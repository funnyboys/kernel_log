commit f4cfa36dab6734466cd5639e0a1d7d753297cba4
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 16 14:41:53 2019 -0800

    dmaengine: ti: omap-dma: Use cpu notifier to block idle for omap2
    
    For omap2, we need to block idle if SDMA is busy. Let's do this with a
    cpu notifier and remove the custom call.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 1581b6a6a416..6953c47d8dc6 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -83,8 +83,6 @@ static int omap2_enter_full_retention(void)
 	l = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) | OMAP24XX_USBSTANDBYCTRL;
 	omap_ctrl_writel(l, OMAP2_CONTROL_DEVCONF0);
 
-	cpu_cluster_pm_enter();
-
 	/* One last check for pending IRQs to avoid extra latency due
 	 * to sleeping unnecessarily. */
 	if (omap_irq_pending())
@@ -96,8 +94,6 @@ static int omap2_enter_full_retention(void)
 			   OMAP_SDRC_REGADDR(SDRC_POWER));
 
 no_sleep:
-	cpu_cluster_pm_exit();
-
 	clk_enable(osc_ck);
 
 	/* clear CORE wake-up events */
@@ -162,25 +158,27 @@ static int omap2_can_sleep(void)
 		return 0;
 	if (__clk_is_enabled(osc_ck))
 		return 0;
-	if (omap_dma_running())
-		return 0;
 
 	return 1;
 }
 
 static void omap2_pm_idle(void)
 {
-	if (!omap2_can_sleep()) {
-		if (omap_irq_pending())
-			return;
-		omap2_enter_mpu_retention();
-		return;
-	}
+	int error;
 
 	if (omap_irq_pending())
 		return;
 
+	error = cpu_cluster_pm_enter();
+	if (error || !omap2_can_sleep()) {
+		omap2_enter_mpu_retention();
+		goto out_cpu_cluster_pm;
+	}
+
 	omap2_enter_full_retention();
+
+out_cpu_cluster_pm:
+	cpu_cluster_pm_exit();
 }
 
 static void __init prcm_setup_regs(void)

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 1298b53ac263..1581b6a6a416 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP2 Power Management Routines
  *
@@ -12,10 +13,6 @@
  * Igor Stoppa <igor.stoppa@nokia.com>
  *
  * Based on pm.c for omap1
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/cpu_pm.h>

commit b764a5863fd834836e65e258303e3a4a81c20f38
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 12:35:31 2018 -0700

    gpio: omap: Remove custom PM calls and use cpu_pm instead
    
    For a long time the gpio-omap custom PM calls have been annoying me so
    let's replace them with cpu_pm instead. This will enable GPIO PM for
    deeper idle states on omap4. And we can handle GPIO PM for omap2/3/4
    in the same way.
    
    Note that with this patch we are also slightly changing GPIO PM to be
    less aggressive for omap3 and only will idle GPIO when PER context
    may be lost.
    
    For omap2, we don't need to save context and don't want to remove any
    triggering so let's add a quirk flag for that.
    
    Let's do this all in a single patch to avoid a situation where old
    custom calls still are used with new code.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Ladislav Michl <ladis@linux-mips.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 2a1a4180d5d0..1298b53ac263 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -18,6 +18,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/cpu_pm.h>
 #include <linux/suspend.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
@@ -29,8 +30,6 @@
 #include <linux/clk-provider.h>
 #include <linux/irq.h>
 #include <linux/time.h>
-#include <linux/gpio.h>
-#include <linux/platform_data/gpio-omap.h>
 
 #include <asm/fncpy.h>
 
@@ -87,7 +86,7 @@ static int omap2_enter_full_retention(void)
 	l = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) | OMAP24XX_USBSTANDBYCTRL;
 	omap_ctrl_writel(l, OMAP2_CONTROL_DEVCONF0);
 
-	omap2_gpio_prepare_for_idle(0);
+	cpu_cluster_pm_enter();
 
 	/* One last check for pending IRQs to avoid extra latency due
 	 * to sleeping unnecessarily. */
@@ -100,7 +99,7 @@ static int omap2_enter_full_retention(void)
 			   OMAP_SDRC_REGADDR(SDRC_POWER));
 
 no_sleep:
-	omap2_gpio_resume_after_idle();
+	cpu_cluster_pm_exit();
 
 	clk_enable(osc_ck);
 

commit f5b00f6f3a05d228479b7c7bb6ec814b07d713fe
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 22 17:05:21 2015 -0700

    ARM: OMAP2+: Include clk.h
    
    These files use the consumer API, so include clk.h explicitly.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b1aad7e1426c..2a1a4180d5d0 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -25,6 +25,7 @@
 #include <linux/sysfs.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/irq.h>
 #include <linux/time.h>

commit 9cb6d36371b0a9935de92bf250c7152f5b50fdc1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:31:51 2014 +0300

    ARM: OMAP2+: PRM: add generic API for clear_mod_irqs
    
    OMAP2/3 now use generic API for the prm_clear_mod_irqs, the SoC specific
    implementation details are provided through prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index fe01c5a03aa2..b1aad7e1426c 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -75,9 +75,9 @@ static int omap2_enter_full_retention(void)
 
 	/* Clear old wake-up events */
 	/* REVISIT: These write to reserved bits? */
-	omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
-	omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
-	omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
+	omap_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+	omap_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
+	omap_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
 
 	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
 	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
@@ -104,18 +104,16 @@ static int omap2_enter_full_retention(void)
 	clk_enable(osc_ck);
 
 	/* clear CORE wake-up events */
-	omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
-	omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
+	omap_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+	omap_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
 
 	/* wakeup domain events - bit 1: GPT1, bit5 GPIO */
-	omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, 0x4 | 0x1);
+	omap_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, 0x4 | 0x1);
 
 	/* MPU domain wake events */
-	omap2xxx_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET,
-				    0x1);
+	omap_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET, 0x1);
 
-	omap2xxx_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET,
-				    0x20);
+	omap_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET, 0x20);
 
 	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
 	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_ON);
@@ -143,9 +141,9 @@ static void omap2_enter_mpu_retention(void)
 	 * it is in retention mode. */
 	if (omap2_allow_mpu_retention()) {
 		/* REVISIT: These write to reserved bits? */
-		omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
-		omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
-		omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
+		omap_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+		omap_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
+		omap_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
 
 		/* Try to enter MPU retention */
 		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);

commit d4e1f5a14e17d4f0e8034c0967511884bcb12fba
Merge: 231bf80f7f14 8850e0ba5721
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 8 11:16:58 2014 -0700

    Merge tag 'dt-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC device-tree changes from Olof Johansson:
     "Unlike the board branch, this keeps having large sets of changes for
      every release, but that's quite expected and is so far working well.
    
      Most of this is plumbing for various device bindings and new
      platforms, but there's also a bit of cleanup and code removal for
      things that are moved from platform code to DT contents (some OMAP
      clock code in particular).
    
      There's also a pinctrl driver for tegra here (appropriately acked),
      that's introduced this way to make it more bisectable.
    
      I'm happy to say that there were no conflicts at all with this branch
      this release, which means that changes are flowing through our tree as
      expected instead of merged through driver maintainers (or at least not
      done with conflicts).
    
      There are several new boards added, and a couple of SoCs.  In no
      particular order:
    
       - Rockchip RK3288 SoC support, including DTS for a dev board that
         they have seeded with some community developers.
       - Better support for Hardkernel Exynos4-based ODROID boards.
       - CCF conversions (and dtsi contents) for several Renesas platforms.
       - Gumstix Pepper (TI AM335x) board support
       - TI eval board support for AM437x
       - Allwinner A23 SoC, very similar to existing ones which mostly has
         resulted in DT changes for support.  Also includes support for an
         Ippo tablet with the chipset.
       - Allwinner A31 Hummingbird board support, not to be confused with
         the SolidRun i.MX-based Hummingboard.
       - Tegra30 Apalis board support"
    
    * tag 'dt-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (334 commits)
      ARM: dts: Enable USB host0 (EHCI) on rk3288-evb
      ARM: dts: add rk3288 ehci usb devices
      ARM: dts: Turn on USB host vbus on rk3288-evb
      ARM: tegra: apalis t30: fix device tree compatible node
      ARM: tegra: paz00: Fix some indentation inconsistencies
      ARM: zynq: DT: Clarify Xilinx Zynq platform
      ARM: dts: rockchip: add watchdog node
      ARM: dts: rockchip: remove pinctrl setting from radxarock uart2
      ARM: dts: Add missing pinctrl for uart0/1 for exynos3250
      ARM: dts: Remove duplicate 'interrput-parent' property for exynos3250
      ARM: dts: Add TMU dt node to monitor the temperature for exynos3250
      ARM: dts: Specify MAX77686 pmic interrupt for exynos5250-smdk5250
      ARM: dts: cypress,cyapa trackpad is exynos5250-Snow only
      ARM: dts: max77686 is exynos5250-snow only
      ARM: zynq: DT: Remove DMA from board DTs
      ARM: zynq: DT: Add CAN node
      ARM: EXYNOS: Add exynos5260 PMU compatible string to DT match table
      ARM: dts: Add PMU DT node for exynos5260 SoC
      ARM: EXYNOS: Add support for Exynos5410 PMU
      ARM: dts: Add PMU to exynos5410
      ...

commit 6bdc4b44b3acc95655b061a88c951c6d9742d8e3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 15:31:05 2014 +0200

    ARM: OMAP24xx: PRM: add API for clearing wakeup status bits
    
    This helps to isolate the PRM into its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index a5ea988ff340..d76694b7a591 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -75,9 +75,9 @@ static int omap2_enter_full_retention(void)
 
 	/* Clear old wake-up events */
 	/* REVISIT: These write to reserved bits? */
-	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
-	omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+	omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+	omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
+	omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
 
 	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
 	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
@@ -104,23 +104,18 @@ static int omap2_enter_full_retention(void)
 	clk_enable(osc_ck);
 
 	/* clear CORE wake-up events */
-	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+	omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+	omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
 
 	/* wakeup domain events - bit 1: GPT1, bit5 GPIO */
-	omap2_prm_clear_mod_reg_bits(0x4 | 0x1, WKUP_MOD, PM_WKST);
+	omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, 0x4 | 0x1);
 
 	/* MPU domain wake events */
-	l = omap2_prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
-	if (l & 0x01)
-		omap2_prm_write_mod_reg(0x01, OCP_MOD,
-				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
-	if (l & 0x20)
-		omap2_prm_write_mod_reg(0x20, OCP_MOD,
-				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	omap2xxx_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET,
+				    0x1);
 
-	/* Mask future PRCM-to-MPU interrupts */
-	omap2_prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	omap2xxx_prm_clear_mod_irqs(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET,
+				    0x20);
 
 	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
 	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_ON);
@@ -148,9 +143,9 @@ static void omap2_enter_mpu_retention(void)
 	 * it is in retention mode. */
 	if (omap2_allow_mpu_retention()) {
 		/* REVISIT: These write to reserved bits? */
-		omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-		omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
-		omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+		omap2xxx_prm_clear_mod_irqs(CORE_MOD, PM_WKST1, ~0);
+		omap2xxx_prm_clear_mod_irqs(CORE_MOD, OMAP24XX_PM_WKST2, ~0);
+		omap2xxx_prm_clear_mod_irqs(WKUP_MOD, PM_WKST, ~0);
 
 		/* Try to enter MPU retention */
 		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);

commit 944ee5dc154b1618d4c794376af237f370c1e6b3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 20 19:09:18 2014 +0200

    ARM: OMAP2: convert sys_ck and osc_ck to standard clock types
    
    osc_ck can be simply defined as a multiplexer clock, and the sys_ck
    can be a simple divider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index a5ea988ff340..d7ac05c6e5e2 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -249,6 +249,10 @@ static void __init prcm_setup_regs(void)
 	/* Enable wake-up events */
 	omap2_prm_write_mod_reg(OMAP24XX_EN_GPIOS_MASK | OMAP24XX_EN_GPT1_MASK,
 				WKUP_MOD, PM_WKEN);
+
+	/* Enable SYS_CLKEN control when all domains idle */
+	omap2_prm_set_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK, OMAP24XX_GR_MOD,
+				   OMAP2_PRCM_CLKSRC_CTRL_OFFSET);
 }
 
 int __init omap2_pm_init(void)

commit 2e4b62dc5e6e2011dbd03ae1a654d990d18d0a14
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Mon May 12 13:33:21 2014 -0500

    ARM: OMAP2+: Remove suspend_set_ops from common pm late init
    
    In omap2_common_pm_late_init suspend_set_ops was called to set common
    suspend handling functions for all omap platforms. This created two
    problems. First, these suspend ops were being set for all platforms,
    regardless of whether or not suspend support has been integrated so in
    the case of AM33XX, suspend to mem was presented as available but
    failed every time. Second, some platforms will need to define a
    completely separate set of suspend ops, such as AM33XX, due to
    differences from previous omap platforms so there is no need to
    always set the common omap ops.
    
    This patch moves the suspend_set_ops call from omap2_common_pm_late_init
    into a separate function that then gets called in the omap*_pm_init
    functions for each platform.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 8c0759496c8d..a5ea988ff340 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -229,9 +229,7 @@ static void __init prcm_setup_regs(void)
 	clkdm_for_each(omap_pm_clkdms_setup, NULL);
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
-#ifdef CONFIG_SUSPEND
-	omap_pm_suspend = omap2_enter_full_retention;
-#endif
+	omap_common_suspend_init(omap2_enter_full_retention);
 
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
 	 * stabilisation */

commit cd6e9db27728e8bcf98cb667996b121761f58121
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Oct 11 19:15:31 2013 +0300

    ARM: OMAP2: CM/PM: remove direct register accesses outside CM code
    
    Users of the CM funtionality should not access the CM registers directly
    by themselves. Thus, added new CM driver APIs for the OMAP2 specific
    functionalities which support the existing direct register accesses, and
    changed the platform code to use these. This is done in preparation
    for moving the CM code into its own individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index ce956b0a7ba4..8c0759496c8d 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -62,16 +62,6 @@ static struct clockdomain *dsp_clkdm, *mpu_clkdm, *wkup_clkdm, *gfx_clkdm;
 
 static struct clk *osc_ck, *emul_ck;
 
-static int omap2_fclks_active(void)
-{
-	u32 f1, f2;
-
-	f1 = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	f2 = omap2_cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
-
-	return (f1 | f2) ? 1 : 0;
-}
-
 static int omap2_enter_full_retention(void)
 {
 	u32 l;
@@ -142,17 +132,7 @@ static int sti_console_enabled;
 
 static int omap2_allow_mpu_retention(void)
 {
-	u32 l;
-
-	/* Check for MMC, UART2, UART1, McSPI2, McSPI1 and DSS1. */
-	l = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	if (l & (OMAP2420_EN_MMC_MASK | OMAP24XX_EN_UART2_MASK |
-		 OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_MCSPI2_MASK |
-		 OMAP24XX_EN_MCSPI1_MASK | OMAP24XX_EN_DSS1_MASK))
-		return 0;
-	/* Check for UART3. */
-	l = omap2_cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
-	if (l & OMAP24XX_EN_UART3_MASK)
+	if (!omap2xxx_cm_mpu_retention_allowed())
 		return 0;
 	if (sti_console_enabled)
 		return 0;
@@ -188,7 +168,7 @@ static void omap2_enter_mpu_retention(void)
 
 static int omap2_can_sleep(void)
 {
-	if (omap2_fclks_active())
+	if (omap2xxx_cm_fclks_active())
 		return 0;
 	if (__clk_is_enabled(osc_ck))
 		return 0;

commit 6b85638b83caac7bae9ffa202391882a9ad4388f
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Feb 11 19:29:45 2013 +0530

    ARM: OMAP2+: PM: Remove bogus fiq_[enable/disable] tuple
    
    On OMAP platform, FIQ is reserved for secure environment only. If at all
    the FIQ needs to be disabled, it involves going through security
    API call. Hence the local_fiq_[enable/disable]() in the OMAP code is bogus.
    On GP devices too, the fiq is disabled for non-secure software.
    
    So just get rid of it.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b59d93908341..ce956b0a7ba4 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -200,22 +200,17 @@ static int omap2_can_sleep(void)
 
 static void omap2_pm_idle(void)
 {
-	local_fiq_disable();
-
 	if (!omap2_can_sleep()) {
 		if (omap_irq_pending())
-			goto out;
+			return;
 		omap2_enter_mpu_retention();
-		goto out;
+		return;
 	}
 
 	if (omap_irq_pending())
-		goto out;
+		return;
 
 	omap2_enter_full_retention();
-
-out:
-	local_fiq_enable();
 }
 
 static void __init prcm_setup_regs(void)

commit 58a656b77a3d352631d058df0ac2a1da92e3a0f0
Merge: 8d61d7f94522 814a18a5d026
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 09:20:50 2013 -0800

    Merge tag 'omap-devel-b-for-3.9' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.9/pm-wfi-take2
    
    On OMAP2+ devices, standardize and clean up WFI entry and WFI blocking.
    
    Basic test logs are available here:
    
       http://www.pwsan.com/omap/testlogs/wfi_devel_a_3.9/20130208085027/
    
    Conflicts:
            arch/arm/mach-omap2/pm24xx.c

commit 1e3d8fe771881de323396aaa1efd20243fa974cb
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Dec 30 10:31:52 2012 -0700

    ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
    
    Use the HWMOD_BLOCK_WFI flag in the hwmod data to prevent the MPU from
    entering WFI when the I2C devices are active.  No idea why this is needed;
    this could certainly bear further investigation if anyone is interested.
    The objective here is to remove some custom code from the OMAP24xx PM
    code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 8914b9e32ee7..bc44bcd64451 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -139,14 +139,6 @@ static int omap2_enter_full_retention(void)
 	return 0;
 }
 
-static int omap2_i2c_active(void)
-{
-	u32 l;
-
-	l = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	return l & (OMAP2420_EN_I2C2_MASK | OMAP2420_EN_I2C1_MASK);
-}
-
 static int sti_console_enabled;
 
 static int omap2_allow_mpu_retention(void)
@@ -173,11 +165,6 @@ static void omap2_enter_mpu_retention(void)
 {
 	const int zero = 0;
 
-	/* Putting MPU into the WFI state while a transfer is active
-	 * seems to cause the I2C block to timeout. Why? Good question. */
-	if (omap2_i2c_active())
-		return;
-
 	/* The peripherals seem not to be able to wake up the MPU when
 	 * it is in retention mode. */
 	if (omap2_allow_mpu_retention()) {

commit 088e8806c411f76216002a8b37c7eb8563614822
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Dec 30 10:15:48 2012 -0700

    ARM: OMAP2xxx: PM: enter WFI via inline asm if CORE stays active
    
    There shouldn't be any need to jump to SRAM code if the OMAP CORE
    clockdomain (and consequently the SDRAM controller and CORE PLL) stays
    active during MPU WFI.  The SRAM code should only be needed when the RAM
    enters self-refresh.  So in the case where CORE stays active, just call
    WFI directly from the mach-omap2/pm24xx.c code.  This removes some
    unnecessary SRAM code.
    
    This second version replaces the inline WFI with the corresponding
    coprocessor register call, using tlbflush.h as an example.  This is
    because the assembler doesn't recognize WFI as a valid ARMv6
    instruction.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Richard Woodruff <r-woodruff2@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c333fa6dffa8..8914b9e32ee7 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -54,7 +54,6 @@
 #include "powerdomain.h"
 #include "clockdomain.h"
 
-static void (*omap2_sram_idle)(void);
 static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,
 				  void __iomem *sdrc_power);
 
@@ -172,6 +171,8 @@ static int omap2_allow_mpu_retention(void)
 
 static void omap2_enter_mpu_retention(void)
 {
+	const int zero = 0;
+
 	/* Putting MPU into the WFI state while a transfer is active
 	 * seems to cause the I2C block to timeout. Why? Good question. */
 	if (omap2_i2c_active())
@@ -196,7 +197,8 @@ static void omap2_enter_mpu_retention(void)
 						 OMAP2_PM_PWSTCTRL);
 	}
 
-	omap2_sram_idle();
+	/* WFI */
+	asm("mcr p15, 0, %0, c7, c0, 4" : : "r" (zero) : "memory", "cc");
 }
 
 static int omap2_can_sleep(void)
@@ -356,11 +358,9 @@ int __init omap2_pm_init(void)
 	/*
 	 * We copy the assembler sleep/wakeup routines to SRAM.
 	 * These routines need to be in SRAM as that's the only
-	 * memory the MPU can see when it wakes up.
+	 * memory the MPU can see when it wakes up after the entire
+	 * chip enters idle.
 	 */
-	omap2_sram_idle = omap_sram_push(omap24xx_idle_loop_suspend,
-					 omap24xx_idle_loop_suspend_sz);
-
 	omap2_sram_suspend = omap_sram_push(omap24xx_cpu_suspend,
 					    omap24xx_cpu_suspend_sz);
 

commit 0e084c9c843320995b0e219f02880f910d439b37
Merge: 7b4bc0799156 562e54d13b6e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 30 14:03:05 2013 -0800

    Merge tag 'omap-cleanup-b-for-3.9' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.9/pm
    
    Several OMAP2+ power management fixes, optimizations, and cleanup.
    This series is a prerequisite for the functional powerdomain
    conversion series.
    
    Basic test logs for this branch are here:
    
        http://www.pwsan.com/omap/testlogs/pm_cleanup_fixes_3.9/20130129150017/

commit f653b29825817a929a606726f03a04fcd0b2b566
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:58:14 2013 -0700

    ARM: OMAP2xxx: PM: clean up some crufty powerstate programming code
    
    Don't attempt to put clockdomains to sleep; this should be handled by the
    clock framework.  It should be enough to program the next-power-state,
    and then let the code in omap_pm_clkdms_setup() deal with the rest.
    
    Start out by programming the MPU and CORE powerdomains to stay ON.
    Then control the MPU and CORE powerdomain states directly in
    omap2_enter_full_retention() and omap2_enter_mpu_retention().  Not the
    most optimal way to do it, but certainly is the most conservative until
    OMAP2xxx PM is working again.
    
    Get rid of the open-coded PM_PWSTCTRL_MPU writes in
    omap2_enter_mpu_retention(); use the powerdomain code instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c333fa6dffa8..5d0f39b490b6 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -90,11 +90,7 @@ static int omap2_enter_full_retention(void)
 	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
 	omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
 
-	/*
-	 * Set MPU powerdomain's next power state to RETENTION;
-	 * preserve logic state during retention
-	 */
-	pwrdm_set_logic_retst(mpu_pwrdm, PWRDM_POWER_RET);
+	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
 	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
 
 	/* Workaround to kill USB */
@@ -137,6 +133,9 @@ static int omap2_enter_full_retention(void)
 	/* Mask future PRCM-to-MPU interrupts */
 	omap2_prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
 
+	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
+	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_ON);
+
 	return 0;
 }
 
@@ -186,17 +185,16 @@ static void omap2_enter_mpu_retention(void)
 		omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
 
 		/* Try to enter MPU retention */
-		omap2_prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
-				  OMAP_LOGICRETSTATE_MASK,
-				  MPU_MOD, OMAP2_PM_PWSTCTRL);
+		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
+
 	} else {
 		/* Block MPU retention */
-
-		omap2_prm_write_mod_reg(OMAP_LOGICRETSTATE_MASK, MPU_MOD,
-						 OMAP2_PM_PWSTCTRL);
+		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
 	}
 
 	omap2_sram_idle();
+
+	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
 }
 
 static int omap2_can_sleep(void)
@@ -251,25 +249,17 @@ static void __init prcm_setup_regs(void)
 	for (i = 0; i < num_mem_banks; i++)
 		pwrdm_set_mem_retst(core_pwrdm, i, PWRDM_POWER_RET);
 
-	/* Set CORE powerdomain's next power state to RETENTION */
-	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
+	pwrdm_set_logic_retst(core_pwrdm, PWRDM_POWER_RET);
 
-	/*
-	 * Set MPU powerdomain's next power state to RETENTION;
-	 * preserve logic state during retention
-	 */
 	pwrdm_set_logic_retst(mpu_pwrdm, PWRDM_POWER_RET);
-	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
 
 	/* Force-power down DSP, GFX powerdomains */
 
 	pwrdm = clkdm_get_pwrdm(dsp_clkdm);
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
-	clkdm_sleep(dsp_clkdm);
 
 	pwrdm = clkdm_get_pwrdm(gfx_clkdm);
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
-	clkdm_sleep(gfx_clkdm);
 
 	/* Enable hardware-supervised idle for all clkdms */
 	clkdm_for_each(omap_pm_clkdms_setup, NULL);

commit aff2f7d90fc6553aa309db2a635d8e5d70d84916
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:56 2013 -0700

    ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
    
    Use the HWMOD_BLOCK_WFI flag in the hwmod data to prevent the MPU from
    entering WFI when the I2C devices are active.  No idea why this is needed;
    this could certainly bear further investigation if anyone is interested.
    The objective here is to remove some custom code from the OMAP24xx PM
    code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c333fa6dffa8..909ef53ba2ea 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -140,14 +140,6 @@ static int omap2_enter_full_retention(void)
 	return 0;
 }
 
-static int omap2_i2c_active(void)
-{
-	u32 l;
-
-	l = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	return l & (OMAP2420_EN_I2C2_MASK | OMAP2420_EN_I2C1_MASK);
-}
-
 static int sti_console_enabled;
 
 static int omap2_allow_mpu_retention(void)
@@ -172,11 +164,6 @@ static int omap2_allow_mpu_retention(void)
 
 static void omap2_enter_mpu_retention(void)
 {
-	/* Putting MPU into the WFI state while a transfer is active
-	 * seems to cause the I2C block to timeout. Why? Good question. */
-	if (omap2_i2c_active())
-		return;
-
 	/* The peripherals seem not to be able to wake up the MPU when
 	 * it is in retention mode. */
 	if (omap2_allow_mpu_retention()) {

commit 45c3eb7d3a07eb08d1b5b0f5983a996d41610b84
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 30 08:41:50 2012 -0800

    ARM: OMAP: Move plat-omap/dma-omap.h to include/linux/omap-dma.h
    
    Based on earlier discussions[1] we attempted to find a suitable
    location for the omap DMA header in commit 2b6c4e73 (ARM: OMAP:
    DMA: Move plat/dma.h to plat-omap/dma-omap.h) until the conversion
    to dmaengine is complete.
    
    Unfortunately that was before I was able to try to test compile
    of the ARM multiplatform builds for omap2+, and the end result
    was not very good.
    
    So I'm creating yet another all over the place patch to cut the
    last dependency for building omap2+ for ARM multiplatform. After
    this, we have finally removed the driver dependencies to the
    arch/arm code, except for few drivers that are being worked on.
    
    The other option was to make the <plat-omap/dma-omap.h> path
    to work, but we'd have to add some new header directory to for
    multiplatform builds.
    
    Or we would have to manually include arch/arm/plat-omap/include
    again from arch/arm/Makefile for omap2+.
    
    Neither of these alternatives sound appealing as they will
    likely lead addition of various other headers exposed to the
    drivers, which we want to avoid for the multiplatform kernels.
    
    Since we already have a minimal include/linux/omap-dma.h,
    let's just use that instead and add a note to it to not
    use the custom omap DMA functions any longer where possible.
    
    Note that converting omap DMA to dmaengine depends on
    dmaengine supporting automatically incrementing the FIFO
    address at the device end, and converting all the remaining
    legacy drivers. So it's going to be few more merge windows.
    
    [1] https://patchwork.kernel.org/patch/1519591/#
    
    cc: Russell King <linux@arm.linux.org.uk>
    cc: Kevin Hilman <khilman@ti.com>
    cc: "Benoît Cousson" <b-cousson@ti.com>
    cc: Herbert Xu <herbert@gondor.apana.org.au>
    cc: "David S. Miller" <davem@davemloft.net>
    cc: Vinod Koul <vinod.koul@intel.com>
    cc: Dan Williams <djbw@fb.com>
    cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    cc: David Woodhouse <dwmw2@infradead.org>
    cc: Kyungmin Park <kyungmin.park@samsung.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    cc: Hans Verkuil <hans.verkuil@cisco.com>
    cc: Vaibhav Hiremath <hvaibhav@ti.com>
    cc: Lokesh Vutla <lokeshvutla@ti.com>
    cc: Rusty Russell <rusty@rustcorp.com.au>
    cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    cc: Afzal Mohammed <afzal@ti.com>
    cc: linux-crypto@vger.kernel.org
    cc: linux-media@vger.kernel.org
    cc: linux-mtd@lists.infradead.org
    cc: linux-usb@vger.kernel.org
    cc: linux-fbdev@vger.kernel.org
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c289b3333c99..c333fa6dffa8 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -38,7 +38,7 @@
 #include <asm/mach-types.h>
 #include <asm/system_misc.h>
 
-#include <plat-omap/dma-omap.h>
+#include <linux/omap-dma.h>
 
 #include "soc.h"
 #include "common.h"

commit 2589d056122f6dcb405d411eae872aac8cf9da1b
Merge: 42a1cc9c0ec2 8b9c1ac2e11a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 30 08:40:31 2012 -0800

    Merge tag 'tags/omap-for-v3.8/devel-prcm-signed' into omap-for-v3.8/cleanup-headers-prepare-multiplatform-v3
    
    omap prcm changes via Paul Walmsley <paul@pwsan.com>:
    
    Some miscellaneous OMAP hwmod changes for 3.8, along with a PRM
    change needed for one of the hwmod patches to function.
    
    Basic test logs for this branch on top of Tony's
    omap-for-v3.8/clock branch at commit
    558a0780b0a04862a678f7823215424b4e5501f9 are here:
    
    http://www.pwsan.com/omap/testlogs/hwmod_devel_a_3.8/20121121161522/
    
    However, omap-for-v3.8/clock at 558a0780 does not include some fixes
    that are needed for a successful test.  With several reverts,
    fixes, and workarounds applied, the following test logs were
    obtained:
    
    http://www.pwsan.com/omap/testlogs/TEST_hwmod_devel_a_3.8/20121121162719/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/cm33xx.c
            arch/arm/mach-omap2/io.c
            arch/arm/mach-omap2/prm_common.c

commit d037e100d138fb522ed0ea3e3a915bd8e0e36f63
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Apr 27 16:55:59 2012 +0530

    ARM: OMAP2: clock: Cleanup !CONFIG_COMMON_CLK parts
    
    Clean all #ifdef's added to OMAP2 clock code to make it COMMON clk
    ready, not that CONFIG_COMMON_CLK is enabled.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: also drop CONFIG_COMMON_CLK tests around APLL recalc_rate
     functions]
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    [paul@pwsan.com: remove some ifdefs in mach-omap2/io.c]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 87ae36c7e155..3d35bd64487c 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -25,11 +25,7 @@
 #include <linux/sysfs.h>
 #include <linux/module.h>
 #include <linux/delay.h>
-#ifdef CONFIG_COMMON_CLK
 #include <linux/clk-provider.h>
-#else
-#include <linux/clk.h>
-#endif
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
@@ -206,11 +202,7 @@ static int omap2_can_sleep(void)
 {
 	if (omap2_fclks_active())
 		return 0;
-#ifdef CONFIG_COMMON_CLK
 	if (__clk_is_enabled(osc_ck))
-#else
-	if (osc_ck->usecount > 1)
-#endif
 		return 0;
 	if (omap_dma_running())
 		return 0;

commit ed1ebc4948fdfe4c68865e5543b4a68e5a55973b
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Apr 27 15:59:32 2012 +0530

    ARM: OMAP2: clock: Convert to common clk
    
    Convert all OMAP2 specific platform files to use COMMON clk
    and keep all the changes under the CONFIG_COMMON_CLK macro check
    so it does not break any existing code. At a later point switch
    to COMMON clk and get rid of all old/legacy code.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 83815ddc4786..87ae36c7e155 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -25,7 +25,11 @@
 #include <linux/sysfs.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#ifdef CONFIG_COMMON_CLK
+#include <linux/clk-provider.h>
+#else
 #include <linux/clk.h>
+#endif
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
@@ -202,7 +206,11 @@ static int omap2_can_sleep(void)
 {
 	if (omap2_fclks_active())
 		return 0;
+#ifdef CONFIG_COMMON_CLK
+	if (__clk_is_enabled(osc_ck))
+#else
 	if (osc_ck->usecount > 1)
+#endif
 		return 0;
 	if (omap_dma_running())
 		return 0;

commit bf027ca13738b1548910351952c3fe9b63263a9a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 13:54:06 2012 -0700

    ARM: OMAP: Split sram.h to local headers and minimal shared header
    
    Most of the defines are specific to omap1 and omap2+,
    and should be in the local headers. Only minimal function
    prototypes need to be shared.
    
    As discussed on linux-arm-kernel, we want to avoid
    relative includes for the arch/arm/*omap* shared code:
    
    http://www.spinics.net/lists/linux-omap/msg80520.html
    
    So this patch re-adds a minimal plat/sram.h.
    
    The new plat/sram.h must not be included from drivers,
    that will break build for omap2+ CONFIG_MULTIPLATFORM.
    
    Note that this patch temporarily adds two more
    relative includes; Those will be removed in the
    following patch.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 6d17e044ffb8..9a2f5594a7dc 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -31,6 +31,8 @@
 #include <linux/gpio.h>
 #include <linux/platform_data/gpio-omap.h>
 
+#include <asm/fncpy.h>
+
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/mach-types.h>
@@ -38,8 +40,6 @@
 
 #include <plat-omap/dma-omap.h>
 
-#include "../plat-omap/sram.h"
-
 #include "soc.h"
 #include "common.h"
 #include "clock.h"
@@ -48,6 +48,7 @@
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-24xx.h"
 #include "sdrc.h"
+#include "sram.h"
 #include "pm.h"
 #include "control.h"
 #include "powerdomain.h"

commit 8634155ef41d3a035f2ea0b6c5bed2806f2788bc
Merge: 6d02643d64b4 2bb2a5d30abb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 17:05:59 2012 -0700

    Merge tag 'omap-cleanup-a-for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8/cleanup-prcm
    
    The first set of OMAP PRM/CM-related cleanup patches for 3.8.
    Prepares for the future move of the PRM/CM code to drivers/.  Also
    includes some prcm.[ch] cleanup patches from the WDTIMER cleanup
    series that don't need external acks.
    
    Basic test logs for this branch on top of v3.7-rc2 are here:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121021123719/
    
    But due to the number of unrelated regressions present in v3.7-rc[12],
    it's not particularly usable as a testing base.  With reverts, fixes,
    and workarounds applied as documented in:
    
    http://www.pwsan.com/omap/testlogs/test_v3.7-rc2/20121020134755/README.txt
    
    the following test logs were obtained:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121020231757/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/Makefile
            arch/arm/mach-omap2/clockdomain2xxx_3xxx.c
            arch/arm/mach-omap2/pm24xx.c

commit ff4ae5d9319b86f940e410e92659c50f9879ff46
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:11 2012 -0600

    ARM: OMAP2+: CM/hwmod: split CM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific CM functions & macros into cm3xxx.[ch] and
    OMAP2xxx-specific macros into cm2xxx.[ch].  Move basic CM register
    access functions into static inline functions in cm2xxx_3xxx.h,
    leaving only OMAP2/3 hardreset functions in cm2xxx_3xxx.c.
    
    As part of this, split the CM and hwmod code that waits for devices to
    become ready into SoC-specific functions.
    
    This is in preparation for the upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 78405a7fb99e..02dca24ec0ab 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -43,7 +43,7 @@
 #include "common.h"
 #include "prm2xxx.h"
 #include "prm-regbits-24xx.h"
-#include "cm2xxx_3xxx.h"
+#include "cm2xxx.h"
 #include "cm-regbits-24xx.h"
 #include "sdrc.h"
 #include "pm.h"

commit 139563ad27e7baad7935b8113940f0d804cf513b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: PRM: split PRM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific PRM functions & macros into prm3xxx.[ch] and
    OMAP2xxx-specific macros into prm2xxx.h.  (prm2xxx.c will be created
    by a subsequent patch when it's needed.)  Move basic PRM register
    access functions into static inline functions in prm2xxx_3xxx.h, leaving
    only OMAP2/3 hardreset functions in prm2xxx_3xxx.c.
    
    Also clarify the initcall function naming to reinforce that this code
    is specifically for the PRM IP block.
    
    This is in preparation for the upcoming powerdomain series and the
    upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 8af6cd6ac331..78405a7fb99e 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -41,7 +41,7 @@
 #include <plat/dma.h>
 
 #include "common.h"
-#include "prm2xxx_3xxx.h"
+#include "prm2xxx.h"
 #include "prm-regbits-24xx.h"
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-24xx.h"

commit e4c060db2c13f10de09101afc564763f9fd0019a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 5 13:25:59 2012 -0700

    ARM: OMAP: Split plat/cpu.h into local soc.h for mach-omap1 and mach-omap2
    
    We want to remove plat/cpu.h. To do this, let's first split
    it to private soc.h to mach-omap1 and mach-omap2. We have to
    keep plat/cpu.h around until the remaining drivers are fixed,
    so let's include the local soc.h in plat/cpu.h and for drivers
    still including plat/cpu.h.
    
    Once the drivers are fixed not to include plat/cpu.h, we
    can remove the file.
    
    This is needed for the ARM common zImage support.
    
    [tony@atomide.com: updated to not print a warning]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index be8989e6d78c..6d17e044ffb8 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -40,6 +40,7 @@
 
 #include "../plat-omap/sram.h"
 
+#include "soc.h"
 #include "common.h"
 #include "clock.h"
 #include "prm2xxx_3xxx.h"

commit a135eaae524acba1509a3b19c97fae556e4da7cd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:34 2012 -0600

    ARM: OMAP: remove plat/clock.h
    
    Remove arch/arm/plat-omap/include/plat/clock.h by merging it into
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h.
    The goal here is to facilitate ARM single image kernels by removing
    includes via the "plat/" symlink.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fixed to remove duplicate clock.h includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 94c838e0175b..be8989e6d78c 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -36,12 +36,12 @@
 #include <asm/mach-types.h>
 #include <asm/system_misc.h>
 
-#include <plat/clock.h>
 #include <plat-omap/dma-omap.h>
 
 #include "../plat-omap/sram.h"
 
 #include "common.h"
+#include "clock.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"
 #include "cm2xxx_3xxx.h"

commit 622297fdec22310d57cc3222a8fc337993c7cd23
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 14:19:52 2012 -0700

    ARM: OMAP: Make plat/sram.h local to plat-omap
    
    We can move this from plat to be local to plat-omap
    for common ARM zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 601a49bc264c..94c838e0175b 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -37,9 +37,10 @@
 #include <asm/system_misc.h>
 
 #include <plat/clock.h>
-#include <plat/sram.h>
 #include <plat-omap/dma-omap.h>
 
+#include "../plat-omap/sram.h"
+
 #include "common.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"

commit 2b6c4e73248758bac8e1ed81b0d0664da0fff6f8
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Mon Oct 15 14:04:53 2012 -0700

    ARM: OMAP: DMA: Move plat/dma.h to plat-omap/dma-omap.h
    
    Move plat/dma.h to plat-omap/dma-omap.h as part of single
    zImage work
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 8af6cd6ac331..601a49bc264c 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -38,7 +38,7 @@
 
 #include <plat/clock.h>
 #include <plat/sram.h>
-#include <plat/dma.h>
+#include <plat-omap/dma-omap.h>
 
 #include "common.h"
 #include "prm2xxx_3xxx.h"

commit 7d7e1eba7e92c2f9c76db80adc24836e7a114bfb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 27 17:43:01 2012 -0700

    ARM: OMAP2+: Prepare for irqs.h removal
    
    As the interrupts should only be defined in the platform_data, and
    eventually coming from device tree, there's no need to define them
    in header files.
    
    Let's remove the hardcoded references to irqs.h and fix up the includes
    so we don't rely on headers included in irqs.h. Note that we're
    defining OMAP_INTC_START as 0 to the interrupts. This will be needed
    when we enable SPARSE_IRQ. For some drivers we need to add
    #include <plat/cpu.h> for now until these drivers are fixed to
    remove cpu_is_omapxxxx() usage.
    
    While at it, sort som of the includes the standard way, and add
    the trailing commas where they are missing in the related data
    structures.
    
    Note that for drivers/staging/tidspbridge we just define things
    locally.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 2708a8b7a39b..8af6cd6ac331 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -40,8 +40,6 @@
 #include <plat/sram.h>
 #include <plat/dma.h>
 
-#include <mach/irqs.h>
-
 #include "common.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"

commit 4b25408f1f61c35b70a19a41053b5e5e3224e97f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Aug 30 15:37:24 2012 -0700

    ARM: OMAP: Move gpio.h to include/linux/platform_data
    
    This way we can remove includes of plat/gpio.h which won't work
    with the single zImage support.
    
    Note that we also remove the cpu_class_is_omap2() check
    in gpio-omap.c as the drivers should not call it as we need to
    make it local to arch/arm/mach-omap2 for single zImage support.
    
    While at it, arrange the related includes in the standard way.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: linux-mtd@lists.infradead.org
    Cc: alsa-devel@alsa-project.org
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index de1caf15ab78..2708a8b7a39b 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -29,6 +29,7 @@
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
+#include <linux/platform_data/gpio-omap.h>
 
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>

commit cf3a6ec2c0a499ef019d25d4dbc79df66e7d3f0c
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Wed Aug 29 02:18:57 2012 +0300

    ARM: OMAP: remove plat/board.h file
    
    plat/board.h file is now empty - remove it.
    
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: linux-mmc@vger.kernel.org
    Cc: linux-mtd@lists.infradead.org
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 9e54dc917abd..de1caf15ab78 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -38,7 +38,6 @@
 #include <plat/clock.h>
 #include <plat/sram.h>
 #include <plat/dma.h>
-#include <plat/board.h>
 
 #include <mach/irqs.h>
 

commit b61968e5cfbc511cefb7567e2d3e2fb722b35c61
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Wed Aug 29 02:18:51 2012 +0300

    ARM: OMAP: remove the sti console workaround
    
    The sti console workaround uses the OMAP custom tags.
    Those tags are not used in upstream kernel and therefore the workaround
    never fires on upstream kernels.
    Remove the sti console workaround tags part.
    This leaves the workaround functional part intact so can be reused if
    needed.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 2edeffc923a6..9e54dc917abd 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -352,16 +352,6 @@ int __init omap2_pm_init(void)
 
 	prcm_setup_regs();
 
-	/* Hack to prevent MPU retention when STI console is enabled. */
-	{
-		const struct omap_sti_console_config *sti;
-
-		sti = omap_get_config(OMAP_TAG_STI_CONSOLE,
-				      struct omap_sti_console_config);
-		if (sti != NULL && sti->enable)
-			sti_console_enabled = 1;
-	}
-
 	/*
 	 * We copy the assembler sleep/wakeup routines to SRAM.
 	 * These routines need to be in SRAM as that's the only

commit f465d145d76803fe6332092775d891c8c509aa44
Merge: 30b842889eea 80b9abf97346
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 26 13:14:01 2012 -0700

    Merge tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull sweeping late_initcall cleanup for arm-soc from Olof Johansson:
     "This is a patch series from Shawn Guo that moves from individual
      late_initcalls() to using a member in the machine structure to invoke
      a platform's late initcalls.
    
      This cleanup is a step in the move towards multiplatform kernels since
      it would reduce the need to check for compatible platforms in each and
      every initcall."
    
    Fix up trivial conflicts in arch/arm/mach-{exynos/mach-universal_c210.c,
    imx/mach-cpuimx51.c, omap2/board-generic.c} due to changes nearby (and,
    in the case of cpuimx51.c the board support being deleted)
    
    * tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: ux500: use machine specific hook for late init
      ARM: tegra: use machine specific hook for late init
      ARM: shmobile: use machine specific hook for late init
      ARM: sa1100: use machine specific hook for late init
      ARM: s3c64xx: use machine specific hook for late init
      ARM: prima2: use machine specific hook for late init
      ARM: pnx4008: use machine specific hook for late init
      ARM: omap2: use machine specific hook for late init
      ARM: omap1: use machine specific hook for late init
      ARM: msm: use machine specific hook for late init
      ARM: imx: use machine specific hook for late init
      ARM: exynos: use machine specific hook for late init
      ARM: ep93xx: use machine specific hook for late init
      ARM: davinci: use machine specific hook for late init
      ARM: provide a late_initcall hook for platform initialization

commit bbd707acee279a61177a604822db92e8164d00db
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 26 16:06:50 2012 +0800

    ARM: omap2: use machine specific hook for late init
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 95442b69ae27..b2758b83a0a6 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -301,13 +301,10 @@ static void __init prcm_setup_regs(void)
 				WKUP_MOD, PM_WKEN);
 }
 
-static int __init omap2_pm_init(void)
+int __init omap2_pm_init(void)
 {
 	u32 l;
 
-	if (!cpu_is_omap24xx())
-		return -ENODEV;
-
 	printk(KERN_INFO "Power Management for OMAP2 initializing\n");
 	l = omap2_prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_REVISION_OFFSET);
 	printk(KERN_INFO "PRCM revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
@@ -373,17 +370,13 @@ static int __init omap2_pm_init(void)
 	 * These routines need to be in SRAM as that's the only
 	 * memory the MPU can see when it wakes up.
 	 */
-	if (cpu_is_omap24xx()) {
-		omap2_sram_idle = omap_sram_push(omap24xx_idle_loop_suspend,
-						 omap24xx_idle_loop_suspend_sz);
+	omap2_sram_idle = omap_sram_push(omap24xx_idle_loop_suspend,
+					 omap24xx_idle_loop_suspend_sz);
 
-		omap2_sram_suspend = omap_sram_push(omap24xx_cpu_suspend,
-						    omap24xx_cpu_suspend_sz);
-	}
+	omap2_sram_suspend = omap_sram_push(omap24xx_cpu_suspend,
+					    omap24xx_cpu_suspend_sz);
 
 	arm_pm_idle = omap2_pm_idle;
 
 	return 0;
 }
-
-late_initcall(omap2_pm_init);

commit eeb3711b89d68e147e05e7b43a49ecc5009dc157
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Apr 13 06:34:32 2012 -0600

    ARM: OMAP2+: clean up some cppcheck warnings
    
    Resolve some warnings identified by cppcheck in arch/arm/mach-omap2:
    
        [arch/arm/mach-omap2/usb-tusb6010.c:129]: (style) Checking if unsigned variable 'tmp' is less than zero.
        [arch/arm/mach-omap2/prm_common.c:241]: (error) Possible null pointer dereference: irq_setup - otherwise it is redundant to check if irq_setup is null at line 247
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'per_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'core_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm24xx.c:185]: (style) Variable 'only_idle' is assigned a value that is never used
        [arch/arm/mach-omap2/mux.c:254]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/mux.c:258]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/gpmc-onenand.c:178]: (style) Variable 'tick_ns' is assigned a value that is never used
        [arch/arm/mach-omap2/gpio.c:56]: (error) Possible null pointer dereference: pdata - otherwise it is redundant to check if pdata is null at line 57
        [arch/arm/mach-omap2/devices.c:45]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/board-omap3evm.c:641] -> [arch/arm/mach-omap2/board-omap3evm.c:639]: (style) Found duplicate branches for if and else.
        [arch/arm/mach-omap2/am35xx-emac.c:95]: (style) Variable 'regval' is assigned a value that is never used
        [arch/arm/mach-omap2/devices.c:74]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:277]: (style) Variable 'per_prev_state' is assigned a value that is never used
        [arch/arm/plat-omap/dmtimer.c:352]: (error) Possible null pointer dereference: timer - otherwise it is redundant to check if timer is null at line 354
        [arch/arm/plat-omap/omap_device.c:478]: (style) Variable 'c' is assigned a value that is never used
        [arch/arm/plat-omap/usb.c:42]: (style) Variable 'status' is assigned a value that is never used
        [arch/arm/mach-omap1/clock.c:197]: (style) Variable 'dpll1_rate' is assigned a value that is never used
        [arch/arm/mach-omap1/lcd_dma.c:60]: (style) struct or union member 'lcd_dma_info::size' is never used
        [arch/arm/mach-omap1/pm.c:572]: (style) Variable 'entry' is assigned a value that is never used
    
    Some of them are pretty good catches, such as gpio.c:56 and
    usb-tusb6010.c:129.
    
    Thanks to Jarkko Nikula for some comments on the sscanf() warnings.
    It seems that the kernel sscanf() ignores the field width anyway for the
    %d format, so those changes have been dropped from this second version.
    
    Thanks to Daniel Marjamäki <daniel.marjamaki@gmail.com> for pointing
    out that a variable was unnecessarily marked static in the
    board-omap3evm.c change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Charulatha Varadarajan <charu@ti.com>
    Cc: Daniel Marjamäki <daniel.marjamaki@gmail.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Charulatha Varadarajan <charu@ti.com> # for gpio.c

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 95442b69ae27..facfffca9eac 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -171,8 +171,6 @@ static int omap2_allow_mpu_retention(void)
 
 static void omap2_enter_mpu_retention(void)
 {
-	int only_idle = 0;
-
 	/* Putting MPU into the WFI state while a transfer is active
 	 * seems to cause the I2C block to timeout. Why? Good question. */
 	if (omap2_i2c_active())
@@ -195,7 +193,6 @@ static void omap2_enter_mpu_retention(void)
 
 		omap2_prm_write_mod_reg(OMAP_LOGICRETSTATE_MASK, MPU_MOD,
 						 OMAP2_PM_PWSTCTRL);
-		only_idle = 1;
 	}
 
 	omap2_sram_idle();

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 23de98d03841..730bb009587f 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -34,6 +34,7 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/mach-types.h>
+#include <asm/system_misc.h>
 
 #include <mach/irqs.h>
 #include <plat/clock.h>

commit 1416408d31236dc2a80d269aa23ffa93aa01e833
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Feb 2 02:30:50 2012 -0700

    ARM: OMAP2+: PM: share some suspend-related functions across OMAP2, 3, 4
    
    The platform_suspend_ops can be shared across OMAP2, 3, and 4, along
    with all of the functions referenced in that structure.  This patch
    shares them.  It also removes the suspend_state file-scoped variable
    in the OMAP2 and 3 PM code; it does not appear to be actually needed
    by anything.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [khilman@ti.com: minor rework needed due to rebase/merge with conflicting changes]
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c4fdde477421..5ca45ca76946 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -52,19 +52,6 @@
 #include "powerdomain.h"
 #include "clockdomain.h"
 
-#ifdef CONFIG_SUSPEND
-static suspend_state_t suspend_state = PM_SUSPEND_ON;
-static inline bool is_suspending(void)
-{
-	return (suspend_state != PM_SUSPEND_ON);
-}
-#else
-static inline bool is_suspending(void)
-{
-	return false;
-}
-#endif
-
 static void (*omap2_sram_idle)(void);
 static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,
 				  void __iomem *sdrc_power);
@@ -84,7 +71,7 @@ static int omap2_fclks_active(void)
 	return (f1 | f2) ? 1 : 0;
 }
 
-static void omap2_enter_full_retention(void)
+static int omap2_enter_full_retention(void)
 {
 	u32 l;
 
@@ -147,6 +134,8 @@ static void omap2_enter_full_retention(void)
 
 	/* Mask future PRCM-to-MPU interrupts */
 	omap2_prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+
+	return 0;
 }
 
 static int omap2_i2c_active(void)
@@ -243,46 +232,6 @@ static void omap2_pm_idle(void)
 	local_fiq_enable();
 }
 
-#ifdef CONFIG_SUSPEND
-static int omap2_pm_begin(suspend_state_t state)
-{
-	disable_hlt();
-	suspend_state = state;
-	return 0;
-}
-
-static int omap2_pm_enter(suspend_state_t state)
-{
-	int ret = 0;
-
-	switch (state) {
-	case PM_SUSPEND_STANDBY:
-	case PM_SUSPEND_MEM:
-		omap2_enter_full_retention();
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static void omap2_pm_end(void)
-{
-	suspend_state = PM_SUSPEND_ON;
-	enable_hlt();
-}
-
-static const struct platform_suspend_ops omap_pm_ops = {
-	.begin		= omap2_pm_begin,
-	.enter		= omap2_pm_enter,
-	.end		= omap2_pm_end,
-	.valid		= suspend_valid_only_mem,
-};
-#else
-static const struct platform_suspend_ops __initdata omap_pm_ops;
-#endif /* CONFIG_SUSPEND */
-
 static void __init prcm_setup_regs(void)
 {
 	int i, num_mem_banks;
@@ -327,6 +276,10 @@ static void __init prcm_setup_regs(void)
 	clkdm_for_each(omap_pm_clkdms_setup, NULL);
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
+#ifdef CONFIG_SUSPEND
+	omap_pm_suspend = omap2_enter_full_retention;
+#endif
+
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
 	 * stabilisation */
 	omap2_prm_write_mod_reg(15 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
@@ -427,7 +380,6 @@ static int __init omap2_pm_init(void)
 						    omap24xx_cpu_suspend_sz);
 	}
 
-	suspend_set_ops(&omap_pm_ops);
 	arm_pm_idle = omap2_pm_idle;
 
 	return 0;

commit 92206fd292da7632c039f6c4054bdaac08b030c0
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Feb 2 02:38:50 2012 -0700

    ARM: OMAP2+: PM: share clkdms_setup() across OMAP2, 3, 4
    
    clkdms_setup() is identical across OMAP2, 3, and 4, so share it.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 36c587f4981b..c4fdde477421 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -283,17 +283,6 @@ static const struct platform_suspend_ops omap_pm_ops = {
 static const struct platform_suspend_ops __initdata omap_pm_ops;
 #endif /* CONFIG_SUSPEND */
 
-/* XXX This function should be shareable between OMAP2xxx and OMAP3 */
-static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
-{
-	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
-		clkdm_allow_idle(clkdm);
-	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
-		 atomic_read(&clkdm->usecount) == 0)
-		clkdm_sleep(clkdm);
-	return 0;
-}
-
 static void __init prcm_setup_regs(void)
 {
 	int i, num_mem_banks;
@@ -335,7 +324,7 @@ static void __init prcm_setup_regs(void)
 	clkdm_sleep(gfx_clkdm);
 
 	/* Enable hardware-supervised idle for all clkdms */
-	clkdm_for_each(clkdms_setup, NULL);
+	clkdm_for_each(omap_pm_clkdms_setup, NULL);
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk

commit 015f1e4297ad32f83251f3f4cee2389ce5516e9e
Merge: 1b35af54ee9c 9cf793f9b8b1
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 5 15:37:04 2012 -0800

    Merge remote-tracking branch 'omap/hsmmc' into for_3.4/cleanup/pm-base

commit a5bee307ba7befc96a97915d6d45ffbe1e5f9a20
Merge: 0aac881246fb acea7c7b81e8
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Feb 28 14:27:01 2012 -0800

    Merge branch 'iomap' into cleanup

commit 2c799cef4d145af2182594a41cb5e5b42f2535c5
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP: Remove plat/io.h by splitting it into mach/io.h and mach/hardware.h
    
    This is needed to minimize io.h so the SoC specific io.h
    for ARMs can removed.
    
    Note that minimal driver changes for DSS and RNG are needed to
    include cpu.h for SoC detection macros.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 423a9a957b84..7e367225d250 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -26,7 +26,6 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
-#include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
@@ -42,7 +41,6 @@
 
 #include <mach/irqs.h>
 
-#include "iomap.h"
 #include "common.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"

commit ee0839c22cdda7f2e5f06e2d0351e2b49e0975ff
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP2+: Move most of plat/io.h into local iomap.h
    
    There's no need to have these defines in plat/io.h.
    
    Note that we now need to ifdef omap_read/write calls
    as they will be available for omap1 only.
    
    While at it, clean up the includes to group them like
    they typically are grouped.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 6d63973c7f15..423a9a957b84 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -35,12 +35,14 @@
 #include <asm/mach/irq.h>
 #include <asm/mach-types.h>
 
-#include <mach/irqs.h>
 #include <plat/clock.h>
 #include <plat/sram.h>
 #include <plat/dma.h>
 #include <plat/board.h>
 
+#include <mach/irqs.h>
+
+#include "iomap.h"
 #include "common.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"
@@ -49,7 +51,6 @@
 #include "sdrc.h"
 #include "pm.h"
 #include "control.h"
-
 #include "powerdomain.h"
 #include "clockdomain.h"
 

commit 645c56a75882830c0ba6e7461f07d099a9c87e69
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 24 10:34:32 2012 -0800

    ARM: OMAP2xxx: PM: remove obsolete timer disable code in the suspend path
    
    Remove omap_{read,write}l() from the 24xx PM code.  The clocksource
    code should now handle what this was supposed to do.
    
    Tested on N800 -- but it's hard to say whether this fixes anything.
    OMAP24xx static suspend path is currently broken, and this patch
    doesn't change that.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rob Herring <robherring2@gmail.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b8822f8b2891..6d63973c7f15 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -260,26 +260,6 @@ static int omap2_pm_begin(suspend_state_t state)
 	return 0;
 }
 
-static int omap2_pm_suspend(void)
-{
-	u32 wken_wkup, mir1;
-
-	wken_wkup = omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
-	wken_wkup &= ~OMAP24XX_EN_GPT1_MASK;
-	omap2_prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
-
-	/* Mask GPT1 */
-	mir1 = omap_readl(0x480fe0a4);
-	omap_writel(1 << 5, 0x480fe0ac);
-
-	omap2_enter_full_retention();
-
-	omap_writel(mir1, 0x480fe0a4);
-	omap2_prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
-
-	return 0;
-}
-
 static int omap2_pm_enter(suspend_state_t state)
 {
 	int ret = 0;
@@ -287,7 +267,7 @@ static int omap2_pm_enter(suspend_state_t state)
 	switch (state) {
 	case PM_SUSPEND_STANDBY:
 	case PM_SUSPEND_MEM:
-		ret = omap2_pm_suspend();
+		omap2_enter_full_retention();
 		break;
 	default:
 		ret = -EINVAL;

commit 1e056dddabc1b7a909d1f992fefb1d5d5bc8ff0d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Feb 9 18:24:03 2012 -0700

    ARM: OMAP2xxx: PM: fix OMAP2xxx-specific UART idle bug in v3.3
    
    On OMAP2420-based systems, the PM code ignores the state of the UART
    functional clocks when determining what idle state to enter.  This
    breaks the serial port now that the UART driver's clock behavior can
    be controlled via the PM autosuspend timeout.
    
    To fix, remove the special-case idle handling for the UARTs in the
    OMAP2420/2430 PM idle code added by commit
    4af4016c53f52b26461b8030211f8427a58fa5ed ("OMAP3: PM: UART: disable
    clocks when idle and off-mode support").
    
    Tested on Nokia N800.  This patch is a collaboration between Tony
    Lindgren <tony@atomide.com> and Paul Walmsley <paul@pwsan.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b8822f8b2891..23de98d03841 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -82,13 +82,7 @@ static int omap2_fclks_active(void)
 	f1 = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	f2 = omap2_cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
 
-	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
-	f1 &= ~(OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_UART2_MASK);
-	f2 &= ~OMAP24XX_EN_UART3_MASK;
-
-	if (f1 | f2)
-		return 1;
-	return 0;
+	return (f1 | f2) ? 1 : 0;
 }
 
 static void omap2_enter_full_retention(void)

commit 0bcd24b0f414003c695e2ecf16b9ffa14d184f48
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Jan 4 16:27:48 2012 -0500

    ARM: OMAP: convert idle handlers from pm_idle to arm_pm_idle
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b8822f8b2891..1f736222a629 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -232,7 +232,6 @@ static int omap2_can_sleep(void)
 
 static void omap2_pm_idle(void)
 {
-	local_irq_disable();
 	local_fiq_disable();
 
 	if (!omap2_can_sleep()) {
@@ -249,7 +248,6 @@ static void omap2_pm_idle(void)
 
 out:
 	local_fiq_enable();
-	local_irq_enable();
 }
 
 #ifdef CONFIG_SUSPEND
@@ -468,7 +466,7 @@ static int __init omap2_pm_init(void)
 	}
 
 	suspend_set_ops(&omap_pm_ops);
-	pm_idle = omap2_pm_idle;
+	arm_pm_idle = omap2_pm_idle;
 
 	return 0;
 }

commit 2fd149645eb46d26130d7070c6de037dddf34880
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Wed Nov 9 17:41:21 2011 +0530

    ARM: OMAP2+: UART: Remove omap_uart_can_sleep and add pm_qos
    
    Omap_uart_can_sleep function blocks system wide low power state until
    uart is active remove this func and add qos requests to prevent
    MPU from transitioning.
    
    Keep qos request to default value which will allow MPU to transition
    and while uart baud rate is available calculate the latency value
    from the baudrate and use the same to hold constraint while uart clocks
    are enabled, and if uart is auto-idled the constraint is updated with
    default constraint value allowing MPU to transition.
    
    Qos requests are blocking notifier calls so put these requests to
    work queue, also the driver uses irq_safe version of runtime API's
    and callbacks can be called in interrupt disabled context.
    So to avoid warn on slow path warning while using qos update
    API's from runtime callbacks use the qos_work_queue.
    
    During bootup the runtime_resume call backs might not be called and runtime
    callback gets called only after uart is idled by setting the autosuspend
    timeout. So qos_request from runtime resume callback might not activated during
    boot if uart baudrate is calculated during bootup for console uart, so schedule
    the qos_work queue once we calc_latency while configuring the uart port.
    
    Flush and complete any pending qos jobs in work queue while suspending.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de> (for drivers/tty changes)
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 22af2f2fdbf9..b8822f8b2891 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -222,8 +222,6 @@ static int omap2_can_sleep(void)
 {
 	if (omap2_fclks_active())
 		return 0;
-	if (!omap_uart_can_sleep())
-		return 0;
 	if (osc_ck->usecount > 1)
 		return 0;
 	if (omap_dma_running())

commit 8384c9749f8c31c6e1e64a63c8d50af7863ce657
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Wed Nov 9 17:22:30 2011 +0530

    ARM: OMAP2+: UART: cleanup + remove uart pm specific API
    
    In preparation to UART runtime conversion remove uart specific calls
    from pm24xx/34xx files and their definition from serial.c
    These func calls will no more be used with upcoming uart runtime design.
    
    1.) omap_uart_prepare_suspend :- can be taken care with driver suspend hooks.
    2.) omap_uart_enable_irqs :- Used to enable/disable uart irq's in suspend
        path from PM code, this is removed as same is handled by
        uart_suspend_port/uart_resume_port in omap-serial driver which will
        do an port_shutdown on suspend freeing irq and port_startup on resume
        enabling back irq.
    3.) Remove prepare_idle/resume_idle calls used to gate uart clocks.
        UART clocks can be gated within driver using runtime funcs
        and be woken up using irq_chaining from omap_prm driver.
    4.) Remove console_locking from idle path as clock gating is done withing
        driver itself with runtime API. Remove is_suspending check used to acquire
        console_lock.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index ef8595c80296..22af2f2fdbf9 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -30,7 +30,6 @@
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
-#include <linux/console.h>
 
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
@@ -127,27 +126,11 @@ static void omap2_enter_full_retention(void)
 	if (omap_irq_pending())
 		goto no_sleep;
 
-	/* Block console output in case it is on one of the OMAP UARTs */
-	if (!is_suspending())
-		if (!console_trylock())
-			goto no_sleep;
-
-	omap_uart_prepare_idle(0);
-	omap_uart_prepare_idle(1);
-	omap_uart_prepare_idle(2);
-
 	/* Jump to SRAM suspend code */
 	omap2_sram_suspend(sdrc_read_reg(SDRC_DLLA_CTRL),
 			   OMAP_SDRC_REGADDR(SDRC_DLLA_CTRL),
 			   OMAP_SDRC_REGADDR(SDRC_POWER));
 
-	omap_uart_resume_idle(2);
-	omap_uart_resume_idle(1);
-	omap_uart_resume_idle(0);
-
-	if (!is_suspending())
-		console_unlock();
-
 no_sleep:
 	omap2_gpio_resume_after_idle();
 
@@ -291,7 +274,6 @@ static int omap2_pm_suspend(void)
 	mir1 = omap_readl(0x480fe0a4);
 	omap_writel(1 << 5, 0x480fe0ac);
 
-	omap_uart_prepare_suspend();
 	omap2_enter_full_retention();
 
 	omap_writel(mir1, 0x480fe0a4);

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index cf0c216132ab..ef8595c80296 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -42,6 +42,7 @@
 #include <plat/dma.h>
 #include <plat/board.h>
 
+#include "common.h"
 #include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"
 #include "cm2xxx_3xxx.h"

commit 12234f39a2067887802e799fd45c3c41dd26e187
Author: Michael Jones <michael.jones@matrix-vision.de>
Date:   Mon Aug 8 09:46:20 2011 +0200

    OMAP2: PM debug: remove leftover debug code
    
    commit 20d5d5514981f9a68832bffb27a698545ecba77a (OMAP2: PM debug:
    remove register dumping) left some code lying around which doesn't
    do anything. Clean it up.
    
    Signed-off-by: Michael Jones <michael.jones@matrix-vision.de>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index bf089e743ed9..cf0c216132ab 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -53,8 +53,6 @@
 #include "powerdomain.h"
 #include "clockdomain.h"
 
-static int omap2_pm_debug;
-
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state = PM_SUSPEND_ON;
 static inline bool is_suspending(void)
@@ -96,7 +94,6 @@ static int omap2_fclks_active(void)
 static void omap2_enter_full_retention(void)
 {
 	u32 l;
-	struct timespec ts_preidle, ts_postidle, ts_idle;
 
 	/* There is 1 reference hold for all children of the oscillator
 	 * clock, the following will remove it. If no one else uses the
@@ -124,10 +121,6 @@ static void omap2_enter_full_retention(void)
 
 	omap2_gpio_prepare_for_idle(0);
 
-	if (omap2_pm_debug) {
-		getnstimeofday(&ts_preidle);
-	}
-
 	/* One last check for pending IRQs to avoid extra latency due
 	 * to sleeping unnecessarily. */
 	if (omap_irq_pending())
@@ -155,13 +148,6 @@ static void omap2_enter_full_retention(void)
 		console_unlock();
 
 no_sleep:
-	if (omap2_pm_debug) {
-		unsigned long long tmp;
-
-		getnstimeofday(&ts_postidle);
-		ts_idle = timespec_sub(ts_postidle, ts_preidle);
-		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
-	}
 	omap2_gpio_resume_after_idle();
 
 	clk_enable(osc_ck);
@@ -219,7 +205,6 @@ static int omap2_allow_mpu_retention(void)
 static void omap2_enter_mpu_retention(void)
 {
 	int only_idle = 0;
-	struct timespec ts_preidle, ts_postidle, ts_idle;
 
 	/* Putting MPU into the WFI state while a transfer is active
 	 * seems to cause the I2C block to timeout. Why? Good question. */
@@ -246,19 +231,7 @@ static void omap2_enter_mpu_retention(void)
 		only_idle = 1;
 	}
 
-	if (omap2_pm_debug) {
-		getnstimeofday(&ts_preidle);
-	}
-
 	omap2_sram_idle();
-
-	if (omap2_pm_debug) {
-		unsigned long long tmp;
-
-		getnstimeofday(&ts_postidle);
-		ts_idle = timespec_sub(ts_postidle, ts_preidle);
-		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
-	}
 }
 
 static int omap2_can_sleep(void)

commit 20d5d5514981f9a68832bffb27a698545ecba77a
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu May 26 14:07:41 2011 -0700

    OMAP2: PM debug: remove register dumping
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index df3ded6fe194..bf089e743ed9 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -53,6 +53,8 @@
 #include "powerdomain.h"
 #include "clockdomain.h"
 
+static int omap2_pm_debug;
+
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state = PM_SUSPEND_ON;
 static inline bool is_suspending(void)
@@ -123,7 +125,6 @@ static void omap2_enter_full_retention(void)
 	omap2_gpio_prepare_for_idle(0);
 
 	if (omap2_pm_debug) {
-		omap2_pm_dump(0, 0, 0);
 		getnstimeofday(&ts_preidle);
 	}
 
@@ -160,7 +161,6 @@ static void omap2_enter_full_retention(void)
 		getnstimeofday(&ts_postidle);
 		ts_idle = timespec_sub(ts_postidle, ts_preidle);
 		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
-		omap2_pm_dump(0, 1, tmp);
 	}
 	omap2_gpio_resume_after_idle();
 
@@ -247,7 +247,6 @@ static void omap2_enter_mpu_retention(void)
 	}
 
 	if (omap2_pm_debug) {
-		omap2_pm_dump(only_idle ? 2 : 1, 0, 0);
 		getnstimeofday(&ts_preidle);
 	}
 
@@ -259,7 +258,6 @@ static void omap2_enter_mpu_retention(void)
 		getnstimeofday(&ts_postidle);
 		ts_idle = timespec_sub(ts_postidle, ts_preidle);
 		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
-		omap2_pm_dump(only_idle ? 2 : 1, 1, tmp);
 	}
 }
 

commit a2358a7bc35e388978fc2f7f6b071a0fd27d78c1
Merge: 94a06b74e724 a08572ae529b
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 11 09:20:03 2011 -0800

    Merge branch 'integration-2.6.39-for-tony' of git://git.pwsan.com/linux-integration into omap-for-linus
    
    Conflicts:
            arch/arm/mach-omap2/pm34xx.c

commit 51d070afd6f927752c76a0cc537c73737578bb93
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jan 27 02:52:55 2011 -0700

    OMAP2/3: PM: remove unnecessary wakeup/sleep dependency clear
    
    The OMAP2 and OMAP3 PM code clears clockdomain wakeup and sleep
    dependencies.  This is unnecessary after commit
    6f7f63cc9adf3192e6fcac4e8bed5cc10fd924aa ("OMAP clockdomain:
    initialize clockdomain registers when the clockdomain layer starts")
    which clears these dependencies during clockdomain init.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 97feb3ab6a69..10f8747ba572 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -363,9 +363,6 @@ static const struct platform_suspend_ops __initdata omap_pm_ops;
 /* XXX This function should be shareable between OMAP2xxx and OMAP3 */
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
-	clkdm_clear_all_wkdeps(clkdm);
-	clkdm_clear_all_sleepdeps(clkdm);
-
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
 		omap2_clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
@@ -411,10 +408,7 @@ static void __init prcm_setup_regs(void)
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
 	omap2_clkdm_sleep(gfx_clkdm);
 
-	/*
-	 * Clear clockdomain wakeup dependencies and enable
-	 * hardware-supervised idle for all clkdms
-	 */
+	/* Enable hardware-supervised idle for all clkdms */
 	clkdm_for_each(clkdms_setup, NULL);
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 

commit 4ef70c0694bf428d9f1d4722edaffa1dc5fa39e1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 25 15:39:30 2011 -0700

    OMAP2/3: PM: remove manual CM_AUTOIDLE bit setting in mach-omap2/pm*xx.c
    
    These CM_AUTOIDLE bits are now set by the clock code via the common PM
    code in mach-omap2/pm.c.
    
    N.B.: The pm24xx.c code that this patch removes didn't ensure that the
    CM_AUTOIDLE bits were set for several 2430-only modules, such as
    GPIO5, MDM_INTC, MMCHS1/2, the modem oscillator clock, and USBHS.
    Similarly, the pm34xx.c code that this patch removes didn't ensure
    that the CM_AUTOIDLE bits were set for USIM and the AM3517 UART4.
    Those cases should now be handled.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index abe08f49b2ec..96907da1910a 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -379,7 +379,10 @@ static void __init prcm_setup_regs(void)
 	int i, num_mem_banks;
 	struct powerdomain *pwrdm;
 
-	/* Enable autoidle */
+	/*
+	 * Enable autoidle
+	 * XXX This should be handled by hwmod code or PRCM init code
+	 */
 	omap2_prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
 			  OMAP2_PRCM_SYSCONFIG_OFFSET);
 
@@ -418,64 +421,6 @@ static void __init prcm_setup_regs(void)
 	clkdm_for_each(clkdms_setup, NULL);
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
-	/* Enable clock autoidle for all domains */
-	omap2_cm_write_mod_reg(OMAP24XX_AUTO_CAM_MASK |
-			       OMAP24XX_AUTO_MAILBOXES_MASK |
-			       OMAP24XX_AUTO_WDT4_MASK |
-			       OMAP2420_AUTO_WDT3_MASK |
-			       OMAP24XX_AUTO_MSPRO_MASK |
-			       OMAP2420_AUTO_MMC_MASK |
-			       OMAP24XX_AUTO_FAC_MASK |
-			       OMAP2420_AUTO_EAC_MASK |
-			       OMAP24XX_AUTO_HDQ_MASK |
-			       OMAP24XX_AUTO_UART2_MASK |
-			       OMAP24XX_AUTO_UART1_MASK |
-			       OMAP24XX_AUTO_I2C2_MASK |
-			       OMAP24XX_AUTO_I2C1_MASK |
-			       OMAP24XX_AUTO_MCSPI2_MASK |
-			       OMAP24XX_AUTO_MCSPI1_MASK |
-			       OMAP24XX_AUTO_MCBSP2_MASK |
-			       OMAP24XX_AUTO_MCBSP1_MASK |
-			       OMAP24XX_AUTO_GPT12_MASK |
-			       OMAP24XX_AUTO_GPT11_MASK |
-			       OMAP24XX_AUTO_GPT10_MASK |
-			       OMAP24XX_AUTO_GPT9_MASK |
-			       OMAP24XX_AUTO_GPT8_MASK |
-			       OMAP24XX_AUTO_GPT7_MASK |
-			       OMAP24XX_AUTO_GPT6_MASK |
-			       OMAP24XX_AUTO_GPT5_MASK |
-			       OMAP24XX_AUTO_GPT4_MASK |
-			       OMAP24XX_AUTO_GPT3_MASK |
-			       OMAP24XX_AUTO_GPT2_MASK |
-			       OMAP2420_AUTO_VLYNQ_MASK |
-			       OMAP24XX_AUTO_DSS_MASK,
-			       CORE_MOD, CM_AUTOIDLE1);
-	omap2_cm_write_mod_reg(OMAP24XX_AUTO_UART3_MASK |
-			       OMAP24XX_AUTO_SSI_MASK |
-			       OMAP24XX_AUTO_USB_MASK,
-			       CORE_MOD, CM_AUTOIDLE2);
-	omap2_cm_write_mod_reg(OMAP24XX_AUTO_SDRC_MASK |
-			       OMAP24XX_AUTO_GPMC_MASK |
-			       OMAP24XX_AUTO_SDMA_MASK,
-			       CORE_MOD, CM_AUTOIDLE3);
-	omap2_cm_write_mod_reg(OMAP24XX_AUTO_PKA_MASK |
-			       OMAP24XX_AUTO_AES_MASK |
-			       OMAP24XX_AUTO_RNG_MASK |
-			       OMAP24XX_AUTO_SHA_MASK |
-			       OMAP24XX_AUTO_DES_MASK,
-			       CORE_MOD, OMAP24XX_CM_AUTOIDLE4);
-
-	omap2_cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
-			       CM_AUTOIDLE);
-
-	omap2_cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
-			       OMAP24XX_AUTO_WDT1_MASK |
-			       OMAP24XX_AUTO_MPU_WDT_MASK |
-			       OMAP24XX_AUTO_GPIOS_MASK |
-			       OMAP24XX_AUTO_32KSYNC_MASK |
-			       OMAP24XX_AUTO_GPT1_MASK,
-			       WKUP_MOD, CM_AUTOIDLE);
-
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
 	 * stabilisation */
 	omap2_prm_write_mod_reg(15 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,

commit 92618ff8b025419960e2e845983f0f49b0cb57a9
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 25 15:39:27 2011 -0700

    OMAP2xxx: clock: add clockfw autoidle support for APLLs
    
    OMAP2xxx devices have two on-chip APLLs.  These APLLs can
    automatically enter idle when not in use.  Connect the APLL autoidle
    code to the clock code, so that the clock framework can handle this
    process.  As part of this patch, remove the code in mach-omap2/pm24xx.c
    that previously handled APLL autoidle control.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 297bb21061b8..abe08f49b2ec 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -378,7 +378,6 @@ static void __init prcm_setup_regs(void)
 {
 	int i, num_mem_banks;
 	struct powerdomain *pwrdm;
-	u32 v;
 
 	/* Enable autoidle */
 	omap2_prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
@@ -469,13 +468,6 @@ static void __init prcm_setup_regs(void)
 	omap2_cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
 			       CM_AUTOIDLE);
 
-	/* Put both APLLs into autoidle mode */
-	v = omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
-	v &= ~(OMAP24XX_AUTO_96M_MASK | OMAP24XX_AUTO_54M_SHIFT);
-	v |= (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
-		(0x03 << OMAP24XX_AUTO_54M_SHIFT);
-	omap2_cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);
-
 	omap2_cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
 			       OMAP24XX_AUTO_WDT1_MASK |
 			       OMAP24XX_AUTO_MPU_WDT_MASK |

commit 0fd0c21be71293d8a54d9075b18b5a25a1868057
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 25 15:49:53 2011 -0700

    OMAP2: clock: add DPLL autoidle support
    
    Add the necessary code and data to allow the clock framework to enable
    and disable the OMAP2 DPLL autoidle state.  This is so the direct
    register access can be moved out of the mach-omap2/pm24xx.c code, and other
    code that needs to control this (e.g., CPUIdle) can do so via an API.
    As part of this patch, remove the pm24xx.c code that formerly wrote
    directly to the autoidle bits.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index e983c8301f55..297bb21061b8 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -378,6 +378,7 @@ static void __init prcm_setup_regs(void)
 {
 	int i, num_mem_banks;
 	struct powerdomain *pwrdm;
+	u32 v;
 
 	/* Enable autoidle */
 	omap2_prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
@@ -468,11 +469,12 @@ static void __init prcm_setup_regs(void)
 	omap2_cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
 			       CM_AUTOIDLE);
 
-	/* Put DPLL and both APLLs into autoidle mode */
-	omap2_cm_write_mod_reg((0x03 << OMAP24XX_AUTO_DPLL_SHIFT) |
-			       (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
-			       (0x03 << OMAP24XX_AUTO_54M_SHIFT),
-			       PLL_MOD, CM_AUTOIDLE);
+	/* Put both APLLs into autoidle mode */
+	v = omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
+	v &= ~(OMAP24XX_AUTO_96M_MASK | OMAP24XX_AUTO_54M_SHIFT);
+	v |= (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
+		(0x03 << OMAP24XX_AUTO_54M_SHIFT);
+	omap2_cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);
 
 	omap2_cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
 			       OMAP24XX_AUTO_WDT1_MASK |

commit 5cd1937b6d5990fe5d5287d925f05afd38e9fb02
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Feb 25 16:06:48 2011 -0700

    OMAP: clockdomain: Arch specific funcs for hwsup control of clkdm
    
    Define the following architecture specific funtions for omap2/3/4
    .clkdm_allow_idle
    .clkdm_deny_idle
    
    Convert the platform-independent framework to call these functions.
    Also rename the api's by removing the omap2_ preamble.
    Hence call omap2_clkdm_allow_idle as clkdm_allow_idle and
    omap2_clkdm_deny_idle as clkdm_deny_idle.
    
    Make the _clkdm_add_autodeps and _clkdm_del_autodeps as non-static
    so they can be accessed from OMAP2/3 platform specific code.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 4125621bf591..e983c8301f55 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -367,7 +367,7 @@ static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 	clkdm_clear_all_sleepdeps(clkdm);
 
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
-		omap2_clkdm_allow_idle(clkdm);
+		clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
 		 atomic_read(&clkdm->usecount) == 0)
 		clkdm_sleep(clkdm);

commit 68b921ad7f35e0323ce0d9fe94e5701a112f257c
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Feb 25 16:06:47 2011 -0700

    OMAP: clockdomain: Arch specific funcs for sleep/wakeup of clkdm
    
    Define the following architecture specific funtions for omap2/3/4
    .clkdm_sleep
    .clkdm_wakeup
    
    Convert the platform-independent framework to call these functions.
    Also rename the api's by removing the omap2_ preamble.
    Hence call omap2_clkdm_wakeup as clkdm_wakeup and
    omap2_clkdm_sleep as clkdm_sleep.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: fixed omap3_clkdm_clear_all_sleepdeps() and
     omap2_clkdm_clear_all_wkdeps() to test against the correct
     loop termination condition; thanks to Kevin Hilman for finding and
     helping fix]
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 97feb3ab6a69..4125621bf591 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -370,7 +370,7 @@ static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 		omap2_clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
 		 atomic_read(&clkdm->usecount) == 0)
-		omap2_clkdm_sleep(clkdm);
+		clkdm_sleep(clkdm);
 	return 0;
 }
 
@@ -405,11 +405,11 @@ static void __init prcm_setup_regs(void)
 
 	pwrdm = clkdm_get_pwrdm(dsp_clkdm);
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
-	omap2_clkdm_sleep(dsp_clkdm);
+	clkdm_sleep(dsp_clkdm);
 
 	pwrdm = clkdm_get_pwrdm(gfx_clkdm);
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
-	omap2_clkdm_sleep(gfx_clkdm);
+	clkdm_sleep(gfx_clkdm);
 
 	/*
 	 * Clear clockdomain wakeup dependencies and enable

commit ac751efa6a0d70f2c9daef5c7e3a92270f5c2dff
Author: Torben Hohn <torbenh@gmx.de>
Date:   Tue Jan 25 15:07:35 2011 -0800

    console: rename acquire/release_console_sem() to console_lock/unlock()
    
    The -rt patches change the console_semaphore to console_mutex.  As a
    result, a quite large chunk of the patches changes all
    acquire/release_console_sem() to acquire/release_console_mutex()
    
    This commit makes things use more neutral function names which dont make
    implications about the underlying lock.
    
    The only real change is the return value of console_trylock which is
    inverted from try_acquire_console_sem()
    
    This patch also paves the way to switching console_sem from a semaphore to
    a mutex.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: make console_trylock return 1 on success, per Geert]
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Thomas Gleixner <tglx@tglx.de>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 9e5dc8ed51e9..97feb3ab6a69 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -134,7 +134,7 @@ static void omap2_enter_full_retention(void)
 
 	/* Block console output in case it is on one of the OMAP UARTs */
 	if (!is_suspending())
-		if (try_acquire_console_sem())
+		if (!console_trylock())
 			goto no_sleep;
 
 	omap_uart_prepare_idle(0);
@@ -151,7 +151,7 @@ static void omap2_enter_full_retention(void)
 	omap_uart_resume_idle(0);
 
 	if (!is_suspending())
-		release_console_sem();
+		console_unlock();
 
 no_sleep:
 	if (omap2_pm_debug) {

commit 008d23e4852d78bb2618f2035f8b2110b6a6b968
Merge: 8f685fbda43d bfc672dcf323
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:05:56 2011 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      Documentation/trace/events.txt: Remove obsolete sched_signal_send.
      writeback: fix global_dirty_limits comment runtime -> real-time
      ppc: fix comment typo singal -> signal
      drivers: fix comment typo diable -> disable.
      m68k: fix comment typo diable -> disable.
      wireless: comment typo fix diable -> disable.
      media: comment typo fix diable -> disable.
      remove doc for obsolete dynamic-printk kernel-parameter
      remove extraneous 'is' from Documentation/iostats.txt
      Fix spelling milisec -> ms in snd_ps3 module parameter description
      Fix spelling mistakes in comments
      Revert conflicting V4L changes
      i7core_edac: fix typos in comments
      mm/rmap.c: fix comment
      sound, ca0106: Fix assignment to 'channel'.
      hrtimer: fix a typo in comment
      init/Kconfig: fix typo
      anon_inodes: fix wrong function name in comment
      fix comment typos concerning "consistent"
      poll: fix a typo in comment
      ...
    
    Fix up trivial conflicts in:
     - drivers/net/wireless/iwlwifi/iwl-core.c (moved to iwl-legacy.c)
     - fs/ext4/ext4.h
    
    Also fix missed 'diabled' typo in drivers/net/bnx2x/bnx2x.h while at it.

commit 05fad3e72e98e57274b8930a08f8b476048f5022
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Dec 22 23:04:17 2010 +0000

    OMAP2: PM: fix compile error when !CONFIG_SUSPEND
    
    When CONFIG_SUSPEND is not enabled, none of the system PM methods are
    used, so do not compile them in.
    
    Thanks to Charles Manning for reporting the problem and proposing
    an initial patch.
    
    Reported-by: Charles Manning <manningc2@actrix.gen.nz>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 2844b84f8d46..dac2d1d9987d 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -299,6 +299,7 @@ static void omap2_pm_idle(void)
 	local_irq_enable();
 }
 
+#ifdef CONFIG_SUSPEND
 static int omap2_pm_begin(suspend_state_t state)
 {
 	disable_hlt();
@@ -355,6 +356,9 @@ static struct platform_suspend_ops omap_pm_ops = {
 	.end		= omap2_pm_end,
 	.valid		= suspend_valid_only_mem,
 };
+#else
+static const struct platform_suspend_ops __initdata omap_pm_ops;
+#endif /* CONFIG_SUSPEND */
 
 /* XXX This function should be shareable between OMAP2xxx and OMAP3 */
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit 72e06d087204f3bc9acf281717b90ebf0b9731f7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:16 2010 -0700

    OMAP2+: powerdomain: move header file from plat-omap to mach-omap2
    
    The OMAP powerdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/powerdomain.h
    to mach-omap2/powerdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access powerdomain code
    and data directly.
    
    As part of this process, remove the references to powerdomain data
    from the GPIO "driver" and the OMAP PM no-op layer, both in plat-omap.
    Change the DSPBridge code to point to the new location for the
    powerdomain headers.  The DSPBridge code should not be including the
    powerdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index f6aef7687b8a..2844b84f8d46 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -50,7 +50,7 @@
 #include "pm.h"
 #include "control.h"
 
-#include <plat/powerdomain.h>
+#include "powerdomain.h"
 #include "clockdomain.h"
 
 #ifdef CONFIG_SUSPEND
@@ -120,7 +120,7 @@ static void omap2_enter_full_retention(void)
 	l = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) | OMAP24XX_USBSTANDBYCTRL;
 	omap_ctrl_writel(l, OMAP2_CONTROL_DEVCONF0);
 
-	omap2_gpio_prepare_for_idle(PWRDM_POWER_RET);
+	omap2_gpio_prepare_for_idle(0);
 
 	if (omap2_pm_debug) {
 		omap2_pm_dump(0, 0, 0);

commit 1540f214065982e6cbc6b8da1fe65a15e358f7c5
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:15 2010 -0700

    OMAP2+: clockdomain: move header file from plat-omap to mach-omap2
    
    The OMAP clockdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/clockdomain.h
    to mach-omap2/clockdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access clockdomain code
    and data directly.
    
    DSPBridge also uses the clockdomain headers for some reason, so,
    modify it also. The DSPBridge code should not be including the
    clockdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index bf0c36b239f9..f6aef7687b8a 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -51,7 +51,7 @@
 #include "control.h"
 
 #include <plat/powerdomain.h>
-#include <plat/clockdomain.h>
+#include "clockdomain.h"
 
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state = PM_SUSPEND_ON;

commit c4d7e58fb52c632d8e33cd23a4917d7a7f8302ac
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:14 2010 -0700

    OMAP2/3: PRM/CM: prefix OMAP2 PRM/CM functions with "omap2_"
    
    Now that OMAP4-specific PRCM functions have been added, distinguish the
    existing OMAP2/3-specific PRCM functions by prefixing them with "omap2_".
    
    This patch should not result in any functional change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 8ea49dcaae4d..bf0c36b239f9 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -79,8 +79,8 @@ static int omap2_fclks_active(void)
 {
 	u32 f1, f2;
 
-	f1 = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	f2 = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
+	f1 = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	f2 = omap2_cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
 
 	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
 	f1 &= ~(OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_UART2_MASK);
@@ -105,9 +105,9 @@ static void omap2_enter_full_retention(void)
 
 	/* Clear old wake-up events */
 	/* REVISIT: These write to reserved bits? */
-	prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
-	prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+	omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
 
 	/*
 	 * Set MPU powerdomain's next power state to RETENTION;
@@ -167,30 +167,30 @@ static void omap2_enter_full_retention(void)
 	clk_enable(osc_ck);
 
 	/* clear CORE wake-up events */
-	prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
 
 	/* wakeup domain events - bit 1: GPT1, bit5 GPIO */
-	prm_clear_mod_reg_bits(0x4 | 0x1, WKUP_MOD, PM_WKST);
+	omap2_prm_clear_mod_reg_bits(0x4 | 0x1, WKUP_MOD, PM_WKST);
 
 	/* MPU domain wake events */
-	l = prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	l = omap2_prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
 	if (l & 0x01)
-		prm_write_mod_reg(0x01, OCP_MOD,
+		omap2_prm_write_mod_reg(0x01, OCP_MOD,
 				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
 	if (l & 0x20)
-		prm_write_mod_reg(0x20, OCP_MOD,
+		omap2_prm_write_mod_reg(0x20, OCP_MOD,
 				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
 
 	/* Mask future PRCM-to-MPU interrupts */
-	prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	omap2_prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
 }
 
 static int omap2_i2c_active(void)
 {
 	u32 l;
 
-	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	l = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	return l & (OMAP2420_EN_I2C2_MASK | OMAP2420_EN_I2C1_MASK);
 }
 
@@ -201,13 +201,13 @@ static int omap2_allow_mpu_retention(void)
 	u32 l;
 
 	/* Check for MMC, UART2, UART1, McSPI2, McSPI1 and DSS1. */
-	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	l = omap2_cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	if (l & (OMAP2420_EN_MMC_MASK | OMAP24XX_EN_UART2_MASK |
 		 OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_MCSPI2_MASK |
 		 OMAP24XX_EN_MCSPI1_MASK | OMAP24XX_EN_DSS1_MASK))
 		return 0;
 	/* Check for UART3. */
-	l = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
+	l = omap2_cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
 	if (l & OMAP24XX_EN_UART3_MASK)
 		return 0;
 	if (sti_console_enabled)
@@ -230,18 +230,18 @@ static void omap2_enter_mpu_retention(void)
 	 * it is in retention mode. */
 	if (omap2_allow_mpu_retention()) {
 		/* REVISIT: These write to reserved bits? */
-		prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
-		prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
-		prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+		omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+		omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+		omap2_prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
 
 		/* Try to enter MPU retention */
-		prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
+		omap2_prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
 				  OMAP_LOGICRETSTATE_MASK,
 				  MPU_MOD, OMAP2_PM_PWSTCTRL);
 	} else {
 		/* Block MPU retention */
 
-		prm_write_mod_reg(OMAP_LOGICRETSTATE_MASK, MPU_MOD,
+		omap2_prm_write_mod_reg(OMAP_LOGICRETSTATE_MASK, MPU_MOD,
 						 OMAP2_PM_PWSTCTRL);
 		only_idle = 1;
 	}
@@ -310,9 +310,9 @@ static int omap2_pm_suspend(void)
 {
 	u32 wken_wkup, mir1;
 
-	wken_wkup = prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+	wken_wkup = omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 	wken_wkup &= ~OMAP24XX_EN_GPT1_MASK;
-	prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
+	omap2_prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
 
 	/* Mask GPT1 */
 	mir1 = omap_readl(0x480fe0a4);
@@ -322,7 +322,7 @@ static int omap2_pm_suspend(void)
 	omap2_enter_full_retention();
 
 	omap_writel(mir1, 0x480fe0a4);
-	prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
+	omap2_prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
 
 	return 0;
 }
@@ -376,7 +376,7 @@ static void __init prcm_setup_regs(void)
 	struct powerdomain *pwrdm;
 
 	/* Enable autoidle */
-	prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
+	omap2_prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
 			  OMAP2_PRCM_SYSCONFIG_OFFSET);
 
 	/*
@@ -415,87 +415,87 @@ static void __init prcm_setup_regs(void)
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
 	/* Enable clock autoidle for all domains */
-	cm_write_mod_reg(OMAP24XX_AUTO_CAM_MASK |
-			 OMAP24XX_AUTO_MAILBOXES_MASK |
-			 OMAP24XX_AUTO_WDT4_MASK |
-			 OMAP2420_AUTO_WDT3_MASK |
-			 OMAP24XX_AUTO_MSPRO_MASK |
-			 OMAP2420_AUTO_MMC_MASK |
-			 OMAP24XX_AUTO_FAC_MASK |
-			 OMAP2420_AUTO_EAC_MASK |
-			 OMAP24XX_AUTO_HDQ_MASK |
-			 OMAP24XX_AUTO_UART2_MASK |
-			 OMAP24XX_AUTO_UART1_MASK |
-			 OMAP24XX_AUTO_I2C2_MASK |
-			 OMAP24XX_AUTO_I2C1_MASK |
-			 OMAP24XX_AUTO_MCSPI2_MASK |
-			 OMAP24XX_AUTO_MCSPI1_MASK |
-			 OMAP24XX_AUTO_MCBSP2_MASK |
-			 OMAP24XX_AUTO_MCBSP1_MASK |
-			 OMAP24XX_AUTO_GPT12_MASK |
-			 OMAP24XX_AUTO_GPT11_MASK |
-			 OMAP24XX_AUTO_GPT10_MASK |
-			 OMAP24XX_AUTO_GPT9_MASK |
-			 OMAP24XX_AUTO_GPT8_MASK |
-			 OMAP24XX_AUTO_GPT7_MASK |
-			 OMAP24XX_AUTO_GPT6_MASK |
-			 OMAP24XX_AUTO_GPT5_MASK |
-			 OMAP24XX_AUTO_GPT4_MASK |
-			 OMAP24XX_AUTO_GPT3_MASK |
-			 OMAP24XX_AUTO_GPT2_MASK |
-			 OMAP2420_AUTO_VLYNQ_MASK |
-			 OMAP24XX_AUTO_DSS_MASK,
-			 CORE_MOD, CM_AUTOIDLE1);
-	cm_write_mod_reg(OMAP24XX_AUTO_UART3_MASK |
-			 OMAP24XX_AUTO_SSI_MASK |
-			 OMAP24XX_AUTO_USB_MASK,
-			 CORE_MOD, CM_AUTOIDLE2);
-	cm_write_mod_reg(OMAP24XX_AUTO_SDRC_MASK |
-			 OMAP24XX_AUTO_GPMC_MASK |
-			 OMAP24XX_AUTO_SDMA_MASK,
-			 CORE_MOD, CM_AUTOIDLE3);
-	cm_write_mod_reg(OMAP24XX_AUTO_PKA_MASK |
-			 OMAP24XX_AUTO_AES_MASK |
-			 OMAP24XX_AUTO_RNG_MASK |
-			 OMAP24XX_AUTO_SHA_MASK |
-			 OMAP24XX_AUTO_DES_MASK,
-			 CORE_MOD, OMAP24XX_CM_AUTOIDLE4);
-
-	cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
-			 CM_AUTOIDLE);
+	omap2_cm_write_mod_reg(OMAP24XX_AUTO_CAM_MASK |
+			       OMAP24XX_AUTO_MAILBOXES_MASK |
+			       OMAP24XX_AUTO_WDT4_MASK |
+			       OMAP2420_AUTO_WDT3_MASK |
+			       OMAP24XX_AUTO_MSPRO_MASK |
+			       OMAP2420_AUTO_MMC_MASK |
+			       OMAP24XX_AUTO_FAC_MASK |
+			       OMAP2420_AUTO_EAC_MASK |
+			       OMAP24XX_AUTO_HDQ_MASK |
+			       OMAP24XX_AUTO_UART2_MASK |
+			       OMAP24XX_AUTO_UART1_MASK |
+			       OMAP24XX_AUTO_I2C2_MASK |
+			       OMAP24XX_AUTO_I2C1_MASK |
+			       OMAP24XX_AUTO_MCSPI2_MASK |
+			       OMAP24XX_AUTO_MCSPI1_MASK |
+			       OMAP24XX_AUTO_MCBSP2_MASK |
+			       OMAP24XX_AUTO_MCBSP1_MASK |
+			       OMAP24XX_AUTO_GPT12_MASK |
+			       OMAP24XX_AUTO_GPT11_MASK |
+			       OMAP24XX_AUTO_GPT10_MASK |
+			       OMAP24XX_AUTO_GPT9_MASK |
+			       OMAP24XX_AUTO_GPT8_MASK |
+			       OMAP24XX_AUTO_GPT7_MASK |
+			       OMAP24XX_AUTO_GPT6_MASK |
+			       OMAP24XX_AUTO_GPT5_MASK |
+			       OMAP24XX_AUTO_GPT4_MASK |
+			       OMAP24XX_AUTO_GPT3_MASK |
+			       OMAP24XX_AUTO_GPT2_MASK |
+			       OMAP2420_AUTO_VLYNQ_MASK |
+			       OMAP24XX_AUTO_DSS_MASK,
+			       CORE_MOD, CM_AUTOIDLE1);
+	omap2_cm_write_mod_reg(OMAP24XX_AUTO_UART3_MASK |
+			       OMAP24XX_AUTO_SSI_MASK |
+			       OMAP24XX_AUTO_USB_MASK,
+			       CORE_MOD, CM_AUTOIDLE2);
+	omap2_cm_write_mod_reg(OMAP24XX_AUTO_SDRC_MASK |
+			       OMAP24XX_AUTO_GPMC_MASK |
+			       OMAP24XX_AUTO_SDMA_MASK,
+			       CORE_MOD, CM_AUTOIDLE3);
+	omap2_cm_write_mod_reg(OMAP24XX_AUTO_PKA_MASK |
+			       OMAP24XX_AUTO_AES_MASK |
+			       OMAP24XX_AUTO_RNG_MASK |
+			       OMAP24XX_AUTO_SHA_MASK |
+			       OMAP24XX_AUTO_DES_MASK,
+			       CORE_MOD, OMAP24XX_CM_AUTOIDLE4);
+
+	omap2_cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
+			       CM_AUTOIDLE);
 
 	/* Put DPLL and both APLLs into autoidle mode */
-	cm_write_mod_reg((0x03 << OMAP24XX_AUTO_DPLL_SHIFT) |
-			 (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
-			 (0x03 << OMAP24XX_AUTO_54M_SHIFT),
-			 PLL_MOD, CM_AUTOIDLE);
-
-	cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
-			 OMAP24XX_AUTO_WDT1_MASK |
-			 OMAP24XX_AUTO_MPU_WDT_MASK |
-			 OMAP24XX_AUTO_GPIOS_MASK |
-			 OMAP24XX_AUTO_32KSYNC_MASK |
-			 OMAP24XX_AUTO_GPT1_MASK,
-			 WKUP_MOD, CM_AUTOIDLE);
+	omap2_cm_write_mod_reg((0x03 << OMAP24XX_AUTO_DPLL_SHIFT) |
+			       (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
+			       (0x03 << OMAP24XX_AUTO_54M_SHIFT),
+			       PLL_MOD, CM_AUTOIDLE);
+
+	omap2_cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
+			       OMAP24XX_AUTO_WDT1_MASK |
+			       OMAP24XX_AUTO_MPU_WDT_MASK |
+			       OMAP24XX_AUTO_GPIOS_MASK |
+			       OMAP24XX_AUTO_32KSYNC_MASK |
+			       OMAP24XX_AUTO_GPT1_MASK,
+			       WKUP_MOD, CM_AUTOIDLE);
 
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
 	 * stabilisation */
-	prm_write_mod_reg(15 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
-			  OMAP2_PRCM_CLKSSETUP_OFFSET);
+	omap2_prm_write_mod_reg(15 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
+				OMAP2_PRCM_CLKSSETUP_OFFSET);
 
 	/* Configure automatic voltage transition */
-	prm_write_mod_reg(2 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
-			  OMAP2_PRCM_VOLTSETUP_OFFSET);
-	prm_write_mod_reg(OMAP24XX_AUTO_EXTVOLT_MASK |
-			  (0x1 << OMAP24XX_SETOFF_LEVEL_SHIFT) |
-			  OMAP24XX_MEMRETCTRL_MASK |
-			  (0x1 << OMAP24XX_SETRET_LEVEL_SHIFT) |
-			  (0x0 << OMAP24XX_VOLT_LEVEL_SHIFT),
-			  OMAP24XX_GR_MOD, OMAP2_PRCM_VOLTCTRL_OFFSET);
+	omap2_prm_write_mod_reg(2 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
+				OMAP2_PRCM_VOLTSETUP_OFFSET);
+	omap2_prm_write_mod_reg(OMAP24XX_AUTO_EXTVOLT_MASK |
+				(0x1 << OMAP24XX_SETOFF_LEVEL_SHIFT) |
+				OMAP24XX_MEMRETCTRL_MASK |
+				(0x1 << OMAP24XX_SETRET_LEVEL_SHIFT) |
+				(0x0 << OMAP24XX_VOLT_LEVEL_SHIFT),
+				OMAP24XX_GR_MOD, OMAP2_PRCM_VOLTCTRL_OFFSET);
 
 	/* Enable wake-up events */
-	prm_write_mod_reg(OMAP24XX_EN_GPIOS_MASK | OMAP24XX_EN_GPT1_MASK,
-			  WKUP_MOD, PM_WKEN);
+	omap2_prm_write_mod_reg(OMAP24XX_EN_GPIOS_MASK | OMAP24XX_EN_GPT1_MASK,
+				WKUP_MOD, PM_WKEN);
 }
 
 static int __init omap2_pm_init(void)
@@ -506,7 +506,7 @@ static int __init omap2_pm_init(void)
 		return -ENODEV;
 
 	printk(KERN_INFO "Power Management for OMAP2 initializing\n");
-	l = prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_REVISION_OFFSET);
+	l = omap2_prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_REVISION_OFFSET);
 	printk(KERN_INFO "PRCM revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
 
 	/* Look up important powerdomains */

commit 59fb659b065f52fcc2deed293cfbfc58f890376c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:55 2010 -0700

    OMAP2/3: PRCM: split OMAP2/3-specific PRCM code into OMAP2/3-specific files
    
    In preparation for adding OMAP4-specific PRCM accessor/mutator
    functions, split the existing OMAP2/3 PRCM code into OMAP2/3-specific
    files.  Most of what was in mach-omap2/{cm,prm}.{c,h} has now been
    moved into mach-omap2/{cm,prm}2xxx_3xxx.{c,h}, since it was
    OMAP2xxx/3xxx-specific.
    
    This process also requires the #includes in each of these files to be
    changed to reference the new file name.  As part of doing so, add some
    comments into plat-omap/sram.c and plat-omap/mcbsp.c, which use
    "sideways includes", to indicate that these users of the PRM/CM includes
    should not be doing so.
    
    Thanks to Felipe Contreras <felipe.contreras@gmail.com> for comments on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Acked-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Acked-by: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index aea7ced9a2ff..8ea49dcaae4d 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -42,9 +42,9 @@
 #include <plat/dma.h>
 #include <plat/board.h>
 
-#include "prm.h"
+#include "prm2xxx_3xxx.h"
 #include "prm-regbits-24xx.h"
-#include "cm.h"
+#include "cm2xxx_3xxx.h"
 #include "cm-regbits-24xx.h"
 #include "sdrc.h"
 #include "pm.h"

commit c166381d4013fd32512f124c237f4213ae9888e9
Author: Jean Pihet <j-pihet@ti.com>
Date:   Thu Dec 9 18:39:58 2010 +0100

    OMAP2+: disable idle early in the suspend sequence
    
    Some bad interaction between the idle and the suspend paths has been
    identified: the idle code is called during the suspend enter and exit
    sequences. This could cause corruption or lock-up of resources.
    
    The solution is to move the calls to disable_hlt at the very beginning
    of the suspend sequence (ex. in omap3_pm_begin instead of
    omap3_pm_prepare), and the call to enable_hlt at the very end of
    the suspend sequence (ex. in omap3_pm_end instead of omap3_pm_finish).
    
    Tested with RET and OFF on Beagle and OMAP3EVM.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index aaeea49b9bdd..aea7ced9a2ff 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -301,14 +301,8 @@ static void omap2_pm_idle(void)
 
 static int omap2_pm_begin(suspend_state_t state)
 {
-	suspend_state = state;
-	return 0;
-}
-
-static int omap2_pm_prepare(void)
-{
-	/* We cannot sleep in idle until we have resumed */
 	disable_hlt();
+	suspend_state = state;
 	return 0;
 }
 
@@ -349,21 +343,15 @@ static int omap2_pm_enter(suspend_state_t state)
 	return ret;
 }
 
-static void omap2_pm_finish(void)
-{
-	enable_hlt();
-}
-
 static void omap2_pm_end(void)
 {
 	suspend_state = PM_SUSPEND_ON;
+	enable_hlt();
 }
 
 static struct platform_suspend_ops omap_pm_ops = {
 	.begin		= omap2_pm_begin,
-	.prepare	= omap2_pm_prepare,
 	.enter		= omap2_pm_enter,
-	.finish		= omap2_pm_finish,
 	.end		= omap2_pm_end,
 	.valid		= suspend_valid_only_mem,
 };

commit e83df17f178360a8e7874441bca04a710c869e42
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Dec 8 22:40:40 2010 +0000

    OMAP2+: PM/serial: fix console semaphore acquire during suspend
    
    commit 0d8e2d0dad98a693bad88aea6876ac8b94ad95c6 (OMAP2+: PM/serial:
    hold console semaphore while OMAP UARTs are disabled) added use of the
    console semaphore to protect UARTs from being accessed after disabled
    during idle, but this causes problems in suspend.
    
    During suspend, the console semaphore is acquired by the console
    suspend method (console_suspend()) so the try_acquire_console_sem()
    will always fail and suspend will be aborted.
    
    To fix, introduce a check so the console semaphore is only attempted
    during idle, and not during suspend.  Also use the same check so that
    the console semaphore is not prematurely released during resume.
    
    Thanks to Paul Walmsley for suggesting adding the same check during
    resume.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Tested-by: Jean Pihet <j-pihet@ti.com>
    Tested-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index c85923e56b85..aaeea49b9bdd 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -53,6 +53,19 @@
 #include <plat/powerdomain.h>
 #include <plat/clockdomain.h>
 
+#ifdef CONFIG_SUSPEND
+static suspend_state_t suspend_state = PM_SUSPEND_ON;
+static inline bool is_suspending(void)
+{
+	return (suspend_state != PM_SUSPEND_ON);
+}
+#else
+static inline bool is_suspending(void)
+{
+	return false;
+}
+#endif
+
 static void (*omap2_sram_idle)(void);
 static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,
 				  void __iomem *sdrc_power);
@@ -120,8 +133,9 @@ static void omap2_enter_full_retention(void)
 		goto no_sleep;
 
 	/* Block console output in case it is on one of the OMAP UARTs */
-	if (try_acquire_console_sem())
-		goto no_sleep;
+	if (!is_suspending())
+		if (try_acquire_console_sem())
+			goto no_sleep;
 
 	omap_uart_prepare_idle(0);
 	omap_uart_prepare_idle(1);
@@ -136,7 +150,8 @@ static void omap2_enter_full_retention(void)
 	omap_uart_resume_idle(1);
 	omap_uart_resume_idle(0);
 
-	release_console_sem();
+	if (!is_suspending())
+		release_console_sem();
 
 no_sleep:
 	if (omap2_pm_debug) {
@@ -284,6 +299,12 @@ static void omap2_pm_idle(void)
 	local_irq_enable();
 }
 
+static int omap2_pm_begin(suspend_state_t state)
+{
+	suspend_state = state;
+	return 0;
+}
+
 static int omap2_pm_prepare(void)
 {
 	/* We cannot sleep in idle until we have resumed */
@@ -333,10 +354,17 @@ static void omap2_pm_finish(void)
 	enable_hlt();
 }
 
+static void omap2_pm_end(void)
+{
+	suspend_state = PM_SUSPEND_ON;
+}
+
 static struct platform_suspend_ops omap_pm_ops = {
+	.begin		= omap2_pm_begin,
 	.prepare	= omap2_pm_prepare,
 	.enter		= omap2_pm_enter,
 	.finish		= omap2_pm_finish,
+	.end		= omap2_pm_end,
 	.valid		= suspend_valid_only_mem,
 };
 

commit 0d8e2d0dad98a693bad88aea6876ac8b94ad95c6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Nov 24 16:49:05 2010 -0700

    OMAP2+: PM/serial: hold console semaphore while OMAP UARTs are disabled
    
    The console semaphore must be held while the OMAP UART devices are
    disabled, lest a console write cause an ARM abort (and a kernel crash)
    when the underlying console device is inaccessible.  These crashes
    only occur when the console is on one of the OMAP internal serial
    ports.
    
    While this problem has been latent in the PM idle loop for some time,
    the crash was not triggerable with an unmodified kernel until commit
    6f251e9db1093c187addc309b5f2f7fe3efd2995 ("OMAP: UART: omap_device
    conversions, remove implicit 8520 assumptions").  After this patch, a
    console write often occurs after the console UART has been disabled in
    the idle loop, crashing the system.  Several users have encountered
    this bug:
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg38396.html
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg36602.html
    
    The same commit also introduced new code that disabled the UARTs
    during init, in omap_serial_init_port().  The kernel will also crash
    in this code when earlyconsole and extra debugging is enabled:
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg36411.html
    
    The minimal fix for the -rc series is to hold the console semaphore
    while the OMAP UARTs are disabled.  This is a somewhat overbroad fix,
    since the console may not be located on an OMAP UART, as is the case
    with the GPMC UART on Zoom3.  While it is technically possible to
    determine which devices the console or earlyconsole is actually
    running on, it is not a trivial problem to solve, and the code to do
    so is not really appropriate for the -rc series.
    
    The right long-term fix is to ensure that no code outside of the OMAP
    serial driver can disable an OMAP UART.  As I understand it, code to
    implement this is under development by TI.
    
    This patch is a collaboration between Paul Walmsley <paul@pwsan.com>
    and Tony Lindgren <tony@atomide.com>.  Thanks to Ming Lei
    <tom.leiming@gmail.com> and Pramod <pramod.gurav@ti.com> for their
    feedback on earlier versions of this patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Pramod <pramod.gurav@ti.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jean Pihet <jean.pihet@newoldbits.com>
    Cc: Govindraj.R <govindraj.raja@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index a40457d81927..c85923e56b85 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -30,6 +30,7 @@
 #include <linux/irq.h>
 #include <linux/time.h>
 #include <linux/gpio.h>
+#include <linux/console.h>
 
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
@@ -118,6 +119,10 @@ static void omap2_enter_full_retention(void)
 	if (omap_irq_pending())
 		goto no_sleep;
 
+	/* Block console output in case it is on one of the OMAP UARTs */
+	if (try_acquire_console_sem())
+		goto no_sleep;
+
 	omap_uart_prepare_idle(0);
 	omap_uart_prepare_idle(1);
 	omap_uart_prepare_idle(2);
@@ -131,6 +136,8 @@ static void omap2_enter_full_retention(void)
 	omap_uart_resume_idle(1);
 	omap_uart_resume_idle(0);
 
+	release_console_sem();
+
 no_sleep:
 	if (omap2_pm_debug) {
 		unsigned long long tmp;

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index a40457d81927..aa9764eeb941 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -326,7 +326,7 @@ static void omap2_pm_finish(void)
 	enable_hlt();
 }
 
-static struct platform_suspend_ops omap_pm_ops = {
+static const struct platform_suspend_ops omap_pm_ops = {
 	.prepare	= omap2_pm_prepare,
 	.enter		= omap2_pm_enter,
 	.finish		= omap2_pm_finish,

commit 4814ced5116e3b73dc4f63eec84999739fc8ed11
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Oct 8 11:40:20 2010 -0600

    OMAP: control: move plat-omap/control.h to mach-omap2/control.h
    
    Only OMAP2+ platforms have the System Control Module (SCM) IP block.
    In the past, we've kept the SCM header file in plat-omap.  This has
    led to abuse - device drivers including it; includes being added that
    create implicit dependencies on OMAP2+ builds; etc.
    
    In response, move the SCM headers into mach-omap2/.
    
    As part of this, remove the direct SCM access from the OMAP UDC
    driver.  It was clearly broken.  The UDC code needs an indepth review for
    use on OMAP2+ chips.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Cory Maccarrone <darkstar6262@gmail.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index f5c7ef955942..a40457d81927 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -38,7 +38,6 @@
 #include <mach/irqs.h>
 #include <plat/clock.h>
 #include <plat/sram.h>
-#include <plat/control.h>
 #include <plat/dma.h>
 #include <plat/board.h>
 
@@ -48,6 +47,7 @@
 #include "cm-regbits-24xx.h"
 #include "sdrc.h"
 #include "pm.h"
+#include "control.h"
 
 #include <plat/powerdomain.h>
 #include <plat/clockdomain.h>

commit 503923eeecb93ff69ee940549f314e0fe3a68429
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Fri Oct 8 10:23:32 2010 -0700

    OMAP2: PM: check UART status before trying to idle
    
    As is done on OMAP3, check omap_uart_can_sleep() as one of the
    pre-conditions for entering the idle loop.  Without this check,
    entering idle introduces large latencies on active UARTs, and is
    especially noticable on serial console.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 6aeedeacdad8..f5c7ef955942 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -245,6 +245,8 @@ static int omap2_can_sleep(void)
 {
 	if (omap2_fclks_active())
 		return 0;
+	if (!omap_uart_can_sleep())
+		return 0;
 	if (osc_ck->usecount > 1)
 		return 0;
 	if (omap_dma_running())

commit c9d8230e316abb6a480f6bda85edf859896e9ab6
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jul 5 16:31:40 2010 +0300

    omap: mux: Remove old mux code
    
    All mach-omap2 omaps should now use the new mux code.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index e321281ab6e1..6aeedeacdad8 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -39,7 +39,6 @@
 #include <plat/clock.h>
 #include <plat/sram.h>
 #include <plat/control.h>
-#include <plat/mux.h>
 #include <plat/dma.h>
 #include <plat/board.h>
 

commit 2fd0f75cb3413105ed10041c719346ccb710fbc6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 18:40:23 2010 -0600

    OMAP2+ PRCM: convert remaining PRCM macros to the _SHIFT/_MASK suffixes
    
    Fix all of the remaining PRCM register shift/bitmask macros that did not
    use the _SHIFT/_MASK suffixes to use them.  This makes the use of these
    macros consistent.  It is intended to reduce error, as code can be inspected
    visually by reviewers to ensure that bitshifts and bitmasks are used in
    the appropriate places.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index b8c9e900a679..e321281ab6e1 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -70,8 +70,8 @@ static int omap2_fclks_active(void)
 	f2 = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
 
 	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
-	f1 &= ~(OMAP24XX_EN_UART1 | OMAP24XX_EN_UART2);
-	f2 &= ~OMAP24XX_EN_UART3;
+	f1 &= ~(OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_UART2_MASK);
+	f2 &= ~OMAP24XX_EN_UART3_MASK;
 
 	if (f1 | f2)
 		return 1;
@@ -181,13 +181,13 @@ static int omap2_allow_mpu_retention(void)
 
 	/* Check for MMC, UART2, UART1, McSPI2, McSPI1 and DSS1. */
 	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	if (l & (OMAP2420_EN_MMC | OMAP24XX_EN_UART2 |
-		 OMAP24XX_EN_UART1 | OMAP24XX_EN_MCSPI2 |
-		 OMAP24XX_EN_MCSPI1 | OMAP24XX_EN_DSS1_MASK))
+	if (l & (OMAP2420_EN_MMC_MASK | OMAP24XX_EN_UART2_MASK |
+		 OMAP24XX_EN_UART1_MASK | OMAP24XX_EN_MCSPI2_MASK |
+		 OMAP24XX_EN_MCSPI1_MASK | OMAP24XX_EN_DSS1_MASK))
 		return 0;
 	/* Check for UART3. */
 	l = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
-	if (l & OMAP24XX_EN_UART3)
+	if (l & OMAP24XX_EN_UART3_MASK)
 		return 0;
 	if (sti_console_enabled)
 		return 0;
@@ -215,12 +215,12 @@ static void omap2_enter_mpu_retention(void)
 
 		/* Try to enter MPU retention */
 		prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
-				  OMAP_LOGICRETSTATE,
+				  OMAP_LOGICRETSTATE_MASK,
 				  MPU_MOD, OMAP2_PM_PWSTCTRL);
 	} else {
 		/* Block MPU retention */
 
-		prm_write_mod_reg(OMAP_LOGICRETSTATE, MPU_MOD,
+		prm_write_mod_reg(OMAP_LOGICRETSTATE_MASK, MPU_MOD,
 						 OMAP2_PM_PWSTCTRL);
 		only_idle = 1;
 	}
@@ -288,7 +288,8 @@ static int omap2_pm_suspend(void)
 	u32 wken_wkup, mir1;
 
 	wken_wkup = prm_read_mod_reg(WKUP_MOD, PM_WKEN);
-	prm_write_mod_reg(wken_wkup & ~OMAP24XX_EN_GPT1, WKUP_MOD, PM_WKEN);
+	wken_wkup &= ~OMAP24XX_EN_GPT1_MASK;
+	prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
 
 	/* Mask GPT1 */
 	mir1 = omap_readl(0x480fe0a4);
@@ -469,7 +470,7 @@ static void __init prcm_setup_regs(void)
 			  OMAP24XX_GR_MOD, OMAP2_PRCM_VOLTCTRL_OFFSET);
 
 	/* Enable wake-up events */
-	prm_write_mod_reg(OMAP24XX_EN_GPIOS | OMAP24XX_EN_GPT1,
+	prm_write_mod_reg(OMAP24XX_EN_GPIOS_MASK | OMAP24XX_EN_GPT1_MASK,
 			  WKUP_MOD, PM_WKEN);
 }
 

commit f38ca10a79a0cd9902b8a470901951354802faa1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu May 20 12:31:04 2010 -0600

    OMAP2 PRCM: convert OMAP2 PRCM macros to the _SHIFT/_MASK suffixes
    
    Fix all of the remaining OMAP2 PRCM register shift/bitmask macros that
    did not use the _SHIFT/_MASK suffixes to use them.  This makes the use
    of these macros consistent.  It is intended to reduce error, as code
    can be inspected visually by reviewers to ensure that bitshifts and
    bitmasks are used in the appropriate places.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 7816c4e84a32..b8c9e900a679 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -170,7 +170,7 @@ static int omap2_i2c_active(void)
 	u32 l;
 
 	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-	return l & (OMAP2420_EN_I2C2 | OMAP2420_EN_I2C1);
+	return l & (OMAP2420_EN_I2C2_MASK | OMAP2420_EN_I2C1_MASK);
 }
 
 static int sti_console_enabled;
@@ -183,7 +183,7 @@ static int omap2_allow_mpu_retention(void)
 	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	if (l & (OMAP2420_EN_MMC | OMAP24XX_EN_UART2 |
 		 OMAP24XX_EN_UART1 | OMAP24XX_EN_MCSPI2 |
-		 OMAP24XX_EN_MCSPI1 | OMAP24XX_EN_DSS1))
+		 OMAP24XX_EN_MCSPI1 | OMAP24XX_EN_DSS1_MASK))
 		return 0;
 	/* Check for UART3. */
 	l = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
@@ -351,7 +351,7 @@ static void __init prcm_setup_regs(void)
 	struct powerdomain *pwrdm;
 
 	/* Enable autoidle */
-	prm_write_mod_reg(OMAP24XX_AUTOIDLE, OCP_MOD,
+	prm_write_mod_reg(OMAP24XX_AUTOIDLE_MASK, OCP_MOD,
 			  OMAP2_PRCM_SYSCONFIG_OFFSET);
 
 	/*
@@ -390,53 +390,54 @@ static void __init prcm_setup_regs(void)
 	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
 	/* Enable clock autoidle for all domains */
-	cm_write_mod_reg(OMAP24XX_AUTO_CAM |
-			 OMAP24XX_AUTO_MAILBOXES |
-			 OMAP24XX_AUTO_WDT4 |
-			 OMAP2420_AUTO_WDT3 |
-			 OMAP24XX_AUTO_MSPRO |
-			 OMAP2420_AUTO_MMC |
-			 OMAP24XX_AUTO_FAC |
-			 OMAP2420_AUTO_EAC |
-			 OMAP24XX_AUTO_HDQ |
-			 OMAP24XX_AUTO_UART2 |
-			 OMAP24XX_AUTO_UART1 |
-			 OMAP24XX_AUTO_I2C2 |
-			 OMAP24XX_AUTO_I2C1 |
-			 OMAP24XX_AUTO_MCSPI2 |
-			 OMAP24XX_AUTO_MCSPI1 |
-			 OMAP24XX_AUTO_MCBSP2 |
-			 OMAP24XX_AUTO_MCBSP1 |
-			 OMAP24XX_AUTO_GPT12 |
-			 OMAP24XX_AUTO_GPT11 |
-			 OMAP24XX_AUTO_GPT10 |
-			 OMAP24XX_AUTO_GPT9 |
-			 OMAP24XX_AUTO_GPT8 |
-			 OMAP24XX_AUTO_GPT7 |
-			 OMAP24XX_AUTO_GPT6 |
-			 OMAP24XX_AUTO_GPT5 |
-			 OMAP24XX_AUTO_GPT4 |
-			 OMAP24XX_AUTO_GPT3 |
-			 OMAP24XX_AUTO_GPT2 |
-			 OMAP2420_AUTO_VLYNQ |
-			 OMAP24XX_AUTO_DSS,
+	cm_write_mod_reg(OMAP24XX_AUTO_CAM_MASK |
+			 OMAP24XX_AUTO_MAILBOXES_MASK |
+			 OMAP24XX_AUTO_WDT4_MASK |
+			 OMAP2420_AUTO_WDT3_MASK |
+			 OMAP24XX_AUTO_MSPRO_MASK |
+			 OMAP2420_AUTO_MMC_MASK |
+			 OMAP24XX_AUTO_FAC_MASK |
+			 OMAP2420_AUTO_EAC_MASK |
+			 OMAP24XX_AUTO_HDQ_MASK |
+			 OMAP24XX_AUTO_UART2_MASK |
+			 OMAP24XX_AUTO_UART1_MASK |
+			 OMAP24XX_AUTO_I2C2_MASK |
+			 OMAP24XX_AUTO_I2C1_MASK |
+			 OMAP24XX_AUTO_MCSPI2_MASK |
+			 OMAP24XX_AUTO_MCSPI1_MASK |
+			 OMAP24XX_AUTO_MCBSP2_MASK |
+			 OMAP24XX_AUTO_MCBSP1_MASK |
+			 OMAP24XX_AUTO_GPT12_MASK |
+			 OMAP24XX_AUTO_GPT11_MASK |
+			 OMAP24XX_AUTO_GPT10_MASK |
+			 OMAP24XX_AUTO_GPT9_MASK |
+			 OMAP24XX_AUTO_GPT8_MASK |
+			 OMAP24XX_AUTO_GPT7_MASK |
+			 OMAP24XX_AUTO_GPT6_MASK |
+			 OMAP24XX_AUTO_GPT5_MASK |
+			 OMAP24XX_AUTO_GPT4_MASK |
+			 OMAP24XX_AUTO_GPT3_MASK |
+			 OMAP24XX_AUTO_GPT2_MASK |
+			 OMAP2420_AUTO_VLYNQ_MASK |
+			 OMAP24XX_AUTO_DSS_MASK,
 			 CORE_MOD, CM_AUTOIDLE1);
-	cm_write_mod_reg(OMAP24XX_AUTO_UART3 |
-			 OMAP24XX_AUTO_SSI |
-			 OMAP24XX_AUTO_USB,
+	cm_write_mod_reg(OMAP24XX_AUTO_UART3_MASK |
+			 OMAP24XX_AUTO_SSI_MASK |
+			 OMAP24XX_AUTO_USB_MASK,
 			 CORE_MOD, CM_AUTOIDLE2);
-	cm_write_mod_reg(OMAP24XX_AUTO_SDRC |
-			 OMAP24XX_AUTO_GPMC |
-			 OMAP24XX_AUTO_SDMA,
+	cm_write_mod_reg(OMAP24XX_AUTO_SDRC_MASK |
+			 OMAP24XX_AUTO_GPMC_MASK |
+			 OMAP24XX_AUTO_SDMA_MASK,
 			 CORE_MOD, CM_AUTOIDLE3);
-	cm_write_mod_reg(OMAP24XX_AUTO_PKA |
-			 OMAP24XX_AUTO_AES |
-			 OMAP24XX_AUTO_RNG |
-			 OMAP24XX_AUTO_SHA |
-			 OMAP24XX_AUTO_DES,
+	cm_write_mod_reg(OMAP24XX_AUTO_PKA_MASK |
+			 OMAP24XX_AUTO_AES_MASK |
+			 OMAP24XX_AUTO_RNG_MASK |
+			 OMAP24XX_AUTO_SHA_MASK |
+			 OMAP24XX_AUTO_DES_MASK,
 			 CORE_MOD, OMAP24XX_CM_AUTOIDLE4);
 
-	cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI, OMAP24XX_DSP_MOD, CM_AUTOIDLE);
+	cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI_MASK, OMAP24XX_DSP_MOD,
+			 CM_AUTOIDLE);
 
 	/* Put DPLL and both APLLs into autoidle mode */
 	cm_write_mod_reg((0x03 << OMAP24XX_AUTO_DPLL_SHIFT) |
@@ -444,12 +445,12 @@ static void __init prcm_setup_regs(void)
 			 (0x03 << OMAP24XX_AUTO_54M_SHIFT),
 			 PLL_MOD, CM_AUTOIDLE);
 
-	cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL |
-			 OMAP24XX_AUTO_WDT1 |
-			 OMAP24XX_AUTO_MPU_WDT |
-			 OMAP24XX_AUTO_GPIOS |
-			 OMAP24XX_AUTO_32KSYNC |
-			 OMAP24XX_AUTO_GPT1,
+	cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL_MASK |
+			 OMAP24XX_AUTO_WDT1_MASK |
+			 OMAP24XX_AUTO_MPU_WDT_MASK |
+			 OMAP24XX_AUTO_GPIOS_MASK |
+			 OMAP24XX_AUTO_32KSYNC_MASK |
+			 OMAP24XX_AUTO_GPT1_MASK,
 			 WKUP_MOD, CM_AUTOIDLE);
 
 	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
@@ -460,9 +461,9 @@ static void __init prcm_setup_regs(void)
 	/* Configure automatic voltage transition */
 	prm_write_mod_reg(2 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
 			  OMAP2_PRCM_VOLTSETUP_OFFSET);
-	prm_write_mod_reg(OMAP24XX_AUTO_EXTVOLT |
+	prm_write_mod_reg(OMAP24XX_AUTO_EXTVOLT_MASK |
 			  (0x1 << OMAP24XX_SETOFF_LEVEL_SHIFT) |
-			  OMAP24XX_MEMRETCTRL |
+			  OMAP24XX_MEMRETCTRL_MASK |
 			  (0x1 << OMAP24XX_SETRET_LEVEL_SHIFT) |
 			  (0x0 << OMAP24XX_VOLT_LEVEL_SHIFT),
 			  OMAP24XX_GR_MOD, OMAP2_PRCM_VOLTCTRL_OFFSET);

commit 43ffcd9a042858a9e9f9fe014bb073e55db34c67
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Jan 27 11:09:24 2009 -0800

    OMAP2/3: GPIO: generalize prepare for idle
    
    Currently, the GPIO 'prepare' hook is only called when going to
    off-mode, while the function is called 'prepare_for_retention.'  This
    patch renames the function to 'prepare_for_idle' and calls it for any
    powersate != PWRDM_POWER_ON passing in the powerstate.
    
    The hook itself is then responsible for doing various preparation
    based on the powerstate.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 374299ea7ade..7816c4e84a32 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -107,7 +107,7 @@ static void omap2_enter_full_retention(void)
 	l = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) | OMAP24XX_USBSTANDBYCTRL;
 	omap_ctrl_writel(l, OMAP2_CONTROL_DEVCONF0);
 
-	omap2_gpio_prepare_for_retention();
+	omap2_gpio_prepare_for_idle(PWRDM_POWER_RET);
 
 	if (omap2_pm_debug) {
 		omap2_pm_dump(0, 0, 0);
@@ -141,7 +141,7 @@ static void omap2_enter_full_retention(void)
 		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
 		omap2_pm_dump(0, 1, tmp);
 	}
-	omap2_gpio_resume_after_retention();
+	omap2_gpio_resume_after_idle();
 
 	clk_enable(osc_ck);
 

commit 369d5614457384edcf62c5f39b03dd20be6ea1df
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jan 26 20:13:01 2010 -0700

    OMAP clockdomains: add usecounting for wakeup and sleep dependencies
    
    Add usecounting for wakeup and sleep dependencies.  In the current
    situation, if several functions add dependencies on the same
    clockdomains, when the first dependency removal function is called,
    the dependency will be incorrectly removed from the hardware.
    
    Add clkdm_clear_all_wkdeps() and clkdm_clear_all_sleepdeps(), which
    provide a fast and usecounting-consistent way to clear all hardware
    clockdomain dependencies, since accesses to these registers can be
    quite slow.  pm{2,3}4xx.c has been updated to use these new functions.
    The original version of this patch did not touch these files, which
    previously wrote directly to the wkdep registers, and thus confused
    the usecounting code.  This problem was found by Kevin Hilman
    <khilman@deeprootsystems.com>.
    
    N.B.: This patch introduces one significant functional difference over
    the previous pm34xx.c code: sleepdeps are now cleared during
    clockdomain initialization, whereas previously they were left
    untouched.  This has been tested by Kevin and confirmed to work.
    
    The original version of this patch also did not take into
    consideration that some clockdomains do not have sleep or wakeup
    dependency sources, which caused NULL pointer dereferences.  This
    problem was debugged and fixed by Kevin Hilman
    <khilman@deeprootsystems.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jouni Högander <jouni.hogander@nokia.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 754381857cb6..374299ea7ade 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -57,11 +57,8 @@ static void (*omap2_sram_idle)(void);
 static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,
 				  void __iomem *sdrc_power);
 
-static struct powerdomain *mpu_pwrdm;
-static struct powerdomain *core_pwrdm;
-
-static struct clockdomain *dsp_clkdm;
-static struct clockdomain *gfx_clkdm;
+static struct powerdomain *mpu_pwrdm, *core_pwrdm;
+static struct clockdomain *dsp_clkdm, *mpu_clkdm, *wkup_clkdm, *gfx_clkdm;
 
 static struct clk *osc_ck, *emul_ck;
 
@@ -334,9 +331,17 @@ static struct platform_suspend_ops omap_pm_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
-static int _pm_clkdm_enable_hwsup(struct clockdomain *clkdm, void *unused)
+/* XXX This function should be shareable between OMAP2xxx and OMAP3 */
+static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
-	omap2_clkdm_allow_idle(clkdm);
+	clkdm_clear_all_wkdeps(clkdm);
+	clkdm_clear_all_sleepdeps(clkdm);
+
+	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
+		omap2_clkdm_allow_idle(clkdm);
+	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
+		 atomic_read(&clkdm->usecount) == 0)
+		omap2_clkdm_sleep(clkdm);
 	return 0;
 }
 
@@ -349,14 +354,6 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP24XX_AUTOIDLE, OCP_MOD,
 			  OMAP2_PRCM_SYSCONFIG_OFFSET);
 
-	/* Set all domain wakeup dependencies */
-	prm_write_mod_reg(OMAP_EN_WKUP_MASK, MPU_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, OMAP24XX_DSP_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, CORE_MOD, PM_WKDEP);
-	if (cpu_is_omap2430())
-		prm_write_mod_reg(0, OMAP2430_MDM_MOD, PM_WKDEP);
-
 	/*
 	 * Set CORE powerdomain memory banks to retain their contents
 	 * during RETENTION
@@ -385,8 +382,12 @@ static void __init prcm_setup_regs(void)
 	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
 	omap2_clkdm_sleep(gfx_clkdm);
 
-	/* Enable clockdomain hardware-supervised control for all clkdms */
-	clkdm_for_each(_pm_clkdm_enable_hwsup, NULL);
+	/*
+	 * Clear clockdomain wakeup dependencies and enable
+	 * hardware-supervised idle for all clkdms
+	 */
+	clkdm_for_each(clkdms_setup, NULL);
+	clkdm_add_wkdep(mpu_clkdm, wkup_clkdm);
 
 	/* Enable clock autoidle for all domains */
 	cm_write_mod_reg(OMAP24XX_AUTO_CAM |
@@ -482,7 +483,7 @@ static int __init omap2_pm_init(void)
 	l = prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_REVISION_OFFSET);
 	printk(KERN_INFO "PRCM revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
 
-	/* Look up important powerdomains, clockdomains */
+	/* Look up important powerdomains */
 
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 	if (!mpu_pwrdm)
@@ -492,9 +493,19 @@ static int __init omap2_pm_init(void)
 	if (!core_pwrdm)
 		pr_err("PM: core_pwrdm not found\n");
 
+	/* Look up important clockdomains */
+
+	mpu_clkdm = clkdm_lookup("mpu_clkdm");
+	if (!mpu_clkdm)
+		pr_err("PM: mpu_clkdm not found\n");
+
+	wkup_clkdm = clkdm_lookup("wkup_clkdm");
+	if (!wkup_clkdm)
+		pr_err("PM: wkup_clkdm not found\n");
+
 	dsp_clkdm = clkdm_lookup("dsp_clkdm");
 	if (!dsp_clkdm)
-		pr_err("PM: mpu_clkdm not found\n");
+		pr_err("PM: dsp_clkdm not found\n");
 
 	gfx_clkdm = clkdm_lookup("gfx_clkdm");
 	if (!gfx_clkdm)

commit 3790300903e6a98ce5f5391f4d435959266f79e7
Author: Abhijit Pagare <abhijitpagare@ti.com>
Date:   Tue Jan 26 20:12:51 2010 -0700

    ARM: OMAP4: PM: OMAP4 Power Domain Porting Related Clean-up.
    
    Module offsets were same for OMAP2 and OMAP3 while they differ for OMAP4.
    Hence we need different macros for identifying platform specific offsets.
    
    Signed-off-by: Abhijit Pagare <abhijitpagare@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index cba05b9f041f..754381857cb6 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -219,11 +219,12 @@ static void omap2_enter_mpu_retention(void)
 		/* Try to enter MPU retention */
 		prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
 				  OMAP_LOGICRETSTATE,
-				  MPU_MOD, PM_PWSTCTRL);
+				  MPU_MOD, OMAP2_PM_PWSTCTRL);
 	} else {
 		/* Block MPU retention */
 
-		prm_write_mod_reg(OMAP_LOGICRETSTATE, MPU_MOD, PM_PWSTCTRL);
+		prm_write_mod_reg(OMAP_LOGICRETSTATE, MPU_MOD,
+						 OMAP2_PM_PWSTCTRL);
 		only_idle = 1;
 	}
 

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index bff5c4e89742..cba05b9f041f 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -36,12 +36,12 @@
 #include <asm/mach-types.h>
 
 #include <mach/irqs.h>
-#include <mach/clock.h>
-#include <mach/sram.h>
-#include <mach/control.h>
-#include <mach/mux.h>
-#include <mach/dma.h>
-#include <mach/board.h>
+#include <plat/clock.h>
+#include <plat/sram.h>
+#include <plat/control.h>
+#include <plat/mux.h>
+#include <plat/dma.h>
+#include <plat/board.h>
 
 #include "prm.h"
 #include "prm-regbits-24xx.h"
@@ -50,8 +50,8 @@
 #include "sdrc.h"
 #include "pm.h"
 
-#include <mach/powerdomain.h>
-#include <mach/clockdomain.h>
+#include <plat/powerdomain.h>
+#include <plat/clockdomain.h>
 
 static void (*omap2_sram_idle)(void);
 static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,

commit a23456e9b02b3fae0fc78cb33fad69803a50e5bc
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Wed Oct 15 18:13:47 2008 +0300

    OMAP: PM: Add closures to clkdm_for_each and pwrdm_for_each.
    
    Add some infrastructure to easily iterate over clock and power
    domains.
    
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 528dbdc26e23..bff5c4e89742 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -333,7 +333,7 @@ static struct platform_suspend_ops omap_pm_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
-static int _pm_clkdm_enable_hwsup(struct clockdomain *clkdm)
+static int _pm_clkdm_enable_hwsup(struct clockdomain *clkdm, void *unused)
 {
 	omap2_clkdm_allow_idle(clkdm);
 	return 0;
@@ -385,7 +385,7 @@ static void __init prcm_setup_regs(void)
 	omap2_clkdm_sleep(gfx_clkdm);
 
 	/* Enable clockdomain hardware-supervised control for all clkdms */
-	clkdm_for_each(_pm_clkdm_enable_hwsup);
+	clkdm_for_each(_pm_clkdm_enable_hwsup, NULL);
 
 	/* Enable clock autoidle for all domains */
 	cm_write_mod_reg(OMAP24XX_AUTO_CAM |

commit 7cc515f74d2871daff106a17714bfd16bcb045ca
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jun 10 09:02:25 2009 -0700

    OMAP2/3: PM: make PM __init calls static
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index db1025562fb0..528dbdc26e23 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -470,7 +470,7 @@ static void __init prcm_setup_regs(void)
 			  WKUP_MOD, PM_WKEN);
 }
 
-int __init omap2_pm_init(void)
+static int __init omap2_pm_init(void)
 {
 	u32 l;
 

commit 4af4016c53f52b26461b8030211f8427a58fa5ed
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Feb 4 10:51:40 2009 -0800

    OMAP3: PM: UART: disable clocks when idle and off-mode support
    
    This patch allows the UART clocks to be disabled when the OMAP UARTs
    are inactive, thus permitting the chip to hit retention in idle.
    After the expiration of an activity timer, each UART is allowed to
    disable its clocks so the system can enter retention.  The activity
    timer is (re)activated on any UART interrupt, UART wake event or any
    IO pad wakeup.  The actual disable of the UART clocks is done in the
    'prepare_idle' hook called from the OMAP idle loop.
    
    While the activity timer is active, the smart-idle mode of the UART is
    also disabled.  This is due to a "feature" of the UART module that
    after a UART wakeup, the smart-idle mode may be entered before the
    UART has communicated the interrupt, or upon TX, an idle mode may be
    entered before the TX FIFOs are emptied.
    
    Upon suspend, the 'prepare_suspend' hook cancels any pending activity
    timers and allows the clocks to be disabled immediately.
    
    In addition, upon disabling clocks the UART state is saved in case
    of an off-mode transition while clocks are off.
    
    Special thanks to Tero Kristo for the initial ideas and first versions
    of UART idle support, and to Jouni Hogander for extra testing and
    bugfixes.
    
    Tested on OMAP3 (Beagle, RX51, SDP, EVM) and OMAP2 (n810)
    
    Cc: Tero Kristo <tero.kristo@nokia.com>
    Cc: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index d38f3121dde9..db1025562fb0 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -71,6 +71,11 @@ static int omap2_fclks_active(void)
 
 	f1 = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	f2 = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
+
+	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
+	f1 &= ~(OMAP24XX_EN_UART1 | OMAP24XX_EN_UART2);
+	f2 &= ~OMAP24XX_EN_UART3;
+
 	if (f1 | f2)
 		return 1;
 	return 0;
@@ -117,12 +122,20 @@ static void omap2_enter_full_retention(void)
 	if (omap_irq_pending())
 		goto no_sleep;
 
+	omap_uart_prepare_idle(0);
+	omap_uart_prepare_idle(1);
+	omap_uart_prepare_idle(2);
+
 	/* Jump to SRAM suspend code */
 	omap2_sram_suspend(sdrc_read_reg(SDRC_DLLA_CTRL),
 			   OMAP_SDRC_REGADDR(SDRC_DLLA_CTRL),
 			   OMAP_SDRC_REGADDR(SDRC_POWER));
-no_sleep:
 
+	omap_uart_resume_idle(2);
+	omap_uart_resume_idle(1);
+	omap_uart_resume_idle(0);
+
+no_sleep:
 	if (omap2_pm_debug) {
 		unsigned long long tmp;
 
@@ -283,6 +296,7 @@ static int omap2_pm_suspend(void)
 	mir1 = omap_readl(0x480fe0a4);
 	omap_writel(1 << 5, 0x480fe0ac);
 
+	omap_uart_prepare_suspend();
 	omap2_enter_full_retention();
 
 	omap_writel(mir1, 0x480fe0a4);

commit 94434535bd36ca010a81e1199f954beef2c4de64
Author: Jouni Hogander <jouni.hogander@nokia.com>
Date:   Tue Feb 3 15:49:04 2009 -0800

    OMAP: Add new function to check wether there is irq pending
    
    Add common omap2/3 function to check wether there is irq pending.
    Switch to use it in omap2 pm code instead of its own.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
index 232b9f6032e8..d38f3121dde9 100644
--- a/arch/arm/mach-omap2/pm24xx.c
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -76,19 +76,6 @@ static int omap2_fclks_active(void)
 	return 0;
 }
 
-static int omap2_irq_pending(void)
-{
-	u32 pending_reg = 0x480fe098;
-	int i;
-
-	for (i = 0; i < 4; i++) {
-		if (omap_readl(pending_reg))
-			return 1;
-		pending_reg += 0x20;
-	}
-	return 0;
-}
-
 static void omap2_enter_full_retention(void)
 {
 	u32 l;
@@ -127,7 +114,7 @@ static void omap2_enter_full_retention(void)
 
 	/* One last check for pending IRQs to avoid extra latency due
 	 * to sleeping unnecessarily. */
-	if (omap2_irq_pending())
+	if (omap_irq_pending())
 		goto no_sleep;
 
 	/* Jump to SRAM suspend code */
@@ -262,13 +249,13 @@ static void omap2_pm_idle(void)
 	local_fiq_disable();
 
 	if (!omap2_can_sleep()) {
-		if (omap2_irq_pending())
+		if (omap_irq_pending())
 			goto out;
 		omap2_enter_mpu_retention();
 		goto out;
 	}
 
-	if (omap2_irq_pending())
+	if (omap_irq_pending())
 		goto out;
 
 	omap2_enter_full_retention();

commit 8bd229492209c0c7d050e2f9a600c12f035d72f7
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu May 28 10:56:16 2009 -0700

    OMAP2/3: PM: push core PM code from linux-omap
    
    This patch is to sync the core linux-omap PM code with mainline.  This
    code has evolved and been used for a while the linux-omap tree, but
    the attempt here is to finally get this into mainline.
    
    Following this will be a series of patches from the 'PM branch' of the
    linux-omap tree to add full PM hardware support from the linux-omap
    tree.
    
    Much of this PM core code was written by Jouni Hogander with
    significant contributions from Paul Walmsley as well as many others
    from Nokia, Texas Instruments and linux-omap community.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm24xx.c b/arch/arm/mach-omap2/pm24xx.c
new file mode 100644
index 000000000000..232b9f6032e8
--- /dev/null
+++ b/arch/arm/mach-omap2/pm24xx.c
@@ -0,0 +1,548 @@
+/*
+ * OMAP2 Power Management Routines
+ *
+ * Copyright (C) 2005 Texas Instruments, Inc.
+ * Copyright (C) 2006-2008 Nokia Corporation
+ *
+ * Written by:
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Tony Lindgren
+ * Juha Yrjola
+ * Amit Kucheria <amit.kucheria@nokia.com>
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * Based on pm.c for omap1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/suspend.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/time.h>
+#include <linux/gpio.h>
+
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/irqs.h>
+#include <mach/clock.h>
+#include <mach/sram.h>
+#include <mach/control.h>
+#include <mach/mux.h>
+#include <mach/dma.h>
+#include <mach/board.h>
+
+#include "prm.h"
+#include "prm-regbits-24xx.h"
+#include "cm.h"
+#include "cm-regbits-24xx.h"
+#include "sdrc.h"
+#include "pm.h"
+
+#include <mach/powerdomain.h>
+#include <mach/clockdomain.h>
+
+static void (*omap2_sram_idle)(void);
+static void (*omap2_sram_suspend)(u32 dllctrl, void __iomem *sdrc_dlla_ctrl,
+				  void __iomem *sdrc_power);
+
+static struct powerdomain *mpu_pwrdm;
+static struct powerdomain *core_pwrdm;
+
+static struct clockdomain *dsp_clkdm;
+static struct clockdomain *gfx_clkdm;
+
+static struct clk *osc_ck, *emul_ck;
+
+static int omap2_fclks_active(void)
+{
+	u32 f1, f2;
+
+	f1 = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	f2 = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
+	if (f1 | f2)
+		return 1;
+	return 0;
+}
+
+static int omap2_irq_pending(void)
+{
+	u32 pending_reg = 0x480fe098;
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		if (omap_readl(pending_reg))
+			return 1;
+		pending_reg += 0x20;
+	}
+	return 0;
+}
+
+static void omap2_enter_full_retention(void)
+{
+	u32 l;
+	struct timespec ts_preidle, ts_postidle, ts_idle;
+
+	/* There is 1 reference hold for all children of the oscillator
+	 * clock, the following will remove it. If no one else uses the
+	 * oscillator itself it will be disabled if/when we enter retention
+	 * mode.
+	 */
+	clk_disable(osc_ck);
+
+	/* Clear old wake-up events */
+	/* REVISIT: These write to reserved bits? */
+	prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+	prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+
+	/*
+	 * Set MPU powerdomain's next power state to RETENTION;
+	 * preserve logic state during retention
+	 */
+	pwrdm_set_logic_retst(mpu_pwrdm, PWRDM_POWER_RET);
+	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
+
+	/* Workaround to kill USB */
+	l = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) | OMAP24XX_USBSTANDBYCTRL;
+	omap_ctrl_writel(l, OMAP2_CONTROL_DEVCONF0);
+
+	omap2_gpio_prepare_for_retention();
+
+	if (omap2_pm_debug) {
+		omap2_pm_dump(0, 0, 0);
+		getnstimeofday(&ts_preidle);
+	}
+
+	/* One last check for pending IRQs to avoid extra latency due
+	 * to sleeping unnecessarily. */
+	if (omap2_irq_pending())
+		goto no_sleep;
+
+	/* Jump to SRAM suspend code */
+	omap2_sram_suspend(sdrc_read_reg(SDRC_DLLA_CTRL),
+			   OMAP_SDRC_REGADDR(SDRC_DLLA_CTRL),
+			   OMAP_SDRC_REGADDR(SDRC_POWER));
+no_sleep:
+
+	if (omap2_pm_debug) {
+		unsigned long long tmp;
+
+		getnstimeofday(&ts_postidle);
+		ts_idle = timespec_sub(ts_postidle, ts_preidle);
+		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
+		omap2_pm_dump(0, 1, tmp);
+	}
+	omap2_gpio_resume_after_retention();
+
+	clk_enable(osc_ck);
+
+	/* clear CORE wake-up events */
+	prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+
+	/* wakeup domain events - bit 1: GPT1, bit5 GPIO */
+	prm_clear_mod_reg_bits(0x4 | 0x1, WKUP_MOD, PM_WKST);
+
+	/* MPU domain wake events */
+	l = prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	if (l & 0x01)
+		prm_write_mod_reg(0x01, OCP_MOD,
+				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+	if (l & 0x20)
+		prm_write_mod_reg(0x20, OCP_MOD,
+				  OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+
+	/* Mask future PRCM-to-MPU interrupts */
+	prm_write_mod_reg(0x0, OCP_MOD, OMAP2_PRCM_IRQSTATUS_MPU_OFFSET);
+}
+
+static int omap2_i2c_active(void)
+{
+	u32 l;
+
+	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	return l & (OMAP2420_EN_I2C2 | OMAP2420_EN_I2C1);
+}
+
+static int sti_console_enabled;
+
+static int omap2_allow_mpu_retention(void)
+{
+	u32 l;
+
+	/* Check for MMC, UART2, UART1, McSPI2, McSPI1 and DSS1. */
+	l = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	if (l & (OMAP2420_EN_MMC | OMAP24XX_EN_UART2 |
+		 OMAP24XX_EN_UART1 | OMAP24XX_EN_MCSPI2 |
+		 OMAP24XX_EN_MCSPI1 | OMAP24XX_EN_DSS1))
+		return 0;
+	/* Check for UART3. */
+	l = cm_read_mod_reg(CORE_MOD, OMAP24XX_CM_FCLKEN2);
+	if (l & OMAP24XX_EN_UART3)
+		return 0;
+	if (sti_console_enabled)
+		return 0;
+
+	return 1;
+}
+
+static void omap2_enter_mpu_retention(void)
+{
+	int only_idle = 0;
+	struct timespec ts_preidle, ts_postidle, ts_idle;
+
+	/* Putting MPU into the WFI state while a transfer is active
+	 * seems to cause the I2C block to timeout. Why? Good question. */
+	if (omap2_i2c_active())
+		return;
+
+	/* The peripherals seem not to be able to wake up the MPU when
+	 * it is in retention mode. */
+	if (omap2_allow_mpu_retention()) {
+		/* REVISIT: These write to reserved bits? */
+		prm_write_mod_reg(0xffffffff, CORE_MOD, PM_WKST1);
+		prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP24XX_PM_WKST2);
+		prm_write_mod_reg(0xffffffff, WKUP_MOD, PM_WKST);
+
+		/* Try to enter MPU retention */
+		prm_write_mod_reg((0x01 << OMAP_POWERSTATE_SHIFT) |
+				  OMAP_LOGICRETSTATE,
+				  MPU_MOD, PM_PWSTCTRL);
+	} else {
+		/* Block MPU retention */
+
+		prm_write_mod_reg(OMAP_LOGICRETSTATE, MPU_MOD, PM_PWSTCTRL);
+		only_idle = 1;
+	}
+
+	if (omap2_pm_debug) {
+		omap2_pm_dump(only_idle ? 2 : 1, 0, 0);
+		getnstimeofday(&ts_preidle);
+	}
+
+	omap2_sram_idle();
+
+	if (omap2_pm_debug) {
+		unsigned long long tmp;
+
+		getnstimeofday(&ts_postidle);
+		ts_idle = timespec_sub(ts_postidle, ts_preidle);
+		tmp = timespec_to_ns(&ts_idle) * NSEC_PER_USEC;
+		omap2_pm_dump(only_idle ? 2 : 1, 1, tmp);
+	}
+}
+
+static int omap2_can_sleep(void)
+{
+	if (omap2_fclks_active())
+		return 0;
+	if (osc_ck->usecount > 1)
+		return 0;
+	if (omap_dma_running())
+		return 0;
+
+	return 1;
+}
+
+static void omap2_pm_idle(void)
+{
+	local_irq_disable();
+	local_fiq_disable();
+
+	if (!omap2_can_sleep()) {
+		if (omap2_irq_pending())
+			goto out;
+		omap2_enter_mpu_retention();
+		goto out;
+	}
+
+	if (omap2_irq_pending())
+		goto out;
+
+	omap2_enter_full_retention();
+
+out:
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+static int omap2_pm_prepare(void)
+{
+	/* We cannot sleep in idle until we have resumed */
+	disable_hlt();
+	return 0;
+}
+
+static int omap2_pm_suspend(void)
+{
+	u32 wken_wkup, mir1;
+
+	wken_wkup = prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+	prm_write_mod_reg(wken_wkup & ~OMAP24XX_EN_GPT1, WKUP_MOD, PM_WKEN);
+
+	/* Mask GPT1 */
+	mir1 = omap_readl(0x480fe0a4);
+	omap_writel(1 << 5, 0x480fe0ac);
+
+	omap2_enter_full_retention();
+
+	omap_writel(mir1, 0x480fe0a4);
+	prm_write_mod_reg(wken_wkup, WKUP_MOD, PM_WKEN);
+
+	return 0;
+}
+
+static int omap2_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		ret = omap2_pm_suspend();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void omap2_pm_finish(void)
+{
+	enable_hlt();
+}
+
+static struct platform_suspend_ops omap_pm_ops = {
+	.prepare	= omap2_pm_prepare,
+	.enter		= omap2_pm_enter,
+	.finish		= omap2_pm_finish,
+	.valid		= suspend_valid_only_mem,
+};
+
+static int _pm_clkdm_enable_hwsup(struct clockdomain *clkdm)
+{
+	omap2_clkdm_allow_idle(clkdm);
+	return 0;
+}
+
+static void __init prcm_setup_regs(void)
+{
+	int i, num_mem_banks;
+	struct powerdomain *pwrdm;
+
+	/* Enable autoidle */
+	prm_write_mod_reg(OMAP24XX_AUTOIDLE, OCP_MOD,
+			  OMAP2_PRCM_SYSCONFIG_OFFSET);
+
+	/* Set all domain wakeup dependencies */
+	prm_write_mod_reg(OMAP_EN_WKUP_MASK, MPU_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, OMAP24XX_DSP_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, CORE_MOD, PM_WKDEP);
+	if (cpu_is_omap2430())
+		prm_write_mod_reg(0, OMAP2430_MDM_MOD, PM_WKDEP);
+
+	/*
+	 * Set CORE powerdomain memory banks to retain their contents
+	 * during RETENTION
+	 */
+	num_mem_banks = pwrdm_get_mem_bank_count(core_pwrdm);
+	for (i = 0; i < num_mem_banks; i++)
+		pwrdm_set_mem_retst(core_pwrdm, i, PWRDM_POWER_RET);
+
+	/* Set CORE powerdomain's next power state to RETENTION */
+	pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
+
+	/*
+	 * Set MPU powerdomain's next power state to RETENTION;
+	 * preserve logic state during retention
+	 */
+	pwrdm_set_logic_retst(mpu_pwrdm, PWRDM_POWER_RET);
+	pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_RET);
+
+	/* Force-power down DSP, GFX powerdomains */
+
+	pwrdm = clkdm_get_pwrdm(dsp_clkdm);
+	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
+	omap2_clkdm_sleep(dsp_clkdm);
+
+	pwrdm = clkdm_get_pwrdm(gfx_clkdm);
+	pwrdm_set_next_pwrst(pwrdm, PWRDM_POWER_OFF);
+	omap2_clkdm_sleep(gfx_clkdm);
+
+	/* Enable clockdomain hardware-supervised control for all clkdms */
+	clkdm_for_each(_pm_clkdm_enable_hwsup);
+
+	/* Enable clock autoidle for all domains */
+	cm_write_mod_reg(OMAP24XX_AUTO_CAM |
+			 OMAP24XX_AUTO_MAILBOXES |
+			 OMAP24XX_AUTO_WDT4 |
+			 OMAP2420_AUTO_WDT3 |
+			 OMAP24XX_AUTO_MSPRO |
+			 OMAP2420_AUTO_MMC |
+			 OMAP24XX_AUTO_FAC |
+			 OMAP2420_AUTO_EAC |
+			 OMAP24XX_AUTO_HDQ |
+			 OMAP24XX_AUTO_UART2 |
+			 OMAP24XX_AUTO_UART1 |
+			 OMAP24XX_AUTO_I2C2 |
+			 OMAP24XX_AUTO_I2C1 |
+			 OMAP24XX_AUTO_MCSPI2 |
+			 OMAP24XX_AUTO_MCSPI1 |
+			 OMAP24XX_AUTO_MCBSP2 |
+			 OMAP24XX_AUTO_MCBSP1 |
+			 OMAP24XX_AUTO_GPT12 |
+			 OMAP24XX_AUTO_GPT11 |
+			 OMAP24XX_AUTO_GPT10 |
+			 OMAP24XX_AUTO_GPT9 |
+			 OMAP24XX_AUTO_GPT8 |
+			 OMAP24XX_AUTO_GPT7 |
+			 OMAP24XX_AUTO_GPT6 |
+			 OMAP24XX_AUTO_GPT5 |
+			 OMAP24XX_AUTO_GPT4 |
+			 OMAP24XX_AUTO_GPT3 |
+			 OMAP24XX_AUTO_GPT2 |
+			 OMAP2420_AUTO_VLYNQ |
+			 OMAP24XX_AUTO_DSS,
+			 CORE_MOD, CM_AUTOIDLE1);
+	cm_write_mod_reg(OMAP24XX_AUTO_UART3 |
+			 OMAP24XX_AUTO_SSI |
+			 OMAP24XX_AUTO_USB,
+			 CORE_MOD, CM_AUTOIDLE2);
+	cm_write_mod_reg(OMAP24XX_AUTO_SDRC |
+			 OMAP24XX_AUTO_GPMC |
+			 OMAP24XX_AUTO_SDMA,
+			 CORE_MOD, CM_AUTOIDLE3);
+	cm_write_mod_reg(OMAP24XX_AUTO_PKA |
+			 OMAP24XX_AUTO_AES |
+			 OMAP24XX_AUTO_RNG |
+			 OMAP24XX_AUTO_SHA |
+			 OMAP24XX_AUTO_DES,
+			 CORE_MOD, OMAP24XX_CM_AUTOIDLE4);
+
+	cm_write_mod_reg(OMAP2420_AUTO_DSP_IPI, OMAP24XX_DSP_MOD, CM_AUTOIDLE);
+
+	/* Put DPLL and both APLLs into autoidle mode */
+	cm_write_mod_reg((0x03 << OMAP24XX_AUTO_DPLL_SHIFT) |
+			 (0x03 << OMAP24XX_AUTO_96M_SHIFT) |
+			 (0x03 << OMAP24XX_AUTO_54M_SHIFT),
+			 PLL_MOD, CM_AUTOIDLE);
+
+	cm_write_mod_reg(OMAP24XX_AUTO_OMAPCTRL |
+			 OMAP24XX_AUTO_WDT1 |
+			 OMAP24XX_AUTO_MPU_WDT |
+			 OMAP24XX_AUTO_GPIOS |
+			 OMAP24XX_AUTO_32KSYNC |
+			 OMAP24XX_AUTO_GPT1,
+			 WKUP_MOD, CM_AUTOIDLE);
+
+	/* REVISIT: Configure number of 32 kHz clock cycles for sys_clk
+	 * stabilisation */
+	prm_write_mod_reg(15 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
+			  OMAP2_PRCM_CLKSSETUP_OFFSET);
+
+	/* Configure automatic voltage transition */
+	prm_write_mod_reg(2 << OMAP_SETUP_TIME_SHIFT, OMAP24XX_GR_MOD,
+			  OMAP2_PRCM_VOLTSETUP_OFFSET);
+	prm_write_mod_reg(OMAP24XX_AUTO_EXTVOLT |
+			  (0x1 << OMAP24XX_SETOFF_LEVEL_SHIFT) |
+			  OMAP24XX_MEMRETCTRL |
+			  (0x1 << OMAP24XX_SETRET_LEVEL_SHIFT) |
+			  (0x0 << OMAP24XX_VOLT_LEVEL_SHIFT),
+			  OMAP24XX_GR_MOD, OMAP2_PRCM_VOLTCTRL_OFFSET);
+
+	/* Enable wake-up events */
+	prm_write_mod_reg(OMAP24XX_EN_GPIOS | OMAP24XX_EN_GPT1,
+			  WKUP_MOD, PM_WKEN);
+}
+
+int __init omap2_pm_init(void)
+{
+	u32 l;
+
+	if (!cpu_is_omap24xx())
+		return -ENODEV;
+
+	printk(KERN_INFO "Power Management for OMAP2 initializing\n");
+	l = prm_read_mod_reg(OCP_MOD, OMAP2_PRCM_REVISION_OFFSET);
+	printk(KERN_INFO "PRCM revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
+
+	/* Look up important powerdomains, clockdomains */
+
+	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
+	if (!mpu_pwrdm)
+		pr_err("PM: mpu_pwrdm not found\n");
+
+	core_pwrdm = pwrdm_lookup("core_pwrdm");
+	if (!core_pwrdm)
+		pr_err("PM: core_pwrdm not found\n");
+
+	dsp_clkdm = clkdm_lookup("dsp_clkdm");
+	if (!dsp_clkdm)
+		pr_err("PM: mpu_clkdm not found\n");
+
+	gfx_clkdm = clkdm_lookup("gfx_clkdm");
+	if (!gfx_clkdm)
+		pr_err("PM: gfx_clkdm not found\n");
+
+
+	osc_ck = clk_get(NULL, "osc_ck");
+	if (IS_ERR(osc_ck)) {
+		printk(KERN_ERR "could not get osc_ck\n");
+		return -ENODEV;
+	}
+
+	if (cpu_is_omap242x()) {
+		emul_ck = clk_get(NULL, "emul_ck");
+		if (IS_ERR(emul_ck)) {
+			printk(KERN_ERR "could not get emul_ck\n");
+			clk_put(osc_ck);
+			return -ENODEV;
+		}
+	}
+
+	prcm_setup_regs();
+
+	/* Hack to prevent MPU retention when STI console is enabled. */
+	{
+		const struct omap_sti_console_config *sti;
+
+		sti = omap_get_config(OMAP_TAG_STI_CONSOLE,
+				      struct omap_sti_console_config);
+		if (sti != NULL && sti->enable)
+			sti_console_enabled = 1;
+	}
+
+	/*
+	 * We copy the assembler sleep/wakeup routines to SRAM.
+	 * These routines need to be in SRAM as that's the only
+	 * memory the MPU can see when it wakes up.
+	 */
+	if (cpu_is_omap24xx()) {
+		omap2_sram_idle = omap_sram_push(omap24xx_idle_loop_suspend,
+						 omap24xx_idle_loop_suspend_sz);
+
+		omap2_sram_suspend = omap_sram_push(omap24xx_cpu_suspend,
+						    omap24xx_cpu_suspend_sz);
+	}
+
+	suspend_set_ops(&omap_pm_ops);
+	pm_idle = omap2_pm_idle;
+
+	return 0;
+}
+
+late_initcall(omap2_pm_init);
