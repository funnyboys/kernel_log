commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index c2a6fbd7f8a9..a0c4c42e56b9 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/arch/arm/mach-omap2/usb-tusb6010.c
  *
  * Copyright (C) 2006 Nokia Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/err.h>

commit 602105ed740d89da00ac7cf3842f5ecd52a58461
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 17 00:47:34 2016 -0700

    ARM: OMAP2+: Remove legacy muxing for usb-tusb6010.c
    
    We are moving to device tree based booting, and this should be
    done using pinctrl-single instead.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index e554d9e66a1c..c2a6fbd7f8a9 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -22,8 +22,6 @@
 
 #include "gpmc.h"
 
-#include "mux.h"
-
 static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
 
@@ -226,25 +224,6 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	}
 	tusb_device.dev.platform_data = data;
 
-	/* REVISIT let the driver know what DMA channels work */
-	if (!dmachan)
-		tusb_device.dev.dma_mask = NULL;
-	else {
-		/* assume OMAP 2420 ES2.0 and later */
-		if (dmachan & (1 << 0))
-			omap_mux_init_signal("sys_ndmareq0", 0);
-		if (dmachan & (1 << 1))
-			omap_mux_init_signal("sys_ndmareq1", 0);
-		if (dmachan & (1 << 2))
-			omap_mux_init_signal("sys_ndmareq2", 0);
-		if (dmachan & (1 << 3))
-			omap_mux_init_signal("sys_ndmareq3", 0);
-		if (dmachan & (1 << 4))
-			omap_mux_init_signal("sys_ndmareq4", 0);
-		if (dmachan & (1 << 5))
-			omap_mux_init_signal("sys_ndmareq5", 0);
-	}
-
 	/* so far so good ... register the device */
 	status = platform_device_register(&tusb_device);
 	if (status < 0) {

commit 2e67690137f3a7bac660edd548f8846709c55381
Author: Robert ABEL <rabel@cit-ec.uni-bielefeld.de>
Date:   Fri Feb 27 16:56:53 2015 +0100

    ARM OMAP2+ GPMC: calculate GPMCFCLKDIVIDER based on WAITMONITORINGTIME
    
    The WAITMONITORINGTIME is expressed as a number of GPMC_CLK clock cycles,
    even though the access is defined as asynchronous, and no GPMC_CLK clock
    is provided to the external device. Still, GPMCFCLKDIVIDER is used as a divider
    for the GPMC clock, so it must be programmed to define the
    correct WAITMONITORINGTIME delay.
    
    Calculate GPMCFCLKDIVIDER independent of gpmc,sync-clk-ps in DT for
    pure asynchronous accesses, i.e. both read and write asynchronous.
    
    Signed-off-by: Robert ABEL <rabel@cit-ec.uni-bielefeld.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 8333400898fb..e554d9e66a1c 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -71,7 +71,7 @@ static int tusb_set_async_mode(unsigned sysclk_ps)
 
 	gpmc_calc_timings(&t, &tusb_async, &dev_t);
 
-	return gpmc_cs_set_timings(async_cs, &t);
+	return gpmc_cs_set_timings(async_cs, &t, &tusb_async);
 }
 
 static int tusb_set_sync_mode(unsigned sysclk_ps)
@@ -98,7 +98,7 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 
 	gpmc_calc_timings(&t, &tusb_sync, &dev_t);
 
-	return gpmc_cs_set_timings(sync_cs, &t);
+	return gpmc_cs_set_timings(sync_cs, &t, &tusb_sync);
 }
 
 /* tusb driver calls this when it changes the chip's clocking */

commit cb4ab22f722b6d550a078747390a26570fb0e208
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Mon Jul 7 04:52:31 2014 -0700

    ARM: omap2+: usb-tusb6010.c: Cleaning up variable is set more than once
    
    A struct member variable is set to the same value more than once
    
    This was found using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index e832bc7b8e2d..8333400898fb 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -95,7 +95,6 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 	dev_t.t_avdp_w = t_scsnh_advnh;
 	dev_t.cyc_aavdh_we = 3;
 	dev_t.cyc_wpl = 6;
-	dev_t.t_ce_rdyz = 7000;
 
 	gpmc_calc_timings(&t, &tusb_sync, &dev_t);
 

commit 012e338625f5ea58d2a16cf98a44779255b458ca
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Feb 21 13:01:47 2013 -0600

    ARM: OMAP2+: Convert TUSB to use gpmc_cs_program_settings()
    
    Convert the OMAP2+ TUSB code to use the gpmc_cs_program_settings()
    function for configuring the various GPMC options instead of directly
    programming the CONFIG1 register.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index faaf96dca0fa..e832bc7b8e2d 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -8,6 +8,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/err.h>
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -27,12 +28,21 @@ static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
 
 static struct gpmc_settings tusb_async = {
+	.wait_on_read	= true,
+	.wait_on_write	= true,
+	.device_width	= GPMC_DEVWIDTH_16BIT,
 	.mux_add_data	= GPMC_MUX_AD,
 };
 
 static struct gpmc_settings tusb_sync = {
+	.burst_read	= true,
+	.burst_write	= true,
 	.sync_read	= true,
 	.sync_write	= true,
+	.wait_on_read	= true,
+	.wait_on_write	= true,
+	.burst_len	= GPMC_BURST_16,
+	.device_width	= GPMC_DEVWIDTH_16BIT,
 	.mux_add_data	= GPMC_MUX_AD,
 };
 
@@ -168,18 +178,12 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		return status;
 	}
 	tusb_resources[0].end = tusb_resources[0].start + 0x9ff;
+	tusb_async.wait_pin = waitpin;
 	async_cs = async;
-	gpmc_cs_write_reg(async, GPMC_CS_CONFIG1,
-			  GPMC_CONFIG1_PAGE_LEN(2)
-			| GPMC_CONFIG1_WAIT_READ_MON
-			| GPMC_CONFIG1_WAIT_WRITE_MON
-			| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)
-			| GPMC_CONFIG1_READTYPE_ASYNC
-			| GPMC_CONFIG1_WRITETYPE_ASYNC
-			| GPMC_CONFIG1_DEVICESIZE_16
-			| GPMC_CONFIG1_DEVICETYPE_NOR
-			| GPMC_CONFIG1_MUXADDDATA);
 
+	status = gpmc_cs_program_settings(async_cs, &tusb_async);
+	if (status < 0)
+		return status;
 
 	/* SYNC region, primarily for DMA */
 	status = gpmc_cs_request(sync, SZ_16M, (unsigned long *)
@@ -189,21 +193,12 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		return status;
 	}
 	tusb_resources[1].end = tusb_resources[1].start + 0x9ff;
+	tusb_sync.wait_pin = waitpin;
 	sync_cs = sync;
-	gpmc_cs_write_reg(sync, GPMC_CS_CONFIG1,
-			  GPMC_CONFIG1_READMULTIPLE_SUPP
-			| GPMC_CONFIG1_READTYPE_SYNC
-			| GPMC_CONFIG1_WRITEMULTIPLE_SUPP
-			| GPMC_CONFIG1_WRITETYPE_SYNC
-			| GPMC_CONFIG1_PAGE_LEN(2)
-			| GPMC_CONFIG1_WAIT_READ_MON
-			| GPMC_CONFIG1_WAIT_WRITE_MON
-			| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)
-			| GPMC_CONFIG1_DEVICESIZE_16
-			| GPMC_CONFIG1_DEVICETYPE_NOR
-			| GPMC_CONFIG1_MUXADDDATA
-			/* fclk divider gets set later */
-			);
+
+	status = gpmc_cs_program_settings(sync_cs, &tusb_sync);
+	if (status < 0)
+		return status;
 
 	/* IRQ */
 	status = gpio_request_one(irq, GPIOF_IN, "TUSB6010 irq");

commit c3be5b457ae1bb6dc93ef25bfa03e595969acbfc
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Feb 21 13:46:22 2013 -0600

    ARM: OMAP2+: Add structure for storing GPMC settings
    
    The GPMC has various different configuration options such as bus-width,
    synchronous or asychronous mode selection, burst mode options etc.
    Currently, there is no central structure for storing all these options
    when configuring the GPMC for a given device. Some of the options are
    stored in the GPMC timing structure and some are directly programmed
    into the GPMC configuration register. Add a new structure to store
    these options and convert code to use this structure. Adding this
    structure will allow us to create a common function for configuring
    these options.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index c5a3c6f9504e..faaf96dca0fa 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -26,6 +26,15 @@
 static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
 
+static struct gpmc_settings tusb_async = {
+	.mux_add_data	= GPMC_MUX_AD,
+};
+
+static struct gpmc_settings tusb_sync = {
+	.sync_read	= true,
+	.sync_write	= true,
+	.mux_add_data	= GPMC_MUX_AD,
+};
 
 /* NOTE:  timings are from tusb 6010 datasheet Rev 1.8, 12-Sept 2006 */
 
@@ -37,8 +46,6 @@ static int tusb_set_async_mode(unsigned sysclk_ps)
 
 	memset(&dev_t, 0, sizeof(dev_t));
 
-	dev_t.mux = true;
-
 	dev_t.t_ceasu = 8 * 1000;
 	dev_t.t_avdasu = t_acsnh_advnh - 7000;
 	dev_t.t_ce_avd = 1000;
@@ -52,7 +59,7 @@ static int tusb_set_async_mode(unsigned sysclk_ps)
 	dev_t.t_wpl = 300;
 	dev_t.cyc_aavdh_we = 1;
 
-	gpmc_calc_timings(&t, &dev_t);
+	gpmc_calc_timings(&t, &tusb_async, &dev_t);
 
 	return gpmc_cs_set_timings(async_cs, &t);
 }
@@ -65,10 +72,6 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 
 	memset(&dev_t, 0, sizeof(dev_t));
 
-	dev_t.mux = true;
-	dev_t.sync_read = true;
-	dev_t.sync_write = true;
-
 	dev_t.clk = 11100;
 	dev_t.t_bacc = 1000;
 	dev_t.t_ces = 1000;
@@ -84,7 +87,7 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 	dev_t.cyc_wpl = 6;
 	dev_t.t_ce_rdyz = 7000;
 
-	gpmc_calc_timings(&t, &dev_t);
+	gpmc_calc_timings(&t, &tusb_sync, &dev_t);
 
 	return gpmc_cs_set_timings(sync_cs, &t);
 }

commit 47acde16726080e5157b602f23937d00a04cd2ed
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Aug 17 12:16:14 2012 +0530

    ARM: OMAP2+: tusb6010: generic timing calculation
    
    Generic gpmc timing calculation helper is available now, use
    it instead of custom timing calculation.
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 5be96c6e1416..c5a3c6f9504e 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -27,182 +27,88 @@ static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
 
 
-/* t2_ps, when quantized to fclk units, must happen no earlier than
- * the clock after after t1_NS.
- *
- * Return a possibly updated value of t2_ps, converted to nsec.
- */
-static unsigned
-next_clk(unsigned t1_NS, unsigned t2_ps, unsigned fclk_ps)
-{
-	unsigned	t1_ps = t1_NS * 1000;
-	unsigned	t1_f, t2_f;
-
-	if ((t1_ps + fclk_ps) < t2_ps)
-		return t2_ps / 1000;
-
-	t1_f = (t1_ps + fclk_ps - 1) / fclk_ps;
-	t2_f = (t2_ps + fclk_ps - 1) / fclk_ps;
-
-	if (t1_f >= t2_f)
-		t2_f = t1_f + 1;
-
-	return (t2_f * fclk_ps) / 1000;
-}
-
 /* NOTE:  timings are from tusb 6010 datasheet Rev 1.8, 12-Sept 2006 */
 
-static int tusb_set_async_mode(unsigned sysclk_ps, unsigned fclk_ps)
+static int tusb_set_async_mode(unsigned sysclk_ps)
 {
+	struct gpmc_device_timings dev_t;
 	struct gpmc_timings	t;
 	unsigned		t_acsnh_advnh = sysclk_ps + 3000;
-	unsigned		tmp;
-
-	memset(&t, 0, sizeof(t));
-
-	/* CS_ON = t_acsnh_acsnl */
-	t.cs_on = 8;
-	/* ADV_ON = t_acsnh_advnh - t_advn */
-	t.adv_on = next_clk(t.cs_on, t_acsnh_advnh - 7000, fclk_ps);
-
-	/*
-	 * READ ... from omap2420 TRM fig 12-13
-	 */
-
-	/* ADV_RD_OFF = t_acsnh_advnh */
-	t.adv_rd_off = next_clk(t.adv_on, t_acsnh_advnh, fclk_ps);
-
-	/* OE_ON = t_acsnh_advnh + t_advn_oen (then wait for nRDY) */
-	t.oe_on = next_clk(t.adv_on, t_acsnh_advnh + 1000, fclk_ps);
-
-	/* ACCESS = counters continue only after nRDY */
-	tmp = t.oe_on * 1000 + 300;
-	t.access = next_clk(t.oe_on, tmp, fclk_ps);
-
-	/* OE_OFF = after data gets sampled */
-	tmp = t.access * 1000;
-	t.oe_off = next_clk(t.access, tmp, fclk_ps);
-
-	t.cs_rd_off = t.oe_off;
-
-	tmp = t.cs_rd_off * 1000 + 7000 /* t_acsn_rdy_z */;
-	t.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);
-
-	/*
-	 * WRITE ... from omap2420 TRM fig 12-15
-	 */
 
-	/* ADV_WR_OFF = t_acsnh_advnh */
-	t.adv_wr_off = t.adv_rd_off;
+	memset(&dev_t, 0, sizeof(dev_t));
 
-	/* WE_ON = t_acsnh_advnh + t_advn_wen (then wait for nRDY) */
-	t.we_on = next_clk(t.adv_wr_off, t_acsnh_advnh + 1000, fclk_ps);
+	dev_t.mux = true;
 
-	/* WE_OFF = after data gets sampled */
-	tmp = t.we_on * 1000 + 300;
-	t.we_off = next_clk(t.we_on, tmp, fclk_ps);
+	dev_t.t_ceasu = 8 * 1000;
+	dev_t.t_avdasu = t_acsnh_advnh - 7000;
+	dev_t.t_ce_avd = 1000;
+	dev_t.t_avdp_r = t_acsnh_advnh;
+	dev_t.t_oeasu = t_acsnh_advnh + 1000;
+	dev_t.t_oe = 300;
+	dev_t.t_cez_r = 7000;
+	dev_t.t_cez_w = dev_t.t_cez_r;
+	dev_t.t_avdp_w = t_acsnh_advnh;
+	dev_t.t_weasu = t_acsnh_advnh + 1000;
+	dev_t.t_wpl = 300;
+	dev_t.cyc_aavdh_we = 1;
 
-	t.cs_wr_off = t.we_off;
-
-	tmp = t.cs_wr_off * 1000 + 7000 /* t_acsn_rdy_z */;
-	t.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);
+	gpmc_calc_timings(&t, &dev_t);
 
 	return gpmc_cs_set_timings(async_cs, &t);
 }
 
-static int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)
+static int tusb_set_sync_mode(unsigned sysclk_ps)
 {
+	struct gpmc_device_timings dev_t;
 	struct gpmc_timings	t;
 	unsigned		t_scsnh_advnh = sysclk_ps + 3000;
-	unsigned		tmp;
-
-	memset(&t, 0, sizeof(t));
-	t.cs_on = 8;
-
-	/* ADV_ON = t_acsnh_advnh - t_advn */
-	t.adv_on = next_clk(t.cs_on, t_scsnh_advnh - 7000, fclk_ps);
-
-	/* GPMC_CLK rate = fclk rate / div */
-	t.sync_clk = 11100 /* 11.1 nsec */;
-	tmp = (t.sync_clk + fclk_ps - 1) / fclk_ps;
-	if (tmp > 4)
-		return -ERANGE;
-	if (tmp == 0)
-		tmp = 1;
-	t.page_burst_access = (fclk_ps * tmp) / 1000;
-
-	/*
-	 * READ ... based on omap2420 TRM fig 12-19, 12-20
-	 */
-
-	/* ADV_RD_OFF = t_scsnh_advnh */
-	t.adv_rd_off = next_clk(t.adv_on, t_scsnh_advnh, fclk_ps);
-
-	/* OE_ON = t_scsnh_advnh + t_advn_oen * fclk_ps (then wait for nRDY) */
-	tmp = (t.adv_rd_off * 1000) + (3 * fclk_ps);
-	t.oe_on = next_clk(t.adv_on, tmp, fclk_ps);
-
-	/* ACCESS = number of clock cycles after t_adv_eon */
-	tmp = (t.oe_on * 1000) + (5 * fclk_ps);
-	t.access = next_clk(t.oe_on, tmp, fclk_ps);
-
-	/* OE_OFF = after data gets sampled */
-	tmp = (t.access * 1000) + (1 * fclk_ps);
-	t.oe_off = next_clk(t.access, tmp, fclk_ps);
 
-	t.cs_rd_off = t.oe_off;
-
-	tmp = t.cs_rd_off * 1000 + 7000 /* t_scsn_rdy_z */;
-	t.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);
-
-	/*
-	 * WRITE ... based on omap2420 TRM fig 12-21
-	 */
-
-	/* ADV_WR_OFF = t_scsnh_advnh */
-	t.adv_wr_off = t.adv_rd_off;
-
-	/* WE_ON = t_scsnh_advnh + t_advn_wen * fclk_ps (then wait for nRDY) */
-	tmp = (t.adv_wr_off * 1000) + (3 * fclk_ps);
-	t.we_on = next_clk(t.adv_wr_off, tmp, fclk_ps);
-
-	/* WE_OFF = number of clock cycles after t_adv_wen */
-	tmp = (t.we_on * 1000) + (6 * fclk_ps);
-	t.we_off = next_clk(t.we_on, tmp, fclk_ps);
-
-	t.cs_wr_off = t.we_off;
-
-	tmp = t.cs_wr_off * 1000 + 7000 /* t_scsn_rdy_z */;
-	t.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);
-
-	t.clk_activation = gpmc_ticks_to_ns(1);
+	memset(&dev_t, 0, sizeof(dev_t));
+
+	dev_t.mux = true;
+	dev_t.sync_read = true;
+	dev_t.sync_write = true;
+
+	dev_t.clk = 11100;
+	dev_t.t_bacc = 1000;
+	dev_t.t_ces = 1000;
+	dev_t.t_ceasu = 8 * 1000;
+	dev_t.t_avdasu = t_scsnh_advnh - 7000;
+	dev_t.t_ce_avd = 1000;
+	dev_t.t_avdp_r = t_scsnh_advnh;
+	dev_t.cyc_aavdh_oe = 3;
+	dev_t.cyc_oe = 5;
+	dev_t.t_ce_rdyz = 7000;
+	dev_t.t_avdp_w = t_scsnh_advnh;
+	dev_t.cyc_aavdh_we = 3;
+	dev_t.cyc_wpl = 6;
+	dev_t.t_ce_rdyz = 7000;
+
+	gpmc_calc_timings(&t, &dev_t);
 
 	return gpmc_cs_set_timings(sync_cs, &t);
 }
 
-extern unsigned long gpmc_get_fclk_period(void);
-
 /* tusb driver calls this when it changes the chip's clocking */
 int tusb6010_platform_retime(unsigned is_refclk)
 {
 	static const char	error[] =
 		KERN_ERR "tusb6010 %s retime error %d\n";
 
-	unsigned	fclk_ps = gpmc_get_fclk_period();
 	unsigned	sysclk_ps;
 	int		status;
 
-	if (!refclk_psec || fclk_ps == 0)
+	if (!refclk_psec)
 		return -ENODEV;
 
 	sysclk_ps = is_refclk ? refclk_psec : TUSB6010_OSCCLK_60;
 
-	status = tusb_set_async_mode(sysclk_ps, fclk_ps);
+	status = tusb_set_async_mode(sysclk_ps);
 	if (status < 0) {
 		printk(error, "async", status);
 		goto done;
 	}
-	status = tusb_set_sync_mode(sysclk_ps, fclk_ps);
+	status = tusb_set_sync_mode(sysclk_ps);
 	if (status < 0)
 		printk(error, "sync", status);
 done:

commit 559d94b00c4dca74b060bae1feeb81cac38628a6
Author: Afzal Mohammed <afzal@ti.com>
Date:   Mon May 28 17:51:37 2012 +0530

    ARM: OMAP2+: gpmc: handle additional timings
    
    Configure busturnaround, cycle2cycledelay, waitmonitoringtime,
    clkactivationtime in gpmc_cs_set_timings(). This is done so
    that boards can configure these parameters of gpmc in Kernel
    instead of relying on bootloader. Also configure bool type
    timings like extradelay.
    
    This needed change to the existing users that were configuring
    clk activation time and extra delay by directly writing to
    registers. Thanks to Tony for making me aware of users of clk
    activation and being kind enough to test the modified one.
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index a8795ff19e6d..5be96c6e1416 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -175,6 +175,8 @@ static int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)
 	tmp = t.cs_wr_off * 1000 + 7000 /* t_scsn_rdy_z */;
 	t.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);
 
+	t.clk_activation = gpmc_ticks_to_ns(1);
+
 	return gpmc_cs_set_timings(sync_cs, &t);
 }
 
@@ -284,7 +286,6 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 			| GPMC_CONFIG1_READTYPE_SYNC
 			| GPMC_CONFIG1_WRITEMULTIPLE_SUPP
 			| GPMC_CONFIG1_WRITETYPE_SYNC
-			| GPMC_CONFIG1_CLKACTIVATIONTIME(1)
 			| GPMC_CONFIG1_PAGE_LEN(2)
 			| GPMC_CONFIG1_WAIT_READ_MON
 			| GPMC_CONFIG1_WAIT_WRITE_MON

commit 6d02643d64b4440394ee462ea4b870c8506cd9e7
Merge: 3d82cbbb3aad e8c4a7acc9ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 15:05:45 2012 -0700

    Merge branch 'omap-for-v3.8/cleanup-headers-usb' into omap-for-v3.8/cleanup-headers
    
    Conflicts:
            arch/arm/mach-omap1/clock.c
            arch/arm/mach-omap2/board-2430sdp.c
            arch/arm/mach-omap2/board-4430sdp.c
            arch/arm/mach-omap2/board-cm-t35.c
            arch/arm/mach-omap2/board-igep0020.c
            arch/arm/mach-omap2/board-ldp.c
            arch/arm/mach-omap2/board-omap3beagle.c
            arch/arm/mach-omap2/board-omap3logic.c
            arch/arm/mach-omap2/board-omap4panda.c
            arch/arm/mach-omap2/board-overo.c
            arch/arm/mach-omap2/board-rm680.c
            arch/arm/mach-omap2/board-rx51.c
            arch/arm/mach-omap2/twl-common.c
            arch/arm/mach-omap2/usb-host.c
            arch/arm/mach-omap2/usb-musb.c

commit e8c4a7acc9ec0ee82feedcdc3c6d0ee44d67918a
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Oct 24 14:26:19 2012 -0700

    ARM: OMAP: move OMAP USB platform data to <linux/platform_data/omap-usb.h>
    
    In order to make single zImage work for ARM architecture,
    we need to make sure we don't depend on private headers.
    
    Move USB platform_data to <linux/platform_data/omap-usb.h>
    and add a minimal drivers/mfd/usb-omap.h.
    
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Partha Basak <parthab@india.ti.com>
    Cc: Keshava Munegowda <keshava_mgowda@ti.com>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    [tony@atomide.com: updated for local mfd/usb-omap.h]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 805bea6edf17..5e2428989c13 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -15,6 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 #include <linux/export.h>
+#include <linux/platform_data/usb-omap.h>
 
 #include <linux/usb/musb.h>
 

commit 3ef5d0071cf6c8b9a00b559232bb700ad59999d7
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Oct 5 10:37:27 2012 +0530

    ARM: OMAP2+: gpmc: localize gpmc header
    
    Requirement of gpmc header outside of mach-omap2 has been
    cutoff, move gpmc header file in plat-omap folder to local
    mach-omap2 folder
    
    Objective - common zImage participation of omap
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 805bea6edf17..6064425ed47b 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -18,7 +18,7 @@
 
 #include <linux/usb/musb.h>
 
-#include <plat/gpmc.h>
+#include "gpmc.h"
 
 #include "mux.h"
 

commit 3d09b33fecf204561e5c7126648ec05c756c631c
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jun 20 07:18:15 2012 -0700

    ARM: OMAP2: Fix tusb6010 GPIO interrupt for n8x0
    
    Here's one more gpio_to_irq conversion that we missed
    earlier. Tested with n800 in gadget mode using USB_ETH.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index db84a46ce7fd..805bea6edf17 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -300,7 +300,7 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		printk(error, 3, status);
 		return status;
 	}
-	tusb_resources[2].start = irq + IH_GPIO_BASE;
+	tusb_resources[2].start = gpio_to_irq(irq);
 
 	/* set up memory timings ... can speed them up later */
 	if (!ps_refclk) {

commit eeb3711b89d68e147e05e7b43a49ecc5009dc157
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Apr 13 06:34:32 2012 -0600

    ARM: OMAP2+: clean up some cppcheck warnings
    
    Resolve some warnings identified by cppcheck in arch/arm/mach-omap2:
    
        [arch/arm/mach-omap2/usb-tusb6010.c:129]: (style) Checking if unsigned variable 'tmp' is less than zero.
        [arch/arm/mach-omap2/prm_common.c:241]: (error) Possible null pointer dereference: irq_setup - otherwise it is redundant to check if irq_setup is null at line 247
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'per_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'core_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm24xx.c:185]: (style) Variable 'only_idle' is assigned a value that is never used
        [arch/arm/mach-omap2/mux.c:254]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/mux.c:258]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/gpmc-onenand.c:178]: (style) Variable 'tick_ns' is assigned a value that is never used
        [arch/arm/mach-omap2/gpio.c:56]: (error) Possible null pointer dereference: pdata - otherwise it is redundant to check if pdata is null at line 57
        [arch/arm/mach-omap2/devices.c:45]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/board-omap3evm.c:641] -> [arch/arm/mach-omap2/board-omap3evm.c:639]: (style) Found duplicate branches for if and else.
        [arch/arm/mach-omap2/am35xx-emac.c:95]: (style) Variable 'regval' is assigned a value that is never used
        [arch/arm/mach-omap2/devices.c:74]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:277]: (style) Variable 'per_prev_state' is assigned a value that is never used
        [arch/arm/plat-omap/dmtimer.c:352]: (error) Possible null pointer dereference: timer - otherwise it is redundant to check if timer is null at line 354
        [arch/arm/plat-omap/omap_device.c:478]: (style) Variable 'c' is assigned a value that is never used
        [arch/arm/plat-omap/usb.c:42]: (style) Variable 'status' is assigned a value that is never used
        [arch/arm/mach-omap1/clock.c:197]: (style) Variable 'dpll1_rate' is assigned a value that is never used
        [arch/arm/mach-omap1/lcd_dma.c:60]: (style) struct or union member 'lcd_dma_info::size' is never used
        [arch/arm/mach-omap1/pm.c:572]: (style) Variable 'entry' is assigned a value that is never used
    
    Some of them are pretty good catches, such as gpio.c:56 and
    usb-tusb6010.c:129.
    
    Thanks to Jarkko Nikula for some comments on the sscanf() warnings.
    It seems that the kernel sscanf() ignores the field width anyway for the
    %d format, so those changes have been dropped from this second version.
    
    Thanks to Daniel Marjamäki <daniel.marjamaki@gmail.com> for pointing
    out that a variable was unnecessarily marked static in the
    board-omap3evm.c change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Charulatha Varadarajan <charu@ti.com>
    Cc: Daniel Marjamäki <daniel.marjamaki@gmail.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Charulatha Varadarajan <charu@ti.com> # for gpio.c

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 994d8f591a1d..db84a46ce7fd 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -126,7 +126,7 @@ static int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)
 	tmp = (t.sync_clk + fclk_ps - 1) / fclk_ps;
 	if (tmp > 4)
 		return -ERANGE;
-	if (tmp <= 0)
+	if (tmp == 0)
 		tmp = 1;
 	t.page_burst_access = (fclk_ps * tmp) / 1000;
 

commit dc28094b905a872f8884f1f1c48ca86b3b78583a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 16:17:29 2011 -0400

    arm: Add export.h to ARM specific files as required.
    
    These files all make use of one of the EXPORT_SYMBOL variants
    or the THIS_MODULE macro.  So they will need <linux/export.h>
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 11760d2e2907..994d8f591a1d 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -14,6 +14,7 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
+#include <linux/export.h>
 
 #include <linux/usb/musb.h>
 

commit d44b28c49e7ab3baf280100ab86d8e7ef9204e45
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 10:52:44 2011 -0400

    arm: fix implicit memset/string.h usage in various arch/arm files
    
    To fix things like this:
    
    arch/arm/mach-omap2/usb-tusb6010.c:58: error: implicit declaration of function 'memset'
    arch/arm/kernel/leds.c:40: error: implicit declaration of function 'strcspn'
    arch/arm/kernel/leds.c:40: warning: incompatible implicit declaration of built-in function 'strcspn'
    arch/arm/kernel/leds.c:45: error: implicit declaration of function 'strncmp'
    arch/arm/kernel/leds.c:55: error: implicit declaration of function 'strlen'
    arch/arm/kernel/leds.c:55: warning: incompatible implicit declaration of built-in function 'strlen'
    arch/arm/mach-omap2/clockdomain.c:52: error: implicit declaration of function 'strcmp'
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 8dd26b765b7d..11760d2e2907 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -8,6 +8,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/string.h>
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/delay.h>

commit bc593f5d787d0a015539e21868302fb44a47c3e3
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue May 3 18:22:09 2011 +0300

    arm: omap2plus: GPIO cleanup
    
    use gpio_request_<one|array>() instead of multiple gpiolib calls,
    remove unneeded variables, etc.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 8a3c05f3c1d6..8dd26b765b7d 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -293,12 +293,11 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 			);
 
 	/* IRQ */
-	status = gpio_request(irq, "TUSB6010 irq");
+	status = gpio_request_one(irq, GPIOF_IN, "TUSB6010 irq");
 	if (status < 0) {
 		printk(error, 3, status);
 		return status;
 	}
-	gpio_direction_input(irq);
 	tusb_resources[2].start = irq + IH_GPIO_BASE;
 
 	/* set up memory timings ... can speed them up later */

commit 3e5b08cbbf78bedd316904ab0cf3b27119433ee5
Merge: da40d036fd71 2af10844eb6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 7 13:16:28 2011 -0800

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (144 commits)
      USB: add support for Dream Cheeky DL100B Webmail Notifier (1d34:0004)
      USB: serial: ftdi_sio: add support for TIOCSERGETLSR
      USB: ehci-mxc: Setup portsc register prior to accessing OTG viewport
      USB: atmel_usba_udc: fix freeing irq in usba_udc_remove()
      usb: ehci-omap: fix tll channel enable mask
      usb: ohci-omap3: fix trivial typo
      USB: gadget: ci13xxx: don't assume that PAGE_SIZE is 4096
      USB: gadget: ci13xxx: fix complete() callback for no_interrupt rq's
      USB: gadget: update ci13xxx to work with g_ether
      USB: gadgets: ci13xxx: fix probing of compiled-in gadget drivers
      Revert "USB: musb: pm: don't rely fully on clock support"
      Revert "USB: musb: blackfin: pm: make it work"
      USB: uas: Use GFP_NOIO instead of GFP_KERNEL in I/O submission path
      USB: uas: Ensure we only bind to a UAS interface
      USB: uas: Rename sense pipe and sense urb to status pipe and status urb
      USB: uas: Use kzalloc instead of kmalloc
      USB: uas: Fix up the Sense IU
      usb: musb: core: kill unneeded #include's
      DA8xx: assign name to MUSB IRQ resource
      usb: gadget: g_ncm added
      ...
    
    Manually fix up trivial conflicts in USB Kconfig changes in:
            arch/arm/mach-omap2/Kconfig
            arch/sh/Kconfig
            drivers/usb/Kconfig
            drivers/usb/host/ehci-hcd.c
    and annoying chip clock data conflicts in:
            arch/arm/mach-omap2/clock3xxx_data.c
            arch/arm/mach-omap2/clock44xx_data.c

commit 6ec1e077e36c5469a6f901ca9abbd9bd5d23e6ae
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 23 12:17:49 2010 -0800

    arm: omap: tusb6010: add name for MUSB IRQ
    
    commit fcf173e4511193b1efeccb0f22a8c641b464353b
    (add names for IRQs in structure resource)
    forgot to take care of tusb6010 making it
    fail to probe due to a missing resource.
    
    Fix it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 1e998ea40951..30f112bd3e4d 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -216,6 +216,7 @@ static struct resource tusb_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	{ /* IRQ */
+		.name	= "mc",
 		.flags	= IORESOURCE_IRQ,
 	},
 };

commit a3551f5b0c3ca7aaa053e554e3ee766983b5d713
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Thu Dec 9 10:48:27 2010 +0200

    OMAP2/3: GPMC: put sync_clk value in picoseconds instead of nanoseconds
    
    The calculations done with sync_clk are anyway in picoseconds
    and switching to picoseconds allows sync_clk values that are
    not a whole number of nanoseconds - which is sometimes the
    case.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 64a0112b70a5..1e998ea40951 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -120,8 +120,8 @@ static int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)
 	t.adv_on = next_clk(t.cs_on, t_scsnh_advnh - 7000, fclk_ps);
 
 	/* GPMC_CLK rate = fclk rate / div */
-	t.sync_clk = 12 /* 11.1 nsec */;
-	tmp = (t.sync_clk * 1000 + fclk_ps - 1) / fclk_ps;
+	t.sync_clk = 11100 /* 11.1 nsec */;
+	tmp = (t.sync_clk + fclk_ps - 1) / fclk_ps;
 	if (tmp > 4)
 		return -ERANGE;
 	if (tmp <= 0)

commit 18688fbeb09665725c842291bbadd88295a359e1
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:13:54 2010 +0200

    usb: musb: split tusb6010 to its own platform_driver
    
    Just adding its own platform_driver, not really
    using it yet.
    
    When all HW glue layers are converted, more patches
    will come to split power management code from musb_core
    and move it completely to HW glue layer.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 42389213b470..7cb3c18a5e20 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -223,7 +223,7 @@ static struct resource tusb_resources[] = {
 static u64 tusb_dmamask = ~(u32)0;
 
 static struct platform_device tusb_device = {
-	.name		= "musb-hdrc",
+	.name		= "musb-tusb",
 	.id		= -1,
 	.dev = {
 		.dma_mask		= &tusb_dmamask,

commit 05ac10dd6862a3fcce33d2203fbb2ef285e3ca87
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 08:49:26 2010 +0200

    usb: musb: trivial search and replace patch
    
    change all ocurrences of musb_hdrc to musb-hdrc.
    
    We will call glue layer drivers musb-<glue layer>,
    so in order to keep things somewhat standard, let's
    change the underscore into a dash.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 64a0112b70a5..42389213b470 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -223,7 +223,7 @@ static struct resource tusb_resources[] = {
 static u64 tusb_dmamask = ~(u32)0;
 
 static struct platform_device tusb_device = {
-	.name		= "musb_hdrc",
+	.name		= "musb-hdrc",
 	.id		= -1,
 	.dev = {
 		.dma_mask		= &tusb_dmamask,

commit f99bf16d70d8a33e5274e429f2b1d71457d06a06
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jul 5 16:31:40 2010 +0300

    omap: mux: Convert 2420 platform init code to use new mux code
    
    Convert 2420 platform init code to use new mux code
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 10a2013c1104..64a0112b70a5 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -17,8 +17,8 @@
 #include <linux/usb/musb.h>
 
 #include <plat/gpmc.h>
-#include <plat/mux.h>
 
+#include "mux.h"
 
 static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
@@ -325,17 +325,17 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	else {
 		/* assume OMAP 2420 ES2.0 and later */
 		if (dmachan & (1 << 0))
-			omap_cfg_reg(AA10_242X_DMAREQ0);
+			omap_mux_init_signal("sys_ndmareq0", 0);
 		if (dmachan & (1 << 1))
-			omap_cfg_reg(AA6_242X_DMAREQ1);
+			omap_mux_init_signal("sys_ndmareq1", 0);
 		if (dmachan & (1 << 2))
-			omap_cfg_reg(E4_242X_DMAREQ2);
+			omap_mux_init_signal("sys_ndmareq2", 0);
 		if (dmachan & (1 << 3))
-			omap_cfg_reg(G4_242X_DMAREQ3);
+			omap_mux_init_signal("sys_ndmareq3", 0);
 		if (dmachan & (1 << 4))
-			omap_cfg_reg(D3_242X_DMAREQ4);
+			omap_mux_init_signal("sys_ndmareq4", 0);
 		if (dmachan & (1 << 5))
-			omap_cfg_reg(E3_242X_DMAREQ5);
+			omap_mux_init_signal("sys_ndmareq5", 0);
 	}
 
 	/* so far so good ... register the device */

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 8622c24cd270..10a2013c1104 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -16,8 +16,8 @@
 
 #include <linux/usb/musb.h>
 
-#include <mach/gpmc.h>
-#include <mach/mux.h>
+#include <plat/gpmc.h>
+#include <plat/mux.h>
 
 
 static u8		async_cs, sync_cs;

commit eaf9393bb79a9c7c8e708669f9581ca466122430
Author: Jarkko Nikula <jarkko.nikula@nokia.com>
Date:   Tue May 12 11:20:02 2009 -0700

    ARM: OMAP2: Fix tusb6010 init error and compilation warning
    
    Fix "tusb6010 init error 5, -19" and compilation warning from function
    tusb6010_platform_retime "warning: 'sysclk_ps' is used uninitialized in this
    function".
    
    I suppose commit c094ba34b8f780885d029ce3c2715a194b780e5d was meant to test
    for zero fclk_ps instead of sysclk_ps.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@nokia.com>
    Cc: Roel Kluin <roel.kluin@gmail.com>
    Tested-by: Kalle Valo <kalle.valo@iki.fi>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 8df55f40f4c0..8622c24cd270 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -187,7 +187,7 @@ int tusb6010_platform_retime(unsigned is_refclk)
 	unsigned	sysclk_ps;
 	int		status;
 
-	if (!refclk_psec || sysclk_ps == 0)
+	if (!refclk_psec || fclk_ps == 0)
 		return -ENODEV;
 
 	sysclk_ps = is_refclk ? refclk_psec : TUSB6010_OSCCLK_60;

commit d94a2eddf50c4aa1553acf3025f45d03704a1f97
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu Apr 23 11:10:49 2009 -0700

    ARM: OMAP2: possible division by 0
    
    In linus' git tree the functions can be found at:
    vi arch/arm/mach-omap2/usb-tusb6010.c +200      - tusb6010_platform_retime()
    vi arch/arm/mach-omap2/gpmc.c +94               - gpmc_get_fclk_period()
    vi arch/arm/mach-omap2/usb-tusb6010.c +53       - tusb_set_async_mode()
    vi arch/arm/mach-omap2/usb-tusb6010.c +111      - tusb_set_sync_mode()
    
    is -ENODEV appropriate when sysclk_ps == 0?
    
    This was found by code analysis, please review.
    ------------------------------>8-------------8<---------------------------------
    gpmc_get_fclk_period() may return 0 when gpmc_l3_clk is not enabled. This is
    not checked in tusb6010_platform_retime() nor in tusb_set_async_mode() it
    seems. In tusb_set_sync_mode() this may result in a division by zero.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 15e509013def..8df55f40f4c0 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -187,7 +187,7 @@ int tusb6010_platform_retime(unsigned is_refclk)
 	unsigned	sysclk_ps;
 	int		status;
 
-	if (!refclk_psec)
+	if (!refclk_psec || sysclk_ps == 0)
 		return -ENODEV;
 
 	sysclk_ps = is_refclk ? refclk_psec : TUSB6010_OSCCLK_60;

commit f2d18fea8b87d09bdda22cc67c36f5f463452a33
Author: Jarkko Nikula <jarkko.nikula@nokia.com>
Date:   Wed Dec 10 17:35:30 2008 -0800

    ARM: OMAP: Switch to gpio_request/free calls
    
    Switch to gpio_request/free calls
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@nokia.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index eb2399dc74c2..15e509013def 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -12,11 +12,11 @@
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <linux/gpio.h>
 
 #include <linux/usb/musb.h>
 
 #include <mach/gpmc.h>
-#include <mach/gpio.h>
 #include <mach/mux.h>
 
 
@@ -292,7 +292,7 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 			);
 
 	/* IRQ */
-	status = omap_request_gpio(irq);
+	status = gpio_request(irq, "TUSB6010 irq");
 	if (status < 0) {
 		printk(error, 3, status);
 		return status;

commit 40e3925ba15b604c9ff87154d77a914221d11cdc
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Dec 10 17:35:26 2008 -0800

    ARM: OMAP: switch to gpio_direction_input
    
    More switchover to the cross-platform GPIO interface:
    use gpio_direction_input(), not an OMAP-specific call.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 10ef464d6be7..eb2399dc74c2 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -297,7 +297,7 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		printk(error, 3, status);
 		return status;
 	}
-	omap_set_gpio_direction(irq, 1);
+	gpio_direction_input(irq);
 	tusb_resources[2].start = irq + IH_GPIO_BASE;
 
 	/* set up memory timings ... can speed them up later */

commit ca6d1b1333bc2e61e37982de1f28d8604c232414
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Fri Aug 8 12:40:54 2008 +0300

    usb: musb: pass configuration specifics via pdata
    
    Use platform_data to pass musb configuration-specific
    details to musb driver.
    
    This patch will prevent that other platforms selecting
    HAVE_CLK and enabling musb won't break tree building.
    
    The other parts of it will come when linux-omap merge
    up more omap2/3 board-files.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 1607c941d95f..10ef464d6be7 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -317,7 +317,6 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		printk(error, 6, status);
 		return -ENODEV;
 	}
-	data->multipoint = 1;
 	tusb_device.dev.platform_data = data;
 
 	/* REVISIT let the driver know what DMA channels work */

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index 80bb42eb5082..1607c941d95f 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -15,9 +15,9 @@
 
 #include <linux/usb/musb.h>
 
-#include <asm/arch/gpmc.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/mux.h>
+#include <mach/gpmc.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
 
 
 static u8		async_cs, sync_cs;

commit c1ed6407cddbd87206b860f6207731d51c1d57bf
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Dec 7 14:03:49 2006 -0800

    ARM: OMAP: TUSB EVM init
    
    Add init support for the TUSB6010 EVM board, as connected to H4.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
new file mode 100644
index 000000000000..80bb42eb5082
--- /dev/null
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -0,0 +1,349 @@
+/*
+ * linux/arch/arm/mach-omap2/usb-tusb6010.c
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/musb.h>
+
+#include <asm/arch/gpmc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mux.h>
+
+
+static u8		async_cs, sync_cs;
+static unsigned		refclk_psec;
+
+
+/* t2_ps, when quantized to fclk units, must happen no earlier than
+ * the clock after after t1_NS.
+ *
+ * Return a possibly updated value of t2_ps, converted to nsec.
+ */
+static unsigned
+next_clk(unsigned t1_NS, unsigned t2_ps, unsigned fclk_ps)
+{
+	unsigned	t1_ps = t1_NS * 1000;
+	unsigned	t1_f, t2_f;
+
+	if ((t1_ps + fclk_ps) < t2_ps)
+		return t2_ps / 1000;
+
+	t1_f = (t1_ps + fclk_ps - 1) / fclk_ps;
+	t2_f = (t2_ps + fclk_ps - 1) / fclk_ps;
+
+	if (t1_f >= t2_f)
+		t2_f = t1_f + 1;
+
+	return (t2_f * fclk_ps) / 1000;
+}
+
+/* NOTE:  timings are from tusb 6010 datasheet Rev 1.8, 12-Sept 2006 */
+
+static int tusb_set_async_mode(unsigned sysclk_ps, unsigned fclk_ps)
+{
+	struct gpmc_timings	t;
+	unsigned		t_acsnh_advnh = sysclk_ps + 3000;
+	unsigned		tmp;
+
+	memset(&t, 0, sizeof(t));
+
+	/* CS_ON = t_acsnh_acsnl */
+	t.cs_on = 8;
+	/* ADV_ON = t_acsnh_advnh - t_advn */
+	t.adv_on = next_clk(t.cs_on, t_acsnh_advnh - 7000, fclk_ps);
+
+	/*
+	 * READ ... from omap2420 TRM fig 12-13
+	 */
+
+	/* ADV_RD_OFF = t_acsnh_advnh */
+	t.adv_rd_off = next_clk(t.adv_on, t_acsnh_advnh, fclk_ps);
+
+	/* OE_ON = t_acsnh_advnh + t_advn_oen (then wait for nRDY) */
+	t.oe_on = next_clk(t.adv_on, t_acsnh_advnh + 1000, fclk_ps);
+
+	/* ACCESS = counters continue only after nRDY */
+	tmp = t.oe_on * 1000 + 300;
+	t.access = next_clk(t.oe_on, tmp, fclk_ps);
+
+	/* OE_OFF = after data gets sampled */
+	tmp = t.access * 1000;
+	t.oe_off = next_clk(t.access, tmp, fclk_ps);
+
+	t.cs_rd_off = t.oe_off;
+
+	tmp = t.cs_rd_off * 1000 + 7000 /* t_acsn_rdy_z */;
+	t.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);
+
+	/*
+	 * WRITE ... from omap2420 TRM fig 12-15
+	 */
+
+	/* ADV_WR_OFF = t_acsnh_advnh */
+	t.adv_wr_off = t.adv_rd_off;
+
+	/* WE_ON = t_acsnh_advnh + t_advn_wen (then wait for nRDY) */
+	t.we_on = next_clk(t.adv_wr_off, t_acsnh_advnh + 1000, fclk_ps);
+
+	/* WE_OFF = after data gets sampled */
+	tmp = t.we_on * 1000 + 300;
+	t.we_off = next_clk(t.we_on, tmp, fclk_ps);
+
+	t.cs_wr_off = t.we_off;
+
+	tmp = t.cs_wr_off * 1000 + 7000 /* t_acsn_rdy_z */;
+	t.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);
+
+	return gpmc_cs_set_timings(async_cs, &t);
+}
+
+static int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)
+{
+	struct gpmc_timings	t;
+	unsigned		t_scsnh_advnh = sysclk_ps + 3000;
+	unsigned		tmp;
+
+	memset(&t, 0, sizeof(t));
+	t.cs_on = 8;
+
+	/* ADV_ON = t_acsnh_advnh - t_advn */
+	t.adv_on = next_clk(t.cs_on, t_scsnh_advnh - 7000, fclk_ps);
+
+	/* GPMC_CLK rate = fclk rate / div */
+	t.sync_clk = 12 /* 11.1 nsec */;
+	tmp = (t.sync_clk * 1000 + fclk_ps - 1) / fclk_ps;
+	if (tmp > 4)
+		return -ERANGE;
+	if (tmp <= 0)
+		tmp = 1;
+	t.page_burst_access = (fclk_ps * tmp) / 1000;
+
+	/*
+	 * READ ... based on omap2420 TRM fig 12-19, 12-20
+	 */
+
+	/* ADV_RD_OFF = t_scsnh_advnh */
+	t.adv_rd_off = next_clk(t.adv_on, t_scsnh_advnh, fclk_ps);
+
+	/* OE_ON = t_scsnh_advnh + t_advn_oen * fclk_ps (then wait for nRDY) */
+	tmp = (t.adv_rd_off * 1000) + (3 * fclk_ps);
+	t.oe_on = next_clk(t.adv_on, tmp, fclk_ps);
+
+	/* ACCESS = number of clock cycles after t_adv_eon */
+	tmp = (t.oe_on * 1000) + (5 * fclk_ps);
+	t.access = next_clk(t.oe_on, tmp, fclk_ps);
+
+	/* OE_OFF = after data gets sampled */
+	tmp = (t.access * 1000) + (1 * fclk_ps);
+	t.oe_off = next_clk(t.access, tmp, fclk_ps);
+
+	t.cs_rd_off = t.oe_off;
+
+	tmp = t.cs_rd_off * 1000 + 7000 /* t_scsn_rdy_z */;
+	t.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);
+
+	/*
+	 * WRITE ... based on omap2420 TRM fig 12-21
+	 */
+
+	/* ADV_WR_OFF = t_scsnh_advnh */
+	t.adv_wr_off = t.adv_rd_off;
+
+	/* WE_ON = t_scsnh_advnh + t_advn_wen * fclk_ps (then wait for nRDY) */
+	tmp = (t.adv_wr_off * 1000) + (3 * fclk_ps);
+	t.we_on = next_clk(t.adv_wr_off, tmp, fclk_ps);
+
+	/* WE_OFF = number of clock cycles after t_adv_wen */
+	tmp = (t.we_on * 1000) + (6 * fclk_ps);
+	t.we_off = next_clk(t.we_on, tmp, fclk_ps);
+
+	t.cs_wr_off = t.we_off;
+
+	tmp = t.cs_wr_off * 1000 + 7000 /* t_scsn_rdy_z */;
+	t.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);
+
+	return gpmc_cs_set_timings(sync_cs, &t);
+}
+
+extern unsigned long gpmc_get_fclk_period(void);
+
+/* tusb driver calls this when it changes the chip's clocking */
+int tusb6010_platform_retime(unsigned is_refclk)
+{
+	static const char	error[] =
+		KERN_ERR "tusb6010 %s retime error %d\n";
+
+	unsigned	fclk_ps = gpmc_get_fclk_period();
+	unsigned	sysclk_ps;
+	int		status;
+
+	if (!refclk_psec)
+		return -ENODEV;
+
+	sysclk_ps = is_refclk ? refclk_psec : TUSB6010_OSCCLK_60;
+
+	status = tusb_set_async_mode(sysclk_ps, fclk_ps);
+	if (status < 0) {
+		printk(error, "async", status);
+		goto done;
+	}
+	status = tusb_set_sync_mode(sysclk_ps, fclk_ps);
+	if (status < 0)
+		printk(error, "sync", status);
+done:
+	return status;
+}
+EXPORT_SYMBOL_GPL(tusb6010_platform_retime);
+
+static struct resource tusb_resources[] = {
+	/* Order is significant!  The start/end fields
+	 * are updated during setup..
+	 */
+	{ /* Asynchronous access */
+		.flags	= IORESOURCE_MEM,
+	},
+	{ /* Synchronous access */
+		.flags	= IORESOURCE_MEM,
+	},
+	{ /* IRQ */
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 tusb_dmamask = ~(u32)0;
+
+static struct platform_device tusb_device = {
+	.name		= "musb_hdrc",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &tusb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(tusb_resources),
+	.resource	= tusb_resources,
+};
+
+
+/* this may be called only from board-*.c setup code */
+int __init
+tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
+		unsigned ps_refclk, unsigned waitpin,
+		unsigned async, unsigned sync,
+		unsigned irq, unsigned dmachan)
+{
+	int		status;
+	static char	error[] __initdata =
+		KERN_ERR "tusb6010 init error %d, %d\n";
+
+	/* ASYNC region, primarily for PIO */
+	status = gpmc_cs_request(async, SZ_16M, (unsigned long *)
+				&tusb_resources[0].start);
+	if (status < 0) {
+		printk(error, 1, status);
+		return status;
+	}
+	tusb_resources[0].end = tusb_resources[0].start + 0x9ff;
+	async_cs = async;
+	gpmc_cs_write_reg(async, GPMC_CS_CONFIG1,
+			  GPMC_CONFIG1_PAGE_LEN(2)
+			| GPMC_CONFIG1_WAIT_READ_MON
+			| GPMC_CONFIG1_WAIT_WRITE_MON
+			| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)
+			| GPMC_CONFIG1_READTYPE_ASYNC
+			| GPMC_CONFIG1_WRITETYPE_ASYNC
+			| GPMC_CONFIG1_DEVICESIZE_16
+			| GPMC_CONFIG1_DEVICETYPE_NOR
+			| GPMC_CONFIG1_MUXADDDATA);
+
+
+	/* SYNC region, primarily for DMA */
+	status = gpmc_cs_request(sync, SZ_16M, (unsigned long *)
+				&tusb_resources[1].start);
+	if (status < 0) {
+		printk(error, 2, status);
+		return status;
+	}
+	tusb_resources[1].end = tusb_resources[1].start + 0x9ff;
+	sync_cs = sync;
+	gpmc_cs_write_reg(sync, GPMC_CS_CONFIG1,
+			  GPMC_CONFIG1_READMULTIPLE_SUPP
+			| GPMC_CONFIG1_READTYPE_SYNC
+			| GPMC_CONFIG1_WRITEMULTIPLE_SUPP
+			| GPMC_CONFIG1_WRITETYPE_SYNC
+			| GPMC_CONFIG1_CLKACTIVATIONTIME(1)
+			| GPMC_CONFIG1_PAGE_LEN(2)
+			| GPMC_CONFIG1_WAIT_READ_MON
+			| GPMC_CONFIG1_WAIT_WRITE_MON
+			| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)
+			| GPMC_CONFIG1_DEVICESIZE_16
+			| GPMC_CONFIG1_DEVICETYPE_NOR
+			| GPMC_CONFIG1_MUXADDDATA
+			/* fclk divider gets set later */
+			);
+
+	/* IRQ */
+	status = omap_request_gpio(irq);
+	if (status < 0) {
+		printk(error, 3, status);
+		return status;
+	}
+	omap_set_gpio_direction(irq, 1);
+	tusb_resources[2].start = irq + IH_GPIO_BASE;
+
+	/* set up memory timings ... can speed them up later */
+	if (!ps_refclk) {
+		printk(error, 4, status);
+		return -ENODEV;
+	}
+	refclk_psec = ps_refclk;
+	status = tusb6010_platform_retime(1);
+	if (status < 0) {
+		printk(error, 5, status);
+		return status;
+	}
+
+	/* finish device setup ... */
+	if (!data) {
+		printk(error, 6, status);
+		return -ENODEV;
+	}
+	data->multipoint = 1;
+	tusb_device.dev.platform_data = data;
+
+	/* REVISIT let the driver know what DMA channels work */
+	if (!dmachan)
+		tusb_device.dev.dma_mask = NULL;
+	else {
+		/* assume OMAP 2420 ES2.0 and later */
+		if (dmachan & (1 << 0))
+			omap_cfg_reg(AA10_242X_DMAREQ0);
+		if (dmachan & (1 << 1))
+			omap_cfg_reg(AA6_242X_DMAREQ1);
+		if (dmachan & (1 << 2))
+			omap_cfg_reg(E4_242X_DMAREQ2);
+		if (dmachan & (1 << 3))
+			omap_cfg_reg(G4_242X_DMAREQ3);
+		if (dmachan & (1 << 4))
+			omap_cfg_reg(D3_242X_DMAREQ4);
+		if (dmachan & (1 << 5))
+			omap_cfg_reg(E3_242X_DMAREQ5);
+	}
+
+	/* so far so good ... register the device */
+	status = platform_device_register(&tusb_device);
+	if (status < 0) {
+		printk(error, 7, status);
+		return status;
+	}
+	return 0;
+}
