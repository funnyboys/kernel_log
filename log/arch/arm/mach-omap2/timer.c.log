commit d2353bad2c1eef7a1228645fbb21e7887c633d12
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri May 29 22:16:45 2020 +0200

    ARM: omap2: fix omap5_realtime_timer_init definition
    
    There is one more regression introduced by the last build fix:
    
    arch/arm/mach-omap2/timer.c:170:6: error: attribute declaration must precede definition [-Werror,-Wignored-attributes]
    void __init omap5_realtime_timer_init(void)
         ^
    arch/arm/mach-omap2/common.h:118:20: note: previous definition is here
    static inline void omap5_realtime_timer_init(void)
                       ^
    arch/arm/mach-omap2/timer.c:170:13: error: redefinition of 'omap5_realtime_timer_init'
    void __init omap5_realtime_timer_init(void)
                ^
    arch/arm/mach-omap2/common.h:118:20: note: previous definition is here
    static inline void omap5_realtime_timer_init(void)
    
    Address this by removing the now obsolete #ifdefs in that file and
    just building the entire file based on the flag that controls the
    omap5_realtime_timer_init function declaration.
    
    Link: https://lore.kernel.org/r/20200529201701.521933-1-arnd@arndb.de
    Fixes: d86ad463d670 ("ARM: OMAP2+: Fix regression for using local timer on non-SMP SoCs")
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index c1737e737a94..620ba69c8f11 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -39,8 +39,6 @@
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
 #define NUMERATOR_DENUMERATOR_MASK			0xfffff000
 
-#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
-
 static unsigned long arch_timer_freq;
 
 void set_cntfreq(void)
@@ -159,14 +157,6 @@ static void __init realtime_counter_init(void)
 	iounmap(base);
 }
 
-#else
-
-static inline void realtime_counter_init(void)
-{
-}
-
-#endif	/* CONFIG_SOC_HAS_REALTIME_COUNTER */
-
 void __init omap5_realtime_timer_init(void)
 {
 	omap_clk_init();

commit d86ad463d6706d35167418660ae3293207ee9d1c
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 28 08:54:53 2020 -0700

    ARM: OMAP2+: Fix regression for using local timer on non-SMP SoCs
    
    On am437x we use also an ARM timer in addition to the dmtimer. As am437x
    is not an SMP SoC, we need tick_broadcast() implemented. With the recent
    dmtimer changes, Arnd started to see link failures for non-SMP am437x
    configuration:
    
    kernel/time/tick-broadcast.o: in function `tick_device_uses_broadcast':
    tick-broadcast.c:(.text+0x130): undefined reference to `tick_broadcast'
    
    Let's fix the issue by reverting dmtimer related changes that started
    building timer.c only for CONFIG_SOC_HAS_REALTIME_COUNTER. We still
    always need timer.c built-in for omap5 and dra7 for timer_probe().
    
    And let's also move am437x tick_broadcast() to board-generic.c as
    that's where we now call timer_probe() for am437x. This way we avoid
    adding back more ifdefs to timer.c.
    
    Fixes: 2ee04b88547a ("ARM: OMAP2+: Drop old timer code for dmtimer and 32k counter")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2d4ea386fc38..c1737e737a94 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -39,6 +39,8 @@
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
 #define NUMERATOR_DENUMERATOR_MASK			0xfffff000
 
+#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
+
 static unsigned long arch_timer_freq;
 
 void set_cntfreq(void)
@@ -46,14 +48,6 @@ void set_cntfreq(void)
 	omap_smc1(OMAP5_DRA7_MON_SET_CNTFRQ_INDEX, arch_timer_freq);
 }
 
-#if !defined(CONFIG_SMP) && defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)
-void tick_broadcast(const struct cpumask *mask)
-{
-}
-#endif
-
-#if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
-
 /*
  * The realtime counter also called master counter, is a free-running
  * counter, which is related to real time. It produces the count used
@@ -165,6 +159,14 @@ static void __init realtime_counter_init(void)
 	iounmap(base);
 }
 
+#else
+
+static inline void realtime_counter_init(void)
+{
+}
+
+#endif	/* CONFIG_SOC_HAS_REALTIME_COUNTER */
+
 void __init omap5_realtime_timer_init(void)
 {
 	omap_clk_init();
@@ -172,4 +174,3 @@ void __init omap5_realtime_timer_init(void)
 
 	timer_probe();
 }
-#endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */

commit 2ee04b88547ab4c46aa2a258efd0f91fc705b6d6
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 7 09:59:31 2020 -0700

    ARM: OMAP2+: Drop old timer code for dmtimer and 32k counter
    
    With dmtimer and 32k counter being initialized based on devicetree data,
    we can just drop the old timer code.
    
    This still leaves the omap5 and dra7 realtime_counter_init() that
    depend on the smc calls and control module platform code for the dra7
    quirk init.
    
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 662a31004b91..2d4ea386fc38 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -26,34 +26,12 @@
  * License. See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-#include <linux/init.h>
-#include <linux/time.h>
-#include <linux/interrupt.h>
-#include <linux/err.h>
 #include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/irq.h>
 #include <linux/clocksource.h>
-#include <linux/clockchips.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/dmtimer-omap.h>
-#include <linux/sched_clock.h>
-
-#include <asm/mach/time.h>
-
-#include "omap_hwmod.h"
-#include "omap_device.h"
-#include <plat/counter-32k.h>
-#include <clocksource/timer-ti-dm.h>
 
 #include "soc.h"
 #include "common.h"
 #include "control.h"
-#include "powerdomain.h"
 #include "omap-secure.h"
 
 #define REALTIME_COUNTER_BASE				0x48243200
@@ -61,294 +39,12 @@
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
 #define NUMERATOR_DENUMERATOR_MASK			0xfffff000
 
-/* Clockevent code */
-
-static struct omap_dm_timer clkev;
-static struct clock_event_device clockevent_gpt;
-
-/* Clockevent hwmod for am335x and am437x suspend */
-static struct omap_hwmod *clockevent_gpt_hwmod;
-
-/* Clockesource hwmod for am437x suspend */
-static struct omap_hwmod *clocksource_gpt_hwmod;
-
-#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
 
 void set_cntfreq(void)
 {
 	omap_smc1(OMAP5_DRA7_MON_SET_CNTFRQ_INDEX, arch_timer_freq);
 }
-#endif
-
-static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
-{
-	struct clock_event_device *evt = &clockevent_gpt;
-
-	__omap_dm_timer_write_status(&clkev, OMAP_TIMER_INT_OVERFLOW);
-
-	evt->event_handler(evt);
-	return IRQ_HANDLED;
-}
-
-static int omap2_gp_timer_set_next_event(unsigned long cycles,
-					 struct clock_event_device *evt)
-{
-	__omap_dm_timer_load_start(&clkev, OMAP_TIMER_CTRL_ST,
-				   0xffffffff - cycles, OMAP_TIMER_POSTED);
-
-	return 0;
-}
-
-static int omap2_gp_timer_shutdown(struct clock_event_device *evt)
-{
-	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
-	return 0;
-}
-
-static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
-{
-	u32 period;
-
-	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
-
-	period = clkev.rate / HZ;
-	period -= 1;
-	/* Looks like we need to first set the load value separately */
-	__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG, 0xffffffff - period,
-			      OMAP_TIMER_POSTED);
-	__omap_dm_timer_load_start(&clkev,
-				   OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
-				   0xffffffff - period, OMAP_TIMER_POSTED);
-	return 0;
-}
-
-static void omap_clkevt_idle(struct clock_event_device *unused)
-{
-	if (!clockevent_gpt_hwmod)
-		return;
-
-	omap_hwmod_idle(clockevent_gpt_hwmod);
-}
-
-static void omap_clkevt_unidle(struct clock_event_device *unused)
-{
-	if (!clockevent_gpt_hwmod)
-		return;
-
-	omap_hwmod_enable(clockevent_gpt_hwmod);
-	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
-}
-
-static struct clock_event_device clockevent_gpt = {
-	.features		= CLOCK_EVT_FEAT_PERIODIC |
-				  CLOCK_EVT_FEAT_ONESHOT,
-	.rating			= 300,
-	.set_next_event		= omap2_gp_timer_set_next_event,
-	.set_state_shutdown	= omap2_gp_timer_shutdown,
-	.set_state_periodic	= omap2_gp_timer_set_periodic,
-	.set_state_oneshot	= omap2_gp_timer_shutdown,
-	.tick_resume		= omap2_gp_timer_shutdown,
-};
-
-static const struct of_device_id omap_timer_match[] __initconst = {
-	{ .compatible = "ti,omap2420-timer", },
-	{ .compatible = "ti,omap3430-timer", },
-	{ .compatible = "ti,omap4430-timer", },
-	{ .compatible = "ti,omap5430-timer", },
-	{ .compatible = "ti,dm814-timer", },
-	{ .compatible = "ti,dm816-timer", },
-	{ .compatible = "ti,am335x-timer", },
-	{ .compatible = "ti,am335x-timer-1ms", },
-	{ }
-};
-
-static int omap_timer_add_disabled_property(struct device_node *np)
-{
-	struct property *prop;
-
-	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
-	if (!prop)
-		return -ENOMEM;
-
-	prop->name = "status";
-	prop->value = "disabled";
-	prop->length = strlen(prop->value);
-
-	return of_add_property(np, prop);
-}
-
-static int omap_timer_update_dt(struct device_node *np)
-{
-	int error = 0;
-
-	if (!of_device_is_compatible(np, "ti,omap-counter32k")) {
-		error = omap_timer_add_disabled_property(np);
-		if (error)
-			return error;
-	}
-
-	/* No parent interconnect target module configured? */
-	if (of_get_property(np, "ti,hwmods", NULL))
-		return error;
-
-	/* Tag parent interconnect target module disabled */
-	error = omap_timer_add_disabled_property(np->parent);
-	if (error)
-		return error;
-
-	return 0;
-}
-
-/**
- * omap_get_timer_dt - get a timer using device-tree
- * @match	- device-tree match structure for matching a device type
- * @property	- optional timer property to match
- *
- * Helper function to get a timer during early boot using device-tree for use
- * as kernel system timer. Optionally, the property argument can be used to
- * select a timer with a specific property. Once a timer is found then mark
- * the timer node in device-tree as disabled, to prevent the kernel from
- * registering this timer as a platform device and so no one else can use it.
- */
-static struct device_node * __init omap_get_timer_dt(const struct of_device_id *match,
-						     const char *property)
-{
-	struct device_node *np;
-	int error;
-
-	for_each_matching_node(np, match) {
-		if (!of_device_is_available(np))
-			continue;
-
-		if (property && !of_get_property(np, property, NULL))
-			continue;
-
-		if (!property && (of_get_property(np, "ti,timer-alwon", NULL) ||
-				  of_get_property(np, "ti,timer-dsp", NULL) ||
-				  of_get_property(np, "ti,timer-pwm", NULL) ||
-				  of_get_property(np, "ti,timer-secure", NULL)))
-			continue;
-
-		error = omap_timer_update_dt(np);
-		WARN(error, "%s: Could not update dt: %i\n", __func__, error);
-
-		return np;
-	}
-
-	return NULL;
-}
-
-/**
- * omap_dmtimer_init - initialisation function when device tree is used
- *
- * For secure OMAP3/DRA7xx devices, timers with device type "timer-secure"
- * cannot be used by the kernel as they are reserved. Therefore, to prevent the
- * kernel registering these devices remove them dynamically from the device
- * tree on boot.
- */
-static void __init omap_dmtimer_init(void)
-{
-	struct device_node *np;
-
-	if (!cpu_is_omap34xx() && !soc_is_dra7xx())
-		return;
-
-	/* If we are a secure device, remove any secure timer nodes */
-	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)) {
-		np = omap_get_timer_dt(omap_timer_match, "ti,timer-secure");
-		of_node_put(np);
-	}
-}
-
-/**
- * omap_dm_timer_get_errata - get errata flags for a timer
- *
- * Get the timer errata flags that are specific to the OMAP device being used.
- */
-static u32 __init omap_dm_timer_get_errata(void)
-{
-	if (cpu_is_omap24xx())
-		return 0;
-
-	return OMAP_TIMER_ERRATA_I103_I767;
-}
-
-static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
-					 const char *fck_source,
-					 const char *property,
-					 const char **timer_name,
-					 int posted)
-{
-	const char *oh_name = NULL;
-	struct device_node *np;
-	struct omap_hwmod *oh;
-	struct clk *src;
-	int r = 0;
-
-	np = omap_get_timer_dt(omap_timer_match, property);
-	if (!np)
-		return -ENODEV;
-
-	of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-	if (!oh_name) {
-		of_property_read_string_index(np->parent, "ti,hwmods", 0,
-					      &oh_name);
-		if (!oh_name)
-			return -ENODEV;
-	}
-
-	timer->irq = irq_of_parse_and_map(np, 0);
-	if (!timer->irq)
-		return -ENXIO;
-
-	timer->io_base = of_iomap(np, 0);
-
-	timer->fclk = of_clk_get_by_name(np, "fck");
-
-	of_node_put(np);
-
-	oh = omap_hwmod_lookup(oh_name);
-	if (!oh)
-		return -ENODEV;
-
-	*timer_name = oh->name;
-
-	if (!timer->io_base)
-		return -ENXIO;
-
-	omap_hwmod_setup_one(oh_name);
-
-	/* After the dmtimer is using hwmod these clocks won't be needed */
-	if (IS_ERR_OR_NULL(timer->fclk))
-		timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
-	if (IS_ERR(timer->fclk))
-		return PTR_ERR(timer->fclk);
-
-	src = clk_get(NULL, fck_source);
-	if (IS_ERR(src))
-		return PTR_ERR(src);
-
-	WARN(clk_set_parent(timer->fclk, src) < 0,
-	     "Cannot set timer parent clock, no PLL clock driver?");
-
-	clk_put(src);
-
-	omap_hwmod_enable(oh);
-	__omap_dm_timer_init_regs(timer);
-
-	if (posted)
-		__omap_dm_timer_enable_posted(timer);
-
-	/* Check that the intended posted configuration matches the actual */
-	if (posted != timer->posted)
-		return -EINVAL;
-
-	timer->rate = clk_get_rate(timer->fclk);
-	timer->reserved = 1;
-
-	return r;
-}
 
 #if !defined(CONFIG_SMP) && defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)
 void tick_broadcast(const struct cpumask *mask)
@@ -356,226 +52,6 @@ void tick_broadcast(const struct cpumask *mask)
 }
 #endif
 
-static void __init omap2_gp_clockevent_init(int gptimer_id,
-						const char *fck_source,
-						const char *property)
-{
-	int res;
-
-	clkev.id = gptimer_id;
-	clkev.errata = omap_dm_timer_get_errata();
-
-	/*
-	 * For clock-event timers we never read the timer counter and
-	 * so we are not impacted by errata i103 and i767. Therefore,
-	 * we can safely ignore this errata for clock-event timers.
-	 */
-	__omap_dm_timer_override_errata(&clkev, OMAP_TIMER_ERRATA_I103_I767);
-
-	res = omap_dm_timer_init_one(&clkev, fck_source, property,
-				     &clockevent_gpt.name, OMAP_TIMER_POSTED);
-	BUG_ON(res);
-
-	if (request_irq(clkev.irq, omap2_gp_timer_interrupt,
-			IRQF_TIMER | IRQF_IRQPOLL, "gp_timer", &clkev))
-		pr_err("Failed to request irq %d (gp_timer)\n", clkev.irq);
-
-	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
-
-	clockevent_gpt.cpumask = cpu_possible_mask;
-	clockevent_gpt.irq = omap_dm_timer_get_irq(&clkev);
-	clockevents_config_and_register(&clockevent_gpt, clkev.rate,
-					3, /* Timer internal resynch latency */
-					0xffffffff);
-
-	if (soc_is_am33xx() || soc_is_am43xx()) {
-		clockevent_gpt.suspend = omap_clkevt_idle;
-		clockevent_gpt.resume = omap_clkevt_unidle;
-
-		clockevent_gpt_hwmod =
-			omap_hwmod_lookup(clockevent_gpt.name);
-	}
-
-	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
-		clkev.rate);
-}
-
-/* Clocksource code */
-static struct omap_dm_timer clksrc;
-static bool use_gptimer_clksrc __initdata;
-
-/*
- * clocksource
- */
-static u64 clocksource_read_cycles(struct clocksource *cs)
-{
-	return (u64)__omap_dm_timer_read_counter(&clksrc,
-						     OMAP_TIMER_NONPOSTED);
-}
-
-static struct clocksource clocksource_gpt = {
-	.rating		= 300,
-	.read		= clocksource_read_cycles,
-	.mask		= CLOCKSOURCE_MASK(32),
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
-static u64 notrace dmtimer_read_sched_clock(void)
-{
-	if (clksrc.reserved)
-		return __omap_dm_timer_read_counter(&clksrc,
-						    OMAP_TIMER_NONPOSTED);
-
-	return 0;
-}
-
-static const struct of_device_id omap_counter_match[] __initconst = {
-	{ .compatible = "ti,omap-counter32k", },
-	{ }
-};
-
-/* Setup free-running counter for clocksource */
-static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
-{
-	int ret;
-	struct device_node *np = NULL;
-	struct omap_hwmod *oh;
-	const char *oh_name = "counter_32k";
-
-	/*
-	 * See if the 32kHz counter is supported.
-	 */
-	np = omap_get_timer_dt(omap_counter_match, NULL);
-	if (!np)
-		return -ENODEV;
-
-	of_property_read_string_index(np->parent, "ti,hwmods", 0, &oh_name);
-	if (!oh_name) {
-		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-		if (!oh_name)
-			return -ENODEV;
-	}
-
-	/*
-	 * First check hwmod data is available for sync32k counter
-	 */
-	oh = omap_hwmod_lookup(oh_name);
-	if (!oh || oh->slaves_cnt == 0)
-		return -ENODEV;
-
-	omap_hwmod_setup_one(oh_name);
-
-	ret = omap_hwmod_enable(oh);
-	if (ret) {
-		pr_warn("%s: failed to enable counter_32k module (%d)\n",
-							__func__, ret);
-		return ret;
-	}
-
-	return ret;
-}
-
-static unsigned int omap2_gptimer_clksrc_load;
-
-static void omap2_gptimer_clksrc_suspend(struct clocksource *unused)
-{
-	omap2_gptimer_clksrc_load =
-		__omap_dm_timer_read_counter(&clksrc, OMAP_TIMER_NONPOSTED);
-
-	omap_hwmod_idle(clocksource_gpt_hwmod);
-}
-
-static void omap2_gptimer_clksrc_resume(struct clocksource *unused)
-{
-	omap_hwmod_enable(clocksource_gpt_hwmod);
-
-	__omap_dm_timer_load_start(&clksrc,
-				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR,
-				   omap2_gptimer_clksrc_load,
-				   OMAP_TIMER_NONPOSTED);
-}
-
-static void __init omap2_gptimer_clocksource_init(int gptimer_id,
-						  const char *fck_source,
-						  const char *property)
-{
-	int res;
-
-	clksrc.id = gptimer_id;
-	clksrc.errata = omap_dm_timer_get_errata();
-
-	res = omap_dm_timer_init_one(&clksrc, fck_source, property,
-				     &clocksource_gpt.name,
-				     OMAP_TIMER_NONPOSTED);
-
-	if (soc_is_am43xx()) {
-		clocksource_gpt.suspend = omap2_gptimer_clksrc_suspend;
-		clocksource_gpt.resume = omap2_gptimer_clksrc_resume;
-
-		clocksource_gpt_hwmod =
-			omap_hwmod_lookup(clocksource_gpt.name);
-	}
-
-	BUG_ON(res);
-
-	__omap_dm_timer_load_start(&clksrc,
-				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0,
-				   OMAP_TIMER_NONPOSTED);
-	sched_clock_register(dmtimer_read_sched_clock, 32, clksrc.rate);
-
-	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
-		pr_err("Could not register clocksource %s\n",
-			clocksource_gpt.name);
-	else
-		pr_info("OMAP clocksource: %s at %lu Hz\n",
-			clocksource_gpt.name, clksrc.rate);
-}
-
-static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
-		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
-		const char *clksrc_prop, bool gptimer)
-{
-	omap_clk_init();
-	omap_dmtimer_init();
-	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
-
-	/* Enable the use of clocksource="gp_timer" kernel parameter */
-	if (clksrc_nr && (use_gptimer_clksrc || gptimer))
-		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
-						clksrc_prop);
-	else
-		omap2_sync32k_clocksource_init();
-}
-
-void __init omap_init_time(void)
-{
-	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck", NULL, false);
-
-	timer_probe();
-}
-
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
-void __init omap3_secure_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
-			2, "timer_sys_ck", NULL, false);
-
-	timer_probe();
-}
-#endif /* CONFIG_ARCH_OMAP3 */
-
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX) || \
-	defined(CONFIG_SOC_AM43XX)
-void __init omap3_gptimer_timer_init(void)
-{
-	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
-			1, "timer_sys_ck", "ti,timer-alwon", true);
-	if (of_have_populated_dt())
-		timer_probe();
-}
-#endif
-
 #if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
 
 /*
@@ -589,7 +65,6 @@ void __init omap3_gptimer_timer_init(void)
  */
 static void __init realtime_counter_init(void)
 {
-#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 	void __iomem *base;
 	static struct clk *sys_clk;
 	unsigned long rate;
@@ -688,7 +163,6 @@ static void __init realtime_counter_init(void)
 	set_cntfreq();
 
 	iounmap(base);
-#endif
 }
 
 void __init omap5_realtime_timer_init(void)
@@ -699,28 +173,3 @@ void __init omap5_realtime_timer_init(void)
 	timer_probe();
 }
 #endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */
-
-/**
- * omap2_override_clocksource - clocksource override with user configuration
- *
- * Allows user to override default clocksource, using kernel parameter
- *   clocksource="gp_timer"	(For all OMAP2PLUS architectures)
- *
- * Note that, here we are using same standard kernel parameter "clocksource=",
- * and not introducing any OMAP specific interface.
- */
-static int __init omap2_override_clocksource(char *str)
-{
-	if (!str)
-		return 0;
-	/*
-	 * For OMAP architecture, we only have two options
-	 *    - sync_32k (default)
-	 *    - gp_timer (sys_clk based)
-	 */
-	if (!strcmp(str, "gp_timer"))
-		use_gptimer_clksrc = true;
-
-	return 0;
-}
-early_param("clocksource", omap2_override_clocksource);

commit 036a3d42bb8f28ae3cdd7c9570135c243724fbd6
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 7 09:59:31 2020 -0700

    ARM: dts: Configure system timers for omap5 and dra7
    
    We can now init system timers using the dmtimer and 32k counter
    based on only devicetree data and drivers/clocksource timers.
    Let's configure the clocksource and clockevent, and drop the old
    unused platform data.
    
    As we're just dropping platform data, and the early platform data
    init is based on the custom ti,hwmods property, we want to drop
    both the platform data and ti,hwmods property in a single patch.
    
    Since the dmtimer can use both 32k clock and system clock as the
    source, let's also configure the SoC specific default values. The
    board specific dts files can reconfigure these with assigned-clocks
    and assigned-clock-parents as needed.
    
    Note that similar to omap_init_time_of(), we now need to call
    omap_clk_init() also from omap5_realtime_timer_init().
    
    Cc: devicetree@vger.kernel.org
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 8b09cdacc30d..662a31004b91 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -576,21 +576,6 @@ void __init omap3_gptimer_timer_init(void)
 }
 #endif
 
-#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) ||		\
-	defined(CONFIG_SOC_DRA7XX)
-static void __init omap4_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-				  0, NULL, NULL, false);
-}
-
-void __init omap4_local_timer_init(void)
-{
-	omap4_sync32k_timer_init();
-	timer_probe();
-}
-#endif
-
 #if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
 
 /*
@@ -708,7 +693,7 @@ static void __init realtime_counter_init(void)
 
 void __init omap5_realtime_timer_init(void)
 {
-	omap4_sync32k_timer_init();
+	omap_clk_init();
 	realtime_counter_init();
 
 	timer_probe();

commit b75ca5217743e4d7076cf65e044e88389e44318d
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Sun Mar 1 17:49:44 2020 +0530

    ARM: OMAP: replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 0d0a731cb476..8b09cdacc30d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -91,12 +91,6 @@ static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct irqaction omap2_gp_timer_irq = {
-	.name		= "gp_timer",
-	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= omap2_gp_timer_interrupt,
-};
-
 static int omap2_gp_timer_set_next_event(unsigned long cycles,
 					 struct clock_event_device *evt)
 {
@@ -382,8 +376,9 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 				     &clockevent_gpt.name, OMAP_TIMER_POSTED);
 	BUG_ON(res);
 
-	omap2_gp_timer_irq.dev_id = &clkev;
-	setup_irq(clkev.irq, &omap2_gp_timer_irq);
+	if (request_irq(clkev.irq, omap2_gp_timer_interrupt,
+			IRQF_TIMER | IRQF_IRQPOLL, "gp_timer", &clkev))
+		pr_err("Failed to request irq %d (gp_timer)\n", clkev.irq);
 
 	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
 

commit 37238d3dd584dc4ce87d844681b89ef58f8200ea
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 13 09:37:49 2019 -0800

    ARM: OMAP2+: Drop useless gptimer option for omap4
    
    We have local timers on Cortex-A9, so using the gptimer option makes no
    sense. Let's just drop it for omap4 to simplify the timer options a bit.
    
    If this is really needed, it can be still done by specifying dts properties
    in the board specific file for assigned-clocks and assigned-clock-parents.
    
    This gets us a bit closer to start dropping legacy platform data for
    gptimers except for timer1 that is used for system clockevent.
    
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07bea84c5d6e..0d0a731cb476 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -545,7 +545,7 @@ static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src
 	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
 
 	/* Enable the use of clocksource="gp_timer" kernel parameter */
-	if (use_gptimer_clksrc || gptimer)
+	if (clksrc_nr && (use_gptimer_clksrc || gptimer))
 		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
 						clksrc_prop);
 	else
@@ -586,7 +586,7 @@ void __init omap3_gptimer_timer_init(void)
 static void __init omap4_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "sys_clkin_ck", NULL, false);
+				  0, NULL, NULL, false);
 }
 
 void __init omap4_local_timer_init(void)

commit b76455335447fa8b73ebc0ca768e46ee74fcd329
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Nov 15 10:58:58 2018 +0100

    ARM: OMAP2+: timer: Remove obsolete inclusion of <asm/smp_twd.h>
    
    As of commit d1dabab2841d546f ("ARM: OMAP2+: Clean up
    omap4_local_timer_init"), this header file is no longer used.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 98ed5ac073bc..07bea84c5d6e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -44,7 +44,6 @@
 #include <linux/sched_clock.h>
 
 #include <asm/mach/time.h>
-#include <asm/smp_twd.h>
 
 #include "omap_hwmod.h"
 #include "omap_device.h"

commit bd6cc4f2d2700fb0a1b0251a95113f0fb517a9b9
Merge: 320b85794724 759c27bdc775
Author: Olof Johansson <olof@lixom.net>
Date:   Fri May 25 15:23:25 2018 -0700

    Merge tag 'omap-for-v4.18/soc-late-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    Late omap soc changes for v4.18 merge window
    
    This series contains two omap1 ams-delta GPIO clean-up patches to get
    started with removal of hard-coded GPIO numbers from drivers. And then
    the removal of board mach includes from drivers. The second patch mostly
    touches the ams-delta audio driver but is included here because of the
    removal of the latch gpios and is acked by Mark Brown.
    
    And there are two more am437x related PM patches to save and restore
    control module and timer registers for RTC only suspend mode. Looks like
    the patch title for the timer changes is a bit misleading, not all the
    timer code is yet living under drivers/clocksource. But I had already
    pushed out the branch before I noticed this.
    
    * tag 'omap-for-v4.18/soc-late-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      OMAP: CLK: CLKSRC: Add suspend resume hooks
      ARM: AM43XX: Add functions to save/restore am43xx control registers
      ASoC: ams_delta: use GPIO lookup table
      ARM: OMAP1: ams-delta: add GPIO lookup tables
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 759c27bdc77577aaecb6f31768e5951a858f97a9
Author: Keerthy <j-keerthy@ti.com>
Date:   Tue May 22 23:52:20 2018 +0530

    OMAP: CLK: CLKSRC: Add suspend resume hooks
    
    Add the save and restore for clksrc as part of suspend and resume
    so that it saves the counter value and restores. This is needed in
    modes like rtc+ddr in self-refresh not doing this stalls the time.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4fb4dc24e5e9..e16b207e9e56 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -71,6 +71,9 @@ static struct clock_event_device clockevent_gpt;
 /* Clockevent hwmod for am335x and am437x suspend */
 static struct omap_hwmod *clockevent_gpt_hwmod;
 
+/* Clockesource hwmod for am437x suspend */
+static struct omap_hwmod *clocksource_gpt_hwmod;
+
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
 
@@ -442,6 +445,26 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 	return ret;
 }
 
+static unsigned int omap2_gptimer_clksrc_load;
+
+static void omap2_gptimer_clksrc_suspend(struct clocksource *unused)
+{
+	omap2_gptimer_clksrc_load =
+		__omap_dm_timer_read_counter(&clksrc, OMAP_TIMER_NONPOSTED);
+
+	omap_hwmod_idle(clocksource_gpt_hwmod);
+}
+
+static void omap2_gptimer_clksrc_resume(struct clocksource *unused)
+{
+	omap_hwmod_enable(clocksource_gpt_hwmod);
+
+	__omap_dm_timer_load_start(&clksrc,
+				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR,
+				   omap2_gptimer_clksrc_load,
+				   OMAP_TIMER_NONPOSTED);
+}
+
 static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 						  const char *fck_source,
 						  const char *property)
@@ -454,6 +477,15 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 	res = omap_dm_timer_init_one(&clksrc, fck_source, property,
 				     &clocksource_gpt.name,
 				     OMAP_TIMER_NONPOSTED);
+
+	if (soc_is_am43xx()) {
+		clocksource_gpt.suspend = omap2_gptimer_clksrc_suspend;
+		clocksource_gpt.resume = omap2_gptimer_clksrc_resume;
+
+		clocksource_gpt_hwmod =
+			omap_hwmod_lookup(clocksource_gpt.name);
+	}
+
 	BUG_ON(res);
 
 	__omap_dm_timer_load_start(&clksrc,

commit b456d4f592ba01a60c78539ca519893f86e4a600
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Apr 16 10:21:39 2018 -0700

    ARM: OMAP2+: Allow using ti-sysc for system timers
    
    If a system timer is configured with an interrconnect target module in
    the dts, the ti,hwmods and module fck are at the interconnect target
    level. Then there's a separate fck for the timer child device.
    
    If the child device has a separate functional clock, we need to configure
    it directly. For example, timer clk clkctrl clock bit 0 is the module
    clock for the interconnect target, and bit 24 being the functional clock
    for the timer IP.
    
    For system timers, we already mark them as disabled. Now must also mark
    the interconnect target module as disabled to prevent ti-sysc to manage
    it instead of the system timer.
    
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 61dd72df119c..5a70ab67af8e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -167,6 +167,43 @@ static const struct of_device_id omap_timer_match[] __initconst = {
 	{ }
 };
 
+static int omap_timer_add_disabled_property(struct device_node *np)
+{
+	struct property *prop;
+
+	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
+	if (!prop)
+		return -ENOMEM;
+
+	prop->name = "status";
+	prop->value = "disabled";
+	prop->length = strlen(prop->value);
+
+	return of_add_property(np, prop);
+}
+
+static int omap_timer_update_dt(struct device_node *np)
+{
+	int error = 0;
+
+	if (!of_device_is_compatible(np, "ti,omap-counter32k")) {
+		error = omap_timer_add_disabled_property(np);
+		if (error)
+			return error;
+	}
+
+	/* No parent interconnect target module configured? */
+	if (of_get_property(np, "ti,hwmods", NULL))
+		return error;
+
+	/* Tag parent interconnect target module disabled */
+	error = omap_timer_add_disabled_property(np->parent);
+	if (error)
+		return error;
+
+	return 0;
+}
+
 /**
  * omap_get_timer_dt - get a timer using device-tree
  * @match	- device-tree match structure for matching a device type
@@ -182,6 +219,7 @@ static struct device_node * __init omap_get_timer_dt(const struct of_device_id *
 						     const char *property)
 {
 	struct device_node *np;
+	int error;
 
 	for_each_matching_node(np, match) {
 		if (!of_device_is_available(np))
@@ -196,17 +234,9 @@ static struct device_node * __init omap_get_timer_dt(const struct of_device_id *
 				  of_get_property(np, "ti,timer-secure", NULL)))
 			continue;
 
-		if (!of_device_is_compatible(np, "ti,omap-counter32k")) {
-			struct property *prop;
+		error = omap_timer_update_dt(np);
+		WARN(error, "%s: Could not update dt: %i\n", __func__, error);
 
-			prop = kzalloc(sizeof(*prop), GFP_KERNEL);
-			if (!prop)
-				return NULL;
-			prop->name = "status";
-			prop->value = "disabled";
-			prop->length = strlen(prop->value);
-			of_add_property(np, prop);
-		}
 		return np;
 	}
 
@@ -265,8 +295,12 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		return -ENODEV;
 
 	of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-	if (!oh_name)
-		return -ENODEV;
+	if (!oh_name) {
+		of_property_read_string_index(np->parent, "ti,hwmods", 0,
+					      &oh_name);
+		if (!oh_name)
+			return -ENODEV;
+	}
 
 	timer->irq = irq_of_parse_and_map(np, 0);
 	if (!timer->irq)
@@ -418,9 +452,12 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 	if (!np)
 		return -ENODEV;
 
-	of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-	if (!oh_name)
-		return -ENODEV;
+	of_property_read_string_index(np->parent, "ti,hwmods", 0, &oh_name);
+	if (!oh_name) {
+		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
+		if (!oh_name)
+			return -ENODEV;
+	}
 
 	/*
 	 * First check hwmod data is available for sync32k counter

commit 44773ba170a6f969620221a6d87d03feae5e464f
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Apr 16 10:22:01 2018 -0700

    ARM: OMAP2+: Drop unused pm-noop
    
    Looks like these functions don't do anything in the mainline kernel so
    we can just drop it.
    
    Note that we must now also remove ir-rx51 pdata as it relies on the dummy
    platform data that does not do anything. And ir-rx51 is calling a pdata
    callback that doesn't do anything without checking if it exists first.
    
    For configuring device specific minimal latencies, the interface to use
    is pm_qos_add_request(). For an example, see what was done in commit
    9834ffd1ecc3 ("ASoC: omap-mcbsp: Add PM QoS support for McBSP to prevent
    glitches"). I've added some comments to ir-rx51 so people using it can
    add pm_qos support and test it.
    
    Cc: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4fb4dc24e5e9..61dd72df119c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -50,7 +50,6 @@
 #include "omap_device.h"
 #include <plat/counter-32k.h>
 #include <clocksource/timer-ti-dm.h>
-#include "omap-pm.h"
 
 #include "soc.h"
 #include "common.h"

commit 5ca467c40c2e557af5675b6a6cf0e7d326349751
Author: Keerthy <j-keerthy@ti.com>
Date:   Thu Feb 15 11:31:44 2018 +0530

    ARM: OMAP: Move dmtimer.h out of plat-omap
    
    The header file is currently under plat-omap directory
    under arch/omap. Move this out to an accessible place.
    
    No Code changes done to the header file and renamed to timer-ti-dm.h.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index d61fbd7a2840..4fb4dc24e5e9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -49,7 +49,7 @@
 #include "omap_hwmod.h"
 #include "omap_device.h"
 #include <plat/counter-32k.h>
-#include <plat/dmtimer.h>
+#include <clocksource/timer-ti-dm.h>
 #include "omap-pm.h"
 
 #include "soc.h"

commit db35340c536f1af0108ec9a0b2126a05d358d14a
Author: Qi Hou <qi.hou@windriver.com>
Date:   Thu Jan 11 12:54:43 2018 +0800

    ARM: OMAP2+: timer: fix a kmemleak caused in omap_get_timer_dt
    
    When more than one GP timers are used as kernel system timers and the
    corresponding nodes in device-tree are marked with the same "disabled"
    property, then the "attr" field of the property will be initialized
    more than once as the property being added to sys file system via
    __of_add_property_sysfs().
    
    In __of_add_property_sysfs(), the "name" field of pp->attr.attr is set
    directly to the return value of safe_name(), without taking care of
    whether it's already a valid pointer to a memory block. If it is, its
    old value will always be overwritten by the new one and the memory block
    allocated before will a "ghost", then a kmemleak happened.
    
    That the same "disabled" property being added to different nodes of device
    tree would cause that kind of kmemleak overhead, at least once.
    
    To fix it, allocate the property dynamically, and delete static one.
    
    Signed-off-by: Qi Hou <qi.hou@windriver.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index ece09c9461f7..d61fbd7a2840 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -156,12 +156,6 @@ static struct clock_event_device clockevent_gpt = {
 	.tick_resume		= omap2_gp_timer_shutdown,
 };
 
-static struct property device_disabled = {
-	.name = "status",
-	.length = sizeof("disabled"),
-	.value = "disabled",
-};
-
 static const struct of_device_id omap_timer_match[] __initconst = {
 	{ .compatible = "ti,omap2420-timer", },
 	{ .compatible = "ti,omap3430-timer", },
@@ -203,8 +197,17 @@ static struct device_node * __init omap_get_timer_dt(const struct of_device_id *
 				  of_get_property(np, "ti,timer-secure", NULL)))
 			continue;
 
-		if (!of_device_is_compatible(np, "ti,omap-counter32k"))
-			of_add_property(np, &device_disabled);
+		if (!of_device_is_compatible(np, "ti,omap-counter32k")) {
+			struct property *prop;
+
+			prop = kzalloc(sizeof(*prop), GFP_KERNEL);
+			if (!prop)
+				return NULL;
+			prop->name = "status";
+			prop->value = "disabled";
+			prop->length = strlen(prop->value);
+			of_add_property(np, prop);
+		}
 		return np;
 	}
 

commit 8ca302e9c61a1b8852f4bd4def8e7ff59f4c729a
Merge: 612341bda6ad 18cfd9429d8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 4 14:34:51 2017 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Arnd Bergmann:
     "SoC platform changes (arch/arm/mach-*). This merge window, the bulk is
      for a few platforms:
    
       - Andres Färber adds initial support for the Actions Semi S500 (aka
         'owl') platform, a close relative of the S900 platform he adds for
         arm64.
    
       - in mach-omap2, we remove more legacy code
    
       - Rockchips gains support for the RV1108 SoC designed for camera
         applications.
    
       - For Atmel, we gain support for MMU-less SoCs (SAME70/V71/S70/V70)
    
       - Minor updates for other platforms, including davinci, s3c64xx,
         prima2, stm32, broadcom nsp, amlogic, pxa, imx and renesas"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (74 commits)
      ARM: owl: smp: Drop bogus holding pen
      ARM: owl: Drop custom machine
      ARM: owl: smp: Implement SPS power-gating for CPU2 and CPU3
      soc: actions: owl-sps: Factor out owl_sps_set_pg() for power-gating
      soc: actions: Add Owl SPS
      dt-bindings: power: Add Owl SPS power domains
      MAINTAINERS: Update Actions Semi section with SPS
      ARM: owl: Implement CPU enable-method for S500
      MAINTAINERS: Add Actions Semi Owl section
      ARM: Prepare Actions Semi S500
      ARM: socfpga: Increase max number of GPIOs
      ARM: stm32: Introduce MACH_STM32F469 flag
      ARM: prima2: remove redundant select CPU_V7
      ARM: davinci: fix const warnings
      ARM: shmobile: pm-rmobile: Use GENPD_FLAG_ALWAYS_ON
      ARM: OMAP4: hwmod_data: add SHAM crypto accelerator
      ARM: OMAP4: hwmod data: add des
      ARM: OMAP4: hwmod data: add aes2
      ARM: OMAP4: hwmod data: add aes1
      ARM: pxa: Delete an error message for a failed memory allocation in pxa3xx_u2d_probe()
      ...

commit ba5d08c0ea785d5710c5a1e7dc3182b7124d63c0
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 17:40:46 2017 +0200

    clocksource/drivers: Rename clocksource_probe to timer_probe
    
    The function name is now renamed to 'timer_probe' for consistency with
    the CLOCKSOURCE_OF_DECLARE => TIMER_OF_DECLARE change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07dd692c4737..ae4bb9fdc483 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -497,7 +497,7 @@ void __init omap_init_time(void)
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL, false);
 
-	clocksource_probe();
+	timer_probe();
 }
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
@@ -506,7 +506,7 @@ void __init omap3_secure_sync32k_timer_init(void)
 	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck", NULL, false);
 
-	clocksource_probe();
+	timer_probe();
 }
 #endif /* CONFIG_ARCH_OMAP3 */
 
@@ -517,7 +517,7 @@ void __init omap3_gptimer_timer_init(void)
 	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
 			1, "timer_sys_ck", "ti,timer-alwon", true);
 	if (of_have_populated_dt())
-		clocksource_probe();
+		timer_probe();
 }
 #endif
 
@@ -532,7 +532,7 @@ static void __init omap4_sync32k_timer_init(void)
 void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
-	clocksource_probe();
+	timer_probe();
 }
 #endif
 
@@ -656,7 +656,7 @@ void __init omap5_realtime_timer_init(void)
 	omap4_sync32k_timer_init();
 	realtime_counter_init();
 
-	clocksource_probe();
+	timer_probe();
 }
 #endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */
 

commit 67d00470accf5c58abbb23a44c867c5f15437976
Merge: 018b732458ac 70f05be32133
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 12 03:27:30 2017 -0700

    Merge branch 'omap-for-v4.13/clkctrl' into omap-for-v4.13/soc-v4

commit 018b732458ac39c4858d9840c0e32310bc0930dd
Merge: c76e4d2e5006 0e78b1218df3
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 12 00:07:44 2017 -0700

    Merge branch 'omap-for-v4.13/legacy-v2' into omap-for-v4.13/soc-v3

commit 138f7ca78f5a0677f591fdf23d0309c2f4774bf7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed May 31 17:59:58 2017 +0300

    ARM: OMAP2+: timer: add support for fetching fck handle from DT
    
    The mux clock handle shall be provided via "fck" DT handle. This avoids
    the need to lookup the main clock via hwmod core, which will not work
    with the clkctrl clock support anymore; the main clock is not going to
    be a mux.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07dd692c4737..af90f95c2433 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -255,6 +255,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 		timer->io_base = of_iomap(np, 0);
 
+		timer->fclk = of_clk_get_by_name(np, "fck");
+
 		of_node_put(np);
 	} else {
 		if (omap_dm_timer_reserve_systimer(timer->id))
@@ -292,7 +294,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	omap_hwmod_setup_one(oh_name);
 
 	/* After the dmtimer is using hwmod these clocks won't be needed */
-	timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
+	if (IS_ERR_OR_NULL(timer->fclk))
+		timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
 	if (IS_ERR(timer->fclk))
 		return PTR_ERR(timer->fclk);
 

commit 8d39ff3d1696f7c6122500e21016f6837984ad8b
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 31 15:51:30 2017 -0700

    ARM: OMAP2+: Remove unused legacy code for timer
    
    We are now booting all mach-omap2 in device tree only mode.
    Any code that is only called in legacy boot mode where
    of_have_populated_dt() is not set is safe to remove now.
    
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07dd692c4737..e4be76016939 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -232,37 +232,27 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 					 const char **timer_name,
 					 int posted)
 {
-	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
 	const char *oh_name = NULL;
 	struct device_node *np;
 	struct omap_hwmod *oh;
-	struct resource irq, mem;
 	struct clk *src;
 	int r = 0;
 
-	if (of_have_populated_dt()) {
-		np = omap_get_timer_dt(omap_timer_match, property);
-		if (!np)
-			return -ENODEV;
+	np = omap_get_timer_dt(omap_timer_match, property);
+	if (!np)
+		return -ENODEV;
 
-		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-		if (!oh_name)
-			return -ENODEV;
+	of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
+	if (!oh_name)
+		return -ENODEV;
 
-		timer->irq = irq_of_parse_and_map(np, 0);
-		if (!timer->irq)
-			return -ENXIO;
+	timer->irq = irq_of_parse_and_map(np, 0);
+	if (!timer->irq)
+		return -ENXIO;
 
-		timer->io_base = of_iomap(np, 0);
+	timer->io_base = of_iomap(np, 0);
 
-		of_node_put(np);
-	} else {
-		if (omap_dm_timer_reserve_systimer(timer->id))
-			return -ENODEV;
-
-		sprintf(name, "timer%d", timer->id);
-		oh_name = name;
-	}
+	of_node_put(np);
 
 	oh = omap_hwmod_lookup(oh_name);
 	if (!oh)
@@ -270,22 +260,6 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 	*timer_name = oh->name;
 
-	if (!of_have_populated_dt()) {
-		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL,
-						   &irq);
-		if (r)
-			return -ENXIO;
-		timer->irq = irq.start;
-
-		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_MEM, NULL,
-						   &mem);
-		if (r)
-			return -ENXIO;
-
-		/* Static mapping, never released */
-		timer->io_base = ioremap(mem.start, mem.end - mem.start);
-	}
-
 	if (!timer->io_base)
 		return -ENXIO;
 
@@ -405,18 +379,15 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 	const char *oh_name = "counter_32k";
 
 	/*
-	 * If device-tree is present, then search the DT blob
-	 * to see if the 32kHz counter is supported.
+	 * See if the 32kHz counter is supported.
 	 */
-	if (of_have_populated_dt()) {
-		np = omap_get_timer_dt(omap_counter_match, NULL);
-		if (!np)
-			return -ENODEV;
-
-		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
-		if (!oh_name)
-			return -ENODEV;
-	}
+	np = omap_get_timer_dt(omap_counter_match, NULL);
+	if (!np)
+		return -ENODEV;
+
+	of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
+	if (!oh_name)
+		return -ENODEV;
 
 	/*
 	 * First check hwmod data is available for sync32k counter
@@ -434,18 +405,6 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 		return ret;
 	}
 
-	if (!of_have_populated_dt()) {
-		void __iomem *vbase;
-
-		vbase = omap_hwmod_get_mpu_rt_va(oh);
-
-		ret = omap_init_clocksource_32k(vbase);
-		if (ret) {
-			pr_warn("%s: failed to initialize counter_32k as a clocksource (%d)\n",
-					__func__, ret);
-			omap_hwmod_idle(oh);
-		}
-	}
 	return ret;
 }
 
@@ -660,96 +619,6 @@ void __init omap5_realtime_timer_init(void)
 }
 #endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */
 
-/**
- * omap_timer_init - build and register timer device with an
- * associated timer hwmod
- * @oh:	timer hwmod pointer to be used to build timer device
- * @user:	parameter that can be passed from calling hwmod API
- *
- * Called by omap_hwmod_for_each_by_class to register each of the timer
- * devices present in the system. The number of timer devices is known
- * by parsing through the hwmod database for a given class name. At the
- * end of function call memory is allocated for timer device and it is
- * registered to the framework ready to be proved by the driver.
- */
-static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
-{
-	int id;
-	int ret = 0;
-	char *name = "omap_timer";
-	struct dmtimer_platform_data *pdata;
-	struct platform_device *pdev;
-	struct omap_timer_capability_dev_attr *timer_dev_attr;
-
-	pr_debug("%s: %s\n", __func__, oh->name);
-
-	/* on secure device, do not register secure timer */
-	timer_dev_attr = oh->dev_attr;
-	if (omap_type() != OMAP2_DEVICE_TYPE_GP && timer_dev_attr)
-		if (timer_dev_attr->timer_capability == OMAP_TIMER_SECURE)
-			return ret;
-
-	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-	if (!pdata) {
-		pr_err("%s: No memory for [%s]\n", __func__, oh->name);
-		return -ENOMEM;
-	}
-
-	/*
-	 * Extract the IDs from name field in hwmod database
-	 * and use the same for constructing ids' for the
-	 * timer devices. In a way, we are avoiding usage of
-	 * static variable witin the function to do the same.
-	 * CAUTION: We have to be careful and make sure the
-	 * name in hwmod database does not change in which case
-	 * we might either make corresponding change here or
-	 * switch back static variable mechanism.
-	 */
-	sscanf(oh->name, "timer%2d", &id);
-
-	if (timer_dev_attr)
-		pdata->timer_capability = timer_dev_attr->timer_capability;
-
-	pdata->timer_errata = omap_dm_timer_get_errata();
-	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
-
-	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata));
-
-	if (IS_ERR(pdev)) {
-		pr_err("%s: Can't build omap_device for %s: %s.\n",
-			__func__, name, oh->name);
-		ret = -EINVAL;
-	}
-
-	kfree(pdata);
-
-	return ret;
-}
-
-/**
- * omap2_dm_timer_init - top level regular device initialization
- *
- * Uses dedicated hwmod api to parse through hwmod database for
- * given class name and then build and register the timer device.
- */
-static int __init omap2_dm_timer_init(void)
-{
-	int ret;
-
-	/* If dtb is there, the devices will be created dynamically */
-	if (of_have_populated_dt())
-		return -ENODEV;
-
-	ret = omap_hwmod_for_each_by_class("timer", omap_timer_init, NULL);
-	if (unlikely(ret)) {
-		pr_err("%s: device registration failed.\n", __func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-omap_arch_initcall(omap2_dm_timer_init);
-
 /**
  * omap2_override_clocksource - clocksource override with user configuration
  *

commit 12b28ba6d6164d3aa54b7e32032bcbd9b7c2a320
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Tue Mar 28 20:57:55 2017 -0500

    ARM: OMAP2+: timer: Add suspend-resume callbacks for clkevent device
    
    OMAP timer code registers two timers - one as clocksource
    and one as clockevent. Since AM33XX has only one usable timer
    in the WKUP domain one of the timers needs suspend-resume
    support to restore the configuration to pre-suspend state.
    
    commit adc78e6b9946 ("timekeeping: Add suspend and resume
    of clock event devices") introduced .suspend and .resume
    callbacks for clock event devices. Leverage these
    callbacks to have AM33XX clockevent timer behave properly
    across system suspend. Extend the use of the .suspend and
    .resume callbacks used by am335x clockevent to am437x as well.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 07dd692c4737..70670dfd7135 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -68,6 +68,9 @@
 static struct omap_dm_timer clkev;
 static struct clock_event_device clockevent_gpt;
 
+/* Clockevent hwmod for am335x and am437x suspend */
+static struct omap_hwmod *clockevent_gpt_hwmod;
+
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
 
@@ -125,6 +128,23 @@ static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 	return 0;
 }
 
+static void omap_clkevt_idle(struct clock_event_device *unused)
+{
+	if (!clockevent_gpt_hwmod)
+		return;
+
+	omap_hwmod_idle(clockevent_gpt_hwmod);
+}
+
+static void omap_clkevt_unidle(struct clock_event_device *unused)
+{
+	if (!clockevent_gpt_hwmod)
+		return;
+
+	omap_hwmod_enable(clockevent_gpt_hwmod);
+	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
+}
+
 static struct clock_event_device clockevent_gpt = {
 	.features		= CLOCK_EVT_FEAT_PERIODIC |
 				  CLOCK_EVT_FEAT_ONESHOT,
@@ -358,6 +378,14 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 					3, /* Timer internal resynch latency */
 					0xffffffff);
 
+	if (soc_is_am33xx() || soc_is_am43xx()) {
+		clockevent_gpt.suspend = omap_clkevt_idle;
+		clockevent_gpt.resume = omap_clkevt_unidle;
+
+		clockevent_gpt_hwmod =
+			omap_hwmod_lookup(clockevent_gpt.name);
+	}
+
 	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
 		clkev.rate);
 }

commit f86a2c875fd146d9b82c8fdd86d31084507bcf4c
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Dec 5 09:27:44 2016 +0530

    ARM: omap2+: am437x: rollback to use omap3_gptimer_timer_init()
    
    The commit 55ee7017ee31 ("arm: omap2: board-generic: use
    omap4_local_timer_init for AM437x") unintentionally changes the
    clocksource devices for AM437x from OMAP GP Timer to SyncTimer32K.
    
    Unfortunately, the SyncTimer32K is starving from frequency deviation
    as mentioned in commit 5b5c01359152 ("ARM: OMAP2+: AM43x: Use gptimer
    as clocksource") and, as reported by Franklin [1], even its monotonic
    nature is under question (most probably there is a HW issue, but it's
    still under investigation).
    
    Taking into account above facts It's reasonable to rollback to the use
    of omap3_gptimer_timer_init().
    
    [1] http://www.spinics.net/lists/linux-omap/msg127425.html
    
    Fixes: 55ee7017ee31 ("arm: omap2: board-generic: use
    omap4_local_timer_init for AM437x")
    Reported-by: Cooper Jr., Franklin <fcooper@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 56128da23c3a..07dd692c4737 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -510,18 +510,19 @@ void __init omap3_secure_sync32k_timer_init(void)
 }
 #endif /* CONFIG_ARCH_OMAP3 */
 
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX) || \
+	defined(CONFIG_SOC_AM43XX)
 void __init omap3_gptimer_timer_init(void)
 {
 	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
 			1, "timer_sys_ck", "ti,timer-alwon", true);
-
-	clocksource_probe();
+	if (of_have_populated_dt())
+		clocksource_probe();
 }
 #endif
 
 #if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) ||		\
-	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
+	defined(CONFIG_SOC_DRA7XX)
 static void __init omap4_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5e2e2218a402..56128da23c3a 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -369,9 +369,9 @@ static bool use_gptimer_clksrc __initdata;
 /*
  * clocksource
  */
-static cycle_t clocksource_read_cycles(struct clocksource *cs)
+static u64 clocksource_read_cycles(struct clocksource *cs)
 {
-	return (cycle_t)__omap_dm_timer_read_counter(&clksrc,
+	return (u64)__omap_dm_timer_read_counter(&clksrc,
 						     OMAP_TIMER_NONPOSTED);
 }
 

commit fbae5cbb43512446ba15a3b90039cb127d22ee95
Merge: 6f888fe31dfc 4756f881ba30
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 1 18:27:08 2016 -0400

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "Improved and new platform support for various SoCs:
    
      New SoC support:
       - Broadcom BCM23550
       - Freescale i.MX7Solo
       - Qualcomm MDM9615
       - Renesas r8a7792
    
      Improvements:
       - convert clps711x to multiplatform
       - debug uart improvements for Atmel platforms
       - Tango platform improvements: HOTPLUG_CPU, Suspend-to-ram
       - OMAP tweaks and improvements to hwmod
       - OMAP support for kexec on SMP"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (109 commits)
      ARM: davinci: fix build break because of undeclared dm365_evm_snd_data
      ARM: s3c64xx: smartq: Avoid sparse warnings
      ARM: sti: Implement dummy L2 cache's write_sec
      ARM: STi: Update machine _namestr to be more generic.
      arm: meson: explicitly select clk drivers
      ARM: tango: add Suspend-to-RAM support
      ARM: hisi: consolidate the hisilicon machine entries
      ARM: tango: fix CONFIG_HOTPLUG_CPU=n build
      MAINTAINERS: Update BCM281XX/BCM11XXX/BCM216XX entry
      MAINTAINERS: Update BCM63XX entry
      MAINTAINERS: Add NS2 entry
      MAINTAINERS: Fix nsp false-positives
      MAINTAINERS: Change L to M for Broadcom ARM/ARM64 SoC entries
      ARM: debug: Enable DEBUG_BCM_5301X for Northstar Plus SoCs
      ARM: clps711x: Switch to MULTIPLATFORM
      ARM: clps711x: Remove boards support
      ARM: clps711x: Add basic DT support
      ARM: clps711x: Reduce static map size
      ARM: SAMSUNG: Constify iomem address passed to s5p_init_cpu
      ARM: oxnas: Change OX810SE default driver config
      ...

commit e98580e880fb88810a1cd2a1a2583371fc0aa19e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jun 30 16:15:01 2016 +0300

    ARM: OMAP2+: timer: change order of hwmod data handling
    
    With the introduction of hwmod module clocks, the name of the hwmod
    main clk may not be available before hwmod setup, as hwmod setup
    may lookup the main clock dynamically based on the hwmod name.
    Thus, change the order of hwmod setup and main clock handling for
    the timer code, to make sure the main clock is going to be
    available.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5b385bb8aff9..e7eccf6a4daf 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -289,6 +289,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (!timer->io_base)
 		return -ENXIO;
 
+	omap_hwmod_setup_one(oh_name);
+
 	/* After the dmtimer is using hwmod these clocks won't be needed */
 	timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
 	if (IS_ERR(timer->fclk))
@@ -303,7 +305,6 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 	clk_put(src);
 
-	omap_hwmod_setup_one(oh_name);
 	omap_hwmod_enable(oh);
 	__omap_dm_timer_init_regs(timer);
 

commit 970f9091d25df14e9540ec7ff48a2f709e284cd1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jun 16 15:25:18 2016 +0300

    ARM: OMAP2+: timer: add probe for clocksources
    
    A few platforms are currently missing clocksource_probe() completely
    in their time_init functionality. On OMAP3430 for example, this is
    causing cpuidle to be pretty much dead, as the counter32k is not
    going to be registered and instead a gptimer is used as a clocksource.
    This will tick in periodic mode, preventing any deeper idle states.
    
    While here, also drop one unnecessary check for populated DT before
    existing clocksource_probe() call.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5b385bb8aff9..cb9497a20fb3 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -496,8 +496,7 @@ void __init omap_init_time(void)
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL, false);
 
-	if (of_have_populated_dt())
-		clocksource_probe();
+	clocksource_probe();
 }
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
@@ -505,6 +504,8 @@ void __init omap3_secure_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck", NULL, false);
+
+	clocksource_probe();
 }
 #endif /* CONFIG_ARCH_OMAP3 */
 
@@ -513,6 +514,8 @@ void __init omap3_gptimer_timer_init(void)
 {
 	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
 			1, "timer_sys_ck", "ti,timer-alwon", true);
+
+	clocksource_probe();
 }
 #endif
 

commit 1305eda751d7df3069b1fcb6f62036185acd24a0
Merge: 6b5a12dbca7a d6bd05794f18
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 20 18:10:05 2016 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "Updates for new platform support:
    
       - New platform: Tango4 from Sigma Designs.
       - Broadcom BCM2836 (Raspberry Pi 2 SoC)
       - Enable cpufreq on Freescale i.MX7D
       - Rockchip: SMP support for rk3036, general support for rk3228
       - SMP support on Broadcom Kona and NSP
       - Cleanups for OMAP removing legacy IOMMU data
    
      + a bunch of misc fixes and tweaks for various platforms"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (46 commits)
      ARM: tango: Fix UP build issues
      ARM: tango: pass ARM arch level for smc.S
      ARM: bcm2835: Add Kconfig support for bcm2836
      ARM: OMAP2+: Add support for dm814x and dra62x usb
      ARM: OMAP2+: Add mmc hwmod entries for dm814x
      ARM: OMAP2+: Update 81xx clock and power domains for default, active and sgx
      ARM: OMAP2+: Fix SoC detection for dra62x j5-eco
      ARM: tango4: Initial platform support
      ARM: bcm2835: Add a compat string for bcm2836 machine probe
      dt-bindings: Add root properties for Raspberry Pi 2
      ARM: imx: select SRC for i.MX7
      ARM: uniphier: select PINCTRL
      ARM: OMAP2+: Remove device creation for omap-pcm-audio
      ARM: OMAP1: Remove device creation for omap-pcm-audio
      ARM: rockchip: enable support for RK3228 SoCs
      ARM: rockchip: use const and __initconst for rk3036 smp_operations
      ARM: zynq: Select ARCH_HAS_RESET_CONTROLLER
      ARM: BCM: Add SMP support for Broadcom 4708
      ARM: BCM: Add SMP support for Broadcom NSP
      ARM: BCM: Clean up SMP support for Broadcom Kona
      ...

commit 0b3e6fca4d1af4aa150d32506220f4241323a00c
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Dec 14 22:34:05 2015 +0200

    ARM: OMAP2+: am43xx: enable GENERIC_CLOCKEVENTS_BROADCAST
    
    System will misbehave in the following case:
    - AM43XX only build (UP);
    - CONFIG_CPU_IDLE=y
    - ARM TWD timer enabled and selected as clockevent device.
    
    In the above case, It's expected that broadcast timer will be used as
    backup timer when CPUIdle will put MPU in low power states where ARM
    TWD will stop and lose its context. But, the CONFIG_SMP might not be
    selected when kernel is built for AM43XX SoC only and, as result,
    GENERIC_CLOCKEVENTS_BROADCAST option will not be selected also. This
    will break CPUIdle and System will stuck in low power states.
    
    Hence, fix it by selecting GENERIC_CLOCKEVENTS_BROADCAST option for
    AM43XX SoCs always and add empty tick_broadcast() function
    implementation - no need to send any IPI on UP. After this change
    timer1 will be selected as broadcast timer the same way as for SMP,
    and CPUIdle will work properly.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b18ebbefae09..f86692dbcfd5 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -320,6 +320,12 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	return r;
 }
 
+#if !defined(CONFIG_SMP) && defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)
+void tick_broadcast(const struct cpumask *mask)
+{
+}
+#endif
+
 static void __init omap2_gp_clockevent_init(int gptimer_id,
 						const char *fck_source,
 						const char *property)

commit ed5a4c6248a9e842d691dd3660b9f79be846693f
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Oct 5 18:28:22 2015 -0500

    ARM: OMAP2+: timer: Remove secure timer for DRA7xx HS devices
    
    Timer 12 on DRA7 SoCs is reserved for secure usage on high-secure (HS)
    devices. The timer cannot be used by the kernel on HS devices, but is
    available on regular general purpose (GP) devices. This is similar to the
    behavior on OMAP3 devices, so extend the logic used in commit ad24bde8f102
    ("ARM: OMAP3: Dynamically disable secure timer nodes for secure devices")
    to remove the secure timer on DRA7xx SoCs at run-time based on the SoC
    device type.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b18ebbefae09..6c19d1e2029f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -194,8 +194,8 @@ static struct device_node * __init omap_get_timer_dt(const struct of_device_id *
 /**
  * omap_dmtimer_init - initialisation function when device tree is used
  *
- * For secure OMAP3 devices, timers with device type "timer-secure" cannot
- * be used by the kernel as they are reserved. Therefore, to prevent the
+ * For secure OMAP3/DRA7xx devices, timers with device type "timer-secure"
+ * cannot be used by the kernel as they are reserved. Therefore, to prevent the
  * kernel registering these devices remove them dynamically from the device
  * tree on boot.
  */
@@ -203,7 +203,7 @@ static void __init omap_dmtimer_init(void)
 {
 	struct device_node *np;
 
-	if (!cpu_is_omap34xx())
+	if (!cpu_is_omap34xx() && !soc_is_dra7xx())
 		return;
 
 	/* If we are a secure device, remove any secure timer nodes */

commit a5e1d715a8d0696961d99d31d869aa522f1cad5a
Merge: 64fd8c8a0ff4 d3dc3df6330e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 14:48:36 2015 -0800

    Merge tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "Again we have a sizable (but not huge) cleanup branch with a net delta
      of about -3k lines.
    
      Main contents here is:
    
       - A bunch of development/cleanup of a few PXA boards
       - Removal of bockw platforms on shmobile, since the platform has now
         gone completely multiplatform.  Whee!
       - move of the 32kHz timer on OMAP to a proper timesource
       - Misc cleanup of older OMAP material (incl removal of one board
         file)
       - Switch over to new common PWM lookup support for several platforms
    
      There's also a handful of other cleanups across the tree, but the
      above are the major pieces"
    
    * tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (103 commits)
      ARM: OMAP3: hwmod data: Remove legacy mailbox data and addrs
      ARM: DRA7: hwmod data: Remove spinlock hwmod addrs
      ARM: OMAP4: hwmod data: Remove spinlock hwmod addrs
      ARM: DRA7/AM335x/AM437x: hwmod: Remove gpmc address space from hwmod data
      ARM: Remove __ref on hotplug cpu die path
      ARM: Remove open-coded version of IRQCHIP_DECLARE
      arm: omap2: board-generic: use omap4_local_timer_init for AM437x
      ARM: DRA7/AM335x/AM437x: hwmod: Remove elm address space from hwmod data
      ARM: OMAP: Remove duplicated operand in OR operation
      clocksource: ti-32k: make it depend on GENERIC_CLOCKSOURCE
      ARM: pxa: remove incorrect __init annotation on pxa27x_set_pwrmode
      ARM: pxa: raumfeld: make some variables static
      ARM: OMAP: Change all cpu_is_* occurences to soc_is_* for id.c
      ARM: OMAP2+: Rename cpu_is macros to soc_is
      arm: omap2: timer: limit hwmod usage to non-DT boots
      arm: omap2+: select 32k clocksource driver
      clocksource: add TI 32.768 Hz counter driver
      arm: omap2: timer: rename omap_sync32k_timer_init()
      arm: omap2: timer: always call clocksource_of_init() when DT
      arm: omap2: timer: move realtime_counter_init() around
      ...

commit bf4c94490aa4491cca758d633c0e641a4419c920
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 15:10:10 2015 -0500

    arm: omap2: timer: limit hwmod usage to non-DT boots
    
    now that we have a working 32k clocksource driver,
    we can limit HWMOD usage to non-DT boots and rely
    on clocksource_of_init() every time we boot
    with DT.
    
    While at that, also make sure that we don't disable
    the 32-counter device so it gets probed by its driver.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index d024b2bb5c4c..05c17eb2f2d9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -183,7 +183,8 @@ static struct device_node * __init omap_get_timer_dt(const struct of_device_id *
 				  of_get_property(np, "ti,timer-secure", NULL)))
 			continue;
 
-		of_add_property(np, &device_disabled);
+		if (!of_device_is_compatible(np, "ti,omap-counter32k"))
+			of_add_property(np, &device_disabled);
 		return np;
 	}
 
@@ -394,7 +395,6 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 	int ret;
 	struct device_node *np = NULL;
 	struct omap_hwmod *oh;
-	void __iomem *vbase;
 	const char *oh_name = "counter_32k";
 
 	/*
@@ -420,18 +420,6 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 
 	omap_hwmod_setup_one(oh_name);
 
-	if (np) {
-		vbase = of_iomap(np, 0);
-		of_node_put(np);
-	} else {
-		vbase = omap_hwmod_get_mpu_rt_va(oh);
-	}
-
-	if (!vbase) {
-		pr_warn("%s: failed to get counter_32k resource\n", __func__);
-		return -ENXIO;
-	}
-
 	ret = omap_hwmod_enable(oh);
 	if (ret) {
 		pr_warn("%s: failed to enable counter_32k module (%d)\n",
@@ -439,13 +427,18 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 		return ret;
 	}
 
-	ret = omap_init_clocksource_32k(vbase);
-	if (ret) {
-		pr_warn("%s: failed to initialize counter_32k as a clocksource (%d)\n",
-							__func__, ret);
-		omap_hwmod_idle(oh);
-	}
+	if (!of_have_populated_dt()) {
+		void __iomem *vbase;
 
+		vbase = omap_hwmod_get_mpu_rt_va(oh);
+
+		ret = omap_init_clocksource_32k(vbase);
+		if (ret) {
+			pr_warn("%s: failed to initialize counter_32k as a clocksource (%d)\n",
+					__func__, ret);
+			omap_hwmod_idle(oh);
+		}
+	}
 	return ret;
 }
 

commit 6f82e25d2e434a70cde5ad135fa00099e8106a76
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 13:26:45 2015 -0500

    arm: omap2: timer: rename omap_sync32k_timer_init()
    
    this function is not only about the 32k sync
    timer, it's OMAP's generic init_time implementation.
    
    Let's rename it to make that detail easier to
    notice.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 851f3ad9e970..d024b2bb5c4c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -492,7 +492,7 @@ static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src
 		omap2_sync32k_clocksource_init();
 }
 
-void __init omap_sync32k_timer_init(void)
+void __init omap_init_time(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL, false);

commit 9c46ffcd521474056629aea580a092559f721b32
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 13:15:02 2015 -0500

    arm: omap2: timer: always call clocksource_of_init() when DT
    
    If booting with DT, let's make sure to always
    call clocksource_of_init() as this will make
    it easier to move timer code to drivers/clocksource
    in the future.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 8f2c75911179..851f3ad9e970 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -496,6 +496,9 @@ void __init omap_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL, false);
+
+	if (of_have_populated_dt())
+		clocksource_of_init();
 }
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)

commit 3afbb9afe2c41d552a04f07aa84867e4ba8d5b76
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 13:12:55 2015 -0500

    arm: omap2: timer: move realtime_counter_init() around
    
    no functional changes, just moving that function
    closer to its calling location.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index ebebe1bd7237..8f2c75911179 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -476,7 +476,61 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 			clocksource_gpt.name, clksrc.rate);
 }
 
-#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
+static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
+		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
+		const char *clksrc_prop, bool gptimer)
+{
+	omap_clk_init();
+	omap_dmtimer_init();
+	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
+
+	/* Enable the use of clocksource="gp_timer" kernel parameter */
+	if (use_gptimer_clksrc || gptimer)
+		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
+						clksrc_prop);
+	else
+		omap2_sync32k_clocksource_init();
+}
+
+void __init omap_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
+			2, "timer_sys_ck", NULL, false);
+}
+
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
+void __init omap3_secure_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
+			2, "timer_sys_ck", NULL, false);
+}
+#endif /* CONFIG_ARCH_OMAP3 */
+
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
+void __init omap3_gptimer_timer_init(void)
+{
+	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
+			1, "timer_sys_ck", "ti,timer-alwon", true);
+}
+#endif
+
+#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) ||		\
+	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
+static void __init omap4_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
+			2, "sys_clkin_ck", NULL, false);
+}
+
+void __init omap4_local_timer_init(void)
+{
+	omap4_sync32k_timer_init();
+	clocksource_of_init();
+}
+#endif
+
+#if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
+
 /*
  * The realtime counter also called master counter, is a free-running
  * counter, which is related to real time. It produces the count used
@@ -488,6 +542,7 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
  */
 static void __init realtime_counter_init(void)
 {
+#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 	void __iomem *base;
 	static struct clk *sys_clk;
 	unsigned long rate;
@@ -586,66 +641,9 @@ static void __init realtime_counter_init(void)
 	set_cntfreq();
 
 	iounmap(base);
-}
-#else
-static inline void __init realtime_counter_init(void)
-{}
-#endif
-
-static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
-		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
-		const char *clksrc_prop, bool gptimer)
-{
-	omap_clk_init();
-	omap_dmtimer_init();
-	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
-
-	/* Enable the use of clocksource="gp_timer" kernel parameter */
-	if (use_gptimer_clksrc || gptimer)
-		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
-						clksrc_prop);
-	else
-		omap2_sync32k_clocksource_init();
-}
-
-void __init omap_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck", NULL, false);
-}
-
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
-void __init omap3_secure_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
-			2, "timer_sys_ck", NULL, false);
-}
-#endif /* CONFIG_ARCH_OMAP3 */
-
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
-void __init omap3_gptimer_timer_init(void)
-{
-	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
-			1, "timer_sys_ck", "ti,timer-alwon", true);
-}
 #endif
-
-#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
-	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
-static void __init omap4_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "sys_clkin_ck", NULL, false);
 }
 
-void __init omap4_local_timer_init(void)
-{
-	omap4_sync32k_timer_init();
-	clocksource_of_init();
-}
-#endif
-
-#if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
 void __init omap5_realtime_timer_init(void)
 {
 	omap4_sync32k_timer_init();

commit c7cb14a58e6dc2a2eba3ed98e484cd8d7544d51d
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 12:15:50 2015 -0500

    arm: omap2: timer: provide generic sync32k_timer_init function
    
    instead of constantly defining a small wrapper
    around __omap_sync32k_timer_init(), let's define
    a generic one which can be used by all OMAPs.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 976ff9fa3594..ebebe1bd7237 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -608,21 +608,13 @@ static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src
 		omap2_sync32k_clocksource_init();
 }
 
-#ifdef CONFIG_ARCH_OMAP2
-void __init omap2_sync32k_timer_init(void)
+void __init omap_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL, false);
 }
-#endif /* CONFIG_ARCH_OMAP2 */
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
-void __init omap3_sync32k_timer_init(void)
-{
-	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck", NULL, false);
-}
-
 void __init omap3_secure_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",

commit a5f72ebaead454f95b8e6f353684681640b29ee3
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 11:44:47 2015 -0500

    arm: omap2: timer: remove __omap_gptimer_init()
    
    __omap_sync32k_timer_init(), now takes the clock
    source as a parameter. This means we no longer need
    __omap_gptimer_init().
    
    Note that __omap_sync32k_timer_init() will be
    renamed in a follow-up patch as it's not longer 32k
    source specific.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index f53ed049d710..976ff9fa3594 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -592,16 +592,6 @@ static inline void __init realtime_counter_init(void)
 {}
 #endif
 
-static void __init __omap_gptimer_init(int clkev_nr, const char *clkev_src,
-		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
-		const char *clksrc_prop)
-{
-	omap_clk_init();
-	omap_dmtimer_init();
-	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
-	omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src, clksrc_prop);
-}
-
 static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
 		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
 		const char *clksrc_prop, bool gptimer)
@@ -643,8 +633,8 @@ void __init omap3_secure_sync32k_timer_init(void)
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
 void __init omap3_gptimer_timer_init(void)
 {
-	__omap_gptimer_init(2, "timer_sys_ck", NULL,
-		       1, "timer_sys_ck", "ti,timer-alwon");
+	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
+			1, "timer_sys_ck", "ti,timer-alwon", true);
 }
 #endif
 

commit f5409092d4dbb4aaeee18e16143adf63c7506dc5
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 11:38:48 2015 -0500

    arm: omap2: timer: add a gptimer argument to sync32k_timer_init()
    
    as it turns out, __omap_gptimer_init() and
    __omap_sync32k_timer_init() are essentially
    the same thing, but __omap_gptimer_init() wants
    to always use gptimer.
    
    Instead of forcing all those devices to pass
    a use_gptimer cmdline argument, we add a new
    function argument to __omap_sync32k_timer_init()
    in preparation to deleting __omap_gptimer_init().
    
    On a follow-up patch, we will remove uses of
    __omap_gptimer_init() and replace them with
    __omap_sync32k_timer_init() and pass the last
    argument as true.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 23e58ea6a171..f53ed049d710 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -604,14 +604,14 @@ static void __init __omap_gptimer_init(int clkev_nr, const char *clkev_src,
 
 static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
 		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
-		const char *clksrc_prop)
+		const char *clksrc_prop, bool gptimer)
 {
 	omap_clk_init();
 	omap_dmtimer_init();
 	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
 
 	/* Enable the use of clocksource="gp_timer" kernel parameter */
-	if (use_gptimer_clksrc)
+	if (use_gptimer_clksrc || gptimer)
 		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
 						clksrc_prop);
 	else
@@ -622,7 +622,7 @@ static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src
 void __init omap2_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck", NULL);
+			2, "timer_sys_ck", NULL, false);
 }
 #endif /* CONFIG_ARCH_OMAP2 */
 
@@ -630,13 +630,13 @@ void __init omap2_sync32k_timer_init(void)
 void __init omap3_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck", NULL);
+			2, "timer_sys_ck", NULL, false);
 }
 
 void __init omap3_secure_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
-			2, "timer_sys_ck", NULL);
+			2, "timer_sys_ck", NULL, false);
 }
 #endif /* CONFIG_ARCH_OMAP3 */
 
@@ -653,7 +653,7 @@ void __init omap3_gptimer_timer_init(void)
 static void __init omap4_sync32k_timer_init(void)
 {
 	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
-			       2, "sys_clkin_ck", NULL);
+			2, "sys_clkin_ck", NULL, false);
 }
 
 void __init omap4_local_timer_init(void)

commit be0ac4c374b50c9756e330104c2024263c86de49
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 29 11:34:39 2015 -0500

    arm: omap2: timer: get rid of obfuscating macros
    
    those macros just make it a lot more difficult
    to grep around and actually find similarities.
    
    In this patch, we will simply remove them and
    replace with actual functions and later commits
    will come to further clean this up.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 548d922cb107..23e58ea6a171 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -592,53 +592,69 @@ static inline void __init realtime_counter_init(void)
 {}
 #endif
 
-#define OMAP_SYS_GP_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
-			       clksrc_nr, clksrc_src, clksrc_prop)	\
-void __init omap##name##_gptimer_timer_init(void)			\
-{									\
-	omap_clk_init();					\
-	omap_dmtimer_init();						\
-	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
-	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,		\
-					clksrc_prop);			\
+static void __init __omap_gptimer_init(int clkev_nr, const char *clkev_src,
+		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
+		const char *clksrc_prop)
+{
+	omap_clk_init();
+	omap_dmtimer_init();
+	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
+	omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src, clksrc_prop);
 }
 
-#define OMAP_SYS_32K_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
-				clksrc_nr, clksrc_src, clksrc_prop)	\
-void __init omap##name##_sync32k_timer_init(void)		\
-{									\
-	omap_clk_init();					\
-	omap_dmtimer_init();						\
-	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
-	/* Enable the use of clocksource="gp_timer" kernel parameter */	\
-	if (use_gptimer_clksrc)						\
-		omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,	\
-						clksrc_prop);		\
-	else								\
-		omap2_sync32k_clocksource_init();			\
+static void __init __omap_sync32k_timer_init(int clkev_nr, const char *clkev_src,
+		const char *clkev_prop, int clksrc_nr, const char *clksrc_src,
+		const char *clksrc_prop)
+{
+	omap_clk_init();
+	omap_dmtimer_init();
+	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
+
+	/* Enable the use of clocksource="gp_timer" kernel parameter */
+	if (use_gptimer_clksrc)
+		omap2_gptimer_clocksource_init(clksrc_nr, clksrc_src,
+						clksrc_prop);
+	else
+		omap2_sync32k_clocksource_init();
 }
 
 #ifdef CONFIG_ARCH_OMAP2
-OMAP_SYS_32K_TIMER_INIT(2, 1, "timer_32k_ck", "ti,timer-alwon",
+void __init omap2_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL);
+}
 #endif /* CONFIG_ARCH_OMAP2 */
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
-OMAP_SYS_32K_TIMER_INIT(3, 1, "timer_32k_ck", "ti,timer-alwon",
+void __init omap3_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL);
-OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
+}
+
+void __init omap3_secure_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck", NULL);
+}
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
-OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
+void __init omap3_gptimer_timer_init(void)
+{
+	__omap_gptimer_init(2, "timer_sys_ck", NULL,
 		       1, "timer_sys_ck", "ti,timer-alwon");
+}
 #endif
 
 #if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
 	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
-static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
+static void __init omap4_sync32k_timer_init(void)
+{
+	__omap_sync32k_timer_init(1, "timer_32k_ck", "ti,timer-alwon",
 			       2, "sys_clkin_ck", NULL);
+}
 
 void __init omap4_local_timer_init(void)
 {

commit 0328d816deba1da154be23982ac7979ff3934302
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 28 13:25:44 2015 -0500

    arm: omap2: timer: always define omap4_local_timer_init
    
    omap4_local_timer_init() can be used by other
    platforms as is. At least AM437x wants to use
    it. Instead of making omap4-only and providing
    a stub for builds without OMAP4, we can just
    make sure that function is always available
    for all SoCs that need it.
    
    Reported-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index a55655127ef2..548d922cb107 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -630,32 +630,22 @@ OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck", NULL);
 #endif /* CONFIG_ARCH_OMAP3 */
 
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX) || \
-	defined(CONFIG_SOC_AM43XX)
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
 OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
 		       1, "timer_sys_ck", "ti,timer-alwon");
 #endif
 
 #if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
-	defined(CONFIG_SOC_DRA7XX)
+	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
 static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 			       2, "sys_clkin_ck", NULL);
-#endif
 
-#ifdef CONFIG_ARCH_OMAP4
-#ifdef CONFIG_HAVE_ARM_TWD
 void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
 	clocksource_of_init();
 }
-#else
-void __init omap4_local_timer_init(void)
-{
-	omap4_sync32k_timer_init();
-}
-#endif /* CONFIG_HAVE_ARM_TWD */
-#endif /* CONFIG_ARCH_OMAP4 */
+#endif
 
 #if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
 void __init omap5_realtime_timer_init(void)

commit 3722ed2380ad6e89eaf81fcf93f06d605e740435
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:18 2015 +0100

    clocksource: cosmetic: Drop OF 'dependency' from symbols
    
    Seeing the 'of' characters in a symbol that is being called from
    ACPI seems to freak out people. So let's do a bit of pointless
    renaming so that these folks do feel at home.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index a55655127ef2..bef41837bf7f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -647,7 +647,7 @@ static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
-	clocksource_of_init();
+	clocksource_probe();
 }
 #else
 void __init omap4_local_timer_init(void)
@@ -663,7 +663,7 @@ void __init omap5_realtime_timer_init(void)
 	omap4_sync32k_timer_init();
 	realtime_counter_init();
 
-	clocksource_of_init();
+	clocksource_probe();
 }
 #endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */
 

commit 874b300a6a0bfe97225ed1f8648fa92238e4d9e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 1 13:59:25 2015 -0700

    ARM: OMAP2+: Fix booting if no timer parent clock is available
    
    When bringing up a new SoC we needlessly prevent booting at timer
    init if timer clock_set_parent fails. This can fail if the system
    is booting on bootloader configured PLL values until the clock
    framework driver for the PLL is implemented.
    
    Let's just WARN instead, this will provide helpful information
    for anybody bringing up a new SoC what needs to be fixed.
    
    This allows to boot dm814x that's still missing the PLL driver.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index e4d8701f99f9..a55655127ef2 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -297,12 +297,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (IS_ERR(src))
 		return PTR_ERR(src);
 
-	r = clk_set_parent(timer->fclk, src);
-	if (r < 0) {
-		pr_warn("%s: %s cannot set source\n", __func__, oh->name);
-		clk_put(src);
-		return r;
-	}
+	WARN(clk_set_parent(timer->fclk, src) < 0,
+	     "Cannot set timer parent clock, no PLL clock driver?");
 
 	clk_put(src);
 

commit 50686e8a3aed2f5d295e9d2e79ff43df461c7b76
Merge: c5fc249862af 1ec6f701707e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 12:18:40 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "New or improved SoC support:
    
       - add support for Atmel's SAMA5D2 SoC
       - add support for Freescale i.MX6UL
       - improved support for TI's DM814x platform
       - misc fixes and improvements for RockChip platforms
       - Marvell MVEBU suspend/resume support
    
      A few driver changes that ideally would belong in the drivers branch
      are also here (acked by appropriate maintainers):
    
       - power key input driver for Freescale platforms (svns)
       - RTC driver updates for Freescale platforms (svns/mxc)
       - clk fixes for TI DM814/816X
    
      + a bunch of other changes for various platforms"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (83 commits)
      ARM: rockchip: pm: Fix PTR_ERR() argument
      ARM: imx: mach-imx6ul: Fix allmodconfig build
      clk: ti: fix for definition movement
      ARM: uniphier: drop v7_invalidate_l1 call at secondary entry
      memory: kill off set_irq_flags usage
      rtc: snvs: select option REGMAP_MMIO
      ARM: brcmstb: select ARCH_DMA_ADDR_T_64BIT for LPAE
      ARM: BCM: Enable ARM erratum 798181 for BRCMSTB
      ARM: OMAP2+: Fix power domain operations regression caused by 81xx
      ARM: rockchip: enable PMU_GPIOINT_WAKEUP_EN when entering shallow suspend
      ARM: rockchip: set correct stabilization thresholds in suspend
      ARM: rockchip: rename osc_switch_to_32k variable
      ARM: imx6ul: add fec MAC refrence clock and phy fixup init
      ARM: imx6ul: add fec bits to GPR syscon definition
      rtc: mxc: add support of device tree
      dt-binding: document the binding for mxc rtc
      rtc: mxc: use a second rtc clock
      ARM: davinci: cp_intc: use IRQCHIP_SKIP_SET_WAKE instead of irq_set_wake callback
      soc: mediatek: Fix SCPSYS compilation
      ARM: at91/soc: add basic support for new sama5d2 SoC
      ...

commit 97d9a3d0967f711e271ef950f1745307720c95d5
Merge: 228e5fadba3c 3b86616e3058
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 23 21:14:02 2015 -0700

    Merge tag 'for-v4.3/omap-hwmod-prcm-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v4.3/soc
    
    ARM: OMAP2+: PRCM and hwmod changes for v4.3
    
    This series adds:
    
    - I/O wakeup support for AM43xx
    - register lock and unlock support to the hwmod code (needed for the RTC
      IP blocks on some chips)
    - several fixes for sparse warnings and an unnecessary null pointer test
    - a DRA7xx clockdomain configuration workaround, to deal with some hardware
      bugs
    
    Basic build, boot, and PM tests are here:
    
    http://www.pwsan.com/omap/testlogs/hwmod-prcm-for-v4.3/20150723080012/
    
    Since I do not have an AM43xx or DRA7xx device, I can't test on those
    platforms.

commit 74364615a643f65b6de9faa4112365e4880c7047
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/omap2/timer: Migrate to new 'set-state' interface
    
    Migrate omap2 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index cac46d852da1..16b37e7196f5 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -102,38 +102,38 @@ static int omap2_gp_timer_set_next_event(unsigned long cycles,
 	return 0;
 }
 
-static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
-				    struct clock_event_device *evt)
+static int omap2_gp_timer_shutdown(struct clock_event_device *evt)
+{
+	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
+	return 0;
+}
+
+static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 {
 	u32 period;
 
 	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
 
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		period = clkev.rate / HZ;
-		period -= 1;
-		/* Looks like we need to first set the load value separately */
-		__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG,
-				      0xffffffff - period, OMAP_TIMER_POSTED);
-		__omap_dm_timer_load_start(&clkev,
-					OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
-					0xffffffff - period, OMAP_TIMER_POSTED);
-		break;
-	case CLOCK_EVT_MODE_ONESHOT:
-		break;
-	case CLOCK_EVT_MODE_UNUSED:
-	case CLOCK_EVT_MODE_SHUTDOWN:
-	case CLOCK_EVT_MODE_RESUME:
-		break;
-	}
+	period = clkev.rate / HZ;
+	period -= 1;
+	/* Looks like we need to first set the load value separately */
+	__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG, 0xffffffff - period,
+			      OMAP_TIMER_POSTED);
+	__omap_dm_timer_load_start(&clkev,
+				   OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
+				   0xffffffff - period, OMAP_TIMER_POSTED);
+	return 0;
 }
 
 static struct clock_event_device clockevent_gpt = {
-	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-	.rating		= 300,
-	.set_next_event	= omap2_gp_timer_set_next_event,
-	.set_mode	= omap2_gp_timer_set_mode,
+	.features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_FEAT_ONESHOT,
+	.rating			= 300,
+	.set_next_event		= omap2_gp_timer_set_next_event,
+	.set_state_shutdown	= omap2_gp_timer_shutdown,
+	.set_state_periodic	= omap2_gp_timer_set_periodic,
+	.set_state_oneshot	= omap2_gp_timer_shutdown,
+	.tick_resume		= omap2_gp_timer_shutdown,
 };
 
 static struct property device_disabled = {

commit d1dabab2841d546f8b946b4940fc63c15e35a739
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jun 3 15:26:20 2015 -0700

    ARM: OMAP2+: Clean up omap4_local_timer_init
    
    Inspired by a patch from Felipe Balbi <balbi@ti.com>, we can
    now get rid of most the code in omap4_local_timer_init.
    
    Omap4 is now device tree only.. And we have not properly supported
    omap4 ES1.0 revision for a really long time AFAIK.
    
    Let's just remove all that code to simplify things. This assumes
    we have arm,cortex-a9-twd-timer entry in the omap4.dtsi file, which
    we do.
    
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index cac46d852da1..c52051b6742c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -649,23 +649,10 @@ static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 
 #ifdef CONFIG_ARCH_OMAP4
 #ifdef CONFIG_HAVE_ARM_TWD
-static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
 void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
-	/* Local timers are not supprted on OMAP4430 ES1.0 */
-	if (omap_rev() != OMAP4430_REV_ES1_0) {
-		int err;
-
-		if (of_have_populated_dt()) {
-			clocksource_of_init();
-			return;
-		}
-
-		err = twd_local_timer_register(&twd_local_timer);
-		if (err)
-			pr_err("twd_local_timer_register failed %d\n", err);
-	}
+	clocksource_of_init();
 }
 #else
 void __init omap4_local_timer_init(void)

commit 9a0cb98589037c0ccb6210f5fd827445b3710c5e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Jun 30 14:00:16 2015 +0200

    ARM: OMAP2: Delete an unnecessary check
    
    The of_node_put() function tests whether its argument is NULL and then
    returns immediately if so.  Furthermore, the kerneldoc for
    of_node_put() explicitly supports passing in a NULL pointer as its
    argument.  Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    [paul@pwsan.com: dropped the omap_device.c and omap_hwmod.c changes for
     now, edited the commit message accordingly and to note the documented
     "contract"]
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index cac46d852da1..154482216624 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -208,8 +208,7 @@ static void __init omap_dmtimer_init(void)
 	/* If we are a secure device, remove any secure timer nodes */
 	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)) {
 		np = omap_get_timer_dt(omap_timer_match, "ti,timer-secure");
-		if (np)
-			of_node_put(np);
+		of_node_put(np);
 	}
 }
 

commit b0897972edfa42b4af5c3189b2b7a7fac5867828
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 11 13:18:19 2015 -0700

    ARM: OMAP2+: Remove bogus struct clk comparison for timer clock
    
    With recent changes to use determine_rate, the comparison of two
    clocks won't work without clk_is_match that does __clk_get_hw
    on the clocks first.
    
    As we've been unconditionally already calling clk_set_parent
    already because of the bogus comparison, let's just remove the
    check as suggested by Stephen Boyd <sboyd@codeaurora.org>.
    
    Cc: Michael Turquette <mturquette@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index cef67af9e9b8..cac46d852da1 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -298,14 +298,11 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (IS_ERR(src))
 		return PTR_ERR(src);
 
-	if (clk_get_parent(timer->fclk) != src) {
-		r = clk_set_parent(timer->fclk, src);
-		if (r < 0) {
-			pr_warn("%s: %s cannot set source\n", __func__,
-				oh->name);
-			clk_put(src);
-			return r;
-		}
+	r = clk_set_parent(timer->fclk, src);
+	if (r < 0) {
+		pr_warn("%s: %s cannot set source\n", __func__, oh->name);
+		clk_put(src);
+		return r;
 	}
 
 	clk_put(src);

commit 4025fa97ff39db054b47b9cdb9f3980480637668
Merge: c397f8fa4379 11fe05de8b73
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:15:46 2015 -0800

    Merge tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical fixes from Olof Johansson:
     "Here's a small collection of fixes accrued during the last release
      that weren't considered severe enough to merge during the -rc series.
    
      A few of these are around resurrecting TI81xx support that's been
      broken for quite a while, the rest are smaller fixes -- most for PXA
      but a few across the board.
    
      There are also some updates to MAINTAINERS here, in particular for
      Broadcom platforms"
    
    * tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (23 commits)
      MAINTAINERS: fix git repositories for Broadcom SoCs
      ARM: pxa: fix broken isa interrupts for zeus and viper
      ARM: DRA7: hwmod: Fix boot crash with DEBUG_LL enabled on UART3
      ARM: OMAP: DRA7: hwmod: Make gpmc software supervised as the smart idle is broken
      ARM: AM43xx: hwmod: set DSS submodule parent hwmods
      ARM: OMAP2+: hwmod: print error if wait_target_ready() failed
      MAINTAINERS: add maintainer for OMAP hwmod data
      ARM: OMAP2+: Disable omap3 PM init for ti81xx
      ARM: OMAP2+: Fix reboot for 81xx
      ARM: OMAP2+: Fix dm814 and dm816 for clocks and timer init
      ARM: OMAP2+: Fix ti81xx class type
      ARM: OMAP2+: Fix ti81xx devtype
      ARM: OMAP2+: Fix error handling for omap2_clk_enable_init_clocks
      MAINTAINERS: add a git entry for BMIPS-based BCM7xxx SoCs
      MAINTAINERS: add a git entry for BCM7xxx ARM-based SoCs
      MAINTAINERS: update Broadcom Cygnus SoC git tree
      MAINTAINERS: move BCM63xx ARM-based SoCs git tree
      hx4700: regulator: declare full constraints
      ARM: pxa: add regulator_has_full_constraints to spitz board file
      ARM: pxa: add regulator_has_full_constraints to poodle board file
      ...

commit 132754e483d55309ddd714a2c44580379e4ac55a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 14 17:37:16 2015 -0800

    ARM: OMAP2+: Fix dm814 and dm816 for clocks and timer init
    
    Fix dm814 and dm816 clocks and timer init.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4f61148ec168..376b099ba84b 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -146,6 +146,8 @@ static const struct of_device_id omap_timer_match[] __initconst = {
 	{ .compatible = "ti,omap3430-timer", },
 	{ .compatible = "ti,omap4430-timer", },
 	{ .compatible = "ti,omap5430-timer", },
+	{ .compatible = "ti,dm814-timer", },
+	{ .compatible = "ti,dm816-timer", },
 	{ .compatible = "ti,am335x-timer", },
 	{ .compatible = "ti,am335x-timer-1ms", },
 	{ }

commit afc9d590b8a150cfeaac0078ef5de6fb21a5ea6a
Author: Lennart Sorensen <lsorense@csclub.uwaterloo.ca>
Date:   Mon Jan 5 15:45:45 2015 -0800

    ARM: dra7xx: Fix counter frequency drift for AM572x errata i856
    
    Errata i856 for the AM572x (DRA7xx) points out that the 32.768KHz external
    crystal is not enabled at power up.  Instead the CPU falls back to using
    an emulation for the 32KHz clock which is SYSCLK1/610.  SYSCLK1 is usually
    20MHz on boards so far (which gives an emulated frequency of 32.786KHz),
    but can also be 19.2 or 27MHz which result in much larger drift.
    
    Since this is used to drive the master counter at 32.768KHz * 375 /
    2 = 6.144MHz, the emulated speed for 20MHz is of by 570ppm, or about 43
    seconds per day, and more than the 500ppm NTP is able to tolerate.
    
    Checking the CTRL_CORE_BOOTSTRAP register can determine if the CPU
    is using the real 32.768KHz crystal or the emulated SYSCLK1/610, and
    by known that the real counter frequency can be determined and used.
    The real speed is then SYSCLK1 / 610 * 375 / 2 or SYSCLK1 * 75 / 244.
    
    Signed-off-by: Len Sorensen <lsorense@csclub.uwaterloo.ca>
    Tested-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index fb0cb2b817a9..7d45c84c69ba 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -54,6 +54,7 @@
 
 #include "soc.h"
 #include "common.h"
+#include "control.h"
 #include "powerdomain.h"
 #include "omap-secure.h"
 
@@ -496,7 +497,8 @@ static void __init realtime_counter_init(void)
 	void __iomem *base;
 	static struct clk *sys_clk;
 	unsigned long rate;
-	unsigned int reg, num, den;
+	unsigned int reg;
+	unsigned long long num, den;
 
 	base = ioremap(REALTIME_COUNTER_BASE, SZ_32);
 	if (!base) {
@@ -511,6 +513,35 @@ static void __init realtime_counter_init(void)
 	}
 
 	rate = clk_get_rate(sys_clk);
+
+	if (soc_is_dra7xx()) {
+		/*
+		 * Errata i856 says the 32.768KHz crystal does not start at
+		 * power on, so the CPU falls back to an emulated 32KHz clock
+		 * based on sysclk / 610 instead. This causes the master counter
+		 * frequency to not be 6.144MHz but at sysclk / 610 * 375 / 2
+		 * (OR sysclk * 75 / 244)
+		 *
+		 * This affects at least the DRA7/AM572x 1.0, 1.1 revisions.
+		 * Of course any board built without a populated 32.768KHz
+		 * crystal would also need this fix even if the CPU is fixed
+		 * later.
+		 *
+		 * Either case can be detected by using the two speedselect bits
+		 * If they are not 0, then the 32.768KHz clock driving the
+		 * coarse counter that corrects the fine counter every time it
+		 * ticks is actually rate/610 rather than 32.768KHz and we
+		 * should compensate to avoid the 570ppm (at 20MHz, much worse
+		 * at other rates) too fast system time.
+		 */
+		reg = omap_ctrl_readl(DRA7_CTRL_CORE_BOOTSTRAP);
+		if (reg & DRA7_SPEEDSELECT_MASK) {
+			num = 75;
+			den = 244;
+			goto sysclk1_based;
+		}
+	}
+
 	/* Numerator/denumerator values refer TRM Realtime Counter section */
 	switch (rate) {
 	case 12000000:
@@ -545,6 +576,7 @@ static void __init realtime_counter_init(void)
 		break;
 	}
 
+sysclk1_based:
 	/* Program numerator and denumerator registers */
 	reg = readl_relaxed(base + INCREMENTER_NUMERATOR_OFFSET) &
 			NUMERATOR_DENUMERATOR_MASK;
@@ -556,7 +588,7 @@ static void __init realtime_counter_init(void)
 	reg |= den;
 	writel_relaxed(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);
 
-	arch_timer_freq = (rate / den) * num;
+	arch_timer_freq = DIV_ROUND_UP_ULL(rate * num, den);
 	set_cntfreq();
 
 	iounmap(base);

commit 572b24e6d85d98cdc552f07e9fb9870d9460d81b
Author: Lennart Sorensen <lsorense@csclub.uwaterloo.ca>
Date:   Mon Jan 5 15:45:45 2015 -0800

    ARM: omap5/dra7xx: Fix frequency typos
    
    The switch statement of the possible list of SYSCLK1 frequencies is
    missing a 0 in 4 out of the 7 frequencies.
    
    Fixes: fa6d79d27614 ("ARM: OMAP: Add initialisation for the real-time counter")
    Cc: stable@vger.kernel.org # v3.7+
    Signed-off-by: Len Sorensen <lsorense@csclub.uwaterloo.ca>
    Reviewed-by: Lokesh Vutla <lokeshvutla@ti.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4f61148ec168..fb0cb2b817a9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -513,11 +513,11 @@ static void __init realtime_counter_init(void)
 	rate = clk_get_rate(sys_clk);
 	/* Numerator/denumerator values refer TRM Realtime Counter section */
 	switch (rate) {
-	case 1200000:
+	case 12000000:
 		num = 64;
 		den = 125;
 		break;
-	case 1300000:
+	case 13000000:
 		num = 768;
 		den = 1625;
 		break;
@@ -529,11 +529,11 @@ static void __init realtime_counter_init(void)
 		num = 192;
 		den = 625;
 		break;
-	case 2600000:
+	case 26000000:
 		num = 384;
 		den = 1625;
 		break;
-	case 2700000:
+	case 27000000:
 		num = 256;
 		den = 1125;
 		break;

commit 31957609db529d401658adc2e91ef7df7ea42699
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 10 10:26:17 2014 +0200

    ARM: OMAP2+: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const function parameters and structs for OMAP2+ as const, too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 43d03fbf4c0b..4f61148ec168 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -141,7 +141,7 @@ static struct property device_disabled = {
 	.value = "disabled",
 };
 
-static struct of_device_id omap_timer_match[] __initdata = {
+static const struct of_device_id omap_timer_match[] __initconst = {
 	{ .compatible = "ti,omap2420-timer", },
 	{ .compatible = "ti,omap3430-timer", },
 	{ .compatible = "ti,omap4430-timer", },
@@ -162,7 +162,7 @@ static struct of_device_id omap_timer_match[] __initdata = {
  * the timer node in device-tree as disabled, to prevent the kernel from
  * registering this timer as a platform device and so no one else can use it.
  */
-static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
+static struct device_node * __init omap_get_timer_dt(const struct of_device_id *match,
 						     const char *property)
 {
 	struct device_node *np;
@@ -388,7 +388,7 @@ static u64 notrace dmtimer_read_sched_clock(void)
 	return 0;
 }
 
-static struct of_device_id omap_counter_match[] __initdata = {
+static const struct of_device_id omap_counter_match[] __initconst = {
 	{ .compatible = "ti,omap-counter32k", },
 	{ }
 };

commit 0a58471541cc823ef8056d23945c39fec154481c
Merge: ff933a0817f9 08d38bebb4dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 2 16:14:07 2014 -0700

    Merge tag 'cleanup-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc into next
    
    Pull ARM SoC cleanups from Olof Johansson:
     "Cleanups for 3.16.  Among these are:
    
       - a bunch of misc cleanups for Broadcom platforms, mostly
         housekeeping
       - enabling Common Clock Framework on the older s3c24xx Samsung
         chipsets
       - cleanup of the Versatile Express system controller code, moving it
         to syscon
       - power management cleanups for OMAP platforms
    
      plus a handful of other cleanups across the place"
    
    * tag 'cleanup-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (87 commits)
      ARM: kconfig: allow PCI support to be selected with ARCH_MULTIPLATFORM
      clk: samsung: fix build error
      ARM: vexpress: refine dependencies for new code
      clk: samsung: clk-s3c2410-dlck: do not use PNAME macro as it declares __initdata
      cpufreq: exynos: Fix the compile error
      ARM: S3C24XX: move debug-macro.S into the common space
      ARM: S3C24XX: use generic DEBUG_UART_PHY/_VIRT in debug macro
      ARM: S3C24XX: trim down debug uart handling
      ARM: compressed/head.S: remove s3c24xx special case
      ARM: EXYNOS: Remove unnecessary inclusion of cpu.h
      ARM: EXYNOS: Migrate Exynos specific macros from plat to mach
      ARM: EXYNOS: Remove exynos_subsys registration
      ARM: EXYNOS: Remove duplicate lines in Makefile
      ARM: EXYNOS: use v7_exit_coherency_flush macro for cache disabling
      ARM: OMAP4: PRCM: remove references to cm-regbits-44xx.h from PRCM core files
      ARM: OMAP3/4: PRM: add support of late_init call to prm_ll_ops
      ARM: OMAP3/OMAP4: PRM: add prm_features flags and add IO wakeup under it
      ARM: OMAP3/4: PRM: provide io chain reconfig function through irq setup
      ARM: OMAP2+: PRM: remove unnecessary cpu_is_XXX calls from prm_init / exit
      ARM: OMAP2+: PRCM: cleanup some header includes
      ...

commit edfaf05c2fcb853fcf35f12aeb9c340f5913337f
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:46 2014 +0300

    ARM: OMAP2+: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b62de9f9d05c..a8ec16787170 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -546,15 +546,15 @@ static void __init realtime_counter_init(void)
 	}
 
 	/* Program numerator and denumerator registers */
-	reg = __raw_readl(base + INCREMENTER_NUMERATOR_OFFSET) &
+	reg = readl_relaxed(base + INCREMENTER_NUMERATOR_OFFSET) &
 			NUMERATOR_DENUMERATOR_MASK;
 	reg |= num;
-	__raw_writel(reg, base + INCREMENTER_NUMERATOR_OFFSET);
+	writel_relaxed(reg, base + INCREMENTER_NUMERATOR_OFFSET);
 
-	reg = __raw_readl(base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET) &
+	reg = readl_relaxed(base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET) &
 			NUMERATOR_DENUMERATOR_MASK;
 	reg |= den;
-	__raw_writel(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);
+	writel_relaxed(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);
 
 	arch_timer_freq = (rate / den) * num;
 	set_cntfreq();

commit 332f19317e50bf9bb7eff16b98403ef11ee25751
Author: Oussama Ghorbel <ghorbel@pivasoftware.com>
Date:   Mon Apr 14 17:49:30 2014 +0100

    ARM: OMAP2+: free use_gptimer_clksrc variable after boot
    
    The variable use_gptimer_clksrc is only used by two __init functions,
    So we can freely free it after boot.
    
    Signed-off-by: Oussama Ghorbel <ghorbel@pivasoftware.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b62de9f9d05c..842b81f31957 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -361,7 +361,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 
 /* Clocksource code */
 static struct omap_dm_timer clksrc;
-static bool use_gptimer_clksrc;
+static bool use_gptimer_clksrc __initdata;
 
 /*
  * clocksource

commit 5b5c01359152f3ddaa1aa0e5d1141bc2b29ba2c5
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Feb 7 15:51:26 2014 +0530

    ARM: OMAP2+: AM43x: Use gptimer as clocksource
    
    The SyncTimer in AM43x is clocked using the following two sources:
    1) An inaccuarte 32k clock (CLK_32KHZ) derived from PER DPLL, causing system
       time to go slowly (~10% deviation).
    2) external 32KHz RTC clock, which may not always be available on board like
       in the case of ePOS EVM
    
    Use gptimer as clocksource instead, as is done in the case of AM335x
    (which does not have a SyncTimer). With this, system time keeping works
    accurately.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 74044aaf438b..b62de9f9d05c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -604,7 +604,8 @@ OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck", NULL);
 #endif /* CONFIG_ARCH_OMAP3 */
 
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX) || \
+	defined(CONFIG_SOC_AM43XX)
 OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
 		       1, "timer_sys_ck", "ti,timer-alwon");
 #endif

commit d30492adea3a82e7120bcf60893aaaab711f90a6
Merge: f1499382f114 fd3fdaf09f26
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 18:44:53 2014 -0800

    Merge tag 'clk-for-linus-3.14-part2' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull more clock framework changes from Mike Turquette:
     "The second half of the clock framework pull requeust for 3.14 is
      dominated by platform support for Qualcomm's MSM SoCs, DT binding
      updates for TI's OMAP-ish processors and additional support for
      Samsung chips.
    
      Additionally there are other smaller clock driver changes and several
      last minute fixes.  This pull request also includes the HiSilicon
      support that depends on the already-merged arm-soc pull request"
    
    [ Fix up stupid compile error in the source tree with evil merge  - Grumpy Linus ]
    
    * tag 'clk-for-linus-3.14-part2' of git://git.linaro.org/people/mike.turquette/linux: (49 commits)
      clk: sort Makefile
      clk: sunxi: fix overflow when setting up divided factors
      clk: Export more clk-provider functions
      dt-bindings: qcom: Fix warning with duplicate dt define
      clk: si5351: remove variant from platform_data
      clk: samsung: Remove unneeded semicolon
      clk: qcom: Fix modular build
      ARM: OMAP3: use DT clock init if DT data is available
      ARM: AM33xx: remove old clock data and link in new clock init code
      ARM: AM43xx: Enable clock init
      ARM: OMAP: DRA7: Enable clock init
      ARM: OMAP4: remove old clock data and link in new clock init code
      ARM: OMAP2+: io: use new clock init API
      ARM: OMAP2+: PRM: add support for initializing PRCM clock modules from DT
      ARM: OMAP3: hwmod: initialize clkdm from clkdm_name
      ARM: OMAP: hwmod: fix an incorrect clk type cast with _get_clkdm
      ARM: OMAP2+: clock: use driver API instead of direct memory read/write
      ARM: OMAP2+: clock: add support for indexed memmaps
      ARM: dts: am43xx clock data
      ARM: dts: AM35xx: use DT clock data
      ...

commit cfa9667d4ac9da8b3ba2269f934ecd69ae504d39
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Oct 22 11:53:02 2013 +0300

    ARM: OMAP2+: io: use new clock init API
    
    clk_init is now separated to a common function which gets called for all
    SoC:s, which initializes the DT clocks and calls the SoC specific clock init.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 3ca81e0ada5e..60e5fc93b114 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -570,8 +570,7 @@ static inline void __init realtime_counter_init(void)
 			       clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_gptimer_timer_init(void)			\
 {									\
-	if (omap_clk_init)						\
-		omap_clk_init();					\
+	omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,		\
@@ -582,8 +581,7 @@ void __init omap##name##_gptimer_timer_init(void)			\
 				clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_sync32k_timer_init(void)		\
 {									\
-	if (omap_clk_init)						\
-		omap_clk_init();					\
+	omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	/* Enable the use of clocksource="gp_timer" kernel parameter */	\

commit f99ba47ccc9f47fbf6ae17e5817d14cc8326d1cc
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 15 15:26:18 2013 -0800

    ARM: OMAP2+: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Santosh Shilimkar<santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 3ca81e0ada5e..ec084d158f64 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -379,7 +379,7 @@ static struct clocksource clocksource_gpt = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
-static u32 notrace dmtimer_read_sched_clock(void)
+static u64 notrace dmtimer_read_sched_clock(void)
 {
 	if (clksrc.reserved)
 		return __omap_dm_timer_read_counter(&clksrc,
@@ -471,7 +471,7 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 	__omap_dm_timer_load_start(&clksrc,
 				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0,
 				   OMAP_TIMER_NONPOSTED);
-	setup_sched_clock(dmtimer_read_sched_clock, 32, clksrc.rate);
+	sched_clock_register(dmtimer_read_sched_clock, 32, clksrc.rate);
 
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
 		pr_err("Could not register clocksource %s\n",

commit aac59e3efce3dca787b11e34726001603ce3d161
Merge: 21604cdcdcf9 005ff5fb077e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 11 16:49:45 2013 +0900

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New and updated SoC support.  Among the things new for this release
      are:
    
       - More support for the AM33xx platforms from TI
       - Tegra 124 support, and some updates to older tegra families as well
       - imx cleanups and updates across the board
       - A rename of Broadcom's Mobile platforms which were introduced as
         ARCH_BCM, and turned out to be too broad a name.  New name is
         ARCH_BCM_MOBILE.
       - A whole bunch of updates and fixes for integrator, making the
         platform code more modern and switches over to DT-only booting.
       - Support for two new Renesas shmobile chipsets.  Next up for them is
         more work on consolidation instead of introduction of new
         non-multiplatform SoCs, we're all looking forward to that!
       - Misc cleanups for older Samsung platforms, some Allwinner updates,
         etc"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (159 commits)
      ARM: bcm281xx: Add ARCH_BCM_MOBILE to bcm config
      ARM: bcm_defconfig: Run "make savedefconfig"
      ARM: bcm281xx: Add ARCH Timers to config
      rename ARCH_BCM to ARCH_BCM_MOBILE (mach-bcm)
      ARM: vexpress: Enable platform-specific options in defconfig
      ARM: vexpress: Make defconfig work again
      ARM: sunxi: remove .init_time hooks
      ARM: imx: enable suspend for imx6sl
      ARM: imx: ensure dsm_request signal is not asserted when setting LPM
      ARM: imx6q: call WB and RBC configuration from imx6q_pm_enter()
      ARM: imx6q: move low-power code out of clock driver
      ARM: imx: drop extern with function prototypes in common.h
      ARM: imx: reset core along with enable/disable operation
      ARM: imx: do not return from imx_cpu_die() call
      ARM: imx_v6_v7_defconfig: Select CONFIG_PROVE_LOCKING
      ARM: imx_v6_v7_defconfig: Enable LEDS_GPIO related options
      ARM: mxs_defconfig: Turn off CONFIG_DEBUG_GPIO
      ARM: imx: replace imx6q_restart() with mxc_restart()
      ARM: mach-imx: mm-imx5: Retrieve iomuxc base address from dt
      ARM: mach-imx: mm-imx5: Retrieve tzic base address from dt
      ...

commit beb5bfe424fdc15be6cf9a56e182192c1a7c7982
Merge: 05ad391dbc2b 462fb38f3d2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 11 16:35:29 2013 +0900

    Merge tag 'fixes-nc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC low-priority fixes from Olof Johansson:
     "A set of fixes for various platforms that weren't considered bad
      enough to include in 3.12 (nor -stable).  Mostly simple typo fixes,
      etc"
    
    * tag 'fixes-nc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: OMAP2+: irq, AM33XX add missing register check
      ARM: OMAP2+: wakeupgen: AM43x adaptation
      ARM: OMAP1: Fix a bunch of GPIO related section warnings after initdata got corrected
      ARM: dts: fix PL330 MDMA1 address in DT for Universal C210 board
      ARM: dts: Work around lack of cpufreq regulator lookup for exynos4210-origen and trats boards
      ARM: dts: Fix typo earlyprintk in exynos5440-sd5v1 and ssdk5440 boards
      ARM: dts: Correct typo in use of samsung,pin-drv for exynos5250
      ARM: rockchip: remove obsolete rockchip,config properties
      ARM: rockchip: fix wrong use of non-existent CONFIG_LOCAL_TIMERS
      ARM: mach-omap1: Fix omap1510_fpga_init_irq() implicit declarations.
      ARM: OMAP1: fix incorrect placement of __initdata tag
      ARM: OMAP: remove deprecated IRQF_DISABLED
      ARM: OMAP2+: throw the die id into the entropy pool

commit d5da94b88efebc375bfcbab6bb0e59a6e8a6571e
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 11 17:28:04 2013 -0700

    ARM: OMAP2+: Fix build error for realtime counter init if not enabled
    
    Otherwise we can get an error with some configs:
    
    arch/arm/mach-omap2/timer.c:73: undefined reference to `omap_smc1'
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 87259dc82aa2..d59b51f07cf2 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -66,12 +66,15 @@
 
 static struct omap_dm_timer clkev;
 static struct clock_event_device clockevent_gpt;
+
+#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
 
 void set_cntfreq(void)
 {
 	omap_smc1(OMAP5_DRA7_MON_SET_CNTFRQ_INDEX, arch_timer_freq);
 }
+#endif
 
 static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 {

commit 5523e4092ee4f2ef58d00c78365c8bddf730c900
Author: R Sricharan <r.sricharan@ti.com>
Date:   Thu Oct 10 13:13:48 2013 +0530

    ARM: OMAP5/DRA7: realtime_counter: Configure CNTFRQ register
    
    The realtime counter called master counter, produces the count
    used by the private timer peripherals in the MPU_CLUSTER. The
    CNTFRQ per cpu register is used to denote the frequency of the counter.
    Currently the frequency value is passed from the
    DT file, but this is not scalable when we have other non-DT guest
    OS. This register must be set to the right value by the
    secure rom code. Setting this register helps in propagating the right
    frequency value across OSes.
    
    More discussions and the reason for adding this in a non-DT
    way can be seen from below.
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg93832.html
    
    So configuring this secure register for all the cpus here.
    
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index d0f80c020423..87259dc82aa2 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -55,6 +55,7 @@
 #include "soc.h"
 #include "common.h"
 #include "powerdomain.h"
+#include "omap-secure.h"
 
 #define REALTIME_COUNTER_BASE				0x48243200
 #define INCREMENTER_NUMERATOR_OFFSET			0x10
@@ -65,6 +66,12 @@
 
 static struct omap_dm_timer clkev;
 static struct clock_event_device clockevent_gpt;
+static unsigned long arch_timer_freq;
+
+void set_cntfreq(void)
+{
+	omap_smc1(OMAP5_DRA7_MON_SET_CNTFRQ_INDEX, arch_timer_freq);
+}
 
 static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 {
@@ -546,6 +553,9 @@ static void __init realtime_counter_init(void)
 	reg |= den;
 	__raw_writel(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);
 
+	arch_timer_freq = (rate / den) * num;
+	set_cntfreq();
+
 	iounmap(base);
 }
 #else

commit 38a1981ce31dc4c527cbc0137f638543261b471a
Author: Sricharan R <r.sricharan@ti.com>
Date:   Wed Sep 18 16:50:11 2013 +0530

    ARM: OMAP2+: DRA7: realtime_counter: Add ratio registers for 20MHZ sys-clk frequency
    
    The real time counter also called master counter, is a free-running
    counter. It produces the count used by the CPU local timer peripherals
    in the MPU cluster. The timer counts at a rate of 6.144 MHz.
    
    The ratio registers are missing for a sys-clk of 20MHZ which is used
    by DRA7 socs. So because of this, the counter was getting wrongly
    programmed for a sys-clk of 38.4Mhz(default). So adding the ratio
    registers for 20MHZ sys-clk.
    
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index fa74a0625da1..d0f80c020423 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -515,6 +515,10 @@ static void __init realtime_counter_init(void)
 		num = 8;
 		den = 25;
 		break;
+	case 20000000:
+		num = 192;
+		den = 625;
+		break;
 	case 2600000:
 		num = 384;
 		den = 1625;

commit 0b8214fe186746d32d8ca5522b736d5b59fd5d40
Author: Simon Barth <simon.pe.barth@gmail.com>
Date:   Tue Oct 8 10:50:33 2013 +0200

    ARM: mach-omap2: board-generic: fix undefined symbol
    
    Since dra7 reuses the  function 'omap5_realtime_timer_init' in
    arch/arm/mach-omap2/board-generic.c as timer init function, it has to be
    built for this SoC as well.
    
    Signed-off-by: Simon Barth <Simon.Pe.Barth@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index fa74a0625da1..ead48fa5715e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -628,7 +628,7 @@ void __init omap4_local_timer_init(void)
 #endif /* CONFIG_HAVE_ARM_TWD */
 #endif /* CONFIG_ARCH_OMAP4 */
 
-#ifdef CONFIG_SOC_OMAP5
+#if defined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX)
 void __init omap5_realtime_timer_init(void)
 {
 	omap4_sync32k_timer_init();
@@ -636,7 +636,7 @@ void __init omap5_realtime_timer_init(void)
 
 	clocksource_of_init();
 }
-#endif /* CONFIG_SOC_OMAP5 */
+#endif /* CONFIG_SOC_OMAP5 || CONFIG_SOC_DRA7XX */
 
 /**
  * omap_timer_init - build and register timer device with an

commit fe806d04d0ed02f87549d2a1a2372e703220b376
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Sat Sep 7 09:19:25 2013 +0200

    ARM: OMAP: remove deprecated IRQF_DISABLED
    
    This patch proposes to remove the IRQF_DISABLED flag from OMAP code
    It's a NOOP since 2.6.35, and will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index fa74a0625da1..038d384ac228 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -78,7 +78,7 @@ static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction omap2_gp_timer_irq = {
 	.name		= "gp_timer",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= omap2_gp_timer_interrupt,
 };
 

commit b4b50fd78b1e31989940dfc647e64453d0f7176a
Merge: dccfd1e439c1 f97c43bbdf8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:30:06 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "This branch contains mostly additions and changes to platform
      enablement and SoC-level drivers.  Since there's sometimes a
      dependency on device-tree changes, there's also a fair amount of
      those in this branch.
    
      Pieces worth mentioning are:
    
       - Mbus driver for Marvell platforms, allowing kernel configuration
         and resource allocation of on-chip peripherals.
       - Enablement of the mbus infrastructure from Marvell PCI-e drivers.
       - Preparation of MSI support for Marvell platforms.
       - Addition of new PCI-e host controller driver for Tegra platforms
       - Some churn caused by sharing of macro names between i.MX 6Q and 6DL
         platforms in the device tree sources and header files.
       - Various suspend/PM updates for Tegra, including LP1 support.
       - Versatile Express support for MCPM, part of big little support.
       - Allwinner platform support for A20 and A31 SoCs (dual and quad
         Cortex-A7)
       - OMAP2+ support for DRA7, a new Cortex-A15-based SoC.
    
      The code that touches other architectures are patches moving MSI
      arch-specific functions over to weak symbols and removal of
      ARCH_SUPPORTS_MSI, acked by PCI maintainers"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (266 commits)
      tegra-cpuidle: provide stub when !CONFIG_CPU_IDLE
      PCI: tegra: replace devm_request_and_ioremap by devm_ioremap_resource
      ARM: tegra: Drop ARCH_SUPPORTS_MSI and sort list
      ARM: dts: vf610-twr: enable i2c0 device
      ARM: dts: i.MX51: Add one more I2C2 pinmux entry
      ARM: dts: i.MX51: Move pins configuration under "iomuxc" label
      ARM: dtsi: imx6qdl-sabresd: Add USB OTG vbus pin to pinctrl_hog
      ARM: dtsi: imx6qdl-sabresd: Add USB host 1 VBUS regulator
      ARM: dts: imx27-phytec-phycore-som: Enable AUDMUX
      ARM: dts: i.MX27: Disable AUDMUX in the template
      ARM: dts: wandboard: Add support for SDIO bcm4329
      ARM: i.MX5 clocks: Remove optional clock setup (CKIH1) from i.MX51 template
      ARM: dts: imx53-qsb: Make USBH1 functional
      ARM i.MX6Q: dts: Enable I2C1 with EEPROM and PMIC on Phytec phyFLEX-i.MX6 Ouad module
      ARM i.MX6Q: dts: Enable SPI NOR flash on Phytec phyFLEX-i.MX6 Ouad module
      ARM: dts: imx6qdl-sabresd: Add touchscreen support
      ARM: imx: add ocram clock for imx53
      ARM: dts: imx: ocram size is different between imx6q and imx6dl
      ARM: dts: imx27-phytec-phycore-som: Fix regulator settings
      ARM: dts: i.MX27: Remove clock name from CPU node
      ...

commit 8e73e367f7dc50f1d1bc22a63e5764bb4eea9b48
Merge: d2f3e9eb7c9e 7323f219533e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:21:16 2013 -0700

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "This branch contains code cleanups, moves and removals for 3.12.
    
      There's a large number of various cleanups, and a nice net removal of
      13500 lines of code.
    
      Highlights worth mentioning are:
    
       - A series of patches from Stephen Boyd removing the ARM local timer
         API.
       - Move of Qualcomm MSM IOMMU code to drivers/iommu.
       - Samsung PWM driver cleanups from Tomasz Figa, removing legacy PWM
         driver and switching over to the drivers/pwm one.
       - Removal of some unusued auto-generated headers for OMAP2+ (PRM/CM).
    
      There's also a move of a header file out of include/linux/i2c/ to
      platform_data, where it really belongs.  It touches mostly ARM
      platform code for include changes so we took it through our tree"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (83 commits)
      ARM: OMAP2+: Add back the define for AM33XX_RST_GLOBAL_WARM_SW_MASK
      gpio: (gpio-pca953x) move header to linux/platform_data/
      arm: zynq: hotplug: Remove unreachable code
      ARM: SAMSUNG: Remove unnecessary exynos4_default_sdhci*()
      tegra: simplify use of devm_ioremap_resource
      ARM: SAMSUNG: Remove plat/regs-timer.h header
      ARM: SAMSUNG: Remove remaining uses of plat/regs-timer.h header
      ARM: SAMSUNG: Remove pwm-clock infrastructure
      ARM: SAMSUNG: Remove old PWM timer platform devices
      pwm: Remove superseded pwm-samsung-legacy driver
      ARM: SAMSUNG: Modify board files to use new PWM platform device
      ARM: SAMSUNG: Rework private data handling in dev-backlight
      pwm: Add new pwm-samsung driver
      ARM: mach-mvebu: remove redundant DT parsing and validation
      ARM: msm: Only compile io.c on platforms that use it
      iommu/msm: Move mach includes to iommu directory
      ARM: msm: Remove devices-iommu.c
      ARM: msm: Move mach/board.h contents to common.h
      ARM: msm: Migrate msm_timer to CLOCKSOURCE_OF_DECLARE
      ARM: msm: Remove TMR and TMR0 static mappings
      ...

commit 42c604ba7c1cbe0be005d473262b91824e920682
Author: Chen Baozi <baozich@gmail.com>
Date:   Wed Aug 7 22:05:21 2013 +0800

    ARM: OMAP2+: fix wrong address when loading PRM_FRAC_INCREMENTOR_DENUMERATOR_RELOAD
    
    The denominator should be load from INCREMENTOR_DENUMERATOR_RELOAD_OFFSET
    rather than INCREMENTER_NUMERATOR_OFFSET.
    
    This is more likely a typo, since INCREMENTER_DENUMERATOR_RELOAD[23:17] is
    reserved. It seems that it won't make much trouble without this fix, because
    the useful [11:0] bits are mask and set the right value. Anyway, reading
    from a right address is better choice.
    
    Signed-off-by: Chen Baozi <baozich@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b37e1fcbad56..9265e031fa2f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -537,7 +537,7 @@ static void __init realtime_counter_init(void)
 	reg |= num;
 	__raw_writel(reg, base + INCREMENTER_NUMERATOR_OFFSET);
 
-	reg = __raw_readl(base + INCREMENTER_NUMERATOR_OFFSET) &
+	reg = __raw_readl(base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET) &
 			NUMERATOR_DENUMERATOR_MASK;
 	reg |= den;
 	__raw_writel(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);

commit f18153f984bef7ab551701f2bae74078c0ded27c
Author: R Sricharan <r.sricharan@ti.com>
Date:   Thu Feb 7 13:25:39 2013 +0530

    ARM: DRA7: Resue the clocksource, clockevent support
    
    All of OMAP5 timer support for clocksource and clockevent is completely
    reused across DRA7.
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b37e1fcbad56..1e77f11c5f51 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -594,7 +594,8 @@ OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
 		       1, "timer_sys_ck", "ti,timer-alwon");
 #endif
 
-#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5)
+#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
+	defined(CONFIG_SOC_DRA7XX)
 static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 			       2, "sys_clkin_ck", NULL);
 #endif

commit 18060f3541cf020d63340bf4c1f9fb82427a7a2a
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Aug 1 13:03:03 2013 -0700

    ARM: OMAP2+: Fix fallout from localtimer divorce and SMP=n
    
    A recent patch ef3160c (ARM: OMAP2+: Divorce from local timer API,
    2013-03-04) broke the omap build when SMP=n because the TWD functions
    are only compiled on SMP=y builds. Stub out the TWD calls when the TWD
    isn't built in to to keep everything building.
    
    arch/arm/mach-omap2/built-in.o: In function `omap4_local_timer_init':
    dss-common.c:(.init.text+0x1d90): undefined reference to `twd_local_timer_register'
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 8e99ca368e07..5a9ee0b48b62 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -600,6 +600,7 @@ static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
+#ifdef CONFIG_HAVE_ARM_TWD
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
 void __init omap4_local_timer_init(void)
 {
@@ -618,6 +619,12 @@ void __init omap4_local_timer_init(void)
 			pr_err("twd_local_timer_register failed %d\n", err);
 	}
 }
+#else
+void __init omap4_local_timer_init(void)
+{
+	omap4_sync32k_timer_init();
+}
+#endif /* CONFIG_HAVE_ARM_TWD */
 #endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5

commit 47dcd3563e45fc5a59bf7f3326ef56087be8bebe
Merge: 3b2f64d00c46 060fd3043e5e
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Jul 23 14:51:34 2013 -0700

    Merge tag 'remove-local-timers' of git://git.kernel.org/pub/scm/linux/kernel/git/davidb/linux-msm into next/cleanup
    
    From Stephen Boyd:
    
    Now that we have a generic arch hook for broadcast we can remove the
    local timer API entirely. Doing so will reduce code in ARM core, reduce
    the architecture dependencies of our timer drivers, and simplify the code
    because we no longer go through an architecture layer that is essentially
    a hotplug notifier.
    
    * tag 'remove-local-timers' of git://git.kernel.org/pub/scm/linux/kernel/git/davidb/linux-msm:
      ARM: smp: Remove local timer API
      clocksource: time-armada-370-xp: Divorce from local timer API
      clocksource: time-armada-370-xp: Fix sparse warning
      ARM: msm: Divorce msm_timer from local timer API
      ARM: PRIMA2: Divorce timer-marco from local timer API
      ARM: EXYNOS4: Divorce mct from local timer API
      ARM: OMAP2+: Divorce from local timer API
      ARM: smp_twd: Divorce smp_twd from local timer API
      ARM: smp: Remove duplicate dummy timer implementation
    
    Resolved a large number of conflicts due to __cpuinit cleanups, etc.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 9663398a094e3b85415e27fe6047b067f5f81f99
Merge: bfd65dd9fe42 d4e1c7ef46e9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 15:00:26 2013 -0700

    Merge tag 'fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC fixes from Olof Johansson:
     "This is our first set of fixes from arm-soc for 3.11.
       - A handful of build and warning fixes from Arnd
       - A collection of OMAP fixes
       - defconfig updates to make the default configs more useful for real
         use (and testing) out of the box on hardware
    
      And a couple of other small fixes.  Some of these have been recently
      applied but it's normally how we deal with fixes, with less bake time
      in -next needed"
    
    * tag 'fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (32 commits)
      arm: multi_v7_defconfig: Tweaks for omap and sunxi
      arm: multi_v7_defconfig: add i.MX options and NFS root
      ARM: omap2: add select of TI_PRIV_EDMA
      ARM: exynos: select PM_GENERIC_DOMAINS only when used
      ARM: ixp4xx: avoid circular header dependency
      ARM: OMAP: omap_common_late_init may be unused
      ARM: sti: move DEBUG_STI_UART into alphabetical order
      ARM: OMAP: build mach-omap code only if needed
      ARM: zynq: use DT_MACHINE_START
      ARM: omap5: omap5 has SCU and TWD
      ARM: OMAP2+: omap2plus_defconfig: Enable appended DTB support
      ARM: OMAP2+: Enable TI_EDMA in omap2plus_defconfig
      ARM: OMAP2+: omap2plus_defconfig: enable DRA752 thermal support by default
      ARM: OMAP2+: omap2plus_defconfig: enable TI bandgap driver
      ARM: OMAP2+: devices: remove duplicated include from devices.c
      ARM: OMAP3: igep0020: Set DSS pins in correct mux mode.
      ARM: OMAP2+: N900: enable N900-specific drivers even if device tree is enabled
      ARM: OMAP2+: Cocci spatch "ptr_ret.spatch"
      ARM: OMAP2+: Remove obsolete Makefile line
      ARM: OMAP5: Enable Cortex A15 errata 798181
      ...

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 37bd6ca8ab6c103603e04e320d3debeb4596e481
Author: Afzal Mohammed <afzal@ti.com>
Date:   Tue May 28 11:54:48 2013 +0530

    ARM: OMAP2+: timer: initialize before using oh_name
    
    of_property_read_string_index(...,&oh_name) in omap_dm_timer_init_one
    does not alter the value of 'oh_name' even if the relevant function
    fails and as 'oh_name' in stack may have a non-zero value, it would
    be misunderstood by timer code that DT has specified "ti,hwmod"
    property for timer. 'oh_name' in this scenario would be a junk value,
    this would result in module not being enabled by hwmod API's for
    timer, and in turn crash.
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Acked-by: Jon Hunter <jgchunter@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 3bdb0fb02028..5f148e721790 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -220,7 +220,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 					 int posted)
 {
 	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
-	const char *oh_name;
+	const char *oh_name = NULL;
 	struct device_node *np;
 	struct omap_hwmod *oh;
 	struct resource irq, mem;

commit ef3160cd2f0a400751f2cf6fd2811225fee1d5a7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Mar 4 19:24:35 2013 -0800

    ARM: OMAP2+: Divorce from local timer API
    
    Now that the TWD doesn't rely on the local timer API, OMAP can
    stop selecting it in Kconfig and relying on the config option to
    decide if it should call smp_twd functions.
    
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4c069b0cab21..3b7cabacbcf5 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -600,7 +600,6 @@ static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
-#ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
 void __init omap4_local_timer_init(void)
 {
@@ -619,12 +618,6 @@ void __init omap4_local_timer_init(void)
 			pr_err("twd_local_timer_register failed %d\n", err);
 	}
 }
-#else /* CONFIG_LOCAL_TIMERS */
-void __init omap4_local_timer_init(void)
-{
-	omap4_sync32k_timer_init();
-}
-#endif /* CONFIG_LOCAL_TIMERS */
 #endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5

commit bb256f803c9f620eb5a7d1c02e53360392cffbdd
Author: Afzal Mohammed <afzal@ti.com>
Date:   Mon May 27 20:06:53 2013 +0530

    ARM: OMAP2+: AM43x: basic dt support
    
    Describe minimal DT boot machine details for AM43x based SoC's. AM43x
    SoC's are ARM Cortex-A9 based with one core. AM43x is similar to
    AM335x w.r.t L4 PER/WKUP memory map. AM43x has a sync timer, here that
    is being used as clocksource, while 1ms dmtimer as clockevent.
    
    Signed-off-by: Ankur Kishore <a-kishore@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index f8b23b8040d9..3bdb0fb02028 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -582,7 +582,7 @@ OMAP_SYS_32K_TIMER_INIT(2, 1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL);
 #endif /* CONFIG_ARCH_OMAP2 */
 
-#ifdef CONFIG_ARCH_OMAP3
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM43XX)
 OMAP_SYS_32K_TIMER_INIT(3, 1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck", NULL);
 OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index f8b23b8040d9..4c069b0cab21 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -41,10 +41,10 @@
 #include <linux/of_irq.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/dmtimer-omap.h>
+#include <linux/sched_clock.h>
 
 #include <asm/mach/time.h>
 #include <asm/smp_twd.h>
-#include <asm/sched_clock.h>
 
 #include "omap_hwmod.h"
 #include "omap_device.h"

commit 9affd6becbfb2c3f0d04e554bb87234761b37aba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 17:59:53 2013 -0700

    arm: fix mismerge of arch/arm/mach-omap2/timer.c
    
    I badly screwed up the merge in commit 6fa52ed33bea ("Merge tag
    'drivers-for-linus' of git://git.kernel.org/pub/.../arm-soc") by
    incorrectly taking the arch/arm/mach-omap2/* data fully from the merge
    target because the 'drivers-for-linus' branch seemed to be a proper
    superset of the duplicate ARM commits.
    
    That was bogus: commit ff931c821bab ("ARM: OMAP: clocks: Delay clk inits
    atleast until slab is initialized") only existed in head, and the
    changes to arch/arm/mach-omap2/timer.c from that commit got list.
    
    Re-doing the merge more carefully, I do think this part was the only
    thing I screwed up.  Knock wood.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 05481490a508..f8b23b8040d9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -553,6 +553,8 @@ static inline void __init realtime_counter_init(void)
 			       clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_gptimer_timer_init(void)			\
 {									\
+	if (omap_clk_init)						\
+		omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,		\
@@ -563,6 +565,8 @@ void __init omap##name##_gptimer_timer_init(void)			\
 				clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_sync32k_timer_init(void)		\
 {									\
+	if (omap_clk_init)						\
+		omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	/* Enable the use of clocksource="gp_timer" kernel parameter */	\

commit 1bf25e78af317e6d5d9b5594dfeb0036e0d589d6
Merge: 38f56f33ca38 0592c2189ece
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:22:14 2013 -0700

    Merge tag 'cleanup-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC late cleanups from Arnd Bergmann:
     "These are cleanups and smaller changes that either depend on earlier
      feature branches or came in late during the development cycle.  We
      normally try to get all cleanups early, so these are the exceptions:
    
       - A follow-up on the clocksource reworks, hopefully the last time we
         need to merge clocksource subsystem changes through arm-soc.
    
         A first set of patches was part of the original 3.10 arm-soc
         cleanup series because of interdependencies with timer drivers now
         moved out of arch/arm.
    
       - Migrating the SPEAr13xx platform away from using auxdata for DMA
         channel descriptions towards using information in device tree,
         based on the earlier SPEAr multiplatform series
    
       - A few follow-ups on the Atmel SAMA5 support and other changes for
         Atmel at91 based on the larger at91 reworks.
    
       - Moving the armada irqchip implementation to drivers/irqchip
    
       - Several OMAP cleanups following up on the larger series already
         merged in 3.10."
    
    * tag 'cleanup-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (50 commits)
      ARM: OMAP4: change the device names in usb_bind_phy
      ARM: OMAP2+: Fix mismerge for timer.c between ff931c82 and da4a686a
      ARM: SPEAr: conditionalize SMP code
      ARM: arch_timer: Silence debug preempt warnings
      ARM: OMAP: remove unused variable
      serial: amba-pl011: fix !CONFIG_DMA_ENGINE case
      ata: arasan: remove the need for platform_data
      ARM: at91/sama5d34ek.dts: remove not needed compatibility string
      ARM: at91: dts: add MCI DMA support
      ARM: at91: dts: add i2c dma support
      ARM: at91: dts: set #dma-cells to the correct value
      ARM: at91: suspend both memory controllers on at91sam9263
      irqchip: armada-370-xp: slightly cleanup irq controller driver
      irqchip: armada-370-xp: move IRQ handler to avoid forward declaration
      irqchip: move IRQ driver for Armada 370/XP
      ARM: mvebu: move L2 cache initialization in init_early()
      devtree: add binding documentation for sp804
      ARM: integrator-cp: convert use CLKSRC_OF for timer init
      ARM: versatile: use OF init for sp804 timer
      ARM: versatile: add versatile dtbs to dtbs target
      ...

commit 38f56f33ca381751f9b8910f67e7a805ec0b68cb
Merge: fcba91454208 4183bef2e093
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:06:17 2013 -0700

    Merge tag 'dt-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC device tree updates (part 2) from Arnd Bergmann:
     "These are mostly new device tree bindings for existing drivers, as
      well as changes to the device tree source files to add support for
      those devices, and a couple of new boards, most notably Samsung's
      Exynos5 based Chromebook.
    
      The changes depend on earlier platform specific updates and touch the
      usual platforms: omap, exynos, tegra, mxs, mvebu and davinci."
    
    * tag 'dt-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (169 commits)
      ARM: exynos: dts: cros5250: add EC device
      ARM: dts: Add sbs-battery for exynos5250-snow
      ARM: dts: Add i2c-arbitrator bus for exynos5250-snow
      ARM: dts: add mshc controller node for Exynos4x12 SoCs
      ARM: dts: Add chip-id controller node on Exynos4/5 SoC
      ARM: EXYNOS: Create virtual I/O mapping for Chip-ID controller using device tree
      ARM: davinci: da850-evm: add SPI flash support
      ARM: davinci: da850: override SPI DT node device name
      ARM: davinci: da850: add SPI1 DT node
      spi/davinci: add DT binding documentation
      spi/davinci: no wildcards in DT compatible property
      ARM: dts: mvebu: Convert mvebu device tree files to 64 bits
      ARM: dts: mvebu: introduce internal-regs node
      ARM: dts: mvebu: Convert all the mvebu files to use the range property
      ARM: dts: mvebu: move all peripherals inside soc
      ARM: dts: mvebu: fix cpus section indentation
      ARM: davinci: da850: add EHRPWM & ECAP DT node
      ARM/dts: OMAP3: fix pinctrl-single configuration
      ARM: dts: Add OMAP3430 SDP NOR flash memory binding
      ARM: dts: Add NOR flash bindings for OMAP2420 H4
      ...

commit 442a33ebce9e02a2dd6662f16c9f2aad834d0115
Merge: a94d236dc355 f31c2f1c68af
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 6 23:43:45 2013 +0200

    Merge branch 'late/clksrc' into late/cleanup
    
    There is no reason to keep the clksrc cleanups separate from the
    other cleanups, and this resolves some merge conflicts.
    
    Conflicts:
            arch/arm/mach-spear/spear13xx.c
            drivers/irqchip/Makefile

commit 4183bef2e093a2f0aab45f2d5fed82b0e02aeacf
Merge: 662478d060a3 775c4f66fd85
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 6 23:38:00 2013 +0200

    Merge branch 'late/dt' into next/dt2
    
    This is support for the ARM Chromebook, originally scheduled
    as a "late" pull request. Since it's already late now, we
    can combine this into the existing next/dt2 branch.
    
    * late/dt:
      ARM: exynos: dts: cros5250: add EC device
      ARM: dts: Add sbs-battery for exynos5250-snow
      ARM: dts: Add i2c-arbitrator bus for exynos5250-snow
      ARM: dts: Add chip-id controller node on Exynos4/5 SoC
      ARM: EXYNOS: Create virtual I/O mapping for Chip-ID controller using device tree

commit 405f5e5ee53339cf5d5d1753f8614938b1222562
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 23 23:16:44 2013 +0200

    ARM: OMAP: remove unused variable
    
    Commit 0583fe478a7 "ARM: convert arm/arm64 arch timer to use CLKSRC_OF init"
    has left the omap5_realtime_timer_init() function with a stale variable and
    broken whitespace. This fixes both.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index d5a13dcb64b8..31109cb3f464 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -621,12 +621,10 @@ void __init omap4_local_timer_init(void)
 #ifdef CONFIG_SOC_OMAP5
 void __init omap5_realtime_timer_init(void)
 {
-	int err;
-
 	omap4_sync32k_timer_init();
 	realtime_counter_init();
 
-        clocksource_of_init();
+	clocksource_of_init();
 }
 #endif /* CONFIG_SOC_OMAP5 */
 

commit 17ada81e4ed9525cc2344aceb2ecf360142eef50
Merge: 981c44801455 105612489bf5
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Apr 19 11:37:21 2013 -0700

    Merge branch 'omap/fixes-non-critical' into late/cleanup
    
    * omap/fixes-non-critical:
      ARM: OMAP2+: fix typo "CONFIG_BRIDGE_DVFS"
      ARM: OMAP1: remove "config MACH_OMAP_HTCWIZARD"
      ARM: OMAP: dpll: enable bypass clock only when attempting dpll bypass
      ARM: OMAP2+: powerdomain: avoid testing whether an unsigned char is less than 0
      ARM: OMAP2+: hwmod: Remove unused _HWMOD_WAKEUP_ENABLED flag
      ARM: OMAP2+: am335x: Change the wdt1 func clk src to per_32k clk
      ARM: OMAP2+: AM33xx: hwmod: Add missing sysc definition to wdt1 entry
      ARM: OMAP: fix typo "CONFIG_SMC91x_MODULE"
      ARM: OMAP5: clock: No Freqsel on OMAP5 devices too
      ARM: OMAP5: Make errata i688 workaround available
      ARM: OMAP5: Update SAR memory layout for WakeupGen
      ARM: OMAP5: Update SAR RAM base address
      ARM: OMAP5: Reuse prm read_inst/write_inst
      ARM: OMAP5: prm: Allow prm init to succeed
      ARM: OMAP5: timer: Update the clocksource name as per clock data
      ARM: OMAP5: Update SOC id detection code for ES2

commit c3e0c873d0653e6e7628b5a8a9fcb3745444ca9e
Merge: 228e3023eb04 69a517b2471b
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Apr 17 10:10:01 2013 -0700

    Merge tag 'clksrc-cleanup-for-3.10-part2' of git://sources.calxeda.com/kernel/linux into late/clksrc
    
    This is the 2nd part of ARM timer clean-ups for 3.10. This series has
    the following changes:
    
    - Add sched_clock selection logic to select the highest frequency clock
    - Use full 64-bit arch timer counter for sched_clock
    - Convert arch timer, sp804 and integrator-cp timers to CLKSRC_OF and
    adapt all users to use clocksource_of_init
    
    * tag 'clksrc-cleanup-for-3.10-part2' of git://sources.calxeda.com/kernel/linux:
      devtree: add binding documentation for sp804
      ARM: integrator-cp: convert use CLKSRC_OF for timer init
      ARM: versatile: use OF init for sp804 timer
      ARM: versatile: add versatile dtbs to dtbs target
      ARM: vexpress: remove extra timer-sp control register clearing
      ARM: dts: vexpress: disable CA9 core tile sp804 timer
      ARM: vexpress: remove sp804 OF init
      ARM: highbank: use OF init for sp804 timer
      ARM: timer-sp: convert to use CLKSRC_OF init
      OF: add empty of_device_is_available for !OF
      ARM: convert arm/arm64 arch timer to use CLKSRC_OF init
      ARM: make machine_desc->init_time default to clocksource_of_init
      ARM: arch_timer: use full 64-bit counter for sched_clock
      ARM: make sched_clock just call a function pointer
      ARM: sched_clock: allow changing to higher frequency counter
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    This has a nasty set of conflicts with the exynos MCT code, which was
    moved in a separate branch, and then fixed up when merged in, but still
    conflicts a bit here. It should have been sorted out by this merge though.

commit 0583fe478a7d93be2c814b7e50d6e81c287edfe8
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Apr 10 18:27:51 2013 -0500

    ARM: convert arm/arm64 arch timer to use CLKSRC_OF init
    
    This converts arm and arm64 to use CLKSRC_OF DT based initialization for
    the arch timer. A new function arch_timer_arch_init is added to allow for
    arch specific setup.
    
    This has a side effect of enabling sched_clock on omap5 and exynos5. There
    should not be any reason not to use the arch timers for sched_clock.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4fd80257c73e..7dd6453a213e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -46,7 +46,6 @@
 #include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
 
-#include <asm/arch_timer.h>
 #include "omap_hwmod.h"
 #include "omap_device.h"
 #include <plat/counter-32k.h>
@@ -624,9 +623,7 @@ void __init omap5_realtime_timer_init(void)
 	omap5_sync32k_timer_init();
 	realtime_counter_init();
 
-	err = arch_timer_of_register();
-	if (err)
-		pr_err("%s: arch_timer_register failed %d\n", __func__, err);
+        clocksource_of_init();
 }
 #endif /* CONFIG_SOC_OMAP5 */
 

commit 4f779ad9939038821202ac5632bbb9610fbac124
Merge: 35db05bb9d88 161e89a689bb
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Apr 11 04:04:38 2013 -0700

    Merge tag 'omap-for-v3.10/dt-signed-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/dt2
    
    From Tony Lindgren:
    Device tree updates for omaps via Benoit Cousson <b-cousson@ti.com>.
    
    Note that the branch has dependencies to two other branches:
    
    - omap-devel-b-for-3.10 from Paul to get the AM33xx missing
      hwmod and thus avoid a regression with Santosh's hwmod
      cleanup including in this DT series [1]. It avoids breaking
      bisect if this series is merged before Paul's fixes.
    
    - omap-for-v3.10/usb branch to avoid nasty merge conflict in
      omap3.dtsi and omap4.dtsi due to the DTS patches contained
      in the USB branch because of a screw up by the unnamed person
      typing this signed tag based on Benoit's comments.
    
    [1] https://patchwork.kernel.org/patch/2366291/
    
    * tag 'omap-for-v3.10/dt-signed-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (69 commits)
      ARM/dts: OMAP3: fix pinctrl-single configuration
      ARM: dts: Add OMAP3430 SDP NOR flash memory binding
      ARM: dts: Add NOR flash bindings for OMAP2420 H4
      ARM: dts: Update OMAP3430 SDP NAND and ONENAND properties
      ARM: dts: OMAP2+: Identify GPIO banks that are always powered
      ARM: OMAP2+: Populate DMTIMER errata when using device-tree
      ARM: dts: OMAP2+: Update DMTIMER compatibility property
      ARM: OMAP: Add function to request timer by node
      ARM: OMAP: Force dmtimer restore if context loss is not detectable
      ARM: OMAP: Simplify dmtimer context-loss handling
      ARM: dts: AM33XX: Corrects typo in interrupt field in SPI node
      ARM: dts: OMAP4460: Add CPU OPP table
      ARM: dts: omap4-panda: move generic sections to panda-common
      ARM: dts: OMAP443x: Add CPU OPP table
      ARM: dts: OMAP3: use twl4030 vdd1 regulator for CPU
      ARM: dts: OMAP36xx: Add CPU OPP table
      ARM: dts: OMAP34xx/35xx: Add CPU OPP table
      Documentation: dt: gpio-omap: Move interrupt-controller from #interrupt-cells description
      ARM: OMAP2+: hwmod: Don't call _init_mpu_rt_base if no sysc
      ARM: OMAP2+: hwmod: extract module address space from DT blob
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 56fecc7de9cfeb804d8ff51c481154bf3f6ccb6a
Merge: 535409d9b372 105612489bf5
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Apr 11 04:02:34 2013 -0700

    Merge branch 'omap/fixes-non-critical' into next/dt2
    
    Merging in dependencies for the omap/dt branch.
    
    * omap/fixes-non-critical:
      ARM: OMAP2+: fix typo "CONFIG_BRIDGE_DVFS"
      ARM: OMAP1: remove "config MACH_OMAP_HTCWIZARD"
      ARM: OMAP: dpll: enable bypass clock only when attempting dpll bypass
      ARM: OMAP2+: powerdomain: avoid testing whether an unsigned char is less than 0
      ARM: OMAP2+: hwmod: Remove unused _HWMOD_WAKEUP_ENABLED flag
      ARM: OMAP2+: am335x: Change the wdt1 func clk src to per_32k clk
      ARM: OMAP2+: AM33xx: hwmod: Add missing sysc definition to wdt1 entry
      ARM: OMAP: fix typo "CONFIG_SMC91x_MODULE"
      ARM: OMAP5: clock: No Freqsel on OMAP5 devices too
      ARM: OMAP5: Make errata i688 workaround available
      ARM: OMAP5: Update SAR memory layout for WakeupGen
      ARM: OMAP5: Update SAR RAM base address
      ARM: OMAP5: Reuse prm read_inst/write_inst
      ARM: OMAP5: prm: Allow prm init to succeed
      ARM: OMAP5: timer: Update the clocksource name as per clock data
      ARM: OMAP5: Update SOC id detection code for ES2
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 002e1ec56d1171e2987c7ce5a865cf21a686a4bf
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Mar 19 12:38:18 2013 -0500

    ARM: dts: OMAP2+: Update DMTIMER compatibility property
    
    Update the DMTIMER compatibility property to reflect the register level
    compatibilty between devices and update the various OMAP/AM timer
    bindings with the appropriate compatibility string.
    
    By doing this we can add platform specific data applicable to specific
    timer versions to the driver. For example, errata flags can be populated
    for the timer versions that are impacted.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Benoit Cousson <benoit.cousson@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2bdd4cf17a8f..14b89afe4af7 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -143,7 +143,12 @@ static struct property device_disabled = {
 };
 
 static struct of_device_id omap_timer_match[] __initdata = {
-	{ .compatible = "ti,omap2-timer", },
+	{ .compatible = "ti,omap2420-timer", },
+	{ .compatible = "ti,omap3430-timer", },
+	{ .compatible = "ti,omap4430-timer", },
+	{ .compatible = "ti,omap5430-timer", },
+	{ .compatible = "ti,am335x-timer", },
+	{ .compatible = "ti,am335x-timer-1ms", },
 	{ }
 };
 

commit dc2d3db8137fba0f62d7517e1bea8a47f69fcbc4
Merge: 8355ae69afca 7f585bbfc54f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 8 19:30:48 2013 +0200

    Merge tag 'omap-for-v3.10/timer-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/drivers
    
    From Tony Lindgren <tony@atomide.com>:
    
    Clean-up for omap2+ timers from Jon Hunter <jon-hunter@ti.com>:
    
    This series consists mainly of clean-ups for clockevents and
    clocksource timers on OMAP2+ devices. The most significant change
    in functionality comes from the 5th patch which is changing the
    selection of the clocksource timer for OMAP3 and AM335x devices
    when gptimers are used for clocksource.
    
    Note that this series depends on 7185684 (ARM: OMAP: use
    consistent error checking) in RMK's tree and 960cba6 (ARM:
    OMAP5: timer: Update the clocksource name as per clock data)
    in omap-for-v3.10/fixes-non-critical. So this branch is based
    on a merge of 7185684 and omap-for-v3.10/fixes-non-critical
    to avoid non-trivial merge conflicts.
    
    * tag 'omap-for-v3.10/timer-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP4+: Fix sparse warning in system timers
      ARM: OMAP2+: Store ID of system timers in timer structure
      ARM: OMAP3: Update clocksource timer selection
      ARM: OMAP2+: Simplify system timers definitions
      ARM: OMAP2+: Simplify system timer clock definitions
      ARM: OMAP2+: Remove hard-coded test on timer ID
      ARM: OMAP2+: Display correct system timer name
      ARM: OMAP2+: fix typo "CONFIG_BRIDGE_DVFS"
      ARM: OMAP1: remove "config MACH_OMAP_HTCWIZARD"
      ARM: OMAP: dpll: enable bypass clock only when attempting dpll bypass
      ARM: OMAP2+: powerdomain: avoid testing whether an unsigned char is less than 0
      ARM: OMAP2+: hwmod: Remove unused _HWMOD_WAKEUP_ENABLED flag
      ARM: OMAP2+: am335x: Change the wdt1 func clk src to per_32k clk
      ARM: OMAP2+: AM33xx: hwmod: Add missing sysc definition to wdt1 entry
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 7f585bbfc54fec9dcf387fd2edb2d6f4908badf8
Merge: 43231b5be657 4615943cf3a5
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Apr 3 10:47:59 2013 -0700

    Merge branch 'omap-timer-for-v3.10' of git://github.com/jonhunter/linux into omap-for-v3.10/timer
    
    Conflicts:
            arch/arm/mach-omap2/timer.c

commit 43231b5be657fde1c4ced180d829bbd59ceef9ad
Merge: 105612489bf5 71856843fb1d
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Apr 3 10:32:47 2013 -0700

    Merge commit '7185684' into omap-for-v3.10/timer
    
    Conflicts:
            arch/arm/plat-omap/dmtimer.c
    
    Resolve merge conflict in omap_device.c as per
    Lothar Waßmann <LW@KARO-electronics.de>.

commit 4615943cf3a531bc76f589c22bd366da092b7c0f
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Feb 1 17:25:42 2013 -0600

    ARM: OMAP4+: Fix sparse warning in system timers
    
    Commit 6bb27d7 (ARM: delete struct sys_timer) changed the function
    created by the macro OMAP_SYS_32K_TIMER_INIT from static void to void.
    For OMAP4+ devices this created the following sparse warning ...
    
    arch/arm/mach-omap2/timer.c:585:1: warning: symbol
            'omap4_sync32k_timer_init' was not declared. Should it be static?
    
    The function omap4_sync32k_timer_init() is not referenced outside of the
    file timer.c and so make this function static.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5294c0832071..fd05024bbe4b 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -594,8 +594,8 @@ OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
 #endif
 
 #if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5)
-OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
-			2, "sys_clkin_ck", NULL);
+static OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
+			       2, "sys_clkin_ck", NULL);
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4

commit 8f6924dcab3a40c5972f960cd45ffccc4021db0b
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Feb 1 16:40:09 2013 -0600

    ARM: OMAP2+: Store ID of system timers in timer structure
    
    Currently, the timer ID is being passed to the function
    omap_dm_timer_init_one(). Instead of passing the ID separately, store it
    in the omap_dm_timer structure, that is also passed, and access the ID
    from this structure.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 04ac1b43fbf2..5294c0832071 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -211,7 +211,6 @@ static u32 __init omap_dm_timer_get_errata(void)
 }
 
 static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
-					 int gptimer_id,
 					 const char *fck_source,
 					 const char *property,
 					 const char **timer_name,
@@ -242,10 +241,10 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 		of_node_put(np);
 	} else {
-		if (omap_dm_timer_reserve_systimer(gptimer_id))
+		if (omap_dm_timer_reserve_systimer(timer->id))
 			return -ENODEV;
 
-		sprintf(name, "timer%d", gptimer_id);
+		sprintf(name, "timer%d", timer->id);
 		oh_name = name;
 	}
 
@@ -318,6 +317,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 {
 	int res;
 
+	clkev.id = gptimer_id;
 	clkev.errata = omap_dm_timer_get_errata();
 
 	/*
@@ -327,7 +327,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 	 */
 	__omap_dm_timer_override_errata(&clkev, OMAP_TIMER_ERRATA_I103_I767);
 
-	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source, property,
+	res = omap_dm_timer_init_one(&clkev, fck_source, property,
 				     &clockevent_gpt.name, OMAP_TIMER_POSTED);
 	BUG_ON(res);
 
@@ -453,9 +453,10 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 {
 	int res;
 
+	clksrc.id = gptimer_id;
 	clksrc.errata = omap_dm_timer_get_errata();
 
-	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, property,
+	res = omap_dm_timer_init_one(&clksrc, fck_source, property,
 				     &clocksource_gpt.name,
 				     OMAP_TIMER_NONPOSTED);
 	BUG_ON(res);

commit 2eb03937df3ebc822dab413bd69533dcd66afd48
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Mon Jan 28 17:53:57 2013 -0600

    ARM: OMAP3: Update clocksource timer selection
    
    When booting with device-tree for OMAP3 and AM335x devices and a gptimer
    is used as the clocksource (which is always the case for AM335x), a
    gptimer located in a power domain that is not always-on is selected.
    Ideally we should use a gptimer for clocksource that is located in a
    power domain that is always on (such as the wake-up domain) so that time
    can be maintained during a kernel suspend without keeping on additional
    power domains unnecessarily.
    
    In order to fix this so that we can select a gptimer located in a power
    domain that is always-on, the following changes were made ...
    1. Currently, only when selecting a gptimer to use for a clockevent
       timer, do we pass a timer property that can be used to select a
       specific gptimer. Change this so that we can pass a property when
       selecting a gptimer to use for a clocksource timer too.
    2. Currently, when selecting either a gptimer to use for a clockevent
       timer or a clocksource timer and no timer property is passed, then
       the first available timer is selected regardless of the properties
       it has. Change this so that if no properties are passed, then a timer
       that does not have additional features (such as always-on, dsp-irq,
       pwm, and secure) is selected.
    
    For OMAP3 and AM335x devices that use a gptimer for clocksource, change
    the selection of the gptimer so that by default the gptimer located in
    the always-on power domain is used for clocksource instead of
    clockevents.
    
    Please note that using a gptimer for both clocksource and clockevents
    can have a system power impact during idle. The reason being is that
    OMAP and AMxxx devices typically only have one gptimer in a power domain
    that is always-on. Therefore when the kernel is idle both the clocksource
    and clockevent timers will be active and this will keep additional power
    domains on. During kernel suspend, only the clocksource timer is active
    and therefore, it is better to use a gptimer in a power domain that is
    always-on for clocksource.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index ffb17beb5754..04ac1b43fbf2 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -161,6 +161,12 @@ static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
 		if (property && !of_get_property(np, property, NULL))
 			continue;
 
+		if (!property && (of_get_property(np, "ti,timer-alwon", NULL) ||
+				  of_get_property(np, "ti,timer-dsp", NULL) ||
+				  of_get_property(np, "ti,timer-pwm", NULL) ||
+				  of_get_property(np, "ti,timer-secure", NULL)))
+			continue;
+
 		of_add_property(np, &device_disabled);
 		return np;
 	}
@@ -442,13 +448,14 @@ static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 }
 
 static void __init omap2_gptimer_clocksource_init(int gptimer_id,
-						const char *fck_source)
+						  const char *fck_source,
+						  const char *property)
 {
 	int res;
 
 	clksrc.errata = omap_dm_timer_get_errata();
 
-	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, NULL,
+	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, property,
 				     &clocksource_gpt.name,
 				     OMAP_TIMER_NONPOSTED);
 	BUG_ON(res);
@@ -545,47 +552,49 @@ static inline void __init realtime_counter_init(void)
 #endif
 
 #define OMAP_SYS_GP_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
-			       clksrc_nr, clksrc_src)			\
+			       clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_gptimer_timer_init(void)			\
 {									\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
-	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src);	\
+	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,		\
+					clksrc_prop);			\
 }
 
 #define OMAP_SYS_32K_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
-				clksrc_nr, clksrc_src)			\
+				clksrc_nr, clksrc_src, clksrc_prop)	\
 void __init omap##name##_sync32k_timer_init(void)		\
 {									\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	/* Enable the use of clocksource="gp_timer" kernel parameter */	\
 	if (use_gptimer_clksrc)						\
-		omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src);\
+		omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src,	\
+						clksrc_prop);		\
 	else								\
 		omap2_sync32k_clocksource_init();			\
 }
 
 #ifdef CONFIG_ARCH_OMAP2
 OMAP_SYS_32K_TIMER_INIT(2, 1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck");
+			2, "timer_sys_ck", NULL);
 #endif /* CONFIG_ARCH_OMAP2 */
 
 #ifdef CONFIG_ARCH_OMAP3
 OMAP_SYS_32K_TIMER_INIT(3, 1, "timer_32k_ck", "ti,timer-alwon",
-			2, "timer_sys_ck");
+			2, "timer_sys_ck", NULL);
 OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
-			2, "timer_sys_ck");
+			2, "timer_sys_ck", NULL);
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
-OMAP_SYS_GP_TIMER_INIT(3, 1, "timer_sys_ck", "ti,timer-alwon",
-		       2, "timer_sys_ck");
+OMAP_SYS_GP_TIMER_INIT(3, 2, "timer_sys_ck", NULL,
+		       1, "timer_sys_ck", "ti,timer-alwon");
 #endif
 
 #if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5)
 OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
-			2, "sys_clkin_ck");
+			2, "sys_clkin_ck", NULL);
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4

commit 00ea4d5618e86b926163c7d080763c6560be9fe3
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Jan 11 20:23:09 2013 -0600

    ARM: OMAP2+: Simplify system timers definitions
    
    There is a lot of redundancy in the definitions for the various system
    timers for OMAP2+ devices. For example, the omap3_am33xx_gptimer_timer_init()
    function is the same as the omap3_gp_gptimer_timer_init() function and the
    function omap4_sync32k_timer_init() can be re-used for OMAP5 devices.
    Therefore, consolidate the definitions to simplify the code.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 84c46bf0c9d3..ffb17beb5754 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -576,18 +576,19 @@ OMAP_SYS_32K_TIMER_INIT(3, 1, "timer_32k_ck", "ti,timer-alwon",
 			2, "timer_sys_ck");
 OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
 			2, "timer_sys_ck");
-OMAP_SYS_GP_TIMER_INIT(3_gp, 1, "timer_sys_ck", "ti,timer-alwon",
-		       2, "timer_sys_ck");
 #endif /* CONFIG_ARCH_OMAP3 */
 
-#ifdef CONFIG_SOC_AM33XX
-OMAP_SYS_GP_TIMER_INIT(3_am33xx, 1, "timer_sys_ck", "ti,timer-alwon",
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX)
+OMAP_SYS_GP_TIMER_INIT(3, 1, "timer_sys_ck", "ti,timer-alwon",
 		       2, "timer_sys_ck");
-#endif /* CONFIG_SOC_AM33XX */
+#endif
 
-#ifdef CONFIG_ARCH_OMAP4
+#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5)
 OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
 			2, "sys_clkin_ck");
+#endif
+
+#ifdef CONFIG_ARCH_OMAP4
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
 void __init omap4_local_timer_init(void)
@@ -616,13 +617,11 @@ void __init omap4_local_timer_init(void)
 #endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5
-OMAP_SYS_32K_TIMER_INIT(5, 1, "timer_32k_ck", "ti,timer-alwon",
-			2, "sys_clkin_ck");
 void __init omap5_realtime_timer_init(void)
 {
 	int err;
 
-	omap5_sync32k_timer_init();
+	omap4_sync32k_timer_init();
 	realtime_counter_init();
 
 	err = arch_timer_of_register();

commit 7bdc83f74f9636fb40a472e1e02fcaf2cc643115
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Jan 11 19:17:38 2013 -0600

    ARM: OMAP2+: Simplify system timer clock definitions
    
    In commit c59b537 (ARM: OMAP2+: Simplify dmtimer clock aliases), new
    clock aliases for dmtimers were added to simplify the code. These clock
    aliases can also be used when configuring the system timers and allow us
    to remove the current definitions, simplifying the code.
    
    Please note that for OMAP4/5 devices (unlike OMAP2/3 devices), there is
    no clock alias for "timer_sys_ck" with NULL as the device name. Therefore
    we still need to use the alias "sys_clkin_ck" for these devices.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 760a02618178..84c46bf0c9d3 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -57,15 +57,6 @@
 #include "common.h"
 #include "powerdomain.h"
 
-/* Parent clocks, eventually these will come from the clock framework */
-
-#define OMAP2_MPU_SOURCE	"sys_ck"
-#define OMAP3_MPU_SOURCE	OMAP2_MPU_SOURCE
-#define OMAP4_MPU_SOURCE	"sys_clkin_ck"
-#define OMAP2_32K_SOURCE	"func_32k_ck"
-#define OMAP3_32K_SOURCE	"omap_32k_fck"
-#define OMAP4_32K_SOURCE	"sys_32k_ck"
-
 #define REALTIME_COUNTER_BASE				0x48243200
 #define INCREMENTER_NUMERATOR_OFFSET			0x10
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
@@ -576,27 +567,27 @@ void __init omap##name##_sync32k_timer_init(void)		\
 }
 
 #ifdef CONFIG_ARCH_OMAP2
-OMAP_SYS_32K_TIMER_INIT(2, 1, OMAP2_32K_SOURCE, "ti,timer-alwon",
-			2, OMAP2_MPU_SOURCE);
+OMAP_SYS_32K_TIMER_INIT(2, 1, "timer_32k_ck", "ti,timer-alwon",
+			2, "timer_sys_ck");
 #endif /* CONFIG_ARCH_OMAP2 */
 
 #ifdef CONFIG_ARCH_OMAP3
-OMAP_SYS_32K_TIMER_INIT(3, 1, OMAP3_32K_SOURCE, "ti,timer-alwon",
-			2, OMAP3_MPU_SOURCE);
-OMAP_SYS_32K_TIMER_INIT(3_secure, 12, OMAP3_32K_SOURCE, "ti,timer-secure",
-			2, OMAP3_MPU_SOURCE);
-OMAP_SYS_GP_TIMER_INIT(3_gp, 1, OMAP3_MPU_SOURCE, "ti,timer-alwon",
-		       2, OMAP3_MPU_SOURCE);
+OMAP_SYS_32K_TIMER_INIT(3, 1, "timer_32k_ck", "ti,timer-alwon",
+			2, "timer_sys_ck");
+OMAP_SYS_32K_TIMER_INIT(3_secure, 12, "secure_32k_fck", "ti,timer-secure",
+			2, "timer_sys_ck");
+OMAP_SYS_GP_TIMER_INIT(3_gp, 1, "timer_sys_ck", "ti,timer-alwon",
+		       2, "timer_sys_ck");
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #ifdef CONFIG_SOC_AM33XX
-OMAP_SYS_GP_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, "ti,timer-alwon",
-		       2, OMAP4_MPU_SOURCE);
+OMAP_SYS_GP_TIMER_INIT(3_am33xx, 1, "timer_sys_ck", "ti,timer-alwon",
+		       2, "timer_sys_ck");
 #endif /* CONFIG_SOC_AM33XX */
 
 #ifdef CONFIG_ARCH_OMAP4
-OMAP_SYS_32K_TIMER_INIT(4, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
-			2, OMAP4_MPU_SOURCE);
+OMAP_SYS_32K_TIMER_INIT(4, 1, "timer_32k_ck", "ti,timer-alwon",
+			2, "sys_clkin_ck");
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
 void __init omap4_local_timer_init(void)
@@ -625,8 +616,8 @@ void __init omap4_local_timer_init(void)
 #endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5
-OMAP_SYS_32K_TIMER_INIT(5, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
-			2, OMAP4_MPU_SOURCE);
+OMAP_SYS_32K_TIMER_INIT(5, 1, "timer_32k_ck", "ti,timer-alwon",
+			2, "sys_clkin_ck");
 void __init omap5_realtime_timer_init(void)
 {
 	int err;

commit a7990a1952cbaea0971272692f69f62906446fdf
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Mar 12 17:17:57 2013 -0500

    ARM: OMAP2+: Remove hard-coded test on timer ID
    
    Currently, when configuring the clock-events and clock-source timers
    for OMAP2+ devices, we check whether the timer ID is 12 before
    attempting to set the parent clock for the timer.
    
    This test was added for OMAP3 general purpose devices (no security
    features enabled) that a 12th timer available but unlike the other
    timers only has a single functional clock source. Calling
    clk_set_parent() for this 12th timer would always return an error
    because there is only one choice for a parent clock. Therefore,
    this hard-coded timer ID test was added.
    
    To avoid this timer ID test, simply check to see if the timer's current
    parent clock is the desired parent clock and only call clk_set_parent()
    if this is not the case.
    
    Also if clk_get() fails, then use PTR_ERR() to return the error code.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 7d67d21fe52c..760a02618178 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -225,6 +225,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	struct device_node *np;
 	struct omap_hwmod *oh;
 	struct resource irq, mem;
+	struct clk *src;
 	int r = 0;
 
 	if (of_have_populated_dt()) {
@@ -279,24 +280,24 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	/* After the dmtimer is using hwmod these clocks won't be needed */
 	timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
 	if (IS_ERR(timer->fclk))
-		return -ENODEV;
+		return PTR_ERR(timer->fclk);
+
+	src = clk_get(NULL, fck_source);
+	if (IS_ERR(src))
+		return PTR_ERR(src);
 
-	/* FIXME: Need to remove hard-coded test on timer ID */
-	if (gptimer_id != 12) {
-		struct clk *src;
-
-		src = clk_get(NULL, fck_source);
-		if (IS_ERR(src)) {
-			r = -EINVAL;
-		} else {
-			r = clk_set_parent(timer->fclk, src);
-			if (r < 0)
-				pr_warn("%s: %s cannot set source\n",
-					__func__, oh->name);
+	if (clk_get_parent(timer->fclk) != src) {
+		r = clk_set_parent(timer->fclk, src);
+		if (r < 0) {
+			pr_warn("%s: %s cannot set source\n", __func__,
+				oh->name);
 			clk_put(src);
+			return r;
 		}
 	}
 
+	clk_put(src);
+
 	omap_hwmod_setup_one(oh_name);
 	omap_hwmod_enable(oh);
 	__omap_dm_timer_init_regs(timer);

commit e95ea43a90c32ccb47a601c70203ff60c0c1f345
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jan 29 13:55:25 2013 -0600

    ARM: OMAP2+: Display correct system timer name
    
    Currently on boot, when displaying the name of the gptimer used for
    clockevents and clocksource timers, the timer ID is shown. However,
    when booting with device-tree, the timer ID is not used to select a
    gptimer but a timer property. Hence, it is possible that the timer
    selected when booting with device-tree does not match the ID shown.
    Therefore, instead display the HWMOD name of the gptimer and use
    the HWMOD name as the name of clockevent and clocksource timer (if a
    gptimer is used).
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 05b3a5472bfb..7d67d21fe52c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -129,7 +129,6 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 }
 
 static struct clock_event_device clockevent_gpt = {
-	.name		= "gp_timer",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.shift		= 32,
 	.rating		= 300,
@@ -215,10 +214,11 @@ static u32 __init omap_dm_timer_get_errata(void)
 }
 
 static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
-						int gptimer_id,
-						const char *fck_source,
-						const char *property,
-						int posted)
+					 int gptimer_id,
+					 const char *fck_source,
+					 const char *property,
+					 const char **timer_name,
+					 int posted)
 {
 	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
 	const char *oh_name;
@@ -255,6 +255,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (!oh)
 		return -ENODEV;
 
+	*timer_name = oh->name;
+
 	if (!of_have_populated_dt()) {
 		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL,
 						   &irq);
@@ -328,7 +330,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 	__omap_dm_timer_override_errata(&clkev, OMAP_TIMER_ERRATA_I103_I767);
 
 	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source, property,
-				     OMAP_TIMER_POSTED);
+				     &clockevent_gpt.name, OMAP_TIMER_POSTED);
 	BUG_ON(res);
 
 	omap2_gp_timer_irq.dev_id = &clkev;
@@ -348,8 +350,8 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 	clockevent_gpt.irq = omap_dm_timer_get_irq(&clkev);
 	clockevents_register_device(&clockevent_gpt);
 
-	pr_info("OMAP clockevent source: GPTIMER%d at %lu Hz\n",
-		gptimer_id, clkev.rate);
+	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
+		clkev.rate);
 }
 
 /* Clocksource code */
@@ -366,7 +368,6 @@ static cycle_t clocksource_read_cycles(struct clocksource *cs)
 }
 
 static struct clocksource clocksource_gpt = {
-	.name		= "gp_timer",
 	.rating		= 300,
 	.read		= clocksource_read_cycles,
 	.mask		= CLOCKSOURCE_MASK(32),
@@ -456,6 +457,7 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 	clksrc.errata = omap_dm_timer_get_errata();
 
 	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, NULL,
+				     &clocksource_gpt.name,
 				     OMAP_TIMER_NONPOSTED);
 	BUG_ON(res);
 
@@ -468,8 +470,8 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 		pr_err("Could not register clocksource %s\n",
 			clocksource_gpt.name);
 	else
-		pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
-			gptimer_id, clksrc.rate);
+		pr_info("OMAP clocksource: %s at %lu Hz\n",
+			clocksource_gpt.name, clksrc.rate);
 }
 
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER

commit 2d61aecee8f32259920cdf90a452fa26ffc64e9f
Merge: 71856843fb1d 6bb27d7349db
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Mon Apr 1 13:47:29 2013 -0500

    Merge commit '6bb27d7349db51b50c40534710fe164ca0d58902' into omap-timer-for-v3.10

commit ff931c821bab6713a52b768b0cd7ee7e90713b36
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Thu Mar 21 16:34:52 2013 +0530

    ARM: OMAP: clocks: Delay clk inits atleast until slab is initialized
    
    clk inits on OMAP happen quite early, even before slab is available.
    The dependency comes from the fact that the timer init code starts to
    use clocks and hwmod and we need clocks to be initialized by then.
    
    There are various problems doing clk inits this early, one is,
    not being able to do dynamic clk registrations and hence the
    dependency on clk-private.h. The other is, inability to debug
    early kernel crashes without enabling DEBUG_LL and earlyprintk.
    
    Doing early clk init also exposed another instance of a kernel
    panic due to a BUG() when CONFIG_DEBUG_SLAB is enabled.
    
    [    0.000000] Kernel BUG at c01174f8 [verbose debug info unavailable]
    [    0.000000] Internal error: Oops - BUG: 0 [#1] SMP ARM
    [    0.000000] Modules linked in:
    [    0.000000] CPU: 0    Not tainted  (3.9.0-rc1-12179-g72d48f9 #6)
    [    0.000000] PC is at __kmalloc+0x1d4/0x248
    [    0.000000] LR is at __clk_init+0x2e0/0x364
    [    0.000000] pc : [<c01174f8>]    lr : [<c0441f54>]    psr: 600001d3
    [    0.000000] sp : c076ff28  ip : c065cefc  fp : c0441f54
    [    0.000000] r10: 0000001c  r9 : 000080d0  r8 : c076ffd4
    [    0.000000] r7 : c074b578  r6 : c0794d88  r5 : 00000040  r4 : 00000000
    [    0.000000] r3 : 00000000  r2 : c07cac70  r1 : 000080d0  r0 : 0000001c
    [    0.000000] Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    [    0.000000] Control: 10c53c7d  Table: 8000404a  DAC: 00000017
    [    0.000000] Process swapper (pid: 0, stack limit = 0xc076e240)
    [    0.000000] Stack: (0xc076ff28 to 0xc0770000)
    [    0.000000] ff20:                   22222222 c0794ec8 c06546e8 00000000 00000040 c0794d88
    [    0.000000] ff40: c074b578 c076ffd4 c07951c8 c076e000 00000000 c0441f54 c074b578 c076ffd4
    [    0.000000] ff60: c0793828 00000040 c0794d88 c074b578 c076ffd4 c0776900 c076e000 c07272ac
    [    0.000000] ff80: 2f800000 c074c968 c07f93d0 c0719780 c076ffa0 c076ff98 00000000 00000000
    [    0.000000] ffa0: 00000000 00000000 00000000 00000001 c074cd6c c077b1ec 8000406a c0715724
    [    0.000000] ffc0: 00000000 00000000 00000000 00000000 00000000 c074c968 10c53c7d c0776974
    [    0.000000] ffe0: c074cd6c c077b1ec 8000406a 411fc092 00000000 80008074 00000000 00000000
    [    0.000000] [<c01174f8>] (__kmalloc+0x1d4/0x248) from [<c0441f54>] (__clk_init+0x2e0/0x364)
    [    0.000000] [<c0441f54>] (__clk_init+0x2e0/0x364) from [<c07272ac>] (omap4xxx_clk_init+0xbc/0x140)
    [    0.000000] [<c07272ac>] (omap4xxx_clk_init+0xbc/0x140) from [<c0719780>] (setup_arch+0x15c/0x284)
    [    0.000000] [<c0719780>] (setup_arch+0x15c/0x284) from [<c0715724>] (start_kernel+0x7c/0x334)
    [    0.000000] [<c0715724>] (start_kernel+0x7c/0x334) from [<80008074>] (0x80008074)
    [    0.000000] Code: e5883004 e1a00006 e28dd00c e8bd8ff0 (e7f001f2)
    [    0.000000] ---[ end trace 1b75b31a2719ed1c ]---
    [    0.000000] Kernel panic - not syncing: Attempted to kill the idle task!
    
    It was a know issue, that slab allocations would fail when common
    clock core tries to cache parent pointers for mux clocks on OMAP,
    and hence a patch 'clk: Allow late cache allocation for clk->parents,
    commit 7975059d' was added to work this problem around.
    A BUG() within kmalloc() with CONFIG_DEBUG_SLAB enabled was completely
    overlooked causing this regression.
    
    More details on the issue reported can be found here,
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg85932.html
    
    With all these issues around clk inits happening way too early, it
    makes sense to at least move them to a point where dynamic memory
    allocations are possible. So move them to a point just before the
    timer code starts using clocks and hwmod.
    
    This should at least pave way for clk inits on OMAP moving to dynamic
    clock registrations instead of using the static macros defined in
    clk-private.h.
    
    The issue with kernel panic while CONFIG_DEBUG_SLAB is enabled
    was reported by Piotr Haber and Tony Lindgren and this patch
    fixes the reported issue as well.
    
    Reported-by: Piotr Haber <phaber@broadcom.com>
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Mike Turquette <mturquette@linaro.org>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Cc: stable@vger.kernel.org  # v3.8
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2bdd4cf17a8f..f62b509ed08d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -547,6 +547,8 @@ static inline void __init realtime_counter_init(void)
 			       clksrc_nr, clksrc_src)			\
 void __init omap##name##_gptimer_timer_init(void)			\
 {									\
+	if (omap_clk_init)						\
+		omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src);	\
@@ -556,6 +558,8 @@ void __init omap##name##_gptimer_timer_init(void)			\
 				clksrc_nr, clksrc_src)			\
 void __init omap##name##_sync32k_timer_init(void)		\
 {									\
+	if (omap_clk_init)						\
+		omap_clk_init();					\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	/* Enable the use of clocksource="gp_timer" kernel parameter */	\

commit 960cba672bcecc6357984101703e70a8c819ccaa
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Jan 7 17:23:22 2013 +0530

    ARM: OMAP5: timer: Update the clocksource name as per clock data
    
    OMAP5 clockdata has different sys clock node name. Fix the timer code
    to take care of it.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2bdd4cf17a8f..773733fccd83 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -62,6 +62,7 @@
 #define OMAP2_MPU_SOURCE	"sys_ck"
 #define OMAP3_MPU_SOURCE	OMAP2_MPU_SOURCE
 #define OMAP4_MPU_SOURCE	"sys_clkin_ck"
+#define OMAP5_MPU_SOURCE	"sys_clkin"
 #define OMAP2_32K_SOURCE	"func_32k_ck"
 #define OMAP3_32K_SOURCE	"omap_32k_fck"
 #define OMAP4_32K_SOURCE	"sys_32k_ck"
@@ -487,7 +488,7 @@ static void __init realtime_counter_init(void)
 		pr_err("%s: ioremap failed\n", __func__);
 		return;
 	}
-	sys_clk = clk_get(NULL, "sys_clkin_ck");
+	sys_clk = clk_get(NULL, OMAP5_MPU_SOURCE);
 	if (IS_ERR(sys_clk)) {
 		pr_err("%s: failed to get system clock handle\n", __func__);
 		iounmap(base);
@@ -616,7 +617,7 @@ void __init omap4_local_timer_init(void)
 
 #ifdef CONFIG_SOC_OMAP5
 OMAP_SYS_32K_TIMER_INIT(5, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
-			2, OMAP4_MPU_SOURCE);
+			2, OMAP5_MPU_SOURCE);
 void __init omap5_realtime_timer_init(void)
 {
 	int err;

commit 71856843fb1d8ee455a4c1a60696c74afa4809e5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 13 20:44:21 2013 +0000

    ARM: OMAP: use consistent error checking
    
    Consistently check errors using the usual method used in the kernel
    for much of its history.  For instance:
    
    int gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)
    {
            int div;
            div = gpmc_calc_divider(t->sync_clk);
            if (div < 0)
                    return div;
    static int gpmc_set_async_mode(int cs, struct gpmc_timings *t)
    {
    ...
            return gpmc_cs_set_timings(cs, t);
    
    .....
            ret = gpmc_set_async_mode(gpmc_onenand_data->cs, &t);
            if (IS_ERR_VALUE(ret))
                    return ret;
    
    So, gpmc_cs_set_timings() thinks any negative return value is an error,
    but where we check that in higher levels, only a limited range are
    errors...
    
    There is only _one_ use of IS_ERR_VALUE() in arch/arm which is really
    appropriate, and that is in arch/arm/include/asm/syscall.h:
    
    static inline long syscall_get_error(struct task_struct *task,
                                         struct pt_regs *regs)
    {
            unsigned long error = regs->ARM_r0;
            return IS_ERR_VALUE(error) ? error : 0;
    }
    
    because this function really does have to differentiate between error
    return values and addresses which look like negative numbers (eg, from
    mmap()).
    
    So, here's a patch to remove them from OMAP, except for the above.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b8ad6e632bb8..390c1b6e15bc 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -288,7 +288,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 			r = -EINVAL;
 		} else {
 			r = clk_set_parent(timer->fclk, src);
-			if (IS_ERR_VALUE(r))
+			if (r < 0)
 				pr_warn("%s: %s cannot set source\n",
 					__func__, oh->name);
 			clk_put(src);

commit da4a686a2cfb077a8bfc1697f597e7f86235b822
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Feb 6 21:17:47 2013 -0600

    ARM: smp_twd: convert to use CLKSRC_OF init
    
    Now that we have OF based init with CLKSRC_OF, convert smp_twd init
    function to use it and covert all callers of
    twd_local_timer_of_register.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-omap@vger.kernel.org
    Cc: spear-devel@list.st.com
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2bdd4cf17a8f..4fd80257c73e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -597,7 +597,7 @@ void __init omap4_local_timer_init(void)
 		int err;
 
 		if (of_have_populated_dt()) {
-			twd_local_timer_of_register();
+			clocksource_of_init();
 			return;
 		}
 

commit bab588fcfb6335c767d811a8955979f5440328e0
Merge: 3298a3511f1e 9cb0d1babfcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 15:27:22 2013 -0800

    Merge tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC-specific updates from Arnd Bergmann:
     "This is a larger set of new functionality for the existing SoC
      families, including:
    
       - vt8500 gains support for new CPU cores, notably the Cortex-A9 based
         wm8850
    
       - prima2 gains support for the "marco" SoC family, its SMP based
         cousin
    
       - tegra gains support for the new Tegra4 (Tegra114) family
    
       - socfpga now supports a newer version of the hardware including SMP
    
       - i.mx31 and bcm2835 are now using DT probing for their clocks
    
       - lots of updates for sh-mobile
    
       - OMAP updates for clocks, power management and USB
    
       - i.mx6q and tegra now support cpuidle
    
       - kirkwood now supports PCIe hot plugging
    
       - tegra clock support is updated
    
       - tegra USB PHY probing gets implemented diffently"
    
    * tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (148 commits)
      ARM: prima2: remove duplicate v7_invalidate_l1
      ARM: shmobile: r8a7779: Correct TMU clock support again
      ARM: prima2: fix __init section for cpu hotplug
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 3/3)
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 1/3)
      arm: socfpga: Add SMP support for actual socfpga harware
      arm: Add v7_invalidate_l1 to cache-v7.S
      arm: socfpga: Add entries to enable make dtbs socfpga
      arm: socfpga: Add new device tree source for actual socfpga HW
      ARM: tegra: sort Kconfig selects for Tegra114
      ARM: tegra: enable ARCH_REQUIRE_GPIOLIB for Tegra114
      ARM: tegra: Fix build error w/ ARCH_TEGRA_114_SOC w/o ARCH_TEGRA_3x_SOC
      ARM: tegra: Fix build error for gic update
      ARM: tegra: remove empty tegra_smp_init_cpus()
      ARM: shmobile: Register ARM architected timer
      ARM: MARCO: fix the build issue due to gic-vic-to-irqchip move
      ARM: shmobile: r8a7779: Correct TMU clock support
      ARM: mxs_defconfig: Select CONFIG_DEVTMPFS_MOUNT
      ARM: mxs: decrease mxs_clockevent_device.min_delta_ns to 2 clock cycles
      ARM: mxs: use apbx bus clock to drive the timers on timrotv2
      ...

commit 3298a3511f1e73255a8dc023efd909e569eea037
Merge: 5ce7aba976eb acb7452369e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 15:20:41 2013 -0800

    Merge tag 'multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC multiplatform support from Arnd Bergmann:
     "Converting more ARM platforms to multiplatform support.  This time,
      OMAP gets converted, which is a major step since this is by far the
      largest platform in terms of code size.  The same thing happens to the
      vt8500 platform."
    
    * tag 'multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      net: cwdavinci_cpdma: export symbols for cpsw
      remoteproc: omap: depend on OMAP_MBOX_FWK
      [media] davinci: do not include mach/hardware.h
      ARM: OMAP2+: Make sure files with omap initcalls include soc.h
      ARM: OMAP2+: Include soc.h to drm.c to fix compiling
      ARM: OMAP2+: Fix warning for hwspinlock omap_postcore_initcall
      ARM: multi_v7_defconfig: add ARCH_ZYNQ
      ARM: multi_v7_defconfig: remove unnecessary CONFIG_GPIOLIB
      arm: vt8500: Remove remaining mach includes
      arm: vt8500: Convert debug-macro.S to be multiplatform friendly
      arm: vt8500: Remove single platform Kconfig options
      ARM: OMAP2+: Remove now obsolete uncompress.h and debug-macro.S
      ARM: OMAP2+: Add minimal support for booting vexpress
      ARM: OMAP2+: Enable ARCH_MULTIPLATFORM support
      ARM: OMAP2+: Disable code that currently does not work with multiplaform
      ARM: OMAP2+: Add multiplatform debug_ll support
      ARM: OMAP: Fix dmaengine init for multiplatform
      ARM: OMAP: Fix i2c cmdline initcall for multiplatform
      ARM: OMAP2+: Use omap initcalls
      ARM: OMAP2+: Limit omap initcalls to omap only on multiplatform kernels

commit b274776c54c320763bc12eb035c0e244f76ccb43
Merge: b24174b0cbbe 3b1209e7994c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 14:58:40 2013 -0800

    Merge tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "A large number of cleanups, all over the platforms.  This is dominated
      largely by the Samsung platforms (s3c, s5p, exynos) and a few of the
      others moving code out of arch/arm into more appropriate subsystems.
    
      The clocksource and irqchip drivers are now abstracted to the point
      where platforms that are already cleaned up do not need to even
      specify the driver they use, it can all get configured from the device
      tree as we do for normal device drivers.  The clocksource changes
      basically touch every single platform in the process.
    
      We further clean up the use of platform specific header files here,
      with the goal of turning more of the platforms over to being
      "multiplatform" enabled, which implies that they cannot expose their
      headers to architecture independent code any more.
    
      It is expected that no functional changes are part of the cleanup.
      The overall reduction in total code lines is mostly the result of
      removing broken and obsolete code."
    
    * tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (133 commits)
      ARM: mvebu: correct gated clock documentation
      ARM: kirkwood: add missing include for nsa310
      ARM: exynos: move exynos4210-combiner to drivers/irqchip
      mfd: db8500-prcmu: update resource passing
      drivers/db8500-cpufreq: delete dangling include
      ARM: at91: remove NEOCORE 926 board
      sunxi: Cleanup the reset code and add meaningful registers defines
      ARM: S3C24XX: header mach/regs-mem.h local
      ARM: S3C24XX: header mach/regs-power.h local
      ARM: S3C24XX: header mach/regs-s3c2412-mem.h local
      ARM: S3C24XX: Remove plat-s3c24xx directory in arch/arm/
      ARM: S3C24XX: transform s3c2443 subirqs into new structure
      ARM: S3C24XX: modify s3c2443 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2443 irq code to irq.c
      ARM: S3C24XX: transform s3c2416 irqs into new structure
      ARM: S3C24XX: modify s3c2416 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2416 irq init to common irq code
      ARM: S3C24XX: Modify s3c_irq_wake to use the hwirq property
      ARM: S3C24XX: Move irq syscore-ops to irq-pm
      clocksource: always define CLOCKSOURCE_OF_DECLARE
      ...

commit acb7452369e4f8749dd32d48dbda98936035a87c
Merge: dad2d9e666cb 949db153b646 6929e24e4cc4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 15 13:25:20 2013 +0100

    Merge branch 'omap/multiplatform-fixes', tag 'v3.8-rc5' into next/multiplatform
    
    The omap multiplatform support uncovered a bug in the cwdavinci_cpdma
    code and was missing two drivers that are enabled now but are not
    quite ready for multiplatform, as found by allyesconfig builds.
    
    There is also a conflict generated by automated merge in
    arch/arm/mach-omap2/drm.c between a bug fix that went into v3.8-rc5
    and a different version of the same fix that went into the
    omap/multiplatform branch. This merge removes the extraneous
     #include that was causing build errors.
    
    * omap/multiplatform-fixes:
      net: cwdavinci_cpdma: export symbols for cpsw
      remoteproc: omap: depend on OMAP_MBOX_FWK
      [media] davinci: do not include mach/hardware.h
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit d37d79ed8af1de90535e6a877081d720205d6cd9
Merge: 7e6111496323 0e084c9c8433
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 5 14:05:11 2013 -0800

    Merge tag 'omap-for-v3.9/pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    From Tony Lindgren:
    OMAP PM related updates via Paul Walmsley <paul@pwsan.com>:
    
    Remove some dead OMAP clock and device integration code and data.
    Also, clean up the way that the OMAP device integration code blocks
    WFI/WFE to use a consistent mechanism, controlled by a data flag.
    
    Several OMAP2+ power management fixes, optimizations, and cleanup.
    This series is a prerequisite for the functional powerdomain
    conversion series.
    
    * tag 'omap-for-v3.9/pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP2+: powerdomain: fix whitespace, improve flag comments
      ARM: OMAP2+: clockdomain: convert existing atomic usecounts into spinlock-protected shorts/ints
      ARM: OMAP2+: clockdomain: work on wkdep/sleepdep functions
      ARM: OMAP2xxx: CM: remove autodep handling
      ARM: OMAP2+: powerdomain/clockdomain: add a per-powerdomain spinlock
      ARM: OMAP2+: PM/powerdomain: move omap_set_pwrdm_state() to powerdomain code
      ARM: OMAP2: PM/powerdomain: drop unnecessary pwrdm_wait_transition()
      ARM: OMAP2xxx: PM: clean up some crufty powerstate programming code
      ARM: OMAP2+: clockdomain: add pwrdm_state_switch() call to clkdm_sleep()
      ARM: OMAP2+: powerdomain: fix powerdomain trace integration
      ARM: OMAP4: MPUSS PM: remove unnecessary shim functions for powerdomain control
      ARM: OMAP3xxx: CPUIdle: optimize __omap3_enter_idle()
      ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
      ARM: OMAP2+: hwmod: add support for blocking WFI when a device is active
      ARM: OMAP3xxx: CPUIdle: simplify the PER next-state code
      ARM: OMAP2xxx: powerdomain: core powerdomain missing logic retention states
      ARM: OMAP2xxx: clock data: clean up unused null clocks
      ARM: OMAP4: clock/hwmod data: remove MODULEMODE entries in mux + gate combos
      ARM: OMAP4: clock/hwmod data: start to remove some IP block control "clocks"
      ARM: OMAP2+: omap_device: remove obsolete pm_lats and early_device code

commit 469da62096e23adc755c1268b00b5fc7a214151b
Merge: 422796165088 88b62b915b0b
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Feb 4 22:56:41 2013 -0800

    Merge tag 'v3.8-rc6' into next/soc
    
    Linux 3.8-rc6

commit 61338d598eec1477455294f006793ee54eead795
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jan 29 14:23:11 2013 -0600

    ARM: OMAP2+: Fix selection of clockevent timer when using device-tree
    
    Commit 9725f44 (ARM: OMAP: Add DT support for timer driver) added
    device-tree support for selecting a clockevent timer by property.
    However, the code is currently ignoring the property passed and
    selecting the first available timer found. Hence, for the OMAP3 beagle
    board timer-12 is not being selected as expected. Fix this problem
    by ensuring the timer property is passed to omap_get_timer_dt().
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b8ad6e632bb8..265de51b43d9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -228,7 +228,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	int r = 0;
 
 	if (of_have_populated_dt()) {
-		np = omap_get_timer_dt(omap_timer_match, NULL);
+		np = omap_get_timer_dt(omap_timer_match, property);
 		if (!np)
 			return -ENODEV;
 

commit 6b914c998787d65022e80d6262dfd0edef58cadb
Merge: 1f87a404d02a 949db153b646
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Jan 27 22:07:11 2013 -0800

    Merge tag 'v3.8-rc5' into next/cleanup
    
    Linux 3.8-rc5
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit c1d1cd597fc77af3086470f8627d77f52f7f8b6c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:53 2013 -0700

    ARM: OMAP2+: omap_device: remove obsolete pm_lats and early_device code
    
    Remove now-obsolete code from arch/arm/mach-omap2/omap_device.c.  This
    mostly consists of removing the first attempt at device PM latency
    handling.  This was never really used, has been replaced by the common
    dev_pm_qos code, and needs to go away as part of the DT conversion.
    Also, the early platform_device creation code has been removed, as it
    appears to be unused.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b8ad6e632bb8..63e5fb017fd8 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -702,8 +702,7 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	pdata->timer_errata = omap_dm_timer_get_errata();
 	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
 
-	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
-				 NULL, 0, 0);
+	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata));
 
 	if (IS_ERR(pdev)) {
 		pr_err("%s: Can't build omap_device for %s: %s.\n",

commit 034bf091b7a5f02e63409b0b5b6dad1101d70144
Author: Pantelis Antoniou <panto@antoniou-consulting.com>
Date:   Tue Jan 8 15:31:42 2013 +0200

    ARM: OMAP2+: DT node Timer iteration fix
    
    The iterator correctly handles of_node_put() calls.
    Remove it before continue'ing the loop.
    Without this patch you get the following with
    CONFIG_OF_DYNAMIC set:
    
    ERROR: Bad of_node_put() on /ocp/timer@44e31000!
    [<c001329c>] (unwind_backtrace+0x0/0xe0) from [<c03dd8f0>] (of_node_release+0x2c/0xa0)!
    [<c03dd8f0>] (of_node_release+0x2c/0xa0) from [<c03ddea0>] (of_find_matching_node_and_match+0x78/0x90)!
    [<c03ddea0>] (of_find_matching_node_and_match+0x78/0x90) from [<c06d349c>] (omap_get_timer_dt+0x78/0x90)!
    [<c06d349c>] (omap_get_timer_dt+0x78/0x90) from [<c06d3664>] (omap_dm_timer_init_one.clone.2+0x34/0x2bc)!
    [<c06d3664>] (omap_dm_timer_init_one.clone.2+0x34/0x2bc) from [<c06d3a2c>] (omap2_gptimer_clocksource_init.clone.4+0x24/0xa8)!
    [<c06d3a2c>] (omap2_gptimer_clocksource_init.clone.4+0x24/0xa8) from [<c06cca58>] (time_init+0x20/0x30)!
    [<c06cca58>] (time_init+0x20/0x30) from [<c06c9690>] (start_kernel+0x1a8/0x2fc)!
    
    Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    Acked-by: Jon Hunter <jon-hunter@ti.com>
    [tony@atomide.com: updated description per Jon]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 691aa674665a..b8ad6e632bb8 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -165,15 +165,11 @@ static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
 	struct device_node *np;
 
 	for_each_matching_node(np, match) {
-		if (!of_device_is_available(np)) {
-			of_node_put(np);
+		if (!of_device_is_available(np))
 			continue;
-		}
 
-		if (property && !of_get_property(np, property, NULL)) {
-			of_node_put(np);
+		if (property && !of_get_property(np, property, NULL))
 			continue;
-		}
 
 		of_add_property(np, &device_disabled);
 		return np;

commit 8d84981e395850aab31c3f2ca7e2738e03f671d7
Merge: 00c82d644056 77cc982f6a3b
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 10:20:02 2013 -0800

    Merge branch 'clocksource/cleanup' into next/cleanup
    
    Clockevent cleanup series from Shawn Guo.
    
    Resolved move/change conflict in mach-pxa/time.c due to the sys_timer
    cleanup.
    
    * clocksource/cleanup:
      clocksource: use clockevents_config_and_register() where possible
      ARM: use clockevents_config_and_register() where possible
      clockevents: export clockevents_config_and_register for module use
      + sync to Linux 3.8-rc3
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-pxa/time.c

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 691aa674665a..3e2ffdbce220 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -131,7 +131,6 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 static struct clock_event_device clockevent_gpt = {
 	.name		= "gp_timer",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-	.shift		= 32,
 	.rating		= 300,
 	.set_next_event	= omap2_gp_timer_set_next_event,
 	.set_mode	= omap2_gp_timer_set_mode,
@@ -340,17 +339,11 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 
 	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
 
-	clockevent_gpt.mult = div_sc(clkev.rate, NSEC_PER_SEC,
-				     clockevent_gpt.shift);
-	clockevent_gpt.max_delta_ns =
-		clockevent_delta2ns(0xffffffff, &clockevent_gpt);
-	clockevent_gpt.min_delta_ns =
-		clockevent_delta2ns(3, &clockevent_gpt);
-		/* Timer internal resynch latency. */
-
 	clockevent_gpt.cpumask = cpu_possible_mask;
 	clockevent_gpt.irq = omap_dm_timer_get_irq(&clkev);
-	clockevents_register_device(&clockevent_gpt);
+	clockevents_config_and_register(&clockevent_gpt, clkev.rate,
+					3, /* Timer internal resynch latency */
+					0xffffffff);
 
 	pr_info("OMAP clockevent source: GPTIMER%d at %lu Hz\n",
 		gptimer_id, clkev.rate);

commit b76c8b19b082c3fc84725de0d3ba5ee1f571c0ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 11 11:24:18 2013 -0800

    ARM: OMAP2+: Use omap initcalls
    
    This way the initcalls don't run on other SoCs on multiplatform
    kernels. Otherwise we'll get something like this when booting
    on vexpress:
    
    omap_hwmod: _ensure_mpu_hwmod_is_setup: MPU initiator hwmod mpu not yet registered
    ...
    WARNING: at arch/arm/mach-omap2/pm.c:82 _init_omap_device+0x74/0x94()
    _init_omap_device: could not find omap_hwmod for mpu
    ...
    omap-dma-engine omap-dma-engine: OMAP DMA engine driver
    ...
    
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 691aa674665a..5b304beeeb12 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -742,7 +742,7 @@ static int __init omap2_dm_timer_init(void)
 
 	return 0;
 }
-arch_initcall(omap2_dm_timer_init);
+omap_arch_initcall(omap2_dm_timer_init);
 
 /**
  * omap2_override_clocksource - clocksource override with user configuration

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 691aa674665a..5975a42e16d4 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -556,7 +556,7 @@ static inline void __init realtime_counter_init(void)
 
 #define OMAP_SYS_GP_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
 			       clksrc_nr, clksrc_src)			\
-static void __init omap##name##_gptimer_timer_init(void)		\
+void __init omap##name##_gptimer_timer_init(void)			\
 {									\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
@@ -565,7 +565,7 @@ static void __init omap##name##_gptimer_timer_init(void)		\
 
 #define OMAP_SYS_32K_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
 				clksrc_nr, clksrc_src)			\
-static void __init omap##name##_sync32k_timer_init(void)		\
+void __init omap##name##_sync32k_timer_init(void)		\
 {									\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
@@ -576,33 +576,23 @@ static void __init omap##name##_sync32k_timer_init(void)		\
 		omap2_sync32k_clocksource_init();			\
 }
 
-#define OMAP_SYS_TIMER(name, clksrc)					\
-struct sys_timer omap##name##_timer = {					\
-	.init	= omap##name##_##clksrc##_timer_init,			\
-};
-
 #ifdef CONFIG_ARCH_OMAP2
 OMAP_SYS_32K_TIMER_INIT(2, 1, OMAP2_32K_SOURCE, "ti,timer-alwon",
 			2, OMAP2_MPU_SOURCE);
-OMAP_SYS_TIMER(2, sync32k);
 #endif /* CONFIG_ARCH_OMAP2 */
 
 #ifdef CONFIG_ARCH_OMAP3
 OMAP_SYS_32K_TIMER_INIT(3, 1, OMAP3_32K_SOURCE, "ti,timer-alwon",
 			2, OMAP3_MPU_SOURCE);
-OMAP_SYS_TIMER(3, sync32k);
 OMAP_SYS_32K_TIMER_INIT(3_secure, 12, OMAP3_32K_SOURCE, "ti,timer-secure",
 			2, OMAP3_MPU_SOURCE);
-OMAP_SYS_TIMER(3_secure, sync32k);
 OMAP_SYS_GP_TIMER_INIT(3_gp, 1, OMAP3_MPU_SOURCE, "ti,timer-alwon",
 		       2, OMAP3_MPU_SOURCE);
-OMAP_SYS_TIMER(3_gp, gptimer);
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #ifdef CONFIG_SOC_AM33XX
 OMAP_SYS_GP_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, "ti,timer-alwon",
 		       2, OMAP4_MPU_SOURCE);
-OMAP_SYS_TIMER(3_am33xx, gptimer);
 #endif /* CONFIG_SOC_AM33XX */
 
 #ifdef CONFIG_ARCH_OMAP4
@@ -610,7 +600,7 @@ OMAP_SYS_32K_TIMER_INIT(4, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
 			2, OMAP4_MPU_SOURCE);
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
-static void __init omap4_local_timer_init(void)
+void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
 	/* Local timers are not supprted on OMAP4430 ES1.0 */
@@ -628,18 +618,17 @@ static void __init omap4_local_timer_init(void)
 	}
 }
 #else /* CONFIG_LOCAL_TIMERS */
-static void __init omap4_local_timer_init(void)
+void __init omap4_local_timer_init(void)
 {
 	omap4_sync32k_timer_init();
 }
 #endif /* CONFIG_LOCAL_TIMERS */
-OMAP_SYS_TIMER(4, local);
 #endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5
 OMAP_SYS_32K_TIMER_INIT(5, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
 			2, OMAP4_MPU_SOURCE);
-static void __init omap5_realtime_timer_init(void)
+void __init omap5_realtime_timer_init(void)
 {
 	int err;
 
@@ -650,7 +639,6 @@ static void __init omap5_realtime_timer_init(void)
 	if (err)
 		pr_err("%s: arch_timer_register failed %d\n", __func__, err);
 }
-OMAP_SYS_TIMER(5, realtime);
 #endif /* CONFIG_SOC_OMAP5 */
 
 /**

commit 2727da8595d6a134502ce576b812f0bb0e3c14ed
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Dec 19 10:50:09 2012 +0100

    ARM: OMAP2+: Fix compillation error in mach-omap2/timer.c
    
    prom_add_property() has been renamed to of_add_property()
    This patch fixes the following comilation error:
    
    arch/arm/mach-omap2/timer.c: In function ‘omap_get_timer_dt’:
    arch/arm/mach-omap2/timer.c:178:3: error: implicit declaration of function ‘prom_add_property’ [-Werror=implicit-function-declaration]
    cc1: some warnings being treated as errors
    make[1]: *** [arch/arm/mach-omap2/timer.o] Error 1
    make[1]: *** Waiting for unfinished jobs....
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 06e141543623..691aa674665a 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -175,7 +175,7 @@ static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
 			continue;
 		}
 
-		prom_add_property(np, &device_disabled);
+		of_add_property(np, &device_disabled);
 		return np;
 	}
 

commit bf85f205d95eb223e849914101e0db1a5a576a3c
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Wed Nov 28 15:56:41 2012 -0600

    ARM: OMAP2+: Fix sparse warnings in timer.c
    
    Sparse generates the following warnings when compiling mach-omap2/timer.c.
    
      CHECK   arch/arm/mach-omap2/timer.c
      arch/arm/mach-omap2/timer.c:193:13: warning: symbol 'omap_dmtimer_init'
      was not declared. Should it be static?
      arch/arm/mach-omap2/timer.c:213:12: warning: symbol
      'omap_dm_timer_get_errata' was not declared. Should it be static?
    
    Add static to function declaration to fix warnings.
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index e2ffe0adc28b..06e141543623 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -190,7 +190,7 @@ static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
  * kernel registering these devices remove them dynamically from the device
  * tree on boot.
  */
-void __init omap_dmtimer_init(void)
+static void __init omap_dmtimer_init(void)
 {
 	struct device_node *np;
 
@@ -210,7 +210,7 @@ void __init omap_dmtimer_init(void)
  *
  * Get the timer errata flags that are specific to the OMAP device being used.
  */
-u32 __init omap_dm_timer_get_errata(void)
+static u32 __init omap_dm_timer_get_errata(void)
 {
 	if (cpu_is_omap24xx())
 		return 0;

commit e0c3e27ce19fcc81156ba49c91d83a676144a103
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Nov 27 15:24:12 2012 -0600

    ARM: AM335x: Fix warning in timer.c
    
    When compiling the kernel with configuration options ...
    
     # CONFIG_ARCH_OMAP2 is not set
     # CONFIG_ARCH_OMAP3 is not set
     # CONFIG_ARCH_OMAP4 is not set
     # CONFIG_SOC_OMAP5 is not set
     CONFIG_SOC_AM33XX=y
    
     ... the following build warning is seen.
    
      CC      arch/arm/mach-omap2/timer.o
      arch/arm/mach-omap2/timer.c:395:19: warning: ‘omap2_sync32k_clocksource_init’
            defined but not used [-Wunused-function]
    
    This issue was introduced by commit 6f80b3b (ARM: OMAP2+: timer: remove
    CONFIG_OMAP_32K_TIMER) where the omap2_sync32k_clocksource_init() is no
    longer referenced by the timer initialisation function for the AM335x
    device as it has no 32k-sync timer.
    
    Fix this by adding the "__maybe_unused" compiler directive to the
    omap2_sync32k_clocksource_init() function to indicate that this function
    may be used for certain configurations.
    
    Cc: Igor Grinberg <grinberg@compulab.co.il>
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 7016637b531c..e2ffe0adc28b 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -392,7 +392,7 @@ static struct of_device_id omap_counter_match[] __initdata = {
 };
 
 /* Setup free-running counter for clocksource */
-static int __init omap2_sync32k_clocksource_init(void)
+static int __init __maybe_unused omap2_sync32k_clocksource_init(void)
 {
 	int ret;
 	struct device_node *np = NULL;

commit 73f14f6d007df1596da7cea9113084acfe846b8f
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Nov 29 23:05:32 2012 -0800

    ARM: omap: fix typo on timer cleanup
    
    Fix 32 vs 32k typo:
    
    arch/arm/mach-omap2/timer.c: In function 'omap4_local_timer_init':
    arch/arm/mach-omap2/timer.c:633:2: error: implicit declaration of function 'omap4_sync32_timer_init' [-Werror=implicit-function-declaration]
    arch/arm/mach-omap2/timer.c: At top level:
    arch/arm/mach-omap2/timer.c:610:2: warning: 'omap4_sync32k_timer_init' defined but not used [-Wunused-function]
    
    Also, mark the omap4_local_timer_init() stub as __init (and take off
    the explicit inline and let the compiler do the work instead).
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Igor Grinberg <grinberg@compulab.co.il>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b9cff72ceaec..7016637b531c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -628,9 +628,9 @@ static void __init omap4_local_timer_init(void)
 	}
 }
 #else /* CONFIG_LOCAL_TIMERS */
-static inline void omap4_local_timer_init(void)
+static void __init omap4_local_timer_init(void)
 {
-	omap4_sync32_timer_init();
+	omap4_sync32k_timer_init();
 }
 #endif /* CONFIG_LOCAL_TIMERS */
 OMAP_SYS_TIMER(4, local);

commit 26f01998b0657a61167a819f1c37cb9f9e9d674b
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Sun Nov 18 17:06:41 2012 +0200

    ARM: OMAP3: cm-t3517: use GPTIMER for system clock
    
    cm-t3517 starting from revision 1.2 does not have the 32K oscilator
    wired to the AM3517 SoC.
    Therefore switch to use the GPTIMER for system clock.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index bbe3cc2c1fca..b9cff72ceaec 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -594,6 +594,9 @@ OMAP_SYS_TIMER(3, sync32k);
 OMAP_SYS_32K_TIMER_INIT(3_secure, 12, OMAP3_32K_SOURCE, "ti,timer-secure",
 			2, OMAP3_MPU_SOURCE);
 OMAP_SYS_TIMER(3_secure, sync32k);
+OMAP_SYS_GP_TIMER_INIT(3_gp, 1, OMAP3_MPU_SOURCE, "ti,timer-alwon",
+		       2, OMAP3_MPU_SOURCE);
+OMAP_SYS_TIMER(3_gp, gptimer);
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #ifdef CONFIG_SOC_AM33XX

commit 6f80b3bb8a0ae4ae376dbdc69acf1fca8b4e2c9c
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue Nov 20 09:17:15 2012 +0200

    ARM: OMAP2+: timer: remove CONFIG_OMAP_32K_TIMER
    
    CONFIG_OMAP_32K_TIMER is kind of standing on the single zImage way.
    Make OMAP2+ timer code independant from the CONFIG_OMAP_32K_TIMER
    setting.
    To remove the dependancy, several conversions/additions had to be done:
    1) Timer initialization functions are named by the platform
       name and the clock source in use.
       This also makes it possible to define and use the GPTIMER as the
       clock source instead of the 32K timer on platforms that do not have
       the 32K timer ip block or the 32K timer is not wired on the board.
       Currently, the the timer is chosen in the machine_desc structure on
       per board basis. Later, DT should be used to choose the timer.
    2) Settings under the CONFIG_OMAP_32K_TIMER option are used as defaults
       and those under !CONFIG_OMAP_32K_TIMER are removed.
       This removes the CONFIG_OMAP_32K_TIMER on OMAP2+ timer code.
    3) Since we have all the timers defined inside machine_desc structure
       and we no longer need the fallback to gp_timer clock source in case
       32k_timer clock source is unavailable (namely on AM33xx), we no
       longer need the #ifdef around omap2_sync32k_clocksource_init()
       function. Remove the #ifdef CONFIG_OMAP_32K_TIMER around the
       omap2_sync32k_clocksource_init() function.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Cc: Jon Hunter <jon-hunter@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b7f43a28e41f..bbe3cc2c1fca 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -66,20 +66,6 @@
 #define OMAP3_32K_SOURCE	"omap_32k_fck"
 #define OMAP4_32K_SOURCE	"sys_32k_ck"
 
-#ifdef CONFIG_OMAP_32K_TIMER
-#define OMAP2_CLKEV_SOURCE	OMAP2_32K_SOURCE
-#define OMAP3_CLKEV_SOURCE	OMAP3_32K_SOURCE
-#define OMAP4_CLKEV_SOURCE	OMAP4_32K_SOURCE
-#define OMAP3_SECURE_TIMER	12
-#define TIMER_PROP_SECURE	"ti,timer-secure"
-#else
-#define OMAP2_CLKEV_SOURCE	OMAP2_MPU_SOURCE
-#define OMAP3_CLKEV_SOURCE	OMAP3_MPU_SOURCE
-#define OMAP4_CLKEV_SOURCE	OMAP4_MPU_SOURCE
-#define OMAP3_SECURE_TIMER	1
-#define TIMER_PROP_SECURE	"ti,timer-alwon"
-#endif
-
 #define REALTIME_COUNTER_BASE				0x48243200
 #define INCREMENTER_NUMERATOR_OFFSET			0x10
 #define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
@@ -400,7 +386,6 @@ static u32 notrace dmtimer_read_sched_clock(void)
 	return 0;
 }
 
-#ifdef CONFIG_OMAP_32K_TIMER
 static struct of_device_id omap_counter_match[] __initdata = {
 	{ .compatible = "ti,omap-counter32k", },
 	{ }
@@ -466,12 +451,6 @@ static int __init omap2_sync32k_clocksource_init(void)
 
 	return ret;
 }
-#else
-static inline int omap2_sync32k_clocksource_init(void)
-{
-	return -ENODEV;
-}
-#endif
 
 static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 						const char *fck_source)
@@ -497,25 +476,6 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 			gptimer_id, clksrc.rate);
 }
 
-static void __init omap2_clocksource_init(int gptimer_id,
-						const char *fck_source)
-{
-	/*
-	 * First give preference to kernel parameter configuration
-	 * by user (clocksource="gp_timer").
-	 *
-	 * In case of missing kernel parameter for clocksource,
-	 * first check for availability for 32k-sync timer, in case
-	 * of failure in finding 32k_counter module or registering
-	 * it as clocksource, execution will fallback to gp-timer.
-	 */
-	if (use_gptimer_clksrc == true)
-		omap2_gptimer_clocksource_init(gptimer_id, fck_source);
-	else if (omap2_sync32k_clocksource_init())
-		/* Fall back to gp-timer code */
-		omap2_gptimer_clocksource_init(gptimer_id, fck_source);
-}
-
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 /*
  * The realtime counter also called master counter, is a free-running
@@ -594,52 +554,62 @@ static inline void __init realtime_counter_init(void)
 {}
 #endif
 
-#define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
+#define OMAP_SYS_GP_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
+			       clksrc_nr, clksrc_src)			\
+static void __init omap##name##_gptimer_timer_init(void)		\
+{									\
+	omap_dmtimer_init();						\
+	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
+	omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src);	\
+}
+
+#define OMAP_SYS_32K_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
 				clksrc_nr, clksrc_src)			\
-static void __init omap##name##_timer_init(void)			\
+static void __init omap##name##_sync32k_timer_init(void)		\
 {									\
 	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
-	omap2_clocksource_init((clksrc_nr), clksrc_src);		\
+	/* Enable the use of clocksource="gp_timer" kernel parameter */	\
+	if (use_gptimer_clksrc)						\
+		omap2_gptimer_clocksource_init((clksrc_nr), clksrc_src);\
+	else								\
+		omap2_sync32k_clocksource_init();			\
 }
 
-#define OMAP_SYS_TIMER(name)						\
+#define OMAP_SYS_TIMER(name, clksrc)					\
 struct sys_timer omap##name##_timer = {					\
-	.init	= omap##name##_timer_init,				\
+	.init	= omap##name##_##clksrc##_timer_init,			\
 };
 
 #ifdef CONFIG_ARCH_OMAP2
-OMAP_SYS_TIMER_INIT(2, 1, OMAP2_CLKEV_SOURCE, "ti,timer-alwon",
-		    2, OMAP2_MPU_SOURCE)
-OMAP_SYS_TIMER(2)
-#endif
+OMAP_SYS_32K_TIMER_INIT(2, 1, OMAP2_32K_SOURCE, "ti,timer-alwon",
+			2, OMAP2_MPU_SOURCE);
+OMAP_SYS_TIMER(2, sync32k);
+#endif /* CONFIG_ARCH_OMAP2 */
 
 #ifdef CONFIG_ARCH_OMAP3
-OMAP_SYS_TIMER_INIT(3, 1, OMAP3_CLKEV_SOURCE, "ti,timer-alwon",
-		    2, OMAP3_MPU_SOURCE)
-OMAP_SYS_TIMER(3)
-OMAP_SYS_TIMER_INIT(3_secure, OMAP3_SECURE_TIMER, OMAP3_CLKEV_SOURCE,
-			TIMER_PROP_SECURE, 2, OMAP3_MPU_SOURCE)
-OMAP_SYS_TIMER(3_secure)
-#endif
+OMAP_SYS_32K_TIMER_INIT(3, 1, OMAP3_32K_SOURCE, "ti,timer-alwon",
+			2, OMAP3_MPU_SOURCE);
+OMAP_SYS_TIMER(3, sync32k);
+OMAP_SYS_32K_TIMER_INIT(3_secure, 12, OMAP3_32K_SOURCE, "ti,timer-secure",
+			2, OMAP3_MPU_SOURCE);
+OMAP_SYS_TIMER(3_secure, sync32k);
+#endif /* CONFIG_ARCH_OMAP3 */
 
 #ifdef CONFIG_SOC_AM33XX
-OMAP_SYS_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, "ti,timer-alwon",
-		    2, OMAP4_MPU_SOURCE)
-OMAP_SYS_TIMER(3_am33xx)
-#endif
+OMAP_SYS_GP_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, "ti,timer-alwon",
+		       2, OMAP4_MPU_SOURCE);
+OMAP_SYS_TIMER(3_am33xx, gptimer);
+#endif /* CONFIG_SOC_AM33XX */
 
 #ifdef CONFIG_ARCH_OMAP4
+OMAP_SYS_32K_TIMER_INIT(4, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
+			2, OMAP4_MPU_SOURCE);
 #ifdef CONFIG_LOCAL_TIMERS
-static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
-			      OMAP44XX_LOCAL_TWD_BASE, 29);
-#endif
-
-static void __init omap4_timer_init(void)
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, OMAP44XX_LOCAL_TWD_BASE, 29);
+static void __init omap4_local_timer_init(void)
 {
-	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE, "ti,timer-alwon");
-	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
-#ifdef CONFIG_LOCAL_TIMERS
+	omap4_sync32k_timer_init();
 	/* Local timers are not supprted on OMAP4430 ES1.0 */
 	if (omap_rev() != OMAP4430_REV_ES1_0) {
 		int err;
@@ -653,26 +623,32 @@ static void __init omap4_timer_init(void)
 		if (err)
 			pr_err("twd_local_timer_register failed %d\n", err);
 	}
-#endif
 }
-OMAP_SYS_TIMER(4)
-#endif
+#else /* CONFIG_LOCAL_TIMERS */
+static inline void omap4_local_timer_init(void)
+{
+	omap4_sync32_timer_init();
+}
+#endif /* CONFIG_LOCAL_TIMERS */
+OMAP_SYS_TIMER(4, local);
+#endif /* CONFIG_ARCH_OMAP4 */
 
 #ifdef CONFIG_SOC_OMAP5
-static void __init omap5_timer_init(void)
+OMAP_SYS_32K_TIMER_INIT(5, 1, OMAP4_32K_SOURCE, "ti,timer-alwon",
+			2, OMAP4_MPU_SOURCE);
+static void __init omap5_realtime_timer_init(void)
 {
 	int err;
 
-	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE, "ti,timer-alwon");
-	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
+	omap5_sync32k_timer_init();
 	realtime_counter_init();
 
 	err = arch_timer_of_register();
 	if (err)
 		pr_err("%s: arch_timer_register failed %d\n", __func__, err);
 }
-OMAP_SYS_TIMER(5)
-#endif
+OMAP_SYS_TIMER(5, realtime);
+#endif /* CONFIG_SOC_OMAP5 */
 
 /**
  * omap_timer_init - build and register timer device with an

commit 258e84af9799b8c81cf856dcbd8e2d4cc082741d
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Nov 15 13:09:03 2012 -0600

    ARM: OMAP2+: Fix compiler warning for 32k timer
    
    Commit "ARM: OMAP2+: Add device-tree support for 32kHz counter"
    added structure omap_counter_match to the OMAP2 timer code. When
    CONFIG_OMAP_32K_TIMER is not defined this structure generates the
    following as it is not used.
    
      CC      arch/arm/mach-omap2/timer.o
      arch/arm/mach-omap2/timer.c:163:28: warning: 'omap_counter_match'
      defined but not used [-Wunused-variable]
    
    Move the definition of omap_counter_match to avoid this warning when
    CONFIG_OMAP_32K_TIMER is not set.
    
    Thanks to Kevin Hilman for tracking down and reporting this problem.
    
    Reported-by: Kevin Hilam <khilman@deeprootsystems.com>
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 4daa8b41c522..b7f43a28e41f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -162,11 +162,6 @@ static struct of_device_id omap_timer_match[] __initdata = {
 	{ }
 };
 
-static struct of_device_id omap_counter_match[] __initdata = {
-	{ .compatible = "ti,omap-counter32k", },
-	{ }
-};
-
 /**
  * omap_get_timer_dt - get a timer using device-tree
  * @match	- device-tree match structure for matching a device type
@@ -406,6 +401,11 @@ static u32 notrace dmtimer_read_sched_clock(void)
 }
 
 #ifdef CONFIG_OMAP_32K_TIMER
+static struct of_device_id omap_counter_match[] __initdata = {
+	{ .compatible = "ti,omap-counter32k", },
+	{ }
+};
+
 /* Setup free-running counter for clocksource */
 static int __init omap2_sync32k_clocksource_init(void)
 {

commit 40fc3bb56ed125aa22c0a85c816ae0f923519146
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Sep 28 11:34:49 2012 -0500

    ARM: OMAP: Add platform data header for DMTIMERs
    
    Move definition of dmtimer platform data structure in to its own header
    under <linux/platform_data>.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 1a662dfdda11..4daa8b41c522 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -39,6 +39,8 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/dmtimer-omap.h>
 
 #include <asm/mach/time.h>
 #include <asm/smp_twd.h>

commit f88095ba07c312fd4b309545553e1492cb227227
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Nov 9 17:07:39 2012 -0600

    ARM: OMAP2+: Remove unnecessary local variable in timer code
    
    The function omap_dm_timer_init_one() declares two local variables of
    type int that are used to store the return value of functions called.
    One such local variable is sufficient and so remove one of these local
    variables.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index e9fcc5faff5c..1a662dfdda11 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -246,8 +246,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	struct device_node *np;
 	struct omap_hwmod *oh;
 	struct resource irq, mem;
-	int res = 0;
-	int r;
+	int r = 0;
 
 	if (of_have_populated_dt()) {
 		np = omap_get_timer_dt(omap_timer_match, NULL);
@@ -307,10 +306,10 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 		src = clk_get(NULL, fck_source);
 		if (IS_ERR(src)) {
-			res = -EINVAL;
+			r = -EINVAL;
 		} else {
-			res = clk_set_parent(timer->fclk, src);
-			if (IS_ERR_VALUE(res))
+			r = clk_set_parent(timer->fclk, src);
+			if (IS_ERR_VALUE(r))
 				pr_warn("%s: %s cannot set source\n",
 					__func__, oh->name);
 			clk_put(src);
@@ -331,7 +330,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	timer->rate = clk_get_rate(timer->fclk);
 	timer->reserved = 1;
 
-	return res;
+	return r;
 }
 
 static void __init omap2_gp_clockevent_init(int gptimer_id,

commit 61b001c564b75bfb47bfb84b33008fc2a35c9a84
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Sep 28 18:03:29 2012 -0500

    ARM: OMAP: Don't store timers physical address
    
    The OMAP2+ system timer code stores the physical address of the timer
    but never uses it. Remove this and clean-up the code by removing the
    local variable "size" and changing the names of the local variables
    mem_rsrc and irq_rsrc to mem and irq, respectively.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 099e4060afe9..e9fcc5faff5c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -245,8 +245,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	const char *oh_name;
 	struct device_node *np;
 	struct omap_hwmod *oh;
-	struct resource irq_rsrc, mem_rsrc;
-	size_t size;
+	struct resource irq, mem;
 	int res = 0;
 	int r;
 
@@ -280,20 +279,18 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 	if (!of_have_populated_dt()) {
 		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL,
-						   &irq_rsrc);
+						   &irq);
 		if (r)
 			return -ENXIO;
-		timer->irq = irq_rsrc.start;
+		timer->irq = irq.start;
 
 		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_MEM, NULL,
-						   &mem_rsrc);
+						   &mem);
 		if (r)
 			return -ENXIO;
-		timer->phys_base = mem_rsrc.start;
-		size = mem_rsrc.end - mem_rsrc.start;
 
 		/* Static mapping, never released */
-		timer->io_base = ioremap(timer->phys_base, size);
+		timer->io_base = ioremap(mem.start, mem.end - mem.start);
 	}
 
 	if (!timer->io_base)

commit b1538832191d59e29b1077e64cf416a7617b45bc
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Sep 28 11:43:30 2012 -0500

    ARM: OMAP: Remove __omap_dm_timer_set_source function
    
    The __omap_dm_timer_set_source() function is only used by the system timer
    (clock-events and clock-source) code for OMAP2+ devices. Therefore, we can
    remove this code from the dmtimer driver and move it to the system timer
    code for OMAP2+ devices.
    
    The current __omap_dm_timer_set_source() function calls clk_disable() before
    calling clk_set_parent() and clk_enable() afterwards. We can avoid these calls
    to clk_disable/enable by moving the calls to omap_hwmod_setup_one() and
    omap_hwmod_enable() to after the call to clk_set_parent() in
    omap_dm_timer_init_one().
    
    The function omap_hwmod_setup_one() will enable the timers functional clock
    and therefore increment the use-count of the functional clock to 1.
    clk_set_parent() will fail if the use-count is not 0 when called. Hence, if
    omap_hwmod_setup_one() is called before clk_set_parent(), we will need to call
    clk_disable() before calling clk_set_parent() to decrement the use-count.
    Hence, avoid these extra calls to disable and enable the functional clock by
    moving the calls to omap_hwmod_setup_one() and omap_hwmod_enable() to after
    clk_set_parent().
    
    We can also remove the delay from the __omap_dm_timer_set_source() function
    because enabling the clock will now be handled via the HWMOD framework by
    calling omap_hwmod_setup_one(). Therefore, by moving the calls to
    omap_hwmod_setup_one() and omap_hwmod_enable() to after the call to
    clk_set_parent(), we can simply replace __omap_dm_timer_set_source() with
    clk_set_parent().
    
    It should be safe to move these hwmod calls to later in the
    omap_dm_timer_init_one() because other calls to the hwmod layer that occur
    before are just requesting resource information.
    
    Testing includes boot testing on OMAP2420 H4, OMAP3430 SDP and OMAP4430 Blaze
    with the following configurations:
    1. CONFIG_OMAP_32K_TIMER=y
    2. CONFIG_OMAP_32K_TIMER=y and boot parameter "clocksource=gp_timer"
    3. CONFIG_OMAP_32K_TIMER not set
    4. CONFIG_OMAP_32K_TIMER not set and boot parameter "clocksource=gp_timer"
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 19765bd96c8e..099e4060afe9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -274,9 +274,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		oh_name = name;
 	}
 
-	omap_hwmod_setup_one(oh_name);
 	oh = omap_hwmod_lookup(oh_name);
-
 	if (!oh)
 		return -ENODEV;
 
@@ -306,8 +304,6 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (IS_ERR(timer->fclk))
 		return -ENODEV;
 
-	omap_hwmod_enable(oh);
-
 	/* FIXME: Need to remove hard-coded test on timer ID */
 	if (gptimer_id != 12) {
 		struct clk *src;
@@ -316,13 +312,16 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		if (IS_ERR(src)) {
 			res = -EINVAL;
 		} else {
-			res = __omap_dm_timer_set_source(timer->fclk, src);
+			res = clk_set_parent(timer->fclk, src);
 			if (IS_ERR_VALUE(res))
 				pr_warn("%s: %s cannot set source\n",
 					__func__, oh->name);
 			clk_put(src);
 		}
 	}
+
+	omap_hwmod_setup_one(oh_name);
+	omap_hwmod_enable(oh);
 	__omap_dm_timer_init_regs(timer);
 
 	if (posted)

commit 10759e823c83e6c88b58264daa791bb82c7ebad9
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Wed Jul 11 13:00:13 2012 -0500

    ARM: OMAP2+: Don't use __omap_dm_timer_reset()
    
    Currently OMAP2+ devices are using the function __omap_dm_timer_reset() to
    configure the clock-activity, idle, wakeup-enable and auto-idle fields in the
    timer OCP_CFG register. The name of the function is mis-leading because this
    function does not actually perform a reset of the timer.
    
    For OMAP2+ devices, HWMOD is responsible for reseting and configuring the
    timer OCP_CFG register. Therefore, do not use __omap_dm_timer_reset() for
    OMAP2+ devices and rely on HWMOD. Furthermore, some timer instances do not
    have the fields clock-activity, wakeup-enable and auto-idle and so this
    function could configure the OCP_CFG register incorrectly.
    
    Currently HWMOD is not configuring the clock-activity field in the OCP_CFG
    register for timers that have this field. Commit 0f0d080 (ARM: OMAP: DMTimer:
    Use posted mode) configures the clock-activity field to keep the f-clk enabled
    so that the wake-up capability is enabled. Therefore, add the appropriate flags
    to the timer HWMOD structures to configure this field in the same way.
    
    For OMAP2/3 devices all dmtimers have the clock-activity field, where as for
    OMAP4 devices, only dmtimer 1, 2 and 10 have the clock-activity field.
    
    Verified on OMAP2420 H4, OMAP3430 Beagle and OMAP4430 Panda that HWMOD is
    configuring the dmtimer OCP_CFG register as expected for clock-events timer.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 63229c5287e6..19765bd96c8e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -324,7 +324,6 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		}
 	}
 	__omap_dm_timer_init_regs(timer);
-	__omap_dm_timer_reset(timer, 1, 1);
 
 	if (posted)
 		__omap_dm_timer_enable_posted(timer);

commit bfd6d021120d5994c4cc94d87ec03642be1540e7
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Sep 27 12:47:43 2012 -0500

    ARM: OMAP3+: Implement timer workaround for errata i103 and i767
    
    Errata Titles:
    i103: Delay needed to read some GP timer, WD timer and sync timer
          registers after wakeup (OMAP3/4)
    i767: Delay needed to read some GP timer registers after wakeup (OMAP5)
    
    Description (i103/i767):
    If a General Purpose Timer (GPTimer) is in posted mode
    (TSICR [2].POSTED=1), due to internal resynchronizations, values read in
    TCRR, TCAR1 and TCAR2 registers right after the timer interface clock
    (L4) goes from stopped to active may not return the expected values. The
    most common event leading to this situation occurs upon wake up from
    idle.
    
    GPTimer non-posted synchronization mode is not impacted by this
    limitation.
    
    Workarounds:
    1). Disable posted mode
    2). Use static dependency between timer clock domain and MPUSS clock
        domain
    3). Use no-idle mode when the timer is active
    
    Workarounds #2 and #3 are not pratical from a power standpoint and so
    workaround #1 has been implemented. Disabling posted mode adds some CPU
    overhead for configuring and reading the timers as the CPU has to wait
    for accesses to be re-synchronised within the timer. However, disabling
    posted mode guarantees correct operation.
    
    Please note that it is safe to use posted mode for timers if the counter
    (TCRR) and capture (TCARx) registers will never be read. An example of
    this is the clock-event system timer. This is used by the kernel to
    schedule events however, the timers counter is never read and capture
    registers are not used. Given that the kernel configures this timer
    often yet never reads the counter register it is safe to enable posted
    mode in this case. Hence, for the timer used for kernel clock-events,
    posted mode is enabled by overriding the errata for devices that are
    impacted by this defect.
    
    For drivers using the timers that do not read the counter or capture
    registers and wish to use posted mode, can override the errata and
    enable posted mode by making the following function calls.
    
            __omap_dm_timer_override_errata(timer, OMAP_TIMER_ERRATA_I103_I767);
            __omap_dm_timer_enable_posted(timer);
    
    Both dmtimers and watchdogs are impacted by this defect this patch only
    implements the workaround for the dmtimer. Currently the watchdog driver
    does not read the counter register and so no workaround is necessary.
    
    Posted mode will be disabled for all OMAP2+ devices (including AM33xx)
    using a GP timer as a clock-source timer to guarantee correct operation.
    This is not necessary for OMAP24xx devices but the default clock-source
    timer for OMAP24xx devices is the 32k-sync timer and not the GP timer
    and so should not have any impact. This should be re-visited for future
    devices if this errata is fixed.
    
    Confirmed with Vaibhav Hiremath that this bug also impacts AM33xx
    devices.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index a135d28e202c..63229c5287e6 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -222,10 +222,24 @@ void __init omap_dmtimer_init(void)
 	}
 }
 
+/**
+ * omap_dm_timer_get_errata - get errata flags for a timer
+ *
+ * Get the timer errata flags that are specific to the OMAP device being used.
+ */
+u32 __init omap_dm_timer_get_errata(void)
+{
+	if (cpu_is_omap24xx())
+		return 0;
+
+	return OMAP_TIMER_ERRATA_I103_I767;
+}
+
 static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 						int gptimer_id,
 						const char *fck_source,
-						const char *property)
+						const char *property,
+						int posted)
 {
 	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
 	const char *oh_name;
@@ -311,10 +325,15 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	}
 	__omap_dm_timer_init_regs(timer);
 	__omap_dm_timer_reset(timer, 1, 1);
-	timer->posted = 1;
 
-	timer->rate = clk_get_rate(timer->fclk);
+	if (posted)
+		__omap_dm_timer_enable_posted(timer);
+
+	/* Check that the intended posted configuration matches the actual */
+	if (posted != timer->posted)
+		return -EINVAL;
 
+	timer->rate = clk_get_rate(timer->fclk);
 	timer->reserved = 1;
 
 	return res;
@@ -326,7 +345,17 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 {
 	int res;
 
-	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source, property);
+	clkev.errata = omap_dm_timer_get_errata();
+
+	/*
+	 * For clock-event timers we never read the timer counter and
+	 * so we are not impacted by errata i103 and i767. Therefore,
+	 * we can safely ignore this errata for clock-event timers.
+	 */
+	__omap_dm_timer_override_errata(&clkev, OMAP_TIMER_ERRATA_I103_I767);
+
+	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source, property,
+				     OMAP_TIMER_POSTED);
 	BUG_ON(res);
 
 	omap2_gp_timer_irq.dev_id = &clkev;
@@ -360,7 +389,7 @@ static bool use_gptimer_clksrc;
 static cycle_t clocksource_read_cycles(struct clocksource *cs)
 {
 	return (cycle_t)__omap_dm_timer_read_counter(&clksrc,
-						     OMAP_TIMER_POSTED);
+						     OMAP_TIMER_NONPOSTED);
 }
 
 static struct clocksource clocksource_gpt = {
@@ -375,7 +404,7 @@ static u32 notrace dmtimer_read_sched_clock(void)
 {
 	if (clksrc.reserved)
 		return __omap_dm_timer_read_counter(&clksrc,
-						    OMAP_TIMER_POSTED);
+						    OMAP_TIMER_NONPOSTED);
 
 	return 0;
 }
@@ -453,12 +482,15 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 {
 	int res;
 
-	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, NULL);
+	clksrc.errata = omap_dm_timer_get_errata();
+
+	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, NULL,
+				     OMAP_TIMER_NONPOSTED);
 	BUG_ON(res);
 
 	__omap_dm_timer_load_start(&clksrc,
 				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0,
-				   OMAP_TIMER_POSTED);
+				   OMAP_TIMER_NONPOSTED);
 	setup_sched_clock(dmtimer_read_sched_clock, 32, clksrc.rate);
 
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
@@ -696,6 +728,7 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;
 
+	pdata->timer_errata = omap_dm_timer_get_errata();
 	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
 
 	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata),

commit 971d0254480572bc6dc5574c28ef8fe014660a31
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Sep 27 11:49:45 2012 -0500

    ARM: OMAP: Add DMTIMER definitions for posted mode
    
    For OMAP2+ devices, when using DMTIMERs for system timers (clock-events and
    clock-source) the posted mode configuration of the timers is used. To allow
    the compiler to optimise the functions for configuring and reading the system
    timers, the posted flag variable is hard-coded with the value 1. To make it
    clear that posted mode is being used add some definitions so that it is more
    readable.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 684d2fc3d485..a135d28e202c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -108,7 +108,7 @@ static int omap2_gp_timer_set_next_event(unsigned long cycles,
 					 struct clock_event_device *evt)
 {
 	__omap_dm_timer_load_start(&clkev, OMAP_TIMER_CTRL_ST,
-						0xffffffff - cycles, 1);
+				   0xffffffff - cycles, OMAP_TIMER_POSTED);
 
 	return 0;
 }
@@ -118,7 +118,7 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 {
 	u32 period;
 
-	__omap_dm_timer_stop(&clkev, 1, clkev.rate);
+	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -126,10 +126,10 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 		period -= 1;
 		/* Looks like we need to first set the load value separately */
 		__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG,
-					0xffffffff - period, 1);
+				      0xffffffff - period, OMAP_TIMER_POSTED);
 		__omap_dm_timer_load_start(&clkev,
 					OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
-						0xffffffff - period, 1);
+					0xffffffff - period, OMAP_TIMER_POSTED);
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
 		break;
@@ -359,7 +359,8 @@ static bool use_gptimer_clksrc;
  */
 static cycle_t clocksource_read_cycles(struct clocksource *cs)
 {
-	return (cycle_t)__omap_dm_timer_read_counter(&clksrc, 1);
+	return (cycle_t)__omap_dm_timer_read_counter(&clksrc,
+						     OMAP_TIMER_POSTED);
 }
 
 static struct clocksource clocksource_gpt = {
@@ -373,7 +374,8 @@ static struct clocksource clocksource_gpt = {
 static u32 notrace dmtimer_read_sched_clock(void)
 {
 	if (clksrc.reserved)
-		return __omap_dm_timer_read_counter(&clksrc, 1);
+		return __omap_dm_timer_read_counter(&clksrc,
+						    OMAP_TIMER_POSTED);
 
 	return 0;
 }
@@ -455,7 +457,8 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 	BUG_ON(res);
 
 	__omap_dm_timer_load_start(&clksrc,
-			OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0, 1);
+				   OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0,
+				   OMAP_TIMER_POSTED);
 	setup_sched_clock(dmtimer_read_sched_clock, 32, clksrc.rate);
 
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))

commit f56f52e02a9c3da4bc2cc6eb9ddcf5602ea44b37
Merge: 84fbd2b8c8da 6ba54ab4a49b
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 9 14:54:17 2012 -0800

    Merge branch 'omap-for-v3.8/cleanup-headers-prepare-multiplatform-v3' into omap-for-v3.8/dt
    
    Conflicts:
            arch/arm/plat-omap/dmtimer.c
    
    Resolved as suggested by Jon Hunter.

commit 9883f7c8dd21acb90697582ca331f3f8a66ac054
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Oct 9 14:12:26 2012 -0500

    ARM: OMAP2+: Add device-tree support for 32kHz counter
    
    For OMAP devices, the 32kHz counter is the default clock-source for the kernel.
    However, this is not the only possible clock-source the kernel can use for OMAP
    devices.
    
    When booting with device-tree, if the 32kHz counter is the desired clock-source
    for the kernel, then parse the device-tree blob to ensure that the counter is
    present and if so map memory for the counter using the device-tree of_iomap()
    function so we are no longer reliant on the OMAP HWMOD framework to do this for
    us.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 92447cd7a41a..0758bae3a57a 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -159,6 +159,11 @@ static struct of_device_id omap_timer_match[] __initdata = {
 	{ }
 };
 
+static struct of_device_id omap_counter_match[] __initdata = {
+	{ .compatible = "ti,omap-counter32k", },
+	{ }
+};
+
 /**
  * omap_get_timer_dt - get a timer using device-tree
  * @match	- device-tree match structure for matching a device type
@@ -377,10 +382,25 @@ static u32 notrace dmtimer_read_sched_clock(void)
 static int __init omap2_sync32k_clocksource_init(void)
 {
 	int ret;
+	struct device_node *np = NULL;
 	struct omap_hwmod *oh;
 	void __iomem *vbase;
 	const char *oh_name = "counter_32k";
 
+	/*
+	 * If device-tree is present, then search the DT blob
+	 * to see if the 32kHz counter is supported.
+	 */
+	if (of_have_populated_dt()) {
+		np = omap_get_timer_dt(omap_counter_match, NULL);
+		if (!np)
+			return -ENODEV;
+
+		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
+		if (!oh_name)
+			return -ENODEV;
+	}
+
 	/*
 	 * First check hwmod data is available for sync32k counter
 	 */
@@ -390,7 +410,13 @@ static int __init omap2_sync32k_clocksource_init(void)
 
 	omap_hwmod_setup_one(oh_name);
 
-	vbase = omap_hwmod_get_mpu_rt_va(oh);
+	if (np) {
+		vbase = of_iomap(np, 0);
+		of_node_put(np);
+	} else {
+		vbase = omap_hwmod_get_mpu_rt_va(oh);
+	}
+
 	if (!vbase) {
 		pr_warn("%s: failed to get counter_32k resource\n", __func__);
 		return -ENXIO;

commit 9725f4451a9ccd159b1d13f63e05896cd9bce07d
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Mon May 14 10:41:37 2012 -0500

    ARM: OMAP: Add DT support for timer driver
    
    In order to add device-tree support to the timer driver the following changes
    were made ...
    
    1. Allocate system timers (used for clock-events and clock-source) based upon
       timer properties rather than using an hard-coded timer instance ID. To allow
       this a new helper function called omap_dmtimer_find_by_property() has been
       added for finding a timer with the particular properties in the device-tree
       blob. Please note that this is an internal helper function for system timers
       only to find a timer in the device-tree blob. This cannot be used by device
       drivers, another API has been added for that (see below). Timers that are
       allocated for system timers are dynamically disabled at boot time by adding
       a status property with the value "disabled" to the timer's device-tree node.
    
       Please note that when allocating system timers we now pass a timer ID and
       timer property. The timer ID is only be used for allocating a timer when
       booting without device-tree. Once device-tree migration is complete, all
       the timer ID references will be removed.
    
    2. System timer resources (memory and interrupts) are directly obtained from
       the device-tree timer node when booting with device-tree, so that system
       timers are no longer reliant upon the OMAP HWMOD framework to provide these
       resources.
    
    3. If DT blob is present, then let device-tree create the timer devices
       dynamically.
    
    4. When device-tree is present the "id" field in the platform_device structure
       (pdev->id) is initialised to -1 and hence cannot be used to identify a timer
       instance. Due to this the following changes were made ...
       a). The API omap_dm_timer_request_specific() is not supported when using
           device-tree, because it uses the device ID to request a specific timer.
           This function will return an error if called when device-tree is present.
           Users of this API should use omap_dm_timer_request_by_cap() instead.
       b). When removing the DMTIMER driver, the timer "id" was used to identify the
           timer instance. The remove function has been modified to use the device
           name instead of the "id".
    
    5. When device-tree is present the platform_data structure will be NULL and so
       check for this.
    
    6. The OMAP timer device tree binding has the following optional parameters ...
       a). ti,timer-alwon  --> Timer is in an always-on power domain
       b). ti,timer-dsp    --> Timer can generate an interrupt to the on-chip DSP
       c). ti,timer-pwm    --> Timer can generate a PWM output
       d). ti,timer-secure --> Timer is reserved on a secure OMAP device
       Search for the above parameters and set the appropriate timer attribute
       flags.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index def9a0ebe42d..92447cd7a41a 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -37,6 +37,8 @@
 #include <linux/clockchips.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/mach/time.h>
 #include <asm/smp_twd.h>
@@ -66,11 +68,13 @@
 #define OMAP3_CLKEV_SOURCE	OMAP3_32K_SOURCE
 #define OMAP4_CLKEV_SOURCE	OMAP4_32K_SOURCE
 #define OMAP3_SECURE_TIMER	12
+#define TIMER_PROP_SECURE	"ti,timer-secure"
 #else
 #define OMAP2_CLKEV_SOURCE	OMAP2_MPU_SOURCE
 #define OMAP3_CLKEV_SOURCE	OMAP3_MPU_SOURCE
 #define OMAP4_CLKEV_SOURCE	OMAP4_MPU_SOURCE
 #define OMAP3_SECURE_TIMER	1
+#define TIMER_PROP_SECURE	"ti,timer-alwon"
 #endif
 
 #define REALTIME_COUNTER_BASE				0x48243200
@@ -155,6 +159,40 @@ static struct of_device_id omap_timer_match[] __initdata = {
 	{ }
 };
 
+/**
+ * omap_get_timer_dt - get a timer using device-tree
+ * @match	- device-tree match structure for matching a device type
+ * @property	- optional timer property to match
+ *
+ * Helper function to get a timer during early boot using device-tree for use
+ * as kernel system timer. Optionally, the property argument can be used to
+ * select a timer with a specific property. Once a timer is found then mark
+ * the timer node in device-tree as disabled, to prevent the kernel from
+ * registering this timer as a platform device and so no one else can use it.
+ */
+static struct device_node * __init omap_get_timer_dt(struct of_device_id *match,
+						     const char *property)
+{
+	struct device_node *np;
+
+	for_each_matching_node(np, match) {
+		if (!of_device_is_available(np)) {
+			of_node_put(np);
+			continue;
+		}
+
+		if (property && !of_get_property(np, property, NULL)) {
+			of_node_put(np);
+			continue;
+		}
+
+		prom_add_property(np, &device_disabled);
+		return np;
+	}
+
+	return NULL;
+}
+
 /**
  * omap_dmtimer_init - initialisation function when device tree is used
  *
@@ -172,43 +210,74 @@ void __init omap_dmtimer_init(void)
 
 	/* If we are a secure device, remove any secure timer nodes */
 	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)) {
-		for_each_matching_node(np, omap_timer_match) {
-			if (of_get_property(np, "ti,timer-secure", NULL))
-				prom_add_property(np, &device_disabled);
-		}
+		np = omap_get_timer_dt(omap_timer_match, "ti,timer-secure");
+		if (np)
+			of_node_put(np);
 	}
 }
 
 static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 						int gptimer_id,
-						const char *fck_source)
+						const char *fck_source,
+						const char *property)
 {
 	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
+	const char *oh_name;
+	struct device_node *np;
 	struct omap_hwmod *oh;
 	struct resource irq_rsrc, mem_rsrc;
 	size_t size;
 	int res = 0;
 	int r;
 
-	sprintf(name, "timer%d", gptimer_id);
-	omap_hwmod_setup_one(name);
-	oh = omap_hwmod_lookup(name);
+	if (of_have_populated_dt()) {
+		np = omap_get_timer_dt(omap_timer_match, NULL);
+		if (!np)
+			return -ENODEV;
+
+		of_property_read_string_index(np, "ti,hwmods", 0, &oh_name);
+		if (!oh_name)
+			return -ENODEV;
+
+		timer->irq = irq_of_parse_and_map(np, 0);
+		if (!timer->irq)
+			return -ENXIO;
+
+		timer->io_base = of_iomap(np, 0);
+
+		of_node_put(np);
+	} else {
+		if (omap_dm_timer_reserve_systimer(gptimer_id))
+			return -ENODEV;
+
+		sprintf(name, "timer%d", gptimer_id);
+		oh_name = name;
+	}
+
+	omap_hwmod_setup_one(oh_name);
+	oh = omap_hwmod_lookup(oh_name);
+
 	if (!oh)
 		return -ENODEV;
 
-	r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL, &irq_rsrc);
-	if (r)
-		return -ENXIO;
-	timer->irq = irq_rsrc.start;
-
-	r = omap_hwmod_get_resource_byname(oh, IORESOURCE_MEM, NULL, &mem_rsrc);
-	if (r)
-		return -ENXIO;
-	timer->phys_base = mem_rsrc.start;
-	size = mem_rsrc.end - mem_rsrc.start;
+	if (!of_have_populated_dt()) {
+		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL,
+						   &irq_rsrc);
+		if (r)
+			return -ENXIO;
+		timer->irq = irq_rsrc.start;
+
+		r = omap_hwmod_get_resource_byname(oh, IORESOURCE_MEM, NULL,
+						   &mem_rsrc);
+		if (r)
+			return -ENXIO;
+		timer->phys_base = mem_rsrc.start;
+		size = mem_rsrc.end - mem_rsrc.start;
+
+		/* Static mapping, never released */
+		timer->io_base = ioremap(timer->phys_base, size);
+	}
 
-	/* Static mapping, never released */
-	timer->io_base = ioremap(timer->phys_base, size);
 	if (!timer->io_base)
 		return -ENXIO;
 
@@ -219,9 +288,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 	omap_hwmod_enable(oh);
 
-	if (omap_dm_timer_reserve_systimer(gptimer_id))
-		return -ENODEV;
-
+	/* FIXME: Need to remove hard-coded test on timer ID */
 	if (gptimer_id != 12) {
 		struct clk *src;
 
@@ -231,8 +298,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		} else {
 			res = __omap_dm_timer_set_source(timer->fclk, src);
 			if (IS_ERR_VALUE(res))
-				pr_warning("%s: timer%i cannot set source\n",
-						__func__, gptimer_id);
+				pr_warn("%s: %s cannot set source\n",
+					__func__, oh->name);
 			clk_put(src);
 		}
 	}
@@ -248,11 +315,12 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 }
 
 static void __init omap2_gp_clockevent_init(int gptimer_id,
-						const char *fck_source)
+						const char *fck_source,
+						const char *property)
 {
 	int res;
 
-	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source);
+	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source, property);
 	BUG_ON(res);
 
 	omap2_gp_timer_irq.dev_id = &clkev;
@@ -356,7 +424,7 @@ static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 {
 	int res;
 
-	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source);
+	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source, NULL);
 	BUG_ON(res);
 
 	__omap_dm_timer_load_start(&clksrc,
@@ -468,12 +536,12 @@ static inline void __init realtime_counter_init(void)
 {}
 #endif
 
-#define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src,			\
+#define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src, clkev_prop,	\
 				clksrc_nr, clksrc_src)			\
 static void __init omap##name##_timer_init(void)			\
 {									\
 	omap_dmtimer_init();						\
-	omap2_gp_clockevent_init((clkev_nr), clkev_src);		\
+	omap2_gp_clockevent_init((clkev_nr), clkev_src, clkev_prop);	\
 	omap2_clocksource_init((clksrc_nr), clksrc_src);		\
 }
 
@@ -483,20 +551,23 @@ struct sys_timer omap##name##_timer = {					\
 };
 
 #ifdef CONFIG_ARCH_OMAP2
-OMAP_SYS_TIMER_INIT(2, 1, OMAP2_CLKEV_SOURCE, 2, OMAP2_MPU_SOURCE)
+OMAP_SYS_TIMER_INIT(2, 1, OMAP2_CLKEV_SOURCE, "ti,timer-alwon",
+		    2, OMAP2_MPU_SOURCE)
 OMAP_SYS_TIMER(2)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP3
-OMAP_SYS_TIMER_INIT(3, 1, OMAP3_CLKEV_SOURCE, 2, OMAP3_MPU_SOURCE)
+OMAP_SYS_TIMER_INIT(3, 1, OMAP3_CLKEV_SOURCE, "ti,timer-alwon",
+		    2, OMAP3_MPU_SOURCE)
 OMAP_SYS_TIMER(3)
 OMAP_SYS_TIMER_INIT(3_secure, OMAP3_SECURE_TIMER, OMAP3_CLKEV_SOURCE,
-			2, OMAP3_MPU_SOURCE)
+			TIMER_PROP_SECURE, 2, OMAP3_MPU_SOURCE)
 OMAP_SYS_TIMER(3_secure)
 #endif
 
 #ifdef CONFIG_SOC_AM33XX
-OMAP_SYS_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, 2, OMAP4_MPU_SOURCE)
+OMAP_SYS_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, "ti,timer-alwon",
+		    2, OMAP4_MPU_SOURCE)
 OMAP_SYS_TIMER(3_am33xx)
 #endif
 
@@ -508,7 +579,7 @@ static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
 
 static void __init omap4_timer_init(void)
 {
-	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
+	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE, "ti,timer-alwon");
 	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
 #ifdef CONFIG_LOCAL_TIMERS
 	/* Local timers are not supprted on OMAP4430 ES1.0 */
@@ -534,7 +605,7 @@ static void __init omap5_timer_init(void)
 {
 	int err;
 
-	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
+	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE, "ti,timer-alwon");
 	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
 	realtime_counter_init();
 
@@ -619,6 +690,10 @@ static int __init omap2_dm_timer_init(void)
 {
 	int ret;
 
+	/* If dtb is there, the devices will be created dynamically */
+	if (of_have_populated_dt())
+		return -ENODEV;
+
 	ret = omap_hwmod_for_each_by_class("timer", omap_timer_init, NULL);
 	if (unlikely(ret)) {
 		pr_err("%s: device registration failed.\n", __func__);

commit ad24bde8f1025da014108493b595bed22d989efb
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Wed Jun 20 15:55:24 2012 -0500

    ARM: OMAP3: Dynamically disable secure timer nodes for secure devices
    
    OMAP3 devices may or may not have security features enabled. Security enabled
    devices are known as high-secure (HS) and devices without security are known as
    general purpose (GP).
    
    For OMAP3 devices there are 12 general purpose timers available. On secure
    devices the 12th timer is reserved for secure usage and so cannot be used by
    the kernel, where as for a GP device it is available. We can detect the OMAP
    device type, secure or GP, at runtime via an on-chip register. Today, when not
    using DT, we do not register the 12th timer as a linux device if the device is
    secure.
    
    When using device tree, device tree is going to register all the timer devices
    it finds in the device tree blob. To prevent device tree from registering 12th
    timer on a secure OMAP3 device we can add a status property to the timer
    binding with the value "disabled" at boot time. Note that timer 12 on a OMAP3
    device has a property "ti,timer-secure" to indicate that it will not be
    available on a secure device and so for secure OMAP3 devices, we search for
    timers with this property and then disable them. Using the prom_add_property()
    function to dynamically add a property was a recommended approach suggested by
    Rob Herring [1].
    
    I have tested this on an OMAP3 GP device and faking it to pretend to be a
    secure device to ensure that any timers marked with "ti,timer-secure" are not
    registered on boot. I have also made sure that all timers are registered as
    expected on a GP device by default.
    
    [1] http://comments.gmane.org/gmane.linux.ports.arm.omap/79203
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 69e46631a7cd..def9a0ebe42d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -144,6 +144,41 @@ static struct clock_event_device clockevent_gpt = {
 	.set_mode	= omap2_gp_timer_set_mode,
 };
 
+static struct property device_disabled = {
+	.name = "status",
+	.length = sizeof("disabled"),
+	.value = "disabled",
+};
+
+static struct of_device_id omap_timer_match[] __initdata = {
+	{ .compatible = "ti,omap2-timer", },
+	{ }
+};
+
+/**
+ * omap_dmtimer_init - initialisation function when device tree is used
+ *
+ * For secure OMAP3 devices, timers with device type "timer-secure" cannot
+ * be used by the kernel as they are reserved. Therefore, to prevent the
+ * kernel registering these devices remove them dynamically from the device
+ * tree on boot.
+ */
+void __init omap_dmtimer_init(void)
+{
+	struct device_node *np;
+
+	if (!cpu_is_omap34xx())
+		return;
+
+	/* If we are a secure device, remove any secure timer nodes */
+	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)) {
+		for_each_matching_node(np, omap_timer_match) {
+			if (of_get_property(np, "ti,timer-secure", NULL))
+				prom_add_property(np, &device_disabled);
+		}
+	}
+}
+
 static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 						int gptimer_id,
 						const char *fck_source)
@@ -437,6 +472,7 @@ static inline void __init realtime_counter_init(void)
 				clksrc_nr, clksrc_src)			\
 static void __init omap##name##_timer_init(void)			\
 {									\
+	omap_dmtimer_init();						\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src);		\
 	omap2_clocksource_init((clksrc_nr), clksrc_src);		\
 }

commit 5c2e88525b5f1cdc72c9eefba72dae13be7e5d20
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 16:45:47 2012 -0700

    ARM: OMAP: Remove plat-omap/common.h
    
    Most of the prototypes in plat-omap/common.h are not
    common to omap1 and omap2+, they are local to omap2+
    and should not be in plat-omap/common.h.
    
    The only shared function prototype in this file is
    omap_init_clocksource_32k(), let's put that into
    counter-32k.h.
    
    Note that the new plat/counter-32k.h must not be
    included from drivers, that will break omap2+ build
    for CONFIG_MULTIPLATFORM.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 95e447890cd5..c5bc2cb4d8d3 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -45,6 +45,7 @@
 #include <asm/arch_timer.h>
 #include "omap_hwmod.h"
 #include "omap_device.h"
+#include <plat/counter-32k.h>
 #include <plat/dmtimer.h>
 #include "omap-pm.h"
 

commit 6e740f9a85339c295af8deb5376511fcb2a268ad
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 15:20:45 2012 -0700

    ARM: OMAP: Move omap-pm-noop.c local to mach-omap2
    
    This code should be private to mach-omap2.
    
    The only use for it in for omap1 has been in dmtimer.c
    to check for context loss. However, omap1 does not
    lose context during idle, so the code is not needed.
    Further, omap1 timer has OMAP_TIMER_ALWON set, so omap1
    was not hitting omap_pm_get_dev_context_loss_count()
    test.
    
    Cc: Jon Hunter <jon-hunter@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 565e5755c9bc..95e447890cd5 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -559,6 +559,8 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;
 
+	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
+
 	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
 				 NULL, 0, 0);
 

commit 3e9a6321f9895eac9a3d241d3126e44021e7102b
Merge: 54ec52b6dd3b e4c060db2c13
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 13:25:44 2012 -0700

    Merge tag 'omap-for-v3.8/cleanup-headers-signed' into omap-for-v3.8/cleanup-headers-serial-take2
    
    This is the first set of omap cleanup patches for v3.8 merge
    window to remove most of the remaining plat includes to get us
    closer to ARM common zImage support.
    
    To avoid a huge amount of trivial merge conflicts with includes,
    this branch is based on several small topic branches coordinated
    with the driver subsystem maintainers. These branches are based on
    v3.7-rc1 and can also be merged into the related driver subsystem
    branches as needed:
    
    omap-for-v3.8/cleanup-headers-prepare   few trivial driver changes
    omap-for-v3.8/cleanup-headers-dma       move of the DMA header
    omap-for-v3.8/cleanup-headers-gpmc      GPMC and MTD changes
    omap-for-v3.8/cleanup-headers-mmc       MMC related changes
    omap-for-v3.8/cleanup-headers-dss       DSS related changes
    omap-for-v3.8/cleanup-headers-asoc      ASoC related changes
    
    Note that for the dma-omap.h, it was decided that it should be
    is completed. For the related discussion, please see:
    
    https://patchwork.kernel.org/patch/1519591/#
    
    After these patches we still have a few plat headers remaining
    that will be handled in later pull requests.

commit 1d5aef4950717526d4827e97a916d38d0d73657e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 3 16:36:40 2012 -0700

    ARM: OMAP: Make plat/omap-pm.h local to mach-omap2
    
    We must move this for ARM common zImage support.
    
    Note that neither drivers/media/rc/ir-rx51.c or
    drivers/media/platform/omap3isp/ispvideo.c need
    to include omap-pm.h, so this patch removes the
    include for those files.
    
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Timo Kokkonen <timo.t.kokkonen@iki.fi>
    Cc: linux-media@vger.kernel.org
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b11df8230145..45598ac819be 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -46,7 +46,7 @@
 #include "omap_hwmod.h"
 #include "omap_device.h"
 #include <plat/dmtimer.h>
-#include <plat/omap-pm.h>
+#include "omap-pm.h"
 
 #include "soc.h"
 #include "common.h"

commit 2a296c8f89bc6aaf91b255c7d631fcbbfaf840ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:41:35 2012 -0700

    ARM: OMAP: Make plat/omap_hwmod.h local to mach-omap2
    
    Let's make omap_hwmod local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index a2ea2f30f7c9..b11df8230145 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -43,7 +43,7 @@
 #include <asm/sched_clock.h>
 
 #include <asm/arch_timer.h>
-#include <plat/omap_hwmod.h>
+#include "omap_hwmod.h"
 #include "omap_device.h"
 #include <plat/dmtimer.h>
 #include <plat/omap-pm.h>

commit 25c7d49ed48b4843da7dea56a81ae7f620211ee0
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:25:48 2012 -0700

    ARM: OMAP: Make omap_device local to mach-omap2
    
    Let's make omap_device local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 44f9aa7ec0c0..a2ea2f30f7c9 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -44,7 +44,7 @@
 
 #include <asm/arch_timer.h>
 #include <plat/omap_hwmod.h>
-#include <plat/omap_device.h>
+#include "omap_device.h"
 #include <plat/dmtimer.h>
 #include <plat/omap-pm.h>
 

commit 3f216ef3f451f91d98dc5c69221a507e327eef3a
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 16 11:19:16 2012 -0700

    ARM: OMAP4: Fix twd_local_timer_register regression
    
    Commit 7d7e1eba (ARM: OMAP2+: Prepare for irqs.h removal)
    changed the interrupts to allow enabling sparse IRQ, but
    accidentally added the omap3 INTC base to the local IRQ.
    This causes the following:
    
    twd: can't register interrupt 45 (-22)
    twd_local_timer_register failed -22
    
    The right fix is to not add any base, as it is a local
    timer. For the OMAP44XX_IRQ_LOCALWDT we had defined earlier
    there are no users, so no need to fix that.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 44f9aa7ec0c0..69e46631a7cd 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -467,7 +467,7 @@ OMAP_SYS_TIMER(3_am33xx)
 #ifdef CONFIG_ARCH_OMAP4
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
-			      OMAP44XX_LOCAL_TWD_BASE, 29 + OMAP_INTC_START);
+			      OMAP44XX_LOCAL_TWD_BASE, 29);
 #endif
 
 static void __init omap4_timer_init(void)

commit 533b298110475804b15b93475389736140bf4aa9
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Oct 8 15:01:41 2012 -0700

    ARM: OMAP: fix return value check in realtime_counter_init()
    
    In case of error, the function clk_get() returns ERR_PTR()
    and never returns NULL. The NULL test in the return value
    check should be replaced with IS_ERR().
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 8847d6eb2313..44f9aa7ec0c0 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -378,7 +378,7 @@ static void __init realtime_counter_init(void)
 		return;
 	}
 	sys_clk = clk_get(NULL, "sys_clkin_ck");
-	if (!sys_clk) {
+	if (IS_ERR(sys_clk)) {
 		pr_err("%s: failed to get system clock handle\n", __func__);
 		iounmap(base);
 		return;

commit 2a2bf85f05e42b12ea6bfe821e2d19221cf93555
Merge: 11801e9de269 99261fbad0a1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 18:28:06 2012 -0700

    Merge tag 'dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM soc device tree updates from Olof Johansson:
     "Device tree conversion and enablement branch.  Mostly a bunch of new
      bindings and setup for various platforms, but the Via/Winchip VT8500
      platform is also converted over from being 100% legacy to now use
      device tree for probing.  More of that will come for 3.8."
    
    Trivial conflicts due to removal of vt8500 files, and one documentation
    file that was added with slightly different contents both here and in
    the USb tree.
    
    * tag 'dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (212 commits)
      arm: vt8500: Fixup for missing gpio.h
      ARM: LPC32xx: LED fix in PHY3250 DTS file
      ARM: dt: mmp-dma: add binding file
      arm: vt8500: Update arch-vt8500 to devicetree support.
      arm: vt8500: gpio: Devicetree support for arch-vt8500
      arm: vt8500: doc: Add device tree bindings for arch-vt8500 devices
      arm: vt8500: clk: Add Common Clock Framework support
      video: vt8500: Add devicetree support for vt8500-fb and wm8505-fb
      serial: vt8500: Add devicetree support for vt8500-serial
      rtc: vt8500: Add devicetree support for vt8500-rtc
      arm: vt8500: Add device tree files for VIA/Wondermedia SoC's
      ARM: tegra: Add Avionic Design Tamonten Evaluation Carrier support
      ARM: tegra: Add Avionic Design Medcom-Wide support
      ARM: tegra: Add Avionic Design Plutux support
      ARM: tegra: Add Avionic Design Tamonten support
      ARM: tegra: dts: Add pwm label
      ARM: ux500: Fix SSP register address format
      ARM: ux500: Apply tc3589x's GPIO/IRQ properties to HREF's DT
      ARM: ux500: Remove redundant #gpio-cell properties from Snowball DT
      ARM: ux500: Add all encompassing sound node to the HREF Device Tree
      ...

commit 0c9de3c52d2baed6bc2ee44885adb418152c71c4
Merge: 6bfc82ff589a 3c7c5dab44d6
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Sep 21 13:48:01 2012 -0700

    Merge branch 'for_3.7/omap5_arch_timer' of git://github.com/SantoshShilimkar/linux into devel-dt-arch-timer
    
    Conflicts:
            arch/arm/mach-omap2/timer.c

commit 32dec75349da4e68b53f099ce3a96469cdc334d6
Merge: 740418ef19fd 9891e3240543
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 19:57:38 2012 -0700

    Merge tag 'tegra-for-3.7-dmaengine' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/cleanup
    
    ARM: tegra: switch to dmaengine
    
    The Tegra code-base has contained both a legacy DMA and a dmaengine
    driver since v3.6-rcX. This series flips Tegra's defconfig to enable
    dmaengine rather than the legacy driver, and removes the legacy driver
    and all client code.
    
    * tag 'tegra-for-3.7-dmaengine' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra:
      ASoC: tegra: remove support of legacy DMA driver based access
      spi: tegra: remove support of legacy DMA driver based access
      ARM: tegra: apbio: remove support of legacy DMA driver based access
      ARM: tegra: dma: remove legacy APB DMA driver
      ARM: tegra: config: enable dmaengine based APB DMA driver
      + sync to 3.6-rc6

commit 3c7c5dab44d6c8861bc86dab924353d8d40344f8
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Aug 13 14:39:03 2012 +0530

    ARM: OMAP5: Enable arch timer support
    
    Enable Cortex A15 generic timer support for OMAP5 based SOCs.
    The CPU local timers run on the free running real time counter clock.
    
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 026fcfff6698..2c5a45d8ca8c 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -41,6 +41,7 @@
 #include <plat/dmtimer.h>
 #include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
+#include <asm/arch_timer.h>
 #include "common.h"
 #include <plat/omap_hwmod.h>
 #include <plat/omap_device.h>
@@ -488,9 +489,15 @@ OMAP_SYS_TIMER(4)
 #ifdef CONFIG_SOC_OMAP5
 static void __init omap5_timer_init(void)
 {
+	int err;
+
 	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
 	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
 	realtime_counter_init();
+
+	err = arch_timer_of_register();
+	if (err)
+		pr_err("%s: arch_timer_register failed %d\n", __func__, err);
 }
 OMAP_SYS_TIMER(5)
 #endif

commit fa6d79d27614223d82418023b7f5300f1a1530d3
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Aug 13 14:24:24 2012 +0530

    ARM: OMAP: Add initialisation for the real-time counter.
    
    The real time counter also called master counter, is a free-running
    counter. It produces the count used by the CPU local timer peripherals
    in the MPU cluster. The timer counts at a rate of 6.144 MHz.
    
    The ratio registers needs to be configured based on system clock
    only onetime. After initialisation, hardware takes care of adjusting
    the clock in different low power modes to keep counter rate constant.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2ba4f57dda86..026fcfff6698 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -69,6 +69,11 @@
 #define OMAP3_SECURE_TIMER	1
 #endif
 
+#define REALTIME_COUNTER_BASE				0x48243200
+#define INCREMENTER_NUMERATOR_OFFSET			0x10
+#define INCREMENTER_DENUMERATOR_RELOAD_OFFSET		0x14
+#define NUMERATOR_DENUMERATOR_MASK			0xfffff000
+
 /* Clockevent code */
 
 static struct omap_dm_timer clkev;
@@ -346,6 +351,84 @@ static void __init omap2_clocksource_init(int gptimer_id,
 		omap2_gptimer_clocksource_init(gptimer_id, fck_source);
 }
 
+#ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
+/*
+ * The realtime counter also called master counter, is a free-running
+ * counter, which is related to real time. It produces the count used
+ * by the CPU local timer peripherals in the MPU cluster. The timer counts
+ * at a rate of 6.144 MHz. Because the device operates on different clocks
+ * in different power modes, the master counter shifts operation between
+ * clocks, adjusting the increment per clock in hardware accordingly to
+ * maintain a constant count rate.
+ */
+static void __init realtime_counter_init(void)
+{
+	void __iomem *base;
+	static struct clk *sys_clk;
+	unsigned long rate;
+	unsigned int reg, num, den;
+
+	base = ioremap(REALTIME_COUNTER_BASE, SZ_32);
+	if (!base) {
+		pr_err("%s: ioremap failed\n", __func__);
+		return;
+	}
+	sys_clk = clk_get(NULL, "sys_clkin_ck");
+	if (!sys_clk) {
+		pr_err("%s: failed to get system clock handle\n", __func__);
+		iounmap(base);
+		return;
+	}
+
+	rate = clk_get_rate(sys_clk);
+	/* Numerator/denumerator values refer TRM Realtime Counter section */
+	switch (rate) {
+	case 1200000:
+		num = 64;
+		den = 125;
+		break;
+	case 1300000:
+		num = 768;
+		den = 1625;
+		break;
+	case 19200000:
+		num = 8;
+		den = 25;
+		break;
+	case 2600000:
+		num = 384;
+		den = 1625;
+		break;
+	case 2700000:
+		num = 256;
+		den = 1125;
+		break;
+	case 38400000:
+	default:
+		/* Program it for 38.4 MHz */
+		num = 4;
+		den = 25;
+		break;
+	}
+
+	/* Program numerator and denumerator registers */
+	reg = __raw_readl(base + INCREMENTER_NUMERATOR_OFFSET) &
+			NUMERATOR_DENUMERATOR_MASK;
+	reg |= num;
+	__raw_writel(reg, base + INCREMENTER_NUMERATOR_OFFSET);
+
+	reg = __raw_readl(base + INCREMENTER_NUMERATOR_OFFSET) &
+			NUMERATOR_DENUMERATOR_MASK;
+	reg |= den;
+	__raw_writel(reg, base + INCREMENTER_DENUMERATOR_RELOAD_OFFSET);
+
+	iounmap(base);
+}
+#else
+static inline void __init realtime_counter_init(void)
+{}
+#endif
+
 #define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src,			\
 				clksrc_nr, clksrc_src)			\
 static void __init omap##name##_timer_init(void)			\
@@ -403,7 +486,12 @@ OMAP_SYS_TIMER(4)
 #endif
 
 #ifdef CONFIG_SOC_OMAP5
-OMAP_SYS_TIMER_INIT(5, 1, OMAP4_CLKEV_SOURCE, 2, OMAP4_MPU_SOURCE)
+static void __init omap5_timer_init(void)
+{
+	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
+	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
+	realtime_counter_init();
+}
 OMAP_SYS_TIMER(5)
 #endif
 

commit 6bfc82ff589a00e5fbc12b958c649d703d273c86
Merge: 26638c667e64 68cb700c59fa
Author: Tony Lindgren <tony@atomide.com>
Date:   Sun Sep 16 15:35:06 2012 -0700

    Merge tag 'omap-cleanup-sparseirq-for-v3.7' into devel-dt
    
    This branch contains changes needed to make omap2+
    work properly with sparse IRQ. It also removes
    dependencies to mach/hardware.h. These help moving
    things towards ARM single zImage support.
    
    This branch is based on a commit in tty-next
    branch with omap-devel-gpmc-fixed-for-v3.7 and
    cleanup-omap-tags-for-v3.7 merged in to keep things
    compiling and sort out some merge conflicts.
    
    Conflicts:
            arch/arm/mach-omap2/omap4-common.c
            drivers/gpio/gpio-twl4030.c

commit 3c101c41fbe5daf88afbbd575542aa1d047812bb
Merge: f191f40c1819 7852ec0536ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 20:42:36 2012 -0700

    Merge tag 'omap-cleanup-b-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-makefile-sparse
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 3bdaf9877e0b..25cbe73b0cd7 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -46,8 +46,7 @@
 #include <plat/dmtimer.h>
 #include <plat/omap-pm.h>
 
-#include <mach/hardware.h>
-
+#include "soc.h"
 #include "common.h"
 #include "powerdomain.h"
 

commit 7d7e1eba7e92c2f9c76db80adc24836e7a114bfb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 27 17:43:01 2012 -0700

    ARM: OMAP2+: Prepare for irqs.h removal
    
    As the interrupts should only be defined in the platform_data, and
    eventually coming from device tree, there's no need to define them
    in header files.
    
    Let's remove the hardcoded references to irqs.h and fix up the includes
    so we don't rely on headers included in irqs.h. Note that we're
    defining OMAP_INTC_START as 0 to the interrupts. This will be needed
    when we enable SPARSE_IRQ. For some drivers we need to add
    #include <plat/cpu.h> for now until these drivers are fixed to
    remove cpu_is_omapxxxx() usage.
    
    While at it, sort som of the includes the standard way, and add
    the trailing commas where they are missing in the related data
    structures.
    
    Note that for drivers/staging/tidspbridge we just define things
    locally.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2ff6d41ec6c6..3bdaf9877e0b 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -38,14 +38,17 @@
 #include <linux/slab.h>
 
 #include <asm/mach/time.h>
-#include <plat/dmtimer.h>
 #include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
-#include "common.h"
+
 #include <plat/omap_hwmod.h>
 #include <plat/omap_device.h>
+#include <plat/dmtimer.h>
 #include <plat/omap-pm.h>
 
+#include <mach/hardware.h>
+
+#include "common.h"
 #include "powerdomain.h"
 
 /* Parent clocks, eventually these will come from the clock framework */
@@ -373,8 +376,7 @@ OMAP_SYS_TIMER(3_am33xx)
 #ifdef CONFIG_ARCH_OMAP4
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
-			      OMAP44XX_LOCAL_TWD_BASE,
-			      OMAP44XX_IRQ_LOCALTIMER);
+			      OMAP44XX_LOCAL_TWD_BASE, 29 + OMAP_INTC_START);
 #endif
 
 static void __init omap4_timer_init(void)

commit a032d33b65c89a781c871fd1def595fa6a69b52a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Aug 3 09:21:10 2012 -0600

    ARM: OMAP: clean up some smatch warnings, fix some printk(KERN_ERR ...
    
    Resolve the following warnings from smatch:
    
    arch/arm/mach-omap2/gpmc.c:282 gpmc_cs_set_timings() info: why not propagate 'div' from gpmc_cs_calc_divider() instead of -1?
    arch/arm/mach-omap2/serial.c:328 omap_serial_init_port() error: 'pdev' dereferencing possible ERR_PTR()
    arch/arm/mach-omap2/timer.c:213 omap2_gp_clockevent_init() Error invalid range 4096 to -1
    arch/arm/mach-omap2/gpio.c:63 omap2_gpio_dev_init() warn: possible memory leak of 'pdata'
    arch/arm/mach-omap2/omap_hwmod.c:1478 _assert_hardreset() warn: assigning -22 to unsigned variable 'ret'
    arch/arm/mach-omap2/omap_hwmod.c:1487 _assert_hardreset() warn: 4294963201 is more than 255 (max '(ret)' can be) so this is always the same.
    arch/arm/mach-omap2/omap_hwmod.c:1545 _read_hardreset() warn: assigning -22 to unsigned variable 'ret'
    arch/arm/mach-omap2/omap_hwmod.c:1554 _read_hardreset() warn: 4294963201 is more than 255 (max '(ret)' can be) so this is always the same.
    arch/arm/mach-omap2/dpll3xxx.c:629 omap3_clkoutx2_recalc() error: we previously assumed 'pclk' could be null (see line 627)
    arch/arm/mach-omap2/board-n8x0.c:422 n8x0_mmc_late_init() Error invalid range 14 to 13
    arch/arm/mach-omap1/leds-h2p2-debug.c:71 h2p2_dbg_leds_event() error: potentially derefencing uninitialized 'fpga'.
    arch/arm/plat-omap/mux.c:79 omap_cfg_reg() Error invalid range 4096 to -1
    
    Thanks to Tony Lindgren <tony@atomide.com> for pointing out that BUG()
    can be disabled.  The changes in the first version that removed the
    subsequent return() after BUG() states have been dropped.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2ff6d41ec6c6..7e688c7c85bb 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -211,7 +211,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source);
 	BUG_ON(res);
 
-	omap2_gp_timer_irq.dev_id = (void *)&clkev;
+	omap2_gp_timer_irq.dev_id = &clkev;
 	setup_irq(clkev.irq, &omap2_gp_timer_irq);
 
 	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);

commit eed0de27726a55f145490619510c8ec58c9dc767
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Jul 4 18:32:32 2012 +0530

    ARM: OMAP4: Add local timer support for Device Tree
    
    Add cortex-a9 local timer support for all OMAP4 based
    SOCs using DT.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2ff6d41ec6c6..31f9c936125f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -36,6 +36,7 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include <asm/mach/time.h>
 #include <plat/dmtimer.h>
@@ -386,6 +387,11 @@ static void __init omap4_timer_init(void)
 	if (omap_rev() != OMAP4430_REV_ES1_0) {
 		int err;
 
+		if (of_have_populated_dt()) {
+			twd_local_timer_of_register();
+			return;
+		}
+
 		err = twd_local_timer_register(&twd_local_timer);
 		if (err)
 			pr_err("twd_local_timer_register failed %d\n", err);

commit 45caae74d238ef6583e9402cb8c550cc0b0f7dbd
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue Aug 28 01:26:14 2012 +0300

    ARM: OMAP: timer: obey the !CONFIG_OMAP_32K_TIMER
    
    Currently, omap2_sync32k_clocksource_init() function initializes the 32K
    timer as the system clock source regardless of the CONFIG_OMAP_32K_TIMER
    setting.
    Fix this by providing a default implementation for
    !CONFIG_OMAP_32K_TIMER case.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2ff6d41ec6c6..2ba4f57dda86 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -260,6 +260,7 @@ static u32 notrace dmtimer_read_sched_clock(void)
 	return 0;
 }
 
+#ifdef CONFIG_OMAP_32K_TIMER
 /* Setup free-running counter for clocksource */
 static int __init omap2_sync32k_clocksource_init(void)
 {
@@ -299,6 +300,12 @@ static int __init omap2_sync32k_clocksource_init(void)
 
 	return ret;
 }
+#else
+static inline int omap2_sync32k_clocksource_init(void)
+{
+	return -ENODEV;
+}
+#endif
 
 static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 						const char *fck_source)

commit bfdf85dfce1f203f8fcca034b8efe339542033fa
Merge: d1494ba8c38b 5c62202968d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 2 11:48:54 2012 -0700

    Merge tag 'pm2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc cpuidle enablement for OMAP from Olof Johansson:
     "Coupled cpuidle was meant to merge for 3.5 through Len Brown's tree,
      but didn't go in because the pull request ended up rejected.  So it
      just got merged, and we got this staged branch that enables the
      coupled cpuidle code on OMAP.
    
      With a stable git workflow from the other maintainer we could have
      staged this earlier, but that wasn't the case so we have had to merge
      it late.
    
      The alternative is to hold it off until 3.7 but given that the code is
      well-isolated to OMAP and they are eager to see it go in, I didn't
      push back hard in that direction."
    
    * tag 'pm2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: OMAP4: CPUidle: Open broadcast clock-event device.
      ARM: OMAP4: CPUidle: add synchronization for coupled idle states
      ARM: OMAP4: CPUidle: Use coupled cpuidle states to implement SMP cpuidle.
      ARM: OMAP: timer: allow gp timer clock-event to be used on both cpus

commit 11d6ec2e488f5613ab380bee9dc9a67c54813b60
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Sat Mar 17 15:00:16 2012 +0530

    ARM: OMAP: timer: allow gp timer clock-event to be used on both cpus
    
    For coupled cpuidle to work when both cpus are active, it needs a global timer
    that can handle events for both cpus.  This timer is used as the broadcast
    clock-event when the per-cpu timer hardware stop in low power states.
    Set the cpumask of clockevent_gpt to all cpus, set the rating correctly, and
    set the irq to allow the clockevent core to determine the affinity of the
    timer.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 840929bd9dae..9b7a07360610 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -135,6 +135,7 @@ static struct clock_event_device clockevent_gpt = {
 	.name		= "gp_timer",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.shift		= 32,
+	.rating		= 300,
 	.set_next_event	= omap2_gp_timer_set_next_event,
 	.set_mode	= omap2_gp_timer_set_mode,
 };
@@ -228,7 +229,8 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 		clockevent_delta2ns(3, &clockevent_gpt);
 		/* Timer internal resynch latency. */
 
-	clockevent_gpt.cpumask = cpumask_of(0);
+	clockevent_gpt.cpumask = cpu_possible_mask;
+	clockevent_gpt.irq = omap_dm_timer_get_irq(&clkev);
 	clockevents_register_device(&clockevent_gpt);
 
 	pr_info("OMAP clockevent source: GPTIMER%d at %lu Hz\n",

commit 37b3280de2a7a3feb75e939cadd988d082984566
Author: R Sricharan <r.sricharan@ti.com>
Date:   Wed May 2 13:07:12 2012 +0530

    ARM: OMAP5: timer: Add clocksource, clockevent support
    
    Adding the Initialisaton for clocksource and clockevent device
    on OMAP5 Socs.
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 2b318ec92d39..13d20c8a283d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -393,6 +393,11 @@ static void __init omap4_timer_init(void)
 OMAP_SYS_TIMER(4)
 #endif
 
+#ifdef CONFIG_SOC_OMAP5
+OMAP_SYS_TIMER_INIT(5, 1, OMAP4_CLKEV_SOURCE, 2, OMAP4_MPU_SOURCE)
+OMAP_SYS_TIMER(5)
+#endif
+
 /**
  * omap_timer_init - build and register timer device with an
  * associated timer hwmod

commit ae6df418a21f3a361c5f9b878e32a8aba4e17692
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Thu Jul 5 18:10:59 2012 +0530

    ARM: OMAP2+: dmtimer: cleanup fclk usage
    
    With omap_hwmod_get_main_clk() now available, this can be passed to
    clk_get() to extract the fclk and thus avoid construction of fclk name.
    Corrected the timer fck name mis-match between clock44xx_data.c and
    omap_hwmod_44xx_data.c. For other platforms this is already taken care.
    
    Cc: Cousson, Benoit <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b5b5d92acd9d..2b318ec92d39 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -168,8 +168,7 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 		return -ENXIO;
 
 	/* After the dmtimer is using hwmod these clocks won't be needed */
-	sprintf(name, "gpt%d_fck", gptimer_id);
-	timer->fclk = clk_get(NULL, name);
+	timer->fclk = clk_get(NULL, omap_hwmod_get_main_clk(oh));
 	if (IS_ERR(timer->fclk))
 		return -ENODEV;
 

commit 3f96a2d90e6923e2dd1e35d2f149a70a4d0f678c
Merge: 6887a4131da3 472fd5401561 c59b537d8706 6fd8246b1c11
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jul 4 00:29:31 2012 -0700

    Merge tags 'omap-cleanup-for-v3.6', 'omap-devel-dmtimer-for-v3.6' and 'omap-devel-am33xx-for-v3.6' into devel-am33xx-part2

commit 2b2d35230099613365ad6000f4d71086130b9e71
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:59 2012 -0500

    ARM: OMAP2+: Move dmtimer clock set function to dmtimer driver
    
    OMAP1 uses an architecture specific function for setting the dmtimer clock
    source, where as the OMAP2+ devices use the clock framework. Eventually OMAP1
    device should also use the clock framework and hence we should not any
    architecture specific functions.
    
    For now move the OMAP2+ function for configuring the clock source into the
    dmtimer driver. Therefore, we do no longer need to specify an architecture
    specific function for setting the clock source for OMAP2+ devices. This will
    simplify device tree migration of the dmtimers for OMAP2+ devices.
    
    From now on, only OMAP1 devices should specify an architecture specific
    function for setting the clock source via the platform data set_dmtimer_src()
    function pointer.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 0e17a0d9690b..8fe75a81e12d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -389,59 +389,6 @@ static void __init omap4_timer_init(void)
 OMAP_SYS_TIMER(4)
 #endif
 
-/**
- * omap2_dm_timer_set_src - change the timer input clock source
- * @pdev:	timer platform device pointer
- * @source:	array index of parent clock source
- */
-static int omap2_dm_timer_set_src(struct platform_device *pdev, int source)
-{
-	int ret;
-	struct clk *fclk, *parent;
-	char *parent_name = NULL;
-
-	fclk = clk_get(&pdev->dev, "fck");
-	if (IS_ERR_OR_NULL(fclk)) {
-		dev_err(&pdev->dev, "%s: %d: clk_get() FAILED\n",
-				__func__, __LINE__);
-		return -EINVAL;
-	}
-
-	switch (source) {
-	case OMAP_TIMER_SRC_SYS_CLK:
-		parent_name = "sys_ck";
-		break;
-
-	case OMAP_TIMER_SRC_32_KHZ:
-		parent_name = "32k_ck";
-		break;
-
-	case OMAP_TIMER_SRC_EXT_CLK:
-		parent_name = "alt_ck";
-		break;
-	}
-
-	parent = clk_get(&pdev->dev, parent_name);
-	if (IS_ERR_OR_NULL(parent)) {
-		dev_err(&pdev->dev, "%s: %d: clk_get() %s FAILED\n",
-			__func__, __LINE__, parent_name);
-		clk_put(fclk);
-		return -EINVAL;
-	}
-
-	ret = clk_set_parent(fclk, parent);
-	if (IS_ERR_VALUE(ret)) {
-		dev_err(&pdev->dev, "%s: clk_set_parent() to %s FAILED\n",
-			__func__, parent_name);
-		ret = -EINVAL;
-	}
-
-	clk_put(parent);
-	clk_put(fclk);
-
-	return ret;
-}
-
 /**
  * omap_timer_init - build and register timer device with an
  * associated timer hwmod
@@ -489,8 +436,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	 */
 	sscanf(oh->name, "timer%2d", &id);
 
-	pdata->set_timer_src = omap2_dm_timer_set_src;
-
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;
 

commit 0b30ec1cb7f1b0134b16670f886baaf3521b083c
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:56 2012 -0500

    ARM: OMAP: Remove timer function pointer for context loss counter
    
    For OMAP2+ devices, a function pointer that returns the number of times a timer
    power domain has lost context is passed to the dmtimer driver. This function
    pointer is only populated for OMAP2+ devices and it is pointing to a platform
    function. Given that this is a platform function, we can simplify the code by
    removing the function pointer and referencing the function directly. We can use
    the OMAP_TIMER_ALWON flag to determine if we need to call this function for
    OMAP1 and OMAP2+ devices.
    
    The benefit of this change is the we can remove the function pointer from the
    platform data and simplifies the dmtimer migration to device-tree.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 9b6880a33793..0e17a0d9690b 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -494,9 +494,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;
 
-#ifdef CONFIG_PM
-	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
-#endif
 	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
 				 NULL, 0, 0);
 

commit 1c2d076b589225e51e022d85bb9f25dca26530f3
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:55 2012 -0500

    ARM: OMAP: Remove loses_context variable from timer platform data
    
    The platform data variable loses_context is used to determine if the timer may
    lose its logic state during power transitions and so needs to be restored. This
    information is also provided in the HWMOD device attributes for OMAP2+ devices
    via the OMAP_TIMER_ALWON flag. When this flag is set the timer will not lose
    context. So use the HWMOD device attributes to determine this.
    
    For OMAP1 devices, loses_context is never set and so set the OMAP_TIMER_ALWON
    flag for OMAP1 timers to ensure that code is equivalent.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 8c046d9d8ae8..9b6880a33793 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -462,7 +462,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	struct dmtimer_platform_data *pdata;
 	struct platform_device *pdev;
 	struct omap_timer_capability_dev_attr *timer_dev_attr;
-	struct powerdomain *pwrdm;
 
 	pr_debug("%s: %s\n", __func__, oh->name);
 
@@ -495,8 +494,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;
 
-	pwrdm = omap_hwmod_get_pwrdm(oh);
-	pdata->loses_context = pwrdm_can_ever_lose_context(pwrdm);
 #ifdef CONFIG_PM
 	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
 #endif

commit 67d2e760ae1909f3a3c444a063961e35a54b7bb0
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:54 2012 -0500

    ARM: OMAP2+: Fix external clock support for dmtimers
    
    Currently, the dmtimer determines whether an timer can support an external
    clock source (sys_altclk) for driving the timer by the IP version. Only
    OMAP24xx devices can support an external clock source, but the IP version
    between OMAP24xx and OMAP3xxx is common and so this incorrectly indicates
    that OMAP3 devices can use an external clock source.
    
    Rather than use the IP version, just let the clock framework handle this.
    If the "alt_ck" does not exist for a timer then the clock framework will fail
    to find the clock and hence will return an error. By doing this we can eliminate
    the "timer_ip_version" variable passed as part of the platform data and simplify
    the code.
    
    We can also remove the timer IP version from the HWMOD data because the dmtimer
    driver uses the TIDR register to determine the IP version.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index d8a5dc3d695f..8c046d9d8ae8 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -397,7 +397,6 @@ OMAP_SYS_TIMER(4)
 static int omap2_dm_timer_set_src(struct platform_device *pdev, int source)
 {
 	int ret;
-	struct dmtimer_platform_data *pdata = pdev->dev.platform_data;
 	struct clk *fclk, *parent;
 	char *parent_name = NULL;
 
@@ -418,14 +417,8 @@ static int omap2_dm_timer_set_src(struct platform_device *pdev, int source)
 		break;
 
 	case OMAP_TIMER_SRC_EXT_CLK:
-		if (pdata->timer_ip_version == OMAP_TIMER_IP_VERSION_1) {
-			parent_name = "alt_ck";
-			break;
-		}
-		dev_err(&pdev->dev, "%s: %d: invalid clk src.\n",
-			__func__, __LINE__);
-		clk_put(fclk);
-		return -EINVAL;
+		parent_name = "alt_ck";
+		break;
 	}
 
 	parent = clk_get(&pdev->dev, parent_name);
@@ -498,7 +491,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	sscanf(oh->name, "timer%2d", &id);
 
 	pdata->set_timer_src = omap2_dm_timer_set_src;
-	pdata->timer_ip_version = oh->class->rev;
 
 	if (timer_dev_attr)
 		pdata->timer_capability = timer_dev_attr->timer_capability;

commit d1c1691be5290bf7e5b11b63b6fda0d63a9f4937
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:52 2012 -0500

    ARM: OMAP: Add DMTIMER capability variable to represent timer features
    
    Although the OMAP timers share a common hardware design, there are some
    differences between the timer instances in a given device. For example, a timer
    maybe in a power domain that can be powered-of, so can lose its logic state and
    need restoring where as another may be in power domain that is always be on.
    Another example, is a timer may support different clock sources to drive the
    timer. This information is passed to the dmtimer via the following platform data
    structure.
    
    struct dmtimer_platform_data {
            int (*set_timer_src)(struct platform_device *pdev, int source);
            int timer_ip_version;
            u32 needs_manual_reset:1;
            bool loses_context;
            int (*get_context_loss_count)(struct device *dev);
    };
    
    The above structure uses multiple variables to represent the timer features.
    HWMOD also stores the timer capabilities using a bit-mask that represents the
    features supported. By using the same format for representing the timer
    features in the platform data as used by HWMOD, we can ...
    
    1. Use the flags defined in the plat/dmtimer.h to represent the features
       supported.
    2. For devices using HWMOD, we can retrieve the features supported from HWMOD.
    3. Eventually, simplify the platform data structure to be ...
    
    struct dmtimer_platform_data {
            int (*set_timer_src)(struct platform_device *pdev, int source);
            u32 timer_capability;
    }
    
    Another benefit from doing this, is that it will simplify the migration of the
    dmtimer driver to device-tree. For example, in the current OMAP2+ timer code the
    "loses_context" variable is configured at runtime by calling an architecture
    specific function. For device tree this creates a problem, because we would need
    to call the architecture specific function from within the dmtimer driver.
    However, such attributes do not need to be queried at runtime and we can look up
    the attributes via HWMOD or device-tree.
    
    This changes a new "capability" variable to the platform data and timer
    structure so we can start removing and simplifying the platform data structure.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b0b208077c96..d8a5dc3d695f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -500,6 +500,9 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	pdata->set_timer_src = omap2_dm_timer_set_src;
 	pdata->timer_ip_version = oh->class->rev;
 
+	if (timer_dev_attr)
+		pdata->timer_capability = timer_dev_attr->timer_capability;
+
 	pwrdm = omap_hwmod_get_pwrdm(oh);
 	pdata->loses_context = pwrdm_can_ever_lose_context(pwrdm);
 #ifdef CONFIG_PM

commit b7b4ff764f7bf903e47eebdab661b1c38e791c6d
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:51 2012 -0500

    ARM: OMAP2+: Add dmtimer platform function to reserve systimers
    
    During early boot, one or two dmtimers are reserved by the kernel as system
    timers (for clocksource and clockevents). These timers are marked as reserved
    and the dmtimer driver is notified which timers have been reserved via the
    platform data information.
    
    For OMAP2+ devices the timers reserved may vary depending on device and compile
    flags. Therefore, it is not easy to assume which timers we be reserved for the
    system timers. In order to migrate the dmtimer driver to support device-tree we
    need a way to pass the timers reserved for system timers to the dmtimer driver.
    Using the platform data structure will not work in the same way as it is
    currently used because the platform data structure will be stored statically in
    the dmtimer itself and the platform data will be selected via the device-tree
    match device function (of_match_device).
    
    There are a couple ways to workaround this. One option is to store the system
    timers reserved for the kernel in the device-tree and query them on boot.
    The downside of this approach is that it adds some delay to parse the DT blob
    to search for the system timers. Secondly, for OMAP3 devices we have a
    dependency on compile time flags and the device-tree would not be aware of that
    kernel compile flags and so we would need to address that.
    
    The second option is to add a function to the dmtimer code to reserved the
    system timers during boot and so the dmtimer knows exactly which timers are
    being used for system timers. This also allows us to remove the "reserved"
    member from the timer platform data. This seemed like the simpler approach and
    so was implemented here.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index c030dfeee76a..b0b208077c96 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -69,8 +69,6 @@
 #define OMAP3_SECURE_TIMER	1
 #endif
 
-static u32 sys_timer_reserved;
-
 /* Clockevent code */
 
 static struct omap_dm_timer clkev;
@@ -177,7 +175,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 
 	omap_hwmod_enable(oh);
 
-	sys_timer_reserved |= (1 << (gptimer_id - 1));
+	if (omap_dm_timer_reserve_systimer(gptimer_id))
+		return -ENODEV;
 
 	if (gptimer_id != 12) {
 		struct clk *src;
@@ -501,10 +500,6 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	pdata->set_timer_src = omap2_dm_timer_set_src;
 	pdata->timer_ip_version = oh->class->rev;
 
-	/* Mark clocksource and clockevent timers as reserved */
-	if ((sys_timer_reserved >> (id - 1)) & 0x1)
-		pdata->reserved = 1;
-
 	pwrdm = omap_hwmod_get_pwrdm(oh);
 	pdata->loses_context = pwrdm_can_ever_lose_context(pwrdm);
 #ifdef CONFIG_PM

commit 26fe4e454bfee3248bc7f7bab38b4888db33528e
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:50 2012 -0500

    ARM: OMAP2+: Remove unused max number of timers definition
    
    The OMAP2+ timer code has a definition for the maximum number of timers that
    OMAP2+ devices have. This defintion is not used anywhere in the code and
    appears to be left over. Furthermore the definition is not accurate for OMAP4
    devices that only have 11 timers available because the 12th timer is reserved
    as a secure timer and for OMAP3 devices the 12th timer is not available on
    secure devices. Therefore, remove this definition.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 840929bd9dae..c030dfeee76a 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -69,9 +69,6 @@
 #define OMAP3_SECURE_TIMER	1
 #endif
 
-/* MAX_GPTIMER_ID: number of GPTIMERs on the chip */
-#define MAX_GPTIMER_ID		12
-
 static u32 sys_timer_reserved;
 
 /* Clockevent code */

commit 08f3098928c991560408e8c71d4af8b1a3ff2d67
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri May 11 00:38:49 2012 +0530

    ARM: OMAP2+: am33xx: Add AM335XEVM machine support
    
    This patch adds minimal support for AM335X machine init.
    
    During last merge window, two separate patches supporting am33xx
    machine init had been submitted,
    
    1. Link to earlier Baseport patch submission (Legacy):
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg59325.html
    2. Link to earlier DT based machine init support patch submission:
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg61398.html
    
    And both had got accepted at that time, but got missed during
    merge window.
    
    But now, since we have taken decision to make am33xx as a separate
    class and not to follow omap3 family, these patches needs to changes
    accordingly (only changes),
    
     - Combine both the patches, since early init and timer init
       used in board-generic.c file requires them.
     - Remove dependency on AM3517EVM, and only use DT approach
       for machine init.
     - Change the config option (as changed recently)
       CONFIG_SOC_OMAPAM33XX --> CONFIG_SOC_AM33XX
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 840929bd9dae..ea6a0eb13f05 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -368,6 +368,11 @@ OMAP_SYS_TIMER_INIT(3_secure, OMAP3_SECURE_TIMER, OMAP3_CLKEV_SOURCE,
 OMAP_SYS_TIMER(3_secure)
 #endif
 
+#ifdef CONFIG_SOC_AM33XX
+OMAP_SYS_TIMER_INIT(3_am33xx, 1, OMAP4_MPU_SOURCE, 2, OMAP4_MPU_SOURCE)
+OMAP_SYS_TIMER(3_am33xx)
+#endif
+
 #ifdef CONFIG_ARCH_OMAP4
 #ifdef CONFIG_LOCAL_TIMERS
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,

commit 1fe97c8f6a1de67a5f56e029a818903d5bed8017
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Wed May 9 10:07:05 2012 -0700

    ARM: OMAP: Make OMAP clocksource source selection using kernel param
    
    Current OMAP code supports couple of clocksource options based
    on compilation flag (CONFIG_OMAP_32K_TIMER). The 32KHz sync-timer
    and a gptimer which can run on 32KHz or system clock (e.g 38.4 MHz).
    So there can be 3 options -
    
    1. 32KHz sync-timer
    2. Sys_clock based (e.g 13/19.2/26/38.4 MHz) gptimer
    3. 32KHz based gptimer.
    
    The optional gptimer based clocksource was added so that it can
    give the high precision than sync-timer, so expected usage was 2
    and not 3.
    Unfortunately option 2, clocksource doesn't meet the requirement of
    free-running clock as per clocksource need. It stops in low power states
    when sys_clock is cut. That makes gptimer based clocksource option
    useless for OMAP2/3/4 devices with sys_clock as a clock input.
    So, in order to use option 2, deeper idle state MUST be disabled.
    
    Option 3 will still work but it is no better than 32K sync-timer
    based clocksource.
    
    We must support both sync timer and gptimer based clocksource as
    some OMAP based derivative SoCs like AM33XX does not have the
    sync timer.
    
    Considering above, make sync-timer and gptimer clocksource runtime
    selectable so that both OMAP and AMXXXX continue to use the same code.
    
    And, in order to precisely configure/setup sched_clock for given
    clocksource, decision has to be made early enough in boot sequence.
    
    So, the solution is,
    
    Use standard kernel parameter ("clocksource=") to override
    default 32k_sync-timer, in addition to this, we also use hwmod database
    lookup mechanism, through which at run-time we can identify availability
    of 32k-sync timer on the device, else fall back to gptimer.
    
    Also, moved low-level SoC specific init code to respective files,
    (mach-omap1/timer32k.c and mach-omap2/timer.c)
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 105829e403b3..840929bd9dae 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -236,22 +236,8 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 }
 
 /* Clocksource code */
-
-#ifdef CONFIG_OMAP_32K_TIMER
-/*
- * When 32k-timer is enabled, don't use GPTimer for clocksource
- * instead, just leave default clocksource which uses the 32k
- * sync counter.  See clocksource setup in plat-omap/counter_32k.c
- */
-
-static void __init omap2_gp_clocksource_init(int unused, const char *dummy)
-{
-	omap_init_clocksource_32k();
-}
-
-#else
-
 static struct omap_dm_timer clksrc;
+static bool use_gptimer_clksrc;
 
 /*
  * clocksource
@@ -278,7 +264,46 @@ static u32 notrace dmtimer_read_sched_clock(void)
 }
 
 /* Setup free-running counter for clocksource */
-static void __init omap2_gp_clocksource_init(int gptimer_id,
+static int __init omap2_sync32k_clocksource_init(void)
+{
+	int ret;
+	struct omap_hwmod *oh;
+	void __iomem *vbase;
+	const char *oh_name = "counter_32k";
+
+	/*
+	 * First check hwmod data is available for sync32k counter
+	 */
+	oh = omap_hwmod_lookup(oh_name);
+	if (!oh || oh->slaves_cnt == 0)
+		return -ENODEV;
+
+	omap_hwmod_setup_one(oh_name);
+
+	vbase = omap_hwmod_get_mpu_rt_va(oh);
+	if (!vbase) {
+		pr_warn("%s: failed to get counter_32k resource\n", __func__);
+		return -ENXIO;
+	}
+
+	ret = omap_hwmod_enable(oh);
+	if (ret) {
+		pr_warn("%s: failed to enable counter_32k module (%d)\n",
+							__func__, ret);
+		return ret;
+	}
+
+	ret = omap_init_clocksource_32k(vbase);
+	if (ret) {
+		pr_warn("%s: failed to initialize counter_32k as a clocksource (%d)\n",
+							__func__, ret);
+		omap_hwmod_idle(oh);
+	}
+
+	return ret;
+}
+
+static void __init omap2_gptimer_clocksource_init(int gptimer_id,
 						const char *fck_source)
 {
 	int res;
@@ -286,9 +311,6 @@ static void __init omap2_gp_clocksource_init(int gptimer_id,
 	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source);
 	BUG_ON(res);
 
-	pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
-		gptimer_id, clksrc.rate);
-
 	__omap_dm_timer_load_start(&clksrc,
 			OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0, 1);
 	setup_sched_clock(dmtimer_read_sched_clock, 32, clksrc.rate);
@@ -296,15 +318,36 @@ static void __init omap2_gp_clocksource_init(int gptimer_id,
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
 		pr_err("Could not register clocksource %s\n",
 			clocksource_gpt.name);
+	else
+		pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
+			gptimer_id, clksrc.rate);
+}
+
+static void __init omap2_clocksource_init(int gptimer_id,
+						const char *fck_source)
+{
+	/*
+	 * First give preference to kernel parameter configuration
+	 * by user (clocksource="gp_timer").
+	 *
+	 * In case of missing kernel parameter for clocksource,
+	 * first check for availability for 32k-sync timer, in case
+	 * of failure in finding 32k_counter module or registering
+	 * it as clocksource, execution will fallback to gp-timer.
+	 */
+	if (use_gptimer_clksrc == true)
+		omap2_gptimer_clocksource_init(gptimer_id, fck_source);
+	else if (omap2_sync32k_clocksource_init())
+		/* Fall back to gp-timer code */
+		omap2_gptimer_clocksource_init(gptimer_id, fck_source);
 }
-#endif
 
 #define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src,			\
 				clksrc_nr, clksrc_src)			\
 static void __init omap##name##_timer_init(void)			\
 {									\
 	omap2_gp_clockevent_init((clkev_nr), clkev_src);		\
-	omap2_gp_clocksource_init((clksrc_nr), clksrc_src);		\
+	omap2_clocksource_init((clksrc_nr), clksrc_src);		\
 }
 
 #define OMAP_SYS_TIMER(name)						\
@@ -335,7 +378,7 @@ static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
 static void __init omap4_timer_init(void)
 {
 	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
-	omap2_gp_clocksource_init(2, OMAP4_MPU_SOURCE);
+	omap2_clocksource_init(2, OMAP4_MPU_SOURCE);
 #ifdef CONFIG_LOCAL_TIMERS
 	/* Local timers are not supprted on OMAP4430 ES1.0 */
 	if (omap_rev() != OMAP4430_REV_ES1_0) {
@@ -503,3 +546,28 @@ static int __init omap2_dm_timer_init(void)
 	return 0;
 }
 arch_initcall(omap2_dm_timer_init);
+
+/**
+ * omap2_override_clocksource - clocksource override with user configuration
+ *
+ * Allows user to override default clocksource, using kernel parameter
+ *   clocksource="gp_timer"	(For all OMAP2PLUS architectures)
+ *
+ * Note that, here we are using same standard kernel parameter "clocksource=",
+ * and not introducing any OMAP specific interface.
+ */
+static int __init omap2_override_clocksource(char *str)
+{
+	if (!str)
+		return 0;
+	/*
+	 * For OMAP architecture, we only have two options
+	 *    - sync_32k (default)
+	 *    - gp_timer (sys_clk based)
+	 */
+	if (!strcmp(str, "gp_timer"))
+		use_gptimer_clksrc = true;
+
+	return 0;
+}
+early_param("clocksource", omap2_override_clocksource);

commit f36921bebdf368ac4892f8ed62fb97dd6461d459
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Wed May 9 10:07:05 2012 -0700

    ARM: OMAP2+: Replace space with underscore in the name field of system timers
    
    Depending on the bootloader, passing command-line arguments
    with spaces may have issues. Some bootloaders doesn't seem
    to pass along the quotes, passing only 'gp' part of the string,
    which leads to wrong override configuration.
    
    The only affected kernel parameter configuration for OMAP family
    is "clocksource=", used to override kernel clocksource.
    
    So this patch changes "gp timer" => "gp_timer", for clockevent,
    clocksource and timer irq_handler.
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 1b7835865c83..105829e403b3 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -90,7 +90,7 @@ static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 }
 
 static struct irqaction omap2_gp_timer_irq = {
-	.name		= "gp timer",
+	.name		= "gp_timer",
 	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= omap2_gp_timer_interrupt,
 };
@@ -132,7 +132,7 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 }
 
 static struct clock_event_device clockevent_gpt = {
-	.name		= "gp timer",
+	.name		= "gp_timer",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.shift		= 32,
 	.set_next_event	= omap2_gp_timer_set_next_event,
@@ -262,7 +262,7 @@ static cycle_t clocksource_read_cycles(struct clocksource *cs)
 }
 
 static struct clocksource clocksource_gpt = {
-	.name		= "gp timer",
+	.name		= "gp_timer",
 	.rating		= 300,
 	.read		= clocksource_read_cycles,
 	.mask		= CLOCKSOURCE_MASK(32),

commit f1bbbb1365fdb1abe29f31d4ac455f265f9bc2ff
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Mon May 7 23:55:30 2012 -0600

    ARM: OMAP2+: dmtimer: cleanup iclk usage
    
    We do not use iclk anywhere in the dmtimer driver and so removing it.
    Hence removing the timer iclk entries from OMAP4 clkdev table as well.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index ecec873e78cd..1b7835865c83 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -178,13 +178,6 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (IS_ERR(timer->fclk))
 		return -ENODEV;
 
-	sprintf(name, "gpt%d_ick", gptimer_id);
-	timer->iclk = clk_get(NULL, name);
-	if (IS_ERR(timer->iclk)) {
-		clk_put(timer->fclk);
-		return -ENODEV;
-	}
-
 	omap_hwmod_enable(oh);
 
 	sys_timer_reserved |= (1 << (gptimer_id - 1));

commit 6c0c27fdb10e15780af800d51711305f65665f25
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:01:50 2012 -0600

    ARM: OMAP2+: timer: use a proper interface to get hwmod data
    
    arch/arm/mach-omap2/timer.c pokes around inside the hwmod data
    structures.  Since the hwmod data structures are about to change, this
    code will break.  This patch modifies the timer code to use
    recently-added hwmod functions instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index c512bac69ec5..ecec873e78cd 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -145,8 +145,10 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 {
 	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
 	struct omap_hwmod *oh;
+	struct resource irq_rsrc, mem_rsrc;
 	size_t size;
 	int res = 0;
+	int r;
 
 	sprintf(name, "timer%d", gptimer_id);
 	omap_hwmod_setup_one(name);
@@ -154,9 +156,16 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 	if (!oh)
 		return -ENODEV;
 
-	timer->irq = oh->mpu_irqs[0].irq;
-	timer->phys_base = oh->slaves[0]->addr->pa_start;
-	size = oh->slaves[0]->addr->pa_end - timer->phys_base;
+	r = omap_hwmod_get_resource_byname(oh, IORESOURCE_IRQ, NULL, &irq_rsrc);
+	if (r)
+		return -ENXIO;
+	timer->irq = irq_rsrc.start;
+
+	r = omap_hwmod_get_resource_byname(oh, IORESOURCE_MEM, NULL, &mem_rsrc);
+	if (r)
+		return -ENXIO;
+	timer->phys_base = mem_rsrc.start;
+	size = mem_rsrc.end - mem_rsrc.start;
 
 	/* Static mapping, never released */
 	timer->io_base = ioremap(timer->phys_base, size);

commit a45c983f85328be9d0540a6b8250609dbf16872c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jan 10 19:44:19 2012 +0000

    ARM: OMAP4: convert to twd_local_timer_register() interface
    
    Add support for the new smp_twd runtime registration interface
    to the OMAP4 platforms, and remove the old compile-time support.
    Tested on Panda.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5c9acea95761..c512bac69ec5 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -39,7 +39,7 @@
 
 #include <asm/mach/time.h>
 #include <plat/dmtimer.h>
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
 #include "common.h"
 #include <plat/omap_hwmod.h>
@@ -324,14 +324,26 @@ OMAP_SYS_TIMER(3_secure)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
-static void __init omap4_timer_init(void)
-{
 #ifdef CONFIG_LOCAL_TIMERS
-	twd_base = ioremap(OMAP44XX_LOCAL_TWD_BASE, SZ_256);
-	BUG_ON(!twd_base);
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      OMAP44XX_LOCAL_TWD_BASE,
+			      OMAP44XX_IRQ_LOCALTIMER);
 #endif
+
+static void __init omap4_timer_init(void)
+{
 	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
 	omap2_gp_clocksource_init(2, OMAP4_MPU_SOURCE);
+#ifdef CONFIG_LOCAL_TIMERS
+	/* Local timers are not supprted on OMAP4430 ES1.0 */
+	if (omap_rev() != OMAP4430_REV_ES1_0) {
+		int err;
+
+		err = twd_local_timer_register(&twd_local_timer);
+		if (err)
+			pr_err("twd_local_timer_register failed %d\n", err);
+	}
+#endif
 }
 OMAP_SYS_TIMER(4)
 #endif

commit dbc3982ae286e934e71f0b44e78d14844a9ca83b
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Mon Jan 23 12:18:14 2012 +0530

    ARM: OMAP2+: timer: Fix crash due to wrong arg to __omap_dm_timer_read_counter
    
    Commit 2f0778af (ARM: 7205/2: sched_clock: allow sched_clock to be
    selected at runtime) had a typo for the case when CONFIG_OMAP_32K_TIMER
    is not set.
    
    In dmtimer_read_sched_clock(), wrong argument was getting passed to
    __omap_dm_timer_read_counter() function call; instead of "&clksrc",
    we were passing "clksrc.io_base", which results into kernel crash.
    
    To reproduce kernel crash, just disable the CONFIG_OMAP_32K_TIMER config
    option (and DEBUG_LL) and build/boot the kernel.
    This will use dmtimer as a kernel clocksource and lead to kernel
    crash during boot  -
    
    [    0.000000] OMAP clocksource: GPTIMER2 at 26000000 Hz
    [    0.000000] sched_clock: 32 bits at 26MHz, resolution 38ns, wraps every
    165191ms
    [    0.000000] Unable to handle kernel paging request at virtual address
    00030ef1
    [    0.000000] pgd = c0004000
    [    0.000000] [00030ef1] *pgd=00000000
    [    0.000000] Internal error: Oops: 5 [#1] SMP
    [    0.000000] Modules linked in:
    [    0.000000] CPU: 0    Not tainted  (3.3.0-rc1-11574-g0c76665-dirty #3)
    [    0.000000] PC is at dmtimer_read_sched_clock+0x18/0x4c
    [    0.000000] LR is at update_sched_clock+0x10/0x84
    [    0.000000] pc : [<c00243b8>]    lr : [<c0018684>]    psr: 200001d3
    [    0.000000] sp : c0641f38  ip : c0641e18  fp : 0000000a
    [    0.000000] r10: 151c3303  r9 : 00000026  r8 : 76276259
    [    0.000000] r7 : 00028547  r6 : c065ac80  r5 : 431bde82  r4 : c0655968
    [    0.000000] r3 : 00030ef1  r2 : fb032000  r1 : 00000028  r0 : 00000001
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    [tony@atomide.com: updated comments]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 6eeff0e0ae01..5c9acea95761 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -270,7 +270,7 @@ static struct clocksource clocksource_gpt = {
 static u32 notrace dmtimer_read_sched_clock(void)
 {
 	if (clksrc.reserved)
-		return __omap_dm_timer_read_counter(clksrc.io_base, 1);
+		return __omap_dm_timer_read_counter(&clksrc, 1);
 
 	return 0;
 }

commit 2f0778afac79bd8d226225556858a636931eeabc
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Thu Dec 15 12:19:23 2011 +0100

    ARM: 7205/2: sched_clock: allow sched_clock to be selected at runtime
    
    sched_clock() is yet another blocker on the road to the single
    image. This patch implements an idea by Russell King:
    
    http://www.spinics.net/lists/linux-omap/msg49561.html
    
    Instead of asking the platform to implement both sched_clock()
    itself and the rollover callback, simply register a read()
    function, and let the ARM code care about sched_clock() itself,
    the conversion to ns and the rollover. sched_clock() uses
    this read() function as an indirection to the platform code.
    If the platform doesn't provide a read(), the code falls back
    to the jiffy counter (just like the default sched_clock).
    
    This allow some simplifications and possibly some footprint gain
    when multiple platforms are compiled in. Among the drawbacks,
    the removal of the *_fixed_sched_clock optimization which could
    negatively impact some platforms (sa1100, tegra, versatile
    and omap).
    
    Tested on 11MPCore, OMAP4 and Tegra.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: STEricsson <STEricsson_nomadik_linux@list.st.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Tested-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 9edcd520510f..6eeff0e0ae01 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -254,7 +254,6 @@ static struct omap_dm_timer clksrc;
 /*
  * clocksource
  */
-static DEFINE_CLOCK_DATA(cd);
 static cycle_t clocksource_read_cycles(struct clocksource *cs)
 {
 	return (cycle_t)__omap_dm_timer_read_counter(&clksrc, 1);
@@ -268,23 +267,12 @@ static struct clocksource clocksource_gpt = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
-static void notrace dmtimer_update_sched_clock(void)
+static u32 notrace dmtimer_read_sched_clock(void)
 {
-	u32 cyc;
-
-	cyc = __omap_dm_timer_read_counter(&clksrc, 1);
-
-	update_sched_clock(&cd, cyc, (u32)~0);
-}
-
-unsigned long long notrace sched_clock(void)
-{
-	u32 cyc = 0;
-
 	if (clksrc.reserved)
-		cyc = __omap_dm_timer_read_counter(&clksrc, 1);
+		return __omap_dm_timer_read_counter(clksrc.io_base, 1);
 
-	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+	return 0;
 }
 
 /* Setup free-running counter for clocksource */
@@ -301,7 +289,7 @@ static void __init omap2_gp_clocksource_init(int gptimer_id,
 
 	__omap_dm_timer_load_start(&clksrc,
 			OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0, 1);
-	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, clksrc.rate);
+	setup_sched_clock(dmtimer_read_sched_clock, 32, clksrc.rate);
 
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
 		pr_err("Could not register clocksource %s\n",

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 037b0d7d4e05..9edcd520510f 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -41,7 +41,7 @@
 #include <plat/dmtimer.h>
 #include <asm/localtimer.h>
 #include <asm/sched_clock.h>
-#include <plat/common.h>
+#include "common.h"
 #include <plat/omap_hwmod.h>
 #include <plat/omap_device.h>
 #include <plat/omap-pm.h>

commit c16ae1e64e292054bc4c5a20724b40217bdc43dd
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Oct 4 23:20:41 2011 +0200

    ARM: OMAP2+: timer: Remove omap_device_pm_latency
    
    Remove the structure since a default one is now available.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index e49fc7be2229..037b0d7d4e05 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -408,14 +408,6 @@ static int omap2_dm_timer_set_src(struct platform_device *pdev, int source)
 	return ret;
 }
 
-struct omap_device_pm_latency omap2_dmtimer_latency[] = {
-	{
-		.deactivate_func = omap_device_idle_hwmods,
-		.activate_func   = omap_device_enable_hwmods,
-		.flags = OMAP_DEVICE_LATENCY_AUTO_ADJUST,
-	},
-};
-
 /**
  * omap_timer_init - build and register timer device with an
  * associated timer hwmod
@@ -477,9 +469,7 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
 #endif
 	pdev = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
-			omap2_dmtimer_latency,
-			ARRAY_SIZE(omap2_dmtimer_latency),
-			0);
+				 NULL, 0, 0);
 
 	if (IS_ERR(pdev)) {
 		pr_err("%s: Can't build omap_device for %s: %s.\n",

commit c541c15fb5ab48c47bc9b90121538fd30d152f23
Merge: 5c30cdfa4182 be7324605873 7d33910262d2 ab4eb8b098c7 dc9ca24f4d7a
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 4 09:47:06 2011 -0700

    Merge branches 'cleanup-part3', 'voltage', 'dmtimer' and 'l3' into dt-base

commit b481113a8af65f49afed46d4c9132b7af9426684
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Tue Sep 20 17:00:24 2011 +0530

    ARM: OMAP: dmtimer: low-power mode support
    
    Clock is enabled only when timer is started and disabled when the the timer
    is stopped. Therefore before accessing registers in functions clock is enabled
    and then disabled back at the end of access. Context save is done dynamically
    whenever the registers are modified. Context restore is called when context is
    lost.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    [tony@atomide.com: updated to use revision instead of tidr]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index f1e3ec1c16e1..1140e98c9773 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -44,6 +44,9 @@
 #include <plat/common.h>
 #include <plat/omap_hwmod.h>
 #include <plat/omap_device.h>
+#include <plat/omap-pm.h>
+
+#include "powerdomain.h"
 
 /* Parent clocks, eventually these will come from the clock framework */
 
@@ -433,6 +436,7 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	struct dmtimer_platform_data *pdata;
 	struct omap_device *od;
 	struct omap_timer_capability_dev_attr *timer_dev_attr;
+	struct powerdomain *pwrdm;
 
 	pr_debug("%s: %s\n", __func__, oh->name);
 
@@ -467,6 +471,11 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	if ((sys_timer_reserved >> (id - 1)) & 0x1)
 		pdata->reserved = 1;
 
+	pwrdm = omap_hwmod_get_pwrdm(oh);
+	pdata->loses_context = pwrdm_can_ever_lose_context(pwrdm);
+#ifdef CONFIG_PM
+	pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
+#endif
 	od = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
 			omap2_dmtimer_latency,
 			ARRAY_SIZE(omap2_dmtimer_latency),

commit 0dad9faeaeb0fa3524068a94e1745b91e5597c17
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 21 16:38:51 2011 -0700

    ARM: OMAP: dmtimer: skip reserved timers
    
    Pass the reserved flag in pdata and use it. We can
    now make sys_timer_reserved static to mach-omap2/timer.c.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 9c2f58895a16..f1e3ec1c16e1 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -69,7 +69,7 @@
 /* MAX_GPTIMER_ID: number of GPTIMERs on the chip */
 #define MAX_GPTIMER_ID		12
 
-u32 sys_timer_reserved;
+static u32 sys_timer_reserved;
 
 /* Clockevent code */
 
@@ -463,6 +463,10 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 	pdata->set_timer_src = omap2_dm_timer_set_src;
 	pdata->timer_ip_version = oh->class->rev;
 
+	/* Mark clocksource and clockevent timers as reserved */
+	if ((sys_timer_reserved >> (id - 1)) & 0x1)
+		pdata->reserved = 1;
+
 	od = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
 			omap2_dmtimer_latency,
 			ARRAY_SIZE(omap2_dmtimer_latency),

commit 3392cdd33a0419e3226910a08b8bdc43b56c95d0
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Tue Sep 20 17:00:20 2011 +0530

    ARM: OMAP: dmtimer: switch-over to platform device driver
    
    Register timer devices by going through hwmod database using
    hwmod API. The driver probes each of the registered devices.
    Functionality which are already performed by hwmod framework
    are removed from timer code. New set of timers present on
    OMAP4 are now supported.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Acked-by: Cousson, Benoit <b-cousson@ti.com>
    [tony@atomide.com: folded in spinlock changes, left out is_omap2]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index b2829ee0c4e4..9c2f58895a16 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -478,3 +478,23 @@ static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
 
 	return ret;
 }
+
+/**
+ * omap2_dm_timer_init - top level regular device initialization
+ *
+ * Uses dedicated hwmod api to parse through hwmod database for
+ * given class name and then build and register the timer device.
+ */
+static int __init omap2_dm_timer_init(void)
+{
+	int ret;
+
+	ret = omap_hwmod_for_each_by_class("timer", omap_timer_init, NULL);
+	if (unlikely(ret)) {
+		pr_err("%s: device registration failed.\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+arch_initcall(omap2_dm_timer_init);

commit c345c8b09d7a131f3571af55341038054a79efbd
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Tue Sep 20 17:00:18 2011 +0530

    ARM: OMAP2+: dmtimer: convert to platform devices
    
    Add routines to converts dmtimers to platform devices. The device data
    is obtained from hwmod database of respective platform and is registered
    to device model after successful binding to driver.
    In addition, capability attribute of each of the timers is added in
    hwmod database.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Cousson, Benoit <b-cousson@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 69466f388417..b2829ee0c4e4 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -35,6 +35,7 @@
 #include <linux/irq.h>
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
+#include <linux/slab.h>
 
 #include <asm/mach/time.h>
 #include <plat/dmtimer.h>
@@ -42,6 +43,7 @@
 #include <asm/sched_clock.h>
 #include <plat/common.h>
 #include <plat/omap_hwmod.h>
+#include <plat/omap_device.h>
 
 /* Parent clocks, eventually these will come from the clock framework */
 
@@ -342,3 +344,137 @@ static void __init omap4_timer_init(void)
 }
 OMAP_SYS_TIMER(4)
 #endif
+
+/**
+ * omap2_dm_timer_set_src - change the timer input clock source
+ * @pdev:	timer platform device pointer
+ * @source:	array index of parent clock source
+ */
+static int omap2_dm_timer_set_src(struct platform_device *pdev, int source)
+{
+	int ret;
+	struct dmtimer_platform_data *pdata = pdev->dev.platform_data;
+	struct clk *fclk, *parent;
+	char *parent_name = NULL;
+
+	fclk = clk_get(&pdev->dev, "fck");
+	if (IS_ERR_OR_NULL(fclk)) {
+		dev_err(&pdev->dev, "%s: %d: clk_get() FAILED\n",
+				__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	switch (source) {
+	case OMAP_TIMER_SRC_SYS_CLK:
+		parent_name = "sys_ck";
+		break;
+
+	case OMAP_TIMER_SRC_32_KHZ:
+		parent_name = "32k_ck";
+		break;
+
+	case OMAP_TIMER_SRC_EXT_CLK:
+		if (pdata->timer_ip_version == OMAP_TIMER_IP_VERSION_1) {
+			parent_name = "alt_ck";
+			break;
+		}
+		dev_err(&pdev->dev, "%s: %d: invalid clk src.\n",
+			__func__, __LINE__);
+		clk_put(fclk);
+		return -EINVAL;
+	}
+
+	parent = clk_get(&pdev->dev, parent_name);
+	if (IS_ERR_OR_NULL(parent)) {
+		dev_err(&pdev->dev, "%s: %d: clk_get() %s FAILED\n",
+			__func__, __LINE__, parent_name);
+		clk_put(fclk);
+		return -EINVAL;
+	}
+
+	ret = clk_set_parent(fclk, parent);
+	if (IS_ERR_VALUE(ret)) {
+		dev_err(&pdev->dev, "%s: clk_set_parent() to %s FAILED\n",
+			__func__, parent_name);
+		ret = -EINVAL;
+	}
+
+	clk_put(parent);
+	clk_put(fclk);
+
+	return ret;
+}
+
+struct omap_device_pm_latency omap2_dmtimer_latency[] = {
+	{
+		.deactivate_func = omap_device_idle_hwmods,
+		.activate_func   = omap_device_enable_hwmods,
+		.flags = OMAP_DEVICE_LATENCY_AUTO_ADJUST,
+	},
+};
+
+/**
+ * omap_timer_init - build and register timer device with an
+ * associated timer hwmod
+ * @oh:	timer hwmod pointer to be used to build timer device
+ * @user:	parameter that can be passed from calling hwmod API
+ *
+ * Called by omap_hwmod_for_each_by_class to register each of the timer
+ * devices present in the system. The number of timer devices is known
+ * by parsing through the hwmod database for a given class name. At the
+ * end of function call memory is allocated for timer device and it is
+ * registered to the framework ready to be proved by the driver.
+ */
+static int __init omap_timer_init(struct omap_hwmod *oh, void *unused)
+{
+	int id;
+	int ret = 0;
+	char *name = "omap_timer";
+	struct dmtimer_platform_data *pdata;
+	struct omap_device *od;
+	struct omap_timer_capability_dev_attr *timer_dev_attr;
+
+	pr_debug("%s: %s\n", __func__, oh->name);
+
+	/* on secure device, do not register secure timer */
+	timer_dev_attr = oh->dev_attr;
+	if (omap_type() != OMAP2_DEVICE_TYPE_GP && timer_dev_attr)
+		if (timer_dev_attr->timer_capability == OMAP_TIMER_SECURE)
+			return ret;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		pr_err("%s: No memory for [%s]\n", __func__, oh->name);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Extract the IDs from name field in hwmod database
+	 * and use the same for constructing ids' for the
+	 * timer devices. In a way, we are avoiding usage of
+	 * static variable witin the function to do the same.
+	 * CAUTION: We have to be careful and make sure the
+	 * name in hwmod database does not change in which case
+	 * we might either make corresponding change here or
+	 * switch back static variable mechanism.
+	 */
+	sscanf(oh->name, "timer%2d", &id);
+
+	pdata->set_timer_src = omap2_dm_timer_set_src;
+	pdata->timer_ip_version = oh->class->rev;
+
+	od = omap_device_build(name, id, oh, pdata, sizeof(*pdata),
+			omap2_dmtimer_latency,
+			ARRAY_SIZE(omap2_dmtimer_latency),
+			0);
+
+	if (IS_ERR(od)) {
+		pr_err("%s: Can't build omap_device for %s: %s.\n",
+			__func__, name, oh->name);
+		ret = -EINVAL;
+	}
+
+	kfree(pdata);
+
+	return ret;
+}

commit ee17f1147f010898e97dea2524b2aa3bcd2447a4
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Sep 16 15:44:20 2011 -0700

    ARM: OMAP: Add support for dmtimer v2 ip
    
    The registers are slightly different between v1 and v2 ip that
    is available in omap4 and later for some timers.
    
    Add support for v2 ip by mapping the interrupt related registers
    separately and adding func_base for the functional registers.
    
    Also disable dmtimer driver features on omap4 for now as
    those need the hwmod conversion series to deal with enabling
    the timers properly in omap_dm_timer_init.
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Tested-by: Hemant Pedanekar <hemantp@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index cf1de7d2630d..69466f388417 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -78,7 +78,7 @@ static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *evt = &clockevent_gpt;
 
-	__omap_dm_timer_write_status(clkev.io_base, OMAP_TIMER_INT_OVERFLOW);
+	__omap_dm_timer_write_status(&clkev, OMAP_TIMER_INT_OVERFLOW);
 
 	evt->event_handler(evt);
 	return IRQ_HANDLED;
@@ -93,7 +93,7 @@ static struct irqaction omap2_gp_timer_irq = {
 static int omap2_gp_timer_set_next_event(unsigned long cycles,
 					 struct clock_event_device *evt)
 {
-	__omap_dm_timer_load_start(clkev.io_base, OMAP_TIMER_CTRL_ST,
+	__omap_dm_timer_load_start(&clkev, OMAP_TIMER_CTRL_ST,
 						0xffffffff - cycles, 1);
 
 	return 0;
@@ -104,16 +104,16 @@ static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
 {
 	u32 period;
 
-	__omap_dm_timer_stop(clkev.io_base, 1, clkev.rate);
+	__omap_dm_timer_stop(&clkev, 1, clkev.rate);
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
 		period = clkev.rate / HZ;
 		period -= 1;
 		/* Looks like we need to first set the load value separately */
-		__omap_dm_timer_write(clkev.io_base, OMAP_TIMER_LOAD_REG,
+		__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG,
 					0xffffffff - period, 1);
-		__omap_dm_timer_load_start(clkev.io_base,
+		__omap_dm_timer_load_start(&clkev,
 					OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
 						0xffffffff - period, 1);
 		break;
@@ -189,7 +189,8 @@ static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
 			clk_put(src);
 		}
 	}
-	__omap_dm_timer_reset(timer->io_base, 1, 1);
+	__omap_dm_timer_init_regs(timer);
+	__omap_dm_timer_reset(timer, 1, 1);
 	timer->posted = 1;
 
 	timer->rate = clk_get_rate(timer->fclk);
@@ -210,7 +211,7 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 	omap2_gp_timer_irq.dev_id = (void *)&clkev;
 	setup_irq(clkev.irq, &omap2_gp_timer_irq);
 
-	__omap_dm_timer_int_enable(clkev.io_base, OMAP_TIMER_INT_OVERFLOW);
+	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
 
 	clockevent_gpt.mult = div_sc(clkev.rate, NSEC_PER_SEC,
 				     clockevent_gpt.shift);
@@ -251,7 +252,7 @@ static struct omap_dm_timer clksrc;
 static DEFINE_CLOCK_DATA(cd);
 static cycle_t clocksource_read_cycles(struct clocksource *cs)
 {
-	return (cycle_t)__omap_dm_timer_read_counter(clksrc.io_base, 1);
+	return (cycle_t)__omap_dm_timer_read_counter(&clksrc, 1);
 }
 
 static struct clocksource clocksource_gpt = {
@@ -266,7 +267,7 @@ static void notrace dmtimer_update_sched_clock(void)
 {
 	u32 cyc;
 
-	cyc = __omap_dm_timer_read_counter(clksrc.io_base, 1);
+	cyc = __omap_dm_timer_read_counter(&clksrc, 1);
 
 	update_sched_clock(&cd, cyc, (u32)~0);
 }
@@ -276,7 +277,7 @@ unsigned long long notrace sched_clock(void)
 	u32 cyc = 0;
 
 	if (clksrc.reserved)
-		cyc = __omap_dm_timer_read_counter(clksrc.io_base, 1);
+		cyc = __omap_dm_timer_read_counter(&clksrc, 1);
 
 	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
 }
@@ -293,7 +294,7 @@ static void __init omap2_gp_clocksource_init(int gptimer_id,
 	pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
 		gptimer_id, clksrc.rate);
 
-	__omap_dm_timer_load_start(clksrc.io_base,
+	__omap_dm_timer_load_start(&clksrc,
 			OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0, 1);
 	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, clksrc.rate);
 

commit e9d0b97eef235eccc3df9ddb9895b35c53a8aaa2
Author: Hemant Pedanekar <hemantp@ti.com>
Date:   Wed Aug 10 13:19:35 2011 +0000

    omap: timer: Set dmtimer used as clocksource in autoreload mode
    
    If CONFIG_OMAP_32K_TIMER is not selected and dmtimer is used as clocksource, the
    timer stops counting once overflow occurs as it was not set in autoreload mode.
    This results into timekeeping failure: for example, 'sleep 1' at the shell after
    the timer counter overflow would hang.
    
    This patch sets up autoreload when starting the clocksource timer which fixes
    the above issue.
    
    Signed-off-by: Hemant Pedanekar <hemantp@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index e9640728239b..cf1de7d2630d 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -293,7 +293,8 @@ static void __init omap2_gp_clocksource_init(int gptimer_id,
 	pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
 		gptimer_id, clksrc.rate);
 
-	__omap_dm_timer_load_start(clksrc.io_base, OMAP_TIMER_CTRL_ST, 0, 1);
+	__omap_dm_timer_load_start(clksrc.io_base,
+			OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR, 0, 1);
 	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, clksrc.rate);
 
 	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))

commit 0f622e8cae379ee17e1ffe867336b74c5b16f958
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 29 15:54:50 2011 -0700

    omap2+: Rename timer-gp.c into timer.c to combine timer init functions
    
    We can keep everything sys_timer and gptimer.c related code in
    timer.c as the code will be very minimal.
    
    Later on we can also remove timer-mpu.c, as it can be called from
    omap4_timer_init function.
    
    This allows us to get rid of confusing existing files. We currently
    have timer-gp.c, timer-mpu.c, and patches have been posted to add
    dmtimer.c. There's no need to have these multiple files, we can
    put everything into timer.c.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
new file mode 100644
index 000000000000..e9640728239b
--- /dev/null
+++ b/arch/arm/mach-omap2/timer.c
@@ -0,0 +1,342 @@
+/*
+ * linux/arch/arm/mach-omap2/timer.c
+ *
+ * OMAP2 GP timer support.
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Update to use new clocksource/clockevent layers
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ * Copyright (C) 2007 MontaVista Software, Inc.
+ *
+ * Original driver:
+ * Copyright (C) 2005 Nokia Corporation
+ * Author: Paul Mundt <paul.mundt@nokia.com>
+ *         Juha Yrjölä <juha.yrjola@nokia.com>
+ * OMAP Dual-mode timer framework support by Timo Teras
+ *
+ * Some parts based off of TI's 24xx code:
+ *
+ * Copyright (C) 2004-2009 Texas Instruments, Inc.
+ *
+ * Roughly modelled after the OMAP1 MPU timer code.
+ * Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+#include <asm/mach/time.h>
+#include <plat/dmtimer.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+#include <plat/common.h>
+#include <plat/omap_hwmod.h>
+
+/* Parent clocks, eventually these will come from the clock framework */
+
+#define OMAP2_MPU_SOURCE	"sys_ck"
+#define OMAP3_MPU_SOURCE	OMAP2_MPU_SOURCE
+#define OMAP4_MPU_SOURCE	"sys_clkin_ck"
+#define OMAP2_32K_SOURCE	"func_32k_ck"
+#define OMAP3_32K_SOURCE	"omap_32k_fck"
+#define OMAP4_32K_SOURCE	"sys_32k_ck"
+
+#ifdef CONFIG_OMAP_32K_TIMER
+#define OMAP2_CLKEV_SOURCE	OMAP2_32K_SOURCE
+#define OMAP3_CLKEV_SOURCE	OMAP3_32K_SOURCE
+#define OMAP4_CLKEV_SOURCE	OMAP4_32K_SOURCE
+#define OMAP3_SECURE_TIMER	12
+#else
+#define OMAP2_CLKEV_SOURCE	OMAP2_MPU_SOURCE
+#define OMAP3_CLKEV_SOURCE	OMAP3_MPU_SOURCE
+#define OMAP4_CLKEV_SOURCE	OMAP4_MPU_SOURCE
+#define OMAP3_SECURE_TIMER	1
+#endif
+
+/* MAX_GPTIMER_ID: number of GPTIMERs on the chip */
+#define MAX_GPTIMER_ID		12
+
+u32 sys_timer_reserved;
+
+/* Clockevent code */
+
+static struct omap_dm_timer clkev;
+static struct clock_event_device clockevent_gpt;
+
+static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &clockevent_gpt;
+
+	__omap_dm_timer_write_status(clkev.io_base, OMAP_TIMER_INT_OVERFLOW);
+
+	evt->event_handler(evt);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction omap2_gp_timer_irq = {
+	.name		= "gp timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= omap2_gp_timer_interrupt,
+};
+
+static int omap2_gp_timer_set_next_event(unsigned long cycles,
+					 struct clock_event_device *evt)
+{
+	__omap_dm_timer_load_start(clkev.io_base, OMAP_TIMER_CTRL_ST,
+						0xffffffff - cycles, 1);
+
+	return 0;
+}
+
+static void omap2_gp_timer_set_mode(enum clock_event_mode mode,
+				    struct clock_event_device *evt)
+{
+	u32 period;
+
+	__omap_dm_timer_stop(clkev.io_base, 1, clkev.rate);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		period = clkev.rate / HZ;
+		period -= 1;
+		/* Looks like we need to first set the load value separately */
+		__omap_dm_timer_write(clkev.io_base, OMAP_TIMER_LOAD_REG,
+					0xffffffff - period, 1);
+		__omap_dm_timer_load_start(clkev.io_base,
+					OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
+						0xffffffff - period, 1);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+}
+
+static struct clock_event_device clockevent_gpt = {
+	.name		= "gp timer",
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.shift		= 32,
+	.set_next_event	= omap2_gp_timer_set_next_event,
+	.set_mode	= omap2_gp_timer_set_mode,
+};
+
+static int __init omap_dm_timer_init_one(struct omap_dm_timer *timer,
+						int gptimer_id,
+						const char *fck_source)
+{
+	char name[10]; /* 10 = sizeof("gptXX_Xck0") */
+	struct omap_hwmod *oh;
+	size_t size;
+	int res = 0;
+
+	sprintf(name, "timer%d", gptimer_id);
+	omap_hwmod_setup_one(name);
+	oh = omap_hwmod_lookup(name);
+	if (!oh)
+		return -ENODEV;
+
+	timer->irq = oh->mpu_irqs[0].irq;
+	timer->phys_base = oh->slaves[0]->addr->pa_start;
+	size = oh->slaves[0]->addr->pa_end - timer->phys_base;
+
+	/* Static mapping, never released */
+	timer->io_base = ioremap(timer->phys_base, size);
+	if (!timer->io_base)
+		return -ENXIO;
+
+	/* After the dmtimer is using hwmod these clocks won't be needed */
+	sprintf(name, "gpt%d_fck", gptimer_id);
+	timer->fclk = clk_get(NULL, name);
+	if (IS_ERR(timer->fclk))
+		return -ENODEV;
+
+	sprintf(name, "gpt%d_ick", gptimer_id);
+	timer->iclk = clk_get(NULL, name);
+	if (IS_ERR(timer->iclk)) {
+		clk_put(timer->fclk);
+		return -ENODEV;
+	}
+
+	omap_hwmod_enable(oh);
+
+	sys_timer_reserved |= (1 << (gptimer_id - 1));
+
+	if (gptimer_id != 12) {
+		struct clk *src;
+
+		src = clk_get(NULL, fck_source);
+		if (IS_ERR(src)) {
+			res = -EINVAL;
+		} else {
+			res = __omap_dm_timer_set_source(timer->fclk, src);
+			if (IS_ERR_VALUE(res))
+				pr_warning("%s: timer%i cannot set source\n",
+						__func__, gptimer_id);
+			clk_put(src);
+		}
+	}
+	__omap_dm_timer_reset(timer->io_base, 1, 1);
+	timer->posted = 1;
+
+	timer->rate = clk_get_rate(timer->fclk);
+
+	timer->reserved = 1;
+
+	return res;
+}
+
+static void __init omap2_gp_clockevent_init(int gptimer_id,
+						const char *fck_source)
+{
+	int res;
+
+	res = omap_dm_timer_init_one(&clkev, gptimer_id, fck_source);
+	BUG_ON(res);
+
+	omap2_gp_timer_irq.dev_id = (void *)&clkev;
+	setup_irq(clkev.irq, &omap2_gp_timer_irq);
+
+	__omap_dm_timer_int_enable(clkev.io_base, OMAP_TIMER_INT_OVERFLOW);
+
+	clockevent_gpt.mult = div_sc(clkev.rate, NSEC_PER_SEC,
+				     clockevent_gpt.shift);
+	clockevent_gpt.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &clockevent_gpt);
+	clockevent_gpt.min_delta_ns =
+		clockevent_delta2ns(3, &clockevent_gpt);
+		/* Timer internal resynch latency. */
+
+	clockevent_gpt.cpumask = cpumask_of(0);
+	clockevents_register_device(&clockevent_gpt);
+
+	pr_info("OMAP clockevent source: GPTIMER%d at %lu Hz\n",
+		gptimer_id, clkev.rate);
+}
+
+/* Clocksource code */
+
+#ifdef CONFIG_OMAP_32K_TIMER
+/*
+ * When 32k-timer is enabled, don't use GPTimer for clocksource
+ * instead, just leave default clocksource which uses the 32k
+ * sync counter.  See clocksource setup in plat-omap/counter_32k.c
+ */
+
+static void __init omap2_gp_clocksource_init(int unused, const char *dummy)
+{
+	omap_init_clocksource_32k();
+}
+
+#else
+
+static struct omap_dm_timer clksrc;
+
+/*
+ * clocksource
+ */
+static DEFINE_CLOCK_DATA(cd);
+static cycle_t clocksource_read_cycles(struct clocksource *cs)
+{
+	return (cycle_t)__omap_dm_timer_read_counter(clksrc.io_base, 1);
+}
+
+static struct clocksource clocksource_gpt = {
+	.name		= "gp timer",
+	.rating		= 300,
+	.read		= clocksource_read_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void notrace dmtimer_update_sched_clock(void)
+{
+	u32 cyc;
+
+	cyc = __omap_dm_timer_read_counter(clksrc.io_base, 1);
+
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
+unsigned long long notrace sched_clock(void)
+{
+	u32 cyc = 0;
+
+	if (clksrc.reserved)
+		cyc = __omap_dm_timer_read_counter(clksrc.io_base, 1);
+
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+/* Setup free-running counter for clocksource */
+static void __init omap2_gp_clocksource_init(int gptimer_id,
+						const char *fck_source)
+{
+	int res;
+
+	res = omap_dm_timer_init_one(&clksrc, gptimer_id, fck_source);
+	BUG_ON(res);
+
+	pr_info("OMAP clocksource: GPTIMER%d at %lu Hz\n",
+		gptimer_id, clksrc.rate);
+
+	__omap_dm_timer_load_start(clksrc.io_base, OMAP_TIMER_CTRL_ST, 0, 1);
+	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, clksrc.rate);
+
+	if (clocksource_register_hz(&clocksource_gpt, clksrc.rate))
+		pr_err("Could not register clocksource %s\n",
+			clocksource_gpt.name);
+}
+#endif
+
+#define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src,			\
+				clksrc_nr, clksrc_src)			\
+static void __init omap##name##_timer_init(void)			\
+{									\
+	omap2_gp_clockevent_init((clkev_nr), clkev_src);		\
+	omap2_gp_clocksource_init((clksrc_nr), clksrc_src);		\
+}
+
+#define OMAP_SYS_TIMER(name)						\
+struct sys_timer omap##name##_timer = {					\
+	.init	= omap##name##_timer_init,				\
+};
+
+#ifdef CONFIG_ARCH_OMAP2
+OMAP_SYS_TIMER_INIT(2, 1, OMAP2_CLKEV_SOURCE, 2, OMAP2_MPU_SOURCE)
+OMAP_SYS_TIMER(2)
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3
+OMAP_SYS_TIMER_INIT(3, 1, OMAP3_CLKEV_SOURCE, 2, OMAP3_MPU_SOURCE)
+OMAP_SYS_TIMER(3)
+OMAP_SYS_TIMER_INIT(3_secure, OMAP3_SECURE_TIMER, OMAP3_CLKEV_SOURCE,
+			2, OMAP3_MPU_SOURCE)
+OMAP_SYS_TIMER(3_secure)
+#endif
+
+#ifdef CONFIG_ARCH_OMAP4
+static void __init omap4_timer_init(void)
+{
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = ioremap(OMAP44XX_LOCAL_TWD_BASE, SZ_256);
+	BUG_ON(!twd_base);
+#endif
+	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
+	omap2_gp_clocksource_init(2, OMAP4_MPU_SOURCE);
+}
+OMAP_SYS_TIMER(4)
+#endif
