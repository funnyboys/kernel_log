commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index a3c30655aa30..a709655b978c 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/kernel.h>
 #include <linux/init.h>
 

commit 46bf4a562207c5ebd24e1dde5e5ee326cd3d6b91
Merge: b197adabbd2f df7cded30ced
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Nov 6 17:06:37 2012 -0800

    Merge tag 'for_3.8-pm-voltage' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into omap-for-v3.8/pm
    
    OMAP voltage layer updates towards supporting auto-retention/auto-off

commit 085b30250041cd485555f547f625ec03341592dd
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:40 2012 +0300

    ARM: OMAP3+: vp: use new vp_params for calculating vddmin and vddmax
    
    Now we select the vddmin and vddmax values based on both pmic and
    voltage processor data, this allows usage of different power ICs.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index c7e0507bfbd3..394a253c4cd4 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -58,8 +58,10 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	sys_clk_rate = voltdm->sys_clk.rate / 1000;
 
 	timeout = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
-	vddmin = voltdm->pmic->uv_to_vsel(voltdm->pmic->vddmin);
-	vddmax = voltdm->pmic->uv_to_vsel(voltdm->pmic->vddmax);
+	vddmin = max(voltdm->vp_param->vddmin, voltdm->pmic->vddmin);
+	vddmax = min(voltdm->vp_param->vddmax, voltdm->pmic->vddmax);
+	vddmin = voltdm->pmic->uv_to_vsel(vddmin);
+	vddmax = voltdm->pmic->uv_to_vsel(vddmax);
 
 	waittime = DIV_ROUND_UP(voltdm->pmic->step_size * sys_clk_rate,
 				1000 * voltdm->pmic->slew_rate);

commit b254012b21e3f0dec798de8d12e3ce009d1c09e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:34 2012 +0300

    ARM: OMAP: voltage: renamed vp_vddmin and vp_vddmax fields
    
    These are now called vddmin and vddmax, as these fields will be used
    globally for selecting voltage ranges for a pmic channel, and not
    only for voltage processor.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 47c89eba57ca..c7e0507bfbd3 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -58,8 +58,8 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	sys_clk_rate = voltdm->sys_clk.rate / 1000;
 
 	timeout = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
-	vddmin = voltdm->pmic->uv_to_vsel(voltdm->pmic->vp_vddmin);
-	vddmax = voltdm->pmic->uv_to_vsel(voltdm->pmic->vp_vddmax);
+	vddmin = voltdm->pmic->uv_to_vsel(voltdm->pmic->vddmin);
+	vddmax = voltdm->pmic->uv_to_vsel(voltdm->pmic->vddmax);
 
 	waittime = DIV_ROUND_UP(voltdm->pmic->step_size * sys_clk_rate,
 				1000 * voltdm->pmic->slew_rate);

commit f2a0dfefec5fac797a5c6defa7e29db933a67a80
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Sep 25 19:33:33 2012 +0300

    ARM: OMAP3+: PM: VP: use uV for max and min voltage limits
    
    Every PMIC has it's own eccentricities, For example, one of the
    PMIC has MSB set to 1 for a specific function - voltage enable!
    using an hardcoded value specific for TWL when copied over to
    such an implementation causes the system to crash as the MSB bit
    was 0 and the voltage got disabled!.
    
    Instead we use actual values and depend on the convertion routines
    to abstract out the eccentricities of each PMIC.
    
    With this, we can now move the voltages to a common location in
    voltage.h as they are no longer dependent on PMICs and expect the
    PMIC's conversion routines to set a cap if the voltage is out of
    reach for the PMIC.
    
    Reported-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 85241b828c02..47c89eba57ca 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -58,8 +58,8 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	sys_clk_rate = voltdm->sys_clk.rate / 1000;
 
 	timeout = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
-	vddmin = voltdm->pmic->vp_vddmin;
-	vddmax = voltdm->pmic->vp_vddmax;
+	vddmin = voltdm->pmic->uv_to_vsel(voltdm->pmic->vp_vddmin);
+	vddmax = voltdm->pmic->uv_to_vsel(voltdm->pmic->vp_vddmax);
 
 	waittime = DIV_ROUND_UP(voltdm->pmic->step_size * sys_clk_rate,
 				1000 * voltdm->pmic->slew_rate);

commit 9bb053787d5ca12ec388bb5f871c79ffb83762ab
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Oct 25 13:37:16 2012 -0500

    ARM: OMAP2+: PM: VP: minor pr_warn updates
    
    change pr_warnings to pr_warn and ensure a newline
    is present in all messages
    
    Cc: linux-omap@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 85241b828c02..6e9fe8574315 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -138,7 +138,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 		udelay(1);
 	}
 	if (timeout >= VP_TRANXDONE_TIMEOUT) {
-		pr_warn("%s: vdd_%s TRANXDONE timeout exceeded. Voltage change aborted",
+		pr_warn("%s: vdd_%s TRANXDONE timeout exceeded. Voltage change aborted\n",
 			__func__, voltdm->name);
 		return -ETIMEDOUT;
 	}
@@ -197,7 +197,7 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 	u32 vpconfig, volt;
 
 	if (!voltdm || IS_ERR(voltdm)) {
-		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		pr_warn("%s: VDD specified does not exist!\n", __func__);
 		return;
 	}
 
@@ -214,8 +214,8 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 
 	volt = voltdm_get_voltage(voltdm);
 	if (!volt) {
-		pr_warning("%s: unable to find current voltage for %s\n",
-			   __func__, voltdm->name);
+		pr_warn("%s: unable to find current voltage for %s\n",
+			__func__, voltdm->name);
 		return;
 	}
 
@@ -242,7 +242,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 	int timeout;
 
 	if (!voltdm || IS_ERR(voltdm)) {
-		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		pr_warn("%s: VDD specified does not exist!\n", __func__);
 		return;
 	}
 
@@ -272,8 +272,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 			  VP_IDLE_TIMEOUT, timeout);
 
 	if (timeout >= VP_IDLE_TIMEOUT)
-		pr_warning("%s: vdd_%s idle timedout\n",
-			__func__, voltdm->name);
+		pr_warn("%s: vdd_%s idle timedout\n", __func__, voltdm->name);
 
 	vp->enabled = false;
 

commit 7852ec0536ca39cefffc6301dc77f8ae55592926
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jul 26 00:54:26 2012 -0600

    ARM: OMAP: unwrap strings
    
    Find and unwrap wrapped strings in the style:
    
            pr_debug("clockdomain: hardware cannot set/clear wake up of "
                     "%s when %s wakes up\n", clkdm1->name, clkdm2->name);
    
    Keeping these strings contiguous seems to be the current Linux kernel
    policy.
    
    The offending lines were found with the following command:
    
        pcregrep -rnM '"\s*$\s*"' arch/arm/*omap*
    
    While here, some messages have been clarified, some pr_warning(
    ... calls have been converted to pr_warn( ..., and some printk(KERN_*
    ... have been converted to pr_*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index f95c1bad9dc6..85241b828c02 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -138,8 +138,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 		udelay(1);
 	}
 	if (timeout >= VP_TRANXDONE_TIMEOUT) {
-		pr_warning("%s: vdd_%s TRANXDONE timeout exceeded."
-			"Voltage change aborted", __func__, voltdm->name);
+		pr_warn("%s: vdd_%s TRANXDONE timeout exceeded. Voltage change aborted",
+			__func__, voltdm->name);
 		return -ETIMEDOUT;
 	}
 
@@ -157,9 +157,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	omap_test_timeout(vp->common->ops->check_txdone(vp->id),
 			  VP_TRANXDONE_TIMEOUT, timeout);
 	if (timeout >= VP_TRANXDONE_TIMEOUT)
-		pr_err("%s: vdd_%s TRANXDONE timeout exceeded."
-			"TRANXDONE never got set after the voltage update\n",
-			__func__, voltdm->name);
+		pr_err("%s: vdd_%s TRANXDONE timeout exceeded. TRANXDONE never got set after the voltage update\n",
+		       __func__, voltdm->name);
 
 	omap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);
 
@@ -176,8 +175,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	}
 
 	if (timeout >= VP_TRANXDONE_TIMEOUT)
-		pr_warning("%s: vdd_%s TRANXDONE timeout exceeded while trying"
-			"to clear the TRANXDONE status\n",
+		pr_warn("%s: vdd_%s TRANXDONE timeout exceeded while trying to clear the TRANXDONE status\n",
 			__func__, voltdm->name);
 
 	/* Clear force bit */
@@ -257,8 +255,8 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 
 	/* If VP is already disabled, do nothing. Return */
 	if (!vp->enabled) {
-		pr_warning("%s: Trying to disable VP for vdd_%s when"
-			"it is already disabled\n", __func__, voltdm->name);
+		pr_warn("%s: Trying to disable VP for vdd_%s when it is already disabled\n",
+			__func__, voltdm->name);
 		return;
 	}
 

commit 3223d007a3f9ddbd68424adf628e740dd87c564f
Author: Yuan Jiangli <jlyuan@motorola.com>
Date:   Tue Mar 6 12:51:12 2012 -0600

    ARM: OMAP3+: PM: VP: fix integer truncation error
    
    commit 2f34ce81b8c05c900e45bd88595cc154f7bb5957
    (OMAP3: PM: Adding voltage driver support.)
    introduced runtime computation of waittime to handle all potential
    sys clocks available.
    
    In the voltage processor, the SPMSUpdateWait is calculated based on
    the slew rate and the voltage step (SMPSUpdateWait = slew rate *
    Voltage Step). After the voltage processor receives the SMPS_Ack
    signal, the Voltage Controller will wait for SMPSUpdateWait clock
    cycles for the voltage to settle to the new value. For all
    practical purposes, the waittime parameter is the OMAP hardware
    translation of what the slew rate on the PMIC is.
    
    As an example, with TPS62361 on OMAP4460,
    step_size = 10000
    slew_rate = 32000
    sys_clk_rate = 38400
    
    Our current computation results in the following:
     = ((step_size / slew_rate) * sys_clk_rate) / 1000
     = ((10000 / 32000) * 38400 / 1000
     = 0
    
    Fix the same using DIV_ROUND_UP as an extra wait clock cycle
    is better than lesser clock cycle. For the above example, this
    translates to:
     = (10000 * 38400) / (1000 * 32000)
     = 12
    
    Acked-by: Jon Hunter <jon-hunter@ti.com>
    [nm@ti.com: slightly better implementation]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Yuan Jiangli <jlyuan@motorola.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 0df88820978d..f95c1bad9dc6 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -61,8 +61,8 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	vddmin = voltdm->pmic->vp_vddmin;
 	vddmax = voltdm->pmic->vp_vddmax;
 
-	waittime = ((voltdm->pmic->step_size / voltdm->pmic->slew_rate) *
-		    sys_clk_rate) / 1000;
+	waittime = DIV_ROUND_UP(voltdm->pmic->step_size * sys_clk_rate,
+				1000 * voltdm->pmic->slew_rate);
 	vstepmin = voltdm->pmic->vp_vstepmin;
 	vstepmax = voltdm->pmic->vp_vstepmax;
 

commit d980e0f8d858c6963d676013e976ff00ab7acb2b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Feb 7 09:42:11 2012 +0000

    ARM: omap: fix oops in arch/arm/mach-omap2/vp.c when pmic is not found
    
    When the PMIC is not found, voltdm->pmic will be NULL.  vp.c's
    initialization function tries to dereferences this, which causes an
    oops:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000000
    pgd = c0004000
    [00000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT
    Modules linked in:
    CPU: 0    Not tainted  (3.3.0-rc2+ #204)
    PC is at omap_vp_init+0x5c/0x15c
    LR is at omap_vp_init+0x58/0x15c
    pc : [<c03db880>]    lr : [<c03db87c>]    psr: 60000013
    sp : c181ff30  ip : c181ff68  fp : c181ff64
    r10: c0407808  r9 : c040786c  r8 : c0407814
    r7 : c0026868  r6 : c00264fc  r5 : c040ad6c  r4 : 00000000
    r3 : 00000040  r2 : 000032c8  r1 : 0000fa00  r0 : 000032c8
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5387d  Table: 80004019  DAC: 00000015
    Process swapper (pid: 1, stack limit = 0xc181e2e8)
    Stack: (0xc181ff30 to 0xc1820000)
    ff20:                                     c0381d00 c02e9c6d c0383582 c040786c
    ff40: c040ad6c c00264fc c0026868 c0407814 00000000 c03d9de4 c181ff8c c181ff68
    ff60: c03db448 c03db830 c02e982c c03fdfb8 c03fe004 c0039988 00000013 00000000
    ff80: c181ff9c c181ff90 c03d9df8 c03db390 c181ffdc c181ffa0 c0008798 c03d9df0
    ffa0: c181ffc4 c181ffb0 c0055a44 c0187050 c0039988 c03fdfb8 c03fe004 c0039988
    ffc0: 00000013 00000000 00000000 00000000 c181fff4 c181ffe0 c03d1284 c0008708
    ffe0: 00000000 c03d1208 00000000 c181fff8 c0039988 c03d1214 1077ce40 01f7ee08
    Backtrace:
    [<c03db824>] (omap_vp_init+0x0/0x15c) from [<c03db448>] (omap_voltage_late_init+0xc4/0xfc)
    [<c03db384>] (omap_voltage_late_init+0x0/0xfc) from [<c03d9df8>] (omap2_common_pm_late_init+0x14/0x54)
     r8:00000000 r7:00000013 r6:c0039988 r5:c03fe004 r4:c03fdfb8
    [<c03d9de4>] (omap2_common_pm_late_init+0x0/0x54) from [<c0008798>] (do_one_initcall+0x9c/0x164)
    [<c00086fc>] (do_one_initcall+0x0/0x164) from [<c03d1284>] (kernel_init+0x7c/0x120)
    [<c03d1208>] (kernel_init+0x0/0x120) from [<c0039988>] (do_exit+0x0/0x2cc)
     r5:c03d1208 r4:00000000
    Code: e5ca300b e5900034 ebf69027 e5994024 (e5941000)
    ---[ end trace aed617dddaf32c3d ]---
    Kernel panic - not syncing: Attempted to kill init!
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 807391d84a9d..0df88820978d 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -41,6 +41,11 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	u32 val, sys_clk_rate, timeout, waittime;
 	u32 vddmin, vddmax, vstepmin, vstepmax;
 
+	if (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {
+		pr_err("%s: No PMIC info for vdd_%s\n", __func__, voltdm->name);
+		return;
+	}
+
 	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 66bd700a2b98..807391d84a9d 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -1,7 +1,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include <plat/common.h>
+#include "common.h"
 
 #include "voltage.h"
 #include "vp.h"

commit b666b4767d3e6a23634b4d485c8511bd42d50023
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri Jul 15 17:05:48 2011 -0700

    OMAP3+: VP: combine setting init voltage into common function
    
    combine VPCONFIG init voltage setup into common function and use from
    both vp_enable and from vp_forceupdate_scale().
    
    NOTE: this patch changes the sequence of when the initVDD bit is
    cleared.  The bit is now cleared immediately after it was written.
    Since only the rising edge of this bit has any affect according to the
    TRM, the exact timing of clearing of this bit should not have any
    effect.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 24020ea2b7e4..66bd700a2b98 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -9,31 +9,18 @@
 #include "prm-regbits-44xx.h"
 #include "prm44xx.h"
 
-static void vp_latch_vsel(struct voltagedomain *voltdm)
+static u32 _vp_set_init_voltage(struct voltagedomain *voltdm, u32 volt)
 {
 	struct omap_vp_instance *vp = voltdm->vp;
 	u32 vpconfig;
-	unsigned long uvdc;
 	char vsel;
 
-	uvdc = omap_voltage_get_nom_volt(voltdm);
-	if (!uvdc) {
-		pr_warning("%s: unable to find current voltage for vdd_%s\n",
-			__func__, voltdm->name);
-		return;
-	}
-
-	if (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {
-		pr_warning("%s: PMIC function to convert voltage in uV to"
-			" vsel not registered\n", __func__);
-		return;
-	}
-
-	vsel = voltdm->pmic->uv_to_vsel(uvdc);
+	vsel = voltdm->pmic->uv_to_vsel(volt);
 
 	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~(vp->common->vpconfig_initvoltage_mask |
-			vp->common->vpconfig_initvdd);
+		      vp->common->vpconfig_forceupdate |
+		      vp->common->vpconfig_initvdd);
 	vpconfig |= vsel << __ffs(vp->common->vpconfig_initvoltage_mask);
 	voltdm->write(vpconfig, vp->vpconfig);
 
@@ -43,6 +30,8 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 
 	/* Clear initVDD copy trigger bit */
 	voltdm->write(vpconfig, vp->vpconfig);
+
+	return vpconfig;
 }
 
 /* Generic voltage init functions */
@@ -149,22 +138,11 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 		return -ETIMEDOUT;
 	}
 
-	/* Configure for VP-Force Update */
-	vpconfig = voltdm->read(vp->vpconfig);
-	vpconfig &= ~(vp->common->vpconfig_initvdd |
-			vp->common->vpconfig_forceupdate |
-			vp->common->vpconfig_initvoltage_mask);
-	vpconfig |= ((target_vsel <<
-		      __ffs(vp->common->vpconfig_initvoltage_mask)));
-	voltdm->write(vpconfig, vp->vpconfig);
-
-	/* Trigger initVDD value copy to voltage processor */
-	vpconfig |= vp->common->vpconfig_initvdd;
-	voltdm->write(vpconfig, vp->vpconfig);
+	vpconfig = _vp_set_init_voltage(voltdm, target_volt);
 
 	/* Force update of voltage */
-	vpconfig |= vp->common->vpconfig_forceupdate;
-	voltdm->write(vpconfig, vp->vpconfig);
+	voltdm->write(vpconfig | vp->common->vpconfig_forceupdate,
+		      voltdm->vp->vpconfig);
 
 	/*
 	 * Wait for TransactionDone. Typical latency is <200us.
@@ -197,12 +175,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			"to clear the TRANXDONE status\n",
 			__func__, voltdm->name);
 
-	vpconfig = voltdm->read(vp->vpconfig);
-	/* Clear initVDD copy trigger bit */
-	vpconfig &= ~vp->common->vpconfig_initvdd;
-	voltdm->write(vpconfig, vp->vpconfig);
 	/* Clear force bit */
-	vpconfig &= ~vp->common->vpconfig_forceupdate;
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	return 0;
@@ -218,7 +191,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 void omap_vp_enable(struct voltagedomain *voltdm)
 {
 	struct omap_vp_instance *vp;
-	u32 vpconfig;
+	u32 vpconfig, volt;
 
 	if (!voltdm || IS_ERR(voltdm)) {
 		pr_warning("%s: VDD specified does not exist!\n", __func__);
@@ -236,12 +209,19 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 	if (vp->enabled)
 		return;
 
-	vp_latch_vsel(voltdm);
+	volt = voltdm_get_voltage(voltdm);
+	if (!volt) {
+		pr_warning("%s: unable to find current voltage for %s\n",
+			   __func__, voltdm->name);
+		return;
+	}
+
+	vpconfig = _vp_set_init_voltage(voltdm, volt);
 
 	/* Enable VP */
-	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig |= vp->common->vpconfig_vpenable;
 	voltdm->write(vpconfig, vp->vpconfig);
+
 	vp->enabled = true;
 }
 

commit cc6962dbab223ae51b47c8057d39d89ac6af0d35
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri Jul 15 16:38:10 2011 -0700

    OMAP3+: VP: remove unused omap_vp_get_curr_volt()
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 29698acc2aea..24020ea2b7e4 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -208,40 +208,6 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	return 0;
 }
 
-/**
- * omap_vp_get_curr_volt() - API to get the current vp voltage.
- * @voltdm:	pointer to the VDD.
- *
- * This API returns the current voltage for the specified voltage processor
- */
-unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
-{
-	struct omap_vp_instance *vp = voltdm->vp;
-	u8 curr_vsel;
-
-	if (!voltdm || IS_ERR(voltdm)) {
-		pr_warning("%s: VDD specified does not exist!\n", __func__);
-		return 0;
-	}
-
-	if (!voltdm->read) {
-		pr_err("%s: No read API for reading vdd_%s regs\n",
-			__func__, voltdm->name);
-		return 0;
-	}
-
-	curr_vsel = (voltdm->read(vp->voltage) & vp->common->vpvoltage_mask)
-		>> __ffs(vp->common->vpvoltage_mask);
-
-	if (!voltdm->pmic || !voltdm->pmic->vsel_to_uv) {
-		pr_warning("%s: PMIC function to convert vsel to voltage"
-			"in uV not registerd\n", __func__);
-		return 0;
-	}
-
-	return voltdm->pmic->vsel_to_uv(curr_vsel);
-}
-
 /**
  * omap_vp_enable() - API to enable a particular VP
  * @voltdm:	pointer to the VDD whose VP is to be enabled.

commit 8798c4ab56d8f726092870cb2cf15c5a7a0a93bf
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jul 18 15:31:43 2011 -0700

    OMAP3+: VP: update_errorgain(): return error if VP
    
    Add check for valid VP in omap_vp_update_errorgain()
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 38076205312e..29698acc2aea 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -103,6 +103,9 @@ int omap_vp_update_errorgain(struct voltagedomain *voltdm,
 {
 	struct omap_volt_data *volt_data;
 
+	if (!voltdm->vp)
+		return -EINVAL;
+
 	/* Get volt_data corresponding to target_volt */
 	volt_data = omap_voltage_get_voltdata(voltdm, target_volt);
 	if (IS_ERR(volt_data))

commit bea30ed65fb2432097f362ce17042e22febcb616
Author: Todd Poynor <toddpoynor@google.com>
Date:   Fri May 27 19:15:59 2011 -0700

    OMAP: VP: Explicitly mask VPVOLTAGE field
    
    Reading the VPVOLTAGE field of PRM_VP_*_VOLTAGE registers currently
    relies on a u32 -> u8 conversion to mask off the FORCEUPDATEWAIT field
    in the upper bits.  Make this explicit using the mask symbol
    already defined, added as a new field in struct omap_vp_common.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index e7d38f67db87..38076205312e 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -227,7 +227,8 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 		return 0;
 	}
 
-	curr_vsel = voltdm->read(vp->voltage);
+	curr_vsel = (voltdm->read(vp->voltage) & vp->common->vpvoltage_mask)
+		>> __ffs(vp->common->vpvoltage_mask);
 
 	if (!voltdm->pmic || !voltdm->pmic->vsel_to_uv) {
 		pr_warning("%s: PMIC function to convert vsel to voltage"

commit 667216d6a435a27f5aed64aa30de583ddccc58c8
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Apr 4 17:58:21 2011 -0700

    OMAP3+: VP: remove omap_vp_runtime_data
    
    Remove the "runtime" VP data in favor of direct programming of VP registers.
    The VP is in the PRM, which is in the wakeup powerdomain, so there is no
    need to keep the state dynamically.
    
    Fixes to original version from Nishanth Menon <nm@ti.com>
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index f68a6db27111..e7d38f67db87 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -49,8 +49,8 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 void __init omap_vp_init(struct voltagedomain *voltdm)
 {
 	struct omap_vp_instance *vp = voltdm->vp;
-	struct omap_vdd_info *vdd = voltdm->vdd;
-	u32 vp_val, sys_clk_rate, timeout_val, waittime;
+	u32 val, sys_clk_rate, timeout, waittime;
+	u32 vddmin, vddmax, vstepmin, vstepmax;
 
 	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
@@ -63,47 +63,39 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	/* Divide to avoid overflow */
 	sys_clk_rate = voltdm->sys_clk.rate / 1000;
 
-	vdd->vp_rt_data.vpconfig_erroroffset =
-		(voltdm->pmic->vp_erroroffset <<
-		 __ffs(voltdm->vp->common->vpconfig_erroroffset_mask));
-
-	timeout_val = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
-	vdd->vp_rt_data.vlimitto_timeout = timeout_val;
-	vdd->vp_rt_data.vlimitto_vddmin = voltdm->pmic->vp_vddmin;
-	vdd->vp_rt_data.vlimitto_vddmax = voltdm->pmic->vp_vddmax;
+	timeout = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
+	vddmin = voltdm->pmic->vp_vddmin;
+	vddmax = voltdm->pmic->vp_vddmax;
 
 	waittime = ((voltdm->pmic->step_size / voltdm->pmic->slew_rate) *
 		    sys_clk_rate) / 1000;
-	vdd->vp_rt_data.vstepmin_smpswaittimemin = waittime;
-	vdd->vp_rt_data.vstepmax_smpswaittimemax = waittime;
-	vdd->vp_rt_data.vstepmin_stepmin = voltdm->pmic->vp_vstepmin;
-	vdd->vp_rt_data.vstepmax_stepmax = voltdm->pmic->vp_vstepmax;
-
-	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
-		(vdd->vp_rt_data.vpconfig_errorgain <<
-		 __ffs(vp->common->vpconfig_errorgain_mask)) |
+	vstepmin = voltdm->pmic->vp_vstepmin;
+	vstepmax = voltdm->pmic->vp_vstepmax;
+
+	/*
+	 * VP_CONFIG: error gain is not set here, it will be updated
+	 * on each scale, based on OPP.
+	 */
+	val = (voltdm->pmic->vp_erroroffset <<
+	       __ffs(voltdm->vp->common->vpconfig_erroroffset_mask)) |
 		vp->common->vpconfig_timeouten;
-	voltdm->write(vp_val, vp->vpconfig);
-
-	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
-		   vp->common->vstepmin_smpswaittimemin_shift) |
-		  (vdd->vp_rt_data.vstepmin_stepmin <<
-		   vp->common->vstepmin_stepmin_shift));
-	voltdm->write(vp_val, vp->vstepmin);
-
-	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
-		   vp->common->vstepmax_smpswaittimemax_shift) |
-		  (vdd->vp_rt_data.vstepmax_stepmax <<
-		   vp->common->vstepmax_stepmax_shift));
-	voltdm->write(vp_val, vp->vstepmax);
-
-	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
-		   vp->common->vlimitto_vddmax_shift) |
-		  (vdd->vp_rt_data.vlimitto_vddmin <<
-		   vp->common->vlimitto_vddmin_shift) |
-		  (vdd->vp_rt_data.vlimitto_timeout <<
-		   vp->common->vlimitto_timeout_shift));
-	voltdm->write(vp_val, vp->vlimitto);
+	voltdm->write(val, vp->vpconfig);
+
+	/* VSTEPMIN */
+	val = (waittime << vp->common->vstepmin_smpswaittimemin_shift) |
+		(vstepmin <<  vp->common->vstepmin_stepmin_shift);
+	voltdm->write(val, vp->vstepmin);
+
+	/* VSTEPMAX */
+	val = (vstepmax << vp->common->vstepmax_stepmax_shift) |
+		(waittime << vp->common->vstepmax_smpswaittimemax_shift);
+	voltdm->write(val, vp->vstepmax);
+
+	/* VLIMITTO */
+	val = (vddmax << vp->common->vlimitto_vddmax_shift) |
+		(vddmin << vp->common->vlimitto_vddmin_shift) |
+		(timeout <<  vp->common->vlimitto_timeout_shift);
+	voltdm->write(val, vp->vlimitto);
 }
 
 int omap_vp_update_errorgain(struct voltagedomain *voltdm,

commit 76ea7424f80350884b4d70ae54cfa51f7f9b2a48
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Apr 5 15:15:31 2011 -0700

    OMAP3+: VP: create VP helper function for updating error gain
    
    Create new helper function in VP layer for updating VP error gain.
    Currently used during pre-scale for VP force update and VC bypass.
    
    TODO: determine if this can be removed from the pre-scale path and
    moved to VP enable path.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index ea61a47bd199..f68a6db27111 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -106,6 +106,25 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	voltdm->write(vp_val, vp->vlimitto);
 }
 
+int omap_vp_update_errorgain(struct voltagedomain *voltdm,
+			     unsigned long target_volt)
+{
+	struct omap_volt_data *volt_data;
+
+	/* Get volt_data corresponding to target_volt */
+	volt_data = omap_voltage_get_voltdata(voltdm, target_volt);
+	if (IS_ERR(volt_data))
+		return -EINVAL;
+
+	/* Setting vp errorgain based on the voltage */
+	voltdm->rmw(voltdm->vp->common->vpconfig_errorgain_mask,
+		    volt_data->vp_errgain <<
+		    __ffs(voltdm->vp->common->vpconfig_errorgain_mask),
+		    voltdm->vp->vpconfig);
+
+	return 0;
+}
+
 /* VP force update method of voltage scaling */
 int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			      unsigned long target_volt)

commit 6f56727383ca3233f40af5e792a08bf07b18f5fd
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu Jul 14 11:10:27 2011 -0700

    OMAP3+: VP: move timing calculation/config into VP init
    
    Move VP timing calcluation (based on sys clock) and register programming
    into VP init.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 297d094263aa..ea61a47bd199 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -50,7 +50,7 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 {
 	struct omap_vp_instance *vp = voltdm->vp;
 	struct omap_vdd_info *vdd = voltdm->vdd;
-	u32 vp_val;
+	u32 vp_val, sys_clk_rate, timeout_val, waittime;
 
 	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
@@ -58,6 +58,27 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 		return;
 	}
 
+	vp->enabled = false;
+
+	/* Divide to avoid overflow */
+	sys_clk_rate = voltdm->sys_clk.rate / 1000;
+
+	vdd->vp_rt_data.vpconfig_erroroffset =
+		(voltdm->pmic->vp_erroroffset <<
+		 __ffs(voltdm->vp->common->vpconfig_erroroffset_mask));
+
+	timeout_val = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;
+	vdd->vp_rt_data.vlimitto_timeout = timeout_val;
+	vdd->vp_rt_data.vlimitto_vddmin = voltdm->pmic->vp_vddmin;
+	vdd->vp_rt_data.vlimitto_vddmax = voltdm->pmic->vp_vddmax;
+
+	waittime = ((voltdm->pmic->step_size / voltdm->pmic->slew_rate) *
+		    sys_clk_rate) / 1000;
+	vdd->vp_rt_data.vstepmin_smpswaittimemin = waittime;
+	vdd->vp_rt_data.vstepmax_smpswaittimemax = waittime;
+	vdd->vp_rt_data.vstepmin_stepmin = voltdm->pmic->vp_vstepmin;
+	vdd->vp_rt_data.vstepmax_stepmax = voltdm->pmic->vp_vstepmax;
+
 	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
 		(vdd->vp_rt_data.vpconfig_errorgain <<
 		 __ffs(vp->common->vpconfig_errorgain_mask)) |

commit 0ec3041e91cf365a76c81b224e85d3c2574fec23
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Apr 4 16:02:28 2011 -0700

    OMAP3+: VP: struct omap_vp_common: replace shift with __ffs(mask)
    
    In struct omap_vp_common, the shift value can be derived from the mask
    value by using __ffs(), so remove the shift value for the various
    VPCONFIG bitfields, and use __ffs() in the code for the shift value.
    
    While here, rename field names in kerneldoc comment to match actual
    field names in structure.  Also, cleanup indendentaion for other VP
    register accesses in omap_vp_init().
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index c9a315f9d3d8..297d094263aa 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -34,8 +34,7 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~(vp->common->vpconfig_initvoltage_mask |
 			vp->common->vpconfig_initvdd);
-	vpconfig |= vsel << vp->common->vpconfig_initvoltage_shift;
-
+	vpconfig |= vsel << __ffs(vp->common->vpconfig_initvoltage_mask);
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
@@ -61,28 +60,28 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 
 	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
 		(vdd->vp_rt_data.vpconfig_errorgain <<
-		vp->common->vpconfig_errorgain_shift) |
+		 __ffs(vp->common->vpconfig_errorgain_mask)) |
 		vp->common->vpconfig_timeouten;
 	voltdm->write(vp_val, vp->vpconfig);
 
 	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
-		vp->common->vstepmin_smpswaittimemin_shift) |
-		(vdd->vp_rt_data.vstepmin_stepmin <<
-		vp->common->vstepmin_stepmin_shift));
+		   vp->common->vstepmin_smpswaittimemin_shift) |
+		  (vdd->vp_rt_data.vstepmin_stepmin <<
+		   vp->common->vstepmin_stepmin_shift));
 	voltdm->write(vp_val, vp->vstepmin);
 
 	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
-		vp->common->vstepmax_smpswaittimemax_shift) |
-		(vdd->vp_rt_data.vstepmax_stepmax <<
-		vp->common->vstepmax_stepmax_shift));
+		   vp->common->vstepmax_smpswaittimemax_shift) |
+		  (vdd->vp_rt_data.vstepmax_stepmax <<
+		   vp->common->vstepmax_stepmax_shift));
 	voltdm->write(vp_val, vp->vstepmax);
 
 	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
-		vp->common->vlimitto_vddmax_shift) |
-		(vdd->vp_rt_data.vlimitto_vddmin <<
-		vp->common->vlimitto_vddmin_shift) |
-		(vdd->vp_rt_data.vlimitto_timeout <<
-		vp->common->vlimitto_timeout_shift));
+		   vp->common->vlimitto_vddmax_shift) |
+		  (vdd->vp_rt_data.vlimitto_vddmin <<
+		   vp->common->vlimitto_vddmin_shift) |
+		  (vdd->vp_rt_data.vlimitto_timeout <<
+		   vp->common->vlimitto_timeout_shift));
 	voltdm->write(vp_val, vp->vlimitto);
 }
 
@@ -121,7 +120,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			vp->common->vpconfig_forceupdate |
 			vp->common->vpconfig_initvoltage_mask);
 	vpconfig |= ((target_vsel <<
-			vp->common->vpconfig_initvoltage_shift));
+		      __ffs(vp->common->vpconfig_initvoltage_mask)));
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */

commit 633ef8b7475a224b6be662d7c698cd705157064f
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Apr 5 14:39:11 2011 -0700

    OMAP3+: voltage: remove unneeded debugfs interface
    
    Remove read-only debugfs interface to VP values.  Most of the values
    are init-time only and never change.  Current voltage value should be
    retreived from the (eventual) regulator framework interface to the
    voltage domain.
    
    Fixes to original version provided by Nishanth Menon <nm@ti.com>
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 53d6018fa678..c9a315f9d3d8 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -1,6 +1,5 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/debugfs.h>
 
 #include <plat/common.h>
 
@@ -10,8 +9,6 @@
 #include "prm-regbits-44xx.h"
 #include "prm44xx.h"
 
-static void __init vp_debugfs_init(struct voltagedomain *voltdm);
-
 static void vp_latch_vsel(struct voltagedomain *voltdm)
 {
 	struct omap_vp_instance *vp = voltdm->vp;
@@ -87,8 +84,6 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 		(vdd->vp_rt_data.vlimitto_timeout <<
 		vp->common->vlimitto_timeout_shift));
 	voltdm->write(vp_val, vp->vlimitto);
-
-	vp_debugfs_init(voltdm);
 }
 
 /* VP force update method of voltage scaling */
@@ -300,61 +295,3 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 
 	return;
 }
-
-/* Voltage debugfs support */
-static int vp_volt_debug_get(void *data, u64 *val)
-{
-	struct voltagedomain *voltdm = (struct voltagedomain *)data;
-	struct omap_vp_instance *vp = voltdm->vp;
-	struct omap_vdd_info *vdd = voltdm->vdd;
-	u8 vsel;
-
-	if (!vdd) {
-		pr_warning("Wrong paramater passed\n");
-		return -EINVAL;
-	}
-
-	vsel = voltdm->read(vp->voltage);
-
-	if (!voltdm->pmic->vsel_to_uv) {
-		pr_warning("PMIC function to convert vsel to voltage"
-			"in uV not registerd\n");
-		return -EINVAL;
-	}
-
-	*val = voltdm->pmic->vsel_to_uv(vsel);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(vp_volt_debug_fops, vp_volt_debug_get, NULL, "%llu\n");
-
-static void __init vp_debugfs_init(struct voltagedomain *voltdm)
-{
-	struct omap_vdd_info *vdd = voltdm->vdd;
-	struct dentry *debug_dir;
-
-	debug_dir = debugfs_create_dir("vp", vdd->debug_dir);
-	if (IS_ERR(debug_dir))
-		pr_err("%s: Unable to create VP debugfs dir dir\n", __func__);
-
-	(void) debugfs_create_x16("errorgain", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vpconfig_errorgain));
-	(void) debugfs_create_x16("smpswaittimemin", S_IRUGO,
-				debug_dir,
-				&(vdd->vp_rt_data.vstepmin_smpswaittimemin));
-	(void) debugfs_create_x8("stepmin", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vstepmin_stepmin));
-	(void) debugfs_create_x16("smpswaittimemax", S_IRUGO,
-				debug_dir,
-				&(vdd->vp_rt_data.vstepmax_smpswaittimemax));
-	(void) debugfs_create_x8("stepmax", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vstepmax_stepmax));
-	(void) debugfs_create_x8("vddmax", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vlimitto_vddmax));
-	(void) debugfs_create_x8("vddmin", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vlimitto_vddmin));
-	(void) debugfs_create_x16("timeout", S_IRUGO, debug_dir,
-				&(vdd->vp_rt_data.vlimitto_timeout));
-	(void) debugfs_create_file("curr_volt", S_IRUGO, debug_dir,
-				(void *) voltdm, &vp_volt_debug_fops);
-}

commit b7ea803e55769768d1eff3b32e4f99837fa6ddb5
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Apr 4 15:25:07 2011 -0700

    OMAP3+: VP: cleanup: move VP instance into voltdm, misc. renames
    
    - move VP instance struct from vdd_info into struct voltage domain
    - remove _data suffix from structure name
    - rename vp_ prefix from vp_common field: accesses are now vp->common
    - move vp_enabled bool from vdd_info into VP instance
    - remove remaining references to omap_vdd_info
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index a3afcbe741e3..53d6018fa678 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -14,7 +14,7 @@ static void __init vp_debugfs_init(struct voltagedomain *voltdm);
 
 static void vp_latch_vsel(struct voltagedomain *voltdm)
 {
-	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vp_instance *vp = voltdm->vp;
 	u32 vpconfig;
 	unsigned long uvdc;
 	char vsel;
@@ -35,14 +35,14 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 	vsel = voltdm->pmic->uv_to_vsel(uvdc);
 
 	vpconfig = voltdm->read(vp->vpconfig);
-	vpconfig &= ~(vp->vp_common->vpconfig_initvoltage_mask |
-			vp->vp_common->vpconfig_initvdd);
-	vpconfig |= vsel << vp->vp_common->vpconfig_initvoltage_shift;
+	vpconfig &= ~(vp->common->vpconfig_initvoltage_mask |
+			vp->common->vpconfig_initvdd);
+	vpconfig |= vsel << vp->common->vpconfig_initvoltage_shift;
 
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
-	voltdm->write((vpconfig | vp->vp_common->vpconfig_initvdd),
+	voltdm->write((vpconfig | vp->common->vpconfig_initvdd),
 		       vp->vpconfig);
 
 	/* Clear initVDD copy trigger bit */
@@ -52,7 +52,7 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 /* Generic voltage init functions */
 void __init omap_vp_init(struct voltagedomain *voltdm)
 {
-	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vp_instance *vp = voltdm->vp;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 vp_val;
 
@@ -64,28 +64,28 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 
 	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
 		(vdd->vp_rt_data.vpconfig_errorgain <<
-		vp->vp_common->vpconfig_errorgain_shift) |
-		vp->vp_common->vpconfig_timeouten;
+		vp->common->vpconfig_errorgain_shift) |
+		vp->common->vpconfig_timeouten;
 	voltdm->write(vp_val, vp->vpconfig);
 
 	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
-		vp->vp_common->vstepmin_smpswaittimemin_shift) |
+		vp->common->vstepmin_smpswaittimemin_shift) |
 		(vdd->vp_rt_data.vstepmin_stepmin <<
-		vp->vp_common->vstepmin_stepmin_shift));
+		vp->common->vstepmin_stepmin_shift));
 	voltdm->write(vp_val, vp->vstepmin);
 
 	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
-		vp->vp_common->vstepmax_smpswaittimemax_shift) |
+		vp->common->vstepmax_smpswaittimemax_shift) |
 		(vdd->vp_rt_data.vstepmax_stepmax <<
-		vp->vp_common->vstepmax_stepmax_shift));
+		vp->common->vstepmax_stepmax_shift));
 	voltdm->write(vp_val, vp->vstepmax);
 
 	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
-		vp->vp_common->vlimitto_vddmax_shift) |
+		vp->common->vlimitto_vddmax_shift) |
 		(vdd->vp_rt_data.vlimitto_vddmin <<
-		vp->vp_common->vlimitto_vddmin_shift) |
+		vp->common->vlimitto_vddmin_shift) |
 		(vdd->vp_rt_data.vlimitto_timeout <<
-		vp->vp_common->vlimitto_timeout_shift));
+		vp->common->vlimitto_timeout_shift));
 	voltdm->write(vp_val, vp->vlimitto);
 
 	vp_debugfs_init(voltdm);
@@ -95,7 +95,7 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			      unsigned long target_volt)
 {
-	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vp_instance *vp = voltdm->vp;
 	u32 vpconfig;
 	u8 target_vsel, current_vsel;
 	int ret, timeout = 0;
@@ -109,8 +109,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 * is <3us
 	 */
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vp->vp_common->ops->clear_txdone(vp->id);
-		if (!vp->vp_common->ops->check_txdone(vp->id))
+		vp->common->ops->clear_txdone(vp->id);
+		if (!vp->common->ops->check_txdone(vp->id))
 			break;
 		udelay(1);
 	}
@@ -122,19 +122,19 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 
 	/* Configure for VP-Force Update */
 	vpconfig = voltdm->read(vp->vpconfig);
-	vpconfig &= ~(vp->vp_common->vpconfig_initvdd |
-			vp->vp_common->vpconfig_forceupdate |
-			vp->vp_common->vpconfig_initvoltage_mask);
+	vpconfig &= ~(vp->common->vpconfig_initvdd |
+			vp->common->vpconfig_forceupdate |
+			vp->common->vpconfig_initvoltage_mask);
 	vpconfig |= ((target_vsel <<
-			vp->vp_common->vpconfig_initvoltage_shift));
+			vp->common->vpconfig_initvoltage_shift));
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
-	vpconfig |= vp->vp_common->vpconfig_initvdd;
+	vpconfig |= vp->common->vpconfig_initvdd;
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Force update of voltage */
-	vpconfig |= vp->vp_common->vpconfig_forceupdate;
+	vpconfig |= vp->common->vpconfig_forceupdate;
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/*
@@ -142,7 +142,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 * Depends on SMPSWAITTIMEMIN/MAX and voltage change
 	 */
 	timeout = 0;
-	omap_test_timeout(vp->vp_common->ops->check_txdone(vp->id),
+	omap_test_timeout(vp->common->ops->check_txdone(vp->id),
 			  VP_TRANXDONE_TIMEOUT, timeout);
 	if (timeout >= VP_TRANXDONE_TIMEOUT)
 		pr_err("%s: vdd_%s TRANXDONE timeout exceeded."
@@ -157,8 +157,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 */
 	timeout = 0;
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vp->vp_common->ops->clear_txdone(vp->id);
-		if (!vp->vp_common->ops->check_txdone(vp->id))
+		vp->common->ops->clear_txdone(vp->id);
+		if (!vp->common->ops->check_txdone(vp->id))
 			break;
 		udelay(1);
 	}
@@ -170,10 +170,10 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 
 	vpconfig = voltdm->read(vp->vpconfig);
 	/* Clear initVDD copy trigger bit */
-	vpconfig &= ~vp->vp_common->vpconfig_initvdd;
+	vpconfig &= ~vp->common->vpconfig_initvdd;
 	voltdm->write(vpconfig, vp->vpconfig);
 	/* Clear force bit */
-	vpconfig &= ~vp->vp_common->vpconfig_forceupdate;
+	vpconfig &= ~vp->common->vpconfig_forceupdate;
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	return 0;
@@ -187,8 +187,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
  */
 unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 {
-	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
-	struct omap_vdd_info *vdd;
+	struct omap_vp_instance *vp = voltdm->vp;
 	u8 curr_vsel;
 
 	if (!voltdm || IS_ERR(voltdm)) {
@@ -196,7 +195,6 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 		return 0;
 	}
 
-	vdd = voltdm->vdd;
 	if (!voltdm->read) {
 		pr_err("%s: No read API for reading vdd_%s regs\n",
 			__func__, voltdm->name);
@@ -223,8 +221,7 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
  */
 void omap_vp_enable(struct voltagedomain *voltdm)
 {
-	struct omap_vp_instance_data *vp;
-	struct omap_vdd_info *vdd;
+	struct omap_vp_instance *vp;
 	u32 vpconfig;
 
 	if (!voltdm || IS_ERR(voltdm)) {
@@ -232,8 +229,7 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 		return;
 	}
 
-	vdd = voltdm->vdd;
-	vp = voltdm->vdd->vp_data;
+	vp = voltdm->vp;
 	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
@@ -241,16 +237,16 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 	}
 
 	/* If VP is already enabled, do nothing. Return */
-	if (vdd->vp_enabled)
+	if (vp->enabled)
 		return;
 
 	vp_latch_vsel(voltdm);
 
 	/* Enable VP */
 	vpconfig = voltdm->read(vp->vpconfig);
-	vpconfig |= vp->vp_common->vpconfig_vpenable;
+	vpconfig |= vp->common->vpconfig_vpenable;
 	voltdm->write(vpconfig, vp->vpconfig);
-	vdd->vp_enabled = true;
+	vp->enabled = true;
 }
 
 /**
@@ -262,8 +258,7 @@ void omap_vp_enable(struct voltagedomain *voltdm)
  */
 void omap_vp_disable(struct voltagedomain *voltdm)
 {
-	struct omap_vp_instance_data *vp;
-	struct omap_vdd_info *vdd;
+	struct omap_vp_instance *vp;
 	u32 vpconfig;
 	int timeout;
 
@@ -272,8 +267,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 		return;
 	}
 
-	vdd = voltdm->vdd;
-	vp = voltdm->vdd->vp_data;
+	vp = voltdm->vp;
 	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
@@ -281,7 +275,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 	}
 
 	/* If VP is already disabled, do nothing. Return */
-	if (!vdd->vp_enabled) {
+	if (!vp->enabled) {
 		pr_warning("%s: Trying to disable VP for vdd_%s when"
 			"it is already disabled\n", __func__, voltdm->name);
 		return;
@@ -289,7 +283,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 
 	/* Disable VP */
 	vpconfig = voltdm->read(vp->vpconfig);
-	vpconfig &= ~vp->vp_common->vpconfig_vpenable;
+	vpconfig &= ~vp->common->vpconfig_vpenable;
 	voltdm->write(vpconfig, vp->vpconfig);
 
 	/*
@@ -302,7 +296,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 		pr_warning("%s: vdd_%s idle timedout\n",
 			__func__, voltdm->name);
 
-	vdd->vp_enabled = false;
+	vp->enabled = false;
 
 	return;
 }
@@ -311,7 +305,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 static int vp_volt_debug_get(void *data, u64 *val)
 {
 	struct voltagedomain *voltdm = (struct voltagedomain *)data;
-	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vp_instance *vp = voltdm->vp;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	u8 vsel;
 

commit ce8ebe0dfb1f8713337cebf82499d3dced288328
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Mar 30 11:01:10 2011 -0700

    OMAP3+: voltage domain: move PMIC struct from vdd_info into struct voltagedomain
    
    Move structure containing PMIC configurable settings into struct
    voltagedomain.  In the process, rename from omap_volt_pmic_info to
    omap_voltdm_pmic (_info suffix is not helpful.)
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 88ac742a38cf..a3afcbe741e3 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -18,7 +18,6 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 	u32 vpconfig;
 	unsigned long uvdc;
 	char vsel;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 
 	uvdc = omap_voltage_get_nom_volt(voltdm);
 	if (!uvdc) {
@@ -27,13 +26,13 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 		return;
 	}
 
-	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
+	if (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {
 		pr_warning("%s: PMIC function to convert voltage in uV to"
 			" vsel not registered\n", __func__);
 		return;
 	}
 
-	vsel = vdd->pmic_info->uv_to_vsel(uvdc);
+	vsel = voltdm->pmic->uv_to_vsel(uvdc);
 
 	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~(vp->vp_common->vpconfig_initvoltage_mask |
@@ -206,13 +205,13 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 
 	curr_vsel = voltdm->read(vp->voltage);
 
-	if (!vdd->pmic_info || !vdd->pmic_info->vsel_to_uv) {
+	if (!voltdm->pmic || !voltdm->pmic->vsel_to_uv) {
 		pr_warning("%s: PMIC function to convert vsel to voltage"
 			"in uV not registerd\n", __func__);
 		return 0;
 	}
 
-	return vdd->pmic_info->vsel_to_uv(curr_vsel);
+	return voltdm->pmic->vsel_to_uv(curr_vsel);
 }
 
 /**
@@ -323,13 +322,13 @@ static int vp_volt_debug_get(void *data, u64 *val)
 
 	vsel = voltdm->read(vp->voltage);
 
-	if (!vdd->pmic_info->vsel_to_uv) {
+	if (!voltdm->pmic->vsel_to_uv) {
 		pr_warning("PMIC function to convert vsel to voltage"
 			"in uV not registerd\n");
 		return -EINVAL;
 	}
 
-	*val = vdd->pmic_info->vsel_to_uv(vsel);
+	*val = voltdm->pmic->vsel_to_uv(vsel);
 	return 0;
 }
 

commit 4bcc475ebd06a04e1531254c27c6cf508ef8ebf9
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 28 10:40:15 2011 -0700

    OMAP3+: voltage: convert to PRM register access functions
    
    Convert VC/VP register access to use PRM VC/VP accessor functions.  In
    the process, move the read/write function pointers from vdd_info into
    struct voltagedomain.
    
    No functional changes.
    
    Additional cleanup:
    - remove prm_mod field from  VC/VP data structures, the PRM register
      access functions know which PRM module to use.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index 113c839f6e23..88ac742a38cf 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -35,19 +35,19 @@ static void vp_latch_vsel(struct voltagedomain *voltdm)
 
 	vsel = vdd->pmic_info->uv_to_vsel(uvdc);
 
-	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~(vp->vp_common->vpconfig_initvoltage_mask |
 			vp->vp_common->vpconfig_initvdd);
 	vpconfig |= vsel << vp->vp_common->vpconfig_initvoltage_shift;
 
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
-	vdd->write_reg((vpconfig | vp->vp_common->vpconfig_initvdd),
-		       vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write((vpconfig | vp->vp_common->vpconfig_initvdd),
+		       vp->vpconfig);
 
 	/* Clear initVDD copy trigger bit */
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 }
 
 /* Generic voltage init functions */
@@ -57,7 +57,7 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 vp_val;
 
-	if (!vdd->read_reg || !vdd->write_reg) {
+	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
 		return;
@@ -67,19 +67,19 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 		(vdd->vp_rt_data.vpconfig_errorgain <<
 		vp->vp_common->vpconfig_errorgain_shift) |
 		vp->vp_common->vpconfig_timeouten;
-	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vp_val, vp->vpconfig);
 
 	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
 		vp->vp_common->vstepmin_smpswaittimemin_shift) |
 		(vdd->vp_rt_data.vstepmin_stepmin <<
 		vp->vp_common->vstepmin_stepmin_shift));
-	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vstepmin);
+	voltdm->write(vp_val, vp->vstepmin);
 
 	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
 		vp->vp_common->vstepmax_smpswaittimemax_shift) |
 		(vdd->vp_rt_data.vstepmax_stepmax <<
 		vp->vp_common->vstepmax_stepmax_shift));
-	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vstepmax);
+	voltdm->write(vp_val, vp->vstepmax);
 
 	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
 		vp->vp_common->vlimitto_vddmax_shift) |
@@ -87,7 +87,7 @@ void __init omap_vp_init(struct voltagedomain *voltdm)
 		vp->vp_common->vlimitto_vddmin_shift) |
 		(vdd->vp_rt_data.vlimitto_timeout <<
 		vp->vp_common->vlimitto_timeout_shift));
-	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vlimitto);
+	voltdm->write(vp_val, vp->vlimitto);
 
 	vp_debugfs_init(voltdm);
 }
@@ -97,7 +97,6 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			      unsigned long target_volt)
 {
 	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 vpconfig;
 	u8 target_vsel, current_vsel;
 	int ret, timeout = 0;
@@ -123,21 +122,21 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	}
 
 	/* Configure for VP-Force Update */
-	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~(vp->vp_common->vpconfig_initvdd |
 			vp->vp_common->vpconfig_forceupdate |
 			vp->vp_common->vpconfig_initvoltage_mask);
 	vpconfig |= ((target_vsel <<
 			vp->vp_common->vpconfig_initvoltage_shift));
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
 	vpconfig |= vp->vp_common->vpconfig_initvdd;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	/* Force update of voltage */
 	vpconfig |= vp->vp_common->vpconfig_forceupdate;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	/*
 	 * Wait for TransactionDone. Typical latency is <200us.
@@ -170,13 +169,13 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 			"to clear the TRANXDONE status\n",
 			__func__, voltdm->name);
 
-	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig = voltdm->read(vp->vpconfig);
 	/* Clear initVDD copy trigger bit */
 	vpconfig &= ~vp->vp_common->vpconfig_initvdd;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 	/* Clear force bit */
 	vpconfig &= ~vp->vp_common->vpconfig_forceupdate;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	return 0;
 }
@@ -199,13 +198,13 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 	}
 
 	vdd = voltdm->vdd;
-	if (!vdd->read_reg) {
+	if (!voltdm->read) {
 		pr_err("%s: No read API for reading vdd_%s regs\n",
 			__func__, voltdm->name);
 		return 0;
 	}
 
-	curr_vsel = vdd->read_reg(vp->vp_common->prm_mod, vp->voltage);
+	curr_vsel = voltdm->read(vp->voltage);
 
 	if (!vdd->pmic_info || !vdd->pmic_info->vsel_to_uv) {
 		pr_warning("%s: PMIC function to convert vsel to voltage"
@@ -236,7 +235,7 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 
 	vdd = voltdm->vdd;
 	vp = voltdm->vdd->vp_data;
-	if (!vdd->read_reg || !vdd->write_reg) {
+	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
 		return;
@@ -249,9 +248,9 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 	vp_latch_vsel(voltdm);
 
 	/* Enable VP */
-	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig |= vp->vp_common->vpconfig_vpenable;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 	vdd->vp_enabled = true;
 }
 
@@ -276,7 +275,7 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 
 	vdd = voltdm->vdd;
 	vp = voltdm->vdd->vp_data;
-	if (!vdd->read_reg || !vdd->write_reg) {
+	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
 		return;
@@ -290,15 +289,15 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 	}
 
 	/* Disable VP */
-	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig = voltdm->read(vp->vpconfig);
 	vpconfig &= ~vp->vp_common->vpconfig_vpenable;
-	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	voltdm->write(vpconfig, vp->vpconfig);
 
 	/*
 	 * Wait for VP idle Typical latency is <2us. Maximum latency is ~100us
 	 */
-	omap_test_timeout((vdd->read_reg(vp->vp_common->prm_mod, vp->vstatus)),
-				VP_IDLE_TIMEOUT, timeout);
+	omap_test_timeout((voltdm->read(vp->vstatus)),
+			  VP_IDLE_TIMEOUT, timeout);
 
 	if (timeout >= VP_IDLE_TIMEOUT)
 		pr_warning("%s: vdd_%s idle timedout\n",
@@ -322,7 +321,7 @@ static int vp_volt_debug_get(void *data, u64 *val)
 		return -EINVAL;
 	}
 
-	vsel = vdd->read_reg(vp->vp_common->prm_mod, vp->voltage);
+	vsel = voltdm->read(vp->voltage);
 
 	if (!vdd->pmic_info->vsel_to_uv) {
 		pr_warning("PMIC function to convert vsel to voltage"

commit 842ec22852cf843558828e6f7a6da2bf72f341a5
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 28 11:57:18 2011 -0700

    OMAP3+ VP: replace transaction done check/clear with VP ops
    
    Replace the VP tranxdone check/clear with helper functions from the
    PRM layer.
    
    In the process, remove prm_irqst_* voltage structure fields for IRQ
    status checking which are no longer needed.
    
    Since these reads/writes of the IRQ status bits were the only PRM
    accesses that were not to VC/VP registers, this allows the rest of the
    register accesses in the VC/VP code to use VC/VP specific register
    access functions (done in the following patch.)
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
index f3503de5d8fd..113c839f6e23 100644
--- a/arch/arm/mach-omap2/vp.c
+++ b/arch/arm/mach-omap2/vp.c
@@ -111,10 +111,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 * is <3us
 	 */
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vdd->write_reg(vp->prm_irqst_data->tranxdone_status,
-			       vdd->prm_irqst_mod, vdd->prm_irqst_reg);
-		if (!(vdd->read_reg(vdd->prm_irqst_mod, vdd->prm_irqst_reg) &
-		      vp->prm_irqst_data->tranxdone_status))
+		vp->vp_common->ops->clear_txdone(vp->id);
+		if (!vp->vp_common->ops->check_txdone(vp->id))
 			break;
 		udelay(1);
 	}
@@ -146,9 +144,7 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 * Depends on SMPSWAITTIMEMIN/MAX and voltage change
 	 */
 	timeout = 0;
-	omap_test_timeout((vdd->read_reg(vdd->prm_irqst_mod,
-					 vdd->prm_irqst_reg) &
-			   vp->prm_irqst_data->tranxdone_status),
+	omap_test_timeout(vp->vp_common->ops->check_txdone(vp->id),
 			  VP_TRANXDONE_TIMEOUT, timeout);
 	if (timeout >= VP_TRANXDONE_TIMEOUT)
 		pr_err("%s: vdd_%s TRANXDONE timeout exceeded."
@@ -163,10 +159,8 @@ int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
 	 */
 	timeout = 0;
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vdd->write_reg(vp->prm_irqst_data->tranxdone_status,
-			       vdd->prm_irqst_mod, vdd->prm_irqst_reg);
-		if (!(vdd->read_reg(vdd->prm_irqst_mod, vdd->prm_irqst_reg) &
-		      vp->prm_irqst_data->tranxdone_status))
+		vp->vp_common->ops->clear_txdone(vp->id);
+		if (!vp->vp_common->ops->check_txdone(vp->id))
 			break;
 		udelay(1);
 	}

commit 01f48d308db1cfcfb0151d8d91153fd73e84ae40
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 21 14:29:13 2011 -0700

    OMAP2+: voltage: split out voltage processor (VP) code into new layer
    
    This patch is primarily a move of VP specific code from voltage.c into
    its own code in vp.c and adds prototypes to vp.h
    
    No functional changes, except debugfs...
    
    VP debugfs moved to 'vp' subdir of <debugfs>/voltage/ and 'vp_'
    prefixes removed from all debugfs filenames.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vp.c b/arch/arm/mach-omap2/vp.c
new file mode 100644
index 000000000000..f3503de5d8fd
--- /dev/null
+++ b/arch/arm/mach-omap2/vp.c
@@ -0,0 +1,374 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/debugfs.h>
+
+#include <plat/common.h>
+
+#include "voltage.h"
+#include "vp.h"
+#include "prm-regbits-34xx.h"
+#include "prm-regbits-44xx.h"
+#include "prm44xx.h"
+
+static void __init vp_debugfs_init(struct voltagedomain *voltdm);
+
+static void vp_latch_vsel(struct voltagedomain *voltdm)
+{
+	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	u32 vpconfig;
+	unsigned long uvdc;
+	char vsel;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+
+	uvdc = omap_voltage_get_nom_volt(voltdm);
+	if (!uvdc) {
+		pr_warning("%s: unable to find current voltage for vdd_%s\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
+		pr_warning("%s: PMIC function to convert voltage in uV to"
+			" vsel not registered\n", __func__);
+		return;
+	}
+
+	vsel = vdd->pmic_info->uv_to_vsel(uvdc);
+
+	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig &= ~(vp->vp_common->vpconfig_initvoltage_mask |
+			vp->vp_common->vpconfig_initvdd);
+	vpconfig |= vsel << vp->vp_common->vpconfig_initvoltage_shift;
+
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	/* Trigger initVDD value copy to voltage processor */
+	vdd->write_reg((vpconfig | vp->vp_common->vpconfig_initvdd),
+		       vp->vp_common->prm_mod, vp->vpconfig);
+
+	/* Clear initVDD copy trigger bit */
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+}
+
+/* Generic voltage init functions */
+void __init omap_vp_init(struct voltagedomain *voltdm)
+{
+	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u32 vp_val;
+
+	if (!vdd->read_reg || !vdd->write_reg) {
+		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
+		(vdd->vp_rt_data.vpconfig_errorgain <<
+		vp->vp_common->vpconfig_errorgain_shift) |
+		vp->vp_common->vpconfig_timeouten;
+	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vpconfig);
+
+	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
+		vp->vp_common->vstepmin_smpswaittimemin_shift) |
+		(vdd->vp_rt_data.vstepmin_stepmin <<
+		vp->vp_common->vstepmin_stepmin_shift));
+	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vstepmin);
+
+	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
+		vp->vp_common->vstepmax_smpswaittimemax_shift) |
+		(vdd->vp_rt_data.vstepmax_stepmax <<
+		vp->vp_common->vstepmax_stepmax_shift));
+	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vstepmax);
+
+	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
+		vp->vp_common->vlimitto_vddmax_shift) |
+		(vdd->vp_rt_data.vlimitto_vddmin <<
+		vp->vp_common->vlimitto_vddmin_shift) |
+		(vdd->vp_rt_data.vlimitto_timeout <<
+		vp->vp_common->vlimitto_timeout_shift));
+	vdd->write_reg(vp_val, vp->vp_common->prm_mod, vp->vlimitto);
+
+	vp_debugfs_init(voltdm);
+}
+
+/* VP force update method of voltage scaling */
+int omap_vp_forceupdate_scale(struct voltagedomain *voltdm,
+			      unsigned long target_volt)
+{
+	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u32 vpconfig;
+	u8 target_vsel, current_vsel;
+	int ret, timeout = 0;
+
+	ret = omap_vc_pre_scale(voltdm, target_volt, &target_vsel, &current_vsel);
+	if (ret)
+		return ret;
+
+	/*
+	 * Clear all pending TransactionDone interrupt/status. Typical latency
+	 * is <3us
+	 */
+	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
+		vdd->write_reg(vp->prm_irqst_data->tranxdone_status,
+			       vdd->prm_irqst_mod, vdd->prm_irqst_reg);
+		if (!(vdd->read_reg(vdd->prm_irqst_mod, vdd->prm_irqst_reg) &
+		      vp->prm_irqst_data->tranxdone_status))
+			break;
+		udelay(1);
+	}
+	if (timeout >= VP_TRANXDONE_TIMEOUT) {
+		pr_warning("%s: vdd_%s TRANXDONE timeout exceeded."
+			"Voltage change aborted", __func__, voltdm->name);
+		return -ETIMEDOUT;
+	}
+
+	/* Configure for VP-Force Update */
+	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig &= ~(vp->vp_common->vpconfig_initvdd |
+			vp->vp_common->vpconfig_forceupdate |
+			vp->vp_common->vpconfig_initvoltage_mask);
+	vpconfig |= ((target_vsel <<
+			vp->vp_common->vpconfig_initvoltage_shift));
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	/* Trigger initVDD value copy to voltage processor */
+	vpconfig |= vp->vp_common->vpconfig_initvdd;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	/* Force update of voltage */
+	vpconfig |= vp->vp_common->vpconfig_forceupdate;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	/*
+	 * Wait for TransactionDone. Typical latency is <200us.
+	 * Depends on SMPSWAITTIMEMIN/MAX and voltage change
+	 */
+	timeout = 0;
+	omap_test_timeout((vdd->read_reg(vdd->prm_irqst_mod,
+					 vdd->prm_irqst_reg) &
+			   vp->prm_irqst_data->tranxdone_status),
+			  VP_TRANXDONE_TIMEOUT, timeout);
+	if (timeout >= VP_TRANXDONE_TIMEOUT)
+		pr_err("%s: vdd_%s TRANXDONE timeout exceeded."
+			"TRANXDONE never got set after the voltage update\n",
+			__func__, voltdm->name);
+
+	omap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);
+
+	/*
+	 * Disable TransactionDone interrupt , clear all status, clear
+	 * control registers
+	 */
+	timeout = 0;
+	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
+		vdd->write_reg(vp->prm_irqst_data->tranxdone_status,
+			       vdd->prm_irqst_mod, vdd->prm_irqst_reg);
+		if (!(vdd->read_reg(vdd->prm_irqst_mod, vdd->prm_irqst_reg) &
+		      vp->prm_irqst_data->tranxdone_status))
+			break;
+		udelay(1);
+	}
+
+	if (timeout >= VP_TRANXDONE_TIMEOUT)
+		pr_warning("%s: vdd_%s TRANXDONE timeout exceeded while trying"
+			"to clear the TRANXDONE status\n",
+			__func__, voltdm->name);
+
+	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	/* Clear initVDD copy trigger bit */
+	vpconfig &= ~vp->vp_common->vpconfig_initvdd;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	/* Clear force bit */
+	vpconfig &= ~vp->vp_common->vpconfig_forceupdate;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	return 0;
+}
+
+/**
+ * omap_vp_get_curr_volt() - API to get the current vp voltage.
+ * @voltdm:	pointer to the VDD.
+ *
+ * This API returns the current voltage for the specified voltage processor
+ */
+unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
+{
+	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vdd_info *vdd;
+	u8 curr_vsel;
+
+	if (!voltdm || IS_ERR(voltdm)) {
+		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		return 0;
+	}
+
+	vdd = voltdm->vdd;
+	if (!vdd->read_reg) {
+		pr_err("%s: No read API for reading vdd_%s regs\n",
+			__func__, voltdm->name);
+		return 0;
+	}
+
+	curr_vsel = vdd->read_reg(vp->vp_common->prm_mod, vp->voltage);
+
+	if (!vdd->pmic_info || !vdd->pmic_info->vsel_to_uv) {
+		pr_warning("%s: PMIC function to convert vsel to voltage"
+			"in uV not registerd\n", __func__);
+		return 0;
+	}
+
+	return vdd->pmic_info->vsel_to_uv(curr_vsel);
+}
+
+/**
+ * omap_vp_enable() - API to enable a particular VP
+ * @voltdm:	pointer to the VDD whose VP is to be enabled.
+ *
+ * This API enables a particular voltage processor. Needed by the smartreflex
+ * class drivers.
+ */
+void omap_vp_enable(struct voltagedomain *voltdm)
+{
+	struct omap_vp_instance_data *vp;
+	struct omap_vdd_info *vdd;
+	u32 vpconfig;
+
+	if (!voltdm || IS_ERR(voltdm)) {
+		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		return;
+	}
+
+	vdd = voltdm->vdd;
+	vp = voltdm->vdd->vp_data;
+	if (!vdd->read_reg || !vdd->write_reg) {
+		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	/* If VP is already enabled, do nothing. Return */
+	if (vdd->vp_enabled)
+		return;
+
+	vp_latch_vsel(voltdm);
+
+	/* Enable VP */
+	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig |= vp->vp_common->vpconfig_vpenable;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+	vdd->vp_enabled = true;
+}
+
+/**
+ * omap_vp_disable() - API to disable a particular VP
+ * @voltdm:	pointer to the VDD whose VP is to be disabled.
+ *
+ * This API disables a particular voltage processor. Needed by the smartreflex
+ * class drivers.
+ */
+void omap_vp_disable(struct voltagedomain *voltdm)
+{
+	struct omap_vp_instance_data *vp;
+	struct omap_vdd_info *vdd;
+	u32 vpconfig;
+	int timeout;
+
+	if (!voltdm || IS_ERR(voltdm)) {
+		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		return;
+	}
+
+	vdd = voltdm->vdd;
+	vp = voltdm->vdd->vp_data;
+	if (!vdd->read_reg || !vdd->write_reg) {
+		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	/* If VP is already disabled, do nothing. Return */
+	if (!vdd->vp_enabled) {
+		pr_warning("%s: Trying to disable VP for vdd_%s when"
+			"it is already disabled\n", __func__, voltdm->name);
+		return;
+	}
+
+	/* Disable VP */
+	vpconfig = vdd->read_reg(vp->vp_common->prm_mod, vp->vpconfig);
+	vpconfig &= ~vp->vp_common->vpconfig_vpenable;
+	vdd->write_reg(vpconfig, vp->vp_common->prm_mod, vp->vpconfig);
+
+	/*
+	 * Wait for VP idle Typical latency is <2us. Maximum latency is ~100us
+	 */
+	omap_test_timeout((vdd->read_reg(vp->vp_common->prm_mod, vp->vstatus)),
+				VP_IDLE_TIMEOUT, timeout);
+
+	if (timeout >= VP_IDLE_TIMEOUT)
+		pr_warning("%s: vdd_%s idle timedout\n",
+			__func__, voltdm->name);
+
+	vdd->vp_enabled = false;
+
+	return;
+}
+
+/* Voltage debugfs support */
+static int vp_volt_debug_get(void *data, u64 *val)
+{
+	struct voltagedomain *voltdm = (struct voltagedomain *)data;
+	struct omap_vp_instance_data *vp = voltdm->vdd->vp_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u8 vsel;
+
+	if (!vdd) {
+		pr_warning("Wrong paramater passed\n");
+		return -EINVAL;
+	}
+
+	vsel = vdd->read_reg(vp->vp_common->prm_mod, vp->voltage);
+
+	if (!vdd->pmic_info->vsel_to_uv) {
+		pr_warning("PMIC function to convert vsel to voltage"
+			"in uV not registerd\n");
+		return -EINVAL;
+	}
+
+	*val = vdd->pmic_info->vsel_to_uv(vsel);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(vp_volt_debug_fops, vp_volt_debug_get, NULL, "%llu\n");
+
+static void __init vp_debugfs_init(struct voltagedomain *voltdm)
+{
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	struct dentry *debug_dir;
+
+	debug_dir = debugfs_create_dir("vp", vdd->debug_dir);
+	if (IS_ERR(debug_dir))
+		pr_err("%s: Unable to create VP debugfs dir dir\n", __func__);
+
+	(void) debugfs_create_x16("errorgain", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vpconfig_errorgain));
+	(void) debugfs_create_x16("smpswaittimemin", S_IRUGO,
+				debug_dir,
+				&(vdd->vp_rt_data.vstepmin_smpswaittimemin));
+	(void) debugfs_create_x8("stepmin", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vstepmin_stepmin));
+	(void) debugfs_create_x16("smpswaittimemax", S_IRUGO,
+				debug_dir,
+				&(vdd->vp_rt_data.vstepmax_smpswaittimemax));
+	(void) debugfs_create_x8("stepmax", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vstepmax_stepmax));
+	(void) debugfs_create_x8("vddmax", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vlimitto_vddmax));
+	(void) debugfs_create_x8("vddmin", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vlimitto_vddmin));
+	(void) debugfs_create_x16("timeout", S_IRUGO, debug_dir,
+				&(vdd->vp_rt_data.vlimitto_timeout));
+	(void) debugfs_create_file("curr_volt", S_IRUGO, debug_dir,
+				(void *) voltdm, &vp_volt_debug_fops);
+}
