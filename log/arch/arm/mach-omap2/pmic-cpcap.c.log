commit 0a4818c19221569b1877ededb3ed991aba35c1e8
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Oct 23 06:29:00 2019 +0000

    ARM: OMAP2+: Remove duplicated include from pmic-cpcap.c
    
    Remove duplicated include.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pmic-cpcap.c b/arch/arm/mach-omap2/pmic-cpcap.c
index 3958f8ce7ca8..eab281a5fc9f 100644
--- a/arch/arm/mach-omap2/pmic-cpcap.c
+++ b/arch/arm/mach-omap2/pmic-cpcap.c
@@ -15,8 +15,6 @@
 #include "voltage.h"
 
 #include <linux/init.h>
-#include <linux/kernel.h>
-#include "pm.h"
 #include "vc.h"
 
 /**

commit c145649bf262a0614fbe5955bdffdfaba9023fce
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Oct 17 06:34:34 2019 -0700

    ARM: OMAP2+: Configure voltage controller for cpcap to low-speed
    
    Looks like the i2c timings in high-speed mode do not work properly to
    allow us to clear I2C_DISABLE bits for PRM_VOLTCTRL register and the
    device reboots if I2C_DISABLE bits are cleared.
    
    Let's configure the voltage controller i2c for low-speed mode as done in
    the Motorola Mapphone Android Linux kernel. This saves us about 7mW of
    power during retention compared to the high-speed values.
    
    Let's also change the low-speed warning to pr_info about relying on the
    bootloader configured low-speed values like we currently do.
    
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pmic-cpcap.c b/arch/arm/mach-omap2/pmic-cpcap.c
index 3cdf40e4fb9d..3958f8ce7ca8 100644
--- a/arch/arm/mach-omap2/pmic-cpcap.c
+++ b/arch/arm/mach-omap2/pmic-cpcap.c
@@ -61,7 +61,7 @@ static struct omap_voltdm_pmic omap_cpcap_core = {
 	.i2c_slave_addr = 0x02,
 	.volt_reg_addr = 0x00,
 	.cmd_reg_addr = 0x01,
-	.i2c_high_speed = true,
+	.i2c_high_speed = false,
 	.vsel_to_uv = omap_cpcap_vsel_to_uv,
 	.uv_to_vsel = omap_cpcap_uv_to_vsel,
 };
@@ -78,7 +78,7 @@ static struct omap_voltdm_pmic omap_cpcap_iva = {
 	.i2c_slave_addr = 0x44,
 	.volt_reg_addr = 0x0,
 	.cmd_reg_addr = 0x01,
-	.i2c_high_speed = true,
+	.i2c_high_speed = false,
 	.vsel_to_uv = omap_cpcap_vsel_to_uv,
 	.uv_to_vsel = omap_cpcap_uv_to_vsel,
 };
@@ -125,7 +125,7 @@ static struct omap_voltdm_pmic omap443x_max8952_mpu = {
 	.i2c_slave_addr = 0x60,
 	.volt_reg_addr = 0x03,
 	.cmd_reg_addr = 0x03,
-	.i2c_high_speed = true,
+	.i2c_high_speed = false,
 	.vsel_to_uv = omap_max8952_vsel_to_uv,
 	.uv_to_vsel = omap_max8952_uv_to_vsel,
 };
@@ -212,7 +212,7 @@ static struct omap_voltdm_pmic omap4_fan_core = {
 	.vddmax = 1375000,
 	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
 	.i2c_slave_addr = 0x4A,
-	.i2c_high_speed = true,
+	.i2c_high_speed = false,
 	.volt_reg_addr = 0x01,
 	.cmd_reg_addr = 0x01,
 	.vsel_to_uv = omap_fan535508_vsel_to_uv,
@@ -232,7 +232,7 @@ static struct omap_voltdm_pmic omap4_fan_iva = {
 	.i2c_slave_addr = 0x48,
 	.volt_reg_addr = 0x01,
 	.cmd_reg_addr = 0x01,
-	.i2c_high_speed = true,
+	.i2c_high_speed = false,
 	.vsel_to_uv = omap_fan535503_vsel_to_uv,
 	.uv_to_vsel = omap_fan535503_uv_to_vsel,
 };
@@ -263,3 +263,11 @@ int __init omap4_cpcap_init(void)
 
 	return 0;
 }
+
+static int __init cpcap_late_init(void)
+{
+	omap4_vc_set_pmic_signaling(PWRDM_POWER_RET);
+
+	return 0;
+}
+omap_late_initcall(cpcap_late_init);

commit 821093e1fd3c5e0b40601ffbd27f2d7692a7a1e6
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Oct 18 20:07:01 2019 +0800

    ARM: OMAP2+: Make some functions static
    
    Fix sparse warnings:
    
    arch/arm/mach-omap2/pmic-cpcap.c:29:15: warning: symbol 'omap_cpcap_vsel_to_uv' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:43:15: warning: symbol 'omap_cpcap_uv_to_vsel' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:93:15: warning: symbol 'omap_max8952_vsel_to_uv' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:107:15: warning: symbol 'omap_max8952_uv_to_vsel' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:140:15: warning: symbol 'omap_fan535503_vsel_to_uv' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:155:15: warning: symbol 'omap_fan535508_vsel_to_uv' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:173:15: warning: symbol 'omap_fan535503_uv_to_vsel' was not declared. Should it be static?
    arch/arm/mach-omap2/pmic-cpcap.c:192:15: warning: symbol 'omap_fan535508_uv_to_vsel' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pmic-cpcap.c b/arch/arm/mach-omap2/pmic-cpcap.c
index 2c2a178d988d..3cdf40e4fb9d 100644
--- a/arch/arm/mach-omap2/pmic-cpcap.c
+++ b/arch/arm/mach-omap2/pmic-cpcap.c
@@ -26,7 +26,7 @@
  * Returns the microvolts DC that the CPCAP PMIC should generate when
  * programmed with @vsel.
  */
-unsigned long omap_cpcap_vsel_to_uv(unsigned char vsel)
+static unsigned long omap_cpcap_vsel_to_uv(unsigned char vsel)
 {
 	if (vsel > 0x44)
 		vsel = 0x44;
@@ -40,7 +40,7 @@ unsigned long omap_cpcap_vsel_to_uv(unsigned char vsel)
  * Returns the VSEL value necessary for the CPCAP PMIC to
  * generate an output voltage equal to or greater than @uv microvolts DC.
  */
-unsigned char omap_cpcap_uv_to_vsel(unsigned long uv)
+static unsigned char omap_cpcap_uv_to_vsel(unsigned long uv)
 {
 	if (uv < 600000)
 		uv = 600000;
@@ -90,7 +90,7 @@ static struct omap_voltdm_pmic omap_cpcap_iva = {
  * Returns the microvolts DC that the MAX8952 Regulator should generate when
  * programmed with @vsel.
  */
-unsigned long omap_max8952_vsel_to_uv(unsigned char vsel)
+static unsigned long omap_max8952_vsel_to_uv(unsigned char vsel)
 {
 	if (vsel > 0x3F)
 		vsel = 0x3F;
@@ -104,7 +104,7 @@ unsigned long omap_max8952_vsel_to_uv(unsigned char vsel)
  * Returns the VSEL value necessary for the MAX8952 Regulator to
  * generate an output voltage equal to or greater than @uv microvolts DC.
  */
-unsigned char omap_max8952_uv_to_vsel(unsigned long uv)
+static unsigned char omap_max8952_uv_to_vsel(unsigned long uv)
 {
 	if (uv < 770000)
 		uv = 770000;
@@ -137,7 +137,7 @@ static struct omap_voltdm_pmic omap443x_max8952_mpu = {
  * Returns the microvolts DC that the FAN535503 Regulator should generate when
  * programmed with @vsel.
  */
-unsigned long omap_fan535503_vsel_to_uv(unsigned char vsel)
+static unsigned long omap_fan535503_vsel_to_uv(unsigned char vsel)
 {
 	/* Extract bits[5:0] */
 	vsel &= 0x3F;
@@ -152,7 +152,7 @@ unsigned long omap_fan535503_vsel_to_uv(unsigned char vsel)
  * Returns the microvolts DC that the FAN535508 Regulator should generate when
  * programmed with @vsel.
  */
-unsigned long omap_fan535508_vsel_to_uv(unsigned char vsel)
+static unsigned long omap_fan535508_vsel_to_uv(unsigned char vsel)
 {
 	/* Extract bits[5:0] */
 	vsel &= 0x3F;
@@ -170,7 +170,7 @@ unsigned long omap_fan535508_vsel_to_uv(unsigned char vsel)
  * Returns the VSEL value necessary for the MAX8952 Regulator to
  * generate an output voltage equal to or greater than @uv microvolts DC.
  */
-unsigned char omap_fan535503_uv_to_vsel(unsigned long uv)
+static unsigned char omap_fan535503_uv_to_vsel(unsigned long uv)
 {
 	unsigned char vsel;
 	if (uv < 750000)
@@ -189,7 +189,7 @@ unsigned char omap_fan535503_uv_to_vsel(unsigned long uv)
  * Returns the VSEL value necessary for the MAX8952 Regulator to
  * generate an output voltage equal to or greater than @uv microvolts DC.
  */
-unsigned char omap_fan535508_uv_to_vsel(unsigned long uv)
+static unsigned char omap_fan535508_uv_to_vsel(unsigned long uv)
 {
 	unsigned char vsel;
 	if (uv < 750000)

commit d44fa156dcb29dd0215c1fe63e7a7031a106557e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 16 07:37:06 2019 -0700

    ARM: OMAP2+: Configure voltage controller for cpcap
    
    We can configure voltage controller for cpcap with the data available in
    Motorola Mapphone Android Linux kernel. Let's add it so we can have droid4
    behave the same way for voltage controller as other omap4 devices and save
    some power when idle.
    
    Note that we're now using high-speed i2c mode, looks like the Motorola
    kernel had a typo using 0x200 instead of 200 for the timings which may
    caused it to not work properly.
    
    Also note that in the long run, this should just become dts data for a
    voltage controller device driver. But let's get things working first to
    make it possible to test further changes easily.
    
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pmic-cpcap.c b/arch/arm/mach-omap2/pmic-cpcap.c
new file mode 100644
index 000000000000..2c2a178d988d
--- /dev/null
+++ b/arch/arm/mach-omap2/pmic-cpcap.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * pmic-cpcap.c - CPCAP-specific functions for the OPP code
+ *
+ * Adapted from Motorola Mapphone Android Linux kernel
+ * Copyright (C) 2011 Motorola, Inc.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+
+#include "soc.h"
+#include "pm.h"
+#include "voltage.h"
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include "pm.h"
+#include "vc.h"
+
+/**
+ * omap_cpcap_vsel_to_vdc - convert CPCAP VSEL value to microvolts DC
+ * @vsel: CPCAP VSEL value to convert
+ *
+ * Returns the microvolts DC that the CPCAP PMIC should generate when
+ * programmed with @vsel.
+ */
+unsigned long omap_cpcap_vsel_to_uv(unsigned char vsel)
+{
+	if (vsel > 0x44)
+		vsel = 0x44;
+	return (((vsel * 125) + 6000)) * 100;
+}
+
+/**
+ * omap_cpcap_uv_to_vsel - convert microvolts DC to CPCAP VSEL value
+ * @uv: microvolts DC to convert
+ *
+ * Returns the VSEL value necessary for the CPCAP PMIC to
+ * generate an output voltage equal to or greater than @uv microvolts DC.
+ */
+unsigned char omap_cpcap_uv_to_vsel(unsigned long uv)
+{
+	if (uv < 600000)
+		uv = 600000;
+	else if (uv > 1450000)
+		uv = 1450000;
+	return DIV_ROUND_UP(uv - 600000, 12500);
+}
+
+static struct omap_voltdm_pmic omap_cpcap_core = {
+	.slew_rate = 4000,
+	.step_size = 12500,
+	.vp_erroroffset = OMAP4_VP_CONFIG_ERROROFFSET,
+	.vp_vstepmin = OMAP4_VP_VSTEPMIN_VSTEPMIN,
+	.vp_vstepmax = OMAP4_VP_VSTEPMAX_VSTEPMAX,
+	.vddmin = 900000,
+	.vddmax = 1350000,
+	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
+	.i2c_slave_addr = 0x02,
+	.volt_reg_addr = 0x00,
+	.cmd_reg_addr = 0x01,
+	.i2c_high_speed = true,
+	.vsel_to_uv = omap_cpcap_vsel_to_uv,
+	.uv_to_vsel = omap_cpcap_uv_to_vsel,
+};
+
+static struct omap_voltdm_pmic omap_cpcap_iva = {
+	.slew_rate = 4000,
+	.step_size = 12500,
+	.vp_erroroffset = OMAP4_VP_CONFIG_ERROROFFSET,
+	.vp_vstepmin = OMAP4_VP_VSTEPMIN_VSTEPMIN,
+	.vp_vstepmax = OMAP4_VP_VSTEPMAX_VSTEPMAX,
+	.vddmin = 900000,
+	.vddmax = 1350000,
+	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
+	.i2c_slave_addr = 0x44,
+	.volt_reg_addr = 0x0,
+	.cmd_reg_addr = 0x01,
+	.i2c_high_speed = true,
+	.vsel_to_uv = omap_cpcap_vsel_to_uv,
+	.uv_to_vsel = omap_cpcap_uv_to_vsel,
+};
+
+/**
+ * omap_max8952_vsel_to_vdc - convert MAX8952 VSEL value to microvolts DC
+ * @vsel: MAX8952 VSEL value to convert
+ *
+ * Returns the microvolts DC that the MAX8952 Regulator should generate when
+ * programmed with @vsel.
+ */
+unsigned long omap_max8952_vsel_to_uv(unsigned char vsel)
+{
+	if (vsel > 0x3F)
+		vsel = 0x3F;
+	return (((vsel * 100) + 7700)) * 100;
+}
+
+/**
+ * omap_max8952_uv_to_vsel - convert microvolts DC to MAX8952 VSEL value
+ * @uv: microvolts DC to convert
+ *
+ * Returns the VSEL value necessary for the MAX8952 Regulator to
+ * generate an output voltage equal to or greater than @uv microvolts DC.
+ */
+unsigned char omap_max8952_uv_to_vsel(unsigned long uv)
+{
+	if (uv < 770000)
+		uv = 770000;
+	else if (uv > 1400000)
+		uv = 1400000;
+	return DIV_ROUND_UP(uv - 770000, 10000);
+}
+
+static struct omap_voltdm_pmic omap443x_max8952_mpu = {
+	.slew_rate = 16000,
+	.step_size = 10000,
+	.vp_erroroffset = OMAP4_VP_CONFIG_ERROROFFSET,
+	.vp_vstepmin = OMAP4_VP_VSTEPMIN_VSTEPMIN,
+	.vp_vstepmax = OMAP4_VP_VSTEPMAX_VSTEPMAX,
+	.vddmin = 900000,
+	.vddmax = 1400000,
+	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
+	.i2c_slave_addr = 0x60,
+	.volt_reg_addr = 0x03,
+	.cmd_reg_addr = 0x03,
+	.i2c_high_speed = true,
+	.vsel_to_uv = omap_max8952_vsel_to_uv,
+	.uv_to_vsel = omap_max8952_uv_to_vsel,
+};
+
+/**
+ * omap_fan5355_vsel_to_vdc - convert FAN535503 VSEL value to microvolts DC
+ * @vsel: FAN535503 VSEL value to convert
+ *
+ * Returns the microvolts DC that the FAN535503 Regulator should generate when
+ * programmed with @vsel.
+ */
+unsigned long omap_fan535503_vsel_to_uv(unsigned char vsel)
+{
+	/* Extract bits[5:0] */
+	vsel &= 0x3F;
+
+	return (((vsel * 125) + 7500)) * 100;
+}
+
+/**
+ * omap_fan535508_vsel_to_vdc - convert FAN535508 VSEL value to microvolts DC
+ * @vsel: FAN535508 VSEL value to convert
+ *
+ * Returns the microvolts DC that the FAN535508 Regulator should generate when
+ * programmed with @vsel.
+ */
+unsigned long omap_fan535508_vsel_to_uv(unsigned char vsel)
+{
+	/* Extract bits[5:0] */
+	vsel &= 0x3F;
+
+	if (vsel > 0x37)
+		vsel = 0x37;
+	return (((vsel * 125) + 7500)) * 100;
+}
+
+
+/**
+ * omap_fan535503_uv_to_vsel - convert microvolts DC to FAN535503 VSEL value
+ * @uv: microvolts DC to convert
+ *
+ * Returns the VSEL value necessary for the MAX8952 Regulator to
+ * generate an output voltage equal to or greater than @uv microvolts DC.
+ */
+unsigned char omap_fan535503_uv_to_vsel(unsigned long uv)
+{
+	unsigned char vsel;
+	if (uv < 750000)
+		uv = 750000;
+	else if (uv > 1537500)
+		uv = 1537500;
+
+	vsel = DIV_ROUND_UP(uv - 750000, 12500);
+	return vsel | 0xC0;
+}
+
+/**
+ * omap_fan535508_uv_to_vsel - convert microvolts DC to FAN535508 VSEL value
+ * @uv: microvolts DC to convert
+ *
+ * Returns the VSEL value necessary for the MAX8952 Regulator to
+ * generate an output voltage equal to or greater than @uv microvolts DC.
+ */
+unsigned char omap_fan535508_uv_to_vsel(unsigned long uv)
+{
+	unsigned char vsel;
+	if (uv < 750000)
+		uv = 750000;
+	else if (uv > 1437500)
+		uv = 1437500;
+
+	vsel = DIV_ROUND_UP(uv - 750000, 12500);
+	return vsel | 0xC0;
+}
+
+/* fan5335-core */
+static struct omap_voltdm_pmic omap4_fan_core = {
+	.slew_rate = 4000,
+	.step_size = 12500,
+	.vp_erroroffset = OMAP4_VP_CONFIG_ERROROFFSET,
+	.vp_vstepmin = OMAP4_VP_VSTEPMIN_VSTEPMIN,
+	.vp_vstepmax = OMAP4_VP_VSTEPMAX_VSTEPMAX,
+	.vddmin = 850000,
+	.vddmax = 1375000,
+	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
+	.i2c_slave_addr = 0x4A,
+	.i2c_high_speed = true,
+	.volt_reg_addr = 0x01,
+	.cmd_reg_addr = 0x01,
+	.vsel_to_uv = omap_fan535508_vsel_to_uv,
+	.uv_to_vsel = omap_fan535508_uv_to_vsel,
+};
+
+/* fan5335 iva */
+static struct omap_voltdm_pmic omap4_fan_iva = {
+	.slew_rate = 4000,
+	.step_size = 12500,
+	.vp_erroroffset = OMAP4_VP_CONFIG_ERROROFFSET,
+	.vp_vstepmin = OMAP4_VP_VSTEPMIN_VSTEPMIN,
+	.vp_vstepmax = OMAP4_VP_VSTEPMAX_VSTEPMAX,
+	.vddmin = 850000,
+	.vddmax = 1375000,
+	.vp_timeout_us = OMAP4_VP_VLIMITTO_TIMEOUT_US,
+	.i2c_slave_addr = 0x48,
+	.volt_reg_addr = 0x01,
+	.cmd_reg_addr = 0x01,
+	.i2c_high_speed = true,
+	.vsel_to_uv = omap_fan535503_vsel_to_uv,
+	.uv_to_vsel = omap_fan535503_uv_to_vsel,
+};
+
+int __init omap4_cpcap_init(void)
+{
+	struct voltagedomain *voltdm;
+
+	if (!of_find_compatible_node(NULL, NULL, "motorola,cpcap"))
+		return -ENODEV;
+
+	voltdm = voltdm_lookup("mpu");
+	omap_voltage_register_pmic(voltdm, &omap443x_max8952_mpu);
+
+	if (of_machine_is_compatible("motorola,droid-bionic")) {
+		voltdm = voltdm_lookup("mpu");
+		omap_voltage_register_pmic(voltdm, &omap_cpcap_core);
+
+		voltdm = voltdm_lookup("mpu");
+		omap_voltage_register_pmic(voltdm, &omap_cpcap_iva);
+	} else {
+		voltdm = voltdm_lookup("core");
+		omap_voltage_register_pmic(voltdm, &omap4_fan_core);
+
+		voltdm = voltdm_lookup("iva");
+		omap_voltage_register_pmic(voltdm, &omap4_fan_iva);
+	}
+
+	return 0;
+}
