commit 4ea3711aece423a160c5b341ba531ccc81c009d1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Dec 12 15:05:40 2019 +0200

    ARM: OMAP2+: omap-iommu.c conversion to ti-sysc
    
    Convert omap2 iommu platform code to use ti-sysc instead of legacy
    omap-device / hwmod interfaces.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 78247e6f4a72..54aff33e55e6 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -8,19 +8,27 @@
 
 #include <linux/platform_device.h>
 #include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/list.h>
 
-#include "omap_hwmod.h"
-#include "omap_device.h"
 #include "clockdomain.h"
 #include "powerdomain.h"
 
+struct pwrdm_link {
+	struct device *dev;
+	struct powerdomain *pwrdm;
+	struct list_head node;
+};
+
+static DEFINE_SPINLOCK(iommu_lock);
+static struct clockdomain *emu_clkdm;
+static atomic_t emu_count;
+
 static void omap_iommu_dra7_emu_swsup_config(struct platform_device *pdev,
 					     bool enable)
 {
-	static struct clockdomain *emu_clkdm;
-	static DEFINE_SPINLOCK(emu_lock);
-	static atomic_t count;
 	struct device_node *np = pdev->dev.of_node;
+	unsigned long flags;
 
 	if (!of_device_is_compatible(np, "ti,dra7-dsp-iommu"))
 		return;
@@ -31,34 +39,87 @@ static void omap_iommu_dra7_emu_swsup_config(struct platform_device *pdev,
 			return;
 	}
 
-	spin_lock(&emu_lock);
+	spin_lock_irqsave(&iommu_lock, flags);
 
-	if (enable && (atomic_inc_return(&count) == 1))
+	if (enable && (atomic_inc_return(&emu_count) == 1))
 		clkdm_deny_idle(emu_clkdm);
-	else if (!enable && (atomic_dec_return(&count) == 0))
+	else if (!enable && (atomic_dec_return(&emu_count) == 0))
 		clkdm_allow_idle(emu_clkdm);
 
-	spin_unlock(&emu_lock);
+	spin_unlock_irqrestore(&iommu_lock, flags);
+}
+
+static struct powerdomain *_get_pwrdm(struct device *dev)
+{
+	struct clk *clk;
+	struct clk_hw_omap *hwclk;
+	struct clockdomain *clkdm;
+	struct powerdomain *pwrdm = NULL;
+	struct pwrdm_link *entry;
+	unsigned long flags;
+	static LIST_HEAD(cache);
+
+	spin_lock_irqsave(&iommu_lock, flags);
+
+	list_for_each_entry(entry, &cache, node) {
+		if (entry->dev == dev) {
+			pwrdm = entry->pwrdm;
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&iommu_lock, flags);
+
+	if (pwrdm)
+		return pwrdm;
+
+	clk = of_clk_get(dev->of_node->parent, 0);
+	if (!clk) {
+		dev_err(dev, "no fck found\n");
+		return NULL;
+	}
+
+	hwclk = to_clk_hw_omap(__clk_get_hw(clk));
+	clk_put(clk);
+	if (!hwclk || !hwclk->clkdm_name) {
+		dev_err(dev, "no hwclk data\n");
+		return NULL;
+	}
+
+	clkdm = clkdm_lookup(hwclk->clkdm_name);
+	if (!clkdm) {
+		dev_err(dev, "clkdm not found: %s\n", hwclk->clkdm_name);
+		return NULL;
+	}
+
+	pwrdm = clkdm_get_pwrdm(clkdm);
+	if (!pwrdm) {
+		dev_err(dev, "pwrdm not found: %s\n", clkdm->name);
+		return NULL;
+	}
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (entry) {
+		entry->dev = dev;
+		entry->pwrdm = pwrdm;
+		spin_lock_irqsave(&iommu_lock, flags);
+		list_add(&entry->node, &cache);
+		spin_unlock_irqrestore(&iommu_lock, flags);
+	}
+
+	return pwrdm;
 }
 
 int omap_iommu_set_pwrdm_constraint(struct platform_device *pdev, bool request,
 				    u8 *pwrst)
 {
 	struct powerdomain *pwrdm;
-	struct omap_device *od;
 	u8 next_pwrst;
 	int ret = 0;
 
-	od = to_omap_device(pdev);
-	if (!od)
-		return -ENODEV;
-
-	if (od->hwmods_cnt != 1)
-		return -EINVAL;
-
-	pwrdm = omap_hwmod_get_pwrdm(od->hwmods[0]);
+	pwrdm = _get_pwrdm(&pdev->dev);
 	if (!pwrdm)
-		return -EINVAL;
+		return -ENODEV;
 
 	if (request) {
 		*pwrst = pwrdm_read_next_pwrst(pwrdm);

commit 2f14101a1d760db72393910d481fbf7768c44530
Author: Suman Anna <s-anna@ti.com>
Date:   Thu Dec 12 15:05:39 2019 +0200

    ARM: OMAP2+: Add workaround for DRA7 DSP MStandby errata i879
    
    Errata Title:
    i879: DSP MStandby requires CD_EMU in SW_WKUP
    
    Description:
    The DSP requires the internal emulation clock to be actively toggling
    in order to successfully enter a low power mode via execution of the
    IDLE instruction and PRCM MStandby/Idle handshake. This assumes that
    other prerequisites and software sequence are followed.
    
    Workaround:
    The emulation clock to the DSP is free-running anytime CCS is connected
    via JTAG debugger to the DSP subsystem or when the CD_EMU clock domain
    is set in SW_WKUP mode. The CD_EMU domain can be set in SW_WKUP mode
    via the CM_EMU_CLKSTCTRL [1:0]CLKTRCTRL field.
    
    Implementation:
    This patch implements this workaround by denying the HW_AUTO mode
    for the EMU clockdomain during the power-up of any DSP processor
    and re-enabling the HW_AUTO mode during the shutdown of the last
    DSP processor (actually done during the enabling and disabling of
    the respective DSP MDMA MMUs). Reference counting has to be used to
    manage the independent sequencing between the multiple DSP processors.
    
    This switching is done at runtime rather than a static clockdomain
    flags value to meet the target power domain state for the EMU power
    domain during suspend.
    
    Note that the DSP MStandby behavior is not consistent across all
    boards prior to this fix. Please see commit 45f871eec6c0 ("ARM:
    OMAP2+: Extend DRA7 IPU1 MMU pdata quirks to DSP MDMA MMUs") for
    details.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index f1a6ece8108e..78247e6f4a72 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -11,14 +11,43 @@
 
 #include "omap_hwmod.h"
 #include "omap_device.h"
+#include "clockdomain.h"
 #include "powerdomain.h"
 
+static void omap_iommu_dra7_emu_swsup_config(struct platform_device *pdev,
+					     bool enable)
+{
+	static struct clockdomain *emu_clkdm;
+	static DEFINE_SPINLOCK(emu_lock);
+	static atomic_t count;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!of_device_is_compatible(np, "ti,dra7-dsp-iommu"))
+		return;
+
+	if (!emu_clkdm) {
+		emu_clkdm = clkdm_lookup("emu_clkdm");
+		if (WARN_ON_ONCE(!emu_clkdm))
+			return;
+	}
+
+	spin_lock(&emu_lock);
+
+	if (enable && (atomic_inc_return(&count) == 1))
+		clkdm_deny_idle(emu_clkdm);
+	else if (!enable && (atomic_dec_return(&count) == 0))
+		clkdm_allow_idle(emu_clkdm);
+
+	spin_unlock(&emu_lock);
+}
+
 int omap_iommu_set_pwrdm_constraint(struct platform_device *pdev, bool request,
 				    u8 *pwrst)
 {
 	struct powerdomain *pwrdm;
 	struct omap_device *od;
 	u8 next_pwrst;
+	int ret = 0;
 
 	od = to_omap_device(pdev);
 	if (!od)
@@ -31,13 +60,21 @@ int omap_iommu_set_pwrdm_constraint(struct platform_device *pdev, bool request,
 	if (!pwrdm)
 		return -EINVAL;
 
-	if (request)
+	if (request) {
 		*pwrst = pwrdm_read_next_pwrst(pwrdm);
+		omap_iommu_dra7_emu_swsup_config(pdev, true);
+	}
 
 	if (*pwrst > PWRDM_POWER_RET)
-		return 0;
+		goto out;
 
 	next_pwrst = request ? PWRDM_POWER_ON : *pwrst;
 
-	return pwrdm_set_next_pwrst(pwrdm, next_pwrst);
+	ret = pwrdm_set_next_pwrst(pwrdm, next_pwrst);
+
+out:
+	if (!request)
+		omap_iommu_dra7_emu_swsup_config(pdev, false);
+
+	return ret;
 }

commit 3846a3b9511c5166082a93536d919a9c42abcd91
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Aug 7 11:26:45 2019 +0300

    iommu/omap: fix boot issue on remoteprocs with AMMU/Unicache
    
    Support has been added to the OMAP IOMMU driver to fix a boot hang
    issue on OMAP remoteprocs with AMMU/Unicache, caused by an improper
    AMMU/Unicache state upon initial deassertion of the processor reset.
    The issue is described in detail in the next three paragraphs.
    
    All the Cortex M3/M4 IPU processor subsystems in OMAP SoCs have a
    AMMU/Unicache IP that dictates the memory attributes for addresses
    seen by the processor cores. The AMMU/Unicache is configured/enabled
    by the SCACHE_CONFIG.BYPASS bit - a value of 1 enables the cache and
    mandates all addresses accessed by M3/M4 be defined in the AMMU. This
    bit is not programmable from the host processor. The M3/M4 boot
    sequence starts out with the AMMU/Unicache in disabled state, and
    SYS/BIOS programs the AMMU regions and enables the Unicache during
    one of its initial boot steps. This SCACHE_CONFIG.BYPASS bit is
    however enabled by default whenever a RET reset is applied to the IP,
    irrespective of whether it was previously enabled or not. The AMMU
    registers lose their context whenever this reset is applied. The reset
    is effective as long as the MMU portion of the subsystem is enabled
    and clocked. This behavior is common to all the IPU and DSP subsystems
    that have an AMMU/Unicache.
    
    The IPU boot sequence involves enabling and programming the MMU, and
    loading the processor and releasing the reset(s) for the processor.
    The PM setup code currently sets the target state for most of the
    power domains to RET. The L2 MMU can be enabled, programmed and
    accessed properly just fine with the domain in hardware supervised
    mode, while the power domain goes through a RET->ON->RET transition
    during the programming sequence. However, the ON->RET transition
    asserts a RET reset, and the SCACHE_CONFIG.BYPASS bit gets auto-set.
    An AMMU fault is thrown immediately when the M3/M4 core's reset is
    released since the first instruction address itself will not be
    defined in any valid AMMU regions. The ON->RET transition happens
    automatically on the power domain after enabling the iommu due to
    the hardware supervised mode.
    
    This patch adds and invokes the .set_pwrdm_constraint pdata ops, if
    present, during the OMAP IOMMU enable and disable functions to resolve
    the above boot hang issue. The ops will allow to invoke a mach-omap2
    layer API pwrdm_set_next_pwrst() in a multi-arch kernel environment.
    The ops also returns the current power domain state while enforcing
    the constraint so that the driver can store it and use it to set back
    the power domain state while releasing the constraint. The pdata ops
    implementation restricts the target power domain to ON during enable,
    and back to the original power domain state during disable, and thereby
    eliminating the conditions for the boot issue. The implementation is
    effective only when the original power domain state is either RET or
    OFF, and is a no-op when it is ON or INACTIVE.
    
    The .set_pwrdm_constraint ops need to be plugged in pdata-quirks
    for the affected remote processors to be able to boot properly.
    
    Note that the current issue is seen only on kernels with the affected
    power domains programmed to enter RET. For eg., IPU1 on DRA7xx is in a
    separate domain and is susceptible to this bug, while the IPU2 subsystem
    is within CORE power domain, and CORE RET is not supported on this SoC.
    IPUs on OMAP4 and OMAP5 are also susceptible since they are in CORE power
    domain, and CORE RET is a valid power target on these SoCs.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
new file mode 100644
index 000000000000..f1a6ece8108e
--- /dev/null
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * OMAP IOMMU quirks for various TI SoCs
+ *
+ * Copyright (C) 2015-2019 Texas Instruments Incorporated - http://www.ti.com/
+ *      Suman Anna <s-anna@ti.com>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/err.h>
+
+#include "omap_hwmod.h"
+#include "omap_device.h"
+#include "powerdomain.h"
+
+int omap_iommu_set_pwrdm_constraint(struct platform_device *pdev, bool request,
+				    u8 *pwrst)
+{
+	struct powerdomain *pwrdm;
+	struct omap_device *od;
+	u8 next_pwrst;
+
+	od = to_omap_device(pdev);
+	if (!od)
+		return -ENODEV;
+
+	if (od->hwmods_cnt != 1)
+		return -EINVAL;
+
+	pwrdm = omap_hwmod_get_pwrdm(od->hwmods[0]);
+	if (!pwrdm)
+		return -EINVAL;
+
+	if (request)
+		*pwrst = pwrdm_read_next_pwrst(pwrdm);
+
+	if (*pwrst > PWRDM_POWER_RET)
+		return 0;
+
+	next_pwrst = request ? PWRDM_POWER_ON : *pwrst;
+
+	return pwrdm_set_next_pwrst(pwrdm, next_pwrst);
+}

commit dd20b0d5c74bc2157a2444f5173dabdc6449aa4d
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Sep 16 18:48:19 2015 -0500

    ARM: OMAP2+: Remove legacy device instantiation of IOMMUs
    
    The legacy-style IOMMU device creation is maintained currently only
    for OMAP3 SoC, as all other SoCs are DT-boot only, and also to ensure
    functionality of the OMAP3 ISP driver, the only in-kernel client user
    on OMAP3 that supported both modes.
    
    Commit 78c66fbcec71 ("[media] v4l: omap3isp: Drop platform data support")
    removed the legacy device support from the OMAP3 ISP driver, so the
    legacy device instantiation of OMAP IOMMU devices is no longer
    needed, and is cleaned up.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    [tony@atomide.com: updated to remove also the Makefile entry]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
deleted file mode 100644
index 8867eb4025bf..000000000000
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * omap iommu: omap device registration
- *
- * Copyright (C) 2008-2009 Nokia Corporation
- *
- * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-
-#include <linux/platform_data/iommu-omap.h>
-#include "soc.h"
-#include "omap_hwmod.h"
-#include "omap_device.h"
-
-static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
-{
-	struct platform_device *pdev;
-	struct iommu_platform_data *pdata;
-	struct omap_mmu_dev_attr *a = (struct omap_mmu_dev_attr *)oh->dev_attr;
-	static int i;
-
-	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
-
-	pdata->name = oh->name;
-	pdata->nr_tlb_entries = a->nr_tlb_entries;
-
-	if (oh->rst_lines_cnt == 1) {
-		pdata->reset_name = oh->rst_lines->name;
-		pdata->assert_reset = omap_device_assert_hardreset;
-		pdata->deassert_reset = omap_device_deassert_hardreset;
-	}
-
-	pdev = omap_device_build("omap-iommu", i, oh, pdata, sizeof(*pdata));
-
-	kfree(pdata);
-
-	if (IS_ERR(pdev)) {
-		pr_err("%s: device build err: %ld\n", __func__, PTR_ERR(pdev));
-		return PTR_ERR(pdev);
-	}
-
-	i++;
-
-	return 0;
-}
-
-static int __init omap_iommu_init(void)
-{
-	/* If dtb is there, the devices will be created dynamically */
-	if (of_have_populated_dt())
-		return -ENODEV;
-
-	return omap_hwmod_for_each_by_class("mmu", omap_iommu_dev_init, NULL);
-}
-omap_subsys_initcall(omap_iommu_init);
-/* must be ready before omap3isp is probed */

commit 228e5fadba3c7d6ef39bac087cd086ab9d68d945
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Jul 10 15:43:05 2015 -0500

    ARM: OMAP2+: Remove module references from IOMMU machine layer
    
    The OMAP IOMMU driver has been adapted to the IOMMU framework
    for a while now, and it no longer supports being built as a
    module. Cleanup all the module related references both from
    the code and in the build.
    
    While at it, also relocate a comment around the initcall to
    avoid a checkpatch strict warning about using a blank line
    after function/struct/union/enum declarations.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 4068350f9059..8867eb4025bf 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/of.h>
-#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/err.h>
 #include <linux/slab.h>
@@ -63,15 +62,5 @@ static int __init omap_iommu_init(void)
 
 	return omap_hwmod_for_each_by_class("mmu", omap_iommu_dev_init, NULL);
 }
-/* must be ready before omap3isp is probed */
 omap_subsys_initcall(omap_iommu_init);
-
-static void __exit omap_iommu_exit(void)
-{
-	/* Do nothing */
-}
-module_exit(omap_iommu_exit);
-
-MODULE_AUTHOR("Hiroshi DOYU");
-MODULE_DESCRIPTION("omap iommu: omap device registration");
-MODULE_LICENSE("GPL v2");
+/* must be ready before omap3isp is probed */

commit 4aa5dd7e56654215bdac18edd4d8b00cbe5be80a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jul 18 12:49:56 2014 +0200

    ARM: omap: Don't set iommu pdata da_start and da_end fields
    
    The fields are not used by the driver and will be removed from platform
    data. Don't set them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index f1fab5684a24..4068350f9059 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -34,8 +34,6 @@ static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 
 	pdata->name = oh->name;
 	pdata->nr_tlb_entries = a->nr_tlb_entries;
-	pdata->da_start = a->da_start;
-	pdata->da_end = a->da_end;
 
 	if (oh->rst_lines_cnt == 1) {
 		pdata->reset_name = oh->rst_lines->name;

commit 3c92748df9941ff8f5be4655a04812ff4d0c7eeb
Author: Florian Vaussard <florian.vaussard@epfl.ch>
Date:   Fri Feb 28 14:42:36 2014 -0600

    iommu/omap: Add devicetree support
    
    As OMAP2+ is moving to a full DT boot for all SoC families, commit
    7ce93f3 "ARM: OMAP2+: Fix more missing data for omap3.dtsi file"
    adds basic DT bits for OMAP3. But the driver is not yet converted,
    so this will not work and driver will not be probed. Convert it!
    
    The legacy boot mode is still supported until OMAP3 is converted
    to DT-boot only.
    
    Signed-off-by: Florian Vaussard <florian.vaussard@epfl.ch>
    [s-anna@ti.com: dev_name adaptation and improved error checking]
    Signed-off-by: Suman Anna <s-anna@ti.com>
    [tony@atomide.com: Ack for arch/arm/*omap* parts]
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index f6daae821ebb..f1fab5684a24 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -10,6 +10,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/of.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/err.h>
@@ -58,6 +59,10 @@ static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 
 static int __init omap_iommu_init(void)
 {
+	/* If dtb is there, the devices will be created dynamically */
+	if (of_have_populated_dt())
+		return -ENODEV;
+
 	return omap_hwmod_for_each_by_class("mmu", omap_iommu_dev_init, NULL);
 }
 /* must be ready before omap3isp is probed */

commit bab588fcfb6335c767d811a8955979f5440328e0
Merge: 3298a3511f1e 9cb0d1babfcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 15:27:22 2013 -0800

    Merge tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC-specific updates from Arnd Bergmann:
     "This is a larger set of new functionality for the existing SoC
      families, including:
    
       - vt8500 gains support for new CPU cores, notably the Cortex-A9 based
         wm8850
    
       - prima2 gains support for the "marco" SoC family, its SMP based
         cousin
    
       - tegra gains support for the new Tegra4 (Tegra114) family
    
       - socfpga now supports a newer version of the hardware including SMP
    
       - i.mx31 and bcm2835 are now using DT probing for their clocks
    
       - lots of updates for sh-mobile
    
       - OMAP updates for clocks, power management and USB
    
       - i.mx6q and tegra now support cpuidle
    
       - kirkwood now supports PCIe hot plugging
    
       - tegra clock support is updated
    
       - tegra USB PHY probing gets implemented diffently"
    
    * tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (148 commits)
      ARM: prima2: remove duplicate v7_invalidate_l1
      ARM: shmobile: r8a7779: Correct TMU clock support again
      ARM: prima2: fix __init section for cpu hotplug
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 3/3)
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 1/3)
      arm: socfpga: Add SMP support for actual socfpga harware
      arm: Add v7_invalidate_l1 to cache-v7.S
      arm: socfpga: Add entries to enable make dtbs socfpga
      arm: socfpga: Add new device tree source for actual socfpga HW
      ARM: tegra: sort Kconfig selects for Tegra114
      ARM: tegra: enable ARCH_REQUIRE_GPIOLIB for Tegra114
      ARM: tegra: Fix build error w/ ARCH_TEGRA_114_SOC w/o ARCH_TEGRA_3x_SOC
      ARM: tegra: Fix build error for gic update
      ARM: tegra: remove empty tegra_smp_init_cpus()
      ARM: shmobile: Register ARM architected timer
      ARM: MARCO: fix the build issue due to gic-vic-to-irqchip move
      ARM: shmobile: r8a7779: Correct TMU clock support
      ARM: mxs_defconfig: Select CONFIG_DEVTMPFS_MOUNT
      ARM: mxs: decrease mxs_clockevent_device.min_delta_ns to 2 clock cycles
      ARM: mxs: use apbx bus clock to drive the timers on timrotv2
      ...

commit dad2d9e666cbd733afff855f5224dd7e8a7996d3
Author: Tony Lindgren <tony@atomide.com>
Date:   Sat Feb 9 19:20:57 2013 -0800

    ARM: OMAP2+: Make sure files with omap initcalls include soc.h
    
    Looks like there are few more places that I missed that can cause
    compiler warnings. After grepping for omap initcall, all files
    needing soc.h should now have it.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index dd8ce6d2f4eb..c20423955bf7 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -16,6 +16,7 @@
 #include <linux/slab.h>
 
 #include <linux/platform_data/iommu-omap.h>
+#include "soc.h"
 #include "omap_hwmod.h"
 #include "omap_device.h"
 

commit c1d1cd597fc77af3086470f8627d77f52f7f8b6c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:53 2013 -0700

    ARM: OMAP2+: omap_device: remove obsolete pm_lats and early_device code
    
    Remove now-obsolete code from arch/arm/mach-omap2/omap_device.c.  This
    mostly consists of removing the first attempt at device PM latency
    handling.  This was never really used, has been replaced by the common
    dev_pm_qos code, and needs to go away as part of the DT conversion.
    Also, the early platform_device creation code has been removed, as it
    appears to be unused.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 6da4f7ae9d7f..f7f38c7fd5ff 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -41,8 +41,7 @@ static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 		pdata->deassert_reset = omap_device_deassert_hardreset;
 	}
 
-	pdev = omap_device_build("omap-iommu", i, oh, pdata, sizeof(*pdata),
-				NULL, 0, 0);
+	pdev = omap_device_build("omap-iommu", i, oh, pdata, sizeof(*pdata));
 
 	kfree(pdata);
 

commit b76c8b19b082c3fc84725de0d3ba5ee1f571c0ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 11 11:24:18 2013 -0800

    ARM: OMAP2+: Use omap initcalls
    
    This way the initcalls don't run on other SoCs on multiplatform
    kernels. Otherwise we'll get something like this when booting
    on vexpress:
    
    omap_hwmod: _ensure_mpu_hwmod_is_setup: MPU initiator hwmod mpu not yet registered
    ...
    WARNING: at arch/arm/mach-omap2/pm.c:82 _init_omap_device+0x74/0x94()
    _init_omap_device: could not find omap_hwmod for mpu
    ...
    omap-dma-engine omap-dma-engine: OMAP DMA engine driver
    ...
    
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 6da4f7ae9d7f..dd8ce6d2f4eb 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -61,7 +61,7 @@ static int __init omap_iommu_init(void)
 	return omap_hwmod_for_each_by_class("mmu", omap_iommu_dev_init, NULL);
 }
 /* must be ready before omap3isp is probed */
-subsys_initcall(omap_iommu_init);
+omap_subsys_initcall(omap_iommu_init);
 
 static void __exit omap_iommu_exit(void)
 {

commit 6f8c9d2130893eda35ad9105e6e2a08db7f0da13
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 20 11:50:34 2012 -0800

    ARM: OMAP2+: Trivial fix for IOMMU merge issue
    
    Commit 787314c35fbb ("Merge tag 'iommu-updates-v3.8' of
    git://git./linux/kernel/git/joro/iommu") did not account for the changed
    header location.
    
    The headers were made local to mach-omap2 as they are specific to omap2+
    only, and we wanted to get most of the #include <plat/*.h> headers fixed
    up anyways for the ARM multiplatform support.
    
    We attempted to avoid this kind of merge conflict early on by setting up
    a minimal git branch shared by the arm-soc tree and the iommu tree, but
    looks like we still hit a merge issue there as the branches got merged
    as various topic branches.
    
    Cc: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 7642fc4672c1..6da4f7ae9d7f 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -16,8 +16,8 @@
 #include <linux/slab.h>
 
 #include <linux/platform_data/iommu-omap.h>
-#include <plat/omap_hwmod.h>
-#include <plat/omap_device.h>
+#include "omap_hwmod.h"
+#include "omap_device.h"
 
 static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 {

commit ebf7cda0f92effd8169b831fae81e9437dce1fef
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Mon Nov 19 19:05:51 2012 -0600

    iommu/omap: Adapt to runtime pm
    
    Use runtime PM functionality interfaced with hwmod enable/idle
    functions, to replace direct clock operations and sysconfig
    handling.
    
    Due to reset sequence, pm_runtime_[get|put]_sync must be used, to
    avoid possible operations with the module under reset. Because of
    this and given that the driver uses spin_locks to protect their
    critical sections, we must use pm_runtime_irq_safe in order for the
    runtime ops to be happy, otherwise might_sleep_if checks in runtime
    framework will complain.
    
    The remaining pm_runtime out of iommu_enable and iommu_disable
    corresponds to paths that can be accessed through debugfs, some of
    them doesn't work if the module is not enabled first, but in future
    if the mmu is idled withouth freeing, these are needed to debug.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    Tested-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 02726a647b1d..7642fc4672c1 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -31,7 +31,6 @@ static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 		return -ENOMEM;
 
 	pdata->name = oh->name;
-	pdata->clk_name = oh->main_clk;
 	pdata->nr_tlb_entries = a->nr_tlb_entries;
 	pdata->da_start = a->da_start;
 	pdata->da_end = a->da_end;

commit 72b15b6ae97796c5fac687addde5dbfab872cf94
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Mon Nov 19 19:05:50 2012 -0600

    iommu/omap: Migrate to hwmod framework
    
    Use hwmod data and device attributes to build and register an
    omap device for iommu driver.
    
     - Update the naming convention in isp module.
     - Remove unneeded check for number of resources, as this is now
       handled by omap_device and prevents driver from loading.
     - Now unused, remove platform device and resource data, handling
       of sysconfig register for softreset purposes, use default
       latency structure.
     - Use hwmod API for reset handling.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    Tested-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index a6a4ff8744b7..02726a647b1d 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -12,153 +12,61 @@
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/slab.h>
 
 #include <linux/platform_data/iommu-omap.h>
+#include <plat/omap_hwmod.h>
+#include <plat/omap_device.h>
 
-#include "soc.h"
-#include "common.h"
-
-struct iommu_device {
-	resource_size_t base;
-	int irq;
-	struct iommu_platform_data pdata;
-	struct resource res[2];
-};
-static struct iommu_device *devices;
-static int num_iommu_devices;
-
-#ifdef CONFIG_ARCH_OMAP3
-static struct iommu_device omap3_devices[] = {
-	{
-		.base = 0x480bd400,
-		.irq = 24 + OMAP_INTC_START,
-		.pdata = {
-			.name = "isp",
-			.nr_tlb_entries = 8,
-			.clk_name = "cam_ick",
-			.da_start = 0x0,
-			.da_end = 0xFFFFF000,
-		},
-	},
-#if defined(CONFIG_OMAP_IOMMU_IVA2)
-	{
-		.base = 0x5d000000,
-		.irq = 28 + OMAP_INTC_START,
-		.pdata = {
-			.name = "iva2",
-			.nr_tlb_entries = 32,
-			.clk_name = "iva2_ck",
-			.da_start = 0x11000000,
-			.da_end = 0xFFFFF000,
-		},
-	},
-#endif
-};
-#define NR_OMAP3_IOMMU_DEVICES ARRAY_SIZE(omap3_devices)
-static struct platform_device *omap3_iommu_pdev[NR_OMAP3_IOMMU_DEVICES];
-#else
-#define omap3_devices		NULL
-#define NR_OMAP3_IOMMU_DEVICES	0
-#define omap3_iommu_pdev	NULL
-#endif
-
-#ifdef CONFIG_ARCH_OMAP4
-static struct iommu_device omap4_devices[] = {
-	{
-		.base = OMAP4_MMU1_BASE,
-		.irq = 100 + OMAP44XX_IRQ_GIC_START,
-		.pdata = {
-			.name = "ducati",
-			.nr_tlb_entries = 32,
-			.clk_name = "ipu_fck",
-			.da_start = 0x0,
-			.da_end = 0xFFFFF000,
-		},
-	},
-	{
-		.base = OMAP4_MMU2_BASE,
-		.irq = 28 + OMAP44XX_IRQ_GIC_START,
-		.pdata = {
-			.name = "tesla",
-			.nr_tlb_entries = 32,
-			.clk_name = "dsp_fck",
-			.da_start = 0x0,
-			.da_end = 0xFFFFF000,
-		},
-	},
-};
-#define NR_OMAP4_IOMMU_DEVICES ARRAY_SIZE(omap4_devices)
-static struct platform_device *omap4_iommu_pdev[NR_OMAP4_IOMMU_DEVICES];
-#else
-#define omap4_devices		NULL
-#define NR_OMAP4_IOMMU_DEVICES	0
-#define omap4_iommu_pdev	NULL
-#endif
-
-static struct platform_device **omap_iommu_pdev;
-
-static int __init omap_iommu_init(void)
+static int __init omap_iommu_dev_init(struct omap_hwmod *oh, void *unused)
 {
-	int i, err;
-	struct resource res[] = {
-		{ .flags = IORESOURCE_MEM },
-		{ .flags = IORESOURCE_IRQ },
-	};
+	struct platform_device *pdev;
+	struct iommu_platform_data *pdata;
+	struct omap_mmu_dev_attr *a = (struct omap_mmu_dev_attr *)oh->dev_attr;
+	static int i;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->name = oh->name;
+	pdata->clk_name = oh->main_clk;
+	pdata->nr_tlb_entries = a->nr_tlb_entries;
+	pdata->da_start = a->da_start;
+	pdata->da_end = a->da_end;
+
+	if (oh->rst_lines_cnt == 1) {
+		pdata->reset_name = oh->rst_lines->name;
+		pdata->assert_reset = omap_device_assert_hardreset;
+		pdata->deassert_reset = omap_device_deassert_hardreset;
+	}
 
-	if (cpu_is_omap34xx()) {
-		devices = omap3_devices;
-		omap_iommu_pdev = omap3_iommu_pdev;
-		num_iommu_devices = NR_OMAP3_IOMMU_DEVICES;
-	} else if (cpu_is_omap44xx()) {
-		devices = omap4_devices;
-		omap_iommu_pdev = omap4_iommu_pdev;
-		num_iommu_devices = NR_OMAP4_IOMMU_DEVICES;
-	} else
-		return -ENODEV;
+	pdev = omap_device_build("omap-iommu", i, oh, pdata, sizeof(*pdata),
+				NULL, 0, 0);
 
-	for (i = 0; i < num_iommu_devices; i++) {
-		struct platform_device *pdev;
-		const struct iommu_device *d = &devices[i];
+	kfree(pdata);
 
-		pdev = platform_device_alloc("omap-iommu", i);
-		if (!pdev) {
-			err = -ENOMEM;
-			goto err_out;
-		}
+	if (IS_ERR(pdev)) {
+		pr_err("%s: device build err: %ld\n", __func__, PTR_ERR(pdev));
+		return PTR_ERR(pdev);
+	}
 
-		res[0].start = d->base;
-		res[0].end = d->base + MMU_REG_SIZE - 1;
-		res[1].start = res[1].end = d->irq;
+	i++;
 
-		err = platform_device_add_resources(pdev, res,
-						    ARRAY_SIZE(res));
-		if (err)
-			goto err_out;
-		err = platform_device_add_data(pdev, &d->pdata,
-					       sizeof(d->pdata));
-		if (err)
-			goto err_out;
-		err = platform_device_add(pdev);
-		if (err)
-			goto err_out;
-		omap_iommu_pdev[i] = pdev;
-	}
 	return 0;
+}
 
-err_out:
-	while (i--)
-		platform_device_put(omap_iommu_pdev[i]);
-	return err;
+static int __init omap_iommu_init(void)
+{
+	return omap_hwmod_for_each_by_class("mmu", omap_iommu_dev_init, NULL);
 }
 /* must be ready before omap3isp is probed */
 subsys_initcall(omap_iommu_init);
 
 static void __exit omap_iommu_exit(void)
 {
-	int i;
-
-	for (i = 0; i < num_iommu_devices; i++)
-		platform_device_unregister(omap_iommu_pdev[i]);
+	/* Do nothing */
 }
 module_exit(omap_iommu_exit);
 

commit 2ab7c84815cffd5fe4946a472fc67fefa8ac3c29
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 2 12:24:14 2012 -0700

    ARM: OMAP2+: Move iommu/iovmm headers to platform_data
    
    Move iommu/iovmm headers from plat/ to platform_data/ as part of the
    single zImage work.
    
    Partially based on an earlier version by Ido Yariv <ido@wizery.com>.
    
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Omar Ramirez Luna <omar.luna@linaro.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index df298d46707c..a6a4ff8744b7 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -13,7 +13,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
-#include <plat/iommu.h>
+#include <linux/platform_data/iommu-omap.h>
 
 #include "soc.h"
 #include "common.h"

commit 7d7e1eba7e92c2f9c76db80adc24836e7a114bfb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 27 17:43:01 2012 -0700

    ARM: OMAP2+: Prepare for irqs.h removal
    
    As the interrupts should only be defined in the platform_data, and
    eventually coming from device tree, there's no need to define them
    in header files.
    
    Let's remove the hardcoded references to irqs.h and fix up the includes
    so we don't rely on headers included in irqs.h. Note that we're
    defining OMAP_INTC_START as 0 to the interrupts. This will be needed
    when we enable SPARSE_IRQ. For some drivers we need to add
    #include <plat/cpu.h> for now until these drivers are fixed to
    remove cpu_is_omapxxxx() usage.
    
    While at it, sort som of the includes the standard way, and add
    the trailing commas where they are missing in the related data
    structures.
    
    Note that for drivers/staging/tidspbridge we just define things
    locally.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 1be8bcb52e93..df298d46707c 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -14,7 +14,9 @@
 #include <linux/platform_device.h>
 
 #include <plat/iommu.h>
-#include <plat/irqs.h>
+
+#include "soc.h"
+#include "common.h"
 
 struct iommu_device {
 	resource_size_t base;
@@ -29,7 +31,7 @@ static int num_iommu_devices;
 static struct iommu_device omap3_devices[] = {
 	{
 		.base = 0x480bd400,
-		.irq = 24,
+		.irq = 24 + OMAP_INTC_START,
 		.pdata = {
 			.name = "isp",
 			.nr_tlb_entries = 8,
@@ -41,7 +43,7 @@ static struct iommu_device omap3_devices[] = {
 #if defined(CONFIG_OMAP_IOMMU_IVA2)
 	{
 		.base = 0x5d000000,
-		.irq = 28,
+		.irq = 28 + OMAP_INTC_START,
 		.pdata = {
 			.name = "iva2",
 			.nr_tlb_entries = 32,
@@ -64,7 +66,7 @@ static struct platform_device *omap3_iommu_pdev[NR_OMAP3_IOMMU_DEVICES];
 static struct iommu_device omap4_devices[] = {
 	{
 		.base = OMAP4_MMU1_BASE,
-		.irq = OMAP44XX_IRQ_DUCATI_MMU,
+		.irq = 100 + OMAP44XX_IRQ_GIC_START,
 		.pdata = {
 			.name = "ducati",
 			.nr_tlb_entries = 32,
@@ -75,7 +77,7 @@ static struct iommu_device omap4_devices[] = {
 	},
 	{
 		.base = OMAP4_MMU2_BASE,
-		.irq = OMAP44XX_IRQ_TESLA_MMU,
+		.irq = 28 + OMAP44XX_IRQ_GIC_START,
 		.pdata = {
 			.name = "tesla",
 			.nr_tlb_entries = 32,

commit 778d02e9b3b7188ce37ff542e54ff5df723659e6
Author: Juan Gutierrez <jgutierrez@ti.com>
Date:   Sun May 13 15:33:07 2012 +0300

    ARM: OMAP4: fix irq and clock name for dsp-iommu
    
    Irq and clock names were wrong for dsp iommu configuration
    for omap4.
    
    - Renamed tesla_ick to dsp_fck:
       This is required because the new naming convention introduced
       by: commit 0e43327 "OMAP4 clock: Fix clock names and align
       with hwmod names"
    
    - Renamed INT_44XX_DSP_MMU to OMAP44XX_IRQ_TESLA_MMU.
       Naming convention adopted since: commit e927f8d "omap4: Add
       auto-generated irq and dma headers"
    
    - dsp-iommu is enabled by default.
    
    Signed-off-by: Juan Gutierrez <jgutierrez@ti.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index ac49384d0285..1be8bcb52e93 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -73,19 +73,17 @@ static struct iommu_device omap4_devices[] = {
 			.da_end = 0xFFFFF000,
 		},
 	},
-#if defined(CONFIG_MPU_TESLA_IOMMU)
 	{
 		.base = OMAP4_MMU2_BASE,
-		.irq = INT_44XX_DSP_MMU,
+		.irq = OMAP44XX_IRQ_TESLA_MMU,
 		.pdata = {
 			.name = "tesla",
 			.nr_tlb_entries = 32,
-			.clk_name = "tesla_ick",
+			.clk_name = "dsp_fck",
 			.da_start = 0x0,
 			.da_end = 0xFFFFF000,
 		},
 	},
-#endif
 };
 #define NR_OMAP4_IOMMU_DEVICES ARRAY_SIZE(omap4_devices)
 static struct platform_device *omap4_iommu_pdev[NR_OMAP4_IOMMU_DEVICES];

commit 134d12fae0bb8f3d60dc7440a9e1950bb5427167
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Mar 4 12:01:11 2012 +0200

    ARM: OMAP: fix iommu, not mailbox
    
    For some weird (freudian?) reason, commit 435792d "ARM: OMAP: make
    iommu subsys_initcall to fix builtin omap3isp" unintentionally changed
    the mailbox's initcall instead of the iommu's.
    
    Fix that.
    
    Reported-by: Fernando Guzman Lugo <fernando.lugo@ti.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Joerg Roedel <Joerg.Roedel@amd.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index b8822048e409..ac49384d0285 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -150,7 +150,8 @@ static int __init omap_iommu_init(void)
 		platform_device_put(omap_iommu_pdev[i]);
 	return err;
 }
-module_init(omap_iommu_init);
+/* must be ready before omap3isp is probed */
+subsys_initcall(omap_iommu_init);
 
 static void __exit omap_iommu_exit(void)
 {

commit a1bcc1dcef8451b4291ea2a1b2677cb194102952
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 7 12:27:10 2011 -0800

    ARM: OMAP: Fix export.h or module.h includes
    
    Commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb (Merge branch
    'modsplit-Oct31_2011'...) caused some build errors. Fix these
    and make sure we always have export.h or module.h included
    for MODULE_ and EXPORT_SYMBOL users:
    
    $ grep -rl ^MODULE_ arch/arm/*omap*/*.c | xargs \
      grep -L linux/module.h
      arch/arm/mach-omap2/dsp.c
      arch/arm/mach-omap2/mailbox.c
      arch/arm/mach-omap2/omap-iommu.c
      arch/arm/mach-omap2/smartreflex.c
    
    Also check we either have export.h or module.h included
    for the files exporting symbols:
    
    $ grep -rl EXPORT_SYMBOL arch/arm/*omap*/*.c | xargs \
      grep -L linux/export.h | xargs grep -L linux/module.h
    
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index e61feadcda4e..b8822048e409 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -10,6 +10,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/module.h>
 #include <linux/platform_device.h>
 
 #include <plat/iommu.h>

commit fee17d4fdf70050e84fab3eb9d8eeb8d1daad242
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Wed Jun 15 16:02:50 2011 +0300

    OMAP4: iommu: fix clock name
    
    0e43327 "OMAP4: clock: Fix clock names and align with hwmod names"
    renamed ducati_ick to ipu_fck.
    
    Update OMAP4's iommu_device accordingly, so that omap_iommu_probe
    doesn't break when calling clk_get.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 3fc5dc7233da..e61feadcda4e 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -67,7 +67,7 @@ static struct iommu_device omap4_devices[] = {
 		.pdata = {
 			.name = "ducati",
 			.nr_tlb_entries = 32,
-			.clk_name = "ducati_ick",
+			.clk_name = "ipu_fck",
 			.da_start = 0x0,
 			.da_end = 0xFFFFF000,
 		},

commit 1cd25df4e53b9507f7abbb8aff8ce2ba644a1468
Author: Felipe Contreras <felipe.contreras@nokia.com>
Date:   Mon Oct 11 09:53:49 2010 +0000

    OMAP: iommu: make iva2 iommu selectable
    
    It seems dsp-link will do this, and tidspbridge too at some point, but
    right now it's not possible to select CONFIG_MPU_BRIDGE_IOMMU.
    
    Cc: Fernando Guzman Lugo <fernando.lugo@ti.com>
    Cc: Yogesh Marathe <yogesh_marathe@ti.com>
    Signed-off-by: Felipe Contreras <felipe.contreras@nokia.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 6be548cdd800..3fc5dc7233da 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -37,7 +37,7 @@ static struct iommu_device omap3_devices[] = {
 			.da_end = 0xFFFFF000,
 		},
 	},
-#if defined(CONFIG_MPU_BRIDGE_IOMMU)
+#if defined(CONFIG_OMAP_IOMMU_IVA2)
 	{
 		.base = 0x5d000000,
 		.irq = 28,

commit c7f4ab26e3bcdaeb3e19ec658e3ad9092f1a6ceb
Author: Guzman Lugo, Fernando <x0095840@ti.com>
Date:   Wed Dec 15 00:54:03 2010 +0000

    OMAP: iommu: create new api to set valid da range
    
    Some IOMMUs cannot use the whole 0x0 - 0xFFFFFFFF range.
    With this new API the valid range can be set.
    
    Signed-off-by: Fernando Guzman Lugo <x0095840@ti.com>
    Acked-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index f5a1aad1a5c0..6be548cdd800 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -33,6 +33,8 @@ static struct iommu_device omap3_devices[] = {
 			.name = "isp",
 			.nr_tlb_entries = 8,
 			.clk_name = "cam_ick",
+			.da_start = 0x0,
+			.da_end = 0xFFFFF000,
 		},
 	},
 #if defined(CONFIG_MPU_BRIDGE_IOMMU)
@@ -43,6 +45,8 @@ static struct iommu_device omap3_devices[] = {
 			.name = "iva2",
 			.nr_tlb_entries = 32,
 			.clk_name = "iva2_ck",
+			.da_start = 0x11000000,
+			.da_end = 0xFFFFF000,
 		},
 	},
 #endif
@@ -64,6 +68,8 @@ static struct iommu_device omap4_devices[] = {
 			.name = "ducati",
 			.nr_tlb_entries = 32,
 			.clk_name = "ducati_ick",
+			.da_start = 0x0,
+			.da_end = 0xFFFFF000,
 		},
 	},
 #if defined(CONFIG_MPU_TESLA_IOMMU)
@@ -74,6 +80,8 @@ static struct iommu_device omap4_devices[] = {
 			.name = "tesla",
 			.nr_tlb_entries = 32,
 			.clk_name = "tesla_ick",
+			.da_start = 0x0,
+			.da_end = 0xFFFFF000,
 		},
 	},
 #endif

commit 1fd7f467127fcaea490451052fea22f234bbb206
Author: Kanigeri, Hari <h-kanigeri2@ti.com>
Date:   Fri May 14 22:55:41 2010 +0000

    omap iommu: update ducati mmu irq define name
    
    2.6.34-rc6 kernel has the Ducati mmu irq define name changed, which is
    resulting in compilation error.
    
    Signed-off-by: Hari Kanigeri <h-kanigeri2@ti.com>
    Signed-off-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index eb9bee73e0cb..f5a1aad1a5c0 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -59,7 +59,7 @@ static struct platform_device *omap3_iommu_pdev[NR_OMAP3_IOMMU_DEVICES];
 static struct iommu_device omap4_devices[] = {
 	{
 		.base = OMAP4_MMU1_BASE,
-		.irq = INT_44XX_DUCATI_MMU_IRQ,
+		.irq = OMAP44XX_IRQ_DUCATI_MMU,
 		.pdata = {
 			.name = "ducati",
 			.nr_tlb_entries = 32,

commit f779f9235f5fcaa887747ee13195efd81d09acce
Author: Kanigeri, Hari <h-kanigeri2@ti.com>
Date:   Thu Apr 22 23:26:09 2010 +0000

    omap iommu: support for OMAP4
    
    This patch provides the iommu support for OMAP4 co-processors.
    
    Signed-off-by: Hari Kanigeri <h-kanigeri2@ti.com>
    Signed-off-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
index 416a65d5c4a9..eb9bee73e0cb 100644
--- a/arch/arm/mach-omap2/omap-iommu.c
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -13,6 +13,7 @@
 #include <linux/platform_device.h>
 
 #include <plat/iommu.h>
+#include <plat/irqs.h>
 
 struct iommu_device {
 	resource_size_t base;
@@ -20,9 +21,11 @@ struct iommu_device {
 	struct iommu_platform_data pdata;
 	struct resource res[2];
 };
+static struct iommu_device *devices;
+static int num_iommu_devices;
 
 #ifdef CONFIG_ARCH_OMAP3
-static struct iommu_device devices[] = {
+static struct iommu_device omap3_devices[] = {
 	{
 		.base = 0x480bd400,
 		.irq = 24,
@@ -44,11 +47,46 @@ static struct iommu_device devices[] = {
 	},
 #endif
 };
+#define NR_OMAP3_IOMMU_DEVICES ARRAY_SIZE(omap3_devices)
+static struct platform_device *omap3_iommu_pdev[NR_OMAP3_IOMMU_DEVICES];
+#else
+#define omap3_devices		NULL
+#define NR_OMAP3_IOMMU_DEVICES	0
+#define omap3_iommu_pdev	NULL
 #endif
 
-#define NR_IOMMU_DEVICES ARRAY_SIZE(devices)
+#ifdef CONFIG_ARCH_OMAP4
+static struct iommu_device omap4_devices[] = {
+	{
+		.base = OMAP4_MMU1_BASE,
+		.irq = INT_44XX_DUCATI_MMU_IRQ,
+		.pdata = {
+			.name = "ducati",
+			.nr_tlb_entries = 32,
+			.clk_name = "ducati_ick",
+		},
+	},
+#if defined(CONFIG_MPU_TESLA_IOMMU)
+	{
+		.base = OMAP4_MMU2_BASE,
+		.irq = INT_44XX_DSP_MMU,
+		.pdata = {
+			.name = "tesla",
+			.nr_tlb_entries = 32,
+			.clk_name = "tesla_ick",
+		},
+	},
+#endif
+};
+#define NR_OMAP4_IOMMU_DEVICES ARRAY_SIZE(omap4_devices)
+static struct platform_device *omap4_iommu_pdev[NR_OMAP4_IOMMU_DEVICES];
+#else
+#define omap4_devices		NULL
+#define NR_OMAP4_IOMMU_DEVICES	0
+#define omap4_iommu_pdev	NULL
+#endif
 
-static struct platform_device *omap_iommu_pdev[NR_IOMMU_DEVICES];
+static struct platform_device **omap_iommu_pdev;
 
 static int __init omap_iommu_init(void)
 {
@@ -58,7 +96,18 @@ static int __init omap_iommu_init(void)
 		{ .flags = IORESOURCE_IRQ },
 	};
 
-	for (i = 0; i < NR_IOMMU_DEVICES; i++) {
+	if (cpu_is_omap34xx()) {
+		devices = omap3_devices;
+		omap_iommu_pdev = omap3_iommu_pdev;
+		num_iommu_devices = NR_OMAP3_IOMMU_DEVICES;
+	} else if (cpu_is_omap44xx()) {
+		devices = omap4_devices;
+		omap_iommu_pdev = omap4_iommu_pdev;
+		num_iommu_devices = NR_OMAP4_IOMMU_DEVICES;
+	} else
+		return -ENODEV;
+
+	for (i = 0; i < num_iommu_devices; i++) {
 		struct platform_device *pdev;
 		const struct iommu_device *d = &devices[i];
 
@@ -98,7 +147,7 @@ static void __exit omap_iommu_exit(void)
 {
 	int i;
 
-	for (i = 0; i < NR_IOMMU_DEVICES; i++)
+	for (i = 0; i < num_iommu_devices; i++)
 		platform_device_unregister(omap_iommu_pdev[i]);
 }
 module_exit(omap_iommu_exit);

commit 44da397fadf19928838aaa58317a5827dd6c1ec6
Author: Kanigeri, Hari <h-kanigeri2@ti.com>
Date:   Thu Apr 22 23:26:08 2010 +0000

    omap iommu: renamed omap3-iommu to omap-iommu
    
    This patch includes changes to omap3-iommu.c file to make it generic
    for all OMAPs. Renamed omap3-iommu.c to omap-iommu.c
    
    [Hiroshi DOYU: Remove unnecessary "iommu-y" in Makefile]
    
    Signed-off-by: Hari Kanigeri <h-kanigeri2@ti.com>
    Signed-off-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>

diff --git a/arch/arm/mach-omap2/omap-iommu.c b/arch/arm/mach-omap2/omap-iommu.c
new file mode 100644
index 000000000000..416a65d5c4a9
--- /dev/null
+++ b/arch/arm/mach-omap2/omap-iommu.c
@@ -0,0 +1,108 @@
+/*
+ * omap iommu: omap device registration
+ *
+ * Copyright (C) 2008-2009 Nokia Corporation
+ *
+ * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <plat/iommu.h>
+
+struct iommu_device {
+	resource_size_t base;
+	int irq;
+	struct iommu_platform_data pdata;
+	struct resource res[2];
+};
+
+#ifdef CONFIG_ARCH_OMAP3
+static struct iommu_device devices[] = {
+	{
+		.base = 0x480bd400,
+		.irq = 24,
+		.pdata = {
+			.name = "isp",
+			.nr_tlb_entries = 8,
+			.clk_name = "cam_ick",
+		},
+	},
+#if defined(CONFIG_MPU_BRIDGE_IOMMU)
+	{
+		.base = 0x5d000000,
+		.irq = 28,
+		.pdata = {
+			.name = "iva2",
+			.nr_tlb_entries = 32,
+			.clk_name = "iva2_ck",
+		},
+	},
+#endif
+};
+#endif
+
+#define NR_IOMMU_DEVICES ARRAY_SIZE(devices)
+
+static struct platform_device *omap_iommu_pdev[NR_IOMMU_DEVICES];
+
+static int __init omap_iommu_init(void)
+{
+	int i, err;
+	struct resource res[] = {
+		{ .flags = IORESOURCE_MEM },
+		{ .flags = IORESOURCE_IRQ },
+	};
+
+	for (i = 0; i < NR_IOMMU_DEVICES; i++) {
+		struct platform_device *pdev;
+		const struct iommu_device *d = &devices[i];
+
+		pdev = platform_device_alloc("omap-iommu", i);
+		if (!pdev) {
+			err = -ENOMEM;
+			goto err_out;
+		}
+
+		res[0].start = d->base;
+		res[0].end = d->base + MMU_REG_SIZE - 1;
+		res[1].start = res[1].end = d->irq;
+
+		err = platform_device_add_resources(pdev, res,
+						    ARRAY_SIZE(res));
+		if (err)
+			goto err_out;
+		err = platform_device_add_data(pdev, &d->pdata,
+					       sizeof(d->pdata));
+		if (err)
+			goto err_out;
+		err = platform_device_add(pdev);
+		if (err)
+			goto err_out;
+		omap_iommu_pdev[i] = pdev;
+	}
+	return 0;
+
+err_out:
+	while (i--)
+		platform_device_put(omap_iommu_pdev[i]);
+	return err;
+}
+module_init(omap_iommu_init);
+
+static void __exit omap_iommu_exit(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IOMMU_DEVICES; i++)
+		platform_device_unregister(omap_iommu_pdev[i]);
+}
+module_exit(omap_iommu_exit);
+
+MODULE_AUTHOR("Hiroshi DOYU");
+MODULE_DESCRIPTION("omap iommu: omap device registration");
+MODULE_LICENSE("GPL v2");
