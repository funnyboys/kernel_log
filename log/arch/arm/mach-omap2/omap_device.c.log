commit 82f12e64a019c1ce240c35a67d8e9ee8f70ad29b
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 16 14:41:53 2019 -0800

    ARM: OMAP2+: Drop legacy init for sdma
    
    We can now drop legacy init for sdma as we pass the quirks in auxdata to
    the dmaengine driver.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 1d55602b3f8f..6b4548f3b57f 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -373,176 +373,6 @@ void omap_device_delete(struct omap_device *od)
 	kfree(od);
 }
 
-/**
- * omap_device_copy_resources - Add legacy IO and IRQ resources
- * @oh: interconnect target module
- * @pdev: platform device to copy resources to
- *
- * We still have legacy DMA and smartreflex needing resources.
- * Let's populate what they need until we can eventually just
- * remove this function. Note that there should be no need to
- * call this from omap_device_build_from_dt(), nor should there
- * be any need to call it for other devices.
- */
-static int
-omap_device_copy_resources(struct omap_hwmod *oh,
-			   struct platform_device *pdev)
-{
-	struct device_node *np, *child;
-	struct property *prop;
-	struct resource *res;
-	const char *name;
-	int error, irq = 0;
-
-	if (!oh || !oh->od || !oh->od->pdev)
-		return -EINVAL;
-
-	np = oh->od->pdev->dev.of_node;
-	if (!np) {
-		error = -ENODEV;
-		goto error;
-	}
-
-	res = kcalloc(2, sizeof(*res), GFP_KERNEL);
-	if (!res)
-		return -ENOMEM;
-
-	/* Do we have a dts range for the interconnect target module? */
-	error = omap_hwmod_parse_module_range(oh, np, res);
-
-	/* No ranges, rely on device reg entry */
-	if (error)
-		error = of_address_to_resource(np, 0, res);
-	if (error)
-		goto free;
-
-	/* SmartReflex needs first IO resource name to be "mpu" */
-	res[0].name = "mpu";
-
-	/*
-	 * We may have a configured "ti,sysc" interconnect target with a
-	 * dts child with the interrupt. If so use the first child's
-	 * first interrupt for "ti-hwmods" legacy support.
-	 */
-	of_property_for_each_string(np, "compatible", prop, name)
-		if (!strncmp("ti,sysc-", name, 8))
-			break;
-
-	child = of_get_next_available_child(np, NULL);
-
-	if (name)
-		irq = irq_of_parse_and_map(child, 0);
-	if (!irq)
-		irq = irq_of_parse_and_map(np, 0);
-	if (!irq) {
-		error = -EINVAL;
-		goto free;
-	}
-
-	/* Legacy DMA code needs interrupt name to be "0" */
-	res[1].start = irq;
-	res[1].end = irq;
-	res[1].flags = IORESOURCE_IRQ;
-	res[1].name = "0";
-
-	error = platform_device_add_resources(pdev, res, 2);
-
-free:
-	kfree(res);
-
-error:
-	WARN(error, "%s: %s device %s failed: %i\n",
-	     __func__, oh->name, dev_name(&pdev->dev),
-	     error);
-
-	return error;
-}
-
-/**
- * omap_device_build - build and register an omap_device with one omap_hwmod
- * @pdev_name: name of the platform_device driver to use
- * @pdev_id: this platform_device's connection ID
- * @oh: ptr to the single omap_hwmod that backs this omap_device
- * @pdata: platform_data ptr to associate with the platform_device
- * @pdata_len: amount of memory pointed to by @pdata
- *
- * Convenience function for building and registering a single
- * omap_device record, which in turn builds and registers a
- * platform_device record.  See omap_device_build_ss() for more
- * information.  Returns ERR_PTR(-EINVAL) if @oh is NULL; otherwise,
- * passes along the return value of omap_device_build_ss().
- */
-struct platform_device __init *omap_device_build(const char *pdev_name,
-						 int pdev_id,
-						 struct omap_hwmod *oh,
-						 void *pdata, int pdata_len)
-{
-	int ret = -ENOMEM;
-	struct platform_device *pdev;
-	struct omap_device *od;
-
-	if (!oh || !pdev_name)
-		return ERR_PTR(-EINVAL);
-
-	if (!pdata && pdata_len > 0)
-		return ERR_PTR(-EINVAL);
-
-	if (strncmp(oh->name, "smartreflex", 11) &&
-	    strncmp(oh->name, "dma", 3)) {
-		pr_warn("%s need to update %s to probe with dt\na",
-			__func__, pdev_name);
-		ret = -ENODEV;
-		goto odbs_exit;
-	}
-
-	pdev = platform_device_alloc(pdev_name, pdev_id);
-	if (!pdev) {
-		ret = -ENOMEM;
-		goto odbs_exit;
-	}
-
-	/* Set the dev_name early to allow dev_xxx in omap_device_alloc */
-	if (pdev->id != -1)
-		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
-	else
-		dev_set_name(&pdev->dev, "%s", pdev->name);
-
-	/*
-	 * Must be called before omap_device_alloc() as oh->od
-	 * only contains the currently registered omap_device
-	 * and will get overwritten by omap_device_alloc().
-	 */
-	ret = omap_device_copy_resources(oh, pdev);
-	if (ret)
-		goto odbs_exit1;
-
-	od = omap_device_alloc(pdev, &oh, 1);
-	if (IS_ERR(od)) {
-		ret = PTR_ERR(od);
-		goto odbs_exit1;
-	}
-
-	ret = platform_device_add_data(pdev, pdata, pdata_len);
-	if (ret)
-		goto odbs_exit2;
-
-	ret = omap_device_register(pdev);
-	if (ret)
-		goto odbs_exit2;
-
-	return pdev;
-
-odbs_exit2:
-	omap_device_delete(od);
-odbs_exit1:
-	platform_device_put(pdev);
-odbs_exit:
-
-	pr_err("omap_device: %s: build failed (%d)\n", pdev_name, ret);
-
-	return ERR_PTR(ret);
-}
-
 #ifdef CONFIG_PM
 static int _od_runtime_suspend(struct device *dev)
 {

commit 7b6560b4bc623dd1344de32404fd5a901cd1b28e
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Wed Nov 6 11:59:45 2019 +0000

    OMAP2: fixup doc comments in omap_device
    
    The documentation comments in this file are out of
    date with the code, so fix this to avoid the
    following warnings:
    
    arch/arm/mach-omap2/omap_device.c:133: warning: Function parameter or member 'pdev' not described in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:133: warning: Excess function parameter 'pdev_name' description in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:133: warning: Excess function parameter 'pdev_id' description in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:133: warning: Excess function parameter 'oh' description in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:133: warning: Excess function parameter 'pdata' description in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:133: warning: Excess function parameter 'pdata_len' description in 'omap_device_build_from_dt'
    arch/arm/mach-omap2/omap_device.c:309: warning: Function parameter or member 'pdev' not described in 'omap_device_get_context_loss_count'
    arch/arm/mach-omap2/omap_device.c:309: warning: Excess function parameter 'od' description in 'omap_device_get_context_loss_count'
    arch/arm/mach-omap2/omap_device.c:335: warning: Function parameter or member 'ohs' not described in 'omap_device_alloc'
    arch/arm/mach-omap2/omap_device.c:335: warning: Function parameter or member 'oh_cnt' not described in 'omap_device_alloc'
    arch/arm/mach-omap2/omap_device.c:335: warning: Excess function parameter 'oh' description in 'omap_device_alloc'
    arch/arm/mach-omap2/omap_device.c:335: warning: Excess function parameter 'pdata' description in 'omap_device_alloc'
    arch/arm/mach-omap2/omap_device.c:335: warning: Excess function parameter 'pdata_len' description in 'omap_device_alloc'
    arch/arm/mach-omap2/omap_device.c:659: warning: Function parameter or member 'pdev' not described in 'omap_device_register'
    arch/arm/mach-omap2/omap_device.c:659: warning: Excess function parameter 'od' description in 'omap_device_register'
    arch/arm/mach-omap2/omap_device.c:682: warning: Function parameter or member 'pdev' not described in 'omap_device_enable'
    arch/arm/mach-omap2/omap_device.c:682: warning: Excess function parameter 'od' description in 'omap_device_enable'
    arch/arm/mach-omap2/omap_device.c:713: warning: Function parameter or member 'pdev' not described in 'omap_device_idle'
    arch/arm/mach-omap2/omap_device.c:713: warning: Excess function parameter 'od' description in 'omap_device_idle'
    
    Signed-off-by: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 3acb4192918d..1d55602b3f8f 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -119,11 +119,7 @@ static void _add_hwmod_clocks_clkdev(struct omap_device *od,
 
 /**
  * omap_device_build_from_dt - build an omap_device with multiple hwmods
- * @pdev_name: name of the platform_device driver to use
- * @pdev_id: this platform_device's connection ID
- * @oh: ptr to the single omap_hwmod that backs this omap_device
- * @pdata: platform_data ptr to associate with the platform_device
- * @pdata_len: amount of memory pointed to by @pdata
+ * @pdev: The platform device to update.
  *
  * Function for building an omap_device already registered from device-tree
  *
@@ -292,7 +288,7 @@ static int _omap_device_idle_hwmods(struct omap_device *od)
 
 /**
  * omap_device_get_context_loss_count - get lost context count
- * @od: struct omap_device *
+ * @pdev: The platform device to update.
  *
  * Using the primary hwmod, query the context loss count for this
  * device.
@@ -321,9 +317,8 @@ int omap_device_get_context_loss_count(struct platform_device *pdev)
 /**
  * omap_device_alloc - allocate an omap_device
  * @pdev: platform_device that will be included in this omap_device
- * @oh: ptr to the single omap_hwmod that backs this omap_device
- * @pdata: platform_data ptr to associate with the platform_device
- * @pdata_len: amount of memory pointed to by @pdata
+ * @ohs: ptr to the omap_hwmod for this omap_device
+ * @oh_cnt: the size of the ohs list
  *
  * Convenience function for allocating an omap_device structure and filling
  * hwmods, and resources.
@@ -649,7 +644,7 @@ struct dev_pm_domain omap_device_pm_domain = {
 
 /**
  * omap_device_register - register an omap_device with one omap_hwmod
- * @od: struct omap_device * to register
+ * @pdev: the platform device (omap_device) to register.
  *
  * Register the omap_device structure.  This currently just calls
  * platform_device_register() on the underlying platform_device.
@@ -668,7 +663,7 @@ int omap_device_register(struct platform_device *pdev)
 
 /**
  * omap_device_enable - fully activate an omap_device
- * @od: struct omap_device * to activate
+ * @pdev: the platform device to activate
  *
  * Do whatever is necessary for the hwmods underlying omap_device @od
  * to be accessible and ready to operate.  This generally involves
@@ -702,7 +697,7 @@ int omap_device_enable(struct platform_device *pdev)
 
 /**
  * omap_device_idle - idle an omap_device
- * @od: struct omap_device * to idle
+ * @pdev: The platform_device (omap_device) to idle
  *
  * Idle omap_device @od.  Device drivers call this function indirectly
  * via pm_runtime_put*().  Returns -EINVAL if the omap_device is not

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 41c7b905980a..3acb4192918d 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * omap_device implementation
  *
@@ -9,10 +10,6 @@
  * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard
  * Woodruff
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * This code provides a consistent interface for OMAP device drivers
  * to control power management and interconnect properties of their
  * devices.
@@ -20,8 +17,6 @@
  * In the medium- to long-term, this code should be implemented as a
  * proper omap_bus/omap_device in Linux, no more platform_data func
  * pointers
- *
- *
  */
 #undef DEBUG
 

commit b08fc5277aaa1d8ea15470d38bf36f19dfb0e125
Merge: 4597fcff0704 9d2a789c1db7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 12 18:28:00 2018 -0700

    Merge tag 'overflow-v4.18-rc1-part2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull more overflow updates from Kees Cook:
     "The rest of the overflow changes for v4.18-rc1.
    
      This includes the explicit overflow fixes from Silvio, further
      struct_size() conversions from Matthew, and a bug fix from Dan.
    
      But the bulk of it is the treewide conversions to use either the
      2-factor argument allocators (e.g. kmalloc(a * b, ...) into
      kmalloc_array(a, b, ...) or the array_size() macros (e.g. vmalloc(a *
      b) into vmalloc(array_size(a, b)).
    
      Coccinelle was fighting me on several fronts, so I've done a bunch of
      manual whitespace updates in the patches as well.
    
      Summary:
    
       - Error path bug fix for overflow tests (Dan)
    
       - Additional struct_size() conversions (Matthew, Kees)
    
       - Explicitly reported overflow fixes (Silvio, Kees)
    
       - Add missing kvcalloc() function (Kees)
    
       - Treewide conversions of allocators to use either 2-factor argument
         variant when available, or array_size() and array3_size() as needed
         (Kees)"
    
    * tag 'overflow-v4.18-rc1-part2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux: (26 commits)
      treewide: Use array_size in f2fs_kvzalloc()
      treewide: Use array_size() in f2fs_kzalloc()
      treewide: Use array_size() in f2fs_kmalloc()
      treewide: Use array_size() in sock_kmalloc()
      treewide: Use array_size() in kvzalloc_node()
      treewide: Use array_size() in vzalloc_node()
      treewide: Use array_size() in vzalloc()
      treewide: Use array_size() in vmalloc()
      treewide: devm_kzalloc() -> devm_kcalloc()
      treewide: devm_kmalloc() -> devm_kmalloc_array()
      treewide: kvzalloc() -> kvcalloc()
      treewide: kvmalloc() -> kvmalloc_array()
      treewide: kzalloc_node() -> kcalloc_node()
      treewide: kzalloc() -> kcalloc()
      treewide: kmalloc() -> kmalloc_array()
      mm: Introduce kvcalloc()
      video: uvesafb: Fix integer overflow in allocation
      UBIFS: Fix potential integer overflow in allocation
      leds: Use struct_size() in allocation
      Convert intel uncore to struct_size
      ...

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 3b829a50d1db..06b6bca3a179 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -155,7 +155,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	if (!omap_hwmod_parse_module_range(NULL, node, &res))
 		return -ENODEV;
 
-	hwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
+	hwmods = kcalloc(oh_cnt, sizeof(struct omap_hwmod *), GFP_KERNEL);
 	if (!hwmods) {
 		ret = -ENOMEM;
 		goto odbfd_exit;
@@ -405,7 +405,7 @@ omap_device_copy_resources(struct omap_hwmod *oh,
 		goto error;
 	}
 
-	res = kzalloc(sizeof(*res) * 2, GFP_KERNEL);
+	res = kcalloc(2, sizeof(*res), GFP_KERNEL);
 	if (!res)
 		return -ENOMEM;
 

commit 71941002ad140cba0ee922a2bc9f5dcf9ac70b54
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Apr 16 10:24:14 2018 -0700

    ARM: OMAP2+: Only probe SDMA via ti-sysc if configured in dts
    
    We still have some SDMA probing using omap_device_build() for the
    arch/arm/plat-omap/dma.c part that the dmaengine driver then uses.
    
    So we still need to ensure that omap_device_build() works even if we
    probe and manage the dmaengine driver via ti-sysc. And we don't want
    to call dev_pm_domain_set() as otherwise we'd also have omap_device
    try to manage the hardware in addition to ti-sysc.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 3b829a50d1db..ac219b9e6a4c 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -143,7 +143,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	struct resource res;
 	const char *oh_name;
 	int oh_cnt, i, ret = 0;
-	bool device_active = false;
+	bool device_active = false, skip_pm_domain = false;
 
 	oh_cnt = of_property_count_strings(node, "ti,hwmods");
 	if (oh_cnt <= 0) {
@@ -151,8 +151,15 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	/* SDMA still needs special handling for omap_device_build() */
+	ret = of_property_read_string_index(node, "ti,hwmods", 0, &oh_name);
+	if (!ret && (!strncmp("dma_system", oh_name, 10) ||
+		     !strncmp("dma", oh_name, 3)))
+		skip_pm_domain = true;
+
 	/* Use ti-sysc driver instead of omap_device? */
-	if (!omap_hwmod_parse_module_range(NULL, node, &res))
+	if (!skip_pm_domain &&
+	    !omap_hwmod_parse_module_range(NULL, node, &res))
 		return -ENODEV;
 
 	hwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
@@ -191,11 +198,12 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 			r->name = dev_name(&pdev->dev);
 	}
 
-	dev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);
-
-	if (device_active) {
-		omap_device_enable(pdev);
-		pm_runtime_set_active(&pdev->dev);
+	if (!skip_pm_domain) {
+		dev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);
+		if (device_active) {
+			omap_device_enable(pdev);
+			pm_runtime_set_active(&pdev->dev);
+		}
 	}
 
 odbfd_exit1:

commit 695eea3d2c7f3e70e852226c338d464a6251c70b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Feb 22 14:05:31 2018 -0800

    ARM: OMAP2+: Enable ti-sysc to use device tree data for smartreflex
    
    Let's enable ti-sysc probing of child devices. So far we have only used
    ti-sysc to probe interconnect target modules to idle them for cases where
    the SoC does not have any child devices configured for the module, such
    as smartreflex on dra7.
    
    As we have smartreflex driver configured in the device tree for some SoCs,
    we need to flip things on with a single patch to prevent both omap_device
    and ti-sysc to probe smartreflex. So let's stop probing smartreflex with
    omap_device and probe it with ti-sysc by enabling passing the auxdata.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index f0388058b7da..3b829a50d1db 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -140,6 +140,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	struct omap_device *od;
 	struct omap_hwmod *oh;
 	struct device_node *node = pdev->dev.of_node;
+	struct resource res;
 	const char *oh_name;
 	int oh_cnt, i, ret = 0;
 	bool device_active = false;
@@ -150,6 +151,10 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	/* Use ti-sysc driver instead of omap_device? */
+	if (!omap_hwmod_parse_module_range(NULL, node, &res))
+		return -ENODEV;
+
 	hwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
 	if (!hwmods) {
 		ret = -ENOMEM;

commit 2db57789e6612ce0cf2fcbb577a1c8307b708566
Merge: f0c96c6d4031 e9a9bb4e4779
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Nov 28 07:06:34 2017 -0800

    Merge branch 'soc-fixes' into omap-for-v4.15/fixes

commit e9a9bb4e4779ca74cb52a6e2f8acbc0881d3bb18
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Nov 14 09:06:48 2017 +0300

    ARM: OMAP2+: Missing error code in omap_device_build()
    
    We need to set the error code if omap_device_alloc() fails.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index d45cbfdb4be6..2e91eb8ab33c 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -516,8 +516,10 @@ struct platform_device __init *omap_device_build(const char *pdev_name,
 		goto odbs_exit1;
 
 	od = omap_device_alloc(pdev, &oh, 1);
-	if (IS_ERR(od))
+	if (IS_ERR(od)) {
+		ret = PTR_ERR(od);
 		goto odbs_exit1;
+	}
 
 	ret = platform_device_add_data(pdev, pdata, pdata_len);
 	if (ret)

commit f0c96c6d40312b1a76cd36709dc3eb5948c1b97f
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 30 10:01:39 2017 -0700

    ARM: OMAP2+: Fix smatch found issue for omap_device
    
    The patch d85a2d61432a: "ARM: OMAP2+: Populate legacy resources for
    dma and smartreflex" from Oct 10, 2017, leads to the following Smatch
    complaint:
    
    arch/arm/mach-omap2/omap_device.c:453 omap_device_copy_resources()
             error: we previously assumed 'oh' could be null (see line 394)
    
    Fixes: d85a2d61432a: ("ARM: OMAP2+: Populate legacy resources for dma
    and smartreflex")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index d45cbfdb4be6..184acd95c216 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -391,10 +391,8 @@ omap_device_copy_resources(struct omap_hwmod *oh,
 	const char *name;
 	int error, irq = 0;
 
-	if (!oh || !oh->od || !oh->od->pdev) {
-		error = -EINVAL;
-		goto error;
-	}
+	if (!oh || !oh->od || !oh->od->pdev)
+		return -EINVAL;
 
 	np = oh->od->pdev->dev.of_node;
 	if (!np) {

commit 552ee3021cd79feb4203df1d594533fa9c8e1595
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Fri Oct 13 09:29:25 2017 +0000

    ARM: OMAP2+: omap_device: fix error return code in omap_device_copy_resources()
    
    Fix to return error code -EINVAL from the irq_of_parse_and_map() error
    handling case instead of 0, as done elsewhere in this function.
    
    Fixes: d85a2d61432a ("ARM: OMAP2+: Populate legacy resources for dma
    and smartreflex")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 713fc6b4b894..d45cbfdb4be6 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -433,8 +433,10 @@ omap_device_copy_resources(struct omap_hwmod *oh,
 		irq = irq_of_parse_and_map(child, 0);
 	if (!irq)
 		irq = irq_of_parse_and_map(np, 0);
-	if (!irq)
+	if (!irq) {
+		error = -EINVAL;
 		goto free;
+	}
 
 	/* Legacy DMA code needs interrupt name to be "0" */
 	res[1].start = irq;

commit c2b84a9bb3414cabaa039b8860a694464a0bad06
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:26 2017 -0700

    ARM: OMAP2+: Drop omap_hwmod_dma_info
    
    We have all of mach-omap2 booting in device tree only
    mode now, and this data is populated from device tree.
    
    Note that once we have removed support for the omap legacy
    DMA, we can also drop struct omap_dma_dev_attr.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 50f81b2d22b7..713fc6b4b894 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -310,88 +310,6 @@ int omap_device_get_context_loss_count(struct platform_device *pdev)
 	return ret;
 }
 
-/**
- * omap_device_count_resources - count number of struct resource entries needed
- * @od: struct omap_device *
- * @flags: Type of resources to include when counting (IRQ/DMA/MEM)
- *
- * Count the number of struct resource entries needed for this
- * omap_device @od.  Used by omap_device_build_ss() to determine how
- * much memory to allocate before calling
- * omap_device_fill_resources().  Returns the count.
- */
-static int omap_device_count_resources(struct omap_device *od,
-				       unsigned long flags)
-{
-	int c = 0;
-	int i;
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		c += omap_hwmod_count_resources(od->hwmods[i], flags);
-
-	pr_debug("omap_device: %s: counted %d total resources across %d hwmods\n",
-		 od->pdev->name, c, od->hwmods_cnt);
-
-	return c;
-}
-
-/**
- * omap_device_fill_resources - fill in array of struct resource
- * @od: struct omap_device *
- * @res: pointer to an array of struct resource to be filled in
- *
- * Populate one or more empty struct resource pointed to by @res with
- * the resource data for this omap_device @od.  Used by
- * omap_device_build_ss() after calling omap_device_count_resources().
- * Ideally this function would not be needed at all.  If omap_device
- * replaces platform_device, then we can specify our own
- * get_resource()/ get_irq()/etc functions that use the underlying
- * omap_hwmod information.  Or if platform_device is extended to use
- * subarchitecture-specific function pointers, the various
- * platform_device functions can simply call omap_device internal
- * functions to get device resources.  Hacking around the existing
- * platform_device code wastes memory.  Returns 0.
- */
-static int omap_device_fill_resources(struct omap_device *od,
-				      struct resource *res)
-{
-	int i, r;
-
-	for (i = 0; i < od->hwmods_cnt; i++) {
-		r = omap_hwmod_fill_resources(od->hwmods[i], res);
-		res += r;
-	}
-
-	return 0;
-}
-
-/**
- * _od_fill_dma_resources - fill in array of struct resource with dma resources
- * @od: struct omap_device *
- * @res: pointer to an array of struct resource to be filled in
- *
- * Populate one or more empty struct resource pointed to by @res with
- * the dma resource data for this omap_device @od.  Used by
- * omap_device_alloc() after calling omap_device_count_resources().
- *
- * Ideally this function would not be needed at all.  If we have
- * mechanism to get dma resources from DT.
- *
- * Returns 0.
- */
-static int _od_fill_dma_resources(struct omap_device *od,
-				      struct resource *res)
-{
-	int i, r;
-
-	for (i = 0; i < od->hwmods_cnt; i++) {
-		r = omap_hwmod_fill_dma_resources(od->hwmods[i], res);
-		res += r;
-	}
-
-	return 0;
-}
-
 /**
  * omap_device_alloc - allocate an omap_device
  * @pdev: platform_device that will be included in this omap_device
@@ -409,8 +327,7 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 {
 	int ret = -ENOMEM;
 	struct omap_device *od;
-	struct resource *res = NULL;
-	int i, res_count;
+	int i;
 	struct omap_hwmod **hwmods;
 
 	od = kzalloc(sizeof(struct omap_device), GFP_KERNEL);
@@ -426,74 +343,6 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 
 	od->hwmods = hwmods;
 	od->pdev = pdev;
-
-	/*
-	 * Non-DT Boot:
-	 *   Here, pdev->num_resources = 0, and we should get all the
-	 *   resources from hwmod.
-	 *
-	 * DT Boot:
-	 *   OF framework will construct the resource structure (currently
-	 *   does for MEM & IRQ resource) and we should respect/use these
-	 *   resources, killing hwmod dependency.
-	 *   If pdev->num_resources > 0, we assume that MEM & IRQ resources
-	 *   have been allocated by OF layer already (through DTB).
-	 *   As preparation for the future we examine the OF provided resources
-	 *   to see if we have DMA resources provided already. In this case
-	 *   there is no need to update the resources for the device, we use the
-	 *   OF provided ones.
-	 *
-	 * TODO: Once DMA resource is available from OF layer, we should
-	 *   kill filling any resources from hwmod.
-	 */
-	if (!pdev->num_resources) {
-		/* Count all resources for the device */
-		res_count = omap_device_count_resources(od, IORESOURCE_IRQ |
-							    IORESOURCE_DMA |
-							    IORESOURCE_MEM);
-	} else {
-		/* Take a look if we already have DMA resource via DT */
-		for (i = 0; i < pdev->num_resources; i++) {
-			struct resource *r = &pdev->resource[i];
-
-			/* We have it, no need to touch the resources */
-			if (r->flags == IORESOURCE_DMA)
-				goto have_everything;
-		}
-		/* Count only DMA resources for the device */
-		res_count = omap_device_count_resources(od, IORESOURCE_DMA);
-		/* The device has no DMA resource, no need for update */
-		if (!res_count)
-			goto have_everything;
-
-		res_count += pdev->num_resources;
-	}
-
-	/* Allocate resources memory to account for new resources */
-	res = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);
-	if (!res)
-		goto oda_exit3;
-
-	if (!pdev->num_resources) {
-		dev_dbg(&pdev->dev, "%s: using %d resources from hwmod\n",
-			__func__, res_count);
-		omap_device_fill_resources(od, res);
-	} else {
-		dev_dbg(&pdev->dev,
-			"%s: appending %d DMA resources from hwmod\n",
-			__func__, res_count - pdev->num_resources);
-		memcpy(res, pdev->resource,
-		       sizeof(struct resource) * pdev->num_resources);
-		_od_fill_dma_resources(od, &res[pdev->num_resources]);
-	}
-
-	ret = platform_device_add_resources(pdev, res, res_count);
-	kfree(res);
-
-	if (ret)
-		goto oda_exit3;
-
-have_everything:
 	pdev->archdata.od = od;
 
 	for (i = 0; i < oh_cnt; i++) {
@@ -503,8 +352,6 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 
 	return od;
 
-oda_exit3:
-	kfree(hwmods);
 oda_exit2:
 	kfree(od);
 oda_exit1:

commit d85a2d61432aed6a4c2e5f90109a37562f9a8092
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:23:35 2017 -0700

    ARM: OMAP2+: Populate legacy resources for dma and smartreflex
    
    We can populate the legacy resources needed by dma and smartreflex
    from device tree in omap_device_build().
    
    There should be no need to do this for other devices, and eventually
    these two remaining users will be gone too. The legacy dma will be
    dropped when the remaining users have been converted to use the
    dmaengine driver, and smartreflex can now become just a regular
    device driver with a few pdata callbacks.
    
    This is needed in order to remove remaining device dma, irq and io
    resources from the interconnect code.
    
    And while at it, let's simplify things by removing otherwise
    unused omap_device_build_ss() as we will never call it for more
    than one hwmod.
    
    Cc: "Benoît Cousson" <bcousson@baylibre.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index acbede082b5b..50f81b2d22b7 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -35,6 +35,8 @@
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include <linux/notifier.h>
 
 #include "common.h"
@@ -521,6 +523,91 @@ void omap_device_delete(struct omap_device *od)
 	kfree(od);
 }
 
+/**
+ * omap_device_copy_resources - Add legacy IO and IRQ resources
+ * @oh: interconnect target module
+ * @pdev: platform device to copy resources to
+ *
+ * We still have legacy DMA and smartreflex needing resources.
+ * Let's populate what they need until we can eventually just
+ * remove this function. Note that there should be no need to
+ * call this from omap_device_build_from_dt(), nor should there
+ * be any need to call it for other devices.
+ */
+static int
+omap_device_copy_resources(struct omap_hwmod *oh,
+			   struct platform_device *pdev)
+{
+	struct device_node *np, *child;
+	struct property *prop;
+	struct resource *res;
+	const char *name;
+	int error, irq = 0;
+
+	if (!oh || !oh->od || !oh->od->pdev) {
+		error = -EINVAL;
+		goto error;
+	}
+
+	np = oh->od->pdev->dev.of_node;
+	if (!np) {
+		error = -ENODEV;
+		goto error;
+	}
+
+	res = kzalloc(sizeof(*res) * 2, GFP_KERNEL);
+	if (!res)
+		return -ENOMEM;
+
+	/* Do we have a dts range for the interconnect target module? */
+	error = omap_hwmod_parse_module_range(oh, np, res);
+
+	/* No ranges, rely on device reg entry */
+	if (error)
+		error = of_address_to_resource(np, 0, res);
+	if (error)
+		goto free;
+
+	/* SmartReflex needs first IO resource name to be "mpu" */
+	res[0].name = "mpu";
+
+	/*
+	 * We may have a configured "ti,sysc" interconnect target with a
+	 * dts child with the interrupt. If so use the first child's
+	 * first interrupt for "ti-hwmods" legacy support.
+	 */
+	of_property_for_each_string(np, "compatible", prop, name)
+		if (!strncmp("ti,sysc-", name, 8))
+			break;
+
+	child = of_get_next_available_child(np, NULL);
+
+	if (name)
+		irq = irq_of_parse_and_map(child, 0);
+	if (!irq)
+		irq = irq_of_parse_and_map(np, 0);
+	if (!irq)
+		goto free;
+
+	/* Legacy DMA code needs interrupt name to be "0" */
+	res[1].start = irq;
+	res[1].end = irq;
+	res[1].flags = IORESOURCE_IRQ;
+	res[1].name = "0";
+
+	error = platform_device_add_resources(pdev, res, 2);
+
+free:
+	kfree(res);
+
+error:
+	WARN(error, "%s: %s device %s failed: %i\n",
+	     __func__, oh->name, dev_name(&pdev->dev),
+	     error);
+
+	return error;
+}
+
 /**
  * omap_device_build - build and register an omap_device with one omap_hwmod
  * @pdev_name: name of the platform_device driver to use
@@ -539,46 +626,25 @@ struct platform_device __init *omap_device_build(const char *pdev_name,
 						 int pdev_id,
 						 struct omap_hwmod *oh,
 						 void *pdata, int pdata_len)
-{
-	struct omap_hwmod *ohs[] = { oh };
-
-	if (!oh)
-		return ERR_PTR(-EINVAL);
-
-	return omap_device_build_ss(pdev_name, pdev_id, ohs, 1, pdata,
-				    pdata_len);
-}
-
-/**
- * omap_device_build_ss - build and register an omap_device with multiple hwmods
- * @pdev_name: name of the platform_device driver to use
- * @pdev_id: this platform_device's connection ID
- * @oh: ptr to the single omap_hwmod that backs this omap_device
- * @pdata: platform_data ptr to associate with the platform_device
- * @pdata_len: amount of memory pointed to by @pdata
- *
- * Convenience function for building and registering an omap_device
- * subsystem record.  Subsystem records consist of multiple
- * omap_hwmods.  This function in turn builds and registers a
- * platform_device record.  Returns an ERR_PTR() on error, or passes
- * along the return value of omap_device_register().
- */
-struct platform_device __init *omap_device_build_ss(const char *pdev_name,
-						    int pdev_id,
-						    struct omap_hwmod **ohs,
-						    int oh_cnt, void *pdata,
-						    int pdata_len)
 {
 	int ret = -ENOMEM;
 	struct platform_device *pdev;
 	struct omap_device *od;
 
-	if (!ohs || oh_cnt == 0 || !pdev_name)
+	if (!oh || !pdev_name)
 		return ERR_PTR(-EINVAL);
 
 	if (!pdata && pdata_len > 0)
 		return ERR_PTR(-EINVAL);
 
+	if (strncmp(oh->name, "smartreflex", 11) &&
+	    strncmp(oh->name, "dma", 3)) {
+		pr_warn("%s need to update %s to probe with dt\na",
+			__func__, pdev_name);
+		ret = -ENODEV;
+		goto odbs_exit;
+	}
+
 	pdev = platform_device_alloc(pdev_name, pdev_id);
 	if (!pdev) {
 		ret = -ENOMEM;
@@ -591,7 +657,16 @@ struct platform_device __init *omap_device_build_ss(const char *pdev_name,
 	else
 		dev_set_name(&pdev->dev, "%s", pdev->name);
 
-	od = omap_device_alloc(pdev, ohs, oh_cnt);
+	/*
+	 * Must be called before omap_device_alloc() as oh->od
+	 * only contains the currently registered omap_device
+	 * and will get overwritten by omap_device_alloc().
+	 */
+	ret = omap_device_copy_resources(oh, pdev);
+	if (ret)
+		goto odbs_exit1;
+
+	od = omap_device_alloc(pdev, &oh, 1);
 	if (IS_ERR(od))
 		goto odbs_exit1;
 

commit 90de9634a5d57b92d8af4ec23aa2c9b297ec8168
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 10 08:06:39 2017 -0700

    ARM: OMAP2+: omap_device: drop broken RPM status update from suspend_noirq
    
    Since commit a8636c89648a ("PM / Runtime: Don't allow to suspend a
    device with an active child"), which went into 4.10, it is no longer
    permitted to set RPM_SUSPENDED state for a device with active children
    (unless power.ignore_children is set).
    
    This specifically means that the attempts to do just that from the omap
    pm-domain suspend_noirq callback have since been failing whenever a
    child is active, for example:
    
      am335x-usb-childs 47400000.usb: runtime PM trying to suspend
        device but active child
    
    Silence this warning by dropping the broken pm_runtime_set_suspended()
    call from the omap suspend_noirq callback along with the redundant
    pm_runtime_set_active() in resume_noirq.
    
    This effectively reverts commit 3522bf7bfa24 ("ARM: OMAP2+: omap_device:
    maintain sane runtime pm status around suspend/resume"), which started
    updating the RPM state after the runtime_suspend callback (!) for active
    omap devices had been called during system suspend. The rationale was
    that a later pm_runtime_get_sync() would then fail (even after runtime
    pm had been disabled) and that this in turn would avoid any external
    aborts when accessing registers with clocks disabled. (See also commit
    6f3c77b040fc ("PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE,
    even when disabled, v2").
    
    But during the suspend_noirq phase all children would already have been
    suspended and their drivers would specifically not attempt any further
    register accesses. And if this was all just a workaround for random
    device drivers doing cross-tree calls during system suspend, those
    drivers should be fixed and updated to explicitly model such
    dependencies using device-links instead (and either way, any such calls
    have been causing crashes since 4.10).
    
    Fixes: 3522bf7bfa24 ("ARM: OMAP2+: omap_device: maintain sane runtime pm status around suspend/resume")
    Fixes: a8636c89648a ("PM / Runtime: Don't allow to suspend a device with an active child")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index ef9ffb8ac912..acbede082b5b 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -672,7 +672,6 @@ static int _od_suspend_noirq(struct device *dev)
 
 	if (!ret && !pm_runtime_status_suspended(dev)) {
 		if (pm_generic_runtime_suspend(dev) == 0) {
-			pm_runtime_set_suspended(dev);
 			omap_device_idle(pdev);
 			od->flags |= OMAP_DEVICE_SUSPENDED;
 		}
@@ -689,15 +688,6 @@ static int _od_resume_noirq(struct device *dev)
 	if (od->flags & OMAP_DEVICE_SUSPENDED) {
 		od->flags &= ~OMAP_DEVICE_SUSPENDED;
 		omap_device_enable(pdev);
-		/*
-		 * XXX: we run before core runtime pm has resumed itself. At
-		 * this point in time, we just restore the runtime pm state and
-		 * considering symmetric operations in resume, we donot expect
-		 * to fail. If we failed, something changed in core runtime_pm
-		 * framework OR some device driver messed things up, hence, WARN
-		 */
-		WARN(pm_runtime_set_active(dev),
-		     "Could not set %s runtime state active\n", dev_name(dev));
 		pm_generic_runtime_resume(dev);
 	}
 

commit 1aa8f0cb19e59a0def9925d401d628c1846c3270
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 31 15:51:37 2017 -0700

    ARM: OMAP2+: Remove unused legacy code for interconnects
    
    We are now booting all mach-omap2 in device tree only mode.
    Any code that is only called in legacy boot mode where
    of_have_populated_dt() is not set is safe to remove now.
    
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index f989145480c8..ef9ffb8ac912 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -65,7 +65,7 @@ static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 
 	r = clk_get_sys(NULL, clk_name);
 
-	if (IS_ERR(r) && of_have_populated_dt()) {
+	if (IS_ERR(r)) {
 		struct of_phandle_args clkspec;
 
 		clkspec.np = of_find_node_by_name(NULL, clk_name);
@@ -953,9 +953,6 @@ static int __init omap_device_late_init(void)
 {
 	bus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);
 
-	WARN(!of_have_populated_dt(),
-		"legacy booting deprecated, please update to boot with .dts\n");
-
 	return 0;
 }
 omap_late_initcall_sync(omap_device_late_init);

commit 04abaf07f6d5cdf22b7a478a86e706dfeeeef960
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Thu Mar 30 14:58:18 2017 -0500

    ARM: OMAP2+: omap_device: Sync omap_device and pm_runtime after probe defer
    
    Starting from commit 5de85b9d57ab ("PM / runtime: Re-init runtime PM
    states at probe error and driver unbind") pm_runtime core now changes
    device runtime_status back to after RPM_SUSPENDED after a probe defer.
    Certain OMAP devices make use of "ti,no-idle-on-init" flag which causes
    omap_device_enable to be called during the BUS_NOTIFY_ADD_DEVICE event
    during probe, along with pm_runtime_set_active.
    
    This call to pm_runtime_set_active typically will prevent a call to
    pm_runtime_get in a driver probe function from re-enabling the
    omap_device. However, in the case of a probe defer that happens before
    the driver probe function is able to run, such as a missing pinctrl
    states defer, pm_runtime_reinit will set the device as RPM_SUSPENDED and
    then once driver probe is actually able to run, pm_runtime_get will see
    the device as suspended and call through to the omap_device layer,
    attempting to enable the already enabled omap_device and causing errors
    like this:
    
    omap-gpmc 50000000.gpmc: omap_device: omap_device_enable() called from
    invalid state 1
    omap-gpmc 50000000.gpmc: use pm_runtime_put_sync_suspend() in driver?
    
    We can avoid this error by making sure the pm_runtime status of a device
    matches the omap_device state before a probe attempt. By extending the
    omap_device bus notifier to act on the BUS_NOTIFY_BIND_DRIVER event we
    can check if a device is enabled in omap_device but with a pm_runtime
    status of RPM_SUSPENDED and once again mark the device as RPM_ACTIVE to
    avoid a second incorrect call to omap_device_enable.
    
    Fixes: 5de85b9d57ab ("PM / runtime: Re-init runtime PM states at probe
    error and driver unbind")
    Tested-by: Franklin S Cooper Jr. <fcooper@ti.com>
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e920dd83e443..f989145480c8 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -222,6 +222,14 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 				dev_err(dev, "failed to idle\n");
 		}
 		break;
+	case BUS_NOTIFY_BIND_DRIVER:
+		od = to_omap_device(pdev);
+		if (od && (od->_state == OMAP_DEVICE_STATE_ENABLED) &&
+		    pm_runtime_status_suspended(dev)) {
+			od->_driver_status = BUS_NOTIFY_BIND_DRIVER;
+			pm_runtime_set_active(dev);
+		}
+		break;
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdev->dev.of_node)
 			omap_device_build_from_dt(pdev);

commit f0936155f2204720655aefbc2f17c25a2c80a59e
Merge: d52bd54db8be 1d2c2024dcb7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 3 07:26:11 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull networking fixes from David Miller:
    
     1) Fix several cases of missing of_node_put() calls in various
        networking drivers.  From Peter Chen.
    
     2) Don't try to remove unconfigured VLANs in qed driver, from Yuval
        Mintz.
    
     3) Unbalanced locking in TIPC error handling, from Wei Yongjun.
    
     4) Fix lockups in CPDMA driver, from Grygorii Strashko.
    
     5) More MACSEC refcount et al fixes, from Sabrina Dubroca.
    
     6) Fix MAC address setting in r8169 during runtime suspend, from
        Chun-Hao Lin.
    
     7) Various printf format specifier fixes, from Heinrich Schuchardt.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (59 commits)
      qed: Fail driver load in 100g MSI mode.
      ethernet: ti: davinci_emac: add missing of_node_put after calling of_parse_phandle
      ethernet: stmicro: stmmac: add missing of_node_put after calling of_parse_phandle
      ethernet: stmicro: stmmac: dwmac-socfpga: add missing of_node_put after calling of_parse_phandle
      ethernet: renesas: sh_eth: add missing of_node_put after calling of_parse_phandle
      ethernet: renesas: ravb_main: add missing of_node_put after calling of_parse_phandle
      ethernet: marvell: pxa168_eth: add missing of_node_put after calling of_parse_phandle
      ethernet: marvell: mvpp2: add missing of_node_put after calling of_parse_phandle
      ethernet: marvell: mvneta: add missing of_node_put after calling of_parse_phandle
      ethernet: hisilicon: hns: hns_dsaf_main: add missing of_node_put after calling of_parse_phandle
      ethernet: hisilicon: hns: hns_dsaf_mac: add missing of_node_put after calling of_parse_phandle
      ethernet: cavium: octeon: add missing of_node_put after calling of_parse_phandle
      ethernet: aurora: nb8800: add missing of_node_put after calling of_parse_phandle
      ethernet: arc: emac_main: add missing of_node_put after calling of_parse_phandle
      ethernet: apm: xgene: add missing of_node_put after calling of_parse_phandle
      ethernet: altera: add missing of_node_put
      8139too: fix system hang when there is a tx timeout event.
      qed: Fix error return code in qed_resc_alloc()
      net: qlcnic: avoid superfluous assignement
      dsa: b53: remove redundant if
      ...

commit 213fa10db2f9c6725946cfa682990277eb9cd565
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Thu Jul 28 20:50:37 2016 +0300

    ARM: OMAP2+: omap_device: fix crash on omap_device removal
    
    Below call chain causes system crash when OMAP device is
    removed by calling of_platform_depopulate()/device_del():
    
    device_del()
    - blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
                                 BUS_NOTIFY_DEL_DEVICE, dev);
      - _omap_device_notifier_call()
        - omap_device_delete()
          - od->pdev->archdata.od = NULL;
            kfree(od->hwmods);
            kfree(od);
      - bus_remove_device()
        - device_release_driver()
          - __device_release_driver()
            - pm_runtime_get_sync()
               - _od_runtime_resume()
                 - omap_hwmod_enable() <- OOPS od's delted already
    
    Backtrace:
    Unable to handle kernel NULL pointer dereference at virtual address 0000000d
    pgd = eb100000
    [0000000d] *pgd=ad6e1831, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] PREEMPT SMP ARM
    CPU: 1 PID: 1273 Comm: modprobe Not tainted 4.4.15-rt19-00115-ge4d3cd3-dirty #68
    Hardware name: Generic DRA74X (Flattened Device Tree)
    task: eb1ee800 ti: ec962000 task.ti: ec962000
    PC is at omap_device_enable+0x10/0x90
    LR is at _od_runtime_resume+0x10/0x24
    [...]
    [<c00299dc>] (omap_device_enable) from [<c0029a6c>] (_od_runtime_resume+0x10/0x24)
    [<c0029a6c>] (_od_runtime_resume) from [<c04ad404>] (__rpm_callback+0x20/0x34)
    [<c04ad404>] (__rpm_callback) from [<c04ad438>] (rpm_callback+0x20/0x80)
    [<c04ad438>] (rpm_callback) from [<c04aee28>] (rpm_resume+0x48c/0x964)
    [<c04aee28>] (rpm_resume) from [<c04af360>] (__pm_runtime_resume+0x60/0x88)
    [<c04af360>] (__pm_runtime_resume) from [<c04a4974>] (__device_release_driver+0x30/0x100)
    [<c04a4974>] (__device_release_driver) from [<c04a4a60>] (device_release_driver+0x1c/0x28)
    [<c04a4a60>] (device_release_driver) from [<c04a38c0>] (bus_remove_device+0xec/0x144)
    [<c04a38c0>] (bus_remove_device) from [<c04a0764>] (device_del+0x10c/0x210)
    [<c04a0764>] (device_del) from [<c04a67b0>] (platform_device_del+0x18/0x84)
    [<c04a67b0>] (platform_device_del) from [<c04a6828>] (platform_device_unregister+0xc/0x20)
    [<c04a6828>] (platform_device_unregister) from [<c05adcfc>] (of_platform_device_destroy+0x8c/0x90)
    [<c05adcfc>] (of_platform_device_destroy) from [<c04a02f0>] (device_for_each_child+0x4c/0x78)
    [<c04a02f0>] (device_for_each_child) from [<c05adc5c>] (of_platform_depopulate+0x30/0x44)
    [<c05adc5c>] (of_platform_depopulate) from [<bf123920>] (cpsw_remove+0x68/0xf4 [ti_cpsw])
    [<bf123920>] (cpsw_remove [ti_cpsw]) from [<c04a68d8>] (platform_drv_remove+0x24/0x3c)
    [<c04a68d8>] (platform_drv_remove) from [<c04a49c8>] (__device_release_driver+0x84/0x100)
    [<c04a49c8>] (__device_release_driver) from [<c04a4b20>] (driver_detach+0xac/0xb0)
    [<c04a4b20>] (driver_detach) from [<c04a3be8>] (bus_remove_driver+0x60/0xd4)
    [<c04a3be8>] (bus_remove_driver) from [<c00d9870>] (SyS_delete_module+0x184/0x20c)
    [<c00d9870>] (SyS_delete_module) from [<c0010540>] (ret_fast_syscall+0x0/0x1c)
    Code: e3500000 e92d4070 1590630c 01a06000 (e5d6300d)
    
    Hence, fix it by using BUS_NOTIFY_REMOVED_DEVICE event for OMAP device
    deletion which is sent when DD has finished processing of device
    deletion.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index f7ff3b9dad87..208f11563036 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -194,7 +194,7 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 	int err;
 
 	switch (event) {
-	case BUS_NOTIFY_DEL_DEVICE:
+	case BUS_NOTIFY_REMOVED_DEVICE:
 		if (pdev->archdata.od)
 			omap_device_delete(pdev->archdata.od);
 		break;

commit 59dcfc48eb41c9074938fc2a0a07634e60f08e22
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jun 30 16:14:59 2016 +0300

    ARM: OMAP2+: omap_device: create clock alias purely from DT data
    
    This avoids the need to add most of the clock aliases under
    drivers/clk/ti/clk-xyz.c files.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index a7be05d83ec7..c2626f83e0c2 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -63,7 +63,22 @@ static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 		return;
 	}
 
-	rc = clk_add_alias(clk_alias, dev_name(&od->pdev->dev), clk_name, NULL);
+	r = clk_get_sys(NULL, clk_name);
+
+	if (IS_ERR(r) && of_have_populated_dt()) {
+		struct of_phandle_args clkspec;
+
+		clkspec.np = of_find_node_by_name(NULL, clk_name);
+
+		r = of_clk_get_from_provider(&clkspec);
+
+		rc = clk_register_clkdev(r, clk_alias,
+					 dev_name(&od->pdev->dev));
+	} else {
+		rc = clk_add_alias(clk_alias, dev_name(&od->pdev->dev),
+				   clk_name, NULL);
+	}
+
 	if (rc) {
 		if (rc == -ENODEV || rc == -ENOMEM)
 			dev_err(&od->pdev->dev,

commit f733e7c0e0c2ccdccbc328f31376282725b5d545
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Sat May 21 13:50:25 2016 +0200

    ARM: OMAP2+: Fix typo in omap_device.c
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index f7ff3b9dad87..a7be05d83ec7 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -268,7 +268,7 @@ static int _omap_device_idle_hwmods(struct omap_device *od)
  * function returns a value different than the value the caller got
  * the last time it called this function.
  *
- * If any hwmods exist for the omap_device assoiated with @pdev,
+ * If any hwmods exist for the omap_device associated with @pdev,
  * return the context loss counter for that hwmod, otherwise return
  * zero.
  */

commit cf26f1137333251f3515dea31f95775b99df0fd5
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 12 08:56:52 2016 -0800

    ARM: OMAP2+: Fix omap_device for module reload on PM runtime forbid
    
    If a driver PM runtime is disabled via sysfs, and the module is
    unloaded, PM runtime can't do anything to disable the device. Let's
    let the interconnect disable the device on BUS_NOTIFY_UNBOUND_DRIVER.
    
    Otherwise omap_device will produce and error on the following module
    reload. This can be easily tested with something like:
    
    # modprobe omap_hsmmc
    # echo on > /sys/devices/platform/68000000.ocp/4809c000.mmc/power/control
    # rmmod omap_hsmmc
    # modprobe omap_hsmmc
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rafael J. Wysocki <rafael@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Reported-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@baylibre.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index ebd83690ba48..f7ff3b9dad87 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -191,12 +191,22 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omap_device *od;
+	int err;
 
 	switch (event) {
 	case BUS_NOTIFY_DEL_DEVICE:
 		if (pdev->archdata.od)
 			omap_device_delete(pdev->archdata.od);
 		break;
+	case BUS_NOTIFY_UNBOUND_DRIVER:
+		od = to_omap_device(pdev);
+		if (od && (od->_state == OMAP_DEVICE_STATE_ENABLED)) {
+			dev_info(dev, "enabled after unload, idling\n");
+			err = omap_device_idle(pdev);
+			if (err)
+				dev_err(dev, "failed to idle\n");
+		}
+		break;
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdev->dev.of_node)
 			omap_device_build_from_dt(pdev);

commit 08c78e9d61a857c9077240e7ddb67550c6f96d06
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 12 08:56:52 2016 -0800

    ARM: OMAP2+: Improve omap_device error for driver writers
    
    Drivers using pm_runtime_use_autosuspend() may not get disabled after
    -EPROBE_DEFER. On the following device driver probe, hardware state
    is different from the PM runtime state causing omap_device to produce
    the following error:
    
    omap_device_enable() called from invalid state 1
    
    And with omap_device and omap hardware being picky for PM, this will
    block any deeper idle states in hardware.
    
    Let's add a proper error message so driver writers can easily fix
    their drivers for PM.
    
    In general, the solution is to fix the drivers to follow the PM
    runtime documentation:
    
    1. For sections of code that needs the device disabled, use
       pm_runtime_put_sync_suspend() if pm_runtime_set_autosuspend() has
       been set.
    
    2. For driver exit code, use pm_runtime_dont_use_autosuspend() before
       pm_runtime_put_sync() if pm_runtime_use_autosuspend() has been
       set.
    
    Let's not return with 0 from _od_runtime_resume() as that will
    eventually lead into new drivers with broken PM runtime that will
    block deeper idle states on omaps.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rafael J. Wysocki <rafael@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Acked-by: Kevin Hilman <khilman@baylibre.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 0437537751bc..ebd83690ba48 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -602,8 +602,10 @@ static int _od_runtime_resume(struct device *dev)
 	int ret;
 
 	ret = omap_device_enable(pdev);
-	if (ret)
+	if (ret) {
+		dev_err(dev, "use pm_runtime_put_sync_suspend() in driver?\n");
 		return ret;
+	}
 
 	return pm_generic_runtime_resume(dev);
 }

commit 30f05309bde49295e02e45c7e615f73aa4e0ccc2
Merge: 3549d8227937 db2b52f75250
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 20 19:06:49 2016 -0800

    Merge tag 'pm+acpi-4.5-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management and ACPI updates from Rafael Wysocki:
     "This includes fixes on top of the previous batch of PM+ACPI updates
      and some new material as well.
    
      From the new material perspective the most significant are the driver
      core changes that should allow USB devices to stay suspended over
      system suspend/resume cycles if they have been runtime-suspended
      already beforehand.  Apart from that, ACPICA is updated to upstream
      revision 20160108 (cosmetic mostly, but including one fixup on top of
      the previous ACPICA update) and there are some devfreq updates the
      didn't make it before (due to timing).
    
      A few recent regressions are fixed, most importantly in the cpuidle
      menu governor and in the ACPI backlight driver and some x86 platform
      drivers depending on it.
    
      Some more bugs are fixed and cleanups are made on top of that.
    
      Specifics:
    
       - Modify the driver core and the USB subsystem to allow USB devices
         to stay suspended over system suspend/resume cycles if they have
         been runtime-suspended already beforehand and fix some bugs on top
         of these changes (Tomeu Vizoso, Rafael Wysocki).
    
       - Update ACPICA to upstream revision 20160108, including updates of
         the ACPICA's copyright notices, a code fixup resulting from a
         regression fix that was necessary in the upstream code only (the
         regression fixed by it has never been present in Linux) and a
         compiler warning fix (Bob Moore, Lv Zheng).
    
       - Fix a recent regression in the cpuidle menu governor that broke it
         on practically all architectures other than x86 and make a couple
         of optimizations on top of that fix (Rafael Wysocki).
    
       - Clean up the selection of cpuidle governors depending on whether or
         not the kernel is configured for tickless systems (Jean Delvare).
    
       - Revert a recent commit that introduced a regression in the ACPI
         backlight driver, address the problem it attempted to fix in a
         different way and revert one more cosmetic change depending on the
         problematic commit (Hans de Goede).
    
       - Add two more ACPI backlight quirks (Hans de Goede).
    
       - Fix a few minor problems in the core devfreq code, clean it up a
         bit and update the MAINTAINERS information related to it (Chanwoo
         Choi, MyungJoo Ham).
    
       - Improve an error message in the ACPI fan driver (Andy Lutomirski).
    
       - Fix a recent build regression in the cpupower tool (Shreyas
         Prabhu)"
    
    * tag 'pm+acpi-4.5-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      cpuidle: menu: Avoid pointless checks in menu_select()
      sched / idle: Drop default_idle_call() fallback from call_cpuidle()
      cpupower: Fix build error in cpufreq-info
      cpuidle: Don't enable all governors by default
      cpuidle: Default to ladder governor on ticking systems
      time: nohz: Expose tick_nohz_enabled
      ACPICA: Update version to 20160108
      ACPICA: Silence a -Wbad-function-cast warning when acpi_uintptr_t is 'uintptr_t'
      ACPICA: Additional 2016 copyright changes
      ACPICA: Reduce regression fix divergence from upstream ACPICA
      ACPI / video: Add disable_backlight_sysfs_if quirk for the Toshiba Satellite R830
      ACPI / video: Revert "thinkpad_acpi: Use acpi_video_handles_brightness_key_presses()"
      ACPI / video: Document acpi_video_handles_brightness_key_presses() a bit
      ACPI / video: Fix using an uninitialized mutex / list_head in acpi_video_handles_brightness_key_presses()
      ACPI / video: Revert "ACPI / video: driver must be registered before checking for keypresses"
      ACPI / fan: Improve acpi_device_update_power error message
      ACPI / video: Add disable_backlight_sysfs_if quirk for the Toshiba Portege R700
      cpuidle: menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0
      MAINTAINERS: Add devfreq-event entry
      MAINTAINERS: Add missing git repository and directory for devfreq
      ...

commit 989561de9b5112999475b406557d9c7e9e59c041
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:13 2016 +0100

    PM / Domains: add setter for dev.pm_domain
    
    Adds a function that sets the pointer to dev_pm_domain in struct device
    and that warns if the device has already finished probing. The reason
    why we want to enforce that is because in the general case that can
    cause problems and also that we can simplify code quite a bit if we can
    always assume that.
    
    This patch also changes all current code that directly sets the
    dev.pm_domain pointer.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 72ebc4c16bae..220822bcfe3f 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -32,6 +32,7 @@
 #include <linux/io.h>
 #include <linux/clk.h>
 #include <linux/clkdev.h>
+#include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
 #include <linux/notifier.h>
@@ -168,7 +169,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 			r->name = dev_name(&pdev->dev);
 	}
 
-	pdev->dev.pm_domain = &omap_device_pm_domain;
+	dev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);
 
 	if (device_active) {
 		omap_device_enable(pdev);
@@ -180,7 +181,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 odbfd_exit:
 	/* if data/we are at fault.. load up a fail handler */
 	if (ret)
-		pdev->dev.pm_domain = &omap_device_fail_pm_domain;
+		dev_pm_domain_set(&pdev->dev, &omap_device_fail_pm_domain);
 
 	return ret;
 }
@@ -701,7 +702,7 @@ int omap_device_register(struct platform_device *pdev)
 {
 	pr_debug("omap_device: %s: registering\n", pdev->name);
 
-	pdev->dev.pm_domain = &omap_device_pm_domain;
+	dev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);
 	return platform_device_add(pdev);
 }
 

commit 8dd5ea72b0c0dbcdb5d629247ac7ead49c6a9c58
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 3 11:38:09 2015 -0800

    ARM: OMAP2+: Change core_initcall levels to postcore_initcall
    
    We want to be able to probe a few selected device drivers before hwmod
    code populates the clocks in omap_hwmod_setup_all(). This allows us to
    convert most of the clock drivers into regular device drivers.
    
    We only need a few minimal clock drivers early for the system timers to
    select between the 32KiHz clock and the high frequency oscillator.
    
    With these changes, initializing the clock drivers can be just done at
    core_initcall time with something like:
    
    np = of_find_node_by_name(NULL, "plls");
    if (np)
            of_platform_populate(np, NULL, NULL, NULL);
    
    And then these clocks will be available for the interconnect code to use.
    
    Having most of the clock drivers being regular device drivers allows
    us to use the nice things like devm_* functions and dev_err and dev_dbg.
    As an extra bonus, this also allows us to develop the clock drivers for
    new SoCs as loadable modules initially for cases where we can boot up
    the system based on the bootloader configured clocks.
    
    To do this, let's change the core_initcalls to postcore_initcall under
    mach-omap2.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 72ebc4c16bae..3750ed14f8c5 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -869,7 +869,7 @@ static int __init omap_device_init(void)
 	bus_register_notifier(&platform_bus_type, &platform_nb);
 	return 0;
 }
-omap_core_initcall(omap_device_init);
+omap_postcore_initcall(omap_device_init);
 
 /**
  * omap_device_late_idle - idle devices without drivers

commit fe8291e82b5d0b79b743683e5c0fb7e273f7a99a
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Sep 1 13:59:24 2015 -0700

    ARM: OMAP2+: omap-device: fix race deferred probe of omap_hsmmc vs omap_device_late_init
    
    Kernel fails to boot 50% of times (form build to build) with
    RT-patchset applied due to the following race - on late boot
    stages deferred_probe_work_func->omap_hsmmc_probe races with omap_device_late_ini.
    
    The same issue has been reported now on linux-next (4.3) by Keerthy [1]
    
    late_initcall
     - deferred_probe_initcal() tries to re-probe all pending driver's probe.
    
    - later on, some driver is probing in this case It's cpsw.c
      (but could be any other drivers)
      cpsw_init
      - platform_driver_register
        - really_probe
           - driver_bound
             - driver_deferred_probe_trigger
      and boot proceed.
      So, at this moment we have deferred_probe_work_func scheduled.
    
    late_initcall_sync
      - omap_device_late_init
        - omap_device_idle
    
    CPU1                                    CPU2
      - deferred_probe_work_func
        - really_probe
          - omap_hsmmc_probe
            - pm_runtime_get_sync
                                            late_initcall_sync
                                            - omap_device_late_init
                                                    if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER) {
                                                            if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
                                                                    - omap_device_idle [ops - IP is disabled]
            - [fail]
            - pm_runtime_put_sync
              - omap_hsmmc_runtime_suspend [ooops!]
    
    == log ==
     omap_hsmmc 480b4000.mmc: unable to get vmmc regulator -517
     davinci_mdio 48485000.mdio: davinci mdio revision 1.6
     davinci_mdio 48485000.mdio: detected phy mask fffffff3
     libphy: 48485000.mdio: probed
     davinci_mdio 48485000.mdio: phy[2]: device 48485000.mdio:02, driver unknown
     davinci_mdio 48485000.mdio: phy[3]: device 48485000.mdio:03, driver unknown
     omap_hsmmc 480b4000.mmc: unable to get vmmc regulator -517
     cpsw 48484000.ethernet: Detected MACID = b4:99:4c:c7:d2:48
     cpsw 48484000.ethernet: cpsw: Detected MACID = b4:99:4c:c7:d2:49
     hctosys: unable to open rtc device (rtc0)
     omap_hsmmc 480b4000.mmc: omap_device_late_idle: enabled but no driver.  Idling
     ldousb: disabling
     Unhandled fault: imprecise external abort (0x1406) at 0x00000000
     [00000000] *pgd=00000000
     Internal error: : 1406 [#1] PREEMPT SMP ARM
     Modules linked in:
     CPU: 1 PID: 58 Comm: kworker/u4:1 Not tainted 4.1.2-rt1-00467-g6da3c0a-dirty #5
     Hardware name: Generic DRA74X (Flattened Device Tree)
     Workqueue: deferwq deferred_probe_work_func
     task: ee6ddb00 ti: edd3c000 task.ti: edd3c000
     PC is at omap_hsmmc_runtime_suspend+0x1c/0x12c
     LR is at _od_runtime_suspend+0xc/0x24
     pc : [<c0471998>]    lr : [<c0029590>]    psr: a0000013
     sp : edd3dda0  ip : ee6ddb00  fp : c07be540
     r10: 00000000  r9 : c07be540  r8 : 00000008
     r7 : 00000000  r6 : ee646c10  r5 : ee646c10  r4 : edd79380
     r3 : fa0b4100  r2 : 00000000  r1 : 00000000  r0 : ee646c10
     Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
     Control: 10c5387d  Table: 8000406a  DAC: 00000015
     Process kworker/u4:1 (pid: 58, stack limit = 0xedd3c218)
     Stack: (0xedd3dda0 to 0xedd3e000)
     dda0: ee646c70 ee646c10 c0029584 00000000 00000008 c0029590 ee646c70 ee646c10
     ddc0: c0029584 c03adfb8 ee646c10 00000004 0000000c c03adff0 ee646c10 00000004
     dde0: 0000000c c03ae4ec 00000000 edd3c000 ee646c10 00000004 ee646c70 00000004
     de00: fa0b4000 c03aec20 ee6ddb00 ee646c10 00000004 ee646c70 ee646c10 fffffdfb
     de20: edd79380 00000000 fa0b4000 c03aee90 fffffdfb edd79000 ee646c00 c0474290
     de40: 00000000 edda24c0 edd79380 edc81f00 00000000 00000200 00000001 c06dd488
     de60: edda3960 ee646c10 ee646c10 c0824cc4 fffffdfb c0880c94 00000002 edc92600
     de80: c0836378 c03a7f84 ee646c10 c0824cc4 00000000 c0880c80 c0880c94 c03a6568
     dea0: 00000000 ee646c10 c03a66ac ee4f8000 00000000 00000001 edc92600 c03a4b40
     dec0: ee404c94 edc83c4c ee646c10 ee646c10 ee646c44 c03a63c4 ee646c10 ee646c10
     dee0: c0814448 c03a5aa8 ee646c10 c0814220 edd3c000 c03a5ec0 c0814250 ee6be400
     df00: edd3c000 c004e5bc ee6ddb01 00000078 ee6ddb00 ee4f8000 ee6be418 edd3c000
     df20: ee4f8028 00000088 c0836045 ee4f8000 ee6be400 c004e928 ee4f8028 00000000
     df40: c004e8ec 00000000 ee6bf1c0 ee6be400 c004e8ec 00000000 00000000 00000000
     df60: 00000000 c0053450 2e56fa97 00000000 afdffbd7 ee6be400 00000000 00000000
     df80: edd3df80 edd3df80 00000000 00000000 edd3df90 edd3df90 edd3dfac ee6bf1c0
     dfa0: c0053384 00000000 00000000 c000f668 00000000 00000000 00000000 00000000
     dfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
     dfe0: 00000000 00000000 00000000 00000000 00000013 00000000 f1fc9d7e febfbdff
     [<c0471998>] (omap_hsmmc_runtime_suspend) from [<c0029590>] (_od_runtime_suspend+0xc/0x24)
     [<c0029590>] (_od_runtime_suspend) from [<c03adfb8>] (__rpm_callback+0x24/0x3c)
     [<c03adfb8>] (__rpm_callback) from [<c03adff0>] (rpm_callback+0x20/0x80)
     [<c03adff0>] (rpm_callback) from [<c03ae4ec>] (rpm_suspend+0xe4/0x618)
     [<c03ae4ec>] (rpm_suspend) from [<c03aee90>] (__pm_runtime_idle+0x60/0x80)
     [<c03aee90>] (__pm_runtime_idle) from [<c0474290>] (omap_hsmmc_probe+0x6bc/0xa7c)
     [<c0474290>] (omap_hsmmc_probe) from [<c03a7f84>] (platform_drv_probe+0x44/0xa4)
     [<c03a7f84>] (platform_drv_probe) from [<c03a6568>] (driver_probe_device+0x170/0x2b4)
     [<c03a6568>] (driver_probe_device) from [<c03a4b40>] (bus_for_each_drv+0x64/0x98)
     [<c03a4b40>] (bus_for_each_drv) from [<c03a63c4>] (device_attach+0x70/0x88)
     [<c03a63c4>] (device_attach) from [<c03a5aa8>] (bus_probe_device+0x84/0xac)
     [<c03a5aa8>] (bus_probe_device) from [<c03a5ec0>] (deferred_probe_work_func+0x58/0x88)
     [<c03a5ec0>] (deferred_probe_work_func) from [<c004e5bc>] (process_one_work+0x134/0x464)
     [<c004e5bc>] (process_one_work) from [<c004e928>] (worker_thread+0x3c/0x4fc)
     [<c004e928>] (worker_thread) from [<c0053450>] (kthread+0xcc/0xe4)
     [<c0053450>] (kthread) from [<c000f668>] (ret_from_fork+0x14/0x2c)
     Code: e594302c e593202c e584205c e594302c (e5932128)
     ---[ end trace 0000000000000002 ]---
    
    The issue happens because omap_device_late_init() do not take into
    account that some drivers are present, but their probes were not
    finished successfully and where deferred instead. This is the valid
    case, and omap_device_late_init() should not idle such devices.
    
    To fix this issue, the value of omap_device->_driver_status field
    should be checked not only for BUS_NOTIFY_BOUND_DRIVER (driver is
    present and has been bound to device successfully), but also checked
    for BUS_NOTIFY_BIND_DRIVER (driver about to be bound) - which means
    driver is present and there was try to bind it to device.
    
    [1] http://www.spinics.net/lists/arm-kernel/msg441880.html
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 4cb8fd9f741f..72ebc4c16bae 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -901,7 +901,8 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 		if (od->hwmods[i]->flags & HWMOD_INIT_NO_IDLE)
 			return 0;
 
-	if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER) {
+	if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER &&
+	    od->_driver_status != BUS_NOTIFY_BIND_DRIVER) {
 		if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
 			dev_warn(dev, "%s: enabled but no driver.  Idling\n",
 				 __func__);

commit 4aa705b18bf17c4ff33ff7bbcd3f0c596443fa81
Merge: c11d71621891 2879e43f0912
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 11:34:35 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform support updates from Kevin Hilman:
     "Our SoC branch usually contains expanded support for new SoCs and
      other core platform code.  Some highlights from this round:
    
       - sunxi: SMP support for A23 SoC
       - socpga: big-endian support
       - pxa: conversion to common clock framework
       - bcm: SMP support for BCM63138
       - imx: support new I.MX7D SoC
       - zte: basic support for ZX296702 SoC"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (134 commits)
      ARM: zx: Add basic defconfig support for ZX296702
      ARM: dts: zx: add an initial zx296702 dts and doc
      clk: zx: add clock support to zx296702
      dt-bindings: Add #defines for ZTE ZX296702 clocks
      ARM: socfpga: fix build error due to secondary_startup
      MAINTAINERS: ARM64: EXYNOS: Extend entry for ARM64 DTS
      ARM: ep93xx: simone: support for SPI-based MMC/SD cards
      MAINTAINERS: update Shawn's email to use kernel.org one
      ARM: socfpga: support suspend to ram
      ARM: socfpga: add CPU_METHOD_OF_DECLARE for Arria 10
      ARM: socfpga: use CPU_METHOD_OF_DECLARE for socfpga_cyclone5
      ARM: EXYNOS: register power domain driver from core_initcall
      ARM: EXYNOS: use PS_HOLD based poweroff for all supported SoCs
      ARM: SAMSUNG: Constify platform_device_id
      ARM: EXYNOS: Constify irq_domain_ops
      ARM: EXYNOS: add coupled cpuidle support for Exynos3250
      ARM: EXYNOS: add exynos_get_boot_addr() helper
      ARM: EXYNOS: add exynos_set_boot_addr() helper
      ARM: EXYNOS: make exynos_core_restart() less verbose
      ARM: EXYNOS: fix exynos_boot_secondary() return value on timeout
      ...

commit 2ad7b44f5dd63a34c8853ce55f7d3d351b2cbd33
Merge: 43c9fad942b5 079ed3681d74
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 23 15:50:46 2015 -0700

    Merge branch 'for-linus-clk' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull clkdev updates from Russell King:
     "This series addresses some breakage in clkdev caused by a previous
      patch set from the clk tree which introduced per-user clk structures.
      This basically renamed the existing 'struct clk' to 'struct clk_hw',
      and introduced a new 'struct clk'.
    
      This change will break anyone using clk_add_alias() with the common
      clk code enabled.  Thankfully, the intersection of users of
      clk_add_alias() and those using the common clk code is practically
      zero, but this is something which should be fixed to keep the code
      sane.
    
      The problem is that clk_add_alias() does this:
    
            r = clk_get(...);
            l = clkdev_alloc(r, ...);
            clk_put(...);
    
      which causes the alias to store a pointer to 'r', which has been
      freed.
    
      The original patch set tried to work around this problem incorrectly -
      at clk_get() time, it tried to convert the struct clk to a struct
      clk_hw, and then creating a new struct clk from that.  Clearly, if the
      original struct clk has been freed, then we have a use-after-free bug.
    
      We have other places in the tree which do something similar, so this
      series also addresses those locations too.
    
      This series addresses this problem by converting clkdev to store and
      use the clk_hw pointer.  This allows clk_get() to only have to create
      it's per-user struct clk from the clk_hw.  We can also get to the
      desired clk_hw at clk_add_alias() or clk lookup creation time, when
      the struct clk is "alive".
    
      We also perform some cleanups of the code:
    
       - replacing looped calls to clkdev_add() with clkdev_add_table()
    
       - replacing open-coded lookup allocation (which should have been
         using clkdev_alloc()) and subsequent clkdev_add() with
         clkdev_create()
    
       - replacing open-coded clk_add_alias() with clk_add_alias()"
    
    * 'for-linus-clk' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      clk: s2mps11: use clkdev_create()
      ASoC: migor: use clkdev_create()
      ARM: omap2: use clkdev_add_alias()
      ARM: omap2: use clkdev_create()
      ARM: orion: use clkdev_create()
      ARM: lpc32xx: convert to use clkdev_add_table()
      SH: use clkdev_add_table()
      clkdev: add clkdev_create() helper
      clkdev: const-ify connection id to clk_add_alias()
      clkdev: get rid of redundant clk_add_alias() prototype in linux/clk.h
      clkdev: drop __init from clkdev_add_table()
      clk: update clk API documentation to clarify clk_round_rate()
      clkdev: use clk_hw internally

commit 6da233589f26ebd891d507a5a134ab43267006f2
Author: Pali Rohár <pali.rohar@gmail.com>
Date:   Thu Feb 26 14:49:51 2015 +0100

    ARM: OMAP2+: Return correct error values from device and hwmod
    
    Without this patch function pm_runtime_get_sync() returns 0 even when
    some omap subfunction fails. This patch properly propagate error codes
    from omap functions back to caller.
    
    This patch fix problem, when loading omap-aes driver in qemu cause
    kernel oops.
    
    Signed-off-by: Pali Rohár <pali.rohar@gmail.com>
    [paul@pwsan.com: fix a checkpatch warning]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 166b18f515a2..4a7303cf563e 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -224,13 +224,13 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
  */
 static int _omap_device_enable_hwmods(struct omap_device *od)
 {
+	int ret = 0;
 	int i;
 
 	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_enable(od->hwmods[i]);
+		ret |= omap_hwmod_enable(od->hwmods[i]);
 
-	/* XXX pass along return value here? */
-	return 0;
+	return ret;
 }
 
 /**
@@ -241,13 +241,13 @@ static int _omap_device_enable_hwmods(struct omap_device *od)
  */
 static int _omap_device_idle_hwmods(struct omap_device *od)
 {
+	int ret = 0;
 	int i;
 
 	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_idle(od->hwmods[i]);
+		ret |= omap_hwmod_idle(od->hwmods[i]);
 
-	/* XXX pass along return value here? */
-	return 0;
+	return ret;
 }
 
 /* Public functions for use by core code */
@@ -595,18 +595,20 @@ static int _od_runtime_suspend(struct device *dev)
 	int ret;
 
 	ret = pm_generic_runtime_suspend(dev);
+	if (ret)
+		return ret;
 
-	if (!ret)
-		omap_device_idle(pdev);
-
-	return ret;
+	return omap_device_idle(pdev);
 }
 
 static int _od_runtime_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
 
-	omap_device_enable(pdev);
+	ret = omap_device_enable(pdev);
+	if (ret)
+		return ret;
 
 	return pm_generic_runtime_resume(dev);
 }
@@ -743,7 +745,8 @@ int omap_device_enable(struct platform_device *pdev)
 
 	ret = _omap_device_enable_hwmods(od);
 
-	od->_state = OMAP_DEVICE_STATE_ENABLED;
+	if (ret == 0)
+		od->_state = OMAP_DEVICE_STATE_ENABLED;
 
 	return ret;
 }
@@ -773,7 +776,8 @@ int omap_device_idle(struct platform_device *pdev)
 
 	ret = _omap_device_idle_hwmods(od);
 
-	od->_state = OMAP_DEVICE_STATE_IDLE;
+	if (ret == 0)
+		od->_state = OMAP_DEVICE_STATE_IDLE;
 
 	return ret;
 }

commit c381f22947ea9afa55311dfe672dd73b92f01e6e
Author: Grygorii Strashko <Grygorii.Strashko@linaro.org>
Date:   Mon Apr 27 21:24:32 2015 +0300

    ARM: omap-device: use SET_NOIRQ_SYSTEM_SLEEP_PM_OPS
    
    Use recently introduced macro SET_NOIRQ_SYSTEM_SLEEP_PM_OPS to
    set up PM callbacks. This also fixes missed assignment of
    .poweroff_noirq() callback.
    
    Signed-off-by: Grygorii Strashko <Grygorii.Strashko@linaro.org>
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 166b18f515a2..83a0f5ab85c2 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -688,11 +688,8 @@ struct dev_pm_domain omap_device_pm_domain = {
 		SET_RUNTIME_PM_OPS(_od_runtime_suspend, _od_runtime_resume,
 				   NULL)
 		USE_PLATFORM_PM_SLEEP_OPS
-		.suspend_noirq = _od_suspend_noirq,
-		.resume_noirq = _od_resume_noirq,
-		.freeze_noirq = _od_suspend_noirq,
-		.thaw_noirq = _od_resume_noirq,
-		.restore_noirq = _od_resume_noirq,
+		SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(_od_suspend_noirq,
+					      _od_resume_noirq)
 	}
 };
 

commit 1ca90bd408a160c95af1ca7ef29b20a789e31d19
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 2 15:46:03 2015 +0000

    ARM: omap2: use clkdev_add_alias()
    
    When creating aliases of existing clkdev clocks, use clkdev_add_alias()
    isntead of open coding the lookup and clk_lookup creation.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 166b18f515a2..02da3655d288 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -47,7 +47,7 @@ static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 		       const char *clk_name)
 {
 	struct clk *r;
-	struct clk_lookup *l;
+	int rc;
 
 	if (!clk_alias || !clk_name)
 		return;
@@ -62,21 +62,15 @@ static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 		return;
 	}
 
-	r = clk_get(NULL, clk_name);
-	if (IS_ERR(r)) {
-		dev_err(&od->pdev->dev,
-			"clk_get for %s failed\n", clk_name);
-		return;
+	rc = clk_add_alias(clk_alias, dev_name(&od->pdev->dev), clk_name, NULL);
+	if (rc) {
+		if (rc == -ENODEV || rc == -ENOMEM)
+			dev_err(&od->pdev->dev,
+				"clkdev_alloc for %s failed\n", clk_alias);
+		else
+			dev_err(&od->pdev->dev,
+				"clk_get for %s failed\n", clk_name);
 	}
-
-	l = clkdev_alloc(r, clk_alias, dev_name(&od->pdev->dev));
-	if (!l) {
-		dev_err(&od->pdev->dev,
-			"clkdev_alloc for %s failed\n", clk_alias);
-		return;
-	}
-
-	clkdev_add(l);
 }
 
 /**

commit 6248015d6867449b0a850dfe0810e9c5a8bffe41
Author: Grygorii Strashko <Grygorii.Strashko@linaro.org>
Date:   Wed Feb 25 16:13:50 2015 +0200

    ARM: omap-device: add missed callback for suspend-to-disk
    
    Add missed callback needed for supporting suspend-to-disk (hibernation) mode.
    
    Signed-off-by: Grygorii Strashko <Grygorii.Strashko@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index be9541e18650..166b18f515a2 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -690,6 +690,9 @@ struct dev_pm_domain omap_device_pm_domain = {
 		USE_PLATFORM_PM_SLEEP_OPS
 		.suspend_noirq = _od_suspend_noirq,
 		.resume_noirq = _od_resume_noirq,
+		.freeze_noirq = _od_suspend_noirq,
+		.thaw_noirq = _od_resume_noirq,
+		.restore_noirq = _od_resume_noirq,
 	}
 };
 

commit bf7c5449e6240c510df5fafcffd8b7bfd9f8e831
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 13 00:42:49 2014 +0100

    ARM / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so #ifdef blocks
    depending on CONFIG_PM_RUNTIME may now be changed to depend on
    CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM everywhere in the code under
    arch/arm/ (the defconfig files will be modified later).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 8c58b71c2727..be9541e18650 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -588,7 +588,7 @@ struct platform_device __init *omap_device_build_ss(const char *pdev_name,
 	return ERR_PTR(ret);
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int _od_runtime_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);

commit 4b91f7f3c8b20e073b7bfc098625b37f99789508
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 27 13:05:54 2014 -0700

    ARM: OMAP2+: Warn about deprecated legacy booting mode
    
    We're moving omaps to use device tree based booting and already have
    omap2, omap4, omap5, am335x and am437x booting in device tree only
    mode.
    
    Only omap3 still has legacy booting still around and we really want
    to make that device tree only. So let's add a warning about deprecated
    legacy booting so we get people to upgrade their boards to use device
    tree based booting and find out about any remaining issues.
    
    Note that for most boards we already have the .dts file and those can
    be booted with without changing the bootloader using the appended
    DTB mode.
    
    Acked-By: Sebastian Reichel <sre@kernel.org>
    Reviewed-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Reviewed-by: Javier Martinez Canillas <javier@dowhile0.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index d22c30d3ccfa..8c58b71c2727 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -917,6 +917,10 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 static int __init omap_device_late_init(void)
 {
 	bus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);
+
+	WARN(!of_have_populated_dt(),
+		"legacy booting deprecated, please update to boot with .dts\n");
+
 	return 0;
 }
 omap_late_initcall_sync(omap_device_late_init);

commit 9a02ae4ed4ee139053d554ca1ab7d0e16609a0f5
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Mon Aug 25 16:15:34 2014 -0700

    ARM: OMAP2+: omap_device: remove warning that clk alias already exists
    
    When an alias for a clock already exists the warning is printed. For
    every module with a main_clk defined, a clk alias for fck is added.
    There are some components that have the same main_clk defined, so this
    is a really normal situation.
    
    For example the am33xx edma device has 4 components using the same main
    clock. So there are three warnings in the boot log for this already
    existing clock alias:
            platform 49000000.edma: alias fck already exists
            platform 49000000.edma: alias fck already exists
            platform 49000000.edma: alias fck already exists
    
    As this is only interesting for developers, this patch changes the
    message to a debug message.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 01ef59def44b..d22c30d3ccfa 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -56,7 +56,7 @@ static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 
 	r = clk_get_sys(dev_name(&od->pdev->dev), clk_alias);
 	if (!IS_ERR(r)) {
-		dev_warn(&od->pdev->dev,
+		dev_dbg(&od->pdev->dev,
 			 "alias %s already exists\n", clk_alias);
 		clk_put(r);
 		return;

commit fe5a365cdb9cc925d5ce86a5bb4509dca57f3894
Merge: 4d77ce6c1fca 413541dd66d5
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Dec 28 21:37:03 2013 -0800

    Merge tag 'v3.13-rc5' into next/boards
    
    Need a newer base version to get a regulator fix for Samsung platforms that
    they enable building in a defconfig.
    
    Linux 3.13-rc5

commit f5c33b070de3fdb8ad995b767ad0e3487cf0d242
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Dec 3 19:39:13 2013 -0600

    ARM: OMAP2+: omap_device: add fail hook for runtime_pm when bad data is detected
    
    Due to the cross dependencies between hwmod for automanaged device
    information for OMAP and dts node definitions, we can run into scenarios
    where the dts node is defined, however it's hwmod entry is yet to be
    added. In these cases:
    a) omap_device does not register a pm_domain (since it cannot find
       hwmod entry).
    b) driver does not know about (a), does a pm_runtime_get_sync which
       never fails
    c) It then tries to do some operation on the device (such as read the
      revision register (as part of probe) without clock or adequate OMAP
      generic PM operation performed for enabling the module.
    
    This causes a crash such as that reported in:
    https://bugzilla.kernel.org/show_bug.cgi?id=66441
    
    When 'ti,hwmod' is provided in dt node, it is expected that the device
    will not function without the OMAP's power automanagement. Hence, when
    we hit a fail condition (due to hwmod entries not present or other
    similar scenario), fail at pm_domain level due to lack of data, provide
    enough information for it to be fixed, however, it allows for the driver
    to take appropriate measures to prevent crash.
    
    Reported-by: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 53f0735817bb..e0a398cf28d8 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -183,6 +183,10 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 odbfd_exit1:
 	kfree(hwmods);
 odbfd_exit:
+	/* if data/we are at fault.. load up a fail handler */
+	if (ret)
+		pdev->dev.pm_domain = &omap_device_fail_pm_domain;
+
 	return ret;
 }
 
@@ -604,6 +608,19 @@ static int _od_runtime_resume(struct device *dev)
 
 	return pm_generic_runtime_resume(dev);
 }
+
+static int _od_fail_runtime_suspend(struct device *dev)
+{
+	dev_warn(dev, "%s: FIXME: missing hwmod/omap_dev info\n", __func__);
+	return -ENODEV;
+}
+
+static int _od_fail_runtime_resume(struct device *dev)
+{
+	dev_warn(dev, "%s: FIXME: missing hwmod/omap_dev info\n", __func__);
+	return -ENODEV;
+}
+
 #endif
 
 #ifdef CONFIG_SUSPEND
@@ -657,6 +674,13 @@ static int _od_resume_noirq(struct device *dev)
 #define _od_resume_noirq NULL
 #endif
 
+struct dev_pm_domain omap_device_fail_pm_domain = {
+	.ops = {
+		SET_RUNTIME_PM_OPS(_od_fail_runtime_suspend,
+				   _od_fail_runtime_resume, NULL)
+	}
+};
+
 struct dev_pm_domain omap_device_pm_domain = {
 	.ops = {
 		SET_RUNTIME_PM_OPS(_od_runtime_suspend, _od_runtime_resume,

commit dad12d11380882616872a8243a9c3f706fcedd31
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 6 10:52:58 2013 -0800

    ARM: OMAP2+: Add support for legacy auxdata for twl
    
    As we currently need to support a mix of legacy platform data and
    device tree intialized data, let's make sure things keep working
    for the TWL GPIOs.
    
    Mostly the issue is caused by the fact that DSS does not yet have
    device tree bindings, so we need to rely on the TWL GPIO callback
    for setting up things like LCD backlight for some boards.
    
    As of_platform_populate() for the TWL GPIO is called by twl-core
    after the I2C bus has been initialized, we cannot pass the auxdata
    table from the board init code to twl-core like we used to with
    just legacy platform data.
    
    So let's use the omap_device bus hook to patch in the platform
    data for TWL GPIO until we have sorted out the issues with the
    TWL GPIOs and device tree bindings.
    
    The other option was be to initialize twl core using legacy
    platform data, which seems like a step backwards as we're moving
    to device tree only initialization.  And we really don't want to
    add custom configuration functions to the TWL GPIO driver either
    for this.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 53f0735817bb..828f538b1c4e 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -36,6 +36,7 @@
 #include <linux/of.h>
 #include <linux/notifier.h>
 
+#include "common.h"
 #include "soc.h"
 #include "omap_device.h"
 #include "omap_hwmod.h"
@@ -200,6 +201,7 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdev->dev.of_node)
 			omap_device_build_from_dt(pdev);
+		omap_auxdata_legacy_init(dev);
 		/* fall through */
 	default:
 		od = to_omap_device(pdev);

commit 3522bf7bfa248b99eafa2f4872190699a808c7d9
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Nov 14 11:05:16 2013 -0600

    ARM: OMAP2+: omap_device: maintain sane runtime pm status around suspend/resume
    
    OMAP device hooks around suspend|resume_noirq ensures that hwmod
    devices are forced to idle using omap_device_idle/enable as part of
    the last stage of suspend activity.
    
    For a device such as i2c who uses autosuspend, it is possible to enter
    the suspend path with dev->power.runtime_status = RPM_ACTIVE.
    
    As part of the suspend flow, the generic runtime logic would increment
    it's dev->power.disable_depth to 1. This should prevent further
    pm_runtime_get_sync from succeeding once the runtime_status has been
    set to RPM_SUSPENDED.
    
    Now, as part of the suspend_noirq handler in omap_device, we force the
    following: if the device status is !suspended, we force the device
    to idle using omap_device_idle (clocks are cut etc..). This ensures
    that from a hardware perspective, the device is "suspended". However,
    runtime_status is left to be active.
    
    *if* an operation is attempted after this point to
    pm_runtime_get_sync, runtime framework depends on runtime_status to
    indicate accurately the device status, and since it sees it to be
    ACTIVE, it assumes the module is functional and returns a non-error
    value. As a result the user will see pm_runtime_get succeed, however a
    register access will crash due to the lack of clocks.
    
    To prevent this from happening, we should ensure that runtime_status
    exactly indicates the device status. As a result of this change
    any further calls to pm_runtime_get* would return -EACCES (since
    disable_depth is 1). On resume, we restore the clocks and runtime
    status exactly as we suspended with. These operations are not expected
    to fail as we update the states after the core runtime framework has
    suspended itself and restore before the core runtime framework has
    resumed.
    
    Cc: stable@vger.kernel.org # v3.4+
    Reported-by: J Keerthy <j-keerthy@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index b69dd9abb50a..53f0735817bb 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -621,6 +621,7 @@ static int _od_suspend_noirq(struct device *dev)
 
 	if (!ret && !pm_runtime_status_suspended(dev)) {
 		if (pm_generic_runtime_suspend(dev) == 0) {
+			pm_runtime_set_suspended(dev);
 			omap_device_idle(pdev);
 			od->flags |= OMAP_DEVICE_SUSPENDED;
 		}
@@ -634,10 +635,18 @@ static int _od_resume_noirq(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omap_device *od = to_omap_device(pdev);
 
-	if ((od->flags & OMAP_DEVICE_SUSPENDED) &&
-	    !pm_runtime_status_suspended(dev)) {
+	if (od->flags & OMAP_DEVICE_SUSPENDED) {
 		od->flags &= ~OMAP_DEVICE_SUSPENDED;
 		omap_device_enable(pdev);
+		/*
+		 * XXX: we run before core runtime pm has resumed itself. At
+		 * this point in time, we just restore the runtime pm state and
+		 * considering symmetric operations in resume, we donot expect
+		 * to fail. If we failed, something changed in core runtime_pm
+		 * framework OR some device driver messed things up, hence, WARN
+		 */
+		WARN(pm_runtime_set_active(dev),
+		     "Could not set %s runtime state active\n", dev_name(dev));
 		pm_generic_runtime_resume(dev);
 	}
 

commit 4cf9cf8967f0316722c6cb4ebf8093b74a8e1dd6
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Wed Sep 18 12:01:58 2013 -0700

    ARM: OMAP: fix return value check in omap_device_build_from_dt()
    
    In case of error, the function omap_device_alloc() returns ERR_PTR()
    and never returns NULL. The NULL test in the return value check
    should be replaced with IS_ERR().
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index f99f68e1e85b..b69dd9abb50a 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -158,7 +158,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	}
 
 	od = omap_device_alloc(pdev, hwmods, oh_cnt);
-	if (!od) {
+	if (IS_ERR(od)) {
 		dev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",
 			oh_name);
 		ret = PTR_ERR(od);

commit 7268032dfb1180fca6e91a738380b7ac53684247
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sun Jul 28 23:01:51 2013 -0600

    ARM: OMAP2+: Sync hwmod state with the pm_runtime and omap_device state
    
    Some hwmods which are marked with HWMOD_INIT_NO_IDLE are left in enabled
    state post setup(). When a omap_device gets created for such hwmods
    make sure the omap_device and pm_runtime states are also in sync for such
    hwmods by doing a omap_device_enable() and pm_runtime_set_active() for the
    device.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Mark Jackson <mpfj-list@newflow.co.uk>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 1c82cdedd358..f99f68e1e85b 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -129,6 +129,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	const char *oh_name;
 	int oh_cnt, i, ret = 0;
+	bool device_active = false;
 
 	oh_cnt = of_property_count_strings(node, "ti,hwmods");
 	if (oh_cnt <= 0) {
@@ -152,6 +153,8 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 			goto odbfd_exit1;
 		}
 		hwmods[i] = oh;
+		if (oh->flags & HWMOD_INIT_NO_IDLE)
+			device_active = true;
 	}
 
 	od = omap_device_alloc(pdev, hwmods, oh_cnt);
@@ -172,6 +175,11 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 
 	pdev->dev.pm_domain = &omap_device_pm_domain;
 
+	if (device_active) {
+		omap_device_enable(pdev);
+		pm_runtime_set_active(&pdev->dev);
+	}
+
 odbfd_exit1:
 	kfree(hwmods);
 odbfd_exit:

commit f66e329d889fce165074f677509d449fc92ff7b9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sun Jul 28 23:01:50 2013 -0600

    ARM: OMAP2+: Avoid idling memory controllers with no drivers
    
    Memory controllers in OMAP (like GPMC and EMIF) have the hwmods marked with
    HWMOD_INIT_NO_IDLE and are left in enabled state post initial setup.
    
    Even if they have drivers missing, avoid idling them as part of
    omap_device_late_idle()
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Mark Jackson <mpfj-list@newflow.co.uk>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 5cc92874be7e..1c82cdedd358 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -842,6 +842,7 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omap_device *od = to_omap_device(pdev);
+	int i;
 
 	if (!od)
 		return 0;
@@ -850,6 +851,15 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 	 * If omap_device state is enabled, but has no driver bound,
 	 * idle it.
 	 */
+
+	/*
+	 * Some devices (like memory controllers) are always kept
+	 * enabled, and should not be idled even with no drivers.
+	 */
+	for (i = 0; i < od->hwmods_cnt; i++)
+		if (od->hwmods[i]->flags & HWMOD_INIT_NO_IDLE)
+			return 0;
+
 	if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER) {
 		if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
 			dev_warn(dev, "%s: enabled but no driver.  Idling\n",

commit f991fae5c6d42dfc5029150b05a78cf3f6c18cc9
Merge: d4141531f63a 2c843bd92ec2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:35:40 2013 -0700

    Merge tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the total number of ACPI commits is slightly greater than
      the number of cpufreq commits, but Viresh Kumar (who works on cpufreq)
      remains the most active patch submitter.
    
      To me, the most significant change is the addition of offline/online
      device operations to the driver core (with the Greg's blessing) and
      the related modifications of the ACPI core hotplug code.  Next are the
      freezer updates from Colin Cross that should make the freezing of
      tasks a bit less heavy weight.
    
      We also have a couple of regression fixes, a number of fixes for
      issues that have not been identified as regressions, two new drivers
      and a bunch of cleanups all over.
    
      Highlights:
    
       - Hotplug changes to support graceful hot-removal failures.
    
         It sometimes is necessary to fail device hot-removal operations
         gracefully if they cannot be carried out completely.  For example,
         if memory from a memory module being hot-removed has been allocated
         for the kernel's own use and cannot be moved elsewhere, it's
         desirable to fail the hot-removal operation in a graceful way
         rather than to crash the kernel, but currenty a success or a kernel
         crash are the only possible outcomes of an attempted memory
         hot-removal.  Needless to say, that is not a very attractive
         alternative and it had to be addressed.
    
         However, in order to make it work for memory, I first had to make
         it work for CPUs and for this purpose I needed to modify the ACPI
         processor driver.  It's been split into two parts, a resident one
         handling the low-level initialization/cleanup and a modular one
         playing the actual driver's role (but it binds to the CPU system
         device objects rather than to the ACPI device objects representing
         processors).  That's been sort of like a live brain surgery on a
         patient who's riding a bike.
    
         So this is a little scary, but since we found and fixed a couple of
         regressions it caused to happen during the early linux-next testing
         (a month ago), nobody has complained.
    
         As a bonus we remove some duplicated ACPI hotplug code, because the
         ACPI-based CPU hotplug is now going to use the common ACPI hotplug
         code.
    
       - Lighter weight freezing of tasks.
    
         These changes from Colin Cross and Mandeep Singh Baines are
         targeted at making the freezing of tasks a bit less heavy weight
         operation.  They reduce the number of tasks woken up every time
         during the freezing, by using the observation that the freezer
         simply doesn't need to wake up some of them and wait for them all
         to call refrigerator().  The time needed for the freezer to decide
         to report a failure is reduced too.
    
         Also reintroduced is the check causing a lockdep warining to
         trigger when try_to_freeze() is called with locks held (which is
         generally unsafe and shouldn't happen).
    
       - cpufreq updates
    
         First off, a commit from Srivatsa S Bhat fixes a resume regression
         introduced during the 3.10 cycle causing some cpufreq sysfs
         attributes to return wrong values to user space after resume.  The
         fix is kind of fresh, but also it's pretty obvious once Srivatsa
         has identified the root cause.
    
         Second, we have a new freqdomain_cpus sysfs attribute for the
         acpi-cpufreq driver to provide information previously available via
         related_cpus.  From Lan Tianyu.
    
         Finally, we fix a number of issues, mostly related to the
         CPUFREQ_POSTCHANGE notifier and cpufreq Kconfig options and clean
         up some code.  The majority of changes from Viresh Kumar with bits
         from Jacob Shin, Heiko Stübner, Xiaoguang Chen, Ezequiel Garcia,
         Arnd Bergmann, and Tang Yuantian.
    
       - ACPICA update
    
         A usual bunch of updates from the ACPICA upstream.
    
         During the 3.4 cycle we introduced support for ACPI 5 extended
         sleep registers, but they are only supposed to be used if the
         HW-reduced mode bit is set in the FADT flags and the code attempted
         to use them without checking that bit.  That caused suspend/resume
         regressions to happen on some systems.  Fix from Lv Zheng causes
         those registers to be used only if the HW-reduced mode bit is set.
    
         Apart from this some other ACPICA bugs are fixed and code cleanups
         are made by Bob Moore, Tomasz Nowicki, Lv Zheng, Chao Guan, and
         Zhang Rui.
    
       - cpuidle updates
    
         New driver for Xilinx Zynq processors is added by Michal Simek.
    
         Multidriver support simplification, addition of some missing
         kerneldoc comments and Kconfig-related fixes come from Daniel
         Lezcano.
    
       - ACPI power management updates
    
         Changes to make suspend/resume work correctly in Xen guests from
         Konrad Rzeszutek Wilk, sparse warning fix from Fengguang Wu and
         cleanups and fixes of the ACPI device power state selection
         routine.
    
       - ACPI documentation updates
    
         Some previously missing pieces of ACPI documentation are added by
         Lv Zheng and Aaron Lu (hopefully, that will help people to
         uderstand how the ACPI subsystem works) and one outdated doc is
         updated by Hanjun Guo.
    
       - Assorted ACPI updates
    
         We finally nailed down the IA-64 issue that was the reason for
         reverting commit 9f29ab11ddbf ("ACPI / scan: do not match drivers
         against objects having scan handlers"), so we can fix it and move
         the ACPI scan handler check added to the ACPI video driver back to
         the core.
    
         A mechanism for adding CMOS RTC address space handlers is
         introduced by Lan Tianyu to allow some EC-related breakage to be
         fixed on some systems.
    
         A spec-compliant implementation of acpi_os_get_timer() is added by
         Mika Westerberg.
    
         The evaluation of _STA is added to do_acpi_find_child() to avoid
         situations in which a pointer to a disabled device object is
         returned instead of an enabled one with the same _ADR value.  From
         Jeff Wu.
    
         Intel BayTrail PCH (Platform Controller Hub) support is added to
         the ACPI driver for Intel Low-Power Subsystems (LPSS) and that
         driver is modified to work around a couple of known BIOS issues.
         Changes from Mika Westerberg and Heikki Krogerus.
    
         The EC driver is fixed by Vasiliy Kulikov to use get_user() and
         put_user() instead of dereferencing user space pointers blindly.
    
         Code cleanups are made by Bjorn Helgaas, Nicholas Mazzuca and Toshi
         Kani.
    
       - Assorted power management updates
    
         The "runtime idle" helper routine is changed to take the return
         values of the callbacks executed by it into account and to call
         rpm_suspend() if they return 0, which allows us to reduce the
         overall code bloat a bit (by dropping some code that's not
         necessary any more after that modification).
    
         The runtime PM documentation is updated by Alan Stern (to reflect
         the "runtime idle" behavior change).
    
         New trace points for PM QoS are added by Sahara
         (<keun-o.park@windriver.com>).
    
         PM QoS documentation is updated by Lan Tianyu.
    
         Code cleanups are made and minor issues are addressed by Bernie
         Thompson, Bjorn Helgaas, Julius Werner, and Shuah Khan.
    
       - devfreq updates
    
         New driver for the Exynos5-bus device from Abhilash Kesavan.
    
         Minor cleanups, fixes and MAINTAINERS update from MyungJoo Ham,
         Abhilash Kesavan, Paul Bolle, Rajagopal Venkat, and Wei Yongjun.
    
       - OMAP power management updates
    
         Adaptive Voltage Scaling (AVS) SmartReflex voltage control driver
         updates from Andrii Tseglytskyi and Nishanth Menon."
    
    * tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      cpufreq: Fix cpufreq regression after suspend/resume
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
      PM / Sleep: Warn about system time after resume with pm_trace
      cpufreq: don't leave stale policy pointer in cdbs->cur_policy
      acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
      cpufreq: make sure frequency transitions are serialized
      ACPI: implement acpi_os_get_timer() according the spec
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI / processor: Drop unused variable from processor_perflib.c
      cpufreq: tegra: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: s3c64xx: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: omap: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: imx6q: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: exynos: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: dbx500: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: davinci: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: arm-big-little: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: powernow-k8: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: pcc: call CPUFREQ_POSTCHANGE notfier in error cases
      ...

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e6d230700b2b..e37feb2f05a3 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -591,11 +591,6 @@ static int _od_runtime_suspend(struct device *dev)
 	return ret;
 }
 
-static int _od_runtime_idle(struct device *dev)
-{
-	return pm_generic_runtime_idle(dev);
-}
-
 static int _od_runtime_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -653,7 +648,7 @@ static int _od_resume_noirq(struct device *dev)
 struct dev_pm_domain omap_device_pm_domain = {
 	.ops = {
 		SET_RUNTIME_PM_OPS(_od_runtime_suspend, _od_runtime_resume,
-				   _od_runtime_idle)
+				   NULL)
 		USE_PLATFORM_PM_SLEEP_OPS
 		.suspend_noirq = _od_suspend_noirq,
 		.resume_noirq = _od_resume_noirq,

commit 4b7ec5accecdb136c7afaf8739a06d5335cc05aa
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Sat Apr 27 01:55:34 2013 +0530

    arm: omap2+: omap_device: remove no_idle_on_suspend
    
    Remove "no_idle_on_suspend" check, since respective
    driver should be able to prevent idling of an
    omap device whenever required.
    
    Driver's can get same behavior by just returning -EBUSY
    from their ->runtime_suspend only during suspend.
    
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Rajendra nayak <rnayak@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e6d230700b2b..68be532f8688 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -170,9 +170,6 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 			r->name = dev_name(&pdev->dev);
 	}
 
-	if (of_get_property(node, "ti,no_idle_on_suspend", NULL))
-		omap_device_disable_idle_on_suspend(pdev);
-
 	pdev->dev.pm_domain = &omap_device_pm_domain;
 
 odbfd_exit1:
@@ -621,8 +618,7 @@ static int _od_suspend_noirq(struct device *dev)
 
 	if (!ret && !pm_runtime_status_suspended(dev)) {
 		if (pm_generic_runtime_suspend(dev) == 0) {
-			if (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))
-				omap_device_idle(pdev);
+			omap_device_idle(pdev);
 			od->flags |= OMAP_DEVICE_SUSPENDED;
 		}
 	}
@@ -638,8 +634,7 @@ static int _od_resume_noirq(struct device *dev)
 	if ((od->flags & OMAP_DEVICE_SUSPENDED) &&
 	    !pm_runtime_status_suspended(dev)) {
 		od->flags &= ~OMAP_DEVICE_SUSPENDED;
-		if (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))
-			omap_device_enable(pdev);
+		omap_device_enable(pdev);
 		pm_generic_runtime_resume(dev);
 	}
 

commit e7e17c538604928b98107a08c2c5dc54745d85fe
Author: Kevin Hilman <khilman@linaro.org>
Date:   Wed May 8 16:48:01 2013 -0700

    ARM: OMAP2+: omap_device: use late_initcall_sync
    
    If DEBUG_LL and earlyprintk are enabled, and omap-serial.c is compiled
    as a module, the kernel boot hangs early as the clocks for serial port
    are cut while earlyprintk still uses the port.
    
    The problem is a race between the late_initcall for omap_device (which
    idles devices that have no drivers) and the late_initcall in
    kernel/printk.c which turns off the earlyconsole.   Any printks
    that happen between this omap_device late initcall and the earlyconsole
    late initcall will crash when accessing the UART.
    
    The fix is to ensure the omap_device initcall happens after the
    earlyconsole initcall.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index eeea4fa28fbc..e6d230700b2b 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -876,4 +876,4 @@ static int __init omap_device_late_init(void)
 	bus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);
 	return 0;
 }
-omap_late_initcall(omap_device_late_init);
+omap_late_initcall_sync(omap_device_late_init);

commit 33b9f582c5c1db515412cc7efff28f7d1779321f
Merge: 946342d03ec4 008ca431822f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 2 21:31:29 2013 +0100

    Merge branch 'cleanup' into for-linus
    
    Conflicts:
            arch/arm/plat-omap/dmtimer.c

commit c48cd659892962f79bba4b4e0eedea8e5aa54c44
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 13 20:44:21 2013 +0000

    ARM: OMAP: use consistent error checking
    
    Consistently check errors using the usual method used in the kernel
    for much of its history.  For instance:
    
    int gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)
    {
            int div;
            div = gpmc_calc_divider(t->sync_clk);
            if (div < 0)
                    return div;
    static int gpmc_set_async_mode(int cs, struct gpmc_timings *t)
    {
    ...
            return gpmc_cs_set_timings(cs, t);
    
    .....
            ret = gpmc_set_async_mode(gpmc_onenand_data->cs, &t);
            if (IS_ERR_VALUE(ret))
                    return ret;
    
    So, gpmc_cs_set_timings() thinks any negative return value is an error,
    but where we check that in higher levels, only a limited range are
    errors...
    
    There is only _one_ use of IS_ERR_VALUE() in arch/arm which is really
    appropriate, and that is in arch/arm/include/asm/syscall.h:
    
    static inline long syscall_get_error(struct task_struct *task,
                                         struct pt_regs *regs)
    {
            unsigned long error = regs->ARM_r0;
            return IS_ERR_VALUE(error) ? error : 0;
    }
    
    because this function really does have to differentiate between error
    return values and addresses which look like negative numbers (eg, from
    mmap()).
    
    So, here's a patch to remove them from OMAP, except for the above.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 1bc16cdafdd6..01839a0b5024 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -333,7 +333,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 	int oh_cnt, i, ret = 0;
 
 	oh_cnt = of_property_count_strings(node, "ti,hwmods");
-	if (!oh_cnt || IS_ERR_VALUE(oh_cnt)) {
+	if (oh_cnt <= 0) {
 		dev_dbg(&pdev->dev, "No 'hwmods' to build omap_device\n");
 		return -ENODEV;
 	}

commit 857835c6d57aef101ac335a6da2149b54e7e0512
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Feb 24 10:56:59 2013 +0000

    ARM: cleanup: OMAP hwmod error checking
    
    omap_hwmod_lookup() only returns NULL on error, never an error pointer.
    Checking the returned pointer using IS_ERR_OR_NULL() is needless
    overhead.  Use a simple !ptr check instead.
    
    OMAP devices (oh->od) always have a valid platform device attached (see
    omap_device_alloc()) so there's no point validating the platform device
    pointer (we will have already oopsed long before if this is not the
    case here.)
    
    Lastly, oh->od is only ever NULL or a valid omap device pointer - 'oh'
    comes from the statically declared hwmod tables, and the pointer is
    only filled in by omap_device_alloc() at a point where the omap device
    pointer must be valid.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e065daa537c0..1bc16cdafdd6 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -1157,20 +1157,17 @@ struct device *omap_device_get_by_hwmod_name(const char *oh_name)
 	}
 
 	oh = omap_hwmod_lookup(oh_name);
-	if (IS_ERR_OR_NULL(oh)) {
+	if (!oh) {
 		WARN(1, "%s: no hwmod for %s\n", __func__,
 			oh_name);
-		return ERR_PTR(oh ? PTR_ERR(oh) : -ENODEV);
+		return ERR_PTR(-ENODEV);
 	}
-	if (IS_ERR_OR_NULL(oh->od)) {
+	if (!oh->od) {
 		WARN(1, "%s: no omap_device for %s\n", __func__,
 			oh_name);
-		return ERR_PTR(oh->od ? PTR_ERR(oh->od) : -ENODEV);
+		return ERR_PTR(-ENODEV);
 	}
 
-	if (IS_ERR_OR_NULL(oh->od->pdev))
-		return ERR_PTR(oh->od->pdev ? PTR_ERR(oh->od->pdev) : -ENODEV);
-
 	return &oh->od->pdev->dev;
 }
 EXPORT_SYMBOL(omap_device_get_by_hwmod_name);

commit bab588fcfb6335c767d811a8955979f5440328e0
Merge: 3298a3511f1e 9cb0d1babfcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 15:27:22 2013 -0800

    Merge tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC-specific updates from Arnd Bergmann:
     "This is a larger set of new functionality for the existing SoC
      families, including:
    
       - vt8500 gains support for new CPU cores, notably the Cortex-A9 based
         wm8850
    
       - prima2 gains support for the "marco" SoC family, its SMP based
         cousin
    
       - tegra gains support for the new Tegra4 (Tegra114) family
    
       - socfpga now supports a newer version of the hardware including SMP
    
       - i.mx31 and bcm2835 are now using DT probing for their clocks
    
       - lots of updates for sh-mobile
    
       - OMAP updates for clocks, power management and USB
    
       - i.mx6q and tegra now support cpuidle
    
       - kirkwood now supports PCIe hot plugging
    
       - tegra clock support is updated
    
       - tegra USB PHY probing gets implemented diffently"
    
    * tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (148 commits)
      ARM: prima2: remove duplicate v7_invalidate_l1
      ARM: shmobile: r8a7779: Correct TMU clock support again
      ARM: prima2: fix __init section for cpu hotplug
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 3/3)
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 1/3)
      arm: socfpga: Add SMP support for actual socfpga harware
      arm: Add v7_invalidate_l1 to cache-v7.S
      arm: socfpga: Add entries to enable make dtbs socfpga
      arm: socfpga: Add new device tree source for actual socfpga HW
      ARM: tegra: sort Kconfig selects for Tegra114
      ARM: tegra: enable ARCH_REQUIRE_GPIOLIB for Tegra114
      ARM: tegra: Fix build error w/ ARCH_TEGRA_114_SOC w/o ARCH_TEGRA_3x_SOC
      ARM: tegra: Fix build error for gic update
      ARM: tegra: remove empty tegra_smp_init_cpus()
      ARM: shmobile: Register ARM architected timer
      ARM: MARCO: fix the build issue due to gic-vic-to-irqchip move
      ARM: shmobile: r8a7779: Correct TMU clock support
      ARM: mxs_defconfig: Select CONFIG_DEVTMPFS_MOUNT
      ARM: mxs: decrease mxs_clockevent_device.min_delta_ns to 2 clock cycles
      ARM: mxs: use apbx bus clock to drive the timers on timrotv2
      ...

commit c1d1cd597fc77af3086470f8627d77f52f7f8b6c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:53 2013 -0700

    ARM: OMAP2+: omap_device: remove obsolete pm_lats and early_device code
    
    Remove now-obsolete code from arch/arm/mach-omap2/omap_device.c.  This
    mostly consists of removing the first attempt at device PM latency
    handling.  This was never really used, has been replaced by the common
    dev_pm_qos code, and needs to go away as part of the DT conversion.
    Also, the early platform_device creation code has been removed, as it
    appears to be unused.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e065daa537c0..6ee3ad3dd95a 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -17,68 +17,15 @@
  * to control power management and interconnect properties of their
  * devices.
  *
- * In the medium- to long-term, this code should either be
- * a) implemented via arch-specific pointers in platform_data
- * or
- * b) implemented as a proper omap_bus/omap_device in Linux, no more
- *    platform_data func pointers
+ * In the medium- to long-term, this code should be implemented as a
+ * proper omap_bus/omap_device in Linux, no more platform_data func
+ * pointers
  *
  *
- * Guidelines for usage by driver authors:
- *
- * 1. These functions are intended to be used by device drivers via
- * function pointers in struct platform_data.  As an example,
- * omap_device_enable() should be passed to the driver as
- *
- * struct foo_driver_platform_data {
- * ...
- *      int (*device_enable)(struct platform_device *pdev);
- * ...
- * }
- *
- * Note that the generic "device_enable" name is used, rather than
- * "omap_device_enable".  This is so other architectures can pass in their
- * own enable/disable functions here.
- *
- * This should be populated during device setup:
- *
- * ...
- * pdata->device_enable = omap_device_enable;
- * ...
- *
- * 2. Drivers should first check to ensure the function pointer is not null
- * before calling it, as in:
- *
- * if (pdata->device_enable)
- *     pdata->device_enable(pdev);
- *
- * This allows other architectures that don't use similar device_enable()/
- * device_shutdown() functions to execute normally.
- *
- * ...
- *
- * Suggested usage by device drivers:
- *
- * During device initialization:
- * device_enable()
- *
- * During device idle:
- * (save remaining device context if necessary)
- * device_idle();
- *
- * During device resume:
- * device_enable();
- * (restore context if necessary)
- *
- * During device shutdown:
- * device_shutdown()
- * (device must be reinitialized at this point to use it again)
- *
  */
 #undef DEBUG
 
 #include <linux/kernel.h>
-#include <linux/export.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/err.h>
@@ -92,155 +39,8 @@
 #include "omap_device.h"
 #include "omap_hwmod.h"
 
-/* These parameters are passed to _omap_device_{de,}activate() */
-#define USE_WAKEUP_LAT			0
-#define IGNORE_WAKEUP_LAT		1
-
-static int omap_early_device_register(struct platform_device *pdev);
-
-static struct omap_device_pm_latency omap_default_latency[] = {
-	{
-		.deactivate_func = omap_device_idle_hwmods,
-		.activate_func   = omap_device_enable_hwmods,
-		.flags = OMAP_DEVICE_LATENCY_AUTO_ADJUST,
-	}
-};
-
 /* Private functions */
 
-/**
- * _omap_device_activate - increase device readiness
- * @od: struct omap_device *
- * @ignore_lat: increase to latency target (0) or full readiness (1)?
- *
- * Increase readiness of omap_device @od (thus decreasing device
- * wakeup latency, but consuming more power).  If @ignore_lat is
- * IGNORE_WAKEUP_LAT, make the omap_device fully active.  Otherwise,
- * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
- * latency is greater than the requested maximum wakeup latency, step
- * backwards in the omap_device_pm_latency table to ensure the
- * device's maximum wakeup latency is less than or equal to the
- * requested maximum wakeup latency.  Returns 0.
- */
-static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
-{
-	struct timespec a, b, c;
-
-	dev_dbg(&od->pdev->dev, "omap_device: activating\n");
-
-	while (od->pm_lat_level > 0) {
-		struct omap_device_pm_latency *odpl;
-		unsigned long long act_lat = 0;
-
-		od->pm_lat_level--;
-
-		odpl = od->pm_lats + od->pm_lat_level;
-
-		if (!ignore_lat &&
-		    (od->dev_wakeup_lat <= od->_dev_wakeup_lat_limit))
-			break;
-
-		read_persistent_clock(&a);
-
-		/* XXX check return code */
-		odpl->activate_func(od);
-
-		read_persistent_clock(&b);
-
-		c = timespec_sub(b, a);
-		act_lat = timespec_to_ns(&c);
-
-		dev_dbg(&od->pdev->dev,
-			"omap_device: pm_lat %d: activate: elapsed time %llu nsec\n",
-			od->pm_lat_level, act_lat);
-
-		if (act_lat > odpl->activate_lat) {
-			odpl->activate_lat_worst = act_lat;
-			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
-				odpl->activate_lat = act_lat;
-				dev_dbg(&od->pdev->dev,
-					"new worst case activate latency %d: %llu\n",
-					od->pm_lat_level, act_lat);
-			} else
-				dev_warn(&od->pdev->dev,
-					 "activate latency %d higher than expected. (%llu > %d)\n",
-					 od->pm_lat_level, act_lat,
-					 odpl->activate_lat);
-		}
-
-		od->dev_wakeup_lat -= odpl->activate_lat;
-	}
-
-	return 0;
-}
-
-/**
- * _omap_device_deactivate - decrease device readiness
- * @od: struct omap_device *
- * @ignore_lat: decrease to latency target (0) or full inactivity (1)?
- *
- * Decrease readiness of omap_device @od (thus increasing device
- * wakeup latency, but conserving power).  If @ignore_lat is
- * IGNORE_WAKEUP_LAT, make the omap_device fully inactive.  Otherwise,
- * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
- * latency is less than the requested maximum wakeup latency, step
- * forwards in the omap_device_pm_latency table to ensure the device's
- * maximum wakeup latency is less than or equal to the requested
- * maximum wakeup latency.  Returns 0.
- */
-static int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)
-{
-	struct timespec a, b, c;
-
-	dev_dbg(&od->pdev->dev, "omap_device: deactivating\n");
-
-	while (od->pm_lat_level < od->pm_lats_cnt) {
-		struct omap_device_pm_latency *odpl;
-		unsigned long long deact_lat = 0;
-
-		odpl = od->pm_lats + od->pm_lat_level;
-
-		if (!ignore_lat &&
-		    ((od->dev_wakeup_lat + odpl->activate_lat) >
-		     od->_dev_wakeup_lat_limit))
-			break;
-
-		read_persistent_clock(&a);
-
-		/* XXX check return code */
-		odpl->deactivate_func(od);
-
-		read_persistent_clock(&b);
-
-		c = timespec_sub(b, a);
-		deact_lat = timespec_to_ns(&c);
-
-		dev_dbg(&od->pdev->dev,
-			"omap_device: pm_lat %d: deactivate: elapsed time %llu nsec\n",
-			od->pm_lat_level, deact_lat);
-
-		if (deact_lat > odpl->deactivate_lat) {
-			odpl->deactivate_lat_worst = deact_lat;
-			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
-				odpl->deactivate_lat = deact_lat;
-				dev_dbg(&od->pdev->dev,
-					"new worst case deactivate latency %d: %llu\n",
-					od->pm_lat_level, deact_lat);
-			} else
-				dev_warn(&od->pdev->dev,
-					 "deactivate latency %d higher than expected. (%llu > %d)\n",
-					 od->pm_lat_level, deact_lat,
-					 odpl->deactivate_lat);
-		}
-
-		od->dev_wakeup_lat += odpl->activate_lat;
-
-		od->pm_lat_level++;
-	}
-
-	return 0;
-}
-
 static void _add_clkdev(struct omap_device *od, const char *clk_alias,
 		       const char *clk_name)
 {
@@ -315,9 +115,6 @@ static void _add_hwmod_clocks_clkdev(struct omap_device *od,
  * @oh: ptr to the single omap_hwmod that backs this omap_device
  * @pdata: platform_data ptr to associate with the platform_device
  * @pdata_len: amount of memory pointed to by @pdata
- * @pm_lats: pointer to a omap_device_pm_latency array for this device
- * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
- * @is_early_device: should the device be registered as an early device or not
  *
  * Function for building an omap_device already registered from device-tree
  *
@@ -356,7 +153,7 @@ static int omap_device_build_from_dt(struct platform_device *pdev)
 		hwmods[i] = oh;
 	}
 
-	od = omap_device_alloc(pdev, hwmods, oh_cnt, NULL, 0);
+	od = omap_device_alloc(pdev, hwmods, oh_cnt);
 	if (!od) {
 		dev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",
 			oh_name);
@@ -407,6 +204,39 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 	return NOTIFY_DONE;
 }
 
+/**
+ * _omap_device_enable_hwmods - call omap_hwmod_enable() on all hwmods
+ * @od: struct omap_device *od
+ *
+ * Enable all underlying hwmods.  Returns 0.
+ */
+static int _omap_device_enable_hwmods(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_enable(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
+
+/**
+ * _omap_device_idle_hwmods - call omap_hwmod_idle() on all hwmods
+ * @od: struct omap_device *od
+ *
+ * Idle all underlying hwmods.  Returns 0.
+ */
+static int _omap_device_idle_hwmods(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_idle(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
 
 /* Public functions for use by core code */
 
@@ -526,18 +356,14 @@ static int _od_fill_dma_resources(struct omap_device *od,
  * @oh: ptr to the single omap_hwmod that backs this omap_device
  * @pdata: platform_data ptr to associate with the platform_device
  * @pdata_len: amount of memory pointed to by @pdata
- * @pm_lats: pointer to a omap_device_pm_latency array for this device
- * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
  *
  * Convenience function for allocating an omap_device structure and filling
- * hwmods, resources and pm_latency attributes.
+ * hwmods, and resources.
  *
  * Returns an struct omap_device pointer or ERR_PTR() on error;
  */
 struct omap_device *omap_device_alloc(struct platform_device *pdev,
-					struct omap_hwmod **ohs, int oh_cnt,
-					struct omap_device_pm_latency *pm_lats,
-					int pm_lats_cnt)
+					struct omap_hwmod **ohs, int oh_cnt)
 {
 	int ret = -ENOMEM;
 	struct omap_device *od;
@@ -626,18 +452,6 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 		goto oda_exit3;
 
 have_everything:
-	if (!pm_lats) {
-		pm_lats = omap_default_latency;
-		pm_lats_cnt = ARRAY_SIZE(omap_default_latency);
-	}
-
-	od->pm_lats_cnt = pm_lats_cnt;
-	od->pm_lats = kmemdup(pm_lats,
-			sizeof(struct omap_device_pm_latency) * pm_lats_cnt,
-			GFP_KERNEL);
-	if (!od->pm_lats)
-		goto oda_exit3;
-
 	pdev->archdata.od = od;
 
 	for (i = 0; i < oh_cnt; i++) {
@@ -663,7 +477,6 @@ void omap_device_delete(struct omap_device *od)
 		return;
 
 	od->pdev->archdata.od = NULL;
-	kfree(od->pm_lats);
 	kfree(od->hwmods);
 	kfree(od);
 }
@@ -675,9 +488,6 @@ void omap_device_delete(struct omap_device *od)
  * @oh: ptr to the single omap_hwmod that backs this omap_device
  * @pdata: platform_data ptr to associate with the platform_device
  * @pdata_len: amount of memory pointed to by @pdata
- * @pm_lats: pointer to a omap_device_pm_latency array for this device
- * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
- * @is_early_device: should the device be registered as an early device or not
  *
  * Convenience function for building and registering a single
  * omap_device record, which in turn builds and registers a
@@ -685,11 +495,10 @@ void omap_device_delete(struct omap_device *od)
  * information.  Returns ERR_PTR(-EINVAL) if @oh is NULL; otherwise,
  * passes along the return value of omap_device_build_ss().
  */
-struct platform_device __init *omap_device_build(const char *pdev_name, int pdev_id,
-				      struct omap_hwmod *oh, void *pdata,
-				      int pdata_len,
-				      struct omap_device_pm_latency *pm_lats,
-				      int pm_lats_cnt, int is_early_device)
+struct platform_device __init *omap_device_build(const char *pdev_name,
+						 int pdev_id,
+						 struct omap_hwmod *oh,
+						 void *pdata, int pdata_len)
 {
 	struct omap_hwmod *ohs[] = { oh };
 
@@ -697,8 +506,7 @@ struct platform_device __init *omap_device_build(const char *pdev_name, int pdev
 		return ERR_PTR(-EINVAL);
 
 	return omap_device_build_ss(pdev_name, pdev_id, ohs, 1, pdata,
-				    pdata_len, pm_lats, pm_lats_cnt,
-				    is_early_device);
+				    pdata_len);
 }
 
 /**
@@ -708,9 +516,6 @@ struct platform_device __init *omap_device_build(const char *pdev_name, int pdev
  * @oh: ptr to the single omap_hwmod that backs this omap_device
  * @pdata: platform_data ptr to associate with the platform_device
  * @pdata_len: amount of memory pointed to by @pdata
- * @pm_lats: pointer to a omap_device_pm_latency array for this device
- * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
- * @is_early_device: should the device be registered as an early device or not
  *
  * Convenience function for building and registering an omap_device
  * subsystem record.  Subsystem records consist of multiple
@@ -718,11 +523,11 @@ struct platform_device __init *omap_device_build(const char *pdev_name, int pdev
  * platform_device record.  Returns an ERR_PTR() on error, or passes
  * along the return value of omap_device_register().
  */
-struct platform_device __init *omap_device_build_ss(const char *pdev_name, int pdev_id,
-					 struct omap_hwmod **ohs, int oh_cnt,
-					 void *pdata, int pdata_len,
-					 struct omap_device_pm_latency *pm_lats,
-					 int pm_lats_cnt, int is_early_device)
+struct platform_device __init *omap_device_build_ss(const char *pdev_name,
+						    int pdev_id,
+						    struct omap_hwmod **ohs,
+						    int oh_cnt, void *pdata,
+						    int pdata_len)
 {
 	int ret = -ENOMEM;
 	struct platform_device *pdev;
@@ -746,7 +551,7 @@ struct platform_device __init *omap_device_build_ss(const char *pdev_name, int p
 	else
 		dev_set_name(&pdev->dev, "%s", pdev->name);
 
-	od = omap_device_alloc(pdev, ohs, oh_cnt, pm_lats, pm_lats_cnt);
+	od = omap_device_alloc(pdev, ohs, oh_cnt);
 	if (IS_ERR(od))
 		goto odbs_exit1;
 
@@ -754,10 +559,7 @@ struct platform_device __init *omap_device_build_ss(const char *pdev_name, int p
 	if (ret)
 		goto odbs_exit2;
 
-	if (is_early_device)
-		ret = omap_early_device_register(pdev);
-	else
-		ret = omap_device_register(pdev);
+	ret = omap_device_register(pdev);
 	if (ret)
 		goto odbs_exit2;
 
@@ -774,24 +576,6 @@ struct platform_device __init *omap_device_build_ss(const char *pdev_name, int p
 	return ERR_PTR(ret);
 }
 
-/**
- * omap_early_device_register - register an omap_device as an early platform
- * device.
- * @od: struct omap_device * to register
- *
- * Register the omap_device structure.  This currently just calls
- * platform_early_add_device() on the underlying platform_device.
- * Returns 0 by default.
- */
-static int __init omap_early_device_register(struct platform_device *pdev)
-{
-	struct platform_device *devices[1];
-
-	devices[0] = pdev;
-	early_platform_add_devices(devices, 1);
-	return 0;
-}
-
 #ifdef CONFIG_PM_RUNTIME
 static int _od_runtime_suspend(struct device *dev)
 {
@@ -902,10 +686,9 @@ int omap_device_register(struct platform_device *pdev)
  * to be accessible and ready to operate.  This generally involves
  * enabling clocks, setting SYSCONFIG registers; and in the future may
  * involve remuxing pins.  Device drivers should call this function
- * (through platform_data function pointers) where they would normally
- * enable clocks, etc.  Returns -EINVAL if called when the omap_device
- * is already enabled, or passes along the return value of
- * _omap_device_activate().
+ * indirectly via pm_runtime_get*().  Returns -EINVAL if called when
+ * the omap_device is already enabled, or passes along the return
+ * value of _omap_device_enable_hwmods().
  */
 int omap_device_enable(struct platform_device *pdev)
 {
@@ -921,14 +704,8 @@ int omap_device_enable(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	/* Enable everything if we're enabling this device from scratch */
-	if (od->_state == OMAP_DEVICE_STATE_UNKNOWN)
-		od->pm_lat_level = od->pm_lats_cnt;
-
-	ret = _omap_device_activate(od, IGNORE_WAKEUP_LAT);
+	ret = _omap_device_enable_hwmods(od);
 
-	od->dev_wakeup_lat = 0;
-	od->_dev_wakeup_lat_limit = UINT_MAX;
 	od->_state = OMAP_DEVICE_STATE_ENABLED;
 
 	return ret;
@@ -938,14 +715,10 @@ int omap_device_enable(struct platform_device *pdev)
  * omap_device_idle - idle an omap_device
  * @od: struct omap_device * to idle
  *
- * Idle omap_device @od by calling as many .deactivate_func() entries
- * in the omap_device's pm_lats table as is possible without exceeding
- * the device's maximum wakeup latency limit, pm_lat_limit.  Device
- * drivers should call this function (through platform_data function
- * pointers) where they would normally disable clocks after operations
- * complete, etc..  Returns -EINVAL if the omap_device is not
+ * Idle omap_device @od.  Device drivers call this function indirectly
+ * via pm_runtime_put*().  Returns -EINVAL if the omap_device is not
  * currently enabled, or passes along the return value of
- * _omap_device_deactivate().
+ * _omap_device_idle_hwmods().
  */
 int omap_device_idle(struct platform_device *pdev)
 {
@@ -961,49 +734,13 @@ int omap_device_idle(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	ret = _omap_device_deactivate(od, USE_WAKEUP_LAT);
+	ret = _omap_device_idle_hwmods(od);
 
 	od->_state = OMAP_DEVICE_STATE_IDLE;
 
 	return ret;
 }
 
-/**
- * omap_device_shutdown - shut down an omap_device
- * @od: struct omap_device * to shut down
- *
- * Shut down omap_device @od by calling all .deactivate_func() entries
- * in the omap_device's pm_lats table and then shutting down all of
- * the underlying omap_hwmods.  Used when a device is being "removed"
- * or a device driver is being unloaded.  Returns -EINVAL if the
- * omap_device is not currently enabled or idle, or passes along the
- * return value of _omap_device_deactivate().
- */
-int omap_device_shutdown(struct platform_device *pdev)
-{
-	int ret, i;
-	struct omap_device *od;
-
-	od = to_omap_device(pdev);
-
-	if (od->_state != OMAP_DEVICE_STATE_ENABLED &&
-	    od->_state != OMAP_DEVICE_STATE_IDLE) {
-		dev_warn(&pdev->dev,
-			 "omap_device: %s() called from invalid state %d\n",
-			 __func__, od->_state);
-		return -EINVAL;
-	}
-
-	ret = _omap_device_deactivate(od, IGNORE_WAKEUP_LAT);
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_shutdown(od->hwmods[i]);
-
-	od->_state = OMAP_DEVICE_STATE_SHUTDOWN;
-
-	return ret;
-}
-
 /**
  * omap_device_assert_hardreset - set a device's hardreset line
  * @pdev: struct platform_device * to reset
@@ -1059,86 +796,6 @@ int omap_device_deassert_hardreset(struct platform_device *pdev,
 	return ret;
 }
 
-/**
- * omap_device_align_pm_lat - activate/deactivate device to match wakeup lat lim
- * @od: struct omap_device *
- *
- * When a device's maximum wakeup latency limit changes, call some of
- * the .activate_func or .deactivate_func function pointers in the
- * omap_device's pm_lats array to ensure that the device's maximum
- * wakeup latency is less than or equal to the new latency limit.
- * Intended to be called by OMAP PM code whenever a device's maximum
- * wakeup latency limit changes (e.g., via
- * omap_pm_set_dev_wakeup_lat()).  Returns 0 if nothing needs to be
- * done (e.g., if the omap_device is not currently idle, or if the
- * wakeup latency is already current with the new limit) or passes
- * along the return value of _omap_device_deactivate() or
- * _omap_device_activate().
- */
-int omap_device_align_pm_lat(struct platform_device *pdev,
-			     u32 new_wakeup_lat_limit)
-{
-	int ret = -EINVAL;
-	struct omap_device *od;
-
-	od = to_omap_device(pdev);
-
-	if (new_wakeup_lat_limit == od->dev_wakeup_lat)
-		return 0;
-
-	od->_dev_wakeup_lat_limit = new_wakeup_lat_limit;
-
-	if (od->_state != OMAP_DEVICE_STATE_IDLE)
-		return 0;
-	else if (new_wakeup_lat_limit > od->dev_wakeup_lat)
-		ret = _omap_device_deactivate(od, USE_WAKEUP_LAT);
-	else if (new_wakeup_lat_limit < od->dev_wakeup_lat)
-		ret = _omap_device_activate(od, USE_WAKEUP_LAT);
-
-	return ret;
-}
-
-/**
- * omap_device_get_pwrdm - return the powerdomain * associated with @od
- * @od: struct omap_device *
- *
- * Return the powerdomain associated with the first underlying
- * omap_hwmod for this omap_device.  Intended for use by core OMAP PM
- * code.  Returns NULL on error or a struct powerdomain * upon
- * success.
- */
-struct powerdomain *omap_device_get_pwrdm(struct omap_device *od)
-{
-	/*
-	 * XXX Assumes that all omap_hwmod powerdomains are identical.
-	 * This may not necessarily be true.  There should be a sanity
-	 * check in here to WARN() if any difference appears.
-	 */
-	if (!od->hwmods_cnt)
-		return NULL;
-
-	return omap_hwmod_get_pwrdm(od->hwmods[0]);
-}
-
-/**
- * omap_device_get_mpu_rt_va - return the MPU's virtual addr for the hwmod base
- * @od: struct omap_device *
- *
- * Return the MPU's virtual address for the base of the hwmod, from
- * the ioremap() that the hwmod code does.  Only valid if there is one
- * hwmod associated with this device.  Returns NULL if there are zero
- * or more than one hwmods associated with this omap_device;
- * otherwise, passes along the return value from
- * omap_hwmod_get_mpu_rt_va().
- */
-void __iomem *omap_device_get_rt_va(struct omap_device *od)
-{
-	if (od->hwmods_cnt != 1)
-		return NULL;
-
-	return omap_hwmod_get_mpu_rt_va(od->hwmods[0]);
-}
-
 /**
  * omap_device_get_by_hwmod_name() - convert a hwmod name to
  * device pointer.
@@ -1173,82 +830,6 @@ struct device *omap_device_get_by_hwmod_name(const char *oh_name)
 
 	return &oh->od->pdev->dev;
 }
-EXPORT_SYMBOL(omap_device_get_by_hwmod_name);
-
-/*
- * Public functions intended for use in omap_device_pm_latency
- * .activate_func and .deactivate_func function pointers
- */
-
-/**
- * omap_device_enable_hwmods - call omap_hwmod_enable() on all hwmods
- * @od: struct omap_device *od
- *
- * Enable all underlying hwmods.  Returns 0.
- */
-int omap_device_enable_hwmods(struct omap_device *od)
-{
-	int i;
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_enable(od->hwmods[i]);
-
-	/* XXX pass along return value here? */
-	return 0;
-}
-
-/**
- * omap_device_idle_hwmods - call omap_hwmod_idle() on all hwmods
- * @od: struct omap_device *od
- *
- * Idle all underlying hwmods.  Returns 0.
- */
-int omap_device_idle_hwmods(struct omap_device *od)
-{
-	int i;
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_idle(od->hwmods[i]);
-
-	/* XXX pass along return value here? */
-	return 0;
-}
-
-/**
- * omap_device_disable_clocks - disable all main and interface clocks
- * @od: struct omap_device *od
- *
- * Disable the main functional clock and interface clock for all of the
- * omap_hwmods associated with the omap_device.  Returns 0.
- */
-int omap_device_disable_clocks(struct omap_device *od)
-{
-	int i;
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_disable_clocks(od->hwmods[i]);
-
-	/* XXX pass along return value here? */
-	return 0;
-}
-
-/**
- * omap_device_enable_clocks - enable all main and interface clocks
- * @od: struct omap_device *od
- *
- * Enable the main functional clock and interface clock for all of the
- * omap_hwmods associated with the omap_device.  Returns 0.
- */
-int omap_device_enable_clocks(struct omap_device *od)
-{
-	int i;
-
-	for (i = 0; i < od->hwmods_cnt; i++)
-		omap_hwmod_enable_clocks(od->hwmods[i]);
-
-	/* XXX pass along return value here? */
-	return 0;
-}
 
 static struct notifier_block platform_nb = {
 	.notifier_call = _omap_device_notifier_call,

commit b76c8b19b082c3fc84725de0d3ba5ee1f571c0ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 11 11:24:18 2013 -0800

    ARM: OMAP2+: Use omap initcalls
    
    This way the initcalls don't run on other SoCs on multiplatform
    kernels. Otherwise we'll get something like this when booting
    on vexpress:
    
    omap_hwmod: _ensure_mpu_hwmod_is_setup: MPU initiator hwmod mpu not yet registered
    ...
    WARNING: at arch/arm/mach-omap2/pm.c:82 _init_omap_device+0x74/0x94()
    _init_omap_device: could not find omap_hwmod for mpu
    ...
    omap-dma-engine omap-dma-engine: OMAP DMA engine driver
    ...
    
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e065daa537c0..d109f06785da 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -89,6 +89,7 @@
 #include <linux/of.h>
 #include <linux/notifier.h>
 
+#include "soc.h"
 #include "omap_device.h"
 #include "omap_hwmod.h"
 
@@ -1259,7 +1260,7 @@ static int __init omap_device_init(void)
 	bus_register_notifier(&platform_bus_type, &platform_nb);
 	return 0;
 }
-core_initcall(omap_device_init);
+omap_core_initcall(omap_device_init);
 
 /**
  * omap_device_late_idle - idle devices without drivers
@@ -1297,4 +1298,4 @@ static int __init omap_device_late_init(void)
 	bus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);
 	return 0;
 }
-late_initcall(omap_device_late_init);
+omap_late_initcall(omap_device_late_init);

commit c567b0584c352e7f97ced003be46bed8581ddd5b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 21 16:15:18 2012 -0700

    ARM: OMAP2+: omap_device: Correct resource handling for DT boot
    
    When booting with DT the OF core can fill up the resources provided within
    the DT blob.
    The current way of handling the DT boot prevents us from removing hwmod data
    for platforms only suppose to boot with DT (OMAP5 for example) since we need
    to keep the whole hwmod database intact in order to have more resources in
    hwmod than in DT (to be able to append the DMA resource from hwmod).
    
    To fix this issue we just examine the OF provided resources:
    If we do not have resources we use hwmod to fill them.
    If we have resources we check if we already able to recive DMA resource, if
    no we only append the DMA resurce from hwmod to the OF provided ones.
    
    In this way we can start removing hwmod data for devices which have their
    resources correctly configured in DT without regressions.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Benoît Cousson <b-cousson@ti.com>
    [paul@pwsan.com: fixed checkpatch problem; updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 8917a0881206..e065daa537c0 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -559,55 +559,73 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 	od->hwmods = hwmods;
 	od->pdev = pdev;
 
-	/* Count all resources for the device */
-	res_count = omap_device_count_resources(od, IORESOURCE_IRQ |
-						    IORESOURCE_DMA |
-						    IORESOURCE_MEM);
 	/*
+	 * Non-DT Boot:
+	 *   Here, pdev->num_resources = 0, and we should get all the
+	 *   resources from hwmod.
+	 *
 	 * DT Boot:
 	 *   OF framework will construct the resource structure (currently
 	 *   does for MEM & IRQ resource) and we should respect/use these
 	 *   resources, killing hwmod dependency.
 	 *   If pdev->num_resources > 0, we assume that MEM & IRQ resources
 	 *   have been allocated by OF layer already (through DTB).
-	 *
-	 * Non-DT Boot:
-	 *   Here, pdev->num_resources = 0, and we should get all the
-	 *   resources from hwmod.
+	 *   As preparation for the future we examine the OF provided resources
+	 *   to see if we have DMA resources provided already. In this case
+	 *   there is no need to update the resources for the device, we use the
+	 *   OF provided ones.
 	 *
 	 * TODO: Once DMA resource is available from OF layer, we should
 	 *   kill filling any resources from hwmod.
 	 */
-	if (res_count > pdev->num_resources) {
-		/* Allocate resources memory to account for new resources */
-		res = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);
-		if (!res)
-			goto oda_exit3;
-
-		/*
-		 * If pdev->num_resources > 0, then assume that,
-		 * MEM and IRQ resources will only come from DT and only
-		 * fill DMA resource from hwmod layer.
-		 */
-		if (pdev->num_resources && pdev->resource) {
-			dev_dbg(&pdev->dev, "%s(): resources already allocated %d\n",
-				__func__, res_count);
-			memcpy(res, pdev->resource,
-			       sizeof(struct resource) * pdev->num_resources);
-			_od_fill_dma_resources(od, &res[pdev->num_resources]);
-		} else {
-			dev_dbg(&pdev->dev, "%s(): using resources from hwmod %d\n",
-				__func__, res_count);
-			omap_device_fill_resources(od, res);
+	if (!pdev->num_resources) {
+		/* Count all resources for the device */
+		res_count = omap_device_count_resources(od, IORESOURCE_IRQ |
+							    IORESOURCE_DMA |
+							    IORESOURCE_MEM);
+	} else {
+		/* Take a look if we already have DMA resource via DT */
+		for (i = 0; i < pdev->num_resources; i++) {
+			struct resource *r = &pdev->resource[i];
+
+			/* We have it, no need to touch the resources */
+			if (r->flags == IORESOURCE_DMA)
+				goto have_everything;
 		}
+		/* Count only DMA resources for the device */
+		res_count = omap_device_count_resources(od, IORESOURCE_DMA);
+		/* The device has no DMA resource, no need for update */
+		if (!res_count)
+			goto have_everything;
 
-		ret = platform_device_add_resources(pdev, res, res_count);
-		kfree(res);
+		res_count += pdev->num_resources;
+	}
 
-		if (ret)
-			goto oda_exit3;
+	/* Allocate resources memory to account for new resources */
+	res = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);
+	if (!res)
+		goto oda_exit3;
+
+	if (!pdev->num_resources) {
+		dev_dbg(&pdev->dev, "%s: using %d resources from hwmod\n",
+			__func__, res_count);
+		omap_device_fill_resources(od, res);
+	} else {
+		dev_dbg(&pdev->dev,
+			"%s: appending %d DMA resources from hwmod\n",
+			__func__, res_count - pdev->num_resources);
+		memcpy(res, pdev->resource,
+		       sizeof(struct resource) * pdev->num_resources);
+		_od_fill_dma_resources(od, &res[pdev->num_resources]);
 	}
 
+	ret = platform_device_add_resources(pdev, res, res_count);
+	kfree(res);
+
+	if (ret)
+		goto oda_exit3;
+
+have_everything:
 	if (!pm_lats) {
 		pm_lats = omap_default_latency;
 		pm_lats_cnt = ARRAY_SIZE(omap_default_latency);

commit dad4191d79bded6674529084bcf842c00e4d874a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 21 16:15:17 2012 -0700

    ARM: OMAP2+: hwmod: Add possibility to count hwmod resources based on type
    
    Add flags parameter for omap_hwmod_count_resources() so users can tell which
    type of resources they are interested when counting them in hwmod database.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Benoît Cousson <b-cousson@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 0ef934fec364..8917a0881206 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -441,19 +441,21 @@ int omap_device_get_context_loss_count(struct platform_device *pdev)
 /**
  * omap_device_count_resources - count number of struct resource entries needed
  * @od: struct omap_device *
+ * @flags: Type of resources to include when counting (IRQ/DMA/MEM)
  *
  * Count the number of struct resource entries needed for this
  * omap_device @od.  Used by omap_device_build_ss() to determine how
  * much memory to allocate before calling
  * omap_device_fill_resources().  Returns the count.
  */
-static int omap_device_count_resources(struct omap_device *od)
+static int omap_device_count_resources(struct omap_device *od,
+				       unsigned long flags)
 {
 	int c = 0;
 	int i;
 
 	for (i = 0; i < od->hwmods_cnt; i++)
-		c += omap_hwmod_count_resources(od->hwmods[i]);
+		c += omap_hwmod_count_resources(od->hwmods[i], flags);
 
 	pr_debug("omap_device: %s: counted %d total resources across %d hwmods\n",
 		 od->pdev->name, c, od->hwmods_cnt);
@@ -557,7 +559,10 @@ struct omap_device *omap_device_alloc(struct platform_device *pdev,
 	od->hwmods = hwmods;
 	od->pdev = pdev;
 
-	res_count = omap_device_count_resources(od);
+	/* Count all resources for the device */
+	res_count = omap_device_count_resources(od, IORESOURCE_IRQ |
+						    IORESOURCE_DMA |
+						    IORESOURCE_MEM);
 	/*
 	 * DT Boot:
 	 *   OF framework will construct the resource structure (currently

commit a135eaae524acba1509a3b19c97fae556e4da7cd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:34 2012 -0600

    ARM: OMAP: remove plat/clock.h
    
    Remove arch/arm/plat-omap/include/plat/clock.h by merging it into
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h.
    The goal here is to facilitate ARM single image kernels by removing
    includes via the "plat/" symlink.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fixed to remove duplicate clock.h includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 2e6d33730b25..0ef934fec364 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -91,7 +91,6 @@
 
 #include "omap_device.h"
 #include "omap_hwmod.h"
-#include <plat/clock.h>
 
 /* These parameters are passed to _omap_device_{de,}activate() */
 #define USE_WAKEUP_LAT			0

commit 2a296c8f89bc6aaf91b255c7d631fcbbfaf840ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:41:35 2012 -0700

    ARM: OMAP: Make plat/omap_hwmod.h local to mach-omap2
    
    Let's make omap_hwmod local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index e5fbcb53c7cc..2e6d33730b25 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -90,7 +90,7 @@
 #include <linux/notifier.h>
 
 #include "omap_device.h"
-#include <plat/omap_hwmod.h>
+#include "omap_hwmod.h"
 #include <plat/clock.h>
 
 /* These parameters are passed to _omap_device_{de,}activate() */

commit 25c7d49ed48b4843da7dea56a81ae7f620211ee0
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:25:48 2012 -0700

    ARM: OMAP: Make omap_device local to mach-omap2
    
    Let's make omap_device local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
new file mode 100644
index 000000000000..e5fbcb53c7cc
--- /dev/null
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -0,0 +1,1278 @@
+/*
+ * omap_device implementation
+ *
+ * Copyright (C) 2009-2010 Nokia Corporation
+ * Paul Walmsley, Kevin Hilman
+ *
+ * Developed in collaboration with (alphabetical order): Benoit
+ * Cousson, Thara Gopinath, Tony Lindgren, Rajendra Nayak, Vikram
+ * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard
+ * Woodruff
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This code provides a consistent interface for OMAP device drivers
+ * to control power management and interconnect properties of their
+ * devices.
+ *
+ * In the medium- to long-term, this code should either be
+ * a) implemented via arch-specific pointers in platform_data
+ * or
+ * b) implemented as a proper omap_bus/omap_device in Linux, no more
+ *    platform_data func pointers
+ *
+ *
+ * Guidelines for usage by driver authors:
+ *
+ * 1. These functions are intended to be used by device drivers via
+ * function pointers in struct platform_data.  As an example,
+ * omap_device_enable() should be passed to the driver as
+ *
+ * struct foo_driver_platform_data {
+ * ...
+ *      int (*device_enable)(struct platform_device *pdev);
+ * ...
+ * }
+ *
+ * Note that the generic "device_enable" name is used, rather than
+ * "omap_device_enable".  This is so other architectures can pass in their
+ * own enable/disable functions here.
+ *
+ * This should be populated during device setup:
+ *
+ * ...
+ * pdata->device_enable = omap_device_enable;
+ * ...
+ *
+ * 2. Drivers should first check to ensure the function pointer is not null
+ * before calling it, as in:
+ *
+ * if (pdata->device_enable)
+ *     pdata->device_enable(pdev);
+ *
+ * This allows other architectures that don't use similar device_enable()/
+ * device_shutdown() functions to execute normally.
+ *
+ * ...
+ *
+ * Suggested usage by device drivers:
+ *
+ * During device initialization:
+ * device_enable()
+ *
+ * During device idle:
+ * (save remaining device context if necessary)
+ * device_idle();
+ *
+ * During device resume:
+ * device_enable();
+ * (restore context if necessary)
+ *
+ * During device shutdown:
+ * device_shutdown()
+ * (device must be reinitialized at this point to use it again)
+ *
+ */
+#undef DEBUG
+
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/notifier.h>
+
+#include "omap_device.h"
+#include <plat/omap_hwmod.h>
+#include <plat/clock.h>
+
+/* These parameters are passed to _omap_device_{de,}activate() */
+#define USE_WAKEUP_LAT			0
+#define IGNORE_WAKEUP_LAT		1
+
+static int omap_early_device_register(struct platform_device *pdev);
+
+static struct omap_device_pm_latency omap_default_latency[] = {
+	{
+		.deactivate_func = omap_device_idle_hwmods,
+		.activate_func   = omap_device_enable_hwmods,
+		.flags = OMAP_DEVICE_LATENCY_AUTO_ADJUST,
+	}
+};
+
+/* Private functions */
+
+/**
+ * _omap_device_activate - increase device readiness
+ * @od: struct omap_device *
+ * @ignore_lat: increase to latency target (0) or full readiness (1)?
+ *
+ * Increase readiness of omap_device @od (thus decreasing device
+ * wakeup latency, but consuming more power).  If @ignore_lat is
+ * IGNORE_WAKEUP_LAT, make the omap_device fully active.  Otherwise,
+ * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
+ * latency is greater than the requested maximum wakeup latency, step
+ * backwards in the omap_device_pm_latency table to ensure the
+ * device's maximum wakeup latency is less than or equal to the
+ * requested maximum wakeup latency.  Returns 0.
+ */
+static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
+{
+	struct timespec a, b, c;
+
+	dev_dbg(&od->pdev->dev, "omap_device: activating\n");
+
+	while (od->pm_lat_level > 0) {
+		struct omap_device_pm_latency *odpl;
+		unsigned long long act_lat = 0;
+
+		od->pm_lat_level--;
+
+		odpl = od->pm_lats + od->pm_lat_level;
+
+		if (!ignore_lat &&
+		    (od->dev_wakeup_lat <= od->_dev_wakeup_lat_limit))
+			break;
+
+		read_persistent_clock(&a);
+
+		/* XXX check return code */
+		odpl->activate_func(od);
+
+		read_persistent_clock(&b);
+
+		c = timespec_sub(b, a);
+		act_lat = timespec_to_ns(&c);
+
+		dev_dbg(&od->pdev->dev,
+			"omap_device: pm_lat %d: activate: elapsed time %llu nsec\n",
+			od->pm_lat_level, act_lat);
+
+		if (act_lat > odpl->activate_lat) {
+			odpl->activate_lat_worst = act_lat;
+			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
+				odpl->activate_lat = act_lat;
+				dev_dbg(&od->pdev->dev,
+					"new worst case activate latency %d: %llu\n",
+					od->pm_lat_level, act_lat);
+			} else
+				dev_warn(&od->pdev->dev,
+					 "activate latency %d higher than expected. (%llu > %d)\n",
+					 od->pm_lat_level, act_lat,
+					 odpl->activate_lat);
+		}
+
+		od->dev_wakeup_lat -= odpl->activate_lat;
+	}
+
+	return 0;
+}
+
+/**
+ * _omap_device_deactivate - decrease device readiness
+ * @od: struct omap_device *
+ * @ignore_lat: decrease to latency target (0) or full inactivity (1)?
+ *
+ * Decrease readiness of omap_device @od (thus increasing device
+ * wakeup latency, but conserving power).  If @ignore_lat is
+ * IGNORE_WAKEUP_LAT, make the omap_device fully inactive.  Otherwise,
+ * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
+ * latency is less than the requested maximum wakeup latency, step
+ * forwards in the omap_device_pm_latency table to ensure the device's
+ * maximum wakeup latency is less than or equal to the requested
+ * maximum wakeup latency.  Returns 0.
+ */
+static int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)
+{
+	struct timespec a, b, c;
+
+	dev_dbg(&od->pdev->dev, "omap_device: deactivating\n");
+
+	while (od->pm_lat_level < od->pm_lats_cnt) {
+		struct omap_device_pm_latency *odpl;
+		unsigned long long deact_lat = 0;
+
+		odpl = od->pm_lats + od->pm_lat_level;
+
+		if (!ignore_lat &&
+		    ((od->dev_wakeup_lat + odpl->activate_lat) >
+		     od->_dev_wakeup_lat_limit))
+			break;
+
+		read_persistent_clock(&a);
+
+		/* XXX check return code */
+		odpl->deactivate_func(od);
+
+		read_persistent_clock(&b);
+
+		c = timespec_sub(b, a);
+		deact_lat = timespec_to_ns(&c);
+
+		dev_dbg(&od->pdev->dev,
+			"omap_device: pm_lat %d: deactivate: elapsed time %llu nsec\n",
+			od->pm_lat_level, deact_lat);
+
+		if (deact_lat > odpl->deactivate_lat) {
+			odpl->deactivate_lat_worst = deact_lat;
+			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
+				odpl->deactivate_lat = deact_lat;
+				dev_dbg(&od->pdev->dev,
+					"new worst case deactivate latency %d: %llu\n",
+					od->pm_lat_level, deact_lat);
+			} else
+				dev_warn(&od->pdev->dev,
+					 "deactivate latency %d higher than expected. (%llu > %d)\n",
+					 od->pm_lat_level, deact_lat,
+					 odpl->deactivate_lat);
+		}
+
+		od->dev_wakeup_lat += odpl->activate_lat;
+
+		od->pm_lat_level++;
+	}
+
+	return 0;
+}
+
+static void _add_clkdev(struct omap_device *od, const char *clk_alias,
+		       const char *clk_name)
+{
+	struct clk *r;
+	struct clk_lookup *l;
+
+	if (!clk_alias || !clk_name)
+		return;
+
+	dev_dbg(&od->pdev->dev, "Creating %s -> %s\n", clk_alias, clk_name);
+
+	r = clk_get_sys(dev_name(&od->pdev->dev), clk_alias);
+	if (!IS_ERR(r)) {
+		dev_warn(&od->pdev->dev,
+			 "alias %s already exists\n", clk_alias);
+		clk_put(r);
+		return;
+	}
+
+	r = clk_get(NULL, clk_name);
+	if (IS_ERR(r)) {
+		dev_err(&od->pdev->dev,
+			"clk_get for %s failed\n", clk_name);
+		return;
+	}
+
+	l = clkdev_alloc(r, clk_alias, dev_name(&od->pdev->dev));
+	if (!l) {
+		dev_err(&od->pdev->dev,
+			"clkdev_alloc for %s failed\n", clk_alias);
+		return;
+	}
+
+	clkdev_add(l);
+}
+
+/**
+ * _add_hwmod_clocks_clkdev - Add clkdev entry for hwmod optional clocks
+ * and main clock
+ * @od: struct omap_device *od
+ * @oh: struct omap_hwmod *oh
+ *
+ * For the main clock and every optional clock present per hwmod per
+ * omap_device, this function adds an entry in the clkdev table of the
+ * form <dev-id=dev_name, con-id=role> if it does not exist already.
+ *
+ * The function is called from inside omap_device_build_ss(), after
+ * omap_device_register.
+ *
+ * This allows drivers to get a pointer to its optional clocks based on its role
+ * by calling clk_get(<dev*>, <role>).
+ * In the case of the main clock, a "fck" alias is used.
+ *
+ * No return value.
+ */
+static void _add_hwmod_clocks_clkdev(struct omap_device *od,
+				     struct omap_hwmod *oh)
+{
+	int i;
+
+	_add_clkdev(od, "fck", oh->main_clk);
+
+	for (i = 0; i < oh->opt_clks_cnt; i++)
+		_add_clkdev(od, oh->opt_clks[i].role, oh->opt_clks[i].clk);
+}
+
+
+/**
+ * omap_device_build_from_dt - build an omap_device with multiple hwmods
+ * @pdev_name: name of the platform_device driver to use
+ * @pdev_id: this platform_device's connection ID
+ * @oh: ptr to the single omap_hwmod that backs this omap_device
+ * @pdata: platform_data ptr to associate with the platform_device
+ * @pdata_len: amount of memory pointed to by @pdata
+ * @pm_lats: pointer to a omap_device_pm_latency array for this device
+ * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
+ * @is_early_device: should the device be registered as an early device or not
+ *
+ * Function for building an omap_device already registered from device-tree
+ *
+ * Returns 0 or PTR_ERR() on error.
+ */
+static int omap_device_build_from_dt(struct platform_device *pdev)
+{
+	struct omap_hwmod **hwmods;
+	struct omap_device *od;
+	struct omap_hwmod *oh;
+	struct device_node *node = pdev->dev.of_node;
+	const char *oh_name;
+	int oh_cnt, i, ret = 0;
+
+	oh_cnt = of_property_count_strings(node, "ti,hwmods");
+	if (!oh_cnt || IS_ERR_VALUE(oh_cnt)) {
+		dev_dbg(&pdev->dev, "No 'hwmods' to build omap_device\n");
+		return -ENODEV;
+	}
+
+	hwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
+	if (!hwmods) {
+		ret = -ENOMEM;
+		goto odbfd_exit;
+	}
+
+	for (i = 0; i < oh_cnt; i++) {
+		of_property_read_string_index(node, "ti,hwmods", i, &oh_name);
+		oh = omap_hwmod_lookup(oh_name);
+		if (!oh) {
+			dev_err(&pdev->dev, "Cannot lookup hwmod '%s'\n",
+				oh_name);
+			ret = -EINVAL;
+			goto odbfd_exit1;
+		}
+		hwmods[i] = oh;
+	}
+
+	od = omap_device_alloc(pdev, hwmods, oh_cnt, NULL, 0);
+	if (!od) {
+		dev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",
+			oh_name);
+		ret = PTR_ERR(od);
+		goto odbfd_exit1;
+	}
+
+	/* Fix up missing resource names */
+	for (i = 0; i < pdev->num_resources; i++) {
+		struct resource *r = &pdev->resource[i];
+
+		if (r->name == NULL)
+			r->name = dev_name(&pdev->dev);
+	}
+
+	if (of_get_property(node, "ti,no_idle_on_suspend", NULL))
+		omap_device_disable_idle_on_suspend(pdev);
+
+	pdev->dev.pm_domain = &omap_device_pm_domain;
+
+odbfd_exit1:
+	kfree(hwmods);
+odbfd_exit:
+	return ret;
+}
+
+static int _omap_device_notifier_call(struct notifier_block *nb,
+				      unsigned long event, void *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct omap_device *od;
+
+	switch (event) {
+	case BUS_NOTIFY_DEL_DEVICE:
+		if (pdev->archdata.od)
+			omap_device_delete(pdev->archdata.od);
+		break;
+	case BUS_NOTIFY_ADD_DEVICE:
+		if (pdev->dev.of_node)
+			omap_device_build_from_dt(pdev);
+		/* fall through */
+	default:
+		od = to_omap_device(pdev);
+		if (od)
+			od->_driver_status = event;
+	}
+
+	return NOTIFY_DONE;
+}
+
+
+/* Public functions for use by core code */
+
+/**
+ * omap_device_get_context_loss_count - get lost context count
+ * @od: struct omap_device *
+ *
+ * Using the primary hwmod, query the context loss count for this
+ * device.
+ *
+ * Callers should consider context for this device lost any time this
+ * function returns a value different than the value the caller got
+ * the last time it called this function.
+ *
+ * If any hwmods exist for the omap_device assoiated with @pdev,
+ * return the context loss counter for that hwmod, otherwise return
+ * zero.
+ */
+int omap_device_get_context_loss_count(struct platform_device *pdev)
+{
+	struct omap_device *od;
+	u32 ret = 0;
+
+	od = to_omap_device(pdev);
+
+	if (od->hwmods_cnt)
+		ret = omap_hwmod_get_context_loss_count(od->hwmods[0]);
+
+	return ret;
+}
+
+/**
+ * omap_device_count_resources - count number of struct resource entries needed
+ * @od: struct omap_device *
+ *
+ * Count the number of struct resource entries needed for this
+ * omap_device @od.  Used by omap_device_build_ss() to determine how
+ * much memory to allocate before calling
+ * omap_device_fill_resources().  Returns the count.
+ */
+static int omap_device_count_resources(struct omap_device *od)
+{
+	int c = 0;
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		c += omap_hwmod_count_resources(od->hwmods[i]);
+
+	pr_debug("omap_device: %s: counted %d total resources across %d hwmods\n",
+		 od->pdev->name, c, od->hwmods_cnt);
+
+	return c;
+}
+
+/**
+ * omap_device_fill_resources - fill in array of struct resource
+ * @od: struct omap_device *
+ * @res: pointer to an array of struct resource to be filled in
+ *
+ * Populate one or more empty struct resource pointed to by @res with
+ * the resource data for this omap_device @od.  Used by
+ * omap_device_build_ss() after calling omap_device_count_resources().
+ * Ideally this function would not be needed at all.  If omap_device
+ * replaces platform_device, then we can specify our own
+ * get_resource()/ get_irq()/etc functions that use the underlying
+ * omap_hwmod information.  Or if platform_device is extended to use
+ * subarchitecture-specific function pointers, the various
+ * platform_device functions can simply call omap_device internal
+ * functions to get device resources.  Hacking around the existing
+ * platform_device code wastes memory.  Returns 0.
+ */
+static int omap_device_fill_resources(struct omap_device *od,
+				      struct resource *res)
+{
+	int i, r;
+
+	for (i = 0; i < od->hwmods_cnt; i++) {
+		r = omap_hwmod_fill_resources(od->hwmods[i], res);
+		res += r;
+	}
+
+	return 0;
+}
+
+/**
+ * _od_fill_dma_resources - fill in array of struct resource with dma resources
+ * @od: struct omap_device *
+ * @res: pointer to an array of struct resource to be filled in
+ *
+ * Populate one or more empty struct resource pointed to by @res with
+ * the dma resource data for this omap_device @od.  Used by
+ * omap_device_alloc() after calling omap_device_count_resources().
+ *
+ * Ideally this function would not be needed at all.  If we have
+ * mechanism to get dma resources from DT.
+ *
+ * Returns 0.
+ */
+static int _od_fill_dma_resources(struct omap_device *od,
+				      struct resource *res)
+{
+	int i, r;
+
+	for (i = 0; i < od->hwmods_cnt; i++) {
+		r = omap_hwmod_fill_dma_resources(od->hwmods[i], res);
+		res += r;
+	}
+
+	return 0;
+}
+
+/**
+ * omap_device_alloc - allocate an omap_device
+ * @pdev: platform_device that will be included in this omap_device
+ * @oh: ptr to the single omap_hwmod that backs this omap_device
+ * @pdata: platform_data ptr to associate with the platform_device
+ * @pdata_len: amount of memory pointed to by @pdata
+ * @pm_lats: pointer to a omap_device_pm_latency array for this device
+ * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
+ *
+ * Convenience function for allocating an omap_device structure and filling
+ * hwmods, resources and pm_latency attributes.
+ *
+ * Returns an struct omap_device pointer or ERR_PTR() on error;
+ */
+struct omap_device *omap_device_alloc(struct platform_device *pdev,
+					struct omap_hwmod **ohs, int oh_cnt,
+					struct omap_device_pm_latency *pm_lats,
+					int pm_lats_cnt)
+{
+	int ret = -ENOMEM;
+	struct omap_device *od;
+	struct resource *res = NULL;
+	int i, res_count;
+	struct omap_hwmod **hwmods;
+
+	od = kzalloc(sizeof(struct omap_device), GFP_KERNEL);
+	if (!od) {
+		ret = -ENOMEM;
+		goto oda_exit1;
+	}
+	od->hwmods_cnt = oh_cnt;
+
+	hwmods = kmemdup(ohs, sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
+	if (!hwmods)
+		goto oda_exit2;
+
+	od->hwmods = hwmods;
+	od->pdev = pdev;
+
+	res_count = omap_device_count_resources(od);
+	/*
+	 * DT Boot:
+	 *   OF framework will construct the resource structure (currently
+	 *   does for MEM & IRQ resource) and we should respect/use these
+	 *   resources, killing hwmod dependency.
+	 *   If pdev->num_resources > 0, we assume that MEM & IRQ resources
+	 *   have been allocated by OF layer already (through DTB).
+	 *
+	 * Non-DT Boot:
+	 *   Here, pdev->num_resources = 0, and we should get all the
+	 *   resources from hwmod.
+	 *
+	 * TODO: Once DMA resource is available from OF layer, we should
+	 *   kill filling any resources from hwmod.
+	 */
+	if (res_count > pdev->num_resources) {
+		/* Allocate resources memory to account for new resources */
+		res = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);
+		if (!res)
+			goto oda_exit3;
+
+		/*
+		 * If pdev->num_resources > 0, then assume that,
+		 * MEM and IRQ resources will only come from DT and only
+		 * fill DMA resource from hwmod layer.
+		 */
+		if (pdev->num_resources && pdev->resource) {
+			dev_dbg(&pdev->dev, "%s(): resources already allocated %d\n",
+				__func__, res_count);
+			memcpy(res, pdev->resource,
+			       sizeof(struct resource) * pdev->num_resources);
+			_od_fill_dma_resources(od, &res[pdev->num_resources]);
+		} else {
+			dev_dbg(&pdev->dev, "%s(): using resources from hwmod %d\n",
+				__func__, res_count);
+			omap_device_fill_resources(od, res);
+		}
+
+		ret = platform_device_add_resources(pdev, res, res_count);
+		kfree(res);
+
+		if (ret)
+			goto oda_exit3;
+	}
+
+	if (!pm_lats) {
+		pm_lats = omap_default_latency;
+		pm_lats_cnt = ARRAY_SIZE(omap_default_latency);
+	}
+
+	od->pm_lats_cnt = pm_lats_cnt;
+	od->pm_lats = kmemdup(pm_lats,
+			sizeof(struct omap_device_pm_latency) * pm_lats_cnt,
+			GFP_KERNEL);
+	if (!od->pm_lats)
+		goto oda_exit3;
+
+	pdev->archdata.od = od;
+
+	for (i = 0; i < oh_cnt; i++) {
+		hwmods[i]->od = od;
+		_add_hwmod_clocks_clkdev(od, hwmods[i]);
+	}
+
+	return od;
+
+oda_exit3:
+	kfree(hwmods);
+oda_exit2:
+	kfree(od);
+oda_exit1:
+	dev_err(&pdev->dev, "omap_device: build failed (%d)\n", ret);
+
+	return ERR_PTR(ret);
+}
+
+void omap_device_delete(struct omap_device *od)
+{
+	if (!od)
+		return;
+
+	od->pdev->archdata.od = NULL;
+	kfree(od->pm_lats);
+	kfree(od->hwmods);
+	kfree(od);
+}
+
+/**
+ * omap_device_build - build and register an omap_device with one omap_hwmod
+ * @pdev_name: name of the platform_device driver to use
+ * @pdev_id: this platform_device's connection ID
+ * @oh: ptr to the single omap_hwmod that backs this omap_device
+ * @pdata: platform_data ptr to associate with the platform_device
+ * @pdata_len: amount of memory pointed to by @pdata
+ * @pm_lats: pointer to a omap_device_pm_latency array for this device
+ * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
+ * @is_early_device: should the device be registered as an early device or not
+ *
+ * Convenience function for building and registering a single
+ * omap_device record, which in turn builds and registers a
+ * platform_device record.  See omap_device_build_ss() for more
+ * information.  Returns ERR_PTR(-EINVAL) if @oh is NULL; otherwise,
+ * passes along the return value of omap_device_build_ss().
+ */
+struct platform_device __init *omap_device_build(const char *pdev_name, int pdev_id,
+				      struct omap_hwmod *oh, void *pdata,
+				      int pdata_len,
+				      struct omap_device_pm_latency *pm_lats,
+				      int pm_lats_cnt, int is_early_device)
+{
+	struct omap_hwmod *ohs[] = { oh };
+
+	if (!oh)
+		return ERR_PTR(-EINVAL);
+
+	return omap_device_build_ss(pdev_name, pdev_id, ohs, 1, pdata,
+				    pdata_len, pm_lats, pm_lats_cnt,
+				    is_early_device);
+}
+
+/**
+ * omap_device_build_ss - build and register an omap_device with multiple hwmods
+ * @pdev_name: name of the platform_device driver to use
+ * @pdev_id: this platform_device's connection ID
+ * @oh: ptr to the single omap_hwmod that backs this omap_device
+ * @pdata: platform_data ptr to associate with the platform_device
+ * @pdata_len: amount of memory pointed to by @pdata
+ * @pm_lats: pointer to a omap_device_pm_latency array for this device
+ * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats
+ * @is_early_device: should the device be registered as an early device or not
+ *
+ * Convenience function for building and registering an omap_device
+ * subsystem record.  Subsystem records consist of multiple
+ * omap_hwmods.  This function in turn builds and registers a
+ * platform_device record.  Returns an ERR_PTR() on error, or passes
+ * along the return value of omap_device_register().
+ */
+struct platform_device __init *omap_device_build_ss(const char *pdev_name, int pdev_id,
+					 struct omap_hwmod **ohs, int oh_cnt,
+					 void *pdata, int pdata_len,
+					 struct omap_device_pm_latency *pm_lats,
+					 int pm_lats_cnt, int is_early_device)
+{
+	int ret = -ENOMEM;
+	struct platform_device *pdev;
+	struct omap_device *od;
+
+	if (!ohs || oh_cnt == 0 || !pdev_name)
+		return ERR_PTR(-EINVAL);
+
+	if (!pdata && pdata_len > 0)
+		return ERR_PTR(-EINVAL);
+
+	pdev = platform_device_alloc(pdev_name, pdev_id);
+	if (!pdev) {
+		ret = -ENOMEM;
+		goto odbs_exit;
+	}
+
+	/* Set the dev_name early to allow dev_xxx in omap_device_alloc */
+	if (pdev->id != -1)
+		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
+	else
+		dev_set_name(&pdev->dev, "%s", pdev->name);
+
+	od = omap_device_alloc(pdev, ohs, oh_cnt, pm_lats, pm_lats_cnt);
+	if (IS_ERR(od))
+		goto odbs_exit1;
+
+	ret = platform_device_add_data(pdev, pdata, pdata_len);
+	if (ret)
+		goto odbs_exit2;
+
+	if (is_early_device)
+		ret = omap_early_device_register(pdev);
+	else
+		ret = omap_device_register(pdev);
+	if (ret)
+		goto odbs_exit2;
+
+	return pdev;
+
+odbs_exit2:
+	omap_device_delete(od);
+odbs_exit1:
+	platform_device_put(pdev);
+odbs_exit:
+
+	pr_err("omap_device: %s: build failed (%d)\n", pdev_name, ret);
+
+	return ERR_PTR(ret);
+}
+
+/**
+ * omap_early_device_register - register an omap_device as an early platform
+ * device.
+ * @od: struct omap_device * to register
+ *
+ * Register the omap_device structure.  This currently just calls
+ * platform_early_add_device() on the underlying platform_device.
+ * Returns 0 by default.
+ */
+static int __init omap_early_device_register(struct platform_device *pdev)
+{
+	struct platform_device *devices[1];
+
+	devices[0] = pdev;
+	early_platform_add_devices(devices, 1);
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int _od_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+
+	ret = pm_generic_runtime_suspend(dev);
+
+	if (!ret)
+		omap_device_idle(pdev);
+
+	return ret;
+}
+
+static int _od_runtime_idle(struct device *dev)
+{
+	return pm_generic_runtime_idle(dev);
+}
+
+static int _od_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	omap_device_enable(pdev);
+
+	return pm_generic_runtime_resume(dev);
+}
+#endif
+
+#ifdef CONFIG_SUSPEND
+static int _od_suspend_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct omap_device *od = to_omap_device(pdev);
+	int ret;
+
+	/* Don't attempt late suspend on a driver that is not bound */
+	if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER)
+		return 0;
+
+	ret = pm_generic_suspend_noirq(dev);
+
+	if (!ret && !pm_runtime_status_suspended(dev)) {
+		if (pm_generic_runtime_suspend(dev) == 0) {
+			if (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))
+				omap_device_idle(pdev);
+			od->flags |= OMAP_DEVICE_SUSPENDED;
+		}
+	}
+
+	return ret;
+}
+
+static int _od_resume_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct omap_device *od = to_omap_device(pdev);
+
+	if ((od->flags & OMAP_DEVICE_SUSPENDED) &&
+	    !pm_runtime_status_suspended(dev)) {
+		od->flags &= ~OMAP_DEVICE_SUSPENDED;
+		if (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))
+			omap_device_enable(pdev);
+		pm_generic_runtime_resume(dev);
+	}
+
+	return pm_generic_resume_noirq(dev);
+}
+#else
+#define _od_suspend_noirq NULL
+#define _od_resume_noirq NULL
+#endif
+
+struct dev_pm_domain omap_device_pm_domain = {
+	.ops = {
+		SET_RUNTIME_PM_OPS(_od_runtime_suspend, _od_runtime_resume,
+				   _od_runtime_idle)
+		USE_PLATFORM_PM_SLEEP_OPS
+		.suspend_noirq = _od_suspend_noirq,
+		.resume_noirq = _od_resume_noirq,
+	}
+};
+
+/**
+ * omap_device_register - register an omap_device with one omap_hwmod
+ * @od: struct omap_device * to register
+ *
+ * Register the omap_device structure.  This currently just calls
+ * platform_device_register() on the underlying platform_device.
+ * Returns the return value of platform_device_register().
+ */
+int omap_device_register(struct platform_device *pdev)
+{
+	pr_debug("omap_device: %s: registering\n", pdev->name);
+
+	pdev->dev.pm_domain = &omap_device_pm_domain;
+	return platform_device_add(pdev);
+}
+
+
+/* Public functions for use by device drivers through struct platform_data */
+
+/**
+ * omap_device_enable - fully activate an omap_device
+ * @od: struct omap_device * to activate
+ *
+ * Do whatever is necessary for the hwmods underlying omap_device @od
+ * to be accessible and ready to operate.  This generally involves
+ * enabling clocks, setting SYSCONFIG registers; and in the future may
+ * involve remuxing pins.  Device drivers should call this function
+ * (through platform_data function pointers) where they would normally
+ * enable clocks, etc.  Returns -EINVAL if called when the omap_device
+ * is already enabled, or passes along the return value of
+ * _omap_device_activate().
+ */
+int omap_device_enable(struct platform_device *pdev)
+{
+	int ret;
+	struct omap_device *od;
+
+	od = to_omap_device(pdev);
+
+	if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
+		dev_warn(&pdev->dev,
+			 "omap_device: %s() called from invalid state %d\n",
+			 __func__, od->_state);
+		return -EINVAL;
+	}
+
+	/* Enable everything if we're enabling this device from scratch */
+	if (od->_state == OMAP_DEVICE_STATE_UNKNOWN)
+		od->pm_lat_level = od->pm_lats_cnt;
+
+	ret = _omap_device_activate(od, IGNORE_WAKEUP_LAT);
+
+	od->dev_wakeup_lat = 0;
+	od->_dev_wakeup_lat_limit = UINT_MAX;
+	od->_state = OMAP_DEVICE_STATE_ENABLED;
+
+	return ret;
+}
+
+/**
+ * omap_device_idle - idle an omap_device
+ * @od: struct omap_device * to idle
+ *
+ * Idle omap_device @od by calling as many .deactivate_func() entries
+ * in the omap_device's pm_lats table as is possible without exceeding
+ * the device's maximum wakeup latency limit, pm_lat_limit.  Device
+ * drivers should call this function (through platform_data function
+ * pointers) where they would normally disable clocks after operations
+ * complete, etc..  Returns -EINVAL if the omap_device is not
+ * currently enabled, or passes along the return value of
+ * _omap_device_deactivate().
+ */
+int omap_device_idle(struct platform_device *pdev)
+{
+	int ret;
+	struct omap_device *od;
+
+	od = to_omap_device(pdev);
+
+	if (od->_state != OMAP_DEVICE_STATE_ENABLED) {
+		dev_warn(&pdev->dev,
+			 "omap_device: %s() called from invalid state %d\n",
+			 __func__, od->_state);
+		return -EINVAL;
+	}
+
+	ret = _omap_device_deactivate(od, USE_WAKEUP_LAT);
+
+	od->_state = OMAP_DEVICE_STATE_IDLE;
+
+	return ret;
+}
+
+/**
+ * omap_device_shutdown - shut down an omap_device
+ * @od: struct omap_device * to shut down
+ *
+ * Shut down omap_device @od by calling all .deactivate_func() entries
+ * in the omap_device's pm_lats table and then shutting down all of
+ * the underlying omap_hwmods.  Used when a device is being "removed"
+ * or a device driver is being unloaded.  Returns -EINVAL if the
+ * omap_device is not currently enabled or idle, or passes along the
+ * return value of _omap_device_deactivate().
+ */
+int omap_device_shutdown(struct platform_device *pdev)
+{
+	int ret, i;
+	struct omap_device *od;
+
+	od = to_omap_device(pdev);
+
+	if (od->_state != OMAP_DEVICE_STATE_ENABLED &&
+	    od->_state != OMAP_DEVICE_STATE_IDLE) {
+		dev_warn(&pdev->dev,
+			 "omap_device: %s() called from invalid state %d\n",
+			 __func__, od->_state);
+		return -EINVAL;
+	}
+
+	ret = _omap_device_deactivate(od, IGNORE_WAKEUP_LAT);
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_shutdown(od->hwmods[i]);
+
+	od->_state = OMAP_DEVICE_STATE_SHUTDOWN;
+
+	return ret;
+}
+
+/**
+ * omap_device_assert_hardreset - set a device's hardreset line
+ * @pdev: struct platform_device * to reset
+ * @name: const char * name of the reset line
+ *
+ * Set the hardreset line identified by @name on the IP blocks
+ * associated with the hwmods backing the platform_device @pdev.  All
+ * of the hwmods associated with @pdev must have the same hardreset
+ * line linked to them for this to work.  Passes along the return value
+ * of omap_hwmod_assert_hardreset() in the event of any failure, or
+ * returns 0 upon success.
+ */
+int omap_device_assert_hardreset(struct platform_device *pdev, const char *name)
+{
+	struct omap_device *od = to_omap_device(pdev);
+	int ret = 0;
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++) {
+		ret = omap_hwmod_assert_hardreset(od->hwmods[i], name);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+/**
+ * omap_device_deassert_hardreset - release a device's hardreset line
+ * @pdev: struct platform_device * to reset
+ * @name: const char * name of the reset line
+ *
+ * Release the hardreset line identified by @name on the IP blocks
+ * associated with the hwmods backing the platform_device @pdev.  All
+ * of the hwmods associated with @pdev must have the same hardreset
+ * line linked to them for this to work.  Passes along the return
+ * value of omap_hwmod_deassert_hardreset() in the event of any
+ * failure, or returns 0 upon success.
+ */
+int omap_device_deassert_hardreset(struct platform_device *pdev,
+				   const char *name)
+{
+	struct omap_device *od = to_omap_device(pdev);
+	int ret = 0;
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++) {
+		ret = omap_hwmod_deassert_hardreset(od->hwmods[i], name);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+/**
+ * omap_device_align_pm_lat - activate/deactivate device to match wakeup lat lim
+ * @od: struct omap_device *
+ *
+ * When a device's maximum wakeup latency limit changes, call some of
+ * the .activate_func or .deactivate_func function pointers in the
+ * omap_device's pm_lats array to ensure that the device's maximum
+ * wakeup latency is less than or equal to the new latency limit.
+ * Intended to be called by OMAP PM code whenever a device's maximum
+ * wakeup latency limit changes (e.g., via
+ * omap_pm_set_dev_wakeup_lat()).  Returns 0 if nothing needs to be
+ * done (e.g., if the omap_device is not currently idle, or if the
+ * wakeup latency is already current with the new limit) or passes
+ * along the return value of _omap_device_deactivate() or
+ * _omap_device_activate().
+ */
+int omap_device_align_pm_lat(struct platform_device *pdev,
+			     u32 new_wakeup_lat_limit)
+{
+	int ret = -EINVAL;
+	struct omap_device *od;
+
+	od = to_omap_device(pdev);
+
+	if (new_wakeup_lat_limit == od->dev_wakeup_lat)
+		return 0;
+
+	od->_dev_wakeup_lat_limit = new_wakeup_lat_limit;
+
+	if (od->_state != OMAP_DEVICE_STATE_IDLE)
+		return 0;
+	else if (new_wakeup_lat_limit > od->dev_wakeup_lat)
+		ret = _omap_device_deactivate(od, USE_WAKEUP_LAT);
+	else if (new_wakeup_lat_limit < od->dev_wakeup_lat)
+		ret = _omap_device_activate(od, USE_WAKEUP_LAT);
+
+	return ret;
+}
+
+/**
+ * omap_device_get_pwrdm - return the powerdomain * associated with @od
+ * @od: struct omap_device *
+ *
+ * Return the powerdomain associated with the first underlying
+ * omap_hwmod for this omap_device.  Intended for use by core OMAP PM
+ * code.  Returns NULL on error or a struct powerdomain * upon
+ * success.
+ */
+struct powerdomain *omap_device_get_pwrdm(struct omap_device *od)
+{
+	/*
+	 * XXX Assumes that all omap_hwmod powerdomains are identical.
+	 * This may not necessarily be true.  There should be a sanity
+	 * check in here to WARN() if any difference appears.
+	 */
+	if (!od->hwmods_cnt)
+		return NULL;
+
+	return omap_hwmod_get_pwrdm(od->hwmods[0]);
+}
+
+/**
+ * omap_device_get_mpu_rt_va - return the MPU's virtual addr for the hwmod base
+ * @od: struct omap_device *
+ *
+ * Return the MPU's virtual address for the base of the hwmod, from
+ * the ioremap() that the hwmod code does.  Only valid if there is one
+ * hwmod associated with this device.  Returns NULL if there are zero
+ * or more than one hwmods associated with this omap_device;
+ * otherwise, passes along the return value from
+ * omap_hwmod_get_mpu_rt_va().
+ */
+void __iomem *omap_device_get_rt_va(struct omap_device *od)
+{
+	if (od->hwmods_cnt != 1)
+		return NULL;
+
+	return omap_hwmod_get_mpu_rt_va(od->hwmods[0]);
+}
+
+/**
+ * omap_device_get_by_hwmod_name() - convert a hwmod name to
+ * device pointer.
+ * @oh_name: name of the hwmod device
+ *
+ * Returns back a struct device * pointer associated with a hwmod
+ * device represented by a hwmod_name
+ */
+struct device *omap_device_get_by_hwmod_name(const char *oh_name)
+{
+	struct omap_hwmod *oh;
+
+	if (!oh_name) {
+		WARN(1, "%s: no hwmod name!\n", __func__);
+		return ERR_PTR(-EINVAL);
+	}
+
+	oh = omap_hwmod_lookup(oh_name);
+	if (IS_ERR_OR_NULL(oh)) {
+		WARN(1, "%s: no hwmod for %s\n", __func__,
+			oh_name);
+		return ERR_PTR(oh ? PTR_ERR(oh) : -ENODEV);
+	}
+	if (IS_ERR_OR_NULL(oh->od)) {
+		WARN(1, "%s: no omap_device for %s\n", __func__,
+			oh_name);
+		return ERR_PTR(oh->od ? PTR_ERR(oh->od) : -ENODEV);
+	}
+
+	if (IS_ERR_OR_NULL(oh->od->pdev))
+		return ERR_PTR(oh->od->pdev ? PTR_ERR(oh->od->pdev) : -ENODEV);
+
+	return &oh->od->pdev->dev;
+}
+EXPORT_SYMBOL(omap_device_get_by_hwmod_name);
+
+/*
+ * Public functions intended for use in omap_device_pm_latency
+ * .activate_func and .deactivate_func function pointers
+ */
+
+/**
+ * omap_device_enable_hwmods - call omap_hwmod_enable() on all hwmods
+ * @od: struct omap_device *od
+ *
+ * Enable all underlying hwmods.  Returns 0.
+ */
+int omap_device_enable_hwmods(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_enable(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
+
+/**
+ * omap_device_idle_hwmods - call omap_hwmod_idle() on all hwmods
+ * @od: struct omap_device *od
+ *
+ * Idle all underlying hwmods.  Returns 0.
+ */
+int omap_device_idle_hwmods(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_idle(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
+
+/**
+ * omap_device_disable_clocks - disable all main and interface clocks
+ * @od: struct omap_device *od
+ *
+ * Disable the main functional clock and interface clock for all of the
+ * omap_hwmods associated with the omap_device.  Returns 0.
+ */
+int omap_device_disable_clocks(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_disable_clocks(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
+
+/**
+ * omap_device_enable_clocks - enable all main and interface clocks
+ * @od: struct omap_device *od
+ *
+ * Enable the main functional clock and interface clock for all of the
+ * omap_hwmods associated with the omap_device.  Returns 0.
+ */
+int omap_device_enable_clocks(struct omap_device *od)
+{
+	int i;
+
+	for (i = 0; i < od->hwmods_cnt; i++)
+		omap_hwmod_enable_clocks(od->hwmods[i]);
+
+	/* XXX pass along return value here? */
+	return 0;
+}
+
+static struct notifier_block platform_nb = {
+	.notifier_call = _omap_device_notifier_call,
+};
+
+static int __init omap_device_init(void)
+{
+	bus_register_notifier(&platform_bus_type, &platform_nb);
+	return 0;
+}
+core_initcall(omap_device_init);
+
+/**
+ * omap_device_late_idle - idle devices without drivers
+ * @dev: struct device * associated with omap_device
+ * @data: unused
+ *
+ * Check the driver bound status of this device, and idle it
+ * if there is no driver attached.
+ */
+static int __init omap_device_late_idle(struct device *dev, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct omap_device *od = to_omap_device(pdev);
+
+	if (!od)
+		return 0;
+
+	/*
+	 * If omap_device state is enabled, but has no driver bound,
+	 * idle it.
+	 */
+	if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER) {
+		if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
+			dev_warn(dev, "%s: enabled but no driver.  Idling\n",
+				 __func__);
+			omap_device_idle(pdev);
+		}
+	}
+
+	return 0;
+}
+
+static int __init omap_device_late_init(void)
+{
+	bus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);
+	return 0;
+}
+late_initcall(omap_device_late_init);
