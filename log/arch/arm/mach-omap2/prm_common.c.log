commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index fd6e0671f957..65b2d82efa27 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP2+ common Power & Reset Management (PRM) IP block functions
  *
  * Copyright (C) 2011 Texas Instruments, Inc.
  * Tero Kristo <t-kristo@ti.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *
  * For historical purposes, the API used to configure the PRM
  * interrupt handler refers to it as the "PRCM interrupt."  The
  * underlying registers are located in the PRM on OMAP3/4.

commit 5388a5b82199facacd3d7ac0d05aca6e8f902fed
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Apr 10 11:35:36 2018 +0100

    ARM: avoid Cortex-A9 livelock on tight dmb loops
    
    machine_crash_nonpanic_core() does this:
    
            while (1)
                    cpu_relax();
    
    because the kernel has crashed, and we have no known safe way to deal
    with the CPU.  So, we place the CPU into an infinite loop which we
    expect it to never exit - at least not until the system as a whole is
    reset by some method.
    
    In the absence of erratum 754327, this code assembles to:
    
            b       .
    
    In other words, an infinite loop.  When erratum 754327 is enabled,
    this becomes:
    
    1:      dmb
            b       1b
    
    It has been observed that on some systems (eg, OMAP4) where, if a
    crash is triggered, the system tries to kexec into the panic kernel,
    but fails after taking the secondary CPU down - placing it into one
    of these loops.  This causes the system to livelock, and the most
    noticable effect is the system stops after issuing:
    
            Loading crashdump kernel...
    
    to the system console.
    
    The tested as working solution I came up with was to add wfe() to
    these infinite loops thusly:
    
            while (1) {
                    cpu_relax();
                    wfe();
            }
    
    which, without 754327 builds to:
    
    1:      wfe
            b       1b
    
    or with 754327 is enabled:
    
    1:      dmb
            wfe
            b       1b
    
    Adding "wfe" does two things depending on the environment we're running
    under:
    - where we're running on bare metal, and the processor implements
      "wfe", it stops us spinning endlessly in a loop where we're never
      going to do any useful work.
    - if we're running in a VM, it allows the CPU to be given back to the
      hypervisor and rescheduled for other purposes (maybe a different VM)
      rather than wasting CPU cycles inside a crashed VM.
    
    However, in light of erratum 794072, Will Deacon wanted to see 10 nops
    as well - which is reasonable to cover the case where we have erratum
    754327 enabled _and_ we have a processor that doesn't implement the
    wfe hint.
    
    So, we now end up with:
    
    1:      wfe
            b       1b
    
    when erratum 754327 is disabled, or:
    
    1:      dmb
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            wfe
            b       1b
    
    when erratum 754327 is enabled.  We also get the dmb + 10 nop
    sequence elsewhere in the kernel, in terminating loops.
    
    This is reasonable - it means we get the workaround for erratum
    794072 when erratum 754327 is enabled, but still relinquish the dead
    processor - either by placing it in a lower power mode when wfe is
    implemented as such or by returning it to the hypervisior, or in the
    case where wfe is a no-op, we use the workaround specified in erratum
    794072 to avoid the problem.
    
    These as two entirely orthogonal problems - the 10 nops addresses
    erratum 794072, and the wfe is an optimisation that makes the system
    more efficient when crashed either in terms of power consumption or
    by allowing the host/other VMs to make use of the CPU.
    
    I don't see any reason not to use kexec() inside a VM - it has the
    potential to provide automated recovery from a failure of the VMs
    kernel with the opportunity for saving a crashdump of the failure.
    A panic() with a reboot timeout won't do that, and reading the
    libvirt documentation, setting on_reboot to "preserve" won't either
    (the documentation states "The preserve action for an on_reboot event
    is treated as a destroy".)  Surely it has to be a good thing to
    avoiding having CPUs spinning inside a VM that is doing no useful
    work.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 058a37e6d11c..fd6e0671f957 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -523,8 +523,10 @@ void omap_prm_reset_system(void)
 
 	prm_ll_data->reset_system();
 
-	while (1)
+	while (1) {
 		cpu_relax();
+		wfe();
+	}
 }
 
 /**

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 021b5a8b9c0a..058a37e6d11c 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -285,10 +285,11 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 
 	prcm_irq_setup = irq_setup;
 
-	prcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);
-	prcm_irq_setup->saved_mask = kzalloc(sizeof(u32) * nr_regs, GFP_KERNEL);
-	prcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,
-		GFP_KERNEL);
+	prcm_irq_chips = kcalloc(nr_regs, sizeof(void *), GFP_KERNEL);
+	prcm_irq_setup->saved_mask = kcalloc(nr_regs, sizeof(u32),
+					     GFP_KERNEL);
+	prcm_irq_setup->priority_mask = kcalloc(nr_regs, sizeof(u32),
+						GFP_KERNEL);
 
 	if (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||
 	    !prcm_irq_setup->priority_mask)

commit 3da521672568702c58767de69b5b0b58c8095fae
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:13 2017 -0700

    ARM: OMAP4: Remove legacy IRQ for PRM
    
    We have the PRM IRQ mapped in device tree and this legacy code
    is no longer needed.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 09180a59b1c9..021b5a8b9c0a 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -218,10 +218,7 @@ void omap_prcm_irq_cleanup(void)
 	kfree(prcm_irq_setup->priority_mask);
 	prcm_irq_setup->priority_mask = NULL;
 
-	if (prcm_irq_setup->xlate_irq)
-		irq = prcm_irq_setup->xlate_irq(prcm_irq_setup->irq);
-	else
-		irq = prcm_irq_setup->irq;
+	irq = prcm_irq_setup->irq;
 	irq_set_chained_handler(irq, NULL);
 
 	if (prcm_irq_setup->base_irq > 0)
@@ -307,10 +304,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 				1 << (offset & 0x1f);
 	}
 
-	if (irq_setup->xlate_irq)
-		irq = irq_setup->xlate_irq(irq_setup->irq);
-	else
-		irq = irq_setup->irq;
+	irq = irq_setup->irq;
 	irq_set_chained_handler(irq, omap_prcm_irq_handler);
 
 	irq_setup->base_irq = irq_alloc_descs(-1, 0, irq_setup->nr_regs * 32,
@@ -671,7 +665,7 @@ static struct omap_prcm_init_data omap4_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = OMAP4430_PRM_DEVICE_INST,
-	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE | PRM_IRQ_DEFAULT,
+	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE,
 };
 #endif
 

commit 2b1ee3061f09bd90a5c659b9cb45fcbf49c5fd4c
Merge: 6198c74939c0 1df5eaa6bced
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Jun 18 20:46:30 2017 -0700

    Merge tag 'omap-for-v4.13/soc-v4-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    SoC changes for omap variants for v4.13 merge window:
    
    - PM clean-up in preparation of adding am335x/am437x PM support
    
    - Fixes for issues found by Coccinelle
    
    - Legacy code removal now that everything boots in device
      tree only mode
    
    - Interconnect changes in preparation of moving clkctrl clocks
      to be managed by clkctrl clock driver
    
    - Interconnect changes to add omap4 crypto acceclerator
      support
    
    * tag 'omap-for-v4.13/soc-v4-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (27 commits)
      ARM: OMAP4: hwmod_data: add SHAM crypto accelerator
      ARM: OMAP4: hwmod data: add des
      ARM: OMAP4: hwmod data: add aes2
      ARM: OMAP4: hwmod data: add aes1
      ARM: OMAP2+: Remove unused legacy code for n8x0
      ARM: OMAP2+: Remove unused legacy code for watchdog
      ARM: OMAP2+: Remove unused legacy code for interconnects
      ARM: OMAP2+: Remove unused legacy code for PRM
      ARM: OMAP2+: Remove unused legacy code for io.c
      ARM: OMAP2+: Remove unused legacy code for McBSP
      ARM: OMAP2+: SmartReflex: Delete an error message for a failed memory allocation in two functions
      ARM: OMAP2+: Use kcalloc() in sr_set_nvalues()
      ARM: OMAP2+: Improve a size determination in sr_dev_init()
      ARM: OMAP2+: Delete an error message for a failed memory allocation in two functions
      ARM: OMAP2+: Remove unused legacy code for device init
      ARM: OMAP2+: Remove unused legacy code for PMU
      ARM: OMAP2+: Remove unused legacy code for opp
      ARM: OMAP2+: hwmod: populate clkctrl clocks for hwmods if available
      ARM: OMAP4: cminst: add support for clkdm_xlate_address
      ARM: omap2+: clockdomain: add clkdm_xlate_address
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 67d00470accf5c58abbb23a44c867c5f15437976
Merge: 018b732458ac 70f05be32133
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 12 03:27:30 2017 -0700

    Merge branch 'omap-for-v4.13/clkctrl' into omap-for-v4.13/soc-v4

commit 2a26d31b1bae5d07b97fc05755053295da686ec7
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 31 15:51:36 2017 -0700

    ARM: OMAP2+: Remove unused legacy code for PRM
    
    We are now booting all mach-omap2 in device tree only mode.
    Any code that is only called in legacy boot mode where
    of_have_populated_dt() is not set is safe to remove now.
    
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 2b138b65129a..538980ee20d4 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -267,10 +267,9 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 {
 	int nr_regs;
 	u32 mask[OMAP_PRCM_MAX_NR_PENDING_REG];
-	int offset, i;
+	int offset, i, irq;
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
-	unsigned int irq;
 
 	if (!irq_setup)
 		return -EINVAL;
@@ -344,10 +343,8 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 		prcm_irq_chips[i] = gc;
 	}
 
-	if (of_have_populated_dt()) {
-		int irq = omap_prcm_event_to_irq("io");
-		omap_pcs_legacy_init(irq, irq_setup->reconfigure_io_chain);
-	}
+	irq = omap_prcm_event_to_irq("io");
+	omap_pcs_legacy_init(irq, irq_setup->reconfigure_io_chain);
 
 	return 0;
 

commit 90129336712c3c8dcd0d81a5dfaea52dd8391e62
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed May 31 18:00:00 2017 +0300

    ARM: OMAP2+: PRCM: store also physical addresses for instances
    
    In some cases the physical address info is needed, so store this
    under the existing cm*_base, prm_base and prcm_mpu_base variables.
    These are converted now to structs that contain both virtual and
    physical address base for the instance.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 2b138b65129a..ae13aa710c75 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -66,7 +66,7 @@ static struct irq_chip_generic **prcm_irq_chips;
 static struct omap_prcm_irq_setup *prcm_irq_setup;
 
 /* prm_base: base virtual address of the PRM IP block */
-void __iomem *prm_base;
+struct omap_domain_base prm_base;
 
 u16 prm_features;
 
@@ -325,7 +325,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 
 	for (i = 0; i < irq_setup->nr_regs; i++) {
 		gc = irq_alloc_generic_chip("PRCM", 1,
-			irq_setup->base_irq + i * 32, prm_base,
+			irq_setup->base_irq + i * 32, prm_base.va,
 			handle_level_irq);
 
 		if (!gc) {
@@ -364,7 +364,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
  */
 void __init omap2_set_globals_prm(void __iomem *prm)
 {
-	prm_base = prm;
+	prm_base.va = prm;
 }
 
 /**
@@ -755,19 +755,22 @@ int __init omap2_prm_base_init(void)
 	struct device_node *np;
 	const struct of_device_id *match;
 	struct omap_prcm_init_data *data;
-	void __iomem *mem;
+	struct resource res;
+	int ret;
 
 	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
 		data = (struct omap_prcm_init_data *)match->data;
 
-		mem = of_iomap(np, 0);
-		if (!mem)
-			return -ENOMEM;
+		ret = of_address_to_resource(np, 0, &res);
+		if (ret)
+			return ret;
 
-		if (data->index == TI_CLKM_PRM)
-			prm_base = mem + data->offset;
+		data->mem = ioremap(res.start, resource_size(&res));
 
-		data->mem = mem;
+		if (data->index == TI_CLKM_PRM) {
+			prm_base.va = data->mem + data->offset;
+			prm_base.pa = res.start + data->offset;
+		}
 
 		data->np = np;
 

commit 0527873b29b077fc8e656acd63e1866b429fef55
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 11 13:50:16 2017 +0200

    ARM: remove duplicate 'const' annotations'
    
    gcc-7 warns about some declarations that are more 'const' than necessary:
    
    arch/arm/mach-at91/pm.c:338:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const ramc_ids[] __initconst = {
    arch/arm/mach-bcm/bcm_kona_smc.c:36:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
    arch/arm/mach-spear/time.c:207:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const timer_of_match[] __initconst = {
    arch/arm/mach-omap2/prm_common.c:714:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
    arch/arm/mach-omap2/vc.c:562:35: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
    
    The ones in arch/arm were apparently all introduced accidentally by one
    commit that correctly marked a lot of variables as __initconst.
    
    Fixes: 19c233b79d1a ("ARM: appropriate __init annotation for const data")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 2b138b65129a..dc11841ca334 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -711,7 +711,7 @@ static struct omap_prcm_init_data scrm_data __initdata = {
 };
 #endif
 
-static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
+static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {
 #ifdef CONFIG_SOC_AM33XX
 	{ .compatible = "ti,am3-prcm", .data = &am3_prm_data },
 #endif

commit 9a6b6f75d9daa892ae8f6e5ed6ae0ab49b9586cb
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Dec 3 21:46:02 2016 +0100

    ARM: OMAP2+: PRM: Delete an error message for a failed memory allocation
    
    Omit an extra message for a memory allocation failure in this function.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 5b2f5138d938..2b138b65129a 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -295,10 +295,8 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 		GFP_KERNEL);
 
 	if (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||
-	    !prcm_irq_setup->priority_mask) {
-		pr_err("PRCM: kzalloc failed\n");
+	    !prcm_irq_setup->priority_mask)
 		goto err;
-	}
 
 	memset(mask, 0, sizeof(mask));
 

commit dbb7e70a69288980c8a89fdb5ffb97e06b806b19
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 21 10:06:52 2015 -0800

    ARM: OMAP2+: Fix randconfig build warning for dm814_pllss_data
    
    Fix warning for arch/arm/mach-omap2/prm_common.c:666:35: warning:
    ‘dm814_pllss_data’ defined but not used [-Wunused-variable]".
    
    This can happen if CONFIG_SOC_TI81XX is not selected.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 55acc76113b8..5b2f5138d938 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -662,7 +662,9 @@ static struct omap_prcm_init_data am3_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = am33xx_prm_init,
 };
+#endif
 
+#ifdef CONFIG_SOC_TI81XX
 static struct omap_prcm_init_data dm814_pllss_data __initdata = {
 	.index = TI_CLKM_PLLSS,
 	.init = am33xx_prm_init,

commit 4e34df0cba14e95e941bf73721352fa4d9c2622f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 3 12:02:31 2015 -0800

    ARM: OMAP2+: Add DPPLS clock manager for dm814x
    
    On dm814x we have some clocks at DPLLS and some at PRCM. Let's add a new
    omap_prcm_init_data entry for the DPLLS so we can initalize timer clocks
    early.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 3fc2cbe52113..55acc76113b8 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -662,6 +662,11 @@ static struct omap_prcm_init_data am3_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = am33xx_prm_init,
 };
+
+static struct omap_prcm_init_data dm814_pllss_data __initdata = {
+	.index = TI_CLKM_PLLSS,
+	.init = am33xx_prm_init,
+};
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
@@ -715,6 +720,7 @@ static const struct of_device_id const omap_prcm_dt_match_table[] __initconst =
 #endif
 #ifdef CONFIG_SOC_TI81XX
 	{ .compatible = "ti,dm814-prcm", .data = &am3_prm_data },
+	{ .compatible = "ti,dm814-pllss", .data = &dm814_pllss_data },
 	{ .compatible = "ti,dm816-prcm", .data = &am3_prm_data },
 #endif
 #ifdef CONFIG_ARCH_OMAP2

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 257e98c26618..3fc2cbe52113 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -102,7 +102,7 @@ static void omap_prcm_events_filter_priority(unsigned long *events,
  * dispatched accordingly. Clearing of the wakeup events should be
  * done by the SoC specific individual handlers.
  */
-static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
+static void omap_prcm_irq_handler(struct irq_desc *desc)
 {
 	unsigned long pending[OMAP_PRCM_MAX_NR_PENDING_REG];
 	unsigned long priority_pending[OMAP_PRCM_MAX_NR_PENDING_REG];

commit 50686e8a3aed2f5d295e9d2e79ff43df461c7b76
Merge: c5fc249862af 1ec6f701707e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 12:18:40 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "New or improved SoC support:
    
       - add support for Atmel's SAMA5D2 SoC
       - add support for Freescale i.MX6UL
       - improved support for TI's DM814x platform
       - misc fixes and improvements for RockChip platforms
       - Marvell MVEBU suspend/resume support
    
      A few driver changes that ideally would belong in the drivers branch
      are also here (acked by appropriate maintainers):
    
       - power key input driver for Freescale platforms (svns)
       - RTC driver updates for Freescale platforms (svns/mxc)
       - clk fixes for TI DM814/816X
    
      + a bunch of other changes for various platforms"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (83 commits)
      ARM: rockchip: pm: Fix PTR_ERR() argument
      ARM: imx: mach-imx6ul: Fix allmodconfig build
      clk: ti: fix for definition movement
      ARM: uniphier: drop v7_invalidate_l1 call at secondary entry
      memory: kill off set_irq_flags usage
      rtc: snvs: select option REGMAP_MMIO
      ARM: brcmstb: select ARCH_DMA_ADDR_T_64BIT for LPAE
      ARM: BCM: Enable ARM erratum 798181 for BRCMSTB
      ARM: OMAP2+: Fix power domain operations regression caused by 81xx
      ARM: rockchip: enable PMU_GPIOINT_WAKEUP_EN when entering shallow suspend
      ARM: rockchip: set correct stabilization thresholds in suspend
      ARM: rockchip: rename osc_switch_to_32k variable
      ARM: imx6ul: add fec MAC refrence clock and phy fixup init
      ARM: imx6ul: add fec bits to GPR syscon definition
      rtc: mxc: add support of device tree
      dt-binding: document the binding for mxc rtc
      rtc: mxc: use a second rtc clock
      ARM: davinci: cp_intc: use IRQCHIP_SKIP_SET_WAKE instead of irq_set_wake callback
      soc: mediatek: Fix SCPSYS compilation
      ARM: at91/soc: add basic support for new sama5d2 SoC
      ...

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 7add7994dbfc..f62f8326aa5f 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -705,7 +705,7 @@ static struct omap_prcm_init_data scrm_data __initdata = {
 };
 #endif
 
-static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {
+static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
 #ifdef CONFIG_SOC_AM33XX
 	{ .compatible = "ti,am3-prcm", .data = &am3_prm_data },
 #endif

commit 8740a1444ed3696c3418c2e90481e9528bad60fa
Author: Keerthy <j-keerthy@ti.com>
Date:   Thu Jul 16 17:23:19 2015 +0530

    ARM: PRM: AM437x: Enable IO wakeup feature
    
    Enable IO wakeup feature. This enables am437x pads to generate daisy
    chained wake ups(eventually generates aprcm Interrupt) especially
    when in low power modes.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 7add7994dbfc..1730fc494221 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -696,6 +696,7 @@ static struct omap_prcm_init_data am4_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = AM43XX_PRM_DEVICE_INST,
+	.flags = PRM_HAS_IO_WAKEUP,
 };
 #endif
 

commit 80cbb224b789d256ad5cb36b0af3e5c04ed46bca
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 6 16:00:32 2015 +0200

    ARM: OMAP2+: clock: add low-level support for regmap
    
    Some of the TI clock providers will be converted to use syscon, thus
    low-level regmap support is needed for the clock drivers also. This
    patch adds this support, which can be enabled for individual drivers
    in later patches.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6832a31e9a70..7add7994dbfc 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -798,7 +798,7 @@ int __init omap_prcm_init(void)
 	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
 		data = match->data;
 
-		ret = omap2_clk_provider_init(np, data->index, data->mem);
+		ret = omap2_clk_provider_init(np, data->index, NULL, data->mem);
 		if (ret)
 			return ret;
 	}

commit 219595b6ee139d883b98a9a32efbe2970802200a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Sep 8 11:44:10 2014 +0300

    ARM: OMAP4+: PRM: get rid of cpu_is_omap44xx calls from interrupt init
    
    The compatible DT node is now passed with the prm init, so there is no
    need to do node matching here again. Added a new flag to the init data
    also, to detect default IRQ support for OMAP4. Also, any booting omap4
    DT setup always has a PRM node, so there is no need to check against
    the special case where it would be missing.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 04dfe8f844c9..6832a31e9a70 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -669,7 +669,7 @@ static struct omap_prcm_init_data omap4_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = OMAP4430_PRM_DEVICE_INST,
-	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE,
+	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE | PRM_IRQ_DEFAULT,
 };
 #endif
 

commit 8b5b9a22b57c75905b368194b6fd4c472d5dc630
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Nov 21 14:45:29 2014 +0200

    ARM: OMAP4+: PRM: setup prm_features from the PRM init time flags
    
    Currently some cpu_is_X checks are used to setup prm_features, however
    the same can be accomplished by just passing these flags from the PRM
    init data. This is done in preparation to make PRM a separate driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 3e932b8b8ce9..04dfe8f844c9 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -669,6 +669,7 @@ static struct omap_prcm_init_data omap4_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = OMAP4430_PRM_DEVICE_INST,
+	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE,
 };
 #endif
 
@@ -677,6 +678,7 @@ static struct omap_prcm_init_data omap5_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = OMAP54XX_PRM_DEVICE_INST,
+	.flags = PRM_HAS_IO_WAKEUP | PRM_HAS_VOLTAGE,
 };
 #endif
 
@@ -685,6 +687,7 @@ static struct omap_prcm_init_data dra7_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
 	.device_inst_offset = DRA7XX_PRM_DEVICE_INST,
+	.flags = PRM_HAS_IO_WAKEUP,
 };
 #endif
 

commit 425dc8b2dff222ffd88f31f589dc647409cae0ce
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Nov 21 15:51:37 2014 +0200

    ARM: OMAP2+: CM: move SoC specific init calls within a generic API
    
    This gets rid of need for some exported driver APIs, and simplifies the
    initialization of the CM driver. Done in preparation to make CM a
    separate driver. The init data is now also passed to the SoC specific
    implementations, allowing future expansion to add feature flags etc.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index a834124c5309..3e932b8b8ce9 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -770,7 +770,13 @@ int __init omap2_prm_base_init(void)
 
 int __init omap2_prcm_base_init(void)
 {
-	return omap2_prm_base_init();
+	int ret;
+
+	ret = omap2_prm_base_init();
+	if (ret)
+		return ret;
+
+	return omap2_cm_base_init();
 }
 
 /**

commit 48e0c1148d18de677f1b2aec179f36fb7c1e3839
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Sep 8 11:29:43 2014 +0300

    ARM: OMAP4+: PRM: determine prm_device_inst based on DT compatibility
    
    PRM device instance offset is now provided through the prm_init_data.
    This gets rid of some cpu_is_X / soc_is_X calls from PRM core code,
    preparing for PRM to be its own separate driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index aede589822fb..a834124c5309 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -34,6 +34,9 @@
 #include "prm3xxx.h"
 #include "prm33xx.h"
 #include "prm44xx.h"
+#include "prm54xx.h"
+#include "prm7xx.h"
+#include "prcm43xx.h"
 #include "common.h"
 #include "clock.h"
 #include "cm.h"
@@ -661,11 +664,35 @@ static struct omap_prcm_init_data am3_prm_data __initdata = {
 };
 #endif
 
-#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
-	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
+#ifdef CONFIG_ARCH_OMAP4
 static struct omap_prcm_init_data omap4_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
 	.init = omap44xx_prm_init,
+	.device_inst_offset = OMAP4430_PRM_DEVICE_INST,
+};
+#endif
+
+#ifdef CONFIG_SOC_OMAP5
+static struct omap_prcm_init_data omap5_prm_data __initdata = {
+	.index = TI_CLKM_PRM,
+	.init = omap44xx_prm_init,
+	.device_inst_offset = OMAP54XX_PRM_DEVICE_INST,
+};
+#endif
+
+#ifdef CONFIG_SOC_DRA7XX
+static struct omap_prcm_init_data dra7_prm_data __initdata = {
+	.index = TI_CLKM_PRM,
+	.init = omap44xx_prm_init,
+	.device_inst_offset = DRA7XX_PRM_DEVICE_INST,
+};
+#endif
+
+#ifdef CONFIG_SOC_AM43XX
+static struct omap_prcm_init_data am4_prm_data __initdata = {
+	.index = TI_CLKM_PRM,
+	.init = omap44xx_prm_init,
+	.device_inst_offset = AM43XX_PRM_DEVICE_INST,
 };
 #endif
 
@@ -680,7 +707,7 @@ static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {
 	{ .compatible = "ti,am3-prcm", .data = &am3_prm_data },
 #endif
 #ifdef CONFIG_SOC_AM43XX
-	{ .compatible = "ti,am4-prcm", .data = &omap4_prm_data },
+	{ .compatible = "ti,am4-prcm", .data = &am4_prm_data },
 #endif
 #ifdef CONFIG_SOC_TI81XX
 	{ .compatible = "ti,dm814-prcm", .data = &am3_prm_data },
@@ -697,11 +724,11 @@ static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {
 	{ .compatible = "ti,omap4-scrm", .data = &scrm_data },
 #endif
 #ifdef CONFIG_SOC_OMAP5
-	{ .compatible = "ti,omap5-prm", .data = &omap4_prm_data },
+	{ .compatible = "ti,omap5-prm", .data = &omap5_prm_data },
 	{ .compatible = "ti,omap5-scrm", .data = &scrm_data },
 #endif
 #ifdef CONFIG_SOC_DRA7XX
-	{ .compatible = "ti,dra7-prm", .data = &omap4_prm_data },
+	{ .compatible = "ti,dra7-prm", .data = &dra7_prm_data },
 #endif
 	{ }
 };

commit ab7b2ffcf576a49b51c240dcd68ca4b7cd60b84d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Nov 20 15:02:59 2014 +0200

    ARM: OMAP2+: PRM: move SoC specific init calls within a generic API
    
    This gets rid of need for some exported driver APIs, and simplifies the
    initialization of the PRM driver. Done in preparation to make PRM a
    separate driver. The init data is now also passed to the SoC specific
    implementations, allowing future expansion to add feature flags etc.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index a943e1447536..aede589822fb 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -32,6 +32,7 @@
 #include "prm2xxx_3xxx.h"
 #include "prm2xxx.h"
 #include "prm3xxx.h"
+#include "prm33xx.h"
 #include "prm44xx.h"
 #include "common.h"
 #include "clock.h"
@@ -633,12 +634,17 @@ int prm_unregister(struct prm_ll_data *pld)
 	return 0;
 }
 
-static struct omap_prcm_init_data prm_data = {
+#ifdef CONFIG_ARCH_OMAP2
+static struct omap_prcm_init_data omap2_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
+	.init = omap2xxx_prm_init,
 };
+#endif
 
-static struct omap_prcm_init_data omap3_prm_data = {
+#ifdef CONFIG_ARCH_OMAP3
+static struct omap_prcm_init_data omap3_prm_data __initdata = {
 	.index = TI_CLKM_PRM,
+	.init = omap3xxx_prm_init,
 
 	/*
 	 * IVA2 offset is a negative value, must offset the prm_base
@@ -646,23 +652,57 @@ static struct omap_prcm_init_data omap3_prm_data = {
 	 */
 	.offset = -OMAP3430_IVA2_MOD,
 };
+#endif
 
-static struct omap_prcm_init_data scrm_data = {
-	.index = TI_CLKM_SCRM,
+#if defined(CONFIG_SOC_AM33XX) || defined(CONFIG_SOC_TI81XX)
+static struct omap_prcm_init_data am3_prm_data __initdata = {
+	.index = TI_CLKM_PRM,
+	.init = am33xx_prm_init,
+};
+#endif
+
+#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \
+	defined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM43XX)
+static struct omap_prcm_init_data omap4_prm_data __initdata = {
+	.index = TI_CLKM_PRM,
+	.init = omap44xx_prm_init,
 };
+#endif
 
-static const struct of_device_id omap_prcm_dt_match_table[] = {
-	{ .compatible = "ti,am3-prcm", .data = &prm_data },
-	{ .compatible = "ti,am4-prcm", .data = &prm_data },
-	{ .compatible = "ti,dm814-prcm", .data = &prm_data },
-	{ .compatible = "ti,dm816-prcm", .data = &prm_data },
-	{ .compatible = "ti,omap2-prcm", .data = &prm_data },
+#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5)
+static struct omap_prcm_init_data scrm_data __initdata = {
+	.index = TI_CLKM_SCRM,
+};
+#endif
+
+static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {
+#ifdef CONFIG_SOC_AM33XX
+	{ .compatible = "ti,am3-prcm", .data = &am3_prm_data },
+#endif
+#ifdef CONFIG_SOC_AM43XX
+	{ .compatible = "ti,am4-prcm", .data = &omap4_prm_data },
+#endif
+#ifdef CONFIG_SOC_TI81XX
+	{ .compatible = "ti,dm814-prcm", .data = &am3_prm_data },
+	{ .compatible = "ti,dm816-prcm", .data = &am3_prm_data },
+#endif
+#ifdef CONFIG_ARCH_OMAP2
+	{ .compatible = "ti,omap2-prcm", .data = &omap2_prm_data },
+#endif
+#ifdef CONFIG_ARCH_OMAP3
 	{ .compatible = "ti,omap3-prm", .data = &omap3_prm_data },
-	{ .compatible = "ti,omap4-prm", .data = &prm_data },
+#endif
+#ifdef CONFIG_ARCH_OMAP4
+	{ .compatible = "ti,omap4-prm", .data = &omap4_prm_data },
 	{ .compatible = "ti,omap4-scrm", .data = &scrm_data },
-	{ .compatible = "ti,omap5-prm", .data = &prm_data },
+#endif
+#ifdef CONFIG_SOC_OMAP5
+	{ .compatible = "ti,omap5-prm", .data = &omap4_prm_data },
 	{ .compatible = "ti,omap5-scrm", .data = &scrm_data },
-	{ .compatible = "ti,dra7-prm", .data = &prm_data },
+#endif
+#ifdef CONFIG_SOC_DRA7XX
+	{ .compatible = "ti,dra7-prm", .data = &omap4_prm_data },
+#endif
 	{ }
 };
 
@@ -691,11 +731,21 @@ int __init omap2_prm_base_init(void)
 			prm_base = mem + data->offset;
 
 		data->mem = mem;
+
+		data->np = np;
+
+		if (data->init)
+			data->init(data);
 	}
 
 	return 0;
 }
 
+int __init omap2_prcm_base_init(void)
+{
+	return omap2_prm_base_init();
+}
+
 /**
  * omap_prcm_init - low level init for the PRCM drivers
  *

commit 2208bf115fecae211480ea41d25e6d56ec20d405
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Nov 13 19:17:34 2014 +0200

    ARM: OMAP2+: control: determine control module base address from DT
    
    There is no need to provide the control module base address through a
    low-level API from the low-level IO init, as this information is
    available through DT. This patch adds a new API to initialize the
    control module though, but mostly makes the old API obsolete. The
    old API can be completely removed once OMAP3 is made DT only.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index b23d2327bafe..a943e1447536 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -722,11 +722,6 @@ int __init omap_prcm_init(void)
 	return 0;
 }
 
-void __init omap3_prcm_legacy_iomaps_init(void)
-{
-	omap2_clk_legacy_provider_init(TI_CLKM_SCRM, omap_ctrl_base_get());
-}
-
 static int __init prm_late_init(void)
 {
 	if (prm_ll_data->late_init)

commit ae521d4d9c54995df1e0fb53ef6820374a3cae4e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Nov 11 17:17:18 2014 +0200

    ARM: OMAP2+: PRM: determine PRM base address from device tree
    
    There is no need to provide the PRM base address through a low-level API
    from the low-level IO init, as this information is available through DT.
    Re-routed the parsing function to be called from the PRM drivers also to
    simplify the implementation under io.c.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 9f9c816ef59f..b23d2327bafe 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -637,6 +637,16 @@ static struct omap_prcm_init_data prm_data = {
 	.index = TI_CLKM_PRM,
 };
 
+static struct omap_prcm_init_data omap3_prm_data = {
+	.index = TI_CLKM_PRM,
+
+	/*
+	 * IVA2 offset is a negative value, must offset the prm_base
+	 * address by this to get it to positive
+	 */
+	.offset = -OMAP3430_IVA2_MOD,
+};
+
 static struct omap_prcm_init_data scrm_data = {
 	.index = TI_CLKM_SCRM,
 };
@@ -647,7 +657,7 @@ static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ .compatible = "ti,dm814-prcm", .data = &prm_data },
 	{ .compatible = "ti,dm816-prcm", .data = &prm_data },
 	{ .compatible = "ti,omap2-prcm", .data = &prm_data },
-	{ .compatible = "ti,omap3-prm", .data = &prm_data },
+	{ .compatible = "ti,omap3-prm", .data = &omap3_prm_data },
 	{ .compatible = "ti,omap4-prm", .data = &prm_data },
 	{ .compatible = "ti,omap4-scrm", .data = &scrm_data },
 	{ .compatible = "ti,omap5-prm", .data = &prm_data },
@@ -656,6 +666,36 @@ static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ }
 };
 
+/**
+ * omap2_prm_base_init - initialize iomappings for the PRM driver
+ *
+ * Detects and initializes the iomappings for the PRM driver, based
+ * on the DT data. Returns 0 in success, negative error value
+ * otherwise.
+ */
+int __init omap2_prm_base_init(void)
+{
+	struct device_node *np;
+	const struct of_device_id *match;
+	struct omap_prcm_init_data *data;
+	void __iomem *mem;
+
+	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
+		data = (struct omap_prcm_init_data *)match->data;
+
+		mem = of_iomap(np, 0);
+		if (!mem)
+			return -ENOMEM;
+
+		if (data->index == TI_CLKM_PRM)
+			prm_base = mem + data->offset;
+
+		data->mem = mem;
+	}
+
+	return 0;
+}
+
 /**
  * omap_prcm_init - low level init for the PRCM drivers
  *
@@ -665,7 +705,6 @@ static const struct of_device_id omap_prcm_dt_match_table[] = {
 int __init omap_prcm_init(void)
 {
 	struct device_node *np;
-	void __iomem *mem;
 	const struct of_device_id *match;
 	const struct omap_prcm_init_data *data;
 	int ret;
@@ -673,11 +712,7 @@ int __init omap_prcm_init(void)
 	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
 		data = match->data;
 
-		mem = of_iomap(np, 0);
-		if (!mem)
-			return -ENOMEM;
-
-		ret = omap2_clk_provider_init(np, data->index, mem);
+		ret = omap2_clk_provider_init(np, data->index, data->mem);
 		if (ret)
 			return ret;
 	}
@@ -689,8 +724,6 @@ int __init omap_prcm_init(void)
 
 void __init omap3_prcm_legacy_iomaps_init(void)
 {
-	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
-				       prm_base + OMAP3430_IVA2_MOD);
 	omap2_clk_legacy_provider_init(TI_CLKM_SCRM, omap_ctrl_base_get());
 }
 

commit 5970ca2db960b2c14e077d27950e402e063298e6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Nov 11 16:51:52 2014 +0200

    ARM: OMAP2+: CM: determine CM base address from device tree
    
    There is no need to provide the CM base address through a low-level API
    from the low-level IO init, as this information is available through DT.
    Re-routed the parsing function to be called from the CM drivers also to
    simplify the implementation under io.c.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6cbebbe252c4..9f9c816ef59f 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -689,7 +689,6 @@ int __init omap_prcm_init(void)
 
 void __init omap3_prcm_legacy_iomaps_init(void)
 {
-	omap2_clk_legacy_provider_init(TI_CLKM_CM, cm_base + OMAP3430_IVA2_MOD);
 	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
 				       prm_base + OMAP3430_IVA2_MOD);
 	omap2_clk_legacy_provider_init(TI_CLKM_SCRM, omap_ctrl_base_get());

commit fe87414f71d0035756cf91a80ac256557d16b488
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Mar 12 18:33:45 2014 +0200

    ARM: OMAP2+: PRCM: split PRCM module init to their own driver files
    
    Splits the clock related provider module inits under their own driver files.
    Previously this was done for all modules under the common PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 1bfd00e10f76..6cbebbe252c4 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -637,43 +637,22 @@ static struct omap_prcm_init_data prm_data = {
 	.index = TI_CLKM_PRM,
 };
 
-static struct omap_prcm_init_data cm_data = {
-	.index = TI_CLKM_CM,
-};
-
-static struct omap_prcm_init_data cm2_data = {
-	.index = TI_CLKM_CM2,
-};
-
 static struct omap_prcm_init_data scrm_data = {
 	.index = TI_CLKM_SCRM,
 };
 
 static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ .compatible = "ti,am3-prcm", .data = &prm_data },
-	{ .compatible = "ti,am3-scrm", .data = &scrm_data },
 	{ .compatible = "ti,am4-prcm", .data = &prm_data },
-	{ .compatible = "ti,am4-scrm", .data = &scrm_data },
 	{ .compatible = "ti,dm814-prcm", .data = &prm_data },
-	{ .compatible = "ti,dm814-scrm", .data = &scrm_data },
 	{ .compatible = "ti,dm816-prcm", .data = &prm_data },
-	{ .compatible = "ti,dm816-scrm", .data = &scrm_data },
 	{ .compatible = "ti,omap2-prcm", .data = &prm_data },
-	{ .compatible = "ti,omap2-scrm", .data = &scrm_data },
 	{ .compatible = "ti,omap3-prm", .data = &prm_data },
-	{ .compatible = "ti,omap3-cm", .data = &cm_data },
-	{ .compatible = "ti,omap3-scrm", .data = &scrm_data },
-	{ .compatible = "ti,omap4-cm1", .data = &cm_data },
 	{ .compatible = "ti,omap4-prm", .data = &prm_data },
-	{ .compatible = "ti,omap4-cm2", .data = &cm2_data },
 	{ .compatible = "ti,omap4-scrm", .data = &scrm_data },
 	{ .compatible = "ti,omap5-prm", .data = &prm_data },
-	{ .compatible = "ti,omap5-cm-core-aon", .data = &cm_data },
 	{ .compatible = "ti,omap5-scrm", .data = &scrm_data },
-	{ .compatible = "ti,omap5-cm-core", .data = &cm2_data },
 	{ .compatible = "ti,dra7-prm", .data = &prm_data },
-	{ .compatible = "ti,dra7-cm-core-aon", .data = &cm_data },
-	{ .compatible = "ti,dra7-cm-core", .data = &cm2_data },
 	{ }
 };
 
@@ -703,6 +682,8 @@ int __init omap_prcm_init(void)
 			return ret;
 	}
 
+	omap_cm_init();
+
 	return 0;
 }
 

commit 9f029b1579b2dfe291006e5bfe8e7d0c4ef20828
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Oct 22 15:15:36 2014 +0300

    ARM: OMAP2+: clock: move clock provider infrastructure to clock driver
    
    Splits the clock provider init out of the PRM driver and moves it to
    clock driver. This is needed so that once the PRCM drivers are separated,
    they can logically just access the clock driver not needing to go through
    common PRM code. This would be wrong in the case of control module for
    example.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 8ec52012f85d..1bfd00e10f76 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -677,25 +677,6 @@ static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ }
 };
 
-static struct clk_hw_omap memmap_dummy_ck = {
-	.flags = MEMMAP_ADDRESSING,
-};
-
-static u32 prm_clk_readl(void __iomem *reg)
-{
-	return omap2_clk_readl(&memmap_dummy_ck, reg);
-}
-
-static void prm_clk_writel(u32 val, void __iomem *reg)
-{
-	omap2_clk_writel(val, &memmap_dummy_ck, reg);
-}
-
-static struct ti_clk_ll_ops omap_clk_ll_ops = {
-	.clk_readl = prm_clk_readl,
-	.clk_writel = prm_clk_writel,
-};
-
 /**
  * omap_prcm_init - low level init for the PRCM drivers
  *
@@ -708,8 +689,7 @@ int __init omap_prcm_init(void)
 	void __iomem *mem;
 	const struct of_device_id *match;
 	const struct omap_prcm_init_data *data;
-
-	ti_clk_ll_ops = &omap_clk_ll_ops;
+	int ret;
 
 	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
 		data = match->data;
@@ -718,8 +698,9 @@ int __init omap_prcm_init(void)
 		if (!mem)
 			return -ENOMEM;
 
-		clk_memmaps[data->index] = mem;
-		ti_dt_clk_init_provider(np, data->index);
+		ret = omap2_clk_provider_init(np, data->index, mem);
+		if (ret)
+			return ret;
 	}
 
 	return 0;
@@ -727,11 +708,10 @@ int __init omap_prcm_init(void)
 
 void __init omap3_prcm_legacy_iomaps_init(void)
 {
-	ti_clk_ll_ops = &omap_clk_ll_ops;
-
-	clk_memmaps[TI_CLKM_CM] = cm_base + OMAP3430_IVA2_MOD;
-	clk_memmaps[TI_CLKM_PRM] = prm_base + OMAP3430_IVA2_MOD;
-	clk_memmaps[TI_CLKM_SCRM] = omap_ctrl_base_get();
+	omap2_clk_legacy_provider_init(TI_CLKM_CM, cm_base + OMAP3430_IVA2_MOD);
+	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
+				       prm_base + OMAP3430_IVA2_MOD);
+	omap2_clk_legacy_provider_init(TI_CLKM_SCRM, omap_ctrl_base_get());
 }
 
 static int __init prm_late_init(void)

commit 3a3e1c88362429ca3a6ef84d232e56b197294ce0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Feb 23 15:57:32 2015 +0200

    ARM: OMAP2+: PRCM: add support for static clock memmap indices
    
    All clock provider related drivers will now register their iomaps
    with a static index. This makes it easier to split up the individual
    drivers to their own files in subsequent patches.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 79cee117f971..8ec52012f85d 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -633,31 +633,47 @@ int prm_unregister(struct prm_ll_data *pld)
 	return 0;
 }
 
+static struct omap_prcm_init_data prm_data = {
+	.index = TI_CLKM_PRM,
+};
+
+static struct omap_prcm_init_data cm_data = {
+	.index = TI_CLKM_CM,
+};
+
+static struct omap_prcm_init_data cm2_data = {
+	.index = TI_CLKM_CM2,
+};
+
+static struct omap_prcm_init_data scrm_data = {
+	.index = TI_CLKM_SCRM,
+};
+
 static const struct of_device_id omap_prcm_dt_match_table[] = {
-	{ .compatible = "ti,am3-prcm" },
-	{ .compatible = "ti,am3-scrm" },
-	{ .compatible = "ti,am4-prcm" },
-	{ .compatible = "ti,am4-scrm" },
-	{ .compatible = "ti,dm814-prcm" },
-	{ .compatible = "ti,dm814-scrm" },
-	{ .compatible = "ti,dm816-prcm" },
-	{ .compatible = "ti,dm816-scrm" },
-	{ .compatible = "ti,omap2-prcm" },
-	{ .compatible = "ti,omap2-scrm" },
-	{ .compatible = "ti,omap3-prm" },
-	{ .compatible = "ti,omap3-cm" },
-	{ .compatible = "ti,omap3-scrm" },
-	{ .compatible = "ti,omap4-cm1" },
-	{ .compatible = "ti,omap4-prm" },
-	{ .compatible = "ti,omap4-cm2" },
-	{ .compatible = "ti,omap4-scrm" },
-	{ .compatible = "ti,omap5-prm" },
-	{ .compatible = "ti,omap5-cm-core-aon" },
-	{ .compatible = "ti,omap5-scrm" },
-	{ .compatible = "ti,omap5-cm-core" },
-	{ .compatible = "ti,dra7-prm" },
-	{ .compatible = "ti,dra7-cm-core-aon" },
-	{ .compatible = "ti,dra7-cm-core" },
+	{ .compatible = "ti,am3-prcm", .data = &prm_data },
+	{ .compatible = "ti,am3-scrm", .data = &scrm_data },
+	{ .compatible = "ti,am4-prcm", .data = &prm_data },
+	{ .compatible = "ti,am4-scrm", .data = &scrm_data },
+	{ .compatible = "ti,dm814-prcm", .data = &prm_data },
+	{ .compatible = "ti,dm814-scrm", .data = &scrm_data },
+	{ .compatible = "ti,dm816-prcm", .data = &prm_data },
+	{ .compatible = "ti,dm816-scrm", .data = &scrm_data },
+	{ .compatible = "ti,omap2-prcm", .data = &prm_data },
+	{ .compatible = "ti,omap2-scrm", .data = &scrm_data },
+	{ .compatible = "ti,omap3-prm", .data = &prm_data },
+	{ .compatible = "ti,omap3-cm", .data = &cm_data },
+	{ .compatible = "ti,omap3-scrm", .data = &scrm_data },
+	{ .compatible = "ti,omap4-cm1", .data = &cm_data },
+	{ .compatible = "ti,omap4-prm", .data = &prm_data },
+	{ .compatible = "ti,omap4-cm2", .data = &cm2_data },
+	{ .compatible = "ti,omap4-scrm", .data = &scrm_data },
+	{ .compatible = "ti,omap5-prm", .data = &prm_data },
+	{ .compatible = "ti,omap5-cm-core-aon", .data = &cm_data },
+	{ .compatible = "ti,omap5-scrm", .data = &scrm_data },
+	{ .compatible = "ti,omap5-cm-core", .data = &cm2_data },
+	{ .compatible = "ti,dra7-prm", .data = &prm_data },
+	{ .compatible = "ti,dra7-cm-core-aon", .data = &cm_data },
+	{ .compatible = "ti,dra7-cm-core", .data = &cm2_data },
 	{ }
 };
 
@@ -690,15 +706,20 @@ int __init omap_prcm_init(void)
 {
 	struct device_node *np;
 	void __iomem *mem;
-	int memmap_index = 0;
+	const struct of_device_id *match;
+	const struct omap_prcm_init_data *data;
 
 	ti_clk_ll_ops = &omap_clk_ll_ops;
 
-	for_each_matching_node(np, omap_prcm_dt_match_table) {
+	for_each_matching_node_and_match(np, omap_prcm_dt_match_table, &match) {
+		data = match->data;
+
 		mem = of_iomap(np, 0);
-		clk_memmaps[memmap_index] = mem;
-		ti_dt_clk_init_provider(np, memmap_index);
-		memmap_index++;
+		if (!mem)
+			return -ENOMEM;
+
+		clk_memmaps[data->index] = mem;
+		ti_dt_clk_init_provider(np, data->index);
 	}
 
 	return 0;

commit e9f1ddcdec54d32892a0a749de017a39c6c84beb
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 15:52:01 2014 +0300

    ARM: OMAP3+: PRM: add common APIs for prm_vp_check/clear_txdone
    
    PRM driver now only exports a generic API for clearing / checking
    VP txdone status.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 2c2e7ed1bc6c..79cee117f971 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -554,6 +554,40 @@ int omap_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)
 	return prm_ll_data->clear_mod_irqs(module, regs, wkst_mask);
 }
 
+/**
+ * omap_prm_vp_check_txdone - check voltage processor TX done status
+ *
+ * Checks if voltage processor transmission has been completed.
+ * Returns non-zero if a transmission has completed, 0 otherwise.
+ */
+u32 omap_prm_vp_check_txdone(u8 vp_id)
+{
+	if (!prm_ll_data->vp_check_txdone) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return 0;
+	}
+
+	return prm_ll_data->vp_check_txdone(vp_id);
+}
+
+/**
+ * omap_prm_vp_clear_txdone - clears voltage processor TX done status
+ *
+ * Clears the status bit for completed voltage processor transmission
+ * returned by prm_vp_check_txdone.
+ */
+void omap_prm_vp_clear_txdone(u8 vp_id)
+{
+	if (!prm_ll_data->vp_clear_txdone) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return;
+	}
+
+	prm_ll_data->vp_clear_txdone(vp_id);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit 9cb6d36371b0a9935de92bf250c7152f5b50fdc1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:31:51 2014 +0300

    ARM: OMAP2+: PRM: add generic API for clear_mod_irqs
    
    OMAP2/3 now use generic API for the prm_clear_mod_irqs, the SoC specific
    implementation details are provided through prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index c5cfaa98be9e..2c2e7ed1bc6c 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -533,6 +533,27 @@ void omap_prm_reset_system(void)
 		cpu_relax();
 }
 
+/**
+ * omap_prm_clear_mod_irqs - clear wake-up events from PRCM interrupt
+ * @module: PRM module to clear wakeups from
+ * @regs: register to clear
+ * @wkst_mask: wkst bits to clear
+ *
+ * Clears any wakeup events for the module and register set defined.
+ * Uses SoC specific implementation to do the actual wakeup status
+ * clearing.
+ */
+int omap_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)
+{
+	if (!prm_ll_data->clear_mod_irqs) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return -EINVAL;
+	}
+
+	return prm_ll_data->clear_mod_irqs(module, regs, wkst_mask);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit 3a1a388e910950553817b71046b00511d6242b06
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Nov 18 14:59:36 2014 +0200

    ARM: OMAP2+: PRCM: rename of_prcm_init to omap_prcm_init
    
    This avoids conflicts in the global namespace, and is more descriptive
    of the purpose anyway.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index bfaa7ba595cc..c5cfaa98be9e 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -625,7 +625,13 @@ static struct ti_clk_ll_ops omap_clk_ll_ops = {
 	.clk_writel = prm_clk_writel,
 };
 
-int __init of_prcm_init(void)
+/**
+ * omap_prcm_init - low level init for the PRCM drivers
+ *
+ * Initializes the low level clock infrastructure for PRCM drivers.
+ * Returns 0 in success, negative error value in failure.
+ */
+int __init omap_prcm_init(void)
 {
 	struct device_node *np;
 	void __iomem *mem;

commit 18a8d49973667aa016e68826eeb374788b7c63b0
Merge: c189cb8ef628 ec02ace8ca0a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 21 12:30:30 2015 -0800

    Merge tag 'clk-for-linus-3.20' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull clock framework updates from Mike Turquette:
     "The clock framework changes contain the usual driver additions,
      enhancements and fixes mostly for ARM32, ARM64, MIPS and Power-based
      devices.
    
      Additionally the framework core underwent a bit of surgery with two
      major changes:
    
       - The boundary between the clock core and clock providers (e.g clock
         drivers) is now more well defined with dedicated provider helper
         functions.  struct clk no longer maps 1:1 with the hardware clock
         but is a true per-user cookie which helps us tracker users of
         hardware clocks and debug bad behavior.
    
       - The addition of rate constraints for clocks.  Rate ranges are now
         supported which are analogous to the voltage ranges in the
         regulator framework.
    
      Unfortunately these changes to the core created some breakeage.  We
      think we fixed it all up but for this reason there are lots of last
      minute commits trying to undo the damage"
    
    * tag 'clk-for-linus-3.20' of git://git.linaro.org/people/mike.turquette/linux: (113 commits)
      clk: Only recalculate the rate if needed
      Revert "clk: mxs: Fix invalid 32-bit access to frac registers"
      clk: qoriq: Add support for the platform PLL
      powerpc/corenet: Enable CLK_QORIQ
      clk: Replace explicit clk assignment with __clk_hw_set_clk
      clk: Add __clk_hw_set_clk helper function
      clk: Don't dereference parent clock if is NULL
      MIPS: Alchemy: Remove bogus args from alchemy_clk_fgcs_detr
      clkdev: Always allocate a struct clk and call __clk_get() w/ CCF
      clk: shmobile: div6: Avoid division by zero in .round_rate()
      clk: mxs: Fix invalid 32-bit access to frac registers
      clk: omap: compile legacy omap3 clocks conditionally
      clkdev: Export clk_register_clkdev
      clk: Add rate constraints to clocks
      clk: remove clk-private.h
      pci: xgene: do not use clk-private.h
      arm: omap2+ remove dead clock code
      clk: Make clk API return per-user struct clk instances
      clk: tegra: Define PLLD_DSI and remove dsia(b)_mux
      clk: tegra: Add support for the Tegra132 CAR IP block
      ...

commit 4025fa97ff39db054b47b9cdb9f3980480637668
Merge: c397f8fa4379 11fe05de8b73
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:15:46 2015 -0800

    Merge tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical fixes from Olof Johansson:
     "Here's a small collection of fixes accrued during the last release
      that weren't considered severe enough to merge during the -rc series.
    
      A few of these are around resurrecting TI81xx support that's been
      broken for quite a while, the rest are smaller fixes -- most for PXA
      but a few across the board.
    
      There are also some updates to MAINTAINERS here, in particular for
      Broadcom platforms"
    
    * tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (23 commits)
      MAINTAINERS: fix git repositories for Broadcom SoCs
      ARM: pxa: fix broken isa interrupts for zeus and viper
      ARM: DRA7: hwmod: Fix boot crash with DEBUG_LL enabled on UART3
      ARM: OMAP: DRA7: hwmod: Make gpmc software supervised as the smart idle is broken
      ARM: AM43xx: hwmod: set DSS submodule parent hwmods
      ARM: OMAP2+: hwmod: print error if wait_target_ready() failed
      MAINTAINERS: add maintainer for OMAP hwmod data
      ARM: OMAP2+: Disable omap3 PM init for ti81xx
      ARM: OMAP2+: Fix reboot for 81xx
      ARM: OMAP2+: Fix dm814 and dm816 for clocks and timer init
      ARM: OMAP2+: Fix ti81xx class type
      ARM: OMAP2+: Fix ti81xx devtype
      ARM: OMAP2+: Fix error handling for omap2_clk_enable_init_clocks
      MAINTAINERS: add a git entry for BMIPS-based BCM7xxx SoCs
      MAINTAINERS: add a git entry for BCM7xxx ARM-based SoCs
      MAINTAINERS: update Broadcom Cygnus SoC git tree
      MAINTAINERS: move BCM63xx ARM-based SoCs git tree
      hx4700: regulator: declare full constraints
      ARM: pxa: add regulator_has_full_constraints to spitz board file
      ARM: pxa: add regulator_has_full_constraints to poodle board file
      ...

commit 54eea32f7ed3037c91853924227585b65df909a8
Merge: e36f014edff7 b530e7d2108a
Author: Michael Turquette <mturquette@linaro.org>
Date:   Mon Feb 2 14:59:38 2015 -0800

    Merge branch 'clk-next' into v3.19-rc7

commit 3dbb048b7c49d1b9030c34c62410c1c5fcf4c4b4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:54 2014 +0200

    ARM: OMAP3: PRM: add support for legacy iomapping init
    
    As the legacy clock data is being moved under clock driver, the
    clock data will be using the same low level infrastructure for
    register accesses. This requires the clk_memmaps to be initialized
    properly. This patch adds a support hook to the PRM driver to
    initialize the mappings.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 779940cb6e56..542dd9dbd035 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -35,6 +35,8 @@
 #include "prm44xx.h"
 #include "common.h"
 #include "clock.h"
+#include "cm.h"
+#include "control.h"
 
 /*
  * OMAP_PRCM_MAX_NR_PENDING_REG: maximum number of PRM_IRQ*_MPU regs
@@ -627,6 +629,15 @@ int __init of_prcm_init(void)
 	return 0;
 }
 
+void __init omap3_prcm_legacy_iomaps_init(void)
+{
+	ti_clk_ll_ops = &omap_clk_ll_ops;
+
+	clk_memmaps[TI_CLKM_CM] = cm_base + OMAP3430_IVA2_MOD;
+	clk_memmaps[TI_CLKM_PRM] = prm_base + OMAP3430_IVA2_MOD;
+	clk_memmaps[TI_CLKM_SCRM] = omap_ctrl_base_get();
+}
+
 static int __init prm_late_init(void)
 {
 	if (prm_ll_data->late_init)

commit 0fb22a8fb7f3bc1b00a36d4a97ce4f93191f7559
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Sat Jan 17 10:21:08 2015 +0000

    ARM: OMAP: Work around hardcoded interrupts
    
    Commit 9a1091ef0017 ("irqchip: gic: Support hierarchy irq domain")
    changed the GIC driver to use a non-legacy IRQ domain on DT
    platforms. This patch assumes that DT-driven systems are getting
    all of their interrupts from device tree.
    
    Turns out that OMAP has quite a few hidden gems, and still uses
    hardcoded interrupts despite having fairly complete DTs.
    
    This patch attempts to work around these by offering a translation
    method that can be called directly from the hwmod code, if present.
    The same hack is sprinkled over PRCM and TWL.
    
    It isn't pretty, but it seems to do the job without having to add
    more hacks to the interrupt controller code.
    
    Tested on OMAP4 (Panda-ES) and OMAP5 (UEVM5432).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    [tony@atomide.com: updated to fix make randconfig issue]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 779940cb6e56..dea2833ca627 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -187,6 +187,7 @@ int omap_prcm_event_to_irq(const char *name)
  */
 void omap_prcm_irq_cleanup(void)
 {
+	unsigned int irq;
 	int i;
 
 	if (!prcm_irq_setup) {
@@ -211,7 +212,11 @@ void omap_prcm_irq_cleanup(void)
 	kfree(prcm_irq_setup->priority_mask);
 	prcm_irq_setup->priority_mask = NULL;
 
-	irq_set_chained_handler(prcm_irq_setup->irq, NULL);
+	if (prcm_irq_setup->xlate_irq)
+		irq = prcm_irq_setup->xlate_irq(prcm_irq_setup->irq);
+	else
+		irq = prcm_irq_setup->irq;
+	irq_set_chained_handler(irq, NULL);
 
 	if (prcm_irq_setup->base_irq > 0)
 		irq_free_descs(prcm_irq_setup->base_irq,
@@ -259,6 +264,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	int offset, i;
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
+	unsigned int irq;
 
 	if (!irq_setup)
 		return -EINVAL;
@@ -298,7 +304,11 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 				1 << (offset & 0x1f);
 	}
 
-	irq_set_chained_handler(irq_setup->irq, omap_prcm_irq_handler);
+	if (irq_setup->xlate_irq)
+		irq = irq_setup->xlate_irq(irq_setup->irq);
+	else
+		irq = irq_setup->irq;
+	irq_set_chained_handler(irq, omap_prcm_irq_handler);
 
 	irq_setup->base_irq = irq_alloc_descs(-1, 0, irq_setup->nr_regs * 32,
 		0);

commit 132754e483d55309ddd714a2c44580379e4ac55a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 14 17:37:16 2015 -0800

    ARM: OMAP2+: Fix dm814 and dm816 for clocks and timer init
    
    Fix dm814 and dm816 clocks and timer init.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 779940cb6e56..b6587854bca5 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -571,6 +571,10 @@ static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scrm" },
 	{ .compatible = "ti,am4-prcm" },
 	{ .compatible = "ti,am4-scrm" },
+	{ .compatible = "ti,dm814-prcm" },
+	{ .compatible = "ti,dm814-scrm" },
+	{ .compatible = "ti,dm816-prcm" },
+	{ .compatible = "ti,dm816-scrm" },
 	{ .compatible = "ti,omap2-prcm" },
 	{ .compatible = "ti,omap2-scrm" },
 	{ .compatible = "ti,omap3-prm" },

commit 61c8621e2bd14faad9b89ab2284955b28000bcd5
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP2+: PRM: provide generic API for system reset
    
    This patch combines the various prm_warm_reset calls under a common
    API prm_reset_system, and adds the SoC specific implementation under
    prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index be40824acf5f..779940cb6e56 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -502,6 +502,25 @@ void omap_prm_reconfigure_io_chain(void)
 	prcm_irq_setup->reconfigure_io_chain();
 }
 
+/**
+ * omap_prm_reset_system - trigger global SW reset
+ *
+ * Triggers SoC specific global warm reset to reboot the device.
+ */
+void omap_prm_reset_system(void)
+{
+	if (!prm_ll_data->reset_system) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return;
+	}
+
+	prm_ll_data->reset_system();
+
+	while (1)
+		cpu_relax();
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit 4984eeaf71f033d1ca6b644e4fcdef4b3e6a97b4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP3+: PRM: add generic API for reconfiguring I/O chain
    
    This adds a generic API for reconfiguring the I/O chain. The implementation
    will call the SoC specific function registered during init time. The SoC
    specific reconfigure functions are also made static, as they don't need
    to be accessed outside the PRM driver itself.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    [tony@atomide.com: updated for recent omap3 prcm fixes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index ce0434a16ad6..be40824acf5f 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -486,6 +486,22 @@ int omap_prm_is_hardreset_asserted(u8 shift, u8 part, s16 prm_mod, u16 offset)
 	return prm_ll_data->is_hardreset_asserted(shift, part, prm_mod, offset);
 }
 
+/**
+ * omap_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
+ *
+ * Clear any previously-latched I/O wakeup events and ensure that the
+ * I/O wakeup gates are aligned with the current mux settings.
+ * Calls SoC specific I/O chain reconfigure function if available,
+ * otherwise does nothing.
+ */
+void omap_prm_reconfigure_io_chain(void)
+{
+	if (!prcm_irq_setup || !prcm_irq_setup->reconfigure_io_chain)
+		return;
+
+	prcm_irq_setup->reconfigure_io_chain();
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit 1bc28b3472dc44e6282b464fdb851adcea859be7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for checking hardreset status
    
    PRM driver now has a generic API for checking hardreset status. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 912d99c4d75d..ce0434a16ad6 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -466,6 +466,26 @@ int omap_prm_deassert_hardreset(u8 shift, u8 st_shift, u8 part, s16 prm_mod,
 					       offset, st_offset);
 }
 
+/**
+ * omap_prm_is_hardreset_asserted - check the hardreset status for an IP block
+ * @shift: register bit shift corresponding to the reset line
+ * @part: PRM partition
+ * @prm_mod: PRM submodule base or instance offset
+ * @offset: register offset
+ *
+ * Checks if a hardware reset line for an IP block is enabled or not.
+ */
+int omap_prm_is_hardreset_asserted(u8 shift, u8 part, s16 prm_mod, u16 offset)
+{
+	if (!prm_ll_data->is_hardreset_asserted) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return -EINVAL;
+	}
+
+	return prm_ll_data->is_hardreset_asserted(shift, part, prm_mod, offset);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit 37fb59d7e0b471f3aacd26bfdbb64a4dc71f189b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for deasserting hardware reset
    
    PRM driver now has a generic API for deasserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 4f8c22075d39..912d99c4d75d 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -442,6 +442,30 @@ int omap_prm_assert_hardreset(u8 shift, u8 part, s16 prm_mod, u16 offset)
 	return prm_ll_data->assert_hardreset(shift, part, prm_mod, offset);
 }
 
+/**
+ * omap_prm_deassert_hardreset - deassert hardreset for an IP block
+ * @shift: register bit shift corresponding to the reset line
+ * @st_shift: reset status bit shift corresponding to the reset line
+ * @part: PRM partition
+ * @prm_mod: PRM submodule base or instance offset
+ * @offset: register offset
+ * @st_offset: status register offset
+ *
+ * Deasserts a hardware reset line for an IP block.
+ */
+int omap_prm_deassert_hardreset(u8 shift, u8 st_shift, u8 part, s16 prm_mod,
+				u16 offset, u16 st_offset)
+{
+	if (!prm_ll_data->deassert_hardreset) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return -EINVAL;
+	}
+
+	return prm_ll_data->deassert_hardreset(shift, st_shift, part, prm_mod,
+					       offset, st_offset);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit efd44dc35f550e0cedd983d13e180da5e0d368a9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: OMAP2+: PRM: add generic API for asserting hardware reset
    
    PRM driver now has a generic API for asserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index ee2b5222eac0..4f8c22075d39 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -422,6 +422,26 @@ void prm_clear_context_loss_flags_old(u8 part, s16 inst, u16 idx)
 			  __func__);
 }
 
+/**
+ * omap_prm_assert_hardreset - assert hardreset for an IP block
+ * @shift: register bit shift corresponding to the reset line
+ * @part: PRM partition
+ * @prm_mod: PRM submodule base or instance offset
+ * @offset: register offset
+ *
+ * Asserts a hardware reset line for an IP block.
+ */
+int omap_prm_assert_hardreset(u8 shift, u8 part, s16 prm_mod, u16 offset)
+{
+	if (!prm_ll_data->assert_hardreset) {
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+		return -EINVAL;
+	}
+
+	return prm_ll_data->assert_hardreset(shift, part, prm_mod, offset);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit c0fa2373f8cfed90437d8d7b17e0b1a84009a10a
Merge: fcc3a5d27757 98d147f50eb0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 15 07:05:03 2014 +0200

    Merge tag 'clk-for-linus-3.18' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull clock tree updates from Mike Turquette:
     "The clk tree changes for 3.18 are dominated by clock drivers.  Mostly
      fixes and enhancements to existing drivers as well as new drivers.
      This tag contains a bit more arch code than I usually take due to some
      OMAP2+ changes.  Additionally it contains the restart notifier
      handlers which are merged as a dependency into several trees.
    
      The PXA changes are the only messy part.  Due to having a stable tree
      I had to revert one patch and follow up with one more fix near the tip
      of this tag.  Some dead code is introduced but it will soon become
      live code after 3.18-rc1 is released as the rest of the PXA family is
      converted over to the common clock framework.
    
      Another trend in this tag is that multiple vendors have started to
      push the complexity of changing their CPU frequency into the clock
      driver, whereas this used to be done in CPUfreq drivers.
    
      Changes to the clk core include a generic gpio-clock type and a
      clk_set_phase() function added to the top-level clk.h api.  Due to
      some confusion on the fbdev mailing list the kernel boot parameters
      documentation was updated to further explain the clk_ignore_unused
      parameter, which is often required by users of the simplefb driver.
    
      Finally some fixes to the locking around the clock debugfs stuff was
      done to prevent deadlocks when interacting with other subsystems."
    
    * tag 'clk-for-linus-3.18' of git://git.linaro.org/people/mike.turquette/linux: (99 commits)
      clk: pxa clocks build system fix
      Revert "arm: pxa: Transition pxa27x to clk framework"
      clk: samsung: register restart handlers for s3c2412 and s3c2443
      clk: rockchip: add restart handler
      clk: rockchip: rk3288: i2s_frac adds flag to set parent's rate
      doc/kernel-parameters.txt: clarify clk_ignore_unused
      arm: pxa: Transition pxa27x to clk framework
      dts: add devicetree bindings for pxa27x clocks
      clk: add pxa27x clock drivers
      arm: pxa: add clock pll selection bits
      clk: dts: document pxa clock binding
      clk: add pxa clocks infrastructure
      clk: gpio-gate: Ensure gpiod_ APIs are prototyped
      clk: ti: dra7-atl-clock: Mark the device as pm_runtime_irq_safe
      clk: ti: LLVMLinux: Move __init outside of type definition
      clk: ti: consider the fact that of_clk_get() might return an error
      clk: ti: dra7-atl-clock: fix a memory leak
      clk: ti: change clock init to use generic of_clk_init
      clk: hix5hd2: add I2C clocks
      clk: hix5hd2: add watchdog0 clocks
      ...

commit c08ee14cc6634457948bc5e26584697208baa02a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Sep 12 15:01:57 2014 +0300

    clk: ti: change clock init to use generic of_clk_init
    
    Previously, the TI clock driver initialized all the clocks hierarchically
    under each separate clock provider node. Now, each clock that requires
    IO access will instead check their parent node to find out which IO range
    to use.
    
    This patch allows the TI clock driver to use a few new features provided
    by the generic of_clk_init, and also allows registration of clock nodes
    outside the clock hierarchy (for example, any external clocks.)
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Stefan Assmann <sassmann@kpanic.de>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 76ca320f007c..3b890807f5e6 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -525,8 +525,6 @@ int __init of_prcm_init(void)
 		memmap_index++;
 	}
 
-	ti_dt_clockdomains_setup();
-
 	return 0;
 }
 

commit 31957609db529d401658adc2e91ef7df7ea42699
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 10 10:26:17 2014 +0200

    ARM: OMAP2+: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const function parameters and structs for OMAP2+ as const, too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 76ca320f007c..74054b813600 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -467,7 +467,7 @@ int prm_unregister(struct prm_ll_data *pld)
 	return 0;
 }
 
-static struct of_device_id omap_prcm_dt_match_table[] = {
+static const struct of_device_id omap_prcm_dt_match_table[] = {
 	{ .compatible = "ti,am3-prcm" },
 	{ .compatible = "ti,am3-scrm" },
 	{ .compatible = "ti,am4-prcm" },

commit ee200119c03c7d43ebaf7ae70985244aedb0586d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 25 09:21:39 2014 +0200

    ARM: OMAP2: PRM: add support for OMAP2 specific clock providers
    
    This patch adds support for initializing also omap2-prcm and omap2-scrm
    through DT.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 25e8b8232115..76ca320f007c 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -472,6 +472,8 @@ static struct of_device_id omap_prcm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scrm" },
 	{ .compatible = "ti,am4-prcm" },
 	{ .compatible = "ti,am4-scrm" },
+	{ .compatible = "ti,omap2-prcm" },
+	{ .compatible = "ti,omap2-scrm" },
 	{ .compatible = "ti,omap3-prm" },
 	{ .compatible = "ti,omap3-cm" },
 	{ .compatible = "ti,omap3-scrm" },

commit b550e47f5e9e74999f754371bdc79331d19f84a3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:45 2014 +0300

    ARM: OMAP3/4: PRM: add support of late_init call to prm_ll_ops
    
    SoC specific late_init call is now registered during PRM init, and will
    be called automatically by PRM core. This helps to get rid of some
    redundant initcalls and cpu_is_X checks from the PRM code.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index aa2550dd2ac1..25e8b8232115 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -527,3 +527,11 @@ int __init of_prcm_init(void)
 
 	return 0;
 }
+
+static int __init prm_late_init(void)
+{
+	if (prm_ll_data->late_init)
+		return prm_ll_data->late_init();
+	return 0;
+}
+subsys_initcall(prm_late_init);

commit 2541d15f16479fd56debe1ea55dee03c3886e33c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:44 2014 +0300

    ARM: OMAP3/OMAP4: PRM: add prm_features flags and add IO wakeup under it
    
    prm_features flag will contain SoC specific feature enabler flags. Initially
    IO wakeup is added under this. Helps to get rid of runtime cpu_is_X checks.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index bd746fc05d18..aa2550dd2ac1 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -62,6 +62,8 @@ static struct omap_prcm_irq_setup *prcm_irq_setup;
 /* prm_base: base virtual address of the PRM IP block */
 void __iomem *prm_base;
 
+u16 prm_features;
+
 /*
  * prm_ll_data: function pointers to SoC-specific implementations of
  * common PRM functions

commit 81243651ba25c4418af26c3c6f1aeabb41f734e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:43 2014 +0300

    ARM: OMAP3/4: PRM: provide io chain reconfig function through irq setup
    
    This helps to make the PRM registration modular, and also gets rid of a
    cpu type check done later.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index b4c4ab9c8044..bd746fc05d18 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -330,12 +330,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 
 	if (of_have_populated_dt()) {
 		int irq = omap_prcm_event_to_irq("io");
-		if (cpu_is_omap34xx())
-			omap_pcs_legacy_init(irq,
-				omap3xxx_prm_reconfigure_io_chain);
-		else
-			omap_pcs_legacy_init(irq,
-				omap44xx_prm_reconfigure_io_chain);
+		omap_pcs_legacy_init(irq, irq_setup->reconfigure_io_chain);
 	}
 
 	return 0;

commit 943a63a41f8542eed31c902d840e9ca2753a592f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Oct 25 15:28:11 2013 +0300

    ARM: OMAP2+: PRM: add support for initializing PRCM clock modules from DT
    
    This patch provides top level functionality for the DT clock initialization.
    Clock tree is initialized hierarchically starting from IP modules (CM/PRM/PRCM)
    going down towards individual clock nodes, and finally initializing
    clockdomains once all the clocks are ready.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index a2e1174ad1b6..b4c4ab9c8044 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -23,6 +23,10 @@
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/ti.h>
 
 #include "soc.h"
 #include "prm2xxx_3xxx.h"
@@ -30,6 +34,7 @@
 #include "prm3xxx.h"
 #include "prm44xx.h"
 #include "common.h"
+#include "clock.h"
 
 /*
  * OMAP_PRCM_MAX_NR_PENDING_REG: maximum number of PRM_IRQ*_MPU regs
@@ -464,3 +469,64 @@ int prm_unregister(struct prm_ll_data *pld)
 
 	return 0;
 }
+
+static struct of_device_id omap_prcm_dt_match_table[] = {
+	{ .compatible = "ti,am3-prcm" },
+	{ .compatible = "ti,am3-scrm" },
+	{ .compatible = "ti,am4-prcm" },
+	{ .compatible = "ti,am4-scrm" },
+	{ .compatible = "ti,omap3-prm" },
+	{ .compatible = "ti,omap3-cm" },
+	{ .compatible = "ti,omap3-scrm" },
+	{ .compatible = "ti,omap4-cm1" },
+	{ .compatible = "ti,omap4-prm" },
+	{ .compatible = "ti,omap4-cm2" },
+	{ .compatible = "ti,omap4-scrm" },
+	{ .compatible = "ti,omap5-prm" },
+	{ .compatible = "ti,omap5-cm-core-aon" },
+	{ .compatible = "ti,omap5-scrm" },
+	{ .compatible = "ti,omap5-cm-core" },
+	{ .compatible = "ti,dra7-prm" },
+	{ .compatible = "ti,dra7-cm-core-aon" },
+	{ .compatible = "ti,dra7-cm-core" },
+	{ }
+};
+
+static struct clk_hw_omap memmap_dummy_ck = {
+	.flags = MEMMAP_ADDRESSING,
+};
+
+static u32 prm_clk_readl(void __iomem *reg)
+{
+	return omap2_clk_readl(&memmap_dummy_ck, reg);
+}
+
+static void prm_clk_writel(u32 val, void __iomem *reg)
+{
+	omap2_clk_writel(val, &memmap_dummy_ck, reg);
+}
+
+static struct ti_clk_ll_ops omap_clk_ll_ops = {
+	.clk_readl = prm_clk_readl,
+	.clk_writel = prm_clk_writel,
+};
+
+int __init of_prcm_init(void)
+{
+	struct device_node *np;
+	void __iomem *mem;
+	int memmap_index = 0;
+
+	ti_clk_ll_ops = &omap_clk_ll_ops;
+
+	for_each_matching_node(np, omap_prcm_dt_match_table) {
+		mem = of_iomap(np, 0);
+		clk_memmaps[memmap_index] = mem;
+		ti_dt_clk_init_provider(np, memmap_index);
+		memmap_index++;
+	}
+
+	ti_dt_clockdomains_setup();
+
+	return 0;
+}

commit 30a69ef785e87c791aab0b4dae76709a7baa3e85
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Oct 10 15:45:13 2013 -0700

    ARM: OMAP: Move DT wake-up event handling over to use pinctrl-single-omap
    
    Now pinctrl-single-omap can handle the wake-up events for us now
    as long as the events are configured in the .dts files.
    
    Done in collaboration with Roger Quadros <rogerq@ti.com>.
    
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Prakash Manjunathappa <prakash.pm@ti.com>
    Cc: Roger Quadros <rogerq@ti.com>
    Cc: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 228b850e632f..a2e1174ad1b6 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
+#include "soc.h"
 #include "prm2xxx_3xxx.h"
 #include "prm2xxx.h"
 #include "prm3xxx.h"
@@ -322,6 +323,16 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 		prcm_irq_chips[i] = gc;
 	}
 
+	if (of_have_populated_dt()) {
+		int irq = omap_prcm_event_to_irq("io");
+		if (cpu_is_omap34xx())
+			omap_pcs_legacy_init(irq,
+				omap3xxx_prm_reconfigure_io_chain);
+		else
+			omap_pcs_legacy_init(irq,
+				omap44xx_prm_reconfigure_io_chain);
+	}
+
 	return 0;
 
 err:

commit 9121dfca73d81fa886f15610cac2bf372391f3eb
Merge: 77f9db89c928 8b9c1ac2e11a
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Nov 29 22:49:30 2012 -0800

    Merge tag 'omap-for-v3.8/devel-prcm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/pm2
    
    From Tony Lindgren:
    
    omap prcm changes via Paul Walmsley <paul@pwsan.com>:
    
    Some miscellaneous OMAP hwmod changes for 3.8, along with a PRM
    change needed for one of the hwmod patches to function.
    
    Basic test logs for this branch on top of Tony's
    omap-for-v3.8/clock branch at commit
    558a0780b0a04862a678f7823215424b4e5501f9 are here:
    
    http://www.pwsan.com/omap/testlogs/hwmod_devel_a_3.8/20121121161522/
    
    However, omap-for-v3.8/clock at 558a0780 does not include some fixes
    that are needed for a successful test.  With several reverts,
    fixes, and workarounds applied, the following test logs were
    obtained:
    
    http://www.pwsan.com/omap/testlogs/TEST_hwmod_devel_a_3.8/20121121162719/
    
    which indicate that the series tests cleanly.
    
    * tag 'omap-for-v3.8/devel-prcm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (49 commits)
      ARM: OMAP2+: omap_device: Correct resource handling for DT boot
      ARM: OMAP2+: hwmod: Add possibility to count hwmod resources based on type
      ARM: OMAP2+: hwmod: Add support for per hwmod/module context lost count
      ARM: OMAP2+: PRM: initialize some PRM functions early
      ARM: OMAP2+: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP2xxx: clock: drop obsolete clock data
      ARM: OMAP2: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP3+: DPLL: drop !CONFIG_COMMON_CLK sections
      ARM: AM33xx: clock: drop obsolete clock data
      ARM: OMAP3xxx: clk: drop obsolete clock data
      ARM: OMAP3: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP44xx: clock: drop obsolete clock data
      ARM: OMAP4: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP: hwmod: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP: clock: Switch to COMMON clk
      ARM: OMAP2: clock: Add 24xx data using common struct clk
      ARM: OMAP3: clock: Add 3xxx data using common struct clk
      ARM: AM33XX: clock: add clock data in common clock format
      ARM: OMAP4: clock: Add 44xx data using common struct clk
      ARM: OMAP2+: clock: add OMAP CCF convenience macros to mach-omap2/clock.h
      ...
    
    Some context conflicts due to nearby changes resolved in
    arch/arm/mach-omap2/io.c.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e6d3a8b0bdcd8f323488a52927682190aee5488e
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Nov 21 16:15:17 2012 -0700

    ARM: OMAP2+: hwmod: Add support for per hwmod/module context lost count
    
    OMAP4 has module specific context lost registers which makes it now
    possible to have module level context loss count, instead of relying
    on the powerdomain level context count.
    
    Add 2 private hwmod api's to update/clear the hwmod/module specific
    context lost counters/register.
    
    Update the module specific context_lost_counter and clear the hardware
    bits just after enabling the module.
    
    omap_hwmod_get_context_loss_count() now returns the hwmod context loss
    count them on platforms where they exist (OMAP4), else fall back on
    the pwrdm level counters for older platforms.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: added function kerneldoc, fixed structure kerneldoc,
     rearranged structure to avoid memory waste, marked fns as OMAP4-specific,
     prevent fn entry on non-OMAP4 chips, reduced indentation, merged update
     and clear, merged patches]
    [t-kristo@ti.com: added support for arch specific hwmod ops, and changed
     the no context offset indicator to USHRT_MAX]
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    [paul@pwsan.com: use NO_CONTEXT_LOSS_BIT flag rather than USHRT_MAX;
     convert unsigned context lost counter to int to match the return type;
     get rid of hwmod_ops in favor of the existing soc_ops mechanism;
     move context loss low-level accesses to the PRM code]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index d2e0798a4c82..c6ae53ca8224 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -366,6 +366,51 @@ u32 prm_read_reset_sources(void)
 	return ret;
 }
 
+/**
+ * prm_was_any_context_lost_old - was device context lost? (old API)
+ * @part: PRM partition ID (e.g., OMAP4430_PRM_PARTITION)
+ * @inst: PRM instance offset (e.g., OMAP4430_PRM_MPU_INST)
+ * @idx: CONTEXT register offset
+ *
+ * Return 1 if any bits were set in the *_CONTEXT_* register
+ * identified by (@part, @inst, @idx), which means that some context
+ * was lost for that module; otherwise, return 0.  XXX Deprecated;
+ * callers need to use a less-SoC-dependent way to identify hardware
+ * IP blocks.
+ */
+bool prm_was_any_context_lost_old(u8 part, s16 inst, u16 idx)
+{
+	bool ret = true;
+
+	if (prm_ll_data->was_any_context_lost_old)
+		ret = prm_ll_data->was_any_context_lost_old(part, inst, idx);
+	else
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+
+	return ret;
+}
+
+/**
+ * prm_clear_context_lost_flags_old - clear context loss flags (old API)
+ * @part: PRM partition ID (e.g., OMAP4430_PRM_PARTITION)
+ * @inst: PRM instance offset (e.g., OMAP4430_PRM_MPU_INST)
+ * @idx: CONTEXT register offset
+ *
+ * Clear hardware context loss bits for the module identified by
+ * (@part, @inst, @idx).  No return value.  XXX Deprecated; callers
+ * need to use a less-SoC-dependent way to identify hardware IP
+ * blocks.
+ */
+void prm_clear_context_loss_flags_old(u8 part, s16 inst, u16 idx)
+{
+	if (prm_ll_data->clear_context_loss_flags_old)
+		prm_ll_data->clear_context_loss_flags_old(part, inst, idx);
+	else
+		WARN_ONCE(1, "prm: %s: no mapping function defined\n",
+			  __func__);
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit cb64babf9ebe06984d87c08d241d05e2f6a7eb5b
Merge: 809a3226ad7c cc4b1e24b93d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 15 17:08:51 2012 +0100

    Merge tag 'omap-for-v3.8/cleanup-prcm-part2-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/cleanup
    
    From Tony Lindgren <tony@atomide.com>:
    
    More PRCM cleanups via Paul Walmsley <paul@pwsan.com>:
    
    Second set of OMAP PRCM cleanups for 3.8.
    
    These patches remove the use of omap_prcm_get_reset_sources() from the
    OMAP watchdog driver, and remove mach-omap2/prcm.c and
    plat-omap/include/plat/prcm.h.
    
    Basic test logs for this branch on top of Tony's cleanup-prcm branch
    at commit 7fc54fd3084457c7f11b9e2e1e3fcd19a3badc33 are here:
    
        http://www.pwsan.com/omap/testlogs/prcm_cleanup_b_3.8/20121108151646/
    
    However, cleanup-prcm at 7fc54fd3 does not include some fixes
    that are needed for a successful test.  With several reverts,
    fixes, and workarounds applied, the following test logs were
    obtained:
    
        http://www.pwsan.com/omap/testlogs/TEST_prcm_cleanup_b_3.8/20121108151930/
    
    which indicate that the series tests cleanly.
    
    This second pull request updates one of the patches which broke
    with rmk's allnoconfigs, and also updates the tag description to
    indicate that 7fc54fd3 is building cleanly here.
    
    * tag 'omap-for-v3.8/cleanup-prcm-part2-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (27 commits)
      ARM: OMAP2: Fix compillation error in cm_common
      ARM: OMAP2+: PRCM: remove obsolete prcm.[ch]
      ARM: OMAP2+: hwmod: call to _omap4_disable_module() should use the SoC-specific call
      ARM: OMAP2+: PRCM: consolidate PRCM-related timeout macros
      ARM: OMAP2+: PRCM: split and relocate the PRM/CM globals setup
      ARM: OMAP2+: PRCM: remove omap2_cm_wait_idlest()
      ARM: OMAP2+: CM/clock: convert _omap2_module_wait_ready() to use SoC-independent CM functions
      ARM: OMAP2xxx: APLL/CM: convert to use omap2_cm_wait_module_ready()
      ARM: OMAP2+: board files: use SoC-specific system restart functions
      ARM: OMAP2+: PRCM: create SoC-specific chip restart functions
      ARM: OMAP2xxx: clock: move virt_prcm_set code into clkt2xxx_virt_prcm_set.c
      ARM: OMAP2xxx: clock: remove global 'dclk' variable
      ARM: OMAP2/3: PRM: add SoC reset functions (using the CORE DPLL method)
      ARM: OMAP2+: common: remove mach-omap2/common.c globals and map_common_io code
      ARM: OMAP2+: PRCM: remove omap_prcm_get_reset_sources()
      watchdog: OMAP: use standard GETBOOTSTATUS interface; use platform_data fn ptr
      ARM: OMAP2+: WDT: move init; add read_reset_sources pdata function pointer
      ARM: OMAP1: CGRM: fix omap1_get_reset_sources() return type
      ARM: OMAP2+: PRM: create PRM reset source API for the watchdog timer driver
      ARM: OMAP1: create read_reset_sources() function (for initial use by watchdog)
      ...
    
    Conflicts:
            arch/arm/mach-omap2/cm33xx.c
            arch/arm/mach-omap2/io.c
            arch/arm/mach-omap2/prm_common.c
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b99db36cdf37decb1b5575c5f293d170cbbc53d6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:59:29 2012 -0600

    ARM: OMAP2+: PRCM: remove obsolete prcm.[ch]
    
    arch/arm/mach-omap2/prcm.c and arch/arm/plat-omap/include/plat/prcm.h
    are now completely unused and can be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 2294daf95c2e..d2e0798a4c82 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -25,7 +25,6 @@
 #include <linux/slab.h>
 
 #include "../plat-omap/common.h"
-#include <plat/prcm.h>
 
 #include "prm2xxx_3xxx.h"
 #include "prm2xxx.h"

commit d9a16f9ab9332b7cf1c95086a4efb98a0d13a57a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:57:39 2012 -0600

    ARM: OMAP2+: PRCM: split and relocate the PRM/CM globals setup
    
    Split omap2_set_globals_prcm() into PRM, CM, and PRCM_MPU variants, since
    these are all separate IP blocks.  This should make it easier to move the
    PRM, CM, PRCM_MPU code into drivers/ in future patchsets.
    
    At this point arch/arm/plat-omap/include/plat/prcm.h is empty; a
    subsequent patch will remove it, and remove the #include from all the
    files that #include it.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6c595798c5c5..2294daf95c2e 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -31,6 +31,7 @@
 #include "prm2xxx.h"
 #include "prm3xxx.h"
 #include "prm44xx.h"
+#include "common.h"
 
 /*
  * OMAP_PRCM_MAX_NR_PENDING_REG: maximum number of PRM_IRQ*_MPU regs
@@ -55,6 +56,9 @@ static struct irq_chip_generic **prcm_irq_chips;
  */
 static struct omap_prcm_irq_setup *prcm_irq_setup;
 
+/* prm_base: base virtual address of the PRM IP block */
+void __iomem *prm_base;
+
 /*
  * prm_ll_data: function pointers to SoC-specific implementations of
  * common PRM functions
@@ -328,6 +332,17 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	return -ENOMEM;
 }
 
+/**
+ * omap2_set_globals_prm - set the PRM base address (for early use)
+ * @prm: PRM base virtual address
+ *
+ * XXX Will be replaced when the PRM/CM drivers are completed.
+ */
+void __init omap2_set_globals_prm(void __iomem *prm)
+{
+	prm_base = prm;
+}
+
 /**
  * prm_read_reset_sources - return the sources of the SoC's last reset
  *

commit 5c2e88525b5f1cdc72c9eefba72dae13be7e5d20
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 16:45:47 2012 -0700

    ARM: OMAP: Remove plat-omap/common.h
    
    Most of the prototypes in plat-omap/common.h are not
    common to omap1 and omap2+, they are local to omap2+
    and should not be in plat-omap/common.h.
    
    The only shared function prototype in this file is
    omap_init_clocksource_32k(), let's put that into
    counter-32k.h.
    
    Note that the new plat/counter-32k.h must not be
    included from drivers, that will break omap2+ build
    for CONFIG_MULTIPLATFORM.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6fabbd816d6b..3442227d3f0b 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -24,7 +24,6 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
-#include "../plat-omap/common.h"
 #include <plat/prcm.h>
 
 #include "prm2xxx_3xxx.h"

commit 8634155ef41d3a035f2ea0b6c5bed2806f2788bc
Merge: 6d02643d64b4 2bb2a5d30abb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 17:05:59 2012 -0700

    Merge tag 'omap-cleanup-a-for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8/cleanup-prcm
    
    The first set of OMAP PRM/CM-related cleanup patches for 3.8.
    Prepares for the future move of the PRM/CM code to drivers/.  Also
    includes some prcm.[ch] cleanup patches from the WDTIMER cleanup
    series that don't need external acks.
    
    Basic test logs for this branch on top of v3.7-rc2 are here:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121021123719/
    
    But due to the number of unrelated regressions present in v3.7-rc[12],
    it's not particularly usable as a testing base.  With reverts, fixes,
    and workarounds applied as documented in:
    
    http://www.pwsan.com/omap/testlogs/test_v3.7-rc2/20121020134755/README.txt
    
    the following test logs were obtained:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121020231757/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/Makefile
            arch/arm/mach-omap2/clockdomain2xxx_3xxx.c
            arch/arm/mach-omap2/pm24xx.c

commit 2bb2a5d30abb0dc99d074877bfad2056142c730b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:13 2012 -0600

    ARM: OMAP2+: PRM: create PRM reset source API for the watchdog timer driver
    
    The OMAP watchdog timer driver needs to determine what caused the SoC
    to reset for its GETBOOTSTATUS ioctl.  So, define a set of standard
    reset sources across OMAP SoCs.  For OMAP2xxx, 3xxx, and 4xxx SoCs,
    define mappings from the SoC-specific reset source register bits to
    the standardized reset source IDs.  Create SoC-specific PRM functions
    that read the appropriate per-SoC register and use the mapping to
    return the standardized reset bits.  Register the SoC-specific PRM
    functions with the common PRM code via prm_register().  Create a
    function in the common PRM code, prm_read_reset_sources(), that
    calls the SoC-specific function, registered during boot.
    
    This patch does not yet handle some SoCs, such as AM33xx.  Those SoCs
    were not handled by the code this will replace.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 8670a3c4bc5e..e200e4fb47dc 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -28,6 +28,8 @@
 #include <plat/prcm.h>
 
 #include "prm2xxx_3xxx.h"
+#include "prm2xxx.h"
+#include "prm3xxx.h"
 #include "prm44xx.h"
 
 /*
@@ -326,6 +328,30 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	return -ENOMEM;
 }
 
+/**
+ * prm_read_reset_sources - return the sources of the SoC's last reset
+ *
+ * Return a u32 bitmask representing the reset sources that caused the
+ * SoC to reset.  The low-level per-SoC functions called by this
+ * function remap the SoC-specific reset source bits into an
+ * OMAP-common set of reset source bits, defined in
+ * arch/arm/mach-omap2/prm.h.  Returns the standardized reset source
+ * u32 bitmask from the hardware upon success, or returns (1 <<
+ * OMAP_UNKNOWN_RST_SRC_ID_SHIFT) if no low-level read_reset_sources()
+ * function was registered.
+ */
+u32 prm_read_reset_sources(void)
+{
+	u32 ret = 1 << OMAP_UNKNOWN_RST_SRC_ID_SHIFT;
+
+	if (prm_ll_data->read_reset_sources)
+		ret = prm_ll_data->read_reset_sources();
+	else
+		WARN_ONCE(1, "prm: %s: no mapping function defined for reset sources\n", __func__);
+
+	return ret;
+}
+
 /**
  * prm_register - register per-SoC low-level data with the PRM
  * @pld: low-level per-SoC OMAP PRM data & function pointers to register

commit e24c35737413c8626f9c4e8f47e33926b7ab7f23
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:11 2012 -0600

    ARM: OMAP2+: PRM: prepare for use of prm_ll_data function pointers
    
    There are several PRM operations which behave similarly across OMAP2+
    SoCs, but which have slight differences in their underlying
    implementations.  For example, to fetch the SoC's last reset sources,
    different registers are read across OMAP2xxx, 3xxx, and 44xx, and
    different bits are used on each SoC.  But the information returned is
    so similar that a single, common interface for drivers is useful.
    
    This patch creates the support code for this function pointer
    registration process.  No function pointers are included yet, but a
    subsequent patch will create one for the reset source API.
    
    To illustrate the end goal with the above reset source example, each
    per-SoC driver will use its own low-level implementation function --
    e.g., prm2xxx.c would contain omap2xxx_prm_read_reset_sources().  This
    function would read the appropriate register and remap the register
    bits to a standard set of reset source bits.  When the prm2xxx.c
    driver is loaded, it would register this function with the common PRM
    driver, prm.c.  prm.c would then export a common function,
    omap_prm_read_reset_sources().  Calling it would call through to the
    function pointer for the currently-registered SoC PRM driver.  This
    will allow other drivers to use PRM-provided data and operations
    without needing to know which SoC is currently in use.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 0a100d9465b4..8670a3c4bc5e 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -53,6 +53,13 @@ static struct irq_chip_generic **prcm_irq_chips;
  */
 static struct omap_prcm_irq_setup *prcm_irq_setup;
 
+/*
+ * prm_ll_data: function pointers to SoC-specific implementations of
+ * common PRM functions
+ */
+static struct prm_ll_data null_prm_ll_data;
+static struct prm_ll_data *prm_ll_data = &null_prm_ll_data;
+
 /* Private functions */
 
 /*
@@ -318,3 +325,48 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	omap_prcm_irq_cleanup();
 	return -ENOMEM;
 }
+
+/**
+ * prm_register - register per-SoC low-level data with the PRM
+ * @pld: low-level per-SoC OMAP PRM data & function pointers to register
+ *
+ * Register per-SoC low-level OMAP PRM data and function pointers with
+ * the OMAP PRM common interface.  The caller must keep the data
+ * pointed to by @pld valid until it calls prm_unregister() and
+ * it returns successfully.  Returns 0 upon success, -EINVAL if @pld
+ * is NULL, or -EEXIST if prm_register() has already been called
+ * without an intervening prm_unregister().
+ */
+int prm_register(struct prm_ll_data *pld)
+{
+	if (!pld)
+		return -EINVAL;
+
+	if (prm_ll_data != &null_prm_ll_data)
+		return -EEXIST;
+
+	prm_ll_data = pld;
+
+	return 0;
+}
+
+/**
+ * prm_unregister - unregister per-SoC low-level data & function pointers
+ * @pld: low-level per-SoC OMAP PRM data & function pointers to unregister
+ *
+ * Unregister per-SoC low-level OMAP PRM data and function pointers
+ * that were previously registered with prm_register().  The
+ * caller may not destroy any of the data pointed to by @pld until
+ * this function returns successfully.  Returns 0 upon success, or
+ * -EINVAL if @pld is NULL or if @pld does not match the struct
+ * prm_ll_data * previously registered by prm_register().
+ */
+int prm_unregister(struct prm_ll_data *pld)
+{
+	if (!pld || prm_ll_data != pld)
+		return -EINVAL;
+
+	prm_ll_data = &null_prm_ll_data;
+
+	return 0;
+}

commit 7a0c19337c38a1ffa7587272e7784e6431e78eaa
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:09 2012 -0600

    ARM: OMAP2+: PRM: remove PRM weak functions
    
    Remove the now-unused PRM weak functions from prm_common.c.  These
    were formerly used to ensure that some OMAP2/3 PRM code would build on
    OMAP4, but none of those functions ever would have worked on OMAP4 due
    to an incompatible PRM register layout.  Now all that has been cleaned
    up and these can be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6b4d332be2f6..0a100d9465b4 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -318,65 +318,3 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	omap_prcm_irq_cleanup();
 	return -ENOMEM;
 }
-
-/*
- * Stubbed functions so that common files continue to build when
- * custom builds are used
- * XXX These are temporary and should be removed at the earliest possible
- * opportunity
- */
-u32 __weak omap2_prm_read_mod_reg(s16 module, u16 idx)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-void __weak omap2_prm_write_mod_reg(u32 val, s16 module, u16 idx)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-}
-
-u32 __weak omap2_prm_rmw_mod_reg_bits(u32 mask, u32 bits,
-		s16 module, s16 idx)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-u32 __weak omap2_prm_set_mod_reg_bits(u32 bits, s16 module, s16 idx)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-u32 __weak omap2_prm_clear_mod_reg_bits(u32 bits, s16 module, s16 idx)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-u32 __weak omap2_prm_read_mod_bits_shift(s16 domain, s16 idx, u32 mask)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-int __weak omap2_prm_is_hardreset_asserted(s16 prm_mod, u8 shift)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-int __weak omap2_prm_assert_hardreset(s16 prm_mod, u8 shift)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-
-int __weak omap2_prm_deassert_hardreset(s16 prm_mod, u8 rst_shift,
-						u8 st_shift)
-{
-	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
-	return 0;
-}
-

commit e6a6e5ad17ee090f8d48a3b0758338a97124539f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 27 17:11:15 2012 -0700

    ARM: OMAP: Make plat/common.h local to mach-omap1 and mach-omap2
    
    We cannot keep this in plat/common.h for common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 6b4d332be2f6..6fabbd816d6b 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -24,7 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
-#include <plat/common.h>
+#include "../plat-omap/common.h"
 #include <plat/prcm.h>
 
 #include "prm2xxx_3xxx.h"

commit 7d7e1eba7e92c2f9c76db80adc24836e7a114bfb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 27 17:43:01 2012 -0700

    ARM: OMAP2+: Prepare for irqs.h removal
    
    As the interrupts should only be defined in the platform_data, and
    eventually coming from device tree, there's no need to define them
    in header files.
    
    Let's remove the hardcoded references to irqs.h and fix up the includes
    so we don't rely on headers included in irqs.h. Note that we're
    defining OMAP_INTC_START as 0 to the interrupts. This will be needed
    when we enable SPARSE_IRQ. For some drivers we need to add
    #include <plat/cpu.h> for now until these drivers are fixed to
    remove cpu_is_omapxxxx() usage.
    
    While at it, sort som of the includes the standard way, and add
    the trailing commas where they are missing in the related data
    structures.
    
    Note that for drivers/staging/tidspbridge we just define things
    locally.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 03b126d9ad94..6b4d332be2f6 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -26,7 +26,6 @@
 
 #include <plat/common.h>
 #include <plat/prcm.h>
-#include <plat/irqs.h>
 
 #include "prm2xxx_3xxx.h"
 #include "prm44xx.h"

commit fde75430278130505cac21997cd9f90b7bb2670a
Merge: 1a4120bc101b db3c47a3af96
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 16:22:12 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc cleanups, part 2, from Arnd Bergmann:
     "These omap cleanups have dependencies on earlier omap branches that in
      turn depend on other cleanups, so they could not go into the same
      branch."
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: OMAP: sdrc: Fix the build break for OMAP4 only builds
      ARM: OMAP2+: dmtimer: cleanup fclk usage
      ARM: OMAP2+: Fix mismerge for omap_hwmod_get_main_clk() API
      ARM: OMAP2+: Remove unnecessary ifdef around __omap2_set_globals
      ARM: OMAP2+: am33xx: Change cpu_is_am33xx to soc_is_am33xx
      ARM: OMAP2+: am33xx: Make am33xx as a separate class
      ARM: OMAP2+: Move omap3 dpll ops to dpll3xxx.c
      ARM: OMAP2+: All OMAP2PLUS uses omap-device.o target so add one entry
      ARM: OMAP: dmtimer: use devm_ API and do some cleanup in probe()
      ARM: OMAP2+: hwmod code: add support to set dmadisable in hwmod framework
      ARM: OMAP2+: PRM/CM: Move the stubbed prm and cm functions to prcm.c file and make them __weak
      ARM: OMAP2+: hwmod: add omap_hwmod_get_main_clk() API
      ARM: OMAP3+: dpll: optimize noncore dpll locking logic
      ARM: OMAP3: control: add definition for CONTROL_CAMERA_PHY_CTRL
      ARM: OMAP2+: powerdomain code: Fix Wake-up power domain power status
      ARM: OMAP4: clockdomain/CM code: Update supported transition modes
      ARM: OMAP3/4: omap_hwmod: Add rstst_offs field to struct omap_hwmod_omap4_prcm
      ARM: OMAP2+: hwmod: Add new sysc_type3 into omap_hwmod required for am33xx

commit 3f4990f44a5dcf15a053a041c813fa73ffa75608
Author: R Sricharan <r.sricharan@ti.com>
Date:   Wed Jul 4 05:04:00 2012 -0600

    ARM: OMAP2+: PRM/CM: Move the stubbed prm and cm functions to prcm.c file and make them __weak
    
    Some prm and cm registers read/write and status functions
    are built only for some custom OMAP2+ builds and are stubbed
    in header files for other builds under ifdef statements.
    But this results in adding new CONFIG_ARCH_OMAPXXX
    checks when SOCs are added in the future. So move them
    to a common place for OMAP2+ and make them 'weak' implementations.
    
    This way no new ifdefs would be required in the future and also
    cleans up the existing code.
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    [paul@pwsan.com: unsplit quoted strings; moved PRM functions to
     mach-omap2/prm_common.c; resolved sparse warnings]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index dfe00ddb5c60..663ade3b2f45 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -319,3 +319,65 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	omap_prcm_irq_cleanup();
 	return -ENOMEM;
 }
+
+/*
+ * Stubbed functions so that common files continue to build when
+ * custom builds are used
+ * XXX These are temporary and should be removed at the earliest possible
+ * opportunity
+ */
+u32 __weak omap2_prm_read_mod_reg(s16 module, u16 idx)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+void __weak omap2_prm_write_mod_reg(u32 val, s16 module, u16 idx)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+}
+
+u32 __weak omap2_prm_rmw_mod_reg_bits(u32 mask, u32 bits,
+		s16 module, s16 idx)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+u32 __weak omap2_prm_set_mod_reg_bits(u32 bits, s16 module, s16 idx)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+u32 __weak omap2_prm_clear_mod_reg_bits(u32 bits, s16 module, s16 idx)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+u32 __weak omap2_prm_read_mod_bits_shift(s16 domain, s16 idx, u32 mask)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+int __weak omap2_prm_is_hardreset_asserted(s16 prm_mod, u8 shift)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+int __weak omap2_prm_assert_hardreset(s16 prm_mod, u8 shift)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+
+int __weak omap2_prm_deassert_hardreset(s16 prm_mod, u8 rst_shift,
+						u8 st_shift)
+{
+	WARN(1, "prm: omap2xxx/omap3xxx specific function called on non-omap2xxx/3xxx\n");
+	return 0;
+}
+

commit b56f2cb71a73618c97721762feb0a1be81302e22
Author: Venkatraman S <svenkatr@ti.com>
Date:   Mon Jun 25 15:56:39 2012 +0530

    ARM: OMAP2+: fix naming collision of variable nr_irqs
    
    Using nr_irqs as local variable name triggers the sparse warning..
    ./arch/arm/mach-omap2/irq.c:265:6: warning: symbol 'nr_irqs' shadows an earlier one
    ./linux/include/linux/irqnr.h:26:12: originally declared here
    
    Signed-off-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index dfe00ddb5c60..534d732caa1e 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -85,7 +85,7 @@ static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
 	unsigned long priority_pending[OMAP_PRCM_MAX_NR_PENDING_REG];
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	unsigned int virtirq;
-	int nr_irqs = prcm_irq_setup->nr_regs * 32;
+	int nr_irq = prcm_irq_setup->nr_regs * 32;
 
 	/*
 	 * If we are suspended, mask all interrupts from PRCM level,
@@ -110,7 +110,7 @@ static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
 		prcm_irq_setup->read_pending_irqs(pending);
 
 		/* No bit set, then all IRQs are handled */
-		if (find_first_bit(pending, nr_irqs) >= nr_irqs)
+		if (find_first_bit(pending, nr_irq) >= nr_irq)
 			break;
 
 		omap_prcm_events_filter_priority(pending, priority_pending);
@@ -121,11 +121,11 @@ static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
 		 */
 
 		/* Serve priority events first */
-		for_each_set_bit(virtirq, priority_pending, nr_irqs)
+		for_each_set_bit(virtirq, priority_pending, nr_irq)
 			generic_handle_irq(prcm_irq_setup->base_irq + virtirq);
 
 		/* Serve normal events next */
-		for_each_set_bit(virtirq, pending, nr_irqs)
+		for_each_set_bit(virtirq, pending, nr_irq)
 			generic_handle_irq(prcm_irq_setup->base_irq + virtirq);
 	}
 	if (chip->irq_ack)

commit eeb3711b89d68e147e05e7b43a49ecc5009dc157
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Apr 13 06:34:32 2012 -0600

    ARM: OMAP2+: clean up some cppcheck warnings
    
    Resolve some warnings identified by cppcheck in arch/arm/mach-omap2:
    
        [arch/arm/mach-omap2/usb-tusb6010.c:129]: (style) Checking if unsigned variable 'tmp' is less than zero.
        [arch/arm/mach-omap2/prm_common.c:241]: (error) Possible null pointer dereference: irq_setup - otherwise it is redundant to check if irq_setup is null at line 247
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'per_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'core_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm24xx.c:185]: (style) Variable 'only_idle' is assigned a value that is never used
        [arch/arm/mach-omap2/mux.c:254]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/mux.c:258]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/gpmc-onenand.c:178]: (style) Variable 'tick_ns' is assigned a value that is never used
        [arch/arm/mach-omap2/gpio.c:56]: (error) Possible null pointer dereference: pdata - otherwise it is redundant to check if pdata is null at line 57
        [arch/arm/mach-omap2/devices.c:45]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/board-omap3evm.c:641] -> [arch/arm/mach-omap2/board-omap3evm.c:639]: (style) Found duplicate branches for if and else.
        [arch/arm/mach-omap2/am35xx-emac.c:95]: (style) Variable 'regval' is assigned a value that is never used
        [arch/arm/mach-omap2/devices.c:74]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:277]: (style) Variable 'per_prev_state' is assigned a value that is never used
        [arch/arm/plat-omap/dmtimer.c:352]: (error) Possible null pointer dereference: timer - otherwise it is redundant to check if timer is null at line 354
        [arch/arm/plat-omap/omap_device.c:478]: (style) Variable 'c' is assigned a value that is never used
        [arch/arm/plat-omap/usb.c:42]: (style) Variable 'status' is assigned a value that is never used
        [arch/arm/mach-omap1/clock.c:197]: (style) Variable 'dpll1_rate' is assigned a value that is never used
        [arch/arm/mach-omap1/lcd_dma.c:60]: (style) struct or union member 'lcd_dma_info::size' is never used
        [arch/arm/mach-omap1/pm.c:572]: (style) Variable 'entry' is assigned a value that is never used
    
    Some of them are pretty good catches, such as gpio.c:56 and
    usb-tusb6010.c:129.
    
    Thanks to Jarkko Nikula for some comments on the sscanf() warnings.
    It seems that the kernel sscanf() ignores the field width anyway for the
    %d format, so those changes have been dropped from this second version.
    
    Thanks to Daniel Marjamäki <daniel.marjamaki@gmail.com> for pointing
    out that a variable was unnecessarily marked static in the
    board-omap3evm.c change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Charulatha Varadarajan <charu@ti.com>
    Cc: Daniel Marjamäki <daniel.marjamaki@gmail.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Charulatha Varadarajan <charu@ti.com> # for gpio.c

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index d28f848897d6..dfe00ddb5c60 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -237,7 +237,7 @@ void omap_prcm_irq_complete(void)
  */
 int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 {
-	int nr_regs = irq_setup->nr_regs;
+	int nr_regs;
 	u32 mask[OMAP_PRCM_MAX_NR_PENDING_REG];
 	int offset, i;
 	struct irq_chip_generic *gc;
@@ -246,6 +246,8 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	if (!irq_setup)
 		return -EINVAL;
 
+	nr_regs = irq_setup->nr_regs;
+
 	if (prcm_irq_setup) {
 		pr_err("PRCM: already initialized; won't reinitialize\n");
 		return -EINVAL;

commit 08956f1c5883f66c2e547f8137061c6b58ccbb53
Merge: 3916043576ec 4ba7c3c3c656
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Apr 3 11:31:38 2012 -0700

    Merge branch 'for_3.4/fixes/pm' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into fixes

commit 4ba7c3c3c6567210bf46b1ab3d089134170c2762
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Thu Mar 22 09:23:37 2012 +0800

    ARM: OMAP3+: fix oops triggered in omap_prcm_register_chain_handler(v1)
    
    This patch fixes the oops below[1].
    
    Obviously, the count of "struct irq_chip_generic" instances to be
    allocated and setup should be irq_setup->nr_regs instead of
    irq_setup->nr_regs plus one, so just fix the iterator to avoid
    the oops.
    
    [1], oops log.
    
    [    1.790242] Unable to handle kernel NULL pointer dereference at virtual address 00000004
    [    1.798632] pgd = c0004000
    [    1.801638] [00000004] *pgd=00000000
    [    1.805400] Internal error: Oops: 805 [#1] PREEMPT SMP THUMB2
    [    1.811381] Modules linked in:
    [    1.814601] CPU: 1    Not tainted  (3.3.0-next-20120320+ #733)
    [    1.820683] PC is at irq_setup_generic_chip+0x6a/0x84
    [    1.825951] LR is at irq_get_irq_data+0x7/0x8
    [    1.830508] pc : [<c006465e>]    lr : [<c0063a03>]    psr: 20000133
    [    1.830512] sp : ee04ff58  ip : 00000000  fp : 00000000
    [    1.842461] r10: 00000000  r9 : 00000000  r8 : 00000800
    [    1.847905] r7 : c064e260  r6 : 000001dc  r5 : 00000001  r4 : ee0accc0
    [    1.854687] r3 : 00000002  r2 : 00000800  r1 : 000001dc  r0 : 00000000
    [    1.861472] Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA Thumb  Segment kernel
    [    1.869234] Control: 50c5387d  Table: 8000404a  DAC: 00000015
    [    1.875215] Process swapper/0 (pid: 1, stack limit = 0xee04e2f8)
    [    1.881463] Stack: (0xee04ff58 to 0xee050000)
    [    1.886017] ff40: c061b668 00000008
    [    1.894497] ff60: c0682090 ee0accc0 00000003 c001c637 00000000 00000000 00000201 00000000
    [    1.902976] ff80: 00000004 c0473820 c0473800 c0459e8d c0680ac0 c000866d 00000004 00000004
    [    1.911455] ffa0: ee04ffa8 00000004 c047381c 00000004 c0473820 c0473800 c0680ac0 00000082
    [    1.919934] ffc0: c0489694 c045265f 00000004 00000004 c0452135 c000d105 00000033 00000000
    [    1.928413] ffe0: c04525b5 c000d111 00000033 00000000 00000000 c000d111 aaaaaaaa aaaaaaaa
    [    1.936912] [<c006465e>] (irq_setup_generic_chip+0x6a/0x84) from [<c001c637>] (omap_prcm_register_chain_handler+0x147/0x1a0)
    [    1.948516] [<c001c637>] (omap_prcm_register_chain_handler+0x147/0x1a0) from [<c000866d>] (do_one_initcall+0x65/0xf4)
    [    1.959500] [<c000866d>] (do_one_initcall+0x65/0xf4) from [<c045265f>] (kernel_init+0xab/0x138)
    [    1.968529] [<c045265f>] (kernel_init+0xab/0x138) from [<c000d111>] (kernel_thread_exit+0x1/0x6)
    [    1.977632] Code: f7ff f9d1 6b23 1af3 (6043) 086d
    [    1.982684] ---[ end trace 1b75b31a2719ed1c ]---
    [    1.987526] Kernel panic - not syncing: Attempted to kill init!
    exitcode=0x0000000b
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 860118ab43e2..de58b8b878e3 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -291,7 +291,7 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 		goto err;
 	}
 
-	for (i = 0; i <= irq_setup->nr_regs; i++) {
+	for (i = 0; i < irq_setup->nr_regs; i++) {
 		gc = irq_alloc_generic_chip("PRCM", 1,
 			irq_setup->base_irq + i * 32, prm_base,
 			handle_level_irq);

commit a570067df9cc1b1821ca5255bbbe8adb67aca199
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Dec 19 03:29:16 2011 -0500

    ARM: big removal of now unused arch_idle()
    
    When this is the only content remaining in mach/system.h then the
    whole file is removed.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-and-tested-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 860118ab43e2..873b51d494ea 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -24,7 +24,6 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
-#include <mach/system.h>
 #include <plat/common.h>
 #include <plat/prcm.h>
 #include <plat/irqs.h>

commit 91285b6fa296657d92dc2225100fb94aee869bf2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Dec 16 14:36:58 2011 -0700

    ARM: OMAP: PRCM: add suspend prepare / finish support
    
    PRCM chain handler needs to disable forwarding of interrupts during
    suspend, because runtime PM is disabled and most of the drivers
    are potentially not able to handle interrupts coming at this time.
    
    This patch masks all the PRCM interrupt events if a PRCM interrupt
    occurs during suspend, but does not ack them. Once suspend finish
    is called, all the masked events will be re-enabled, which causes
    immediate PRCM interrupt and handles the postponed event.
    
    The suspend prepare and complete  callbacks will be called from
    pm34xx.c / pm44xx.c files in the following patches.
    
    The functions defined in this patch should eventually be moved to
    suspend->prepare and suspend->finish driver hooks, once the PRCM
    chain handler will be made as its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: add kerneldoc, add omap_prcm_irq_setup.saved_mask, add fn
     ptrs for save_and_clear_irqen() and restore_irqen()]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 5694be56a947..860118ab43e2 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -88,11 +88,26 @@ static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
 	unsigned int virtirq;
 	int nr_irqs = prcm_irq_setup->nr_regs * 32;
 
+	/*
+	 * If we are suspended, mask all interrupts from PRCM level,
+	 * this does not ack them, and they will be pending until we
+	 * re-enable the interrupts, at which point the
+	 * omap_prcm_irq_handler will be executed again.  The
+	 * _save_and_clear_irqen() function must ensure that the PRM
+	 * write to disable all IRQs has reached the PRM before
+	 * returning, or spurious PRCM interrupts may occur during
+	 * suspend.
+	 */
+	if (prcm_irq_setup->suspended) {
+		prcm_irq_setup->save_and_clear_irqen(prcm_irq_setup->saved_mask);
+		prcm_irq_setup->suspend_save_flag = true;
+	}
+
 	/*
 	 * Loop until all pending irqs are handled, since
 	 * generic_handle_irq() can cause new irqs to come
 	 */
-	while (1) {
+	while (!prcm_irq_setup->suspended) {
 		prcm_irq_setup->read_pending_irqs(pending);
 
 		/* No bit set, then all IRQs are handled */
@@ -174,6 +189,9 @@ void omap_prcm_irq_cleanup(void)
 		prcm_irq_chips = NULL;
 	}
 
+	kfree(prcm_irq_setup->saved_mask);
+	prcm_irq_setup->saved_mask = NULL;
+
 	kfree(prcm_irq_setup->priority_mask);
 	prcm_irq_setup->priority_mask = NULL;
 
@@ -185,6 +203,29 @@ void omap_prcm_irq_cleanup(void)
 	prcm_irq_setup->base_irq = 0;
 }
 
+void omap_prcm_irq_prepare(void)
+{
+	prcm_irq_setup->suspended = true;
+}
+
+void omap_prcm_irq_complete(void)
+{
+	prcm_irq_setup->suspended = false;
+
+	/* If we have not saved the masks, do not attempt to restore */
+	if (!prcm_irq_setup->suspend_save_flag)
+		return;
+
+	prcm_irq_setup->suspend_save_flag = false;
+
+	/*
+	 * Re-enable all masked PRCM irq sources, this causes the PRCM
+	 * interrupt to fire immediately if the events were masked
+	 * previously in the chain handler
+	 */
+	prcm_irq_setup->restore_irqen(prcm_irq_setup->saved_mask);
+}
+
 /**
  * omap_prcm_register_chain_handler - initializes the prcm chained interrupt
  * handler based on provided parameters
@@ -219,10 +260,12 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 	prcm_irq_setup = irq_setup;
 
 	prcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);
+	prcm_irq_setup->saved_mask = kzalloc(sizeof(u32) * nr_regs, GFP_KERNEL);
 	prcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,
 		GFP_KERNEL);
 
-	if (!prcm_irq_chips || !prcm_irq_setup->priority_mask) {
+	if (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||
+	    !prcm_irq_setup->priority_mask) {
 		pr_err("PRCM: kzalloc failed\n");
 		goto err;
 	}

commit 0a84a91c37ada296ffe7147e73af99b5654628ec
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Dec 16 14:36:58 2011 -0700

    ARM: OMAP: PRCM: add support for chain interrupt handler
    
    Introduce a chained interrupt handler mechanism for the PRCM
    interrupt, so that individual PRCM event can cleanly be handled by
    handlers in separate drivers. We do this by introducing PRCM event
    names, which are then matched to the particular PRCM interrupt bit
    depending on the specific OMAP SoC being used.
    
    PRCM interrupts have two priority levels, high or normal. High priority
    is needed for IO event handling, so that we can be sure that IO events
    are processed before other events. This reduces latency for IO event
    customers and also prevents incorrect ack sequence on OMAP3.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Avinash.H.M <avinashhm@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Govindraj.R <govindraj.raja@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: drop some dead code; use SoC-specific pending IRQ
     detection; move code to prm_common.c; add lots of documentation;
     remove saved_mask; add OCP barrier on ISR exit; improved error
     handling; split out per-SoC initialization to a separate patch]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
new file mode 100644
index 000000000000..5694be56a947
--- /dev/null
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -0,0 +1,277 @@
+/*
+ * OMAP2+ common Power & Reset Management (PRM) IP block functions
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ * Tero Kristo <t-kristo@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ * For historical purposes, the API used to configure the PRM
+ * interrupt handler refers to it as the "PRCM interrupt."  The
+ * underlying registers are located in the PRM on OMAP3/4.
+ *
+ * XXX This code should eventually be moved to a PRM driver.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include <mach/system.h>
+#include <plat/common.h>
+#include <plat/prcm.h>
+#include <plat/irqs.h>
+
+#include "prm2xxx_3xxx.h"
+#include "prm44xx.h"
+
+/*
+ * OMAP_PRCM_MAX_NR_PENDING_REG: maximum number of PRM_IRQ*_MPU regs
+ * XXX this is technically not needed, since
+ * omap_prcm_register_chain_handler() could allocate this based on the
+ * actual amount of memory needed for the SoC
+ */
+#define OMAP_PRCM_MAX_NR_PENDING_REG		2
+
+/*
+ * prcm_irq_chips: an array of all of the "generic IRQ chips" in use
+ * by the PRCM interrupt handler code.  There will be one 'chip' per
+ * PRM_{IRQSTATUS,IRQENABLE}_MPU register pair.  (So OMAP3 will have
+ * one "chip" and OMAP4 will have two.)
+ */
+static struct irq_chip_generic **prcm_irq_chips;
+
+/*
+ * prcm_irq_setup: the PRCM IRQ parameters for the hardware the code
+ * is currently running on.  Defined and passed by initialization code
+ * that calls omap_prcm_register_chain_handler().
+ */
+static struct omap_prcm_irq_setup *prcm_irq_setup;
+
+/* Private functions */
+
+/*
+ * Move priority events from events to priority_events array
+ */
+static void omap_prcm_events_filter_priority(unsigned long *events,
+	unsigned long *priority_events)
+{
+	int i;
+
+	for (i = 0; i < prcm_irq_setup->nr_regs; i++) {
+		priority_events[i] =
+			events[i] & prcm_irq_setup->priority_mask[i];
+		events[i] ^= priority_events[i];
+	}
+}
+
+/*
+ * PRCM Interrupt Handler
+ *
+ * This is a common handler for the OMAP PRCM interrupts. Pending
+ * interrupts are detected by a call to prcm_pending_events and
+ * dispatched accordingly. Clearing of the wakeup events should be
+ * done by the SoC specific individual handlers.
+ */
+static void omap_prcm_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned long pending[OMAP_PRCM_MAX_NR_PENDING_REG];
+	unsigned long priority_pending[OMAP_PRCM_MAX_NR_PENDING_REG];
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned int virtirq;
+	int nr_irqs = prcm_irq_setup->nr_regs * 32;
+
+	/*
+	 * Loop until all pending irqs are handled, since
+	 * generic_handle_irq() can cause new irqs to come
+	 */
+	while (1) {
+		prcm_irq_setup->read_pending_irqs(pending);
+
+		/* No bit set, then all IRQs are handled */
+		if (find_first_bit(pending, nr_irqs) >= nr_irqs)
+			break;
+
+		omap_prcm_events_filter_priority(pending, priority_pending);
+
+		/*
+		 * Loop on all currently pending irqs so that new irqs
+		 * cannot starve previously pending irqs
+		 */
+
+		/* Serve priority events first */
+		for_each_set_bit(virtirq, priority_pending, nr_irqs)
+			generic_handle_irq(prcm_irq_setup->base_irq + virtirq);
+
+		/* Serve normal events next */
+		for_each_set_bit(virtirq, pending, nr_irqs)
+			generic_handle_irq(prcm_irq_setup->base_irq + virtirq);
+	}
+	if (chip->irq_ack)
+		chip->irq_ack(&desc->irq_data);
+	if (chip->irq_eoi)
+		chip->irq_eoi(&desc->irq_data);
+	chip->irq_unmask(&desc->irq_data);
+
+	prcm_irq_setup->ocp_barrier(); /* avoid spurious IRQs */
+}
+
+/* Public functions */
+
+/**
+ * omap_prcm_event_to_irq - given a PRCM event name, returns the
+ * corresponding IRQ on which the handler should be registered
+ * @name: name of the PRCM interrupt bit to look up - see struct omap_prcm_irq
+ *
+ * Returns the Linux internal IRQ ID corresponding to @name upon success,
+ * or -ENOENT upon failure.
+ */
+int omap_prcm_event_to_irq(const char *name)
+{
+	int i;
+
+	if (!prcm_irq_setup || !name)
+		return -ENOENT;
+
+	for (i = 0; i < prcm_irq_setup->nr_irqs; i++)
+		if (!strcmp(prcm_irq_setup->irqs[i].name, name))
+			return prcm_irq_setup->base_irq +
+				prcm_irq_setup->irqs[i].offset;
+
+	return -ENOENT;
+}
+
+/**
+ * omap_prcm_irq_cleanup - reverses memory allocated and other steps
+ * done by omap_prcm_register_chain_handler()
+ *
+ * No return value.
+ */
+void omap_prcm_irq_cleanup(void)
+{
+	int i;
+
+	if (!prcm_irq_setup) {
+		pr_err("PRCM: IRQ handler not initialized; cannot cleanup\n");
+		return;
+	}
+
+	if (prcm_irq_chips) {
+		for (i = 0; i < prcm_irq_setup->nr_regs; i++) {
+			if (prcm_irq_chips[i])
+				irq_remove_generic_chip(prcm_irq_chips[i],
+					0xffffffff, 0, 0);
+			prcm_irq_chips[i] = NULL;
+		}
+		kfree(prcm_irq_chips);
+		prcm_irq_chips = NULL;
+	}
+
+	kfree(prcm_irq_setup->priority_mask);
+	prcm_irq_setup->priority_mask = NULL;
+
+	irq_set_chained_handler(prcm_irq_setup->irq, NULL);
+
+	if (prcm_irq_setup->base_irq > 0)
+		irq_free_descs(prcm_irq_setup->base_irq,
+			prcm_irq_setup->nr_regs * 32);
+	prcm_irq_setup->base_irq = 0;
+}
+
+/**
+ * omap_prcm_register_chain_handler - initializes the prcm chained interrupt
+ * handler based on provided parameters
+ * @irq_setup: hardware data about the underlying PRM/PRCM
+ *
+ * Set up the PRCM chained interrupt handler on the PRCM IRQ.  Sets up
+ * one generic IRQ chip per PRM interrupt status/enable register pair.
+ * Returns 0 upon success, -EINVAL if called twice or if invalid
+ * arguments are passed, or -ENOMEM on any other error.
+ */
+int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
+{
+	int nr_regs = irq_setup->nr_regs;
+	u32 mask[OMAP_PRCM_MAX_NR_PENDING_REG];
+	int offset, i;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+
+	if (!irq_setup)
+		return -EINVAL;
+
+	if (prcm_irq_setup) {
+		pr_err("PRCM: already initialized; won't reinitialize\n");
+		return -EINVAL;
+	}
+
+	if (nr_regs > OMAP_PRCM_MAX_NR_PENDING_REG) {
+		pr_err("PRCM: nr_regs too large\n");
+		return -EINVAL;
+	}
+
+	prcm_irq_setup = irq_setup;
+
+	prcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);
+	prcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,
+		GFP_KERNEL);
+
+	if (!prcm_irq_chips || !prcm_irq_setup->priority_mask) {
+		pr_err("PRCM: kzalloc failed\n");
+		goto err;
+	}
+
+	memset(mask, 0, sizeof(mask));
+
+	for (i = 0; i < irq_setup->nr_irqs; i++) {
+		offset = irq_setup->irqs[i].offset;
+		mask[offset >> 5] |= 1 << (offset & 0x1f);
+		if (irq_setup->irqs[i].priority)
+			irq_setup->priority_mask[offset >> 5] |=
+				1 << (offset & 0x1f);
+	}
+
+	irq_set_chained_handler(irq_setup->irq, omap_prcm_irq_handler);
+
+	irq_setup->base_irq = irq_alloc_descs(-1, 0, irq_setup->nr_regs * 32,
+		0);
+
+	if (irq_setup->base_irq < 0) {
+		pr_err("PRCM: failed to allocate irq descs: %d\n",
+			irq_setup->base_irq);
+		goto err;
+	}
+
+	for (i = 0; i <= irq_setup->nr_regs; i++) {
+		gc = irq_alloc_generic_chip("PRCM", 1,
+			irq_setup->base_irq + i * 32, prm_base,
+			handle_level_irq);
+
+		if (!gc) {
+			pr_err("PRCM: failed to allocate generic chip\n");
+			goto err;
+		}
+		ct = gc->chip_types;
+		ct->chip.irq_ack = irq_gc_ack_set_bit;
+		ct->chip.irq_mask = irq_gc_mask_clr_bit;
+		ct->chip.irq_unmask = irq_gc_mask_set_bit;
+
+		ct->regs.ack = irq_setup->ack + i * 4;
+		ct->regs.mask = irq_setup->mask + i * 4;
+
+		irq_setup_generic_chip(gc, mask[i], 0, IRQ_NOREQUEST, 0);
+		prcm_irq_chips[i] = gc;
+	}
+
+	return 0;
+
+err:
+	omap_prcm_irq_cleanup();
+	return -ENOMEM;
+}
