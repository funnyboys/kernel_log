commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 451ae684aaf4..a91f21e3c5b5 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  arch/arm/include/asm/smp.h
  *
  *  Copyright (C) 2004-2005 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef __ASM_ARM_SMP_H
 #define __ASM_ARM_SMP_H

commit 6213f70e7c10fd4a01b65bad3826648fc78df8a8
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Dec 13 14:02:48 2018 +0000

    ARM: smp: remove arch-provided "pen_release"
    
    Consolidating the "pen_release" stuff amongst the various SoC
    implementations gives credence to having a CPU holding pen for
    secondary CPUs.  However, this is far from the truth.
    
    Many SoC implementations cargo-cult copied various bits of the pen
    release implementation from the initial Realview/Versatile Express
    implementation without understanding what it was or why it existed.
    The reason it existed is because these are _development_ platforms,
    and some board firmware is unable to individually control the
    startup of secondary CPUs.  Moreover, they do not have a way to
    power down or reset secondary CPUs for hot-unplug.  Hence, the
    pen_release implementation was designed for ARM Ltd's development
    platforms to provide a working implementation, even though it is
    very far from what is required.
    
    It was decided a while back to reduce the duplication by consolidating
    the "pen_release" variable, but this only made the situation worse -
    we have ended up with several implementations that read this variable
    but do not write it - again, showing the cargo-cult mentality at work,
    lack of proper review of new code, and in some cases a lack of testing.
    
    While it would be preferable to remove pen_release entirely from the
    kernel, this is not possible without help from the SoC maintainers,
    which seems to be lacking.  However, I want to remove pen_release from
    arch code to remove the credence that having it gives.
    
    This patch removes pen_release from the arch code entirely, adding
    private per-SoC definitions for it instead, and explicitly stating
    that write_pen_release() is cargo-cult copied and should not be
    copied any further.  Rename write_pen_release() in a similar fashion
    as well.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 709a55989cb0..451ae684aaf4 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -67,7 +67,6 @@ struct secondary_data {
 	void *stack;
 };
 extern struct secondary_data secondary_data;
-extern volatile int pen_release;
 extern void secondary_startup(void);
 extern void secondary_startup_arm(void);
 

commit a0995c0805b63c930b99970f2c9d5e4f167ca65b
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Oct 16 12:54:05 2017 +0100

    ARM: 8708/1: NOMMU: Rework MPU to be mostly done in C
    
    Currently, there are several issues with how MPU is setup:
    
     1. We won't boot if MPU is missing
     2. We won't boot if use XIP
     3. Further extension of MPU setup requires asm skills
    
    The 1st point can be relaxed, so we can continue with boot CPU even if
    MPU is missed and fail boot for secondaries only. To address the 2nd
    point we could create region covering CONFIG_XIP_PHYS_ADDR - _end and
    that might work for the first stage of MPU enable, but due to MPU's
    alignment requirement we could cover too much, IOW we need more
    flexibility in how we're partitioning memory regions... and it'd be
    hardly possible to archive because of the 3rd point.
    
    This patch is trying to address 1st and 3rd issues and paves the path
    for 2nd and further improvements.
    
    The most visible change introduced with this patch is that we start
    using mpu_rgn_info array (as it was supposed?), so change in MPU setup
    done by boot CPU is recorded there and feed to secondaries. It
    allows us to keep minimal region setup for boot CPU and do the rest in
    C. Since we start programming MPU regions in C evaluation of MPU
    constrains (number of regions supported and minimal region order) can
    be done once, which in turn open possibility to free-up "probe"
    region early.
    
    Tested-by: Szemző András <sza@esh.hu>
    Tested-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Tested-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 3d6dc8b460e4..709a55989cb0 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -60,7 +60,7 @@ asmlinkage void secondary_start_kernel(void);
  */
 struct secondary_data {
 	union {
-		unsigned long mpu_rgn_szr;
+		struct mpu_rgn_info *mpu_rgn_info;
 		u64 pgdir;
 	};
 	unsigned long swapper_pg_dir;

commit f460b6abdeeafd30c3ee737c843be17b1ceb38e5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 26 07:49:12 2015 +0100

    ARM: 8423/1: add const qualifier to smp_operations member in structures
    
    The core framework does not modify smp_operations structures.
    To clarify it, this commit adds 'const' qualifier to the 'ops'
    member of struct of_cpu_method and the 'smp' member of struct
    machine_desc.
    
    This change allows each SoC code to add 'const' qualifier to its
    smp_operation structure.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 2f8bd44e65c4..3d6dc8b460e4 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -112,7 +112,7 @@ struct smp_operations {
 
 struct of_cpu_method {
 	const char *method;
-	struct smp_operations *ops;
+	const struct smp_operations *ops;
 };
 
 #define CPU_METHOD_OF_DECLARE(name, _method, _ops)			\

commit 4caa9dda388f34f957a9eb52b9f5ef1a8c975c7b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 26 07:49:11 2015 +0100

    ARM: 8424/1: add const qualifier to the argument of smp_set_ops()
    
    This function just copies '*ops' to 'smp_ops', so the given
    structure '*ops' is not modified at all.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index ef356659b4f4..2f8bd44e65c4 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -122,6 +122,6 @@ struct of_cpu_method {
 /*
  * set platform specific SMP operations
  */
-extern void smp_set_ops(struct smp_operations *);
+extern void smp_set_ops(const struct smp_operations *);
 
 #endif /* ifndef __ASM_ARM_SMP_H */

commit 9205b797dbe519a629267ec8c5766cd973d35063
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Aug 24 21:49:30 2015 +0100

    ARM: 8421/1: smp: Collapse arch_cpu_idle_dead() into cpu_die()
    
    The only caller of cpu_die() on ARM is arch_cpu_idle_dead(), so
    let's simplify the code by renaming cpu_die() to
    arch_cpu_idle_dead(). While were here, drop the __ref annotation
    because __cpuinit is gone nowadays.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 318ce89eeff7..ef356659b4f4 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -74,7 +74,6 @@ extern void secondary_startup_arm(void);
 extern int __cpu_disable(void);
 
 extern void __cpu_die(unsigned int cpu);
-extern void cpu_die(void);
 
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);

commit 787047eea24a2443c366679ae6b5a3873a33b64e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 29 00:34:48 2015 +0100

    ARM: 8392/3: smp: Only expose /sys/.../cpuX/online if hotpluggable
    
    Writes to /sys/.../cpuX/online fail if we determine the platform
    doesn't support hotplug for that CPU. Furthermore, if the cpu_die
    op isn't specified the system hangs when we try to offline a CPU
    and it comes right back online unexpectedly. Let's figure this
    stuff out before we make the sysfs nodes so that the online file
    doesn't even exist if it isn't (at least sometimes) possible to
    hotplug the CPU.
    
    Add a new 'cpu_can_disable' op and repoint all 'cpu_disable'
    implementations at it because all implementers use the op to
    indicate if a CPU can be hotplugged or not in a static fashion.
    With PSCI we may need to add a 'cpu_disable' op so that the
    secure OS can be migrated off the CPU we're trying to hotplug.
    In this case, the 'cpu_can_disable' op will indicate that all
    CPUs are hotpluggable by returning true, but the 'cpu_disable' op
    will make a PSCI migration call and occasionally fail, denying
    the hotplug of a CPU. This shouldn't be any worse than x86 where
    we may indicate that all CPUs are hotpluggable but occasionally
    we can't offline a CPU due to check_irq_vectors_for_cpu_disable()
    failing to find a CPU to move vectors to.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Dave Martin <Dave.Martin@arm.com>
    Acked-by: Simon Horman <horms@verge.net.au> [shmobile portion]
    Tested-by: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: <linux-sh@vger.kernel.org>
    Tested-by: Tyler Baker <tyler.baker@linaro.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 2f3ac1ba6fb4..318ce89eeff7 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -105,6 +105,7 @@ struct smp_operations {
 #ifdef CONFIG_HOTPLUG_CPU
 	int  (*cpu_kill)(unsigned int cpu);
 	void (*cpu_die)(unsigned int cpu);
+	bool  (*cpu_can_disable)(unsigned int cpu);
 	int  (*cpu_disable)(unsigned int cpu);
 #endif
 #endif

commit 9de44aa4dc969e4a46c2bfbd33d65bfa6ad2a15d
Merge: 6fb18ac9366b 079ed3681d74 ec3bd0e68a67 c76f238e261b 0bbe6b5a73c0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jun 12 21:18:08 2015 +0100

    Merge branches 'arnd-fixes', 'clk', 'misc', 'v7' and 'fixes' into for-next

commit 29d2e5631ca25fc45d68373817cd3f2b5ee7d8d0
Author: Yingjoe Chen <yingjoe.chen@mediatek.com>
Date:   Mon May 18 09:06:13 2015 +0100

    ARM: 8360/1: add secondary_startup_arm prototype in header file
    
    Put secondary_startup_arm() prototype in arch/arm/include/asm/smp.h
    so users doesn't have to add extern prototype in their code.
    
    Signed-off-by: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Reviewed-by: Matthias Brugger <matthias.bgg@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 18f5a554134f..f5cffb76fc90 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -69,6 +69,7 @@ struct secondary_data {
 extern struct secondary_data secondary_data;
 extern volatile int pen_release;
 extern void secondary_startup(void);
+extern void secondary_startup_arm(void);
 
 extern int __cpu_disable(void);
 

commit b2c3e38a54714e917c9e8675ff5812dca1c0f39d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Apr 4 20:09:46 2015 +0100

    ARM: redo TTBR setup code for LPAE
    
    Re-engineer the LPAE TTBR setup code.  Rather than passing some shifted
    address in order to fit in a CPU register, pass either a full physical
    address (in the case of r4, r5 for TTBR0) or a PFN (for TTBR1).
    
    This removes the ARCH_PGD_SHIFT hack, and the last dangerous user of
    cpu_set_ttbr() in the secondary CPU startup code path (which was there
    to re-set TTBR1 to the appropriate high physical address space on
    Keystone2.)
    
    Tested-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 18f5a554134f..487aa08f31ee 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -61,7 +61,7 @@ asmlinkage void secondary_start_kernel(void);
 struct secondary_data {
 	union {
 		unsigned long mpu_rgn_szr;
-		unsigned long pgdir;
+		u64 pgdir;
 	};
 	unsigned long swapper_pg_dir;
 	void *stack;

commit 084bb5bc00c19ec32b45f44d11ba6a0ca2514ec3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Aug 20 20:49:54 2014 +0100

    ARM: 8131/1: arm/smp: Absorb boot_secondary()
    
    After becoming a mandatory function, boot_secondary() is no longer used
    outside arch/arm/kernel/smp.c. Hence remove its public prototype, and,
    as suggested by Arnd, let it be absorbed by its single caller.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 2ec765c39ab4..18f5a554134f 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -48,12 +48,6 @@ extern void smp_init_cpus(void);
  */
 extern void set_smp_cross_call(void (*)(const struct cpumask *, unsigned int));
 
-/*
- * Boot a secondary CPU, and assign it the specified idle task.
- * This also gives us the initial stack to use for this CPU.
- */
-extern int boot_secondary(unsigned int cpu, struct task_struct *);
-
 /*
  * Called from platform specific assembly code, this is the
  * secondary CPU entry point.

commit ff050ad12c551233e546506409c89eb2f640d9f3
Merge: dfc25e4503ae 9233087dc468
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 14:19:54 2014 -0700

    Merge tag 'soc-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC specific changes from Arnd Bergmann:
     "Lots of changes specific to one of the SoC families.  Some that stick
      out are:
    
       - mach-qcom gains new features, most importantly SMP support for the
         newer chips (Stephen Boyd, Rohit Vaswani)
       - mvebu gains support for three new SoCs: Armada 375, 380 and 385
         (Thomas Petazzoni and Free-electrons team)
       - SMP support for Rockchips (Heiko Stübner)
       - Lots of i.MX changes (Shawn Guo)
       - Added support for BCM5301x SoC (Hauke Mehrtens)
       - Multiplatform support for Marvell Kirkwood and Dove (Andrew Lunn
         and Sebastian Hesselbarth doing the final part of a long journey)
       - Unify davinci platforms and remove obsolete ones (Sekhar Nori, Arnd
         Bergmann)"
    
    * tag 'soc-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (126 commits)
      ARM: sunxi: Select HAVE_ARM_ARCH_TIMER
      ARM: cache-tauros2: remove ARMv6 code
      ARM: mvebu: don't select CONFIG_NEON
      ARM: davinci: fix DT booting with default defconfig
      ARM: configs: bcm_defconfig: enable bcm590xx regulator support
      ARM: davinci: remove tnetv107x support
      MAINTAINERS: Update ARM STi maintainers
      ARM: restrict BCM_KONA_UART to ARCH_BCM_MOBILE
      ARM: bcm21664: Add board support.
      ARM: sunxi: Add the new watchog compatibles to the reboot code
      ARM: enable ARM_HAS_SG_CHAIN for multiplatform
      ARM: davinci: remove da8xx_omapl_defconfig
      ARM: davinci: da8xx: fix multiple watchdog device registration
      ARM: davinci: add da8xx specific configs to davinci_all_defconfig
      ARM: davinci: enable da8xx build concurrently with older devices
      ARM: BCM5301X: workaround suppress fault
      ARM: BCM5301X: add early debugging support
      ARM: BCM5301X: initial support for the BCM5301X/BCM470X SoCs with ARM CPU
      ARM: mach-bcm: Remove GENERIC_TIME
      ARM: shmobile: APMU: Fix warnings due to improper printk formats
      ...

commit 1146b600044de64af0ef775025731eeef1fa2189
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Mar 16 18:04:54 2014 +0100

    ARM: sunxi: fix build for THUMB2_KERNEL
    
    Building an SMP kernel for the sunxi platform with THUMB2 instructions
    fails with this error at the moment:
    
    headsmp.S:7: Error: Thumb encoding does not support an immediate here -- `msr cpsr_fsxc,#0xd3'
    
    Since the generic secondary_startup function already does
    the same thing in a safe way, we can just drop the private
    sunxi implementation and jump straight to secondary_startup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 22a3b9b5d4a1..4157aec4e307 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -74,6 +74,7 @@ struct secondary_data {
 };
 extern struct secondary_data secondary_data;
 extern volatile int pen_release;
+extern void secondary_startup(void);
 
 extern int __cpu_disable(void);
 

commit 6c3ff8b11a16ec69199ab85b74a5fae6d9c59db7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Oct 30 18:21:09 2013 -0700

    ARM: Introduce CPU_METHOD_OF_DECLARE() for cpu hotplug/smp
    
    The goal of multi-platform kernels is to remove the need for mach
    directories and machine descriptors. To further that goal,
    introduce CPU_METHOD_OF_DECLARE() to allow cpu hotplug/smp
    support to be separated from the machine descriptors.
    Implementers should specify an enable-method property in their
    cpus node and then implement a matching set of smp_ops in their
    hotplug/smp code, wiring it up with the CPU_METHOD_OF_DECLARE()
    macro. When the kernel is compiled we'll collect all the
    enable-method smp_ops into one section for use at boot.
    
    At boot time we'll look for an enable-method in each cpu node and
    try to match that against all known CPU enable methods in the
    kernel. If there are no enable-methods in the cpu nodes we
    fallback to the cpus node and try to use any enable-method found
    there. If that doesn't work we fall back to the old way of using
    the machine descriptor.
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: <devicetree@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 22a3b9b5d4a1..772435b08207 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -114,6 +114,15 @@ struct smp_operations {
 #endif
 };
 
+struct of_cpu_method {
+	const char *method;
+	struct smp_operations *ops;
+};
+
+#define CPU_METHOD_OF_DECLARE(name, _method, _ops)			\
+	static const struct of_cpu_method __cpu_method_of_table_##name	\
+		__used __section(__cpu_method_of_table)			\
+		= { .method = _method, .ops = _ops }
 /*
  * set platform specific SMP operations
  */

commit 5135d875e1457ef946a055003d8f80713e862135
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Nov 27 21:54:41 2012 -0500

    ARM: SMP: basic IPI triggered completion support
    
    We need a mechanism to let an inbound CPU signal that it is alive before
    even getting into the kernel environment i.e. from early assembly code.
    Using an IPI is the simplest way to achieve that.
    
    This adds some basic infrastructure to register a struct completion
    pointer to be "completed" when the dedicated IPI for this task is
    received.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index a8cae71caceb..22a3b9b5d4a1 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -84,6 +84,8 @@ extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 extern void arch_send_wakeup_ipi_mask(const struct cpumask *mask);
 
+extern int register_ipi_completion(struct completion *completion, int cpu);
+
 struct smp_operations {
 #ifdef CONFIG_SMP
 	/*

commit eb08375ea66e63c5e11dea69b43c5633d531ce81
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Fri Feb 22 18:51:30 2013 +0000

    ARM: mpu: add MPU initialisation for secondary cores
    
    The MPU initialisation on the primary core is performed in two stages, one
    minimal stage to ensure the CPU can boot and a second one after
    sanity_check_meminfo. As the memory configuration is known by the time we
    boot secondary cores only a single step is necessary, provided the values
    for DRSR are passed to secondaries.
    
    This patch implements this arrangement. The configuration generated for the
    MPU regions is made available to the secondary core, which can then use the
    asm MPU intialisation code to program a complete region configuration.
    
    This is necessary for SMP configurations without an MMU, as the MPU
    initialisation is the only way to ensure that memory is specified as
    'shared'.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    CC: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index d3a22bebe6ce..a8cae71caceb 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -65,7 +65,10 @@ asmlinkage void secondary_start_kernel(void);
  * Initial data for bringing up a secondary CPU.
  */
 struct secondary_data {
-	unsigned long pgdir;
+	union {
+		unsigned long mpu_rgn_szr;
+		unsigned long pgdir;
+	};
 	unsigned long swapper_pg_dir;
 	void *stack;
 };

commit b62655f4c6f3e4d21934eee14ac2ac5cd479c97c
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Nov 6 03:48:40 2012 +0100

    ARM: 7571/1: SMP: add function arch_send_wakeup_ipi_mask()
    
    Add function arch_send_wakeup_ipi_mask(), so that platform code can
    use it as an easy way to wake up cores that are in WFI.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 2e3be16c6766..d3a22bebe6ce 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -79,6 +79,7 @@ extern void cpu_die(void);
 
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
+extern void arch_send_wakeup_ipi_mask(const struct cpumask *mask);
 
 struct smp_operations {
 #ifdef CONFIG_SMP

commit 28e8e29c616f947348cc66bea684d0035c76021a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 12 11:16:27 2012 +0100

    ARM: consolidate pen_release instead of having per platform definitions
    
    Almost each SMP platform defines pen_release to manage booting secondary
    CPUs. This of course clashes with the single zImage effort.
    
    Add the pen_release definition to the ARM SMP code, and remove all others.
    This should only be used by platforms which lack any kind of CPU power
    management...
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 3a8cfee26c91..2e3be16c6766 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -70,6 +70,7 @@ struct secondary_data {
 	void *stack;
 };
 extern struct secondary_data secondary_data;
+extern volatile int pen_release;
 
 extern int __cpu_disable(void);
 

commit ac6c7998712d55bd15aa2dd5ae85f5988c0cb526
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Sep 27 14:48:23 2011 +0100

    ARM: smp: Make SMP operations mandatory
    
    Now that all SMP platforms have been converted to use struct
    smp_operations, remove the "weak" attribute from the hooks
    in smp.c, and make the functions static wherever possible.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index f79a9f51e322..3a8cfee26c91 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -60,15 +60,6 @@ extern int boot_secondary(unsigned int cpu, struct task_struct *);
  */
 asmlinkage void secondary_start_kernel(void);
 
-/*
- * Perform platform specific initialisation of the specified CPU.
- */
-extern void platform_secondary_init(unsigned int cpu);
-
-/*
- * Initialize cpu_possible map, and enable coherency
- */
-extern void platform_smp_prepare_cpus(unsigned int);
 
 /*
  * Initial data for bringing up a secondary CPU.
@@ -81,15 +72,10 @@ struct secondary_data {
 extern struct secondary_data secondary_data;
 
 extern int __cpu_disable(void);
-extern int platform_cpu_disable(unsigned int cpu);
 
 extern void __cpu_die(unsigned int cpu);
 extern void cpu_die(void);
 
-extern void platform_cpu_die(unsigned int cpu);
-extern int platform_cpu_kill(unsigned int cpu);
-extern void platform_cpu_enable(unsigned int cpu);
-
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 

commit abcee5fb0dfbb248d883a2f6bdb4820abe3ac524
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 09:06:10 2011 +0100

    ARM: SoC: add per-platform SMP operations
    
    This adds a 'struct smp_operations' to abstract the CPU initialization
    and hot plugging functions on SMP systems, which otherwise conflict
    in a multiplatform kernel. This also helps shmobile and potentially
    others that have more than one method to do these.
    
    To allow the kernel to continue building, the platform hooks are
    defined as weak symbols which are overrided by the platform code.
    Once all platforms are converted, the "weak" attribute will be
    removed and the function made static.
    
    Unlike the original version from Marc, this new version from Arnd
    does not use a generalized abstraction for per-soc data structures
    but only tries to solve the problem for the SMP operations. This
    way, we can collapse the previous four data structures into a
    single struct, which is less systematic but also easier to follow
    as a causal reader.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index ae29293270a3..f79a9f51e322 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -93,4 +93,37 @@ extern void platform_cpu_enable(unsigned int cpu);
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 
+struct smp_operations {
+#ifdef CONFIG_SMP
+	/*
+	 * Setup the set of possible CPUs (via set_cpu_possible)
+	 */
+	void (*smp_init_cpus)(void);
+	/*
+	 * Initialize cpu_possible map, and enable coherency
+	 */
+	void (*smp_prepare_cpus)(unsigned int max_cpus);
+
+	/*
+	 * Perform platform specific initialisation of the specified CPU.
+	 */
+	void (*smp_secondary_init)(unsigned int cpu);
+	/*
+	 * Boot a secondary CPU, and assign it the specified idle task.
+	 * This also gives us the initial stack to use for this CPU.
+	 */
+	int  (*smp_boot_secondary)(unsigned int cpu, struct task_struct *idle);
+#ifdef CONFIG_HOTPLUG_CPU
+	int  (*cpu_kill)(unsigned int cpu);
+	void (*cpu_die)(unsigned int cpu);
+	int  (*cpu_disable)(unsigned int cpu);
+#endif
+#endif
+};
+
+/*
+ * set platform specific SMP operations
+ */
+extern void smp_set_ops(struct smp_operations *);
+
 #endif /* ifndef __ASM_ARM_SMP_H */

commit eb50439b92b6298bf209a982f295ba9c0f7cb30b
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jan 20 12:01:12 2012 +0100

    ARM: 7293/1: logical_cpu_map: decouple CPU mapping from SMP
    
    It turns out that the logical CPU mapping is useful even when !CONFIG_SMP
    for manipulation of devices like interrupt and power controllers when
    running a UP kernel on a CPU other than 0. This can happen when kexecing
    a UP image from an SMP kernel.
    
    In the future, multi-cluster systems running AMP configurations will
    require something similar for mapping cluster IDs, so it makes sense to
    decouple this logic in preparation for this support.
    
    Acked-by: Yang Bai <hamo.by@gmail.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reported-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 1e5717afc4ac..ae29293270a3 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -70,12 +70,6 @@ extern void platform_secondary_init(unsigned int cpu);
  */
 extern void platform_smp_prepare_cpus(unsigned int);
 
-/*
- * Logical CPU mapping.
- */
-extern int __cpu_logical_map[NR_CPUS];
-#define cpu_logical_map(cpu)	__cpu_logical_map[cpu]
-
 /*
  * Initial data for bringing up a secondary CPU.
  */

commit 292b293ceef2eda1f96f0c90b96e954d7bdabd1c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Jul 20 16:24:14 2011 +0100

    ARM: gic: consolidate PPI handling
    
    PPI handling is a bit of an odd beast. It uses its own low level
    handling code and is hardwired to the local timers (hence lacking
    a registration interface).
    
    Instead, switch the low handling to the normal SPI handling code.
    PPIs are handled by the handle_percpu_devid_irq flow.
    
    This also allows the removal of some duplicated code.
    
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David Brown <davidb@codeaurora.org>
    Tested-by: David Brown <davidb@codeaurora.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 0a17b62538c2..1e5717afc4ac 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -99,9 +99,4 @@ extern void platform_cpu_enable(unsigned int cpu);
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 
-/*
- * show local interrupt info
- */
-extern void show_local_irqs(struct seq_file *, int);
-
 #endif /* ifndef __ASM_ARM_SMP_H */

commit 0b5a1b95dcdfa451125132d5ce3f79a27ffb0950
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Oct 6 15:18:14 2011 +0100

    ARM: 7123/1: smp: Add an IPI handler callable from C code
    
    In order to be able to handle IPI directly from C code instead of
    assembly code, introduce handle_IPI(), which is modeled after handle_IRQ().
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 674ebcd337fe..0a17b62538c2 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -32,6 +32,11 @@ extern void show_ipi_list(struct seq_file *, int);
  */
 asmlinkage void do_IPI(int ipinr, struct pt_regs *regs);
 
+/*
+ * Called from C code, this handles an IPI.
+ */
+void handle_IPI(int ipinr, struct pt_regs *regs);
+
 /*
  * Setup the set of possible CPUs (via set_cpu_possible)
  */

commit d6257288c4052465feeff7e283e35ec0ed06ca03
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Aug 23 22:19:29 2011 +0100

    ARM: 7060/1: smp: populate logical CPU mapping during boot
    
    To allow booting Linux on a CPU with physical ID != 0, we need to
    provide a mapping from the logical CPU number to the physical CPU
    number.
    
    This patch adds such a mapping and populates it during boot.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index e42d96a45d3e..674ebcd337fe 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -65,6 +65,12 @@ extern void platform_secondary_init(unsigned int cpu);
  */
 extern void platform_smp_prepare_cpus(unsigned int);
 
+/*
+ * Logical CPU mapping.
+ */
+extern int __cpu_logical_map[NR_CPUS];
+#define cpu_logical_map(cpu)	__cpu_logical_map[cpu]
+
 /*
  * Initial data for bringing up a secondary CPU.
  */

commit d427958a46af24f75d0017c45eadd172273bbf33
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu May 26 11:22:44 2011 +0100

    ARM: 6942/1: mm: make TTBR1 always point to swapper_pg_dir on ARMv6/7
    
    This patch makes TTBR1 point to swapper_pg_dir so that global, kernel
    mappings can be used exclusively on v6 and v7 cores where they are
    needed.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index d2b514fd76f4..e42d96a45d3e 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -70,6 +70,7 @@ extern void platform_smp_prepare_cpus(unsigned int);
  */
 struct secondary_data {
 	unsigned long pgdir;
+	unsigned long swapper_pg_dir;
 	void *stack;
 };
 extern struct secondary_data secondary_data;

commit 818b667ba57f68bf1e7240fa441dda0b11e6b944
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue May 24 17:13:08 2011 -0700

    Remove unused PROC_CHANGE_PENALTY constant
    
    This constant hasn't been used since before the git era (2.6.12) and thus
    can be dropped.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index a87664f54f93..d2b514fd76f4 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -20,12 +20,6 @@
 
 #define raw_smp_processor_id() (current_thread_info()->cpu)
 
-/*
- * at the moment, there's not a big penalty for changing CPUs
- * (the >big< penalty is running SMP in the first place)
- */
-#define PROC_CHANGE_PENALTY		15
-
 struct seq_file;
 
 /*

commit 0f7b332f9777819a39a3b325690379a7efef89d1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 3 13:01:30 2011 +0100

    ARM: consolidate SMP cross call implementation
    
    Rather than having each platform class provide a mach/smp.h header for
    smp_cross_call(), arrange for them to register the function with the
    core ARM SMP code instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 96ed521f2408..a87664f54f93 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -14,8 +14,6 @@
 #include <linux/cpumask.h>
 #include <linux/thread_info.h>
 
-#include <mach/smp.h>
-
 #ifndef CONFIG_SMP
 # error "<asm/smp.h> included in non-SMP build"
 #endif
@@ -47,9 +45,9 @@ extern void smp_init_cpus(void);
 
 
 /*
- * Raise an IPI cross call on CPUs in callmap.
+ * Provide a function to raise an IPI cross call on CPUs in callmap.
  */
-extern void smp_cross_call(const struct cpumask *mask, int ipi);
+extern void set_smp_cross_call(void (*)(const struct cpumask *, unsigned int));
 
 /*
  * Boot a secondary CPU, and assign it the specified idle task.

commit 05c74a6cbcfb416286a947668ba32f63d99fe74a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 11:09:48 2010 +0000

    ARM: SMP: consolidate the common parts of smp_prepare_cpus()
    
    There is a certain amount of smp_prepare_cpus() which doesn't belong
    in the platform support code - that is, code which is invariant to the
    SMP implementation.  Move this code into arch/arm/kernel/smp.c, and
    add a platform_ prefix to the original function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index f93d0a637016..96ed521f2408 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -45,10 +45,6 @@ asmlinkage void do_IPI(int ipinr, struct pt_regs *regs);
  */
 extern void smp_init_cpus(void);
 
-/*
- * Move global data into per-processor storage.
- */
-extern void smp_store_cpu_info(unsigned int cpuid);
 
 /*
  * Raise an IPI cross call on CPUs in callmap.
@@ -72,6 +68,11 @@ asmlinkage void secondary_start_kernel(void);
  */
 extern void platform_secondary_init(unsigned int cpu);
 
+/*
+ * Initialize cpu_possible map, and enable coherency
+ */
+extern void platform_smp_prepare_cpus(unsigned int);
+
 /*
  * Initial data for bringing up a secondary CPU.
  */

commit f13cd4170ee789f63b3c9585c1ae34e028bd549d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Nov 15 14:33:51 2010 +0000

    ARM: fix /proc/interrupts formatting
    
    As per x86, align the initial column according to how many IRQs we
    have.  Also, provide an english explaination for the 'LOC:' and
    'IPI:' lines.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index da7e7ca53cc1..f93d0a637016 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -33,7 +33,7 @@ struct seq_file;
 /*
  * generate IPI list text
  */
-extern void show_ipi_list(struct seq_file *p);
+extern void show_ipi_list(struct seq_file *, int);
 
 /*
  * Called from assembly code, this handles an IPI.
@@ -97,6 +97,6 @@ extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 /*
  * show local interrupt info
  */
-extern void show_local_irqs(struct seq_file *);
+extern void show_local_irqs(struct seq_file *, int);
 
 #endif /* ifndef __ASM_ARM_SMP_H */

commit ad3b6993b9c5482e8a2ec5aed181538c921fdcbd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Nov 15 09:42:08 2010 +0000

    ARM: SMP: pass an ipi number to smp_cross_call()
    
    This allows us to use smp_cross_call() to trigger a number of different
    software generated interrupts, rather than combining them all on one
    SGI.  Recover the SGI number via do_IPI.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 3d05190797cb..da7e7ca53cc1 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -38,7 +38,7 @@ extern void show_ipi_list(struct seq_file *p);
 /*
  * Called from assembly code, this handles an IPI.
  */
-asmlinkage void do_IPI(struct pt_regs *regs);
+asmlinkage void do_IPI(int ipinr, struct pt_regs *regs);
 
 /*
  * Setup the set of possible CPUs (via set_cpu_possible)
@@ -53,7 +53,7 @@ extern void smp_store_cpu_info(unsigned int cpuid);
 /*
  * Raise an IPI cross call on CPUs in callmap.
  */
-extern void smp_cross_call(const struct cpumask *mask);
+extern void smp_cross_call(const struct cpumask *mask, int ipi);
 
 /*
  * Boot a secondary CPU, and assign it the specified idle task.

commit 8e2a43f5f5e1255879064924917fb1a6e5be7cb3
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 15 10:18:05 2010 +0100

    ARM: rename mach_cpu_disable() to platform_cpu_disable()
    
    Consistently name all SMP platform related functions.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index e0d763be1846..3d05190797cb 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -82,7 +82,7 @@ struct secondary_data {
 extern struct secondary_data secondary_data;
 
 extern int __cpu_disable(void);
-extern int mach_cpu_disable(unsigned int cpu);
+extern int platform_cpu_disable(unsigned int cpu);
 
 extern void __cpu_die(unsigned int cpu);
 extern void cpu_die(void);

commit 0748bd01773395003208996c4c0b3f80caf80976
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Sep 24 09:34:46 2009 -0600

    cpumask: remove arch_send_call_function_ipi
    
    Now everyone is converted to arch_send_call_function_ipi_mask, remove
    the shim and the #defines.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index a06e735b262a..e0d763be1846 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -93,7 +93,6 @@ extern void platform_cpu_enable(unsigned int cpu);
 
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
-#define arch_send_call_function_ipi_mask arch_send_call_function_ipi_mask
 
 /*
  * show local interrupt info

commit e03cdade0ca945a04e982525e50fef275190b77b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu May 28 14:16:52 2009 +0100

    [ARM] smp: use new cpumask functions
    
    Convert cpu_*_mask bit twiddling to the new set_cpu_*() API.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 608f2d533ff2..a06e735b262a 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -41,7 +41,7 @@ extern void show_ipi_list(struct seq_file *p);
 asmlinkage void do_IPI(struct pt_regs *regs);
 
 /*
- * Setup the SMP cpu_possible_map
+ * Setup the set of possible CPUs (via set_cpu_possible)
  */
 extern void smp_init_cpus(void);
 

commit bc28248ee25e5c239cbe6afca35a100b08401de5
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun May 17 18:58:34 2009 +0100

    [ARM] smp: move core localtimer support out of platform specific files
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 5995935338e1..608f2d533ff2 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -55,11 +55,6 @@ extern void smp_store_cpu_info(unsigned int cpuid);
  */
 extern void smp_cross_call(const struct cpumask *mask);
 
-/*
- * Broadcast a clock event to other CPUs.
- */
-extern void smp_timer_broadcast(const struct cpumask *mask);
-
 /*
  * Boot a secondary CPU, and assign it the specified idle task.
  * This also gives us the initial stack to use for this CPU.
@@ -100,44 +95,9 @@ extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 #define arch_send_call_function_ipi_mask arch_send_call_function_ipi_mask
 
-/*
- * Local timer interrupt handling function (can be IPI'ed).
- */
-extern void local_timer_interrupt(void);
-
-#ifdef CONFIG_LOCAL_TIMERS
-
-/*
- * Stop a local timer interrupt.
- */
-extern void local_timer_stop(void);
-
-/*
- * Platform provides this to acknowledge a local timer IRQ
- */
-extern int local_timer_ack(void);
-
-#else
-
-static inline void local_timer_stop(void)
-{
-}
-
-#endif
-
-/*
- * Setup a local timer interrupt for a CPU.
- */
-extern void local_timer_setup(void);
-
 /*
  * show local interrupt info
  */
 extern void show_local_irqs(struct seq_file *);
 
-/*
- * Called from assembly, this is the local timer IRQ handler
- */
-asmlinkage void do_local_timer(struct pt_regs *);
-
 #endif /* ifndef __ASM_ARM_SMP_H */

commit 826681043d7184b4d650cab5b007b9a86b628eb5
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun May 17 16:20:18 2009 +0100

    [ARM] smp: fix cpumask usage in ARM SMP code
    
    The ARM SMP code wasn't properly updated for the cpumask changes, which
    results in smp_timer_broadcast() broadcasting ticks to non-online CPUs.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index fad70da5911d..5995935338e1 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -53,17 +53,12 @@ extern void smp_store_cpu_info(unsigned int cpuid);
 /*
  * Raise an IPI cross call on CPUs in callmap.
  */
-extern void smp_cross_call(cpumask_t callmap);
-
-/*
- * Broadcast a timer interrupt to the other CPUs.
- */
-extern void smp_send_timer(void);
+extern void smp_cross_call(const struct cpumask *mask);
 
 /*
  * Broadcast a clock event to other CPUs.
  */
-extern void smp_timer_broadcast(cpumask_t mask);
+extern void smp_timer_broadcast(const struct cpumask *mask);
 
 /*
  * Boot a secondary CPU, and assign it the specified idle task.
@@ -102,7 +97,8 @@ extern int platform_cpu_kill(unsigned int cpu);
 extern void platform_cpu_enable(unsigned int cpu);
 
 extern void arch_send_call_function_single_ipi(int cpu);
-extern void arch_send_call_function_ipi(cpumask_t mask);
+extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
+#define arch_send_call_function_ipi_mask arch_send_call_function_ipi_mask
 
 /*
  * Local timer interrupt handling function (can be IPI'ed).

commit ebac6546df7e8bd17f66f029c616ea9ee3c595ae
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Dec 1 14:54:57 2008 +0000

    RealView: Use only the shadow mapping of ARM11MPCore local timers
    
    All the cases where the local timer for a CPU is accessed happen on the
    corresponding current CPU, hence no need to access the per-CPU local
    timer mappings.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 727b5c042e52..fad70da5911d 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -114,7 +114,7 @@ extern void local_timer_interrupt(void);
 /*
  * Stop a local timer interrupt.
  */
-extern void local_timer_stop(unsigned int cpu);
+extern void local_timer_stop(void);
 
 /*
  * Platform provides this to acknowledge a local timer IRQ
@@ -123,7 +123,7 @@ extern int local_timer_ack(void);
 
 #else
 
-static inline void local_timer_stop(unsigned int cpu)
+static inline void local_timer_stop(void)
 {
 }
 
@@ -132,7 +132,7 @@ static inline void local_timer_stop(unsigned int cpu)
 /*
  * Setup a local timer interrupt for a CPU.
  */
-extern void local_timer_setup(unsigned int cpu);
+extern void local_timer_setup(void);
 
 /*
  * show local interrupt info

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index cc12a525a06a..727b5c042e52 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -14,7 +14,7 @@
 #include <linux/cpumask.h>
 #include <linux/thread_info.h>
 
-#include <asm/arch/smp.h>
+#include <mach/smp.h>
 
 #ifndef CONFIG_SMP
 # error "<asm/smp.h> included in non-SMP build"

commit 4baa9922430662431231ac637adedddbb0cfb2d7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Aug 2 10:55:55 2008 +0100

    [ARM] move include/asm-arm to arch/arm/include/asm
    
    Move platform independent header files to arch/arm/include/asm, leaving
    those in asm/arch* and asm/plat* alone.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
new file mode 100644
index 000000000000..cc12a525a06a
--- /dev/null
+++ b/arch/arm/include/asm/smp.h
@@ -0,0 +1,147 @@
+/*
+ *  arch/arm/include/asm/smp.h
+ *
+ *  Copyright (C) 2004-2005 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_SMP_H
+#define __ASM_ARM_SMP_H
+
+#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <linux/thread_info.h>
+
+#include <asm/arch/smp.h>
+
+#ifndef CONFIG_SMP
+# error "<asm/smp.h> included in non-SMP build"
+#endif
+
+#define raw_smp_processor_id() (current_thread_info()->cpu)
+
+/*
+ * at the moment, there's not a big penalty for changing CPUs
+ * (the >big< penalty is running SMP in the first place)
+ */
+#define PROC_CHANGE_PENALTY		15
+
+struct seq_file;
+
+/*
+ * generate IPI list text
+ */
+extern void show_ipi_list(struct seq_file *p);
+
+/*
+ * Called from assembly code, this handles an IPI.
+ */
+asmlinkage void do_IPI(struct pt_regs *regs);
+
+/*
+ * Setup the SMP cpu_possible_map
+ */
+extern void smp_init_cpus(void);
+
+/*
+ * Move global data into per-processor storage.
+ */
+extern void smp_store_cpu_info(unsigned int cpuid);
+
+/*
+ * Raise an IPI cross call on CPUs in callmap.
+ */
+extern void smp_cross_call(cpumask_t callmap);
+
+/*
+ * Broadcast a timer interrupt to the other CPUs.
+ */
+extern void smp_send_timer(void);
+
+/*
+ * Broadcast a clock event to other CPUs.
+ */
+extern void smp_timer_broadcast(cpumask_t mask);
+
+/*
+ * Boot a secondary CPU, and assign it the specified idle task.
+ * This also gives us the initial stack to use for this CPU.
+ */
+extern int boot_secondary(unsigned int cpu, struct task_struct *);
+
+/*
+ * Called from platform specific assembly code, this is the
+ * secondary CPU entry point.
+ */
+asmlinkage void secondary_start_kernel(void);
+
+/*
+ * Perform platform specific initialisation of the specified CPU.
+ */
+extern void platform_secondary_init(unsigned int cpu);
+
+/*
+ * Initial data for bringing up a secondary CPU.
+ */
+struct secondary_data {
+	unsigned long pgdir;
+	void *stack;
+};
+extern struct secondary_data secondary_data;
+
+extern int __cpu_disable(void);
+extern int mach_cpu_disable(unsigned int cpu);
+
+extern void __cpu_die(unsigned int cpu);
+extern void cpu_die(void);
+
+extern void platform_cpu_die(unsigned int cpu);
+extern int platform_cpu_kill(unsigned int cpu);
+extern void platform_cpu_enable(unsigned int cpu);
+
+extern void arch_send_call_function_single_ipi(int cpu);
+extern void arch_send_call_function_ipi(cpumask_t mask);
+
+/*
+ * Local timer interrupt handling function (can be IPI'ed).
+ */
+extern void local_timer_interrupt(void);
+
+#ifdef CONFIG_LOCAL_TIMERS
+
+/*
+ * Stop a local timer interrupt.
+ */
+extern void local_timer_stop(unsigned int cpu);
+
+/*
+ * Platform provides this to acknowledge a local timer IRQ
+ */
+extern int local_timer_ack(void);
+
+#else
+
+static inline void local_timer_stop(unsigned int cpu)
+{
+}
+
+#endif
+
+/*
+ * Setup a local timer interrupt for a CPU.
+ */
+extern void local_timer_setup(unsigned int cpu);
+
+/*
+ * show local interrupt info
+ */
+extern void show_local_irqs(struct seq_file *);
+
+/*
+ * Called from assembly, this is the local timer IRQ handler
+ */
+asmlinkage void do_local_timer(struct pt_regs *);
+
+#endif /* ifndef __ASM_ARM_SMP_H */
