commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index 1714800fa113..45a75d9381eb 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * arch/arm/include/asm/bL_switcher.h
  *
  * Created by:  Nicolas Pitre, April 2012
  * Copyright:   (C) 2012-2013  Linaro Limited
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef ASM_BL_SWITCHER_H

commit d08e2e09042bd3f7ef66a35cb4bb92794ab26bb2
Author: Dave Martin <dave.martin@linaro.org>
Date:   Wed Feb 13 16:20:44 2013 +0000

    ARM: bL_switcher: Add query interface to discover CPU affinities
    
    When the switcher is active, there is no straightforward way to
    figure out which logical CPU a given physical CPU maps to.
    
    This patch provides a function
    bL_switcher_get_logical_index(mpidr), which is analogous to
    get_logical_index().
    
    This function returns the logical CPU on which the specified
    physical CPU is grouped (or -EINVAL if unknown).
    If the switcher is inactive or not present, -EUNATCH is returned instead.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index 8ada5a885c70..1714800fa113 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -55,6 +55,7 @@ bool bL_switcher_get_enabled(void);
 void bL_switcher_put_enabled(void);
 
 int bL_switcher_trace_trigger(void);
+int bL_switcher_get_logical_index(u32 mpidr);
 
 #else
 static inline int bL_switcher_register_notifier(struct notifier_block *nb)
@@ -70,6 +71,7 @@ static inline int bL_switcher_unregister_notifier(struct notifier_block *nb)
 static inline bool bL_switcher_get_enabled(void) { return false; }
 static inline void bL_switcher_put_enabled(void) { }
 static inline int bL_switcher_trace_trigger(void) { return 0; }
+static inline int bL_switcher_get_logical_index(u32 mpidr) { return -EUNATCH; }
 #endif /* CONFIG_BL_SWITCHER */
 
 #endif

commit 29064b88466ee725613db16d8c05b0ec5443a309
Author: Dave Martin <dave.martin@linaro.org>
Date:   Mon Feb 11 14:39:19 2013 +0000

    ARM: bL_switcher/trace: Add kernel trace trigger interface
    
    This patch exports a bL_switcher_trace_trigger() function to
    provide a means for drivers using the trace events to get the
    current status when starting a trace session.
    
    Calling this function is equivalent to pinging the trace_trigger
    file in sysfs.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index 7d1cce8b8a0d..8ada5a885c70 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -54,6 +54,8 @@ int bL_switcher_unregister_notifier(struct notifier_block *nb);
 bool bL_switcher_get_enabled(void);
 void bL_switcher_put_enabled(void);
 
+int bL_switcher_trace_trigger(void);
+
 #else
 static inline int bL_switcher_register_notifier(struct notifier_block *nb)
 {
@@ -67,6 +69,7 @@ static inline int bL_switcher_unregister_notifier(struct notifier_block *nb)
 
 static inline bool bL_switcher_get_enabled(void) { return false; }
 static inline void bL_switcher_put_enabled(void) { }
+static inline int bL_switcher_trace_trigger(void) { return 0; }
 #endif /* CONFIG_BL_SWITCHER */
 
 #endif

commit 0577fee283fb385afbcdb78d1f4c398d7326b68f
Author: Dave Martin <dave.martin@linaro.org>
Date:   Wed May 22 19:08:16 2013 +0100

    ARM: bL_switcher: Add switch completion callback for bL_switch_request()
    
    There is no explicit way to know when a switch started via
    bL_switch_request() is complete.  This can lead to unpredictable
    behaviour when the switcher is controlled by a subsystem which
    makes dynamic decisions (such as cpufreq).
    
    The CPU PM notifier is not really suitable for signalling
    completion, because the CPU could get suspended and resumed for
    other, independent reasons while a switch request is in flight.
    Adding a whole new notifier for this seems excessive, and may tempt
    people to put heavyweight code on this path.
    
    This patch implements a new bL_switch_request_cb() function that
    allows for a per-request lightweight callback, private between the
    switcher and the caller of bL_switch_request_cb().
    
    Overlapping switches on a single CPU are considered incorrect if
    they are requested via bL_switch_request_cb() with a callback (they
    will lead to an unpredictable final state without explicit external
    synchronisation to force the requests into a particular order).
    Queuing requests robustly would be overkill because only one
    subsystem should be attempting to control the switcher at any time.
    
    Overlapping requests of this kind will be failed with -EBUSY to
    indicate that the second request won't take effect and the
    completer will never be called for it.
    
    bL_switch_request() is retained as a wrapper round the new function,
    with the old, fire-and-forget semantics.  In this case the last request
    will always win. The request may still be denied if a previous request
    with a completer is still pending.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index b243ca93e8e9..7d1cce8b8a0d 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -15,7 +15,15 @@
 #include <linux/compiler.h>
 #include <linux/types.h>
 
-int bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
+typedef void (*bL_switch_completion_handler)(void *cookie);
+
+int bL_switch_request_cb(unsigned int cpu, unsigned int new_cluster_id,
+			 bL_switch_completion_handler completer,
+			 void *completer_cookie);
+static inline int bL_switch_request(unsigned int cpu, unsigned int new_cluster_id)
+{
+	return bL_switch_request_cb(cpu, new_cluster_id, NULL, NULL);
+}
 
 /*
  * Register here to be notified about runtime enabling/disabling of

commit 491990e29f5d285a1b75e74785e3160716b79040
Author: Dave Martin <dave.martin@linaro.org>
Date:   Mon Dec 10 17:19:58 2012 +0000

    ARM: bL_switcher: Add runtime control notifier
    
    Some subsystems will need to respond synchronously to runtime
    enabling and disabling of the switcher.
    
    This patch adds a dedicated notifier interface to support such
    subsystems.  Pre- and post- enable/disable notifications are sent
    to registered callbacks, allowing safe transition of non-b.L-
    transparent subsystems across these control transitions.
    
    Notifier callbacks may veto switcher (de)activation on pre notifications
    only.  Post notifications won't revert the action.
    
    If enabling or disabling of the switcher fails after the pre-change
    notification has been sent, subsystems which have registered
    notifiers can be left in an inappropriate state.
    
    This patch sends a suitable post-change notification on failure,
    indicating that the old state has been reestablished.
    
    For example, a failed initialisation will result in the following
    sequence:
    
        BL_NOTIFY_PRE_ENABLE
        /* switcher initialisation fails */
        BL_NOTIFY_POST_DISABLE
    
    It is the responsibility of notified subsystems to respond in an
    appropriate way.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index 05d7c4cb9473..b243ca93e8e9 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -12,9 +12,53 @@
 #ifndef ASM_BL_SWITCHER_H
 #define ASM_BL_SWITCHER_H
 
+#include <linux/compiler.h>
+#include <linux/types.h>
+
 int bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
 
+/*
+ * Register here to be notified about runtime enabling/disabling of
+ * the switcher.
+ *
+ * The notifier chain is called with the switcher activation lock held:
+ * the switcher will not be enabled or disabled during callbacks.
+ * Callbacks must not call bL_switcher_{get,put}_enabled().
+ */
+#define BL_NOTIFY_PRE_ENABLE	0
+#define BL_NOTIFY_POST_ENABLE	1
+#define BL_NOTIFY_PRE_DISABLE	2
+#define BL_NOTIFY_POST_DISABLE	3
+
+#ifdef CONFIG_BL_SWITCHER
+
+int bL_switcher_register_notifier(struct notifier_block *nb);
+int bL_switcher_unregister_notifier(struct notifier_block *nb);
+
+/*
+ * Use these functions to temporarily prevent enabling/disabling of
+ * the switcher.
+ * bL_switcher_get_enabled() returns true if the switcher is currently
+ * enabled.  Each call to bL_switcher_get_enabled() must be followed
+ * by a call to bL_switcher_put_enabled().  These functions are not
+ * recursive.
+ */
 bool bL_switcher_get_enabled(void);
 void bL_switcher_put_enabled(void);
 
+#else
+static inline int bL_switcher_register_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline int bL_switcher_unregister_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline bool bL_switcher_get_enabled(void) { return false; }
+static inline void bL_switcher_put_enabled(void) { }
+#endif /* CONFIG_BL_SWITCHER */
+
 #endif

commit c0f4375146a738bae23e48fa8b5383abf02177cb
Author: Dave Martin <dave.martin@linaro.org>
Date:   Mon Dec 10 17:19:57 2012 +0000

    ARM: bL_switcher: Add synchronous enable/disable interface
    
    Some subsystems will need to know for sure whether the switcher is
    enabled or disabled during certain critical regions.
    
    This patch provides a simple mutex-based mechanism to discover
    whether the switcher is enabled and temporarily lock out further
    enable/disable:
    
      * bL_switcher_get_enabled() returns true iff the switcher is
        enabled and temporarily inhibits enable/disable.
    
      * bL_switcher_put_enabled() permits enable/disable of the switcher
        again after a previous call to bL_switcher_get_enabled().
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index e0c0bba70bbf..05d7c4cb9473 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -14,4 +14,7 @@
 
 int bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
 
+bool bL_switcher_get_enabled(void);
+void bL_switcher_put_enabled(void);
+
 #endif

commit 71ce1deeff8f9341ae3b21983e9bdde28e8c96fe
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Oct 26 02:36:17 2012 -0400

    ARM: bL_switcher: move to dedicated threads rather than workqueues
    
    The workqueues are problematic as they may be contended.
    They can't be scheduled with top priority either.  Also the optimization
    in bL_switch_request() to skip the workqueue entirely when the target CPU
    and the calling CPU were the same didn't allow for bL_switch_request() to
    be called from atomic context, as might be the case for some cpufreq
    drivers.
    
    Let's move to dedicated kthreads instead.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
index 72efe3f349b9..e0c0bba70bbf 100644
--- a/arch/arm/include/asm/bL_switcher.h
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -12,6 +12,6 @@
 #ifndef ASM_BL_SWITCHER_H
 #define ASM_BL_SWITCHER_H
 
-void bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
+int bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
 
 #endif

commit 1c33be57496d927ce05b2513ff0c108f69db4345
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Apr 12 02:56:10 2012 -0400

    ARM: b.L: core switcher code
    
    This is the core code implementing big.LITTLE switcher functionality.
    Rationale for this code is available here:
    
    http://lwn.net/Articles/481055/
    
    The main entry point for a switch request is:
    
    void bL_switch_request(unsigned int cpu, unsigned int new_cluster_id)
    
    If the calling CPU is not the wanted one, this wrapper takes care of
    sending the request to the appropriate CPU with schedule_work_on().
    
    At the moment the core switch operation is handled by bL_switch_to()
    which must be called on the CPU for which a switch is requested.
    
    What this code does:
    
      * Return early if the current cluster is the wanted one.
    
      * Close the gate in the kernel entry vector for both the inbound
        and outbound CPUs.
    
      * Wake up the inbound CPU so it can perform its reset sequence in
        parallel up to the kernel entry vector gate.
    
      * Migrate all interrupts in the GIC targeting the outbound CPU
        interface to the inbound CPU interface, including SGIs. This is
        performed by gic_migrate_target() in drivers/irqchip/irq-gic.c.
    
      * Call cpu_pm_enter() which takes care of flushing the VFP state to
        RAM and save the CPU interface config from the GIC to RAM.
    
      * Modify the cpu_logical_map to refer to the inbound physical CPU.
    
      * Call cpu_suspend() which saves the CPU state (general purpose
        registers, page table address) onto the stack and store the
        resulting stack pointer in an array indexed by the updated
        cpu_logical_map, then call the provided shutdown function.
        This happens in arch/arm/kernel/sleep.S.
    
    At this point, the provided shutdown function executed by the outbound
    CPU ungates the inbound CPU. Therefore the inbound CPU:
    
      * Picks up the saved stack pointer in the array indexed by its MPIDR
        in arch/arm/kernel/sleep.S.
    
      * The MMU and caches are re-enabled using the saved state on the
        provided stack, just like if this was a resume operation from a
        suspended state.
    
      * Then cpu_suspend() returns, although this is on the inbound CPU
        rather than the outbound CPU which called it initially.
    
      * The function cpu_pm_exit() is called which effect is to restore the
        CPU interface state in the GIC using the state previously saved by
        the outbound CPU.
    
      * Exit of bL_switch_to() to resume normal kernel execution on the
        new CPU.
    
    However, the outbound CPU is potentially still running in parallel while
    the inbound CPU is resuming normal kernel execution, hence we need
    per CPU stack isolation to execute bL_do_switch().  After the outbound
    CPU has ungated the inbound CPU, it calls mcpm_cpu_power_down() to:
    
      * Clean its L1 cache.
    
      * If it is the last CPU still alive in its cluster (last man standing),
        it also cleans its L2 cache and disables cache snooping from the other
        cluster.
    
      * Power down the CPU (or whole cluster).
    
    Code called from bL_do_switch() might end up referencing 'current' for
    some reasons.  However, 'current' is derived from the stack pointer.
    With any arbitrary stack, the returned value for 'current' and any
    dereferenced values through it are just random garbage which may lead to
    segmentation faults.
    
    The active page table during the execution of bL_do_switch() is also a
    problem.  There is no guarantee that the inbound CPU won't destroy the
    corresponding task which would free the attached page table while the
    outbound CPU is still running and relying on it.
    
    To solve both issues, we borrow some of the task space belonging to
    the init/idle task which, by its nature, is lightly used and therefore
    is unlikely to clash with our usage.  The init task is also never going
    away.
    
    Right now the logical CPU number is assumed to be equivalent to the
    physical CPU number within each cluster. The kernel should also be
    booted with only one cluster active.  These limitations will be lifted
    eventually.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/bL_switcher.h b/arch/arm/include/asm/bL_switcher.h
new file mode 100644
index 000000000000..72efe3f349b9
--- /dev/null
+++ b/arch/arm/include/asm/bL_switcher.h
@@ -0,0 +1,17 @@
+/*
+ * arch/arm/include/asm/bL_switcher.h
+ *
+ * Created by:  Nicolas Pitre, April 2012
+ * Copyright:   (C) 2012-2013  Linaro Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef ASM_BL_SWITCHER_H
+#define ASM_BL_SWITCHER_H
+
+void bL_switch_request(unsigned int cpu, unsigned int new_cluster_id);
+
+#endif
