commit cfaa9f029f8141e9ee8d621a126d9dd4cc89aa63
Merge: 1ce80e0fe98e 383fb3ee8024
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 18 10:45:09 2018 -0800

    Merge branch 'spectre' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM spectre updates from Russell King:
     "These are the currently known final bits that resolve the Spectre
      issues. big.Little systems used to be sufficiently identical in that
      there were no differences between individual CPUs in the system that
      mattered to the kernel. With the advent of the Spectre problem, the
      CPUs now have differences in how the workaround is applied.
    
      As a result of previous Spectre patches, these systems ended up
      reporting quite a lot of:
    
         "CPUx: Spectre v2: incorrect context switching function, system vulnerable"
    
      messages due to the action of the big.Little switcher causing the CPUs
      to be re-initialised regularly. This series resolves that issue by
      making the CPU vtable unique to each CPU.
    
      However, since this is used very early, before per-cpu is setup,
      per-cpu can't be used. We also have a problem that two of the methods
      are not called from preempt-safe paths, but thankfully these remain
      identical between all CPUs in the system. To make sure, we validate
      that these are identical during boot"
    
    * 'spectre' of git://git.armlinux.org.uk/~rmk/linux-arm:
      ARM: spectre-v2: per-CPU vtables to work around big.Little systems
      ARM: add PROC_VTABLE and PROC_TABLE macros
      ARM: clean up per-processor check_bugs method call
      ARM: split out processor lookup
      ARM: make lookup_processor_type() non-__init

commit 65987a8553061515b5851b472081aedb9837a391
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Jul 19 11:59:56 2018 +0100

    ARM: split out processor lookup
    
    Split out the lookup of the processor type and associated error handling
    from the rest of setup_processor() - we will need to use this in the
    secondary CPU bringup path for big.Little Spectre variant 2 mitigation.
    
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 26021980504d..f6df4bb4e543 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -107,6 +107,7 @@
 #define ARM_CPU_PART_SCORPION		0x510002d0
 
 extern unsigned int processor_id;
+struct proc_info_list *lookup_processor(u32 midr);
 
 #ifdef CONFIG_CPU_CP15
 #define read_cpuid(reg)							\

commit 7c00e8ae041b349992047769af741b67379ce19a
Merge: a2b7ab45b890 958da6e3ff44
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 11 17:49:09 2018 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "Here are the main updates for SoC support (besides DT additions) for
      ARM 32- and 64-bit platforms. The branch also contains defconfig
      updates to turn on drivers and options as needed on the various
      platforms.
    
      The largest parts of the delta are from cleanups moving platform data
      and board file setup of TI platforms to ti-sysc bus drivers. There are
      also some sweeping changes of eeprom and nand setup on Davinci, i.MX
      and other platforms.
    
      Samsung is removing support for Exynos5440, which was an oddball SoC
      that hasn't been seen much use in designs.
    
      Renesas is adding support for new SoCs (R-Car E3, RZ/G1C and RZ/N1D).
    
      Linus Walleij is also removing support for ux500 (Sony Ericsson)
      U8540/9540 SoCs that never made it to significant mass production and
      products"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (133 commits)
      MAINTAINERS: add NXP linux team maillist as i.MX reviewer
      ARM: stm32: Don't select DMA unconditionally on STM32MP157C
      arm64: defconfig: Enable PCIe on msm8996 and db820c
      ARM: pxa3xx: enable external wakeup pins
      ARM: pxa: stargate2: use device properties for at24 eeprom
      arm64: defconfig: Enable HISILICON_LPC
      arm64: defconfig: enable drivers for Poplar support
      arm64: defconfig: Enable UFS on msm8996
      ARM: berlin: switch to SPDX license identifier
      arm: berlin: remove non-necessary flush_cache_all()
      ARM: berlin: extend BG2CD Kconfig entry
      OMAP: CLK: CLKSRC: Add suspend resume hooks
      ARM: AM43XX: Add functions to save/restore am43xx control registers
      ASoC: ams_delta: use GPIO lookup table
      ARM: OMAP1: ams-delta: add GPIO lookup tables
      bus: ti-sysc: Fix optional clocks array access
      ARM: OMAP2+: Make sure LOGICRETSTATE bits are not cleared
      ARM: OMAP2+: prm44xx: Inroduce cpu_pm notifiers for context save/restore
      ARM: OMAP2+: prm44xx: Introduce context save/restore for am43 PRCM IO
      ARM: OMAP2+: powerdomain: Introduce cpu_pm notifiers for context save/restore
      ...

commit f5683e76f35b4ec5891031b6a29036efe0a1ff84
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon May 14 14:42:32 2018 +0100

    ARM: add more CPU part numbers for Cortex and Brahma B15 CPUs
    
    Add CPU part numbers for Cortex A53, A57, A72, A73, A75 and the
    Broadcom Brahma B15 CPU.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Boot-tested-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index cb546425da8a..26021980504d 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -77,8 +77,16 @@
 #define ARM_CPU_PART_CORTEX_A12		0x4100c0d0
 #define ARM_CPU_PART_CORTEX_A17		0x4100c0e0
 #define ARM_CPU_PART_CORTEX_A15		0x4100c0f0
+#define ARM_CPU_PART_CORTEX_A53		0x4100d030
+#define ARM_CPU_PART_CORTEX_A57		0x4100d070
+#define ARM_CPU_PART_CORTEX_A72		0x4100d080
+#define ARM_CPU_PART_CORTEX_A73		0x4100d090
+#define ARM_CPU_PART_CORTEX_A75		0x4100d0a0
 #define ARM_CPU_PART_MASK		0xff00fff0
 
+/* Broadcom cores */
+#define ARM_CPU_PART_BRAHMA_B15		0x420000f0
+
 /* DEC implemented cores */
 #define ARM_CPU_PART_SA1100		0x4400a110
 

commit 842fa17d6c95368d756def1e3ca20aadedc4660c
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Feb 23 13:09:22 2018 -0800

    ARM: add Broadcom Brahma-B15 main ID definition
    
    Define Broadcom's Brahma-B15 main ID register value, masked with
    ARM_CPU_PART_MASK.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 6d1c7b22faea..d1b62ee69f3b 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -78,6 +78,7 @@
 #define ARM_CPU_PART_MASK		0xff00fff0
 
 /* Broadcom implemented processors */
+#define ARM_CPU_PART_BRAHMA_B15		0x420000f0
 #define ARM_CPU_PART_BRAHMA_B53		0x42001000
 
 /* DEC implemented cores */

commit 9e35ddc962a656bf4bb4cd50964943d0ffb89255
Author: Doug Berger <opendmb@gmail.com>
Date:   Fri Feb 23 13:09:21 2018 -0800

    ARM: add Broadcom Brahma-B53 main ID definition
    
    This commit allows a Broadcom Brahma-B53 core to be detected when executing
    an arm architecture kernel in aarch32 state.
    
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index e7632f536633..6d1c7b22faea 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -59,6 +59,7 @@
 	((mpidr >> (MPIDR_LEVEL_BITS * level)) & MPIDR_LEVEL_MASK)
 
 #define ARM_CPU_IMP_ARM			0x41
+#define ARM_CPU_IMP_BRCM		0x42
 #define ARM_CPU_IMP_DEC			0x44
 #define ARM_CPU_IMP_INTEL		0x69
 
@@ -76,6 +77,9 @@
 #define ARM_CPU_PART_CORTEX_A15		0x4100c0f0
 #define ARM_CPU_PART_MASK		0xff00fff0
 
+/* Broadcom implemented processors */
+#define ARM_CPU_PART_BRAHMA_B53		0x42001000
+
 /* DEC implemented cores */
 #define ARM_CPU_PART_SA1100		0x4400a110
 

commit 16f021b03aae117715ee47e3a5f24c42a214e638
Author: Doug Berger <opendmb@gmail.com>
Date:   Fri May 4 21:05:34 2018 +0200

    ARM: Allow this header to be included by assembly files
    
    The constants defined in this file are equally useful in assembly and C
    source files. The arm64 architecture version of this file allows
    inclusion in both assembly and C source files, so this commit adds
    that capability to the arm architecture version so that the constants
    don't need to be defined in multiple places.
    
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Myl√®ne Josserand <mylene.josserand@bootlin.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index cb546425da8a..e7632f536633 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -2,9 +2,6 @@
 #ifndef __ASM_ARM_CPUTYPE_H
 #define __ASM_ARM_CPUTYPE_H
 
-#include <linux/stringify.h>
-#include <linux/kernel.h>
-
 #define CPUID_ID	0
 #define CPUID_CACHETYPE	1
 #define CPUID_TCM	2
@@ -98,6 +95,11 @@
 /* Qualcomm implemented cores */
 #define ARM_CPU_PART_SCORPION		0x510002d0
 
+#ifndef __ASSEMBLY__
+
+#include <linux/stringify.h>
+#include <linux/kernel.h>
+
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15
@@ -326,4 +328,6 @@ static inline int __attribute_const__ cpuid_feature_extract_field(u32 features,
 #define cpuid_feature_extract(reg, field) \
 	cpuid_feature_extract_field(read_cpuid_ext(reg), field)
 
+#endif /* __ASSEMBLY__ */
+
 #endif

commit 441692aafc1731087bbaf657a8b6059d95c2a6df
Merge: 5b0e2cb02008 02196144a0a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 12:50:35 2017 -0800

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
    
     - add support for ELF fdpic binaries on both MMU and noMMU platforms
    
     - linker script cleanups
    
     - support for compressed .data section for XIP images
    
     - discard memblock arrays when possible
    
     - various cleanups
    
     - atomic DMA pool updates
    
     - better diagnostics of missing/corrupt device tree
    
     - export information to allow userspace kexec tool to place images more
       inteligently, so that the device tree isn't overwritten by the
       booting kernel
    
     - make early_printk more efficient on semihosted systems
    
     - noMMU cleanups
    
     - SA1111 PCMCIA update in preparation for further cleanups
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (38 commits)
      ARM: 8719/1: NOMMU: work around maybe-uninitialized warning
      ARM: 8717/2: debug printch/printascii: translate '\n' to "\r\n" not "\n\r"
      ARM: 8713/1: NOMMU: Support MPU in XIP configuration
      ARM: 8712/1: NOMMU: Use more MPU regions to cover memory
      ARM: 8711/1: V7M: Add support for MPU to M-class
      ARM: 8710/1: Kconfig: Kill CONFIG_VECTORS_BASE
      ARM: 8709/1: NOMMU: Disallow MPU for XIP
      ARM: 8708/1: NOMMU: Rework MPU to be mostly done in C
      ARM: 8707/1: NOMMU: Update MPU accessors to use cp15 helpers
      ARM: 8706/1: NOMMU: Move out MPU setup in separate module
      ARM: 8702/1: head-common.S: Clear lr before jumping to start_kernel()
      ARM: 8705/1: early_printk: use printascii() rather than printch()
      ARM: 8703/1: debug.S: move hexbuf to a writable section
      ARM: add additional table to compressed kernel
      ARM: decompressor: fix BSS size calculation
      pcmcia: sa1111: remove special sa1111 mmio accessors
      pcmcia: sa1111: use sa1111_get_irq() to obtain IRQ resources
      ARM: better diagnostics with missing/corrupt dtb
      ARM: 8699/1: dma-mapping: Remove init_dma_coherent_pool_size()
      ARM: 8698/1: dma-mapping: Mark atomic_pool as __ro_after_init
      ..

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index b62eaeb147aa..441933311bbf 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ASM_ARM_CPUTYPE_H
 #define __ASM_ARM_CPUTYPE_H
 

commit 9fcb01a9f54c28062a73a545c29137a4cc104c72
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Oct 16 12:57:48 2017 +0100

    ARM: 8711/1: V7M: Add support for MPU to M-class
    
    This patch makes it possible to use MPU with v7M cores.
    
    Tested-by: Szemz≈ë Andr√°s <sza@esh.hu>
    Tested-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Tested-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index b62eaeb147aa..abaac5e07b80 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -173,6 +173,11 @@ static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 	return read_cpuid(CPUID_CACHETYPE);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_mputype(void)
+{
+	return read_cpuid(CPUID_MPUIR);
+}
+
 #elif defined(CONFIG_CPU_V7M)
 
 static inline unsigned int __attribute_const__ read_cpuid_id(void)
@@ -185,6 +190,11 @@ static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 	return readl(BASEADDR_V7M_SCB + V7M_SCB_CTR);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_mputype(void)
+{
+	return readl(BASEADDR_V7M_SCB + MPU_TYPE);
+}
+
 #else /* ifdef CONFIG_CPU_CP15 / elif defined(CONFIG_CPU_V7M) */
 
 static inline unsigned int __attribute_const__ read_cpuid_id(void)

commit ddc37832a1349f474c4532de381498020ed71d31
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Jan 6 13:12:47 2017 +0100

    ARM: 8634/1: hw_breakpoint: blacklist Scorpion CPUs
    
    On APQ8060, the kernel crashes in arch_hw_breakpoint_init, taking an
    undefined instruction trap within write_wb_reg. This is because Scorpion
    CPUs erroneously appear to set DBGPRSR.SPD when WFI is issued, even if
    the core is not powered down. When DBGPRSR.SPD is set, breakpoint and
    watchpoint registers are treated as undefined.
    
    It's possible to trigger similar crashes later on from userspace, by
    requesting the kernel to install a breakpoint or watchpoint, as we can
    go idle at any point between the reset of the debug registers and their
    later use. This has always been the case.
    
    Given that this has always been broken, no-one has complained until now,
    and there is no clear workaround, disable hardware breakpoints and
    watchpoints on Scorpion to avoid these issues.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reported-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 522b5feb4eaa..b62eaeb147aa 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -94,6 +94,9 @@
 #define ARM_CPU_XSCALE_ARCH_V2		0x4000
 #define ARM_CPU_XSCALE_ARCH_V3		0x6000
 
+/* Qualcomm implemented cores */
+#define ARM_CPU_PART_SCORPION		0x510002d0
+
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15

commit 6218590bcb452c3da7517d02b588d4d0a8628f73
Merge: 14986a34e128 d9ab710b8531
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 6 10:49:01 2016 -0700

    Merge tag 'kvm-4.9-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Radim Krƒçm√°≈ô:
     "All architectures:
       - move `make kvmconfig` stubs from x86
       - use 64 bits for debugfs stats
    
      ARM:
       - Important fixes for not using an in-kernel irqchip
       - handle SError exceptions and present them to guests if appropriate
       - proxying of GICV access at EL2 if guest mappings are unsafe
       - GICv3 on AArch32 on ARMv8
       - preparations for GICv3 save/restore, including ABI docs
       - cleanups and a bit of optimizations
    
      MIPS:
       - A couple of fixes in preparation for supporting MIPS EVA host
         kernels
       - MIPS SMP host & TLB invalidation fixes
    
      PPC:
       - Fix the bug which caused guests to falsely report lockups
       - other minor fixes
       - a small optimization
    
      s390:
       - Lazy enablement of runtime instrumentation
       - up to 255 CPUs for nested guests
       - rework of machine check deliver
       - cleanups and fixes
    
      x86:
       - IOMMU part of AMD's AVIC for vmexit-less interrupt delivery
       - Hyper-V TSC page
       - per-vcpu tsc_offset in debugfs
       - accelerated INS/OUTS in nVMX
       - cleanups and fixes"
    
    * tag 'kvm-4.9-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (140 commits)
      KVM: MIPS: Drop dubious EntryHi optimisation
      KVM: MIPS: Invalidate TLB by regenerating ASIDs
      KVM: MIPS: Split kernel/user ASID regeneration
      KVM: MIPS: Drop other CPU ASIDs on guest MMU changes
      KVM: arm/arm64: vgic: Don't flush/sync without a working vgic
      KVM: arm64: Require in-kernel irqchip for PMU support
      KVM: PPC: Book3s PR: Allow access to unprivileged MMCR2 register
      KVM: PPC: Book3S PR: Support 64kB page size on POWER8E and POWER8NVL
      KVM: PPC: Book3S: Remove duplicate setting of the B field in tlbie
      KVM: PPC: BookE: Fix a sanity check
      KVM: PPC: Book3S HV: Take out virtual core piggybacking code
      KVM: PPC: Book3S: Treat VTB as a per-subcore register, not per-thread
      ARM: gic-v3: Work around definition of gic_write_bpr1
      KVM: nVMX: Fix the NMI IDT-vectoring handling
      KVM: VMX: Enable MSR-BASED TPR shadow even if APICv is inactive
      KVM: nVMX: Fix reload apic access page warning
      kvmconfig: add virtio-gpu to config fragment
      config: move x86 kvm_guest.config to a common location
      arm64: KVM: Remove duplicating init code for setting VMID
      ARM: KVM: Support vgic-v3
      ...

commit 163352eb6827e5b556b0860edc19327798fcc5ff
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Sep 12 15:49:21 2016 +0100

    ARM: Introduce MPIDR_LEVEL_SHIFT macro
    
    vgic-v3 driver uses architecture specific MPIDR_LEVEL_SHIFT macro to
    encode the affinity in a form compatible with ICC_SGI* registers.
    Unfortunately, that macro is missing on ARM, so let's add it.
    
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 1ee94c716a7f..e2d94c1b07b8 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -55,6 +55,7 @@
 
 #define MPIDR_LEVEL_BITS 8
 #define MPIDR_LEVEL_MASK ((1 << MPIDR_LEVEL_BITS) - 1)
+#define MPIDR_LEVEL_SHIFT(level) (MPIDR_LEVEL_BITS * level)
 
 #define MPIDR_AFFINITY_LEVEL(mpidr, level) \
 	((mpidr >> (MPIDR_LEVEL_BITS * level)) & MPIDR_LEVEL_MASK)

commit f5a5c89e36d0897b65e4e6bc2f646f75f8074263
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Tue Aug 30 17:27:19 2016 +0100

    ARM: 8604/1: V7M: Add support for reading the CTR with read_cpuid_cachetype()
    
    With the addition of caches to the V7M Architecture a new Cache Type
    Register (CTR) is defined at 0xE000ED7C. This register serves the same
    purpose as the V7A/R version and accessed via the read_cpuid_cachetype.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Tested-by: Andras Szemzo <sza@esh.hu>
    Tested-by: Joachim Eastwood <manabian@gmail.com>
    Tested-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index d6a4902a75d7..754f86f667d4 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -164,6 +164,11 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 	return read_cpuid(CPUID_ID);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
+{
+	return read_cpuid(CPUID_CACHETYPE);
+}
+
 #elif defined(CONFIG_CPU_V7M)
 
 static inline unsigned int __attribute_const__ read_cpuid_id(void)
@@ -171,6 +176,11 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 	return readl(BASEADDR_V7M_SCB + V7M_SCB_CPUID);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
+{
+	return readl(BASEADDR_V7M_SCB + V7M_SCB_CTR);
+}
+
 #else /* ifdef CONFIG_CPU_CP15 / elif defined(CONFIG_CPU_V7M) */
 
 static inline unsigned int __attribute_const__ read_cpuid_id(void)
@@ -210,11 +220,6 @@ static inline unsigned int __attribute_const__ xscale_cpu_arch_version(void)
 	return read_cpuid_id() & ARM_CPU_XSCALE_ARCH_MASK;
 }
 
-static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
-{
-	return read_cpuid(CPUID_CACHETYPE);
-}
-
 static inline unsigned int __attribute_const__ read_cpuid_tcmstatus(void)
 {
 	return read_cpuid(CPUID_TCM);

commit 83809b90a6dbedbcd94fcb99c9cde9477534f3d3
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Aug 19 15:15:03 2016 +0100

    ARM: sa1100: move StrongARM CPU ID checks to cputype.h
    
    Move the StrongARM CPU ID checks out of the platform's hardware.h
    file into asm/cputype.h
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 1ee94c716a7f..d6a4902a75d7 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -60,6 +60,7 @@
 	((mpidr >> (MPIDR_LEVEL_BITS * level)) & MPIDR_LEVEL_MASK)
 
 #define ARM_CPU_IMP_ARM			0x41
+#define ARM_CPU_IMP_DEC			0x44
 #define ARM_CPU_IMP_INTEL		0x69
 
 /* ARM implemented processors */
@@ -76,6 +77,17 @@
 #define ARM_CPU_PART_CORTEX_A15		0x4100c0f0
 #define ARM_CPU_PART_MASK		0xff00fff0
 
+/* DEC implemented cores */
+#define ARM_CPU_PART_SA1100		0x4400a110
+
+/* Intel implemented cores */
+#define ARM_CPU_PART_SA1110		0x6900b110
+#define ARM_CPU_REV_SA1110_A0		0
+#define ARM_CPU_REV_SA1110_B0		4
+#define ARM_CPU_REV_SA1110_B1		5
+#define ARM_CPU_REV_SA1110_B2		6
+#define ARM_CPU_REV_SA1110_B4		8
+
 #define ARM_CPU_XSCALE_ARCH_MASK	0xe000
 #define ARM_CPU_XSCALE_ARCH_V1		0x2000
 #define ARM_CPU_XSCALE_ARCH_V2		0x4000
@@ -173,6 +185,11 @@ static inline unsigned int __attribute_const__ read_cpuid_implementor(void)
 	return (read_cpuid_id() & 0xFF000000) >> 24;
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_revision(void)
+{
+	return read_cpuid_id() & 0x0000000f;
+}
+
 /*
  * The CPU part number is meaningless without referring to the CPU
  * implementer: implementers are free to define their own part numbers
@@ -208,6 +225,10 @@ static inline unsigned int __attribute_const__ read_cpuid_mpidr(void)
 	return read_cpuid(CPUID_MPIDR);
 }
 
+/* StrongARM-11x0 CPUs */
+#define cpu_is_sa1100() (read_cpuid_part() == ARM_CPU_PART_SA1100)
+#define cpu_is_sa1110() (read_cpuid_part() == ARM_CPU_PART_SA1110)
+
 /*
  * Intel's XScale3 core supports some v6 features (supersections, L2)
  * but advertises itself as v5 as it does not support the v6 ISA.  For

commit ac36a881b72a1e9831f1c59abf935868c90685cf
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Tue Apr 19 12:35:55 2016 +0100

    ARM: 8564/1: fix cpu feature extracting helper
    
    Commit b8c9592 "ARM: 8318/1: treat CPU feature register fields as signed
    quantities" introduced helper to extract signed quantities of 4-bit
    blocks. However, with a current code feature with value 0b1000 isn't
    rejected as negative. So fix the "if" condition.
    
    Reported-by: Jonathan Brawn <Jon.Brawn@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index b23c6c81c9ad..1ee94c716a7f 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -276,7 +276,7 @@ static inline int __attribute_const__ cpuid_feature_extract_field(u32 features,
 	int feature = (features >> field) & 15;
 
 	/* feature registers are signed values */
-	if (feature > 8)
+	if (feature > 7)
 		feature -= 16;
 
 	return feature;

commit d33c43ac185e2921e0f541872719588c3d491c60
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 15 15:38:39 2014 +0200

    ARM: make xscale iwmmxt code multiplatform aware
    
    In a multiplatform configuration, we may end up building a kernel for
    both Marvell PJ1 and an ARMv4 CPU implementation. In that case, the
    xscale-cp0 code is built with gcc -march=armv4{,t}, which results in a
    build error from the coprocessor instructions.
    
    Since we know this code will only have to run on an actual xscale
    processor, we can simply build the entire file for ARMv5TE.
    
    Related to this, we need to handle the iWMMXT initialization sequence
    differently during boot, to ensure we don't try to touch xscale
    specific registers on other CPUs from the xscale_cp0_init initcall.
    cpu_is_xscale() used to be hardcoded to '1' in any configuration that
    enables any XScale-compatible core, but this breaks once we can have a
    combined kernel with MMP1 and something else.
    
    In this patch, I replace the existing cpu_is_xscale() macro with a new
    cpu_is_xscale_family() macro that evaluates true for xscale, xsc3 and
    mohawk, which makes the behavior more deterministic.
    
    The two existing users of cpu_is_xscale() are modified accordingly,
    but slightly change behavior for kernels that enable CPU_MOHAWK without
    also enabling CPU_XSCALE or CPU_XSC3. Previously, these would leave leave
    PMD_BIT4 in the page tables untouched, now they clear it as we've always
    done for kernels that enable both MOHAWK and the support for the older
    CPU types.
    
    Since the previous behavior was inconsistent, I assume it was
    unintentional.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 85e374f873ac..b23c6c81c9ad 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -228,10 +228,26 @@ static inline int cpu_is_xsc3(void)
 }
 #endif
 
-#if !defined(CONFIG_CPU_XSCALE) && !defined(CONFIG_CPU_XSC3)
-#define	cpu_is_xscale()	0
+#if !defined(CONFIG_CPU_XSCALE) && !defined(CONFIG_CPU_XSC3) && \
+    !defined(CONFIG_CPU_MOHAWK)
+#define	cpu_is_xscale_family() 0
 #else
-#define	cpu_is_xscale()	1
+static inline int cpu_is_xscale_family(void)
+{
+	unsigned int id;
+	id = read_cpuid_id() & 0xffffe000;
+
+	switch (id) {
+	case 0x69052000: /* Intel XScale 1 */
+	case 0x69054000: /* Intel XScale 2 */
+	case 0x69056000: /* Intel XScale 3 */
+	case 0x56056000: /* Marvell XScale 3 */
+	case 0x56158000: /* Marvell Mohawk */
+		return 1;
+	}
+
+	return 0;
+}
 #endif
 
 /*

commit b8c9592b4a6c93211c8163888a97880d608503b5
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Mar 19 19:03:25 2015 +0100

    ARM: 8318/1: treat CPU feature register fields as signed quantities
    
    The various CPU feature registers consist of 4-bit blocks that
    represent signed quantities, whose positive values represent
    incremental features, and whose negative values are reserved.
    
    To improve forward compatibility, update the feature detection
    code to take possible future higher values into account, but
    ignore negative values.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 819777d0e91f..85e374f873ac 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -253,4 +253,20 @@ static inline int cpu_is_pj4(void)
 #else
 #define cpu_is_pj4()	0
 #endif
+
+static inline int __attribute_const__ cpuid_feature_extract_field(u32 features,
+								  int field)
+{
+	int feature = (features >> field) & 15;
+
+	/* feature registers are signed values */
+	if (feature > 8)
+		feature -= 16;
+
+	return feature;
+}
+
+#define cpuid_feature_extract(reg, field) \
+	cpuid_feature_extract_field(read_cpuid_ext(reg), field)
+
 #endif

commit eba1c71819d210f5e0d522571f9b8abce94fe9c5
Author: Juri Lelli <juri.lelli@arm.com>
Date:   Fri Aug 15 15:53:14 2014 +0100

    ARM: 8130/1: cpuidle/cpuidle-big_little: fix reading cpu id part number
    
    Commit af040ffc9ba1 ("ARM: make it easier to check the CPU part number
    correctly") changed ARM_CPU_PART_X masks, and the way they are returned and
    checked against. Usage of read_cpuid_part_number() is now deprecated, and
    calling places updated accordingly. This actually broke cpuidle-big_little
    initialization, as bl_idle_driver_init() performs a check using an hardcoded
    mask on cpu_id.
    
    Create an interface to perform the check (that is now even easier to read).
    Define also a proper mask (ARM_CPU_PART_MASK) that makes this kind of checks
    cleaner and helps preventing bugs in the future. Update usage accordingly.
    
    Signed-off-by: Juri Lelli <juri.lelli@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 963a2515906d..819777d0e91f 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -74,6 +74,7 @@
 #define ARM_CPU_PART_CORTEX_A12		0x4100c0d0
 #define ARM_CPU_PART_CORTEX_A17		0x4100c0e0
 #define ARM_CPU_PART_CORTEX_A15		0x4100c0f0
+#define ARM_CPU_PART_MASK		0xff00fff0
 
 #define ARM_CPU_XSCALE_ARCH_MASK	0xe000
 #define ARM_CPU_XSCALE_ARCH_V1		0x2000
@@ -179,7 +180,7 @@ static inline unsigned int __attribute_const__ read_cpuid_implementor(void)
  */
 static inline unsigned int __attribute_const__ read_cpuid_part(void)
 {
-	return read_cpuid_id() & 0xff00fff0;
+	return read_cpuid_id() & ARM_CPU_PART_MASK;
 }
 
 static inline unsigned int __attribute_const__ __deprecated read_cpuid_part_number(void)

commit af040ffc9ba1e079ee4c0748aff64fa3d4716fa5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 24 19:43:15 2014 +0100

    ARM: make it easier to check the CPU part number correctly
    
    Ensure that platform maintainers check the CPU part number in the right
    manner: the CPU part number is meaningless without also checking the
    CPU implement(e|o)r (choose your preferred spelling!)  Provide an
    interface which returns both the implementer and part number together,
    and update the definitions to include the implementer.
    
    Mark the old function as being deprecated... indeed, using the old
    function with the definitions will now always evaluate as false, so
    people must update their un-merged code to the new function.  While
    this could be avoided by adding new definitions, we'd also have to
    create new names for them which would be awkward.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 8c2b7321a478..963a2515906d 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -62,17 +62,18 @@
 #define ARM_CPU_IMP_ARM			0x41
 #define ARM_CPU_IMP_INTEL		0x69
 
-#define ARM_CPU_PART_ARM1136		0xB360
-#define ARM_CPU_PART_ARM1156		0xB560
-#define ARM_CPU_PART_ARM1176		0xB760
-#define ARM_CPU_PART_ARM11MPCORE	0xB020
-#define ARM_CPU_PART_CORTEX_A8		0xC080
-#define ARM_CPU_PART_CORTEX_A9		0xC090
-#define ARM_CPU_PART_CORTEX_A5		0xC050
-#define ARM_CPU_PART_CORTEX_A15		0xC0F0
-#define ARM_CPU_PART_CORTEX_A7		0xC070
-#define ARM_CPU_PART_CORTEX_A12		0xC0D0
-#define ARM_CPU_PART_CORTEX_A17		0xC0E0
+/* ARM implemented processors */
+#define ARM_CPU_PART_ARM1136		0x4100b360
+#define ARM_CPU_PART_ARM1156		0x4100b560
+#define ARM_CPU_PART_ARM1176		0x4100b760
+#define ARM_CPU_PART_ARM11MPCORE	0x4100b020
+#define ARM_CPU_PART_CORTEX_A8		0x4100c080
+#define ARM_CPU_PART_CORTEX_A9		0x4100c090
+#define ARM_CPU_PART_CORTEX_A5		0x4100c050
+#define ARM_CPU_PART_CORTEX_A7		0x4100c070
+#define ARM_CPU_PART_CORTEX_A12		0x4100c0d0
+#define ARM_CPU_PART_CORTEX_A17		0x4100c0e0
+#define ARM_CPU_PART_CORTEX_A15		0x4100c0f0
 
 #define ARM_CPU_XSCALE_ARCH_MASK	0xe000
 #define ARM_CPU_XSCALE_ARCH_V1		0x2000
@@ -171,14 +172,24 @@ static inline unsigned int __attribute_const__ read_cpuid_implementor(void)
 	return (read_cpuid_id() & 0xFF000000) >> 24;
 }
 
-static inline unsigned int __attribute_const__ read_cpuid_part_number(void)
+/*
+ * The CPU part number is meaningless without referring to the CPU
+ * implementer: implementers are free to define their own part numbers
+ * which are permitted to clash with other implementer part numbers.
+ */
+static inline unsigned int __attribute_const__ read_cpuid_part(void)
+{
+	return read_cpuid_id() & 0xff00fff0;
+}
+
+static inline unsigned int __attribute_const__ __deprecated read_cpuid_part_number(void)
 {
 	return read_cpuid_id() & 0xFFF0;
 }
 
 static inline unsigned int __attribute_const__ xscale_cpu_arch_version(void)
 {
-	return read_cpuid_part_number() & ARM_CPU_XSCALE_ARCH_MASK;
+	return read_cpuid_id() & ARM_CPU_XSCALE_ARCH_MASK;
 }
 
 static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)

commit 1fb333489fb917c704ad43e51b45c12f52215a9c
Merge: 20e7e364331d 3f8517e7937d 8ef418c7178f 1c2f87c22566
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 5 12:35:52 2014 +0100

    Merge branches 'alignment', 'fixes', 'l2c' (early part) and 'misc' into for-next

commit cd000cf650cd43dc0dc37032cb4016985c9dda6c
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri May 2 17:06:02 2014 +0100

    ARM: 8046/1: proc: add support for the Cortex-A17 processor
    
    Cortex-A17 has identical initialisation requirements to Cortex-A12, so
    hook it up in proc-v7.S in the same way.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index c651e3b26ec7..550bf7110fef 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -72,6 +72,7 @@
 #define ARM_CPU_PART_CORTEX_A15		0xC0F0
 #define ARM_CPU_PART_CORTEX_A7		0xC070
 #define ARM_CPU_PART_CORTEX_A12		0xC0D0
+#define ARM_CPU_PART_CORTEX_A17		0xC0E0
 
 #define ARM_CPU_XSCALE_ARCH_MASK	0xe000
 #define ARM_CPU_XSCALE_ARCH_V1		0x2000

commit cd1711709fe98d3569e7f8215ba31adcfc3686ae
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Thu Apr 24 22:58:00 2014 +0100

    ARM: 8041/1: pj4: fix cpu_is_pj4 check
    
    Commit fdb487f5c961b94486a78fa61fa28b8eff1954ab
      ("ARM: 8015/1: Add cpu_is_pj4 to distinguish PJ4 because it
        has some differences with V7")
    introduced a cpuid check for Marvell PJ4 processors to fix a
    regression caused by adding PJ4 based Marvell Dove into
    multi_v7.
    
    Unfortunately, this check is too narrow to catch PJ4 used on
    Dove itself and breaks iWMMXt support.
    
    This patch therefore relaxes the cpuid mask to match both PJ4
    and PJ4B. Also, rework the given comment about PJ4/PJ4B
    modifications to be a little bit more specific about the
    differences.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index c651e3b26ec7..4764344367d4 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -222,22 +222,22 @@ static inline int cpu_is_xsc3(void)
 #endif
 
 /*
- * Marvell's PJ4 core is based on V7 version. It has some modification
- * for coprocessor setting. For this reason, we need a way to distinguish
- * it.
+ * Marvell's PJ4 and PJ4B cores are based on V7 version,
+ * but require a specical sequence for enabling coprocessors.
+ * For this reason, we need a way to distinguish them.
  */
-#ifndef CONFIG_CPU_PJ4
-#define cpu_is_pj4()	0
-#else
+#if defined(CONFIG_CPU_PJ4) || defined(CONFIG_CPU_PJ4B)
 static inline int cpu_is_pj4(void)
 {
 	unsigned int id;
 
 	id = read_cpuid_id();
-	if ((id & 0xfffffff0) == 0x562f5840)
+	if ((id & 0xff0fff00) == 0x560f5800)
 		return 1;
 
 	return 0;
 }
+#else
+#define cpu_is_pj4()	0
 #endif
 #endif

commit fdb487f5c961b94486a78fa61fa28b8eff1954ab
Author: Chao Xie Linux <xiechao.mail@gmail.com>
Date:   Wed Apr 2 02:47:09 2014 +0100

    ARM: 8015/1: Add cpu_is_pj4 to distinguish PJ4 because it has some differences with V7
    
    The patch add cpu_is_pj4 at arch/arm/include/asm/cputype.h
    PJ4 has some differences with V7, for example the coprocessor.
    To disinguish this kind of situation. cpu_is_pj4 is needed.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 42f0889f0584..c651e3b26ec7 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -221,4 +221,23 @@ static inline int cpu_is_xsc3(void)
 #define	cpu_is_xscale()	1
 #endif
 
+/*
+ * Marvell's PJ4 core is based on V7 version. It has some modification
+ * for coprocessor setting. For this reason, we need a way to distinguish
+ * it.
+ */
+#ifndef CONFIG_CPU_PJ4
+#define cpu_is_pj4()	0
+#else
+static inline int cpu_is_pj4(void)
+{
+	unsigned int id;
+
+	id = read_cpuid_id();
+	if ((id & 0xfffffff0) == 0x562f5840)
+		return 1;
+
+	return 0;
+}
+#endif
 #endif

commit ddb2ff731b53ae28ec3a2af0da96a108b8bad814
Author: Jonathan Austin <Jonathan.Austin@arm.com>
Date:   Mon Jan 13 12:10:57 2014 +0100

    ARM: 7940/1: add support for the Cortex-A12 processor
    
    The A12 behaves as the A7/A15 does with respect to setting the SMP bit, and
    doesn't require TLB ops broadcasting to be explicitly enabled like the A9 does.
    
    Note that as the ACTLR cannot (usually) be written from non-secure, it is the
    responsibility of the bootloader/firmware to set this bit per core - it is
    done here in Linux as last resort in case of bad firmware.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index acdde76b39bb..42f0889f0584 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -71,6 +71,7 @@
 #define ARM_CPU_PART_CORTEX_A5		0xC050
 #define ARM_CPU_PART_CORTEX_A15		0xC0F0
 #define ARM_CPU_PART_CORTEX_A7		0xC070
+#define ARM_CPU_PART_CORTEX_A12		0xC0D0
 
 #define ARM_CPU_XSCALE_ARCH_MASK	0xe000
 #define ARM_CPU_XSCALE_ARCH_V1		0x2000

commit 92871b94a5f9892e324c31960678387922c75049
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Oct 9 17:26:44 2013 +0100

    ARM: 7855/1: Add check for Cortex-A15 errata 798181 ECO
    
    The work-around for A15 errata 798181 is not needed if appropriate ECO
    fixes have been applied to r3p2 and earlier core revisions. This can be
    checked by reading REVIDR register bits 4 and 9. If only bit 4 is set,
    then the IPI broadcast can be skipped.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 9672e978d50d..acdde76b39bb 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -10,6 +10,7 @@
 #define CPUID_TLBTYPE	3
 #define CPUID_MPUIR	4
 #define CPUID_MPIDR	5
+#define CPUID_REVIDR	6
 
 #ifdef CONFIG_CPU_V7M
 #define CPUID_EXT_PFR0	0x40

commit 067e710b9a982a92cc8294d7fa0f1e924c65bba1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jul 30 12:38:45 2013 +0100

    ARM: 7801/1: v6: prevent gcc 4.5 from reordering extended CP15 reads above is_smp() test
    
    Commit 621a0147d5c921f4cc33636ccd0602ad5d7cbfbc ("ARM: 7757/1: mm:
    don't flush icache in switch_mm with hardware broadcasting") breaks
    the boot on OMAP2430SDP with omap2plus_defconfig.  Tracked to an
    undefined instruction abort from the CP15 read in
    cache_ops_need_broadcast().  It turns out that gcc 4.5 reorders the
    extended CP15 read above the is_smp() test.  This breaks ARM1136 r0
    cores, since they don't support several CP15 registers that later ARM
    cores do.  ARM1136JF-S TRM section 3.2.1 "Register allocation" has the
    details.
    
    So mark the extended CP15 read as clobbering memory, which prevents
    the compiler from reordering it before the is_smp() test.  Russell
    states that the code generated from this approach is preferable to
    marking the inline asm as volatile.  Remove the existing condition
    code clobber as it's obsolete, per Nico's post:
    
        http://www.spinics.net/lists/arm-kernel/msg261208.html
    
    This patch is a collaboration with Will Deacon and Russell King.
    
    Comments from Paul Walmsley:
    
     Russell, if you accept this one, might you also add Will's ack from the lists:
    
    Comments from Paul Walmsley:
    
     I'd also be obliged if you could add a Cc: line for Jonathan Austin, since he helped test:
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 8c25dc4e9851..9672e978d50d 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -89,13 +89,18 @@ extern unsigned int processor_id;
 		__val;							\
 	})
 
+/*
+ * The memory clobber prevents gcc 4.5 from reordering the mrc before
+ * any is_smp() tests, which can cause undefined instruction aborts on
+ * ARM1136 r0 due to the missing extended CP15 registers.
+ */
 #define read_cpuid_ext(ext_reg)						\
 	({								\
 		unsigned int __val;					\
 		asm("mrc	p15, 0, %0, c0, " ext_reg		\
 		    : "=r" (__val)					\
 		    :							\
-		    : "cc");						\
+		    : "memory");					\
 		__val;							\
 	})
 

commit 3c0c01ab742ddfaf6b6f2d64b890e77cda4b7727
Merge: cbd379b10019 809e660f438f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jun 29 11:44:43 2013 +0100

    Merge branch 'devel-stable' into for-next
    
    Conflicts:
            arch/arm/Makefile
            arch/arm/include/asm/glue-proc.h

commit 18d7f152df31e5a326301fdaad385e40874dff80
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 19 10:40:48 2013 +0100

    ARM: 7763/1: kernel: fix __cpu_logical_map default initialization
    
    The __cpu_logical_map array is statically initialized to 0, which is a valid
    MPIDR value. To prevent issues with the current implementation, this patch
    defines an MPIDR_INVALID value, and statically initializes the
    __cpu_logical_map[] array to it. Entries in the arm_dt_init_cpu_maps()
    tmp_map array used to stash DT reg properties while parsing DT are initialized
    with the MPIDR_INVALID value as well for consistency.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 7652712d1d14..dba62cb1ad08 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -32,6 +32,8 @@
 
 #define MPIDR_HWID_BITMASK 0xFFFFFF
 
+#define MPIDR_INVALID (~MPIDR_HWID_BITMASK)
+
 #define MPIDR_LEVEL_BITS 8
 #define MPIDR_LEVEL_MASK ((1 << MPIDR_LEVEL_BITS) - 1)
 

commit aca7e5920c8e80a2a49c1e37664675d78b23398b
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Thu Feb 21 15:21:34 2013 +0000

    ARM: mpu: add PMSA related registers and bitfields to existing headers
    
    This patch adds the following definitions relevant to the PMSA:
    
    Add SCTLR bit 17, (CR_BR - Background Region bit) to the list of CR_*
    bitfields. This bit determines whether to use the architecturally defined
    memory map
    
    Add the MPUIR to the available registers when using read_cpuid macro. The
    MPUIR is the MPU type register.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    CC:"Uwe Kleine-K√∂nig" <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index ec635ff32f49..3b704dfb6c58 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -8,6 +8,7 @@
 #define CPUID_CACHETYPE	1
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
+#define CPUID_MPUIR	4
 #define CPUID_MPIDR	5
 
 #ifdef CONFIG_CPU_V7M

commit 6fae9cdafc92ae9958a3a45dd68205f72e3ad900
Author: Uwe Kleine-K√∂nig <u.kleine-koenig@pengutronix.de>
Date:   Mon May 6 11:35:42 2013 +0200

    ARM: ARMv7-M: implement read_cpuid_ext
    
    On v7-M the extended cpuid registers are not available from CP15 but they
    are memory mapped in the System Control Space.
    There isn't an equivalent available for CPUID_{CACHETYPE,TCM,TLBTYPE,MPIDR}.
    
    Signed-off-by: Uwe Kleine-K√∂nig <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 4eb94a3add3c..ec635ff32f49 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -10,6 +10,22 @@
 #define CPUID_TLBTYPE	3
 #define CPUID_MPIDR	5
 
+#ifdef CONFIG_CPU_V7M
+#define CPUID_EXT_PFR0	0x40
+#define CPUID_EXT_PFR1	0x44
+#define CPUID_EXT_DFR0	0x48
+#define CPUID_EXT_AFR0	0x4c
+#define CPUID_EXT_MMFR0	0x50
+#define CPUID_EXT_MMFR1	0x54
+#define CPUID_EXT_MMFR2	0x58
+#define CPUID_EXT_MMFR3	0x5c
+#define CPUID_EXT_ISAR0	0x60
+#define CPUID_EXT_ISAR1	0x64
+#define CPUID_EXT_ISAR2	0x68
+#define CPUID_EXT_ISAR3	0x6c
+#define CPUID_EXT_ISAR4	0x70
+#define CPUID_EXT_ISAR5	0x74
+#else
 #define CPUID_EXT_PFR0	"c1, 0"
 #define CPUID_EXT_PFR1	"c1, 1"
 #define CPUID_EXT_DFR0	"c1, 2"
@@ -24,6 +40,7 @@
 #define CPUID_EXT_ISAR3	"c2, 3"
 #define CPUID_EXT_ISAR4	"c2, 4"
 #define CPUID_EXT_ISAR5	"c2, 5"
+#endif
 
 #define MPIDR_SMP_BITMASK (0x3 << 30)
 #define MPIDR_SMP_VALUE (0x2 << 30)
@@ -79,7 +96,23 @@ extern unsigned int processor_id;
 		__val;							\
 	})
 
-#else /* ifdef CONFIG_CPU_CP15 */
+#elif defined(CONFIG_CPU_V7M)
+
+#include <asm/io.h>
+#include <asm/v7m.h>
+
+#define read_cpuid(reg)							\
+	({								\
+		WARN_ON_ONCE(1);					\
+		0;							\
+	})
+
+static inline unsigned int __attribute_const__ read_cpuid_ext(unsigned offset)
+{
+	return readl(BASEADDR_V7M_SCB + offset);
+}
+
+#else /* ifdef CONFIG_CPU_CP15 / elif defined (CONFIG_CPU_V7M) */
 
 /*
  * read_cpuid and read_cpuid_ext should only ever be called on machines that
@@ -108,9 +141,6 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 
 #elif defined(CONFIG_CPU_V7M)
 
-#include <asm/io.h>
-#include <asm/v7m.h>
-
 static inline unsigned int __attribute_const__ read_cpuid_id(void)
 {
 	return readl(BASEADDR_V7M_SCB + V7M_SCB_CPUID);

commit 55bdd694116597d2f16510b121463cd579ba78da
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri May 21 18:06:41 2010 +0100

    ARM: Add base support for ARMv7-M
    
    This patch adds the base support for the ARMv7-M
    architecture. It consists of the corresponding arch/arm/mm/ files and
    various #ifdef's around the kernel. Exception handling is implemented by
    a subsequent patch.
    
    [ukleinek: squash in some changes originating from commit
    
    b5717ba (Cortex-M3: Add support for the Microcontroller Prototyping System)
    
    from the v2.6.33-arm1 patch stack, port to post 3.6, drop zImage
    support, drop reorganisation of pt_regs, assert CONFIG_CPU_V7M doesn't
    leak into installed headers and a few cosmetic changes]
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Jonathan Austin <jonathan.austin@arm.com>
    Tested-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Uwe Kleine-K√∂nig <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 7652712d1d14..4eb94a3add3c 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -106,7 +106,17 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 	return read_cpuid(CPUID_ID);
 }
 
-#else /* ifdef CONFIG_CPU_CP15 */
+#elif defined(CONFIG_CPU_V7M)
+
+#include <asm/io.h>
+#include <asm/v7m.h>
+
+static inline unsigned int __attribute_const__ read_cpuid_id(void)
+{
+	return readl(BASEADDR_V7M_SCB + V7M_SCB_CPUID);
+}
+
+#else /* ifdef CONFIG_CPU_CP15 / elif defined(CONFIG_CPU_V7M) */
 
 static inline unsigned int __attribute_const__ read_cpuid_id(void)
 {

commit 73a09d212ec65b7068a283e6034fa05649d3d075
Merge: 6dbe51c251a3 6ebd4d038dbb
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 9 15:49:32 2013 +0000

    Merge branch 'for-next' of git://git.pengutronix.de/git/ukl/linux into devel-stable
    
    Conflicts:
            arch/arm/include/asm/cputype.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 6ebd4d038dbb626a43d87db3007e71f92f49d7b3
Author: Uwe Kleine-K√∂nig <u.kleine-koenig@pengutronix.de>
Date:   Thu Jan 31 11:08:03 2013 +0100

    ARM: stub out read_cpuid and read_cpuid_ext for CPU_CP15=n
    
    Traditionally for !CPU_CP15 read_cpuid and read_cpuid_ext returned the
    processor id independent of the parameter passed in. This is wrong of
    course but theoretically this doesn't harm because it's only called on
    machines having a cp15.
    
    Instead return 0 unconditionally which might make unused code paths be
    better optimizable and so smaller and warn about unexpected usage.
    
    Signed-off-by: Uwe Kleine-K√∂nig <u.kleine-koenig@pengutronix.de>
    Message-Id: 1359646587-1788-2-git-send-email-u.kleine-koenig@pengutronix.de

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index a59dcb5ab5fc..574269ed2232 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -50,6 +50,7 @@ extern unsigned int processor_id;
 		    : "cc");						\
 		__val;							\
 	})
+
 #define read_cpuid_ext(ext_reg)						\
 	({								\
 		unsigned int __val;					\
@@ -59,11 +60,24 @@ extern unsigned int processor_id;
 		    : "cc");						\
 		__val;							\
 	})
-#else
-#define read_cpuid(reg) (processor_id)
-#define read_cpuid_ext(reg) 0
-#endif
+
+#else /* ifdef CONFIG_CPU_CP15 */
 
+/*
+ * read_cpuid and read_cpuid_ext should only ever be called on machines that
+ * have cp15 so warn on other usages.
+ */
+#define read_cpuid(reg)							\
+	({								\
+		WARN_ON_ONCE(1);					\
+		0;							\
+	})
+
+#define read_cpuid_ext(reg) read_cpuid(reg)
+
+#endif /* ifdef CONFIG_CPU_CP15 / else */
+
+#ifdef CONFIG_CPU_CP15
 /*
  * The CPU ID never changes at run time, so we might as well tell the
  * compiler that it's constant.  Use this function to read the CPU ID
@@ -74,6 +88,15 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 	return read_cpuid(CPUID_ID);
 }
 
+#else /* ifdef CONFIG_CPU_CP15 */
+
+static inline unsigned int __attribute_const__ read_cpuid_id(void)
+{
+	return processor_id;
+}
+
+#endif /* ifdef CONFIG_CPU_CP15 / else */
+
 static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 {
 	return read_cpuid(CPUID_CACHETYPE);

commit 59530adc3f1b802c275f0197fc3ac72dc014267a
Author: Christoffer Dall <c.dall@virtualopensystems.com>
Date:   Tue Dec 18 04:06:37 2012 +0000

    ARM: Define CPU part numbers and implementors
    
    Define implementor IDs, part numbers and Xscale architecture versions in
    cputype.h.  Also create accessor functions for reading the implementor,
    part number, and Xscale architecture versions from the CPUID regiser.
    
    Signed-off-by: Christoffer Dall <c.dall@virtualopensystems.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index a59dcb5ab5fc..ad41ec2471e8 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -64,6 +64,24 @@ extern unsigned int processor_id;
 #define read_cpuid_ext(reg) 0
 #endif
 
+#define ARM_CPU_IMP_ARM			0x41
+#define ARM_CPU_IMP_INTEL		0x69
+
+#define ARM_CPU_PART_ARM1136		0xB360
+#define ARM_CPU_PART_ARM1156		0xB560
+#define ARM_CPU_PART_ARM1176		0xB760
+#define ARM_CPU_PART_ARM11MPCORE	0xB020
+#define ARM_CPU_PART_CORTEX_A8		0xC080
+#define ARM_CPU_PART_CORTEX_A9		0xC090
+#define ARM_CPU_PART_CORTEX_A5		0xC050
+#define ARM_CPU_PART_CORTEX_A15		0xC0F0
+#define ARM_CPU_PART_CORTEX_A7		0xC070
+
+#define ARM_CPU_XSCALE_ARCH_MASK	0xe000
+#define ARM_CPU_XSCALE_ARCH_V1		0x2000
+#define ARM_CPU_XSCALE_ARCH_V2		0x4000
+#define ARM_CPU_XSCALE_ARCH_V3		0x6000
+
 /*
  * The CPU ID never changes at run time, so we might as well tell the
  * compiler that it's constant.  Use this function to read the CPU ID
@@ -74,6 +92,21 @@ static inline unsigned int __attribute_const__ read_cpuid_id(void)
 	return read_cpuid(CPUID_ID);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_implementor(void)
+{
+	return (read_cpuid_id() & 0xFF000000) >> 24;
+}
+
+static inline unsigned int __attribute_const__ read_cpuid_part_number(void)
+{
+	return read_cpuid_id() & 0xFFF0;
+}
+
+static inline unsigned int __attribute_const__ xscale_cpu_arch_version(void)
+{
+	return read_cpuid_part_number() & ARM_CPU_XSCALE_ARCH_MASK;
+}
+
 static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 {
 	return read_cpuid(CPUID_CACHETYPE);

commit dca463daa0151c5bbbd8ec8fd42882a3966d3c44
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Nov 15 17:30:32 2012 +0000

    ARM: kernel: enhance MPIDR macro definitions
    
    Kernel subsystems other than the topology layer need the MPIDR
    mask definitions to access the MPIDR without relying on hardcoded
    masks. This patch moves the MPIDR register masks definition to
    a header file and defines a macro to simplify access to MPIDR bit fields
    representing affinity levels.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index cb47d28cbe1f..a59dcb5ab5fc 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -25,6 +25,19 @@
 #define CPUID_EXT_ISAR4	"c2, 4"
 #define CPUID_EXT_ISAR5	"c2, 5"
 
+#define MPIDR_SMP_BITMASK (0x3 << 30)
+#define MPIDR_SMP_VALUE (0x2 << 30)
+
+#define MPIDR_MT_BITMASK (0x1 << 24)
+
+#define MPIDR_HWID_BITMASK 0xFFFFFF
+
+#define MPIDR_LEVEL_BITS 8
+#define MPIDR_LEVEL_MASK ((1 << MPIDR_LEVEL_BITS) - 1)
+
+#define MPIDR_AFFINITY_LEVEL(mpidr, level) \
+	((mpidr >> (MPIDR_LEVEL_BITS * level)) & MPIDR_LEVEL_MASK)
+
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15

commit c9018aab8eee24b993c12c7aff7fc99d3d73f298
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Mon Aug 8 13:21:59 2011 +0100

    ARM: 7011/1: Add ARM cpu topology definition
    
    The affinity between ARM processors is defined in the MPIDR register.
    We can identify which processors are in the same cluster,
    and which ones have performance interdependency. We can define the
    cpu topology of ARM platform, that is then used by sched_mc and sched_smt.
    
    The default state of sched_mc and sched_smt config is disable.
    When enabled, the behavior of the scheduler can be modified with
    sched_mc_power_savings and sched_smt_power_savings sysfs interfaces.
    
    Changes since v4 :
    *  Remove unnecessary parentheses and blank lines
    
    Changes since v3 :
    * Update the format of printk message
    * Remove blank line
    
    Changes since v2 :
    * Update the commit message and some comments
    
    Changes since v1 :
    * Update the commit message
    * Add read_cpuid_mpidr in arch/arm/include/asm/cputype.h
    * Modify header of arch/arm/kernel/topology.c
    * Modify tests and manipulation of MPIDR's bitfields
    * Modify the place and dependancy of the config
    * Modify Noop functions
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index cd4458f64171..cb47d28cbe1f 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -8,6 +8,7 @@
 #define CPUID_CACHETYPE	1
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
+#define CPUID_MPIDR	5
 
 #define CPUID_EXT_PFR0	"c1, 0"
 #define CPUID_EXT_PFR1	"c1, 1"
@@ -70,6 +71,11 @@ static inline unsigned int __attribute_const__ read_cpuid_tcmstatus(void)
 	return read_cpuid(CPUID_TCM);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_mpidr(void)
+{
+	return read_cpuid(CPUID_MPIDR);
+}
+
 /*
  * Intel's XScale3 core supports some v6 features (supersections, L2)
  * but advertises itself as v5 as it does not support the v6 ISA.  For

commit e9569c1511d2590a27b46b94bafb7acece034e5c
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Thu Apr 14 12:11:42 2011 +0100

    ARM: 6881/1: cputype.h uses __attribute_const__ which requires including kernel.h
    
    Issue manifests as:
    
    In file included from arch/arm/mach-pxa/include/mach/hardware.h:62,
                      from arch/arm/mach-pxa/include/mach/gpio.h:28,
                      from /home/jic23/src/kernel/temp-remove/arch/arm/include/asm/gpio.h:5,
                      from include/linux/gpio.h:7,
                      from drivers/staging/iio/gyro/adis16080_core.c:8:
     /home/jic23/src/kernel/temp-remove/arch/arm/include/asm/cputype.h:57: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'read_cpuid_id'
    ...
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index ed5bc9e05a4e..cd4458f64171 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -2,6 +2,7 @@
 #define __ASM_ARM_CPUTYPE_H
 
 #include <linux/stringify.h>
+#include <linux/kernel.h>
 
 #define CPUID_ID	0
 #define CPUID_CACHETYPE	1

commit 2bbd7e9b74271b2d6a14b4840fc44afbea83774d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 8 12:05:09 2011 +0000

    ARM: fix some sparse errors in generic ARM code
    
    arch/arm/kernel/return_address.c:37:6: warning: symbol 'return_address' was not declared. Should it be static?
    arch/arm/kernel/setup.c:76:14: warning: symbol 'processor_id' was not declared. Should it be static?
    arch/arm/kernel/traps.c:259:1: warning: symbol 'die_lock' was not declared. Should it be static?
    arch/arm/vfp/vfpmodule.c:156:6: warning: symbol 'vfp_raise_sigfpe' was not declared. Should it be static?
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 20ae96cc0020..ed5bc9e05a4e 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -23,6 +23,8 @@
 #define CPUID_EXT_ISAR4	"c2, 4"
 #define CPUID_EXT_ISAR5	"c2, 5"
 
+extern unsigned int processor_id;
+
 #ifdef CONFIG_CPU_CP15
 #define read_cpuid(reg)							\
 	({								\
@@ -43,7 +45,6 @@
 		__val;							\
 	})
 #else
-extern unsigned int processor_id;
 #define read_cpuid(reg) (processor_id)
 #define read_cpuid_ext(reg) 0
 #endif

commit 28f9f19db9dda54c851d5689539d86f6fc008773
Merge: 40262b2b6efa 52a7a1cec88a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Sep 21 16:02:24 2009 +0100

    Merge branch 'devel' of git://git.kernel.org/pub/scm/linux/kernel/git/ycmiao/pxa-linux-2.6 into devel

commit bc581770cfdd8c17ea17d324dc05e2f9c599e7ca
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Sep 15 17:30:37 2009 +0100

    ARM: 5580/2: ARM TCM (Tightly-Coupled Memory) support v3
    
    This adds the TCM interface to Linux, when active, it will
    detect and report TCM memories and sizes early in boot if
    present, introduce generic TCM memory handling, provide a
    generic TCM memory pool and select TCM memory for the U300
    platform.
    
    See the Documentation/arm/tcm.txt for documentation.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index b3e656c6fb78..54a1f1d76b14 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -63,6 +63,11 @@ static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 	return read_cpuid(CPUID_CACHETYPE);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_tcmstatus(void)
+{
+	return read_cpuid(CPUID_TCM);
+}
+
 /*
  * Intel's XScale3 core supports some v6 features (supersections, L2)
  * but advertises itself as v5 as it does not support the v6 ISA.  For

commit 337c1db645bce3f5a832129c4a803dc157ac7e9a
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Fri Aug 21 16:10:41 2009 +0800

    [ARM] pxa: update cpu_is_xsc3() to include Marvell CPUID
    
    CPU id is changed in Marvell chip. So update the code in cpu_is_xsc3().
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index b3e656c6fb78..7c6e208a7de7 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -73,7 +73,10 @@ static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
 #else
 static inline int cpu_is_xsc3(void)
 {
-	if ((read_cpuid_id() & 0xffffe000) == 0x69056000)
+	unsigned int id;
+	id = read_cpuid_id() & 0xffffe000;
+	/* It covers both Intel ID and Marvell ID */
+	if ((id == 0x69056000) || (id == 0x56056000))
 		return 1;
 
 	return 0;

commit faa7bc51c11d5bbe440ac04710fd7a3208782000
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Sat May 30 14:00:14 2009 +0100

    Check whether the TLB operations need broadcasting on SMP systems
    
    ARMv7 SMP hardware can handle the TLB maintenance operations
    broadcasting in hardware so that the software can avoid the costly IPIs.
    This patch adds the necessary checks (the MMFR3 CPUID register) to avoid
    the broadcasting if already supported by the hardware.
    
    (this patch is based on the work done by Tony Thompson @ ARM)
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 7b9d27e749b8..b3e656c6fb78 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -8,6 +8,21 @@
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
 
+#define CPUID_EXT_PFR0	"c1, 0"
+#define CPUID_EXT_PFR1	"c1, 1"
+#define CPUID_EXT_DFR0	"c1, 2"
+#define CPUID_EXT_AFR0	"c1, 3"
+#define CPUID_EXT_MMFR0	"c1, 4"
+#define CPUID_EXT_MMFR1	"c1, 5"
+#define CPUID_EXT_MMFR2	"c1, 6"
+#define CPUID_EXT_MMFR3	"c1, 7"
+#define CPUID_EXT_ISAR0	"c2, 0"
+#define CPUID_EXT_ISAR1	"c2, 1"
+#define CPUID_EXT_ISAR2	"c2, 2"
+#define CPUID_EXT_ISAR3	"c2, 3"
+#define CPUID_EXT_ISAR4	"c2, 4"
+#define CPUID_EXT_ISAR5	"c2, 5"
+
 #ifdef CONFIG_CPU_CP15
 #define read_cpuid(reg)							\
 	({								\
@@ -18,9 +33,19 @@
 		    : "cc");						\
 		__val;							\
 	})
+#define read_cpuid_ext(ext_reg)						\
+	({								\
+		unsigned int __val;					\
+		asm("mrc	p15, 0, %0, c0, " ext_reg		\
+		    : "=r" (__val)					\
+		    :							\
+		    : "cc");						\
+		__val;							\
+	})
 #else
 extern unsigned int processor_id;
 #define read_cpuid(reg) (processor_id)
+#define read_cpuid_ext(reg) 0
 #endif
 
 /*

commit 0ba8b9b273c45dd23f60ff700e265a0069b33758
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 10 18:08:10 2008 +0100

    [ARM] cputype: separate definitions, use them
    
    Add asm/cputype.h, moving functions and definitions from asm/system.h
    there.  Convert all users of 'processor_id' to the more efficient
    read_cpuid_id() function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
new file mode 100644
index 000000000000..7b9d27e749b8
--- /dev/null
+++ b/arch/arm/include/asm/cputype.h
@@ -0,0 +1,64 @@
+#ifndef __ASM_ARM_CPUTYPE_H
+#define __ASM_ARM_CPUTYPE_H
+
+#include <linux/stringify.h>
+
+#define CPUID_ID	0
+#define CPUID_CACHETYPE	1
+#define CPUID_TCM	2
+#define CPUID_TLBTYPE	3
+
+#ifdef CONFIG_CPU_CP15
+#define read_cpuid(reg)							\
+	({								\
+		unsigned int __val;					\
+		asm("mrc	p15, 0, %0, c0, c0, " __stringify(reg)	\
+		    : "=r" (__val)					\
+		    :							\
+		    : "cc");						\
+		__val;							\
+	})
+#else
+extern unsigned int processor_id;
+#define read_cpuid(reg) (processor_id)
+#endif
+
+/*
+ * The CPU ID never changes at run time, so we might as well tell the
+ * compiler that it's constant.  Use this function to read the CPU ID
+ * rather than directly reading processor_id or read_cpuid() directly.
+ */
+static inline unsigned int __attribute_const__ read_cpuid_id(void)
+{
+	return read_cpuid(CPUID_ID);
+}
+
+static inline unsigned int __attribute_const__ read_cpuid_cachetype(void)
+{
+	return read_cpuid(CPUID_CACHETYPE);
+}
+
+/*
+ * Intel's XScale3 core supports some v6 features (supersections, L2)
+ * but advertises itself as v5 as it does not support the v6 ISA.  For
+ * this reason, we need a way to explicitly test for this type of CPU.
+ */
+#ifndef CONFIG_CPU_XSC3
+#define cpu_is_xsc3()	0
+#else
+static inline int cpu_is_xsc3(void)
+{
+	if ((read_cpuid_id() & 0xffffe000) == 0x69056000)
+		return 1;
+
+	return 0;
+}
+#endif
+
+#if !defined(CONFIG_CPU_XSCALE) && !defined(CONFIG_CPU_XSC3)
+#define	cpu_is_xscale()	0
+#else
+#define	cpu_is_xscale()	1
+#endif
+
+#endif
