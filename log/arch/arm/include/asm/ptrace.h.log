commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index c7cdbb43ae7c..91d6b7856be4 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  arch/arm/include/asm/ptrace.h
  *
  *  Copyright (C) 1996-2003 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef __ASM_ARM_PTRACE_H
 #define __ASM_ARM_PTRACE_H

commit d15155824c5014803d91b829736d249c500bdda6
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Oct 24 11:22:46 2017 +0100

    linux/compiler.h: Split into compiler.h and compiler_types.h
    
    linux/compiler.h is included indirectly by linux/types.h via
    uapi/linux/types.h -> uapi/linux/posix_types.h -> linux/stddef.h
    -> uapi/linux/stddef.h and is needed to provide a proper definition of
    offsetof.
    
    Unfortunately, compiler.h requires a definition of
    smp_read_barrier_depends() for defining lockless_dereference() and soon
    for defining READ_ONCE(), which means that all
    users of READ_ONCE() will need to include asm/barrier.h to avoid splats
    such as:
    
       In file included from include/uapi/linux/stddef.h:1:0,
                        from include/linux/stddef.h:4,
                        from arch/h8300/kernel/asm-offsets.c:11:
       include/linux/list.h: In function 'list_empty':
    >> include/linux/compiler.h:343:2: error: implicit declaration of function 'smp_read_barrier_depends' [-Werror=implicit-function-declaration]
         smp_read_barrier_depends(); /* Enforce dependency ordering from x */ \
         ^
    
    A better alternative is to include asm/barrier.h in linux/compiler.h,
    but this requires a type definition for "bool" on some architectures
    (e.g. x86), which is defined later by linux/types.h. Type "bool" is also
    used directly in linux/compiler.h, so the whole thing is pretty fragile.
    
    This patch splits compiler.h in two: compiler_types.h contains type
    annotations, definitions and the compiler-specific parts, whereas
    compiler.h #includes compiler-types.h and additionally defines macros
    such as {READ,WRITE.ACCESS}_ONCE().
    
    uapi/linux/stddef.h and linux/linkage.h are then moved over to include
    linux/compiler_types.h, which fixes the build for h8 and blackfin.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1508840570-22169-2-git-send-email-will.deacon@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index e9c9a117bd25..c7cdbb43ae7c 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -126,8 +126,7 @@ extern unsigned long profile_pc(struct pt_regs *regs);
 /*
  * kprobe-based event tracer support
  */
-#include <linux/stddef.h>
-#include <linux/types.h>
+#include <linux/compiler.h>
 #define MAX_REG_OFFSET (offsetof(struct pt_regs, ARM_ORIG_r0))
 
 extern int regs_query_register_offset(const char *name);

commit e6978e4bf181fb3b5f8cb6f71b4fe30fbf1b655c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri May 13 11:40:20 2016 +0100

    ARM: save and reset the address limit when entering an exception
    
    When we enter an exception, the current address limit should not apply
    to the exception context: if the exception context wishes to access
    kernel space via the user accessors (eg, perf code), it must explicitly
    request such access.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 0ef0093800f2..e9c9a117bd25 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -22,7 +22,7 @@ struct pt_regs {
 struct svc_pt_regs {
 	struct pt_regs regs;
 	u32 dacr;
-	u32 unused;
+	u32 addr_limit;
 };
 
 #define to_svc_pt_regs(r) container_of(r, struct svc_pt_regs, regs)

commit 5fa9da5043a81b9eea5d4522d1371455bf64894a
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri May 13 10:26:10 2016 +0100

    ARM: get rid of horrible *(unsigned int *)(regs + 1)
    
    Get rid of the horrible "*(unsigned int *)(regs + 1)" to get at the
    parent context domain access register value, instead using the newly
    introduced svc_pt_regs structure.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 5194cf79c90f..0ef0093800f2 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -25,6 +25,8 @@ struct svc_pt_regs {
 	u32 unused;
 };
 
+#define to_svc_pt_regs(r) container_of(r, struct svc_pt_regs, regs)
+
 #define user_mode(regs)	\
 	(((regs)->ARM_cpsr & 0xf) == 0)
 

commit e6a9dc6129d23cd3025e841c4e13a70910a37135
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri May 13 10:22:38 2016 +0100

    ARM: introduce svc_pt_regs structure
    
    Since the privileged mode pt_regs are an extended version of the saved
    userland pt_regs, introduce a new svc_pt_regs structure to describe this
    layout.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 51622ba7c4a6..5194cf79c90f 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -13,10 +13,18 @@
 #include <uapi/asm/ptrace.h>
 
 #ifndef __ASSEMBLY__
+#include <linux/types.h>
+
 struct pt_regs {
 	unsigned long uregs[18];
 };
 
+struct svc_pt_regs {
+	struct pt_regs regs;
+	u32 dacr;
+	u32 unused;
+};
+
 #define user_mode(regs)	\
 	(((regs)->ARM_cpsr & 0xf) == 0)
 

commit 0ebc1f5671dff84b7ba4dcc38ebce956e6dea5fa
Author: Behan Webster <behanw@converseincode.com>
Date:   Sat Sep 27 00:31:06 2014 +0100

    ARM: 8175/1: Use current_stack_pointer to calculate pt_regs address
    
    Use the global current_stack_pointer to calculate the end of the stack for
    current_pt_regs()
    
    Signed-off-by: Behan Webster <behanw@converseincode.com>
    Reviewed-by: Mark Charlebois <charlebm@gmail.com>
    Reviewed-by: Jan-Simon Möller <dl9pf@gmx.de>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 601264d983fa..51622ba7c4a6 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -154,9 +154,8 @@ static inline unsigned long user_stack_pointer(struct pt_regs *regs)
 	return regs->ARM_sp;
 }
 
-#define current_pt_regs(void) ({				\
-	register unsigned long sp asm ("sp");			\
-	(struct pt_regs *)((sp | (THREAD_SIZE - 1)) - 7) - 1;	\
+#define current_pt_regs(void) ({ (struct pt_regs *)			\
+		((current_stack_pointer | (THREAD_SIZE - 1)) - 7) - 1;	\
 })
 
 #endif /* __ASSEMBLY__ */

commit 9865f1d46a68a5f58cb623054c8308484007d8a4
Author: Nikolay Borisov <Nikolay.Borisov@arm.com>
Date:   Tue Jun 3 19:48:10 2014 +0100

    ARM: 8070/1: Introduce arm_get_current_stack_frame()
    
    Currently there are numerous places where "struct pt_regs" are used to
    populate "struct stackframe", however all of those location do not
    consider the situation where the kernel might be compiled in THUMB2
    mode, in which case the framepointer member of pt_regs become ARM_r7
    instead of ARM_fp (r11). Document this idiosyncracy in the
    definition of "struct stackframe"
    
    The easiest solution is to introduce a new function (in the spirit of
    https://groups.google.com/forum/#!topic/linux.kernel/dA2YuUcSpZ4)
    which would hide the complexity of initializing the stackframe struct
    from pt_regs.
    
    Also implement a macro frame_pointer(regs) that would return the correct
    register so that we can use it in cases where we just require the frame
    pointer and not a whole struct stackframe
    
    Signed-off-by: Nikolay Borisov <Nikolay.Borisov@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Robert Richter <rric@kernel.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index c877654fe3bf..601264d983fa 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -84,6 +84,12 @@ static inline long regs_return_value(struct pt_regs *regs)
 
 #define instruction_pointer(regs)	(regs)->ARM_pc
 
+#ifdef CONFIG_THUMB2_KERNEL
+#define frame_pointer(regs) (regs)->ARM_r7
+#else
+#define frame_pointer(regs) (regs)->ARM_fp
+#endif
+
 static inline void instruction_pointer_set(struct pt_regs *regs,
 					   unsigned long val)
 {

commit 566b60c04ab230b8cc3845f964306f99504b18df
Merge: 3ba4cea21901 c7edc9e326d5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 19 20:15:46 2014 +0000

    Merge branch 'uprobes-v7' of git://git.linaro.org/people/dave.long/linux into devel-stable
    
    This patch series adds basic uprobes support to ARM. It is based on
    patches developed earlier by Rabin Vincent. That approach of adding
    hooks into the kprobes instruction parsing code was not well received.
    This approach separates the ARM instruction parsing code in kprobes out
    into a separate set of functions which can be used by both kprobes and
    uprobes. Both kprobes and uprobes then provide their own semantic action
    tables to process the results of the parsing.

commit c7edc9e326d53ca5ef9bed82de0740c6b107d55b
Author: David A. Long <dave.long@linaro.org>
Date:   Fri Mar 7 11:23:04 2014 -0500

    ARM: add uprobes support
    
    Using Rabin Vincent's ARM uprobes patches as a base, enable uprobes
    support on ARM.
    
    Caveats:
    
     - Thumb is not supported
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: David A. Long <dave.long@linaro.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 04c99f36ff7f..ee688b0a13c3 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -80,6 +80,12 @@ static inline long regs_return_value(struct pt_regs *regs)
 
 #define instruction_pointer(regs)	(regs)->ARM_pc
 
+static inline void instruction_pointer_set(struct pt_regs *regs,
+					   unsigned long val)
+{
+	instruction_pointer(regs) = val;
+}
+
 #ifdef CONFIG_SMP
 extern unsigned long profile_pc(struct pt_regs *regs);
 #else

commit 3f18b1bf599d3d13cd81fdf6bf869c458772adfe
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Dec 16 10:24:46 2013 +0100

    ARM: make isa_mode macro more robust and fix for v7-M
    
    The definition of isa_mode hardcodes the values to shift PSR_J_BIT and
    PSR_T_BIT to move them to bits 1 and 0 respectively. Instead use __ffs to
    calculate the shift from the #define already used for masking.
    
    This is relevant on v7-M as there PSR_T_BIT is 0x01000000 instead of
    0x00000020 for V7-[AR] and earlier. Because of that isa_mode produced
    values >= 0x80000 which are unsuitable to index into isa_modes[4] there
    and so made __show_regs read from undefined memory which resulted in
    hangs and crashes.
    
    Moreover isa_mode is wrong for v7-M even after this robustness fix as
    there is no J-bit in the PSR register. So hardcode isa_mode to "Thumb"
    for v7-M.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 04c99f36ff7f..627a03ebb987 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -27,9 +27,13 @@ struct pt_regs {
 #define thumb_mode(regs) (0)
 #endif
 
+#ifndef CONFIG_CPU_V7M
 #define isa_mode(regs) \
-	((((regs)->ARM_cpsr & PSR_J_BIT) >> 23) | \
-	 (((regs)->ARM_cpsr & PSR_T_BIT) >> 5))
+	((((regs)->ARM_cpsr & PSR_J_BIT) >> (__ffs(PSR_J_BIT) - 1)) | \
+	 (((regs)->ARM_cpsr & PSR_T_BIT) >> (__ffs(PSR_T_BIT))))
+#else
+#define isa_mode(regs) 1 /* Thumb */
+#endif
 
 #define processor_mode(regs) \
 	((regs)->ARM_cpsr & MODE_MASK)

commit 55bdd694116597d2f16510b121463cd579ba78da
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri May 21 18:06:41 2010 +0100

    ARM: Add base support for ARMv7-M
    
    This patch adds the base support for the ARMv7-M
    architecture. It consists of the corresponding arch/arm/mm/ files and
    various #ifdef's around the kernel. Exception handling is implemented by
    a subsequent patch.
    
    [ukleinek: squash in some changes originating from commit
    
    b5717ba (Cortex-M3: Add support for the Microcontroller Prototyping System)
    
    from the v2.6.33-arm1 patch stack, port to post 3.6, drop zImage
    support, drop reorganisation of pt_regs, assert CONFIG_CPU_V7M doesn't
    leak into installed headers and a few cosmetic changes]
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Jonathan Austin <jonathan.austin@arm.com>
    Tested-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 3d52ee1bfb31..04c99f36ff7f 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -45,6 +45,7 @@ struct pt_regs {
  */
 static inline int valid_user_regs(struct pt_regs *regs)
 {
+#ifndef CONFIG_CPU_V7M
 	unsigned long mode = regs->ARM_cpsr & MODE_MASK;
 
 	/*
@@ -67,6 +68,9 @@ static inline int valid_user_regs(struct pt_regs *regs)
 		regs->ARM_cpsr |= USR_MODE;
 
 	return 0;
+#else /* ifndef CONFIG_CPU_V7M */
+	return 1;
+#endif
 }
 
 static inline long regs_return_value(struct pt_regs *regs)

commit cb8db5d4578ac9d996200ab59aa655344d305f5b
Author: David Howells <dhowells@redhat.com>
Date:   Fri Oct 12 13:05:52 2012 +0100

    UAPI: (Scripted) Disintegrate arch/arm/include/asm
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 142d6ae41231..3d52ee1bfb31 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -10,133 +10,12 @@
 #ifndef __ASM_ARM_PTRACE_H
 #define __ASM_ARM_PTRACE_H
 
-#include <asm/hwcap.h>
-
-#define PTRACE_GETREGS		12
-#define PTRACE_SETREGS		13
-#define PTRACE_GETFPREGS	14
-#define PTRACE_SETFPREGS	15
-/* PTRACE_ATTACH is 16 */
-/* PTRACE_DETACH is 17 */
-#define PTRACE_GETWMMXREGS	18
-#define PTRACE_SETWMMXREGS	19
-/* 20 is unused */
-#define PTRACE_OLDSETOPTIONS	21
-#define PTRACE_GET_THREAD_AREA	22
-#define PTRACE_SET_SYSCALL	23
-/* PTRACE_SYSCALL is 24 */
-#define PTRACE_GETCRUNCHREGS	25
-#define PTRACE_SETCRUNCHREGS	26
-#define PTRACE_GETVFPREGS	27
-#define PTRACE_SETVFPREGS	28
-#define PTRACE_GETHBPREGS	29
-#define PTRACE_SETHBPREGS	30
-
-/*
- * PSR bits
- */
-#define USR26_MODE	0x00000000
-#define FIQ26_MODE	0x00000001
-#define IRQ26_MODE	0x00000002
-#define SVC26_MODE	0x00000003
-#define USR_MODE	0x00000010
-#define FIQ_MODE	0x00000011
-#define IRQ_MODE	0x00000012
-#define SVC_MODE	0x00000013
-#define ABT_MODE	0x00000017
-#define HYP_MODE	0x0000001a
-#define UND_MODE	0x0000001b
-#define SYSTEM_MODE	0x0000001f
-#define MODE32_BIT	0x00000010
-#define MODE_MASK	0x0000001f
-#define PSR_T_BIT	0x00000020
-#define PSR_F_BIT	0x00000040
-#define PSR_I_BIT	0x00000080
-#define PSR_A_BIT	0x00000100
-#define PSR_E_BIT	0x00000200
-#define PSR_J_BIT	0x01000000
-#define PSR_Q_BIT	0x08000000
-#define PSR_V_BIT	0x10000000
-#define PSR_C_BIT	0x20000000
-#define PSR_Z_BIT	0x40000000
-#define PSR_N_BIT	0x80000000
-
-/*
- * Groups of PSR bits
- */
-#define PSR_f		0xff000000	/* Flags		*/
-#define PSR_s		0x00ff0000	/* Status		*/
-#define PSR_x		0x0000ff00	/* Extension		*/
-#define PSR_c		0x000000ff	/* Control		*/
-
-/*
- * ARMv7 groups of PSR bits
- */
-#define APSR_MASK	0xf80f0000	/* N, Z, C, V, Q and GE flags */
-#define PSR_ISET_MASK	0x01000010	/* ISA state (J, T) mask */
-#define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
-#define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */
-
-/*
- * Default endianness state
- */
-#ifdef CONFIG_CPU_ENDIAN_BE8
-#define PSR_ENDSTATE	PSR_E_BIT
-#else
-#define PSR_ENDSTATE	0
-#endif
-
-/* 
- * These are 'magic' values for PTRACE_PEEKUSR that return info about where a
- * process is located in memory.
- */
-#define PT_TEXT_ADDR		0x10000
-#define PT_DATA_ADDR		0x10004
-#define PT_TEXT_END_ADDR	0x10008
+#include <uapi/asm/ptrace.h>
 
 #ifndef __ASSEMBLY__
-
-/*
- * This struct defines the way the registers are stored on the
- * stack during a system call.  Note that sizeof(struct pt_regs)
- * has to be a multiple of 8.
- */
-#ifndef __KERNEL__
-struct pt_regs {
-	long uregs[18];
-};
-#else /* __KERNEL__ */
 struct pt_regs {
 	unsigned long uregs[18];
 };
-#endif /* __KERNEL__ */
-
-#define ARM_cpsr	uregs[16]
-#define ARM_pc		uregs[15]
-#define ARM_lr		uregs[14]
-#define ARM_sp		uregs[13]
-#define ARM_ip		uregs[12]
-#define ARM_fp		uregs[11]
-#define ARM_r10		uregs[10]
-#define ARM_r9		uregs[9]
-#define ARM_r8		uregs[8]
-#define ARM_r7		uregs[7]
-#define ARM_r6		uregs[6]
-#define ARM_r5		uregs[5]
-#define ARM_r4		uregs[4]
-#define ARM_r3		uregs[3]
-#define ARM_r2		uregs[2]
-#define ARM_r1		uregs[1]
-#define ARM_r0		uregs[0]
-#define ARM_ORIG_r0	uregs[17]
-
-/*
- * The size of the user-visible VFP state as seen by PTRACE_GET/SETVFPREGS
- * and core dumps.
- */
-#define ARM_VFPREGS_SIZE ( 32 * 8 /*fpregs*/ + 4 /*fpscr*/ )
-
-#ifdef __KERNEL__
 
 #define user_mode(regs)	\
 	(((regs)->ARM_cpsr & 0xf) == 0)
@@ -260,9 +139,5 @@ static inline unsigned long user_stack_pointer(struct pt_regs *regs)
 	(struct pt_regs *)((sp | (THREAD_SIZE - 1)) - 7) - 1;	\
 })
 
-#endif /* __KERNEL__ */
-
 #endif /* __ASSEMBLY__ */
-
 #endif
-

commit 5cea24c5899a81abf59706d69580dd5c734effa8
Merge: 2fc07efa2241 a0f0dd57f4a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 12 12:32:43 2012 +0900

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull second set of ARM updates from Russell King:
     "This is the second set of ARM updates for this merge window.
    
      Contained within are changes to allow the kernel to boot in hypervisor
      mode on CPUs supporting virtualization, and cache flushing support to
      the point of inner sharable unification, which are used by the
      suspend/resume code to avoid having to do a full cache flush.
    
      Also included is one fix for VFP code identified by Michael Olbrich."
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm:
      ARM: vfp: fix saving d16-d31 vfp registers on v6+ kernels
      ARM: 7549/1: HYP: fix boot on some ARM1136 cores
      ARM: 7542/1: mm: fix cache LoUIS API for xscale and feroceon
      ARM: mm: update __v7_setup() to the new LoUIS cache maintenance API
      ARM: kernel: update __cpu_disable to use cache LoUIS maintenance API
      ARM: kernel: update cpu_suspend code to use cache LoUIS operations
      ARM: mm: rename jump labels in v7_flush_dcache_all function
      ARM: mm: implement LoUIS API for cache maintenance ops
      ARM: virt: arch_timers: enable access to physical timers
      ARM: virt: Add CONFIG_ARM_VIRT_EXT option
      ARM: virt: Add boot-time diagnostics
      ARM: virt: Update documentation for hyp mode entry support
      ARM: zImage/virt: hyp mode entry support for the zImage loader
      ARM: virt: allow the kernel to be entered in HYP mode
      ARM: opcodes: add __ERET/__MSR_ELR_HYP instruction encoding

commit bfd170d56505bf21cb636b0f1f169eaa815bdfe4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Aug 2 11:49:43 2012 +0400

    arm: optimized current_pt_regs()
    
    ... no need to read current_thread_info()->task only to
    feed it to task_thread_page() immediately afterwards.
    Moreover, not using current_thread_info() at all ends
    up with better assembler - we need a location very close
    to the top of kernel stack page and it's actually better
    to do or with 0x1fff, followed be subtracting a small
    constant than and with ~0x1fff, followed by adding a large
    one.  Both & and | would be a couple of insns (mvn lsr/mvn lsl
    for |, a pair of bic for &), but the following addition
    would cost a pair of add while the subtraction ends up
    as a single sub.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 355ece523f41..44fe998269d9 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -254,6 +254,11 @@ static inline unsigned long user_stack_pointer(struct pt_regs *regs)
 	return regs->ARM_sp;
 }
 
+#define current_pt_regs(void) ({				\
+	register unsigned long sp asm ("sp");			\
+	(struct pt_regs *)((sp | (THREAD_SIZE - 1)) - 7) - 1;	\
+})
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASSEMBLY__ */

commit 80c59dafb1a9a86fa996e6e34d06b60567c925ca
Author: Dave Martin <dave.martin@linaro.org>
Date:   Thu Feb 9 08:47:17 2012 -0800

    ARM: virt: allow the kernel to be entered in HYP mode
    
    This patch does two things:
    
      * Ensure that asynchronous aborts are masked at kernel entry.
        The bootloader should be masking these anyway, but this reduces
        the damage window just in case it doesn't.
    
      * Enter svc mode via exception return to ensure that CPU state is
        properly serialised.  This does not matter when switching from
        an ordinary privileged mode ("PL1" modes in ARMv7-AR rev C
        parlance), but it potentially does matter when switching from a
        another privileged mode such as hyp mode.
    
    This should allow the kernel to boot safely either from svc mode or
    hyp mode, even if no support for use of the ARM Virtualization
    Extensions is built into the kernel.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 355ece523f41..91ef6c231c47 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -44,6 +44,7 @@
 #define IRQ_MODE	0x00000012
 #define SVC_MODE	0x00000013
 #define ABT_MODE	0x00000017
+#define HYP_MODE	0x0000001a
 #define UND_MODE	0x0000001b
 #define SYSTEM_MODE	0x0000001f
 #define MODE32_BIT	0x00000010

commit 0693bf68148c4473158e435383e75af70b704f78
Author: Wade Farnsworth <wade_farnsworth@mentor.com>
Date:   Wed Apr 4 16:19:47 2012 +0100

    ARM: 7374/1: add TRACEHOOK support
    
    Add calls to tracehook_report_syscall_{entry,exit} and tracehook_signal_handler
    
    Signed-off-by: Steven Walter <stevenrwalter@gmail.com>
    Signed-off-by: Wade Farnsworth <wade_farnsworth@mentor.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 451808ba1211..355ece523f41 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -249,6 +249,11 @@ static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
 	return regs->ARM_sp;
 }
 
+static inline unsigned long user_stack_pointer(struct pt_regs *regs)
+{
+	return regs->ARM_sp;
+}
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASSEMBLY__ */

commit 29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b
Author: Nathaniel Husted <nhusted@gmail.com>
Date:   Tue Jan 3 14:23:09 2012 -0500

    Kernel: Audit Support For The ARM Platform
    
    This patch provides functionality to audit system call events on the
    ARM platform. The implementation was based off the structure of the
    MIPS platform and information in this
    (http://lists.fedoraproject.org/pipermail/arm/2009-October/000382.html)
    mailing list thread. The required audit_syscall_exit and
    audit_syscall_entry checks were added to ptrace using the standard
    registers for system call values (r0 through r3). A thread information
    flag was added for auditing (TIF_SYSCALL_AUDIT) and a meta-flag was
    added (_TIF_SYSCALL_WORK) to simplify modifications to the syscall
    entry/exit. Now, if either the TRACE flag is set or the AUDIT flag is
    set, the syscall_trace function will be executed. The prober changes
    were made to Kconfig to allow CONFIG_AUDITSYSCALL to be enabled.
    
    Due to platform availability limitations, this patch was only tested
    on the Android platform running the modified "android-goldfish-2.6.29"
    kernel. A test compile was performed using Code Sourcery's
    cross-compilation toolset and the current linux-3.0 stable kernel. The
    changes compile without error. I'm hoping, due to the simple modifications,
    the patch is "obviously correct".
    
    Signed-off-by: Nathaniel Husted <nhusted@gmail.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 96187ff58c24..451808ba1211 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -189,6 +189,11 @@ static inline int valid_user_regs(struct pt_regs *regs)
 	return 0;
 }
 
+static inline long regs_return_value(struct pt_regs *regs)
+{
+	return regs->ARM_r0;
+}
+
 #define instruction_pointer(regs)	(regs)->ARM_pc
 
 #ifdef CONFIG_SMP

commit 7460bce42323df6570c7ba5091cb5201c7af1944
Author: Jon Medhurst <tixy@yxit.co.uk>
Date:   Fri Jun 3 12:12:33 2011 +0100

    ARM: ptrace: Add APSR_MASK definition to ptrace.h
    
    APSR_MASK can be used to extract the APSR bits from the CPSR. The
    comment for these definitions is also changed because it was inaccurate
    as the existing defines didn't refer to any part of the APSR.
    
    Signed-off-by: Jon Medhurst <tixy@yxit.co.uk>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index d484871698da..96187ff58c24 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -69,8 +69,9 @@
 #define PSR_c		0x000000ff	/* Control		*/
 
 /*
- * ARMv7 groups of APSR bits
+ * ARMv7 groups of PSR bits
  */
+#define APSR_MASK	0xf80f0000	/* N, Z, C, V, Q and GE flags */
 #define PSR_ISET_MASK	0x01000010	/* ISA state (J, T) mask */
 #define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
 #define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */

commit 592201a9f154cdd5db59304d1369e94d8b551803
Author: Jon Medhurst <tixy@yxit.co.uk>
Date:   Sat Mar 26 19:19:07 2011 +0000

    ARM: Thumb-2: Support Thumb-2 in undefined instruction handler
    
    This patch allows undef_hook's to be specified for 32-bit Thumb
    instructions and also to be used for thumb kernel-side code.
    
    32-bit Thumb instructions are specified in the form:
            ((first_half << 16 ) | second_half)
    which matches the layout used by the ARM ARM.
    
    ptrace was handling 32-bit Thumb instructions by hooking the first
    halfword and manually checking the second half. This method would be
    broken by this patch so it is migrated to make use of the new Thumb-2
    support.
    
    Signed-off-by: Jon Medhurst <tixy@yxit.co.uk>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 312d10877bd7..d484871698da 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -199,6 +199,14 @@ extern unsigned long profile_pc(struct pt_regs *regs);
 #define predicate(x)		((x) & 0xf0000000)
 #define PREDICATE_ALWAYS	0xe0000000
 
+/*
+ * True if instr is a 32-bit thumb instruction. This works if instr
+ * is the first or only half-word of a thumb instruction. It also works
+ * when instr holds all 32-bits of a wide thumb instruction if stored
+ * in the form (first_half<<16)|(second_half)
+ */
+#define is_wide_instruction(instr)	((unsigned)(instr) >= 0xe800)
+
 /*
  * kprobe-based event tracer support
  */

commit 5be6f62b0059a3344437b4c2877152c58cb3fdeb
Author: Dave Martin <dave.martin@linaro.org>
Date:   Mon Apr 18 14:48:23 2011 +0100

    ARM: 6883/1: ptrace: Migrate to regsets framework
    
    This patch migrates the implementation of the ptrace interface for
    the core integer registers, legacy FPA registers and VFP registers
    to use the regsets framework.
    
    As an added bonus, all this stuff gets included in coredumps
    at no extra cost.  Without this patch, coredumps contained no
    VFP state.
    
    Third-party extension register sets (iwmmx, crunch) are not migrated
    by this patch, and continue to use the old implementation;
    these should be migratable without much extra work.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Acked-by: Will Deacon <Will.Deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index a8ff22b2a391..312d10877bd7 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -128,6 +128,12 @@ struct pt_regs {
 #define ARM_r0		uregs[0]
 #define ARM_ORIG_r0	uregs[17]
 
+/*
+ * The size of the user-visible VFP state as seen by PTRACE_GET/SETVFPREGS
+ * and core dumps.
+ */
+#define ARM_VFPREGS_SIZE ( 32 * 8 /*fpregs*/ + 4 /*fpscr*/ )
+
 #ifdef __KERNEL__
 
 #define user_mode(regs)	\

commit 425fc47adb5bb69f76285be77a09a3341a30799e
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Feb 14 14:31:09 2011 +0100

    ARM: 6668/1: ptrace: remove single-step emulation code
    
    PTRACE_SINGLESTEP is a ptrace request designed to offer single-stepping
    support to userspace when the underlying architecture has hardware
    support for this operation.
    
    On ARM, we set arch_has_single_step() to 1 and attempt to emulate hardware
    single-stepping by disassembling the current instruction to determine the
    next pc and placing a software breakpoint on that location.
    
    Unfortunately this has the following problems:
    
    1.) Only a subset of ARMv7 instructions are supported
    2.) Thumb-2 is unsupported
    3.) The code is not SMP safe
    
    We could try to fix this code, but it turns out that because of the above
    issues it is rarely used in practice.  GDB, for example, uses PTRACE_POKETEXT
    and PTRACE_PEEKTEXT to manage breakpoints itself and does not require any
    kernel assistance.
    
    This patch removes the single-step emulation code from ptrace meaning that
    the PTRACE_SINGLESTEP request will return -EIO on ARM. Portable code must
    check the return value from a ptrace call and handle the failure gracefully.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 783d50f32618..a8ff22b2a391 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -130,8 +130,6 @@ struct pt_regs {
 
 #ifdef __KERNEL__
 
-#define arch_has_single_step()	(1)
-
 #define user_mode(regs)	\
 	(((regs)->ARM_cpsr & 0xf) == 0)
 

commit 864232fa1a2f8dfe003438ef0851a56722740f3e
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Sep 3 10:42:55 2010 +0100

    ARM: 6357/1: hw-breakpoint: add new ptrace requests for hw-breakpoint interaction
    
    For debuggers to take advantage of the hw-breakpoint framework in the kernel,
    it is necessary to expose the API calls via a ptrace interface.
    
    This patch exposes the hardware breakpoints framework as a collection of
    virtual registers, accesible using PTRACE_SETHBPREGS and PTRACE_GETHBPREGS
    requests. The breakpoints are stored in the debug_info struct of the running
    thread.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: S. Karthikeyan <informkarthik@gmail.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 7ce15eb15f72..783d50f32618 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -29,6 +29,8 @@
 #define PTRACE_SETCRUNCHREGS	26
 #define PTRACE_GETVFPREGS	27
 #define PTRACE_SETVFPREGS	28
+#define PTRACE_GETHBPREGS	29
+#define PTRACE_SETHBPREGS	30
 
 /*
  * PSR bits

commit 41e2e8fd34fff909a0e40129f6ac4233ecfa67a9
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Aug 13 23:33:46 2010 +0100

    ARM: Tighten check for allowable CPSR values
    
    Reviewed-by: Arve Hjønnevåg <arve@android.com>
    Acked-by: Dima Zavin <dima@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index c974be8913a7..7ce15eb15f72 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -158,15 +158,24 @@ struct pt_regs {
  */
 static inline int valid_user_regs(struct pt_regs *regs)
 {
-	if (user_mode(regs) && (regs->ARM_cpsr & PSR_I_BIT) == 0) {
-		regs->ARM_cpsr &= ~(PSR_F_BIT | PSR_A_BIT);
-		return 1;
+	unsigned long mode = regs->ARM_cpsr & MODE_MASK;
+
+	/*
+	 * Always clear the F (FIQ) and A (delayed abort) bits
+	 */
+	regs->ARM_cpsr &= ~(PSR_F_BIT | PSR_A_BIT);
+
+	if ((regs->ARM_cpsr & PSR_I_BIT) == 0) {
+		if (mode == USR_MODE)
+			return 1;
+		if (elf_hwcap & HWCAP_26BIT && mode == USR26_MODE)
+			return 1;
 	}
 
 	/*
 	 * Force CPSR to something logical...
 	 */
-	regs->ARM_cpsr &= PSR_f | PSR_s | (PSR_x & ~PSR_A_BIT) | PSR_T_BIT | MODE32_BIT;
+	regs->ARM_cpsr &= PSR_f | PSR_s | PSR_x | PSR_T_BIT | MODE32_BIT;
 	if (!(elf_hwcap & HWCAP_26BIT))
 		regs->ARM_cpsr |= USR_MODE;
 

commit e513f8bf240d34bd6e732ba2f74df9ab84686ce6
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jun 25 12:24:53 2010 +0100

    ARM: 6199/1: Add kprobe-based event tracer
    
    This patch enables the HAVE_REGS_AND_STACK_ACCESS_API option
    for ARM which is required by the kprobe events tracer. Code based
    on the PowerPC port.
    
    Cc: Jean Pihet <jpihet@mvista.com>
    Tested-by: Jamie Iles <jamie.iles@picochip.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 9dcb11e59026..c974be8913a7 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -184,6 +184,42 @@ extern unsigned long profile_pc(struct pt_regs *regs);
 #define predicate(x)		((x) & 0xf0000000)
 #define PREDICATE_ALWAYS	0xe0000000
 
+/*
+ * kprobe-based event tracer support
+ */
+#include <linux/stddef.h>
+#include <linux/types.h>
+#define MAX_REG_OFFSET (offsetof(struct pt_regs, ARM_ORIG_r0))
+
+extern int regs_query_register_offset(const char *name);
+extern const char *regs_query_register_name(unsigned int offset);
+extern bool regs_within_kernel_stack(struct pt_regs *regs, unsigned long addr);
+extern unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
+					       unsigned int n);
+
+/**
+ * regs_get_register() - get register value from its offset
+ * @regs:	   pt_regs from which register value is gotten
+ * @offset:    offset number of the register.
+ *
+ * regs_get_register returns the value of a register whose offset from @regs.
+ * The @offset is the offset of the register in struct pt_regs.
+ * If @offset is bigger than MAX_REG_OFFSET, this returns 0.
+ */
+static inline unsigned long regs_get_register(struct pt_regs *regs,
+					      unsigned int offset)
+{
+	if (unlikely(offset > MAX_REG_OFFSET))
+		return 0;
+	return *(unsigned long *)((unsigned long)regs + offset);
+}
+
+/* Valid only for Kernel mode traps. */
+static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
+{
+	return regs->ARM_sp;
+}
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASSEMBLY__ */

commit 440e6ca79aebdc274ce4c625a6f42c8bf3c7bc91
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 10 15:22:50 2010 -0800

    arm: use generic ptrace_resume code
    
    Use the generic ptrace_resume code for PTRACE_SYSCALL, PTRACE_CONT,
    PTRACE_KILL and PTRACE_SINGLESTEP.  This implies defining
    arch_has_single_step in <asm/ptrace.h> and implementing the
    user_enable_single_step and user_disable_single_step functions, which also
    causes the breakpoint information to be cleared on fork, which could be
    considered a bug fix.
    
    Also the TIF_SYSCALL_TRACE thread flag is now cleared on PTRACE_KILL which
    it previously wasn't and the single stepping disable only happens if the
    tracee process isn't a zombie yet, which is consistent with all
    architectures using the modern ptrace code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index eec6e897ceb2..9dcb11e59026 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -128,6 +128,8 @@ struct pt_regs {
 
 #ifdef __KERNEL__
 
+#define arch_has_single_step()	(1)
+
 #define user_mode(regs)	\
 	(((regs)->ARM_cpsr & 0xf) == 0)
 

commit 092a4e957a835cbf6b2ec82a6a4d6ff06c0a362e
Author: Jamie Iles <jamie.iles@picochip.com>
Date:   Wed Jan 6 10:50:08 2010 +0100

    ARM: 5866/1: arm ptrace: use unsigned types for kernel pt_regs
    
    Make registers unsigned for kernel space. This is important for
    example in the perf events where the PC is stored into a u64. We
    don't want it sign extended so make the regs unsigned to prevent
    casts throughout the kernel.
    
    Signed-off-by: Jamie Iles <jamie.iles@picochip.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index bbecccda76d0..eec6e897ceb2 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -97,9 +97,15 @@
  * stack during a system call.  Note that sizeof(struct pt_regs)
  * has to be a multiple of 8.
  */
+#ifndef __KERNEL__
 struct pt_regs {
 	long uregs[18];
 };
+#else /* __KERNEL__ */
+struct pt_regs {
+	unsigned long uregs[18];
+};
+#endif /* __KERNEL__ */
 
 #define ARM_cpsr	uregs[16]
 #define ARM_pc		uregs[15]

commit 68b7f7153fa58df710924fbb79722717d2d16094
Author: Paul Brook <paul@codesourcery.com>
Date:   Fri Jul 24 12:34:58 2009 +0100

    nommu: ptrace support
    
    The patch below adds ARM ptrace functions to get the process load address.
    This is required for useful userspace debugging on mmuless systems.  These
    values are obtained by reading magic offsets with PTRACE_PEEKUSR, as on other
    nommu targets. I picked arbitrary large values for the offsets.
    
    Signed-off-by: Paul Brook <paul@codesourcery.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 67b833c9b6b9..bbecccda76d0 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -82,6 +82,14 @@
 #define PSR_ENDSTATE	0
 #endif
 
+/* 
+ * These are 'magic' values for PTRACE_PEEKUSR that return info about where a
+ * process is located in memory.
+ */
+#define PT_TEXT_ADDR		0x10000
+#define PT_DATA_ADDR		0x10004
+#define PT_TEXT_END_ADDR	0x10008
+
 #ifndef __ASSEMBLY__
 
 /*

commit 26584853a44c58f3d6ac7360d697a2ddcd1a3efa
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Sat May 30 14:00:18 2009 +0100

    Add core support for ARMv6/v7 big-endian
    
    Starting with ARMv6, the CPUs support the BE-8 variant of big-endian
    (byte-invariant). This patch adds the core support:
    
    - setting of the BE-8 mode via the CPSR.E register for both kernel and
      user threads
    - big-endian page table walking
    - REV used to rotate instructions read from memory during fault
      processing as they are still little-endian format
    - Kconfig and Makefile support for BE-8. The --be8 option must be passed
      to the final linking stage to convert the instructions to
      little-endian
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 4a4290f7b4a2..67b833c9b6b9 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -50,6 +50,7 @@
 #define PSR_F_BIT	0x00000040
 #define PSR_I_BIT	0x00000080
 #define PSR_A_BIT	0x00000100
+#define PSR_E_BIT	0x00000200
 #define PSR_J_BIT	0x01000000
 #define PSR_Q_BIT	0x08000000
 #define PSR_V_BIT	0x10000000
@@ -72,6 +73,15 @@
 #define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
 #define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */
 
+/*
+ * Default endianness state
+ */
+#ifdef CONFIG_CPU_ENDIAN_BE8
+#define PSR_ENDSTATE	PSR_E_BIT
+#else
+#define PSR_ENDSTATE	0
+#endif
+
 #ifndef __ASSEMBLY__
 
 /*

commit d71e1352e240dea32d481ad8d662e8de4406ac7e
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Sat May 30 14:00:15 2009 +0100

    Clear the IT state when invoking a Thumb-2 signal handler
    
    If a process is interrupted during an If-Then block and a signal is
    invoked, the ITSTATE bits must be cleared otherwise the handler would
    not run correctly.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Joseph S. Myers <joseph@codesourcery.com>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 236a06b9b7ce..4a4290f7b4a2 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -65,6 +65,13 @@
 #define PSR_x		0x0000ff00	/* Extension		*/
 #define PSR_c		0x000000ff	/* Control		*/
 
+/*
+ * ARMv7 groups of APSR bits
+ */
+#define PSR_ISET_MASK	0x01000010	/* ISA state (J, T) mask */
+#define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
+#define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */
+
 #ifndef __ASSEMBLY__
 
 /*

commit 3d1228ead618b88e8606015cbabc49019981805d
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Feb 11 13:12:56 2009 +0100

    [ARM] 5387/1: Add ptrace VFP support on ARM
    
    This patch adds ptrace support for setting and getting the VFP registers
    using PTRACE_SETVFPREGS and PTRACE_GETVFPREGS. The user_vfp structure
    defined in asm/user.h contains 32 double registers (to cover VFPv3 and
    Neon hardware) and the FPSCR register.
    
    Cc: Paul Brook <paul@codesourcery.com>
    Cc: Daniel Jacobowitz <dan@codesourcery.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 73192618f1c2..236a06b9b7ce 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -27,6 +27,8 @@
 /* PTRACE_SYSCALL is 24 */
 #define PTRACE_GETCRUNCHREGS	25
 #define PTRACE_SETCRUNCHREGS	26
+#define PTRACE_GETVFPREGS	27
+#define PTRACE_SETVFPREGS	28
 
 /*
  * PSR bits

commit 1de765c1e940e23d83ec57035769e8af003f8796
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 10:14:24 2008 +0100

    [ARM] remove pc_pointer()
    
    pc_pointer() was a function to mask the PC for 26-bit ARMs, which
    we no longer support.  Remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index b415c0e85458..73192618f1c2 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -54,7 +54,6 @@
 #define PSR_C_BIT	0x20000000
 #define PSR_Z_BIT	0x40000000
 #define PSR_N_BIT	0x80000000
-#define PCMASK		0
 
 /*
  * Groups of PSR bits
@@ -139,11 +138,7 @@ static inline int valid_user_regs(struct pt_regs *regs)
 	return 0;
 }
 
-#define pc_pointer(v) \
-	((v) & ~PCMASK)
-
-#define instruction_pointer(regs) \
-	(pc_pointer((regs)->ARM_pc))
+#define instruction_pointer(regs)	(regs)->ARM_pc
 
 #ifdef CONFIG_SMP
 extern unsigned long profile_pc(struct pt_regs *regs);

commit 4baa9922430662431231ac637adedddbb0cfb2d7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Aug 2 10:55:55 2008 +0100

    [ARM] move include/asm-arm to arch/arm/include/asm
    
    Move platform independent header files to arch/arm/include/asm, leaving
    those in asm/arch* and asm/plat* alone.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
new file mode 100644
index 000000000000..b415c0e85458
--- /dev/null
+++ b/arch/arm/include/asm/ptrace.h
@@ -0,0 +1,162 @@
+/*
+ *  arch/arm/include/asm/ptrace.h
+ *
+ *  Copyright (C) 1996-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_PTRACE_H
+#define __ASM_ARM_PTRACE_H
+
+#include <asm/hwcap.h>
+
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+#define PTRACE_GETFPREGS	14
+#define PTRACE_SETFPREGS	15
+/* PTRACE_ATTACH is 16 */
+/* PTRACE_DETACH is 17 */
+#define PTRACE_GETWMMXREGS	18
+#define PTRACE_SETWMMXREGS	19
+/* 20 is unused */
+#define PTRACE_OLDSETOPTIONS	21
+#define PTRACE_GET_THREAD_AREA	22
+#define PTRACE_SET_SYSCALL	23
+/* PTRACE_SYSCALL is 24 */
+#define PTRACE_GETCRUNCHREGS	25
+#define PTRACE_SETCRUNCHREGS	26
+
+/*
+ * PSR bits
+ */
+#define USR26_MODE	0x00000000
+#define FIQ26_MODE	0x00000001
+#define IRQ26_MODE	0x00000002
+#define SVC26_MODE	0x00000003
+#define USR_MODE	0x00000010
+#define FIQ_MODE	0x00000011
+#define IRQ_MODE	0x00000012
+#define SVC_MODE	0x00000013
+#define ABT_MODE	0x00000017
+#define UND_MODE	0x0000001b
+#define SYSTEM_MODE	0x0000001f
+#define MODE32_BIT	0x00000010
+#define MODE_MASK	0x0000001f
+#define PSR_T_BIT	0x00000020
+#define PSR_F_BIT	0x00000040
+#define PSR_I_BIT	0x00000080
+#define PSR_A_BIT	0x00000100
+#define PSR_J_BIT	0x01000000
+#define PSR_Q_BIT	0x08000000
+#define PSR_V_BIT	0x10000000
+#define PSR_C_BIT	0x20000000
+#define PSR_Z_BIT	0x40000000
+#define PSR_N_BIT	0x80000000
+#define PCMASK		0
+
+/*
+ * Groups of PSR bits
+ */
+#define PSR_f		0xff000000	/* Flags		*/
+#define PSR_s		0x00ff0000	/* Status		*/
+#define PSR_x		0x0000ff00	/* Extension		*/
+#define PSR_c		0x000000ff	/* Control		*/
+
+#ifndef __ASSEMBLY__
+
+/*
+ * This struct defines the way the registers are stored on the
+ * stack during a system call.  Note that sizeof(struct pt_regs)
+ * has to be a multiple of 8.
+ */
+struct pt_regs {
+	long uregs[18];
+};
+
+#define ARM_cpsr	uregs[16]
+#define ARM_pc		uregs[15]
+#define ARM_lr		uregs[14]
+#define ARM_sp		uregs[13]
+#define ARM_ip		uregs[12]
+#define ARM_fp		uregs[11]
+#define ARM_r10		uregs[10]
+#define ARM_r9		uregs[9]
+#define ARM_r8		uregs[8]
+#define ARM_r7		uregs[7]
+#define ARM_r6		uregs[6]
+#define ARM_r5		uregs[5]
+#define ARM_r4		uregs[4]
+#define ARM_r3		uregs[3]
+#define ARM_r2		uregs[2]
+#define ARM_r1		uregs[1]
+#define ARM_r0		uregs[0]
+#define ARM_ORIG_r0	uregs[17]
+
+#ifdef __KERNEL__
+
+#define user_mode(regs)	\
+	(((regs)->ARM_cpsr & 0xf) == 0)
+
+#ifdef CONFIG_ARM_THUMB
+#define thumb_mode(regs) \
+	(((regs)->ARM_cpsr & PSR_T_BIT))
+#else
+#define thumb_mode(regs) (0)
+#endif
+
+#define isa_mode(regs) \
+	((((regs)->ARM_cpsr & PSR_J_BIT) >> 23) | \
+	 (((regs)->ARM_cpsr & PSR_T_BIT) >> 5))
+
+#define processor_mode(regs) \
+	((regs)->ARM_cpsr & MODE_MASK)
+
+#define interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & PSR_I_BIT))
+
+#define fast_interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & PSR_F_BIT))
+
+/* Are the current registers suitable for user mode?
+ * (used to maintain security in signal handlers)
+ */
+static inline int valid_user_regs(struct pt_regs *regs)
+{
+	if (user_mode(regs) && (regs->ARM_cpsr & PSR_I_BIT) == 0) {
+		regs->ARM_cpsr &= ~(PSR_F_BIT | PSR_A_BIT);
+		return 1;
+	}
+
+	/*
+	 * Force CPSR to something logical...
+	 */
+	regs->ARM_cpsr &= PSR_f | PSR_s | (PSR_x & ~PSR_A_BIT) | PSR_T_BIT | MODE32_BIT;
+	if (!(elf_hwcap & HWCAP_26BIT))
+		regs->ARM_cpsr |= USR_MODE;
+
+	return 0;
+}
+
+#define pc_pointer(v) \
+	((v) & ~PCMASK)
+
+#define instruction_pointer(regs) \
+	(pc_pointer((regs)->ARM_pc))
+
+#ifdef CONFIG_SMP
+extern unsigned long profile_pc(struct pt_regs *regs);
+#else
+#define profile_pc(regs) instruction_pointer(regs)
+#endif
+
+#define predicate(x)		((x) & 0xf0000000)
+#define PREDICATE_ALWAYS	0xe0000000
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASSEMBLY__ */
+
+#endif
+
