commit 78c8516141014cf6322ac899c3832f66612504bb
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Fri Mar 20 14:53:49 2020 +0000

    arm: vdso: Enable arm to use common headers
    
    Enable arm to use only the common headers in the implementation
    of the vDSO library.
    
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@armlinux.org.uk>
    Link: https://lkml.kernel.org/r/20200320145351.32292-25-vincenzo.frascino@arm.com

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index d2453e2d3f1f..a54230e65647 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -50,25 +50,7 @@
 
 #ifdef CONFIG_CPU_CP15
 
-#define __ACCESS_CP15(CRn, Op1, CRm, Op2)	\
-	"mrc", "mcr", __stringify(p15, Op1, %0, CRn, CRm, Op2), u32
-#define __ACCESS_CP15_64(Op1, CRm)		\
-	"mrrc", "mcrr", __stringify(p15, Op1, %Q0, %R0, CRm), u64
-
-#define __read_sysreg(r, w, c, t) ({				\
-	t __val;						\
-	asm volatile(r " " c : "=r" (__val));			\
-	__val;							\
-})
-#define read_sysreg(...)		__read_sysreg(__VA_ARGS__)
-
-#define __write_sysreg(v, r, w, c, t)	asm volatile(w " " c : : "r" ((t)(v)))
-#define write_sysreg(v, ...)		__write_sysreg(v, __VA_ARGS__)
-
-#define BPIALL				__ACCESS_CP15(c7, 0, c5, 6)
-#define ICIALLU				__ACCESS_CP15(c7, 0, c5, 0)
-
-#define CNTVCT				__ACCESS_CP15_64(1, c14)
+#include <asm/vdso/cp15.h>
 
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 

commit 1f5b62f09f6b314c8d70b9de5182dae4de1f94da
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Apr 8 16:49:01 2019 +0100

    ARM: vdso: Remove dependency with the arch_timer driver internals
    
    The VDSO code uses the kernel helper that was originally designed
    to abstract the access between 32 and 64bit systems. It worked so
    far because this function is declared as 'inline'.
    
    As we're about to revamp that part of the code, the VDSO would
    break. Let's fix it by doing what should have been done from
    the start, a proper system register access.
    
    Reviewed-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 07e27f212dc7..d2453e2d3f1f 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -68,6 +68,8 @@
 #define BPIALL				__ACCESS_CP15(c7, 0, c5, 6)
 #define ICIALLU				__ACCESS_CP15(c7, 0, c5, 0)
 
+#define CNTVCT				__ACCESS_CP15_64(1, c14)
+
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
 static inline unsigned long get_cr(void)

commit f5fe12b1eaee220ce62ff9afb8b90929c396595f
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon May 14 14:20:21 2018 +0100

    ARM: spectre-v2: harden user aborts in kernel space
    
    In order to prevent aliasing attacks on the branch predictor,
    invalidate the BTB or instruction cache on CPUs that are known to be
    affected when taking an abort on a address that is outside of a user
    task limit:
    
    Cortex A8, A9, A12, A17, A73, A75: flush BTB.
    Cortex A15, Brahma B15: invalidate icache.
    
    If the IBE bit is not set, then there is little point to enabling the
    workaround.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Boot-tested-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 4c9fa72b59f5..07e27f212dc7 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -65,6 +65,9 @@
 #define __write_sysreg(v, r, w, c, t)	asm volatile(w " " c : : "r" ((t)(v)))
 #define write_sysreg(v, ...)		__write_sysreg(v, __VA_ARGS__)
 
+#define BPIALL				__ACCESS_CP15(c7, 0, c5, 6)
+#define ICIALLU				__ACCESS_CP15(c7, 0, c5, 0)
+
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
 static inline unsigned long get_cr(void)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index dbdbce1b3a72..4c9fa72b59f5 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ASM_ARM_CP15_H
 #define __ASM_ARM_CP15_H
 

commit 4f2546384150e78cad8045e59a9587fabcd9f9fe
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Sep 12 15:49:22 2016 +0100

    ARM: Move system register accessors to asm/cp15.h
    
    Headers linux/irqchip/arm-gic.v3.h and arch/arm/include/asm/kvm_hyp.h
    are included in virt/kvm/arm/hyp/vgic-v3-sr.c and both define macros
    called __ACCESS_CP15 and __ACCESS_CP15_64 which obviously creates a
    conflict. These macros were introduced independently for GIC and KVM
    and, in fact, do the same thing.
    
    As an option we could add prefixes to KVM and GIC version of macros so
    they won't clash, but it'd introduce code duplication.  Alternatively,
    we could keep macro in, say, GIC header and include it in KVM one (or
    vice versa), but such dependency would not look nicer.
    
    So we follow arm64 way (it handles this via sysreg.h) and move only
    single set of macros to asm/cp15.h
    
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index c3f11524f10c..dbdbce1b3a72 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -49,6 +49,21 @@
 
 #ifdef CONFIG_CPU_CP15
 
+#define __ACCESS_CP15(CRn, Op1, CRm, Op2)	\
+	"mrc", "mcr", __stringify(p15, Op1, %0, CRn, CRm, Op2), u32
+#define __ACCESS_CP15_64(Op1, CRm)		\
+	"mrrc", "mcrr", __stringify(p15, Op1, %Q0, %R0, CRm), u64
+
+#define __read_sysreg(r, w, c, t) ({				\
+	t __val;						\
+	asm volatile(r " " c : "=r" (__val));			\
+	__val;							\
+})
+#define read_sysreg(...)		__read_sysreg(__VA_ARGS__)
+
+#define __write_sysreg(v, r, w, c, t)	asm volatile(w " " c : : "r" ((t)(v)))
+#define write_sysreg(v, ...)		__write_sysreg(v, __VA_ARGS__)
+
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
 static inline unsigned long get_cr(void)

commit 0aeb3408ca9773283b0ae63771c4b17f39e204df
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 13 19:43:26 2014 +0100

    ARM: remove global cr_no_alignment
    
    cr_no_alignment is really only used by the alignment code.  Since we no
    longer change the setting of cr_alignment after boot, we can localise
    this to alignment.c
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index ebae45d7f017..c3f11524f10c 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -49,7 +49,6 @@
 
 #ifdef CONFIG_CPU_CP15
 
-extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
 static inline unsigned long get_cr(void)
@@ -102,11 +101,10 @@ static inline void set_copro_access(unsigned int val)
 #else /* ifdef CONFIG_CPU_CP15 */
 
 /*
- * cr_alignment and cr_no_alignment are tightly coupled to cp15 (at least in the
- * minds of the developers). Yielding 0 for machines without a cp15 (and making
- * it read-only) is fine for most cases and saves quite some #ifdeffery.
+ * cr_alignment is tightly coupled to cp15 (at least in the minds of the
+ * developers). Yielding 0 for machines without a cp15 (and making it
+ * read-only) is fine for most cases and saves quite some #ifdeffery.
  */
-#define cr_no_alignment	UL(0)
 #define cr_alignment	UL(0)
 
 static inline unsigned long get_cr(void)

commit c6e13600d3b2137ff583767d7f8688a41e34ac49
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 13 19:01:14 2014 +0100

    ARM: remove unused adjust_cr() function
    
    adjust_cr() is not used anymore, so let's get rid of it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 63427266015d..ebae45d7f017 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -80,10 +80,6 @@ static inline void set_auxcr(unsigned int val)
 	isb();
 }
 
-#ifndef CONFIG_SMP
-extern void adjust_cr(unsigned long mask, unsigned long set);
-#endif
-
 #define CPACC_FULL(n)		(3 << (n * 2))
 #define CPACC_SVC(n)		(1 << (n * 2))
 #define CPACC_DISABLE(n)	(0 << (n * 2))

commit 4585eaff634b1bbb09686895221b3645f53f7a60
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 13 18:47:34 2014 +0100

    ARM: use get_cr() rather than cr_alignment
    
    Rather than reading the cr_alignment variable, use get_cr() to read
    directly from the hardware instead.  We have two places where this
    occurs, neither of them are performance critical.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index d5bf322a0630..63427266015d 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -42,7 +42,7 @@
 #ifndef __ASSEMBLY__
 
 #if __LINUX_ARM_ARCH__ >= 4
-#define vectors_high()	(cr_alignment & CR_V)
+#define vectors_high()	(get_cr() & CR_V)
 #else
 #define vectors_high()	(0)
 #endif
@@ -113,6 +113,11 @@ static inline void set_copro_access(unsigned int val)
 #define cr_no_alignment	UL(0)
 #define cr_alignment	UL(0)
 
+static inline unsigned long get_cr(void)
+{
+	return 0;
+}
+
 #endif /* ifdef CONFIG_CPU_CP15 / else */
 
 #endif /* ifndef __ASSEMBLY__ */

commit 7668fd577bae5bba50e97d257a4cf0c44ca002d3
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 13 20:09:55 2014 +0100

    ARM: make get_cr()/set_cr() use unsigned long values
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 6493802f880a..d5bf322a0630 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -52,14 +52,14 @@
 extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
-static inline unsigned int get_cr(void)
+static inline unsigned long get_cr(void)
 {
-	unsigned int val;
+	unsigned long val;
 	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
 	return val;
 }
 
-static inline void set_cr(unsigned int val)
+static inline void set_cr(unsigned long val)
 {
 	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
 	  : : "r" (val) : "cc");

commit fb2af0020a51709ad87ea8055c325d3fbde04158
Merge: 790eac5640ab 3c0c01ab742d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 09:46:29 2013 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "This contains the usual updates from other people (listed below) and
      the usual random muddle of miscellaneous ARM updates which cover some
      low priority bug fixes and performance improvements.
    
      I've started to put the pull request wording into the merge commits,
      which are:
    
       - NoMMU stuff:
    
         This includes the following series sent earlier to the list:
          - nommu-fixes
          - R7 Support
          - MPU support
    
         I've left out the ARCH_MULTIPLATFORM/!MMU stuff that Arnd and I
         were discussing today until we've reached a conclusion/that's had
         some more review.
    
         This is rebased (and re-tested) on your devel-stable branch because
         otherwise there were going to be conflicts with Uwe's V7M work now
         that you've merged that.  I've included the fix for limiting MPU to
         CPU_V7.
    
       - Huge page support
    
         These changes bring both HugeTLB support and Transparent HugePage
         (THP) support to ARM.  Only long descriptors (LPAE) are supported
         in this series.
    
         The code has been tested on an Arndale board (Exynos 5250).
    
       - LPAE updates
    
         Please pull these miscellaneous LPAE fixes I've been collecting for
         a while now for 3.11.  They've been tested and reviewed by quite a
         few people, and most of the patches are pretty trivial.  -- Will Deacon.
    
       - arch_timer cleanups
    
         Please pull these arch_timer cleanups I've been holding onto for a
         while.  They're the same as my last posting, but have been rebased
         to v3.10-rc3.
    
       - mpidr linearisation (multiprocessor id register - identifies which
         CPU number we are in the system)
    
         This patch series that implements MPIDR linearization through a
         simple hashing algorithm and updates current cpu_{suspend}/{resume}
         code to use the newly created hash structures to retrieve context
         pointers.  It represents a stepping stone for the implementation of
         power management code on forthcoming multi-cluster ARM systems.
    
         It has been tested on TC2 (dual cluster A15xA7 system), iMX6q,
         OMAP4 and Tegra, with processors hitting low-power states requiring
         warm-boot resume through the cpu_resume code path"
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (77 commits)
      ARM: 7775/1: mm: Remove do_sect_fault from LPAE code
      ARM: 7777/1: Avoid extra calls to the C compiler
      ARM: 7774/1: Fix dtb dependency to use order-only prerequisites
      ARM: 7770/1: remove residual ARMv2 support from decompressor
      ARM: 7769/1: Cortex-A15: fix erratum 798181 implementation
      ARM: 7768/1: prevent risks of out-of-bound access in ASID allocator
      ARM: 7767/1: let the ASID allocator handle suspended animation
      ARM: 7766/1: versatile: don't mark pen as __INIT
      ARM: 7765/1: perf: Record the user-mode PC in the call chain.
      ARM: 7735/2: Preserve the user r/w register TPIDRURW on context switch and fork
      ARM: kernel: implement stack pointer save array through MPIDR hashing
      ARM: kernel: build MPIDR hash function data structure
      ARM: mpu: Ensure that MPU depends on CPU_V7
      ARM: mpu: protect the vectors page with an MPU region
      ARM: mpu: Allow enabling of the MPU via kconfig
      ARM: 7758/1: introduce config HAS_BANDGAP
      ARM: 7757/1: mm: don't flush icache in switch_mm with hardware broadcasting
      ARM: 7751/1: zImage: don't overwrite ourself with a page table
      ARM: 7749/1: spinlock: retry trylock operation if strex fails on free lock
      ARM: 7748/1: oabi: handle faults when loading swi instruction from userspace
      ...

commit aca7e5920c8e80a2a49c1e37664675d78b23398b
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Thu Feb 21 15:21:34 2013 +0000

    ARM: mpu: add PMSA related registers and bitfields to existing headers
    
    This patch adds the following definitions relevant to the PMSA:
    
    Add SCTLR bit 17, (CR_BR - Background Region bit) to the list of CR_*
    bitfields. This bit determines whether to use the architecturally defined
    memory map
    
    Add the MPUIR to the available registers when using read_cpuid macro. The
    MPUIR is the MPU type register.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    CC:"Uwe Kleine-König" <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 1f3262e99d81..a524a23d8627 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -23,6 +23,11 @@
 #define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
 #define CR_L4	(1 << 15)	/* LDR pc can set T bit			*/
 #define CR_DT	(1 << 16)
+#ifdef CONFIG_MMU
+#define CR_HA	(1 << 17)	/* Hardware management of Access Flag   */
+#else
+#define CR_BR	(1 << 17)	/* MPU Background region enable (PMSA)  */
+#endif
 #define CR_IT	(1 << 18)
 #define CR_ST	(1 << 19)
 #define CR_FI	(1 << 21)	/* Fast interrupt (lower latency mode)	*/

commit bbc8d77db655be61a21d7623428c46c578a866d3
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Jan 16 17:57:33 2013 -0600

    ARM: introduce common set_auxcr/get_auxcr functions
    
    Move the private set_auxcr/get_auxcr functions from
    drivers/cpuidle/cpuidle-calxeda.c so they can be used across platforms.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 1f3262e99d81..cedd3721318b 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -61,6 +61,20 @@ static inline void set_cr(unsigned int val)
 	isb();
 }
 
+static inline unsigned int get_auxcr(void)
+{
+	unsigned int val;
+	asm("mrc p15, 0, %0, c1, c0, 1	@ get AUXCR" : "=r" (val));
+	return val;
+}
+
+static inline void set_auxcr(unsigned int val)
+{
+	asm volatile("mcr p15, 0, %0, c1, c0, 1	@ set AUXCR"
+	  : : "r" (val));
+	isb();
+}
+
 #ifndef CONFIG_SMP
 extern void adjust_cr(unsigned long mask, unsigned long set);
 #endif

commit b849a60e0903b1c5430c3859864554662e127a8d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jan 16 10:34:31 2012 +0100

    ARM: make cr_alignment read-only #ifndef CONFIG_CPU_CP15
    
    This makes cr_alignment a constant 0 to break code that tries to modify
    the value as it's likely that it's built on wrong assumption when
    CONFIG_CPU_CP15 isn't defined. For code that is only reading the value 0
    is more or less a fine value to report.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Message-Id: 1358413196-5609-2-git-send-email-u.kleine-koenig@pengutronix.de (v8)

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 5ef4d8015a60..1f3262e99d81 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -42,6 +42,8 @@
 #define vectors_high()	(0)
 #endif
 
+#ifdef CONFIG_CPU_CP15
+
 extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
 
@@ -82,6 +84,18 @@ static inline void set_copro_access(unsigned int val)
 	isb();
 }
 
-#endif
+#else /* ifdef CONFIG_CPU_CP15 */
+
+/*
+ * cr_alignment and cr_no_alignment are tightly coupled to cp15 (at least in the
+ * minds of the developers). Yielding 0 for machines without a cp15 (and making
+ * it read-only) is fine for most cases and saves quite some #ifdeffery.
+ */
+#define cr_no_alignment	UL(0)
+#define cr_alignment	UL(0)
+
+#endif /* ifdef CONFIG_CPU_CP15 / else */
+
+#endif /* ifndef __ASSEMBLY__ */
 
 #endif

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
index 3dabd8dd4049..5ef4d8015a60 100644
--- a/arch/arm/include/asm/cp15.h
+++ b/arch/arm/include/asm/cp15.h
@@ -1,7 +1,7 @@
 #ifndef __ASM_ARM_CP15_H
 #define __ASM_ARM_CP15_H
 
-#include <asm/system.h>
+#include <asm/barrier.h>
 
 /*
  * CR1 bits (CP#15 CR1)

commit 15d07dc9c59eae51219c40253bdf920f62bb10f2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 28 18:30:01 2012 +0100

    ARM: move CP15 definitions to separate header file
    
    Avoid namespace conflicts with drivers over the CP15 definitions by
    moving CP15 related prototypes and definitions to a private header
    file.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com> [Tegra]
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: H Hartley Sweeten <hsweeten@visionengravers.com> [EP93xx]
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/arch/arm/include/asm/cp15.h b/arch/arm/include/asm/cp15.h
new file mode 100644
index 000000000000..3dabd8dd4049
--- /dev/null
+++ b/arch/arm/include/asm/cp15.h
@@ -0,0 +1,87 @@
+#ifndef __ASM_ARM_CP15_H
+#define __ASM_ARM_CP15_H
+
+#include <asm/system.h>
+
+/*
+ * CR1 bits (CP#15 CR1)
+ */
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CR_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CR_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+#define CR_L4	(1 << 15)	/* LDR pc can set T bit			*/
+#define CR_DT	(1 << 16)
+#define CR_IT	(1 << 18)
+#define CR_ST	(1 << 19)
+#define CR_FI	(1 << 21)	/* Fast interrupt (lower latency mode)	*/
+#define CR_U	(1 << 22)	/* Unaligned access operation		*/
+#define CR_XP	(1 << 23)	/* Extended page tables			*/
+#define CR_VE	(1 << 24)	/* Vectored interrupts			*/
+#define CR_EE	(1 << 25)	/* Exception (Big) Endian		*/
+#define CR_TRE	(1 << 28)	/* TEX remap enable			*/
+#define CR_AFE	(1 << 29)	/* Access flag enable			*/
+#define CR_TE	(1 << 30)	/* Thumb exception enable		*/
+
+#ifndef __ASSEMBLY__
+
+#if __LINUX_ARM_ARCH__ >= 4
+#define vectors_high()	(cr_alignment & CR_V)
+#else
+#define vectors_high()	(0)
+#endif
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+static inline unsigned int get_cr(void)
+{
+	unsigned int val;
+	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
+	return val;
+}
+
+static inline void set_cr(unsigned int val)
+{
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
+	  : : "r" (val) : "cc");
+	isb();
+}
+
+#ifndef CONFIG_SMP
+extern void adjust_cr(unsigned long mask, unsigned long set);
+#endif
+
+#define CPACC_FULL(n)		(3 << (n * 2))
+#define CPACC_SVC(n)		(1 << (n * 2))
+#define CPACC_DISABLE(n)	(0 << (n * 2))
+
+static inline unsigned int get_copro_access(void)
+{
+	unsigned int val;
+	asm("mrc p15, 0, %0, c1, c0, 2 @ get copro access"
+	  : "=r" (val) : : "cc");
+	return val;
+}
+
+static inline void set_copro_access(unsigned int val)
+{
+	asm volatile("mcr p15, 0, %0, c1, c0, 2 @ set copro access"
+	  : : "r" (val) : "cc");
+	isb();
+}
+
+#endif
+
+#endif
