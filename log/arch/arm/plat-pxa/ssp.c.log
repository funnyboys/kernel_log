commit 4f3d957718e7f0ac2b033dbf48c7cddecd0a8dd3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Oct 18 13:54:25 2019 +0300

    spi: pxa2xx: No need to keep pointer to platform device
    
    There is no need to keep a pointer to the platform device. Currently there are
    no users of it directly, and if there will be in the future we may restore it
    from pointer to the struct device.
    
    Convert all users at the same time.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20191018105429.82782-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 9a6e4923bd69..563440315acd 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -89,7 +89,7 @@ void pxa_ssp_free(struct ssp_device *ssp)
 		ssp->use_count--;
 		ssp->label = NULL;
 	} else
-		dev_err(&ssp->pdev->dev, "device already free\n");
+		dev_err(ssp->dev, "device already free\n");
 	mutex_unlock(&ssp_lock);
 }
 EXPORT_SYMBOL(pxa_ssp_free);
@@ -118,7 +118,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	if (ssp == NULL)
 		return -ENOMEM;
 
-	ssp->pdev = pdev;
+	ssp->dev = dev;
 
 	ssp->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(ssp->clk))

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index bf25f780c1c9..9a6e4923bd69 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-pxa/ssp.c
  *
@@ -6,10 +7,6 @@
  *  Copyright (C) 2003 Russell King.
  *  Copyright (C) 2003 Wolfson Microelectronics PLC
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  PXA2xx SSP driver.  This provides the generic core for simple
  *  IO-based SSP applications and allows easy port setup for DMA access.
  *

commit 9ee8578d953023cc57e7e736ae48502c707c0210
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Jan 29 16:03:24 2019 +0800

    ARM: pxa: ssp: Fix "WARNING: invalid free of devm_ allocated data"
    
    Since commit 1c459de1e645 ("ARM: pxa: ssp: use devm_ functions")
    kfree, iounmap, clk_put etc are not needed anymore in remove path.
    
    Fixes: 1c459de1e645 ("ARM: pxa: ssp: use devm_ functions")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    [ commit message spelling fix ]
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index f51919974183..bf25f780c1c9 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -183,18 +183,12 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 static int pxa_ssp_remove(struct platform_device *pdev)
 {
-	struct resource *res;
 	struct ssp_device *ssp;
 
 	ssp = platform_get_drvdata(pdev);
 	if (ssp == NULL)
 		return -ENODEV;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, resource_size(res));
-
-	clk_put(ssp->clk);
-
 	mutex_lock(&ssp_lock);
 	list_del(&ssp->node);
 	mutex_unlock(&ssp_lock);

commit ba16adeb346387eb2d1ada69003588be96f098fa
Author: Peng Hao <peng.hao2@zte.com.cn>
Date:   Sat Dec 29 13:10:06 2018 +0800

    ARM: pxa: ssp: unneeded to free devm_ allocated data
    
    devm_ allocated data will be automatically freed. The free
    of devm_ allocated data is invalid.
    
    Fixes: 1c459de1e645 ("ARM: pxa: ssp: use devm_ functions")
    Signed-off-by: Peng Hao <peng.hao2@zte.com.cn>
    [title's prefix changed]
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index ed36dcab80f1..f51919974183 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -190,8 +190,6 @@ static int pxa_ssp_remove(struct platform_device *pdev)
 	if (ssp == NULL)
 		return -ENODEV;
 
-	iounmap(ssp->mmio_base);
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(res->start, resource_size(res));
 
@@ -201,7 +199,6 @@ static int pxa_ssp_remove(struct platform_device *pdev)
 	list_del(&ssp->node);
 	mutex_unlock(&ssp_lock);
 
-	kfree(ssp);
 	return 0;
 }
 

commit cd31b80736852d34bc1072f3e579a6fd73a244e7
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Sun Jun 17 19:02:17 2018 +0200

    ARM: pxa: change SSP DMA channels allocation
    
    Now the dma_slave_map is available for PXA architecture, switch the SSP
    device to it.
    
    This specifically means that :
    - for platform data based machines, the DMA requestor channels are
      extracted from the slave map, where pxa-ssp-dai.<N> is a 1-1 match to
      ssp.<N>, and the channels are either "rx" or "tx".
    
    - for device tree platforms, the dma node should be hooked into the
      pxa2xx-ac97 or pxa-ssp-dai node.
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Daniel Mack <daniel@zonque.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index ba13f793fbce..ed36dcab80f1 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -127,53 +127,6 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	if (IS_ERR(ssp->clk))
 		return PTR_ERR(ssp->clk);
 
-	if (dev->of_node) {
-		struct of_phandle_args dma_spec;
-		struct device_node *np = dev->of_node;
-		int ret;
-
-		/*
-		 * FIXME: we should allocate the DMA channel from this
-		 * context and pass the channel down to the ssp users.
-		 * For now, we lookup the rx and tx indices manually
-		 */
-
-		/* rx */
-		ret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",
-						 0, &dma_spec);
-
-		if (ret) {
-			dev_err(dev, "Can't parse dmas property\n");
-			return -ENODEV;
-		}
-		ssp->drcmr_rx = dma_spec.args[0];
-		of_node_put(dma_spec.np);
-
-		/* tx */
-		ret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",
-						 1, &dma_spec);
-		if (ret) {
-			dev_err(dev, "Can't parse dmas property\n");
-			return -ENODEV;
-		}
-		ssp->drcmr_tx = dma_spec.args[0];
-		of_node_put(dma_spec.np);
-	} else {
-		res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-		if (res == NULL) {
-			dev_err(dev, "no SSP RX DRCMR defined\n");
-			return -ENODEV;
-		}
-		ssp->drcmr_rx = res->start;
-
-		res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
-		if (res == NULL) {
-			dev_err(dev, "no SSP TX DRCMR defined\n");
-			return -ENODEV;
-		}
-		ssp->drcmr_tx = res->start;
-	}
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(dev, "no memory resource defined\n");

commit 8bf42cc8888f1475728104d386fc9306b8ef7e3e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 15 20:33:14 2014 +0200

    ARM: mmp: make plat-pxa build standalone
    
    The ssp.c driver in plat-pxa is the only remaining file including a
    mach/*.h header from mmp. It actually doesn't need mach/hardware.h at
    all, so we can remove the #include.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index daa1a65f2eb7..ba13f793fbce 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -34,7 +34,6 @@
 #include <linux/of_device.h>
 
 #include <asm/irq.h>
-#include <mach/hardware.h>
 
 static DEFINE_MUTEX(ssp_lock);
 static LIST_HEAD(ssp_list);

commit b692cb83b14d2f741f513221f5f78042c674c2a9
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Sep 7 10:23:01 2015 +0300

    ARM: pxa: ssp: Fix build error by removing originally incorrect DT binding
    
    Commit 03fbf488cece ("spi: pxa2xx: Differentiate Intel LPSS types") caused
    build error here because it removed the type LPSS_SSP and I didn't notice
    the type was used here too.
    
    I believe commit a6e56c28a178 ("ARM: pxa: ssp: add DT bindings") added it
    accidentally by copying all enum pxa_ssp_type types from
    include/linux/pxa2xx_ssp.h even LPSS_SSP was for Intel LPSS SPI devices.
    
    Fix the build error by removing this incorrect binding.
    
    Fixes: 03fbf488cece ("spi: pxa2xx: Differentiate Intel LPSS types")
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reported-by: Axel Lin <axel.lin@ingics.com>
    Cc: <stable@vger.kernel.org> # 4.2
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index ad9529cc4203..daa1a65f2eb7 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -107,7 +107,6 @@ static const struct of_device_id pxa_ssp_of_ids[] = {
 	{ .compatible = "mvrl,pxa168-ssp",	.data = (void *) PXA168_SSP },
 	{ .compatible = "mrvl,pxa910-ssp",	.data = (void *) PXA910_SSP },
 	{ .compatible = "mrvl,ce4100-ssp",	.data = (void *) CE4100_SSP },
-	{ .compatible = "mrvl,lpss-ssp",	.data = (void *) LPSS_SSP },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, pxa_ssp_of_ids);

commit 848ceb1b85e306a8634ea6ed6ec752598554f5b1
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:07 2014 +0200

    ARM: plat-pxa: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 1f5ee17a10e8..ad9529cc4203 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -268,7 +268,6 @@ static struct platform_driver pxa_ssp_driver = {
 	.probe		= pxa_ssp_probe,
 	.remove		= pxa_ssp_remove,
 	.driver		= {
-		.owner		= THIS_MODULE,
 		.name		= "pxa2xx-ssp",
 		.of_match_table	= of_match_ptr(pxa_ssp_of_ids),
 	},

commit 6f0243a1ec55e7140f69629b53e105d0715ef31b
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Aug 13 21:59:18 2014 +0200

    ARM: pxa: ssp: provide platform_device_id for PXA3xx
    
    Provide an explicit match string for PXA3xx SSP ports.
    
    Without this match string, SSP0/SSP1/SSP2 in PXA3xxx will be consided as
    PXA27x SSP Port.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 3ea02903d75a..1f5ee17a10e8 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -258,6 +258,7 @@ static const struct platform_device_id ssp_id_table[] = {
 	{ "pxa25x-ssp",		PXA25x_SSP },
 	{ "pxa25x-nssp",	PXA25x_NSSP },
 	{ "pxa27x-ssp",		PXA27x_SSP },
+	{ "pxa3xx-ssp",		PXA3xx_SSP },
 	{ "pxa168-ssp",		PXA168_SSP },
 	{ "pxa910-ssp",		PXA910_SSP },
 	{ },

commit d5ece9373c6e0f95ae59f303810e1ccbcd044629
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 5 12:30:52 2013 -0700

    ARM: pxa: ssp: Check return values from phandle lookups
    
    Commit a6e56c28a178cef5f (ARM: pxa: ssp: add DT bindings) causes warnings
    when built:
    
    arch/arm/plat-pxa/ssp.c: In function 'pxa_ssp_probe':
    arch/arm/plat-pxa/ssp.c:145:17: warning: 'dma_spec.args[0]' may be used
            uninitialized in this function [-Wmaybe-uninitialized]
    
    Resolve by checking return values and aborting when lookups fail.
    
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Mark Brown <broonie@linaro.org>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index c83f27b6bdda..3ea02903d75a 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -132,6 +132,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	if (dev->of_node) {
 		struct of_phandle_args dma_spec;
 		struct device_node *np = dev->of_node;
+		int ret;
 
 		/*
 		 * FIXME: we should allocate the DMA channel from this
@@ -140,14 +141,23 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 		 */
 
 		/* rx */
-		of_parse_phandle_with_args(np, "dmas", "#dma-cells",
-					   0, &dma_spec);
+		ret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",
+						 0, &dma_spec);
+
+		if (ret) {
+			dev_err(dev, "Can't parse dmas property\n");
+			return -ENODEV;
+		}
 		ssp->drcmr_rx = dma_spec.args[0];
 		of_node_put(dma_spec.np);
 
 		/* tx */
-		of_parse_phandle_with_args(np, "dmas", "#dma-cells",
-					   1, &dma_spec);
+		ret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",
+						 1, &dma_spec);
+		if (ret) {
+			dev_err(dev, "Can't parse dmas property\n");
+			return -ENODEV;
+		}
 		ssp->drcmr_tx = dma_spec.args[0];
 		of_node_put(dma_spec.np);
 	} else {

commit 6446221c14ef3bf58754cf1948631128dbe62700
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:37:18 2013 +0200

    ARM: pxa: ssp: add pxa_ssp_request_of()
    
    Add a function to lookup ssp devices from device tree. This way, users
    can reference the ssp devices in order to register to them.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index f2661355fa4e..c83f27b6bdda 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -62,6 +62,30 @@ struct ssp_device *pxa_ssp_request(int port, const char *label)
 }
 EXPORT_SYMBOL(pxa_ssp_request);
 
+struct ssp_device *pxa_ssp_request_of(const struct device_node *of_node,
+				      const char *label)
+{
+	struct ssp_device *ssp = NULL;
+
+	mutex_lock(&ssp_lock);
+
+	list_for_each_entry(ssp, &ssp_list, node) {
+		if (ssp->of_node == of_node && ssp->use_count == 0) {
+			ssp->use_count++;
+			ssp->label = label;
+			break;
+		}
+	}
+
+	mutex_unlock(&ssp_lock);
+
+	if (&ssp->node == &ssp_list)
+		return NULL;
+
+	return ssp;
+}
+EXPORT_SYMBOL(pxa_ssp_request_of);
+
 void pxa_ssp_free(struct ssp_device *ssp)
 {
 	mutex_lock(&ssp_lock);
@@ -185,6 +209,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	}
 
 	ssp->use_count = 0;
+	ssp->of_node = dev->of_node;
 
 	mutex_lock(&ssp_lock);
 	list_add(&ssp->node, &ssp_list);

commit 1c459de1e645b213a07b9492884a54f5861409f5
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:37:17 2013 +0200

    ARM: pxa: ssp: use devm_ functions
    
    Use devm_ functions to allocate memory, ioremap, clk_get etc to clean up
    the error unwind path.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index c3afcec7094c..f2661355fa4e 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -94,19 +94,16 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct ssp_device *ssp;
 	struct device *dev = &pdev->dev;
-	int ret = 0;
 
-	ssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);
+	ssp = devm_kzalloc(dev, sizeof(struct ssp_device), GFP_KERNEL);
 	if (ssp == NULL)
 		return -ENOMEM;
 
 	ssp->pdev = pdev;
 
-	ssp->clk = clk_get(dev, NULL);
-	if (IS_ERR(ssp->clk)) {
-		ret = PTR_ERR(ssp->clk);
-		goto err_free;
-	}
+	ssp->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(ssp->clk))
+		return PTR_ERR(ssp->clk);
 
 	if (dev->of_node) {
 		struct of_phandle_args dma_spec;
@@ -148,32 +145,28 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(dev, "no memory resource defined\n");
-		ret = -ENODEV;
-		goto err_free_clk;
+		return -ENODEV;
 	}
 
-	res = request_mem_region(res->start, resource_size(res),
-			pdev->name);
+	res = devm_request_mem_region(dev, res->start, resource_size(res),
+				      pdev->name);
 	if (res == NULL) {
 		dev_err(dev, "failed to request memory resource\n");
-		ret = -EBUSY;
-		goto err_free_clk;
+		return -EBUSY;
 	}
 
 	ssp->phys_base = res->start;
 
-	ssp->mmio_base = ioremap(res->start, resource_size(res));
+	ssp->mmio_base = devm_ioremap(dev, res->start, resource_size(res));
 	if (ssp->mmio_base == NULL) {
 		dev_err(dev, "failed to ioremap() registers\n");
-		ret = -ENODEV;
-		goto err_free_mem;
+		return -ENODEV;
 	}
 
 	ssp->irq = platform_get_irq(pdev, 0);
 	if (ssp->irq < 0) {
 		dev_err(dev, "no IRQ resource defined\n");
-		ret = -ENODEV;
-		goto err_free_io;
+		return -ENODEV;
 	}
 
 	if (dev->of_node) {
@@ -198,17 +191,8 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	mutex_unlock(&ssp_lock);
 
 	platform_set_drvdata(pdev, ssp);
-	return 0;
 
-err_free_io:
-	iounmap(ssp->mmio_base);
-err_free_mem:
-	release_mem_region(res->start, resource_size(res));
-err_free_clk:
-	clk_put(ssp->clk);
-err_free:
-	kfree(ssp);
-	return ret;
+	return 0;
 }
 
 static int pxa_ssp_remove(struct platform_device *pdev)

commit a6e56c28a178cef5f93d1e11698a23a5482175d9
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:37:16 2013 +0200

    ARM: pxa: ssp: add DT bindings
    
    This patch contains an ugly hack for looking up the the DMA request
    number. The problem here is that the implementation as it stands will
    allocate the DMA channel from the user of the ssp port, and hence we
    cannot allocate a real channel here.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 65ba28a0e3c6..c3afcec7094c 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -30,6 +30,8 @@
 #include <linux/platform_device.h>
 #include <linux/spi/pxa2xx_spi.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <asm/irq.h>
 #include <mach/hardware.h>
@@ -72,9 +74,23 @@ void pxa_ssp_free(struct ssp_device *ssp)
 }
 EXPORT_SYMBOL(pxa_ssp_free);
 
+#ifdef CONFIG_OF
+static const struct of_device_id pxa_ssp_of_ids[] = {
+	{ .compatible = "mrvl,pxa25x-ssp",	.data = (void *) PXA25x_SSP },
+	{ .compatible = "mvrl,pxa25x-nssp",	.data = (void *) PXA25x_NSSP },
+	{ .compatible = "mrvl,pxa27x-ssp",	.data = (void *) PXA27x_SSP },
+	{ .compatible = "mrvl,pxa3xx-ssp",	.data = (void *) PXA3xx_SSP },
+	{ .compatible = "mvrl,pxa168-ssp",	.data = (void *) PXA168_SSP },
+	{ .compatible = "mrvl,pxa910-ssp",	.data = (void *) PXA910_SSP },
+	{ .compatible = "mrvl,ce4100-ssp",	.data = (void *) CE4100_SSP },
+	{ .compatible = "mrvl,lpss-ssp",	.data = (void *) LPSS_SSP },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pxa_ssp_of_ids);
+#endif
+
 static int pxa_ssp_probe(struct platform_device *pdev)
 {
-	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct resource *res;
 	struct ssp_device *ssp;
 	struct device *dev = &pdev->dev;
@@ -92,21 +108,42 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 		goto err_free;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (res == NULL) {
-		dev_err(dev, "no SSP RX DRCMR defined\n");
-		ret = -ENODEV;
-		goto err_free_clk;
-	}
-	ssp->drcmr_rx = res->start;
+	if (dev->of_node) {
+		struct of_phandle_args dma_spec;
+		struct device_node *np = dev->of_node;
+
+		/*
+		 * FIXME: we should allocate the DMA channel from this
+		 * context and pass the channel down to the ssp users.
+		 * For now, we lookup the rx and tx indices manually
+		 */
+
+		/* rx */
+		of_parse_phandle_with_args(np, "dmas", "#dma-cells",
+					   0, &dma_spec);
+		ssp->drcmr_rx = dma_spec.args[0];
+		of_node_put(dma_spec.np);
+
+		/* tx */
+		of_parse_phandle_with_args(np, "dmas", "#dma-cells",
+					   1, &dma_spec);
+		ssp->drcmr_tx = dma_spec.args[0];
+		of_node_put(dma_spec.np);
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+		if (res == NULL) {
+			dev_err(dev, "no SSP RX DRCMR defined\n");
+			return -ENODEV;
+		}
+		ssp->drcmr_rx = res->start;
 
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
-	if (res == NULL) {
-		dev_err(dev, "no SSP TX DRCMR defined\n");
-		ret = -ENODEV;
-		goto err_free_clk;
+		res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+		if (res == NULL) {
+			dev_err(dev, "no SSP TX DRCMR defined\n");
+			return -ENODEV;
+		}
+		ssp->drcmr_tx = res->start;
 	}
-	ssp->drcmr_tx = res->start;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
@@ -139,12 +176,22 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 		goto err_free_io;
 	}
 
-	/* PXA2xx/3xx SSP ports starts from 1 and the internal pdev->id
-	 * starts from 0, do a translation here
-	 */
-	ssp->port_id = pdev->id + 1;
+	if (dev->of_node) {
+		const struct of_device_id *id =
+			of_match_device(of_match_ptr(pxa_ssp_of_ids), dev);
+		ssp->type = (int) id->data;
+	} else {
+		const struct platform_device_id *id =
+			platform_get_device_id(pdev);
+		ssp->type = (int) id->driver_data;
+
+		/* PXA2xx/3xx SSP ports starts from 1 and the internal pdev->id
+		 * starts from 0, do a translation here
+		 */
+		ssp->port_id = pdev->id + 1;
+	}
+
 	ssp->use_count = 0;
-	ssp->type = (int)id->driver_data;
 
 	mutex_lock(&ssp_lock);
 	list_add(&ssp->node, &ssp_list);
@@ -201,8 +248,9 @@ static struct platform_driver pxa_ssp_driver = {
 	.probe		= pxa_ssp_probe,
 	.remove		= pxa_ssp_remove,
 	.driver		= {
-		.owner	= THIS_MODULE,
-		.name	= "pxa2xx-ssp",
+		.owner		= THIS_MODULE,
+		.name		= "pxa2xx-ssp",
+		.of_match_table	= of_match_ptr(pxa_ssp_of_ids),
 	},
 	.id_table	= ssp_id_table,
 };

commit 970d8a7152aa884b9bab6a8db1ff148ee22df899
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:37:15 2013 +0200

    ARM: pxa: ssp: add shortcut for &pdev->dev
    
    No functional change, just a cosmetic cleanup.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index f746b6a388b8..65ba28a0e3c6 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -77,6 +77,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct resource *res;
 	struct ssp_device *ssp;
+	struct device *dev = &pdev->dev;
 	int ret = 0;
 
 	ssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);
@@ -85,7 +86,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 	ssp->pdev = pdev;
 
-	ssp->clk = clk_get(&pdev->dev, NULL);
+	ssp->clk = clk_get(dev, NULL);
 	if (IS_ERR(ssp->clk)) {
 		ret = PTR_ERR(ssp->clk);
 		goto err_free;
@@ -93,7 +94,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (res == NULL) {
-		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
+		dev_err(dev, "no SSP RX DRCMR defined\n");
 		ret = -ENODEV;
 		goto err_free_clk;
 	}
@@ -101,7 +102,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
 	if (res == NULL) {
-		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
+		dev_err(dev, "no SSP TX DRCMR defined\n");
 		ret = -ENODEV;
 		goto err_free_clk;
 	}
@@ -109,7 +110,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
-		dev_err(&pdev->dev, "no memory resource defined\n");
+		dev_err(dev, "no memory resource defined\n");
 		ret = -ENODEV;
 		goto err_free_clk;
 	}
@@ -117,7 +118,7 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	res = request_mem_region(res->start, resource_size(res),
 			pdev->name);
 	if (res == NULL) {
-		dev_err(&pdev->dev, "failed to request memory resource\n");
+		dev_err(dev, "failed to request memory resource\n");
 		ret = -EBUSY;
 		goto err_free_clk;
 	}
@@ -126,14 +127,14 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 
 	ssp->mmio_base = ioremap(res->start, resource_size(res));
 	if (ssp->mmio_base == NULL) {
-		dev_err(&pdev->dev, "failed to ioremap() registers\n");
+		dev_err(dev, "failed to ioremap() registers\n");
 		ret = -ENODEV;
 		goto err_free_mem;
 	}
 
 	ssp->irq = platform_get_irq(pdev, 0);
 	if (ssp->irq < 0) {
-		dev_err(&pdev->dev, "no IRQ resource defined\n");
+		dev_err(dev, "no IRQ resource defined\n");
 		ret = -ENODEV;
 		goto err_free_io;
 	}

commit 64be28146f746681c5f5625d321dd67602bb264c
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:37:14 2013 +0200

    ARM: pxa: ssp: remove unnecessary warning on kzalloc() failure
    
    The memory subsystem will already complain loudly enough in such cases.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 8e11e96eab5e..f746b6a388b8 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -80,10 +80,9 @@ static int pxa_ssp_probe(struct platform_device *pdev)
 	int ret = 0;
 
 	ssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);
-	if (ssp == NULL) {
-		dev_err(&pdev->dev, "failed to allocate memory");
+	if (ssp == NULL)
 		return -ENOMEM;
-	}
+
 	ssp->pdev = pdev;
 
 	ssp->clk = clk_get(&pdev->dev, NULL);

commit 351a102dbf489d0e9c9b0883f76e2a94d895503d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:02:24 2012 -0800

    ARM: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 584c9bf8ed2d..8e11e96eab5e 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -72,7 +72,7 @@ void pxa_ssp_free(struct ssp_device *ssp)
 }
 EXPORT_SYMBOL(pxa_ssp_free);
 
-static int __devinit pxa_ssp_probe(struct platform_device *pdev)
+static int pxa_ssp_probe(struct platform_device *pdev)
 {
 	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct resource *res;
@@ -164,7 +164,7 @@ static int __devinit pxa_ssp_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit pxa_ssp_remove(struct platform_device *pdev)
+static int pxa_ssp_remove(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct ssp_device *ssp;
@@ -199,7 +199,7 @@ static const struct platform_device_id ssp_id_table[] = {
 
 static struct platform_driver pxa_ssp_driver = {
 	.probe		= pxa_ssp_probe,
-	.remove		= __devexit_p(pxa_ssp_remove),
+	.remove		= pxa_ssp_remove,
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "pxa2xx-ssp",

commit 601722157b3f6be73623644eeae6f14940f0bd8f
Author: Qiao Zhou <zhouqiao@marvell.com>
Date:   Mon Jun 4 10:41:03 2012 +0800

    ARM: MMP: add pxa910-ssp into ssp_id_table
    
    add pxa910-ssp into ssp_id_table, and fix pxa-ssp compiling issue
    under mach-mmp architect.
    
    Signed-off-by: Qiao Zhou <zhouqiao@marvell.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 58b79809d20c..584c9bf8ed2d 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -193,6 +193,7 @@ static const struct platform_device_id ssp_id_table[] = {
 	{ "pxa25x-nssp",	PXA25x_NSSP },
 	{ "pxa27x-ssp",		PXA27x_SSP },
 	{ "pxa168-ssp",		PXA168_SSP },
+	{ "pxa910-ssp",		PXA910_SSP },
 	{ },
 };
 

commit 8348c259dd6a6019a8fa01b0a3443409480f7b9d
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Nov 22 17:12:15 2010 -0800

    arm/pxa2xx: reorgazine SSP and SPI header files
    
    The PXA-SPI driver relies on some files / defines which are arm specific
    and are within the ARM tree. The CE4100 SoC which is x86 has also the
    SPI core.
    This patch moves the ssp and spi files from arm/mach-pxa and plat-pxa to
    include/linux where the CE4100 can access them.
    
    This move got verified by building the following defconfigs:
       cm_x2xx_defconfig corgi_defconfig em_x270_defconfig ezx_defconfig
       imote2_defconfig pxa3xx_defconfig spitz_defconfig zeus_defconfig
       raumfeld_defconfig magician_defconfig
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index c6357e554aba..58b79809d20c 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -28,11 +28,11 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
+#include <linux/spi/pxa2xx_spi.h>
 #include <linux/io.h>
 
 #include <asm/irq.h>
 #include <mach/hardware.h>
-#include <plat/ssp.h>
 
 static DEFINE_MUTEX(ssp_lock);
 static LIST_HEAD(ssp_list);

commit baffe1699c68da5040de6b274054adc995795782
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed May 5 10:11:15 2010 -0400

    [ARM] pxa: add namespace on ssp
    
    In order to prevent code ambiguous, add namespace on functions in ssp driver.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 52c07cc756d7..c6357e554aba 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -37,7 +37,7 @@
 static DEFINE_MUTEX(ssp_lock);
 static LIST_HEAD(ssp_list);
 
-struct ssp_device *ssp_request(int port, const char *label)
+struct ssp_device *pxa_ssp_request(int port, const char *label)
 {
 	struct ssp_device *ssp = NULL;
 
@@ -58,9 +58,9 @@ struct ssp_device *ssp_request(int port, const char *label)
 
 	return ssp;
 }
-EXPORT_SYMBOL(ssp_request);
+EXPORT_SYMBOL(pxa_ssp_request);
 
-void ssp_free(struct ssp_device *ssp)
+void pxa_ssp_free(struct ssp_device *ssp)
 {
 	mutex_lock(&ssp_lock);
 	if (ssp->use_count) {
@@ -70,9 +70,9 @@ void ssp_free(struct ssp_device *ssp)
 		dev_err(&ssp->pdev->dev, "device already free\n");
 	mutex_unlock(&ssp_lock);
 }
-EXPORT_SYMBOL(ssp_free);
+EXPORT_SYMBOL(pxa_ssp_free);
 
-static int __devinit ssp_probe(struct platform_device *pdev)
+static int __devinit pxa_ssp_probe(struct platform_device *pdev)
 {
 	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct resource *res;
@@ -164,7 +164,7 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit ssp_remove(struct platform_device *pdev)
+static int __devexit pxa_ssp_remove(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct ssp_device *ssp;
@@ -196,9 +196,9 @@ static const struct platform_device_id ssp_id_table[] = {
 	{ },
 };
 
-static struct platform_driver ssp_driver = {
-	.probe		= ssp_probe,
-	.remove		= __devexit_p(ssp_remove),
+static struct platform_driver pxa_ssp_driver = {
+	.probe		= pxa_ssp_probe,
+	.remove		= __devexit_p(pxa_ssp_remove),
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "pxa2xx-ssp",
@@ -208,12 +208,12 @@ static struct platform_driver ssp_driver = {
 
 static int __init pxa_ssp_init(void)
 {
-	return platform_driver_register(&ssp_driver);
+	return platform_driver_register(&pxa_ssp_driver);
 }
 
 static void __exit pxa_ssp_exit(void)
 {
-	platform_driver_unregister(&ssp_driver);
+	platform_driver_unregister(&pxa_ssp_driver);
 }
 
 arch_initcall(pxa_ssp_init);

commit c8ee5c69516fdd973b981e3ac12d49b3133930cd
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Mar 22 16:16:24 2010 +0800

    [ARM] pxa: use resource_size() in ssp.c
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 3bf704d7a0d6..52c07cc756d7 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -115,7 +115,7 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 		goto err_free_clk;
 	}
 
-	res = request_mem_region(res->start, res->end - res->start + 1,
+	res = request_mem_region(res->start, resource_size(res),
 			pdev->name);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to request memory resource\n");
@@ -125,7 +125,7 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 
 	ssp->phys_base = res->start;
 
-	ssp->mmio_base = ioremap(res->start, res->end - res->start + 1);
+	ssp->mmio_base = ioremap(res->start, resource_size(res));
 	if (ssp->mmio_base == NULL) {
 		dev_err(&pdev->dev, "failed to ioremap() registers\n");
 		ret = -ENODEV;
@@ -156,7 +156,7 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 err_free_io:
 	iounmap(ssp->mmio_base);
 err_free_mem:
-	release_mem_region(res->start, res->end - res->start + 1);
+	release_mem_region(res->start, resource_size(res));
 err_free_clk:
 	clk_put(ssp->clk);
 err_free:
@@ -176,7 +176,7 @@ static int __devexit ssp_remove(struct platform_device *pdev)
 	iounmap(ssp->mmio_base);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, res->end - res->start + 1);
+	release_mem_region(res->start, resource_size(res));
 
 	clk_put(ssp->clk);
 

commit 077de1ad5ad8b4e08fd8853ae7e4cc628c1a369b
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Mar 22 16:11:55 2010 +0800

    [ARM] pxa: avoid NULL dereferencing in error handling of ssp.c
    
    The assignments of res to the results of the two calls to
    platform_get_resource make it impossible to use res in the error handling
    code in the arguments to release_mem_region.
    
    The semantic match that finds the former problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    expression E, E1;
    identifier f;
    statement S1,S3;
    iterator iter;
    @@
    
    if ((E == NULL && ...) || ...)
    {
     ... when != false ((E == NULL && ...) || ...)
         when != true  ((E != NULL && ...) || ...)
         when != iter(E,...) S1
         when != E = E1
    (
     sizeof(E->f)
    |
    * E->f
    )
     ... when any
     return ...;
    }
    else S3
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index cfebcd836f3e..3bf704d7a0d6 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -92,6 +92,22 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 		goto err_free;
 	}
 
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_clk;
+	}
+	ssp->drcmr_rx = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_clk;
+	}
+	ssp->drcmr_tx = res->start;
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "no memory resource defined\n");
@@ -123,22 +139,6 @@ static int __devinit ssp_probe(struct platform_device *pdev)
 		goto err_free_io;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
-		ret = -ENODEV;
-		goto err_free_io;
-	}
-	ssp->drcmr_rx = res->start;
-
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
-		ret = -ENODEV;
-		goto err_free_io;
-	}
-	ssp->drcmr_tx = res->start;
-
 	/* PXA2xx/3xx SSP ports starts from 1 and the internal pdev->id
 	 * starts from 0, do a translation here
 	 */

commit 7e4992288e55f1e15f7498ead618b3943f5cfd3f
Author: Haojian Zhuang <haojian.zhuang@gmail.com>
Date:   Fri Mar 19 11:53:17 2010 -0400

    [ARM] mmp: support ssp in pxa168
    
    Support ssp devices in PXA168. PXA168 could reuse the code of PXA SSP.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
index 5fe230178f0a..cfebcd836f3e 100644
--- a/arch/arm/plat-pxa/ssp.c
+++ b/arch/arm/plat-pxa/ssp.c
@@ -192,6 +192,7 @@ static const struct platform_device_id ssp_id_table[] = {
 	{ "pxa25x-ssp",		PXA25x_SSP },
 	{ "pxa25x-nssp",	PXA25x_NSSP },
 	{ "pxa27x-ssp",		PXA27x_SSP },
+	{ "pxa168-ssp",		PXA168_SSP },
 	{ },
 };
 

commit 54c39b420f017c546fb130a05c14bdb0a7910f98
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Tue Mar 16 17:12:37 2010 +0800

    [ARM] pxa: move ssp into common plat-pxa
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/plat-pxa/ssp.c b/arch/arm/plat-pxa/ssp.c
new file mode 100644
index 000000000000..5fe230178f0a
--- /dev/null
+++ b/arch/arm/plat-pxa/ssp.c
@@ -0,0 +1,223 @@
+/*
+ *  linux/arch/arm/mach-pxa/ssp.c
+ *
+ *  based on linux/arch/arm/mach-sa1100/ssp.c by Russell King
+ *
+ *  Copyright (C) 2003 Russell King.
+ *  Copyright (C) 2003 Wolfson Microelectronics PLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  PXA2xx SSP driver.  This provides the generic core for simple
+ *  IO-based SSP applications and allows easy port setup for DMA access.
+ *
+ *  Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <plat/ssp.h>
+
+static DEFINE_MUTEX(ssp_lock);
+static LIST_HEAD(ssp_list);
+
+struct ssp_device *ssp_request(int port, const char *label)
+{
+	struct ssp_device *ssp = NULL;
+
+	mutex_lock(&ssp_lock);
+
+	list_for_each_entry(ssp, &ssp_list, node) {
+		if (ssp->port_id == port && ssp->use_count == 0) {
+			ssp->use_count++;
+			ssp->label = label;
+			break;
+		}
+	}
+
+	mutex_unlock(&ssp_lock);
+
+	if (&ssp->node == &ssp_list)
+		return NULL;
+
+	return ssp;
+}
+EXPORT_SYMBOL(ssp_request);
+
+void ssp_free(struct ssp_device *ssp)
+{
+	mutex_lock(&ssp_lock);
+	if (ssp->use_count) {
+		ssp->use_count--;
+		ssp->label = NULL;
+	} else
+		dev_err(&ssp->pdev->dev, "device already free\n");
+	mutex_unlock(&ssp_lock);
+}
+EXPORT_SYMBOL(ssp_free);
+
+static int __devinit ssp_probe(struct platform_device *pdev)
+{
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	struct resource *res;
+	struct ssp_device *ssp;
+	int ret = 0;
+
+	ssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);
+	if (ssp == NULL) {
+		dev_err(&pdev->dev, "failed to allocate memory");
+		return -ENOMEM;
+	}
+	ssp->pdev = pdev;
+
+	ssp->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ssp->clk)) {
+		ret = PTR_ERR(ssp->clk);
+		goto err_free;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no memory resource defined\n");
+		ret = -ENODEV;
+		goto err_free_clk;
+	}
+
+	res = request_mem_region(res->start, res->end - res->start + 1,
+			pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request memory resource\n");
+		ret = -EBUSY;
+		goto err_free_clk;
+	}
+
+	ssp->phys_base = res->start;
+
+	ssp->mmio_base = ioremap(res->start, res->end - res->start + 1);
+	if (ssp->mmio_base == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap() registers\n");
+		ret = -ENODEV;
+		goto err_free_mem;
+	}
+
+	ssp->irq = platform_get_irq(pdev, 0);
+	if (ssp->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+	ssp->drcmr_rx = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+	ssp->drcmr_tx = res->start;
+
+	/* PXA2xx/3xx SSP ports starts from 1 and the internal pdev->id
+	 * starts from 0, do a translation here
+	 */
+	ssp->port_id = pdev->id + 1;
+	ssp->use_count = 0;
+	ssp->type = (int)id->driver_data;
+
+	mutex_lock(&ssp_lock);
+	list_add(&ssp->node, &ssp_list);
+	mutex_unlock(&ssp_lock);
+
+	platform_set_drvdata(pdev, ssp);
+	return 0;
+
+err_free_io:
+	iounmap(ssp->mmio_base);
+err_free_mem:
+	release_mem_region(res->start, res->end - res->start + 1);
+err_free_clk:
+	clk_put(ssp->clk);
+err_free:
+	kfree(ssp);
+	return ret;
+}
+
+static int __devexit ssp_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct ssp_device *ssp;
+
+	ssp = platform_get_drvdata(pdev);
+	if (ssp == NULL)
+		return -ENODEV;
+
+	iounmap(ssp->mmio_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	clk_put(ssp->clk);
+
+	mutex_lock(&ssp_lock);
+	list_del(&ssp->node);
+	mutex_unlock(&ssp_lock);
+
+	kfree(ssp);
+	return 0;
+}
+
+static const struct platform_device_id ssp_id_table[] = {
+	{ "pxa25x-ssp",		PXA25x_SSP },
+	{ "pxa25x-nssp",	PXA25x_NSSP },
+	{ "pxa27x-ssp",		PXA27x_SSP },
+	{ },
+};
+
+static struct platform_driver ssp_driver = {
+	.probe		= ssp_probe,
+	.remove		= __devexit_p(ssp_remove),
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "pxa2xx-ssp",
+	},
+	.id_table	= ssp_id_table,
+};
+
+static int __init pxa_ssp_init(void)
+{
+	return platform_driver_register(&ssp_driver);
+}
+
+static void __exit pxa_ssp_exit(void)
+{
+	platform_driver_unregister(&ssp_driver);
+}
+
+arch_initcall(pxa_ssp_init);
+module_exit(pxa_ssp_exit);
+
+MODULE_DESCRIPTION("PXA SSP driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
