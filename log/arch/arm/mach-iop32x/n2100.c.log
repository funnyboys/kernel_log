commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 5382a93ad0f8..78b9a5ee41c9 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -35,7 +35,6 @@
 #include <asm/mach/time.h>
 #include <asm/mach-types.h>
 #include <asm/page.h>
-#include <asm/pgtable.h>
 
 #include "hardware.h"
 #include "irqs.h"

commit a1f487d75c9be17421f1ab10172427dd16e5f56a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 9 18:33:21 2019 +0200

    ARM: iop32x: merge everything into mach-iop32x/
    
    Various bits of iop32x are now in their traditional locations in plat-iop,
    mach-iop/include/mach/ and in include/asm/mach/hardware. As nothing
    outside of the iop32x mach code references these any more, this can all
    be moved into one place now.
    
    The only remaining things in the include/mach/ directory are now the
    NR_IRQS definition, the entry-macros.S file and the the decompressor
    uart access. After the irqchip code has been converted to SPARSE_IRQ
    and GENERIC_IRQ_MULTI_HANDLER, it can be moved to ARCH_MULTIPLATFORM.
    
    Link: https://lore.kernel.org/r/20190809163334.489360-7-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 26d76b377e79..5382a93ad0f8 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -28,7 +28,6 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/gpio/machine.h>
-#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -37,7 +36,9 @@
 #include <asm/mach-types.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
-#include <mach/time.h>
+
+#include "hardware.h"
+#include "irqs.h"
 #include "gpio-iop32x.h"
 
 /*

commit 273cbf61c3ddee9574ef1f4959b9bc6db5b24271
Merge: 5fe7b600a116 cc6b9dfb2c57
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 21:10:39 2019 -0700

    Merge branch 'i2c/for-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "New stuff from the I2C world:
    
       - in the core, getting irqs from ACPI is now similar to OF
    
       - new driver for MediaTek MT7621/7628/7688 SoCs
    
       - bcm2835, i801, and tegra drivers got some more attention
    
       - GPIO API cleanups
    
       - cleanups in the core headers
    
       - lots of usual driver updates"
    
    * 'i2c/for-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (74 commits)
      i2c: mt7621: Fix platform_no_drv_owner.cocci warnings
      i2c: cpm: remove casting dma_alloc
      dt-bindings: i2c: sun6i-p2wi: Fix the binding example
      dt-bindings: i2c: mv64xxx: Fix the example compatible
      i2c: i801: Documentation update
      i2c: i801: Add support for Intel Tiger Lake
      i2c: i801: Fix PCI ID sorting
      dt-bindings: i2c-stm32: document optional dmas
      i2c: i2c-stm32f7: Add I2C_SMBUS_I2C_BLOCK_DATA support
      i2c: core: Tidy up handling of init_irq
      i2c: core: Move ACPI gpio IRQ handling into i2c_acpi_get_irq
      i2c: core: Move ACPI IRQ handling to probe time
      i2c: acpi: Factor out getting the IRQ from ACPI
      i2c: acpi: Use available IRQ helper functions
      i2c: core: Allow whole core to use i2c_dev_irq_from_resources
      eeprom: at24: modify a comment referring to platform data
      dt-bindings: i2c: omap: Add new compatible for J721E SoCs
      dt-bindings: i2c: mv64xxx: Add YAML schemas
      dt-bindings: i2c: sun6i-p2wi: Add YAML schemas
      i2c: mt7621: Add MediaTek MT7621/7628/7688 I2C driver
      ...

commit fdb7e884ad617f8aa69abdd7f39e3fdac85e081e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Jun 1 00:37:56 2019 +0200

    i2c: iop: Use GPIO descriptors
    
    The IOP3xx has some elaborate code to directly slam the
    GPIO lines multiplexed with I2C down low before enablement,
    apparently a workaround for a hardware bug found in the
    early chips.
    
    After consulting the developer documentation for IOP80321
    and IOP80331 I can clearly see that this may be useful for
    IOP80321 family (mach-iop32x) but it is highly dubious for
    any 80331 series or later chip: in these chips the lines
    are not multiplexed for UARTs.
    
    We convert the code to pass optional GPIO descriptors
    and register these only on the 80321-based boards where
    it makes sense, optionally obtain them in the driver and
    use the gpiod_set_raw_value() to ascertain the line gets
    driven low when needed.
    
    The GPIO driver does not give the GPIO chip a reasonable
    label so the patch also adds that so that these machine
    descriptor tables can be used.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 23e8c93515d4..c780b6e82ad9 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -31,6 +31,7 @@
 #include <linux/reboot.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
+#include <linux/gpio/machine.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>
@@ -345,6 +346,7 @@ device_initcall(n2100_request_gpios);
 static void __init n2100_init_machine(void)
 {
 	register_iop32x_gpio();
+	gpiod_add_lookup_table(&iop3xx_i2c0_gpio_lookup);
 	platform_device_register(&iop3xx_i2c0_device);
 	platform_device_register(&n2100_flash_device);
 	platform_device_register(&n2100_serial_device);

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 23e8c93515d4..1948180594f4 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * arch/arm/mach-iop32x/n2100.c
  *
@@ -7,11 +8,6 @@
  * Copyright (C) 2002 Rory Bolt
  * Copyright 2003 (c) MontaVista, Software, Inc.
  * Copyright (C) 2004 Intel Corp.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
  */
 
 #include <linux/mm.h>

commit db4090920ba2d61a5827a23e441447926a02ffee
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Jan 25 20:10:15 2019 +0000

    ARM: iop32x/n2100: fix PCI IRQ mapping
    
    Booting 4.20 on a TheCUS N2100 results in a kernel oops while probing
    PCI, due to n2100_pci_map_irq() having been discarded during boot.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: stable@vger.kernel.org # 2.6.18+
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 3b73813c6b04..23e8c93515d4 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -75,8 +75,7 @@ void __init n2100_map_io(void)
 /*
  * N2100 PCI.
  */
-static int __init
-n2100_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+static int n2100_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
 

commit e99e88a9d2b067465adaa9c111ada99a041bef9a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 14:43:17 2017 -0700

    treewide: setup_timer() -> timer_setup()
    
    This converts all remaining cases of the old setup_timer() API into using
    timer_setup(), where the callback argument is the structure already
    holding the struct timer_list. These should have no behavioral changes,
    since they just change which pointer is passed into the callback with
    the same available pointers after conversion. It handles the following
    examples, in addition to some other variations.
    
    Casting from unsigned long:
    
        void my_callback(unsigned long data)
        {
            struct something *ptr = (struct something *)data;
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, ptr);
    
    and forced object casts:
    
        void my_callback(struct something *ptr)
        {
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, (unsigned long)ptr);
    
    become:
    
        void my_callback(struct timer_list *t)
        {
            struct something *ptr = from_timer(ptr, t, my_timer);
        ...
        }
        ...
        timer_setup(&ptr->my_timer, my_callback, 0);
    
    Direct function assignments:
    
        void my_callback(unsigned long data)
        {
            struct something *ptr = (struct something *)data;
        ...
        }
        ...
        ptr->my_timer.function = my_callback;
    
    have a temporary cast added, along with converting the args:
    
        void my_callback(struct timer_list *t)
        {
            struct something *ptr = from_timer(ptr, t, my_timer);
        ...
        }
        ...
        ptr->my_timer.function = (TIMER_FUNC_TYPE)my_callback;
    
    And finally, callbacks without a data assignment:
    
        void my_callback(unsigned long data)
        {
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, 0);
    
    have their argument renamed to verify they're unused during conversion:
    
        void my_callback(struct timer_list *unused)
        {
        ...
        }
        ...
        timer_setup(&ptr->my_timer, my_callback, 0);
    
    The conversion is done with the following Coccinelle script:
    
    spatch --very-quiet --all-includes --include-headers \
            -I ./arch/x86/include -I ./arch/x86/include/generated \
            -I ./include -I ./arch/x86/include/uapi \
            -I ./arch/x86/include/generated/uapi -I ./include/uapi \
            -I ./include/generated/uapi --include ./include/linux/kconfig.h \
            --dir . \
            --cocci-file ~/src/data/timer_setup.cocci
    
    @fix_address_of@
    expression e;
    @@
    
     setup_timer(
    -&(e)
    +&e
     , ...)
    
    // Update any raw setup_timer() usages that have a NULL callback, but
    // would otherwise match change_timer_function_usage, since the latter
    // will update all function assignments done in the face of a NULL
    // function initialization in setup_timer().
    @change_timer_function_usage_NULL@
    expression _E;
    identifier _timer;
    type _cast_data;
    @@
    
    (
    -setup_timer(&_E->_timer, NULL, _E);
    +timer_setup(&_E->_timer, NULL, 0);
    |
    -setup_timer(&_E->_timer, NULL, (_cast_data)_E);
    +timer_setup(&_E->_timer, NULL, 0);
    |
    -setup_timer(&_E._timer, NULL, &_E);
    +timer_setup(&_E._timer, NULL, 0);
    |
    -setup_timer(&_E._timer, NULL, (_cast_data)&_E);
    +timer_setup(&_E._timer, NULL, 0);
    )
    
    @change_timer_function_usage@
    expression _E;
    identifier _timer;
    struct timer_list _stl;
    identifier _callback;
    type _cast_func, _cast_data;
    @@
    
    (
    -setup_timer(&_E->_timer, _callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, &_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, &_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)&_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)&_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, &_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, &_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
     _E->_timer@_stl.function = _callback;
    |
     _E->_timer@_stl.function = &_callback;
    |
     _E->_timer@_stl.function = (_cast_func)_callback;
    |
     _E->_timer@_stl.function = (_cast_func)&_callback;
    |
     _E._timer@_stl.function = _callback;
    |
     _E._timer@_stl.function = &_callback;
    |
     _E._timer@_stl.function = (_cast_func)_callback;
    |
     _E._timer@_stl.function = (_cast_func)&_callback;
    )
    
    // callback(unsigned long arg)
    @change_callback_handle_cast
     depends on change_timer_function_usage@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _origtype;
    identifier _origarg;
    type _handletype;
    identifier _handle;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *t
     )
     {
    (
            ... when != _origarg
            _handletype *_handle =
    -(_handletype *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle =
    -(void *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle;
            ... when != _handle
            _handle =
    -(_handletype *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle;
            ... when != _handle
            _handle =
    -(void *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    )
     }
    
    // callback(unsigned long arg) without existing variable
    @change_callback_handle_cast_no_arg
     depends on change_timer_function_usage &&
                         !change_callback_handle_cast@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _origtype;
    identifier _origarg;
    type _handletype;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *t
     )
     {
    +       _handletype *_origarg = from_timer(_origarg, t, _timer);
    +
            ... when != _origarg
    -       (_handletype *)_origarg
    +       _origarg
            ... when != _origarg
     }
    
    // Avoid already converted callbacks.
    @match_callback_converted
     depends on change_timer_function_usage &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg@
    identifier change_timer_function_usage._callback;
    identifier t;
    @@
    
     void _callback(struct timer_list *t)
     { ... }
    
    // callback(struct something *handle)
    @change_callback_handle_arg
     depends on change_timer_function_usage &&
                !match_callback_converted &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _handletype;
    identifier _handle;
    @@
    
     void _callback(
    -_handletype *_handle
    +struct timer_list *t
     )
     {
    +       _handletype *_handle = from_timer(_handle, t, _timer);
            ...
     }
    
    // If change_callback_handle_arg ran on an empty function, remove
    // the added handler.
    @unchange_callback_handle_arg
     depends on change_timer_function_usage &&
                change_callback_handle_arg@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _handletype;
    identifier _handle;
    identifier t;
    @@
    
     void _callback(struct timer_list *t)
     {
    -       _handletype *_handle = from_timer(_handle, t, _timer);
     }
    
    // We only want to refactor the setup_timer() data argument if we've found
    // the matching callback. This undoes changes in change_timer_function_usage.
    @unchange_timer_function_usage
     depends on change_timer_function_usage &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg &&
                !change_callback_handle_arg@
    expression change_timer_function_usage._E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type change_timer_function_usage._cast_data;
    @@
    
    (
    -timer_setup(&_E->_timer, _callback, 0);
    +setup_timer(&_E->_timer, _callback, (_cast_data)_E);
    |
    -timer_setup(&_E._timer, _callback, 0);
    +setup_timer(&_E._timer, _callback, (_cast_data)&_E);
    )
    
    // If we fixed a callback from a .function assignment, fix the
    // assignment cast now.
    @change_timer_function_assignment
     depends on change_timer_function_usage &&
                (change_callback_handle_cast ||
                 change_callback_handle_cast_no_arg ||
                 change_callback_handle_arg)@
    expression change_timer_function_usage._E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type _cast_func;
    typedef TIMER_FUNC_TYPE;
    @@
    
    (
     _E->_timer.function =
    -_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -(_cast_func)_callback;
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -(_cast_func)&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -&_callback;
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -(_cast_func)_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -(_cast_func)&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    )
    
    // Sometimes timer functions are called directly. Replace matched args.
    @change_timer_function_calls
     depends on change_timer_function_usage &&
                (change_callback_handle_cast ||
                 change_callback_handle_cast_no_arg ||
                 change_callback_handle_arg)@
    expression _E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type _cast_data;
    @@
    
     _callback(
    (
    -(_cast_data)_E
    +&_E->_timer
    |
    -(_cast_data)&_E
    +&_E._timer
    |
    -_E
    +&_E->_timer
    )
     )
    
    // If a timer has been configured without a data argument, it can be
    // converted without regard to the callback argument, since it is unused.
    @match_timer_function_unused_data@
    expression _E;
    identifier _timer;
    identifier _callback;
    @@
    
    (
    -setup_timer(&_E->_timer, _callback, 0);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, 0L);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, 0UL);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0L);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0UL);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0L);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0UL);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0);
    +timer_setup(_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0L);
    +timer_setup(_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0UL);
    +timer_setup(_timer, _callback, 0);
    )
    
    @change_callback_unused_data
     depends on match_timer_function_unused_data@
    identifier match_timer_function_unused_data._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *unused
     )
     {
            ... when != _origarg
     }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 4a64a11ba63c..3b73813c6b04 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -305,7 +305,7 @@ static void n2100_restart(enum reboot_mode mode, const char *cmd)
 
 static struct timer_list power_button_poll_timer;
 
-static void power_button_poll(unsigned long dummy)
+static void power_button_poll(struct timer_list *unused)
 {
 	if (gpio_get_value(N2100_POWER_BUTTON) == 0) {
 		ctrl_alt_del();
@@ -336,7 +336,7 @@ static int __init n2100_request_gpios(void)
 			pr_err("could not set power GPIO as input\n");
 	}
 	/* Set up power button poll timer */
-	setup_timer(&power_button_poll_timer, power_button_poll, 0UL);
+	timer_setup(&power_button_poll_timer, power_button_poll, 0);
 	power_button_poll_timer.expires = jiffies + (HZ / 10);
 	add_timer(&power_button_poll_timer);
 	return 0;

commit b9eaf18722221ef8b2bd6a67240ebe668622152a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 13:15:39 2017 -0700

    treewide: init_timer() -> setup_timer()
    
    This mechanically converts all remaining cases of ancient open-coded timer
    setup with the old setup_timer() API, which is the first step in timer
    conversions. This has no behavioral changes, since it ultimately just
    changes the order of assignment to fields of struct timer_list when
    finding variations of:
    
        init_timer(&t);
        f.function = timer_callback;
        t.data = timer_callback_arg;
    
    to be converted into:
    
        setup_timer(&t, timer_callback, timer_callback_arg);
    
    The conversion is done with the following Coccinelle script, which
    is an improved version of scripts/cocci/api/setup_timer.cocci, in the
    following ways:
     - assignments-before-init_timer() cases
     - limit the .data case removal to the specific struct timer_list instance
     - handling calls by dereference (timer->field vs timer.field)
    
    spatch --very-quiet --all-includes --include-headers \
            -I ./arch/x86/include -I ./arch/x86/include/generated \
            -I ./include -I ./arch/x86/include/uapi \
            -I ./arch/x86/include/generated/uapi -I ./include/uapi \
            -I ./include/generated/uapi --include ./include/linux/kconfig.h \
            --dir . \
            --cocci-file ~/src/data/setup_timer.cocci
    
    @fix_address_of@
    expression e;
    @@
    
     init_timer(
    -&(e)
    +&e
     , ...)
    
    // Match the common cases first to avoid Coccinelle parsing loops with
    // "... when" clauses.
    
    @match_immediate_function_data_after_init_timer@
    expression e, func, da;
    @@
    
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    (
    -\(e.function\|e->function\) = func;
    -\(e.data\|e->data\) = da;
    |
    -\(e.data\|e->data\) = da;
    -\(e.function\|e->function\) = func;
    )
    
    @match_immediate_function_data_before_init_timer@
    expression e, func, da;
    @@
    
    (
    -\(e.function\|e->function\) = func;
    -\(e.data\|e->data\) = da;
    |
    -\(e.data\|e->data\) = da;
    -\(e.function\|e->function\) = func;
    )
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    
    @match_function_and_data_after_init_timer@
    expression e, e2, e3, e4, e5, func, da;
    @@
    
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
     ... when != func = e2
         when != da = e3
    (
    -e.function = func;
    ... when != da = e4
    -e.data = da;
    |
    -e->function = func;
    ... when != da = e4
    -e->data = da;
    |
    -e.data = da;
    ... when != func = e5
    -e.function = func;
    |
    -e->data = da;
    ... when != func = e5
    -e->function = func;
    )
    
    @match_function_and_data_before_init_timer@
    expression e, e2, e3, e4, e5, func, da;
    @@
    (
    -e.function = func;
    ... when != da = e4
    -e.data = da;
    |
    -e->function = func;
    ... when != da = e4
    -e->data = da;
    |
    -e.data = da;
    ... when != func = e5
    -e.function = func;
    |
    -e->data = da;
    ... when != func = e5
    -e->function = func;
    )
    ... when != func = e2
        when != da = e3
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    
    @r1 exists@
    expression t;
    identifier f;
    position p;
    @@
    
    f(...) { ... when any
      init_timer@p(\(&t\|t\))
      ... when any
    }
    
    @r2 exists@
    expression r1.t;
    identifier g != r1.f;
    expression e8;
    @@
    
    g(...) { ... when any
      \(t.data\|t->data\) = e8
      ... when any
    }
    
    // It is dangerous to use setup_timer if data field is initialized
    // in another function.
    @script:python depends on r2@
    p << r1.p;
    @@
    
    cocci.include_match(False)
    
    @r3@
    expression r1.t, func, e7;
    position r1.p;
    @@
    
    (
    -init_timer@p(&t);
    +setup_timer(&t, func, 0UL);
    ... when != func = e7
    -t.function = func;
    |
    -t.function = func;
    ... when != func = e7
    -init_timer@p(&t);
    +setup_timer(&t, func, 0UL);
    |
    -init_timer@p(t);
    +setup_timer(t, func, 0UL);
    ... when != func = e7
    -t->function = func;
    |
    -t->function = func;
    ... when != func = e7
    -init_timer@p(t);
    +setup_timer(t, func, 0UL);
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index c1cd80ecc219..4a64a11ba63c 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -336,8 +336,7 @@ static int __init n2100_request_gpios(void)
 			pr_err("could not set power GPIO as input\n");
 	}
 	/* Set up power button poll timer */
-	init_timer(&power_button_poll_timer);
-	power_button_poll_timer.function = power_button_poll;
+	setup_timer(&power_button_poll_timer, power_button_poll, 0UL);
 	power_button_poll_timer.expires = jiffies + (HZ / 10);
 	add_timer(&power_button_poll_timer);
 	return 0;

commit 7b85b867b99044da93f83851c806d1e324d49ed5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Sep 9 16:39:51 2013 +0200

    ARM: plat-iop: instantiate GPIO from platform device
    
    This converts the IOP32x and IOP33x platforms to pass their
    base address offset by a resource attached to a platform device
    instead of using static offset macros implicitly passed
    through <linux/gpio.h> including <mach/gpio.h>. Delete the
    local <mach/gpio.h> and <asm/hardware/iop3xx-gpio.h> headers
    and remove the selection of NEED_MACH_GPIO_H.
    
    Pass the virtual address as a resource in the platform device
    at this point for bisectability, next patch will pass the
    physical address as is custom.
    
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index bc40a97050a1..c1cd80ecc219 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -41,6 +41,7 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <mach/time.h>
+#include "gpio-iop32x.h"
 
 /*
  * N2100 timer tick configuration.
@@ -345,6 +346,7 @@ device_initcall(n2100_request_gpios);
 
 static void __init n2100_init_machine(void)
 {
+	register_iop32x_gpio();
 	platform_device_register(&iop3xx_i2c0_device);
 	platform_device_register(&n2100_flash_device);
 	platform_device_register(&n2100_serial_device);

commit afc3b79f5dbddd4ab210beb9cc6da102a1032b89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Sep 9 14:53:02 2013 +0200

    ARM: iop32x: read N2100 power key using gpiolib
    
    Refrain from using the custom gpio_line_get() to read the power
    key on the N2100, use the gpiolib function gpio_get() instead.
    Also request the line in the GPIOs initicall, and move the poll
    timer setup to that inicall so the gpio chip is available before
    we request this GPIO and start to poll it.
    
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 6bace5bc7ebb..bc40a97050a1 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -306,7 +306,7 @@ static struct timer_list power_button_poll_timer;
 
 static void power_button_poll(unsigned long dummy)
 {
-	if (gpio_line_get(N2100_POWER_BUTTON) == 0) {
+	if (gpio_get_value(N2100_POWER_BUTTON) == 0) {
 		ctrl_alt_del();
 		return;
 	}
@@ -325,6 +325,20 @@ static int __init n2100_request_gpios(void)
 	ret = gpio_request(N2100_HARDWARE_RESET, "reset");
 	if (ret)
 		pr_err("could not request reset GPIO\n");
+
+	ret = gpio_request(N2100_POWER_BUTTON, "power");
+	if (ret)
+		pr_err("could not request power GPIO\n");
+	else {
+		ret = gpio_direction_input(N2100_POWER_BUTTON);
+		if (ret)
+			pr_err("could not set power GPIO as input\n");
+	}
+	/* Set up power button poll timer */
+	init_timer(&power_button_poll_timer);
+	power_button_poll_timer.function = power_button_poll;
+	power_button_poll_timer.expires = jiffies + (HZ / 10);
+	add_timer(&power_button_poll_timer);
 	return 0;
 }
 device_initcall(n2100_request_gpios);
@@ -341,11 +355,6 @@ static void __init n2100_init_machine(void)
 		ARRAY_SIZE(n2100_i2c_devices));
 
 	pm_power_off = n2100_power_off;
-
-	init_timer(&power_button_poll_timer);
-	power_button_poll_timer.function = power_button_poll;
-	power_button_poll_timer.expires = jiffies + (HZ / 10);
-	add_timer(&power_button_poll_timer);
 }
 
 MACHINE_START(N2100, "Thecus N2100")

commit 7111f8780fcf770d8624d758fd240e585adf7d3c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Sep 9 14:45:47 2013 +0200

    ARM: iop32x: request and issue reset using gpio
    
    As the IOP GPIO driver supports gpiolib we can use the standard
    GPIO calls to issue a reset of the machine instead of using the
    custom gpio_line_set/config calls. Also request the GPIO when
    initializing the machine.
    
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 069144300b77..6bace5bc7ebb 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -30,6 +30,7 @@
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
 #include <linux/io.h>
+#include <linux/gpio.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>
@@ -288,8 +289,14 @@ static void n2100_power_off(void)
 
 static void n2100_restart(enum reboot_mode mode, const char *cmd)
 {
-	gpio_line_set(N2100_HARDWARE_RESET, GPIO_LOW);
-	gpio_line_config(N2100_HARDWARE_RESET, GPIO_OUT);
+	int ret;
+
+	ret = gpio_direction_output(N2100_HARDWARE_RESET, 0);
+	if (ret) {
+		pr_crit("could not drive reset GPIO low\n");
+		return;
+	}
+	/* Wait for reset to happen */
 	while (1)
 		;
 }
@@ -308,6 +315,19 @@ static void power_button_poll(unsigned long dummy)
 	add_timer(&power_button_poll_timer);
 }
 
+static int __init n2100_request_gpios(void)
+{
+	int ret;
+
+	if (!machine_is_n2100())
+		return 0;
+
+	ret = gpio_request(N2100_HARDWARE_RESET, "reset");
+	if (ret)
+		pr_err("could not request reset GPIO\n");
+	return 0;
+}
+device_initcall(n2100_request_gpios);
 
 static void __init n2100_init_machine(void)
 {

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index ea0984a7449e..069144300b77 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -286,7 +286,7 @@ static void n2100_power_off(void)
 		;
 }
 
-static void n2100_restart(char mode, const char *cmd)
+static void n2100_restart(enum reboot_mode mode, const char *cmd)
 {
 	gpio_line_set(N2100_HARDWARE_RESET, GPIO_LOW);
 	gpio_line_config(N2100_HARDWARE_RESET, GPIO_OUT);

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 5a7ae91e8849..ea0984a7449e 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -50,10 +50,6 @@ static void __init n2100_timer_init(void)
 	iop_init_time(198000000);
 }
 
-static struct sys_timer n2100_timer = {
-	.init		= n2100_timer_init,
-};
-
 
 /*
  * N2100 I/O.
@@ -337,7 +333,7 @@ MACHINE_START(N2100, "Thecus N2100")
 	.atag_offset	= 0x100,
 	.map_io		= n2100_map_io,
 	.init_irq	= iop32x_init_irq,
-	.timer		= &n2100_timer,
+	.init_time	= n2100_timer_init,
 	.init_machine	= n2100_init_machine,
 	.restart	= n2100_restart,
 MACHINE_END

commit c23bfc3835173f5229b2503e3b616001a28affad
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 12:49:16 2012 +0000

    ARM: PCI: provide a default bus scan implementation
    
    Most PCI implementations perform simple root bus scanning.  Rather than
    having each group of platforms provide a duplicated bus scan function,
    provide the PCI configuration ops structure via the hw_pci structure,
    and call the root bus scanning function from core ARM PCI code.
    
    Acked-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index adf257a18f19..5a7ae91e8849 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -115,9 +115,9 @@ n2100_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 
 static struct hw_pci n2100_pci __initdata = {
 	.nr_controllers = 1,
+	.ops		= &iop3xx_ops,
 	.setup		= iop3xx_pci_setup,
 	.preinit	= iop3xx_pci_preinit,
-	.scan		= iop3xx_pci_scan_bus,
 	.map_irq	= n2100_pci_map_irq,
 };
 

commit daeb4c0c3bf2df72d0cd6e4330bad9e2e520552b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 11:39:33 2012 +0000

    ARM: PCI: get rid of pci_std_swizzle()
    
    Most PCI implementations use the standard PCI swizzle function, which
    handles the well defined behaviour of PCI-to-PCI bridges which can be
    found on cards (eg, four port ethernet cards.)
    
    Rather than having almost every platform specify the standard swizzle
    function, make this the default when no swizzle function is supplied.
    Therefore, a swizzle function only needs to be provided when there is
    something exceptional which needs to be handled.
    
    This gets rid of the swizzle initializer from 47 files, and leaves us
    with just two platforms specifying a swizzle function: ARM Integrator
    and Chalice CATS.
    
    Acked-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 6b6d55912444..adf257a18f19 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -114,7 +114,6 @@ n2100_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 }
 
 static struct hw_pci n2100_pci __initdata = {
-	.swizzle	= pci_std_swizzle,
 	.nr_controllers = 1,
 	.setup		= iop3xx_pci_setup,
 	.preinit	= iop3xx_pci_preinit,

commit bec92b1ec67b4998b6a3bad7c2f03c846cbac71e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 11:26:32 2011 +0000

    ARM: restart: iop3xx: use new restart hook
    
    Hook these platforms restart code into the arm_pm_restart hook rather
    than using arch_reset().
    
    In doing so, we split out the n2100 platform specific restart handler
    into the n2100 platform file.
    
    Acked-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index d7269279968c..6b6d55912444 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -291,6 +291,14 @@ static void n2100_power_off(void)
 		;
 }
 
+static void n2100_restart(char mode, const char *cmd)
+{
+	gpio_line_set(N2100_HARDWARE_RESET, GPIO_LOW);
+	gpio_line_config(N2100_HARDWARE_RESET, GPIO_OUT);
+	while (1)
+		;
+}
+
 
 static struct timer_list power_button_poll_timer;
 
@@ -332,4 +340,5 @@ MACHINE_START(N2100, "Thecus N2100")
 	.init_irq	= iop32x_init_irq,
 	.timer		= &n2100_timer,
 	.init_machine	= n2100_init_machine,
+	.restart	= n2100_restart,
 MACHINE_END

commit 1896746defa4b711b39bd04145a55d42a902ae2a
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jul 5 22:38:12 2011 -0400

    ARM: mach-iop32x: convert boot_params to atag_offset
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 1a374eab6007..d7269279968c 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -327,7 +327,7 @@ static void __init n2100_init_machine(void)
 
 MACHINE_START(N2100, "Thecus N2100")
 	/* Maintainer: Lennert Buytenhek <buytenh@wantstofly.org> */
-	.boot_params	= 0xa0000100,
+	.atag_offset	= 0x100,
 	.map_io		= n2100_map_io,
 	.init_irq	= iop32x_init_irq,
 	.timer		= &n2100_timer,

commit d5341942d784134f2997b3ff82cd63cf71d1f932
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 10 15:30:21 2011 +0100

    PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
    
    Aside of the usual motivation for constification,  this function has a
    history of being abused a hook for interrupt and other fixups so I turned
    this function const ages ago in the MIPS code but it should be done
    treewide.
    
    Due to function pointer passing in varous places a few other functions
    had to be constified as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    To: Anton Vorontsov <avorontsov@mvista.com>
    To: Chris Metcalf <cmetcalf@tilera.com>
    To: Colin Cross <ccross@android.com>
    Acked-by: "David S. Miller" <davem@davemloft.net>
    To: Eric Miao <eric.y.miao@gmail.com>
    To: Erik Gilling <konkers@android.com>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: "H. Peter Anvin" <hpa@zytor.com>
    To: Imre Kaloz <kaloz@openwrt.org>
    To: Ingo Molnar <mingo@redhat.com>
    To: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    To: Jesse Barnes <jbarnes@virtuousgeek.org>
    To: Krzysztof Halasa <khc@pm.waw.pl>
    To: Lennert Buytenhek <kernel@wantstofly.org>
    To: Matt Turner <mattst88@gmail.com>
    To: Nicolas Pitre <nico@fluxnic.net>
    To: Olof Johansson <olof@lixom.net>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    To: Richard Henderson <rth@twiddle.net>
    To: Russell King <linux@arm.linux.org.uk>
    To: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 626aa375915d..1a374eab6007 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -78,7 +78,7 @@ void __init n2100_map_io(void)
  * N2100 PCI.
  */
 static int __init
-n2100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+n2100_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
 

commit 6451d7783ba5ff24eb1a544eaa6665b890f30466
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Oct 14 22:21:46 2010 -0400

    arm: remove machine_desc.io_pg_offst and .phys_io
    
    Since we're now using addruart to establish the debug mapping, we can
    remove the io_pg_offst and phys_io members of struct machine_desc.
    
    The various declarations were removed using the following script:
    
      grep -rl MACHINE_START arch/arm | xargs \
      sed -i '/MACHINE_START/,/MACHINE_END/ { /\.\(phys_io\|io_pg_offst\)/d }'
    
    [ Initial patch was from Jeremy Kerr, example script from Russell King ]
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Eric Miao <eric.miao at canonical.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index f108a31afc2b..626aa375915d 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -327,8 +327,6 @@ static void __init n2100_init_machine(void)
 
 MACHINE_START(N2100, "Thecus N2100")
 	/* Maintainer: Lennert Buytenhek <buytenh@wantstofly.org> */
-	.phys_io	= N2100_UART,
-	.io_pg_offst	= ((N2100_UART) >> 18) & 0xfffc,
 	.boot_params	= 0xa0000100,
 	.map_io		= n2100_map_io,
 	.init_irq	= iop32x_init_irq,

commit ac1d426e825ab5778995f2f6f053ca2e6b45c622
Merge: fda0e18c8a7a a3685f00652a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon May 17 17:24:04 2010 +0100

    Merge branch 'devel-stable' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/include/asm/system.h
            arch/arm/mm/Kconfig

commit cc761beda2426cf663a649b905b6643673ff7b30
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Tue Feb 16 22:06:14 2010 +0100

    ARM: 5943/1: iop: n2100: enable serial interrupt
    
    Thecus N2100 has a jumper (J3/J4) to select whether the XINT1 interrupt
    line is connected to the second UHCI controller (position J3) or to
    the serial port UART (position J4). Currently, the kernel is hardcoded
    to assume the J3 position, and the serial port is always being used in
    polling mode.
    
    The patch adds the IRQ autodetection flag for the serial port interrupt,
    and also marks it as shared (as the driver for the second UHCI controller
    will request the interrupt in any case). Now, when the jumper is set to
    the J4 position, the serial port will have an interrupt line, resulting
    in less CPU overhead and faster throughput.
    
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Acked-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 2a5c637639bb..266b1f58a784 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -177,7 +177,7 @@ static struct plat_serial8250_port n2100_serial_port[] = {
 		.mapbase	= N2100_UART,
 		.membase	= (char *)N2100_UART,
 		.irq		= 0,
-		.flags		= UPF_SKIP_TEST,
+		.flags		= UPF_SKIP_TEST | UPF_AUTO_IRQ | UPF_SHARE_IRQ,
 		.iotype		= UPIO_MEM,
 		.regshift	= 0,
 		.uartclk	= 1843200,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 2a5c637639bb..5d99039286eb 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -23,7 +23,6 @@
 #include <linux/pci.h>
 #include <linux/pm.h>
 #include <linux/string.h>
-#include <linux/slab.h>
 #include <linux/serial_core.h>
 #include <linux/serial_8250.h>
 #include <linux/mtd/physmap.h>

commit 980f2296b5a8dfe589f023fd34229dcfdcf280fa
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Thu Oct 29 11:46:55 2009 -0700

    iop: enable generic time
    
    This updates the IOP platform to use the kernel's generic time
    framework. With clockevent support in place, this reduces to
    selecting GENERIC_TIME and removing the platform's private timer
    ->offset() operation (iop_gettimeoffset).
    
    Tested on n2100, compile-tested for all plat-iop machines.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index d2e427899729..2a5c637639bb 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -53,7 +53,6 @@ static void __init n2100_timer_init(void)
 
 static struct sys_timer n2100_timer = {
 	.init		= n2100_timer_init,
-	.offset		= iop_gettimeoffset,
 };
 
 

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 3173f9c5835d..d2e427899729 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -30,8 +30,8 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
+#include <linux/io.h>
 #include <mach/hardware.h>
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index f38dc19bbcc9..3173f9c5835d 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -30,7 +30,7 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>
@@ -40,7 +40,7 @@
 #include <asm/mach-types.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
-#include <asm/arch/time.h>
+#include <mach/time.h>
 
 /*
  * N2100 timer tick configuration.

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 28f164ea4726..f38dc19bbcc9 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -30,7 +30,7 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mach/arch.h>

commit 30be0486791fb637e758c771956c8f73bef3467c
Author: Riku Voipio <riku.voipio@iki.fi>
Date:   Sat May 31 14:45:16 2008 +0100

    leds: Add pca9532 platform data for Thecus N2100
    
    Thecus N2100 has leds and a buzzer attached to a pca9532 controller.  Attach
    the driver to the i2c bus and define the pca9532 pin coniguration for this
    platform in n2100_leds.
    
    With this patch, support for N2100 should be complete in mainline Linux.
    
    Signed-off-by: Riku Voipio <riku.voipio@iki.fi>
    Acked-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 2741063bf361..28f164ea4726 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/f75375s.h>
+#include <linux/leds-pca9532.h>
 #include <linux/delay.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
@@ -206,6 +207,53 @@ static struct f75375s_platform_data n2100_f75375s = {
 	.pwm_enable = { 0, 0 },
 };
 
+static struct pca9532_platform_data n2100_leds = {
+	.leds = {
+	{	.name = "n2100:red:satafail0",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "n2100:red:satafail1",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "n2100:blue:usb",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{ 	.type = PCA9532_TYPE_NONE },
+
+	{ 	.type = PCA9532_TYPE_NONE },
+	{ 	.type = PCA9532_TYPE_NONE },
+	{ 	.type = PCA9532_TYPE_NONE },
+	{	.name = "n2100:red:usb",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+
+	{	.type = PCA9532_TYPE_NONE }, /* power OFF gpio */
+	{	.type = PCA9532_TYPE_NONE }, /* reset gpio */
+	{	.type = PCA9532_TYPE_NONE },
+	{	.type = PCA9532_TYPE_NONE },
+
+	{	.type = PCA9532_TYPE_NONE },
+	{	.name = "n2100:orange:system",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "n2100:red:system",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "N2100 beeper"  ,
+		.state =  PCA9532_OFF,
+		.type = PCA9532_TYPE_N2100_BEEP,
+	},
+	},
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+
 static struct i2c_board_info __initdata n2100_i2c_devices[] = {
 	{
 		I2C_BOARD_INFO("rs5c372b", 0x32),
@@ -214,6 +262,10 @@ static struct i2c_board_info __initdata n2100_i2c_devices[] = {
 		I2C_BOARD_INFO("f75375", 0x2e),
 		.platform_data = &n2100_f75375s,
 	},
+	{
+		I2C_BOARD_INFO("pca9532", 0x60),
+		.platform_data = &n2100_leds,
+	},
 };
 
 /*

commit 3760f736716f74bdc62a4ba5406934338da93eb2
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Apr 29 23:11:40 2008 +0200

    i2c: Convert most new-style drivers to use module aliasing
    
    Based on earlier work by Jon Smirl and Jochen Friedrich.
    
    Update most new-style i2c drivers to use standard module aliasing
    instead of the old driver_name/type driver matching scheme. I've
    left the video drivers apart (except for SoC camera drivers) as
    they're a bit more diffcult to deal with, they'll have their own
    patch later.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Jon Smirl <jonsmirl@gmail.com>
    Cc: Jochen Friedrich <jochen@scram.de>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index bc91d6e66bc4..2741063bf361 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -208,12 +208,10 @@ static struct f75375s_platform_data n2100_f75375s = {
 
 static struct i2c_board_info __initdata n2100_i2c_devices[] = {
 	{
-		I2C_BOARD_INFO("rtc-rs5c372", 0x32),
-		.type = "rs5c372b",
+		I2C_BOARD_INFO("rs5c372b", 0x32),
 	},
 	{
 		I2C_BOARD_INFO("f75375", 0x2e),
-		.type = "f75375",
 		.platform_data = &n2100_f75375s,
 	},
 };

commit 9aa69338924266ca0b1aceb0ab943e8842449b0a
Author: Riku Voipio <riku.voipio@movial.fi>
Date:   Tue Oct 16 13:08:57 2007 +0300

    hwmon: (f75375s) On n2100 systems, set fans to full speed on boot
    
    On thecus n2100, the bootloader does not setup fans to run. In order
    to protect the user from frying their gear, start up fans on boot.
    
    Signed-off-by: Riku Voipio <riku.voipio@movial.fi>
    Acked-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 1873bd8cd1b2..bc91d6e66bc4 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -16,6 +16,7 @@
 
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/f75375s.h>
 #include <linux/delay.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
@@ -200,11 +201,21 @@ static struct platform_device n2100_serial_device = {
 	.resource	= &n2100_uart_resource,
 };
 
+static struct f75375s_platform_data n2100_f75375s = {
+	.pwm		= { 255, 255 },
+	.pwm_enable = { 0, 0 },
+};
+
 static struct i2c_board_info __initdata n2100_i2c_devices[] = {
 	{
 		I2C_BOARD_INFO("rtc-rs5c372", 0x32),
 		.type = "rs5c372b",
 	},
+	{
+		I2C_BOARD_INFO("f75375", 0x2e),
+		.type = "f75375",
+		.platform_data = &n2100_f75375s,
+	},
 };
 
 /*

commit c00593f6f816e5cfa6d193a2561ca77541f71424
Author: Martin Michlmayr <tbm@cyrius.com>
Date:   Tue Jul 17 04:04:57 2007 -0700

    Thecus N2100: register rtc-rs5c372 i2c device
    
    Use the new i2c framework to load rtc-rs5c372 for the Thecus N2100.
    
    Signed-off-by: Martin Michlmayr <tbm@cyrius.com>
    Tested-by: Voipio Riku <Riku.Voipio@movial.fi>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 390a97d39e5a..1873bd8cd1b2 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -25,6 +25,7 @@
 #include <linux/serial_core.h>
 #include <linux/serial_8250.h>
 #include <linux/mtd/physmap.h>
+#include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
 #include <asm/hardware.h>
@@ -199,6 +200,12 @@ static struct platform_device n2100_serial_device = {
 	.resource	= &n2100_uart_resource,
 };
 
+static struct i2c_board_info __initdata n2100_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("rtc-rs5c372", 0x32),
+		.type = "rs5c372b",
+	},
+};
 
 /*
  * Pull PCA9532 GPIO #8 low to power off the machine.
@@ -248,6 +255,9 @@ static void __init n2100_init_machine(void)
 	platform_device_register(&iop3xx_dma_0_channel);
 	platform_device_register(&iop3xx_dma_1_channel);
 
+	i2c_register_board_info(0, n2100_i2c_devices,
+		ARRAY_SIZE(n2100_i2c_devices));
+
 	pm_power_off = n2100_power_off;
 
 	init_timer(&power_button_poll_timer);

commit 2492c845189a961a92d8537a44d233e8e1e45c6d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 2 13:52:31 2007 -0700

    iop3xx: surface the iop3xx DMA and AAU units to the iop-adma driver
    
    Adds the platform device definitions and the architecture specific support
    routines (i.e. register initialization and descriptor formats) for the
    iop-adma driver.
    
    Changelog:
    * add support for > 1k zero sum buffer sizes
    * added dma/aau platform devices to iq80321 and iq80332 setup
    * fixed the calculation in iop_desc_is_aligned
    * support xor buffer sizes larger than 16MB
    * fix places where software descriptors are assumed to be contiguous, only
      hardware descriptors are contiguous for up to a PAGE_SIZE buffer size
    * convert to async_tx
    * add interrupt support
    * add platform devices for 80219 boards
    * do not call platform register macros in driver code
    * remove switch() statements for compatible register offsets/layouts
    * change over to bitmap based capabilities
    * remove unnecessary ARM assembly statement
    * checkpatch.pl fixes
    * gpl v2 only correction
    * phys move to dma_async_tx_descriptor
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index d55005d64781..390a97d39e5a 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -245,6 +245,8 @@ static void __init n2100_init_machine(void)
 	platform_device_register(&iop3xx_i2c0_device);
 	platform_device_register(&n2100_flash_device);
 	platform_device_register(&n2100_serial_device);
+	platform_device_register(&iop3xx_dma_0_channel);
+	platform_device_register(&iop3xx_dma_1_channel);
 
 	pm_power_off = n2100_power_off;
 

commit d73d8011779292788def2cd2520d6f39d9b406de
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 15 01:03:36 2007 +0100

    [ARM] 4383/1: iop: fix usage of '__init' and 'inline' in iop files
    
    WARNING: arch/arm/mach-iop13xx/built-in.o - Section mismatch: reference to
    .init.text:iop13xx_pcie_map_irq from .text between 'iop13xx_pci_setup' (at
    offset 0x7fc) and 'iop13xx_map_pci_memory'
    
    While fixing this warning I also recalled Adrian Bunk's recommendation to
    not use inline in .c files, as 'iop13xx_map_pci_memory' is needlessly
    inlined.
    
    Removing 'inline' uncovered some dead code so that is cleaned up as well.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 5f07344d96f3..d55005d64781 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -76,7 +76,7 @@ void __init n2100_map_io(void)
 /*
  * N2100 PCI.
  */
-static inline int __init
+static int __init
 n2100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;

commit e80a0e6e7ccdf64575d4384cb4172860422f5b81
Merge: 3b0eb4a195a1 3668b45d46f7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Feb 20 10:52:01 2007 +0000

    [ARM] Merge remaining IOP code
    
    Conflicts:
            include/asm-arm/arch-at91rm9200/entry-macro.S
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 66822b2eef8de9fe3ec9fa837386817565dbe690
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Feb 8 01:03:17 2007 +0100

    [ARM] 4058/2: iop32x: set ->broken_parity_status on n2100 onboard r8169 ports
    
    On the n2100, both onboard r8169 ports exhibit PCI parity problems.
    Set the ->broken_parity_status flag for both ports so that the r8169
    drivers knows it should ignore error interrupts.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 2499a7707e3c..966aa51aee09 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -120,6 +120,20 @@ static struct hw_pci n2100_pci __initdata = {
 	.map_irq	= n2100_pci_map_irq,
 };
 
+/*
+ * Both r8169 chips on the n2100 exhibit PCI parity problems.  Set
+ * the ->broken_parity_status flag for both ports so that the r8169
+ * driver knows it should ignore error interrupts.
+ */
+static void n2100_fixup_r8169(struct pci_dev *dev)
+{
+	if (dev->bus->number == 0 &&
+	    (dev->devfn == PCI_DEVFN(1, 0) ||
+	     dev->devfn == PCI_DEVFN(2, 0)))
+		dev->broken_parity_status = 1;
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_REALTEK, PCI_ANY_ID, n2100_fixup_r8169);
+
 static int __init n2100_pci_init(void)
 {
 	if (machine_is_n2100())

commit 3668b45d46f777b0773ef5ff49531c1144efb6dd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Feb 13 17:13:34 2007 +0100

    [ARM] 4187/1: iop: unify time implementation across iop32x, iop33x, and iop13xx
    
    * architecture specific details are handled in asm/arch/time.h
    * ARCH_IOP13XX now selects PLAT_IOP
    * as suggested by Lennert use ifdef CONFIG_XSCALE to skip the cp_wait on
    XSC3
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 2499a7707e3c..92fa0c55443e 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -37,6 +37,7 @@
 #include <asm/mach-types.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
+#include <asm/arch/time.h>
 
 /*
  * N2100 timer tick configuration.
@@ -44,12 +45,12 @@
 static void __init n2100_timer_init(void)
 {
 	/* 33.000 MHz crystal.  */
-	iop3xx_init_time(198000000);
+	iop_init_time(198000000);
 }
 
 static struct sys_timer n2100_timer = {
 	.init		= n2100_timer_init,
-	.offset		= iop3xx_gettimeoffset,
+	.offset		= iop_gettimeoffset,
 };
 
 

commit 811c9a4b618ffc7de097490f8dc61b43b8464b9c
Author: Lennert Buytenhek <buytenh@org.rmk.(none)>
Date:   Sun Oct 29 14:15:10 2006 +0100

    [ARM] 3913/1: n2100: fix IRQ routing for second ethernet port
    
    The second ethernet port on the Thecus n2100 was incorrectly assigned
    to XINT1 instead of the correct XINT3 (PCI INTB instead of INTD), which
    caused that port to be non-functional.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index a2c94a47b2b2..2499a7707e3c 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -85,7 +85,7 @@ n2100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 		irq = IRQ_IOP32X_XINT0;
 	} else if (PCI_SLOT(dev->devfn) == 2) {
 		/* RTL8110SB #2 */
-		irq = IRQ_IOP32X_XINT1;
+		irq = IRQ_IOP32X_XINT3;
 	} else if (PCI_SLOT(dev->devfn) == 3) {
 		/* Sil3512 */
 		irq = IRQ_IOP32X_XINT2;

commit e60d07b6cd38a7afb85f2cf51aebcb3359b63819
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Sep 21 02:42:12 2006 +0100

    [ARM] 3850/1: iop3xx: add thecus n2100 support
    
    Add support for the Thecus n2100 (80219-based.)
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
new file mode 100644
index 000000000000..a2c94a47b2b2
--- /dev/null
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -0,0 +1,251 @@
+/*
+ * arch/arm/mach-iop32x/n2100.c
+ *
+ * Board support code for the Thecus N2100 platform.
+ *
+ * Author: Rory Bolt <rorybolt@pacbell.net>
+ * Copyright (C) 2002 Rory Bolt
+ * Copyright 2003 (c) MontaVista, Software, Inc.
+ * Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/pci.h>
+#include <asm/mach/time.h>
+#include <asm/mach-types.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+/*
+ * N2100 timer tick configuration.
+ */
+static void __init n2100_timer_init(void)
+{
+	/* 33.000 MHz crystal.  */
+	iop3xx_init_time(198000000);
+}
+
+static struct sys_timer n2100_timer = {
+	.init		= n2100_timer_init,
+	.offset		= iop3xx_gettimeoffset,
+};
+
+
+/*
+ * N2100 I/O.
+ */
+static struct map_desc n2100_io_desc[] __initdata = {
+	{	/* on-board devices */
+		.virtual	= N2100_UART,
+		.pfn		= __phys_to_pfn(N2100_UART),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	},
+};
+
+void __init n2100_map_io(void)
+{
+	iop3xx_map_io();
+	iotable_init(n2100_io_desc, ARRAY_SIZE(n2100_io_desc));
+}
+
+
+/*
+ * N2100 PCI.
+ */
+static inline int __init
+n2100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	if (PCI_SLOT(dev->devfn) == 1) {
+		/* RTL8110SB #1 */
+		irq = IRQ_IOP32X_XINT0;
+	} else if (PCI_SLOT(dev->devfn) == 2) {
+		/* RTL8110SB #2 */
+		irq = IRQ_IOP32X_XINT1;
+	} else if (PCI_SLOT(dev->devfn) == 3) {
+		/* Sil3512 */
+		irq = IRQ_IOP32X_XINT2;
+	} else if (PCI_SLOT(dev->devfn) == 4 && pin == 1) {
+		/* VT6212 INTA */
+		irq = IRQ_IOP32X_XINT1;
+	} else if (PCI_SLOT(dev->devfn) == 4 && pin == 2) {
+		/* VT6212 INTB */
+		irq = IRQ_IOP32X_XINT0;
+	} else if (PCI_SLOT(dev->devfn) == 4 && pin == 3) {
+		/* VT6212 INTC */
+		irq = IRQ_IOP32X_XINT2;
+	} else if (PCI_SLOT(dev->devfn) == 5) {
+		/* Mini-PCI slot */
+		irq = IRQ_IOP32X_XINT3;
+	} else {
+		printk(KERN_ERR "n2100_pci_map_irq() called for unknown "
+			"device PCI:%d:%d:%d\n", dev->bus->number,
+			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+		irq = -1;
+	}
+
+	return irq;
+}
+
+static struct hw_pci n2100_pci __initdata = {
+	.swizzle	= pci_std_swizzle,
+	.nr_controllers = 1,
+	.setup		= iop3xx_pci_setup,
+	.preinit	= iop3xx_pci_preinit,
+	.scan		= iop3xx_pci_scan_bus,
+	.map_irq	= n2100_pci_map_irq,
+};
+
+static int __init n2100_pci_init(void)
+{
+	if (machine_is_n2100())
+		pci_common_init(&n2100_pci);
+
+	return 0;
+}
+
+subsys_initcall(n2100_pci_init);
+
+
+/*
+ * N2100 machine initialisation.
+ */
+static struct physmap_flash_data n2100_flash_data = {
+	.width		= 2,
+};
+
+static struct resource n2100_flash_resource = {
+	.start		= 0xf0000000,
+	.end		= 0xf0ffffff,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device n2100_flash_device = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &n2100_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &n2100_flash_resource,
+};
+
+
+static struct plat_serial8250_port n2100_serial_port[] = {
+	{
+		.mapbase	= N2100_UART,
+		.membase	= (char *)N2100_UART,
+		.irq		= 0,
+		.flags		= UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 1843200,
+	},
+	{ },
+};
+
+static struct resource n2100_uart_resource = {
+	.start		= N2100_UART,
+	.end		= N2100_UART + 7,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device n2100_serial_device = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_PLATFORM,
+	.dev		= {
+		.platform_data		= n2100_serial_port,
+	},
+	.num_resources	= 1,
+	.resource	= &n2100_uart_resource,
+};
+
+
+/*
+ * Pull PCA9532 GPIO #8 low to power off the machine.
+ */
+static void n2100_power_off(void)
+{
+	local_irq_disable();
+
+	/* Start condition, I2C address of PCA9532, write transaction.  */
+	*IOP3XX_IDBR0 = 0xc0;
+	*IOP3XX_ICR0 = 0xe9;
+	mdelay(1);
+
+	/* Write address 0x08.  */
+	*IOP3XX_IDBR0 = 0x08;
+	*IOP3XX_ICR0 = 0xe8;
+	mdelay(1);
+
+	/* Write data 0x01, stop condition.  */
+	*IOP3XX_IDBR0 = 0x01;
+	*IOP3XX_ICR0 = 0xea;
+
+	while (1)
+		;
+}
+
+
+static struct timer_list power_button_poll_timer;
+
+static void power_button_poll(unsigned long dummy)
+{
+	if (gpio_line_get(N2100_POWER_BUTTON) == 0) {
+		ctrl_alt_del();
+		return;
+	}
+
+	power_button_poll_timer.expires = jiffies + (HZ / 10);
+	add_timer(&power_button_poll_timer);
+}
+
+
+static void __init n2100_init_machine(void)
+{
+	platform_device_register(&iop3xx_i2c0_device);
+	platform_device_register(&n2100_flash_device);
+	platform_device_register(&n2100_serial_device);
+
+	pm_power_off = n2100_power_off;
+
+	init_timer(&power_button_poll_timer);
+	power_button_poll_timer.function = power_button_poll;
+	power_button_poll_timer.expires = jiffies + (HZ / 10);
+	add_timer(&power_button_poll_timer);
+}
+
+MACHINE_START(N2100, "Thecus N2100")
+	/* Maintainer: Lennert Buytenhek <buytenh@wantstofly.org> */
+	.phys_io	= N2100_UART,
+	.io_pg_offst	= ((N2100_UART) >> 18) & 0xfffc,
+	.boot_params	= 0xa0000100,
+	.map_io		= n2100_map_io,
+	.init_irq	= iop32x_init_irq,
+	.timer		= &n2100_timer,
+	.init_machine	= n2100_init_machine,
+MACHINE_END
