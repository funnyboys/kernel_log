commit 9b06fc39084e161da84a399b6b5dc524e673f51e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 29 15:58:10 2020 -0500

    ARM: vexpress: Move vexpress_flags_set() into arch code
    
    vexpress_flags_set() is only used by the platform SMP related code and
    has nothing to do with the vexpress-sysreg MFD driver other than both
    access the same h/w block. It's also only needed for 32-bit systems and
    must be built-in for them. Let's move vexpress_flags_set() closer to
    where it is being used. This will allow for vexpress-sysreg to be built
    as a module.
    
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 95886b3bb9dd..ffe7c7a85ae9 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -1,8 +1,31 @@
 // SPDX-License-Identifier: GPL-2.0
+#include <linux/of.h>
+#include <linux/of_address.h>
 #include <asm/mach/arch.h>
 
 #include "core.h"
 
+#define SYS_FLAGSSET		0x030
+#define SYS_FLAGSCLR		0x034
+
+void vexpress_flags_set(u32 data)
+{
+	static void __iomem *base;
+
+	if (!base) {
+		struct device_node *node = of_find_compatible_node(NULL, NULL,
+				"arm,vexpress-sysreg");
+
+		base = of_iomap(node, 0);
+	}
+
+	if (WARN_ON(!base))
+		return;
+
+	writel(~0, base + SYS_FLAGSCLR);
+	writel(data, base + SYS_FLAGSSET);
+}
+
 static const char * const v2m_dt_match[] __initconst = {
 	"arm,vexpress",
 	NULL,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index a0400f4cca89..95886b3bb9dd 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <asm/mach/arch.h>
 
 #include "core.h"

commit 81cc3f868d30884c6f2d2bf5d1861fbeb24ddebd
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Nov 25 18:17:34 2014 +0000

    ARM: vexpress: Remove non-DT code
    
    Now, with the CLCD DT support available, there is no
    more reason to keep the non-DT support for V2P-CA9.
    
    Removed, together with "some" supporting code. It was
    necessary to make PLAT_VERSATILE_SCHED_CLOCK optional
    and selected by the machines still interested in it.
    
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 6ff681a24ba7..a0400f4cca89 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -1,380 +1,7 @@
-/*
- * Versatile Express V2M Motherboard Support
- */
-#include <linux/device.h>
-#include <linux/amba/bus.h>
-#include <linux/amba/mmci.h>
-#include <linux/io.h>
-#include <linux/smp.h>
-#include <linux/init.h>
-#include <linux/of_address.h>
-#include <linux/of_fdt.h>
-#include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/smsc911x.h>
-#include <linux/spinlock.h>
-#include <linux/usb/isp1760.h>
-#include <linux/mtd/physmap.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/vexpress.h>
-#include <linux/clkdev.h>
-
-#include <asm/mach-types.h>
-#include <asm/sizes.h>
 #include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/time.h>
-#include <asm/hardware/arm_timer.h>
-#include <asm/hardware/cache-l2x0.h>
-#include <asm/hardware/timer-sp.h>
-
-#include <mach/ct-ca9x4.h>
-#include <mach/motherboard.h>
-
-#include <plat/sched_clock.h>
-#include <plat/platsmp.h>
 
 #include "core.h"
 
-#define V2M_PA_CS0	0x40000000
-#define V2M_PA_CS1	0x44000000
-#define V2M_PA_CS2	0x48000000
-#define V2M_PA_CS3	0x4c000000
-#define V2M_PA_CS7	0x10000000
-
-static struct map_desc v2m_io_desc[] __initdata = {
-	{
-		.virtual	= V2M_PERIPH,
-		.pfn		= __phys_to_pfn(V2M_PA_CS7),
-		.length		= SZ_128K,
-		.type		= MT_DEVICE,
-	},
-};
-
-static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
-{
-	if (WARN_ON(!base || irq == NO_IRQ))
-		return;
-
-	sp804_clocksource_init(base + TIMER_2_BASE, "v2m-timer1");
-	sp804_clockevents_init(base + TIMER_1_BASE, irq, "v2m-timer0");
-}
-
-
-static struct resource v2m_pcie_i2c_resource = {
-	.start	= V2M_SERIAL_BUS_PCI,
-	.end	= V2M_SERIAL_BUS_PCI + SZ_4K - 1,
-	.flags	= IORESOURCE_MEM,
-};
-
-static struct platform_device v2m_pcie_i2c_device = {
-	.name		= "versatile-i2c",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= &v2m_pcie_i2c_resource,
-};
-
-static struct resource v2m_ddc_i2c_resource = {
-	.start	= V2M_SERIAL_BUS_DVI,
-	.end	= V2M_SERIAL_BUS_DVI + SZ_4K - 1,
-	.flags	= IORESOURCE_MEM,
-};
-
-static struct platform_device v2m_ddc_i2c_device = {
-	.name		= "versatile-i2c",
-	.id		= 1,
-	.num_resources	= 1,
-	.resource	= &v2m_ddc_i2c_resource,
-};
-
-static struct resource v2m_eth_resources[] = {
-	{
-		.start	= V2M_LAN9118,
-		.end	= V2M_LAN9118 + SZ_64K - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_V2M_LAN9118,
-		.end	= IRQ_V2M_LAN9118,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config v2m_eth_config = {
-	.flags		= SMSC911X_USE_32BIT,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device v2m_eth_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.resource	= v2m_eth_resources,
-	.num_resources	= ARRAY_SIZE(v2m_eth_resources),
-	.dev.platform_data = &v2m_eth_config,
-};
-
-static struct regulator_consumer_supply v2m_eth_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct resource v2m_usb_resources[] = {
-	{
-		.start	= V2M_ISP1761,
-		.end	= V2M_ISP1761 + SZ_128K - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_V2M_ISP1761,
-		.end	= IRQ_V2M_ISP1761,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct isp1760_platform_data v2m_usb_config = {
-	.is_isp1761		= true,
-	.bus_width_16		= false,
-	.port1_otg		= true,
-	.analog_oc		= false,
-	.dack_polarity_high	= false,
-	.dreq_polarity_high	= false,
-};
-
-static struct platform_device v2m_usb_device = {
-	.name		= "isp1760",
-	.id		= -1,
-	.resource	= v2m_usb_resources,
-	.num_resources	= ARRAY_SIZE(v2m_usb_resources),
-	.dev.platform_data = &v2m_usb_config,
-};
-
-static struct physmap_flash_data v2m_flash_data = {
-	.width		= 4,
-};
-
-static struct resource v2m_flash_resources[] = {
-	{
-		.start	= V2M_NOR0,
-		.end	= V2M_NOR0 + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= V2M_NOR1,
-		.end	= V2M_NOR1 + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device v2m_flash_device = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.resource	= v2m_flash_resources,
-	.num_resources	= ARRAY_SIZE(v2m_flash_resources),
-	.dev.platform_data = &v2m_flash_data,
-};
-
-static struct pata_platform_info v2m_pata_data = {
-	.ioport_shift	= 2,
-};
-
-static struct resource v2m_pata_resources[] = {
-	{
-		.start	= V2M_CF,
-		.end	= V2M_CF + 0xff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= V2M_CF + 0x100,
-		.end	= V2M_CF + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device v2m_cf_device = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.resource	= v2m_pata_resources,
-	.num_resources	= ARRAY_SIZE(v2m_pata_resources),
-	.dev.platform_data = &v2m_pata_data,
-};
-
-static struct mmci_platform_data v2m_mmci_data = {
-	.ocr_mask	= MMC_VDD_32_33|MMC_VDD_33_34,
-	.status		= vexpress_get_mci_cardin,
-	.gpio_cd	= -1,
-	.gpio_wp	= -1,
-};
-
-static struct resource v2m_sysreg_resources[] = {
-	{
-		.start	= V2M_SYSREGS,
-		.end	= V2M_SYSREGS + 0xfff,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device v2m_sysreg_device = {
-	.name		= "vexpress-sysreg",
-	.id		= -1,
-	.resource	= v2m_sysreg_resources,
-	.num_resources	= ARRAY_SIZE(v2m_sysreg_resources),
-};
-
-static struct platform_device v2m_muxfpga_device = {
-	.name		= "vexpress-muxfpga",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= (struct resource []) {
-		VEXPRESS_RES_FUNC(0, 7),
-	}
-};
-
-static struct platform_device v2m_shutdown_device = {
-	.name		= "vexpress-shutdown",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= (struct resource []) {
-		VEXPRESS_RES_FUNC(0, 8),
-	}
-};
-
-static struct platform_device v2m_reboot_device = {
-	.name		= "vexpress-reboot",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= (struct resource []) {
-		VEXPRESS_RES_FUNC(0, 9),
-	}
-};
-
-static struct platform_device v2m_dvimode_device = {
-	.name		= "vexpress-dvimode",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= (struct resource []) {
-		VEXPRESS_RES_FUNC(0, 11),
-	}
-};
-
-static AMBA_APB_DEVICE(aaci,  "mb:aaci",  0, V2M_AACI, IRQ_V2M_AACI, NULL);
-static AMBA_APB_DEVICE(mmci,  "mb:mmci",  0, V2M_MMCI, IRQ_V2M_MMCI, &v2m_mmci_data);
-static AMBA_APB_DEVICE(kmi0,  "mb:kmi0",  0, V2M_KMI0, IRQ_V2M_KMI0, NULL);
-static AMBA_APB_DEVICE(kmi1,  "mb:kmi1",  0, V2M_KMI1, IRQ_V2M_KMI1, NULL);
-static AMBA_APB_DEVICE(uart0, "mb:uart0", 0, V2M_UART0, IRQ_V2M_UART0, NULL);
-static AMBA_APB_DEVICE(uart1, "mb:uart1", 0, V2M_UART1, IRQ_V2M_UART1, NULL);
-static AMBA_APB_DEVICE(uart2, "mb:uart2", 0, V2M_UART2, IRQ_V2M_UART2, NULL);
-static AMBA_APB_DEVICE(uart3, "mb:uart3", 0, V2M_UART3, IRQ_V2M_UART3, NULL);
-static AMBA_APB_DEVICE(wdt,   "mb:wdt",   0, V2M_WDT, IRQ_V2M_WDT, NULL);
-static AMBA_APB_DEVICE(rtc,   "mb:rtc",   0, V2M_RTC, IRQ_V2M_RTC, NULL);
-
-static struct amba_device *v2m_amba_devs[] __initdata = {
-	&aaci_device,
-	&mmci_device,
-	&kmi0_device,
-	&kmi1_device,
-	&uart0_device,
-	&uart1_device,
-	&uart2_device,
-	&uart3_device,
-	&wdt_device,
-	&rtc_device,
-};
-
-static void __init v2m_timer_init(void)
-{
-	vexpress_clk_init(ioremap(V2M_SYSCTL, SZ_4K));
-	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
-}
-
-static void __init v2m_init_early(void)
-{
-	if (ct_desc->init_early)
-		ct_desc->init_early();
-	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(), 24000000);
-}
-
-struct ct_desc *ct_desc;
-
-static struct ct_desc *ct_descs[] __initdata = {
-#ifdef CONFIG_ARCH_VEXPRESS_CA9X4
-	&ct_ca9x4_desc,
-#endif
-};
-
-static void __init v2m_populate_ct_desc(void)
-{
-	int i;
-	u32 current_tile_id;
-
-	ct_desc = NULL;
-	current_tile_id = vexpress_get_procid(VEXPRESS_SITE_MASTER)
-				& V2M_CT_ID_MASK;
-
-	for (i = 0; i < ARRAY_SIZE(ct_descs) && !ct_desc; ++i)
-		if (ct_descs[i]->id == current_tile_id)
-			ct_desc = ct_descs[i];
-
-	if (!ct_desc)
-		panic("vexpress: this kernel does not support core tile ID 0x%08x when booting via ATAGs.\n"
-		      "You may need a device tree blob or a different kernel to boot on this board.\n",
-		      current_tile_id);
-}
-
-static void __init v2m_map_io(void)
-{
-	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
-	vexpress_sysreg_early_init(ioremap(V2M_SYSREGS, SZ_4K));
-	v2m_populate_ct_desc();
-	ct_desc->map_io();
-}
-
-static void __init v2m_init_irq(void)
-{
-	ct_desc->init_irq();
-}
-
-static void __init v2m_init(void)
-{
-	int i;
-
-	regulator_register_fixed(0, v2m_eth_supplies,
-			ARRAY_SIZE(v2m_eth_supplies));
-
-	platform_device_register(&v2m_sysreg_device);
-	platform_device_register(&v2m_pcie_i2c_device);
-	platform_device_register(&v2m_ddc_i2c_device);
-	platform_device_register(&v2m_flash_device);
-	platform_device_register(&v2m_cf_device);
-	platform_device_register(&v2m_eth_device);
-	platform_device_register(&v2m_usb_device);
-
-	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
-		amba_device_register(v2m_amba_devs[i], &iomem_resource);
-
-	vexpress_syscfg_device_register(&v2m_muxfpga_device);
-	vexpress_syscfg_device_register(&v2m_shutdown_device);
-	vexpress_syscfg_device_register(&v2m_reboot_device);
-	vexpress_syscfg_device_register(&v2m_dvimode_device);
-
-	ct_desc->init_tile();
-}
-
-MACHINE_START(VEXPRESS, "ARM-Versatile Express")
-	.atag_offset	= 0x100,
-	.smp		= smp_ops(vexpress_smp_ops),
-	.map_io		= v2m_map_io,
-	.init_early	= v2m_init_early,
-	.init_irq	= v2m_init_irq,
-	.init_time	= v2m_timer_init,
-	.init_machine	= v2m_init,
-MACHINE_END
-
-static void __init v2m_dt_init(void)
-{
-	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
-}
-
 static const char * const v2m_dt_match[] __initconst = {
 	"arm,vexpress",
 	NULL,
@@ -386,5 +13,4 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.l2c_aux_mask	= 0xfe0fffff,
 	.smp		= smp_ops(vexpress_smp_dt_ops),
 	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
-	.init_machine	= v2m_dt_init,
 MACHINE_END

commit eb3d3ec567e868c8a3bfbfdfc9465ffd52983d11
Merge: c3c55a072039 bd63ce27d9d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 5 15:57:04 2014 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm into next
    
    Pull ARM updates from Russell King:
    
     - Major clean-up of the L2 cache support code.  The existing mess was
       becoming rather unmaintainable through all the additions that others
       have done over time.  This turns it into a much nicer structure, and
       implements a few performance improvements as well.
    
     - Clean up some of the CP15 control register tweaks for alignment
       support, moving some code and data into alignment.c
    
     - DMA properties for ARM, from Santosh and reviewed by DT people.  This
       adds DT properties to specify bus translations we can't discover
       automatically, and to indicate whether devices are coherent.
    
     - Hibernation support for ARM
    
     - Make ftrace work with read-only text in modules
    
     - add suspend support for PJ4B CPUs
    
     - rework interrupt masking for undefined instruction handling, which
       allows us to enable interrupts earlier in the handling of these
       exceptions.
    
     - support for big endian page tables
    
     - fix stacktrace support to exclude stacktrace functions from the
       trace, and add save_stack_trace_regs() implementation so that kprobes
       can record stack traces.
    
     - Add support for the Cortex-A17 CPU.
    
     - Remove last vestiges of ARM710 support.
    
     - Removal of ARM "meminfo" structure, finally converting us solely to
       memblock to handle the early memory initialisation.
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (142 commits)
      ARM: ensure C page table setup code follows assembly code (part II)
      ARM: ensure C page table setup code follows assembly code
      ARM: consolidate last remaining open-coded alignment trap enable
      ARM: remove global cr_no_alignment
      ARM: remove CPU_CP15 conditional from alignment.c
      ARM: remove unused adjust_cr() function
      ARM: move "noalign" command line option to alignment.c
      ARM: provide common method to clear bits in CPU control register
      ARM: 8025/1: Get rid of meminfo
      ARM: 8060/1: mm: allow sub-architectures to override PCI I/O memory type
      ARM: 8066/1: correction for ARM patch 8031/2
      ARM: 8049/1: ftrace/add save_stack_trace_regs() implementation
      ARM: 8065/1: remove last use of CONFIG_CPU_ARM710
      ARM: 8062/1: Modify ldrt fixup handler to re-execute the userspace instruction
      ARM: 8047/1: rwsem: use asm-generic rwsem implementation
      ARM: l2c: trial at enabling some Cortex-A9 optimisations
      ARM: l2c: add warnings for stuff modifying aux_ctrl register values
      ARM: l2c: print a warning with L2C-310 caches if the cache size is modified
      ARM: l2c: remove old .set_debug method
      ARM: l2c: kill L2X0_AUX_CTRL_MASK before anyone else makes use of this
      ...

commit b28dd4ac66de15c48b00184b63180094f2f7fb45
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Apr 28 15:43:12 2014 +0100

    ARM: l2c: vexpress: convert to generic l2c OF initialisation
    
    Remove the explicit call to l2x0_of_init(), converting to the generic
    infrastructure instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 4f8b8cb17ff5..b2fea70d412d 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -432,7 +432,6 @@ static const struct of_device_id v2m_dt_bus_match[] __initconst = {
 
 static void __init v2m_dt_init(void)
 {
-	l2x0_of_init(0x00400000, 0xfe0fffff);
 	of_platform_populate(NULL, v2m_dt_bus_match, NULL, NULL);
 }
 
@@ -443,6 +442,8 @@ static const char * const v2m_dt_match[] __initconst = {
 
 DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.dt_compat	= v2m_dt_match,
+	.l2c_aux_val	= 0x00400000,
+	.l2c_aux_mask	= 0xfe0fffff,
 	.smp		= smp_ops(vexpress_smp_ops),
 	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
 	.map_io		= v2m_dt_map_io,

commit 6b2c31c71d6fa8896c5f3f2354d790a5bd3f0a1e
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Feb 6 14:33:44 2014 +0000

    ARM: vexpress: move HBI check to sysreg driver
    
    The last reason for static memory mapping is the HBI (board
    identification number) check early in the machine code.
    
    Moving the check to the sysreg driver makes it possible to
    completely remove the early mapping and init functions.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index d8b419bcf3c3..38f4f6f37770 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -370,53 +370,6 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_machine	= v2m_init,
 MACHINE_END
 
-static struct map_desc v2m_rs1_io_desc __initdata = {
-	.virtual	= V2M_PERIPH,
-	.pfn		= __phys_to_pfn(0x1c000000),
-	.length		= SZ_2M,
-	.type		= MT_DEVICE,
-};
-
-static int __init v2m_dt_scan_memory_map(unsigned long node, const char *uname,
-		int depth, void *data)
-{
-	const char **map = data;
-
-	if (strcmp(uname, "motherboard") != 0)
-		return 0;
-
-	*map = of_get_flat_dt_prop(node, "arm,v2m-memory-map", NULL);
-
-	return 1;
-}
-
-void __init v2m_dt_map_io(void)
-{
-	const char *map = NULL;
-
-	of_scan_flat_dt(v2m_dt_scan_memory_map, &map);
-
-	if (map && strcmp(map, "rs1") == 0)
-		iotable_init(&v2m_rs1_io_desc, 1);
-	else
-		iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
-}
-
-void __init v2m_dt_init_early(void)
-{
-	u32 dt_hbi;
-
-	/* Confirm board type against DT property, if available */
-	if (of_property_read_u32(of_allnodes, "arm,hbi", &dt_hbi) == 0) {
-		u32 hbi = vexpress_get_hbi(VEXPRESS_SITE_MASTER);
-
-		if (WARN_ON(dt_hbi != hbi))
-			pr_warning("vexpress: DT HBI (%x) is not matching "
-					"hardware (%x)!\n", dt_hbi, hbi);
-	}
-}
-
-
 static void __init v2m_dt_init(void)
 {
 	l2x0_of_init(0x00400000, 0xfe0fffff);
@@ -432,7 +385,5 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.dt_compat	= v2m_dt_match,
 	.smp		= smp_ops(vexpress_smp_dt_ops),
 	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
-	.map_io		= v2m_dt_map_io,
-	.init_early	= v2m_dt_init_early,
 	.init_machine	= v2m_dt_init,
 MACHINE_END

commit d2606f81d5632f873884f1988fb2e9d3f057fcb6
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Sep 17 18:30:58 2013 +0100

    ARM: vexpress: Simplify SMP operations for DT-powered system
    
    As all cores must be properly described in the Device Tree,
    there is no point in getting their numbers from SCU on
    A5/A9 platforms. This significantly simplifies the code,
    removing the need for flat-tree scanning and early static
    mapping.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index d8a9fd7a695d..d8b419bcf3c3 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -400,10 +400,6 @@ void __init v2m_dt_map_io(void)
 		iotable_init(&v2m_rs1_io_desc, 1);
 	else
 		iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
-
-#if defined(CONFIG_SMP)
-	vexpress_dt_smp_map_io();
-#endif
 }
 
 void __init v2m_dt_init_early(void)
@@ -434,7 +430,7 @@ static const char * const v2m_dt_match[] __initconst = {
 
 DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.dt_compat	= v2m_dt_match,
-	.smp		= smp_ops(vexpress_smp_ops),
+	.smp		= smp_ops(vexpress_smp_dt_ops),
 	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,

commit 220e2a8d22cd57d5ec8111465923c6c25691394d
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Wed Apr 16 18:22:59 2014 +0100

    clocksource: Sched clock source for Versatile Express
    
    This patch adds a trival sched clock source using free
    running, 24MHz clocked counter present in the ARM Ltd.
    reference platforms (Versatile, RealView, Versatile
    Express) System Registers block.
    
    This code replaces the call in the VE machine code.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 90f04c9b11d2..d8a9fd7a695d 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -418,8 +418,6 @@ void __init v2m_dt_init_early(void)
 			pr_warning("vexpress: DT HBI (%x) is not matching "
 					"hardware (%x)!\n", dt_hbi, hbi);
 	}
-
-	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(), 24000000);
 }
 
 

commit 974cc7b93441a0e78f030495436d1be7eb7c208d
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Wed Apr 23 10:49:31 2014 +0100

    mfd: vexpress: Define the device as MFD cells
    
    This patch - finally, after over 6 months! :-( - addresses
    Samuel's request to split the vexpress-sysreg driver into
    smaller portions and define the device in a form of MFD
    cells:
    
    * LEDs code has been completely removed and replaced with
      "gpio-leds" nodes in the tree (referencing dedicated
      GPIO subnodes in sysreg - bindings documentation updated);
      this also better fits the reality as some variants of the
      motherboard don't have all the LEDs populated
    
    * syscfg bridge code has been extracted into a separate
      driver (placed in drivers/misc for no better place)
    
    * all the ID & MISC registers are defined as sysconf
      making them available for other drivers should they need
      to use them (and also to the user via /sys/kernel/debug/regmap
      which can be helpful in platform debugging)
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index ac95220a5019..90f04c9b11d2 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -201,8 +201,9 @@ static struct platform_device v2m_cf_device = {
 
 static struct mmci_platform_data v2m_mmci_data = {
 	.ocr_mask	= MMC_VDD_32_33|MMC_VDD_33_34,
-	.gpio_wp	= VEXPRESS_GPIO_MMC_WPROT,
-	.gpio_cd	= VEXPRESS_GPIO_MMC_CARDIN,
+	.status		= vexpress_get_mci_cardin,
+	.gpio_cd	= -1,
+	.gpio_wp	= -1,
 };
 
 static struct resource v2m_sysreg_resources[] = {
@@ -351,10 +352,10 @@ static void __init v2m_init(void)
 	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
 		amba_device_register(v2m_amba_devs[i], &iomem_resource);
 
-	vexpress_sysreg_config_device_register(&v2m_muxfpga_device);
-	vexpress_sysreg_config_device_register(&v2m_shutdown_device);
-	vexpress_sysreg_config_device_register(&v2m_reboot_device);
-	vexpress_sysreg_config_device_register(&v2m_dvimode_device);
+	vexpress_syscfg_device_register(&v2m_muxfpga_device);
+	vexpress_syscfg_device_register(&v2m_shutdown_device);
+	vexpress_syscfg_device_register(&v2m_reboot_device);
+	vexpress_syscfg_device_register(&v2m_dvimode_device);
 
 	ct_desc->init_tile();
 }
@@ -409,8 +410,6 @@ void __init v2m_dt_init_early(void)
 {
 	u32 dt_hbi;
 
-	vexpress_sysreg_of_early_init();
-
 	/* Confirm board type against DT property, if available */
 	if (of_property_read_u32(of_allnodes, "arm,hbi", &dt_hbi) == 0) {
 		u32 hbi = vexpress_get_hbi(VEXPRESS_SITE_MASTER);

commit 3b9334ac835bb431e2186645230c9f1eb94b5d49
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Wed Apr 30 16:46:29 2014 +0100

    mfd: vexpress: Convert custom func API to regmap
    
    Components of the Versatile Express platform (configuration
    microcontrollers on motherboard and daughterboards in particular)
    talk to each other over a custom configuration bus. They
    provide miscellaneous functions (from clock generator control
    to energy sensors) which are represented as platform devices
    (and Device Tree nodes). The transactions on the bus can
    be generated by different "bridges" in the system, some
    of which are universal for the whole platform (for the price
    of high transfer latencies), others restricted to a subsystem
    (but much faster).
    
    Until now drivers for such functions were using custom "func"
    API, which is being replaced in this patch by regmap calls.
    This required:
    
    * a rework (and move to drivers/bus directory, as suggested
      by Samuel and Arnd) of the config bus core, which is much
      simpler now and uses device model infrastructure (class)
      to keep track of the bridges; non-DT case (soon to be
      retired anyway) is simply covered by a special device
      registration function
    
    * the new config-bus driver also takes over device population,
      so there is no need for special matching table for
      of_platform_populate nor "simple-bus" hack in the arm64
      model dtsi file (relevant bindings documentation has
      been updated); this allows all the vexpress devices
      fit into normal device model, making it possible
      to remove plenty of early inits and other hacks in
      the near future
    
    * adaptation of the syscfg bridge implementation in the
      sysreg driver, again making it much simpler; there is
      a special case of the "energy" function spanning two
      registers, where they should be both defined in the tree
      now, but backward compatibility is maintained in the code
    
    * modification of the relevant drivers:
    
      * hwmon - just a straight-forward API change
      * power/reset driver - API change
      * regulator - API change plus error handling
        simplification
      * osc clock driver - this one required larger rework
        in order to turn in into a standard platform driver
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 4f8b8cb17ff5..ac95220a5019 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -340,11 +340,6 @@ static void __init v2m_init(void)
 	regulator_register_fixed(0, v2m_eth_supplies,
 			ARRAY_SIZE(v2m_eth_supplies));
 
-	platform_device_register(&v2m_muxfpga_device);
-	platform_device_register(&v2m_shutdown_device);
-	platform_device_register(&v2m_reboot_device);
-	platform_device_register(&v2m_dvimode_device);
-
 	platform_device_register(&v2m_sysreg_device);
 	platform_device_register(&v2m_pcie_i2c_device);
 	platform_device_register(&v2m_ddc_i2c_device);
@@ -356,6 +351,11 @@ static void __init v2m_init(void)
 	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
 		amba_device_register(v2m_amba_devs[i], &iomem_resource);
 
+	vexpress_sysreg_config_device_register(&v2m_muxfpga_device);
+	vexpress_sysreg_config_device_register(&v2m_shutdown_device);
+	vexpress_sysreg_config_device_register(&v2m_reboot_device);
+	vexpress_sysreg_config_device_register(&v2m_dvimode_device);
+
 	ct_desc->init_tile();
 }
 
@@ -423,17 +423,11 @@ void __init v2m_dt_init_early(void)
 	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(), 24000000);
 }
 
-static const struct of_device_id v2m_dt_bus_match[] __initconst = {
-	{ .compatible = "simple-bus", },
-	{ .compatible = "arm,amba-bus", },
-	{ .compatible = "arm,vexpress,config-bus", },
-	{}
-};
 
 static void __init v2m_dt_init(void)
 {
 	l2x0_of_init(0x00400000, 0xfe0fffff);
-	of_platform_populate(NULL, v2m_dt_bus_match, NULL, NULL);
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
 }
 
 static const char * const v2m_dt_match[] __initconst = {

commit 56e89cf55c47288f906bd769cb3d6d4736db548a
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Tue Aug 27 15:34:12 2013 +0200

    ARM: vexpress: remove custom .init_time hook
    
    With arch/arm calling of_clk_init(NULL) from time_init(), we can now
    remove custom .init_time hooks. The call to versatile_sched_clock_init
    is moved to .init_early instead, were it is also for non-DT boards.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Jon Medhurst (Tixy) <tixy@linaro.org>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 95a469e23e37..4f8b8cb17ff5 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -1,12 +1,10 @@
 /*
  * Versatile Express V2M Motherboard Support
  */
-#include <linux/clocksource.h>
 #include <linux/device.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/mmci.h>
 #include <linux/io.h>
-#include <linux/clocksource.h>
 #include <linux/smp.h>
 #include <linux/init.h>
 #include <linux/of_address.h>
@@ -22,7 +20,6 @@
 #include <linux/regulator/fixed.h>
 #include <linux/regulator/machine.h>
 #include <linux/vexpress.h>
-#include <linux/clk-provider.h>
 #include <linux/clkdev.h>
 
 #include <asm/mach-types.h>
@@ -422,16 +419,8 @@ void __init v2m_dt_init_early(void)
 			pr_warning("vexpress: DT HBI (%x) is not matching "
 					"hardware (%x)!\n", dt_hbi, hbi);
 	}
-}
-
-static void __init v2m_dt_timer_init(void)
-{
-	of_clk_init(NULL);
 
-	clocksource_of_init();
-
-	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),
-				24000000);
+	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(), 24000000);
 }
 
 static const struct of_device_id v2m_dt_bus_match[] __initconst = {
@@ -458,6 +447,5 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
-	.init_time	= v2m_dt_timer_init,
 	.init_machine	= v2m_dt_init,
 MACHINE_END

commit 3883cbb6c1bda013a3ce2dbdab7dc97c52e4a232
Merge: d2033f2c1d1d 1eb92b24e243
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 2 13:43:38 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC specific changes from Arnd Bergmann:
     "These changes are all to SoC-specific code, a total of 33 branches on
      17 platforms were pulled into this.  Like last time, Renesas sh-mobile
      is now the platform with the most changes, followed by OMAP and
      EXYNOS.
    
      Two new platforms, TI Keystone and Rockchips RK3xxx are added in this
      branch, both containing almost no platform specific code at all, since
      they are using generic subsystem interfaces for clocks, pinctrl,
      interrupts etc.  The device drivers are getting merged through the
      respective subsystem maintainer trees.
    
      One more SoC (u300) is now multiplatform capable and several others
      (shmobile, exynos, msm, integrator, kirkwood, clps711x) are moving
      towards that goal with this series but need more work.
    
      Also noteworthy is the work on PCI here, which is traditionally part
      of the SoC specific code.  With the changes done by Thomas Petazzoni,
      we can now more easily have PCI host controller drivers as loadable
      modules and keep them separate from the platform code in
      drivers/pci/host.  This has already led to the discovery that three
      platforms (exynos, spear and imx) are actually using an identical PCIe
      host controller and will be able to share a driver once support for
      spear and imx is added."
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (480 commits)
      ARM: integrator: let pciv3 use mem/premem from device tree
      ARM: integrator: set local side PCI addresses right
      ARM: dts: Add pcie controller node for exynos5440-ssdk5440
      ARM: dts: Add pcie controller node for Samsung EXYNOS5440 SoC
      ARM: EXYNOS: Enable PCIe support for Exynos5440
      pci: Add PCIe driver for Samsung Exynos
      ARM: OMAP5: voltagedomain data: remove temporary OMAP4 voltage data
      ARM: keystone: Move CPU bringup code to dedicated asm file
      ARM: multiplatform: always pick one CPU type
      ARM: imx: select syscon for IMX6SL
      ARM: keystone: select ARM_ERRATA_798181 only for SMP
      ARM: imx: Synertronixx scb9328 needs to select SOC_IMX1
      ARM: OMAP2+: AM43x: resolve SMP related build error
      dmaengine: edma: enable build for AM33XX
      ARM: edma: Add EDMA crossbar event mux support
      ARM: edma: Add DT and runtime PM support to the private EDMA API
      dmaengine: edma: Add TI EDMA device tree binding
      arm: add basic support for Rockchip RK3066a boards
      arm: add debug uarts for rockchip rk29xx and rk3xxx series
      arm: Add basic clocks for Rockchip rk3066a SoCs
      ...

commit 033a899c9b06e7e4f6733a637fee34c632ca2d47
Author: Jon Medhurst <tixy@linaro.org>
Date:   Wed Jan 30 09:12:55 2013 +0000

    ARM: vexpress: Select multi-cluster SMP operation if required
    
    Signed-off-by: Jon Medhurst <tixy@linaro.org>
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 8802030df98d..b0eccf7e06ec 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -456,6 +456,7 @@ static const char * const v2m_dt_match[] __initconst = {
 DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.dt_compat	= v2m_dt_match,
 	.smp		= smp_ops(vexpress_smp_ops),
+	.smp_init	= smp_init_ops(vexpress_smp_init_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
 	.init_irq	= irqchip_init,

commit 4415788803bc3ec75a9fe88da09f8035af273dc9
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Apr 18 22:08:50 2013 +0200

    ARM: vexpress: Remove init_irq declaration in machine description
    
    Commit ebafed7a ("ARM: irq: Call irqchip_init if no init_irq function is
    specified") removed the need to explictly setup the init_irq field in
    the machine description when using only irqchip_init. Remove that
    declaration for vexpress as well.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 8802030df98d..d6016970e2fe 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -9,7 +9,6 @@
 #include <linux/clocksource.h>
 #include <linux/smp.h>
 #include <linux/init.h>
-#include <linux/irqchip.h>
 #include <linux/of_address.h>
 #include <linux/of_fdt.h>
 #include <linux/of_irq.h>
@@ -458,7 +457,6 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.smp		= smp_ops(vexpress_smp_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
-	.init_irq	= irqchip_init,
 	.init_time	= v2m_dt_timer_init,
 	.init_machine	= v2m_dt_init,
 MACHINE_END

commit d75e2f902318cc20f3218e6823fe5463a8126bde
Merge: de9c9f86be0d 9bc25a1d5f95
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 15:11:43 2013 -0700

    Merge tag '3.9-rc3-smp-6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/sstabellini/xen
    
    Pull ARM Xen SMP updates from Stefano Stabellini:
     "This contains a bunch of Xen/ARM specific changes, including some
      fixes, SMP support for Xen on ARM, and moving the xenvm machine from
      mach-vexpress to mach-virt.
    
      The non-Xen files that are touched are arch/arm/Kconfig, to select
      ARM_PSCI on XEN, and arch/arm/boot/dts/Makefile, to build the xenvm
      DTB if CONFIG_ARCH_VIRT.
    
      Highlights:
    
       - Move xenvm to mach-virt.
    
       - Implement SMP support in Xen on ARM.
    
       - Add support for machine reboot and power off via Xen hypercalls"
    
    * tag '3.9-rc3-smp-6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/sstabellini/xen:
      xen/arm: remove duplicated include from enlighten.c
      xen/arm: use sched_op hypercalls for machine reboot and power off
      xenvm: add a simple PSCI node and a second cpu
      xen/arm: XEN selects ARM_PSCI
      xen: move the xenvm machine to mach-virt
      xen/arm: SMP support
      xen/arm: implement HYPERVISOR_vcpu_op
      xen/arm: actually pass a non-NULL percpu pointer to request_percpu_irq

commit 1bf25e78af317e6d5d9b5594dfeb0036e0d589d6
Merge: 38f56f33ca38 0592c2189ece
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:22:14 2013 -0700

    Merge tag 'cleanup-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC late cleanups from Arnd Bergmann:
     "These are cleanups and smaller changes that either depend on earlier
      feature branches or came in late during the development cycle.  We
      normally try to get all cleanups early, so these are the exceptions:
    
       - A follow-up on the clocksource reworks, hopefully the last time we
         need to merge clocksource subsystem changes through arm-soc.
    
         A first set of patches was part of the original 3.10 arm-soc
         cleanup series because of interdependencies with timer drivers now
         moved out of arch/arm.
    
       - Migrating the SPEAr13xx platform away from using auxdata for DMA
         channel descriptions towards using information in device tree,
         based on the earlier SPEAr multiplatform series
    
       - A few follow-ups on the Atmel SAMA5 support and other changes for
         Atmel at91 based on the larger at91 reworks.
    
       - Moving the armada irqchip implementation to drivers/irqchip
    
       - Several OMAP cleanups following up on the larger series already
         merged in 3.10."
    
    * tag 'cleanup-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (50 commits)
      ARM: OMAP4: change the device names in usb_bind_phy
      ARM: OMAP2+: Fix mismerge for timer.c between ff931c82 and da4a686a
      ARM: SPEAr: conditionalize SMP code
      ARM: arch_timer: Silence debug preempt warnings
      ARM: OMAP: remove unused variable
      serial: amba-pl011: fix !CONFIG_DMA_ENGINE case
      ata: arasan: remove the need for platform_data
      ARM: at91/sama5d34ek.dts: remove not needed compatibility string
      ARM: at91: dts: add MCI DMA support
      ARM: at91: dts: add i2c dma support
      ARM: at91: dts: set #dma-cells to the correct value
      ARM: at91: suspend both memory controllers on at91sam9263
      irqchip: armada-370-xp: slightly cleanup irq controller driver
      irqchip: armada-370-xp: move IRQ handler to avoid forward declaration
      irqchip: move IRQ driver for Armada 370/XP
      ARM: mvebu: move L2 cache initialization in init_early()
      devtree: add binding documentation for sp804
      ARM: integrator-cp: convert use CLKSRC_OF for timer init
      ARM: versatile: use OF init for sp804 timer
      ARM: versatile: add versatile dtbs to dtbs target
      ...

commit a7726350e06401929eac0aa0677a5467106565fc
Merge: 4d26aa305414 afcf7924ecab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:03:55 2013 -0700

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanup from Olof Johansson:
     "Here is a collection of cleanup patches.  Among the pieces that stand
      out are:
    
       - The deletion of h720x platforms
       - Split of at91 non-dt platforms to their own Kconfig file to keep
         them separate
       - General cleanups and refactoring of i.MX and MXS platforms
       - Some restructuring of clock tables for OMAP
       - Convertion of PMC driver for Tegra to dt-only
       - Some renames of sunxi -> sun4i (Allwinner A10)
       - ... plus a bunch of other stuff that I haven't mentioned"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (119 commits)
      ARM: i.MX: remove unused ARCH_* configs
      ARM i.MX53: remove platform ahci support
      ARM: sunxi: Rework the restart code
      irqchip: sunxi: Rename sunxi to sun4i
      irqchip: sunxi: Make use of the IRQCHIP_DECLARE macro
      clocksource: sunxi: Rename sunxi to sun4i
      clocksource: sunxi: make use of CLKSRC_OF
      clocksource: sunxi: Cleanup the timer code
      ARM: at91: remove trailing semicolon from macros
      ARM: at91/setup: fix trivial typos
      ARM: EXYNOS: remove "config EXYNOS_DEV_DRM"
      ARM: EXYNOS: change the name of USB ohci header
      ARM: SAMSUNG: Remove unnecessary code for dma
      ARM: S3C24XX: Remove unused GPIO drive strength register definitions
      ARM: OMAP4+: PM: Restore CPU power state to ON with clockdomain force wakeup method
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2412
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2410
      ARM: S3C24XX: Removed unneeded dependency on ARCH_S3C24XX for boards
      ARM: SAMSUNG: Fix typo "CONFIG_SAMSUNG_DEV_RTC"
      ARM: S5P64X0: Fix typo "CONFIG_S5P64X0_SETUP_SDHCI"
      ...

commit 151173e8ce9b95bbbbd7eedb9035cfaffbdb7cb2
Merge: 30945669593d 6b170807cd5c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 15:15:24 2013 -0700

    Merge tag 'for-v3.10' of git://git.infradead.org/battery-2.6
    
    Pull battery updates from Anton Vorontsov:
     "Highlights:
    
       - OpenFirmware/DeviceTree support for the Power Supply core: the core
         now automatically populates supplied_from hierarchy from the device
         tree.  With these patches chargers and batteries can now lookup
         each other without the board files support shim.  Rhyland Klein at
         NVIDIA did the work
    
       - New ST-Ericsson ABX500 hwmon driver.  The driver is heavily using
         the AB85xx core and depends on some recent changes to it, so that
         is why the driver comes through the battery tree.  It has an
         appropriate ack from the hwmon maintainer (i.e.  Guenter Roeck).
         Martin Persson at ST-Ericsson and Hongbo Zhang at Linaro authored
         the driver
    
       - Final bits to sync AB85xx ST-Ericsson changes into mainline.  The
         changes touch mfd parts, but these were acked by the appropriate
         MFD maintainer (ie Samuel Ortiz).  Lee Jones at Linaro did most of
         the work and lead the submission process.
    
      Minor changes, but still worth mentioning:
    
       - Battery temperature reporting fix for Nokia N900 phones
       - Versatile Express poweroff driver moved into drivers/power/reset/
       - Tree-wide: use devm_kzalloc() where appropriate
       - Tree-wide: dev_pm_ops cleanups/fixes"
    
    * tag 'for-v3.10' of git://git.infradead.org/battery-2.6: (112 commits)
      pm2301-charger: Fix suspend/resume
      charger-manager: Use kmemdup instead of kzalloc + memcpy
      power_supply: Populate supplied_from hierarchy from the device tree
      power_supply: Add core support for supplied_from
      power_supply: Define Binding for power-supplies
      rx51_battery: Fix reporting temperature
      hwmon: Add ST-Ericsson ABX500 hwmon driver
      ab8500_bmdata: Export abx500_res_to_temp tables for hwmon
      ab8500_{bmdata,fg}: Add const attributes to some data arrays
      ab8500_bmdata: Eliminate CamelCase warning of some variables
      ab8500_btemp: Make ab8500_btemp_get* interfaces public
      goldfish_battery: Use resource_size()
      lp8788-charger: Use PAGE_SIZE for the sysfs read operation
      max8925_power: Use devm_kzalloc()
      da9030_battery: Use devm_kzalloc()
      da9052-battery: Use devm_kzalloc()
      ds2760_battery: Use devm_kzalloc()
      ds2780_battery: Use devm_kzalloc()
      gpio-charger: Use devm_kzalloc()
      isp1704_charger: Use devm_kzalloc()
      ...

commit cc3d7f70c37641ca417f4c02ecaf12cd9772ffa6
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Tue Apr 23 14:51:11 2013 +0000

    xen: move the xenvm machine to mach-virt
    
    xenvm is based on mach-vexpress, move it to mach-virt.
    
    Changes in v4:
    - update the dts Makefile too.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    CC: Marc Zyngier <marc.zyngier@arm.com>
    CC: will.deacon@arm.com
    CC: arnd@arndb.de
    CC: rob.herring@calxeda.com

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 915683cb67d6..c43ec789661d 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -469,7 +469,6 @@ static void __init v2m_dt_init(void)
 
 static const char * const v2m_dt_match[] __initconst = {
 	"arm,vexpress",
-	"xen,xenvm",
 	NULL,
 };
 

commit 6e973d2c438502dcf956e76305258ba7d1c7d1d3
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Apr 18 18:23:22 2013 +0100

    clk: vexpress: Add separate SP810 driver
    
    Factor out the SP810 clocking code into a separate driver,
    selecting better (faster) parent at clk_prepare() time.
    This is to avoid problems with clocking infrastructure
    initialisation order, in particular to avoid dependency
    of fixed clock being initialized before SP810. It also
    makes vexpress platform OF-based clock initialisation code
    unnecessary.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Tested-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: add .unprepare, FIXME comment, cleaned up code]

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 915683cb67d6..c5e20b52e3b7 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -21,6 +21,8 @@
 #include <linux/regulator/fixed.h>
 #include <linux/regulator/machine.h>
 #include <linux/vexpress.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
 
 #include <asm/arch_timer.h>
 #include <asm/mach-types.h>
@@ -433,7 +435,7 @@ static void __init v2m_dt_timer_init(void)
 {
 	struct device_node *node = NULL;
 
-	vexpress_clk_of_init();
+	of_clk_init(NULL);
 
 	do {
 		node = of_find_compatible_node(node, NULL, "arm,sp804");
@@ -441,6 +443,10 @@ static void __init v2m_dt_timer_init(void)
 	if (node) {
 		pr_info("Using SP804 '%s' as a clock & events source\n",
 				node->full_name);
+		WARN_ON(clk_register_clkdev(of_clk_get_by_name(node,
+				"timclken1"), "v2m-timer0", "sp804"));
+		WARN_ON(clk_register_clkdev(of_clk_get_by_name(node,
+				"timclken2"), "v2m-timer1", "sp804"));
 		v2m_sp804_init(of_iomap(node, 0),
 				irq_of_parse_and_map(node, 0));
 	}

commit b2a93b1d6b0d1af00e4796f3ef1252d2862513e3
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Mar 25 11:20:36 2013 -0500

    ARM: vexpress: remove extra timer-sp control register clearing
    
    The timer-sp initialization code clears the control register before
    initializing the timers, so every platform doing this is redundant.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index cdc29d895ab0..09e571ddc984 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -61,9 +61,6 @@ static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
 	if (WARN_ON(!base || irq == NO_IRQ))
 		return;
 
-	writel(0, base + TIMER_1_BASE + TIMER_CTRL);
-	writel(0, base + TIMER_2_BASE + TIMER_CTRL);
-
 	sp804_clocksource_init(base + TIMER_2_BASE, "v2m-timer1");
 	sp804_clockevents_init(base + TIMER_1_BASE, irq, "v2m-timer0");
 }

commit dabfd8fb84abfddf526123388b68a50ec14cd380
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Feb 6 21:18:31 2013 -0600

    ARM: vexpress: remove sp804 OF init
    
    Remove the vexpress specific setup for the sp804 timer now that
    clocksource_of_init will do it.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 621571781b20..cdc29d895ab0 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -431,20 +431,9 @@ void __init v2m_dt_init_early(void)
 
 static void __init v2m_dt_timer_init(void)
 {
-	struct device_node *node = NULL;
-
 	vexpress_clk_of_init();
 
 	clocksource_of_init();
-	do {
-		node = of_find_compatible_node(node, NULL, "arm,sp804");
-	} while (node && vexpress_get_site_by_node(node) != VEXPRESS_SITE_MB);
-	if (node) {
-		pr_info("Using SP804 '%s' as a clock & events source\n",
-				node->full_name);
-		v2m_sp804_init(of_iomap(node, 0),
-				irq_of_parse_and_map(node, 0));
-	}
 
 	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),
 				24000000);

commit 0583fe478a7d93be2c814b7e50d6e81c287edfe8
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Apr 10 18:27:51 2013 -0500

    ARM: convert arm/arm64 arch timer to use CLKSRC_OF init
    
    This converts arm and arm64 to use CLKSRC_OF DT based initialization for
    the arch timer. A new function arch_timer_arch_init is added to allow for
    arch specific setup.
    
    This has a side effect of enabling sched_clock on omap5 and exynos5. There
    should not be any reason not to use the arch timers for sched_clock.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index d0ad78998cb6..621571781b20 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -1,6 +1,7 @@
 /*
  * Versatile Express V2M Motherboard Support
  */
+#include <linux/clocksource.h>
 #include <linux/device.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/mmci.h>
@@ -23,7 +24,6 @@
 #include <linux/regulator/machine.h>
 #include <linux/vexpress.h>
 
-#include <asm/arch_timer.h>
 #include <asm/mach-types.h>
 #include <asm/sizes.h>
 #include <asm/mach/arch.h>
@@ -446,10 +446,7 @@ static void __init v2m_dt_timer_init(void)
 				irq_of_parse_and_map(node, 0));
 	}
 
-	arch_timer_of_register();
-
-	if (arch_timer_sched_clock_init() != 0)
-		versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),
+	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),
 				24000000);
 }
 

commit 65deb782858128cde598ac4a9150ab7cdd29dafa
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Feb 28 16:43:19 2013 +0000

    arm: vexpress: Decouple vexpress-poweroff implementation from machine_desc
    
    This patch adds the pm_power_off and arm_pm_restart variable settings to
    the vexpress-poweroff.c driver to decouple it from the machine_desc
    definition.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 915683cb67d6..c970762e8386 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -361,8 +361,6 @@ static void __init v2m_init(void)
 	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
 		amba_device_register(v2m_amba_devs[i], &iomem_resource);
 
-	pm_power_off = vexpress_power_off;
-
 	ct_desc->init_tile();
 }
 
@@ -374,7 +372,6 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_irq	= v2m_init_irq,
 	.init_time	= v2m_timer_init,
 	.init_machine	= v2m_init,
-	.restart	= vexpress_restart,
 MACHINE_END
 
 static struct map_desc v2m_rs1_io_desc __initdata = {
@@ -464,7 +461,6 @@ static void __init v2m_dt_init(void)
 {
 	l2x0_of_init(0x00400000, 0xfe0fffff);
 	of_platform_populate(NULL, v2m_dt_bus_match, NULL, NULL);
-	pm_power_off = vexpress_power_off;
 }
 
 static const char * const v2m_dt_match[] __initconst = {
@@ -481,5 +477,4 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.init_irq	= irqchip_init,
 	.init_time	= v2m_dt_timer_init,
 	.init_machine	= v2m_dt_init,
-	.restart	= vexpress_restart,
 MACHINE_END

commit da4a686a2cfb077a8bfc1697f597e7f86235b822
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Feb 6 21:17:47 2013 -0600

    ARM: smp_twd: convert to use CLKSRC_OF init
    
    Now that we have OF based init with CLKSRC_OF, convert smp_twd init
    function to use it and covert all callers of
    twd_local_timer_of_register.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-omap@vger.kernel.org
    Cc: spear-devel@list.st.com
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 915683cb67d6..d0ad78998cb6 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -5,6 +5,7 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/mmci.h>
 #include <linux/io.h>
+#include <linux/clocksource.h>
 #include <linux/smp.h>
 #include <linux/init.h>
 #include <linux/irqchip.h>
@@ -25,7 +26,6 @@
 #include <asm/arch_timer.h>
 #include <asm/mach-types.h>
 #include <asm/sizes.h>
-#include <asm/smp_twd.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
@@ -435,6 +435,7 @@ static void __init v2m_dt_timer_init(void)
 
 	vexpress_clk_of_init();
 
+	clocksource_of_init();
 	do {
 		node = of_find_compatible_node(node, NULL, "arm,sp804");
 	} while (node && vexpress_get_site_by_node(node) != VEXPRESS_SITE_MB);
@@ -445,8 +446,7 @@ static void __init v2m_dt_timer_init(void)
 				irq_of_parse_and_map(node, 0));
 	}
 
-	if (arch_timer_of_register() != 0)
-		twd_local_timer_of_register();
+	arch_timer_of_register();
 
 	if (arch_timer_sched_clock_init() != 0)
 		versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),

commit f8060f5446b1f2782f0a8ca9be2d870ea4198aee
Merge: 175dbc1eeadb 9e47b8bf9815
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 17:22:00 2013 -0800

    Merge tag 'gic-vic-to-irqchip' of git://sources.calxeda.com/kernel/linux into next/cleanup
    
    From Rob Herring:
    
    Initial irqchip init infrastructure and GIC and VIC clean-ups
    
    This creates irqchip initialization infrastructure from Thomas
    Petazzoni. The VIC and GIC irqchip code is moved to drivers/irqchips
    and adapted to use the new infrastructure. All DT enabled platforms
    using GIC and VIC are converted over to use the new irqchip_init.
    
    * tag 'gic-vic-to-irqchip' of git://sources.calxeda.com/kernel/linux:
      irqchip: Move ARM vic.h to include/linux/irqchip/arm-vic.h
      ARM: picoxcell: use common irqchip_init function
      ARM: spear: use common irqchip_init function
      irqchip: Move ARM VIC to drivers/irqchip
      ARM: samsung: remove unused tick.h
      ARM: remove unneeded vic.h includes
      ARM: remove mach .handle_irq for VIC users
      ARM: VIC: set handle_arch_irq in VIC initialization
      ARM: VIC: shrink down vic.h
      irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
      ARM: use common irqchip_init for GIC init
      irqchip: Move ARM GIC to drivers/irqchip
      ARM: remove mach .handle_irq for GIC users
      ARM: GIC: set handle_arch_irq in GIC initialization
      ARM: GIC: remove direct use of gic_raise_softirq
      ARM: GIC: remove assembly ifdefs from gic.h
      ARM: mach-ux500: use SGI0 to wake up the other core
      arm: add set_handle_irq() to register the parent IRQ controller handler function
      irqchip: add basic infrastructure
      irqchip: add to the directories part of the IRQ subsystem in MAINTAINERS
    
    Fixed up massive merge conflicts with the timer cleanup due to adjacent changes:
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-bcm/board_bcm.c
            arch/arm/mach-cns3xxx/cns3420vb.c
            arch/arm/mach-ep93xx/adssphere.c
            arch/arm/mach-ep93xx/edb93xx.c
            arch/arm/mach-ep93xx/gesbc9312.c
            arch/arm/mach-ep93xx/micro9.c
            arch/arm/mach-ep93xx/simone.c
            arch/arm/mach-ep93xx/snappercl15.c
            arch/arm/mach-ep93xx/ts72xx.c
            arch/arm/mach-ep93xx/vision_ep9307.c
            arch/arm/mach-highbank/highbank.c
            arch/arm/mach-imx/mach-imx6q.c
            arch/arm/mach-msm/board-dt-8960.c
            arch/arm/mach-netx/nxdb500.c
            arch/arm/mach-netx/nxdkn.c
            arch/arm/mach-netx/nxeb500hmi.c
            arch/arm/mach-nomadik/board-nhk8815.c
            arch/arm/mach-picoxcell/common.c
            arch/arm/mach-realview/realview_eb.c
            arch/arm/mach-realview/realview_pb1176.c
            arch/arm/mach-realview/realview_pb11mp.c
            arch/arm/mach-realview/realview_pba8.c
            arch/arm/mach-realview/realview_pbx.c
            arch/arm/mach-socfpga/socfpga.c
            arch/arm/mach-spear13xx/spear1310.c
            arch/arm/mach-spear13xx/spear1340.c
            arch/arm/mach-spear13xx/spear13xx.c
            arch/arm/mach-spear3xx/spear300.c
            arch/arm/mach-spear3xx/spear310.c
            arch/arm/mach-spear3xx/spear320.c
            arch/arm/mach-spear3xx/spear3xx.c
            arch/arm/mach-spear6xx/spear6xx.c
            arch/arm/mach-tegra/board-dt-tegra20.c
            arch/arm/mach-tegra/board-dt-tegra30.c
            arch/arm/mach-u300/core.c
            arch/arm/mach-ux500/board-mop500.c
            arch/arm/mach-ux500/cpu-db8500.c
            arch/arm/mach-versatile/versatile_ab.c
            arch/arm/mach-versatile/versatile_dt.c
            arch/arm/mach-versatile/versatile_pb.c
            arch/arm/mach-vexpress/v2m.c
            include/asm-generic/vmlinux.lds.h

commit 0529e315bbda5d502c93df2cfafba9bb337fbdf4
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Nov 5 16:18:28 2012 -0600

    ARM: use common irqchip_init for GIC init
    
    Convert all GIC DT initialization over to use common irqchip_init
    function.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Dinh Nguyen <dinguyen@altera.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 557d361022a6..82be02b3ae28 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -7,6 +7,7 @@
 #include <linux/io.h>
 #include <linux/smp.h>
 #include <linux/init.h>
+#include <linux/irqchip.h>
 #include <linux/of_address.h>
 #include <linux/of_fdt.h>
 #include <linux/of_irq.h>
@@ -30,7 +31,6 @@
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/cache-l2x0.h>
-#include <asm/hardware/gic.h>
 #include <asm/hardware/timer-sp.h>
 
 #include <mach/ct-ca9x4.h>
@@ -433,16 +433,6 @@ void __init v2m_dt_init_early(void)
 	}
 }
 
-static  struct of_device_id vexpress_irq_match[] __initdata = {
-	{ .compatible = "arm,cortex-a9-gic", .data = gic_of_init, },
-	{}
-};
-
-static void __init v2m_dt_init_irq(void)
-{
-	of_irq_init(vexpress_irq_match);
-}
-
 static void __init v2m_dt_timer_init(void)
 {
 	struct device_node *node = NULL;
@@ -496,7 +486,7 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.smp		= smp_ops(vexpress_smp_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
-	.init_irq	= v2m_dt_init_irq,
+	.init_irq	= irqchip_init,
 	.timer		= &v2m_dt_timer,
 	.init_machine	= v2m_dt_init,
 	.restart	= vexpress_restart,

commit 1d5cc604f42ff1acdec0407247b2f720135ba0c2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Nov 20 19:52:32 2012 -0600

    ARM: remove mach .handle_irq for GIC users
    
    Now that the GIC initialization sets up the handle_arch_irq pointer, we
    can remove it for all machines and make it static.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Dinh Nguyen <dinguyen@altera.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 011661a6c5cb..557d361022a6 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -377,7 +377,6 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_early	= v2m_init_early,
 	.init_irq	= v2m_init_irq,
 	.timer		= &v2m_timer,
-	.handle_irq	= gic_handle_irq,
 	.init_machine	= v2m_init,
 	.restart	= vexpress_restart,
 MACHINE_END
@@ -500,6 +499,5 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.init_irq	= v2m_dt_init_irq,
 	.timer		= &v2m_dt_timer,
 	.init_machine	= v2m_dt_init,
-	.handle_irq	= gic_handle_irq,
 	.restart	= vexpress_restart,
 MACHINE_END

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 011661a6c5cb..08bd548ef144 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -291,10 +291,6 @@ static void __init v2m_timer_init(void)
 	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
 }
 
-static struct sys_timer v2m_timer = {
-	.init	= v2m_timer_init,
-};
-
 static void __init v2m_init_early(void)
 {
 	if (ct_desc->init_early)
@@ -376,7 +372,7 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.map_io		= v2m_map_io,
 	.init_early	= v2m_init_early,
 	.init_irq	= v2m_init_irq,
-	.timer		= &v2m_timer,
+	.init_time	= v2m_timer_init,
 	.handle_irq	= gic_handle_irq,
 	.init_machine	= v2m_init,
 	.restart	= vexpress_restart,
@@ -468,10 +464,6 @@ static void __init v2m_dt_timer_init(void)
 				24000000);
 }
 
-static struct sys_timer v2m_dt_timer = {
-	.init = v2m_dt_timer_init,
-};
-
 static const struct of_device_id v2m_dt_bus_match[] __initconst = {
 	{ .compatible = "simple-bus", },
 	{ .compatible = "arm,amba-bus", },
@@ -498,7 +490,7 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
 	.init_irq	= v2m_dt_init_irq,
-	.timer		= &v2m_dt_timer,
+	.init_time	= v2m_dt_timer_init,
 	.init_machine	= v2m_dt_init,
 	.handle_irq	= gic_handle_irq,
 	.restart	= vexpress_restart,

commit d027db132b395dabfac208e52a7e510e441bb9d2
Merge: d01e4afdbb65 5faf7cbb848d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 12 12:05:15 2012 -0800

    Merge tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC updates from Olof Johansson:
     "This contains the bulk of new SoC development for this merge window.
    
      Two new platforms have been added, the sunxi platforms (Allwinner A1x
      SoCs) by Maxime Ripard, and a generic Broadcom platform for a new
      series of ARMv7 platforms from them, where the hope is that we can
      keep the platform code generic enough to have them all share one mach
      directory.  The new Broadcom platform is contributed by Christian
      Daudt.
    
      Highbank has grown support for Calxeda's next generation of hardware,
      ECX-2000.
    
      clps711x has seen a lot of cleanup from Alexander Shiyan, and he's
      also taken on maintainership of the platform.
    
      Beyond this there has been a bunch of work from a number of people on
      converting more platforms to IRQ domains, pinctrl conversion, cleanup
      and general feature enablement across most of the active platforms."
    
    Fix up trivial conflicts as per Olof.
    
    * tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (174 commits)
      mfd: vexpress-sysreg: Remove LEDs code
      irqchip: irq-sunxi: Add terminating entry for sunxi_irq_dt_ids
      clocksource: sunxi_timer: Add terminating entry for sunxi_timer_dt_ids
      irq: versatile: delete dangling variable
      ARM: sunxi: add missing include for mdelay()
      ARM: EXYNOS: Avoid early use of of_machine_is_compatible()
      ARM: dts: add node for PL330 MDMA1 controller for exynos4
      ARM: EXYNOS: Add support for secondary CPU bring-up on Exynos4412
      ARM: EXYNOS: add UART3 to DEBUG_LL ports
      ARM: S3C24XX: Add clkdev entry for camif-upll clock
      ARM: SAMSUNG: Add s3c24xx/s3c64xx CAMIF GPIO setup helpers
      ARM: sunxi: Add missing sun4i.dtsi file
      pinctrl: samsung: Do not initialise statics to 0
      ARM i.MX6: remove gate_mask from pllv3
      ARM i.MX6: Fix ethernet PLL clocks
      ARM i.MX6: rename PLLs according to datasheet
      ARM i.MX6: Add pwm support
      ARM i.MX51: Add pwm support
      ARM i.MX53: Add pwm support
      ARM: mx5: Replace clk_register_clkdev with clock DT lookup
      ...

commit 465aac6d496aa3e99caaa6868865fb3830f73d80
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Nov 30 10:01:51 2012 +0000

    Fix build when CONFIG_W1_MASTER_GPIO=m b exporting "allnodes"
    
    ERROR: "allnodes" [drivers/w1/masters/w1-gpio.ko] undefined!
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    [grant.likely: allnodes is too generic; rename to of_allnodes]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Ville Syrjala <syrjala@sci.fi>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 560e0df728f8..359f782c747d 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -589,7 +589,7 @@ void __init v2m_dt_init_early(void)
 		return;
 
 	/* Confirm board type against DT property, if available */
-	if (of_property_read_u32(allnodes, "arm,hbi", &dt_hbi) == 0) {
+	if (of_property_read_u32(of_allnodes, "arm,hbi", &dt_hbi) == 0) {
 		int site = v2m_get_master_site();
 		u32 id = readl(v2m_sysreg_base + (site == SYS_CFG_SITE_DB2 ?
 				V2M_SYS_PROCID1 : V2M_SYS_PROCID0));

commit 433683a66401adb0150792e725cc4f631c94de46
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Oct 16 15:27:12 2012 +0100

    ARM: vexpress: Remove motherboard dependencies in the DTS files
    
    The way the VE motherboard Device Trees were constructed
    enforced naming and structure of daughterboard files. This
    patch makes it possible to simply include the motherboard
    description anywhere in the main Device Tree and retires
    the "arm,v2m-timer" alias - any of the motherboard SP804
    timers will be used instead.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 99d4172816be..4e168e81fb42 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -446,17 +446,20 @@ static void __init v2m_dt_init_irq(void)
 
 static void __init v2m_dt_timer_init(void)
 {
-	struct device_node *node;
-	const char *path;
-	int err;
+	struct device_node *node = NULL;
 
 	vexpress_clk_of_init();
 
-	err = of_property_read_string(of_aliases, "arm,v2m_timer", &path);
-	if (WARN_ON(err))
-		return;
-	node = of_find_node_by_path(path);
-	v2m_sp804_init(of_iomap(node, 0), irq_of_parse_and_map(node, 0));
+	do {
+		node = of_find_compatible_node(node, NULL, "arm,sp804");
+	} while (node && vexpress_get_site_by_node(node) != VEXPRESS_SITE_MB);
+	if (node) {
+		pr_info("Using SP804 '%s' as a clock & events source\n",
+				node->full_name);
+		v2m_sp804_init(of_iomap(node, 0),
+				irq_of_parse_and_map(node, 0));
+	}
+
 	if (arch_timer_of_register() != 0)
 		twd_local_timer_of_register();
 

commit 38669e045dbf8f62a008898a7fb1e93975b3817c
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Oct 9 12:56:36 2012 +0100

    ARM: vexpress: Start using new Versatile Express infrastructure
    
    This patch starts using all the configuration infrastructure.
    
    - generic GPIO library is forced now
    
    - sysreg GPIOs are used as MMC CD and WP information sources;
      thanks to this MMCI auxiliary data is not longer necessary
    
    - DVI muxer and mode control is removed from non-DT V2P-CA9 code
      as this is now handled by the vexpress-dvi driver
    
    - clock generators control is removed as is being handled by the
      common clock driver now
    
    - the sysreg and sysctl control is now delegated to the
      appropriate drivers and all related code was removed
    
    - NOR Flash set_vpp function has been removed as the control
      bit used does _not_ control its VPP line, but the #WP signal
      instead (which is de facto unusable in case of Linux MTD
      drivers); this also allowed the remove its DT auxiliary
      data
    
    The non-DT code defines only minimal required number of
    the config devices. Device Trees are updated to make use
    of all new features.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 560e0df728f8..99d4172816be 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -16,11 +16,10 @@
 #include <linux/smsc911x.h>
 #include <linux/spinlock.h>
 #include <linux/usb/isp1760.h>
-#include <linux/clkdev.h>
-#include <linux/clk-provider.h>
 #include <linux/mtd/physmap.h>
 #include <linux/regulator/fixed.h>
 #include <linux/regulator/machine.h>
+#include <linux/vexpress.h>
 
 #include <asm/arch_timer.h>
 #include <asm/mach-types.h>
@@ -33,7 +32,6 @@
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/timer-sp.h>
-#include <asm/hardware/sp810.h>
 
 #include <mach/ct-ca9x4.h>
 #include <mach/motherboard.h>
@@ -58,22 +56,6 @@ static struct map_desc v2m_io_desc[] __initdata = {
 	},
 };
 
-static void __iomem *v2m_sysreg_base;
-
-static void __init v2m_sysctl_init(void __iomem *base)
-{
-	u32 scctrl;
-
-	if (WARN_ON(!base))
-		return;
-
-	/* Select 1MHz TIMCLK as the reference clock for SP804 timers */
-	scctrl = readl(base + SCCTRL);
-	scctrl |= SCCTRL_TIMEREN0SEL_TIMCLK;
-	scctrl |= SCCTRL_TIMEREN1SEL_TIMCLK;
-	writel(scctrl, base + SCCTRL);
-}
-
 static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
 {
 	if (WARN_ON(!base || irq == NO_IRQ))
@@ -87,69 +69,6 @@ static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
 }
 
 
-static DEFINE_SPINLOCK(v2m_cfg_lock);
-
-int v2m_cfg_write(u32 devfn, u32 data)
-{
-	/* Configuration interface broken? */
-	u32 val;
-
-	printk("%s: writing %08x to %08x\n", __func__, data, devfn);
-
-	devfn |= SYS_CFG_START | SYS_CFG_WRITE;
-
-	spin_lock(&v2m_cfg_lock);
-	val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
-	writel(val & ~SYS_CFG_COMPLETE, v2m_sysreg_base + V2M_SYS_CFGSTAT);
-
-	writel(data, v2m_sysreg_base +  V2M_SYS_CFGDATA);
-	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
-
-	do {
-		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
-	} while (val == 0);
-	spin_unlock(&v2m_cfg_lock);
-
-	return !!(val & SYS_CFG_ERR);
-}
-
-int v2m_cfg_read(u32 devfn, u32 *data)
-{
-	u32 val;
-
-	devfn |= SYS_CFG_START;
-
-	spin_lock(&v2m_cfg_lock);
-	writel(0, v2m_sysreg_base + V2M_SYS_CFGSTAT);
-	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
-
-	mb();
-
-	do {
-		cpu_relax();
-		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
-	} while (val == 0);
-
-	*data = readl(v2m_sysreg_base + V2M_SYS_CFGDATA);
-	spin_unlock(&v2m_cfg_lock);
-
-	return !!(val & SYS_CFG_ERR);
-}
-
-void __init v2m_flags_set(u32 data)
-{
-	writel(~0, v2m_sysreg_base + V2M_SYS_FLAGSCLR);
-	writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);
-}
-
-int v2m_get_master_site(void)
-{
-	u32 misc = readl(v2m_sysreg_base + V2M_SYS_MISC);
-
-	return misc & SYS_MISC_MASTERSITE ? SYS_CFG_SITE_DB2 : SYS_CFG_SITE_DB1;
-}
-
-
 static struct resource v2m_pcie_i2c_resource = {
 	.start	= V2M_SERIAL_BUS_PCI,
 	.end	= V2M_SERIAL_BUS_PCI + SZ_4K - 1,
@@ -237,14 +156,8 @@ static struct platform_device v2m_usb_device = {
 	.dev.platform_data = &v2m_usb_config,
 };
 
-static void v2m_flash_set_vpp(struct platform_device *pdev, int on)
-{
-	writel(on != 0, v2m_sysreg_base + V2M_SYS_FLASH);
-}
-
 static struct physmap_flash_data v2m_flash_data = {
 	.width		= 4,
-	.set_vpp	= v2m_flash_set_vpp,
 };
 
 static struct resource v2m_flash_resources[] = {
@@ -291,14 +204,61 @@ static struct platform_device v2m_cf_device = {
 	.dev.platform_data = &v2m_pata_data,
 };
 
-static unsigned int v2m_mmci_status(struct device *dev)
-{
-	return readl(v2m_sysreg_base + V2M_SYS_MCI) & (1 << 0);
-}
-
 static struct mmci_platform_data v2m_mmci_data = {
 	.ocr_mask	= MMC_VDD_32_33|MMC_VDD_33_34,
-	.status		= v2m_mmci_status,
+	.gpio_wp	= VEXPRESS_GPIO_MMC_WPROT,
+	.gpio_cd	= VEXPRESS_GPIO_MMC_CARDIN,
+};
+
+static struct resource v2m_sysreg_resources[] = {
+	{
+		.start	= V2M_SYSREGS,
+		.end	= V2M_SYSREGS + 0xfff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device v2m_sysreg_device = {
+	.name		= "vexpress-sysreg",
+	.id		= -1,
+	.resource	= v2m_sysreg_resources,
+	.num_resources	= ARRAY_SIZE(v2m_sysreg_resources),
+};
+
+static struct platform_device v2m_muxfpga_device = {
+	.name		= "vexpress-muxfpga",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource []) {
+		VEXPRESS_RES_FUNC(0, 7),
+	}
+};
+
+static struct platform_device v2m_shutdown_device = {
+	.name		= "vexpress-shutdown",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource []) {
+		VEXPRESS_RES_FUNC(0, 8),
+	}
+};
+
+static struct platform_device v2m_reboot_device = {
+	.name		= "vexpress-reboot",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource []) {
+		VEXPRESS_RES_FUNC(0, 9),
+	}
+};
+
+static struct platform_device v2m_dvimode_device = {
+	.name		= "vexpress-dvimode",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource []) {
+		VEXPRESS_RES_FUNC(0, 11),
+	}
 };
 
 static AMBA_APB_DEVICE(aaci,  "mb:aaci",  0, V2M_AACI, IRQ_V2M_AACI, NULL);
@@ -325,123 +285,9 @@ static struct amba_device *v2m_amba_devs[] __initdata = {
 	&rtc_device,
 };
 
-
-static unsigned long v2m_osc_recalc_rate(struct clk_hw *hw,
-		unsigned long parent_rate)
-{
-	struct v2m_osc *osc = to_v2m_osc(hw);
-
-	return !parent_rate ? osc->rate_default : parent_rate;
-}
-
-static long v2m_osc_round_rate(struct clk_hw *hw, unsigned long rate,
-		unsigned long *parent_rate)
-{
-	struct v2m_osc *osc = to_v2m_osc(hw);
-
-	if (WARN_ON(rate < osc->rate_min))
-		rate = osc->rate_min;
-
-	if (WARN_ON(rate > osc->rate_max))
-		rate = osc->rate_max;
-
-	return rate;
-}
-
-static int v2m_osc_set_rate(struct clk_hw *hw, unsigned long rate,
-		unsigned long parent_rate)
-{
-	struct v2m_osc *osc = to_v2m_osc(hw);
-
-	v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE(osc->site) |
-			SYS_CFG_STACK(osc->stack) | osc->osc, rate);
-
-	return 0;
-}
-
-static struct clk_ops v2m_osc_ops = {
-	.recalc_rate = v2m_osc_recalc_rate,
-	.round_rate = v2m_osc_round_rate,
-	.set_rate = v2m_osc_set_rate,
-};
-
-struct clk * __init v2m_osc_register(const char *name, struct v2m_osc *osc)
-{
-	struct clk_init_data init;
-
-	WARN_ON(osc->site > 2);
-	WARN_ON(osc->stack > 15);
-	WARN_ON(osc->osc > 4095);
-
-	init.name = name;
-	init.ops = &v2m_osc_ops;
-	init.flags = CLK_IS_ROOT;
-	init.num_parents = 0;
-
-	osc->hw.init = &init;
-
-	return clk_register(NULL, &osc->hw);
-}
-
-static struct v2m_osc v2m_mb_osc1 = {
-	.site = SYS_CFG_SITE_MB,
-	.osc = 1,
-	.rate_min = 23750000,
-	.rate_max = 63500000,
-	.rate_default = 23750000,
-};
-
-static const char *v2m_ref_clk_periphs[] __initconst = {
-	"mb:wdt",   "1000f000.wdt",  "1c0f0000.wdt",	/* SP805 WDT */
-};
-
-static const char *v2m_osc1_periphs[] __initconst = {
-	"mb:clcd",  "1001f000.clcd", "1c1f0000.clcd",	/* PL111 CLCD */
-};
-
-static const char *v2m_osc2_periphs[] __initconst = {
-	"mb:mmci",  "10005000.mmci", "1c050000.mmci",	/* PL180 MMCI */
-	"mb:kmi0",  "10006000.kmi",  "1c060000.kmi",	/* PL050 KMI0 */
-	"mb:kmi1",  "10007000.kmi",  "1c070000.kmi",	/* PL050 KMI1 */
-	"mb:uart0", "10009000.uart", "1c090000.uart",	/* PL011 UART0 */
-	"mb:uart1", "1000a000.uart", "1c0a0000.uart",	/* PL011 UART1 */
-	"mb:uart2", "1000b000.uart", "1c0b0000.uart",	/* PL011 UART2 */
-	"mb:uart3", "1000c000.uart", "1c0c0000.uart",	/* PL011 UART3 */
-};
-
-static void __init v2m_clk_init(void)
-{
-	struct clk *clk;
-	int i;
-
-	clk = clk_register_fixed_rate(NULL, "dummy_apb_pclk", NULL,
-			CLK_IS_ROOT, 0);
-	WARN_ON(clk_register_clkdev(clk, "apb_pclk", NULL));
-
-	clk = clk_register_fixed_rate(NULL, "mb:ref_clk", NULL,
-			CLK_IS_ROOT, 32768);
-	for (i = 0; i < ARRAY_SIZE(v2m_ref_clk_periphs); i++)
-		WARN_ON(clk_register_clkdev(clk, NULL, v2m_ref_clk_periphs[i]));
-
-	clk = clk_register_fixed_rate(NULL, "mb:sp804_clk", NULL,
-			CLK_IS_ROOT, 1000000);
-	WARN_ON(clk_register_clkdev(clk, "v2m-timer0", "sp804"));
-	WARN_ON(clk_register_clkdev(clk, "v2m-timer1", "sp804"));
-
-	clk = v2m_osc_register("mb:osc1", &v2m_mb_osc1);
-	for (i = 0; i < ARRAY_SIZE(v2m_osc1_periphs); i++)
-		WARN_ON(clk_register_clkdev(clk, NULL, v2m_osc1_periphs[i]));
-
-	clk = clk_register_fixed_rate(NULL, "mb:osc2", NULL,
-			CLK_IS_ROOT, 24000000);
-	for (i = 0; i < ARRAY_SIZE(v2m_osc2_periphs); i++)
-		WARN_ON(clk_register_clkdev(clk, NULL, v2m_osc2_periphs[i]));
-}
-
 static void __init v2m_timer_init(void)
 {
-	v2m_sysctl_init(ioremap(V2M_SYSCTL, SZ_4K));
-	v2m_clk_init();
+	vexpress_clk_init(ioremap(V2M_SYSCTL, SZ_4K));
 	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
 }
 
@@ -453,19 +299,7 @@ static void __init v2m_init_early(void)
 {
 	if (ct_desc->init_early)
 		ct_desc->init_early();
-	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
-}
-
-static void v2m_power_off(void)
-{
-	if (v2m_cfg_write(SYS_CFG_SHUTDOWN | SYS_CFG_SITE(SYS_CFG_SITE_MB), 0))
-		printk(KERN_EMERG "Unable to shutdown\n");
-}
-
-static void v2m_restart(char str, const char *cmd)
-{
-	if (v2m_cfg_write(SYS_CFG_REBOOT | SYS_CFG_SITE(SYS_CFG_SITE_MB), 0))
-		printk(KERN_EMERG "Unable to reboot\n");
+	versatile_sched_clock_init(vexpress_get_24mhz_clock_base(), 24000000);
 }
 
 struct ct_desc *ct_desc;
@@ -482,7 +316,7 @@ static void __init v2m_populate_ct_desc(void)
 	u32 current_tile_id;
 
 	ct_desc = NULL;
-	current_tile_id = readl(v2m_sysreg_base + V2M_SYS_PROCID0)
+	current_tile_id = vexpress_get_procid(VEXPRESS_SITE_MASTER)
 				& V2M_CT_ID_MASK;
 
 	for (i = 0; i < ARRAY_SIZE(ct_descs) && !ct_desc; ++i)
@@ -498,7 +332,7 @@ static void __init v2m_populate_ct_desc(void)
 static void __init v2m_map_io(void)
 {
 	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
-	v2m_sysreg_base = ioremap(V2M_SYSREGS, SZ_4K);
+	vexpress_sysreg_early_init(ioremap(V2M_SYSREGS, SZ_4K));
 	v2m_populate_ct_desc();
 	ct_desc->map_io();
 }
@@ -515,6 +349,12 @@ static void __init v2m_init(void)
 	regulator_register_fixed(0, v2m_eth_supplies,
 			ARRAY_SIZE(v2m_eth_supplies));
 
+	platform_device_register(&v2m_muxfpga_device);
+	platform_device_register(&v2m_shutdown_device);
+	platform_device_register(&v2m_reboot_device);
+	platform_device_register(&v2m_dvimode_device);
+
+	platform_device_register(&v2m_sysreg_device);
 	platform_device_register(&v2m_pcie_i2c_device);
 	platform_device_register(&v2m_ddc_i2c_device);
 	platform_device_register(&v2m_flash_device);
@@ -525,7 +365,7 @@ static void __init v2m_init(void)
 	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
 		amba_device_register(v2m_amba_devs[i], &iomem_resource);
 
-	pm_power_off = v2m_power_off;
+	pm_power_off = vexpress_power_off;
 
 	ct_desc->init_tile();
 }
@@ -539,7 +379,7 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.timer		= &v2m_timer,
 	.handle_irq	= gic_handle_irq,
 	.init_machine	= v2m_init,
-	.restart	= v2m_restart,
+	.restart	= vexpress_restart,
 MACHINE_END
 
 static struct map_desc v2m_rs1_io_desc __initdata = {
@@ -580,20 +420,13 @@ void __init v2m_dt_map_io(void)
 
 void __init v2m_dt_init_early(void)
 {
-	struct device_node *node;
 	u32 dt_hbi;
 
-	node = of_find_compatible_node(NULL, NULL, "arm,vexpress-sysreg");
-	v2m_sysreg_base = of_iomap(node, 0);
-	if (WARN_ON(!v2m_sysreg_base))
-		return;
+	vexpress_sysreg_of_early_init();
 
 	/* Confirm board type against DT property, if available */
 	if (of_property_read_u32(allnodes, "arm,hbi", &dt_hbi) == 0) {
-		int site = v2m_get_master_site();
-		u32 id = readl(v2m_sysreg_base + (site == SYS_CFG_SITE_DB2 ?
-				V2M_SYS_PROCID1 : V2M_SYS_PROCID0));
-		u32 hbi = id & SYS_PROCIDx_HBI_MASK;
+		u32 hbi = vexpress_get_hbi(VEXPRESS_SITE_MASTER);
 
 		if (WARN_ON(dt_hbi != hbi))
 			pr_warning("vexpress: DT HBI (%x) is not matching "
@@ -617,10 +450,7 @@ static void __init v2m_dt_timer_init(void)
 	const char *path;
 	int err;
 
-	node = of_find_compatible_node(NULL, NULL, "arm,sp810");
-	v2m_sysctl_init(of_iomap(node, 0));
-
-	v2m_clk_init();
+	vexpress_clk_of_init();
 
 	err = of_property_read_string(of_aliases, "arm,v2m_timer", &path);
 	if (WARN_ON(err))
@@ -631,33 +461,29 @@ static void __init v2m_dt_timer_init(void)
 		twd_local_timer_of_register();
 
 	if (arch_timer_sched_clock_init() != 0)
-		versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
+		versatile_sched_clock_init(vexpress_get_24mhz_clock_base(),
+				24000000);
 }
 
 static struct sys_timer v2m_dt_timer = {
 	.init = v2m_dt_timer_init,
 };
 
-static struct of_dev_auxdata v2m_dt_auxdata_lookup[] __initdata = {
-	OF_DEV_AUXDATA("arm,vexpress-flash", V2M_NOR0, "physmap-flash",
-			&v2m_flash_data),
-	OF_DEV_AUXDATA("arm,primecell", V2M_MMCI, "mb:mmci", &v2m_mmci_data),
-	/* RS1 memory map */
-	OF_DEV_AUXDATA("arm,vexpress-flash", 0x08000000, "physmap-flash",
-			&v2m_flash_data),
-	OF_DEV_AUXDATA("arm,primecell", 0x1c050000, "mb:mmci", &v2m_mmci_data),
+static const struct of_device_id v2m_dt_bus_match[] __initconst = {
+	{ .compatible = "simple-bus", },
+	{ .compatible = "arm,amba-bus", },
+	{ .compatible = "arm,vexpress,config-bus", },
 	{}
 };
 
 static void __init v2m_dt_init(void)
 {
 	l2x0_of_init(0x00400000, 0xfe0fffff);
-	of_platform_populate(NULL, of_default_bus_match_table,
-			v2m_dt_auxdata_lookup, NULL);
-	pm_power_off = v2m_power_off;
+	of_platform_populate(NULL, v2m_dt_bus_match, NULL, NULL);
+	pm_power_off = vexpress_power_off;
 }
 
-const static char *v2m_dt_match[] __initconst = {
+static const char * const v2m_dt_match[] __initconst = {
 	"arm,vexpress",
 	"xen,xenvm",
 	NULL,
@@ -672,5 +498,5 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.timer		= &v2m_dt_timer,
 	.init_machine	= v2m_dt_init,
 	.handle_irq	= gic_handle_irq,
-	.restart	= v2m_restart,
+	.restart	= vexpress_restart,
 MACHINE_END

commit f1c6872e4980bc4078cfaead05f892b3d78dea64
Merge: 5f3d2f2e1a63 4ed5978bdd99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 7 07:13:01 2012 +0900

    Merge tag 'stable/for-linus-3.7-arm-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen
    
    Pull ADM Xen support from Konrad Rzeszutek Wilk:
    
      Features:
       * Allow a Linux guest to boot as initial domain and as normal guests
         on Xen on ARM (specifically ARMv7 with virtualized extensions).  PV
         console, block and network frontend/backends are working.
      Bug-fixes:
       * Fix compile linux-next fallout.
       * Fix PVHVM bootup crashing.
    
      The Xen-unstable hypervisor (so will be 4.3 in a ~6 months), supports
      ARMv7 platforms.
    
      The goal in implementing this architecture is to exploit the hardware
      as much as possible.  That means use as little as possible of PV
      operations (so no PV MMU) - and use existing PV drivers for I/Os
      (network, block, console, etc).  This is similar to how PVHVM guests
      operate in X86 platform nowadays - except that on ARM there is no need
      for QEMU.  The end result is that we share a lot of the generic Xen
      drivers and infrastructure.
    
      Details on how to compile/boot/etc are available at this Wiki:
    
        http://wiki.xen.org/wiki/Xen_ARMv7_with_Virtualization_Extensions
    
      and this blog has links to a technical discussion/presentations on the
      overall architecture:
    
        http://blog.xen.org/index.php/2012/09/21/xensummit-sessions-new-pvh-virtualisation-mode-for-arm-cortex-a15arm-servers-and-x86/
    
    * tag 'stable/for-linus-3.7-arm-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen: (21 commits)
      xen/xen_initial_domain: check that xen_start_info is initialized
      xen: mark xen_init_IRQ __init
      xen/Makefile: fix dom-y build
      arm: introduce a DTS for Xen unprivileged virtual machines
      MAINTAINERS: add myself as Xen ARM maintainer
      xen/arm: compile netback
      xen/arm: compile blkfront and blkback
      xen/arm: implement alloc/free_xenballooned_pages with alloc_pages/kfree
      xen/arm: receive Xen events on ARM
      xen/arm: initialize grant_table on ARM
      xen/arm: get privilege status
      xen/arm: introduce CONFIG_XEN on ARM
      xen: do not compile manage, balloon, pci, acpi, pcpu and cpu_hotplug on ARM
      xen/arm: Introduce xen_ulong_t for unsigned long
      xen/arm: Xen detection and shared_info page mapping
      docs: Xen ARM DT bindings
      xen/arm: empty implementation of grant_table arch specific functions
      xen/arm: sync_bitops
      xen/arm: page.h definitions
      xen/arm: hypercalls
      ...

commit bbd6eb29214e1a278e8575f57d64b88077bebf6d
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Mon Sep 24 16:40:52 2012 +0000

    arm: introduce a DTS for Xen unprivileged virtual machines
    
    Given that the xenvm machine is based on vexpress but with an extremely
    limited selection of peripherals (the guest is supposed to use virtual
    devices instead), add "xen,xenvm" to the list of compatible machines in
    mach-vexpress.
    
    
    Changes in v3:
    
    - add comments to mark fields that are likely to be changed by the
    hypervisor.
    
    
    Changes in v2:
    
    - remove include skeleton;
    - use #address-cells = <2> and #size-cells = <2>;
    - remove the debug bootargs;
    - use memory@80000000 instead of memory;
    - remove the ranges and interrupt-map from the motherboard node;
    - set the machine compatible to "xen,xenvm-4.2", "xen,xenvm";
    - rename the dts file to xenvm-4.2.dts;
    - add "xen,xenvm" to the list of compatible DT strings to mach-vexpress.
    
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Pawel Moll <pawel.moll@arm.com> (v2m changes)

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 37608f22ee31..0a79b085ceaf 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -658,6 +658,7 @@ static void __init v2m_dt_init(void)
 
 const static char *v2m_dt_match[] __initconst = {
 	"arm,vexpress",
+	"xen,xenvm",
 	NULL,
 };
 

commit 25468fe89f88c4ceeef94526e94ae0db176f6999
Merge: a283580c52d3 28e8e29c616f
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 00:06:21 2012 -0700

    Merge branch 'multiplatform/smp_ops' into next/multiplatform
    
    * multiplatform/smp_ops:
      ARM: consolidate pen_release instead of having per platform definitions
      ARM: smp: Make SMP operations mandatory
      ARM: SoC: convert spear13xx to SMP operations
      ARM: SoC: convert imx6q to SMP operations
      ARM: SoC: convert highbank to SMP operations
      ARM: SoC: convert shmobile SMP to SMP operations
      ARM: SoC: convert ux500 to SMP operations
      ARM: SoC: convert MSM to SMP operations
      ARM: SoC: convert Exynos4 to SMP operations
      ARM: SoC: convert Tegra to SMP operations
      ARM: SoC: convert OMAP4 to SMP operations
      ARM: SoC: convert VExpress/RealView to SMP operations
      ARM: SoC: add per-platform SMP operations
    
    Conflicts due to file moves or removals in:
            arch/arm/mach-msm/board-msm8960.c
            arch/arm/mach-msm/board-msm8x60.c
            arch/arm/mach-tegra/board-harmony.c
            arch/arm/mach-tegra/board-trimslice.c
    
    Conflicts due to board file cleanup:
            arch/arm/mach-tegra/board-paz00.c
    
    Conflicts due to cpu hotplug addition:
            arch/arm/mach-tegra/hotplug.c
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 617276307cd4cdb9a95c77efaa3063695af63aa7
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Sep 6 13:43:04 2012 -0500

    ARM: vexpress: convert to multi-platform
    
    Convert vexpress to multi-platform. This always enables vexpress DT and
    makes it the default v7 platform.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 37608f22ee31..2ca86c50174d 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -539,8 +539,6 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.restart	= v2m_restart,
 MACHINE_END
 
-#if defined(CONFIG_ARCH_VEXPRESS_DT)
-
 static struct map_desc v2m_rs1_io_desc __initdata = {
 	.virtual	= V2M_PERIPH,
 	.pfn		= __phys_to_pfn(0x1c000000),
@@ -671,5 +669,3 @@ DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.handle_irq	= gic_handle_irq,
 	.restart	= v2m_restart,
 MACHINE_END
-
-#endif

commit 3695adc2fdaf3ad1881e0dd3e3422e5e141abd7d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 13:15:22 2011 +0100

    ARM: SoC: convert VExpress/RealView to SMP operations
    
    Convert both Realview and VExpress to use struct smp_operations to
    provide their SMP and CPU hotplug operation.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 37608f22ee31..722ef339c5f2 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -5,6 +5,7 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/mmci.h>
 #include <linux/io.h>
+#include <linux/smp.h>
 #include <linux/init.h>
 #include <linux/of_address.h>
 #include <linux/of_fdt.h>
@@ -38,6 +39,7 @@
 #include <mach/motherboard.h>
 
 #include <plat/sched_clock.h>
+#include <plat/platsmp.h>
 
 #include "core.h"
 
@@ -530,6 +532,7 @@ static void __init v2m_init(void)
 
 MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.atag_offset	= 0x100,
+	.smp		= smp_ops(vexpress_smp_ops),
 	.map_io		= v2m_map_io,
 	.init_early	= v2m_init_early,
 	.init_irq	= v2m_init_irq,
@@ -663,6 +666,7 @@ const static char *v2m_dt_match[] __initconst = {
 
 DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
 	.dt_compat	= v2m_dt_match,
+	.smp		= smp_ops(vexpress_smp_ops),
 	.map_io		= v2m_dt_map_io,
 	.init_early	= v2m_dt_init_early,
 	.init_irq	= v2m_dt_init_irq,

commit b2a54ff03ca80f11f3760f4eab9a955e7215f569
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Mon Jul 9 11:33:47 2012 +0100

    ARM: vexpress: Add fixed regulator for SMSC
    
    SMSC driver requires "vdd33a" and "vddvario" regulator supplies now.
    
    Add fixed regulator describing 3V3 power line (in both motherboard's
    Device Trees and the non-DT code) and force fixed regulator config
    option if regulators framework is enabled.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index a3652a4ddc40..37608f22ee31 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -18,6 +18,8 @@
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
 #include <linux/mtd/physmap.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
 
 #include <asm/arch_timer.h>
 #include <asm/mach-types.h>
@@ -199,6 +201,11 @@ static struct platform_device v2m_eth_device = {
 	.dev.platform_data = &v2m_eth_config,
 };
 
+static struct regulator_consumer_supply v2m_eth_supplies[] = {
+	REGULATOR_SUPPLY("vddvario", "smsc911x"),
+	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
+};
+
 static struct resource v2m_usb_resources[] = {
 	{
 		.start	= V2M_ISP1761,
@@ -503,6 +510,9 @@ static void __init v2m_init(void)
 {
 	int i;
 
+	regulator_register_fixed(0, v2m_eth_supplies,
+			ARRAY_SIZE(v2m_eth_supplies));
+
 	platform_device_register(&v2m_pcie_i2c_device);
 	platform_device_register(&v2m_ddc_i2c_device);
 	platform_device_register(&v2m_flash_device);

commit d1b8a775fdb686c949d31e366a898b64147543e0
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Fri Jul 13 11:48:16 2012 +0100

    ARM: vexpress: Initial common clock support
    
    This patch makes Versatile Express use the common clock framework
    instead of the plat-versatile implementation.
    
    It defines clock provider for VE's OSCs (clock generators) and
    registers all required fixed and variable clock sources (for both
    motherboard and core tile).
    
    This is a simple conversion of the existing state and will be
    extended (and migrated to drivers/clk) in the near future.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index bb185921fce1..a3652a4ddc40 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -16,6 +16,7 @@
 #include <linux/spinlock.h>
 #include <linux/usb/isp1760.h>
 #include <linux/clkdev.h>
+#include <linux/clk-provider.h>
 #include <linux/mtd/physmap.h>
 
 #include <asm/arch_timer.h>
@@ -81,16 +82,6 @@ static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
 	sp804_clockevents_init(base + TIMER_1_BASE, irq, "v2m-timer0");
 }
 
-static void __init v2m_timer_init(void)
-{
-	v2m_sysctl_init(ioremap(V2M_SYSCTL, SZ_4K));
-	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
-}
-
-static struct sys_timer v2m_timer = {
-	.init	= v2m_timer_init,
-};
-
 
 static DEFINE_SPINLOCK(v2m_cfg_lock);
 
@@ -326,87 +317,133 @@ static struct amba_device *v2m_amba_devs[] __initdata = {
 };
 
 
-static long v2m_osc_round(struct clk *clk, unsigned long rate)
+static unsigned long v2m_osc_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct v2m_osc *osc = to_v2m_osc(hw);
+
+	return !parent_rate ? osc->rate_default : parent_rate;
+}
+
+static long v2m_osc_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *parent_rate)
 {
+	struct v2m_osc *osc = to_v2m_osc(hw);
+
+	if (WARN_ON(rate < osc->rate_min))
+		rate = osc->rate_min;
+
+	if (WARN_ON(rate > osc->rate_max))
+		rate = osc->rate_max;
+
 	return rate;
 }
 
-static int v2m_osc1_set(struct clk *clk, unsigned long rate)
+static int v2m_osc_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
 {
-	return v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE(SYS_CFG_SITE_MB) | 1,
-			rate);
+	struct v2m_osc *osc = to_v2m_osc(hw);
+
+	v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE(osc->site) |
+			SYS_CFG_STACK(osc->stack) | osc->osc, rate);
+
+	return 0;
 }
 
-static const struct clk_ops osc1_clk_ops = {
-	.round	= v2m_osc_round,
-	.set	= v2m_osc1_set,
+static struct clk_ops v2m_osc_ops = {
+	.recalc_rate = v2m_osc_recalc_rate,
+	.round_rate = v2m_osc_round_rate,
+	.set_rate = v2m_osc_set_rate,
 };
 
-static struct clk osc1_clk = {
-	.ops	= &osc1_clk_ops,
-	.rate	= 24000000,
+struct clk * __init v2m_osc_register(const char *name, struct v2m_osc *osc)
+{
+	struct clk_init_data init;
+
+	WARN_ON(osc->site > 2);
+	WARN_ON(osc->stack > 15);
+	WARN_ON(osc->osc > 4095);
+
+	init.name = name;
+	init.ops = &v2m_osc_ops;
+	init.flags = CLK_IS_ROOT;
+	init.num_parents = 0;
+
+	osc->hw.init = &init;
+
+	return clk_register(NULL, &osc->hw);
+}
+
+static struct v2m_osc v2m_mb_osc1 = {
+	.site = SYS_CFG_SITE_MB,
+	.osc = 1,
+	.rate_min = 23750000,
+	.rate_max = 63500000,
+	.rate_default = 23750000,
 };
 
-static struct clk osc2_clk = {
-	.rate	= 24000000,
+static const char *v2m_ref_clk_periphs[] __initconst = {
+	"mb:wdt",   "1000f000.wdt",  "1c0f0000.wdt",	/* SP805 WDT */
 };
 
-static struct clk v2m_sp804_clk = {
-	.rate	= 1000000,
+static const char *v2m_osc1_periphs[] __initconst = {
+	"mb:clcd",  "1001f000.clcd", "1c1f0000.clcd",	/* PL111 CLCD */
 };
 
-static struct clk v2m_ref_clk = {
-	.rate   = 32768,
+static const char *v2m_osc2_periphs[] __initconst = {
+	"mb:mmci",  "10005000.mmci", "1c050000.mmci",	/* PL180 MMCI */
+	"mb:kmi0",  "10006000.kmi",  "1c060000.kmi",	/* PL050 KMI0 */
+	"mb:kmi1",  "10007000.kmi",  "1c070000.kmi",	/* PL050 KMI1 */
+	"mb:uart0", "10009000.uart", "1c090000.uart",	/* PL011 UART0 */
+	"mb:uart1", "1000a000.uart", "1c0a0000.uart",	/* PL011 UART1 */
+	"mb:uart2", "1000b000.uart", "1c0b0000.uart",	/* PL011 UART2 */
+	"mb:uart3", "1000c000.uart", "1c0c0000.uart",	/* PL011 UART3 */
 };
 
-static struct clk dummy_apb_pclk;
-
-static struct clk_lookup v2m_lookups[] = {
-	{	/* AMBA bus clock */
-		.con_id		= "apb_pclk",
-		.clk		= &dummy_apb_pclk,
-	}, {	/* UART0 */
-		.dev_id		= "mb:uart0",
-		.clk		= &osc2_clk,
-	}, {	/* UART1 */
-		.dev_id		= "mb:uart1",
-		.clk		= &osc2_clk,
-	}, {	/* UART2 */
-		.dev_id		= "mb:uart2",
-		.clk		= &osc2_clk,
-	}, {	/* UART3 */
-		.dev_id		= "mb:uart3",
-		.clk		= &osc2_clk,
-	}, {	/* KMI0 */
-		.dev_id		= "mb:kmi0",
-		.clk		= &osc2_clk,
-	}, {	/* KMI1 */
-		.dev_id		= "mb:kmi1",
-		.clk		= &osc2_clk,
-	}, {	/* MMC0 */
-		.dev_id		= "mb:mmci",
-		.clk		= &osc2_clk,
-	}, {	/* CLCD */
-		.dev_id		= "mb:clcd",
-		.clk		= &osc1_clk,
-	}, {	/* SP805 WDT */
-		.dev_id		= "mb:wdt",
-		.clk		= &v2m_ref_clk,
-	}, {	/* SP804 timers */
-		.dev_id		= "sp804",
-		.con_id		= "v2m-timer0",
-		.clk		= &v2m_sp804_clk,
-	}, {	/* SP804 timers */
-		.dev_id		= "sp804",
-		.con_id		= "v2m-timer1",
-		.clk		= &v2m_sp804_clk,
-	},
+static void __init v2m_clk_init(void)
+{
+	struct clk *clk;
+	int i;
+
+	clk = clk_register_fixed_rate(NULL, "dummy_apb_pclk", NULL,
+			CLK_IS_ROOT, 0);
+	WARN_ON(clk_register_clkdev(clk, "apb_pclk", NULL));
+
+	clk = clk_register_fixed_rate(NULL, "mb:ref_clk", NULL,
+			CLK_IS_ROOT, 32768);
+	for (i = 0; i < ARRAY_SIZE(v2m_ref_clk_periphs); i++)
+		WARN_ON(clk_register_clkdev(clk, NULL, v2m_ref_clk_periphs[i]));
+
+	clk = clk_register_fixed_rate(NULL, "mb:sp804_clk", NULL,
+			CLK_IS_ROOT, 1000000);
+	WARN_ON(clk_register_clkdev(clk, "v2m-timer0", "sp804"));
+	WARN_ON(clk_register_clkdev(clk, "v2m-timer1", "sp804"));
+
+	clk = v2m_osc_register("mb:osc1", &v2m_mb_osc1);
+	for (i = 0; i < ARRAY_SIZE(v2m_osc1_periphs); i++)
+		WARN_ON(clk_register_clkdev(clk, NULL, v2m_osc1_periphs[i]));
+
+	clk = clk_register_fixed_rate(NULL, "mb:osc2", NULL,
+			CLK_IS_ROOT, 24000000);
+	for (i = 0; i < ARRAY_SIZE(v2m_osc2_periphs); i++)
+		WARN_ON(clk_register_clkdev(clk, NULL, v2m_osc2_periphs[i]));
+}
+
+static void __init v2m_timer_init(void)
+{
+	v2m_sysctl_init(ioremap(V2M_SYSCTL, SZ_4K));
+	v2m_clk_init();
+	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
+}
+
+static struct sys_timer v2m_timer = {
+	.init	= v2m_timer_init,
 };
 
 static void __init v2m_init_early(void)
 {
-	ct_desc->init_early();
-	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
+	if (ct_desc->init_early)
+		ct_desc->init_early();
 	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
 }
 
@@ -530,77 +567,6 @@ void __init v2m_dt_map_io(void)
 #endif
 }
 
-static struct clk_lookup v2m_dt_lookups[] = {
-	{	/* AMBA bus clock */
-		.con_id		= "apb_pclk",
-		.clk		= &dummy_apb_pclk,
-	}, {	/* SP804 timers */
-		.dev_id		= "sp804",
-		.con_id		= "v2m-timer0",
-		.clk		= &v2m_sp804_clk,
-	}, {	/* SP804 timers */
-		.dev_id		= "sp804",
-		.con_id		= "v2m-timer1",
-		.clk		= &v2m_sp804_clk,
-	}, {	/* PL180 MMCI */
-		.dev_id		= "mb:mmci", /* 10005000.mmci */
-		.clk		= &osc2_clk,
-	}, {	/* PL050 KMI0 */
-		.dev_id		= "10006000.kmi",
-		.clk		= &osc2_clk,
-	}, {	/* PL050 KMI1 */
-		.dev_id		= "10007000.kmi",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART0 */
-		.dev_id		= "10009000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART1 */
-		.dev_id		= "1000a000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART2 */
-		.dev_id		= "1000b000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART3 */
-		.dev_id		= "1000c000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* SP805 WDT */
-		.dev_id		= "1000f000.wdt",
-		.clk		= &v2m_ref_clk,
-	}, {	/* PL111 CLCD */
-		.dev_id		= "1001f000.clcd",
-		.clk		= &osc1_clk,
-	},
-	/* RS1 memory map */
-	{	/* PL180 MMCI */
-		.dev_id		= "mb:mmci", /* 1c050000.mmci */
-		.clk		= &osc2_clk,
-	}, {	/* PL050 KMI0 */
-		.dev_id		= "1c060000.kmi",
-		.clk		= &osc2_clk,
-	}, {	/* PL050 KMI1 */
-		.dev_id		= "1c070000.kmi",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART0 */
-		.dev_id		= "1c090000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART1 */
-		.dev_id		= "1c0a0000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART2 */
-		.dev_id		= "1c0b0000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* PL011 UART3 */
-		.dev_id		= "1c0c0000.uart",
-		.clk		= &osc2_clk,
-	}, {	/* SP805 WDT */
-		.dev_id		= "1c0f0000.wdt",
-		.clk		= &v2m_ref_clk,
-	}, {	/* PL111 CLCD */
-		.dev_id		= "1c1f0000.clcd",
-		.clk		= &osc1_clk,
-	},
-};
-
 void __init v2m_dt_init_early(void)
 {
 	struct device_node *node;
@@ -622,8 +588,6 @@ void __init v2m_dt_init_early(void)
 			pr_warning("vexpress: DT HBI (%x) is not matching "
 					"hardware (%x)!\n", dt_hbi, hbi);
 	}
-
-	clkdev_add_table(v2m_dt_lookups, ARRAY_SIZE(v2m_dt_lookups));
 }
 
 static  struct of_device_id vexpress_irq_match[] __initdata = {
@@ -645,6 +609,8 @@ static void __init v2m_dt_timer_init(void)
 	node = of_find_compatible_node(NULL, NULL, "arm,sp810");
 	v2m_sysctl_init(of_iomap(node, 0));
 
+	v2m_clk_init();
+
 	err = of_property_read_string(of_aliases, "arm,v2m_timer", &path);
 	if (WARN_ON(err))
 		return;

commit d927daf5c81c9b6bf2d6a83dc4c8c60268930ee5
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Jun 12 16:14:03 2012 +0100

    ARM: vexpress: Check master site in daughterboard's sysctl operations
    
    With recent enough motherboard firmware, core tile can be fitted
    in either of the two daughterboard sites. The non-DT tile code for
    V2P-CA9 did not check that when configuring DVI output nor setting
    CLCD pixel clock.
    
    Fixed now, providing "get master site" API in motherboard's code.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index fde26adaef32..bb185921fce1 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -147,6 +147,13 @@ void __init v2m_flags_set(u32 data)
 	writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);
 }
 
+int v2m_get_master_site(void)
+{
+	u32 misc = readl(v2m_sysreg_base + V2M_SYS_MISC);
+
+	return misc & SYS_MISC_MASTERSITE ? SYS_CFG_SITE_DB2 : SYS_CFG_SITE_DB1;
+}
+
 
 static struct resource v2m_pcie_i2c_resource = {
 	.start	= V2M_SERIAL_BUS_PCI,
@@ -326,7 +333,8 @@ static long v2m_osc_round(struct clk *clk, unsigned long rate)
 
 static int v2m_osc1_set(struct clk *clk, unsigned long rate)
 {
-	return v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE_MB | 1, rate);
+	return v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE(SYS_CFG_SITE_MB) | 1,
+			rate);
 }
 
 static const struct clk_ops osc1_clk_ops = {
@@ -404,13 +412,13 @@ static void __init v2m_init_early(void)
 
 static void v2m_power_off(void)
 {
-	if (v2m_cfg_write(SYS_CFG_SHUTDOWN | SYS_CFG_SITE_MB, 0))
+	if (v2m_cfg_write(SYS_CFG_SHUTDOWN | SYS_CFG_SITE(SYS_CFG_SITE_MB), 0))
 		printk(KERN_EMERG "Unable to shutdown\n");
 }
 
 static void v2m_restart(char str, const char *cmd)
 {
-	if (v2m_cfg_write(SYS_CFG_REBOOT | SYS_CFG_SITE_MB, 0))
+	if (v2m_cfg_write(SYS_CFG_REBOOT | SYS_CFG_SITE(SYS_CFG_SITE_MB), 0))
 		printk(KERN_EMERG "Unable to reboot\n");
 }
 
@@ -605,8 +613,8 @@ void __init v2m_dt_init_early(void)
 
 	/* Confirm board type against DT property, if available */
 	if (of_property_read_u32(allnodes, "arm,hbi", &dt_hbi) == 0) {
-		u32 misc = readl(v2m_sysreg_base + V2M_SYS_MISC);
-		u32 id = readl(v2m_sysreg_base + (misc & SYS_MISC_MASTERSITE ?
+		int site = v2m_get_master_site();
+		u32 id = readl(v2m_sysreg_base + (site == SYS_CFG_SITE_DB2 ?
 				V2M_SYS_PROCID1 : V2M_SYS_PROCID0));
 		u32 hbi = id & SYS_PROCIDx_HBI_MASK;
 

commit 929d138a3ba776145d2f421c2c4f16d922535090
Merge: d64f41d8d2da 67e7ebc21ff5
Author: Olof Johansson <olof@lixom.net>
Date:   Wed May 30 16:06:46 2012 -0700

    Merge branch 'late/soc' into devel-late
    
    * late/soc:
      ARM: vexpress: Remove twice included header files
      ARM: vexpress: Device Tree updates
      ARM: EXYNOS: Support suspend and resume for EXYNOS5250
      ARM: EXYNOS: Add Clock register list for save and restore
      ARM: EXYNOS: Add PMU table for EXYNOS5250
      ARM: EXYNOS: Rename of function for pm.c
      ARM: EXYNOS: Remove GIC save & restore function
      ARM: dts: Add node for interrupt combiner controller on EXYNOS5250
      ARM: S3C24XX: add support for second irq set of S3C2416

commit c533f32e1ac440b8840159f89ece8c9cca2422b5
Author: Thomas Weber <thomas@tomweber.eu>
Date:   Tue Apr 10 15:11:01 2012 +0200

    ARM: vexpress: Remove twice included header files
    
    Remove duplicates of
     - linux/device.h and
     - asm/hardware/gic.h
    
    Signed-off-by: Thomas Weber <thomas@tomweber.eu>
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 47cdcca5a7e7..e769ab612627 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -14,7 +14,6 @@
 #include <linux/ata_platform.h>
 #include <linux/smsc911x.h>
 #include <linux/spinlock.h>
-#include <linux/device.h>
 #include <linux/usb/isp1760.h>
 #include <linux/clkdev.h>
 #include <linux/mtd/physmap.h>
@@ -29,7 +28,6 @@
 #include <asm/hardware/gic.h>
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/sp810.h>
-#include <asm/hardware/gic.h>
 
 #include <mach/ct-ca9x4.h>
 #include <mach/motherboard.h>

commit 120f3d6c2309cde8b93310267ed11a9b5aa2aad4
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 28 17:13:53 2012 +0100

    ARM: vexpress: plug local timers into the DT code
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 47cdcca5a7e7..04dd092211b8 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -19,8 +19,10 @@
 #include <linux/clkdev.h>
 #include <linux/mtd/physmap.h>
 
+#include <asm/arch_timer.h>
 #include <asm/mach-types.h>
 #include <asm/sizes.h>
+#include <asm/smp_twd.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
@@ -616,7 +618,6 @@ void __init v2m_dt_init_early(void)
 	}
 
 	clkdev_add_table(v2m_dt_lookups, ARRAY_SIZE(v2m_dt_lookups));
-	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
 }
 
 static  struct of_device_id vexpress_irq_match[] __initdata = {
@@ -643,6 +644,11 @@ static void __init v2m_dt_timer_init(void)
 		return;
 	node = of_find_node_by_path(path);
 	v2m_sp804_init(of_iomap(node, 0), irq_of_parse_and_map(node, 0));
+	if (arch_timer_of_register() != 0)
+		twd_local_timer_of_register();
+
+	if (arch_timer_sched_clock_init() != 0)
+		versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
 }
 
 static struct sys_timer v2m_dt_timer = {

commit fdc24d4ba20499febb90ff17d3b75674026712f8
Merge: a5f17d1f4c28 059289b26082
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 24 12:39:18 2012 +0000

    Merge branch 'vexpress-dt-v3.3-rc4' of git://git.linaro.org/people/pawelmoll/linux into next/dt
    
    * 'vexpress-dt-v3.3-rc4' of git://git.linaro.org/people/pawelmoll/linux: (573 commits)
      ARM: vexpress: Add Device Tree for V2P-CA15 core tile (TC1 variant)
      ARM: vexpress: Add Device Tree for V2P-CA9 core tile
      ARM: vexpress: Add Device Tree for V2P-CA5s core tile
      ARM: vexpress: Motherboard RS1 memory map support
      ARM: vexpress: Add Device Tree support
      ARM: vexpress: Use FDT data in platform SMP calls
      ARM: versatile: Map local timers using Device Tree when possible
      ARM: vexpress: Get rid of MMIO_P2V
    
    This adds full device tree boot support for the versatile express
    platform, as has been awaited for a long time.
    
    Conflicts:
            arch/arm/mach-vexpress/core.h
    
    The definition of AMBA_DEVICE was removed in one branch, and the
    definition of MMIO_P2V was removed in the other branch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 6a3719562b69ffdfc36e829e19b35fda6ab19ca6
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Fri Dec 9 18:47:39 2011 +0000

    ARM: vexpress: Motherboard RS1 memory map support
    
    This patch adds support for RS1 memory map based Versatile Express
    motherboard.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index dbf055103000..9cab5417e5df 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -486,9 +486,36 @@ MACHINE_END
 
 #if defined(CONFIG_ARCH_VEXPRESS_DT)
 
+static struct map_desc v2m_rs1_io_desc __initdata = {
+	.virtual	= V2M_PERIPH,
+	.pfn		= __phys_to_pfn(0x1c000000),
+	.length		= SZ_2M,
+	.type		= MT_DEVICE,
+};
+
+static int __init v2m_dt_scan_memory_map(unsigned long node, const char *uname,
+		int depth, void *data)
+{
+	const char **map = data;
+
+	if (strcmp(uname, "motherboard") != 0)
+		return 0;
+
+	*map = of_get_flat_dt_prop(node, "arm,v2m-memory-map", NULL);
+
+	return 1;
+}
+
 void __init v2m_dt_map_io(void)
 {
-	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+	const char *map = NULL;
+
+	of_scan_flat_dt(v2m_dt_scan_memory_map, &map);
+
+	if (map && strcmp(map, "rs1") == 0)
+		iotable_init(&v2m_rs1_io_desc, 1);
+	else
+		iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
 
 #if defined(CONFIG_SMP)
 	vexpress_dt_smp_map_io();
@@ -535,6 +562,35 @@ static struct clk_lookup v2m_dt_lookups[] = {
 		.dev_id		= "1001f000.clcd",
 		.clk		= &osc1_clk,
 	},
+	/* RS1 memory map */
+	{	/* PL180 MMCI */
+		.dev_id		= "mb:mmci", /* 1c050000.mmci */
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI0 */
+		.dev_id		= "1c060000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI1 */
+		.dev_id		= "1c070000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART0 */
+		.dev_id		= "1c090000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART1 */
+		.dev_id		= "1c0a0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART2 */
+		.dev_id		= "1c0b0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART3 */
+		.dev_id		= "1c0c0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* SP805 WDT */
+		.dev_id		= "1c0f0000.wdt",
+		.clk		= &v2m_ref_clk,
+	}, {	/* PL111 CLCD */
+		.dev_id		= "1c1f0000.clcd",
+		.clk		= &osc1_clk,
+	},
 };
 
 void __init v2m_dt_init_early(void)
@@ -597,6 +653,10 @@ static struct of_dev_auxdata v2m_dt_auxdata_lookup[] __initdata = {
 	OF_DEV_AUXDATA("arm,vexpress-flash", V2M_NOR0, "physmap-flash",
 			&v2m_flash_data),
 	OF_DEV_AUXDATA("arm,primecell", V2M_MMCI, "mb:mmci", &v2m_mmci_data),
+	/* RS1 memory map */
+	OF_DEV_AUXDATA("arm,vexpress-flash", 0x08000000, "physmap-flash",
+			&v2m_flash_data),
+	OF_DEV_AUXDATA("arm,primecell", 0x1c050000, "mb:mmci", &v2m_mmci_data),
 	{}
 };
 

commit 8deed1786a6479d0ccda51226582920ab1d6976c
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Feb 23 13:04:51 2012 +0000

    ARM: vexpress: Add Device Tree support
    
    This patch adds generic Versatile Express DT machine description,
    Device Tree description for the motherboard and documentation for
    the bindings.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index c76f9144898a..dbf055103000 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -6,6 +6,10 @@
 #include <linux/amba/mmci.h>
 #include <linux/io.h>
 #include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of_fdt.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/ata_platform.h>
 #include <linux/smsc911x.h>
@@ -21,6 +25,8 @@
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/sp810.h>
 #include <asm/hardware/gic.h>
@@ -430,8 +436,9 @@ static void __init v2m_populate_ct_desc(void)
 			ct_desc = ct_descs[i];
 
 	if (!ct_desc)
-		panic("vexpress: failed to populate core tile description "
-		      "for tile ID 0x%8x\n", current_tile_id);
+		panic("vexpress: this kernel does not support core tile ID 0x%08x when booting via ATAGs.\n"
+		      "You may need a device tree blob or a different kernel to boot on this board.\n",
+		      current_tile_id);
 }
 
 static void __init v2m_map_io(void)
@@ -476,3 +483,145 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_machine	= v2m_init,
 	.restart	= v2m_restart,
 MACHINE_END
+
+#if defined(CONFIG_ARCH_VEXPRESS_DT)
+
+void __init v2m_dt_map_io(void)
+{
+	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+
+#if defined(CONFIG_SMP)
+	vexpress_dt_smp_map_io();
+#endif
+}
+
+static struct clk_lookup v2m_dt_lookups[] = {
+	{	/* AMBA bus clock */
+		.con_id		= "apb_pclk",
+		.clk		= &dummy_apb_pclk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer0",
+		.clk		= &v2m_sp804_clk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer1",
+		.clk		= &v2m_sp804_clk,
+	}, {	/* PL180 MMCI */
+		.dev_id		= "mb:mmci", /* 10005000.mmci */
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI0 */
+		.dev_id		= "10006000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI1 */
+		.dev_id		= "10007000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART0 */
+		.dev_id		= "10009000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART1 */
+		.dev_id		= "1000a000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART2 */
+		.dev_id		= "1000b000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART3 */
+		.dev_id		= "1000c000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* SP805 WDT */
+		.dev_id		= "1000f000.wdt",
+		.clk		= &v2m_ref_clk,
+	}, {	/* PL111 CLCD */
+		.dev_id		= "1001f000.clcd",
+		.clk		= &osc1_clk,
+	},
+};
+
+void __init v2m_dt_init_early(void)
+{
+	struct device_node *node;
+	u32 dt_hbi;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,vexpress-sysreg");
+	v2m_sysreg_base = of_iomap(node, 0);
+	if (WARN_ON(!v2m_sysreg_base))
+		return;
+
+	/* Confirm board type against DT property, if available */
+	if (of_property_read_u32(allnodes, "arm,hbi", &dt_hbi) == 0) {
+		u32 misc = readl(v2m_sysreg_base + V2M_SYS_MISC);
+		u32 id = readl(v2m_sysreg_base + (misc & SYS_MISC_MASTERSITE ?
+				V2M_SYS_PROCID1 : V2M_SYS_PROCID0));
+		u32 hbi = id & SYS_PROCIDx_HBI_MASK;
+
+		if (WARN_ON(dt_hbi != hbi))
+			pr_warning("vexpress: DT HBI (%x) is not matching "
+					"hardware (%x)!\n", dt_hbi, hbi);
+	}
+
+	clkdev_add_table(v2m_dt_lookups, ARRAY_SIZE(v2m_dt_lookups));
+	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
+}
+
+static  struct of_device_id vexpress_irq_match[] __initdata = {
+	{ .compatible = "arm,cortex-a9-gic", .data = gic_of_init, },
+	{}
+};
+
+static void __init v2m_dt_init_irq(void)
+{
+	of_irq_init(vexpress_irq_match);
+}
+
+static void __init v2m_dt_timer_init(void)
+{
+	struct device_node *node;
+	const char *path;
+	int err;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,sp810");
+	v2m_sysctl_init(of_iomap(node, 0));
+
+	err = of_property_read_string(of_aliases, "arm,v2m_timer", &path);
+	if (WARN_ON(err))
+		return;
+	node = of_find_node_by_path(path);
+	v2m_sp804_init(of_iomap(node, 0), irq_of_parse_and_map(node, 0));
+}
+
+static struct sys_timer v2m_dt_timer = {
+	.init = v2m_dt_timer_init,
+};
+
+static struct of_dev_auxdata v2m_dt_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("arm,vexpress-flash", V2M_NOR0, "physmap-flash",
+			&v2m_flash_data),
+	OF_DEV_AUXDATA("arm,primecell", V2M_MMCI, "mb:mmci", &v2m_mmci_data),
+	{}
+};
+
+static void __init v2m_dt_init(void)
+{
+	l2x0_of_init(0x00400000, 0xfe0fffff);
+	of_platform_populate(NULL, of_default_bus_match_table,
+			v2m_dt_auxdata_lookup, NULL);
+	pm_power_off = v2m_power_off;
+}
+
+const static char *v2m_dt_match[] __initconst = {
+	"arm,vexpress",
+	NULL,
+};
+
+DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
+	.dt_compat	= v2m_dt_match,
+	.map_io		= v2m_dt_map_io,
+	.init_early	= v2m_dt_init_early,
+	.init_irq	= v2m_dt_init_irq,
+	.timer		= &v2m_dt_timer,
+	.init_machine	= v2m_dt_init,
+	.handle_irq	= gic_handle_irq,
+	.restart	= v2m_restart,
+MACHINE_END
+
+#endif

commit 98ed4ceb93ba22268f35ebcbb7de0cb1c7e70231
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Wed Jan 25 15:37:29 2012 +0000

    ARM: vexpress: Get rid of MMIO_P2V
    
    This patch gets rid of the MMIO_P2V and __MMIO_P2V macros,
    defining constant virtual base for motherboard and tile
    peripherals instead.
    
    Additionally, in preparation for the new motherboard memory
    map, the motherboard peripherals are using base pointers
    calculated in runtime, instead of compile-time calculated
    values.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index b4a28ca0e50a..c76f9144898a 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -40,29 +40,45 @@
 
 static struct map_desc v2m_io_desc[] __initdata = {
 	{
-		.virtual	= __MMIO_P2V(V2M_PA_CS7),
+		.virtual	= V2M_PERIPH,
 		.pfn		= __phys_to_pfn(V2M_PA_CS7),
 		.length		= SZ_128K,
 		.type		= MT_DEVICE,
 	},
 };
 
-static void __init v2m_timer_init(void)
+static void __iomem *v2m_sysreg_base;
+
+static void __init v2m_sysctl_init(void __iomem *base)
 {
 	u32 scctrl;
 
+	if (WARN_ON(!base))
+		return;
+
 	/* Select 1MHz TIMCLK as the reference clock for SP804 timers */
-	scctrl = readl(MMIO_P2V(V2M_SYSCTL + SCCTRL));
+	scctrl = readl(base + SCCTRL);
 	scctrl |= SCCTRL_TIMEREN0SEL_TIMCLK;
 	scctrl |= SCCTRL_TIMEREN1SEL_TIMCLK;
-	writel(scctrl, MMIO_P2V(V2M_SYSCTL + SCCTRL));
+	writel(scctrl, base + SCCTRL);
+}
 
-	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
-	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
+static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
+{
+	if (WARN_ON(!base || irq == NO_IRQ))
+		return;
+
+	writel(0, base + TIMER_1_BASE + TIMER_CTRL);
+	writel(0, base + TIMER_2_BASE + TIMER_CTRL);
 
-	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1), "v2m-timer1");
-	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0,
-		"v2m-timer0");
+	sp804_clocksource_init(base + TIMER_2_BASE, "v2m-timer1");
+	sp804_clockevents_init(base + TIMER_1_BASE, irq, "v2m-timer0");
+}
+
+static void __init v2m_timer_init(void)
+{
+	v2m_sysctl_init(ioremap(V2M_SYSCTL, SZ_4K));
+	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
 }
 
 static struct sys_timer v2m_timer = {
@@ -82,14 +98,14 @@ int v2m_cfg_write(u32 devfn, u32 data)
 	devfn |= SYS_CFG_START | SYS_CFG_WRITE;
 
 	spin_lock(&v2m_cfg_lock);
-	val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
-	writel(val & ~SYS_CFG_COMPLETE, MMIO_P2V(V2M_SYS_CFGSTAT));
+	val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
+	writel(val & ~SYS_CFG_COMPLETE, v2m_sysreg_base + V2M_SYS_CFGSTAT);
 
-	writel(data, MMIO_P2V(V2M_SYS_CFGDATA));
-	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+	writel(data, v2m_sysreg_base +  V2M_SYS_CFGDATA);
+	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
 
 	do {
-		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
 	} while (val == 0);
 	spin_unlock(&v2m_cfg_lock);
 
@@ -103,22 +119,28 @@ int v2m_cfg_read(u32 devfn, u32 *data)
 	devfn |= SYS_CFG_START;
 
 	spin_lock(&v2m_cfg_lock);
-	writel(0, MMIO_P2V(V2M_SYS_CFGSTAT));
-	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+	writel(0, v2m_sysreg_base + V2M_SYS_CFGSTAT);
+	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
 
 	mb();
 
 	do {
 		cpu_relax();
-		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
 	} while (val == 0);
 
-	*data = readl(MMIO_P2V(V2M_SYS_CFGDATA));
+	*data = readl(v2m_sysreg_base + V2M_SYS_CFGDATA);
 	spin_unlock(&v2m_cfg_lock);
 
 	return !!(val & SYS_CFG_ERR);
 }
 
+void __init v2m_flags_set(u32 data)
+{
+	writel(~0, v2m_sysreg_base + V2M_SYS_FLAGSCLR);
+	writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);
+}
+
 
 static struct resource v2m_pcie_i2c_resource = {
 	.start	= V2M_SERIAL_BUS_PCI,
@@ -204,7 +226,7 @@ static struct platform_device v2m_usb_device = {
 
 static void v2m_flash_set_vpp(struct platform_device *pdev, int on)
 {
-	writel(on != 0, MMIO_P2V(V2M_SYS_FLASH));
+	writel(on != 0, v2m_sysreg_base + V2M_SYS_FLASH);
 }
 
 static struct physmap_flash_data v2m_flash_data = {
@@ -258,7 +280,7 @@ static struct platform_device v2m_cf_device = {
 
 static unsigned int v2m_mmci_status(struct device *dev)
 {
-	return readl(MMIO_P2V(V2M_SYS_MCI)) & (1 << 0);
+	return readl(v2m_sysreg_base + V2M_SYS_MCI) & (1 << 0);
 }
 
 static struct mmci_platform_data v2m_mmci_data = {
@@ -371,7 +393,7 @@ static void __init v2m_init_early(void)
 {
 	ct_desc->init_early();
 	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
-	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
+	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
 }
 
 static void v2m_power_off(void)
@@ -400,7 +422,8 @@ static void __init v2m_populate_ct_desc(void)
 	u32 current_tile_id;
 
 	ct_desc = NULL;
-	current_tile_id = readl(MMIO_P2V(V2M_SYS_PROCID0)) & V2M_CT_ID_MASK;
+	current_tile_id = readl(v2m_sysreg_base + V2M_SYS_PROCID0)
+				& V2M_CT_ID_MASK;
 
 	for (i = 0; i < ARRAY_SIZE(ct_descs) && !ct_desc; ++i)
 		if (ct_descs[i]->id == current_tile_id)
@@ -414,6 +437,7 @@ static void __init v2m_populate_ct_desc(void)
 static void __init v2m_map_io(void)
 {
 	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+	v2m_sysreg_base = ioremap(V2M_SYSREGS, SZ_4K);
 	v2m_populate_ct_desc();
 	ct_desc->map_io();
 }

commit cdd4e1a76cef22bb0368da7eba6f5a44bccb89b0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 12:07:09 2011 +0000

    ARM: amba: vexpress: get rid of private platform amba_device initializer
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index b4a28ca0e50a..ad64f97a2003 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -266,16 +266,16 @@ static struct mmci_platform_data v2m_mmci_data = {
 	.status		= v2m_mmci_status,
 };
 
-static AMBA_DEVICE(aaci,  "mb:aaci",  V2M_AACI, NULL);
-static AMBA_DEVICE(mmci,  "mb:mmci",  V2M_MMCI, &v2m_mmci_data);
-static AMBA_DEVICE(kmi0,  "mb:kmi0",  V2M_KMI0, NULL);
-static AMBA_DEVICE(kmi1,  "mb:kmi1",  V2M_KMI1, NULL);
-static AMBA_DEVICE(uart0, "mb:uart0", V2M_UART0, NULL);
-static AMBA_DEVICE(uart1, "mb:uart1", V2M_UART1, NULL);
-static AMBA_DEVICE(uart2, "mb:uart2", V2M_UART2, NULL);
-static AMBA_DEVICE(uart3, "mb:uart3", V2M_UART3, NULL);
-static AMBA_DEVICE(wdt,   "mb:wdt",   V2M_WDT, NULL);
-static AMBA_DEVICE(rtc,   "mb:rtc",   V2M_RTC, NULL);
+static AMBA_APB_DEVICE(aaci,  "mb:aaci",  0, V2M_AACI, IRQ_V2M_AACI, NULL);
+static AMBA_APB_DEVICE(mmci,  "mb:mmci",  0, V2M_MMCI, IRQ_V2M_MMCI, &v2m_mmci_data);
+static AMBA_APB_DEVICE(kmi0,  "mb:kmi0",  0, V2M_KMI0, IRQ_V2M_KMI0, NULL);
+static AMBA_APB_DEVICE(kmi1,  "mb:kmi1",  0, V2M_KMI1, IRQ_V2M_KMI1, NULL);
+static AMBA_APB_DEVICE(uart0, "mb:uart0", 0, V2M_UART0, IRQ_V2M_UART0, NULL);
+static AMBA_APB_DEVICE(uart1, "mb:uart1", 0, V2M_UART1, IRQ_V2M_UART1, NULL);
+static AMBA_APB_DEVICE(uart2, "mb:uart2", 0, V2M_UART2, IRQ_V2M_UART2, NULL);
+static AMBA_APB_DEVICE(uart3, "mb:uart3", 0, V2M_UART3, IRQ_V2M_UART3, NULL);
+static AMBA_APB_DEVICE(wdt,   "mb:wdt",   0, V2M_WDT, IRQ_V2M_WDT, NULL);
+static AMBA_APB_DEVICE(rtc,   "mb:rtc",   0, V2M_RTC, IRQ_V2M_RTC, NULL);
 
 static struct amba_device *v2m_amba_devs[] __initdata = {
 	&aaci_device,

commit 7affca3537d74365128e477b40c529d6f2fe86c8
Merge: 356b95424cfb ff4b8a57f0aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 7 12:03:30 2012 -0800

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (73 commits)
      arm: fix up some samsung merge sysdev conversion problems
      firmware: Fix an oops on reading fw_priv->fw in sysfs loading file
      Drivers:hv: Fix a bug in vmbus_driver_unregister()
      driver core: remove __must_check from device_create_file
      debugfs: add missing #ifdef HAS_IOMEM
      arm: time.h: remove device.h #include
      driver-core: remove sysdev.h usage.
      clockevents: remove sysdev.h
      arm: convert sysdev_class to a regular subsystem
      arm: leds: convert sysdev_class to a regular subsystem
      kobject: remove kset_find_obj_hinted()
      m86k: gpio - convert sysdev_class to a regular subsystem
      mips: txx9_sram - convert sysdev_class to a regular subsystem
      mips: 7segled - convert sysdev_class to a regular subsystem
      sh: dma - convert sysdev_class to a regular subsystem
      sh: intc - convert sysdev_class to a regular subsystem
      power: suspend - convert sysdev_class to a regular subsystem
      power: qe_ic - convert sysdev_class to a regular subsystem
      power: cmm - convert sysdev_class to a regular subsystem
      s390: time - convert sysdev_class to a regular subsystem
      ...
    
    Fix up conflicts with 'struct sysdev' removal from various platform
    drivers that got changed:
     - arch/arm/mach-exynos/cpu.c
     - arch/arm/mach-exynos/irq-eint.c
     - arch/arm/mach-s3c64xx/common.c
     - arch/arm/mach-s3c64xx/cpu.c
     - arch/arm/mach-s5p64x0/cpu.c
     - arch/arm/mach-s5pv210/common.c
     - arch/arm/plat-samsung/include/plat/cpu.h
     - arch/powerpc/kernel/sysfs.c
    and fix up cpu_is_hotpluggable() as per Greg in include/linux/cpu.h

commit 7b9dd47136c07ffd883aff6926c7b281e4c1eea4
Merge: 2e0e94343691 0575fb754dbf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 13:25:15 2012 +0000

    Merge branch 'restart' into for-linus
    
    Conflicts:
            arch/arm/mach-exynos/cpu.c
    
    The changes to arch/arm/mach-exynos/cpu.c were moved to
    mach-exynos/common.c.

commit f5733a1e80fa0b40bea815ddf605ece272c6dac1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Nov 4 15:47:50 2011 +0000

    ARM: restart: Versatile Express: use new restart hook
    
    Hook the Versatile Express platform restart code into the new restart
    hook.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 1fafc3244607..b9a465bd2d0f 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -437,7 +437,6 @@ static void __init v2m_init(void)
 		amba_device_register(v2m_amba_devs[i], &iomem_resource);
 
 	pm_power_off = v2m_power_off;
-	arm_pm_restart = v2m_restart;
 
 	ct_desc->init_tile();
 }
@@ -449,4 +448,5 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_irq	= v2m_init_irq,
 	.timer		= &v2m_timer,
 	.init_machine	= v2m_init,
+	.restart	= v2m_restart,
 MACHINE_END

commit edbaa603eb801655e80808a9cf3d3b622e8ac66b
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 16:26:03 2011 -0800

    driver-core: remove sysdev.h usage.
    
    The sysdev.h file should not be needed by any in-kernel code, so remove
    the .h file from these random files that seem to still want to include
    it.
    
    The sysdev code will be going away soon, so this include needs to be
    removed no matter what.
    
    Cc: Jiandong Zheng <jdzheng@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: "Venkatesh Pallipadi
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 1fafc3244607..de5a2384284b 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -10,7 +10,7 @@
 #include <linux/ata_platform.h>
 #include <linux/smsc911x.h>
 #include <linux/spinlock.h>
-#include <linux/sysdev.h>
+#include <linux/device.h>
 #include <linux/usb/isp1760.h>
 #include <linux/clkdev.h>
 #include <linux/mtd/physmap.h>

commit abd3ca51fba8bc200ae78e99bd1ac19c4e3b6781
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Sep 6 10:23:45 2011 +0100

    ARM: VExpress: convert to CONFIG_MULTI_IRQ_HANDLER
    
    Convert the VExpress platform to be using the gic_handle_irq
    function as its primary interrupt handler.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 1fafc3244607..7aa07a8ce232 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -23,6 +23,7 @@
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/sp810.h>
+#include <asm/hardware/gic.h>
 
 #include <mach/ct-ca9x4.h>
 #include <mach/motherboard.h>
@@ -448,5 +449,6 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_early	= v2m_init_early,
 	.init_irq	= v2m_init_irq,
 	.timer		= &v2m_timer,
+	.handle_irq	= gic_handle_irq,
 	.init_machine	= v2m_init,
 MACHINE_END

commit 4722cd7741c6404f967f7a7b8b666540b6c1663e
Merge: 1db3706b05b1 4fb0d2ea397a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Sep 16 21:45:16 2011 +0100

    Merge branch 'for-rmk' of git://linux-arm.org/linux-2.6-wd into devel-stable
    
    Conflicts:
            arch/arm/mach-imx/mach-cpuimx27.c

commit 0ebb962e00a52b644433065d224ed89f72a84756
Author: Nick Bowler <nbowler@elliptictech.com>
Date:   Wed Jul 20 15:43:42 2011 +0100

    ARM: 7003/1: vexpress: Add clock definition for the SP805.
    
    It seems that an entry for the SP805 watchdog in the table of clocks was
    missing.  This results in the sp805_wdt driver rejecting the device with
    the following errors:
    
      sp805-wdt mb:wdt: Clock not found
      sp805-wdt mb:wdt: Probe Failed!!!
      sp805-wdt: probe of mb:wdt failed with error -2
    
    While not obviously stated in the hardware docs, the onboard SP810's
    "REFCLK" is connected to a 32.768KHz crystal, and this drives the
    watchdog.  Add a struct clk and corresponding lookup entry for it.
    
    Signed-off-by: Nick Bowler <nbowler@elliptictech.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 9e6b93b1a043..d0d267a8d3f9 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -318,6 +318,10 @@ static struct clk v2m_sp804_clk = {
 	.rate	= 1000000,
 };
 
+static struct clk v2m_ref_clk = {
+	.rate   = 32768,
+};
+
 static struct clk dummy_apb_pclk;
 
 static struct clk_lookup v2m_lookups[] = {
@@ -348,6 +352,9 @@ static struct clk_lookup v2m_lookups[] = {
 	}, {	/* CLCD */
 		.dev_id		= "mb:clcd",
 		.clk		= &osc1_clk,
+	}, {	/* SP805 WDT */
+		.dev_id		= "mb:wdt",
+		.clk		= &v2m_ref_clk,
 	}, {	/* SP804 timers */
 		.dev_id		= "sp804",
 		.con_id		= "v2m-timer0",

commit e9ce8e5bd0314e90b60e185ca40b1d4740df7f22
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jul 5 22:38:18 2011 -0400

    ARM: vexpress: convert boot_params to atag_offset
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 9e6b93b1a043..de72058180a6 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -436,7 +436,7 @@ static void __init v2m_init(void)
 }
 
 MACHINE_START(VEXPRESS, "ARM-Versatile Express")
-	.boot_params	= PLAT_PHYS_OFFSET + 0x00000100,
+	.atag_offset	= 0x100,
 	.map_io		= v2m_map_io,
 	.init_early	= v2m_init_early,
 	.init_irq	= v2m_init_irq,

commit 2fdf99934c2c39848ad3633ce504a0262f21faf9
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon May 30 19:44:22 2011 +0100

    ARM: 6946/1: vexpress: move v2m clock init to init_early
    
    Commit 7ff550de99141cbd3be0129d563cc4554fdde9f6 breaks vexpress booting. The
    v2m clock table needs to be setup in init_early before the timer
    initialization occurs.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 285edcd2da2a..9e6b93b1a043 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -46,12 +46,6 @@ static struct map_desc v2m_io_desc[] __initdata = {
 	},
 };
 
-static void __init v2m_init_early(void)
-{
-	ct_desc->init_early();
-	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
-}
-
 static void __init v2m_timer_init(void)
 {
 	u32 scctrl;
@@ -365,6 +359,13 @@ static struct clk_lookup v2m_lookups[] = {
 	},
 };
 
+static void __init v2m_init_early(void)
+{
+	ct_desc->init_early();
+	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
+	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
+}
+
 static void v2m_power_off(void)
 {
 	if (v2m_cfg_write(SYS_CFG_SHUTDOWN | SYS_CFG_SITE_MB, 0))
@@ -418,8 +419,6 @@ static void __init v2m_init(void)
 {
 	int i;
 
-	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
-
 	platform_device_register(&v2m_pcie_i2c_device);
 	platform_device_register(&v2m_ddc_i2c_device);
 	platform_device_register(&v2m_flash_device);

commit 4b60e5f90dec4ae251386f20464336369e962e9c
Merge: e8765afe54b7 667f390bee98 a35d4e587371 4d5336d50a7b 041f10d46f97 be20902ba67d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon May 23 18:05:10 2011 +0100

    Merge branches 'consolidate-clksrc', 'consolidate-flash', 'consolidate-generic', 'consolidate-smp', 'consolidate-stmp' and 'consolidate-zones' into consolidate

commit 23828a7a976eb8dbe3b5f4e83584c3fe814b295b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 15:45:16 2011 +0100

    clockevents: ARM sp804: obtain sp804 timer rate via clks
    
    This allows platforms to specify the rate of the SP804 clockevent via
    the clk subsystem.  While ARM boards clock these at 1MHz, BCMRing also
    has SP804 timers but are clocked at different rates.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index f6fecdd0fbe8..9d9d4af384e2 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -368,6 +368,10 @@ static struct clk_lookup v2m_lookups[] = {
 	}, {	/* CLCD */
 		.dev_id		= "mb:clcd",
 		.clk		= &osc1_clk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer0",
+		.clk		= &v2m_sp804_clk,
 	}, {	/* SP804 timers */
 		.dev_id		= "sp804",
 		.con_id		= "v2m-timer1",

commit 57cc4f7de2b896ca79185e337eaf7ff9906c4656
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 15:31:13 2011 +0100

    clockevents: ARM sp804: allow clockevent name to be specified
    
    This allows platforms to specify the clcokevent name upon registration.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 77d5db3d7808..f6fecdd0fbe8 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -66,7 +66,8 @@ static void __init v2m_timer_init(void)
 	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
 
 	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1), "v2m-timer1");
-	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0);
+	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0,
+		"v2m-timer0");
 }
 
 static struct sys_timer v2m_timer = {

commit 7ff550de99141cbd3be0129d563cc4554fdde9f6
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 13:31:48 2011 +0100

    clocksource: ARM sp804: obtain sp804 timer rate via clks
    
    This allows platforms to specify the rate of the SP804 clocksource via
    the clk subsystem.  While ARM boards clock these at 1MHz, BCMRing also
    has SP804 timers but are clocked at different rates.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index ccf1f899ac21..77d5db3d7808 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -333,6 +333,10 @@ static struct clk osc2_clk = {
 	.rate	= 24000000,
 };
 
+static struct clk v2m_sp804_clk = {
+	.rate	= 1000000,
+};
+
 static struct clk dummy_apb_pclk;
 
 static struct clk_lookup v2m_lookups[] = {
@@ -363,6 +367,10 @@ static struct clk_lookup v2m_lookups[] = {
 	}, {	/* CLCD */
 		.dev_id		= "mb:clcd",
 		.clk		= &osc1_clk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer1",
+		.clk		= &v2m_sp804_clk,
 	},
 };
 

commit fb593cf38fc426331275d761fefe13096070f56a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 12:08:23 2011 +0100

    clocksource: ARM sp804: allow clocksource name to be specified
    
    This allows platforms to specify the clocksource name upon
    registration, which is necessary should they wish to register more
    than one sp804 clocksource.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index ba46e8e07437..ccf1f899ac21 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -65,7 +65,7 @@ static void __init v2m_timer_init(void)
 	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
 	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
 
-	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1));
+	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1), "v2m-timer1");
 	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0);
 }
 

commit 667f390bee987d45351402e42008c52cdfb77d76
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Wed May 18 10:51:55 2011 +0100

    ARM: 6910/1: MTD: physmap: let set_vpp() pass a platform_device instead of a map_info
    
    The set_vpp() method provided by physmap passes a map_info back to
    the platform code, which has little relevance as far as the platform
    is concerned (this parameter is completely unused).
    
    Instead, pass the platform_device, which can be used in the pismo
    driver to retrieve some important information in a nicer way, instead
    of the hack that was in place.
    
    The empty set_vpp function in board-at572d940hf_ek.c is left untouched,
    as the board/SoC is scheduled for removal.
    
    Cc: Andrew Victor <linux@maxim.org.za>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Philipp Zabel <philipp.zabel@gmail.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Acked-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Acked-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index e3268152c834..f860314ef7f6 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -206,7 +206,7 @@ static struct platform_device v2m_usb_device = {
 	.dev.platform_data = &v2m_usb_config,
 };
 
-static void v2m_flash_set_vpp(struct map_info *map, int on)
+static void v2m_flash_set_vpp(struct platform_device *pdev, int on)
 {
 	writel(on != 0, MMIO_P2V(V2M_SYS_FLASH));
 }

commit 0f71fd492d99a005db7d0050a5ce8a733ffc2a1e
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Wed May 18 10:51:51 2011 +0100

    ARM: 6909/1: VExpress: Use physmap driver instead of integrator-flash
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index ba46e8e07437..e3268152c834 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -13,11 +13,11 @@
 #include <linux/sysdev.h>
 #include <linux/usb/isp1760.h>
 #include <linux/clkdev.h>
+#include <linux/mtd/physmap.h>
 
 #include <asm/mach-types.h>
 #include <asm/sizes.h>
 #include <asm/mach/arch.h>
-#include <asm/mach/flash.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
@@ -206,27 +206,13 @@ static struct platform_device v2m_usb_device = {
 	.dev.platform_data = &v2m_usb_config,
 };
 
-static int v2m_flash_init(void)
-{
-	writel(0, MMIO_P2V(V2M_SYS_FLASH));
-	return 0;
-}
-
-static void v2m_flash_exit(void)
-{
-	writel(0, MMIO_P2V(V2M_SYS_FLASH));
-}
-
-static void v2m_flash_set_vpp(int on)
+static void v2m_flash_set_vpp(struct map_info *map, int on)
 {
 	writel(on != 0, MMIO_P2V(V2M_SYS_FLASH));
 }
 
-static struct flash_platform_data v2m_flash_data = {
-	.map_name	= "cfi_probe",
+static struct physmap_flash_data v2m_flash_data = {
 	.width		= 4,
-	.init		= v2m_flash_init,
-	.exit		= v2m_flash_exit,
 	.set_vpp	= v2m_flash_set_vpp,
 };
 
@@ -243,7 +229,7 @@ static struct resource v2m_flash_resources[] = {
 };
 
 static struct platform_device v2m_flash_device = {
-	.name		= "armflash",
+	.name		= "physmap-flash",
 	.id		= -1,
 	.resource	= v2m_flash_resources,
 	.num_resources	= ARRAY_SIZE(v2m_flash_resources),

commit 80b5efbd43f0a21e9fc6db87823be32fcfe3e7ce
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Feb 28 17:01:04 2011 +0100

    ARM: 6771/1: vexpress: add support for multiple core tiles
    
    The current Versatile Express BSP defines the MACHINE_START macro
    in the core tile code.
    
    This patch moves this into the generic board code and introduces a
    method for determining the current tile at runtime, allowing the
    Kernel to have support for multiple tiles compiled in. Tile-specific
    functions are executed via a descriptor struct containing the correct
    implementations for the current tile.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 63ef663fb0be..ba46e8e07437 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -14,7 +14,9 @@
 #include <linux/usb/isp1760.h>
 #include <linux/clkdev.h>
 
+#include <asm/mach-types.h>
 #include <asm/sizes.h>
+#include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
@@ -22,6 +24,7 @@
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/sp810.h>
 
+#include <mach/ct-ca9x4.h>
 #include <mach/motherboard.h>
 
 #include <plat/sched_clock.h>
@@ -43,14 +46,9 @@ static struct map_desc v2m_io_desc[] __initdata = {
 	},
 };
 
-void __init v2m_map_io(struct map_desc *tile, size_t num)
-{
-	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
-	iotable_init(tile, num);
-}
-
-void __init v2m_init_early(void)
+static void __init v2m_init_early(void)
 {
+	ct_desc->init_early();
 	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
 }
 
@@ -71,7 +69,7 @@ static void __init v2m_timer_init(void)
 	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0);
 }
 
-struct sys_timer v2m_timer = {
+static struct sys_timer v2m_timer = {
 	.init	= v2m_timer_init,
 };
 
@@ -380,7 +378,44 @@ static void v2m_restart(char str, const char *cmd)
 		printk(KERN_EMERG "Unable to reboot\n");
 }
 
-static int __init v2m_init(void)
+struct ct_desc *ct_desc;
+
+static struct ct_desc *ct_descs[] __initdata = {
+#ifdef CONFIG_ARCH_VEXPRESS_CA9X4
+	&ct_ca9x4_desc,
+#endif
+};
+
+static void __init v2m_populate_ct_desc(void)
+{
+	int i;
+	u32 current_tile_id;
+
+	ct_desc = NULL;
+	current_tile_id = readl(MMIO_P2V(V2M_SYS_PROCID0)) & V2M_CT_ID_MASK;
+
+	for (i = 0; i < ARRAY_SIZE(ct_descs) && !ct_desc; ++i)
+		if (ct_descs[i]->id == current_tile_id)
+			ct_desc = ct_descs[i];
+
+	if (!ct_desc)
+		panic("vexpress: failed to populate core tile description "
+		      "for tile ID 0x%8x\n", current_tile_id);
+}
+
+static void __init v2m_map_io(void)
+{
+	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+	v2m_populate_ct_desc();
+	ct_desc->map_io();
+}
+
+static void __init v2m_init_irq(void)
+{
+	ct_desc->init_irq();
+}
+
+static void __init v2m_init(void)
 {
 	int i;
 
@@ -399,6 +434,14 @@ static int __init v2m_init(void)
 	pm_power_off = v2m_power_off;
 	arm_pm_restart = v2m_restart;
 
-	return 0;
+	ct_desc->init_tile();
 }
-arch_initcall(v2m_init);
+
+MACHINE_START(VEXPRESS, "ARM-Versatile Express")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x00000100,
+	.map_io		= v2m_map_io,
+	.init_early	= v2m_init_early,
+	.init_irq	= v2m_init_irq,
+	.timer		= &v2m_timer,
+	.init_machine	= v2m_init,
+MACHINE_END

commit 493a451bb559476d2f7f189670be2172ca3010b4
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 11 13:07:52 2011 +0000

    ARM: vexpress: use new init_early for clock tree and sched_clock init
    
    Initialize the clock tree and our sched_clock() early.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index f35d646a1bf1..63ef663fb0be 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -49,13 +49,15 @@ void __init v2m_map_io(struct map_desc *tile, size_t num)
 	iotable_init(tile, num);
 }
 
+void __init v2m_init_early(void)
+{
+	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
+}
 
 static void __init v2m_timer_init(void)
 {
 	u32 scctrl;
 
-	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
-
 	/* Select 1MHz TIMCLK as the reference clock for SP804 timers */
 	scctrl = readl(MMIO_P2V(V2M_SYSCTL + SCCTRL));
 	scctrl |= SCCTRL_TIMEREN0SEL_TIMCLK;

commit 95c34f831f0e06cda6dc0a26b4f693ed105c394d
Author: Nick Bowler <nbowler@elliptictech.com>
Date:   Fri Jan 21 15:51:06 2011 +0100

    ARM: 6633/1: vexpress: register platform PATA device.
    
    The compactflash device on this platform is not usable simply because it
    is never registered with the kernel.  Fix that up.
    
    Signed-off-by: Nick Bowler <nbowler@elliptictech.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 1edae65a0e72..f35d646a1bf1 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -7,6 +7,7 @@
 #include <linux/io.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/ata_platform.h>
 #include <linux/smsc911x.h>
 #include <linux/spinlock.h>
 #include <linux/sysdev.h>
@@ -249,6 +250,29 @@ static struct platform_device v2m_flash_device = {
 	.dev.platform_data = &v2m_flash_data,
 };
 
+static struct pata_platform_info v2m_pata_data = {
+	.ioport_shift	= 2,
+};
+
+static struct resource v2m_pata_resources[] = {
+	{
+		.start	= V2M_CF,
+		.end	= V2M_CF + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= V2M_CF + 0x100,
+		.end	= V2M_CF + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device v2m_cf_device = {
+	.name		= "pata_platform",
+	.id		= -1,
+	.resource	= v2m_pata_resources,
+	.num_resources	= ARRAY_SIZE(v2m_pata_resources),
+	.dev.platform_data = &v2m_pata_data,
+};
 
 static unsigned int v2m_mmci_status(struct device *dev)
 {
@@ -363,6 +387,7 @@ static int __init v2m_init(void)
 	platform_device_register(&v2m_pcie_i2c_device);
 	platform_device_register(&v2m_ddc_i2c_device);
 	platform_device_register(&v2m_flash_device);
+	platform_device_register(&v2m_cf_device);
 	platform_device_register(&v2m_eth_device);
 	platform_device_register(&v2m_usb_device);
 

commit baaece224570a935210a59257b5d9073e99843ea
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Tue Jan 25 15:53:03 2011 +0100

    ARM: 6635/2: Configure reference clock for Versatile Express timers
    
    Timers on Versatile Express mainboard are used as system clock/event
    sources. Driver assumes that they are clocked with 1MHz signal.
    Old V2M firmware apparently configured it by default, but on newer
    boards one can observe that "sleep 1" command takes over 30 seconds
    to finish, as the timers are fed with 32kHz instead...
    
    This patch performs required magic and also removes code clearing
    timer's control registers, as exactly the same operations are
    performed by the timer driver few jiffies later.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index a9ed3428a2fa..1edae65a0e72 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -19,6 +19,7 @@
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/timer-sp.h>
+#include <asm/hardware/sp810.h>
 
 #include <mach/motherboard.h>
 
@@ -50,8 +51,16 @@ void __init v2m_map_io(struct map_desc *tile, size_t num)
 
 static void __init v2m_timer_init(void)
 {
+	u32 scctrl;
+
 	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
 
+	/* Select 1MHz TIMCLK as the reference clock for SP804 timers */
+	scctrl = readl(MMIO_P2V(V2M_SYSCTL + SCCTRL));
+	scctrl |= SCCTRL_TIMEREN0SEL_TIMCLK;
+	scctrl |= SCCTRL_TIMEREN1SEL_TIMCLK;
+	writel(scctrl, MMIO_P2V(V2M_SYSCTL + SCCTRL));
+
 	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
 	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
 

commit 4073723acb9cdcdbe4df9c0e0c376c65d1697e43
Merge: 58daf18cdcab 4ec3eb136345
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:32:52 2011 +0000

    Merge branch 'misc' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/common/Makefile
            arch/arm/kernel/Makefile
            arch/arm/kernel/smp.c

commit 58daf18cdcab550262a5f4681e1f1e073e21965a
Merge: aa312be1987d 0af85dda39d9
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jan 5 18:09:03 2011 +0000

    Merge branch 'clksrc' into devel
    
    Conflicts:
            arch/arm/mach-vexpress/v2m.c
            arch/arm/plat-omap/counter_32k.c
            arch/arm/plat-versatile/Makefile

commit 0af85dda39d9b673aca8c0ebae004ea70f3efc93
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 21:58:50 2010 +0000

    ARM: vexpress: add sched_clock() for Versatile Express
    
    Add a sched_clock() implementation to Versatile Express using the new
    sched_clock() infrastructure for extending 32bit counters to full
    64-bit nanoseconds.
    
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 7eaa232180a5..8c283100a9a0 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -22,6 +22,8 @@
 #include <mach/clkdev.h>
 #include <mach/motherboard.h>
 
+#include <plat/sched_clock.h>
+
 #include <plat/timer-sp.h>
 
 #include "core.h"
@@ -50,6 +52,8 @@ void __init v2m_map_io(struct map_desc *tile, size_t num)
 
 static void __init v2m_timer_init(void)
 {
+	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
+
 	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
 	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
 

commit 6d803ba736abb5e122dede70a4720e4843dd6df4
Author: Jean-Christop PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 17 10:04:33 2010 +0100

    ARM: 6483/1: arm & sh: factorised duplicated clkdev.c
    
    factorise some generic infrastructure to assist looking up struct clks
    for the ARM & SH architecture.
    
    as the code is identical at 99%
    
    put the arch specific code for allocation as example in asm/clkdev.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 7eaa232180a5..d374a78986e8 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -11,15 +11,14 @@
 #include <linux/spinlock.h>
 #include <linux/sysdev.h>
 #include <linux/usb/isp1760.h>
+#include <linux/clkdev.h>
 
-#include <asm/clkdev.h>
 #include <asm/sizes.h>
 #include <asm/mach/flash.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
 
-#include <mach/clkdev.h>
 #include <mach/motherboard.h>
 
 #include <plat/timer-sp.h>

commit 8a9618f5dfca35edb0d7ab6374ff586e2e9e989b
Author: Rob Herring <r.herring@freescale.com>
Date:   Wed Oct 6 16:18:08 2010 +0100

    ARM: 6432/1: move timer-sp.c from versatile to common
    
    From: Rob Herring <rob.herring@smooth-stone.com>
    
    The timer-sp h/w used on versatile platforms can also be used for other
    platforms, so move it to a common location.
    
    Signed-off-by: Rob Herring <rob.herring@smooth-stone.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 7eaa232180a5..91ff2e0df856 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -22,7 +22,7 @@
 #include <mach/clkdev.h>
 #include <mach/motherboard.h>
 
-#include <plat/timer-sp.h>
+#include <asm/hardware/timer-sp.h>
 
 #include "core.h"
 

commit cdaf9a2f280b25dd2fb1e04da5d3899411766e1b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 5 11:29:28 2010 +0100

    ARM: fix section mismatch warnings in Versatile Express
    
    WARNING: vmlinux.o(.text+0xbf30): Section mismatch in reference from the function v2m_timer_init() to the function .init.text:sp804_clocksource_init()
    The function v2m_timer_init() references
    the function __init sp804_clocksource_init().
    This is often because v2m_timer_init lacks a __init
    annotation or the annotation of sp804_clocksource_init is wrong.
    
    WARNING: vmlinux.o(.text+0xbf3c): Section mismatch in reference from the function v2m_timer_init() to the function .init.text:sp804_clockevents_init()
    The function v2m_timer_init() references
    the function __init sp804_clockevents_init().
    This is often because v2m_timer_init lacks a __init
    annotation or the annotation of sp804_clockevents_init is wrong.
    
    WARNING: vmlinux.o(.text+0xc524): Section mismatch in reference from the function ct_ca9x4_init() to the function .init.text:l2x0_init()
    The function ct_ca9x4_init() references
    the function __init l2x0_init().
    This is often because ct_ca9x4_init lacks a __init
    annotation or the annotation of l2x0_init is wrong.
    
    WARNING: vmlinux.o(.text+0xc530): Section mismatch in reference from the function ct_ca9x4_init() to the function .init.text:clkdev_add_table()
    The function ct_ca9x4_init() references
    the function __init clkdev_add_table().
    This is often because ct_ca9x4_init lacks a __init
    annotation or the annotation of clkdev_add_table is wrong.
    
    WARNING: vmlinux.o(.text+0xc578): Section mismatch in reference from the function ct_ca9x4_init() to the (unknown reference) .init.data:(unknown)
    The function ct_ca9x4_init() references
    the (unknown reference) __initdata (unknown).
    This is often because ct_ca9x4_init lacks a __initdata
    annotation or the annotation of (unknown) is wrong.
    
    Fix these by making ct_ca9x4_init() and v2m_timer_init() both __init.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index 817f0ad38a0b..7eaa232180a5 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -48,7 +48,7 @@ void __init v2m_map_io(struct map_desc *tile, size_t num)
 }
 
 
-static void v2m_timer_init(void)
+static void __init v2m_timer_init(void)
 {
 	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
 	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);

commit be82ae0238b0453afcf4a76f0512b7dde34ba500
Merge: 4b4fd27c0b5e 7b70c4275f28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 3 14:31:24 2010 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (291 commits)
      ARM: AMBA: Add pclk support to AMBA bus infrastructure
      ARM: 6278/2: fix regression in RealView after the introduction of pclk
      ARM: 6277/1: mach-shmobile: Allow users to select HZ, default to 128
      ARM: 6276/1: mach-shmobile: remove duplicate NR_IRQS_LEGACY
      ARM: 6246/1: mmci: support larger MMCIDATALENGTH register
      ARM: 6245/1: mmci: enable hardware flow control on Ux500 variants
      ARM: 6244/1: mmci: add variant data and default MCICLOCK support
      ARM: 6243/1: mmci: pass power_mode to the translate_vdd callback
      ARM: 6274/1: add global control registers definition header file for nuc900
      mx2_camera: fix type of dma buffer virtual address pointer
      mx2_camera: Add soc_camera support for i.MX25/i.MX27
      arm/imx/gpio: add spinlock protection
      ARM: Add support for the LPC32XX arch
      ARM: LPC32XX: Arch config menu supoport and makefiles
      ARM: LPC32XX: Phytec 3250 platform support
      ARM: LPC32XX: Misc support functions
      ARM: LPC32XX: Serial support code
      ARM: LPC32XX: System suspend support
      ARM: LPC32XX: GPIO, timer, and IRQ drivers
      ARM: LPC32XX: Clock driver
      ...

commit 74bc80931c8bc34d24545f992a35349ad548897c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 29 15:58:59 2010 +0100

    ARM: Fix Versatile/Realview/VExpress MMC card detection sense
    
    The MMC card detection sense has become really confused with negations
    at various levels, leading to some platforms not detecting inserted
    cards.  Fix this by converting everything to positive logic throughout,
    thereby getting rid of these negations.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index d250711b8c7a..c84239761cb4 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -241,7 +241,7 @@ static struct platform_device v2m_flash_device = {
 
 static unsigned int v2m_mmci_status(struct device *dev)
 {
-	return !(readl(MMIO_P2V(V2M_SYS_MCI)) & (1 << 0));
+	return readl(MMIO_P2V(V2M_SYS_MCI)) & (1 << 0);
 }
 
 static struct mmci_platform_data v2m_mmci_data = {

commit 3126c7bc4106c572ef47e2c220df5a00e7973379
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 15 11:01:17 2010 +0100

    ARM: AMBA: Add pclk definition for platforms using primecells
    
    Add a dummy clk definition for the APB pclk signal on all platforms
    using the AMBA bus infrastructure.  This ensures that these platforms
    continue to work when the core amba bus code controls the APB pclk.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index d250711b8c7a..d6db3453908b 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -298,8 +298,13 @@ static struct clk osc2_clk = {
 	.rate	= 24000000,
 };
 
+static struct clk dummy_apb_pclk;
+
 static struct clk_lookup v2m_lookups[] = {
-	{	/* UART0 */
+	{	/* AMBA bus clock */
+		.con_id		= "apb_pclk",
+		.clk		= &dummy_apb_pclk,
+	}, {	/* UART0 */
 		.dev_id		= "mb:uart0",
 		.clk		= &osc2_clk,
 	}, {	/* UART1 */

commit ceade897f31b8bb66f378cc35859fcfd0d46aaa2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Feb 11 21:44:53 2010 +0000

    ARM: Add Versatile Express support
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
new file mode 100644
index 000000000000..d250711b8c7a
--- /dev/null
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -0,0 +1,361 @@
+/*
+ * Versatile Express V2M Motherboard Support
+ */
+#include <linux/device.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/mmci.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/smsc911x.h>
+#include <linux/spinlock.h>
+#include <linux/sysdev.h>
+#include <linux/usb/isp1760.h>
+
+#include <asm/clkdev.h>
+#include <asm/sizes.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/hardware/arm_timer.h>
+
+#include <mach/clkdev.h>
+#include <mach/motherboard.h>
+
+#include <plat/timer-sp.h>
+
+#include "core.h"
+
+#define V2M_PA_CS0	0x40000000
+#define V2M_PA_CS1	0x44000000
+#define V2M_PA_CS2	0x48000000
+#define V2M_PA_CS3	0x4c000000
+#define V2M_PA_CS7	0x10000000
+
+static struct map_desc v2m_io_desc[] __initdata = {
+	{
+		.virtual	= __MMIO_P2V(V2M_PA_CS7),
+		.pfn		= __phys_to_pfn(V2M_PA_CS7),
+		.length		= SZ_128K,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init v2m_map_io(struct map_desc *tile, size_t num)
+{
+	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+	iotable_init(tile, num);
+}
+
+
+static void v2m_timer_init(void)
+{
+	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
+	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
+
+	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1));
+	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0);
+}
+
+struct sys_timer v2m_timer = {
+	.init	= v2m_timer_init,
+};
+
+
+static DEFINE_SPINLOCK(v2m_cfg_lock);
+
+int v2m_cfg_write(u32 devfn, u32 data)
+{
+	/* Configuration interface broken? */
+	u32 val;
+
+	printk("%s: writing %08x to %08x\n", __func__, data, devfn);
+
+	devfn |= SYS_CFG_START | SYS_CFG_WRITE;
+
+	spin_lock(&v2m_cfg_lock);
+	val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+	writel(val & ~SYS_CFG_COMPLETE, MMIO_P2V(V2M_SYS_CFGSTAT));
+
+	writel(data, MMIO_P2V(V2M_SYS_CFGDATA));
+	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+
+	do {
+		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+	} while (val == 0);
+	spin_unlock(&v2m_cfg_lock);
+
+	return !!(val & SYS_CFG_ERR);
+}
+
+int v2m_cfg_read(u32 devfn, u32 *data)
+{
+	u32 val;
+
+	devfn |= SYS_CFG_START;
+
+	spin_lock(&v2m_cfg_lock);
+	writel(0, MMIO_P2V(V2M_SYS_CFGSTAT));
+	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+
+	mb();
+
+	do {
+		cpu_relax();
+		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+	} while (val == 0);
+
+	*data = readl(MMIO_P2V(V2M_SYS_CFGDATA));
+	spin_unlock(&v2m_cfg_lock);
+
+	return !!(val & SYS_CFG_ERR);
+}
+
+
+static struct resource v2m_pcie_i2c_resource = {
+	.start	= V2M_SERIAL_BUS_PCI,
+	.end	= V2M_SERIAL_BUS_PCI + SZ_4K - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct platform_device v2m_pcie_i2c_device = {
+	.name		= "versatile-i2c",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= &v2m_pcie_i2c_resource,
+};
+
+static struct resource v2m_ddc_i2c_resource = {
+	.start	= V2M_SERIAL_BUS_DVI,
+	.end	= V2M_SERIAL_BUS_DVI + SZ_4K - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct platform_device v2m_ddc_i2c_device = {
+	.name		= "versatile-i2c",
+	.id		= 1,
+	.num_resources	= 1,
+	.resource	= &v2m_ddc_i2c_resource,
+};
+
+static struct resource v2m_eth_resources[] = {
+	{
+		.start	= V2M_LAN9118,
+		.end	= V2M_LAN9118 + SZ_64K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_V2M_LAN9118,
+		.end	= IRQ_V2M_LAN9118,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct smsc911x_platform_config v2m_eth_config = {
+	.flags		= SMSC911X_USE_32BIT,
+	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,
+	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.phy_interface	= PHY_INTERFACE_MODE_MII,
+};
+
+static struct platform_device v2m_eth_device = {
+	.name		= "smsc911x",
+	.id		= -1,
+	.resource	= v2m_eth_resources,
+	.num_resources	= ARRAY_SIZE(v2m_eth_resources),
+	.dev.platform_data = &v2m_eth_config,
+};
+
+static struct resource v2m_usb_resources[] = {
+	{
+		.start	= V2M_ISP1761,
+		.end	= V2M_ISP1761 + SZ_128K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_V2M_ISP1761,
+		.end	= IRQ_V2M_ISP1761,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct isp1760_platform_data v2m_usb_config = {
+	.is_isp1761		= true,
+	.bus_width_16		= false,
+	.port1_otg		= true,
+	.analog_oc		= false,
+	.dack_polarity_high	= false,
+	.dreq_polarity_high	= false,
+};
+
+static struct platform_device v2m_usb_device = {
+	.name		= "isp1760",
+	.id		= -1,
+	.resource	= v2m_usb_resources,
+	.num_resources	= ARRAY_SIZE(v2m_usb_resources),
+	.dev.platform_data = &v2m_usb_config,
+};
+
+static int v2m_flash_init(void)
+{
+	writel(0, MMIO_P2V(V2M_SYS_FLASH));
+	return 0;
+}
+
+static void v2m_flash_exit(void)
+{
+	writel(0, MMIO_P2V(V2M_SYS_FLASH));
+}
+
+static void v2m_flash_set_vpp(int on)
+{
+	writel(on != 0, MMIO_P2V(V2M_SYS_FLASH));
+}
+
+static struct flash_platform_data v2m_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= 4,
+	.init		= v2m_flash_init,
+	.exit		= v2m_flash_exit,
+	.set_vpp	= v2m_flash_set_vpp,
+};
+
+static struct resource v2m_flash_resources[] = {
+	{
+		.start	= V2M_NOR0,
+		.end	= V2M_NOR0 + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= V2M_NOR1,
+		.end	= V2M_NOR1 + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device v2m_flash_device = {
+	.name		= "armflash",
+	.id		= -1,
+	.resource	= v2m_flash_resources,
+	.num_resources	= ARRAY_SIZE(v2m_flash_resources),
+	.dev.platform_data = &v2m_flash_data,
+};
+
+
+static unsigned int v2m_mmci_status(struct device *dev)
+{
+	return !(readl(MMIO_P2V(V2M_SYS_MCI)) & (1 << 0));
+}
+
+static struct mmci_platform_data v2m_mmci_data = {
+	.ocr_mask	= MMC_VDD_32_33|MMC_VDD_33_34,
+	.status		= v2m_mmci_status,
+};
+
+static AMBA_DEVICE(aaci,  "mb:aaci",  V2M_AACI, NULL);
+static AMBA_DEVICE(mmci,  "mb:mmci",  V2M_MMCI, &v2m_mmci_data);
+static AMBA_DEVICE(kmi0,  "mb:kmi0",  V2M_KMI0, NULL);
+static AMBA_DEVICE(kmi1,  "mb:kmi1",  V2M_KMI1, NULL);
+static AMBA_DEVICE(uart0, "mb:uart0", V2M_UART0, NULL);
+static AMBA_DEVICE(uart1, "mb:uart1", V2M_UART1, NULL);
+static AMBA_DEVICE(uart2, "mb:uart2", V2M_UART2, NULL);
+static AMBA_DEVICE(uart3, "mb:uart3", V2M_UART3, NULL);
+static AMBA_DEVICE(wdt,   "mb:wdt",   V2M_WDT, NULL);
+static AMBA_DEVICE(rtc,   "mb:rtc",   V2M_RTC, NULL);
+
+static struct amba_device *v2m_amba_devs[] __initdata = {
+	&aaci_device,
+	&mmci_device,
+	&kmi0_device,
+	&kmi1_device,
+	&uart0_device,
+	&uart1_device,
+	&uart2_device,
+	&uart3_device,
+	&wdt_device,
+	&rtc_device,
+};
+
+
+static long v2m_osc_round(struct clk *clk, unsigned long rate)
+{
+	return rate;
+}
+
+static int v2m_osc1_set(struct clk *clk, unsigned long rate)
+{
+	return v2m_cfg_write(SYS_CFG_OSC | SYS_CFG_SITE_MB | 1, rate);
+}
+
+static const struct clk_ops osc1_clk_ops = {
+	.round	= v2m_osc_round,
+	.set	= v2m_osc1_set,
+};
+
+static struct clk osc1_clk = {
+	.ops	= &osc1_clk_ops,
+	.rate	= 24000000,
+};
+
+static struct clk osc2_clk = {
+	.rate	= 24000000,
+};
+
+static struct clk_lookup v2m_lookups[] = {
+	{	/* UART0 */
+		.dev_id		= "mb:uart0",
+		.clk		= &osc2_clk,
+	}, {	/* UART1 */
+		.dev_id		= "mb:uart1",
+		.clk		= &osc2_clk,
+	}, {	/* UART2 */
+		.dev_id		= "mb:uart2",
+		.clk		= &osc2_clk,
+	}, {	/* UART3 */
+		.dev_id		= "mb:uart3",
+		.clk		= &osc2_clk,
+	}, {	/* KMI0 */
+		.dev_id		= "mb:kmi0",
+		.clk		= &osc2_clk,
+	}, {	/* KMI1 */
+		.dev_id		= "mb:kmi1",
+		.clk		= &osc2_clk,
+	}, {	/* MMC0 */
+		.dev_id		= "mb:mmci",
+		.clk		= &osc2_clk,
+	}, {	/* CLCD */
+		.dev_id		= "mb:clcd",
+		.clk		= &osc1_clk,
+	},
+};
+
+static void v2m_power_off(void)
+{
+	if (v2m_cfg_write(SYS_CFG_SHUTDOWN | SYS_CFG_SITE_MB, 0))
+		printk(KERN_EMERG "Unable to shutdown\n");
+}
+
+static void v2m_restart(char str, const char *cmd)
+{
+	if (v2m_cfg_write(SYS_CFG_REBOOT | SYS_CFG_SITE_MB, 0))
+		printk(KERN_EMERG "Unable to reboot\n");
+}
+
+static int __init v2m_init(void)
+{
+	int i;
+
+	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
+
+	platform_device_register(&v2m_pcie_i2c_device);
+	platform_device_register(&v2m_ddc_i2c_device);
+	platform_device_register(&v2m_flash_device);
+	platform_device_register(&v2m_eth_device);
+	platform_device_register(&v2m_usb_device);
+
+	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
+		amba_device_register(v2m_amba_devs[i], &iomem_resource);
+
+	pm_power_off = v2m_power_off;
+	arm_pm_restart = v2m_restart;
+
+	return 0;
+}
+arch_initcall(v2m_init);
