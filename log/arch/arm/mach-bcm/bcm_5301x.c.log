commit 09f3510fb70a46c8921f2cf4a90dbcae460a6820
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Sat Oct 29 13:12:29 2016 +0200

    ARM: BCM5301X: Add back handler ignoring external imprecise aborts
    
    Since early BCM5301X days we got abort handler that was removed by
    commit 937b12306ea79 ("ARM: BCM5301X: remove workaround imprecise abort
    fault handler"). It assumed we need to deal only with pending aborts
    left by the bootloader. Unfortunately this isn't true for BCM5301X.
    
    When probing PCI config space (device enumeration) it is expected to
    have master aborts on the PCI bus. Most bridges don't forward (or they
    allow disabling it) these errors onto the AXI/AMBA bus but not the
    Northstar (BCM5301X) one.
    
    iProc PCIe controller on Northstar seems to be some older one, without
    a control register for errors forwarding. It means we need to workaround
    this at platform level. All newer platforms are not affected by this
    issue.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index c8830a2b0d60..fe067f6cebb6 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -9,14 +9,42 @@
 #include <asm/hardware/cache-l2x0.h>
 
 #include <asm/mach/arch.h>
+#include <asm/siginfo.h>
+#include <asm/signal.h>
+
+#define FSR_EXTERNAL		(1 << 12)
+#define FSR_READ		(0 << 10)
+#define FSR_IMPRECISE		0x0406
 
 static const char *const bcm5301x_dt_compat[] __initconst = {
 	"brcm,bcm4708",
 	NULL,
 };
 
+static int bcm5301x_abort_handler(unsigned long addr, unsigned int fsr,
+				  struct pt_regs *regs)
+{
+	/*
+	 * We want to ignore aborts forwarded from the PCIe bus that are
+	 * expected and shouldn't really be passed by the PCIe controller.
+	 * The biggest disadvantage is the same FSR code may be reported when
+	 * reading non-existing APB register and we shouldn't ignore that.
+	 */
+	if (fsr == (FSR_EXTERNAL | FSR_READ | FSR_IMPRECISE))
+		return 0;
+
+	return 1;
+}
+
+static void __init bcm5301x_init_early(void)
+{
+	hook_fault_code(16 + 6, bcm5301x_abort_handler, SIGBUS, BUS_OBJERR,
+			"imprecise external abort");
+}
+
 DT_MACHINE_START(BCM5301X, "BCM5301X")
 	.l2c_aux_val	= 0,
 	.l2c_aux_mask	= ~0,
 	.dt_compat	= bcm5301x_dt_compat,
+	.init_early	= bcm5301x_init_early,
 MACHINE_END

commit 937b12306ea79044c86f2e69b3061c7279245825
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Oct 15 12:32:22 2015 +0200

    ARM: BCM5301X: remove workaround imprecise abort fault handler
    
    This is not needed anymore. Handling a potentially pending imprecise external
    abort left behind by the bootloader is now done in a slightly safer way inside
    the common ARM startup code.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Acked-by: Hauke Mehrtens <hauke@hauke-m.de>
    Tested-by: Tyler Baker <tyler.baker@linaro.org>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index 5478fe6bcce6..c8830a2b0d60 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -9,40 +9,6 @@
 #include <asm/hardware/cache-l2x0.h>
 
 #include <asm/mach/arch.h>
-#include <asm/siginfo.h>
-#include <asm/signal.h>
-
-
-static bool first_fault = true;
-
-static int bcm5301x_abort_handler(unsigned long addr, unsigned int fsr,
-				 struct pt_regs *regs)
-{
-	if ((fsr == 0x1406 || fsr == 0x1c06) && first_fault) {
-		first_fault = false;
-
-		/*
-		 * These faults with codes 0x1406 (BCM4709) or 0x1c06 happens
-		 * for no good reason, possibly left over from the CFE boot
-		 * loader.
-		 */
-		pr_warn("External imprecise Data abort at addr=%#lx, fsr=%#x ignored.\n",
-			addr, fsr);
-
-		/* Returning non-zero causes fault display and panic */
-		return 0;
-	}
-
-	/* Others should cause a fault */
-	return 1;
-}
-
-static void __init bcm5301x_init_early(void)
-{
-	/* Install our hook */
-	hook_fault_code(16 + 6, bcm5301x_abort_handler, SIGBUS, BUS_OBJERR,
-			"imprecise external abort");
-}
 
 static const char *const bcm5301x_dt_compat[] __initconst = {
 	"brcm,bcm4708",
@@ -52,6 +18,5 @@ static const char *const bcm5301x_dt_compat[] __initconst = {
 DT_MACHINE_START(BCM5301X, "BCM5301X")
 	.l2c_aux_val	= 0,
 	.l2c_aux_mask	= ~0,
-	.init_early	= bcm5301x_init_early,
 	.dt_compat	= bcm5301x_dt_compat,
 MACHINE_END

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index 7aef92720eb4..5478fe6bcce6 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -44,7 +44,7 @@ static void __init bcm5301x_init_early(void)
 			"imprecise external abort");
 }
 
-static const char __initconst *bcm5301x_dt_compat[] = {
+static const char *const bcm5301x_dt_compat[] __initconst = {
 	"brcm,bcm4708",
 	NULL,
 };

commit 7eb68a2a0519a77b93184c695d4d293c92dc2286
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Wed Feb 11 16:40:58 2015 +0100

    ARM: BCM5301X: Ignore another (BCM4709 specific) fault code
    
    Broadcom ARM devices seem to generate some fault once per boot. We
    already have an ignoring handler for BCM4707/BCM4708, but BCM4709
    generates different code.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index e9bcbdbce555..7aef92720eb4 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -18,15 +18,16 @@ static bool first_fault = true;
 static int bcm5301x_abort_handler(unsigned long addr, unsigned int fsr,
 				 struct pt_regs *regs)
 {
-	if (fsr == 0x1c06 && first_fault) {
+	if ((fsr == 0x1406 || fsr == 0x1c06) && first_fault) {
 		first_fault = false;
 
 		/*
-		 * These faults with code 0x1c06 happens for no good reason,
-		 * possibly left over from the CFE boot loader.
+		 * These faults with codes 0x1406 (BCM4709) or 0x1c06 happens
+		 * for no good reason, possibly left over from the CFE boot
+		 * loader.
 		 */
 		pr_warn("External imprecise Data abort at addr=%#lx, fsr=%#x ignored.\n",
-		addr, fsr);
+			addr, fsr);
 
 		/* Returning non-zero causes fault display and panic */
 		return 0;

commit d458773fb3c456d0e2e860fece8602b062e2f7a0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Apr 28 15:27:59 2014 +0100

    ARM: l2c: bcm_5301x: convert to generic l2c OF initialisation
    
    Remove the explicit call to l2x0_of_init(), converting to the generic
    infrastructure instead.  We can remove the explicit machine init too
    as this becomes identical to the generic version.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index 6bc9c31b1b0b..e9bcbdbce555 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -43,19 +43,14 @@ static void __init bcm5301x_init_early(void)
 			"imprecise external abort");
 }
 
-static void __init bcm5301x_dt_init(void)
-{
-	l2x0_of_init(0, ~0);
-	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
-}
-
 static const char __initconst *bcm5301x_dt_compat[] = {
 	"brcm,bcm4708",
 	NULL,
 };
 
 DT_MACHINE_START(BCM5301X, "BCM5301X")
+	.l2c_aux_val	= 0,
+	.l2c_aux_mask	= ~0,
 	.init_early	= bcm5301x_init_early,
-	.init_machine	= bcm5301x_dt_init,
 	.dt_compat	= bcm5301x_dt_compat,
 MACHINE_END

commit d453ef752cf01e96168ea012016baea0079f5377
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 19 12:50:53 2014 +0000

    ARM: l2c: remove unnecessary UL-suffix to mask values
    
    They're u32, they're not unsigned long.  The UL suffix is not required
    here.
    
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index edff69761e04..6bc9c31b1b0b 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -45,7 +45,7 @@ static void __init bcm5301x_init_early(void)
 
 static void __init bcm5301x_dt_init(void)
 {
-	l2x0_of_init(0, ~0UL);
+	l2x0_of_init(0, ~0);
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
 }
 

commit fdf4850cb5b2e5e549a18b8b41abb001bfb19e9c
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Tue Feb 4 00:01:46 2014 +0100

    ARM: BCM5301X: workaround suppress fault
    
    Without this patch I am getting a unhandled fault exception like this
    one after "Freeing unused kernel memory":
    
    Freeing unused kernel memory: 1260K (c02c1000 - c03fc000)
    Unhandled fault: imprecise external abort (0x1c06) at 0xb6f89005
    Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000007
    
    The address which is here 0xb6f89005 changes from boot to boot, with a
    new build the changes are bigger. With kernel 3.10 I have also seen
    this fault at different places in the boot process, but starting with
    3.11 they are always occurring after the "Freeing unused kernel memory"
    message. I never was able to completely boot to userspace without this
    handler. The abort code is constant 0x1c06. This fault just happens
    once in the boot process I have never seen it happing twice or more.
    
    I also tried changing the CPSR.A bit to 0 in init_early, with this code
    like Afzal suggested, but that did not change anything:
    asm volatile("mrs r12, cpsr\n"
            "bic r12, r12, #0x00000100\n"
            "msr cpsr_c, r12" ::: "r12", "cc", "memory");
    
    Disabling the L2 cache by building with CONFIG_CACHE_L2X0 unset did not
    help.
    
    This workaround was copied from the vendor code including most of the
    comments. It says it they think this is caused by the CFE boot loader
    used on this device. I do not have any access to any datasheet or
    errata document to check this.
    
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Christian Daudt <bcm@fixthebug.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
index ef9740a20883..edff69761e04 100644
--- a/arch/arm/mach-bcm/bcm_5301x.c
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -9,8 +9,40 @@
 #include <asm/hardware/cache-l2x0.h>
 
 #include <asm/mach/arch.h>
+#include <asm/siginfo.h>
+#include <asm/signal.h>
 
 
+static bool first_fault = true;
+
+static int bcm5301x_abort_handler(unsigned long addr, unsigned int fsr,
+				 struct pt_regs *regs)
+{
+	if (fsr == 0x1c06 && first_fault) {
+		first_fault = false;
+
+		/*
+		 * These faults with code 0x1c06 happens for no good reason,
+		 * possibly left over from the CFE boot loader.
+		 */
+		pr_warn("External imprecise Data abort at addr=%#lx, fsr=%#x ignored.\n",
+		addr, fsr);
+
+		/* Returning non-zero causes fault display and panic */
+		return 0;
+	}
+
+	/* Others should cause a fault */
+	return 1;
+}
+
+static void __init bcm5301x_init_early(void)
+{
+	/* Install our hook */
+	hook_fault_code(16 + 6, bcm5301x_abort_handler, SIGBUS, BUS_OBJERR,
+			"imprecise external abort");
+}
+
 static void __init bcm5301x_dt_init(void)
 {
 	l2x0_of_init(0, ~0UL);
@@ -23,6 +55,7 @@ static const char __initconst *bcm5301x_dt_compat[] = {
 };
 
 DT_MACHINE_START(BCM5301X, "BCM5301X")
+	.init_early	= bcm5301x_init_early,
 	.init_machine	= bcm5301x_dt_init,
 	.dt_compat	= bcm5301x_dt_compat,
 MACHINE_END

commit 5b293ebe757213993ae93b6cbbf5e1d09b75ac2f
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Tue Feb 4 00:01:43 2014 +0100

    ARM: BCM5301X: initial support for the BCM5301X/BCM470X SoCs with ARM CPU
    
    This patch adds support for the BCM5301X/BCM470X SoCs with an ARM CPUs.
    Currently just booting to a shell is working and nothing else, no
    Ethernet, wifi, flash, ...
    I have some pending patches to make Ethernet work for this device.
    Mostly device tree support for bcma is missing.
    
    This SoC is used in small office and home router with Broadcom SoCs
    it's internal name is Northstar. This code should support the BCM4707,
    BCM4708, BCM4709, BCM53010, BCM53011 and BCM53012 SoC. It uses one or
    two ARM Cortex A9 Cores, some highlights are 2 PCIe 2.0 controllers,
    4 Gigabit Ethernet MACs and a USB 3.0 host controller.
    
    This SoC uses a dual core CPU, but this is currently not implemented.
    More information about this SoC can be found here:
    http://www.anandtech.com/show/5925/broadcom-announces-bcm4708x-and-bcm5301x-socs-for-80211ac-routers
    
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Christian Daudt <bcm@fixthebug.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_5301x.c b/arch/arm/mach-bcm/bcm_5301x.c
new file mode 100644
index 000000000000..ef9740a20883
--- /dev/null
+++ b/arch/arm/mach-bcm/bcm_5301x.c
@@ -0,0 +1,28 @@
+/*
+ * Broadcom BCM470X / BCM5301X ARM platform code.
+ *
+ * Copyright 2013 Hauke Mehrtens <hauke@hauke-m.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+#include <linux/of_platform.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach/arch.h>
+
+
+static void __init bcm5301x_dt_init(void)
+{
+	l2x0_of_init(0, ~0UL);
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char __initconst *bcm5301x_dt_compat[] = {
+	"brcm,bcm4708",
+	NULL,
+};
+
+DT_MACHINE_START(BCM5301X, "BCM5301X")
+	.init_machine	= bcm5301x_dt_init,
+	.dt_compat	= bcm5301x_dt_compat,
+MACHINE_END
