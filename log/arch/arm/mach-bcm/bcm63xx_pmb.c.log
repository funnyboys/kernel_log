commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-bcm/bcm63xx_pmb.c b/arch/arm/mach-bcm/bcm63xx_pmb.c
index 41dcf5d65630..0e5a05bac3ea 100644
--- a/arch/arm/mach-bcm/bcm63xx_pmb.c
+++ b/arch/arm/mach-bcm/bcm63xx_pmb.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Broadcom BCM63138 PMB initialization for secondary CPU(s)
  *
  * Copyright (C) 2015 Broadcom Corporation
  * Author: Florian Fainelli <f.fainelli@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 #include <linux/kernel.h>
 #include <linux/io.h>

commit 6580566e10016c1ec00aa5e0e62af3c4b3498019
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 31 16:32:48 2016 -0800

    ARM: BCM63xx: Remove unused pmb_dn variable
    
    Introduced in commit 3f2a43c98d72b ("ARM: BCM63xx: Add secondary CPU PMB
    initialization sequence"), but not used by the code.
    
    Reported-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm63xx_pmb.c b/arch/arm/mach-bcm/bcm63xx_pmb.c
index de061ec5a479..41dcf5d65630 100644
--- a/arch/arm/mach-bcm/bcm63xx_pmb.c
+++ b/arch/arm/mach-bcm/bcm63xx_pmb.c
@@ -92,7 +92,6 @@ static int bcm63xx_pmb_get_resources(struct device_node *dn,
 				     unsigned int *cpu,
 				     unsigned int *addr)
 {
-	struct device_node *pmb_dn;
 	struct of_phandle_args args;
 	int ret;
 
@@ -109,7 +108,6 @@ static int bcm63xx_pmb_get_resources(struct device_node *dn,
 		return ret;
 	}
 
-	pmb_dn = args.np;
 	if (args.args_count != 2) {
 		pr_err("reset-controller does not conform to reset-cells\n");
 		return -EINVAL;

commit 3cc630564e1ee9cca211ec0f14ef34cab30f21ed
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 27 11:25:12 2015 +0300

    ARM: BCM63xx: fix an error path in bcm63xx_pmb_power_on_cpu()
    
    We need to unlock and unmap some resourses before returning.
    
    Fixes: 3f2a43c98d72 ('ARM: BCM63xx: Add secondary CPU PMB initialization sequence')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm63xx_pmb.c b/arch/arm/mach-bcm/bcm63xx_pmb.c
index c39752b85b92..de061ec5a479 100644
--- a/arch/arm/mach-bcm/bcm63xx_pmb.c
+++ b/arch/arm/mach-bcm/bcm63xx_pmb.c
@@ -150,7 +150,7 @@ int bcm63xx_pmb_power_on_cpu(struct device_node *dn)
 	 */
 	ret = bpcm_rd(base, addr, ARM_CONTROL, &ctrl);
 	if (ret)
-		return ret;
+		goto out;
 
 	if (ctrl & CPU_RESET_N(cpu)) {
 		pr_info("PMB: CPU%d is already powered on\n", cpu);

commit 3f2a43c98d72bcb236f3db7e3a8355dd5e1311d8
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Apr 17 10:50:40 2015 -0700

    ARM: BCM63xx: Add secondary CPU PMB initialization sequence
    
    The sequence to initialize a secondary CPU using the BCM63138 PMB is
    extremely specific and represents much more code than any other on-chip
    peripheral (AHCI, USB 3.0 or integrated Ethernet switch), as such we
    keep that code local and utilize Device Tree to lookup all the resources
    we need from the CPU device tree node.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm63xx_pmb.c b/arch/arm/mach-bcm/bcm63xx_pmb.c
new file mode 100644
index 000000000000..c39752b85b92
--- /dev/null
+++ b/arch/arm/mach-bcm/bcm63xx_pmb.c
@@ -0,0 +1,221 @@
+/*
+ * Broadcom BCM63138 PMB initialization for secondary CPU(s)
+ *
+ * Copyright (C) 2015 Broadcom Corporation
+ * Author: Florian Fainelli <f.fainelli@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/reset/bcm63xx_pmb.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include "bcm63xx_smp.h"
+
+/* ARM Control register definitions */
+#define CORE_PWR_CTRL_SHIFT	0
+#define CORE_PWR_CTRL_MASK	0x3
+#define PLL_PWR_ON		BIT(8)
+#define PLL_LDO_PWR_ON		BIT(9)
+#define PLL_CLAMP_ON		BIT(10)
+#define CPU_RESET_N(x)		BIT(13 + (x))
+#define NEON_RESET_N		BIT(15)
+#define PWR_CTRL_STATUS_SHIFT	28
+#define PWR_CTRL_STATUS_MASK	0x3
+#define PWR_DOWN_SHIFT		30
+#define PWR_DOWN_MASK		0x3
+
+/* CPU Power control register definitions */
+#define MEM_PWR_OK		BIT(0)
+#define MEM_PWR_ON		BIT(1)
+#define MEM_CLAMP_ON		BIT(2)
+#define MEM_PWR_OK_STATUS	BIT(4)
+#define MEM_PWR_ON_STATUS	BIT(5)
+#define MEM_PDA_SHIFT		8
+#define MEM_PDA_MASK		0xf
+#define  MEM_PDA_CPU_MASK	0x1
+#define  MEM_PDA_NEON_MASK	0xf
+#define CLAMP_ON		BIT(15)
+#define PWR_OK_SHIFT		16
+#define PWR_OK_MASK		0xf
+#define PWR_ON_SHIFT		20
+#define  PWR_CPU_MASK		0x03
+#define  PWR_NEON_MASK		0x01
+#define PWR_ON_MASK		0xf
+#define PWR_OK_STATUS_SHIFT	24
+#define PWR_OK_STATUS_MASK	0xf
+#define PWR_ON_STATUS_SHIFT	28
+#define PWR_ON_STATUS_MASK	0xf
+
+#define ARM_CONTROL		0x30
+#define ARM_PWR_CONTROL_BASE	0x34
+#define ARM_PWR_CONTROL(x)	(ARM_PWR_CONTROL_BASE + (x) * 0x4)
+#define ARM_NEON_L2		0x3c
+
+/* Perform a value write, then spin until the value shifted by
+ * shift is seen, masked with mask and is different from cond.
+ */
+static int bpcm_wr_rd_mask(void __iomem *master,
+			   unsigned int addr, u32 off, u32 *val,
+			   u32 shift, u32 mask, u32 cond)
+{
+	int ret;
+
+	ret = bpcm_wr(master, addr, off, *val);
+	if (ret)
+		return ret;
+
+	do {
+		ret = bpcm_rd(master, addr, off, val);
+		if (ret)
+			return ret;
+
+		cpu_relax();
+	} while (((*val >> shift) & mask) != cond);
+
+	return ret;
+}
+
+/* Global lock to serialize accesses to the PMB registers while we
+ * are bringing up the secondary CPU
+ */
+static DEFINE_SPINLOCK(pmb_lock);
+
+static int bcm63xx_pmb_get_resources(struct device_node *dn,
+				     void __iomem **base,
+				     unsigned int *cpu,
+				     unsigned int *addr)
+{
+	struct device_node *pmb_dn;
+	struct of_phandle_args args;
+	int ret;
+
+	ret = of_property_read_u32(dn, "reg", cpu);
+	if (ret) {
+		pr_err("CPU is missing a reg node\n");
+		return ret;
+	}
+
+	ret = of_parse_phandle_with_args(dn, "resets", "#reset-cells",
+					 0, &args);
+	if (ret) {
+		pr_err("CPU is missing a resets phandle\n");
+		return ret;
+	}
+
+	pmb_dn = args.np;
+	if (args.args_count != 2) {
+		pr_err("reset-controller does not conform to reset-cells\n");
+		return -EINVAL;
+	}
+
+	*base = of_iomap(args.np, 0);
+	if (!*base) {
+		pr_err("failed remapping PMB register\n");
+		return -ENOMEM;
+	}
+
+	/* We do not need the number of zones */
+	*addr = args.args[0];
+
+	return 0;
+}
+
+int bcm63xx_pmb_power_on_cpu(struct device_node *dn)
+{
+	void __iomem *base;
+	unsigned int cpu, addr;
+	unsigned long flags;
+	u32 val, ctrl;
+	int ret;
+
+	ret = bcm63xx_pmb_get_resources(dn, &base, &cpu, &addr);
+	if (ret)
+		return ret;
+
+	/* We would not know how to enable a third and greater CPU */
+	WARN_ON(cpu > 1);
+
+	spin_lock_irqsave(&pmb_lock, flags);
+
+	/* Check if the CPU is already on and save the ARM_CONTROL register
+	 * value since we will use it later for CPU de-assert once done with
+	 * the CPU-specific power sequence
+	 */
+	ret = bpcm_rd(base, addr, ARM_CONTROL, &ctrl);
+	if (ret)
+		return ret;
+
+	if (ctrl & CPU_RESET_N(cpu)) {
+		pr_info("PMB: CPU%d is already powered on\n", cpu);
+		ret = 0;
+		goto out;
+	}
+
+	/* Power on PLL */
+	ret = bpcm_rd(base, addr, ARM_PWR_CONTROL(cpu), &val);
+	if (ret)
+		goto out;
+
+	val |= (PWR_CPU_MASK << PWR_ON_SHIFT);
+
+	ret = bpcm_wr_rd_mask(base, addr, ARM_PWR_CONTROL(cpu), &val,
+			PWR_ON_STATUS_SHIFT, PWR_CPU_MASK, PWR_CPU_MASK);
+	if (ret)
+		goto out;
+
+	val |= (PWR_CPU_MASK << PWR_OK_SHIFT);
+
+	ret = bpcm_wr_rd_mask(base, addr, ARM_PWR_CONTROL(cpu), &val,
+			PWR_OK_STATUS_SHIFT, PWR_CPU_MASK, PWR_CPU_MASK);
+	if (ret)
+		goto out;
+
+	val &= ~CLAMP_ON;
+
+	ret = bpcm_wr(base, addr, ARM_PWR_CONTROL(cpu), val);
+	if (ret)
+		goto out;
+
+	/* Power on CPU<N> RAM */
+	val &= ~(MEM_PDA_MASK << MEM_PDA_SHIFT);
+
+	ret = bpcm_wr(base, addr, ARM_PWR_CONTROL(cpu), val);
+	if (ret)
+		goto out;
+
+	val |= MEM_PWR_ON;
+
+	ret = bpcm_wr_rd_mask(base, addr, ARM_PWR_CONTROL(cpu), &val,
+			0, MEM_PWR_ON_STATUS, MEM_PWR_ON_STATUS);
+	if (ret)
+		goto out;
+
+	val |= MEM_PWR_OK;
+
+	ret = bpcm_wr_rd_mask(base, addr, ARM_PWR_CONTROL(cpu), &val,
+			0, MEM_PWR_OK_STATUS, MEM_PWR_OK_STATUS);
+	if (ret)
+		goto out;
+
+	val &= ~MEM_CLAMP_ON;
+
+	ret = bpcm_wr(base, addr, ARM_PWR_CONTROL(cpu), val);
+	if (ret)
+		goto out;
+
+	/* De-assert CPU reset */
+	ctrl |= CPU_RESET_N(cpu);
+
+	ret = bpcm_wr(base, addr, ARM_CONTROL, ctrl);
+out:
+	spin_unlock_irqrestore(&pmb_lock, flags);
+	iounmap(base);
+	return ret;
+}
