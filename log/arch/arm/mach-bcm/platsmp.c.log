commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 21400b3fa5fe..c9db2a9006d9 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -105,7 +105,7 @@ static int nsp_write_lut(unsigned int cpu)
 	if (!secondary_boot_addr)
 		return -EINVAL;
 
-	sku_rom_lut = ioremap_nocache((phys_addr_t)secondary_boot_addr,
+	sku_rom_lut = ioremap((phys_addr_t)secondary_boot_addr,
 				      sizeof(phys_addr_t));
 	if (!sku_rom_lut) {
 		pr_warn("unable to ioremap SKU-ROM LUT register for cpu %u\n", cpu);
@@ -174,7 +174,7 @@ static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	if (!secondary_boot_addr)
 		return -EINVAL;
 
-	boot_reg = ioremap_nocache((phys_addr_t)secondary_boot_addr,
+	boot_reg = ioremap((phys_addr_t)secondary_boot_addr,
 				   sizeof(phys_addr_t));
 	if (!boot_reg) {
 		pr_err("unable to map boot register for cpu %u\n", cpu_id);

commit d67fa6caae51f3a5d159234272903788e3446878
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 8 13:34:43 2019 +0100

    ARM: bcm: include local platsmp.h for bcm2836_smp_ops
    
    Include platsmp.h for the definition of bcm2836_smp_ops to fix
    the following warning:
    
    arch/arm/mach-bcm/platsmp.c:334:29: warning: symbol 'bcm2836_smp_ops' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 47f8053d0240..21400b3fa5fe 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -22,6 +22,8 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
+#include "platsmp.h"
+
 /* Size of mapped Cortex A9 SCU address space */
 #define CORTEX_A9_SCU_SIZE	0x58
 

commit 7b369a42e6d06c59fc56a1769fb4da797fac9bad
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Mon Oct 22 22:18:39 2018 +0200

    ARM: mach-bcm: Switch bcm2835 and platsmp to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management.
    
    Cc: Simon Arlott <simon@arlott.org>
    Cc: Kapil Hali <kapilh@broadcom.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 7d954830eb57..47f8053d0240 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2014-2015 Broadcom Corporation
  * Copyright 2014 Linaro Limited
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/cpumask.h>

commit 968f76417df671338ea3a1fd33b2c93a048cc1b1
Author: Phil Elwell <phil@raspberrypi.org>
Date:   Tue Aug 8 12:04:55 2017 +0100

    ARM: bcm2836: Send event when onlining other cores
    
    Secondary cores should enter a low-power idle state when waiting to
    be started. The "wfe" instruction causes a core to wait until an event
    or interrupt arrives before continuing to the next instruction, and
    the "sev" instruction sends a wakeup event to the other cores.
    
    Add an "sev" (and a memory barrier) to bcm2836_boot_secondary, the
    function that wakes the waiting cores during booting. This is required
    if the secondary cores are sitting in "wfe", and harmless if not.
    
    Signed-off-by: Phil Elwell <phil@raspberrypi.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 34506a608fea..7d954830eb57 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -312,6 +312,9 @@ static int bcm2836_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	writel(virt_to_phys(secondary_startup),
 	       intc_base + LOCAL_MAILBOX3_SET0 + 16 * cpu);
 
+	dsb(sy);
+	sev();
+
 	iounmap(intc_base);
 
 	return 0;

commit 88bbe85dcd37aa2662c1a83962c15009fc12503e
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sun Aug 6 17:52:02 2017 +0200

    irqchip: bcm2836: Move SMP startup code to arch/arm (v2)
    
    In order to easily provide SMP for BCM2837 on 32-bit and 64-bit
    the SMP startup code was placed in irq-bcm2836. That's not the
    right approach. So move this code where it belongs.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Fixes: 41f4988cc287 ("irqchip/bcm2836: Add SMP support for the 2836")
    Tested-by: Eric Anholt <eric@anholt.net>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 9e3f275934eb..34506a608fea 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -17,6 +17,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/irqchip/irq-bcm2836.h>
 #include <linux/jiffies.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -287,6 +288,35 @@ static int nsp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return ret;
 }
 
+static int bcm2836_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	void __iomem *intc_base;
+	struct device_node *dn;
+	char *name;
+
+	name = "brcm,bcm2836-l1-intc";
+	dn = of_find_compatible_node(NULL, NULL, name);
+	if (!dn) {
+		pr_err("unable to find intc node\n");
+		return -ENODEV;
+	}
+
+	intc_base = of_iomap(dn, 0);
+	of_node_put(dn);
+
+	if (!intc_base) {
+		pr_err("unable to remap intc base register\n");
+		return -ENOMEM;
+	}
+
+	writel(virt_to_phys(secondary_startup),
+	       intc_base + LOCAL_MAILBOX3_SET0 + 16 * cpu);
+
+	iounmap(intc_base);
+
+	return 0;
+}
+
 static const struct smp_operations kona_smp_ops __initconst = {
 	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
 	.smp_boot_secondary	= kona_boot_secondary,
@@ -305,3 +335,8 @@ static const struct smp_operations nsp_smp_ops __initconst = {
 	.smp_boot_secondary	= nsp_boot_secondary,
 };
 CPU_METHOD_OF_DECLARE(bcm_smp_nsp, "brcm,bcm-nsp-smp", &nsp_smp_ops);
+
+const struct smp_operations bcm2836_smp_ops __initconst = {
+	.smp_boot_secondary	= bcm2836_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(bcm_smp_bcm2836, "brcm,bcm2836-smp", &bcm2836_smp_ops);

commit e601757102cfd3eeae068f53b3bc1234f3a2b2e9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 1 16:36:40 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/clock.h>
    
    We are going to split <linux/sched/clock.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and .c files.
    
    Create a trivial placeholder <linux/sched/clock.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 582886d0d02f..9e3f275934eb 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -21,6 +21,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/sched.h>
+#include <linux/sched/clock.h>
 #include <linux/smp.h>
 
 #include <asm/cacheflush.h>

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 3ac3a9bc663c..582886d0d02f 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -116,7 +116,7 @@ static int nsp_write_lut(unsigned int cpu)
 		return -ENOMEM;
 	}
 
-	secondary_startup_phy = virt_to_phys(secondary_startup);
+	secondary_startup_phy = __pa_symbol(secondary_startup);
 	BUG_ON(secondary_startup_phy > (phys_addr_t)U32_MAX);
 
 	writel_relaxed(secondary_startup_phy, sku_rom_lut);
@@ -189,7 +189,7 @@ static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * Secondary cores will start in secondary_startup(),
 	 * defined in "arch/arm/kernel/head.S"
 	 */
-	boot_func = virt_to_phys(secondary_startup);
+	boot_func = __pa_symbol(secondary_startup);
 	BUG_ON(boot_func & BOOT_ADDR_CPUID_MASK);
 	BUG_ON(boot_func > (phys_addr_t)U32_MAX);
 

commit 043248cd4e9603e2e8858c4e20810d8e40be7d9d
Merge: 43a0a98aa8da d95eabc7b8ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 1 18:37:45 2016 -0400

    Merge tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM DT updates from Olof Johansson:
     "Device tree contents continue to be the largest branches we submit.
      This time around, some of the contents worth pointing out is:
    
      New SoC platforms:
       - Freescale i.MX 7Solo
       - Broadcom BCM23550
       - Cirrus Logic EP7209 and EP7211 (clps711x platforms)_
       - Hisilicon HI3519
       - Renesas R8A7792
    
      Some of the other delta that is sticking out, line-count wise:
       - Exynos moves of IP blocks under an SoC bus, which causes a large
         delta due to indentation changes
       - a new Tegra K1 board: Apalis
       - a bunch of small updates to many Allwinner platforms; new hardware
         support, some cleanup, etc"
    
    * tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (426 commits)
      ARM: dts: sun8i: Add dts file for inet86dz board
      ARM: dts: sun8i: Add dts file for Polaroid MID2407PXE03 tablet
      ARM: dts: sun8i: Use sun8i-reference-design-tablet for ga10h dts
      ARM: dts: sun8i: Use sun8i-reference-design-tablet for polaroid mid2809pxe04
      ARM: dts: sun8i: reference-design-tablet: Add drivevbus-supply
      ARM: dts: Copy sun8i-q8-common.dtsi sun8i-reference-design-tablet.dtsi
      ARM: dts: sun5i: Use sun5i-reference-design-tablet.dtsi for utoo p66 dts
      ARM: dts: sun5i: Use sun5i-reference-design-tablet.dtsi for dit4350 dts
      ARM: dts: sun5i: reference-design-tablet: Remove mention of q8
      ARM: dts: sun5i: reference-design-tablet: Set lradc vref to avcc
      ARM: dts: sun5i: Rename sun5i-q8-common.dtsi sun5i-reference-design-tablet.dtsi
      ARM: dts: sun5i: Move q8 display bits to sun5i-a13-q8-tablet.dts
      ARM: dts: sunxi: Rename sunxi-q8-common.dtsi sunxi-reference-design-tablet.dtsi
      ARM: dts: at91: Don't build unnecessary dtbs
      ARM: dts: at91: sama5d3x: separate motherboard gmac and emac definitions
      ARM: dts: at91: at91sam9g25ek: fix isi endpoint node
      ARM: dts: at91: move isi definition to at91sam9g25ek
      ARM: dts: at91: fix i2c-gpio node name
      ARM: dts: at91: vinco: fix regulator name
      ARM: dts: at91: ariag25 : fix onewire node
      ...

commit 5fcf999abfeb908f5a6fead7c4a99c23c705e9c0
Author: Chris Brand <chris.brand@broadcom.com>
Date:   Wed May 11 14:36:21 2016 -0700

    ARM: BCM23550 SMP support
    
    BCM23550 has a Cluster Dormant Control IP block that holds cores
    in an idle state. Support a new CPU enable method in which the CDC is
    accessed to bring the core online.
    
    Signed-off-by: Raymond Ngun <raymond.ngun@broadcom.com>
    Signed-off-by: Chris Brand <chris.brand@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index cfae9c71fb74..33c4d8349f95 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -19,6 +19,7 @@
 #include <linux/io.h>
 #include <linux/jiffies.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 
@@ -255,6 +256,57 @@ static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return -ENXIO;
 }
 
+/* Cluster Dormant Control command to bring CPU into a running state */
+#define CDC_CMD			6
+#define CDC_CMD_OFFSET		0
+#define CDC_CMD_REG(cpu)	(CDC_CMD_OFFSET + 4*(cpu))
+
+/*
+ * BCM23550 has a Cluster Dormant Control block that keeps the core in
+ * idle state. A command needs to be sent to the block to bring the CPU
+ * into running state.
+ */
+static int bcm23550_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	void __iomem *cdc_base;
+	struct device_node *dn;
+	char *name;
+	int ret;
+
+	/* Make sure a CDC node exists before booting the
+	 * secondary core.
+	 */
+	name = "brcm,bcm23550-cdc";
+	dn = of_find_compatible_node(NULL, NULL, name);
+	if (!dn) {
+		pr_err("unable to find cdc node\n");
+		return -ENODEV;
+	}
+
+	cdc_base = of_iomap(dn, 0);
+	of_node_put(dn);
+
+	if (!cdc_base) {
+		pr_err("unable to remap cdc base register\n");
+		return -ENOMEM;
+	}
+
+	/* Boot the secondary core */
+	ret = kona_boot_secondary(cpu, idle);
+	if (ret)
+		goto out;
+
+	/* Bring this CPU to RUN state so that nIRQ nFIQ
+	 * signals are unblocked.
+	 */
+	writel_relaxed(CDC_CMD, cdc_base + CDC_CMD_REG(cpu));
+
+out:
+	iounmap(cdc_base);
+
+	return ret;
+}
+
 static int nsp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int ret;
@@ -283,6 +335,12 @@ static const struct smp_operations bcm_smp_ops __initconst = {
 CPU_METHOD_OF_DECLARE(bcm_smp_bcm281xx, "brcm,bcm11351-cpu-method",
 			&bcm_smp_ops);
 
+static const struct smp_operations bcm23550_smp_ops __initconst = {
+	.smp_boot_secondary	= bcm23550_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(bcm_smp_bcm23550, "brcm,bcm23550",
+			&bcm23550_smp_ops);
+
 static const struct smp_operations nsp_smp_ops __initconst = {
 	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
 	.smp_boot_secondary	= nsp_boot_secondary,

commit 6585cb5a1341cbc5dfcf99a9b4ebda338b03657e
Author: Chris Brand <chris.brand@broadcom.com>
Date:   Thu Apr 28 10:59:59 2016 -0700

    ARM: BCM: modify Broadcom CPU enable method
    
    Commit 84320e1a635fcf90cff4185f029ce9e31bf1d4a7
    ("ARM: BCM: Clean up SMP support for Broadcom Kona") moved the
    "secondary-boot-reg" property from the "cpus" node to the individual "cpu"
    nodes but negelected to actually support multiple "secondary-boot-reg"
    properties.
    
    This patchset rectifies that omission. Note that the behaviour is changed
    slightly in that the "secondary-boot-reg" property is now read in
    smp_boot_secondary() rather than smp_prepare_cpus(). This means that any
    omissions will now only be reported when and if the cpu in question is being
    brought up. It also means that an omission for one cpu will not force
    uniprocessor mode.
    
    Signed-off-by: Chris Brand <chris.brand@broadcom.com>
    Reviewed-and-Tested-by: Jon Mason <jon.mason@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index cfae9c71fb74..5e53cf2fc052 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -37,9 +37,6 @@
 #define OF_SECONDARY_BOOT	"secondary-boot-reg"
 #define MPIDR_CPUID_BITMASK	0x3
 
-/* I/O address of register used to coordinate secondary core startup */
-static u32	secondary_boot_addr;
-
 /*
  * Enable the Cortex A9 Snoop Control Unit
  *
@@ -81,20 +78,40 @@ static int __init scu_a9_enable(void)
 	return 0;
 }
 
-static int nsp_write_lut(void)
+static u32 secondary_boot_addr_for(unsigned int cpu)
+{
+	u32 secondary_boot_addr = 0;
+	struct device_node *cpu_node = of_get_cpu_node(cpu, NULL);
+
+        if (!cpu_node) {
+		pr_err("Failed to find device tree node for CPU%u\n", cpu);
+		return 0;
+	}
+
+	if (of_property_read_u32(cpu_node,
+				 OF_SECONDARY_BOOT,
+				 &secondary_boot_addr))
+		pr_err("required secondary boot register not specified for CPU%u\n",
+			cpu);
+
+	of_node_put(cpu_node);
+
+	return secondary_boot_addr;
+}
+
+static int nsp_write_lut(unsigned int cpu)
 {
 	void __iomem *sku_rom_lut;
 	phys_addr_t secondary_startup_phy;
+	const u32 secondary_boot_addr = secondary_boot_addr_for(cpu);
 
-	if (!secondary_boot_addr) {
-		pr_warn("required secondary boot register not specified\n");
+	if (!secondary_boot_addr)
 		return -EINVAL;
-	}
 
 	sku_rom_lut = ioremap_nocache((phys_addr_t)secondary_boot_addr,
-						sizeof(secondary_boot_addr));
+				      sizeof(phys_addr_t));
 	if (!sku_rom_lut) {
-		pr_warn("unable to ioremap SKU-ROM LUT register\n");
+		pr_warn("unable to ioremap SKU-ROM LUT register for cpu %u\n", cpu);
 		return -ENOMEM;
 	}
 
@@ -113,70 +130,12 @@ static int nsp_write_lut(void)
 
 static void __init bcm_smp_prepare_cpus(unsigned int max_cpus)
 {
-	static cpumask_t only_cpu_0 = { CPU_BITS_CPU0 };
-	struct device_node *cpus_node = NULL;
-	struct device_node *cpu_node = NULL;
-	int ret;
-
-	/*
-	 * This function is only called via smp_ops->smp_prepare_cpu().
-	 * That only happens if a "/cpus" device tree node exists
-	 * and has an "enable-method" property that selects the SMP
-	 * operations defined herein.
-	 */
-	cpus_node = of_find_node_by_path("/cpus");
-	if (!cpus_node)
-		return;
-
-	for_each_child_of_node(cpus_node, cpu_node) {
-		u32 cpuid;
-
-		if (of_node_cmp(cpu_node->type, "cpu"))
-			continue;
-
-		if (of_property_read_u32(cpu_node, "reg", &cpuid)) {
-			pr_debug("%s: missing reg property\n",
-				     cpu_node->full_name);
-			ret = -ENOENT;
-			goto out;
-		}
-
-		/*
-		 * "secondary-boot-reg" property should be defined only
-		 * for secondary cpu
-		 */
-		if ((cpuid & MPIDR_CPUID_BITMASK) == 1) {
-			/*
-			 * Our secondary enable method requires a
-			 * "secondary-boot-reg" property to specify a register
-			 * address used to request the ROM code boot a secondary
-			 * core. If we have any trouble getting this we fall
-			 * back to uniprocessor mode.
-			 */
-			if (of_property_read_u32(cpu_node,
-						OF_SECONDARY_BOOT,
-						&secondary_boot_addr)) {
-				pr_warn("%s: no" OF_SECONDARY_BOOT "property\n",
-					cpu_node->name);
-				ret = -ENOENT;
-				goto out;
-			}
-		}
-	}
-
-	/*
-	 * Enable the SCU on Cortex A9 based SoCs. If -ENOENT is
-	 * returned, the SoC reported a uniprocessor configuration.
-	 * We bail on any other error.
-	 */
-	ret = scu_a9_enable();
-out:
-	of_node_put(cpu_node);
-	of_node_put(cpus_node);
+	const cpumask_t only_cpu_0 = { CPU_BITS_CPU0 };
 
-	if (ret) {
+	/* Enable the SCU on Cortex A9 based SoCs */
+	if (scu_a9_enable()) {
 		/* Update the CPU present map to reflect uniprocessor mode */
-		pr_warn("disabling SMP\n");
+		pr_warn("failed to enable A9 SCU - disabling SMP\n");
 		init_cpu_present(&only_cpu_0);
 	}
 }
@@ -207,6 +166,7 @@ static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	u32 cpu_id;
 	u32 boot_val;
 	bool timeout = false;
+	const u32 secondary_boot_addr = secondary_boot_addr_for(cpu);
 
 	cpu_id = cpu_logical_map(cpu);
 	if (cpu_id & ~BOOT_ADDR_CPUID_MASK) {
@@ -214,13 +174,11 @@ static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		return -EINVAL;
 	}
 
-	if (!secondary_boot_addr) {
-		pr_err("required secondary boot register not specified\n");
+	if (!secondary_boot_addr)
 		return -EINVAL;
-	}
 
-	boot_reg = ioremap_nocache(
-			(phys_addr_t)secondary_boot_addr, sizeof(u32));
+	boot_reg = ioremap_nocache((phys_addr_t)secondary_boot_addr,
+				   sizeof(phys_addr_t));
 	if (!boot_reg) {
 		pr_err("unable to map boot register for cpu %u\n", cpu_id);
 		return -ENOMEM;
@@ -263,7 +221,7 @@ static int nsp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * After wake up, secondary core branches to the startup
 	 * address programmed at SKU ROM LUT location.
 	 */
-	ret = nsp_write_lut();
+	ret = nsp_write_lut(cpu);
 	if (ret) {
 		pr_err("unable to write startup addr to SKU ROM LUT\n");
 		goto out;
@@ -276,12 +234,12 @@ static int nsp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return ret;
 }
 
-static const struct smp_operations bcm_smp_ops __initconst = {
+static const struct smp_operations kona_smp_ops __initconst = {
 	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
 	.smp_boot_secondary	= kona_boot_secondary,
 };
 CPU_METHOD_OF_DECLARE(bcm_smp_bcm281xx, "brcm,bcm11351-cpu-method",
-			&bcm_smp_ops);
+			&kona_smp_ops);
 
 static const struct smp_operations nsp_smp_ops __initconst = {
 	.smp_prepare_cpus	= bcm_smp_prepare_cpus,

commit 9480e085c3737e0638112fcce5cfeedb7909348c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Jan 25 20:31:15 2016 +0900

    ARM: bcm: use const and __initconst for smp_operations
    
    This newly added code missed the global fixup by commit 75305275a721
    ("ARM: use const and __initconst for smp_operations").  So fix it now.
    
    Also, add missing "static" qualifier.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Ray Jui <rjui@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index 575defcc53f9..cfae9c71fb74 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -283,7 +283,7 @@ static const struct smp_operations bcm_smp_ops __initconst = {
 CPU_METHOD_OF_DECLARE(bcm_smp_bcm281xx, "brcm,bcm11351-cpu-method",
 			&bcm_smp_ops);
 
-struct smp_operations nsp_smp_ops __initdata = {
+static const struct smp_operations nsp_smp_ops __initconst = {
 	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
 	.smp_boot_secondary	= nsp_boot_secondary,
 };

commit 8907dbaa363de87e5c6f48070e3d8b639477d5ba
Merge: 9cdac4a20a96 e32465429490
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Dec 22 13:10:00 2015 -0800

    Merge branch 'treewide/cleanup' into next/soc
    
    Merge in cleanup to avoid internal conflicts with newly added code.
    
    * treewide/cleanup:
      ARM: use "depends on" for SoC configs instead of "if" after prompt
      ARM/clocksource: use automatic DT probing for ux500 PRCMU
      ARM: use const and __initconst for smp_operations
      ARM: hisi: do not export smp_operations structures
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 97890821bb58dea522f823d8db396f9c17c6e356
Author: Kapil Hali <kapilh@broadcom.com>
Date:   Tue Dec 1 11:24:08 2015 -0500

    ARM: BCM: Add SMP support for Broadcom NSP
    
    Add SMP support for Broadcom's Northstar Plus SoC
    cpu enable method. This changes also consolidates
    iProc family's - BCM NSP and BCM Kona, platform
    SMP handling in a common file.
    
    Northstar Plus SoC is based on ARM Cortex-A9
    revision r3p0 which requires configuration for ARM
    Errata 764369 for SMP. This change adds the needed
    configuration option.
    
    Signed-off-by: Kapil Hali <kapilh@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
new file mode 100644
index 000000000000..ea4201e6d0c9
--- /dev/null
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 2014-2015 Broadcom Corporation
+ * Copyright 2014 Linaro Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/of.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp.h>
+#include <asm/smp_plat.h>
+#include <asm/smp_scu.h>
+
+/* Size of mapped Cortex A9 SCU address space */
+#define CORTEX_A9_SCU_SIZE	0x58
+
+#define SECONDARY_TIMEOUT_NS	NSEC_PER_MSEC	/* 1 msec (in nanoseconds) */
+#define BOOT_ADDR_CPUID_MASK	0x3
+
+/* Name of device node property defining secondary boot register location */
+#define OF_SECONDARY_BOOT	"secondary-boot-reg"
+#define MPIDR_CPUID_BITMASK	0x3
+
+/* I/O address of register used to coordinate secondary core startup */
+static u32	secondary_boot_addr;
+
+/*
+ * Enable the Cortex A9 Snoop Control Unit
+ *
+ * By the time this is called we already know there are multiple
+ * cores present.  We assume we're running on a Cortex A9 processor,
+ * so any trouble getting the base address register or getting the
+ * SCU base is a problem.
+ *
+ * Return 0 if successful or an error code otherwise.
+ */
+static int __init scu_a9_enable(void)
+{
+	unsigned long config_base;
+	void __iomem *scu_base;
+
+	if (!scu_a9_has_base()) {
+		pr_err("no configuration base address register!\n");
+		return -ENXIO;
+	}
+
+	/* Config base address register value is zero for uniprocessor */
+	config_base = scu_a9_get_base();
+	if (!config_base) {
+		pr_err("hardware reports only one core\n");
+		return -ENOENT;
+	}
+
+	scu_base = ioremap((phys_addr_t)config_base, CORTEX_A9_SCU_SIZE);
+	if (!scu_base) {
+		pr_err("failed to remap config base (%lu/%u) for SCU\n",
+			config_base, CORTEX_A9_SCU_SIZE);
+		return -ENOMEM;
+	}
+
+	scu_enable(scu_base);
+
+	iounmap(scu_base);	/* That's the last we'll need of this */
+
+	return 0;
+}
+
+static int nsp_write_lut(void)
+{
+	void __iomem *sku_rom_lut;
+	phys_addr_t secondary_startup_phy;
+
+	if (!secondary_boot_addr) {
+		pr_warn("required secondary boot register not specified\n");
+		return -EINVAL;
+	}
+
+	sku_rom_lut = ioremap_nocache((phys_addr_t)secondary_boot_addr,
+						sizeof(secondary_boot_addr));
+	if (!sku_rom_lut) {
+		pr_warn("unable to ioremap SKU-ROM LUT register\n");
+		return -ENOMEM;
+	}
+
+	secondary_startup_phy = virt_to_phys(secondary_startup);
+	BUG_ON(secondary_startup_phy > (phys_addr_t)U32_MAX);
+
+	writel_relaxed(secondary_startup_phy, sku_rom_lut);
+
+	/* Ensure the write is visible to the secondary core */
+	smp_wmb();
+
+	iounmap(sku_rom_lut);
+
+	return 0;
+}
+
+static void __init bcm_smp_prepare_cpus(unsigned int max_cpus)
+{
+	static cpumask_t only_cpu_0 = { CPU_BITS_CPU0 };
+	struct device_node *cpus_node = NULL;
+	struct device_node *cpu_node = NULL;
+	int ret;
+
+	/*
+	 * This function is only called via smp_ops->smp_prepare_cpu().
+	 * That only happens if a "/cpus" device tree node exists
+	 * and has an "enable-method" property that selects the SMP
+	 * operations defined herein.
+	 */
+	cpus_node = of_find_node_by_path("/cpus");
+	if (!cpus_node)
+		return;
+
+	for_each_child_of_node(cpus_node, cpu_node) {
+		u32 cpuid;
+
+		if (of_node_cmp(cpu_node->type, "cpu"))
+			continue;
+
+		if (of_property_read_u32(cpu_node, "reg", &cpuid)) {
+			pr_debug("%s: missing reg property\n",
+				     cpu_node->full_name);
+			ret = -ENOENT;
+			goto out;
+		}
+
+		/*
+		 * "secondary-boot-reg" property should be defined only
+		 * for secondary cpu
+		 */
+		if ((cpuid & MPIDR_CPUID_BITMASK) == 1) {
+			/*
+			 * Our secondary enable method requires a
+			 * "secondary-boot-reg" property to specify a register
+			 * address used to request the ROM code boot a secondary
+			 * core. If we have any trouble getting this we fall
+			 * back to uniprocessor mode.
+			 */
+			if (of_property_read_u32(cpu_node,
+						OF_SECONDARY_BOOT,
+						&secondary_boot_addr)) {
+				pr_warn("%s: no" OF_SECONDARY_BOOT "property\n",
+					cpu_node->name);
+				ret = -ENOENT;
+				goto out;
+			}
+		}
+	}
+
+	/*
+	 * Enable the SCU on Cortex A9 based SoCs. If -ENOENT is
+	 * returned, the SoC reported a uniprocessor configuration.
+	 * We bail on any other error.
+	 */
+	ret = scu_a9_enable();
+out:
+	of_node_put(cpu_node);
+	of_node_put(cpus_node);
+
+	if (ret) {
+		/* Update the CPU present map to reflect uniprocessor mode */
+		pr_warn("disabling SMP\n");
+		init_cpu_present(&only_cpu_0);
+	}
+}
+
+/*
+ * The ROM code has the secondary cores looping, waiting for an event.
+ * When an event occurs each core examines the bottom two bits of the
+ * secondary boot register.  When a core finds those bits contain its
+ * own core id, it performs initialization, including computing its boot
+ * address by clearing the boot register value's bottom two bits.  The
+ * core signals that it is beginning its execution by writing its boot
+ * address back to the secondary boot register, and finally jumps to
+ * that address.
+ *
+ * So to start a core executing we need to:
+ * - Encode the (hardware) CPU id with the bottom bits of the secondary
+ *   start address.
+ * - Write that value into the secondary boot register.
+ * - Generate an event to wake up the secondary CPU(s).
+ * - Wait for the secondary boot register to be re-written, which
+ *   indicates the secondary core has started.
+ */
+static int kona_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	void __iomem *boot_reg;
+	phys_addr_t boot_func;
+	u64 start_clock;
+	u32 cpu_id;
+	u32 boot_val;
+	bool timeout = false;
+
+	cpu_id = cpu_logical_map(cpu);
+	if (cpu_id & ~BOOT_ADDR_CPUID_MASK) {
+		pr_err("bad cpu id (%u > %u)\n", cpu_id, BOOT_ADDR_CPUID_MASK);
+		return -EINVAL;
+	}
+
+	if (!secondary_boot_addr) {
+		pr_err("required secondary boot register not specified\n");
+		return -EINVAL;
+	}
+
+	boot_reg = ioremap_nocache(
+			(phys_addr_t)secondary_boot_addr, sizeof(u32));
+	if (!boot_reg) {
+		pr_err("unable to map boot register for cpu %u\n", cpu_id);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Secondary cores will start in secondary_startup(),
+	 * defined in "arch/arm/kernel/head.S"
+	 */
+	boot_func = virt_to_phys(secondary_startup);
+	BUG_ON(boot_func & BOOT_ADDR_CPUID_MASK);
+	BUG_ON(boot_func > (phys_addr_t)U32_MAX);
+
+	/* The core to start is encoded in the low bits */
+	boot_val = (u32)boot_func | cpu_id;
+	writel_relaxed(boot_val, boot_reg);
+
+	sev();
+
+	/* The low bits will be cleared once the core has started */
+	start_clock = local_clock();
+	while (!timeout && readl_relaxed(boot_reg) == boot_val)
+		timeout = local_clock() - start_clock > SECONDARY_TIMEOUT_NS;
+
+	iounmap(boot_reg);
+
+	if (!timeout)
+		return 0;
+
+	pr_err("timeout waiting for cpu %u to start\n", cpu_id);
+
+	return -ENXIO;
+}
+
+static int nsp_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	int ret;
+
+	/*
+	 * After wake up, secondary core branches to the startup
+	 * address programmed at SKU ROM LUT location.
+	 */
+	ret = nsp_write_lut();
+	if (ret) {
+		pr_err("unable to write startup addr to SKU ROM LUT\n");
+		goto out;
+	}
+
+	/* Send a CPU wakeup interrupt to the secondary core */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+out:
+	return ret;
+}
+
+static struct smp_operations bcm_smp_ops __initdata = {
+	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
+	.smp_boot_secondary	= kona_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(bcm_smp_bcm281xx, "brcm,bcm11351-cpu-method",
+			&bcm_smp_ops);
+
+struct smp_operations nsp_smp_ops __initdata = {
+	.smp_prepare_cpus	= bcm_smp_prepare_cpus,
+	.smp_boot_secondary	= nsp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(bcm_smp_nsp, "brcm,bcm-nsp-smp", &nsp_smp_ops);
