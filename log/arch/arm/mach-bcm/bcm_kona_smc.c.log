commit b47879aa85ed8969ab5c9a03b99d5414ee3b4148
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 8 13:34:44 2019 +0100

    ARM: bcm: fix missing __iomem in bcm_kona_smc.c
    
    Fix the following sparse warnings from a missing __iomem
    in __bcm_kona_smc() function by adding __iomem attriubte.
    
    arch/arm/mach-bcm/bcm_kona_smc.c:143:21: warning: incorrect type in initializer (different address spaces)
    arch/arm/mach-bcm/bcm_kona_smc.c:143:21:    expected unsigned int [usertype] *args
    arch/arm/mach-bcm/bcm_kona_smc.c:143:21:    got void [noderef] <asn:2> *static [toplevel] [assigned] bcm_smc
    _buffer
    arch/arm/mach-bcm/bcm_kona_smc.c:149:9: warning: incorrect type in argument 2 (different address spaces)
    arch/arm/mach-bcm/bcm_kona_smc.c:149:9:    expected void volatile [noderef] <asn:2> *addr
    arch/arm/mach-bcm/bcm_kona_smc.c:149:9:    got unsigned int [usertype] *
    arch/arm/mach-bcm/bcm_kona_smc.c:150:9: warning: incorrect type in argument 2 (different address spaces)
    arch/arm/mach-bcm/bcm_kona_smc.c:150:9:    expected void volatile [noderef] <asn:2> *addr
    arch/arm/mach-bcm/bcm_kona_smc.c:150:9:    got unsigned int [usertype] *
    arch/arm/mach-bcm/bcm_kona_smc.c:151:9: warning: incorrect type in argument 2 (different address spaces)
    arch/arm/mach-bcm/bcm_kona_smc.c:151:9:    expected void volatile [noderef] <asn:2> *addr
    arch/arm/mach-bcm/bcm_kona_smc.c:151:9:    got unsigned int [usertype] *
    arch/arm/mach-bcm/bcm_kona_smc.c:152:9: warning: incorrect type in argument 2 (different address spaces)
    arch/arm/mach-bcm/bcm_kona_smc.c:152:9:    expected void volatile [noderef] <asn:2> *addr
    arch/arm/mach-bcm/bcm_kona_smc.c:152:9:    got unsigned int [usertype] *[assigned] args
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 541e850a736c..43a16f922b53 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -140,7 +140,7 @@ static int bcm_kona_do_smc(u32 service_id, u32 buffer_phys)
 static void __bcm_kona_smc(void *info)
 {
 	struct bcm_kona_smc_data *data = info;
-	u32 *args = bcm_smc_buffer;
+	u32 __iomem *args = bcm_smc_buffer;
 
 	BUG_ON(smp_processor_id() != 0);
 	BUG_ON(!args);

commit 3fe1ee40b2a2db271513a498c475c13572dcb4c6
Author: Stefan Agner <stefan@agner.ch>
Date:   Tue May 28 00:40:50 2019 +0200

    ARM: use arch_extension directive instead of arch argument
    
    The LLVM Target parser currently does not allow to specify the security
    extension as part of -march (see also LLVM Bug 40186 [0]). When trying
    to use Clang with LLVM's integrated assembler, this leads to build
    errors such as this:
      clang-8: error: the clang compiler does not support '-Wa,-march=armv7-a+sec'
    
    Use ".arch_extension sec" to enable the security extension in a more
    portable fasion. Also make sure to use ".arch armv7-a" in case a v6/v7
    multi-platform kernel is being built.
    
    Note that this is technically not exactly the same as the old code
    checked for availabilty of the security extension by calling as-instr.
    However, there are already other sites which use ".arch_extension sec"
    unconditionally, hence de-facto we need an assembler capable of
    ".arch_extension sec" already today (arch/arm/mm/proc-v7.S). The
    arch extension "sec" is available since binutils 2.21 according to
    its documentation [1].
    
    [0] https://bugs.llvm.org/show_bug.cgi?id=40186
    [1] https://sourceware.org/binutils/docs-2.21/as/ARM-Options.html
    
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Acked-by: Mans Rullgard <mans@mansr.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index a55a7ecf146a..541e850a736c 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -125,9 +125,7 @@ static int bcm_kona_do_smc(u32 service_id, u32 buffer_phys)
 		__asmeq("%2", "r4")
 		__asmeq("%3", "r5")
 		__asmeq("%4", "r6")
-#ifdef REQUIRES_SEC
 		".arch_extension sec\n"
-#endif
 		"	smc    #0\n"
 		: "=r" (ip), "=r" (r0)
 		: "r" (r4), "r" (r5), "r" (r6)

commit 0527873b29b077fc8e656acd63e1866b429fef55
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 11 13:50:16 2017 +0200

    ARM: remove duplicate 'const' annotations'
    
    gcc-7 warns about some declarations that are more 'const' than necessary:
    
    arch/arm/mach-at91/pm.c:338:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const ramc_ids[] __initconst = {
    arch/arm/mach-bcm/bcm_kona_smc.c:36:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
    arch/arm/mach-spear/time.c:207:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const timer_of_match[] __initconst = {
    arch/arm/mach-omap2/prm_common.c:714:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
    arch/arm/mach-omap2/vc.c:562:35: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
    
    The ones in arch/arm were apparently all introduced accidentally by one
    commit that correctly marked a lot of variables as __initconst.
    
    Fixes: 19c233b79d1a ("ARM: appropriate __init annotation for const data")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index cf3f8658f0e5..a55a7ecf146a 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -33,7 +33,7 @@ struct bcm_kona_smc_data {
 	unsigned result;
 };
 
-static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
+static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
 	{.compatible = "brcm,kona-smc"},
 	{.compatible = "bcm,kona-smc"}, /* deprecated name */
 	{},

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index a55a7ecf146a..cf3f8658f0e5 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -33,7 +33,7 @@ struct bcm_kona_smc_data {
 	unsigned result;
 };
 
-static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
+static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
 	{.compatible = "brcm,kona-smc"},
 	{.compatible = "bcm,kona-smc"}, /* deprecated name */
 	{},

commit ed24f446ab82e3f39c4a45357186ca76368301e4
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:10 2014 -0500

    ARM: bcm: rewrite commentary for bcm_kona_do_smc()
    
    The block of comments in bcm_kona_do_smc() are somewhat confusing.
    This patch attempts to clarify what's going on.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index cc81c86f24b5..a55a7ecf146a 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -77,16 +77,34 @@ int __init bcm_kona_smc_init(void)
 }
 
 /*
- * Since interrupts are disabled in the open mode, we must keep
- * interrupts disabled in secure mode by setting R5=0x3. If interrupts
- * are enabled in open mode, we can set R5=0x0 to allow interrupts in
- * secure mode.  If we did this, the secure monitor would return back
- * control to the open mode to handle the interrupt prior to completing
- * the secure service. If this happened, R12 would not be
- * SEC_EXIT_NORMAL and we would need to call SMC again after resetting
- * R5 (it gets clobbered by the secure monitor) and setting R4 to
- * SSAPI_RET_FROM_INT_SERV to indicate that we want the secure monitor
- * to finish up the previous uncompleted secure service.
+ * int bcm_kona_do_smc(u32 service_id, u32 buffer_addr)
+ *
+ * Only core 0 can run the secure monitor code.  If an "smc" request
+ * is initiated on a different core it must be redirected to core 0
+ * for execution.  We rely on the caller to handle this.
+ *
+ * Each "smc" request supplies a service id and the address of a
+ * buffer containing parameters related to the service to be
+ * performed.  A flags value defines the behavior of the level 2
+ * cache and interrupt handling while the secure monitor executes.
+ *
+ * Parameters to the "smc" request are passed in r4-r6 as follows:
+ *     r4	service id
+ *     r5	flags (SEC_ROM_*)
+ *     r6	physical address of buffer with other parameters
+ *
+ * Execution of an "smc" request produces two distinct results.
+ *
+ * First, the secure monitor call itself (regardless of the specific
+ * service request) can succeed, or can produce an error.  When an
+ * "smc" request completes this value is found in r12; it should
+ * always be SEC_EXIT_NORMAL.
+ *
+ * In addition, the particular service performed produces a result.
+ * The values that should be expected depend on the service.  We
+ * therefore return this value to the caller, so it can handle the
+ * request result appropriately.  This result value is found in r0
+ * when the "smc" request completes.
  */
 static int bcm_kona_do_smc(u32 service_id, u32 buffer_phys)
 {

commit 8b9c550e37ff4e4d0de2890a835f44a7813e3423
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:09 2014 -0500

    ARM: bcm: use inline assembly for "smc" request
    
    Move the code that implements the "smc" call into a C function that
    uses inline assembly.  This allows us to make that function private,
    and enables us to get rid of "arch/arm/mach-bcm/bcm_kona_smc_asm.S".
    Rename what had been the "buffer_addr" argument to be "buffer_phys"
    so it's consistent with other usage in this file.
    
    Since it's now easy to do, verify that r12 contains SEC_EXIT_NORMAL
    upon completion of the SMC.  There really isn't a good way to handle
    the abnormal completion of a secure monitor request.
    
    Since "bcm_kona_smc.h" is now only included from C files, eliminate
    the #ifndef __ASSEMBLY__.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 6fdcf96ca54e..cc81c86f24b5 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -76,6 +76,50 @@ int __init bcm_kona_smc_init(void)
 	return 0;
 }
 
+/*
+ * Since interrupts are disabled in the open mode, we must keep
+ * interrupts disabled in secure mode by setting R5=0x3. If interrupts
+ * are enabled in open mode, we can set R5=0x0 to allow interrupts in
+ * secure mode.  If we did this, the secure monitor would return back
+ * control to the open mode to handle the interrupt prior to completing
+ * the secure service. If this happened, R12 would not be
+ * SEC_EXIT_NORMAL and we would need to call SMC again after resetting
+ * R5 (it gets clobbered by the secure monitor) and setting R4 to
+ * SSAPI_RET_FROM_INT_SERV to indicate that we want the secure monitor
+ * to finish up the previous uncompleted secure service.
+ */
+static int bcm_kona_do_smc(u32 service_id, u32 buffer_phys)
+{
+	register u32 ip asm("ip");	/* Also called r12 */
+	register u32 r0 asm("r0");
+	register u32 r4 asm("r4");
+	register u32 r5 asm("r5");
+	register u32 r6 asm("r6");
+
+	r4 = service_id;
+	r5 = 0x3;		/* Keep IRQ and FIQ off in SM */
+	r6 = buffer_phys;
+
+	asm volatile (
+		/* Make sure we got the registers we want */
+		__asmeq("%0", "ip")
+		__asmeq("%1", "r0")
+		__asmeq("%2", "r4")
+		__asmeq("%3", "r5")
+		__asmeq("%4", "r6")
+#ifdef REQUIRES_SEC
+		".arch_extension sec\n"
+#endif
+		"	smc    #0\n"
+		: "=r" (ip), "=r" (r0)
+		: "r" (r4), "r" (r5), "r" (r6)
+		: "r1", "r2", "r3", "r7", "lr");
+
+	BUG_ON(ip != SEC_EXIT_NORMAL);
+
+	return r0;
+}
+
 /* __bcm_kona_smc() should only run on CPU 0, with pre-emption disabled */
 static void __bcm_kona_smc(void *info)
 {
@@ -95,7 +139,7 @@ static void __bcm_kona_smc(void *info)
 	flush_cache_all();
 
 	/* Trap into Secure Monitor and record the request result */
-	data->result = bcm_kona_smc_asm(data->service_id, bcm_smc_buffer_phys);
+	data->result = bcm_kona_do_smc(data->service_id, bcm_smc_buffer_phys);
 }
 
 unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,

commit 35138d52f18c3f757f12d54c0962a755bcf218f3
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:06 2014 -0500

    ARM: bcm: don't special-case CPU 0 in bcm_kona_smc()
    
    There's logic in bcm_kona_smc() to ensure __bcm_kona_smc() gets
    called on CPU 0; if already executing on CPU 0, that function is
    called directly.  The direct call is not protected from interrupts,
    however, which is not safe.
    
    Note that smp_call_function_single() is designed to handle the case
    where the target cpu is the current one.  It also gets a reference
    to the CPU and disables IRQs across the call.
    
    So we can simplify things and at the same time be protected against
    interrupts by calling smp_call_function_single() unconditionally.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 47cf360f985b..6fdcf96ca54e 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -114,12 +114,7 @@ unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,
 	 * Due to a limitation of the secure monitor, we must use the SMP
 	 * infrastructure to forward all secure monitor calls to Core 0.
 	 */
-	if (get_cpu() != 0)
-		smp_call_function_single(0, __bcm_kona_smc, (void *)&data, 1);
-	else
-		__bcm_kona_smc(&data);
-
-	put_cpu();
+	smp_call_function_single(0, __bcm_kona_smc, &data, 1);
 
 	return data.result;
 }

commit 6c90f10864d1f7492ebe4c90465a9c9797ce649e
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:05 2014 -0500

    ARM: bcm: have bcm_kona_smc() return request result
    
    Currently it is assumed that SEC_ROM_RET_OK is the only valid "good"
    result of a secure monitor request.  However the values that can be
    returned by a secure monitor request are dependent on which service
    id was provided.
    
    We therefore should handle the result in a request-dependent way.
    The most natural way to do that is to have the initiator of the
    request--where bcm_kona_smc() is called--handle the result in a way
    appropriate to the request.
    
    An "smc" operation must be performed only on core 0, while the
    request can be initiated from any core.  To pass back the request
    result, we add a new field to the bcm_kona_smc_data structure, and
    have bcm_kona_smc() return that value rather than 0.
    
    There's only one caller right now.  Move the existing check of the
    result out of __bcm_kona_smc() and into the kona_l2_cache_init()
    where the SSAPI_ENABLE_L2_CACHE request is initiated.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 0d2bfe2bcfa8..47cf360f985b 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -30,6 +30,7 @@ struct bcm_kona_smc_data {
 	unsigned arg1;
 	unsigned arg2;
 	unsigned arg3;
+	unsigned result;
 };
 
 static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
@@ -80,7 +81,6 @@ static void __bcm_kona_smc(void *info)
 {
 	struct bcm_kona_smc_data *data = info;
 	u32 *args = bcm_smc_buffer;
-	int rc;
 
 	BUG_ON(smp_processor_id() != 0);
 	BUG_ON(!args);
@@ -94,11 +94,8 @@ static void __bcm_kona_smc(void *info)
 	/* Flush caches for input data passed to Secure Monitor */
 	flush_cache_all();
 
-	/* Trap into Secure Monitor */
-	rc = bcm_kona_smc_asm(data->service_id, bcm_smc_buffer_phys);
-
-	if (rc != SEC_ROM_RET_OK)
-		pr_err("Secure Monitor call failed (0x%x)!\n", rc);
+	/* Trap into Secure Monitor and record the request result */
+	data->result = bcm_kona_smc_asm(data->service_id, bcm_smc_buffer_phys);
 }
 
 unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,
@@ -111,6 +108,7 @@ unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,
 	data.arg1 = arg1;
 	data.arg2 = arg2;
 	data.arg3 = arg3;
+	data.result = 0;
 
 	/*
 	 * Due to a limitation of the secure monitor, we must use the SMP
@@ -123,5 +121,5 @@ unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,
 
 	put_cpu();
 
-	return 0;
+	return data.result;
 }

commit c64756cca2fb4da96fcc71e376d712297aedc4a2
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:04 2014 -0500

    ARM: bcm: clean up SMC code
    
    This patch just does some simple cleanup in "bcm_kona_smc.c":
        - Get rid of the secure_bridge_data structure.  Instead, just
          define two globals that record the physical and virtual
          addresses of the SMC arguments buffer.  Use "buffer" instead
          of "bounce" in their names.  Drop of the erroneous __iomem
          annotation for the physical address.
        - Get rid of the initialized flag and just use a non-null buffer
          address to indicate that.
        - Get the size of the memory region when fetching the SMC
          arguments buffer location from the device tree.  Use it to
          call ioremap() directly rather than requiring of_iomap() to
          go look it up again.
        - Do some additional validation on that memory region size.
        - Flush caches unconditionally in __bcm_kona_smc(); nothing
          supplies SSAPI_BRCM_START_VC_CORE as a service id.
        - Drop a needless initialization of "rc" in __bcm_kona_smc().
    
    It also deletes most of the content of "bcm_kona_smc.h" because it's
    never actually used and is of questionable value anyway.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index ddc2f17217ee..0d2bfe2bcfa8 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -21,11 +21,8 @@
 
 #include "bcm_kona_smc.h"
 
-struct secure_bridge_data {
-	void __iomem *bounce;		/* virtual address */
-	u32 __iomem buffer_addr;	/* physical address */
-	int initialized;
-} bridge_data;
+static u32		bcm_smc_buffer_phys;	/* physical address */
+static void __iomem	*bcm_smc_buffer;	/* virtual address */
 
 struct bcm_kona_smc_data {
 	unsigned service_id;
@@ -41,31 +38,37 @@ static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
 	{},
 };
 
-/* Map in the bounce area */
+/* Map in the args buffer area */
 int __init bcm_kona_smc_init(void)
 {
 	struct device_node *node;
 	const __be32 *prop_val;
+	u64 prop_size = 0;
+	unsigned long buffer_size;
+	u32 buffer_phys;
 
 	/* Read buffer addr and size from the device tree node */
 	node = of_find_matching_node(NULL, bcm_kona_smc_ids);
 	if (!node)
 		return -ENODEV;
 
-	/* Don't care about size or flags of the DT node */
-	prop_val = of_get_address(node, 0, NULL, NULL);
+	prop_val = of_get_address(node, 0, &prop_size, NULL);
 	if (!prop_val)
 		return -EINVAL;
 
-	bridge_data.buffer_addr = be32_to_cpu(*prop_val);
-	if (!bridge_data.buffer_addr)
+	/* We assume space for four 32-bit arguments */
+	if (prop_size < 4 * sizeof(u32) || prop_size > (u64)ULONG_MAX)
 		return -EINVAL;
+	buffer_size = (unsigned long)prop_size;
 
-	bridge_data.bounce = of_iomap(node, 0);
-	if (!bridge_data.bounce)
-		return -ENOMEM;
+	buffer_phys = be32_to_cpup(prop_val);
+	if (!buffer_phys)
+		return -EINVAL;
 
-	bridge_data.initialized = 1;
+	bcm_smc_buffer = ioremap(buffer_phys, buffer_size);
+	if (!bcm_smc_buffer)
+		return -ENOMEM;
+	bcm_smc_buffer_phys = buffer_phys;
 
 	pr_info("Kona Secure API initialized\n");
 
@@ -76,14 +79,11 @@ int __init bcm_kona_smc_init(void)
 static void __bcm_kona_smc(void *info)
 {
 	struct bcm_kona_smc_data *data = info;
-	u32 *args = bridge_data.bounce;
-	int rc = 0;
+	u32 *args = bcm_smc_buffer;
+	int rc;
 
-	/* Must run on CPU 0 */
 	BUG_ON(smp_processor_id() != 0);
-
-	/* Check map in the bounce area */
-	BUG_ON(!bridge_data.initialized);
+	BUG_ON(!args);
 
 	/* Copy the four 32 bit argument values into the bounce area */
 	writel_relaxed(data->arg0, args++);
@@ -92,11 +92,10 @@ static void __bcm_kona_smc(void *info)
 	writel(data->arg3, args);
 
 	/* Flush caches for input data passed to Secure Monitor */
-	if (data->service_id != SSAPI_BRCM_START_VC_CORE)
-		flush_cache_all();
+	flush_cache_all();
 
 	/* Trap into Secure Monitor */
-	rc = bcm_kona_smc_asm(data->service_id, bridge_data.buffer_addr);
+	rc = bcm_kona_smc_asm(data->service_id, bcm_smc_buffer_phys);
 
 	if (rc != SEC_ROM_RET_OK)
 		pr_err("Secure Monitor call failed (0x%x)!\n", rc);

commit 5c4cee2fe8de7c14e60502b02e7c3bc7acba0530
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:03 2014 -0500

    ARM: bcm: err, don't BUG() on SMC init failures
    
    Several conditions in bcm_kona_smc_init() are handled with BUG_ON().
    That function is capable of returning an error, so do that instead.
    
    Also, don't assume of_get_address() returns a valid pointer.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index d881c72ee878..ddc2f17217ee 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -45,6 +45,7 @@ static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
 int __init bcm_kona_smc_init(void)
 {
 	struct device_node *node;
+	const __be32 *prop_val;
 
 	/* Read buffer addr and size from the device tree node */
 	node = of_find_matching_node(NULL, bcm_kona_smc_ids);
@@ -52,12 +53,17 @@ int __init bcm_kona_smc_init(void)
 		return -ENODEV;
 
 	/* Don't care about size or flags of the DT node */
-	bridge_data.buffer_addr =
-		be32_to_cpu(*of_get_address(node, 0, NULL, NULL));
-	BUG_ON(!bridge_data.buffer_addr);
+	prop_val = of_get_address(node, 0, NULL, NULL);
+	if (!prop_val)
+		return -EINVAL;
+
+	bridge_data.buffer_addr = be32_to_cpu(*prop_val);
+	if (!bridge_data.buffer_addr)
+		return -EINVAL;
 
 	bridge_data.bounce = of_iomap(node, 0);
-	BUG_ON(!bridge_data.bounce);
+	if (!bridge_data.bounce)
+		return -ENOMEM;
 
 	bridge_data.initialized = 1;
 

commit e80eef33f4596a247fdcf7d67d54d95d9dfaf7d3
Author: Alex Elder <elder@linaro.org>
Date:   Mon Apr 21 16:53:02 2014 -0500

    ARM: bcm: use memory accessors for ioremapped area
    
    The pointer used to pass parameters to an "smc" call is produced
    through a call to ioremap().  As such, we should be using functions
    like writel() to access it.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Tim Kryger <tim.kryger@linaro.org>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Matt Porter <mporter@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 5e31e918f325..d881c72ee878 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -79,11 +79,11 @@ static void __bcm_kona_smc(void *info)
 	/* Check map in the bounce area */
 	BUG_ON(!bridge_data.initialized);
 
-	/* Copy one 32 bit word into the bounce area */
-	args[0] = data->arg0;
-	args[1] = data->arg1;
-	args[2] = data->arg2;
-	args[3] = data->arg3;
+	/* Copy the four 32 bit argument values into the bounce area */
+	writel_relaxed(data->arg0, args++);
+	writel_relaxed(data->arg1, args++);
+	writel_relaxed(data->arg2, args++);
+	writel(data->arg3, args);
 
 	/* Flush caches for input data passed to Secure Monitor */
 	if (data->service_id != SSAPI_BRCM_START_VC_CORE)

commit 3a76b35186cb967a69c4a3935caf2fdf428e933b
Author: Christian Daudt <csd@broadcom.com>
Date:   Tue Aug 6 17:04:54 2013 -0700

    ARM: bcm: Make secure API call optional
    
    The current bcm_kona_smc_init function throws a BUG_ON if there's no SMC
    device node defined in the device tree.
    
    Since secure API access is optional depending the chip configuration,
    fix this by allowing the rest of the code to run even if there's no SMC
    device node defined
    
    Signed-off-by: Christian Daudt <csd@broadcom.com>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index bcc1c5903fb1..5e31e918f325 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -42,13 +42,14 @@ static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
 };
 
 /* Map in the bounce area */
-void __init bcm_kona_smc_init(void)
+int __init bcm_kona_smc_init(void)
 {
 	struct device_node *node;
 
 	/* Read buffer addr and size from the device tree node */
 	node = of_find_matching_node(NULL, bcm_kona_smc_ids);
-	BUG_ON(!node);
+	if (!node)
+		return -ENODEV;
 
 	/* Don't care about size or flags of the DT node */
 	bridge_data.buffer_addr =
@@ -60,7 +61,9 @@ void __init bcm_kona_smc_init(void)
 
 	bridge_data.initialized = 1;
 
-	pr_info("Secure API initialized!\n");
+	pr_info("Kona Secure API initialized\n");
+
+	return 0;
 }
 
 /* __bcm_kona_smc() should only run on CPU 0, with pre-emption disabled */

commit aea237bfa0a8ce8fe364e3fa7de6850777044a60
Author: Christian Daudt <csd@broadcom.com>
Date:   Tue Aug 20 08:37:19 2013 -0700

    ARM: DT: binding fixup to align with vendor-prefixes.txt (drivers)
    
    [ this is a follow-up to this discussion:
    http://archive.arm.linux.org.uk/lurker/message/20130730.230827.a1ceb12a.en.html ]
    This patchset renames all uses of "bcm," name bindings to
    "brcm," as they were done prior to knowing that brcm had
    already been standardized as Broadcom vendor prefix
    (in Documentation/devicetree/bindings/vendor-prefixes.txt).
    This will not cause any churn on devices because none of
    these bindings have made it into production yet.
    
    Signed-off-by: Christian Daudt <csd@broadcom.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 56d9d19b2470..bcc1c5903fb1 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -36,7 +36,8 @@ struct bcm_kona_smc_data {
 };
 
 static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
-	{.compatible = "bcm,kona-smc"},
+	{.compatible = "brcm,kona-smc"},
+	{.compatible = "bcm,kona-smc"}, /* deprecated name */
 	{},
 };
 

commit 721e0205b07589223343737a9c421d8118d87bba
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 23 16:06:40 2013 +0200

    ARM: bcm: mark bcm_kona_smc_init as __init
    
    The bcm_kona_smc_init function references the bcm_kona_smc_ids variable
    that is marked __initconst, so the function itself has to be __init
    to avoid this build error:
    
    WARNING: arch/arm/mach-bcm/built-in.o(.text+0x12c): Section mismatch in reference from the function bcm_kona_smc_init() to the (unknown reference) .init.rodata:(unknown)
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Christian Daudt <csd@broadcom.com>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
index 5f1d13175138..56d9d19b2470 100644
--- a/arch/arm/mach-bcm/bcm_kona_smc.c
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -41,7 +41,7 @@ static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
 };
 
 /* Map in the bounce area */
-void bcm_kona_smc_init(void)
+void __init bcm_kona_smc_init(void)
 {
 	struct device_node *node;
 

commit b8eb35fd594aa5b635e329d5c8efab8aaceb8619
Author: Christian Daudt <csd@broadcom.com>
Date:   Tue Feb 26 21:48:49 2013 -0800

    ARM: bcm281xx: Add L2 cache enable code
    
    - Adds a module to provide calls into secure monitor mode
    - Uses this module to make secure monitor calls to enable L2 cache.
    
    Updates from V1:
    - Split DT portion into separate patch
    - replace #ifdef-ed L2 code with "if".
    - move init call to board init
    
    Signed-off-by: Christian Daudt <csd@broadcom.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c
new file mode 100644
index 000000000000..5f1d13175138
--- /dev/null
+++ b/arch/arm/mach-bcm/bcm_kona_smc.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2013 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <stdarg.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+
+#include <asm/cacheflush.h>
+#include <linux/of_address.h>
+
+#include "bcm_kona_smc.h"
+
+struct secure_bridge_data {
+	void __iomem *bounce;		/* virtual address */
+	u32 __iomem buffer_addr;	/* physical address */
+	int initialized;
+} bridge_data;
+
+struct bcm_kona_smc_data {
+	unsigned service_id;
+	unsigned arg0;
+	unsigned arg1;
+	unsigned arg2;
+	unsigned arg3;
+};
+
+static const struct of_device_id bcm_kona_smc_ids[] __initconst = {
+	{.compatible = "bcm,kona-smc"},
+	{},
+};
+
+/* Map in the bounce area */
+void bcm_kona_smc_init(void)
+{
+	struct device_node *node;
+
+	/* Read buffer addr and size from the device tree node */
+	node = of_find_matching_node(NULL, bcm_kona_smc_ids);
+	BUG_ON(!node);
+
+	/* Don't care about size or flags of the DT node */
+	bridge_data.buffer_addr =
+		be32_to_cpu(*of_get_address(node, 0, NULL, NULL));
+	BUG_ON(!bridge_data.buffer_addr);
+
+	bridge_data.bounce = of_iomap(node, 0);
+	BUG_ON(!bridge_data.bounce);
+
+	bridge_data.initialized = 1;
+
+	pr_info("Secure API initialized!\n");
+}
+
+/* __bcm_kona_smc() should only run on CPU 0, with pre-emption disabled */
+static void __bcm_kona_smc(void *info)
+{
+	struct bcm_kona_smc_data *data = info;
+	u32 *args = bridge_data.bounce;
+	int rc = 0;
+
+	/* Must run on CPU 0 */
+	BUG_ON(smp_processor_id() != 0);
+
+	/* Check map in the bounce area */
+	BUG_ON(!bridge_data.initialized);
+
+	/* Copy one 32 bit word into the bounce area */
+	args[0] = data->arg0;
+	args[1] = data->arg1;
+	args[2] = data->arg2;
+	args[3] = data->arg3;
+
+	/* Flush caches for input data passed to Secure Monitor */
+	if (data->service_id != SSAPI_BRCM_START_VC_CORE)
+		flush_cache_all();
+
+	/* Trap into Secure Monitor */
+	rc = bcm_kona_smc_asm(data->service_id, bridge_data.buffer_addr);
+
+	if (rc != SEC_ROM_RET_OK)
+		pr_err("Secure Monitor call failed (0x%x)!\n", rc);
+}
+
+unsigned bcm_kona_smc(unsigned service_id, unsigned arg0, unsigned arg1,
+		  unsigned arg2, unsigned arg3)
+{
+	struct bcm_kona_smc_data data;
+
+	data.service_id = service_id;
+	data.arg0 = arg0;
+	data.arg1 = arg1;
+	data.arg2 = arg2;
+	data.arg3 = arg3;
+
+	/*
+	 * Due to a limitation of the secure monitor, we must use the SMP
+	 * infrastructure to forward all secure monitor calls to Core 0.
+	 */
+	if (get_cpu() != 0)
+		smp_call_function_single(0, __bcm_kona_smc, (void *)&data, 1);
+	else
+		__bcm_kona_smc(&data);
+
+	put_cpu();
+
+	return 0;
+}
