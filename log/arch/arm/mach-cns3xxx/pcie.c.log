commit 25d5bf4764f9a0855180cd52559186dd16c0c39f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 418
    
    Based on 1 normalized pattern(s):
    
      this file is free software you can redistribute it and or modify it
      under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190113.419778592@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 95a11d5b3587..e92fbd679dfb 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * PCI-E support for CNS3xxx
  *
@@ -5,10 +6,6 @@
  *		  Richard Liu <richard.liu@caviumnetworks.com>
  * Copyright 2010 MontaVista Software, LLC.
  *		  Anton Vorontsov <avorontsov@mvista.com>
- *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as
- * published by the Free Software Foundation.
  */
 
 #include <linux/init.h>

commit 432dd7064aa1c030a488745917cfa4ebc6c8c060
Author: Koen Vandeputte <koen.vandeputte@ncentric.com>
Date:   Thu Jan 31 15:00:11 2019 -0600

    ARM: cns3xxx: Use actual size reads for PCIe
    
    commit 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config
    accessors") reimplemented cns3xxx_pci_read_config() using
    pci_generic_config_read32(), which preserved the property of only doing
    32-bit reads.
    
    It also replaced cns3xxx_pci_write_config() with pci_generic_config_write(),
    so it changed writes from always being 32 bits to being the actual size,
    which works just fine.
    
    Given that:
    
    - The documentation does not mention that only 32 bit access is allowed.
    - Writes are already executed using the actual size
    - Extensive testing shows that 8b, 16b and 32b reads work as intended
    
    Allow read access of any size by replacing pci_generic_config_read32()
    with the pci_generic_config_read() accessors.
    
    Fixes: 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
    [lorenzo.pieralisi@arm.com: updated commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    CC: Krzysztof Halasa <khalasa@piap.pl>
    CC: Olof Johansson <olof@lixom.net>
    CC: Robin Leblon <robin.leblon@ncentric.com>
    CC: Rob Herring <robh@kernel.org>
    CC: Russell King <linux@armlinux.org.uk>
    CC: Tim Harvey <tharvey@gateworks.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 5e11ad3164e0..95a11d5b3587 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -93,7 +93,7 @@ static int cns3xxx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
 	u32 mask = (0x1ull << (size * 8)) - 1;
 	int shift = (where % 4) * 8;
 
-	ret = pci_generic_config_read32(bus, devfn, where, size, val);
+	ret = pci_generic_config_read(bus, devfn, where, size, val);
 
 	if (ret == PCIBIOS_SUCCESSFUL && !bus->number && !devfn &&
 	    (where & 0xffc) == PCI_CLASS_REVISION)

commit 65dbb423cf28232fed1732b779249d6164c5999b
Author: Koen Vandeputte <koen.vandeputte@ncentric.com>
Date:   Thu Jan 31 15:00:01 2019 -0600

    ARM: cns3xxx: Fix writing to wrong PCI config registers after alignment
    
    Originally, cns3xxx used its own functions for mapping, reading and
    writing config registers.
    
    Commit 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config
    accessors") removed the internal PCI config write function in favor of
    the generic one:
    
      cns3xxx_pci_write_config() --> pci_generic_config_write()
    
    cns3xxx_pci_write_config() expected aligned addresses, being produced by
    cns3xxx_pci_map_bus() while the generic one pci_generic_config_write()
    actually expects the real address as both the function and hardware are
    capable of byte-aligned writes.
    
    This currently leads to pci_generic_config_write() writing to the wrong
    registers.
    
    For instance, upon ath9k module loading:
    
    - driver ath9k gets loaded
    - The driver wants to write value 0xA8 to register PCI_LATENCY_TIMER,
      located at 0x0D
    - cns3xxx_pci_map_bus() aligns the address to 0x0C
    - pci_generic_config_write() effectively writes 0xA8 into register 0x0C
      (CACHE_LINE_SIZE)
    
    Fix the bug by removing the alignment in the cns3xxx mapping function.
    
    Fixes: 802b7c06adc7 ("ARM: cns3xxx: Convert PCI to use generic config accessors")
    Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
    [lorenzo.pieralisi@arm.com: updated commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Acked-by: Tim Harvey <tharvey@gateworks.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    CC: stable@vger.kernel.org      # v4.0+
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Olof Johansson <olof@lixom.net>
    CC: Robin Leblon <robin.leblon@ncentric.com>
    CC: Rob Herring <robh@kernel.org>
    CC: Russell King <linux@armlinux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 318394ed5c7a..5e11ad3164e0 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -83,7 +83,7 @@ static void __iomem *cns3xxx_pci_map_bus(struct pci_bus *bus,
 	} else /* remote PCI bus */
 		base = cnspci->cfg1_regs + ((busno & 0xf) << 20);
 
-	return base + (where & 0xffc) + (devfn << 12);
+	return base + where + (devfn << 12);
 }
 
 static int cns3xxx_pci_read_config(struct pci_bus *bus, unsigned int devfn,

commit 88e9da9a2a70b6f1a171fbf30a681d6bc4031c4d
Author: Krzysztof Halasa <khalasa@piap.pl>
Date:   Fri Mar 11 12:32:14 2016 +0100

    CNS3xxx: Fix PCI cns3xxx_write_config()
    
    The "where" offset was added twice, fix it.
    
    Signed-off-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    Fixes: 498a92d42596 ("ARM: cns3xxx: pci: avoid potential stack overflow")
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 47905a50e075..318394ed5c7a 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -220,13 +220,13 @@ static void cns3xxx_write_config(struct cns3xxx_pcie *cnspci,
 	u32 mask = (0x1ull << (size * 8)) - 1;
 	int shift = (where % 4) * 8;
 
-	v = readl_relaxed(base + (where & 0xffc));
+	v = readl_relaxed(base);
 
 	v &= ~(mask << shift);
 	v |= (val & mask) << shift;
 
-	writel_relaxed(v, base + (where & 0xffc));
-	readl_relaxed(base + (where & 0xffc));
+	writel_relaxed(v, base);
+	readl_relaxed(base);
 }
 
 static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)

commit 498a92d42596a7a32c042319eb62a4c3d8081cf1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Oct 7 22:05:49 2015 +0200

    ARM: cns3xxx: pci: avoid potential stack overflow
    
    The cns3xxx_pcie_hw_init function uses excessive kernel
    stack space because of a hack that puts a fake struct
    pci_sys_data and struct pci_bus on the stack in order to
    call the generic pci_bus_read_config accessors, which causes
    a warning in ARM allmodconfig builds:
    
    arch/arm/mach-cns3xxx/pcie.c:266:1: warning: the frame size of 1080 bytes is larger than 1024 bytes
    
    I've spent a few hours trying to find out what exactly this
    code is wants to achieve here. The obvious part is setting
    up the host_regs using config space accessors, and this can
    simply be changed to use direct MMIO accesses, as I do
    in this patch.
    
    The second part is how the driver sets up the Max_Read_Request_Size
    value for the first device/function on bus 1, i.e. the device
    plugged directly into the PCIe root port.
    For all I can tell, this is in fact incomplete, as it does not
    perform the same setting on devices attached to a PCIe switch,
    or multi-function devices.
    The solution for this part fortunately is even easier: if we
    just set the global pcie_bus_config variable to PCIE_BUS_PEER2PEER,
    all PCIe devices in the system are limited to 128 byte MPS, which
    in turn limits the MRRS to 128 bytes for all devices, and we
    no longer even need to touch any devices.
    
    With those two changes in place, we no longer need the fake
    pci_sys_data/pci_bus structures for faking config space writes,
    and the stack usage goes down as well.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index c622c306c390..47905a50e075 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -65,8 +65,9 @@ static void __iomem *cns3xxx_pci_map_bus(struct pci_bus *bus,
 
 	/*
 	 * The CNS PCI bridge doesn't fit into the PCI hierarchy, though
-	 * we still want to access it. For this to work, we must place
-	 * the first device on the same bus as the CNS PCI bridge.
+	 * we still want to access it.
+	 * We place the host bridge on bus 0, and the directly connected
+	 * device on bus 1, slot 0.
 	 */
 	if (busno == 0) { /* internal PCIe bus, host bridge device */
 		if (devfn == 0) /* device# and function# are ignored by hw */
@@ -211,58 +212,46 @@ static void __init cns3xxx_pcie_check_link(struct cns3xxx_pcie *cnspci)
 	}
 }
 
+static void cns3xxx_write_config(struct cns3xxx_pcie *cnspci,
+					 int where, int size, u32 val)
+{
+	void __iomem *base = cnspci->host_regs + (where & 0xffc);
+	u32 v;
+	u32 mask = (0x1ull << (size * 8)) - 1;
+	int shift = (where % 4) * 8;
+
+	v = readl_relaxed(base + (where & 0xffc));
+
+	v &= ~(mask << shift);
+	v |= (val & mask) << shift;
+
+	writel_relaxed(v, base + (where & 0xffc));
+	readl_relaxed(base + (where & 0xffc));
+}
+
 static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 {
-	int port = cnspci->port;
-	struct pci_sys_data sd = {
-		.private_data = cnspci,
-	};
-	struct pci_bus bus = {
-		.number = 0,
-		.ops = &cns3xxx_pcie_ops,
-		.sysdata = &sd,
-	};
 	u16 mem_base  = cnspci->res_mem.start >> 16;
 	u16 mem_limit = cnspci->res_mem.end   >> 16;
 	u16 io_base   = cnspci->res_io.start  >> 16;
 	u16 io_limit  = cnspci->res_io.end    >> 16;
-	u32 devfn = 0;
-	u8 tmp8;
-	u16 pos;
-	u16 dc;
-
-	pci_bus_write_config_byte(&bus, devfn, PCI_PRIMARY_BUS, 0);
-	pci_bus_write_config_byte(&bus, devfn, PCI_SECONDARY_BUS, 1);
-	pci_bus_write_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, 1);
 
-	pci_bus_read_config_byte(&bus, devfn, PCI_PRIMARY_BUS, &tmp8);
-	pci_bus_read_config_byte(&bus, devfn, PCI_SECONDARY_BUS, &tmp8);
-	pci_bus_read_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, &tmp8);
-
-	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_BASE, mem_base);
-	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_LIMIT, mem_limit);
-	pci_bus_write_config_word(&bus, devfn, PCI_IO_BASE_UPPER16, io_base);
-	pci_bus_write_config_word(&bus, devfn, PCI_IO_LIMIT_UPPER16, io_limit);
+	cns3xxx_write_config(cnspci, PCI_PRIMARY_BUS, 1, 0);
+	cns3xxx_write_config(cnspci, PCI_SECONDARY_BUS, 1, 1);
+	cns3xxx_write_config(cnspci, PCI_SUBORDINATE_BUS, 1, 1);
+	cns3xxx_write_config(cnspci, PCI_MEMORY_BASE, 2, mem_base);
+	cns3xxx_write_config(cnspci, PCI_MEMORY_LIMIT, 2, mem_limit);
+	cns3xxx_write_config(cnspci, PCI_IO_BASE_UPPER16, 2, io_base);
+	cns3xxx_write_config(cnspci, PCI_IO_LIMIT_UPPER16, 2, io_limit);
 
 	if (!cnspci->linked)
 		return;
 
 	/* Set Device Max_Read_Request_Size to 128 byte */
-	bus.number = 1; /* directly connected PCIe device */
-	devfn = PCI_DEVFN(0, 0);
-	pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
-	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
-	if (dc & PCI_EXP_DEVCTL_READRQ) {
-		dc &= ~PCI_EXP_DEVCTL_READRQ;
-		pci_bus_write_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, dc);
-		pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
-		if (dc & PCI_EXP_DEVCTL_READRQ)
-			pr_warn("PCIe: Unable to set device Max_Read_Request_Size\n");
-		else
-			pr_info("PCIe: Max_Read_Request_Size set to 128 bytes\n");
-	}
+	pcie_bus_config = PCIE_BUS_PEER2PEER;
+
 	/* Disable PCIe0 Interrupt Mask INTA to INTD */
-	__raw_writel(~0x3FFF, MISC_PCIE_INT_MASK(port));
+	__raw_writel(~0x3FFF, MISC_PCIE_INT_MASK(cnspci->port));
 }
 
 static int cns3xxx_pcie_abort_handler(unsigned long addr, unsigned int fsr,

commit 2cd59deaefbc5fb88e6e232664377a02ca3122ed
Merge: 341f3a2bcfa2 029e2151fc4a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Feb 2 14:49:29 2015 -0600

    Merge branch 'pci/config' into next
    
    * pci/config:
      PCI: xilinx: Convert to use generic config accessors
      PCI: xgene: Convert to use generic config accessors
      PCI: tegra: Convert to use generic config accessors
      PCI: rcar: Convert to use generic config accessors
      PCI: generic: Convert to use generic config accessors
      powerpc/powermac: Convert PCI to use generic config accessors
      powerpc/fsl_pci: Convert PCI to use generic config accessors
      ARM: ks8695: Convert PCI to use generic config accessors
      ARM: sa1100: Convert PCI to use generic config accessors
      ARM: integrator: Convert PCI to use generic config accessors
      ARM: cns3xxx: Convert PCI to use generic config accessors
      PCI: Add generic config accessors
      powerpc/PCI: Add struct pci_ops member names to initialization
      mn10300/PCI: Add struct pci_ops member names to initialization
      MIPS: PCI: Add struct pci_ops member names to initialization
      frv/PCI: Add struct pci_ops member names to initialization

commit 802b7c06adc7186da59110ad136d88919fdb180b
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jan 9 20:34:40 2015 -0600

    ARM: cns3xxx: Convert PCI to use generic config accessors
    
    Convert the cns3xxx PCI driver to use the generic config access functions.
    
    This changes accesses from __raw_readl/__raw_writel to readl/writel.
    
    [arnd: remove extra open parenthesis]
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 45d6bd09e6ef..85fc72e875d2 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -54,8 +54,8 @@ static struct cns3xxx_pcie *pbus_to_cnspci(struct pci_bus *bus)
 	return sysdata_to_cnspci(bus->sysdata);
 }
 
-static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
-				  unsigned int devfn, int where)
+static void __iomem *cns3xxx_pci_map_bus(struct pci_bus *bus,
+					 unsigned int devfn, int where)
 {
 	struct cns3xxx_pcie *cnspci = pbus_to_cnspci(bus);
 	int busno = bus->number;
@@ -91,55 +91,22 @@ static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
 static int cns3xxx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
 				   int where, int size, u32 *val)
 {
-	u32 v;
-	void __iomem *base;
+	int ret;
 	u32 mask = (0x1ull << (size * 8)) - 1;
 	int shift = (where % 4) * 8;
 
-	base = cns3xxx_pci_cfg_base(bus, devfn, where);
-	if (!base) {
-		*val = 0xffffffff;
-		return PCIBIOS_SUCCESSFUL;
-	}
-
-	v = __raw_readl(base);
+	ret = pci_generic_config_read32(bus, devfn, where, size, val);
 
-	if (bus->number == 0 && devfn == 0 &&
-			(where & 0xffc) == PCI_CLASS_REVISION) {
+	if (ret == PCIBIOS_SUCCESSFUL && !bus->number && !devfn &&
+	    (where & 0xffc) == PCI_CLASS_REVISION)
 		/*
 		 * RC's class is 0xb, but Linux PCI driver needs 0x604
 		 * for a PCIe bridge. So we must fixup the class code
 		 * to 0x604 here.
 		 */
-		v &= 0xff;
-		v |= 0x604 << 16;
-	}
-
-	*val = (v >> shift) & mask;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int cns3xxx_pci_write_config(struct pci_bus *bus, unsigned int devfn,
-				    int where, int size, u32 val)
-{
-	u32 v;
-	void __iomem *base;
-	u32 mask = (0x1ull << (size * 8)) - 1;
-	int shift = (where % 4) * 8;
-
-	base = cns3xxx_pci_cfg_base(bus, devfn, where);
-	if (!base)
-		return PCIBIOS_SUCCESSFUL;
-
-	v = __raw_readl(base);
-
-	v &= ~(mask << shift);
-	v |= (val & mask) << shift;
-
-	__raw_writel(v, base);
+		*val = ((((*val << shift) & 0xff) | (0x604 << 16)) >> shift) & mask;
 
-	return PCIBIOS_SUCCESSFUL;
+	return ret;
 }
 
 static int cns3xxx_pci_setup(int nr, struct pci_sys_data *sys)
@@ -158,8 +125,9 @@ static int cns3xxx_pci_setup(int nr, struct pci_sys_data *sys)
 }
 
 static struct pci_ops cns3xxx_pcie_ops = {
+	.map_bus = cns3xxx_pci_map_bus,
 	.read = cns3xxx_pci_read_config,
-	.write = cns3xxx_pci_write_config,
+	.write = pci_generic_config_write,
 };
 
 static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)

commit c88d54ba0c3d89b925bfb8e98b13a3f55b55cde4
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Nov 21 11:29:25 2014 +0000

    CNS3xxx: Remove artificial dependency on pci_sys_data domain.
    
    On cns3xxx platforms the PCI controller probing code relies on an
    artificial dependency on the domain number to look-up the internal data
    structures.
    
    This patch reworks the host controller control data structure and adds a
    domain equivalent field named port in it so that the dependency on
    pci_sys_data domain field can be eventually removed.
    
    Acked-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [lp: added commit log, removed pci_sys_data domain references]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 45d6bd09e6ef..f6bf9f623d70 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -30,18 +30,15 @@ struct cns3xxx_pcie {
 	unsigned int irqs[2];
 	struct resource res_io;
 	struct resource res_mem;
-	struct hw_pci hw_pci;
-
+	int port;
 	bool linked;
 };
 
-static struct cns3xxx_pcie cns3xxx_pcie[]; /* forward decl. */
-
 static struct cns3xxx_pcie *sysdata_to_cnspci(void *sysdata)
 {
 	struct pci_sys_data *root = sysdata;
 
-	return &cns3xxx_pcie[root->domain];
+	return root->private_data;
 }
 
 static struct cns3xxx_pcie *pdev_to_cnspci(const struct pci_dev *dev)
@@ -192,13 +189,7 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 			.flags = IORESOURCE_MEM,
 		},
 		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
-		.hw_pci = {
-			.domain = 0,
-			.nr_controllers = 1,
-			.ops = &cns3xxx_pcie_ops,
-			.setup = cns3xxx_pci_setup,
-			.map_irq = cns3xxx_pcie_map_irq,
-		},
+		.port = 0,
 	},
 	[1] = {
 		.host_regs = (void __iomem *)CNS3XXX_PCIE1_HOST_BASE_VIRT,
@@ -217,19 +208,13 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 			.flags = IORESOURCE_MEM,
 		},
 		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
-		.hw_pci = {
-			.domain = 1,
-			.nr_controllers = 1,
-			.ops = &cns3xxx_pcie_ops,
-			.setup = cns3xxx_pci_setup,
-			.map_irq = cns3xxx_pcie_map_irq,
-		},
+		.port = 1,
 	},
 };
 
 static void __init cns3xxx_pcie_check_link(struct cns3xxx_pcie *cnspci)
 {
-	int port = cnspci->hw_pci.domain;
+	int port = cnspci->port;
 	u32 reg;
 	unsigned long time;
 
@@ -260,9 +245,9 @@ static void __init cns3xxx_pcie_check_link(struct cns3xxx_pcie *cnspci)
 
 static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 {
-	int port = cnspci->hw_pci.domain;
+	int port = cnspci->port;
 	struct pci_sys_data sd = {
-		.domain = port,
+		.private_data = cnspci,
 	};
 	struct pci_bus bus = {
 		.number = 0,
@@ -323,6 +308,14 @@ static int cns3xxx_pcie_abort_handler(unsigned long addr, unsigned int fsr,
 void __init cns3xxx_pcie_init_late(void)
 {
 	int i;
+	void *private_data;
+	struct hw_pci hw_pci = {
+	       .nr_controllers = 1,
+	       .ops = &cns3xxx_pcie_ops,
+	       .setup = cns3xxx_pci_setup,
+	       .map_irq = cns3xxx_pcie_map_irq,
+	       .private_data = &private_data,
+	};
 
 	pcibios_min_io = 0;
 	pcibios_min_mem = 0;
@@ -335,7 +328,8 @@ void __init cns3xxx_pcie_init_late(void)
 		cns3xxx_pwr_soft_rst(0x1 << PM_SOFT_RST_REG_OFFST_PCIE(i));
 		cns3xxx_pcie_check_link(&cns3xxx_pcie[i]);
 		cns3xxx_pcie_hw_init(&cns3xxx_pcie[i]);
-		pci_common_init(&cns3xxx_pcie[i].hw_pci);
+		private_data = &cns3xxx_pcie[i];
+		pci_common_init(&hw_pci);
 	}
 
 	pci_assign_unassigned_resources();

commit 367dc4b75f4349d5363bc3ebdc030939db944786
Author: Krzysztof Ha≈Çasa <khalasa@piap.pl>
Date:   Tue Sep 16 12:37:16 2014 +0200

    CNS3xxx: Fix PCIe read size limit.
    
    Max_Read_Request_Size is 3 bits wide, not 2 bits.
    Also fix the message.
    
    Signed-off-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index fbfe852286e8..45d6bd09e6ef 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -299,12 +299,15 @@ static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 	devfn = PCI_DEVFN(0, 0);
 	pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
 	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
-	dc &= ~(0x3 << 12);	/* Clear Device Control Register [14:12] */
-	pci_bus_write_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, dc);
-	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
-	if (!(dc & (0x3 << 12)))
-		pr_info("PCIe: Set Device Max_Read_Request_Size to 128 byte\n");
-
+	if (dc & PCI_EXP_DEVCTL_READRQ) {
+		dc &= ~PCI_EXP_DEVCTL_READRQ;
+		pci_bus_write_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, dc);
+		pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
+		if (dc & PCI_EXP_DEVCTL_READRQ)
+			pr_warn("PCIe: Unable to set device Max_Read_Request_Size\n");
+		else
+			pr_info("PCIe: Max_Read_Request_Size set to 128 bytes\n");
+	}
 	/* Disable PCIe0 Interrupt Mask INTA to INTD */
 	__raw_writel(~0x3FFF, MISC_PCIE_INT_MASK(port));
 }

commit defaa4d1dc97320ccc0ea83bc3851443b1c9083a
Author: Krzysztof Ha≈Çasa <khalasa@piap.pl>
Date:   Tue Sep 16 12:36:32 2014 +0200

    CNS3xxx: Fix logical PCIe topology.
    
    Without this patch, each root port and the device connected directly to it seem
    to be located on a shared (virtual) bus #0. It creates problems with enabling
    devices (the PCI code doesn't know that the root bridge must be enabled in order
    to access other devices).
    The PCIe topology shown by lspci doesn't reflect reality, e.g.:
    
    0000:00:00.0 PCI bridge: Cavium Networks Device 3400
    0000:00:01.0 PCI bridge: Texas Instruments XIO2001 PCI Express-to-PCI Bridge
    0000:02:...
    0001:00:00.0 PCI bridge: Cavium Networks Device 3400 (for the second lane/bus)
    
    -+-[0001:00]---00.0-[01]--
     \-[0000:00]-+-00.0-[01]--
                 | ^^^^ root bridge
                 \-01.0-[02]----...
                   ^^^^ first external device
    
    With this patch, the first external PCIe device is connected to bus #1
    (behind the root bridge).
    
    -+-[0001:00]---00.0-[01]--
     \-[0000:00]---00.0-[01-02]----------00.0-[02]----...
                   ^^^^ root bridge      ^^^^ first external device
    
    Signed-off-by: Krzysztof Ha≈Çasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 70fd81ea1828..fbfe852286e8 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -60,11 +60,10 @@ static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
 	struct cns3xxx_pcie *cnspci = pbus_to_cnspci(bus);
 	int busno = bus->number;
 	int slot = PCI_SLOT(devfn);
-	int offset;
 	void __iomem *base;
 
 	/* If there is no link, just show the CNS PCI bridge. */
-	if (!cnspci->linked && (busno > 0 || slot > 0))
+	if (!cnspci->linked && busno > 0)
 		return NULL;
 
 	/*
@@ -72,22 +71,21 @@ static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
 	 * we still want to access it. For this to work, we must place
 	 * the first device on the same bus as the CNS PCI bridge.
 	 */
-	if (busno == 0) { /* directly connected PCIe bus */
-		switch (slot) {
-		case 0: /* host bridge device, function 0 only */
+	if (busno == 0) { /* internal PCIe bus, host bridge device */
+		if (devfn == 0) /* device# and function# are ignored by hw */
 			base = cnspci->host_regs;
-			break;
-		case 1: /* directly connected device */
+		else
+			return NULL; /* no such device */
+
+	} else if (busno == 1) { /* directly connected PCIe device */
+		if (slot == 0) /* device# is ignored by hw */
 			base = cnspci->cfg0_regs;
-			break;
-		default:
+		else
 			return NULL; /* no such device */
-		}
 	} else /* remote PCI bus */
-		base = cnspci->cfg1_regs;
+		base = cnspci->cfg1_regs + ((busno & 0xf) << 20);
 
-	offset = ((busno & 0xf) << 20) | (devfn << 12) | (where & 0xffc);
-	return base + offset;
+	return base + (where & 0xffc) + (devfn << 12);
 }
 
 static int cns3xxx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
@@ -167,7 +165,7 @@ static struct pci_ops cns3xxx_pcie_ops = {
 static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
-	int irq = cnspci->irqs[slot];
+	int irq = cnspci->irqs[!!dev->bus->number];
 
 	pr_info("PCIe map irq: %04d:%02x:%02x.%02x slot %d, pin %d, irq: %d\n",
 		pci_domain_nr(dev->bus), dev->bus->number, PCI_SLOT(dev->devfn),
@@ -297,7 +295,8 @@ static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 		return;
 
 	/* Set Device Max_Read_Request_Size to 128 byte */
-	devfn = PCI_DEVFN(1, 0);
+	bus.number = 1; /* directly connected PCIe device */
+	devfn = PCI_DEVFN(0, 0);
 	pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
 	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
 	dc &= ~(0x3 << 12);	/* Clear Device Control Register [14:12] */

commit 0a2e912d296201c476fe5d7ba6ac23a66325935f
Author: Xia Kaixu <kaixu.xia@linaro.org>
Date:   Wed Sep 3 21:18:12 2014 +0800

    ARM: cns3xxx: fix allmodconfig panic in pci driver
    
    The kernel panic occurs when running an allmodconfig kernel on
    OMAP4460. The inicall "cns3xxx_pcie_init" does not check which
    hardware it's running on and just tries to access to its specific
    registers. Now call it from .init_late callback from the two
    machine descriptors.
    
    Signed-off-by: Xia Kaixu <kaixu.xia@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Felix Fietkau <nbd@openwrt.org>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 413134c54452..70fd81ea1828 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -318,7 +318,7 @@ static int cns3xxx_pcie_abort_handler(unsigned long addr, unsigned int fsr,
 	return 0;
 }
 
-static int __init cns3xxx_pcie_init(void)
+void __init cns3xxx_pcie_init_late(void)
 {
 	int i;
 
@@ -337,7 +337,4 @@ static int __init cns3xxx_pcie_init(void)
 	}
 
 	pci_assign_unassigned_resources();
-
-	return 0;
 }
-device_initcall(cns3xxx_pcie_init);

commit 64cf9d07ef1f5ed6abc6ed8a2420eb2849f7f444
Author: Krzysztof Ha≈Çasa <khalasa@piap.pl>
Date:   Tue Mar 4 08:37:10 2014 +0100

    CNS3xxx: Fix PCIe early iotable_init().
    
    This patch fixes the following BUG:
    
    > kernel BUG at mm/vmalloc.c:1132!
    > PC is at vm_area_add_early+0x20/0x84
    > LR is at add_static_vm_early+0xc/0x60
    >
    > The problem is cns3xxx_pcie_init() (device_initcall) calls the "early"
    > iotable_init().
    
    Instead of merely calling the PCIe iotable_init() from
    machine_desc->map_io(), this patch adds the required mappings to the
    main CNS3xxx mapping table. This means we don't convert .pfn back to
    virtual addresses in pcie.c. The size of the address space consumed for
    PCIe control is reduced from 96 MiB (6 * 16 MiB) to about 32 MiB (this
    doesn't include MMIO address space required by PCI devices):
    
    - Size of the PCIe "host" mapping is reduced from 16 MiB to 4 KiB.
      It's a PCI configuration address space for the local (on-chip) PCIe
      bridge.
    
    - Size of the "CFG0" mapping is reduced from 16 MiB to 64 KiB. It's for
      Type 0 Configuration accesses, i.e., accesses to the single device
      (with possible "functions") on the other end of the PCIe link.
      We really only need a 4 KiB page at 0x8000 (see the offset
      calculation in cns3xxx_pci_cfg_base()). There is still a potential
      problem with PCI bus numbers > 0xF, are they supported?
    
    - The code in cns3xxx_pci_cfg_base() and cns3xxx_pcie_hw_init() should
      be clearer now.
    
    - The maximum address space allocated for PCI MMIO is now correctly
      shown in /proc/iomem as 176 MiB (per each of the two PCI "domains"
      - previously only 16 MiB were reserved).
    
    This patch has been tested on Gateworks Laguna board, masqueraded as
    CNS3420VB.
    
    Signed-off-by: Krzysztof Ha?asa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index c7b204bff386..413134c54452 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -23,15 +23,10 @@
 #include "cns3xxx.h"
 #include "core.h"
 
-enum cns3xxx_access_type {
-	CNS3XXX_HOST_TYPE = 0,
-	CNS3XXX_CFG0_TYPE,
-	CNS3XXX_CFG1_TYPE,
-	CNS3XXX_NUM_ACCESS_TYPES,
-};
-
 struct cns3xxx_pcie {
-	struct map_desc cfg_bases[CNS3XXX_NUM_ACCESS_TYPES];
+	void __iomem *host_regs; /* PCI config registers for host bridge */
+	void __iomem *cfg0_regs; /* PCI Type 0 config registers */
+	void __iomem *cfg1_regs; /* PCI Type 1 config registers */
 	unsigned int irqs[2];
 	struct resource res_io;
 	struct resource res_mem;
@@ -66,7 +61,6 @@ static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
 	int busno = bus->number;
 	int slot = PCI_SLOT(devfn);
 	int offset;
-	enum cns3xxx_access_type type;
 	void __iomem *base;
 
 	/* If there is no link, just show the CNS PCI bridge. */
@@ -78,17 +72,21 @@ static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
 	 * we still want to access it. For this to work, we must place
 	 * the first device on the same bus as the CNS PCI bridge.
 	 */
-	if (busno == 0) {
-		if (slot > 1)
-			return NULL;
-		type = slot;
-	} else {
-		type = CNS3XXX_CFG1_TYPE;
-	}
+	if (busno == 0) { /* directly connected PCIe bus */
+		switch (slot) {
+		case 0: /* host bridge device, function 0 only */
+			base = cnspci->host_regs;
+			break;
+		case 1: /* directly connected device */
+			base = cnspci->cfg0_regs;
+			break;
+		default:
+			return NULL; /* no such device */
+		}
+	} else /* remote PCI bus */
+		base = cnspci->cfg1_regs;
 
-	base = (void __iomem *)cnspci->cfg_bases[type].virtual;
 	offset = ((busno & 0xf) << 20) | (devfn << 12) | (where & 0xffc);
-
 	return base + offset;
 }
 
@@ -180,36 +178,19 @@ static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 
 static struct cns3xxx_pcie cns3xxx_pcie[] = {
 	[0] = {
-		.cfg_bases = {
-			[CNS3XXX_HOST_TYPE] = {
-				.virtual = CNS3XXX_PCIE0_HOST_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_HOST_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-			[CNS3XXX_CFG0_TYPE] = {
-				.virtual = CNS3XXX_PCIE0_CFG0_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_CFG0_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-			[CNS3XXX_CFG1_TYPE] = {
-				.virtual = CNS3XXX_PCIE0_CFG1_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_CFG1_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-		},
+		.host_regs = (void __iomem *)CNS3XXX_PCIE0_HOST_BASE_VIRT,
+		.cfg0_regs = (void __iomem *)CNS3XXX_PCIE0_CFG0_BASE_VIRT,
+		.cfg1_regs = (void __iomem *)CNS3XXX_PCIE0_CFG1_BASE_VIRT,
 		.res_io = {
 			.name = "PCIe0 I/O space",
 			.start = CNS3XXX_PCIE0_IO_BASE,
-			.end = CNS3XXX_PCIE0_IO_BASE + SZ_16M - 1,
+			.end = CNS3XXX_PCIE0_CFG0_BASE - 1, /* 16 MiB */
 			.flags = IORESOURCE_IO,
 		},
 		.res_mem = {
 			.name = "PCIe0 non-prefetchable",
 			.start = CNS3XXX_PCIE0_MEM_BASE,
-			.end = CNS3XXX_PCIE0_MEM_BASE + SZ_16M - 1,
+			.end = CNS3XXX_PCIE0_HOST_BASE - 1, /* 176 MiB */
 			.flags = IORESOURCE_MEM,
 		},
 		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
@@ -222,36 +203,19 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 		},
 	},
 	[1] = {
-		.cfg_bases = {
-			[CNS3XXX_HOST_TYPE] = {
-				.virtual = CNS3XXX_PCIE1_HOST_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_HOST_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-			[CNS3XXX_CFG0_TYPE] = {
-				.virtual = CNS3XXX_PCIE1_CFG0_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_CFG0_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-			[CNS3XXX_CFG1_TYPE] = {
-				.virtual = CNS3XXX_PCIE1_CFG1_BASE_VIRT,
-				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_CFG1_BASE),
-				.length = SZ_16M,
-				.type = MT_DEVICE,
-			},
-		},
+		.host_regs = (void __iomem *)CNS3XXX_PCIE1_HOST_BASE_VIRT,
+		.cfg0_regs = (void __iomem *)CNS3XXX_PCIE1_CFG0_BASE_VIRT,
+		.cfg1_regs = (void __iomem *)CNS3XXX_PCIE1_CFG1_BASE_VIRT,
 		.res_io = {
 			.name = "PCIe1 I/O space",
 			.start = CNS3XXX_PCIE1_IO_BASE,
-			.end = CNS3XXX_PCIE1_IO_BASE + SZ_16M - 1,
+			.end = CNS3XXX_PCIE1_CFG0_BASE - 1, /* 16 MiB */
 			.flags = IORESOURCE_IO,
 		},
 		.res_mem = {
 			.name = "PCIe1 non-prefetchable",
 			.start = CNS3XXX_PCIE1_MEM_BASE,
-			.end = CNS3XXX_PCIE1_MEM_BASE + SZ_16M - 1,
+			.end = CNS3XXX_PCIE1_HOST_BASE - 1, /* 176 MiB */
 			.flags = IORESOURCE_MEM,
 		},
 		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
@@ -307,18 +271,15 @@ static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 		.ops = &cns3xxx_pcie_ops,
 		.sysdata = &sd,
 	};
-	u32 io_base = cnspci->res_io.start >> 16;
-	u32 mem_base = cnspci->res_mem.start >> 16;
-	u32 host_base = cnspci->cfg_bases[CNS3XXX_HOST_TYPE].pfn;
-	u32 cfg0_base = cnspci->cfg_bases[CNS3XXX_CFG0_TYPE].pfn;
+	u16 mem_base  = cnspci->res_mem.start >> 16;
+	u16 mem_limit = cnspci->res_mem.end   >> 16;
+	u16 io_base   = cnspci->res_io.start  >> 16;
+	u16 io_limit  = cnspci->res_io.end    >> 16;
 	u32 devfn = 0;
 	u8 tmp8;
 	u16 pos;
 	u16 dc;
 
-	host_base = (__pfn_to_phys(host_base) - 1) >> 16;
-	cfg0_base = (__pfn_to_phys(cfg0_base) - 1) >> 16;
-
 	pci_bus_write_config_byte(&bus, devfn, PCI_PRIMARY_BUS, 0);
 	pci_bus_write_config_byte(&bus, devfn, PCI_SECONDARY_BUS, 1);
 	pci_bus_write_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, 1);
@@ -328,9 +289,9 @@ static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
 	pci_bus_read_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, &tmp8);
 
 	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_BASE, mem_base);
-	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_LIMIT, host_base);
+	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_LIMIT, mem_limit);
 	pci_bus_write_config_word(&bus, devfn, PCI_IO_BASE_UPPER16, io_base);
-	pci_bus_write_config_word(&bus, devfn, PCI_IO_LIMIT_UPPER16, cfg0_base);
+	pci_bus_write_config_word(&bus, devfn, PCI_IO_LIMIT_UPPER16, io_limit);
 
 	if (!cnspci->linked)
 		return;
@@ -368,8 +329,6 @@ static int __init cns3xxx_pcie_init(void)
 			"imprecise external abort");
 
 	for (i = 0; i < ARRAY_SIZE(cns3xxx_pcie); i++) {
-		iotable_init(cns3xxx_pcie[i].cfg_bases,
-			     ARRAY_SIZE(cns3xxx_pcie[i].cfg_bases));
 		cns3xxx_pwr_clk_en(0x1 << PM_CLK_GATE_REG_OFFSET_PCIE(i));
 		cns3xxx_pwr_soft_rst(0x1 << PM_SOFT_RST_REG_OFFST_PCIE(i));
 		cns3xxx_pcie_check_link(&cns3xxx_pcie[i]);

commit 3f9fb2a08f55c79b4c6cde423c1e8ddcc5a49781
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 13 13:15:25 2013 +0100

    ARM: cns3xxx: make mach header files local
    
    The mach/cns3xxx.h and mach/pm.h header files are used only
    in the platform code itself, so there is no need to make
    them globally visible. This gets us closer to multiplatform
    configuration for cns3xxx.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 311328314163..c7b204bff386 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -20,7 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/ptrace.h>
 #include <asm/mach/map.h>
-#include <mach/cns3xxx.h>
+#include "cns3xxx.h"
 #include "core.h"
 
 enum cns3xxx_access_type {

commit c23bfc3835173f5229b2503e3b616001a28affad
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 12:49:16 2012 +0000

    ARM: PCI: provide a default bus scan implementation
    
    Most PCI implementations perform simple root bus scanning.  Rather than
    having each group of platforms provide a duplicated bus scan function,
    provide the PCI configuration ops structure via the hw_pci structure,
    and call the root bus scanning function from core ARM PCI code.
    
    Acked-by: Krzysztof Ha≈Çasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 62f861bef243..311328314163 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -166,12 +166,6 @@ static struct pci_ops cns3xxx_pcie_ops = {
 	.write = cns3xxx_pci_write_config,
 };
 
-static struct pci_bus *cns3xxx_pci_scan_bus(int nr, struct pci_sys_data *sys)
-{
-	return pci_scan_root_bus(NULL, sys->busnr, &cns3xxx_pcie_ops, sys,
-				 &sys->resources);
-}
-
 static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
@@ -222,8 +216,8 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 		.hw_pci = {
 			.domain = 0,
 			.nr_controllers = 1,
+			.ops = &cns3xxx_pcie_ops,
 			.setup = cns3xxx_pci_setup,
-			.scan = cns3xxx_pci_scan_bus,
 			.map_irq = cns3xxx_pcie_map_irq,
 		},
 	},
@@ -264,8 +258,8 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 		.hw_pci = {
 			.domain = 1,
 			.nr_controllers = 1,
+			.ops = &cns3xxx_pcie_ops,
 			.setup = cns3xxx_pci_setup,
-			.scan = cns3xxx_pci_scan_bus,
 			.map_irq = cns3xxx_pcie_map_irq,
 		},
 	},

commit daeb4c0c3bf2df72d0cd6e4330bad9e2e520552b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 11:39:33 2012 +0000

    ARM: PCI: get rid of pci_std_swizzle()
    
    Most PCI implementations use the standard PCI swizzle function, which
    handles the well defined behaviour of PCI-to-PCI bridges which can be
    found on cards (eg, four port ethernet cards.)
    
    Rather than having almost every platform specify the standard swizzle
    function, make this the default when no swizzle function is supplied.
    Therefore, a swizzle function only needs to be provided when there is
    something exceptional which needs to be handled.
    
    This gets rid of the swizzle initializer from 47 files, and leaves us
    with just two platforms specifying a swizzle function: ARM Integrator
    and Chalice CATS.
    
    Acked-by: Krzysztof Ha≈Çasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 79d001f831e0..62f861bef243 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -221,7 +221,6 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
 		.hw_pci = {
 			.domain = 0,
-			.swizzle = pci_std_swizzle,
 			.nr_controllers = 1,
 			.setup = cns3xxx_pci_setup,
 			.scan = cns3xxx_pci_scan_bus,
@@ -264,7 +263,6 @@ static struct cns3xxx_pcie cns3xxx_pcie[] = {
 		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
 		.hw_pci = {
 			.domain = 1,
-			.swizzle = pci_std_swizzle,
 			.nr_controllers = 1,
 			.setup = cns3xxx_pci_setup,
 			.scan = cns3xxx_pci_scan_bus,

commit 9f786d033d025ab7d2c4d1b959aa81d935eb9e19
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:01 2012 -0700

    arm/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index e159d69967c9..79d001f831e0 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -155,8 +155,8 @@ static int cns3xxx_pci_setup(int nr, struct pci_sys_data *sys)
 	BUG_ON(request_resource(&iomem_resource, res_io) ||
 	       request_resource(&iomem_resource, res_mem));
 
-	pci_add_resource(&sys->resources, res_io);
-	pci_add_resource(&sys->resources, res_mem);
+	pci_add_resource_offset(&sys->resources, res_io, sys->io_offset);
+	pci_add_resource_offset(&sys->resources, res_mem, sys->mem_offset);
 
 	return 1;
 }

commit 37d15909ff6bf6e97e1d4447efa7f1a19e7a508e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:16 2011 -0600

    arm/PCI: convert to pci_scan_root_bus() for correct root bus resources
    
    Convert from pci_scan_bus() to pci_scan_root_bus() and remove root bus
    resource fixups.  This fixes the problem of "early" and "header" quirks
    seeing incorrect root bus resources.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 0f8fca48a5ed..e159d69967c9 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -151,13 +151,12 @@ static int cns3xxx_pci_setup(int nr, struct pci_sys_data *sys)
 	struct cns3xxx_pcie *cnspci = sysdata_to_cnspci(sys);
 	struct resource *res_io = &cnspci->res_io;
 	struct resource *res_mem = &cnspci->res_mem;
-	struct resource **sysres = sys->resource;
 
 	BUG_ON(request_resource(&iomem_resource, res_io) ||
 	       request_resource(&iomem_resource, res_mem));
 
-	sysres[0] = res_io;
-	sysres[1] = res_mem;
+	pci_add_resource(&sys->resources, res_io);
+	pci_add_resource(&sys->resources, res_mem);
 
 	return 1;
 }
@@ -169,7 +168,8 @@ static struct pci_ops cns3xxx_pcie_ops = {
 
 static struct pci_bus *cns3xxx_pci_scan_bus(int nr, struct pci_sys_data *sys)
 {
-	return pci_scan_bus(sys->busnr, &cns3xxx_pcie_ops, sys);
+	return pci_scan_root_bus(NULL, sys->busnr, &cns3xxx_pcie_ops, sys,
+				 &sys->resources);
 }
 
 static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)

commit 7caaf7efb98a4f713e4c8b16289e03874aace493
Author: Anton Vorontsov <cbouatmailru@gmail.com>
Date:   Fri Sep 9 23:18:00 2011 +0400

    ARM: cns3xxx: Fix newly introduced warnings in the PCIe code
    
    commit d5341942d784134f2997b3ff82cd63cf71d1f932 ("PCI: Make the struct
    pci_dev * argument of pci_fixup_irqs const") did not change argument
    of pdev_to_cnspci(), and thus introduced the following warnings:
    
      CHECK   arch/arm/mach-cns3xxx/pcie.c
    pcie.c:177:60: warning: incorrect type in argument 1 (different modifiers)
    pcie.c:177:60:    expected struct pci_dev *dev
    pcie.c:177:60:    got struct pci_dev const *dev
      CC      arch/arm/mach-cns3xxx/pcie.o
    pcie.c: In function 'cns3xxx_pcie_map_irq':
    pcie.c:177: warning: passing argument 1 of 'pdev_to_cnspci' discards qualifiers from pointer target type
    pcie.c:52: note: expected 'struct pci_dev *' but argument is of type 'const struct pci_dev *'
    
    This patch fixes the issue.
    
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 06fd25d70aec..0f8fca48a5ed 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -49,7 +49,7 @@ static struct cns3xxx_pcie *sysdata_to_cnspci(void *sysdata)
 	return &cns3xxx_pcie[root->domain];
 }
 
-static struct cns3xxx_pcie *pdev_to_cnspci(struct pci_dev *dev)
+static struct cns3xxx_pcie *pdev_to_cnspci(const struct pci_dev *dev)
 {
 	return sysdata_to_cnspci(dev->sysdata);
 }

commit f85f19de90a9997583bb26e6f1f9297a4e152c18
Merge: b993fdbc7fe2 7b87c9df5602
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 23:35:05 2011 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI: remove printks about disabled bridge windows
      PCI: fold pci_calc_resource_flags() into decode_bar()
      PCI: treat mem BAR type "11" (reserved) as 32-bit, not 64-bit, BAR
      PCI: correct pcie_set_readrq write size
      PCI: pciehp: change wait time for valid configuration access
      x86/PCI: Preserve existing pci=bfsort whitelist for Dell systems
      PCI: ARI is a PCIe v2 feature
      x86/PCI: quirks: Use pci_dev->revision
      PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
      PCI hotplug: cpqphp: use pci_dev->vendor
      PCI hotplug: cpqphp: use pci_dev->subsystem_{vendor|device}
      x86/PCI: config space accessor functions should not ignore the segment argument
      PCI: Assign values to 'pci_obff_signal_type' enumeration constants
      x86/PCI: reduce severity of host bridge window conflict warnings
      PCI: enumerate the PCI device only removed out PCI hieratchy of OS when re-scanning PCI
      PCI: PCIe AER: add aer_recover_queue
      x86/PCI: select direct access mode for mmconfig option
      PCI hotplug: Rename is_ejectable which also exists in dock.c

commit d5341942d784134f2997b3ff82cd63cf71d1f932
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 10 15:30:21 2011 +0100

    PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
    
    Aside of the usual motivation for constification,  this function has a
    history of being abused a hook for interrupt and other fixups so I turned
    this function const ages ago in the MIPS code but it should be done
    treewide.
    
    Due to function pointer passing in varous places a few other functions
    had to be constified as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    To: Anton Vorontsov <avorontsov@mvista.com>
    To: Chris Metcalf <cmetcalf@tilera.com>
    To: Colin Cross <ccross@android.com>
    Acked-by: "David S. Miller" <davem@davemloft.net>
    To: Eric Miao <eric.y.miao@gmail.com>
    To: Erik Gilling <konkers@android.com>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: "H. Peter Anvin" <hpa@zytor.com>
    To: Imre Kaloz <kaloz@openwrt.org>
    To: Ingo Molnar <mingo@redhat.com>
    To: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    To: Jesse Barnes <jbarnes@virtuousgeek.org>
    To: Krzysztof Halasa <khc@pm.waw.pl>
    To: Lennert Buytenhek <kernel@wantstofly.org>
    To: Matt Turner <mattst88@gmail.com>
    To: Nicolas Pitre <nico@fluxnic.net>
    To: Olof Johansson <olof@lixom.net>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    To: Richard Henderson <rth@twiddle.net>
    To: Russell King <linux@arm.linux.org.uk>
    To: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 78defd71a829..725b94fe919a 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -172,7 +172,7 @@ static struct pci_bus *cns3xxx_pci_scan_bus(int nr, struct pci_sys_data *sys)
 	return pci_scan_bus(sys->busnr, &cns3xxx_pcie_ops, sys);
 }
 
-static int cns3xxx_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
 	int irq = cnspci->irqs[slot];

commit c9d95fbe59e426eed7f16e7cac812e46ac4772d0
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Jun 28 21:16:13 2011 -0500

    ARM: convert PCI defines to variables
    
    Convert PCIBIOS_MIN_IO and PCIBIOS_MIN_MEM to variables to allow
    multi-platform builds. This also removes the requirement for a platform to
    have a mach/hardware.h.
    
    The default values for i/o and mem are 0x1000 and 0x01000000, respectively.
    Per Arnd Bergmann, other values are likely to be incorrect, but this commit
    does not try to address that issue.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 78defd71a829..a4ec080908b8 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -369,6 +369,9 @@ static int __init cns3xxx_pcie_init(void)
 {
 	int i;
 
+	pcibios_min_io = 0;
+	pcibios_min_mem = 0;
+
 	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS, 0,
 			"imprecise external abort");
 

commit 44266416f786514ec43a0d15ad951c34566b99c9
Author: Anton Vorontsov <cbouatmailru@gmail.com>
Date:   Mon Nov 29 18:46:22 2010 +0300

    ARM: cns3xxx: Fix build with CONFIG_PCI=y
    
    commit 6338a6aa7c082f11d55712251e14178c68bf5869 ("ARM: 6269/1: Add 'code'
    parameter for hook_fault_code()") breaks CNS3xxx build:
    
      CC      arch/arm/mach-cns3xxx/pcie.o
    pcie.c: In function 'cns3xxx_pcie_init':
    pcie.c:373: warning: passing argument 4 of 'hook_fault_code' makes integer from pointer without a cast
    pcie.c:373: error: too few arguments to function 'hook_fault_code'
    
    This commit fixes the small issue.
    
    Cc: stable@kernel.org [36]
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
index 38088c36936c..78defd71a829 100644
--- a/arch/arm/mach-cns3xxx/pcie.c
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -369,7 +369,7 @@ static int __init cns3xxx_pcie_init(void)
 {
 	int i;
 
-	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS,
+	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS, 0,
 			"imprecise external abort");
 
 	for (i = 0; i < ARRAY_SIZE(cns3xxx_pcie); i++) {

commit 5f32f7a028c9e8e032132b1818bde6cda5785a6b
Author: Anton Vorontsov <avorontsov@mvista.com>
Date:   Fri May 28 13:10:52 2010 +0400

    ARM: cns3xxx: Add support for PCI Express ports
    
    This patch adds PCIe support for CNS3xxx-based boards. The support
    was tested with a directly attached SKY2 NIC, and EHCI USB controller
    behind the PLX PEX8112 P2P bridge (to make sure that type1 cfg cycles
    work as expected).
    
    Signed-off-by: Anton Vorontsov <avorontsov@mvista.com>

diff --git a/arch/arm/mach-cns3xxx/pcie.c b/arch/arm/mach-cns3xxx/pcie.c
new file mode 100644
index 000000000000..38088c36936c
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/pcie.c
@@ -0,0 +1,389 @@
+/*
+ * PCI-E support for CNS3xxx
+ *
+ * Copyright 2008 Cavium Networks
+ *		  Richard Liu <richard.liu@caviumnetworks.com>
+ * Copyright 2010 MontaVista Software, LLC.
+ *		  Anton Vorontsov <avorontsov@mvista.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bug.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <asm/mach/map.h>
+#include <mach/cns3xxx.h>
+#include "core.h"
+
+enum cns3xxx_access_type {
+	CNS3XXX_HOST_TYPE = 0,
+	CNS3XXX_CFG0_TYPE,
+	CNS3XXX_CFG1_TYPE,
+	CNS3XXX_NUM_ACCESS_TYPES,
+};
+
+struct cns3xxx_pcie {
+	struct map_desc cfg_bases[CNS3XXX_NUM_ACCESS_TYPES];
+	unsigned int irqs[2];
+	struct resource res_io;
+	struct resource res_mem;
+	struct hw_pci hw_pci;
+
+	bool linked;
+};
+
+static struct cns3xxx_pcie cns3xxx_pcie[]; /* forward decl. */
+
+static struct cns3xxx_pcie *sysdata_to_cnspci(void *sysdata)
+{
+	struct pci_sys_data *root = sysdata;
+
+	return &cns3xxx_pcie[root->domain];
+}
+
+static struct cns3xxx_pcie *pdev_to_cnspci(struct pci_dev *dev)
+{
+	return sysdata_to_cnspci(dev->sysdata);
+}
+
+static struct cns3xxx_pcie *pbus_to_cnspci(struct pci_bus *bus)
+{
+	return sysdata_to_cnspci(bus->sysdata);
+}
+
+static void __iomem *cns3xxx_pci_cfg_base(struct pci_bus *bus,
+				  unsigned int devfn, int where)
+{
+	struct cns3xxx_pcie *cnspci = pbus_to_cnspci(bus);
+	int busno = bus->number;
+	int slot = PCI_SLOT(devfn);
+	int offset;
+	enum cns3xxx_access_type type;
+	void __iomem *base;
+
+	/* If there is no link, just show the CNS PCI bridge. */
+	if (!cnspci->linked && (busno > 0 || slot > 0))
+		return NULL;
+
+	/*
+	 * The CNS PCI bridge doesn't fit into the PCI hierarchy, though
+	 * we still want to access it. For this to work, we must place
+	 * the first device on the same bus as the CNS PCI bridge.
+	 */
+	if (busno == 0) {
+		if (slot > 1)
+			return NULL;
+		type = slot;
+	} else {
+		type = CNS3XXX_CFG1_TYPE;
+	}
+
+	base = (void __iomem *)cnspci->cfg_bases[type].virtual;
+	offset = ((busno & 0xf) << 20) | (devfn << 12) | (where & 0xffc);
+
+	return base + offset;
+}
+
+static int cns3xxx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 *val)
+{
+	u32 v;
+	void __iomem *base;
+	u32 mask = (0x1ull << (size * 8)) - 1;
+	int shift = (where % 4) * 8;
+
+	base = cns3xxx_pci_cfg_base(bus, devfn, where);
+	if (!base) {
+		*val = 0xffffffff;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	v = __raw_readl(base);
+
+	if (bus->number == 0 && devfn == 0 &&
+			(where & 0xffc) == PCI_CLASS_REVISION) {
+		/*
+		 * RC's class is 0xb, but Linux PCI driver needs 0x604
+		 * for a PCIe bridge. So we must fixup the class code
+		 * to 0x604 here.
+		 */
+		v &= 0xff;
+		v |= 0x604 << 16;
+	}
+
+	*val = (v >> shift) & mask;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int cns3xxx_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				    int where, int size, u32 val)
+{
+	u32 v;
+	void __iomem *base;
+	u32 mask = (0x1ull << (size * 8)) - 1;
+	int shift = (where % 4) * 8;
+
+	base = cns3xxx_pci_cfg_base(bus, devfn, where);
+	if (!base)
+		return PCIBIOS_SUCCESSFUL;
+
+	v = __raw_readl(base);
+
+	v &= ~(mask << shift);
+	v |= (val & mask) << shift;
+
+	__raw_writel(v, base);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int cns3xxx_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	struct cns3xxx_pcie *cnspci = sysdata_to_cnspci(sys);
+	struct resource *res_io = &cnspci->res_io;
+	struct resource *res_mem = &cnspci->res_mem;
+	struct resource **sysres = sys->resource;
+
+	BUG_ON(request_resource(&iomem_resource, res_io) ||
+	       request_resource(&iomem_resource, res_mem));
+
+	sysres[0] = res_io;
+	sysres[1] = res_mem;
+
+	return 1;
+}
+
+static struct pci_ops cns3xxx_pcie_ops = {
+	.read = cns3xxx_pci_read_config,
+	.write = cns3xxx_pci_write_config,
+};
+
+static struct pci_bus *cns3xxx_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	return pci_scan_bus(sys->busnr, &cns3xxx_pcie_ops, sys);
+}
+
+static int cns3xxx_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
+	int irq = cnspci->irqs[slot];
+
+	pr_info("PCIe map irq: %04d:%02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+		pci_domain_nr(dev->bus), dev->bus->number, PCI_SLOT(dev->devfn),
+		PCI_FUNC(dev->devfn), slot, pin, irq);
+
+	return irq;
+}
+
+static struct cns3xxx_pcie cns3xxx_pcie[] = {
+	[0] = {
+		.cfg_bases = {
+			[CNS3XXX_HOST_TYPE] = {
+				.virtual = CNS3XXX_PCIE0_HOST_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_HOST_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+			[CNS3XXX_CFG0_TYPE] = {
+				.virtual = CNS3XXX_PCIE0_CFG0_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_CFG0_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+			[CNS3XXX_CFG1_TYPE] = {
+				.virtual = CNS3XXX_PCIE0_CFG1_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE0_CFG1_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+		},
+		.res_io = {
+			.name = "PCIe0 I/O space",
+			.start = CNS3XXX_PCIE0_IO_BASE,
+			.end = CNS3XXX_PCIE0_IO_BASE + SZ_16M - 1,
+			.flags = IORESOURCE_IO,
+		},
+		.res_mem = {
+			.name = "PCIe0 non-prefetchable",
+			.start = CNS3XXX_PCIE0_MEM_BASE,
+			.end = CNS3XXX_PCIE0_MEM_BASE + SZ_16M - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
+		.hw_pci = {
+			.domain = 0,
+			.swizzle = pci_std_swizzle,
+			.nr_controllers = 1,
+			.setup = cns3xxx_pci_setup,
+			.scan = cns3xxx_pci_scan_bus,
+			.map_irq = cns3xxx_pcie_map_irq,
+		},
+	},
+	[1] = {
+		.cfg_bases = {
+			[CNS3XXX_HOST_TYPE] = {
+				.virtual = CNS3XXX_PCIE1_HOST_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_HOST_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+			[CNS3XXX_CFG0_TYPE] = {
+				.virtual = CNS3XXX_PCIE1_CFG0_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_CFG0_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+			[CNS3XXX_CFG1_TYPE] = {
+				.virtual = CNS3XXX_PCIE1_CFG1_BASE_VIRT,
+				.pfn = __phys_to_pfn(CNS3XXX_PCIE1_CFG1_BASE),
+				.length = SZ_16M,
+				.type = MT_DEVICE,
+			},
+		},
+		.res_io = {
+			.name = "PCIe1 I/O space",
+			.start = CNS3XXX_PCIE1_IO_BASE,
+			.end = CNS3XXX_PCIE1_IO_BASE + SZ_16M - 1,
+			.flags = IORESOURCE_IO,
+		},
+		.res_mem = {
+			.name = "PCIe1 non-prefetchable",
+			.start = CNS3XXX_PCIE1_MEM_BASE,
+			.end = CNS3XXX_PCIE1_MEM_BASE + SZ_16M - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
+		.hw_pci = {
+			.domain = 1,
+			.swizzle = pci_std_swizzle,
+			.nr_controllers = 1,
+			.setup = cns3xxx_pci_setup,
+			.scan = cns3xxx_pci_scan_bus,
+			.map_irq = cns3xxx_pcie_map_irq,
+		},
+	},
+};
+
+static void __init cns3xxx_pcie_check_link(struct cns3xxx_pcie *cnspci)
+{
+	int port = cnspci->hw_pci.domain;
+	u32 reg;
+	unsigned long time;
+
+	reg = __raw_readl(MISC_PCIE_CTRL(port));
+	/*
+	 * Enable Application Request to 1, it will exit L1 automatically,
+	 * but when chip back, it will use another clock, still can use 0x1.
+	 */
+	reg |= 0x3;
+	__raw_writel(reg, MISC_PCIE_CTRL(port));
+
+	pr_info("PCIe: Port[%d] Enable PCIe LTSSM\n", port);
+	pr_info("PCIe: Port[%d] Check data link layer...", port);
+
+	time = jiffies;
+	while (1) {
+		reg = __raw_readl(MISC_PCIE_PM_DEBUG(port));
+		if (reg & 0x1) {
+			pr_info("Link up.\n");
+			cnspci->linked = 1;
+			break;
+		} else if (time_after(jiffies, time + 50)) {
+			pr_info("Device not found.\n");
+			break;
+		}
+	}
+}
+
+static void __init cns3xxx_pcie_hw_init(struct cns3xxx_pcie *cnspci)
+{
+	int port = cnspci->hw_pci.domain;
+	struct pci_sys_data sd = {
+		.domain = port,
+	};
+	struct pci_bus bus = {
+		.number = 0,
+		.ops = &cns3xxx_pcie_ops,
+		.sysdata = &sd,
+	};
+	u32 io_base = cnspci->res_io.start >> 16;
+	u32 mem_base = cnspci->res_mem.start >> 16;
+	u32 host_base = cnspci->cfg_bases[CNS3XXX_HOST_TYPE].pfn;
+	u32 cfg0_base = cnspci->cfg_bases[CNS3XXX_CFG0_TYPE].pfn;
+	u32 devfn = 0;
+	u8 tmp8;
+	u16 pos;
+	u16 dc;
+
+	host_base = (__pfn_to_phys(host_base) - 1) >> 16;
+	cfg0_base = (__pfn_to_phys(cfg0_base) - 1) >> 16;
+
+	pci_bus_write_config_byte(&bus, devfn, PCI_PRIMARY_BUS, 0);
+	pci_bus_write_config_byte(&bus, devfn, PCI_SECONDARY_BUS, 1);
+	pci_bus_write_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, 1);
+
+	pci_bus_read_config_byte(&bus, devfn, PCI_PRIMARY_BUS, &tmp8);
+	pci_bus_read_config_byte(&bus, devfn, PCI_SECONDARY_BUS, &tmp8);
+	pci_bus_read_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, &tmp8);
+
+	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_BASE, mem_base);
+	pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_LIMIT, host_base);
+	pci_bus_write_config_word(&bus, devfn, PCI_IO_BASE_UPPER16, io_base);
+	pci_bus_write_config_word(&bus, devfn, PCI_IO_LIMIT_UPPER16, cfg0_base);
+
+	if (!cnspci->linked)
+		return;
+
+	/* Set Device Max_Read_Request_Size to 128 byte */
+	devfn = PCI_DEVFN(1, 0);
+	pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
+	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
+	dc &= ~(0x3 << 12);	/* Clear Device Control Register [14:12] */
+	pci_bus_write_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, dc);
+	pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_DEVCTL, &dc);
+	if (!(dc & (0x3 << 12)))
+		pr_info("PCIe: Set Device Max_Read_Request_Size to 128 byte\n");
+
+	/* Disable PCIe0 Interrupt Mask INTA to INTD */
+	__raw_writel(~0x3FFF, MISC_PCIE_INT_MASK(port));
+}
+
+static int cns3xxx_pcie_abort_handler(unsigned long addr, unsigned int fsr,
+				      struct pt_regs *regs)
+{
+	if (fsr & (1 << 10))
+		regs->ARM_pc += 4;
+	return 0;
+}
+
+static int __init cns3xxx_pcie_init(void)
+{
+	int i;
+
+	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS,
+			"imprecise external abort");
+
+	for (i = 0; i < ARRAY_SIZE(cns3xxx_pcie); i++) {
+		iotable_init(cns3xxx_pcie[i].cfg_bases,
+			     ARRAY_SIZE(cns3xxx_pcie[i].cfg_bases));
+		cns3xxx_pwr_clk_en(0x1 << PM_CLK_GATE_REG_OFFSET_PCIE(i));
+		cns3xxx_pwr_soft_rst(0x1 << PM_SOFT_RST_REG_OFFST_PCIE(i));
+		cns3xxx_pcie_check_link(&cns3xxx_pcie[i]);
+		cns3xxx_pcie_hw_init(&cns3xxx_pcie[i]);
+		pci_common_init(&cns3xxx_pcie[i].hw_pci);
+	}
+
+	pci_assign_unassigned_resources();
+
+	return 0;
+}
+device_initcall(cns3xxx_pcie_init);
