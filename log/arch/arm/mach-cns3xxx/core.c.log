commit 4c819924f571fb74496c85df2780dc75f8686b68
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Fri Mar 27 18:14:22 2020 +0530

    ARM: cns3xxx: replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Link: https://lore.kernel.org/r/20200327124422.4181-1-afzal.mohd.ma@gmail.com
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 1d61a7701c11..e4f4b20b83a2 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -189,12 +189,6 @@ static irqreturn_t cns3xxx_timer_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct irqaction cns3xxx_timer_irq = {
-	.name		= "timer",
-	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= cns3xxx_timer_interrupt,
-};
-
 /*
  * Set up the clock source and clock events devices
  */
@@ -245,7 +239,9 @@ static void __init __cns3xxx_timer_init(unsigned int timer_irq)
 	writel(val, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
 
 	/* Make irqs happen for the system timer */
-	setup_irq(timer_irq, &cns3xxx_timer_irq);
+	if (request_irq(timer_irq, cns3xxx_timer_interrupt,
+			IRQF_TIMER | IRQF_IRQPOLL, "timer", NULL))
+		pr_err("Failed to request irq %d (timer)\n", timer_irq);
 
 	cns3xxx_clockevents_init(timer_irq);
 }

commit 25d5bf4764f9a0855180cd52559186dd16c0c39f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 418
    
    Based on 1 normalized pattern(s):
    
      this file is free software you can redistribute it and or modify it
      under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190113.419778592@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index f676592d8402..1d61a7701c11 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 1999 - 2003 ARM Limited
  * Copyright 2000 Deep Blue Solutions Ltd
  * Copyright 2008 Cavium Networks
- *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as
- * published by the Free Software Foundation.
  */
 
 #include <linux/init.h>

commit b41fdc4a7bf9045e4871c5b15905ea732ffd044f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Mar 11 15:38:10 2019 +0000

    irqchip/gic: Drop support for secondary GIC in non-DT systems
    
    We do not have any in-tree platform with this pathological setup,
    and only a single system (Cavium's cns3xxx) isn't DT aware.
    
    Let's drop the secondary GIC support for now, until we remove
    the above horror altogether.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 7d5a44a06648..f676592d8402 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -90,7 +90,7 @@ void __init cns3xxx_map_io(void)
 /* used by entry-macro.S */
 void __init cns3xxx_init_irq(void)
 {
-	gic_init(0, 29, IOMEM(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
+	gic_init(IOMEM(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
 		 IOMEM(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT));
 }
 

commit 0527873b29b077fc8e656acd63e1866b429fef55
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 11 13:50:16 2017 +0200

    ARM: remove duplicate 'const' annotations'
    
    gcc-7 warns about some declarations that are more 'const' than necessary:
    
    arch/arm/mach-at91/pm.c:338:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const ramc_ids[] __initconst = {
    arch/arm/mach-bcm/bcm_kona_smc.c:36:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
    arch/arm/mach-spear/time.c:207:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const timer_of_match[] __initconst = {
    arch/arm/mach-omap2/prm_common.c:714:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
    arch/arm/mach-omap2/vc.c:562:35: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
    
    The ones in arch/arm were apparently all introduced accidentally by one
    commit that correctly marked a lot of variables as __initconst.
    
    Fixes: 19c233b79d1a ("ARM: appropriate __init annotation for const data")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 03da3813f1ab..7d5a44a06648 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -346,7 +346,7 @@ static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {
 	.power_off	= csn3xxx_usb_power_off,
 };
 
-static const struct of_dev_auxdata const cns3xxx_auxdata[] __initconst = {
+static const struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {
 	{ "intel,usb-ehci", CNS3XXX_USB_BASE, "ehci-platform", &cns3xxx_usb_ehci_pdata },
 	{ "intel,usb-ohci", CNS3XXX_USB_OHCI_BASE, "ohci-platform", &cns3xxx_usb_ohci_pdata },
 	{ "cavium,cns3420-ahci", CNS3XXX_SATA2_BASE, "ahci", NULL },

commit 435ebcbc9fee4e8af037d293c89de60be3605c66
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Jun 1 14:53:05 2016 +0800

    arm: use of_platform_default_populate() to populate
    
    Use helper of_platform_default_populate() in linux/of_platform
    when possible, instead of calling of_platform_populate() with
    the default match table.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Viresh Kumar <vireshk@kernel.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 9b1dc223d8d3..03da3813f1ab 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -395,8 +395,7 @@ static void __init cns3xxx_init(void)
 
 	pm_power_off = cns3xxx_power_off;
 
-	of_platform_populate(NULL, of_default_bus_match_table,
-                        cns3xxx_auxdata, NULL);
+	of_platform_default_populate(NULL, cns3xxx_auxdata, NULL);
 }
 
 static const char *const cns3xxx_dt_compat[] __initconst = {

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 11f9644f8f41..9b1dc223d8d3 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -346,7 +346,7 @@ static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {
 	.power_off	= csn3xxx_usb_power_off,
 };
 
-static struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {
+static const struct of_dev_auxdata const cns3xxx_auxdata[] __initconst = {
 	{ "intel,usb-ehci", CNS3XXX_USB_BASE, "ehci-platform", &cns3xxx_usb_ehci_pdata },
 	{ "intel,usb-ohci", CNS3XXX_USB_OHCI_BASE, "ohci-platform", &cns3xxx_usb_ohci_pdata },
 	{ "cavium,cns3420-ahci", CNS3XXX_SATA2_BASE, "ahci", NULL },
@@ -399,7 +399,7 @@ static void __init cns3xxx_init(void)
                         cns3xxx_auxdata, NULL);
 }
 
-static const char *cns3xxx_dt_compat[] __initdata = {
+static const char *const cns3xxx_dt_compat[] __initconst = {
 	"cavium,cns3410",
 	"cavium,cns3420",
 	NULL,

commit 9bdc2e0c9a45b2b5f4de9927562305475ecb9b55
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/cns3xxx/timer: Migrate to new 'set-state' interface
    
    Migrate cns3xxx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    NOTE: We don't read TIMER1_2_CONTROL_OFFSET register on shutdown
    anymore.
    
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 4e9837ded96d..11f9644f8f41 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -113,30 +113,33 @@ void cns3xxx_power_off(void)
  */
 static void __iomem *cns3xxx_tmr1;
 
-static void cns3xxx_timer_set_mode(enum clock_event_mode mode,
-				   struct clock_event_device *clk)
+static int cns3xxx_shutdown(struct clock_event_device *clk)
+{
+	writel(0, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	return 0;
+}
+
+static int cns3xxx_set_oneshot(struct clock_event_device *clk)
+{
+	unsigned long ctrl = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+
+	/* period set, and timer enabled in 'next_event' hook */
+	ctrl |= (1 << 2) | (1 << 9);
+	writel(ctrl, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	return 0;
+}
+
+static int cns3xxx_set_periodic(struct clock_event_device *clk)
 {
 	unsigned long ctrl = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
 	int pclk = cns3xxx_cpu_clock() / 8;
 	int reload;
 
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		reload = pclk * 20 / (3 * HZ) * 0x25000;
-		writel(reload, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
-		ctrl |= (1 << 0) | (1 << 2) | (1 << 9);
-		break;
-	case CLOCK_EVT_MODE_ONESHOT:
-		/* period set, and timer enabled in 'next_event' hook */
-		ctrl |= (1 << 2) | (1 << 9);
-		break;
-	case CLOCK_EVT_MODE_UNUSED:
-	case CLOCK_EVT_MODE_SHUTDOWN:
-	default:
-		ctrl = 0;
-	}
-
+	reload = pclk * 20 / (3 * HZ) * 0x25000;
+	writel(reload, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
+	ctrl |= (1 << 0) | (1 << 2) | (1 << 9);
 	writel(ctrl, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	return 0;
 }
 
 static int cns3xxx_timer_set_next_event(unsigned long evt,
@@ -151,12 +154,16 @@ static int cns3xxx_timer_set_next_event(unsigned long evt,
 }
 
 static struct clock_event_device cns3xxx_tmr1_clockevent = {
-	.name		= "cns3xxx timer1",
-	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-	.set_mode	= cns3xxx_timer_set_mode,
-	.set_next_event	= cns3xxx_timer_set_next_event,
-	.rating		= 350,
-	.cpumask	= cpu_all_mask,
+	.name			= "cns3xxx timer1",
+	.features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_FEAT_ONESHOT,
+	.set_state_shutdown	= cns3xxx_shutdown,
+	.set_state_periodic	= cns3xxx_set_periodic,
+	.set_state_oneshot	= cns3xxx_set_oneshot,
+	.tick_resume		= cns3xxx_shutdown,
+	.set_next_event		= cns3xxx_timer_set_next_event,
+	.rating			= 350,
+	.cpumask		= cpu_all_mask,
 };
 
 static void __init cns3xxx_clockevents_init(unsigned int timer_irq)

commit 0a2e912d296201c476fe5d7ba6ac23a66325935f
Author: Xia Kaixu <kaixu.xia@linaro.org>
Date:   Wed Sep 3 21:18:12 2014 +0800

    ARM: cns3xxx: fix allmodconfig panic in pci driver
    
    The kernel panic occurs when running an allmodconfig kernel on
    OMAP4460. The inicall "cns3xxx_pcie_init" does not check which
    hardware it's running on and just tries to access to its specific
    registers. Now call it from .init_late callback from the two
    machine descriptors.
    
    Signed-off-by: Xia Kaixu <kaixu.xia@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Felix Fietkau <nbd@openwrt.org>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index f85449a6accd..4e9837ded96d 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -404,5 +404,6 @@ DT_MACHINE_START(CNS3XXX_DT, "Cavium Networks CNS3xxx")
 	.init_irq	= cns3xxx_init_irq,
 	.init_time	= cns3xxx_timer_init,
 	.init_machine	= cns3xxx_init,
+	.init_late	= cns3xxx_pcie_init_late,
 	.restart	= cns3xxx_restart,
 MACHINE_END

commit 24cb65feab42ac0cc26464ac4b7a38c0ab7ce173
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 19 12:06:27 2014 +0000

    ARM: l2c: cns3xxx: remove cache size override
    
    The cache size should already be present in the L2 cache auxiliary
    control register: it is part of the integration process to configure
    the hardware IP.  Most platforms get this right, yet still many
    cargo-cult program, and assume that they always need specifying to
    the L2 cache code.  Remove them so we can find out which really need
    this.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 5c31b2638c01..f85449a6accd 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -290,7 +290,7 @@ void __init cns3xxx_l2x0_init(void)
 	writel(val, base + L310_DATA_LATENCY_CTRL);
 
 	/* 32 KiB, 8-way, parity disable */
-	l2x0_init(base, 0x00540000, 0xfe000fff);
+	l2x0_init(base, 0x00500000, 0xfe0f0fff);
 }
 
 #endif /* CONFIG_CACHE_L2X0 */

commit 1a5a954ce0dd8ba1fc8b5305bcdb6e4cf7d6939b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Mar 16 20:52:25 2014 +0000

    ARM: l2c: fix register naming
    
    We have a mixture of different devices with different register layouts,
    but we group all the bits together in an opaque mess.  Split them out
    into those which are L2C-310 specific and ones which refer to earlier
    devices.  Provide full auxiliary control register definitions.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 2ae28a69e3e5..5c31b2638c01 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -272,9 +272,9 @@ void __init cns3xxx_l2x0_init(void)
 	 *
 	 * 1 cycle of latency for setup, read and write accesses
 	 */
-	val = readl(base + L2X0_TAG_LATENCY_CTRL);
+	val = readl(base + L310_TAG_LATENCY_CTRL);
 	val &= 0xfffff888;
-	writel(val, base + L2X0_TAG_LATENCY_CTRL);
+	writel(val, base + L310_TAG_LATENCY_CTRL);
 
 	/*
 	 * Data RAM Control register
@@ -285,9 +285,9 @@ void __init cns3xxx_l2x0_init(void)
 	 *
 	 * 1 cycle of latency for setup, read and write accesses
 	 */
-	val = readl(base + L2X0_DATA_LATENCY_CTRL);
+	val = readl(base + L310_DATA_LATENCY_CTRL);
 	val &= 0xfffff888;
-	writel(val, base + L2X0_DATA_LATENCY_CTRL);
+	writel(val, base + L310_DATA_LATENCY_CTRL);
 
 	/* 32 KiB, 8-way, parity disable */
 	l2x0_init(base, 0x00540000, 0xfe000fff);

commit 9f800363bb0ea459e15bef0928a72c88d374e489
Merge: 2d1eb87ae1e6 cb46a256a782
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 13:44:27 2014 -0700

    Merge tag 'fixes-non-critical-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical bug fixes from Arnd Bergmann:
     "Lots of isolated bug fixes that were not found to be important enough
      to be submitted before the merge window or backported into stable
      kernels.
    
      The vast majority of these came out of Arnd's randconfig testing and
      just prevents running into build-time bugs in configurations that we
      do not care about in practice"
    
    * tag 'fixes-non-critical-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (75 commits)
      ARM: at91: fix a typo
      ARM: moxart: fix CPU selection
      ARM: tegra: fix board DT pinmux setup
      ARM: nspire: Fix compiler warning
      IXP4xx: Fix DMA masks.
      Revert "ARM: ixp4xx: Make dma_set_coherent_mask common, correct implementation"
      IXP4xx: Fix Goramo Multilink GPIO conversion.
      Revert "ARM: ixp4xx: fix gpio rework"
      ARM: tegra: make debug_ll code build for ARMv6
      ARM: sunxi: fix build for THUMB2_KERNEL
      ARM: exynos: add missing include of linux/module.h
      ARM: exynos: fix l2x0 saved regs handling
      ARM: samsung: select CRC32 for SAMSUNG_PM_CHECK
      ARM: samsung: select ATAGS where necessary
      ARM: samsung: fix SAMSUNG_PM_DEBUG Kconfig logic
      ARM: samsung: allow serial driver to be disabled
      ARM: s5pv210: enable IDE support in MACH_TORBRECK
      ARM: s5p64x0: fix building with only one soc type
      ARM: s3c64xx: select power domains only when used
      ARM: s3c64xx: MACH_SMDK6400 needs HSMMC1
      ...

commit 64cf9d07ef1f5ed6abc6ed8a2420eb2849f7f444
Author: Krzysztof Hałasa <khalasa@piap.pl>
Date:   Tue Mar 4 08:37:10 2014 +0100

    CNS3xxx: Fix PCIe early iotable_init().
    
    This patch fixes the following BUG:
    
    > kernel BUG at mm/vmalloc.c:1132!
    > PC is at vm_area_add_early+0x20/0x84
    > LR is at add_static_vm_early+0xc/0x60
    >
    > The problem is cns3xxx_pcie_init() (device_initcall) calls the "early"
    > iotable_init().
    
    Instead of merely calling the PCIe iotable_init() from
    machine_desc->map_io(), this patch adds the required mappings to the
    main CNS3xxx mapping table. This means we don't convert .pfn back to
    virtual addresses in pcie.c. The size of the address space consumed for
    PCIe control is reduced from 96 MiB (6 * 16 MiB) to about 32 MiB (this
    doesn't include MMIO address space required by PCI devices):
    
    - Size of the PCIe "host" mapping is reduced from 16 MiB to 4 KiB.
      It's a PCI configuration address space for the local (on-chip) PCIe
      bridge.
    
    - Size of the "CFG0" mapping is reduced from 16 MiB to 64 KiB. It's for
      Type 0 Configuration accesses, i.e., accesses to the single device
      (with possible "functions") on the other end of the PCIe link.
      We really only need a 4 KiB page at 0x8000 (see the offset
      calculation in cns3xxx_pci_cfg_base()). There is still a potential
      problem with PCI bus numbers > 0xF, are they supported?
    
    - The code in cns3xxx_pci_cfg_base() and cns3xxx_pcie_hw_init() should
      be clearer now.
    
    - The maximum address space allocated for PCI MMIO is now correctly
      shown in /proc/iomem as 176 MiB (per each of the two PCI "domains"
      - previously only 16 MiB were reserved).
    
    This patch has been tested on Gateworks Laguna board, masqueraded as
    CNS3420VB.
    
    Signed-off-by: Krzysztof Ha?asa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 0aaeb8c19c9c..79d37adcb1f7 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -47,6 +47,38 @@ static struct map_desc cns3xxx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(CNS3XXX_PM_BASE),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
+#ifdef CONFIG_PCI
+	}, {
+		.virtual	= CNS3XXX_PCIE0_HOST_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE0_HOST_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PCIE0_CFG0_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE0_CFG0_BASE),
+		.length		= SZ_64K, /* really 4 KiB at offset 32 KiB */
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PCIE0_CFG1_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE0_CFG1_BASE),
+		.length		= SZ_16M,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PCIE1_HOST_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE1_HOST_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PCIE1_CFG0_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE1_CFG0_BASE),
+		.length		= SZ_64K, /* really 4 KiB at offset 32 KiB */
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PCIE1_CFG1_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PCIE1_CFG1_BASE),
+		.length		= SZ_16M,
+		.type		= MT_DEVICE,
+#endif
 	},
 };
 

commit 75efba81513133fdd2f9c1ac9213bf86cc622f62
Author: Krzysztof Hałasa <khalasa@piap.pl>
Date:   Tue Mar 4 11:50:35 2014 +0100

    CNS3xxx: Fix a WARN() related to IRQ allocation.
    
    WARNING: at drivers/irqchip/irq-gic.c:952 gic_init_bases+0xe4/0x2b8()
    Cannot allocate irq_descs @ IRQ16, assuming pre-allocated
    Backtrace:
    gic_init_bases    from cns3xxx_init_irq+0x24/0x34
    cns3xxx_init_irq  from init_IRQ+0x24/0x2c
    init_IRQ          from start_kernel+0x1a8/0x338
    start_kernel      from 0x2000806c
    
    The problem is that 64 CNS3xxx CPU interrupts, starting at 32, are
    allocated by the ARM platform-independent code (as requested by
    machine_desc->nr_irqs = 96), and then the GIC code tries to allocate
    them again.
    
    Tested on Gateworks Laguna board, masqueraded as CNS3420VB.
    
    Signed-off-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index e38b279f402c..0aaeb8c19c9c 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -368,7 +368,6 @@ static const char *cns3xxx_dt_compat[] __initdata = {
 
 DT_MACHINE_START(CNS3XXX_DT, "Cavium Networks CNS3xxx")
 	.dt_compat	= cns3xxx_dt_compat,
-	.nr_irqs	= NR_IRQS_CNS3XXX,
 	.map_io		= cns3xxx_map_io,
 	.init_irq	= cns3xxx_init_irq,
 	.init_time	= cns3xxx_timer_init,

commit 19bd9b286da6f28f4cb04757dd8509a38f9f34d7
Author: Michael Opdenacker <michael@free-electrons.com>
Date:   Tue Mar 4 21:56:10 2014 +0100

    ARM: 7997/1: cns3xxx: remove deprecated IRQF_DISABLED
    
    This patch removes the use of the IRQF_DISABLED flag
    from arch/arm/mach-cns3xxx/core.c
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index e38b279f402c..384dc859e6c6 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -155,7 +155,7 @@ static irqreturn_t cns3xxx_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction cns3xxx_timer_irq = {
 	.name		= "timer",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= cns3xxx_timer_interrupt,
 };
 

commit 99c6bcf46d2233d33e441834e958ed0bc22b190a
Merge: 97b1007a2924 2fdfe1c26fb9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:38:16 2013 -0700

    Merge tag 'multiplatform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC multiplatform updates from Olof Johansson:
     "More multiplatform enablement for ARM platforms.  The ones converted
      in this branch are:
    
       - bcm2835
       - cns3xxx
       - sirf
       - nomadik
       - msx
       - spear
       - tegra
       - ux500
    
      We're getting close to having most of them converted!
    
      One of the larger platforms remaining is Samsung Exynos, and there are
      a bunch of supporting patches in this merge window for it.  There was
      a patch in this branch to a early version of multiplatform conversion,
      but it ended up being reverted due to need of more bake time.  The
      revert commit is part of the branch since it would have required
      rebasing multiple dependent branches and they were stable by then"
    
    * tag 'multiplatform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (70 commits)
      mmc: sdhci-s3c: Fix operation on non-single image Samsung platforms
      clocksource: nomadik-mtu: fix up clocksource/timer
      Revert "ARM: exynos: enable multiplatform support"
      ARM: SPEAr13xx: Fix typo "ARCH_HAVE_CPUFREQ"
      ARM: exynos: enable multiplatform support
      rtc: s3c: make header file local
      mtd: onenand/samsung: make regs-onenand.h file local
      thermal/exynos: remove unnecessary header inclusions
      mmc: sdhci-s3c: remove platform dependencies
      ARM: samsung: move mfc device definition to s5p-dev-mfc.c
      ARM: exynos: move debug-macro.S to include/debug/
      ARM: exynos: prepare for sparse IRQ
      ARM: exynos: introduce EXYNOS_ATAGS symbol
      ARM: tegra: build assembly files with -march=armv7-a
      ARM: Push selects for TWD/SCU into machine entries
      ARM: ux500: build hotplug.o for ARMv7-a
      ARM: ux500: move to multiplatform
      ARM: ux500: make remaining headers local
      ARM: ux500: make irqs.h local to platform
      ARM: ux500: get rid of <mach/[hardware|db8500-regs].h>
      ...

commit fc46d17c4a6b7aa2af11eb9275ed9791f2594ddf
Author: Mac Lin <mkl0301@gmail.com>
Date:   Mon Mar 25 17:24:19 2013 +0800

    ARM: cns3xxx: remove unused virtual address and iotable defines
    
    Signed-off-by: Mac Lin <mkl0301@gmail.com>
    Signed-off-by: Anton Vorontsov <anton@enomsg.org>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 52e4bb5cf12d..126f74f6087c 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -31,16 +31,6 @@ static struct map_desc cns3xxx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(CNS3XXX_TIMER1_2_3_BASE),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
-	}, {
-		.virtual	= CNS3XXX_GPIOA_BASE_VIRT,
-		.pfn		= __phys_to_pfn(CNS3XXX_GPIOA_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
-	}, {
-		.virtual	= CNS3XXX_GPIOB_BASE_VIRT,
-		.pfn		= __phys_to_pfn(CNS3XXX_GPIOB_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_MISC_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_MISC_BASE),

commit a3d9052c6296ad3398d3ad649c3c682c3e7ecfa6
Author: Mac Lin <mkl0301@gmail.com>
Date:   Mon Mar 25 17:23:33 2013 +0800

    ARM: cns3xxx: fix mapping of private memory region
    
    Since commit 0536bdf33faf (ARM: move iotable mappings within the vmalloc
    region), the Cavium CNS3xxx cannot boot anymore.
    
    This is caused by the pre-defined iotable mappings is not in the vmalloc
    region. This patch move the iotable mappings into the vmalloc region, and
    merge the MPCore private memory region (containing the SCU, the GIC and
    the TWD) as a single region.
    
    Signed-off-by: Mac Lin <mkl0301@gmail.com>
    Signed-off-by: Anton Vorontsov <anton@enomsg.org>
    Cc: stable@vger.kernel.org [v3.3+]

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index e698f26cc0cb..52e4bb5cf12d 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -22,19 +22,9 @@
 
 static struct map_desc cns3xxx_io_desc[] __initdata = {
 	{
-		.virtual	= CNS3XXX_TC11MP_TWD_BASE_VIRT,
-		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_TWD_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
-	}, {
-		.virtual	= CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT,
-		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_GIC_CPU_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
-	}, {
-		.virtual	= CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT,
-		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_GIC_DIST_BASE),
-		.length		= SZ_4K,
+		.virtual	= CNS3XXX_TC11MP_SCU_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_SCU_BASE),
+		.length		= SZ_8K,
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_TIMER1_2_3_BASE_VIRT,

commit 415f59142d9d9dd023deaeb3b4dfc1aecdd3983c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 14 22:27:32 2013 +0100

    ARM: cns3xxx: initial DT support
    
    This adds very minimal support for booting cns3xxx using a device
    tree. It should support the same devices that cns3420vb provides
    but gets them from the DT. All devices that don't have their own
    binding are probed through auxdata. This is completely untested
    and likely incomplete.
    
    Booting through ATAGS is made optional, so it can be turned off
    by anybody who has a DTB file.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 012ffdb9e142..49e657c15067 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -13,12 +13,18 @@
 #include <linux/clockchips.h>
 #include <linux/io.h>
 #include <linux/irqchip/arm-gic.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/usb/ehci_pdriver.h>
+#include <linux/usb/ohci_pdriver.h>
+#include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/hardware/cache-l2x0.h>
 #include "cns3xxx.h"
 #include "core.h"
+#include "pm.h"
 
 static struct map_desc cns3xxx_io_desc[] __initdata = {
 	{
@@ -276,3 +282,116 @@ void __init cns3xxx_l2x0_init(void)
 }
 
 #endif /* CONFIG_CACHE_L2X0 */
+
+static int csn3xxx_usb_power_on(struct platform_device *pdev)
+{
+	/*
+	 * EHCI and OHCI share the same clock and power,
+	 * resetting twice would cause the 1st controller been reset.
+	 * Therefore only do power up  at the first up device, and
+	 * power down at the last down device.
+	 *
+	 * Set USB AHB INCR length to 16
+	 */
+	if (atomic_inc_return(&usb_pwr_ref) == 1) {
+		cns3xxx_pwr_power_up(1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
+		cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
+		cns3xxx_pwr_soft_rst(1 << PM_SOFT_RST_REG_OFFST_USB_HOST);
+		__raw_writel((__raw_readl(MISC_CHIP_CONFIG_REG) | (0X2 << 24)),
+			MISC_CHIP_CONFIG_REG);
+	}
+
+	return 0;
+}
+
+static void csn3xxx_usb_power_off(struct platform_device *pdev)
+{
+	/*
+	 * EHCI and OHCI share the same clock and power,
+	 * resetting twice would cause the 1st controller been reset.
+	 * Therefore only do power up  at the first up device, and
+	 * power down at the last down device.
+	 */
+	if (atomic_dec_return(&usb_pwr_ref) == 0)
+		cns3xxx_pwr_clk_dis(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
+}
+
+static struct usb_ehci_pdata cns3xxx_usb_ehci_pdata = {
+	.power_on	= csn3xxx_usb_power_on,
+	.power_off	= csn3xxx_usb_power_off,
+};
+
+static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {
+	.num_ports	= 1,
+	.power_on	= csn3xxx_usb_power_on,
+	.power_off	= csn3xxx_usb_power_off,
+};
+
+static struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {
+	{ "intel,usb-ehci", CNS3XXX_USB_BASE, "ehci-platform", &cns3xxx_usb_ehci_pdata },
+	{ "intel,usb-ohci", CNS3XXX_USB_OHCI_BASE, "ohci-platform", &cns3xxx_usb_ohci_pdata },
+	{ "cavium,cns3420-ahci", CNS3XXX_SATA2_BASE, "ahci", NULL },
+	{ "cavium,cns3420-sdhci", CNS3XXX_SDIO_BASE, "ahci", NULL },
+	{},
+};
+
+static void __init cns3xxx_init(void)
+{
+	struct device_node *dn;
+
+	cns3xxx_l2x0_init();
+
+	dn = of_find_compatible_node(NULL, NULL, "cavium,cns3420-ahci");
+	if (of_device_is_available(dn)) {
+		u32 tmp;
+	
+		tmp = __raw_readl(MISC_SATA_POWER_MODE);
+		tmp |= 0x1 << 16; /* Disable SATA PHY 0 from SLUMBER Mode */
+		tmp |= 0x1 << 17; /* Disable SATA PHY 1 from SLUMBER Mode */
+		__raw_writel(tmp, MISC_SATA_POWER_MODE);
+	
+		/* Enable SATA PHY */
+		cns3xxx_pwr_power_up(0x1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_SATA_PHY0);
+		cns3xxx_pwr_power_up(0x1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_SATA_PHY1);
+	
+		/* Enable SATA Clock */
+		cns3xxx_pwr_clk_en(0x1 << PM_CLK_GATE_REG_OFFSET_SATA);
+	
+		/* De-Asscer SATA Reset */
+		cns3xxx_pwr_soft_rst(CNS3XXX_PWR_SOFTWARE_RST(SATA));
+	}
+
+	dn = of_find_compatible_node(NULL, NULL, "cavium,cns3420-sdhci");
+	if (of_device_is_available(dn)) {
+		u32 __iomem *gpioa = IOMEM(CNS3XXX_MISC_BASE_VIRT + 0x0014);
+		u32 gpioa_pins = __raw_readl(gpioa);
+	
+		/* MMC/SD pins share with GPIOA */
+		gpioa_pins |= 0x1fff0004;
+		__raw_writel(gpioa_pins, gpioa);
+	
+		cns3xxx_pwr_clk_en(CNS3XXX_PWR_CLK_EN(SDIO));
+		cns3xxx_pwr_soft_rst(CNS3XXX_PWR_SOFTWARE_RST(SDIO));
+	}
+
+	pm_power_off = cns3xxx_power_off;
+
+	of_platform_populate(NULL, of_default_bus_match_table,
+                        cns3xxx_auxdata, NULL);
+}
+
+static const char *cns3xxx_dt_compat[] __initdata = {
+	"cavium,cns3410",
+	"cavium,cns3420",
+	NULL,
+};
+
+DT_MACHINE_START(CNS3XXX_DT, "Cavium Networks CNS3xxx")
+	.dt_compat	= cns3xxx_dt_compat,
+	.nr_irqs	= NR_IRQS_CNS3XXX,
+	.map_io		= cns3xxx_map_io,
+	.init_irq	= cns3xxx_init_irq,
+	.init_time	= cns3xxx_timer_init,
+	.init_machine	= cns3xxx_init,
+	.restart	= cns3xxx_restart,
+MACHINE_END

commit 3f9fb2a08f55c79b4c6cde423c1e8ddcc5a49781
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 13 13:15:25 2013 +0100

    ARM: cns3xxx: make mach header files local
    
    The mach/cns3xxx.h and mach/pm.h header files are used only
    in the platform code itself, so there is no need to make
    them globally visible. This gets us closer to multiplatform
    configuration for cns3xxx.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index e698f26cc0cb..012ffdb9e142 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -17,7 +17,7 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/hardware/cache-l2x0.h>
-#include <mach/cns3xxx.h>
+#include "cns3xxx.h"
 #include "core.h"
 
 static struct map_desc cns3xxx_io_desc[] __initdata = {

commit f8060f5446b1f2782f0a8ca9be2d870ea4198aee
Merge: 175dbc1eeadb 9e47b8bf9815
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 17:22:00 2013 -0800

    Merge tag 'gic-vic-to-irqchip' of git://sources.calxeda.com/kernel/linux into next/cleanup
    
    From Rob Herring:
    
    Initial irqchip init infrastructure and GIC and VIC clean-ups
    
    This creates irqchip initialization infrastructure from Thomas
    Petazzoni. The VIC and GIC irqchip code is moved to drivers/irqchips
    and adapted to use the new infrastructure. All DT enabled platforms
    using GIC and VIC are converted over to use the new irqchip_init.
    
    * tag 'gic-vic-to-irqchip' of git://sources.calxeda.com/kernel/linux:
      irqchip: Move ARM vic.h to include/linux/irqchip/arm-vic.h
      ARM: picoxcell: use common irqchip_init function
      ARM: spear: use common irqchip_init function
      irqchip: Move ARM VIC to drivers/irqchip
      ARM: samsung: remove unused tick.h
      ARM: remove unneeded vic.h includes
      ARM: remove mach .handle_irq for VIC users
      ARM: VIC: set handle_arch_irq in VIC initialization
      ARM: VIC: shrink down vic.h
      irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
      ARM: use common irqchip_init for GIC init
      irqchip: Move ARM GIC to drivers/irqchip
      ARM: remove mach .handle_irq for GIC users
      ARM: GIC: set handle_arch_irq in GIC initialization
      ARM: GIC: remove direct use of gic_raise_softirq
      ARM: GIC: remove assembly ifdefs from gic.h
      ARM: mach-ux500: use SGI0 to wake up the other core
      arm: add set_handle_irq() to register the parent IRQ controller handler function
      irqchip: add basic infrastructure
      irqchip: add to the directories part of the IRQ subsystem in MAINTAINERS
    
    Fixed up massive merge conflicts with the timer cleanup due to adjacent changes:
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-bcm/board_bcm.c
            arch/arm/mach-cns3xxx/cns3420vb.c
            arch/arm/mach-ep93xx/adssphere.c
            arch/arm/mach-ep93xx/edb93xx.c
            arch/arm/mach-ep93xx/gesbc9312.c
            arch/arm/mach-ep93xx/micro9.c
            arch/arm/mach-ep93xx/simone.c
            arch/arm/mach-ep93xx/snappercl15.c
            arch/arm/mach-ep93xx/ts72xx.c
            arch/arm/mach-ep93xx/vision_ep9307.c
            arch/arm/mach-highbank/highbank.c
            arch/arm/mach-imx/mach-imx6q.c
            arch/arm/mach-msm/board-dt-8960.c
            arch/arm/mach-netx/nxdb500.c
            arch/arm/mach-netx/nxdkn.c
            arch/arm/mach-netx/nxeb500hmi.c
            arch/arm/mach-nomadik/board-nhk8815.c
            arch/arm/mach-picoxcell/common.c
            arch/arm/mach-realview/realview_eb.c
            arch/arm/mach-realview/realview_pb1176.c
            arch/arm/mach-realview/realview_pb11mp.c
            arch/arm/mach-realview/realview_pba8.c
            arch/arm/mach-realview/realview_pbx.c
            arch/arm/mach-socfpga/socfpga.c
            arch/arm/mach-spear13xx/spear1310.c
            arch/arm/mach-spear13xx/spear1340.c
            arch/arm/mach-spear13xx/spear13xx.c
            arch/arm/mach-spear3xx/spear300.c
            arch/arm/mach-spear3xx/spear310.c
            arch/arm/mach-spear3xx/spear320.c
            arch/arm/mach-spear3xx/spear3xx.c
            arch/arm/mach-spear6xx/spear6xx.c
            arch/arm/mach-tegra/board-dt-tegra20.c
            arch/arm/mach-tegra/board-dt-tegra30.c
            arch/arm/mach-u300/core.c
            arch/arm/mach-ux500/board-mop500.c
            arch/arm/mach-ux500/cpu-db8500.c
            arch/arm/mach-versatile/versatile_ab.c
            arch/arm/mach-versatile/versatile_dt.c
            arch/arm/mach-versatile/versatile_pb.c
            arch/arm/mach-vexpress/v2m.c
            include/asm-generic/vmlinux.lds.h

commit 8d84981e395850aab31c3f2ca7e2738e03f671d7
Merge: 00c82d644056 77cc982f6a3b
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 10:20:02 2013 -0800

    Merge branch 'clocksource/cleanup' into next/cleanup
    
    Clockevent cleanup series from Shawn Guo.
    
    Resolved move/change conflict in mach-pxa/time.c due to the sys_timer
    cleanup.
    
    * clocksource/cleanup:
      clocksource: use clockevents_config_and_register() where possible
      ARM: use clockevents_config_and_register() where possible
      clockevents: export clockevents_config_and_register for module use
      + sync to Linux 3.8-rc3
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-pxa/time.c

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 031805b1428d..3eb74d1ba067 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -134,7 +134,6 @@ static int cns3xxx_timer_set_next_event(unsigned long evt,
 
 static struct clock_event_device cns3xxx_tmr1_clockevent = {
 	.name		= "cns3xxx timer1",
-	.shift		= 8,
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.set_mode	= cns3xxx_timer_set_mode,
 	.set_next_event	= cns3xxx_timer_set_next_event,
@@ -145,15 +144,9 @@ static struct clock_event_device cns3xxx_tmr1_clockevent = {
 static void __init cns3xxx_clockevents_init(unsigned int timer_irq)
 {
 	cns3xxx_tmr1_clockevent.irq = timer_irq;
-	cns3xxx_tmr1_clockevent.mult =
-		div_sc((cns3xxx_cpu_clock() >> 3) * 1000000, NSEC_PER_SEC,
-		       cns3xxx_tmr1_clockevent.shift);
-	cns3xxx_tmr1_clockevent.max_delta_ns =
-		clockevent_delta2ns(0xffffffff, &cns3xxx_tmr1_clockevent);
-	cns3xxx_tmr1_clockevent.min_delta_ns =
-		clockevent_delta2ns(0xf, &cns3xxx_tmr1_clockevent);
-
-	clockevents_register_device(&cns3xxx_tmr1_clockevent);
+	clockevents_config_and_register(&cns3xxx_tmr1_clockevent,
+					(cns3xxx_cpu_clock() >> 3) * 1000000,
+					0xf, 0xffffffff);
 }
 
 /*

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 031805b1428d..db3806c00f4b 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -12,10 +12,10 @@
 #include <linux/interrupt.h>
 #include <linux/clockchips.h>
 #include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
-#include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <mach/cns3xxx.h>
 #include "core.h"

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 031805b1428d..1754f8f4f34c 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -235,17 +235,13 @@ static void __init __cns3xxx_timer_init(unsigned int timer_irq)
 	cns3xxx_clockevents_init(timer_irq);
 }
 
-static void __init cns3xxx_timer_init(void)
+void __init cns3xxx_timer_init(void)
 {
 	cns3xxx_tmr1 = IOMEM(CNS3XXX_TIMER1_2_3_BASE_VIRT);
 
 	__cns3xxx_timer_init(IRQ_CNS3XXX_TIMER0);
 }
 
-struct sys_timer cns3xxx_timer = {
-	.init = cns3xxx_timer_init,
-};
-
 #ifdef CONFIG_CACHE_L2X0
 
 void __init cns3xxx_l2x0_init(void)

commit a2a47ca36642e3995e982957bc42678cf11ca6ac
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Mar 9 17:16:40 2012 -0600

    ARM: __io abuse cleanup
    
    Several platforms incorrectly use __io() for casting to 'void __iomem *'.
    This converts all of those uses to use the common IOMEM macro.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-sh@vger.kernel.org
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 941a308e1253..031805b1428d 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -72,13 +72,13 @@ void __init cns3xxx_map_io(void)
 /* used by entry-macro.S */
 void __init cns3xxx_init_irq(void)
 {
-	gic_init(0, 29, __io(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
-		 __io(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT));
+	gic_init(0, 29, IOMEM(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
+		 IOMEM(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT));
 }
 
 void cns3xxx_power_off(void)
 {
-	u32 __iomem *pm_base = __io(CNS3XXX_PM_BASE_VIRT);
+	u32 __iomem *pm_base = IOMEM(CNS3XXX_PM_BASE_VIRT);
 	u32 clkctrl;
 
 	printk(KERN_INFO "powering system down...\n");
@@ -237,7 +237,7 @@ static void __init __cns3xxx_timer_init(unsigned int timer_irq)
 
 static void __init cns3xxx_timer_init(void)
 {
-	cns3xxx_tmr1 = __io(CNS3XXX_TIMER1_2_3_BASE_VIRT);
+	cns3xxx_tmr1 = IOMEM(CNS3XXX_TIMER1_2_3_BASE_VIRT);
 
 	__cns3xxx_timer_init(IRQ_CNS3XXX_TIMER0);
 }

commit 93e85d8e902e1a4468c6ade5c6ec3dd3055a489f
Author: Anton Vorontsov <avorontsov@mvista.com>
Date:   Wed Jul 6 16:45:09 2011 +0400

    ARM: cns3xxx: Add support for L2 Cache Controller
    
    CNS3xxx SOCs have L310-compatible cache controller, so let's use it.
    
    With this patch benchmarking with 'gzip' shows that performance is
    doubled, and I'm still able to boot full-fledged userland over NFS
    (using PCIe NIC), so the support should be pretty robust.
    
    p.s. While CNS3xxx reports that it has PL310, it still needs to wait
    on cache line operations, so we should not select 'CACHE_PL310',
    which is a micro-optimization that removes these waits for v7 CPUs.
    Someday we'd better rename CACHE_PL310 Kconfig option into
    NO_CACHE_WAIT or something less ambiguous.
    
    Signed-off-by: Anton Vorontsov <avorontsov@mvista.com>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index da30078a80c1..941a308e1253 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -16,6 +16,7 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
 #include <mach/cns3xxx.h>
 #include "core.h"
 
@@ -244,3 +245,45 @@ static void __init cns3xxx_timer_init(void)
 struct sys_timer cns3xxx_timer = {
 	.init = cns3xxx_timer_init,
 };
+
+#ifdef CONFIG_CACHE_L2X0
+
+void __init cns3xxx_l2x0_init(void)
+{
+	void __iomem *base = ioremap(CNS3XXX_L2C_BASE, SZ_4K);
+	u32 val;
+
+	if (WARN_ON(!base))
+		return;
+
+	/*
+	 * Tag RAM Control register
+	 *
+	 * bit[10:8]	- 1 cycle of write accesses latency
+	 * bit[6:4]	- 1 cycle of read accesses latency
+	 * bit[3:0]	- 1 cycle of setup latency
+	 *
+	 * 1 cycle of latency for setup, read and write accesses
+	 */
+	val = readl(base + L2X0_TAG_LATENCY_CTRL);
+	val &= 0xfffff888;
+	writel(val, base + L2X0_TAG_LATENCY_CTRL);
+
+	/*
+	 * Data RAM Control register
+	 *
+	 * bit[10:8]	- 1 cycles of write accesses latency
+	 * bit[6:4]	- 1 cycles of read accesses latency
+	 * bit[3:0]	- 1 cycle of setup latency
+	 *
+	 * 1 cycle of latency for setup, read and write accesses
+	 */
+	val = readl(base + L2X0_DATA_LATENCY_CTRL);
+	val &= 0xfffff888;
+	writel(val, base + L2X0_DATA_LATENCY_CTRL);
+
+	/* 32 KiB, 8-way, parity disable */
+	l2x0_init(base, 0x00540000, 0xfe000fff);
+}
+
+#endif /* CONFIG_CACHE_L2X0 */

commit ff2e27ae0b17f53a6a289c87d325f706598f3788
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 4 16:13:29 2010 +0000

    ARM: GIC: consolidate gic_cpu_base_addr to common GIC code
    
    Every architecture using the GIC has a gic_cpu_base_addr pointer for
    GIC 0 for their entry assembly code to use to decode the cause of the
    current interrupt.  Move this into the common GIC code.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index e9c491552ca1..da30078a80c1 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -69,13 +69,10 @@ void __init cns3xxx_map_io(void)
 }
 
 /* used by entry-macro.S */
-void __iomem *gic_cpu_base_addr;
-
 void __init cns3xxx_init_irq(void)
 {
-	gic_cpu_base_addr = __io(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT);
 	gic_init(0, 29, __io(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
-		gic_cpu_base_addr);
+		 __io(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT));
 }
 
 void cns3xxx_power_off(void)

commit b580b899dd05a007ad232ee49a07b32d91876462
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 4 15:55:14 2010 +0000

    ARM: GIC: provide a single initialization function for boot CPU
    
    Provide gic_init() which initializes the GIC distributor and current
    CPU's GIC interface for the boot (or single) CPU.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
index 9ca4d581016f..e9c491552ca1 100644
--- a/arch/arm/mach-cns3xxx/core.c
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -74,8 +74,8 @@ void __iomem *gic_cpu_base_addr;
 void __init cns3xxx_init_irq(void)
 {
 	gic_cpu_base_addr = __io(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT);
-	gic_dist_init(0, __io(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT), 29);
-	gic_cpu_init(0, gic_cpu_base_addr);
+	gic_init(0, 29, __io(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT),
+		gic_cpu_base_addr);
 }
 
 void cns3xxx_power_off(void)

commit d94f944e108da21badabd99f527b25e03b677b96
Author: Anton Vorontsov <avorontsov@mvista.com>
Date:   Thu Mar 25 17:12:41 2010 +0300

    ARM: cns3xxx: Add basic support for Cavium Networks CNS3xxx processors
    
    This patch adds very basic support for ECONA CNS3xxx ARM11 MPcore
    (ARMv6) dual-core processors.
    
    Note that SMP is not yet supported, as well as many peripheral
    devices. Support for these features will be added later.
    
    Signed-off-by: Anton Vorontsov <avorontsov@mvista.com>

diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c
new file mode 100644
index 000000000000..9ca4d581016f
--- /dev/null
+++ b/arch/arm/mach-cns3xxx/core.c
@@ -0,0 +1,249 @@
+/*
+ * Copyright 1999 - 2003 ARM Limited
+ * Copyright 2000 Deep Blue Solutions Ltd
+ * Copyright 2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/hardware/gic.h>
+#include <mach/cns3xxx.h>
+#include "core.h"
+
+static struct map_desc cns3xxx_io_desc[] __initdata = {
+	{
+		.virtual	= CNS3XXX_TC11MP_TWD_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_TWD_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_GIC_CPU_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_GIC_DIST_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_TIMER1_2_3_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_TIMER1_2_3_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_GPIOA_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_GPIOA_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_GPIOB_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_GPIOB_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_MISC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_MISC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_PM_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_PM_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init cns3xxx_map_io(void)
+{
+	iotable_init(cns3xxx_io_desc, ARRAY_SIZE(cns3xxx_io_desc));
+}
+
+/* used by entry-macro.S */
+void __iomem *gic_cpu_base_addr;
+
+void __init cns3xxx_init_irq(void)
+{
+	gic_cpu_base_addr = __io(CNS3XXX_TC11MP_GIC_CPU_BASE_VIRT);
+	gic_dist_init(0, __io(CNS3XXX_TC11MP_GIC_DIST_BASE_VIRT), 29);
+	gic_cpu_init(0, gic_cpu_base_addr);
+}
+
+void cns3xxx_power_off(void)
+{
+	u32 __iomem *pm_base = __io(CNS3XXX_PM_BASE_VIRT);
+	u32 clkctrl;
+
+	printk(KERN_INFO "powering system down...\n");
+
+	clkctrl = readl(pm_base + PM_SYS_CLK_CTRL_OFFSET);
+	clkctrl &= 0xfffff1ff;
+	clkctrl |= (0x5 << 9);		/* Hibernate */
+	writel(clkctrl, pm_base + PM_SYS_CLK_CTRL_OFFSET);
+
+}
+
+/*
+ * Timer
+ */
+static void __iomem *cns3xxx_tmr1;
+
+static void cns3xxx_timer_set_mode(enum clock_event_mode mode,
+				   struct clock_event_device *clk)
+{
+	unsigned long ctrl = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	int pclk = cns3xxx_cpu_clock() / 8;
+	int reload;
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		reload = pclk * 20 / (3 * HZ) * 0x25000;
+		writel(reload, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
+		ctrl |= (1 << 0) | (1 << 2) | (1 << 9);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		ctrl |= (1 << 2) | (1 << 9);
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	writel(ctrl, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+}
+
+static int cns3xxx_timer_set_next_event(unsigned long evt,
+					struct clock_event_device *unused)
+{
+	unsigned long ctrl = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+
+	writel(evt, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
+	writel(ctrl | (1 << 0), cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+
+	return 0;
+}
+
+static struct clock_event_device cns3xxx_tmr1_clockevent = {
+	.name		= "cns3xxx timer1",
+	.shift		= 8,
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= cns3xxx_timer_set_mode,
+	.set_next_event	= cns3xxx_timer_set_next_event,
+	.rating		= 350,
+	.cpumask	= cpu_all_mask,
+};
+
+static void __init cns3xxx_clockevents_init(unsigned int timer_irq)
+{
+	cns3xxx_tmr1_clockevent.irq = timer_irq;
+	cns3xxx_tmr1_clockevent.mult =
+		div_sc((cns3xxx_cpu_clock() >> 3) * 1000000, NSEC_PER_SEC,
+		       cns3xxx_tmr1_clockevent.shift);
+	cns3xxx_tmr1_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &cns3xxx_tmr1_clockevent);
+	cns3xxx_tmr1_clockevent.min_delta_ns =
+		clockevent_delta2ns(0xf, &cns3xxx_tmr1_clockevent);
+
+	clockevents_register_device(&cns3xxx_tmr1_clockevent);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t cns3xxx_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &cns3xxx_tmr1_clockevent;
+	u32 __iomem *stat = cns3xxx_tmr1 + TIMER1_2_INTERRUPT_STATUS_OFFSET;
+	u32 val;
+
+	/* Clear the interrupt */
+	val = readl(stat);
+	writel(val & ~(1 << 2), stat);
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction cns3xxx_timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= cns3xxx_timer_interrupt,
+};
+
+/*
+ * Set up the clock source and clock events devices
+ */
+static void __init __cns3xxx_timer_init(unsigned int timer_irq)
+{
+	u32 val;
+	u32 irq_mask;
+
+	/*
+	 * Initialise to a known state (all timers off)
+	 */
+
+	/* disable timer1 and timer2 */
+	writel(0, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	/* stop free running timer3 */
+	writel(0, cns3xxx_tmr1 + TIMER_FREERUN_CONTROL_OFFSET);
+
+	/* timer1 */
+	writel(0x5C800, cns3xxx_tmr1 + TIMER1_COUNTER_OFFSET);
+	writel(0x5C800, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
+
+	writel(0, cns3xxx_tmr1 + TIMER1_MATCH_V1_OFFSET);
+	writel(0, cns3xxx_tmr1 + TIMER1_MATCH_V2_OFFSET);
+
+	/* mask irq, non-mask timer1 overflow */
+	irq_mask = readl(cns3xxx_tmr1 + TIMER1_2_INTERRUPT_MASK_OFFSET);
+	irq_mask &= ~(1 << 2);
+	irq_mask |= 0x03;
+	writel(irq_mask, cns3xxx_tmr1 + TIMER1_2_INTERRUPT_MASK_OFFSET);
+
+	/* down counter */
+	val = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	val |= (1 << 9);
+	writel(val, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+
+	/* timer2 */
+	writel(0, cns3xxx_tmr1 + TIMER2_MATCH_V1_OFFSET);
+	writel(0, cns3xxx_tmr1 + TIMER2_MATCH_V2_OFFSET);
+
+	/* mask irq */
+	irq_mask = readl(cns3xxx_tmr1 + TIMER1_2_INTERRUPT_MASK_OFFSET);
+	irq_mask |= ((1 << 3) | (1 << 4) | (1 << 5));
+	writel(irq_mask, cns3xxx_tmr1 + TIMER1_2_INTERRUPT_MASK_OFFSET);
+
+	/* down counter */
+	val = readl(cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+	val |= (1 << 10);
+	writel(val, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
+
+	/* Make irqs happen for the system timer */
+	setup_irq(timer_irq, &cns3xxx_timer_irq);
+
+	cns3xxx_clockevents_init(timer_irq);
+}
+
+static void __init cns3xxx_timer_init(void)
+{
+	cns3xxx_tmr1 = __io(CNS3XXX_TIMER1_2_3_BASE_VIRT);
+
+	__cns3xxx_timer_init(IRQ_CNS3XXX_TIMER0);
+}
+
+struct sys_timer cns3xxx_timer = {
+	.init = cns3xxx_timer_init,
+};
