commit d193631bfb383d7503a1a72fe1643ac2168bbba7
Author: Punit Agrawal <punit.agrawal@arm.com>
Date:   Tue Aug 28 16:05:13 2018 +0100

    x86/PCI: Remove node-local allocation when initialising host controller
    
    Memory for host controller data structures is allocated local to the node
    to which the controller is associated with.  This has been the behaviour
    since 965cd0e4a5e5 ("x86, PCI, ACPI: Use kmalloc_node() to optimize for
    performance") where the node local allocation was added without additional
    context.
    
    Drop the node local allocation as there is no benefit from doing so - the
    usage of these structures is independent from where the controller is
    located.
    
    Signed-off-by: Punit Agrawal <punit.agrawal@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 5559dcaddd5e..948656069cdd 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -356,7 +356,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	} else {
 		struct pci_root_info *info;
 
-		info = kzalloc_node(sizeof(*info), GFP_KERNEL, node);
+		info = kzalloc(sizeof(*info), GFP_KERNEL);
 		if (!info)
 			dev_err(&root->device->dev,
 				"pci_bus %04x:%02x: ignored (out of memory)\n",

commit 47a9973d3ed8994589c845c8b1a293a475a549a9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 20 20:08:00 2018 +0200

    x86/PCI: Fix a potential regression when using dmi_get_bios_year()
    
    dmi_get_bios_year() may return 0 when it cannot parse
    the BIOS date string. Previously this has been checked in
    pci_acpi_crs_quirks().
    
    Update the code to restore old behaviour.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J . Wysocki <rjw@rjwysocki.net>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Fixes: 69c42d493db4 ("x86/pci: Simplify code by using the new dmi_get_bios_year() helper")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 00e60de30328..5559dcaddd5e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -140,7 +140,9 @@ static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 
 void __init pci_acpi_crs_quirks(void)
 {
-	if ((dmi_get_bios_year() < 2008) && (iomem_resource.end <= 0xffffffff))
+	int year = dmi_get_bios_year();
+
+	if (year >= 0 && year < 2008 && iomem_resource.end <= 0xffffffff)
 		pci_use_crs = false;
 
 	dmi_check_system(pci_crs_quirks);

commit 69c42d493db452ea87c1ac56e83c978512f4e6ec
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Feb 22 14:59:21 2018 +0200

    x86/pci: Simplify code by using the new dmi_get_bios_year() helper
    
    ...instead of open coding its functionality.
    
    No changes in functionality.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180222125923.57385-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 7df49c40665e..00e60de30328 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -140,12 +140,8 @@ static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 
 void __init pci_acpi_crs_quirks(void)
 {
-	int year;
-
-	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008) {
-		if (iomem_resource.end <= 0xffffffff)
-			pci_use_crs = false;
-	}
+	if ((dmi_get_bios_year() < 2008) && (iomem_resource.end <= 0xffffffff))
+		pci_use_crs = false;
 
 	dmi_check_system(pci_crs_quirks);
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 3961103e9176..7df49c40665e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/pci.h>
 #include <linux/acpi.h>
 #include <linux/init.h>

commit 89e9f7bcd8744ea25fcf0ac671b8d72c10d7d790
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 28 14:55:16 2016 -0600

    x86/PCI: Ignore _CRS on Supermicro X8DTH-i/6/iF/6F
    
    Martin reported that the Supermicro X8DTH-i/6/iF/6F advertises incorrect
    host bridge windows via _CRS:
    
      pci_root PNP0A08:00: host bridge window [io  0xf000-0xffff]
      pci_root PNP0A08:01: host bridge window [io  0xf000-0xffff]
    
    Both bridges advertise the 0xf000-0xffff window, which cannot be correct.
    
    Work around this by ignoring _CRS on this system.  The downside is that we
    may not assign resources correctly to hot-added PCI devices (if they are
    possible on this system).
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=42606
    Reported-by: Martin Burnicki <martin.burnicki@meinberg.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 3cd69832d7f4..3961103e9176 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -114,6 +114,16 @@ static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VERSION, "6JET85WW (1.43 )"),
 		},
 	},
+	/* https://bugzilla.kernel.org/show_bug.cgi?id=42606 */
+	{
+		.callback = set_nouse_crs,
+		.ident = "Supermicro X8DTH",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Supermicro"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "X8DTH-i/6/iF/6F"),
+			DMI_MATCH(DMI_BIOS_VERSION, "2.0a"),
+		},
+	},
 
 	/* https://bugzilla.kernel.org/show_bug.cgi?id=15362 */
 	{

commit 4d6b4e69a245e9df4b84dba387596086cb66887d
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Oct 14 14:29:41 2015 +0800

    x86/PCI/ACPI: Use common interface to support PCI host bridge
    
    Use common interface to simplify ACPI PCI host bridge implementation.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 5bc018559cc4..3cd69832d7f4 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -4,16 +4,15 @@
 #include <linux/irq.h>
 #include <linux/dmi.h>
 #include <linux/slab.h>
+#include <linux/pci-acpi.h>
 #include <asm/numa.h>
 #include <asm/pci_x86.h>
 
 struct pci_root_info {
-	struct acpi_device *bridge;
-	char name[16];
+	struct acpi_pci_root_info common;
 	struct pci_sysdata sd;
 #ifdef	CONFIG_PCI_MMCONFIG
 	bool mcfg_added;
-	u16 segment;
 	u8 start_bus;
 	u8 end_bus;
 #endif
@@ -178,15 +177,18 @@ static int check_segment(u16 seg, struct device *dev, char *estr)
 	return 0;
 }
 
-static int setup_mcfg_map(struct pci_root_info *info, u16 seg, u8 start,
-			  u8 end, phys_addr_t addr)
+static int setup_mcfg_map(struct acpi_pci_root_info *ci)
 {
-	int result;
-	struct device *dev = &info->bridge->dev;
+	int result, seg;
+	struct pci_root_info *info;
+	struct acpi_pci_root *root = ci->root;
+	struct device *dev = &ci->bridge->dev;
 
-	info->start_bus = start;
-	info->end_bus = end;
+	info = container_of(ci, struct pci_root_info, common);
+	info->start_bus = (u8)root->secondary.start;
+	info->end_bus = (u8)root->secondary.end;
 	info->mcfg_added = false;
+	seg = info->sd.domain;
 
 	/* return success if MMCFG is not in use */
 	if (raw_pci_ext_ops && raw_pci_ext_ops != &pci_mmcfg)
@@ -195,7 +197,8 @@ static int setup_mcfg_map(struct pci_root_info *info, u16 seg, u8 start,
 	if (!(pci_probe & PCI_PROBE_MMCONF))
 		return check_segment(seg, dev, "MMCONFIG is disabled,");
 
-	result = pci_mmconfig_insert(dev, seg, start, end, addr);
+	result = pci_mmconfig_insert(dev, seg, info->start_bus, info->end_bus,
+				     root->mcfg_addr);
 	if (result == 0) {
 		/* enable MMCFG if it hasn't been enabled yet */
 		if (raw_pci_ext_ops == NULL)
@@ -208,134 +211,55 @@ static int setup_mcfg_map(struct pci_root_info *info, u16 seg, u8 start,
 	return 0;
 }
 
-static void teardown_mcfg_map(struct pci_root_info *info)
+static void teardown_mcfg_map(struct acpi_pci_root_info *ci)
 {
+	struct pci_root_info *info;
+
+	info = container_of(ci, struct pci_root_info, common);
 	if (info->mcfg_added) {
-		pci_mmconfig_delete(info->segment, info->start_bus,
-				    info->end_bus);
+		pci_mmconfig_delete(info->sd.domain,
+				    info->start_bus, info->end_bus);
 		info->mcfg_added = false;
 	}
 }
 #else
-static int setup_mcfg_map(struct pci_root_info *info,
-				    u16 seg, u8 start, u8 end,
-				    phys_addr_t addr)
+static int setup_mcfg_map(struct acpi_pci_root_info *ci)
 {
 	return 0;
 }
-static void teardown_mcfg_map(struct pci_root_info *info)
+
+static void teardown_mcfg_map(struct acpi_pci_root_info *ci)
 {
 }
 #endif
 
-static void validate_resources(struct device *dev, struct list_head *crs_res,
-			       unsigned long type)
+static int pci_acpi_root_get_node(struct acpi_pci_root *root)
 {
-	LIST_HEAD(list);
-	struct resource *res1, *res2, *root = NULL;
-	struct resource_entry *tmp, *entry, *entry2;
-
-	BUG_ON((type & (IORESOURCE_MEM | IORESOURCE_IO)) == 0);
-	root = (type & IORESOURCE_MEM) ? &iomem_resource : &ioport_resource;
-
-	list_splice_init(crs_res, &list);
-	resource_list_for_each_entry_safe(entry, tmp, &list) {
-		bool free = false;
-		resource_size_t end;
-
-		res1 = entry->res;
-		if (!(res1->flags & type))
-			goto next;
-
-		/* Exclude non-addressable range or non-addressable portion */
-		end = min(res1->end, root->end);
-		if (end <= res1->start) {
-			dev_info(dev, "host bridge window %pR (ignored, not CPU addressable)\n",
-				 res1);
-			free = true;
-			goto next;
-		} else if (res1->end != end) {
-			dev_info(dev, "host bridge window %pR ([%#llx-%#llx] ignored, not CPU addressable)\n",
-				 res1, (unsigned long long)end + 1,
-				 (unsigned long long)res1->end);
-			res1->end = end;
-		}
-
-		resource_list_for_each_entry(entry2, crs_res) {
-			res2 = entry2->res;
-			if (!(res2->flags & type))
-				continue;
-
-			/*
-			 * I don't like throwing away windows because then
-			 * our resources no longer match the ACPI _CRS, but
-			 * the kernel resource tree doesn't allow overlaps.
-			 */
-			if (resource_overlaps(res1, res2)) {
-				res2->start = min(res1->start, res2->start);
-				res2->end = max(res1->end, res2->end);
-				dev_info(dev, "host bridge window expanded to %pR; %pR ignored\n",
-					 res2, res1);
-				free = true;
-				goto next;
-			}
-		}
+	int busnum = root->secondary.start;
+	struct acpi_device *device = root->device;
+	int node = acpi_get_node(device->handle);
 
-next:
-		resource_list_del(entry);
-		if (free)
-			resource_list_free_entry(entry);
-		else
-			resource_list_add_tail(entry, crs_res);
+	if (node == NUMA_NO_NODE) {
+		node = x86_pci_root_bus_node(busnum);
+		if (node != 0 && node != NUMA_NO_NODE)
+			dev_info(&device->dev, FW_BUG "no _PXM; falling back to node %d from hardware (may be inconsistent with ACPI node numbers)\n",
+				node);
 	}
+	if (node != NUMA_NO_NODE && !node_online(node))
+		node = NUMA_NO_NODE;
+
+	return node;
 }
 
-static void add_resources(struct pci_root_info *info,
-			  struct list_head *resources,
-			  struct list_head *crs_res)
+static int pci_acpi_root_init_info(struct acpi_pci_root_info *ci)
 {
-	struct resource_entry *entry, *tmp;
-	struct resource *res, *conflict, *root = NULL;
-
-	validate_resources(&info->bridge->dev, crs_res, IORESOURCE_MEM);
-	validate_resources(&info->bridge->dev, crs_res, IORESOURCE_IO);
-
-	resource_list_for_each_entry_safe(entry, tmp, crs_res) {
-		res = entry->res;
-		if (res->flags & IORESOURCE_MEM)
-			root = &iomem_resource;
-		else if (res->flags & IORESOURCE_IO)
-			root = &ioport_resource;
-		else
-			BUG_ON(res);
-
-		conflict = insert_resource_conflict(root, res);
-		if (conflict) {
-			dev_info(&info->bridge->dev,
-				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
-				 res, conflict->name, conflict);
-			resource_list_destroy_entry(entry);
-		}
-	}
-
-	list_splice_tail(crs_res, resources);
+	return setup_mcfg_map(ci);
 }
 
-static void release_pci_root_info(struct pci_host_bridge *bridge)
+static void pci_acpi_root_release_info(struct acpi_pci_root_info *ci)
 {
-	struct resource *res;
-	struct resource_entry *entry;
-	struct pci_root_info *info = bridge->release_data;
-
-	resource_list_for_each_entry(entry, &bridge->windows) {
-		res = entry->res;
-		if (res->parent &&
-		    (res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))
-			release_resource(res);
-	}
-
-	teardown_mcfg_map(info);
-	kfree(info);
+	teardown_mcfg_map(ci);
+	kfree(container_of(ci, struct pci_root_info, common));
 }
 
 /*
@@ -358,47 +282,44 @@ static bool resource_is_pcicfg_ioport(struct resource *res)
 		res->start == 0xCF8 && res->end == 0xCFF;
 }
 
-static void probe_pci_root_info(struct pci_root_info *info,
-				struct acpi_device *device,
-				int busnum, int domain,
-				struct list_head *list)
+static int pci_acpi_root_prepare_resources(struct acpi_pci_root_info *ci)
 {
-	int ret;
+	struct acpi_device *device = ci->bridge;
+	int busnum = ci->root->secondary.start;
 	struct resource_entry *entry, *tmp;
+	int status;
 
-	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
-	info->bridge = device;
-	ret = acpi_dev_get_resources(device, list,
-				     acpi_dev_filter_resource_type_cb,
-				     (void *)(IORESOURCE_IO | IORESOURCE_MEM));
-	if (ret < 0)
-		dev_warn(&device->dev,
-			 "failed to parse _CRS method, error code %d\n", ret);
-	else if (ret == 0)
-		dev_dbg(&device->dev,
-			"no IO and memory resources present in _CRS\n");
-	else
-		resource_list_for_each_entry_safe(entry, tmp, list) {
-			if ((entry->res->flags & IORESOURCE_DISABLED) ||
-			    resource_is_pcicfg_ioport(entry->res))
+	status = acpi_pci_probe_root_resources(ci);
+	if (pci_use_crs) {
+		resource_list_for_each_entry_safe(entry, tmp, &ci->resources)
+			if (resource_is_pcicfg_ioport(entry->res))
 				resource_list_destroy_entry(entry);
-			else
-				entry->res->name = info->name;
-		}
+		return status;
+	}
+
+	resource_list_for_each_entry_safe(entry, tmp, &ci->resources) {
+		dev_printk(KERN_DEBUG, &device->dev,
+			   "host bridge window %pR (ignored)\n", entry->res);
+		resource_list_destroy_entry(entry);
+	}
+	x86_pci_root_bus_resources(busnum, &ci->resources);
+
+	return 0;
 }
 
+static struct acpi_pci_root_ops acpi_pci_root_ops = {
+	.pci_ops = &pci_root_ops,
+	.init_info = pci_acpi_root_init_info,
+	.release_info = pci_acpi_root_release_info,
+	.prepare_resources = pci_acpi_root_prepare_resources,
+};
+
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
-	struct acpi_device *device = root->device;
-	struct pci_root_info *info;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
-	struct resource_entry *res_entry;
-	LIST_HEAD(crs_res);
-	LIST_HEAD(resources);
+	int node = pci_acpi_root_get_node(root);
 	struct pci_bus *bus;
-	struct pci_sysdata *sd;
-	int node;
 
 	if (pci_ignore_seg)
 		root->segment = domain = 0;
@@ -410,71 +331,33 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		return NULL;
 	}
 
-	node = acpi_get_node(device->handle);
-	if (node == NUMA_NO_NODE) {
-		node = x86_pci_root_bus_node(busnum);
-		if (node != 0 && node != NUMA_NO_NODE)
-			dev_info(&device->dev, FW_BUG "no _PXM; falling back to node %d from hardware (may be inconsistent with ACPI node numbers)\n",
-				node);
-	}
-
-	if (node != NUMA_NO_NODE && !node_online(node))
-		node = NUMA_NO_NODE;
-
-	info = kzalloc_node(sizeof(*info), GFP_KERNEL, node);
-	if (!info) {
-		printk(KERN_WARNING "pci_bus %04x:%02x: "
-		       "ignored (out of memory)\n", domain, busnum);
-		return NULL;
-	}
-
-	sd = &info->sd;
-	sd->domain = domain;
-	sd->node = node;
-	sd->companion = device;
-
 	bus = pci_find_bus(domain, busnum);
 	if (bus) {
 		/*
 		 * If the desired bus has been scanned already, replace
 		 * its bus->sysdata.
 		 */
-		memcpy(bus->sysdata, sd, sizeof(*sd));
-		kfree(info);
-	} else {
-		/* insert busn res at first */
-		pci_add_resource(&resources,  &root->secondary);
+		struct pci_sysdata sd = {
+			.domain = domain,
+			.node = node,
+			.companion = root->device
+		};
 
-		/*
-		 * _CRS with no apertures is normal, so only fall back to
-		 * defaults or native bridge info if we're ignoring _CRS.
-		 */
-		probe_pci_root_info(info, device, busnum, domain, &crs_res);
-		if (pci_use_crs) {
-			add_resources(info, &resources, &crs_res);
-		} else {
-			resource_list_for_each_entry(res_entry, &crs_res)
-				dev_printk(KERN_DEBUG, &device->dev,
-					   "host bridge window %pR (ignored)\n",
-					   res_entry->res);
-			resource_list_free(&crs_res);
-			x86_pci_root_bus_resources(busnum, &resources);
-		}
-
-		if (!setup_mcfg_map(info, domain, (u8)root->secondary.start,
-				    (u8)root->secondary.end, root->mcfg_addr))
-			bus = pci_create_root_bus(NULL, busnum, &pci_root_ops,
-						  sd, &resources);
-
-		if (bus) {
-			pci_scan_child_bus(bus);
-			pci_set_host_bridge_release(
-				to_pci_host_bridge(bus->bridge),
-				release_pci_root_info, info);
-		} else {
-			resource_list_free(&resources);
-			teardown_mcfg_map(info);
-			kfree(info);
+		memcpy(bus->sysdata, &sd, sizeof(sd));
+	} else {
+		struct pci_root_info *info;
+
+		info = kzalloc_node(sizeof(*info), GFP_KERNEL, node);
+		if (!info)
+			dev_err(&root->device->dev,
+				"pci_bus %04x:%02x: ignored (out of memory)\n",
+				domain, busnum);
+		else {
+			info->sd.domain = domain;
+			info->sd.node = node;
+			info->sd.companion = root->device;
+			bus = acpi_pci_root_create(root, &acpi_pci_root_ops,
+						   &info->common, &info->sd);
 		}
 	}
 
@@ -487,9 +370,6 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 			pcie_bus_configure_settings(child);
 	}
 
-	if (bus && node != NUMA_NO_NODE)
-		dev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);
-
 	return bus;
 }
 

commit a3669868d99c8647d780895d83e74d9a921eba2b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Oct 14 14:29:40 2015 +0800

    ACPI/PCI: Reset acpi_root_dev->domain to 0 when pci_ignore_seg is set
    
    Reset acpi_root_dev->domain to 0 when pci_ignore_seg is set to keep
    consistence between ACPI PCI root device and PCI host bridge device.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index ff9911707160..5bc018559cc4 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -401,7 +401,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	int node;
 
 	if (pci_ignore_seg)
-		domain = 0;
+		root->segment = domain = 0;
 
 	if (domain && !pci_domains_supported) {
 		printk(KERN_WARNING "pci_bus %04x:%02x: "

commit d8133356e99713bd023b229de107ddd6dd6d375a
Merge: 234a56c80a6a 207b074f82c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 23 13:41:24 2015 -0700

    Merge tag 'pci-v4.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.2 merge window:
    
      Enumeration
        - Move pci_ari_enabled() to global header (Alex Williamson)
        - Account for ARI in _PRT lookups (Alex Williamson)
        - Remove unused pci_scan_bus_parented() (Yijing Wang)
    
      Resource management
        - Use host bridge _CRS info on systems with >32 bit addressing (Bjorn Helgaas)
        - Use host bridge _CRS info on Foxconn K8M890-8237A (Bjorn Helgaas)
        - Fix pci_address_to_pio() conversion of CPU address to I/O port (Zhichang Yuan)
        - Add pci_bus_addr_t (Yinghai Lu)
    
      PCI device hotplug
        - Wait for pciehp command completion where necessary (Alex Williamson)
        - Drop pointless ACPI-based "slot detection" check (Rafael J. Wysocki)
        - Check ignore_hotplug for all downstream devices (Rafael J. Wysocki)
        - Propagate the "ignore hotplug" setting to parent (Rafael J. Wysocki)
        - Inline pciehp "handle event" functions into the ISR (Bjorn Helgaas)
        - Clean up pciehp debug logging (Bjorn Helgaas)
    
      Power management
        - Remove redundant PCIe port type checking (Yijing Wang)
        - Add dev->has_secondary_link to track downstream PCIe links (Yijing Wang)
        - Use dev->has_secondary_link to find downstream links for ASPM (Yijing Wang)
        - Drop __pci_disable_link_state() useless "force" parameter (Bjorn Helgaas)
        - Simplify Clock Power Management setting (Bjorn Helgaas)
    
      Virtualization
        - Add ACS quirks for Intel 9-series PCH root ports (Alex Williamson)
        - Add function 1 DMA alias quirk for Marvell 9120 (Sakari Ailus)
    
      MSI
        - Disable MSI at enumeration even if kernel doesn't support MSI (Michael S. Tsirkin)
        - Remove unused pci_msi_off() (Bjorn Helgaas)
        - Rename msi_set_enable(), msix_clear_and_set_ctrl() (Michael S.  Tsirkin)
        - Export pci_msi_set_enable(), pci_msix_clear_and_set_ctrl() (Michael S. Tsirkin)
        - Drop pci_msi_off() calls during probe (Michael S. Tsirkin)
    
      APM X-Gene host bridge driver
        - Add APM X-Gene v1 PCIe MSI/MSIX termination driver (Duc Dang)
        - Add APM X-Gene PCIe MSI DTS nodes (Duc Dang)
        - Disable Configuration Request Retry Status for v1 silicon (Duc Dang)
        - Allow config access to Root Port even when link is down (Duc Dang)
    
      Broadcom iProc host bridge driver
        - Allow override of device tree IRQ mapping function (Hauke Mehrtens)
        - Add BCMA PCIe driver (Hauke Mehrtens)
        - Directly add PCI resources (Hauke Mehrtens)
        - Free resource list after registration (Hauke Mehrtens)
    
      Freescale i.MX6 host bridge driver
        - Add speed change timeout message (Troy Kisky)
        - Rename imx6_pcie_start_link() to imx6_pcie_establish_link() (Bjorn Helgaas)
    
      Freescale Layerscape host bridge driver
        - Use dw_pcie_link_up() consistently (Bjorn Helgaas)
        - Factor out ls_pcie_establish_link() (Bjorn Helgaas)
    
      Marvell MVEBU host bridge driver
        - Remove mvebu_pcie_scan_bus() (Yijing Wang)
    
      NVIDIA Tegra host bridge driver
        - Remove tegra_pcie_scan_bus() (Yijing Wang)
    
      Synopsys DesignWare host bridge driver
        - Consolidate outbound iATU programming functions (Jisheng Zhang)
        - Use iATU0 for cfg and IO, iATU1 for MEM (Jisheng Zhang)
        - Add support for x8 links (Zhou Wang)
        - Wait for link to come up with consistent style (Bjorn Helgaas)
        - Use pci_scan_root_bus() for simplicity (Yijing Wang)
    
      TI DRA7xx host bridge driver
        - Use dw_pcie_link_up() consistently (Bjorn Helgaas)
    
      Miscellaneous
        - Include <linux/pci.h>, not <asm/pci.h> (Bjorn Helgaas)
        - Remove unnecessary #includes of <asm/pci.h> (Bjorn Helgaas)
        - Remove unused pcibios_select_root() (again) (Bjorn Helgaas)
        - Remove unused pci_dma_burst_advice() (Bjorn Helgaas)
        - xen/pcifront: Don't use deprecated function pci_scan_bus_parented() (Arnd Bergmann)"
    
    * tag 'pci-v4.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (58 commits)
      PCI: pciehp: Inline the "handle event" functions into the ISR
      PCI: pciehp: Rename queue_interrupt_event() to pciehp_queue_interrupt_event()
      PCI: pciehp: Make queue_interrupt_event() void
      PCI: xgene: Allow config access to Root Port even when link is down
      PCI: xgene: Disable Configuration Request Retry Status for v1 silicon
      PCI: pciehp: Clean up debug logging
      x86/PCI: Use host bridge _CRS info on systems with >32 bit addressing
      PCI: imx6: Add #define PCIE_RC_LCSR
      PCI: imx6: Use "u32", not "uint32_t"
      PCI: Remove unused pci_scan_bus_parented()
      xen/pcifront: Don't use deprecated function pci_scan_bus_parented()
      PCI: imx6: Add speed change timeout message
      PCI/ASPM: Simplify Clock Power Management setting
      PCI: designware: Wait for link to come up with consistent style
      PCI: layerscape: Factor out ls_pcie_establish_link()
      PCI: layerscape: Use dw_pcie_link_up() consistently
      PCI: dra7xx: Use dw_pcie_link_up() consistently
      x86/PCI: Use host bridge _CRS info on Foxconn K8M890-8237A
      PCI: pciehp: Wait for hotplug command completion where necessary
      PCI: Remove unused pci_dma_burst_advice()
      ...

commit 3d9fecf6bfb8b12bc2f9a4c7109895a2a2bb9436
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 9 17:31:38 2015 -0500

    x86/PCI: Use host bridge _CRS info on systems with >32 bit addressing
    
    We enable _CRS on all systems from 2008 and later.  On older systems, we
    ignore _CRS and assume the whole physical address space (excluding RAM and
    other devices) is available for PCI devices, but on systems that support
    physical address spaces larger than 4GB, it's doubtful that the area above
    4GB is really available for PCI.
    
    After d56dbf5bab8c ("PCI: Allocate 64-bit BARs above 4G when possible"), we
    try to use that space above 4GB *first*, so we're more likely to put a
    device there.
    
    On Juan's Toshiba Satellite Pro U200, BIOS left the graphics, sound, 1394,
    and card reader devices unassigned (but only after Windows had been
    booted).  Only the sound device had a 64-bit BAR, so it was the only device
    placed above 4GB, and hence the only device that didn't work.
    
    Keep _CRS enabled even on pre-2008 systems if they support physical address
    space larger than 4GB.
    
    Fixes: d56dbf5bab8c ("PCI: Allocate 64-bit BARs above 4G when possible")
    Reported-and-tested-by: Juan Dayer <jdayer@outlook.com>
    Reported-and-tested-by: Alan Horsfield <alan@hazelgarth.co.uk>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=99221
    Link: https://bugzilla.opensuse.org/show_bug.cgi?id=907092
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index d8e225826489..2ae7ce240e02 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -132,8 +132,10 @@ void __init pci_acpi_crs_quirks(void)
 {
 	int year;
 
-	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008)
-		pci_use_crs = false;
+	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008) {
+		if (iomem_resource.end <= 0xffffffff)
+			pci_use_crs = false;
+	}
 
 	dmi_check_system(pci_crs_quirks);
 

commit 1dace0116d0b05c967d94644fc4dfe96be2ecd3d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 9 18:54:07 2015 -0500

    x86/PCI: Use host bridge _CRS info on Foxconn K8M890-8237A
    
    The Foxconn K8M890-8237A has two PCI host bridges, and we can't assign
    resources correctly without the information from _CRS that tells us which
    address ranges are claimed by which bridge.  In the bugs mentioned below,
    we incorrectly assign a sound card address (this example is from 1033299):
    
      bus: 00 index 2 [mem 0x80000000-0xfcffffffff]
      ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-7f])
      pci_root PNP0A08:00: host bridge window [mem 0x80000000-0xbfefffff] (ignored)
      pci_root PNP0A08:00: host bridge window [mem 0xc0000000-0xdfffffff] (ignored)
      pci_root PNP0A08:00: host bridge window [mem 0xf0000000-0xfebfffff] (ignored)
      ACPI: PCI Root Bridge [PCI1] (domain 0000 [bus 80-ff])
      pci_root PNP0A08:01: host bridge window [mem 0xbff00000-0xbfffffff] (ignored)
      pci 0000:80:01.0: [1106:3288] type 0 class 0x000403
      pci 0000:80:01.0: reg 10: [mem 0xbfffc000-0xbfffffff 64bit]
      pci 0000:80:01.0: address space collision: [mem 0xbfffc000-0xbfffffff 64bit] conflicts with PCI Bus #00 [mem 0x80000000-0xfcffffffff]
      pci 0000:80:01.0: BAR 0: assigned [mem 0xfd00000000-0xfd00003fff 64bit]
      BUG: unable to handle kernel paging request at ffffc90000378000
      IP: [<ffffffffa0345f63>] azx_create+0x37c/0x822 [snd_hda_intel]
    
    We assigned 0xfd_0000_0000, but that is not in any of the host bridge
    windows, and the sound card doesn't work.
    
    Turn on pci=use_crs automatically for this system.
    
    Link: https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368
    Link: https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index e4695985f9de..d8e225826489 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -81,6 +81,17 @@ static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
 		},
 	},
+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */
+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */
+	{
+		.callback = set_use_crs,
+		.ident = "Foxconn K8M890-8237A",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Foxconn"),
+			DMI_MATCH(DMI_BOARD_NAME, "K8M890-8237A"),
+			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
+		},
+	},
 
 	/* Now for the blacklist.. */
 

commit dc4fdaf0e4839109169d8261814813816951c75f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 28 01:39:53 2015 +0200

    PCI / ACPI: Do not set ACPI companions for host bridges with parents
    
    Commit 97badf873ab6 (device property: Make it possible to use
    secondary firmware nodes) uncovered a bug in the x86 (and ia64) PCI
    host bridge initialization code that assumes bridge->bus->sysdata
    to always point to a struct pci_sysdata object which need not be
    the case (in particular, the Xen PCI frontend driver sets it to point
    to a different data type).  If it is not the case, an incorrect
    pointer (or a piece of data that is not a pointer at all) will be
    passed to ACPI_COMPANION_SET() and that may cause interesting
    breakage to happen going forward.
    
    To work around this problem use the observation that the ACPI
    host bridge initialization always passes NULL as parent to
    pci_create_root_bus(), so if pcibios_root_bridge_prepare() sees
    a non-NULL parent of the bridge, it should not attempt to set
    an ACPI companion for it, because that means that
    pci_create_root_bus() has been called by someone else.
    
    Fixes: 97badf873ab6 (device property: Make it possible to use secondary firmware nodes)
    Reported-and-tested-by: Sander Eikelenboom <linux@eikelenboom.it>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index d93963340c3c..14a63ed6fe09 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -482,9 +482,16 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 
 int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 {
-	struct pci_sysdata *sd = bridge->bus->sysdata;
-
-	ACPI_COMPANION_SET(&bridge->dev, sd->companion);
+	/*
+	 * We pass NULL as parent to pci_create_root_bus(), so if it is not NULL
+	 * here, pci_create_root_bus() has been called by someone else and
+	 * sysdata is likely to be different from what we expect.  Let it go in
+	 * that case.
+	 */
+	if (!bridge->dev.parent) {
+		struct pci_sysdata *sd = bridge->bus->sysdata;
+		ACPI_COMPANION_SET(&bridge->dev, sd->companion);
+	}
 	return 0;
 }
 

commit 2c62e8492ed7358bbe7da51666c7e0f6da9474ee
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Apr 30 12:41:28 2015 +0800

    x86/PCI/ACPI: Make all resources except [io 0xcf8-0xcff] available on PCI bus
    
    An IO port or MMIO resource assigned to a PCI host bridge may be
    consumed by the host bridge itself or available to its child
    bus/devices. The ACPI specification defines a bit (Producer/Consumer)
    to tell whether the resource is consumed by the host bridge itself,
    but firmware hasn't used that bit consistently, so we can't rely on it.
    
    Before commit 593669c2ac0f ("x86/PCI/ACPI: Use common ACPI resource
    interfaces to simplify implementation"), arch/x86/pci/acpi.c ignored
    all IO port resources defined by acpi_resource_io and
    acpi_resource_fixed_io to filter out IO ports consumed by the host
    bridge itself.
    
    Commit 593669c2ac0f ("x86/PCI/ACPI: Use common ACPI resource interfaces
    to simplify implementation") started accepting all IO port and MMIO
    resources, which caused a regression that IO port resources consumed
    by the host bridge itself became available to its child devices.
    
    Then commit 63f1789ec716 ("x86/PCI/ACPI: Ignore resources consumed by
    host bridge itself") ignored resources consumed by the host bridge
    itself by checking the IORESOURCE_WINDOW flag, which accidently removed
    MMIO resources defined by acpi_resource_memory24, acpi_resource_memory32
    and acpi_resource_fixed_memory32.
    
    On x86 and IA64 platforms, all IO port and MMIO resources are assumed
    to be available to child bus/devices except one special case:
        IO port [0xCF8-0xCFF] is consumed by the host bridge itself
        to access PCI configuration space.
    
    So explicitly filter out PCI CFG IO ports[0xCF8-0xCFF]. This solution
    will also ease the way to consolidate ACPI PCI host bridge common code
    from x86, ia64 and ARM64.
    
    Related ACPI table are archived at:
    https://bugzilla.kernel.org/show_bug.cgi?id=94221
    
    Related discussions at:
    http://patchwork.ozlabs.org/patch/461633/
    https://lkml.org/lkml/2015/3/29/304
    
    Fixes: 63f1789ec716 (Ignore resources consumed by host bridge itself)
    Reported-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: 4.0+ <stable@vger.kernel.org> # 4.0+
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index e4695985f9de..d93963340c3c 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -325,6 +325,26 @@ static void release_pci_root_info(struct pci_host_bridge *bridge)
 	kfree(info);
 }
 
+/*
+ * An IO port or MMIO resource assigned to a PCI host bridge may be
+ * consumed by the host bridge itself or available to its child
+ * bus/devices. The ACPI specification defines a bit (Producer/Consumer)
+ * to tell whether the resource is consumed by the host bridge itself,
+ * but firmware hasn't used that bit consistently, so we can't rely on it.
+ *
+ * On x86 and IA64 platforms, all IO port and MMIO resources are assumed
+ * to be available to child bus/devices except one special case:
+ *     IO port [0xCF8-0xCFF] is consumed by the host bridge itself
+ *     to access PCI configuration space.
+ *
+ * So explicitly filter out PCI CFG IO ports[0xCF8-0xCFF].
+ */
+static bool resource_is_pcicfg_ioport(struct resource *res)
+{
+	return (res->flags & IORESOURCE_IO) &&
+		res->start == 0xCF8 && res->end == 0xCFF;
+}
+
 static void probe_pci_root_info(struct pci_root_info *info,
 				struct acpi_device *device,
 				int busnum, int domain,
@@ -346,8 +366,8 @@ static void probe_pci_root_info(struct pci_root_info *info,
 			"no IO and memory resources present in _CRS\n");
 	else
 		resource_list_for_each_entry_safe(entry, tmp, list) {
-			if ((entry->res->flags & IORESOURCE_WINDOW) == 0 ||
-			    (entry->res->flags & IORESOURCE_DISABLED))
+			if ((entry->res->flags & IORESOURCE_DISABLED) ||
+			    resource_is_pcicfg_ioport(entry->res))
 				resource_list_destroy_entry(entry);
 			else
 				entry->res->name = info->name;

commit 63f1789ec71677dd285d43d6c79ca44808f16945
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Mar 4 16:47:11 2015 +0800

    x86/PCI/ACPI: Ignore resources consumed by host bridge itself
    
    When parsing resources for PCI host bridge, we should ignore resources
    consumed by host bridge itself and only report window resources available
    to child PCI busses.
    
    Fixes: 593669c2ac0f (x86/PCI/ACPI: Use common ACPI resource interfaces ...)
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 6ac273832f28..e4695985f9de 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -331,7 +331,7 @@ static void probe_pci_root_info(struct pci_root_info *info,
 				struct list_head *list)
 {
 	int ret;
-	struct resource_entry *entry;
+	struct resource_entry *entry, *tmp;
 
 	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
 	info->bridge = device;
@@ -345,8 +345,13 @@ static void probe_pci_root_info(struct pci_root_info *info,
 		dev_dbg(&device->dev,
 			"no IO and memory resources present in _CRS\n");
 	else
-		resource_list_for_each_entry(entry, list)
-			entry->res->name = info->name;
+		resource_list_for_each_entry_safe(entry, tmp, list) {
+			if ((entry->res->flags & IORESOURCE_WINDOW) == 0 ||
+			    (entry->res->flags & IORESOURCE_DISABLED))
+				resource_list_destroy_entry(entry);
+			else
+				entry->res->name = info->name;
+		}
 }
 
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)

commit 593669c2ac0fe18baee04a3cd5539a148aa48574
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:46 2015 +0800

    x86/PCI/ACPI: Use common ACPI resource interfaces to simplify implementation
    
    Use common ACPI resource discovery interfaces to simplify PCI host bridge
    resource enumeration.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 1d725d99963d..6ac273832f28 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -10,9 +10,6 @@
 struct pci_root_info {
 	struct acpi_device *bridge;
 	char name[16];
-	unsigned int res_num;
-	struct resource *res;
-	resource_size_t *res_offset;
 	struct pci_sysdata sd;
 #ifdef	CONFIG_PCI_MMCONFIG
 	bool mcfg_added;
@@ -218,132 +215,41 @@ static void teardown_mcfg_map(struct pci_root_info *info)
 }
 #endif
 
-static acpi_status resource_to_addr(struct acpi_resource *resource,
-				    struct acpi_resource_address64 *addr)
-{
-	acpi_status status;
-	struct acpi_resource_memory24 *memory24;
-	struct acpi_resource_memory32 *memory32;
-	struct acpi_resource_fixed_memory32 *fixed_memory32;
-
-	memset(addr, 0, sizeof(*addr));
-	switch (resource->type) {
-	case ACPI_RESOURCE_TYPE_MEMORY24:
-		memory24 = &resource->data.memory24;
-		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->address.minimum = memory24->minimum;
-		addr->address.address_length = memory24->address_length;
-		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
-		return AE_OK;
-	case ACPI_RESOURCE_TYPE_MEMORY32:
-		memory32 = &resource->data.memory32;
-		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->address.minimum = memory32->minimum;
-		addr->address.address_length = memory32->address_length;
-		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
-		return AE_OK;
-	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
-		fixed_memory32 = &resource->data.fixed_memory32;
-		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->address.minimum = fixed_memory32->address;
-		addr->address.address_length = fixed_memory32->address_length;
-		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
-		return AE_OK;
-	case ACPI_RESOURCE_TYPE_ADDRESS16:
-	case ACPI_RESOURCE_TYPE_ADDRESS32:
-	case ACPI_RESOURCE_TYPE_ADDRESS64:
-		status = acpi_resource_to_address64(resource, addr);
-		if (ACPI_SUCCESS(status) &&
-		    (addr->resource_type == ACPI_MEMORY_RANGE ||
-		    addr->resource_type == ACPI_IO_RANGE) &&
-		    addr->address.address_length > 0) {
-			return AE_OK;
-		}
-		break;
-	}
-	return AE_ERROR;
-}
-
-static acpi_status count_resource(struct acpi_resource *acpi_res, void *data)
+static void validate_resources(struct device *dev, struct list_head *crs_res,
+			       unsigned long type)
 {
-	struct pci_root_info *info = data;
-	struct acpi_resource_address64 addr;
-	acpi_status status;
-
-	status = resource_to_addr(acpi_res, &addr);
-	if (ACPI_SUCCESS(status))
-		info->res_num++;
-	return AE_OK;
-}
-
-static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
-{
-	struct pci_root_info *info = data;
-	struct resource *res;
-	struct acpi_resource_address64 addr;
-	acpi_status status;
-	unsigned long flags;
-	u64 start, orig_end, end, res_end;
-
-	status = resource_to_addr(acpi_res, &addr);
-	if (!ACPI_SUCCESS(status))
-		return AE_OK;
-
-	if (addr.resource_type == ACPI_MEMORY_RANGE) {
-		flags = IORESOURCE_MEM;
-		if (addr.info.mem.caching == ACPI_PREFETCHABLE_MEMORY)
-			flags |= IORESOURCE_PREFETCH;
-		res_end = (u64)iomem_resource.end;
-	} else if (addr.resource_type == ACPI_IO_RANGE) {
-		flags = IORESOURCE_IO;
-		res_end = (u64)ioport_resource.end;
-	} else
-		return AE_OK;
-
-	start = addr.address.minimum + addr.address.translation_offset;
-	orig_end = end = addr.address.maximum + addr.address.translation_offset;
-
-	/* Exclude non-addressable range or non-addressable portion of range */
-	end = min(end, res_end);
-	if (end <= start) {
-		dev_info(&info->bridge->dev,
-			"host bridge window [%#llx-%#llx] "
-			"(ignored, not CPU addressable)\n", start, orig_end);
-		return AE_OK;
-	} else if (orig_end != end) {
-		dev_info(&info->bridge->dev,
-			"host bridge window [%#llx-%#llx] "
-			"([%#llx-%#llx] ignored, not CPU addressable)\n", 
-			start, orig_end, end + 1, orig_end);
-	}
+	LIST_HEAD(list);
+	struct resource *res1, *res2, *root = NULL;
+	struct resource_entry *tmp, *entry, *entry2;
 
-	res = &info->res[info->res_num];
-	res->name = info->name;
-	res->flags = flags;
-	res->start = start;
-	res->end = end;
-	info->res_offset[info->res_num] = addr.address.translation_offset;
-	info->res_num++;
+	BUG_ON((type & (IORESOURCE_MEM | IORESOURCE_IO)) == 0);
+	root = (type & IORESOURCE_MEM) ? &iomem_resource : &ioport_resource;
 
-	if (!pci_use_crs)
-		dev_printk(KERN_DEBUG, &info->bridge->dev,
-			   "host bridge window %pR (ignored)\n", res);
+	list_splice_init(crs_res, &list);
+	resource_list_for_each_entry_safe(entry, tmp, &list) {
+		bool free = false;
+		resource_size_t end;
 
-	return AE_OK;
-}
-
-static void coalesce_windows(struct pci_root_info *info, unsigned long type)
-{
-	int i, j;
-	struct resource *res1, *res2;
-
-	for (i = 0; i < info->res_num; i++) {
-		res1 = &info->res[i];
+		res1 = entry->res;
 		if (!(res1->flags & type))
-			continue;
+			goto next;
+
+		/* Exclude non-addressable range or non-addressable portion */
+		end = min(res1->end, root->end);
+		if (end <= res1->start) {
+			dev_info(dev, "host bridge window %pR (ignored, not CPU addressable)\n",
+				 res1);
+			free = true;
+			goto next;
+		} else if (res1->end != end) {
+			dev_info(dev, "host bridge window %pR ([%#llx-%#llx] ignored, not CPU addressable)\n",
+				 res1, (unsigned long long)end + 1,
+				 (unsigned long long)res1->end);
+			res1->end = end;
+		}
 
-		for (j = i + 1; j < info->res_num; j++) {
-			res2 = &info->res[j];
+		resource_list_for_each_entry(entry2, crs_res) {
+			res2 = entry2->res;
 			if (!(res2->flags & type))
 				continue;
 
@@ -355,118 +261,92 @@ static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 			if (resource_overlaps(res1, res2)) {
 				res2->start = min(res1->start, res2->start);
 				res2->end = max(res1->end, res2->end);
-				dev_info(&info->bridge->dev,
-					 "host bridge window expanded to %pR; %pR ignored\n",
+				dev_info(dev, "host bridge window expanded to %pR; %pR ignored\n",
 					 res2, res1);
-				res1->flags = 0;
+				free = true;
+				goto next;
 			}
 		}
+
+next:
+		resource_list_del(entry);
+		if (free)
+			resource_list_free_entry(entry);
+		else
+			resource_list_add_tail(entry, crs_res);
 	}
 }
 
 static void add_resources(struct pci_root_info *info,
-			  struct list_head *resources)
+			  struct list_head *resources,
+			  struct list_head *crs_res)
 {
-	int i;
-	struct resource *res, *root, *conflict;
-
-	coalesce_windows(info, IORESOURCE_MEM);
-	coalesce_windows(info, IORESOURCE_IO);
+	struct resource_entry *entry, *tmp;
+	struct resource *res, *conflict, *root = NULL;
 
-	for (i = 0; i < info->res_num; i++) {
-		res = &info->res[i];
+	validate_resources(&info->bridge->dev, crs_res, IORESOURCE_MEM);
+	validate_resources(&info->bridge->dev, crs_res, IORESOURCE_IO);
 
+	resource_list_for_each_entry_safe(entry, tmp, crs_res) {
+		res = entry->res;
 		if (res->flags & IORESOURCE_MEM)
 			root = &iomem_resource;
 		else if (res->flags & IORESOURCE_IO)
 			root = &ioport_resource;
 		else
-			continue;
+			BUG_ON(res);
 
 		conflict = insert_resource_conflict(root, res);
-		if (conflict)
+		if (conflict) {
 			dev_info(&info->bridge->dev,
 				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
 				 res, conflict->name, conflict);
-		else
-			pci_add_resource_offset(resources, res,
-					info->res_offset[i]);
+			resource_list_destroy_entry(entry);
+		}
 	}
-}
 
-static void free_pci_root_info_res(struct pci_root_info *info)
-{
-	kfree(info->res);
-	info->res = NULL;
-	kfree(info->res_offset);
-	info->res_offset = NULL;
-	info->res_num = 0;
+	list_splice_tail(crs_res, resources);
 }
 
-static void __release_pci_root_info(struct pci_root_info *info)
+static void release_pci_root_info(struct pci_host_bridge *bridge)
 {
-	int i;
 	struct resource *res;
+	struct resource_entry *entry;
+	struct pci_root_info *info = bridge->release_data;
 
-	for (i = 0; i < info->res_num; i++) {
-		res = &info->res[i];
-
-		if (!res->parent)
-			continue;
-
-		if (!(res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))
-			continue;
-
-		release_resource(res);
+	resource_list_for_each_entry(entry, &bridge->windows) {
+		res = entry->res;
+		if (res->parent &&
+		    (res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))
+			release_resource(res);
 	}
 
-	free_pci_root_info_res(info);
-
 	teardown_mcfg_map(info);
-
 	kfree(info);
 }
 
-static void release_pci_root_info(struct pci_host_bridge *bridge)
-{
-	struct pci_root_info *info = bridge->release_data;
-
-	__release_pci_root_info(info);
-}
-
 static void probe_pci_root_info(struct pci_root_info *info,
 				struct acpi_device *device,
-				int busnum, int domain)
+				int busnum, int domain,
+				struct list_head *list)
 {
-	size_t size;
+	int ret;
+	struct resource_entry *entry;
 
 	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
 	info->bridge = device;
-
-	info->res_num = 0;
-	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
-				info);
-	if (!info->res_num)
-		return;
-
-	size = sizeof(*info->res) * info->res_num;
-	info->res = kzalloc_node(size, GFP_KERNEL, info->sd.node);
-	if (!info->res) {
-		info->res_num = 0;
-		return;
-	}
-
-	size = sizeof(*info->res_offset) * info->res_num;
-	info->res_num = 0;
-	info->res_offset = kzalloc_node(size, GFP_KERNEL, info->sd.node);
-	if (!info->res_offset) {
-		kfree(info->res);
-		info->res = NULL;
-		return;
-	}
-
-	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
-				info);
+	ret = acpi_dev_get_resources(device, list,
+				     acpi_dev_filter_resource_type_cb,
+				     (void *)(IORESOURCE_IO | IORESOURCE_MEM));
+	if (ret < 0)
+		dev_warn(&device->dev,
+			 "failed to parse _CRS method, error code %d\n", ret);
+	else if (ret == 0)
+		dev_dbg(&device->dev,
+			"no IO and memory resources present in _CRS\n");
+	else
+		resource_list_for_each_entry(entry, list)
+			entry->res->name = info->name;
 }
 
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
@@ -475,6 +355,8 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	struct pci_root_info *info;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
+	struct resource_entry *res_entry;
+	LIST_HEAD(crs_res);
 	LIST_HEAD(resources);
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
@@ -522,18 +404,22 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(info);
 	} else {
-		probe_pci_root_info(info, device, busnum, domain);
-
 		/* insert busn res at first */
 		pci_add_resource(&resources,  &root->secondary);
+
 		/*
 		 * _CRS with no apertures is normal, so only fall back to
 		 * defaults or native bridge info if we're ignoring _CRS.
 		 */
-		if (pci_use_crs)
-			add_resources(info, &resources);
-		else {
-			free_pci_root_info_res(info);
+		probe_pci_root_info(info, device, busnum, domain, &crs_res);
+		if (pci_use_crs) {
+			add_resources(info, &resources, &crs_res);
+		} else {
+			resource_list_for_each_entry(res_entry, &crs_res)
+				dev_printk(KERN_DEBUG, &device->dev,
+					   "host bridge window %pR (ignored)\n",
+					   res_entry->res);
+			resource_list_free(&crs_res);
 			x86_pci_root_bus_resources(busnum, &resources);
 		}
 
@@ -548,8 +434,9 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 				to_pci_host_bridge(bus->bridge),
 				release_pci_root_info, info);
 		} else {
-			pci_free_resource_list(&resources);
-			__release_pci_root_info(info);
+			resource_list_free(&resources);
+			teardown_mcfg_map(info);
+			kfree(info);
 		}
 	}
 

commit 812dbd9994f122629db73205a7f7f46b430a6360
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:45 2015 +0800

    x86/PCI: Fix the range check for IO resources
    
    The range check in setup_res() checks the IO range against
    iomem_resource. That's just wrong.
    
    Reworked based on Thomas original patch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index bb98afd0591e..1d725d99963d 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -283,7 +283,7 @@ static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 	unsigned long flags;
-	u64 start, orig_end, end;
+	u64 start, orig_end, end, res_end;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -293,8 +293,10 @@ static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 		flags = IORESOURCE_MEM;
 		if (addr.info.mem.caching == ACPI_PREFETCHABLE_MEMORY)
 			flags |= IORESOURCE_PREFETCH;
+		res_end = (u64)iomem_resource.end;
 	} else if (addr.resource_type == ACPI_IO_RANGE) {
 		flags = IORESOURCE_IO;
+		res_end = (u64)ioport_resource.end;
 	} else
 		return AE_OK;
 
@@ -302,7 +304,7 @@ static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 	orig_end = end = addr.address.maximum + addr.address.translation_offset;
 
 	/* Exclude non-addressable range or non-addressable portion of range */
-	end = min(end, (u64)iomem_resource.end);
+	end = min(end, res_end);
 	if (end <= start) {
 		dev_info(&info->bridge->dev,
 			"host bridge window [%#llx-%#llx] "

commit a45de93eb10ae44446aec2c73d722562ab46092a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jan 26 16:58:56 2015 +0800

    ACPICA: Resources: Provide common part for struct acpi_resource_address structures.
    
    struct acpi_resource_address and struct acpi_resource_extended_address64 share substracts
    just at different offsets. To unify the parsing functions, OSPMs like Linux
    need a new ACPI_ADDRESS64_ATTRIBUTE as their substructs, so they can
    extract the shared data.
    
    This patch also synchronizes the structure changes to the Linux kernel.
    The usages are searched by matching the following keywords:
    1. acpi_resource_address
    2. acpi_resource_extended_address
    3. ACPI_RESOURCE_TYPE_ADDRESS
    4. ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS
    And we found and fixed the usages in the following files:
     arch/ia64/kernel/acpi-ext.c
     arch/ia64/pci/pci.c
     arch/x86/pci/acpi.c
     arch/x86/pci/mmconfig-shared.c
     drivers/xen/xen-acpi-memhotplug.c
     drivers/acpi/acpi_memhotplug.c
     drivers/acpi/pci_root.c
     drivers/acpi/resource.c
     drivers/char/hpet.c
     drivers/pnp/pnpacpi/rsparser.c
     drivers/hv/vmbus_drv.c
    
    Build tests are passed with defconfig/allnoconfig/allyesconfig and
    defconfig+CONFIG_ACPI=n.
    
    Original-by: Thomas Gleixner <tglx@linutronix.de>
    Original-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index cfd1b132b8e3..bb98afd0591e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -231,23 +231,23 @@ static acpi_status resource_to_addr(struct acpi_resource *resource,
 	case ACPI_RESOURCE_TYPE_MEMORY24:
 		memory24 = &resource->data.memory24;
 		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->minimum = memory24->minimum;
-		addr->address_length = memory24->address_length;
-		addr->maximum = addr->minimum + addr->address_length - 1;
+		addr->address.minimum = memory24->minimum;
+		addr->address.address_length = memory24->address_length;
+		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
 		return AE_OK;
 	case ACPI_RESOURCE_TYPE_MEMORY32:
 		memory32 = &resource->data.memory32;
 		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->minimum = memory32->minimum;
-		addr->address_length = memory32->address_length;
-		addr->maximum = addr->minimum + addr->address_length - 1;
+		addr->address.minimum = memory32->minimum;
+		addr->address.address_length = memory32->address_length;
+		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
 		return AE_OK;
 	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
 		fixed_memory32 = &resource->data.fixed_memory32;
 		addr->resource_type = ACPI_MEMORY_RANGE;
-		addr->minimum = fixed_memory32->address;
-		addr->address_length = fixed_memory32->address_length;
-		addr->maximum = addr->minimum + addr->address_length - 1;
+		addr->address.minimum = fixed_memory32->address;
+		addr->address.address_length = fixed_memory32->address_length;
+		addr->address.maximum = addr->address.minimum + addr->address.address_length - 1;
 		return AE_OK;
 	case ACPI_RESOURCE_TYPE_ADDRESS16:
 	case ACPI_RESOURCE_TYPE_ADDRESS32:
@@ -256,7 +256,7 @@ static acpi_status resource_to_addr(struct acpi_resource *resource,
 		if (ACPI_SUCCESS(status) &&
 		    (addr->resource_type == ACPI_MEMORY_RANGE ||
 		    addr->resource_type == ACPI_IO_RANGE) &&
-		    addr->address_length > 0) {
+		    addr->address.address_length > 0) {
 			return AE_OK;
 		}
 		break;
@@ -298,8 +298,8 @@ static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 	} else
 		return AE_OK;
 
-	start = addr.minimum + addr.translation_offset;
-	orig_end = end = addr.maximum + addr.translation_offset;
+	start = addr.address.minimum + addr.address.translation_offset;
+	orig_end = end = addr.address.maximum + addr.address.translation_offset;
 
 	/* Exclude non-addressable range or non-addressable portion of range */
 	end = min(end, (u64)iomem_resource.end);
@@ -320,7 +320,7 @@ static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->flags = flags;
 	res->start = start;
 	res->end = end;
-	info->res_offset[info->res_num] = addr.translation_offset;
+	info->res_offset[info->res_num] = addr.address.translation_offset;
 	info->res_num++;
 
 	if (!pci_use_crs)

commit 965cd0e4a5e5d704934fa6d476b1a4faa0417e1b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 9 16:19:34 2014 +0800

    x86, PCI, ACPI: Use kmalloc_node() to optimize for performance
    
    Use kmalloc_node() instead of kmalloc() when possible to optimize
    for performance on NUMA platforms.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/1402302011-23642-6-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 5075371ab593..cfd1b132b8e3 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -448,7 +448,7 @@ static void probe_pci_root_info(struct pci_root_info *info,
 		return;
 
 	size = sizeof(*info->res) * info->res_num;
-	info->res = kzalloc(size, GFP_KERNEL);
+	info->res = kzalloc_node(size, GFP_KERNEL, info->sd.node);
 	if (!info->res) {
 		info->res_num = 0;
 		return;
@@ -456,7 +456,7 @@ static void probe_pci_root_info(struct pci_root_info *info,
 
 	size = sizeof(*info->res_offset) * info->res_num;
 	info->res_num = 0;
-	info->res_offset = kzalloc(size, GFP_KERNEL);
+	info->res_offset = kzalloc_node(size, GFP_KERNEL, info->sd.node);
 	if (!info->res_offset) {
 		kfree(info->res);
 		info->res = NULL;
@@ -499,7 +499,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	if (node != NUMA_NO_NODE && !node_online(node))
 		node = NUMA_NO_NODE;
 
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	info = kzalloc_node(sizeof(*info), GFP_KERNEL, node);
 	if (!info) {
 		printk(KERN_WARNING "pci_bus %04x:%02x: "
 		       "ignored (out of memory)\n", domain, busnum);

commit 33673101335b19913745ff0e9d2946b490608e5f
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Thu May 8 11:44:20 2014 -0500

    x86/PCI: Warn if we have to "guess" host bridge node information
    
    The vast majority of platforms are not supplying ACPI _PXM (proximity)
    information corresponding to host bridge (PNP0A03/PNP0A08) devices
    resulting in sysfs "numa_node" values of -1 (NUMA_NO_NODE):
    
      # for i in /sys/devices/pci0000\:00/*/numa_node; do cat $i; done | uniq
      -1
    
      # find /sys/ -name "numa_node" | while read fname; do cat $fname; \
        done | uniq
      -1
    
    AMD based platforms provide a fall-back for this situation via amd_bus.c.
    These platforms snoop out the information by directly reading specific
    registers from the Northbridge and caching them via alloc_pci_root_info().
    
    Later during boot processing when host bridges are discovered -
    pci_acpi_scan_root() - the kernel looks for their corresponding ACPI _PXM
    method - drivers/acpi/numa.c::acpi_get_node().  If the BIOS supplied a _PXM
    method then that node (proximity) value is associated.  If the BIOS did not
    supply a _PXM method *and* the platform is AMD-based, the fall-back cached
    values obtained directly from the Northbridge are used; otherwise,
    "NUMA_NO_NODE" is associated.
    
    There are a number of issues with this fall-back mechanism the most notable
    being that amd_bus.c extracts a 3-bit number from a CPU register and uses
    it as the node number.  The node numbers used by Linux are logical and
    there's no reason they need to be identical to settings in the CPU
    registers.  So if we have some node information obtained in the normal way
    (from _PXM, SLIT, SRAT, etc.) and some from amd_bus.c, there's no reason to
    believe they will be compatible.
    
    This patch warns when this situation occurs:
    
      pci_root PNP0A08:00: [Firmware Bug]: no _PXM; falling back to node 0 from hardware (may be inconsistent with ACPI node numbers)
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=72051
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 01edac6c5e18..5075371ab593 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -489,8 +489,12 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	}
 
 	node = acpi_get_node(device->handle);
-	if (node == NUMA_NO_NODE)
+	if (node == NUMA_NO_NODE) {
 		node = x86_pci_root_bus_node(busnum);
+		if (node != 0 && node != NUMA_NO_NODE)
+			dev_info(&device->dev, FW_BUG "no _PXM; falling back to node %d from hardware (may be inconsistent with ACPI node numbers)\n",
+				node);
+	}
 
 	if (node != NUMA_NO_NODE && !node_online(node))
 		node = NUMA_NO_NODE;

commit 94a5f850aead02f02f350d401a43c4bf9a9fbf3a
Merge: ec5130ba7907 1e2571a78138
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 18 17:02:04 2014 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Enable INTx if BIOS left them disabled
      ia64/PCI: Set IORESOURCE_ROM_SHADOW only for the default VGA device
      x86/PCI: Set IORESOURCE_ROM_SHADOW only for the default VGA device
      PCI: Update outdated comment for pcibios_bus_report_status()
      PCI: Cleanup per-arch list of object files
      PCI: cpqphp: Fix hex vs decimal typo in cpqhpc_probe()
      x86/PCI: Fix function definition whitespace
      x86/PCI: Reword comments
      x86/PCI: Remove unnecessary local variable initialization
      PCI: Remove unnecessary list_empty(&pci_pme_list) check

commit da5d727c9744e3986c54192a7fbcf10720b6534c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 10:44:42 2014 -0700

    x86/PCI: Fix function definition whitespace
    
    Consistently put the function type, name, and parameters on one line,
    wrapping only as necessary.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0073348b2960..b0bc5920f5c6 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -218,9 +218,8 @@ static void teardown_mcfg_map(struct pci_root_info *info)
 }
 #endif
 
-static acpi_status
-resource_to_addr(struct acpi_resource *resource,
-			struct acpi_resource_address64 *addr)
+static acpi_status resource_to_addr(struct acpi_resource *resource,
+				    struct acpi_resource_address64 *addr)
 {
 	acpi_status status;
 	struct acpi_resource_memory24 *memory24;
@@ -265,8 +264,7 @@ resource_to_addr(struct acpi_resource *resource,
 	return AE_ERROR;
 }
 
-static acpi_status
-count_resource(struct acpi_resource *acpi_res, void *data)
+static acpi_status count_resource(struct acpi_resource *acpi_res, void *data)
 {
 	struct pci_root_info *info = data;
 	struct acpi_resource_address64 addr;
@@ -278,8 +276,7 @@ count_resource(struct acpi_resource *acpi_res, void *data)
 	return AE_OK;
 }
 
-static acpi_status
-setup_resource(struct acpi_resource *acpi_res, void *data)
+static acpi_status setup_resource(struct acpi_resource *acpi_res, void *data)
 {
 	struct pci_root_info *info = data;
 	struct resource *res;
@@ -435,9 +432,9 @@ static void release_pci_root_info(struct pci_host_bridge *bridge)
 	__release_pci_root_info(info);
 }
 
-static void
-probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
-		    int busnum, int domain)
+static void probe_pci_root_info(struct pci_root_info *info,
+				struct acpi_device *device,
+				int busnum, int domain)
 {
 	size_t size;
 

commit affbda86feef8da5056effe5d71da7981b2a9565
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 10:38:40 2014 -0700

    x86/PCI: Reword comments
    
    Reword comments so they make sense.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index ef7e92068eb1..0073348b2960 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -519,15 +519,12 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	sd->domain = domain;
 	sd->node = node;
 	sd->companion = device;
-	/*
-	 * Maybe the desired pci bus has been already scanned. In such case
-	 * it is unnecessary to scan the pci bus with the given domain,busnum.
-	 */
+
 	bus = pci_find_bus(domain, busnum);
 	if (bus) {
 		/*
-		 * If the desired bus exits, the content of bus->sysdata will
-		 * be replaced by sd.
+		 * If the desired bus has been scanned already, replace
+		 * its bus->sysdata.
 		 */
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(info);

commit 8928d5a66df1428fd215e611088822d0bec08f58
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 10:41:11 2014 -0700

    x86/PCI: Remove unnecessary local variable initialization
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 4f25ec077552..ef7e92068eb1 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -473,11 +473,11 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	struct acpi_device *device = root->device;
-	struct pci_root_info *info = NULL;
+	struct pci_root_info *info;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
 	LIST_HEAD(resources);
-	struct pci_bus *bus = NULL;
+	struct pci_bus *bus;
 	struct pci_sysdata *sd;
 	int node;
 #ifdef CONFIG_ACPI_NUMA

commit ab6ffce35b2cd1f558fce954d38a7ee7ffa9c415
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 14:40:46 2014 -0700

    x86/PCI: Remove acpi_get_pxm() usage
    
    The PCI host bridge code doesn't care about _PXM values directly; it only
    needs to know what NUMA node the hardware is on.
    
    This uses acpi_get_node() directly and removes the _PXM stuff.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 6304ea0f426d..f44a64c74e37 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -480,9 +480,6 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	struct pci_bus *bus = NULL;
 	struct pci_sysdata *sd;
 	int node;
-#ifdef CONFIG_ACPI_NUMA
-	int pxm;
-#endif
 
 	if (pci_ignore_seg)
 		domain = 0;
@@ -494,12 +491,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		return NULL;
 	}
 
-	node = NUMA_NO_NODE;
-#ifdef CONFIG_ACPI_NUMA
-	pxm = acpi_get_pxm(device->handle);
-	if (pxm >= 0)
-		node = pxm_to_node(pxm);
-#endif
+	node = acpi_get_node(device->handle);
 	if (node == NUMA_NO_NODE)
 		node = x86_pci_root_bus_node(busnum);
 
@@ -570,15 +562,8 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 			pcie_bus_configure_settings(child);
 	}
 
-	if (bus && node != NUMA_NO_NODE) {
-#ifdef CONFIG_ACPI_NUMA
-		if (pxm >= 0)
-			dev_printk(KERN_DEBUG, &bus->dev,
-				   "on NUMA node %d (pxm %d)\n", node, pxm);
-#else
+	if (bus && node != NUMA_NO_NODE)
 		dev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);
-#endif
-	}
 
 	return bus;
 }

commit 8a3d01c740ab5ce141af8ddeef23cecaa51d2710
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 14:51:49 2014 -0700

    x86/PCI: Use NUMA_NO_NODE, not -1, for unknown node
    
    NUMA_NO_NODE is the usual value for "we don't know what node this is on,"
    e.g., it is the error return from acpi_get_node().  This changes uses of -1
    to NUMA_NO_NODE.  NUMA_NO_NODE is #defined to be -1 already, so this is not
    a functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 78f27efa11e1..6304ea0f426d 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -494,17 +494,17 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		return NULL;
 	}
 
-	node = -1;
+	node = NUMA_NO_NODE;
 #ifdef CONFIG_ACPI_NUMA
 	pxm = acpi_get_pxm(device->handle);
 	if (pxm >= 0)
 		node = pxm_to_node(pxm);
 #endif
-	if (node == -1)
+	if (node == NUMA_NO_NODE)
 		node = x86_pci_root_bus_node(busnum);
 
-	if (node != -1 && !node_online(node))
-		node = -1;
+	if (node != NUMA_NO_NODE && !node_online(node))
+		node = NUMA_NO_NODE;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info) {
@@ -570,7 +570,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 			pcie_bus_configure_settings(child);
 	}
 
-	if (bus && node != -1) {
+	if (bus && node != NUMA_NO_NODE) {
 #ifdef CONFIG_ACPI_NUMA
 		if (pxm >= 0)
 			dev_printk(KERN_DEBUG, &bus->dev,

commit 25453e9e521382883b6588ef1748ed61efc77001
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 11:56:06 2014 -0700

    x86/PCI: Remove mp_bus_to_node[], set_mp_bus_to_node(), get_mp_bus_to_node()
    
    There are no callers of get_mp_bus_to_node(), so we no longer need
    mp_bus_to_node[], get_mp_bus_to_node(), or set_mp_bus_to_node().
    This removes them.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 3f42c5c05bf6..78f27efa11e1 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -499,10 +499,8 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	pxm = acpi_get_pxm(device->handle);
 	if (pxm >= 0)
 		node = pxm_to_node(pxm);
-	if (node != -1)
-		set_mp_bus_to_node(busnum, node);
-	else
 #endif
+	if (node == -1)
 		node = x86_pci_root_bus_node(busnum);
 
 	if (node != -1 && !node_online(node))

commit 6616dbdf6d967c704830586d5ead35c9767a8431
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 11:54:51 2014 -0700

    x86/PCI: Use x86_pci_root_bus_node() instead of get_mp_bus_to_node()
    
    This replaces all uses of get_mp_bus_to_node() with x86_pci_root_bus_node().
    
    I think these uses are all on root buses, except possibly for blind
    probing, where NUMA node information is unimportant.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 4f25ec077552..3f42c5c05bf6 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -503,7 +503,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		set_mp_bus_to_node(busnum, node);
 	else
 #endif
-		node = get_mp_bus_to_node(busnum);
+		node = x86_pci_root_bus_node(busnum);
 
 	if (node != -1 && !node_online(node))
 		node = -1;

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 7fb24e53d4c8..4f25ec077552 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -518,7 +518,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	sd = &info->sd;
 	sd->domain = domain;
 	sd->node = node;
-	sd->acpi = device->handle;
+	sd->companion = device;
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -589,7 +589,7 @@ int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 {
 	struct pci_sysdata *sd = bridge->bus->sysdata;
 
-	ACPI_HANDLE_SET(&bridge->dev, sd->acpi);
+	ACPI_COMPANION_SET(&bridge->dev, sd->companion);
 	return 0;
 }
 

commit 3ad674d6c6c5724c83f10f422d826420c83536cd
Author: Alexey Neyman <stilor@att.net>
Date:   Wed Oct 9 16:16:38 2013 -0600

    x86/PCI: Coalesce multiple overlapping host bridge windows
    
    Previously we coalesced windows by expanding the first overlapping one and
    making the second invalid.  But we never look at the expanded first window
    again, so we fail to notice other windows that overlap it.  For example, we
    coalesced these:
    
      [io  0x0000-0x03af] // #0
      [io  0x03e0-0x0cf7] // #1
      [io  0x0000-0xdfff] // #2
    
    into these, which still overlap:
    
      [io  0x0000-0xdfff] // #0
      [io  0x03e0-0x0cf7] // #1
    
    The fix is to expand the *second* overlapping resource and ignore the
    first, so we get this instead with no overlaps:
    
      [io  0x0000-0xdfff] // #2
    
    [bhelgaas: changelog]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=62511
    Signed-off-by: Alexey Neyman <stilor@att.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index b30e937689d6..7fb24e53d4c8 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -354,12 +354,12 @@ static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 			 * the kernel resource tree doesn't allow overlaps.
 			 */
 			if (resource_overlaps(res1, res2)) {
-				res1->start = min(res1->start, res2->start);
-				res1->end = max(res1->end, res2->end);
+				res2->start = min(res1->start, res2->start);
+				res2->end = max(res1->end, res2->end);
 				dev_info(&info->bridge->dev,
 					 "host bridge window expanded to %pR; %pR ignored\n",
-					 res1, res2);
-				res2->flags = 0;
+					 res2, res1);
+				res1->flags = 0;
 			}
 		}
 	}

commit a58674ff8383f5b8f6a77f03c48f6a47840b9325
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 22 11:24:44 2013 +0800

    PCI: Simplify pcie_bus_configure_settings() interface
    
    Based on a patch by Jon Mason (see URL below).
    
    All users of pcie_bus_configure_settings() pass arguments of the form
    "bus, bus->self->pcie_mpss".  The "mpss" argument is redundant since we
    can easily look it up internally.  In addition, all callers check
    "bus->self" for NULL, which we can also do internally.
    
    This patch simplifies the interface and the callers.  No functional change.
    
    Reference: http://lkml.kernel.org/r/1317048850-30728-2-git-send-email-mason@myri.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index d641897a1f4e..b30e937689d6 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -568,13 +568,8 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	 */
 	if (bus) {
 		struct pci_bus *child;
-		list_for_each_entry(child, &bus->children, node) {
-			struct pci_dev *self = child->self;
-			if (!self)
-				continue;
-
-			pcie_bus_configure_settings(child, self->pcie_mpss);
-		}
+		list_for_each_entry(child, &bus->children, node)
+			pcie_bus_configure_settings(child);
 	}
 
 	if (bus && node != -1) {

commit ea221e64140f6fa543c29e31349001167b9f8ad0
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue May 28 10:55:09 2013 +0800

    x86/PCI: Increase info->res_num before checking pci_use_crs
    
    We should increase info->res_num before we checking pci_use_crs return
    when pci=nocrs set.
    
    No functional change, since we don't use res_num and res_offset[]
    in the "!pci_use_crs" case anyway, but this makes the code read better.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Jiang Liu <liuj97@gmail.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Feng Tang <feng.tang@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 3e724256dbee..d641897a1f4e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -324,14 +324,11 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->start = start;
 	res->end = end;
 	info->res_offset[info->res_num] = addr.translation_offset;
+	info->res_num++;
 
-	if (!pci_use_crs) {
+	if (!pci_use_crs)
 		dev_printk(KERN_DEBUG, &info->bridge->dev,
 			   "host bridge window %pR (ignored)\n", res);
-		return AE_OK;
-	}
-
-	info->res_num++;
 
 	return AE_OK;
 }

commit 556f12f602ac0a18a82ca83e9f8e8547688fc633
Merge: fffddfd6c8e0 018ba0a6efad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:18:18 2013 -0800

    Merge tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug
        - Major overhaul of ACPI host bridge add/start (Rafael Wysocki, Yinghai Lu)
        - Major overhaul of PCI/ACPI binding (Rafael Wysocki, Yinghai Lu)
        - Split out ACPI host bridge and ACPI PCI device hotplug (Yinghai Lu)
        - Stop caching _PRT and make independent of bus numbers (Yinghai Lu)
    
      PCI device hotplug
        - Clean up cpqphp dead code (Sasha Levin)
        - Disable ARI unless device and upstream bridge support it (Yijing Wang)
        - Initialize all hot-added devices (not functions 0-7) (Yijing Wang)
    
      Power management
        - Don't touch ASPM if disabled (Joe Lawrence)
        - Fix ASPM link state management (Myron Stowe)
    
      Miscellaneous
        - Fix PCI_EXP_FLAGS accessor (Alex Williamson)
        - Disable Bus Master in pci_device_shutdown (Konstantin Khlebnikov)
        - Document hotplug resource and MPS parameters (Yijing Wang)
        - Add accessor for PCIe capabilities (Myron Stowe)
        - Drop pciehp suspend/resume messages (Paul Bolle)
        - Make pci_slot built-in only (not a module) (Jiang Liu)
        - Remove unused PCI/ACPI bind ops (Jiang Liu)
        - Removed used pci_root_bus (Bjorn Helgaas)"
    
    * tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (51 commits)
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
      PCI: Fix PCI Express Capability accessors for PCI_EXP_FLAGS
      ACPI / PCI: Make pci_slot built-in only, not a module
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()
      PCI: acpiphp: Remove dead code for PCI host bridge hotplug
      PCI: acpiphp: Create companion ACPI devices before creating PCI devices
      PCI: Remove unused "rc" in virtfn_add_bus()
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI/ASPM: Don't touch ASPM if forcibly disabled
      PCI/ASPM: Deallocate upstream link state even if device is not PCIe
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      ...

commit 6c0cc950ae670403a362bdcbf3cde0df33744928
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 9 22:33:37 2013 +0100

    ACPI / PCI: Set root bridge ACPI handle in advance
    
    The ACPI handles of PCI root bridges need to be known to
    acpi_bind_one(), so that it can create the appropriate
    "firmware_node" and "physical_node" files for them, but currently
    the way it gets to know those handles is not exactly straightforward
    (to put it lightly).
    
    This is how it works, roughly:
    
      1. acpi_bus_scan() finds the handle of a PCI root bridge,
         creates a struct acpi_device object for it and passes that
         object to acpi_pci_root_add().
    
      2. acpi_pci_root_add() creates a struct acpi_pci_root object,
         populates its "device" field with its argument's address
         (device->handle is the ACPI handle found in step 1).
    
      3. The struct acpi_pci_root object created in step 2 is passed
         to pci_acpi_scan_root() and used to get resources that are
         passed to pci_create_root_bus().
    
      4. pci_create_root_bus() creates a struct pci_host_bridge object
         and passes its "dev" member to device_register().
    
      5. platform_notify(), which for systems with ACPI is set to
         acpi_platform_notify(), is called.
    
    So far, so good.  Now it starts to be "interesting".
    
      6. acpi_find_bridge_device() is used to find the ACPI handle of
         the given device (which is the PCI root bridge) and executes
         acpi_pci_find_root_bridge(), among other things, for the
         given device object.
    
      7. acpi_pci_find_root_bridge() uses the name (sic!) of the given
         device object to extract the segment and bus numbers of the PCI
         root bridge and passes them to acpi_get_pci_rootbridge_handle().
    
      8. acpi_get_pci_rootbridge_handle() browses the list of ACPI PCI
         root bridges and finds the one that matches the given segment
         and bus numbers.  Its handle is then used to initialize the
         ACPI handle of the PCI root bridge's device object by
         acpi_bind_one().  However, this is *exactly* the ACPI handle we
         started with in step 1.
    
    Needless to say, this is quite embarassing, but it may be avoided
    thanks to commit f3fd0c8 (ACPI: Allow ACPI handles of devices to be
    initialized in advance), which makes it possible to initialize the
    ACPI handle of a device before passing it to device_register().
    
    Accordingly, add a new __weak routine, pcibios_root_bridge_prepare(),
    defaulting to an empty implementation that can be replaced by the
    interested architecutres (x86 and ia64 at the moment) with functions
    that will set the root bridge's ACPI handle before its dev member is
    passed to device_register().  Make both x86 and ia64 provide such
    implementations of pcibios_root_bridge_prepare() and remove
    acpi_pci_find_root_bridge() and acpi_get_pci_rootbridge_handle() that
    aren't necessary any more.
    
    Included is a fix for breakage on systems with non-ACPI PCI host
    bridges from Bjorn Helgaas.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0c01261fe5a8..3d49094ed3e8 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -522,6 +522,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	sd = &info->sd;
 	sd->domain = domain;
 	sd->node = node;
+	sd->acpi = device->handle;
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -593,6 +594,14 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	return bus;
 }
 
+int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
+{
+	struct pci_sysdata *sd = bridge->bus->sysdata;
+
+	ACPI_HANDLE_SET(&bridge->dev, sd->acpi);
+	return 0;
+}
+
 int __init pci_acpi_init(void)
 {
 	struct pci_dev *dev = NULL;

commit a18e3690a52790a034d6540d54e8e1f1cd125da2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:02:53 2012 -0800

    X86: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitconst,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0c01261fe5a8..53ea60458e01 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -145,7 +145,7 @@ void __init pci_acpi_crs_quirks(void)
 }
 
 #ifdef	CONFIG_PCI_MMCONFIG
-static int __devinit check_segment(u16 seg, struct device *dev, char *estr)
+static int check_segment(u16 seg, struct device *dev, char *estr)
 {
 	if (seg) {
 		dev_err(dev,
@@ -168,9 +168,8 @@ static int __devinit check_segment(u16 seg, struct device *dev, char *estr)
 	return 0;
 }
 
-static int __devinit setup_mcfg_map(struct pci_root_info *info,
-				    u16 seg, u8 start, u8 end,
-				    phys_addr_t addr)
+static int setup_mcfg_map(struct pci_root_info *info, u16 seg, u8 start,
+			  u8 end, phys_addr_t addr)
 {
 	int result;
 	struct device *dev = &info->bridge->dev;
@@ -208,7 +207,7 @@ static void teardown_mcfg_map(struct pci_root_info *info)
 	}
 }
 #else
-static int __devinit setup_mcfg_map(struct pci_root_info *info,
+static int setup_mcfg_map(struct pci_root_info *info,
 				    u16 seg, u8 start, u8 end,
 				    phys_addr_t addr)
 {
@@ -474,7 +473,7 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 				info);
 }
 
-struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
+struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	struct acpi_device *device = root->device;
 	struct pci_root_info *info = NULL;

commit 0dcccc5c53c55565a6b1061e1b15894495c7c9b9
Merge: 05508270064e b4873931cc8c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Nov 9 10:00:10 2012 -0700

    Merge branch 'pci/mike-x86-tra' into next
    
    * pci/mike-x86-tra:
      x86/PCI: Allow x86 platforms to use translation offsets

commit b4873931cc8c934a9893d5962bde97aca23be983
Author: Mike Yoknis <mike.yoknis@hp.com>
Date:   Wed Nov 7 15:52:20 2012 -0700

    x86/PCI: Allow x86 platforms to use translation offsets
    
    The memory range descriptors in the _CRS control method contain an address
    translation offset for host bridges.  This value is used to translate
    addresses across the bridge.  The support to use _TRA values is present for
    other architectures but not for X86 platforms.
    
    For existing X86 platforms the _TRA value is zero.  Non-zero _TRA values
    are expected on future X86 platforms.  This change will register that value
    with the resource.
    
    Signed-off-by: Mike Yoknis <mike.yoknis@hp.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 192397c98606..9cecffc72e63 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -12,6 +12,7 @@ struct pci_root_info {
 	char name[16];
 	unsigned int res_num;
 	struct resource *res;
+	resource_size_t *res_offset;
 	struct pci_sysdata sd;
 #ifdef	CONFIG_PCI_MMCONFIG
 	bool mcfg_added;
@@ -305,6 +306,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->flags = flags;
 	res->start = start;
 	res->end = end;
+	info->res_offset[info->res_num] = addr.translation_offset;
 
 	if (!pci_use_crs) {
 		dev_printk(KERN_DEBUG, &info->bridge->dev,
@@ -374,7 +376,8 @@ static void add_resources(struct pci_root_info *info,
 				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
 				 res, conflict->name, conflict);
 		else
-			pci_add_resource(resources, res);
+			pci_add_resource_offset(resources, res,
+					info->res_offset[i]);
 	}
 }
 
@@ -382,6 +385,8 @@ static void free_pci_root_info_res(struct pci_root_info *info)
 {
 	kfree(info->res);
 	info->res = NULL;
+	kfree(info->res_offset);
+	info->res_offset = NULL;
 	info->res_num = 0;
 }
 
@@ -432,10 +437,20 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 		return;
 
 	size = sizeof(*info->res) * info->res_num;
-	info->res_num = 0;
 	info->res = kzalloc(size, GFP_KERNEL);
-	if (!info->res)
+	if (!info->res) {
+		info->res_num = 0;
+		return;
+	}
+
+	size = sizeof(*info->res_offset) * info->res_num;
+	info->res_num = 0;
+	info->res_offset = kzalloc(size, GFP_KERNEL);
+	if (!info->res_offset) {
+		kfree(info->res);
+		info->res = NULL;
 		return;
+	}
 
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				info);

commit 1f09b09b4de0e120800e49d806d264e7446ed446
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 29 17:26:54 2012 -0600

    x86/PCI: Ignore _SEG on HP xw9300
    
    The xw9300 BIOS supplies _SEG methods that are incorrect, which results
    in some LSI SCSI devices not being discovered.  This adds a quirk to
    ignore _SEG on this machine and default to zero.
    
    The xw9300 has three host bridges:
    
        ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-3f])
        ACPI: PCI Root Bridge [PCI1] (domain 0001 [bus 40-7f])
        ACPI: PCI Root Bridge [PCI2] (domain 0002 [bus 80-ff])
    
    When the BIOS "ACPI Bus Segmentation" option is enabled (as it is by
    default), the _SEG methods of the PCI1 and PCI2 bridges return 1 and 2,
    respectively.  However, the BIOS implementation appears to be incomplete,
    and we can't enumerate devices in those domains.
    
    But if we assume PCI1 and PCI2 really lead to buses in domain 0,
    everything works fine.  Windows XP and Vista also seem to ignore
    these _SEG methods.
    
    Reference: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=543308
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=15362
    Reported-and-Tested-by: Sean M. Pappalardo <pegasus@renegadetech.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 192397c98606..49e5195223db 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -22,6 +22,7 @@ struct pci_root_info {
 };
 
 static bool pci_use_crs = true;
+static bool pci_ignore_seg = false;
 
 static int __init set_use_crs(const struct dmi_system_id *id)
 {
@@ -35,7 +36,14 @@ static int __init set_nouse_crs(const struct dmi_system_id *id)
 	return 0;
 }
 
-static const struct dmi_system_id pci_use_crs_table[] __initconst = {
+static int __init set_ignore_seg(const struct dmi_system_id *id)
+{
+	printk(KERN_INFO "PCI: %s detected: ignoring ACPI _SEG\n", id->ident);
+	pci_ignore_seg = true;
+	return 0;
+}
+
+static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 	/* http://bugzilla.kernel.org/show_bug.cgi?id=14183 */
 	{
 		.callback = set_use_crs,
@@ -98,6 +106,16 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VERSION, "6JET85WW (1.43 )"),
 		},
 	},
+
+	/* https://bugzilla.kernel.org/show_bug.cgi?id=15362 */
+	{
+		.callback = set_ignore_seg,
+		.ident = "HP xw9300",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP xw9300 Workstation"),
+		},
+	},
 	{}
 };
 
@@ -108,7 +126,7 @@ void __init pci_acpi_crs_quirks(void)
 	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008)
 		pci_use_crs = false;
 
-	dmi_check_system(pci_use_crs_table);
+	dmi_check_system(pci_crs_quirks);
 
 	/*
 	 * If the user specifies "pci=use_crs" or "pci=nocrs" explicitly, that
@@ -455,6 +473,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	int pxm;
 #endif
 
+	if (pci_ignore_seg)
+		domain = 0;
+
 	if (domain && !pci_domains_supported) {
 		printk(KERN_WARNING "pci_bus %04x:%02x: "
 		       "ignored (multiple domains not supported)\n",

commit 4cd8daf05c7071ac80008c8d4368860110fa6466
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Sep 19 10:49:00 2012 -0700

    x86/PCI: Clear host bridge aperture struct resource
    
    Use kzalloc() so the struct resource doesn't contain garbage in
    fields we don't initialize.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: x86@kernel.org

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 505acdd6d600..192397c98606 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -305,7 +305,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->flags = flags;
 	res->start = start;
 	res->end = end;
-	res->child = NULL;
 
 	if (!pci_use_crs) {
 		dev_printk(KERN_DEBUG, &info->bridge->dev,
@@ -434,7 +433,7 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 
 	size = sizeof(*info->res) * info->res_num;
 	info->res_num = 0;
-	info->res = kmalloc(size, GFP_KERNEL);
+	info->res = kzalloc(size, GFP_KERNEL);
 	if (!info->res)
 		return;
 

commit 8503562fd4e8e261bd7ca442705c6e8f0fd88228
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Fri Jun 22 14:55:19 2012 +0800

    x86/PCI: get rid of redundant log messages
    
    For each resource of a PCI host bridge, the arch code and PCI
    code log following messages.  We don't need both, so drop the
    arch-specific printing.
    
        pci_root PNP0A08:00: host bridge window [io 0x0000-0x03af]
        pci_bus 0000:00: root bus resource [io  0x0000-0x03af]
    
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jiang Liu <liuj97@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 912b54b26d6a..505acdd6d600 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -314,13 +314,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	}
 
 	info->res_num++;
-	if (addr.translation_offset)
-		dev_info(&info->bridge->dev, "host bridge window %pR "
-			 "(PCI address [%#llx-%#llx])\n",
-			 res, res->start - addr.translation_offset,
-			 res->end - addr.translation_offset);
-	else
-		dev_info(&info->bridge->dev, "host bridge window %pR\n", res);
 
 	return AE_OK;
 }

commit c0fa40784cce9cc66b54499a3762cfe07e35353f
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Fri Jun 22 14:55:17 2012 +0800

    x86/PCI: update MMCONFIG information when hot-plugging PCI host bridges
    
    This patch enhances x86 arch-specific code to update MMCONFIG information
    when PCI host bridge hotplug event happens.
    
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jiang Liu <liuj97@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2bb885afe103..912b54b26d6a 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -13,6 +13,12 @@ struct pci_root_info {
 	unsigned int res_num;
 	struct resource *res;
 	struct pci_sysdata sd;
+#ifdef	CONFIG_PCI_MMCONFIG
+	bool mcfg_added;
+	u16 segment;
+	u8 start_bus;
+	u8 end_bus;
+#endif
 };
 
 static bool pci_use_crs = true;
@@ -119,6 +125,81 @@ void __init pci_acpi_crs_quirks(void)
 	       pci_use_crs ? "nocrs" : "use_crs");
 }
 
+#ifdef	CONFIG_PCI_MMCONFIG
+static int __devinit check_segment(u16 seg, struct device *dev, char *estr)
+{
+	if (seg) {
+		dev_err(dev,
+			"%s can't access PCI configuration "
+			"space under this host bridge.\n",
+			estr);
+		return -EIO;
+	}
+
+	/*
+	 * Failure in adding MMCFG information is not fatal,
+	 * just can't access extended configuration space of
+	 * devices under this host bridge.
+	 */
+	dev_warn(dev,
+		 "%s can't access extended PCI configuration "
+		 "space under this bridge.\n",
+		 estr);
+
+	return 0;
+}
+
+static int __devinit setup_mcfg_map(struct pci_root_info *info,
+				    u16 seg, u8 start, u8 end,
+				    phys_addr_t addr)
+{
+	int result;
+	struct device *dev = &info->bridge->dev;
+
+	info->start_bus = start;
+	info->end_bus = end;
+	info->mcfg_added = false;
+
+	/* return success if MMCFG is not in use */
+	if (raw_pci_ext_ops && raw_pci_ext_ops != &pci_mmcfg)
+		return 0;
+
+	if (!(pci_probe & PCI_PROBE_MMCONF))
+		return check_segment(seg, dev, "MMCONFIG is disabled,");
+
+	result = pci_mmconfig_insert(dev, seg, start, end, addr);
+	if (result == 0) {
+		/* enable MMCFG if it hasn't been enabled yet */
+		if (raw_pci_ext_ops == NULL)
+			raw_pci_ext_ops = &pci_mmcfg;
+		info->mcfg_added = true;
+	} else if (result != -EEXIST)
+		return check_segment(seg, dev,
+			 "fail to add MMCONFIG information,");
+
+	return 0;
+}
+
+static void teardown_mcfg_map(struct pci_root_info *info)
+{
+	if (info->mcfg_added) {
+		pci_mmconfig_delete(info->segment, info->start_bus,
+				    info->end_bus);
+		info->mcfg_added = false;
+	}
+}
+#else
+static int __devinit setup_mcfg_map(struct pci_root_info *info,
+				    u16 seg, u8 start, u8 end,
+				    phys_addr_t addr)
+{
+	return 0;
+}
+static void teardown_mcfg_map(struct pci_root_info *info)
+{
+}
+#endif
+
 static acpi_status
 resource_to_addr(struct acpi_resource *resource,
 			struct acpi_resource_address64 *addr)
@@ -331,8 +412,11 @@ static void __release_pci_root_info(struct pci_root_info *info)
 
 	free_pci_root_info_res(info);
 
+	teardown_mcfg_map(info);
+
 	kfree(info);
 }
+
 static void release_pci_root_info(struct pci_host_bridge *bridge)
 {
 	struct pci_root_info *info = bridge->release_data;
@@ -372,7 +456,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	int domain = root->segment;
 	int busnum = root->secondary.start;
 	LIST_HEAD(resources);
-	struct pci_bus *bus;
+	struct pci_bus *bus = NULL;
 	struct pci_sysdata *sd;
 	int node;
 #ifdef CONFIG_ACPI_NUMA
@@ -438,8 +522,11 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 			x86_pci_root_bus_resources(busnum, &resources);
 		}
 
-		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
-					  &resources);
+		if (!setup_mcfg_map(info, domain, (u8)root->secondary.start,
+				    (u8)root->secondary.end, root->mcfg_addr))
+			bus = pci_create_root_bus(NULL, busnum, &pci_root_ops,
+						  sd, &resources);
+
 		if (bus) {
 			pci_scan_child_bus(bus);
 			pci_set_host_bridge_release(

commit 5c1d81d160cc46e36fdd06702885c98c2643b4c5
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    x86/PCI: use _CRS bus number aperture for host bridges from ACPI
    
    Add the host bridge bus number aperture from _CRS to the resource list.
    Like the MMIO and I/O port apertures, this will be used when assigning
    resources to hot-added devices or in the case of conflicts.
    
    Note that we always use the _CRS bus number aperture, even if we're
    ignoring _CRS otherwise.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 350fe63c8a42..2bb885afe103 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -12,7 +12,6 @@ struct pci_root_info {
 	char name[16];
 	unsigned int res_num;
 	struct resource *res;
-	int busnum;
 	struct pci_sysdata sd;
 };
 
@@ -347,7 +346,9 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 {
 	size_t size;
 
+	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
 	info->bridge = device;
+
 	info->res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
 				info);
@@ -360,8 +361,6 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 	if (!info->res)
 		return;
 
-	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
-
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				info);
 }
@@ -426,6 +425,8 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	} else {
 		probe_pci_root_info(info, device, busnum, domain);
 
+		/* insert busn res at first */
+		pci_add_resource(&resources,  &root->secondary);
 		/*
 		 * _CRS with no apertures is normal, so only fall back to
 		 * defaults or native bridge info if we're ignoring _CRS.
@@ -440,7 +441,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
 					  &resources);
 		if (bus) {
-			bus->busn_res.end = pci_scan_child_bus(bus);
+			pci_scan_child_bus(bus);
 			pci_set_host_bridge_release(
 				to_pci_host_bridge(bus->bridge),
 				release_pci_root_info, info);

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index fc09c2754e08..350fe63c8a42 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -440,7 +440,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
 					  &resources);
 		if (bus) {
-			bus->subordinate = pci_scan_child_bus(bus);
+			bus->busn_res.end = pci_scan_child_bus(bus);
 			pci_set_host_bridge_release(
 				to_pci_host_bridge(bus->bridge),
 				release_pci_root_info, info);

commit 74d24b219bc4ebb20b75d63af2bb577bc1b10b5e
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Thu Apr 26 15:32:55 2012 +0800

    resources: add resource_overlaps()
    
    Add resource_overlaps(), which returns true if two resources overlap at all.
    
    Use this to replace the complicated check in coalesce_windows().
    
    Signed-Off-By: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 8a17b23f8c84..fc09c2754e08 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -245,13 +245,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	return AE_OK;
 }
 
-static bool resource_contains(struct resource *res, resource_size_t point)
-{
-	if (res->start <= point && point <= res->end)
-		return true;
-	return false;
-}
-
 static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 {
 	int i, j;
@@ -272,10 +265,7 @@ static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 			 * our resources no longer match the ACPI _CRS, but
 			 * the kernel resource tree doesn't allow overlaps.
 			 */
-			if (resource_contains(res1, res2->start) ||
-			    resource_contains(res1, res2->end) ||
-			    resource_contains(res2, res1->start) ||
-			    resource_contains(res2, res1->end)) {
+			if (resource_overlaps(res1, res2)) {
 				res1->start = min(res1->start, res2->start);
 				res1->end = max(res1->end, res2->end);
 				dev_info(&info->bridge->dev,

commit 35cb05e5bdac209cfdfafbe50d89ee7069cb6237
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    x86/PCI: embed pci_sysdata into pci_root_info on ACPI path
    
    Embed the x86 struct pci_sysdata in the struct pci_root_info so it
    will be automatically freed in the remove path.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 23e7361b1747..8a17b23f8c84 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -13,6 +13,7 @@ struct pci_root_info {
 	unsigned int res_num;
 	struct resource *res;
 	int busnum;
+	struct pci_sysdata sd;
 };
 
 static bool pci_use_crs = true;
@@ -410,26 +411,16 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	if (node != -1 && !node_online(node))
 		node = -1;
 
-	/* Allocate per-root-bus (not per bus) arch-specific data.
-	 * TODO: leak; this memory is never freed.
-	 * It's arguable whether it's worth the trouble to care.
-	 */
-	sd = kzalloc(sizeof(*sd), GFP_KERNEL);
-	if (!sd) {
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
 		printk(KERN_WARNING "pci_bus %04x:%02x: "
 		       "ignored (out of memory)\n", domain, busnum);
 		return NULL;
 	}
 
+	sd = &info->sd;
 	sd->domain = domain;
 	sd->node = node;
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (!info) {
-		kfree(sd);
-		printk(KERN_WARNING "pci_bus %04x:%02x: "
-		       "ignored (out of memory)\n", domain, busnum);
-		return NULL;
-	}
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -442,7 +433,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		 */
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(info);
-		kfree(sd);
 	} else {
 		probe_pci_root_info(info, device, busnum, domain);
 
@@ -484,9 +474,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		}
 	}
 
-	if (!bus)
-		kfree(sd);
-
 	if (bus && node != -1) {
 #ifdef CONFIG_ACPI_NUMA
 		if (pxm >= 0)

commit fe05725ff97530e26109a0c3d52cef7fff326e15
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    x86/PCI: embed name into pci_root_info struct
    
    We now keep the pci_root_info struct for the entire lifetime of the
    host bridge, so just embed the name in the struct rather than
    allocating it separately.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2b74a161d215..23e7361b1747 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -9,7 +9,7 @@
 
 struct pci_root_info {
 	struct acpi_device *bridge;
-	char *name;
+	char name[16];
 	unsigned int res_num;
 	struct resource *res;
 	int busnum;
@@ -317,7 +317,6 @@ static void add_resources(struct pci_root_info *info,
 
 static void free_pci_root_info_res(struct pci_root_info *info)
 {
-	kfree(info->name);
 	kfree(info->res);
 	info->res = NULL;
 	info->res_num = 0;
@@ -370,9 +369,7 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 	if (!info->res)
 		return;
 
-	info->name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
-	if (!info->name)
-		return;
+	sprintf(info->name, "PCI Bus %04x:%02x", domain, busnum);
 
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				info);

commit fd3b0c1ea482e863d6a2556b6686e35bec7a4f1c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    x86/PCI: add host bridge resource release for _CRS path
    
    1. Allocate pci_root_info instead of using stack.  We need to pass around
       info for release function.
    2. Add release_pci_root_info
    3. Set x86 host bridge release function to make sure root bridge
       related resources get freed during root bus removal.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index a858c1d9af53..2b74a161d215 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -315,11 +315,40 @@ static void add_resources(struct pci_root_info *info,
 	}
 }
 
-static void free_pci_root_info(struct pci_root_info *info)
+static void free_pci_root_info_res(struct pci_root_info *info)
 {
 	kfree(info->name);
 	kfree(info->res);
-	memset(info, 0, sizeof(struct pci_root_info));
+	info->res = NULL;
+	info->res_num = 0;
+}
+
+static void __release_pci_root_info(struct pci_root_info *info)
+{
+	int i;
+	struct resource *res;
+
+	for (i = 0; i < info->res_num; i++) {
+		res = &info->res[i];
+
+		if (!res->parent)
+			continue;
+
+		if (!(res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))
+			continue;
+
+		release_resource(res);
+	}
+
+	free_pci_root_info_res(info);
+
+	kfree(info);
+}
+static void release_pci_root_info(struct pci_host_bridge *bridge)
+{
+	struct pci_root_info *info = bridge->release_data;
+
+	__release_pci_root_info(info);
 }
 
 static void
@@ -352,7 +381,7 @@ probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	struct acpi_device *device = root->device;
-	struct pci_root_info info;
+	struct pci_root_info *info = NULL;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
 	LIST_HEAD(resources);
@@ -397,7 +426,13 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 
 	sd->domain = domain;
 	sd->node = node;
-	memset(&info, 0, sizeof(struct pci_root_info));
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		kfree(sd);
+		printk(KERN_WARNING "pci_bus %04x:%02x: "
+		       "ignored (out of memory)\n", domain, busnum);
+		return NULL;
+	}
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -409,29 +444,33 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		 * be replaced by sd.
 		 */
 		memcpy(bus->sysdata, sd, sizeof(*sd));
+		kfree(info);
 		kfree(sd);
 	} else {
-		probe_pci_root_info(&info, device, busnum, domain);
+		probe_pci_root_info(info, device, busnum, domain);
 
 		/*
 		 * _CRS with no apertures is normal, so only fall back to
 		 * defaults or native bridge info if we're ignoring _CRS.
 		 */
 		if (pci_use_crs)
-			add_resources(&info, &resources);
+			add_resources(info, &resources);
 		else {
-			free_pci_root_info(&info);
+			free_pci_root_info_res(info);
 			x86_pci_root_bus_resources(busnum, &resources);
 		}
+
 		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
 					  &resources);
-		if (bus)
+		if (bus) {
 			bus->subordinate = pci_scan_child_bus(bus);
-		else
+			pci_set_host_bridge_release(
+				to_pci_host_bridge(bus->bridge),
+				release_pci_root_info, info);
+		} else {
 			pci_free_resource_list(&resources);
-
-		if (!bus && pci_use_crs)
-			free_pci_root_info(&info);
+			__release_pci_root_info(info);
+		}
 	}
 
 	/* After the PCI-E bus has been walked and all devices discovered,

commit 9a03d28d9490b5a04f8b1d98fc08067c6f4f6189
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    x86/PCI: refactor get_current_resources()
    
    Rename get_current_resources() to probe_pci_root_info.
    
    1. Remove resource list head from pci_root_info
    2. Make get_current_resources() not pass resources
    3. Rename get_current_resources() to probe_pci_root_info()
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index a99b7d75f5ca..a858c1d9af53 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -12,7 +12,6 @@ struct pci_root_info {
 	char *name;
 	unsigned int res_num;
 	struct resource *res;
-	struct list_head *resources;
 	int busnum;
 };
 
@@ -287,7 +286,8 @@ static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 	}
 }
 
-static void add_resources(struct pci_root_info *info)
+static void add_resources(struct pci_root_info *info,
+			  struct list_head *resources)
 {
 	int i;
 	struct resource *res, *root, *conflict;
@@ -311,7 +311,7 @@ static void add_resources(struct pci_root_info *info)
 				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
 				 res, conflict->name, conflict);
 		else
-			pci_add_resource(info->resources, res);
+			pci_add_resource(resources, res);
 	}
 }
 
@@ -323,41 +323,30 @@ static void free_pci_root_info(struct pci_root_info *info)
 }
 
 static void
-get_current_resources(struct pci_root_info *info,
-		      struct acpi_device *device, int busnum,
-		      int domain, struct list_head *resources)
+probe_pci_root_info(struct pci_root_info *info, struct acpi_device *device,
+		    int busnum, int domain)
 {
 	size_t size;
 
 	info->bridge = device;
 	info->res_num = 0;
-	info->resources = resources;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
 				info);
 	if (!info->res_num)
 		return;
 
 	size = sizeof(*info->res) * info->res_num;
+	info->res_num = 0;
 	info->res = kmalloc(size, GFP_KERNEL);
 	if (!info->res)
 		return;
 
 	info->name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
 	if (!info->name)
-		goto name_alloc_fail;
+		return;
 
-	info->res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				info);
-
-	if (pci_use_crs) {
-		add_resources(info);
-
-		return;
-	}
-
-name_alloc_fail:
-	free_pci_root_info(info);
 }
 
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
@@ -422,15 +411,18 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(sd);
 	} else {
-		get_current_resources(&info, device, busnum, domain,
-					&resources);
+		probe_pci_root_info(&info, device, busnum, domain);
 
 		/*
 		 * _CRS with no apertures is normal, so only fall back to
 		 * defaults or native bridge info if we're ignoring _CRS.
 		 */
-		if (!pci_use_crs)
+		if (pci_use_crs)
+			add_resources(&info, &resources);
+		else {
+			free_pci_root_info(&info);
 			x86_pci_root_bus_resources(busnum, &resources);
+		}
 		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
 					  &resources);
 		if (bus)

commit baa495d9de2af97310128bfc0e365a813b63d5bb
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    x86/PCI: fix memleak with get_current_resources()
    
    In pci_scan_acpi_root(), when pci_use_crs is set, get_current_resources()
    is used to get pci_root_info, and it will allocate name and resource array.
    
    Later if pci_create_root_bus() can not create bus (could be already
    there...) it will only free bus res list, but the name and res array is not
    freed.
    
    Let get_current_resource() take info pointer instead of using local info.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index ed2835e148b5..a99b7d75f5ca 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -315,49 +315,55 @@ static void add_resources(struct pci_root_info *info)
 	}
 }
 
+static void free_pci_root_info(struct pci_root_info *info)
+{
+	kfree(info->name);
+	kfree(info->res);
+	memset(info, 0, sizeof(struct pci_root_info));
+}
+
 static void
-get_current_resources(struct acpi_device *device, int busnum,
+get_current_resources(struct pci_root_info *info,
+		      struct acpi_device *device, int busnum,
 		      int domain, struct list_head *resources)
 {
-	struct pci_root_info info;
 	size_t size;
 
-	info.bridge = device;
-	info.res_num = 0;
-	info.resources = resources;
+	info->bridge = device;
+	info->res_num = 0;
+	info->resources = resources;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
-				&info);
-	if (!info.res_num)
+				info);
+	if (!info->res_num)
 		return;
 
-	size = sizeof(*info.res) * info.res_num;
-	info.res = kmalloc(size, GFP_KERNEL);
-	if (!info.res)
+	size = sizeof(*info->res) * info->res_num;
+	info->res = kmalloc(size, GFP_KERNEL);
+	if (!info->res)
 		return;
 
-	info.name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
-	if (!info.name)
+	info->name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
+	if (!info->name)
 		goto name_alloc_fail;
 
-	info.res_num = 0;
+	info->res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
-				&info);
+				info);
 
 	if (pci_use_crs) {
-		add_resources(&info);
+		add_resources(info);
 
 		return;
 	}
 
-	kfree(info.name);
-
 name_alloc_fail:
-	kfree(info.res);
+	free_pci_root_info(info);
 }
 
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	struct acpi_device *device = root->device;
+	struct pci_root_info info;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
 	LIST_HEAD(resources);
@@ -402,6 +408,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 
 	sd->domain = domain;
 	sd->node = node;
+	memset(&info, 0, sizeof(struct pci_root_info));
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -415,7 +422,8 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(sd);
 	} else {
-		get_current_resources(device, busnum, domain, &resources);
+		get_current_resources(&info, device, busnum, domain,
+					&resources);
 
 		/*
 		 * _CRS with no apertures is normal, so only fall back to
@@ -429,6 +437,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 			bus->subordinate = pci_scan_child_bus(bus);
 		else
 			pci_free_resource_list(&resources);
+
+		if (!bus && pci_use_crs)
+			free_pci_root_info(&info);
 	}
 
 	/* After the PCI-E bus has been walked and all devices discovered,

commit 475c77edf826333aa61625f49d6a2bec26ecb5a6
Merge: 934e18b5cb45 1488d5158dcd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 14:02:12 2012 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    Pull PCI changes (including maintainer change) from Jesse Barnes:
     "This pull has some good cleanups from Bjorn and Yinghai, as well as
      some more code from Yinghai to better handle resource re-allocation
      when enabled.
    
      There's also a new initcall_debug feature from Arjan which will print
      out quirk timing information to help identify slow quirks for fixing
      or refinement (Yinghai sent in a few patches to do just that once the
      new debug code landed).
    
      Beyond that, I'm handing off PCI maintainership to Bjorn Helgaas.
      He's been a core PCI and Linux contributor for some time now, and has
      kindly volunteered to take over.  I just don't feel I have the time
      for PCI review and work that it deserves lately (I've taken on some
      other projects), and haven't been as responsive lately as I'd like, so
      I approached Bjorn asking if he'd like to manage things.  He's going
      to give it a try, and I'm confident he'll do at least as well as I
      have in keeping the tree managed, patches flowing, and keeping things
      stable."
    
    Fix up some fairly trivial conflicts due to other cleanups (mips device
    resource fixup cleanups clashing with list handling cleanup, ppc iseries
    removal clashing with pci_probe_only cleanup etc)
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (112 commits)
      PCI: Bjorn gets PCI hotplug too
      PCI: hand PCI maintenance over to Bjorn Helgaas
      unicore32/PCI: move <asm-generic/pci-bridge.h> include to asm/pci.h
      sparc/PCI: convert devtree and arch-probed bus addresses to resource
      powerpc/PCI: allow reallocation on PA Semi
      powerpc/PCI: convert devtree bus addresses to resource
      powerpc/PCI: compute I/O space bus-to-resource offset consistently
      arm/PCI: don't export pci_flags
      PCI: fix bridge I/O window bus-to-resource conversion
      x86/PCI: add spinlock held check to 'pcibios_fwaddrmap_lookup()'
      PCI / PCIe: Introduce command line option to disable ARI
      PCI: make acpihp use __pci_remove_bus_device instead
      PCI: export __pci_remove_bus_device
      PCI: Rename pci_remove_behind_bridge to pci_stop_and_remove_behind_bridge
      PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
      PCI: print out PCI device info along with duration
      PCI: Move "pci reassigndev resource alignment" out of quirks.c
      PCI: Use class for quirk for usb host controller fixup
      PCI: Use class for quirk for ti816x class fixup
      PCI: Use class for quirk for intel e100 interrupt fixup
      ...

commit a97f4f5e524bcd09a85ef0b8821a14d35e69335f
Author: Jonathan Nieder <jrnieder@gmail.com>
Date:   Tue Feb 28 15:31:35 2012 -0600

    x86/PCI: do not tie MSI MS-7253 use_crs quirk to BIOS version
    
    Carlos was getting
    
            WARNING: at drivers/pci/pci.c:118 pci_ioremap_bar+0x24/0x52()
    
    when probing his sound card, and sound did not work.  After adding
    pci=use_crs to the kernel command line, no more trouble.
    
    Ok, we can add a quirk.  dmidecode output reveals that this is an MSI
    MS-7253, for which we already have a quirk, but the short-sighted
    author tied the quirk to a single BIOS version, making it not kick in
    on Carlos's machine with BIOS V1.2.  If a later BIOS update makes it
    no longer necessary to look at the _CRS info it will still be
    harmless, so let's stop trying to guess which versions have and don't
    have accurate _CRS tables.
    
    Addresses https://bugtrack.alsa-project.org/alsa-bug/view.php?id=5533
    Also see <https://bugzilla.kernel.org/show_bug.cgi?id=42619>.
    
    Reported-by: Carlos Luna <caralu74@gmail.com>
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 7034c081b226..49a5cb55429b 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -68,7 +68,6 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
 			DMI_MATCH(DMI_BOARD_NAME, "MS-7253"),
 			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
-			DMI_MATCH(DMI_BIOS_VERSION, "V1.6"),
 		},
 	},
 

commit 8411371709610c826bf65684f886bfdfb5780ca1
Author: Jonathan Nieder <jrnieder@gmail.com>
Date:   Tue Feb 28 11:51:10 2012 -0700

    x86/PCI: use host bridge _CRS info on MSI MS-7253
    
    In the spirit of commit 29cf7a30f8a0 ("x86/PCI: use host bridge _CRS
    info on ASUS M2V-MX SE"), this DMI quirk turns on "pci_use_crs" by
    default on a board that needs it.
    
    This fixes boot failures and oopses introduced in 3e3da00c01d0
    ("x86/pci: AMD one chain system to use pci read out res").  The quirk
    is quite targetted (to a specific board and BIOS version) for two
    reasons:
    
     (1) to emphasize that this method of tackling the problem one quirk
         at a time is a little insane
    
     (2) to give BIOS vendors an opportunity to use simpler tables and
         allow us to return to generic behavior (whatever that happens to
         be) with a later BIOS update
    
    In other words, I am not at all happy with having quirks like this.
    But it is even worse for the kernel not to work out of the box on
    these machines, so...
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=42619
    Reported-by: Svante Signell <svante.signell@telia.com>
    Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index c33e0970ee9f..7034c081b226 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -60,6 +60,17 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
 		},
 	},
+	/* https://bugzilla.kernel.org/show_bug.cgi?id=42619 */
+	{
+		.callback = set_use_crs,
+		.ident = "MSI MS-7253",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-7253"),
+			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
+			DMI_MATCH(DMI_BIOS_VERSION, "V1.6"),
+		},
+	},
 
 	/* Now for the blacklist.. */
 

commit 1cc1c96c1658bfaf85d06d764bd7ac00640ae90f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Feb 20 17:23:47 2012 -0800

    PCI: fix memleak when ACPI _CRS is not used.
    
    warning:
    unreferenced object 0xffff8801f6914200 (size 512):
      comm "swapper/0", pid 1, jiffies 4294893643 (age 2664.644s)
      hex dump (first 32 bytes):
        00 00 c0 fe 00 00 00 00 ff ff ff ff 00 00 00 00  ................
        60 58 2f f6 03 88 ff ff 00 02 00 00 00 00 00 00  `X/.............
      backtrace:
        [<ffffffff81c2408c>] kmemleak_alloc+0x26/0x43
        [<ffffffff8113764f>] __kmalloc+0x121/0x183
        [<ffffffff81ca8d93>] get_current_resources+0x5a/0xc6
        [<ffffffff81c5bedd>] pci_acpi_scan_root+0x13c/0x21c
        [<ffffffff81c2a745>] acpi_pci_root_add+0x1e1/0x421
        [<ffffffff81408f50>] acpi_device_probe+0x50/0x190
        [<ffffffff8149edc7>] really_probe+0x99/0x126
        [<ffffffff8149ef83>] driver_probe_device+0x3b/0x56
        [<ffffffff8149effd>] __driver_attach+0x5f/0x82
        [<ffffffff8149d860>] bus_for_each_dev+0x5c/0x88
        [<ffffffff8149eb87>] driver_attach+0x1e/0x20
        [<ffffffff8149e7cc>] bus_add_driver+0xca/0x21d
        [<ffffffff8149f47b>] driver_register+0x91/0xfe
        [<ffffffff81409d09>] acpi_bus_register_driver+0x43/0x45
        [<ffffffff8278bdc9>] acpi_pci_root_init+0x20/0x28
        [<ffffffff810001e7>] do_one_initcall+0x57/0x134
    
    The system has _CRS for root buses, but they are not used because the machine
    date is before the cutoff date for _CRS usage.
    
    Try to free those unused resource arrays and names.
    
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index a312e76063a7..c33e0970ee9f 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -282,9 +282,6 @@ static void add_resources(struct pci_root_info *info)
 	int i;
 	struct resource *res, *root, *conflict;
 
-	if (!pci_use_crs)
-		return;
-
 	coalesce_windows(info, IORESOURCE_MEM);
 	coalesce_windows(info, IORESOURCE_IO);
 
@@ -336,8 +333,13 @@ get_current_resources(struct acpi_device *device, int busnum,
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				&info);
 
-	add_resources(&info);
-	return;
+	if (pci_use_crs) {
+		add_resources(&info);
+
+		return;
+	}
+
+	kfree(info.name);
 
 name_alloc_fail:
 	kfree(info.res);

commit 316d86fe8641abfad32702c77d9e62cf19e68b00
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jan 17 17:41:21 2012 -0700

    x86/PCI: don't fall back to defaults if _CRS has no apertures
    
    Host bridges that lead to things like the Uncore need not have any
    I/O port or MMIO apertures.  For example, in this case:
    
        ACPI: PCI Root Bridge [UNC1] (domain 0000 [bus ff])
        PCI: root bus ff: using default resources
        PCI host bridge to bus 0000:ff
        pci_bus 0000:ff: root bus resource [io  0x0000-0xffff]
        pci_bus 0000:ff: root bus resource [mem 0x00000000-0x3fffffffffff]
    
    we should not pretend those default resources are available on bus ff.
    
    CC: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index a312e76063a7..daa42490c1d9 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -404,7 +404,12 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		kfree(sd);
 	} else {
 		get_current_resources(device, busnum, domain, &resources);
-		if (list_empty(&resources))
+
+		/*
+		 * _CRS with no apertures is normal, so only fall back to
+		 * defaults or native bridge info if we're ignoring _CRS.
+		 */
+		if (!pci_use_crs)
 			x86_pci_root_bus_resources(busnum, &resources);
 		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
 					  &resources);

commit 2cd6975a4ff92a75e46240109d01c1daf4682e5d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:28:14 2011 -0600

    x86/PCI: convert to pci_create_root_bus() and pci_scan_root_bus()
    
    x86 has two kinds of PCI root bus scanning:
    
    (1) ACPI-based, using _CRS resources.  This used pci_create_bus(), not
        pci_scan_bus(), because ACPI hotplug needed to split the
        pci_bus_add_devices() into a separate host bridge .start() method.
    
        This patch parses the _CRS resources earlier, so we can build a list of
        resources and pass it to pci_create_root_bus().
    
        Note that as before, we parse the _CRS even if we aren't going to use
        it so we can print it for debugging purposes.
    
    (2) All other, which used either default resources (ioport_resource and
        iomem_resource) or information read from the hardware via amd_bus.c or
        similar.  This used pci_scan_bus().
    
        This patch converts x86_pci_root_bus_res_quirks() (previously called
        from pcibios_fixup_bus()) to x86_pci_root_bus_resources(), which builds
        a list of resources before we call pci_scan_root_bus().
    
        We also use x86_pci_root_bus_resources() if we have ACPI but are
        ignoring _CRS.
    
    CC: Yinghai Lu <yinghai.lu@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 425500bb24e6..a312e76063a7 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -12,7 +12,7 @@ struct pci_root_info {
 	char *name;
 	unsigned int res_num;
 	struct resource *res;
-	struct pci_bus *bus;
+	struct list_head *resources;
 	int busnum;
 };
 
@@ -304,23 +304,20 @@ static void add_resources(struct pci_root_info *info)
 				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
 				 res, conflict->name, conflict);
 		else
-			pci_bus_add_resource(info->bus, res, 0);
+			pci_add_resource(info->resources, res);
 	}
 }
 
 static void
 get_current_resources(struct acpi_device *device, int busnum,
-			int domain, struct pci_bus *bus)
+		      int domain, struct list_head *resources)
 {
 	struct pci_root_info info;
 	size_t size;
 
-	if (pci_use_crs)
-		pci_bus_remove_resources(bus);
-
 	info.bridge = device;
-	info.bus = bus;
 	info.res_num = 0;
+	info.resources = resources;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
 				&info);
 	if (!info.res_num)
@@ -329,7 +326,7 @@ get_current_resources(struct acpi_device *device, int busnum,
 	size = sizeof(*info.res) * info.res_num;
 	info.res = kmalloc(size, GFP_KERNEL);
 	if (!info.res)
-		goto res_alloc_fail;
+		return;
 
 	info.name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
 	if (!info.name)
@@ -344,8 +341,6 @@ get_current_resources(struct acpi_device *device, int busnum,
 
 name_alloc_fail:
 	kfree(info.res);
-res_alloc_fail:
-	return;
 }
 
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
@@ -353,6 +348,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	struct acpi_device *device = root->device;
 	int domain = root->segment;
 	int busnum = root->secondary.start;
+	LIST_HEAD(resources);
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
 	int node;
@@ -407,11 +403,15 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(sd);
 	} else {
-		bus = pci_create_bus(NULL, busnum, &pci_root_ops, sd);
-		if (bus) {
-			get_current_resources(device, busnum, domain, bus);
+		get_current_resources(device, busnum, domain, &resources);
+		if (list_empty(&resources))
+			x86_pci_root_bus_resources(busnum, &resources);
+		bus = pci_create_root_bus(NULL, busnum, &pci_root_ops, sd,
+					  &resources);
+		if (bus)
 			bus->subordinate = pci_scan_child_bus(bus);
-		}
+		else
+			pci_free_resource_list(&resources);
 	}
 
 	/* After the PCI-E bus has been walked and all devices discovered,

commit ae5cd86455381282ece162966183d3f208c6fad7
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Mon Nov 14 15:42:16 2011 -0800

    x86/PCI: Ignore CPU non-addressable _CRS reserved memory resources
    
    This assures that a _CRS reserved host bridge window or window region is
    not used if it is not addressable by the CPU.  The new code either trims
    the window to exclude the non-addressable portion or totally ignores the
    window if the entire window is non-addressable.
    
    The current code has been shown to be problematic with 32-bit non-PAE
    kernels on systems where _CRS reserves resources above 4GB.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Thomas Renninger <trenn@novell.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: stable@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index e662ceebd798..425500bb24e6 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -178,7 +178,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 	unsigned long flags;
-	u64 start, end;
+	u64 start, orig_end, end;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -194,7 +194,21 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 		return AE_OK;
 
 	start = addr.minimum + addr.translation_offset;
-	end = addr.maximum + addr.translation_offset;
+	orig_end = end = addr.maximum + addr.translation_offset;
+
+	/* Exclude non-addressable range or non-addressable portion of range */
+	end = min(end, (u64)iomem_resource.end);
+	if (end <= start) {
+		dev_info(&info->bridge->dev,
+			"host bridge window [%#llx-%#llx] "
+			"(ignored, not CPU addressable)\n", start, orig_end);
+		return AE_OK;
+	} else if (orig_end != end) {
+		dev_info(&info->bridge->dev,
+			"host bridge window [%#llx-%#llx] "
+			"([%#llx-%#llx] ignored, not CPU addressable)\n", 
+			start, orig_end, end + 1, orig_end);
+	}
 
 	res = &info->res[info->res_num];
 	res->name = info->name;

commit 8b6a5af92c03b363df050da906480085b6cd6e00
Author: Dave Jones <davej@redhat.com>
Date:   Wed Jan 4 11:30:52 2012 -0500

    PCI: Add Thinkpad SL510 to pci=nocrs blacklist
    
    Enabling CRS by default breaks suspend on the Thinkpad SL510.
    Details in https://bugzilla.redhat.com/show_bug.cgi?id=769657
    
    Reported-by: Stefan Kirrmann <stefan.kirrmann@gmail.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0d9329f203e9..e662ceebd798 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -73,6 +73,16 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VERSION, "A09"),
 		},
 	},
+	/* https://bugzilla.redhat.com/show_bug.cgi?id=769657 */
+	{
+		.callback = set_nouse_crs,
+		.ident = "Thinkpad SL510",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_BOARD_NAME, "2847DFG"),
+			DMI_MATCH(DMI_BIOS_VERSION, "6JET85WW (1.43 )"),
+		},
+	},
 	{}
 };
 

commit e702781fa846dd726b73e673f91ffbd3b0e8d114
Author: Dave Jones <davej@redhat.com>
Date:   Wed Jan 4 11:33:12 2012 -0500

    PCI: Add Dell Studio 1557 to pci=nocrs blacklist
    
    The Dell Studio 1557 also doesn't suspend correctly when CRS is enabled.
    Details at https://bugzilla.redhat.com/show_bug.cgi?id=769657
    
    Reported-by: Gregory S. Hoerner <ghoerner@transcendingthought.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index f5ccf29cd6aa..0d9329f203e9 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -61,6 +61,18 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 		},
 	},
 
+	/* Now for the blacklist.. */
+
+	/* https://bugzilla.redhat.com/show_bug.cgi?id=769657 */
+	{
+		.callback = set_nouse_crs,
+		.ident = "Dell Studio 1557",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1557"),
+			DMI_MATCH(DMI_BIOS_VERSION, "A09"),
+		},
+	},
 	{}
 };
 

commit 28c3c05d337f6fdf84faf69374e6325b80cbf9ad
Author: Dave Jones <davej@redhat.com>
Date:   Fri Dec 30 14:37:05 2011 -0500

    PCI: add set_nouse_crs for use by a pci=nocrs blacklist
    
    Some machines don't boot unless passed pci=nocrs.
    (See https://bugzilla.redhat.com/show_bug.cgi?id=770308 for details of
      one report. Waiting on dmidecode output for others).
    
    Currently there is a DMI whitelist, even though the default is on.
    
    v2: drop the 1536 blacklist entry, superceded by the PNP/MMCONFIG changes from
        Bjorn
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 404f21a3ff9e..f5ccf29cd6aa 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -24,6 +24,12 @@ static int __init set_use_crs(const struct dmi_system_id *id)
 	return 0;
 }
 
+static int __init set_nouse_crs(const struct dmi_system_id *id)
+{
+	pci_use_crs = false;
+	return 0;
+}
+
 static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 	/* http://bugzilla.kernel.org/show_bug.cgi?id=14183 */
 	{
@@ -54,6 +60,7 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
 		},
 	},
+
 	{}
 };
 

commit 29cf7a30f8a0ce4af2406d93d5a332099be26923
Author: Paul Menzel <paulepanter@users.sourceforge.net>
Date:   Wed Aug 31 17:07:10 2011 +0200

    x86/PCI: use host bridge _CRS info on ASUS M2V-MX SE
    
    In summary, this DMI quirk uses the _CRS info by default for the ASUS
    M2V-MX SE by turning on `pci=use_crs` and is similar to the quirk
    added by commit 2491762cfb47 ("x86/PCI: use host bridge _CRS info on
    ASRock ALiveSATA2-GLAN") whose commit message should be read for further
    information.
    
    Since commit 3e3da00c01d0 ("x86/pci: AMD one chain system to use pci
    read out res") Linux gives the following oops:
    
        parport0: PC-style at 0x378, irq 7 [PCSPP,TRISTATE]
        HDA Intel 0000:20:01.0: PCI INT A -> GSI 17 (level, low) -> IRQ 17
        HDA Intel 0000:20:01.0: setting latency timer to 64
        BUG: unable to handle kernel paging request at ffffc90011c08000
        IP: [<ffffffffa0578402>] azx_probe+0x3ad/0x86b [snd_hda_intel]
        PGD 13781a067 PUD 13781b067 PMD 1300ba067 PTE 800000fd00000173
        Oops: 0009 [#1] SMP
        last sysfs file: /sys/module/snd_pcm/initstate
        CPU 0
        Modules linked in: snd_hda_intel(+) snd_hda_codec snd_hwdep snd_pcm_oss snd_mixer_oss snd_pcm snd_seq_midi snd_rawmidi snd_seq_midi_event tpm_tis tpm snd_seq tpm_bios psmouse parport_pc snd_timer snd_seq_device parport processor evdev snd i2c_viapro thermal_sys amd64_edac_mod k8temp i2c_core soundcore shpchp pcspkr serio_raw asus_atk0110 pci_hotplug edac_core button snd_page_alloc edac_mce_amd ext3 jbd mbcache sha256_generic cryptd aes_x86_64 aes_generic cbc dm_crypt dm_mod raid1 md_mod usbhid hid sg sd_mod crc_t10dif sr_mod cdrom ata_generic uhci_hcd sata_via pata_via libata ehci_hcd usbcore scsi_mod via_rhine mii nls_base [last unloaded: scsi_wait_scan]
        Pid: 1153, comm: work_for_cpu Not tainted 2.6.37-1-amd64 #1 M2V-MX SE/System Product Name
        RIP: 0010:[<ffffffffa0578402>]  [<ffffffffa0578402>] azx_probe+0x3ad/0x86b [snd_hda_intel]
        RSP: 0018:ffff88013153fe50  EFLAGS: 00010286
        RAX: ffffc90011c08000 RBX: ffff88013029ec00 RCX: 0000000000000006
        RDX: 0000000000000000 RSI: 0000000000000246 RDI: 0000000000000246
        RBP: ffff88013341d000 R08: 0000000000000000 R09: 0000000000000040
        R10: 0000000000000286 R11: 0000000000003731 R12: ffff88013029c400
        R13: 0000000000000000 R14: 0000000000000000 R15: ffff88013341d090
        FS:  0000000000000000(0000) GS:ffff8800bfc00000(0000) knlGS:00000000f7610ab0
        CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
        CR2: ffffc90011c08000 CR3: 0000000132f57000 CR4: 00000000000006f0
        DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
        DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
        Process work_for_cpu (pid: 1153, threadinfo ffff88013153e000, task ffff8801303c86c0)
        Stack:
         0000000000000005 ffffffff8123ad65 00000000000136c0 ffff88013029c400
         ffff8801303c8998 ffff88013341d000 ffff88013341d090 ffff8801322d9dc8
         ffff88013341d208 0000000000000000 0000000000000000 ffffffff811ad232
        Call Trace:
         [<ffffffff8123ad65>] ? __pm_runtime_set_status+0x162/0x186
         [<ffffffff811ad232>] ? local_pci_probe+0x49/0x92
         [<ffffffff8105afc5>] ? do_work_for_cpu+0x0/0x1b
         [<ffffffff8105afc5>] ? do_work_for_cpu+0x0/0x1b
         [<ffffffff8105afd0>] ? do_work_for_cpu+0xb/0x1b
         [<ffffffff8105fd3f>] ? kthread+0x7a/0x82
         [<ffffffff8100a824>] ? kernel_thread_helper+0x4/0x10
         [<ffffffff8105fcc5>] ? kthread+0x0/0x82
         [<ffffffff8100a820>] ? kernel_thread_helper+0x0/0x10
        Code: f4 01 00 00 ef 31 f6 48 89 df e8 29 dd ff ff 85 c0 0f 88 2b 03 00 00 48 89 ef e8 b4 39 c3 e0 8b 7b 40 e8 fc 9d b1 e0 48 8b 43 38 <66> 8b 10 66 89 14 24 8b 43 14 83 e8 03 83 f8 01 77 32 31 d2 be
        RIP  [<ffffffffa0578402>] azx_probe+0x3ad/0x86b [snd_hda_intel]
         RSP <ffff88013153fe50>
        CR2: ffffc90011c08000
        ---[ end trace 8d1f3ebc136437fd ]---
    
    Trusting the ACPI _CRS information (`pci=use_crs`) fixes this problem.
    
        $ dmesg | grep -i crs # with the quirk
        PCI: Using host bridge windows from ACPI; if necessary, use "pci=nocrs" and report a bug
    
    The match has to be against the DMI board entries though since the vendor entries are not populated.
    
        DMI: System manufacturer System Product Name/M2V-MX SE, BIOS 0304    10/30/2007
    
    This quirk should be removed when `pci=use_crs` is enabled for machines
    from 2006 or earlier or some other solution is implemented.
    
    Using coreboot [1] with this board the problem does not exist but this
    quirk also does not affect it either. To be safe though the check is
    tightened to only take effect when the BIOS from American Megatrends is
    used.
    
            15:13 < ruik> but coreboot does not need that
            15:13 < ruik> because i have there only one root bus
            15:13 < ruik> the audio is behind a bridge
    
            $ sudo dmidecode
            BIOS Information
                    Vendor: American Megatrends Inc.
                    Version: 0304
                    Release Date: 10/30/2007
    
    [1] http://www.coreboot.org/
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=30552
    
    Cc: stable@kernel.org (2.6.34)
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: x86@kernel.org
    Signed-off-by: Paul Menzel <paulepanter@users.sourceforge.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 039d91315bc5..404f21a3ff9e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -43,6 +43,17 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "ALiveSATA2-GLAN"),
                 },
         },
+	/* https://bugzilla.kernel.org/show_bug.cgi?id=30552 */
+	/* 2006 AMD HT/VIA system with two host bridges */
+	{
+		.callback = set_use_crs,
+		.ident = "ASUS M2V-MX SE",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+			DMI_MATCH(DMI_BOARD_NAME, "M2V-MX SE"),
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+		},
+	},
 	{}
 };
 

commit 5307f6d5fb12fd01f9f321bc4a8fd77e74858647
Author: Shyam Iyer <shyam.iyer.t@gmail.com>
Date:   Thu Sep 8 16:41:17 2011 -0500

    Fix pointer dereference before call to pcie_bus_configure_settings
    
    Commit b03e7495a862 ("PCI: Set PCI-E Max Payload Size on fabric")
    introduced a potential NULL pointer dereference in calls to
    pcie_bus_configure_settings due to attempts to access pci_bus self
    variables when the self pointer is NULL.
    
    To correct this, verify that the self pointer in pci_bus is non-NULL
    before dereferencing it.
    
    Reported-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Shyam Iyer <shyam_iyer@dell.com>
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index c95330267f08..039d91315bc5 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -365,8 +365,13 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 	 */
 	if (bus) {
 		struct pci_bus *child;
-		list_for_each_entry(child, &bus->children, node)
-			pcie_bus_configure_settings(child, child->self->pcie_mpss);
+		list_for_each_entry(child, &bus->children, node) {
+			struct pci_dev *self = child->self;
+			if (!self)
+				continue;
+
+			pcie_bus_configure_settings(child, self->pcie_mpss);
+		}
 	}
 
 	if (!bus)

commit b03e7495a862b028294f59fc87286d6d78ee7fa1
Author: Jon Mason <mason@myri.com>
Date:   Wed Jul 20 15:20:54 2011 -0500

    PCI: Set PCI-E Max Payload Size on fabric
    
    On a given PCI-E fabric, each device, bridge, and root port can have a
    different PCI-E maximum payload size.  There is a sizable performance
    boost for having the largest possible maximum payload size on each PCI-E
    device.  However, if improperly configured, fatal bus errors can occur.
    Thus, it is important to ensure that PCI-E payloads sends by a device
    are never larger than the MPS setting of all devices on the way to the
    destination.
    
    This can be achieved two ways:
    
    - A conservative approach is to use the smallest common denominator of
      the entire tree below a root complex for every device on that fabric.
    
    This means for example that having a 128 bytes MPS USB controller on one
    leg of a switch will dramatically reduce performances of a video card or
    10GE adapter on another leg of that same switch.
    
    It also means that any hierarchy supporting hotplug slots (including
    expresscard or thunderbolt I suppose, dbl check that) will have to be
    entirely clamped to 128 bytes since we cannot predict what will be
    plugged into those slots, and we cannot change the MPS on a "live"
    system.
    
    - A more optimal way is possible, if it falls within a couple of
      constraints:
    * The top-level host bridge will never generate packets larger than the
      smallest TLP (or if it can be controlled independently from its MPS at
      least)
    * The device will never generate packets larger than MPS (which can be
      configured via MRRS)
    * No support of direct PCI-E <-> PCI-E transfers between devices without
      some additional code to specifically deal with that case
    
    Then we can use an approach that basically ignores downstream requests
    and focuses exclusively on upstream requests. In that case, all we need
    to care about is that a device MPS is no larger than its parent MPS,
    which allows us to keep all switches/bridges to the max MPS supported by
    their parent and eventually the PHB.
    
    In this case, your USB controller would no longer "starve" your 10GE
    Ethernet and your hotplug slots won't affect your global MPS.
    Additionally, the hotplugged devices themselves can be configured to a
    larger MPS up to the value configured in the hotplug bridge.
    
    To choose between the two available options, two PCI kernel boot args
    have been added to the PCI calls.  "pcie_bus_safe" will provide the
    former behavior, while "pcie_bus_perf" will perform the latter behavior.
    By default, the latter behavior is used.
    
    NOTE: due to the location of the enablement, each arch will need to add
    calls to this function.  This patch only enables x86.
    
    This patch includes a number of changes recommended by Benjamin
    Herrenschmidt.
    
    Tested-by: Jordan_Hargrave@dell.com
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index ae3cb23cd89b..c95330267f08 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -360,6 +360,15 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 		}
 	}
 
+	/* After the PCI-E bus has been walked and all devices discovered,
+	 * configure any settings of the fabric that might be necessary.
+	 */
+	if (bus) {
+		struct pci_bus *child;
+		list_for_each_entry(child, &bus->children, node)
+			pcie_bus_configure_settings(child, child->self->pcie_mpss);
+	}
+
 	if (!bus)
 		kfree(sd);
 

commit 43d786ed4df4c54cb8802a523748a7d78130a2cb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jul 2 10:47:12 2011 -0600

    x86/PCI: reduce severity of host bridge window conflict warnings
    
    Host bridge windows are top-level resources, so if we find a host bridge
    window conflict, it's probably with a hard-coded legacy reservation.
    Moving host bridge windows is theoretically possible, but we don't support
    it; we just ignore windows with conflicts, and it's not worth making this
    a user-visible error.
    
    Reported-and-tested-by: Jools Wills <jools@oxfordinspire.co.uk>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=38522
    Reported-by: Das <dasfox@gmail.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=16497
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 68c3c1395202..ae3cb23cd89b 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -246,10 +246,9 @@ static void add_resources(struct pci_root_info *info)
 
 		conflict = insert_resource_conflict(root, res);
 		if (conflict)
-			dev_err(&info->bridge->dev,
-				"address space collision: host bridge window %pR "
-				"conflicts with %s %pR\n",
-				res, conflict->name, conflict);
+			dev_info(&info->bridge->dev,
+				 "ignoring host bridge window %pR (conflicts with %s %pR)\n",
+				 res, conflict->name, conflict);
 		else
 			pci_bus_add_resource(info->bus, res, 0);
 	}

commit 6e33a852a37dee02979ec9d82bea26c07cee5bce
Author: Márton Németh <nm127@freemail.hu>
Date:   Sat May 14 19:27:33 2011 +0200

    x86/PCI/ACPI: fix type mismatch
    
    The flags field of struct resource from linux/ioport.h is "unsigned
    long". Change the "type" parameter of coalesce_windows() function to
    match that field. This fixes the following warning messages when
    compiling with "make C=1 W=1 bzImage modules":
    
    arch/x86/pci/acpi.c: In function ‘coalesce_windows’:
    arch/x86/pci/acpi.c:198: warning: conversion to ‘long unsigned int’ from ‘int’ may change the sign of the result
    arch/x86/pci/acpi.c:203: warning: conversion to ‘long unsigned int’ from ‘int’ may change the sign of the result
    
    Signed-off-by: Márton Németh <nm127@freemail.hu>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0972315c3860..68c3c1395202 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -188,7 +188,7 @@ static bool resource_contains(struct resource *res, resource_size_t point)
 	return false;
 }
 
-static void coalesce_windows(struct pci_root_info *info, int type)
+static void coalesce_windows(struct pci_root_info *info, unsigned long type)
 {
 	int i, j;
 	struct resource *res1, *res2;

commit 4723d0f2f96e6c910f951d595067eb31e0dd2d01
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Sep 22 11:09:19 2010 -0600

    x86/PCI: coalesce overlapping host bridge windows
    
    Some BIOSes provide PCI host bridge windows that overlap, e.g.,
    
        pci_root PNP0A03:00: host bridge window [mem 0xb0000000-0xffffffff]
        pci_root PNP0A03:00: host bridge window [mem 0xafffffff-0xdfffffff]
        pci_root PNP0A03:00: host bridge window [mem 0xf0000000-0xffffffff]
    
    If we simply insert these as children of iomem_resource, the second window
    fails because it conflicts with the first, and the third is inserted as a
    child of the first, i.e.,
    
        b0000000-ffffffff PCI Bus 0000:00
          f0000000-ffffffff PCI Bus 0000:00
    
    When we claim PCI device resources, this can cause collisions like this
    if we put them in the first window:
    
        pci 0000:00:01.0: address space collision: [mem 0xff300000-0xff4fffff] conflicts with PCI Bus 0000:00 [mem 0xf0000000-0xffffffff]
    
    Host bridge windows are top-level resources by definition, so it doesn't
    make sense to make the third window a child of the first.  This patch
    coalesces any host bridge windows that overlap.  For the example above,
    the result is this single window:
    
        pci_root PNP0A03:00: host bridge window [mem 0xafffffff-0xffffffff]
    
    This fixes a 2.6.34 regression.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=17011
    Reported-and-tested-by: Anisse Astier <anisse@astier.eu>
    Reported-and-tested-by: Pramod Dematagoda <pmd.lotr.gandalf@gmail.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 15466c096ba5..0972315c3860 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -138,7 +138,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 	unsigned long flags;
-	struct resource *root, *conflict;
 	u64 start, end;
 
 	status = resource_to_addr(acpi_res, &addr);
@@ -146,12 +145,10 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 		return AE_OK;
 
 	if (addr.resource_type == ACPI_MEMORY_RANGE) {
-		root = &iomem_resource;
 		flags = IORESOURCE_MEM;
 		if (addr.info.mem.caching == ACPI_PREFETCHABLE_MEMORY)
 			flags |= IORESOURCE_PREFETCH;
 	} else if (addr.resource_type == ACPI_IO_RANGE) {
-		root = &ioport_resource;
 		flags = IORESOURCE_IO;
 	} else
 		return AE_OK;
@@ -172,25 +169,90 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 		return AE_OK;
 	}
 
-	conflict = insert_resource_conflict(root, res);
-	if (conflict) {
-		dev_err(&info->bridge->dev,
-			"address space collision: host bridge window %pR "
-			"conflicts with %s %pR\n",
-			res, conflict->name, conflict);
-	} else {
-		pci_bus_add_resource(info->bus, res, 0);
-		info->res_num++;
-		if (addr.translation_offset)
-			dev_info(&info->bridge->dev, "host bridge window %pR "
-				 "(PCI address [%#llx-%#llx])\n",
-				 res, res->start - addr.translation_offset,
-				 res->end - addr.translation_offset);
+	info->res_num++;
+	if (addr.translation_offset)
+		dev_info(&info->bridge->dev, "host bridge window %pR "
+			 "(PCI address [%#llx-%#llx])\n",
+			 res, res->start - addr.translation_offset,
+			 res->end - addr.translation_offset);
+	else
+		dev_info(&info->bridge->dev, "host bridge window %pR\n", res);
+
+	return AE_OK;
+}
+
+static bool resource_contains(struct resource *res, resource_size_t point)
+{
+	if (res->start <= point && point <= res->end)
+		return true;
+	return false;
+}
+
+static void coalesce_windows(struct pci_root_info *info, int type)
+{
+	int i, j;
+	struct resource *res1, *res2;
+
+	for (i = 0; i < info->res_num; i++) {
+		res1 = &info->res[i];
+		if (!(res1->flags & type))
+			continue;
+
+		for (j = i + 1; j < info->res_num; j++) {
+			res2 = &info->res[j];
+			if (!(res2->flags & type))
+				continue;
+
+			/*
+			 * I don't like throwing away windows because then
+			 * our resources no longer match the ACPI _CRS, but
+			 * the kernel resource tree doesn't allow overlaps.
+			 */
+			if (resource_contains(res1, res2->start) ||
+			    resource_contains(res1, res2->end) ||
+			    resource_contains(res2, res1->start) ||
+			    resource_contains(res2, res1->end)) {
+				res1->start = min(res1->start, res2->start);
+				res1->end = max(res1->end, res2->end);
+				dev_info(&info->bridge->dev,
+					 "host bridge window expanded to %pR; %pR ignored\n",
+					 res1, res2);
+				res2->flags = 0;
+			}
+		}
+	}
+}
+
+static void add_resources(struct pci_root_info *info)
+{
+	int i;
+	struct resource *res, *root, *conflict;
+
+	if (!pci_use_crs)
+		return;
+
+	coalesce_windows(info, IORESOURCE_MEM);
+	coalesce_windows(info, IORESOURCE_IO);
+
+	for (i = 0; i < info->res_num; i++) {
+		res = &info->res[i];
+
+		if (res->flags & IORESOURCE_MEM)
+			root = &iomem_resource;
+		else if (res->flags & IORESOURCE_IO)
+			root = &ioport_resource;
 		else
-			dev_info(&info->bridge->dev,
-				 "host bridge window %pR\n", res);
+			continue;
+
+		conflict = insert_resource_conflict(root, res);
+		if (conflict)
+			dev_err(&info->bridge->dev,
+				"address space collision: host bridge window %pR "
+				"conflicts with %s %pR\n",
+				res, conflict->name, conflict);
+		else
+			pci_bus_add_resource(info->bus, res, 0);
 	}
-	return AE_OK;
 }
 
 static void
@@ -224,6 +286,7 @@ get_current_resources(struct acpi_device *device, int busnum,
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				&info);
 
+	add_resources(&info);
 	return;
 
 name_alloc_fail:

commit 2491762cfb475dbdfa3db11ebea6de49f58b7fac
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jul 23 12:53:27 2010 -0600

    x86/PCI: use host bridge _CRS info on ASRock ALiveSATA2-GLAN
    
    This DMI quirk turns on "pci=use_crs" for the ALiveSATA2-GLAN because
    amd_bus.c doesn't handle this system correctly.
    
    The system has a single HyperTransport I/O chain, but has two PCI host
    bridges to buses 00 and 80.  amd_bus.c learns the MMIO range associated
    with buses 00-ff and that this range is routed to the HT chain hosted at
    node 0, link 0:
    
        bus: [00, ff] on node 0 link 0
        bus: 00 index 1 [mem 0x80000000-0xfcffffffff]
    
    This includes the address space for both bus 00 and bus 80, and amd_bus.c
    assumes it's all routed to bus 00.
    
    We find device 80:01.0, which BIOS left in the middle of that space, but
    we don't find a bridge from bus 00 to bus 80, so we conclude that 80:01.0
    is unreachable from bus 00, and we move it from the original, working,
    address to something outside the bus 00 aperture, which does not work:
    
        pci 0000:80:01.0: reg 10: [mem 0xfebfc000-0xfebfffff 64bit]
        pci 0000:80:01.0: BAR 0: assigned [mem 0xfd00000000-0xfd00003fff 64bit]
    
    The BIOS told us everything we need to know to handle this correctly,
    so we're better off if we just pay attention, which lets us leave the
    80:01.0 device at the original, working, address:
    
        ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-7f])
        pci_root PNP0A03:00: host bridge window [mem 0x80000000-0xff37ffff]
        ACPI: PCI Root Bridge [PCI1] (domain 0000 [bus 80-ff])
        pci_root PNP0A08:00: host bridge window [mem 0xfebfc000-0xfebfffff]
    
    This was a regression between 2.6.33 and 2.6.34.  In 2.6.33, amd_bus.c
    was used only when we found multiple HT chains.  3e3da00c01d050, which
    enabled amd_bus.c even on systems with a single HT chain, caused this
    failure.
    
    This quirk was written by Graham.  If we ever enable "pci=use_crs" for
    machines from 2006 or earlir, this quirk should be removed.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=16007
    
    Cc: stable@kernel.org
    Reported-by: Graham Ramsey <ramsey.graham@ntlworld.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2ec04c424a62..15466c096ba5 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -34,6 +34,15 @@ static const struct dmi_system_id pci_use_crs_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "x3800"),
 		},
 	},
+	/* https://bugzilla.kernel.org/show_bug.cgi?id=16007 */
+	/* 2006 AMD HT/VIA system with two host bridges */
+        {
+		.callback = set_use_crs,
+		.ident = "ASRock ALiveSATA2-GLAN",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "ALiveSATA2-GLAN"),
+                },
+        },
 	{}
 };
 

commit 021fad8b706849c091f6e682bc5df3ce4f9ab4d7
Merge: e9a5f426b85e 1ba4f22c426b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 30 09:06:13 2010 -0700

    Merge branch 'x86-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, cpufeature: Unbreak compile with gcc 3.x
      x86, pat: Fix memory leak in free_memtype
      x86, k8: Fix section mismatch for powernowk8_exit()
      lib/atomic64_test: fix missing include of linux/kernel.h
      x86: remove last traces of quicklist usage
      x86, setup: Phoenix BIOS fixup is needed on Dell Inspiron Mini 1012
      x86: "nosmp" command line option should force the system into UP mode
      arch/x86/pci: use kasprintf
      x86, apic: ack all pending irqs when crashed/on kexec

commit dc1544ea5d6dfdf29440295788e639e4b44c605a
Merge: 6e320ec1d98f 57283776b2b8
Author: Len Brown <len.brown@intel.com>
Date:   Fri May 28 16:17:16 2010 -0400

    Merge branch 'bjorn-pci-root-v4-2.6.35' into release

commit b46fc5f235be04a7f77fb2af1d8cb809889c25c1
Author: Julia Lawall <julia@diku.dk>
Date:   Mon May 24 12:13:16 2010 -0700

    arch/x86/pci: use kasprintf
    
    kasprintf combines kmalloc and sprintf, and takes care of the size
    calculation itself.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression a,flag;
    expression list args;
    statement S;
    @@
    
      a =
    -  \(kmalloc\|kzalloc\)(...,flag)
    +  kasprintf(flag,args)
      <... when != a
      if (a == NULL || ...) S
      ...>
    - sprintf(a,args);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    LKML-Reference: <201005241913.o4OJDG3R010871@imap1.linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 31930fd30ea9..7c0ad634694a 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -207,10 +207,9 @@ get_current_resources(struct acpi_device *device, int busnum,
 	if (!info.res)
 		goto res_alloc_fail;
 
-	info.name = kmalloc(16, GFP_KERNEL);
+	info.name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);
 	if (!info.name)
 		goto name_alloc_fail;
-	sprintf(info.name, "PCI Bus %04x:%02x", domain, busnum);
 
 	info.res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,

commit 48728e077480910df45baabc5f87b04276348c90
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Apr 27 14:45:43 2010 -0600

    x86/PCI: compute Address Space length rather than using _LEN
    
    ACPI _CRS Address Space Descriptors have _MIN, _MAX, and _LEN.  Linux has
    been computing Address Spaces as [_MIN to _MIN + _LEN - 1].  Based on the
    tests in the bug reports below, Windows apparently uses [_MIN to _MAX].
    
    Per spec (ACPI 4.0, Table 6-40), for _CRS fixed-size, fixed location
    descriptors, "_LEN must be (_MAX - _MIN + 1)", and when that's true, it
    doesn't matter which way we compute the end.  But of course, there are
    BIOSes that don't follow this rule, and we're better off if Linux handles
    those exceptions the same way as Windows.
    
    This patch makes Linux use [_MIN to _MAX], as Windows seems to do.  This
    effectively reverts d558b483d5 and 03db42adfe and replaces them with
    simpler code.
    
        https://bugzilla.kernel.org/show_bug.cgi?id=14337 (round)
        https://bugzilla.kernel.org/show_bug.cgi?id=15480 (truncate)
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 44f83ce02470..31930fd30ea9 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -121,30 +121,6 @@ count_resource(struct acpi_resource *acpi_res, void *data)
 	return AE_OK;
 }
 
-static void
-align_resource(struct acpi_device *bridge, struct resource *res)
-{
-	int align = (res->flags & IORESOURCE_MEM) ? 16 : 4;
-
-	/*
-	 * Host bridge windows are not BARs, but the decoders on the PCI side
-	 * that claim this address space have starting alignment and length
-	 * constraints, so fix any obvious BIOS goofs.
-	 */
-	if (!IS_ALIGNED(res->start, align)) {
-		dev_printk(KERN_DEBUG, &bridge->dev,
-			   "host bridge window %pR invalid; "
-			   "aligning start to %d-byte boundary\n", res, align);
-		res->start &= ~(align - 1);
-	}
-	if (!IS_ALIGNED(res->end + 1, align)) {
-		dev_printk(KERN_DEBUG, &bridge->dev,
-			   "host bridge window %pR invalid; "
-			   "aligning end to %d-byte boundary\n", res, align);
-		res->end = ALIGN(res->end, align) - 1;
-	}
-}
-
 static acpi_status
 setup_resource(struct acpi_resource *acpi_res, void *data)
 {
@@ -154,7 +130,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	acpi_status status;
 	unsigned long flags;
 	struct resource *root, *conflict;
-	u64 start, end, max_len;
+	u64 start, end;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -171,19 +147,8 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	} else
 		return AE_OK;
 
-	max_len = addr.maximum - addr.minimum + 1;
-	if (addr.address_length > max_len) {
-		dev_printk(KERN_DEBUG, &info->bridge->dev,
-			   "host bridge window length %#llx doesn't fit in "
-			   "%#llx-%#llx, trimming\n",
-			   (unsigned long long) addr.address_length,
-			   (unsigned long long) addr.minimum,
-			   (unsigned long long) addr.maximum);
-		addr.address_length = max_len;
-	}
-
 	start = addr.minimum + addr.translation_offset;
-	end = start + addr.address_length - 1;
+	end = addr.maximum + addr.translation_offset;
 
 	res = &info->res[info->res_num];
 	res->name = info->name;
@@ -191,7 +156,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->start = start;
 	res->end = end;
 	res->child = NULL;
-	align_resource(info->bridge, res);
 
 	if (!pci_use_crs) {
 		dev_printk(KERN_DEBUG, &info->bridge->dev,

commit 66528fdd45b082bf7c74687d72ae08afa4a446f8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Apr 20 13:52:41 2010 -0600

    x86/PCI: parse additional host bridge window resource types
    
    This adds support for Memory24, Memory32, and Memory32Fixed descriptors in
    PCI host bridge _CRS.
    
    I experimentally determined that Windows (2008 R2) accepts these descriptors
    and treats them as windows that are forwarded to the PCI bus, e.g., if
    it finds any PCI devices with BARs outside the windows, it moves them into
    the windows.
    
    I don't know whether any machines actually use these descriptors in PCI
    host bridge _CRS methods, but if any exist and they're new enough that we
    automatically turn on "pci=use_crs", they will work with Windows but not
    with Linux.
    
    Here are the details: https://bugzilla.kernel.org/show_bug.cgi?id=15817
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 334153ca4c30..44f83ce02470 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -66,13 +66,44 @@ resource_to_addr(struct acpi_resource *resource,
 			struct acpi_resource_address64 *addr)
 {
 	acpi_status status;
-
-	status = acpi_resource_to_address64(resource, addr);
-	if (ACPI_SUCCESS(status) &&
-	    (addr->resource_type == ACPI_MEMORY_RANGE ||
-	    addr->resource_type == ACPI_IO_RANGE) &&
-	    addr->address_length > 0) {
+	struct acpi_resource_memory24 *memory24;
+	struct acpi_resource_memory32 *memory32;
+	struct acpi_resource_fixed_memory32 *fixed_memory32;
+
+	memset(addr, 0, sizeof(*addr));
+	switch (resource->type) {
+	case ACPI_RESOURCE_TYPE_MEMORY24:
+		memory24 = &resource->data.memory24;
+		addr->resource_type = ACPI_MEMORY_RANGE;
+		addr->minimum = memory24->minimum;
+		addr->address_length = memory24->address_length;
+		addr->maximum = addr->minimum + addr->address_length - 1;
+		return AE_OK;
+	case ACPI_RESOURCE_TYPE_MEMORY32:
+		memory32 = &resource->data.memory32;
+		addr->resource_type = ACPI_MEMORY_RANGE;
+		addr->minimum = memory32->minimum;
+		addr->address_length = memory32->address_length;
+		addr->maximum = addr->minimum + addr->address_length - 1;
 		return AE_OK;
+	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
+		fixed_memory32 = &resource->data.fixed_memory32;
+		addr->resource_type = ACPI_MEMORY_RANGE;
+		addr->minimum = fixed_memory32->address;
+		addr->address_length = fixed_memory32->address_length;
+		addr->maximum = addr->minimum + addr->address_length - 1;
+		return AE_OK;
+	case ACPI_RESOURCE_TYPE_ADDRESS16:
+	case ACPI_RESOURCE_TYPE_ADDRESS32:
+	case ACPI_RESOURCE_TYPE_ADDRESS64:
+		status = acpi_resource_to_address64(resource, addr);
+		if (ACPI_SUCCESS(status) &&
+		    (addr->resource_type == ACPI_MEMORY_RANGE ||
+		    addr->resource_type == ACPI_IO_RANGE) &&
+		    addr->address_length > 0) {
+			return AE_OK;
+		}
+		break;
 	}
 	return AE_ERROR;
 }

commit 73a0e614580fb650846be1e9315f6b7b6069b9cc
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Apr 6 13:24:08 2010 -0600

    x86/PCI: ignore Consumer/Producer bit in ACPI window descriptions
    
    ACPI Address Space Descriptors (used in _CRS) have a Consumer/Producer
    bit that is supposed to distinguish regions that are consumed directly
    by a device from those that are forwarded ("produced") by a bridge.
    But BIOSes have apparently not used this consistently, and Windows
    seems to ignore it, so I think Linux should ignore it as well.
    
    I can't point to any of these supposed broken BIOSes, but since we
    now rely on _CRS by default, I think it's safer to ignore this bit
    from the start.
    
    Here are details of my experiments with how Windows handles it:
        https://bugzilla.kernel.org/show_bug.cgi?id=15701
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index c7b1ebfb7da7..334153ca4c30 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -71,8 +71,7 @@ resource_to_addr(struct acpi_resource *resource,
 	if (ACPI_SUCCESS(status) &&
 	    (addr->resource_type == ACPI_MEMORY_RANGE ||
 	    addr->resource_type == ACPI_IO_RANGE) &&
-	    addr->address_length > 0 &&
-	    addr->producer_consumer == ACPI_PRODUCER) {
+	    addr->address_length > 0) {
 		return AE_OK;
 	}
 	return AE_ERROR;

commit 57283776b2b821ba4d592f61cad04d0293412740
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Mar 11 12:20:11 2010 -0700

    ACPI: pci_root: pass acpi_pci_root to arch-specific scan
    
    The acpi_pci_root structure contains all the individual items (acpi_device,
    domain, bus number) we pass to pci_acpi_scan_root(), so just pass the
    single acpi_pci_root pointer directly.
    
    This will make it easier to add _CBA support later.  For _CBA, we need the
    entire downstream bus range, not just the base bus number.  We have that in
    the acpi_pci_root structure, so passing the pointer makes it available to
    the arch-specific code.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index e31160216efb..0b7882dbe784 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -229,8 +229,11 @@ get_current_resources(struct acpi_device *device, int busnum,
 	return;
 }
 
-struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int domain, int busnum)
+struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)
 {
+	struct acpi_device *device = root->device;
+	int domain = root->segment;
+	int busnum = root->secondary.start;
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
 	int node;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index e31160216efb..c7b1ebfb7da7 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -3,6 +3,7 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/dmi.h>
+#include <linux/slab.h>
 #include <asm/numa.h>
 #include <asm/pci_x86.h>
 

commit d558b483d5a73f5718705b270cb2090f66ea48c8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Mar 25 09:28:30 2010 -0600

    x86/PCI: truncate _CRS windows with _LEN > _MAX - _MIN + 1
    
    Yanko's GA-MA78GM-S2H (BIOS F11) reports the following resource in a PCI
    host bridge _CRS:
    
        [07] 32-Bit DWORD Address Space Resource
             Min Relocatability : MinFixed
             Max Relocatability : MaxFixed
                Address Minimum : CFF00000  (_MIN)
                Address Maximum : FEBFFFFF  (_MAX)
                 Address Length : 3EE10000  (_LEN)
    
    This is invalid per spec (ACPI 4.0, 6.4.3.5) because it's a fixed size,
    fixed location descriptor, but _LEN != _MAX - _MIN + 1.
    
    Based on https://bugzilla.kernel.org/show_bug.cgi?id=15480#c15, I think
    Windows handles this by truncating the window so it fits between _MIN and
    _MAX.  I also verified this by modifying the SeaBIOS DSDT and booting
    Windows 2008 R2 with qemu.
    
    This patch makes Linux truncate the window, too, which fixes:
        http://bugzilla.kernel.org/show_bug.cgi?id=15480
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Tested-by: Yanko Kaneti <yaneti@declera.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 75ac3f856ea5..e31160216efb 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -123,7 +123,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	acpi_status status;
 	unsigned long flags;
 	struct resource *root, *conflict;
-	u64 start, end;
+	u64 start, end, max_len;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -140,6 +140,17 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	} else
 		return AE_OK;
 
+	max_len = addr.maximum - addr.minimum + 1;
+	if (addr.address_length > max_len) {
+		dev_printk(KERN_DEBUG, &info->bridge->dev,
+			   "host bridge window length %#llx doesn't fit in "
+			   "%#llx-%#llx, trimming\n",
+			   (unsigned long long) addr.address_length,
+			   (unsigned long long) addr.minimum,
+			   (unsigned long long) addr.maximum);
+		addr.address_length = max_len;
+	}
+
 	start = addr.minimum + addr.translation_offset;
 	end = start + addr.address_length - 1;
 

commit eb9fc8ef7cb1362374e55d9503e3e7458f319991
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Mar 25 09:28:24 2010 -0600

    x86/PCI: for host bridge address space collisions, show conflicting resource
    
    With insert_resource_conflict(), we can learn what the actual conflict is,
    so print that info for debugging purposes.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 6e22454bfaa6..75ac3f856ea5 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -122,7 +122,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 	unsigned long flags;
-	struct resource *root;
+	struct resource *root, *conflict;
 	u64 start, end;
 
 	status = resource_to_addr(acpi_res, &addr);
@@ -157,9 +157,12 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 		return AE_OK;
 	}
 
-	if (insert_resource(root, res)) {
+	conflict = insert_resource_conflict(root, res);
+	if (conflict) {
 		dev_err(&info->bridge->dev,
-			"can't allocate host bridge window %pR\n", res);
+			"address space collision: host bridge window %pR "
+			"conflicts with %s %pR\n",
+			res, conflict->name, conflict);
 	} else {
 		pci_bus_add_resource(info->bus, res, 0);
 		info->res_num++;

commit 322aafa6645a48c3b7837ca7385f126ab78127fd
Merge: dd04265b028c c7bbf52aa4fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 7 15:59:39 2010 -0800

    Merge branch 'x86-mrst-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-mrst-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (30 commits)
      x86, mrst: Fix whitespace breakage in apb_timer.c
      x86, mrst: Fix APB timer per cpu clockevent
      x86, mrst: Remove X86_MRST dependency on PCI_IOAPIC
      x86, olpc: Use pci subarch init for OLPC
      x86, pci: Add arch_init to x86_init abstraction
      x86, mrst: Add Kconfig dependencies for Moorestown
      x86, pci: Exclude Moorestown PCI code if CONFIG_X86_MRST=n
      x86, numaq: Make CONFIG_X86_NUMAQ depend on CONFIG_PCI
      x86, pci: Add sanity check for PCI fixed bar probing
      x86, legacy_irq: Remove duplicate vector assigment
      x86, legacy_irq: Remove left over nr_legacy_irqs
      x86, mrst: Platform clock setup code
      x86, apbt: Moorestown APB system timer driver
      x86, mrst: Add vrtc platform data setup code
      x86, mrst: Add platform timer info parsing code
      x86, mrst: Fill in PCI functions in x86_init layer
      x86, mrst: Add dummy legacy pic to platform setup
      x86/PCI: Moorestown PCI support
      x86, ioapic: Add dummy ioapic functions
      x86, ioapic: Early enable ioapic for timer irq
      ...
    
    Fixed up semantic conflict of new clocksources due to commit
    17622339af25 ("clocksource: add argument to resume callback").

commit 7bc5e3f2be32ae6fb0c74cd0f707f986b3a01a26
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:41 2010 -0700

    x86/PCI: use host bridge _CRS info by default on 2008 and newer machines
    
    The main benefit of using ACPI host bridge window information is that
    we can do better resource allocation in systems with multiple host bridges,
    e.g., http://bugzilla.kernel.org/show_bug.cgi?id=14183
    
    Sometimes we need _CRS information even if we only have one host bridge,
    e.g., https://bugs.launchpad.net/ubuntu/+source/linux/+bug/341681
    
    Most of these systems are relatively new, so this patch turns on
    "pci=use_crs" only on machines with a BIOS date of 2008 or newer.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index a2f8cdb8c1d5..5f11ff6f5389 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -15,6 +15,51 @@ struct pci_root_info {
 	int busnum;
 };
 
+static bool pci_use_crs = true;
+
+static int __init set_use_crs(const struct dmi_system_id *id)
+{
+	pci_use_crs = true;
+	return 0;
+}
+
+static const struct dmi_system_id pci_use_crs_table[] __initconst = {
+	/* http://bugzilla.kernel.org/show_bug.cgi?id=14183 */
+	{
+		.callback = set_use_crs,
+		.ident = "IBM System x3800",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "x3800"),
+		},
+	},
+	{}
+};
+
+void __init pci_acpi_crs_quirks(void)
+{
+	int year;
+
+	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008)
+		pci_use_crs = false;
+
+	dmi_check_system(pci_use_crs_table);
+
+	/*
+	 * If the user specifies "pci=use_crs" or "pci=nocrs" explicitly, that
+	 * takes precedence over anything we figured out above.
+	 */
+	if (pci_probe & PCI_ROOT_NO_CRS)
+		pci_use_crs = false;
+	else if (pci_probe & PCI_USE__CRS)
+		pci_use_crs = true;
+
+	printk(KERN_INFO "PCI: %s host bridge windows from ACPI; "
+	       "if necessary, use \"pci=%s\" and report a bug\n",
+	       pci_use_crs ? "Using" : "Ignoring",
+	       pci_use_crs ? "nocrs" : "use_crs");
+}
+
 static acpi_status
 resource_to_addr(struct acpi_resource *resource,
 			struct acpi_resource_address64 *addr)
@@ -106,7 +151,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->child = NULL;
 	align_resource(info->bridge, res);
 
-	if (!(pci_probe & PCI_USE__CRS)) {
+	if (!pci_use_crs) {
 		dev_printk(KERN_DEBUG, &info->bridge->dev,
 			   "host bridge window %pR (ignored)\n", res);
 		return AE_OK;
@@ -137,12 +182,8 @@ get_current_resources(struct acpi_device *device, int busnum,
 	struct pci_root_info info;
 	size_t size;
 
-	if (pci_probe & PCI_USE__CRS)
+	if (pci_use_crs)
 		pci_bus_remove_resources(bus);
-	else
-		dev_info(&device->dev,
-			 "ignoring host bridge windows from ACPI; "
-			 "boot with \"pci=use_crs\" to use them\n");
 
 	info.bridge = device;
 	info.bus = bus;

commit 2fe2abf896c1e7a0ee65faaf3ef0ce654848abbd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:36 2010 -0700

    PCI: augment bus resource table with a list
    
    Previously we used a table of size PCI_BUS_NUM_RESOURCES (16) for resources
    forwarded to a bus by its upstream bridge.  We've increased this size
    several times when the table overflowed.
    
    But there's no good limit on the number of resources because host bridges
    and subtractive decode bridges can forward any number of ranges to their
    secondary buses.
    
    This patch reduces the table to only PCI_BRIDGE_RESOURCE_NUM (4) entries,
    which corresponds to the number of windows a PCI-to-PCI (3) or CardBus (4)
    bridge can positively decode.  Any additional resources, e.g., PCI host
    bridge windows or subtractively-decoded regions, are kept in a list.
    
    I'd prefer a single list rather than this split table/list approach, but
    that requires simultaneous changes to every architecture.  This approach
    only requires immediate changes where we set up (a) host bridges with more
    than four windows and (b) subtractive-decode P2P bridges, and we can
    incrementally change other architectures to use the list.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 959e548a7039..a2f8cdb8c1d5 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -45,20 +45,6 @@ count_resource(struct acpi_resource *acpi_res, void *data)
 	return AE_OK;
 }
 
-static int
-bus_has_transparent_bridge(struct pci_bus *bus)
-{
-	struct pci_dev *dev;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		u16 class = dev->class >> 8;
-
-		if (class == PCI_CLASS_BRIDGE_PCI && dev->transparent)
-			return true;
-	}
-	return false;
-}
-
 static void
 align_resource(struct acpi_device *bridge, struct resource *res)
 {
@@ -92,12 +78,8 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	acpi_status status;
 	unsigned long flags;
 	struct resource *root;
-	int max_root_bus_resources = PCI_BUS_NUM_RESOURCES;
 	u64 start, end;
 
-	if (bus_has_transparent_bridge(info->bus))
-		max_root_bus_resources -= 3;
-
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
 		return AE_OK;
@@ -115,15 +97,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 
 	start = addr.minimum + addr.translation_offset;
 	end = start + addr.address_length - 1;
-	if (info->res_num >= max_root_bus_resources) {
-		if (pci_probe & PCI_USE__CRS)
-			printk(KERN_WARNING "PCI: Failed to allocate "
-			       "0x%lx-0x%lx from %s for %s due to _CRS "
-			       "returning more than %d resource descriptors\n",
-			       (unsigned long) start, (unsigned long) end,
-			       root->name, info->name, max_root_bus_resources);
-		return AE_OK;
-	}
 
 	res = &info->res[info->res_num];
 	res->name = info->name;
@@ -143,7 +116,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 		dev_err(&info->bridge->dev,
 			"can't allocate host bridge window %pR\n", res);
 	} else {
-		info->bus->resource[info->res_num] = res;
+		pci_bus_add_resource(info->bus, res, 0);
 		info->res_num++;
 		if (addr.translation_offset)
 			dev_info(&info->bridge->dev, "host bridge window %pR "
@@ -164,7 +137,9 @@ get_current_resources(struct acpi_device *device, int busnum,
 	struct pci_root_info info;
 	size_t size;
 
-	if (!(pci_probe & PCI_USE__CRS))
+	if (pci_probe & PCI_USE__CRS)
+		pci_bus_remove_resources(bus);
+	else
 		dev_info(&device->dev,
 			 "ignoring host bridge windows from ACPI; "
 			 "boot with \"pci=use_crs\" to use them\n");

commit ab3b37937e8f4fb38dc9780b7bc3fd3c5195cca3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Aug 29 17:47:33 2009 +0200

    x86: Add pci_init_irq to x86_init
    
    Moorestown wants to reuse pcibios_init_irq but needs to provide its
    own implementation of pci_enable_irq. After we distangled the init we
    can move the init_irq call to x86_init and remove the pci_enable_irq
    != NULL check in pcibios_init_irq. pci_enable_irq is compile time
    initialized to pirq_enable_irq and the special cases which override it
    (visws and acpi) set the x86_init function pointer to noop. That
    allows MSRT to override pci_enable_irq and otherwise run
    pcibios_init_irq unmodified.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <43F901BD926A4E43B106BF17856F07559FB80CFF@orsmsx508.amr.corp.intel.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 73b3fe9aa716..b53f0487e2d3 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -289,6 +289,7 @@ int __init pci_acpi_init(void)
 	acpi_irq_penalty_init();
 	pcibios_enable_irq = acpi_pci_irq_enable;
 	pcibios_disable_irq = acpi_pci_irq_disable;
+	x86_init.pci.init_irq = x86_init_noop;
 
 	if (pci_routeirq) {
 		/*

commit b72d0db9dd41da1f2ec6274b03e8909583c64e41
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Aug 29 16:24:51 2009 +0200

    x86: Move pci init function to x86_init
    
    The PCI initialization in pci_subsys_init() is a mess. pci_numaq_init,
    pci_acpi_init, pci_visws_init and pci_legacy_init are called and each
    implementation checks and eventually modifies the global variable
    pcibios_scanned.
    
    x86_init functions allow us to do this more elegant. The pci.init
    function pointer is preset to pci_legacy_init. numaq, acpi and visws
    can modify the pointer in their early setup functions. The functions
    return 0 when they did the full initialization including bus scan. A
    non zero return value indicates that pci_legacy_init needs to be
    called either because the selected function failed or wants the
    generic bus scan in pci_legacy_init to happen (e.g. visws).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <43F901BD926A4E43B106BF17856F07559FB80CFE@orsmsx508.amr.corp.intel.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 959e548a7039..73b3fe9aa716 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -282,15 +282,11 @@ int __init pci_acpi_init(void)
 {
 	struct pci_dev *dev = NULL;
 
-	if (pcibios_scanned)
-		return 0;
-
 	if (acpi_noirq)
-		return 0;
+		return -ENODEV;
 
 	printk(KERN_INFO "PCI: Using ACPI for IRQ routing\n");
 	acpi_irq_penalty_init();
-	pcibios_scanned++;
 	pcibios_enable_irq = acpi_pci_irq_enable;
 	pcibios_disable_irq = acpi_pci_irq_disable;
 

commit ea7f1b6ee9dc96c5827b06ba21d7769d553efb7d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Nov 5 11:17:11 2009 -0600

    x86/PCI: remove 64-bit division
    
    The roundup() caused a build error (undefined reference to `__udivdi3').
    We're aligning to power-of-two boundaries, so it's simpler to just use
    ALIGN() anyway, which avoids the division.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 8ddf4f4c7253..959e548a7039 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -69,17 +69,17 @@ align_resource(struct acpi_device *bridge, struct resource *res)
 	 * that claim this address space have starting alignment and length
 	 * constraints, so fix any obvious BIOS goofs.
 	 */
-	if (res->start & (align - 1)) {
+	if (!IS_ALIGNED(res->start, align)) {
 		dev_printk(KERN_DEBUG, &bridge->dev,
 			   "host bridge window %pR invalid; "
 			   "aligning start to %d-byte boundary\n", res, align);
 		res->start &= ~(align - 1);
 	}
-	if ((res->end + 1) & (align - 1)) {
+	if (!IS_ALIGNED(res->end + 1, align)) {
 		dev_printk(KERN_DEBUG, &bridge->dev,
 			   "host bridge window %pR invalid; "
 			   "aligning end to %d-byte boundary\n", res, align);
-		res->end = roundup(res->end, align) - 1;
+		res->end = ALIGN(res->end, align) - 1;
 	}
 }
 

commit 03db42adfeeabe856dbb6894dd3aaff55838330a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:39:18 2009 -0700

    x86/PCI: fix bogus host bridge window start/end alignment from _CRS
    
    PCI device BARs are guaranteed to start and end on at least a four-byte
    (I/O) or a sixteen-byte (MMIO) boundary because they're aligned on their
    size and the low BAR bits are reserved.  PCI-to-PCI bridge apertures
    have even larger alignment restrictions.
    
    However, some BIOSes (e.g., HP DL360 BIOS P31) report host bridge windows
    like "[io  0x0000-0x2cfe]".  This is wrong because it excludes the last
    port at 0x2cff: it's impossible for a downstream device to claim 0x2cfe
    without also claiming 0x2cff.  In fact, this BIOS configures a device
    behind the bridge to "[io  0x2c00-0x2cff]", so we know the window actually
    does include 0x2cff.
    
    This patch rounds the start and end of apertures to the appropriate
    boundary.  I experimentally determined that Windows contains a similar
    workaround; details here:
    
        http://bugzilla.kernel.org/show_bug.cgi?id=14337
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 54db5a04b5e1..8ddf4f4c7253 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -59,6 +59,30 @@ bus_has_transparent_bridge(struct pci_bus *bus)
 	return false;
 }
 
+static void
+align_resource(struct acpi_device *bridge, struct resource *res)
+{
+	int align = (res->flags & IORESOURCE_MEM) ? 16 : 4;
+
+	/*
+	 * Host bridge windows are not BARs, but the decoders on the PCI side
+	 * that claim this address space have starting alignment and length
+	 * constraints, so fix any obvious BIOS goofs.
+	 */
+	if (res->start & (align - 1)) {
+		dev_printk(KERN_DEBUG, &bridge->dev,
+			   "host bridge window %pR invalid; "
+			   "aligning start to %d-byte boundary\n", res, align);
+		res->start &= ~(align - 1);
+	}
+	if ((res->end + 1) & (align - 1)) {
+		dev_printk(KERN_DEBUG, &bridge->dev,
+			   "host bridge window %pR invalid; "
+			   "aligning end to %d-byte boundary\n", res, align);
+		res->end = roundup(res->end, align) - 1;
+	}
+}
+
 static acpi_status
 setup_resource(struct acpi_resource *acpi_res, void *data)
 {
@@ -107,6 +131,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->start = start;
 	res->end = end;
 	res->child = NULL;
+	align_resource(info->bridge, res);
 
 	if (!(pci_probe & PCI_USE__CRS)) {
 		dev_printk(KERN_DEBUG, &info->bridge->dev,

commit f1db6fde09e201218f488d7205a7cd7bc448d496
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:39:13 2009 -0700

    x86/PCI: for debuggability, show host bridge windows even when ignoring _CRS
    
    We have occasional problems with PCI resource allocation, and sometimes
    they could be avoided by paying attention to what ACPI tells us about
    the host bridges.  This patch doesn't change the behavior, but it prints
    window information that should make debugging easier.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 68b89dc7d761..54db5a04b5e1 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -92,11 +92,12 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	start = addr.minimum + addr.translation_offset;
 	end = start + addr.address_length - 1;
 	if (info->res_num >= max_root_bus_resources) {
-		printk(KERN_WARNING "PCI: Failed to allocate 0x%lx-0x%lx "
-			"from %s for %s due to _CRS returning more than "
-			"%d resource descriptors\n", (unsigned long) start,
-			(unsigned long) end, root->name, info->name,
-			max_root_bus_resources);
+		if (pci_probe & PCI_USE__CRS)
+			printk(KERN_WARNING "PCI: Failed to allocate "
+			       "0x%lx-0x%lx from %s for %s due to _CRS "
+			       "returning more than %d resource descriptors\n",
+			       (unsigned long) start, (unsigned long) end,
+			       root->name, info->name, max_root_bus_resources);
 		return AE_OK;
 	}
 
@@ -107,6 +108,12 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->end = end;
 	res->child = NULL;
 
+	if (!(pci_probe & PCI_USE__CRS)) {
+		dev_printk(KERN_DEBUG, &info->bridge->dev,
+			   "host bridge window %pR (ignored)\n", res);
+		return AE_OK;
+	}
+
 	if (insert_resource(root, res)) {
 		dev_err(&info->bridge->dev,
 			"can't allocate host bridge window %pR\n", res);
@@ -132,6 +139,11 @@ get_current_resources(struct acpi_device *device, int busnum,
 	struct pci_root_info info;
 	size_t size;
 
+	if (!(pci_probe & PCI_USE__CRS))
+		dev_info(&device->dev,
+			 "ignoring host bridge windows from ACPI; "
+			 "boot with \"pci=use_crs\" to use them\n");
+
 	info.bridge = device;
 	info.bus = bus;
 	info.res_num = 0;
@@ -220,9 +232,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	} else {
 		bus = pci_create_bus(NULL, busnum, &pci_root_ops, sd);
 		if (bus) {
-			if (pci_probe & PCI_USE__CRS)
-				get_current_resources(device, busnum, domain,
-							bus);
+			get_current_resources(device, busnum, domain, bus);
 			bus->subordinate = pci_scan_child_bus(bus);
 		}
 	}

commit 2a6bed8301f8b019717504575a3f9c6cce1fe271
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:47 2009 -0700

    x86/PCI: print domain:bus in conventional format
    
    Use the dev_printk-like "%04x:%02x" format for printing PCI bus numbers.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 6bf8091d2fd5..68b89dc7d761 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -172,8 +172,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 #endif
 
 	if (domain && !pci_domains_supported) {
-		printk(KERN_WARNING "PCI: Multiple domains not supported "
-		       "(dom %d, bus %d)\n", domain, busnum);
+		printk(KERN_WARNING "pci_bus %04x:%02x: "
+		       "ignored (multiple domains not supported)\n",
+		       domain, busnum);
 		return NULL;
 	}
 
@@ -197,7 +198,8 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	 */
 	sd = kzalloc(sizeof(*sd), GFP_KERNEL);
 	if (!sd) {
-		printk(KERN_ERR "PCI: OOM, not probing PCI bus %02x\n", busnum);
+		printk(KERN_WARNING "pci_bus %04x:%02x: "
+		       "ignored (out of memory)\n", domain, busnum);
 		return NULL;
 	}
 

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 9b3daf976732..6bf8091d2fd5 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -108,18 +108,19 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->child = NULL;
 
 	if (insert_resource(root, res)) {
-		dev_err(&info->bridge->dev, "can't allocate %pRt\n", res);
+		dev_err(&info->bridge->dev,
+			"can't allocate host bridge window %pR\n", res);
 	} else {
 		info->bus->resource[info->res_num] = res;
 		info->res_num++;
 		if (addr.translation_offset)
-			dev_info(&info->bridge->dev, "host bridge window: %pRt "
+			dev_info(&info->bridge->dev, "host bridge window %pR "
 				 "(PCI address [%#llx-%#llx])\n",
 				 res, res->start - addr.translation_offset,
 				 res->end - addr.translation_offset);
 		else
 			dev_info(&info->bridge->dev,
-				 "host bridge window: %pRt\n", res);
+				 "host bridge window %pR\n", res);
 	}
 	return AE_OK;
 }

commit 42887b29ced263ec3b8bd26ef157a324789b89d9
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:33:49 2009 -0600

    x86/PCI: print resources consistently with %pRt
    
    This uses %pRt to print additional resource information (type, size,
    prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 1014eb4bfc37..9b3daf976732 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -7,6 +7,7 @@
 #include <asm/pci_x86.h>
 
 struct pci_root_info {
+	struct acpi_device *bridge;
 	char *name;
 	unsigned int res_num;
 	struct resource *res;
@@ -107,12 +108,18 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->child = NULL;
 
 	if (insert_resource(root, res)) {
-		printk(KERN_ERR "PCI: Failed to allocate 0x%lx-0x%lx "
-			"from %s for %s\n", (unsigned long) res->start,
-			(unsigned long) res->end, root->name, info->name);
+		dev_err(&info->bridge->dev, "can't allocate %pRt\n", res);
 	} else {
 		info->bus->resource[info->res_num] = res;
 		info->res_num++;
+		if (addr.translation_offset)
+			dev_info(&info->bridge->dev, "host bridge window: %pRt "
+				 "(PCI address [%#llx-%#llx])\n",
+				 res, res->start - addr.translation_offset,
+				 res->end - addr.translation_offset);
+		else
+			dev_info(&info->bridge->dev,
+				 "host bridge window: %pRt\n", res);
 	}
 	return AE_OK;
 }
@@ -124,6 +131,7 @@ get_current_resources(struct acpi_device *device, int busnum,
 	struct pci_root_info info;
 	size_t size;
 
+	info.bridge = device;
 	info.bus = bus;
 	info.res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,

commit 626fdfec1588ac1341a37805809d03a719d977e0
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Jun 24 20:00:12 2009 -0700

    x86/PCI: get root CRS before scanning children
    
    This allows us to remove adjust_transparent_bridge_resources and give
    x86_pci_root_bus_res_quirks a chance when _CRS is not used or not there.
    
    Acked-by: Gary Hade <garyhade@us.ibm.com>
    Tested-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 8bf152910eb0..1014eb4bfc37 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -117,23 +117,6 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	return AE_OK;
 }
 
-static void
-adjust_transparent_bridge_resources(struct pci_bus *bus)
-{
-	struct pci_dev *dev;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		int i;
-		u16 class = dev->class >> 8;
-
-		if (class == PCI_CLASS_BRIDGE_PCI && dev->transparent) {
-			for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
-				dev->subordinate->resource[i] =
-						dev->bus->resource[i - 3];
-		}
-	}
-}
-
 static void
 get_current_resources(struct acpi_device *device, int busnum,
 			int domain, struct pci_bus *bus)
@@ -161,8 +144,6 @@ get_current_resources(struct acpi_device *device, int busnum,
 	info.res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
 				&info);
-	if (info.res_num)
-		adjust_transparent_bridge_resources(bus);
 
 	return;
 
@@ -225,8 +206,15 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		 */
 		memcpy(bus->sysdata, sd, sizeof(*sd));
 		kfree(sd);
-	} else
-		bus = pci_scan_bus_parented(NULL, busnum, &pci_root_ops, sd);
+	} else {
+		bus = pci_create_bus(NULL, busnum, &pci_root_ops, sd);
+		if (bus) {
+			if (pci_probe & PCI_USE__CRS)
+				get_current_resources(device, busnum, domain,
+							bus);
+			bus->subordinate = pci_scan_child_bus(bus);
+		}
+	}
 
 	if (!bus)
 		kfree(sd);
@@ -241,8 +229,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 #endif
 	}
 
-	if (bus && (pci_probe & PCI_USE__CRS))
-		get_current_resources(device, busnum, domain, bus);
 	return bus;
 }
 

commit 2cdb3f1d834aab27a927be7555fbf4f9e43e9261
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Jun 24 19:01:19 2009 -0700

    x86/PCI: fix boundary checking when using root CRS
    
    Don't touch info->res_num if we are out of space.
    
    Acked-by: Gary Hade <garyhade@us.ibm.com>
    Tested-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index b26626dc517c..8bf152910eb0 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -68,6 +68,10 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	unsigned long flags;
 	struct resource *root;
 	int max_root_bus_resources = PCI_BUS_NUM_RESOURCES;
+	u64 start, end;
+
+	if (bus_has_transparent_bridge(info->bus))
+		max_root_bus_resources -= 3;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -84,25 +88,24 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	} else
 		return AE_OK;
 
-	res = &info->res[info->res_num];
-	res->name = info->name;
-	res->flags = flags;
-	res->start = addr.minimum + addr.translation_offset;
-	res->end = res->start + addr.address_length - 1;
-	res->child = NULL;
-
-	if (bus_has_transparent_bridge(info->bus))
-		max_root_bus_resources -= 3;
+	start = addr.minimum + addr.translation_offset;
+	end = start + addr.address_length - 1;
 	if (info->res_num >= max_root_bus_resources) {
 		printk(KERN_WARNING "PCI: Failed to allocate 0x%lx-0x%lx "
 			"from %s for %s due to _CRS returning more than "
-			"%d resource descriptors\n", (unsigned long) res->start,
-			(unsigned long) res->end, root->name, info->name,
+			"%d resource descriptors\n", (unsigned long) start,
+			(unsigned long) end, root->name, info->name,
 			max_root_bus_resources);
-		info->res_num++;
 		return AE_OK;
 	}
 
+	res = &info->res[info->res_num];
+	res->name = info->name;
+	res->flags = flags;
+	res->start = start;
+	res->end = end;
+	res->child = NULL;
+
 	if (insert_resource(root, res)) {
 		printk(KERN_ERR "PCI: Failed to allocate 0x%lx-0x%lx "
 			"from %s for %s\n", (unsigned long) res->start,

commit 236e946b53ffd5e2f5d7e6abebbe72a9f0826d15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 24 16:23:03 2009 -0700

    Revert "PCI: use ACPI _CRS data by default"
    
    This reverts commit 9e9f46c44e487af0a82eb61b624553e2f7118f5b.
    
    Quoting from the commit message:
    
     "At this point, it seems to solve more problems than it causes, so let's
      try using it by default.  It's an easy revert if it ends up causing
      trouble."
    
    And guess what? The _CRS code causes trouble.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 16c3fda85bba..b26626dc517c 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -238,7 +238,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 #endif
 	}
 
-	if (bus && !(pci_probe & PCI_NO_ROOT_CRS))
+	if (bus && (pci_probe & PCI_USE__CRS))
 		get_current_resources(device, busnum, domain, bus);
 	return bus;
 }

commit f9cde5ffed17bf74f6bef042d99edb0622f58576
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Wed May 27 12:41:44 2009 -0700

    x86/ACPI: Correct maximum allowed _CRS returned resources and warn if exceeded
    
    Issue a warning if _CRS returns too many resource descriptors to be
    accommodated by the fixed size resource array instances.  If there is no
    transparent bridge on the root bus "too many" is the
    PCI_BUS_NUM_RESOURCES size of the resource array.  Otherwise, the last 3
    slots of the resource array must be excluded making the maximum
    (PCI_BUS_NUM_RESOURCES - 3).
    
    The current code:
     - is silent when _CRS returns too many resource descriptors and
     - incorrectly allows use of the last 3 slots of the resource array
       for a root bus with a transparent bridge
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 8d898e0d3609..16c3fda85bba 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -38,15 +38,26 @@ count_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 
-	if (info->res_num >= PCI_BUS_NUM_RESOURCES)
-		return AE_OK;
-
 	status = resource_to_addr(acpi_res, &addr);
 	if (ACPI_SUCCESS(status))
 		info->res_num++;
 	return AE_OK;
 }
 
+static int
+bus_has_transparent_bridge(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		u16 class = dev->class >> 8;
+
+		if (class == PCI_CLASS_BRIDGE_PCI && dev->transparent)
+			return true;
+	}
+	return false;
+}
+
 static acpi_status
 setup_resource(struct acpi_resource *acpi_res, void *data)
 {
@@ -56,9 +67,7 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	acpi_status status;
 	unsigned long flags;
 	struct resource *root;
-
-	if (info->res_num >= PCI_BUS_NUM_RESOURCES)
-		return AE_OK;
+	int max_root_bus_resources = PCI_BUS_NUM_RESOURCES;
 
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
@@ -82,6 +91,18 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	res->end = res->start + addr.address_length - 1;
 	res->child = NULL;
 
+	if (bus_has_transparent_bridge(info->bus))
+		max_root_bus_resources -= 3;
+	if (info->res_num >= max_root_bus_resources) {
+		printk(KERN_WARNING "PCI: Failed to allocate 0x%lx-0x%lx "
+			"from %s for %s due to _CRS returning more than "
+			"%d resource descriptors\n", (unsigned long) res->start,
+			(unsigned long) res->end, root->name, info->name,
+			max_root_bus_resources);
+		info->res_num++;
+		return AE_OK;
+	}
+
 	if (insert_resource(root, res)) {
 		printk(KERN_ERR "PCI: Failed to allocate 0x%lx-0x%lx "
 			"from %s for %s\n", (unsigned long) res->start,

commit 9e9f46c44e487af0a82eb61b624553e2f7118f5b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Jun 11 10:58:28 2009 -0700

    PCI: use ACPI _CRS data by default
    
    At this point, it seems to solve more problems than it causes, so let's try using it by default.  It's an easy revert if it ends up causing trouble.
    
    Reviewed-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index c0ecf250fe51..8d898e0d3609 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -217,7 +217,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 #endif
 	}
 
-	if (bus && (pci_probe & PCI_USE__CRS))
+	if (bus && !(pci_probe & PCI_NO_ROOT_CRS))
 		get_current_resources(device, busnum, domain, bus);
 	return bus;
 }

commit 2b8c2efe44ed897fc958131d70addc89876d806b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Dec 18 16:34:51 2008 -0700

    x86/PCI: use dev_printk for PCI bus locality messages
    
    Since pci_bus has a struct device, use dev_printk directly instead
    of faking it by hand.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 6c7683709c44..c0ecf250fe51 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -210,12 +210,10 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (bus && node != -1) {
 #ifdef CONFIG_ACPI_NUMA
 		if (pxm >= 0)
-			printk(KERN_DEBUG
-			       "pci %04x:%02x: bus on NUMA node %d (pxm %d)\n",
-				domain, busnum, node, pxm);
+			dev_printk(KERN_DEBUG, &bus->dev,
+				   "on NUMA node %d (pxm %d)\n", node, pxm);
 #else
-		printk(KERN_DEBUG "pci %04x:%02x: bus on NUMA node %d\n",
-			domain, busnum, node);
+		dev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);
 #endif
 	}
 

commit 0663a36284586ac9a9781be8aa7e8ca9fff16d06
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Dec 10 13:12:00 2008 -0700

    x86/PCI: make PCI bus locality messages more meaningful
    
    Change PCI bus locality messages so they have a bit more context
    and look like the rest of PCI, e.g.,
    
        - bus 01 -> node 0
        - bus 04 -> node 0
        + pci 0000:01: bus on NUMA node 0
        + pci 0000:04: bus on NUMA node 0
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 9e5752fe4d15..6c7683709c44 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -210,11 +210,12 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (bus && node != -1) {
 #ifdef CONFIG_ACPI_NUMA
 		if (pxm >= 0)
-			printk(KERN_DEBUG "bus %02x -> pxm %d -> node %d\n",
-				busnum, pxm, node);
+			printk(KERN_DEBUG
+			       "pci %04x:%02x: bus on NUMA node %d (pxm %d)\n",
+				domain, busnum, node, pxm);
 #else
-		printk(KERN_DEBUG "bus %02x -> node %d\n",
-			busnum, node);
+		printk(KERN_DEBUG "pci %04x:%02x: bus on NUMA node %d\n",
+			domain, busnum, node);
 #endif
 	}
 

commit 824877111cd7f2b4fd2fe6947c5c5cbbb3ac5bd8
Author: Jaswinder Singh Rajput <jaswinder@infradead.org>
Date:   Sat Dec 27 18:32:28 2008 +0530

    x86, pci: move arch/x86/pci/pci.h to arch/x86/include/asm/pci_x86.h
    
    Impact: cleanup
    
    Now that arch/x86/pci/pci.h is used in a number of other places as well,
    move the lowlevel x86 pci definitions into the architecture include files.
    (not to be confused with the existing arch/x86/include/asm/pci.h file,
    which provides public details about x86 PCI)
    
    Tested on: X86_32_UP, X86_32_SMP and X86_64_SMP
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 1d88d2b39771..9e5752fe4d15 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -4,7 +4,7 @@
 #include <linux/irq.h>
 #include <linux/dmi.h>
 #include <asm/numa.h>
-#include "pci.h"
+#include <asm/pci_x86.h>
 
 struct pci_root_info {
 	char *name;

commit 32f71aff77b6470d272f80ac28f43f9601c4d140
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Jul 21 00:52:49 2008 +0100

    x86: PIC, L-APIC and I/O APIC debug information
    
     Dump all the PIC, local APIC and I/O APIC information at the
    fs_initcall() level, which is after ACPI (if used) has initialised PCI
    information, making the point of invocation consistent across MP-table and
    ACPI platforms.  Remove explicit calls to print_IO_APIC() from elsewhere.
    Make the interface of all the functions involved consistent between 32-bit
    and 64-bit versions and make them all static by default by the means of a
    New-and-Improved(TM) __apicdebuginit() macro.
    
     Note that like print_IO_APIC() all these only output anything if
    "apic=debug" has been passed to the kernel through the command line.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 19af06927fbc..1d88d2b39771 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -250,10 +250,5 @@ int __init pci_acpi_init(void)
 			acpi_pci_irq_enable(dev);
 	}
 
-#ifdef CONFIG_X86_IO_APIC
-	if (acpi_ioapic)
-		print_IO_APIC();
-#endif
-
 	return 0;
 }

commit 8dd779b19ce5972072ad2372a86c8acbae4da768
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Jul 2 22:50:29 2008 +0200

    x86/pci: removing subsys_initcall ordering dependencies
    
    So far subsys_initcalls has been executed in this order depending on
    the object order in the Makefile:
    
    arch/x86/pci/visws.c:subsys_initcall(pcibios_init);
    arch/x86/pci/numa.c:subsys_initcall(pci_numa_init);
    arch/x86/pci/acpi.c:subsys_initcall(pci_acpi_init);
    arch/x86/pci/legacy.c:subsys_initcall(pci_legacy_init);
    arch/x86/pci/irq.c:subsys_initcall(pcibios_irq_init);
    arch/x86/pci/common.c:subsys_initcall(pcibios_init);
    
    This patch removes the ordering dependency. There is now only one
    subsys_initcall function that contains subsystem initialization code
    with a defined order.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 4fa52d3dc848..19af06927fbc 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -223,7 +223,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	return bus;
 }
 
-static int __init pci_acpi_init(void)
+int __init pci_acpi_init(void)
 {
 	struct pci_dev *dev = NULL;
 
@@ -257,4 +257,3 @@ static int __init pci_acpi_init(void)
 
 	return 0;
 }
-subsys_initcall(pci_acpi_init);

commit 2b4fa851b2f06fdb04cac808b57324f5e51e1578
Merge: 3de352bbd86f 46f68e1c6b04
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jul 8 11:59:23 2008 +0200

    Merge branch 'x86/numa' into x86/devel
    
    Conflicts:
    
            arch/x86/Kconfig
            arch/x86/kernel/e820.c
            arch/x86/kernel/efi_64.c
            arch/x86/kernel/mpparse.c
            arch/x86/kernel/setup.c
            arch/x86/kernel/setup_32.c
            arch/x86/mm/init_64.c
            include/asm-x86/proto.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit dbb6152e6f72df367f8a955586c5e6282a7255e5
Author: Yinghai Lu <yhlu.kernel.send@gmail.com>
Date:   Sat Apr 19 01:30:16 2008 -0700

    x86: don't call pxm_to_node again
    
    also make bus_numa work even if ACPI_NUMA is not defined.
    
    don't call pxm_to_node again, and use node directly.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index ea8685f89bc3..28d17a5cfb8d 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -171,11 +171,11 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (node != -1)
 		set_mp_bus_to_node(busnum, node);
 	else
+#endif
 		node = get_mp_bus_to_node(busnum);
 
 	if (node != -1 && !node_online(node))
 		node = -1;
-#endif
 
 	/* Allocate per-root-bus (not per bus) arch-specific data.
 	 * TODO: leak; this memory is never freed.
@@ -207,14 +207,16 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (!bus)
 		kfree(sd);
 
+	if (bus && node != -1) {
 #ifdef CONFIG_ACPI_NUMA
-	if (bus) {
-		if (pxm >= 0) {
+		if (pxm >= 0)
 			printk(KERN_DEBUG "bus %02x -> pxm %d -> node %d\n",
-				busnum, pxm, pxm_to_node(pxm));
-		}
-	}
+				busnum, pxm, node);
+#else
+		printk(KERN_DEBUG "bus %02x -> node %d\n",
+			busnum, node);
 #endif
+	}
 
 	if (bus && (pci_probe & PCI_USE__CRS))
 		get_current_resources(device, busnum, domain, bus);

commit b755de8dfdfef97effaa91379ffafcb81f4d62a1
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Wed Feb 20 12:41:52 2008 -0800

    x86: make dev_to_node return online node
    
    a numa system (with multi HT chains) may return node without ram. Aka it
    is not online. Try to get an online node, otherwise return -1.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index d95de2f199cd..ea8685f89bc3 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -172,6 +172,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		set_mp_bus_to_node(busnum, node);
 	else
 		node = get_mp_bus_to_node(busnum);
+
+	if (node != -1 && !node_online(node))
+		node = -1;
 #endif
 
 	/* Allocate per-root-bus (not per bus) arch-specific data.

commit 071565095897dff9668cd4a2343160ae31538c27
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 12 15:43:37 2008 +0200

    x86: move pci_routirq declaration to pci.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index d95de2f199cd..464279da49c4 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -218,7 +218,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	return bus;
 }
 
-extern int pci_routeirq;
 static int __init pci_acpi_init(void)
 {
 	struct pci_dev *dev = NULL;

commit 13a6ddb08e58a1bd344da7898c4e2f13bdf18c2f
Author: Yinghai Lu <yhlu.kernel.send@gmail.com>
Date:   Thu Mar 27 01:31:18 2008 -0700

    x86/pci: add pci=skip_isa_align command lines.
    
    so we don't align the io port start address for pci cards.
    
    also move out dmi check out acpi.c, because it has nothing to do with acpi.
    it could spare some calling when we have several peer root buses.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 1a9c0c6a1a18..d95de2f199cd 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -6,45 +6,6 @@
 #include <asm/numa.h>
 #include "pci.h"
 
-static int __devinit can_skip_ioresource_align(const struct dmi_system_id *d)
-{
-	pci_probe |= PCI_CAN_SKIP_ISA_ALIGN;
-	printk(KERN_INFO "PCI: %s detected, can skip ISA alignment\n", d->ident);
-	return 0;
-}
-
-static struct dmi_system_id acpi_pciprobe_dmi_table[] __devinitdata = {
-/*
- * Systems where PCI IO resource ISA alignment can be skipped
- * when the ISA enable bit in the bridge control is not set
- */
-	{
-		.callback = can_skip_ioresource_align,
-		.ident = "IBM System x3800",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "x3800"),
-		},
-	},
-	{
-		.callback = can_skip_ioresource_align,
-		.ident = "IBM System x3850",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "x3850"),
-		},
-	},
-	{
-		.callback = can_skip_ioresource_align,
-		.ident = "IBM System x3950",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "x3950"),
-		},
-	},
-	{}
-};
-
 struct pci_root_info {
 	char *name;
 	unsigned int res_num;
@@ -196,8 +157,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	int pxm;
 #endif
 
-	dmi_check_system(acpi_pciprobe_dmi_table);
-
 	if (domain && !pci_domains_supported) {
 		printk(KERN_WARNING "PCI: Multiple domains not supported "
 		       "(dom %d, bus %d)\n", domain, busnum);

commit 871d5f8dd0f7647f03facd4cb79485938d1b61ab
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Tue Feb 19 03:20:09 2008 -0800

    x86: get mp_bus_to_node early
    
    Currently, on an amd k8 system with multi ht chains, the numa_node of
    pci devices under /sys/devices/pci0000:80/* is always 0, even if that
    chain is on node 1 or 2 or 3.
    
    Workaround: pcibus_to_node(bus) is used when we want to get the node that
    pci_device is on.
    
    In struct device, we already have numa_node member, and we could use
    dev_to_node()/set_dev_node() to get and set numa_node in the device.
    set_dev_node is called in pci_device_add() with pcibus_to_node(bus),
    and pcibus_to_node uses bus->sysdata for nodeid.
    
    The problem is when pci_add_device is called, bus->sysdata is not assigned
    correct nodeid yet. The result is that numa_node will always be 0.
    
    pcibios_scan_root and pci_scan_root could take sysdata. So we need to get
    mp_bus_to_node mapping before these two are called, and thus
    get_mp_bus_to_node could get correct node for sysdata in root bus.
    
    In scanning of the root bus, all child busses will take parent bus sysdata.
    So all pci_device->dev.numa_node will be assigned correctly and automatically.
    
    Later we could use dev_to_node(&pci_dev->dev) to get numa_node, and we
    could also could make other bus specific device get the correct numa_node
    too.
    
    This is an updated version of pci_sysdata and Jeff's pci_domain patch.
    
    [ mingo@elte.hu: build fix ]
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2664cb3fc96c..1a9c0c6a1a18 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -191,7 +191,10 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 {
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
+	int node;
+#ifdef CONFIG_ACPI_NUMA
 	int pxm;
+#endif
 
 	dmi_check_system(acpi_pciprobe_dmi_table);
 
@@ -201,6 +204,17 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		return NULL;
 	}
 
+	node = -1;
+#ifdef CONFIG_ACPI_NUMA
+	pxm = acpi_get_pxm(device->handle);
+	if (pxm >= 0)
+		node = pxm_to_node(pxm);
+	if (node != -1)
+		set_mp_bus_to_node(busnum, node);
+	else
+		node = get_mp_bus_to_node(busnum);
+#endif
+
 	/* Allocate per-root-bus (not per bus) arch-specific data.
 	 * TODO: leak; this memory is never freed.
 	 * It's arguable whether it's worth the trouble to care.
@@ -212,13 +226,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	}
 
 	sd->domain = domain;
-	sd->node = -1;
-
-	pxm = acpi_get_pxm(device->handle);
-#ifdef CONFIG_ACPI_NUMA
-	if (pxm >= 0)
-		sd->node = pxm_to_node(pxm);
-#endif
+	sd->node = node;
 	/*
 	 * Maybe the desired pci bus has been already scanned. In such case
 	 * it is unnecessary to scan the pci bus with the given domain,busnum.
@@ -238,9 +246,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		kfree(sd);
 
 #ifdef CONFIG_ACPI_NUMA
-	if (bus != NULL) {
+	if (bus) {
 		if (pxm >= 0) {
-			printk("bus %d -> pxm %d -> node %d\n",
+			printk(KERN_DEBUG "bus %02x -> pxm %d -> node %d\n",
 				busnum, pxm, pxm_to_node(pxm));
 		}
 	}
@@ -248,7 +256,6 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 
 	if (bus && (pci_probe & PCI_USE__CRS))
 		get_current_resources(device, busnum, domain, bus);
-	
 	return bus;
 }
 

commit 657472e9ccd9fccb82b775eb691c4b25b27451da
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Feb 18 09:44:13 2008 -0700

    PCI: remove "pci=routeirq" noise from dmesg
    
    The "pci=routeirq" option was added in 2004, and I don't get any valid
    reports anymore.  The option is still mentioned in kernel-parameters.txt.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 8e0e7238370e..2664cb3fc96c 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -278,8 +278,7 @@ static int __init pci_acpi_init(void)
 		printk(KERN_INFO "PCI: Routing PCI interrupts for all devices because \"pci=routeirq\" specified\n");
 		for_each_pci_dev(dev)
 			acpi_pci_irq_enable(dev);
-	} else
-		printk(KERN_INFO "PCI: If a device doesn't work, try \"pci=routeirq\".  If it helps, post a report\n");
+	}
 
 #ifdef CONFIG_X86_IO_APIC
 	if (acpi_ioapic)

commit cb3576fa34e36907e292f408cb6c258f4fd112ad
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Fri Feb 8 14:00:52 2008 -0800

    PCI: Include PCI domain in PCI bus names on x86/x86_64
    
    The PCI bus names included in /proc/iomem and /proc/ioports are
    of the form 'PCI Bus #XX' where XX is the bus number.  This patch
    changes the naming to 'PCI Bus XXXX:YY' where XXXX is the domain
    number and YY is the bus number.  For example, PCI bus 14 in
    domain 0 will show as 'PCI Bus 0000:14' instead of 'PCI Bus #14'.
    This change makes the naming consistent with other architectures
    such as ia64 where multiple PCI domain support has been around
    longer.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 378136fb5044..8e0e7238370e 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -151,7 +151,7 @@ adjust_transparent_bridge_resources(struct pci_bus *bus)
 
 static void
 get_current_resources(struct acpi_device *device, int busnum,
-			struct pci_bus *bus)
+			int domain, struct pci_bus *bus)
 {
 	struct pci_root_info info;
 	size_t size;
@@ -168,10 +168,10 @@ get_current_resources(struct acpi_device *device, int busnum,
 	if (!info.res)
 		goto res_alloc_fail;
 
-	info.name = kmalloc(12, GFP_KERNEL);
+	info.name = kmalloc(16, GFP_KERNEL);
 	if (!info.name)
 		goto name_alloc_fail;
-	sprintf(info.name, "PCI Bus #%02x", busnum);
+	sprintf(info.name, "PCI Bus %04x:%02x", domain, busnum);
 
 	info.res_num = 0;
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
@@ -247,7 +247,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 #endif
 
 	if (bus && (pci_probe & PCI_USE__CRS))
-		get_current_resources(device, busnum, bus);
+		get_current_resources(device, busnum, domain, bus);
 	
 	return bus;
 }

commit b87e81e5c6e64ae0eae3b4f61bf07bfeec856184
Author: yakui.zhao@intel.com <yakui.zhao@intel.com>
Date:   Tue Apr 15 14:34:49 2008 -0700

    acpi: unneccessary to scan the PCI bus already scanned
    
    http://bugzilla.kernel.org/show_bug.cgi?id=10124
    
    this change:
    
          commit 08f1c192c3c32797068bfe97738babb3295bbf42
          Author: Muli Ben-Yehuda <muli@il.ibm.com>
          Date:   Sun Jul 22 00:23:39 2007 +0300
    
             x86-64: introduce struct pci_sysdata to facilitate sharing of ->sysdata
    
             This patch introduces struct pci_sysdata to x86 and x86-64, and
             converts the existing two users (NUMA, Calgary) to use it.
    
             This lays the groundwork for having other users of sysdata, such as
             the PCI domains work.
    
             The Calgary bits are tested, the NUMA bits just look ok.
    
    replaces pcibios_scan_root by pci_scan_bus_parented...
    
    but in pcibios_scan_root we have a check about scanned busses.
    
    Cc: <yakui.zhao@intel.com>
    Cc: Stian Jordet <stian@jordet.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "Yinghai Lu" <yhlu.kernel@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 0234f2831bf3..378136fb5044 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -219,8 +219,21 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (pxm >= 0)
 		sd->node = pxm_to_node(pxm);
 #endif
+	/*
+	 * Maybe the desired pci bus has been already scanned. In such case
+	 * it is unnecessary to scan the pci bus with the given domain,busnum.
+	 */
+	bus = pci_find_bus(domain, busnum);
+	if (bus) {
+		/*
+		 * If the desired bus exits, the content of bus->sysdata will
+		 * be replaced by sd.
+		 */
+		memcpy(bus->sysdata, sd, sizeof(*sd));
+		kfree(sd);
+	} else
+		bus = pci_scan_bus_parented(NULL, busnum, &pci_root_ops, sd);
 
-	bus = pci_scan_bus_parented(NULL, busnum, &pci_root_ops, sd);
 	if (!bus)
 		kfree(sd);
 
@@ -228,7 +241,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 	if (bus != NULL) {
 		if (pxm >= 0) {
 			printk("bus %d -> pxm %d -> node %d\n",
-				busnum, pxm, sd->node);
+				busnum, pxm, pxm_to_node(pxm));
 		}
 	}
 #endif

commit e6532b8883760bdf9d251c669a3919fc9457aeca
Merge: d89a9bda1420 4fdb2a05ef57
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 20 01:21:47 2007 -0500

    Pull fluff into release branch
    
    Conflicts:
    
            drivers/acpi/ec.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 3d9befd2cdf65b1768b0d3078a65cc0ae9aa6412
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Sat Nov 17 16:27:01 2007 +0100

    x86: check boundary in count setup resource
    
    need to check info->res_num less than PCI_BUS_NUM_RESOURCES, so
    info->bus->resource[info->res_num] = res will not beyond of bus resource
    array when acpi returns too many resource entries.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Gary Hade <gary.hade@us.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2d88f7c6d6ac..7e35078673a4 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -77,6 +77,9 @@ count_resource(struct acpi_resource *acpi_res, void *data)
 	struct acpi_resource_address64 addr;
 	acpi_status status;
 
+	if (info->res_num >= PCI_BUS_NUM_RESOURCES)
+		return AE_OK;
+
 	status = resource_to_addr(acpi_res, &addr);
 	if (ACPI_SUCCESS(status))
 		info->res_num++;
@@ -93,6 +96,9 @@ setup_resource(struct acpi_resource *acpi_res, void *data)
 	unsigned long flags;
 	struct resource *root;
 
+	if (info->res_num >= PCI_BUS_NUM_RESOURCES)
+		return AE_OK;
+
 	status = resource_to_addr(acpi_res, &addr);
 	if (!ACPI_SUCCESS(status))
 		return AE_OK;

commit 55b8d50c1a7b2d53eddaa3114dc55b0ed00df0f3
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Nov 9 07:02:11 2007 +0100

    x86: acpi_pciprobe_dmi_table[] must be __devinitdata
    
    This patch fixes the following section mismatches with CONFIG_HOTPLUG=n:
    
    <--  snip  -->
    
    ...
    WARNING: vmlinux.o(.data+0x23640): Section mismatch: reference to .init.text.20:can_skip_ioresource_align (between 'acpi_pciprobe_dmi_table' and 'pcibios_irq_mask')
    WARNING: vmlinux.o(.data+0x2366c): Section mismatch: reference to .init.text.20:can_skip_ioresource_align (between 'acpi_pciprobe_dmi_table' and 'pcibios_irq_mask')
    WARNING: vmlinux.o(.data+0x23698): Section mismatch: reference to .init.text.20:can_skip_ioresource_align (between 'acpi_pciprobe_dmi_table' and 'pcibios_irq_mask')
    ...
    
    <--  snip  -->
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 2d88f7c6d6ac..a7536dcc2acf 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -13,7 +13,7 @@ static int __devinit can_skip_ioresource_align(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id acpi_pciprobe_dmi_table[] = {
+static struct dmi_system_id acpi_pciprobe_dmi_table[] __devinitdata = {
 /*
  * Systems where PCI IO resource ISA alignment can be skipped
  * when the ISA enable bit in the bridge control is not set

commit 752097cec53eea111d087c545179b421e2bde98a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 12 22:34:40 2007 -0400

    x86/pci/acpi: fix DMI const-ification fallout
    
    Fix DMI const-ification fallout that appeared when merging subsystem
    trees.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 27a391da9a98..2d88f7c6d6ac 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -6,7 +6,7 @@
 #include <asm/numa.h>
 #include "pci.h"
 
-static int __devinit can_skip_ioresource_align(struct dmi_system_id *d)
+static int __devinit can_skip_ioresource_align(const struct dmi_system_id *d)
 {
 	pci_probe |= PCI_CAN_SKIP_ISA_ALIGN;
 	printk(KERN_INFO "PCI: %s detected, can skip ISA alignment\n", d->ident);

commit a79e4198d1effbba040e9bf407a95fc9b3418789
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Oct 11 16:58:30 2007 -0400

    PCI: X86: Introduce and enable PCI domain support
    
    * fix bug in pci_read() and pci_write() which prevented PCI domain
      support from working (hardcoded domain 0).
    
    * unconditionally enable CONFIG_PCI_DOMAINS
    
    * implement pci_domain_nr() and pci_proc_domain(), as required of
      all arches when CONFIG_PCI_DOMAINS is enabled.
    
    * store domain in struct pci_sysdata, as assigned by ACPI
    
    * support "pci=nodomains"
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index c6fd3a6afa42..27a391da9a98 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -189,6 +189,12 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 
 	dmi_check_system(acpi_pciprobe_dmi_table);
 
+	if (domain && !pci_domains_supported) {
+		printk(KERN_WARNING "PCI: Multiple domains not supported "
+		       "(dom %d, bus %d)\n", domain, busnum);
+		return NULL;
+	}
+
 	/* Allocate per-root-bus (not per bus) arch-specific data.
 	 * TODO: leak; this memory is never freed.
 	 * It's arguable whether it's worth the trouble to care.
@@ -199,12 +205,7 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		return NULL;
 	}
 
-	if (domain != 0) {
-		printk(KERN_WARNING "PCI: Multiple domains not supported\n");
-		kfree(sd);
-		return NULL;
-	}
-
+	sd->domain = domain;
 	sd->node = -1;
 
 	pxm = acpi_get_pxm(device->handle);

commit 62f420f828249f686aaae949ac3439d1304a759a
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Wed Oct 3 15:56:51 2007 -0700

    PCI: use _CRS for PCI resource allocation
    
    Use _CRS for PCI resource allocation
    
    This patch resolves an issue where incorrect PCI memory and i/o ranges
    are being assigned to hotplugged PCI devices on some IBM systems.  The
    resource mis-allocation not only makes the PCI device unuseable but
    often makes the entire system unuseable due to resulting machine checks.
    
    The hotplug capable PCI slots on the affected systems are not located
    under a standard P2P bridge but are instead located under PCI root
    bridges or subtractive decode P2P bridges.  For example, the IBM x3850
    contains 2 hotplug capable PCI-X slots and 4 hotplug capable PCIe slots
    with the PCI-X slots each located under a PCI root bridge and the PCIe
    slots each located under a subtractive decode P2P bridge.
    
    The current i386/x86_64 PCI resource allocation code does not use _CRS
    returned resource information.  No other resource information source is
    available for slots that are not below a standard P2P bridge so
    incorrect ranges are being allocated from e820 hole causing the bad
    result.
    
    This patch causes the kernel to use _CRS returned resource info.  It is
    roughly based on a change provided by Matthew Wilcox for the ia64 kernel
    in 2005.  Due to possible buggy BIOS factor and possible yet to be
    discovered kernel issues the function is disabled by default and can be
    enabled with pci=use_crs.
    
    Signed-off-by: Gary Hade <gary.hade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 1dd6f3fc077d..c6fd3a6afa42 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -45,6 +45,142 @@ static struct dmi_system_id acpi_pciprobe_dmi_table[] = {
 	{}
 };
 
+struct pci_root_info {
+	char *name;
+	unsigned int res_num;
+	struct resource *res;
+	struct pci_bus *bus;
+	int busnum;
+};
+
+static acpi_status
+resource_to_addr(struct acpi_resource *resource,
+			struct acpi_resource_address64 *addr)
+{
+	acpi_status status;
+
+	status = acpi_resource_to_address64(resource, addr);
+	if (ACPI_SUCCESS(status) &&
+	    (addr->resource_type == ACPI_MEMORY_RANGE ||
+	    addr->resource_type == ACPI_IO_RANGE) &&
+	    addr->address_length > 0 &&
+	    addr->producer_consumer == ACPI_PRODUCER) {
+		return AE_OK;
+	}
+	return AE_ERROR;
+}
+
+static acpi_status
+count_resource(struct acpi_resource *acpi_res, void *data)
+{
+	struct pci_root_info *info = data;
+	struct acpi_resource_address64 addr;
+	acpi_status status;
+
+	status = resource_to_addr(acpi_res, &addr);
+	if (ACPI_SUCCESS(status))
+		info->res_num++;
+	return AE_OK;
+}
+
+static acpi_status
+setup_resource(struct acpi_resource *acpi_res, void *data)
+{
+	struct pci_root_info *info = data;
+	struct resource *res;
+	struct acpi_resource_address64 addr;
+	acpi_status status;
+	unsigned long flags;
+	struct resource *root;
+
+	status = resource_to_addr(acpi_res, &addr);
+	if (!ACPI_SUCCESS(status))
+		return AE_OK;
+
+	if (addr.resource_type == ACPI_MEMORY_RANGE) {
+		root = &iomem_resource;
+		flags = IORESOURCE_MEM;
+		if (addr.info.mem.caching == ACPI_PREFETCHABLE_MEMORY)
+			flags |= IORESOURCE_PREFETCH;
+	} else if (addr.resource_type == ACPI_IO_RANGE) {
+		root = &ioport_resource;
+		flags = IORESOURCE_IO;
+	} else
+		return AE_OK;
+
+	res = &info->res[info->res_num];
+	res->name = info->name;
+	res->flags = flags;
+	res->start = addr.minimum + addr.translation_offset;
+	res->end = res->start + addr.address_length - 1;
+	res->child = NULL;
+
+	if (insert_resource(root, res)) {
+		printk(KERN_ERR "PCI: Failed to allocate 0x%lx-0x%lx "
+			"from %s for %s\n", (unsigned long) res->start,
+			(unsigned long) res->end, root->name, info->name);
+	} else {
+		info->bus->resource[info->res_num] = res;
+		info->res_num++;
+	}
+	return AE_OK;
+}
+
+static void
+adjust_transparent_bridge_resources(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		int i;
+		u16 class = dev->class >> 8;
+
+		if (class == PCI_CLASS_BRIDGE_PCI && dev->transparent) {
+			for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
+				dev->subordinate->resource[i] =
+						dev->bus->resource[i - 3];
+		}
+	}
+}
+
+static void
+get_current_resources(struct acpi_device *device, int busnum,
+			struct pci_bus *bus)
+{
+	struct pci_root_info info;
+	size_t size;
+
+	info.bus = bus;
+	info.res_num = 0;
+	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,
+				&info);
+	if (!info.res_num)
+		return;
+
+	size = sizeof(*info.res) * info.res_num;
+	info.res = kmalloc(size, GFP_KERNEL);
+	if (!info.res)
+		goto res_alloc_fail;
+
+	info.name = kmalloc(12, GFP_KERNEL);
+	if (!info.name)
+		goto name_alloc_fail;
+	sprintf(info.name, "PCI Bus #%02x", busnum);
+
+	info.res_num = 0;
+	acpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,
+				&info);
+	if (info.res_num)
+		adjust_transparent_bridge_resources(bus);
+
+	return;
+
+name_alloc_fail:
+	kfree(info.res);
+res_alloc_fail:
+	return;
+}
+
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int domain, int busnum)
 {
 	struct pci_bus *bus;
@@ -89,6 +225,9 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 		}
 	}
 #endif
+
+	if (bus && (pci_probe & PCI_USE__CRS))
+		get_current_resources(device, busnum, bus);
 	
 	return bus;
 }

commit 036fff4cf732c4d69f99a2915924935705744b00
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Wed Oct 3 15:56:14 2007 -0700

    PCI: skip ISA ioresource alignment on some systems
    
    Skip ISA ioresource alignment on some systems
    
    To conserve limited PCI i/o resource on some IBM multi-node systems, the
    BIOS allocates (via _CRS) and expects the kernel to use addresses in
    ranges currently excluded by pcibios_align_resource() [i386/pci/i386.c].
    This change allows the kernel to use the currently excluded address
    ranges on the IBM x3800, x3850, and x3950.
    
    Signed-off-by: Gary Hade <gary.hade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index bc8a44bddaa7..1dd6f3fc077d 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -2,15 +2,57 @@
 #include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/dmi.h>
 #include <asm/numa.h>
 #include "pci.h"
 
+static int __devinit can_skip_ioresource_align(struct dmi_system_id *d)
+{
+	pci_probe |= PCI_CAN_SKIP_ISA_ALIGN;
+	printk(KERN_INFO "PCI: %s detected, can skip ISA alignment\n", d->ident);
+	return 0;
+}
+
+static struct dmi_system_id acpi_pciprobe_dmi_table[] = {
+/*
+ * Systems where PCI IO resource ISA alignment can be skipped
+ * when the ISA enable bit in the bridge control is not set
+ */
+	{
+		.callback = can_skip_ioresource_align,
+		.ident = "IBM System x3800",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "x3800"),
+		},
+	},
+	{
+		.callback = can_skip_ioresource_align,
+		.ident = "IBM System x3850",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "x3850"),
+		},
+	},
+	{
+		.callback = can_skip_ioresource_align,
+		.ident = "IBM System x3950",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "x3950"),
+		},
+	},
+	{}
+};
+
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int domain, int busnum)
 {
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
 	int pxm;
 
+	dmi_check_system(acpi_pciprobe_dmi_table);
+
 	/* Allocate per-root-bus (not per bus) arch-specific data.
 	 * TODO: leak; this memory is never freed.
 	 * It's arguable whether it's worth the trouble to care.

commit fb9aa6f1d4a1e11e66a680460b2c2b2b10b62f79
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 11 11:16:36 2007 +0200

    i386: move pci
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
new file mode 100644
index 000000000000..bc8a44bddaa7
--- /dev/null
+++ b/arch/x86/pci/acpi.c
@@ -0,0 +1,90 @@
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/numa.h>
+#include "pci.h"
+
+struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int domain, int busnum)
+{
+	struct pci_bus *bus;
+	struct pci_sysdata *sd;
+	int pxm;
+
+	/* Allocate per-root-bus (not per bus) arch-specific data.
+	 * TODO: leak; this memory is never freed.
+	 * It's arguable whether it's worth the trouble to care.
+	 */
+	sd = kzalloc(sizeof(*sd), GFP_KERNEL);
+	if (!sd) {
+		printk(KERN_ERR "PCI: OOM, not probing PCI bus %02x\n", busnum);
+		return NULL;
+	}
+
+	if (domain != 0) {
+		printk(KERN_WARNING "PCI: Multiple domains not supported\n");
+		kfree(sd);
+		return NULL;
+	}
+
+	sd->node = -1;
+
+	pxm = acpi_get_pxm(device->handle);
+#ifdef CONFIG_ACPI_NUMA
+	if (pxm >= 0)
+		sd->node = pxm_to_node(pxm);
+#endif
+
+	bus = pci_scan_bus_parented(NULL, busnum, &pci_root_ops, sd);
+	if (!bus)
+		kfree(sd);
+
+#ifdef CONFIG_ACPI_NUMA
+	if (bus != NULL) {
+		if (pxm >= 0) {
+			printk("bus %d -> pxm %d -> node %d\n",
+				busnum, pxm, sd->node);
+		}
+	}
+#endif
+	
+	return bus;
+}
+
+extern int pci_routeirq;
+static int __init pci_acpi_init(void)
+{
+	struct pci_dev *dev = NULL;
+
+	if (pcibios_scanned)
+		return 0;
+
+	if (acpi_noirq)
+		return 0;
+
+	printk(KERN_INFO "PCI: Using ACPI for IRQ routing\n");
+	acpi_irq_penalty_init();
+	pcibios_scanned++;
+	pcibios_enable_irq = acpi_pci_irq_enable;
+	pcibios_disable_irq = acpi_pci_irq_disable;
+
+	if (pci_routeirq) {
+		/*
+		 * PCI IRQ routing is set up by pci_enable_device(), but we
+		 * also do it here in case there are still broken drivers that
+		 * don't use pci_enable_device().
+		 */
+		printk(KERN_INFO "PCI: Routing PCI interrupts for all devices because \"pci=routeirq\" specified\n");
+		for_each_pci_dev(dev)
+			acpi_pci_irq_enable(dev);
+	} else
+		printk(KERN_INFO "PCI: If a device doesn't work, try \"pci=routeirq\".  If it helps, post a report\n");
+
+#ifdef CONFIG_X86_IO_APIC
+	if (acpi_ioapic)
+		print_IO_APIC();
+#endif
+
+	return 0;
+}
+subsys_initcall(pci_acpi_init);
