commit 13cad9851ef1d004640991d45227dd35c08f45fc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:45 2020 +0200

    x86/entry: Convert reschedule interrupt to IDTENTRY_SYSVEC_SIMPLE
    
    The scheduler IPI does not need the full interrupt entry handling logic
    when the entry is from kernel mode. Use IDTENTRY_SYSVEC_SIMPLE and spare
    all the overhead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.835425642@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index fd5e7c8825e1..74c12437401e 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -28,9 +28,6 @@
 #include <asm/irq.h>
 #include <asm/sections.h>
 
-/* Interrupt handlers registered during init_IRQ */
-extern asmlinkage void reschedule_interrupt(void);
-
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct pci_dev;

commit 9c3b1f4975c46fc2932fd6d53e63c14f0ddf985f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:42 2020 +0200

    x86/entry: Convert KVM vectors to IDTENTRY_SYSVEC*
    
    Convert KVM specific system vectors to IDTENTRY_SYSVEC*:
    
    The two empty stub handlers which only increment the stats counter do no
    need to run on the interrupt stack. Use IDTENTRY_SYSVEC_SIMPLE for them.
    
    The wakeup handler does more work and runs on the interrupt stack.
    
    None of these handlers need to save and restore the irq_regs pointer.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.555715519@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 7281c7e3a0f6..fd5e7c8825e1 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -29,10 +29,6 @@
 #include <asm/sections.h>
 
 /* Interrupt handlers registered during init_IRQ */
-extern asmlinkage void kvm_posted_intr_ipi(void);
-extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
-extern asmlinkage void kvm_posted_intr_nested_ipi(void);
-
 extern asmlinkage void reschedule_interrupt(void);
 
 #ifdef	CONFIG_X86_LOCAL_APIC

commit 720909a7abd351535bfb485a0ecce03c2e4467e2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:41 2020 +0200

    x86/entry: Convert various system vectors
    
    Convert various system vectors to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.464812973@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 36a38695f27f..7281c7e3a0f6 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -32,15 +32,9 @@
 extern asmlinkage void kvm_posted_intr_ipi(void);
 extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
 extern asmlinkage void kvm_posted_intr_nested_ipi(void);
-extern asmlinkage void irq_work_interrupt(void);
-extern asmlinkage void uv_bau_message_intr1(void);
 
-extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);
 
-extern asmlinkage void threshold_interrupt(void);
-extern asmlinkage void deferred_error_interrupt(void);
-
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct pci_dev;

commit 582f9191231b994582ad5349a7b06b3255c926fb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:40 2020 +0200

    x86/entry: Convert SMP system vectors to IDTENTRY_SYSVEC
    
    Convert SMP system vectors to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.372234635@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1765993360e7..36a38695f27f 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -38,14 +38,9 @@ extern asmlinkage void uv_bau_message_intr1(void);
 extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);
 
-extern asmlinkage void irq_move_cleanup_interrupt(void);
-extern asmlinkage void reboot_interrupt(void);
 extern asmlinkage void threshold_interrupt(void);
 extern asmlinkage void deferred_error_interrupt(void);
 
-extern asmlinkage void call_function_interrupt(void);
-extern asmlinkage void call_function_single_interrupt(void);
-
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct pci_dev;

commit db0338eec5836eea3bd1b274212234d04bac2034
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:39 2020 +0200

    x86/entry: Convert APIC interrupts to IDTENTRY_SYSVEC
    
    Convert APIC interrupts to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.280728850@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 3213d36b92d3..1765993360e7 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -29,16 +29,12 @@
 #include <asm/sections.h>
 
 /* Interrupt handlers registered during init_IRQ */
-extern asmlinkage void apic_timer_interrupt(void);
-extern asmlinkage void x86_platform_ipi(void);
 extern asmlinkage void kvm_posted_intr_ipi(void);
 extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
 extern asmlinkage void kvm_posted_intr_nested_ipi(void);
-extern asmlinkage void error_interrupt(void);
 extern asmlinkage void irq_work_interrupt(void);
 extern asmlinkage void uv_bau_message_intr1(void);
 
-extern asmlinkage void spurious_apic_interrupt(void);
 extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);
 

commit fa5e5c409213265da8a188b4a5e4e641b1382eb4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:37 2020 +0200

    x86/entry: Use idtentry for interrupts
    
    Replace the extra interrupt handling code and reuse the existing idtentry
    machinery. This moves the irq stack switching on 64-bit from ASM to C code;
    32-bit already does the stack switching in C.
    
    This requires to remove HAVE_IRQ_EXIT_ON_IRQ_STACK as the stack switch is
    not longer in the low level entry code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.078690991@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 0ffe80792b2d..3213d36b92d3 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -38,7 +38,6 @@ extern asmlinkage void error_interrupt(void);
 extern asmlinkage void irq_work_interrupt(void);
 extern asmlinkage void uv_bau_message_intr1(void);
 
-extern asmlinkage void spurious_interrupt(void);
 extern asmlinkage void spurious_apic_interrupt(void);
 extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);

commit 633260fa143bbed05e65dc557a492667dfdc45bb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:34 2020 +0200

    x86/irq: Convey vector as argument and not in ptregs
    
    Device interrupts which go through do_IRQ() or the spurious interrupt
    handler have their separate entry code on 64 bit for no good reason.
    
    Both 32 and 64 bit transport the vector number through ORIG_[RE]AX in
    pt_regs. Further the vector number is forced to fit into an u8 and is
    complemented and offset by 0x80 so it's in the signed character
    range. Otherwise GAS would expand the pushq to a 5 byte instruction for any
    vector > 0x7F.
    
    Treat the vector number like an error code and hand it to the C function as
    argument. This allows to get rid of the extra entry code in a later step.
    
    Simplify the error code push magic by implementing the pushq imm8 via a
    '.byte 0x6a, vector' sequence so GAS is not able to screw it up. As the
    pushq imm8 is sign extending the resulting error code needs to be truncated
    to 8 bits in C code.
    
    Originally-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202118.796915981@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 4154bc5f6a4e..0ffe80792b2d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -39,6 +39,7 @@ extern asmlinkage void irq_work_interrupt(void);
 extern asmlinkage void uv_bau_message_intr1(void);
 
 extern asmlinkage void spurious_interrupt(void);
+extern asmlinkage void spurious_apic_interrupt(void);
 extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);
 

commit e30c44e2e59c98023997632815cbc5e273991c25
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Aug 19 21:34:47 2019 +0200

    x86/irq: Improve definition of VECTOR_SHUTDOWN et al
    
    These values are used with IS_ERR(), so it's more intuitive to define
    them like a standard PTR_ERR() of a negative errno.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/146835e8-c086-4e85-7ece-bcba6795e6db@gmail.com

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index cbd97e22d2f3..4154bc5f6a4e 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -153,8 +153,8 @@ extern char irq_entries_start[];
 extern char spurious_entries_start[];
 
 #define VECTOR_UNUSED		NULL
-#define VECTOR_SHUTDOWN		((void *)~0UL)
-#define VECTOR_RETRIGGERED	((void *)~1UL)
+#define VECTOR_SHUTDOWN		((void *)-1L)
+#define VECTOR_RETRIGGERED	((void *)-2L)
 
 typedef struct irq_desc* vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);

commit f8a8fe61fec8006575699559ead88b0b833d5cad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 28 13:11:54 2019 +0200

    x86/irq: Seperate unused system vectors from spurious entry again
    
    Quite some time ago the interrupt entry stubs for unused vectors in the
    system vector range got removed and directly mapped to the spurious
    interrupt vector entry point.
    
    Sounds reasonable, but it's subtly broken. The spurious interrupt vector
    entry point pushes vector number 0xFF on the stack which makes the whole
    logic in __smp_spurious_interrupt() pointless.
    
    As a consequence any spurious interrupt which comes from a vector != 0xFF
    is treated as a real spurious interrupt (vector 0xFF) and not
    acknowledged. That subsequently stalls all interrupt vectors of equal and
    lower priority, which brings the system to a grinding halt.
    
    This can happen because even on 64-bit the system vector space is not
    guaranteed to be fully populated. A full compile time handling of the
    unused vectors is not possible because quite some of them are conditonally
    populated at runtime.
    
    Bring the entry stubs back, which wastes 160 bytes if all stubs are unused,
    but gains the proper handling back. There is no point to selectively spare
    some of the stubs which are known at compile time as the required code in
    the IDT management would be way larger and convoluted.
    
    Do not route the spurious entries through common_interrupt and do_IRQ() as
    the original code did. Route it to smp_spurious_interrupt() which evaluates
    the vector number and acts accordingly now that the real vector numbers are
    handed in.
    
    Fixup the pr_warn so the actual spurious vector (0xff) is clearly
    distiguished from the other vectors and also note for the vectored case
    whether it was pending in the ISR or not.
    
     "Spurious APIC interrupt (vector 0xFF) on CPU#0, should never happen."
     "Spurious interrupt vector 0xed on CPU#1. Acked."
     "Spurious interrupt vector 0xee on CPU#1. Not pending!."
    
    Fixes: 2414e021ac8d ("x86: Avoid building unused IRQ entry stubs")
    Reported-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jan Beulich <jbeulich@suse.com>
    Link: https://lkml.kernel.org/r/20190628111440.550568228@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 626e1ac6516e..cbd97e22d2f3 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -150,6 +150,8 @@ extern char irq_entries_start[];
 #define trace_irq_entries_start irq_entries_start
 #endif
 
+extern char spurious_entries_start[];
+
 #define VECTOR_UNUSED		NULL
 #define VECTOR_SHUTDOWN		((void *)~0UL)
 #define VECTOR_RETRIGGERED	((void *)~1UL)

commit b7107a67f0d125459fe41f86e8079afd1a5e0b15
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 28 13:11:53 2019 +0200

    x86/irq: Handle spurious interrupt after shutdown gracefully
    
    Since the rework of the vector management, warnings about spurious
    interrupts have been reported. Robert provided some more information and
    did an initial analysis. The following situation leads to these warnings:
    
       CPU 0                  CPU 1               IO_APIC
    
                                                  interrupt is raised
                                                  sent to CPU1
                              Unable to handle
                              immediately
                              (interrupts off,
                               deep idle delay)
       mask()
       ...
       free()
         shutdown()
         synchronize_irq()
         clear_vector()
                              do_IRQ()
                                -> vector is clear
    
    Before the rework the vector entries of legacy interrupts were statically
    assigned and occupied precious vector space while most of them were
    unused. Due to that the above situation was handled silently because the
    vector was handled and the core handler of the assigned interrupt
    descriptor noticed that it is shut down and returned.
    
    While this has been usually observed with legacy interrupts, this situation
    is not limited to them. Any other interrupt source, e.g. MSI, can cause the
    same issue.
    
    After adding proper synchronization for level triggered interrupts, this
    can only happen for edge triggered interrupts where the IO-APIC obviously
    cannot provide information about interrupts in flight.
    
    While the spurious warning is actually harmless in this case it worries
    users and driver developers.
    
    Handle it gracefully by marking the vector entry as VECTOR_SHUTDOWN instead
    of VECTOR_UNUSED when the vector is freed up.
    
    If that above late handling happens the spurious detector will not complain
    and switch the entry to VECTOR_UNUSED. Any subsequent spurious interrupt on
    that line will trigger the spurious warning as before.
    
    Fixes: 464d12309e1b ("x86/vector: Switch IOAPIC to global reservation mode")
    Reported-by: Robert Hodaszi <Robert.Hodaszi@digi.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>-
    Tested-by: Robert Hodaszi <Robert.Hodaszi@digi.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/20190628111440.459647741@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 32e666e1231e..626e1ac6516e 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -151,7 +151,8 @@ extern char irq_entries_start[];
 #endif
 
 #define VECTOR_UNUSED		NULL
-#define VECTOR_RETRIGGERED	((void *)~0UL)
+#define VECTOR_SHUTDOWN		((void *)~0UL)
+#define VECTOR_RETRIGGERED	((void *)~1UL)
 
 typedef struct irq_desc* vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);

commit 151ad17fbe5e56afa59709f41980508672c777ce
Author: Andrew Banman <abanman@hpe.com>
Date:   Tue Mar 27 17:09:06 2018 -0500

    x86/platform/uv/BAU: Add APIC idt entry
    
    BAU uses the old alloc_initr_gate90 method to setup its interrupt. This
    fails silently as the BAU vector is in the range of APIC vectors that are
    registered to the spurious interrupt handler. As a consequence BAU
    broadcasts are not handled, and the broadcast source CPU hangs.
    
    Update BAU to use new idt structure.
    
    Fixes: dc20b2d52653 ("x86/idt: Move interrupt gate initialization to IDT code")
    Signed-off-by: Andrew Banman <abanman@hpe.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Mike Travis <mike.travis@hpe.com>
    Cc: Dimitri Sivanich <sivanich@hpe.com>
    Cc: Russ Anderson <rja@hpe.com>
    Cc: stable@vger.kernel.org
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Link: https://lkml.kernel.org/r/1522188546-196177-1-git-send-email-abanman@hpe.com

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 2851077b6051..32e666e1231e 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -36,6 +36,7 @@ extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
 extern asmlinkage void kvm_posted_intr_nested_ipi(void);
 extern asmlinkage void error_interrupt(void);
 extern asmlinkage void irq_work_interrupt(void);
+extern asmlinkage void uv_bau_message_intr1(void);
 
 extern asmlinkage void spurious_interrupt(void);
 extern asmlinkage void thermal_interrupt(void);

commit fd2fa6c18b729e19c51240453a521f76c766247e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 22 16:13:37 2017 -0600

    x86/PCI: Remove unused HyperTransport interrupt support
    
    There are no in-tree callers of ht_create_irq(), the driver interface for
    HyperTransport interrupts, left.  Remove the unused entry point and all the
    supporting code.
    
    See 8b955b0dddb3 ("[PATCH] Initial generic hypertransport interrupt
    support").
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-pci@vger.kernel.org
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Link: https://lkml.kernel.org/r/20171122221337.3877.23362.stgit@bhelgaas-glaptop.roam.corp.google.com

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b80e46733909..2851077b6051 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -99,14 +99,6 @@ struct irq_alloc_info {
 			void		*dmar_data;
 		};
 #endif
-#ifdef	CONFIG_HT_IRQ
-		struct {
-			int		ht_pos;
-			int		ht_idx;
-			struct pci_dev	*ht_dev;
-			void		*ht_update;
-		};
-#endif
 #ifdef	CONFIG_X86_UV
 		struct {
 			int		uv_limit;

commit 141d3b1daacd11bdbd6fa74c2b163093e10d17ee
Merge: c201c91799d6 e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:51:10 2017 +0100

    Merge branch 'linus' into x86/apic, to resolve conflicts
    
    Conflicts:
            arch/x86/include/asm/x2apic.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 6dfe366a8804..8ec99a55e6b9 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _ASM_X86_HW_IRQ_H
 #define _ASM_X86_HW_IRQ_H
 

commit ba224feac8bb367edd62da33552353d4bdc3fe3a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:45 2017 +0200

    x86/vector: Untangle internal state from irq_cfg
    
    The vector management state is not required to live in irq_cfg. irq_cfg is
    only relevant for the depending irq domains (IOAPIC, DMAR, MSI ...).
    
    The seperation of the vector management status allows to direct a shut down
    interrupt to a special shutdown vector w/o confusing the internal state of
    the vector management.
    
    Preparatory change for the rework of managed interrupts and the global
    vector reservation scheme.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213155.683712356@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 386368890376..661540a93072 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -124,8 +124,7 @@ struct irq_alloc_info {
 
 struct irq_cfg {
 	unsigned int		dest_apicid;
-	u8			vector;
-	u8			old_vector;
+	unsigned int		vector;
 };
 
 extern struct irq_cfg *irq_cfg(unsigned int irq);

commit 0fa115da408f645cca419a60a5af8f4426ad4188
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:38 2017 +0200

    x86/irq/vector: Initialize matrix allocator
    
    Initialize the matrix allocator and add the proper accounting points to the
    code.
    
    No functional change, just preparation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213155.108410660@linutronix.de

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 6dfe366a8804..386368890376 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -15,6 +15,8 @@
 
 #include <asm/irq_vectors.h>
 
+#define IRQ_MATRIX_BITS		NR_VECTORS
+
 #ifndef __ASSEMBLY__
 
 #include <linux/percpu.h>
@@ -130,7 +132,6 @@ extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 extern void lock_vector_lock(void);
 extern void unlock_vector_lock(void);
-extern void setup_vector_irq(int cpu);
 #ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
 extern void irq_complete_move(struct irq_cfg *cfg);

commit 4b9a8dca0e58b6fee229795f77e902a4dfd116fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:31 2017 +0200

    x86/idt: Remove the tracing IDT completely
    
    No more users of the tracing IDT. All exception tracepoints have been moved
    into the regular handlers. Get rid of the mess which shouldn't have been
    created in the first place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170828064957.378851687@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 4626f8790ce7..6dfe366a8804 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -46,26 +46,6 @@ extern asmlinkage void deferred_error_interrupt(void);
 extern asmlinkage void call_function_interrupt(void);
 extern asmlinkage void call_function_single_interrupt(void);
 
-#ifdef CONFIG_TRACING
-/* Interrupt handlers registered during init_IRQ */
-#define trace_reschedule_interrupt	reschedule_interrupt
-#define trace_call_function_interrupt	call_function_interrupt
-#define trace_call_function_single_interrupt	call_function_single_interrupt
-#define trace_thermal_interrupt	thermal_interrupt
-#define trace_threshold_interrupt	threshold_interrupt
-#define trace_deferred_error_interrupt	deferred_error_interrupt
-#define trace_irq_work_interrupt irq_work_interrupt
-#define trace_error_interrupt error_interrupt
-#define trace_spurious_interrupt spurious_interrupt
-#define trace_x86_platform_ipi	x86_platform_ipi
-#define trace_apic_timer_interrupt	apic_timer_interrupt
-#define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
-#define trace_reboot_interrupt  reboot_interrupt
-#define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
-#define trace_kvm_posted_intr_wakeup_ipi kvm_posted_intr_wakeup_ipi
-#define trace_kvm_posted_intr_nested_ipi kvm_posted_intr_nested_ipi
-#endif /* CONFIG_TRACING */
-
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct pci_dev;

commit 3cd788c1eec4b3659671aa13d335a15102ac4d06
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:30 2017 +0200

    x86/smp: Use static key for reschedule interrupt tracing
    
    It's worth to avoid the extra irq_enter()/irq_exit() pair in the case that
    the reschedule interrupt tracepoints are disabled.
    
    Use the static key which indicates that exception tracing is enabled. For
    now this key is global. It will be optimized in a later step.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170828064957.299808677@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 8fb6c228438f..4626f8790ce7 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,7 +48,7 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_reschedule_interrupt(void);
+#define trace_reschedule_interrupt	reschedule_interrupt
 #define trace_call_function_interrupt	call_function_interrupt
 #define trace_call_function_single_interrupt	call_function_single_interrupt
 #define trace_thermal_interrupt	thermal_interrupt

commit 85b77cdd8fbd163d65f340e3f6578c50031af960
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:29 2017 +0200

    x86/smp: Remove pointless duplicated interrupt code
    
    Two NOP5s are really a good tradeoff vs. the unholy IDT switching mess,
    which duplicates code all over the place. The rescheduling interrupt gets
    optimized in a later step.
    
    Make the ordering of function call and statistics increment the same as in
    other places. Calculate stats first, then do the function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170828064957.222101344@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 5f042ec1b4ee..8fb6c228438f 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -49,8 +49,8 @@ extern asmlinkage void call_function_single_interrupt(void);
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
 extern void trace_reschedule_interrupt(void);
-extern void trace_call_function_interrupt(void);
-extern void trace_call_function_single_interrupt(void);
+#define trace_call_function_interrupt	call_function_interrupt
+#define trace_call_function_single_interrupt	call_function_single_interrupt
 #define trace_thermal_interrupt	thermal_interrupt
 #define trace_threshold_interrupt	threshold_interrupt
 #define trace_deferred_error_interrupt	deferred_error_interrupt

commit 0f42ae283c9b3ebfa34cac6d86c335aa1ebe8ac1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:28 2017 +0200

    x86/mce: Remove duplicated tracing interrupt code
    
    Machine checks are not really high frequency events. The extra two NOP5s for
    the disabled tracepoints are noise vs. the heavy lifting which needs to be
    done in the MCE handler.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170828064957.144301907@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index fd7e7e67ff79..5f042ec1b4ee 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,12 +48,12 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_thermal_interrupt(void);
 extern void trace_reschedule_interrupt(void);
-extern void trace_threshold_interrupt(void);
-extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
+#define trace_thermal_interrupt	thermal_interrupt
+#define trace_threshold_interrupt	threshold_interrupt
+#define trace_deferred_error_interrupt	deferred_error_interrupt
 #define trace_irq_work_interrupt irq_work_interrupt
 #define trace_error_interrupt error_interrupt
 #define trace_spurious_interrupt spurious_interrupt

commit daabb8eb9a55af90d0a55d93547a51cc6921389f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:27 2017 +0200

    x86/irqwork: Get rid of duplicated tracing interrupt code
    
    Two NOP5s are a reasonable tradeoff to avoid duplicated code and the
    requirement to switch the IDT.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170828064957.064746737@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b094b877b294..fd7e7e67ff79 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,13 +48,13 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_irq_work_interrupt(void);
 extern void trace_thermal_interrupt(void);
 extern void trace_reschedule_interrupt(void);
 extern void trace_threshold_interrupt(void);
 extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
+#define trace_irq_work_interrupt irq_work_interrupt
 #define trace_error_interrupt error_interrupt
 #define trace_spurious_interrupt spurious_interrupt
 #define trace_x86_platform_ipi	x86_platform_ipi

commit 61069de7a3252be0b1f567fe9e0b4723f1d2814f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:26 2017 +0200

    x86/apic: Remove the duplicated tracing versions of interrupts
    
    The error and the spurious interrupt are really rare events and not at all
    performance sensitive: two NOP5s can be tolerated when tracing is disabled.
    
    Remove the complication.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170828064956.986009402@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index a7e45d1707b7..b094b877b294 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,15 +48,15 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_error_interrupt(void);
 extern void trace_irq_work_interrupt(void);
-extern void trace_spurious_interrupt(void);
 extern void trace_thermal_interrupt(void);
 extern void trace_reschedule_interrupt(void);
 extern void trace_threshold_interrupt(void);
 extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
+#define trace_error_interrupt error_interrupt
+#define trace_spurious_interrupt spurious_interrupt
 #define trace_x86_platform_ipi	x86_platform_ipi
 #define trace_apic_timer_interrupt	apic_timer_interrupt
 #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt

commit 8a17116b1fddc1f414cd4dd5e86fa239fcdb5208
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:25 2017 +0200

    x86/irq: Get rid of duplicated trace_x86_platform_ipi() code
    
    Two NOP5s are really a good tradeoff vs. the unholy IDT switching mess,
    which duplicates code all over the place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170828064956.907209383@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 44137bb12136..a7e45d1707b7 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,7 +48,6 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_x86_platform_ipi(void);
 extern void trace_error_interrupt(void);
 extern void trace_irq_work_interrupt(void);
 extern void trace_spurious_interrupt(void);
@@ -58,6 +57,7 @@ extern void trace_threshold_interrupt(void);
 extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
+#define trace_x86_platform_ipi	x86_platform_ipi
 #define trace_apic_timer_interrupt	apic_timer_interrupt
 #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
 #define trace_reboot_interrupt  reboot_interrupt

commit 302a98f896bbd2feb1393d98e8b9febeb101db6e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 28 08:47:23 2017 +0200

    x86/apic: Remove the duplicated tracing version of local_timer_interrupt()
    
    The two NOP5s are noise in the rest of the work which is done by the timer
    interrupt and modern CPUs are pretty good in optimizing NOPs anyway.
    
    Get rid of the interrupt handler duplication and move the tracepoints into
    the regular handler.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170828064956.751247330@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index d6dbafbd4207..44137bb12136 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -48,7 +48,6 @@ extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
-extern void trace_apic_timer_interrupt(void);
 extern void trace_x86_platform_ipi(void);
 extern void trace_error_interrupt(void);
 extern void trace_irq_work_interrupt(void);
@@ -59,6 +58,7 @@ extern void trace_threshold_interrupt(void);
 extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
+#define trace_apic_timer_interrupt	apic_timer_interrupt
 #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
 #define trace_reboot_interrupt  reboot_interrupt
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi

commit 210f84b0ca7743f3b2a9acfae81df668dbbb6a12
Author: Wincy Van <fanwenyi0529@gmail.com>
Date:   Fri Apr 28 13:13:58 2017 +0800

    x86: irq: Define a global vector for nested posted interrupts
    
    We are using the same vector for nested/non-nested posted
    interrupts delivery, this may cause interrupts latency in
    L1 since we can't kick the L2 vcpu out of vmx-nonroot mode.
    
    This patch introduces a new vector which is only for nested
    posted interrupts to solve the problems above.
    
    Signed-off-by: Wincy Van <fanwenyi0529@gmail.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b90e1053049b..d6dbafbd4207 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -30,6 +30,7 @@ extern asmlinkage void apic_timer_interrupt(void);
 extern asmlinkage void x86_platform_ipi(void);
 extern asmlinkage void kvm_posted_intr_ipi(void);
 extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
+extern asmlinkage void kvm_posted_intr_nested_ipi(void);
 extern asmlinkage void error_interrupt(void);
 extern asmlinkage void irq_work_interrupt(void);
 
@@ -62,6 +63,7 @@ extern void trace_call_function_single_interrupt(void);
 #define trace_reboot_interrupt  reboot_interrupt
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
 #define trace_kvm_posted_intr_wakeup_ipi kvm_posted_intr_wakeup_ipi
+#define trace_kvm_posted_intr_nested_ipi kvm_posted_intr_nested_ipi
 #endif /* CONFIG_TRACING */
 
 #ifdef	CONFIG_X86_LOCAL_APIC

commit 551adc60573cb68e3d55cacca9ba1b7437313df7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 14 09:40:46 2016 +0100

    x86/irq: Cure live lock in fixup_irqs()
    
    Harry reported, that he's able to trigger a system freeze with cpu hot
    unplug. The freeze turned out to be a live lock caused by recent changes in
    irq_force_complete_move().
    
    When fixup_irqs() and from there irq_force_complete_move() is called on the
    dying cpu, then all other cpus are in stop machine an wait for the dying cpu
    to complete the teardown. If there is a move of an interrupt pending then
    irq_force_complete_move() sends the cleanup IPI to the cpus in the old_domain
    mask and waits for them to clear the mask. That's obviously impossible as
    those cpus are firmly stuck in stop machine with interrupts disabled.
    
    I should have known that, but I completely overlooked it being concentrated on
    the locking issues around the vectors. And the existance of the call to
    __irq_complete_move() in the code, which actually sends the cleanup IPI made
    it reasonable to wait for that cleanup to complete. That call was bogus even
    before the recent changes as it was just a pointless distraction.
    
    We have to look at two cases:
    
    1) The move_in_progress flag of the interrupt is set
    
       This means the ioapic has been updated with the new vector, but it has not
       fired yet. In theory there is a race:
    
       set_ioapic(new_vector) <-- Interrupt is raised before update is effective,
                                  i.e. it's raised on the old vector.
    
       So if the target cpu cannot handle that interrupt before the old vector is
       cleaned up, we get a spurious interrupt and in the worst case the ioapic
       irq line becomes stale, but my experiments so far have only resulted in
       spurious interrupts.
    
       But in case of cpu hotplug this should be a non issue because if the
       affinity update happens right before all cpus rendevouz in stop machine,
       there is no way that the interrupt can be blocked on the target cpu because
       all cpus loops first with interrupts enabled in stop machine, so the old
       vector is not yet cleaned up when the interrupt fires.
    
       So the only way to run into this issue is if the delivery of the interrupt
       on the apic/system bus would be delayed beyond the point where the target
       cpu disables interrupts in stop machine. I doubt that it can happen, but at
       least there is a theroretical chance. Virtualization might be able to
       expose this, but AFAICT the IOAPIC emulation is not as stupid as the real
       hardware.
    
       I've spent quite some time over the weekend to enforce that situation,
       though I was not able to trigger the delayed case.
    
    2) The move_in_progress flag is not set and the old_domain cpu mask is not
       empty.
    
       That means, that an interrupt was delivered after the change and the
       cleanup IPI has been sent to the cpus in old_domain, but not all CPUs have
       responded to it yet.
    
    In both cases we can assume that the next interrupt will arrive on the new
    vector, so we can cleanup the old vectors on the cpus in the old_domain cpu
    mask.
    
    Fixes: 98229aa36caa "x86/irq: Plug vector cleanup race"
    Reported-by: Harry Junior <harryjr@outlook.fr>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Joe Lawrence <joe.lawrence@stratus.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1603140931430.3657@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index f564d2b2275f..b90e1053049b 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -141,6 +141,7 @@ struct irq_alloc_info {
 struct irq_cfg {
 	unsigned int		dest_apicid;
 	u8			vector;
+	u8			old_vector;
 };
 
 extern struct irq_cfg *irq_cfg(unsigned int irq);

commit d89abe2a1f0c92499eedc815e4a9b2881f4959a5
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Feb 9 02:43:02 2016 +0100

    arch/x86/irq: Purge useless handler declarations from hw_irq.h
    
    arch/x86/include/asm/hw_irq.h contains declarations for the C-level handlers
    called into directly from the IDT-referenced assembly stubs. These
    declarations are never used as they are referenced from assembly only.
    
    Furthermore, these declarations got their attributes wrong: there is no
    '__irqentry' (parameter passing via stack) attached to them.
    
    Also, the list of declarations isn't complete: none of the tracing-capable
    variants is declared, for example.
    
    Purge the handler declarations.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1815b736269d..f564d2b2275f 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -168,20 +168,6 @@ extern atomic_t irq_mis_count;
 
 extern void elcr_set_level_irq(unsigned int irq);
 
-/* SMP */
-extern __visible void smp_apic_timer_interrupt(struct pt_regs *);
-extern __visible void smp_spurious_interrupt(struct pt_regs *);
-extern __visible void smp_x86_platform_ipi(struct pt_regs *);
-extern __visible void smp_error_interrupt(struct pt_regs *);
-#ifdef CONFIG_X86_IO_APIC
-extern asmlinkage void smp_irq_move_cleanup_interrupt(void);
-#endif
-#ifdef CONFIG_SMP
-extern __visible void smp_reschedule_interrupt(struct pt_regs *);
-extern __visible void smp_call_function_interrupt(struct pt_regs *);
-extern __visible void smp_call_function_single_interrupt(struct pt_regs *);
-#endif
-
 extern char irq_entries_start[];
 #ifdef CONFIG_TRACING
 #define trace_irq_entries_start irq_entries_start

commit 185a383ada2e7794b0e82e040223e741b24d2bf8
Author: Keith Busch <keith.busch@intel.com>
Date:   Tue Jan 12 13:18:10 2016 -0700

    x86/PCI: Add driver for Intel Volume Management Device (VMD)
    
    The Intel Volume Management Device (VMD) is a Root Complex Integrated
    Endpoint that acts as a host bridge to a secondary PCIe domain.  BIOS can
    reassign one or more Root Ports to appear within a VMD domain instead of
    the primary domain.  The immediate benefit is that additional PCIe domains
    allow more than 256 buses in a system by letting bus numbers be reused
    across different domains.
    
    VMD domains do not define ACPI _SEG, so to avoid domain clashing with host
    bridges defining this segment, VMD domains start at 0x10000, which is
    greater than the highest possible 16-bit ACPI defined _SEG.
    
    This driver enumerates and enables the domain using the root bus
    configuration interface provided by the PCI subsystem.  The driver provides
    configuration space accessor functions (pci_ops), bus and memory resources,
    an MSI IRQ domain with irq_chip implementation, and DMA operations
    necessary to use devices through the VMD endpoint's interface.
    
    VMD routes I/O as follows:
    
       1) Configuration Space: BAR 0 ("CFGBAR") of VMD provides the base
       address and size for configuration space register access to VMD-owned
       root ports.  It works similarly to MMCONFIG for extended configuration
       space.  Bus numbering is independent and does not conflict with the
       primary domain.
    
       2) MMIO Space: BARs 2 and 4 ("MEMBAR1" and "MEMBAR2") of VMD provide the
       base address, size, and type for MMIO register access.  These addresses
       are not translated by VMD hardware; they are simply reservations to be
       distributed to root ports' memory base/limit registers and subdivided
       among devices downstream.
    
       3) DMA: To interact appropriately with an IOMMU, the source ID DMA read
       and write requests are translated to the bus-device-function of the VMD
       endpoint.  Otherwise, DMA operates normally without VMD-specific address
       translation.
    
       4) Interrupts: Part of VMD's BAR 4 is reserved for VMD's MSI-X Table and
       PBA.  MSIs from VMD domain devices and ports are remapped to appear as
       if they were issued using one of VMD's MSI-X table entries.  Each MSI
       and MSI-X address of VMD-owned devices and ports has a special format
       where the address refers to specific entries in the VMD's MSI-X table.
       As with DMA, the interrupt source ID is translated to VMD's
       bus-device-function.
    
       The driver provides its own MSI and MSI-X configuration functions
       specific to how MSI messages are used within the VMD domain, and
       provides an irq_chip for independent IRQ allocation to relay interrupts
       from VMD's interrupt handler to the appropriate device driver's handler.
    
       5) Errors: PCIe error message are intercepted by the root ports normally
       (e.g., AER), except with VMD, system errors (i.e., firmware first) are
       disabled by default.  AER and hotplug interrupts are translated in the
       same way as endpoint interrupts.
    
       6) VMD does not support INTx interrupts or IO ports.  Devices or drivers
       requiring these features should either not be placed below VMD-owned
       root ports, or VMD should be disabled by BIOS for such endpoints.
    
    [bhelgaas: add VMD BAR #defines, factor out vmd_cfg_addr(), rework VMD
    resource setup, whitespace, changelog]
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de> (IRQ-related parts)

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1e3408e88604..1815b736269d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -129,6 +129,11 @@ struct irq_alloc_info {
 			unsigned long	uv_offset;
 			char		*uv_name;
 		};
+#endif
+#if IS_ENABLED(CONFIG_VMD)
+		struct {
+			struct msi_desc *desc;
+		};
 #endif
 	};
 };

commit a782a7e46bb50822fabfeb7271605762a59c86df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 2 20:38:27 2015 +0000

    x86/irq: Store irq descriptor in vector array
    
    We can spare the irq_desc lookup in the interrupt entry code if we
    store the descriptor pointer in the vector array instead the interrupt
    number.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/20150802203609.717724106@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 62bb8d23b826..1e3408e88604 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -182,10 +182,10 @@ extern char irq_entries_start[];
 #define trace_irq_entries_start irq_entries_start
 #endif
 
-#define VECTOR_UNUSED		(-1)
-#define VECTOR_RETRIGGERED	(-2)
+#define VECTOR_UNUSED		NULL
+#define VECTOR_RETRIGGERED	((void *)~0UL)
 
-typedef int vector_irq_t[NR_VECTORS];
+typedef struct irq_desc* vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);
 
 #endif /* !ASSEMBLY_ */

commit 7276c6a2cb5f7ae46fd0c9539af02dbcb7c4f3f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 2 20:38:25 2015 +0000

    x86/irq: Rename VECTOR_UNDEFINED to VECTOR_UNUSED
    
    VECTOR_UNDEFINED is a misnomer. The vector is defined, but unused.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/20150802203609.477282494@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 6615032e19c8..62bb8d23b826 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -182,7 +182,7 @@ extern char irq_entries_start[];
 #define trace_irq_entries_start irq_entries_start
 #endif
 
-#define VECTOR_UNDEFINED	(-1)
+#define VECTOR_UNUSED		(-1)
 #define VECTOR_RETRIGGERED	(-2)
 
 typedef int vector_irq_t[NR_VECTORS];

commit c2f9b0af8bb4b2a5c020ae88efc9a624f59a7080
Merge: c8e56d20f2d1 243d657eaf54
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jun 7 15:35:27 2015 +0200

    Merge branch 'x86/ras' into x86/core, to fix conflicts
    
    Conflicts:
            arch/x86/include/asm/irq_vectors.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f6b3c72c23661e5534cd2eede16e9bac7ebb761c
Author: Feng Wu <feng.wu@intel.com>
Date:   Tue May 19 17:07:16 2015 +0800

    x86/irq: Define a global vector for VT-d Posted-Interrupts
    
    Currently, we use a global vector as the Posted-Interrupts
    Notification Event for all the vCPUs in the system. We need
    to introduce another global vector for VT-d Posted-Interrtups,
    which will be used to wakeup the sleep vCPU when an external
    interrupt from a direct-assigned device happens for that vCPU.
    
    [ tglx: Removed a gazillion of extra newlines ]
    
    Signed-off-by: Feng Wu <feng.wu@intel.com>
    Cc: jiang.liu@linux.intel.com
    Link: http://lkml.kernel.org/r/1432026437-16560-4-git-send-email-feng.wu@intel.com
    Suggested-by: Yang Zhang <yang.z.zhang@intel.com>
    Acked-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 9ec5d37d8da3..10c80d4f8386 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -29,6 +29,7 @@
 extern asmlinkage void apic_timer_interrupt(void);
 extern asmlinkage void x86_platform_ipi(void);
 extern asmlinkage void kvm_posted_intr_ipi(void);
+extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
 extern asmlinkage void error_interrupt(void);
 extern asmlinkage void irq_work_interrupt(void);
 
@@ -58,6 +59,7 @@ extern void trace_call_function_single_interrupt(void);
 #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
 #define trace_reboot_interrupt  reboot_interrupt
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
+#define trace_kvm_posted_intr_wakeup_ipi kvm_posted_intr_wakeup_ipi
 #endif /* CONFIG_TRACING */
 
 #ifdef	CONFIG_X86_LOCAL_APIC

commit ea6cd25058f39ac69623efdcbd94a7fc7d4d13f0
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat May 9 20:27:37 2015 -0400

    x86: Rename eisa_set_level_irq to elcr_set_level_irq
    
    This routine has been around for over a decade, but with EISA
    being dead and abandoned for about twice that long, the name can
    be kind of confusing.  The function is going at the PIC Edge/Level
    Configuration Registers (ELCR), so rename it as such and mentally
    decouple it from the long since dead EISA bus.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Reviewed-by: Maciej W. Rozycki <macro@linux-mips.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: x86@kernel.org
    Link: http://lkml.kernel.org/r/1431217657-934-1-git-send-email-paul.gortmaker@windriver.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 9472c9aff26d..9ec5d37d8da3 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -157,8 +157,7 @@ static inline void unlock_vector_lock(void) {}
 extern atomic_t irq_err_count;
 extern atomic_t irq_mis_count;
 
-/* EISA */
-extern void eisa_set_level_irq(unsigned int irq);
+extern void elcr_set_level_irq(unsigned int irq);
 
 /* SMP */
 extern __visible void smp_apic_timer_interrupt(struct pt_regs *);

commit 191a66353b22fad8ac89404ab4c929cbe7b0afb2
Merge: f5d6a52f5111 f21262b8e092
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 11 16:05:09 2015 +0200

    Merge branch 'x86/asm' into x86/apic, to resolve a conflict
    
    Conflicts:
            arch/x86/kernel/apic/io_apic.c
            arch/x86/kernel/apic/vector.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c6e692f95dacddff5f3607717fb2246c60bbb714
Author: Brian Gerst <brgerst@gmail.com>
Date:   Sat May 9 11:36:51 2015 -0400

    x86/asm/entry/irq: Remove unused invalidate_interrupt prototypes
    
    The invalidate_interrupt* functions no longer exist.
    
    Signed-off-by: Brian Gerst <brgerst@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1431185813-15413-3-git-send-email-brgerst@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e9571ddabc4f..014c6382ffce 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -36,40 +36,6 @@ extern asmlinkage void spurious_interrupt(void);
 extern asmlinkage void thermal_interrupt(void);
 extern asmlinkage void reschedule_interrupt(void);
 
-extern asmlinkage void invalidate_interrupt(void);
-extern asmlinkage void invalidate_interrupt0(void);
-extern asmlinkage void invalidate_interrupt1(void);
-extern asmlinkage void invalidate_interrupt2(void);
-extern asmlinkage void invalidate_interrupt3(void);
-extern asmlinkage void invalidate_interrupt4(void);
-extern asmlinkage void invalidate_interrupt5(void);
-extern asmlinkage void invalidate_interrupt6(void);
-extern asmlinkage void invalidate_interrupt7(void);
-extern asmlinkage void invalidate_interrupt8(void);
-extern asmlinkage void invalidate_interrupt9(void);
-extern asmlinkage void invalidate_interrupt10(void);
-extern asmlinkage void invalidate_interrupt11(void);
-extern asmlinkage void invalidate_interrupt12(void);
-extern asmlinkage void invalidate_interrupt13(void);
-extern asmlinkage void invalidate_interrupt14(void);
-extern asmlinkage void invalidate_interrupt15(void);
-extern asmlinkage void invalidate_interrupt16(void);
-extern asmlinkage void invalidate_interrupt17(void);
-extern asmlinkage void invalidate_interrupt18(void);
-extern asmlinkage void invalidate_interrupt19(void);
-extern asmlinkage void invalidate_interrupt20(void);
-extern asmlinkage void invalidate_interrupt21(void);
-extern asmlinkage void invalidate_interrupt22(void);
-extern asmlinkage void invalidate_interrupt23(void);
-extern asmlinkage void invalidate_interrupt24(void);
-extern asmlinkage void invalidate_interrupt25(void);
-extern asmlinkage void invalidate_interrupt26(void);
-extern asmlinkage void invalidate_interrupt27(void);
-extern asmlinkage void invalidate_interrupt28(void);
-extern asmlinkage void invalidate_interrupt29(void);
-extern asmlinkage void invalidate_interrupt30(void);
-extern asmlinkage void invalidate_interrupt31(void);
-
 extern asmlinkage void irq_move_cleanup_interrupt(void);
 extern asmlinkage void reboot_interrupt(void);
 extern asmlinkage void threshold_interrupt(void);
@@ -178,7 +144,6 @@ extern asmlinkage void smp_irq_move_cleanup_interrupt(void);
 extern __visible void smp_reschedule_interrupt(struct pt_regs *);
 extern __visible void smp_call_function_interrupt(struct pt_regs *);
 extern __visible void smp_call_function_single_interrupt(struct pt_regs *);
-extern __visible void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
 extern char irq_entries_start[];

commit 24fd78a81f6d3fe7f7a440c8629f9c52cd5f830e
Author: Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
Date:   Wed May 6 06:58:56 2015 -0500

    x86/mce/amd: Introduce deferred error interrupt handler
    
    Deferred errors indicate error conditions that were not corrected, but
    require no action from S/W (or action is optional).These errors provide
    info about a latent UC MCE that can occur when a poisoned data is
    consumed by the processor.
    
    Processors that report these errors can be configured to generate APIC
    interrupts to notify OS about the error.
    
    Provide an interrupt handler in this patch so that OS can catch these
    errors as and when they happen. Currently, we simply log the errors and
    exit the handler as S/W action is not mandated.
    
    Signed-off-by: Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: x86-ml <x86@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1430913538-1415-5-git-send-email-Aravind.Gopalakrishnan@amd.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e9571ddabc4f..f71e489d7537 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -73,6 +73,7 @@ extern asmlinkage void invalidate_interrupt31(void);
 extern asmlinkage void irq_move_cleanup_interrupt(void);
 extern asmlinkage void reboot_interrupt(void);
 extern asmlinkage void threshold_interrupt(void);
+extern asmlinkage void deferred_error_interrupt(void);
 
 extern asmlinkage void call_function_interrupt(void);
 extern asmlinkage void call_function_single_interrupt(void);
@@ -87,6 +88,7 @@ extern void trace_spurious_interrupt(void);
 extern void trace_thermal_interrupt(void);
 extern void trace_reschedule_interrupt(void);
 extern void trace_threshold_interrupt(void);
+extern void trace_deferred_error_interrupt(void);
 extern void trace_call_function_interrupt(void);
 extern void trace_call_function_single_interrupt(void);
 #define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt

commit d746d1ebd30c48562a3fb512ab18d5822f137820
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:30:09 2015 +0800

    x86/irq: Move irqdomain specific code into asm/irqdomain.h
    
    Now we have dedicated asm/irqdomain.h, so move irqdomain specific
    code into it.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Link: http://lkml.kernel.org/r/1428978610-28986-33-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 3b8233a26348..1f88e719fa78 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -94,8 +94,6 @@ extern void trace_call_function_single_interrupt(void);
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
 #endif /* CONFIG_TRACING */
 
-struct irq_domain;
-
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct pci_dev;
@@ -165,22 +163,11 @@ struct irq_alloc_info {
 	};
 };
 
-enum {
-	/* Allocate contiguous CPU vectors */
-	X86_IRQ_ALLOC_CONTIGUOUS_VECTORS		= 0x1,
-};
-
 struct irq_cfg {
 	unsigned int		dest_apicid;
 	u8			vector;
 };
 
-extern struct irq_domain *x86_vector_domain;
-
-extern void init_irq_alloc_info(struct irq_alloc_info *info,
-				const struct cpumask *mask);
-extern void copy_irq_alloc_info(struct irq_alloc_info *dst,
-				struct irq_alloc_info *src);
 extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 extern void lock_vector_lock(void);
@@ -200,17 +187,6 @@ static inline void lock_vector_lock(void) {}
 static inline void unlock_vector_lock(void) {}
 #endif	/* CONFIG_X86_LOCAL_APIC */
 
-#ifdef	CONFIG_PCI_MSI
-extern void arch_init_msi_domain(struct irq_domain *domain);
-#else
-static inline void arch_init_msi_domain(struct irq_domain *domain) { }
-#endif
-#ifdef	CONFIG_HT_IRQ
-extern void arch_init_htirq_domain(struct irq_domain *domain);
-#else
-static inline void arch_init_htirq_domain(struct irq_domain *domain) { }
-#endif
-
 /* Statistics */
 extern atomic_t irq_err_count;
 extern atomic_t irq_mis_count;

commit 7f3262edcdf623296b514377d52911b115c7ab49
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:30:03 2015 +0800

    x86/irq: Move private data in struct irq_cfg into dedicated data structure
    
    Several fields in struct irq_cfg are private to vector.c, so move it
    into dedicated data structure. This helps to hide implementation
    details.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428978610-28986-27-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1416901802-24211-35-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Joerg Roedel <jroedel@suse.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 727c62378a65..3b8233a26348 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -171,11 +171,8 @@ enum {
 };
 
 struct irq_cfg {
-	cpumask_var_t		domain;
-	cpumask_var_t		old_domain;
 	unsigned int		dest_apicid;
 	u8			vector;
-	u8			move_in_progress : 1;
 };
 
 extern struct irq_domain *x86_vector_domain;

commit 68f9f4404d74f859dc84973db8731b41a51d929a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:30:01 2015 +0800

    x86/irq: Remove function apic_set_affinity()
    
    Now there's no user of apic_set_affinity(), so remove it.  Also rename
    vector_set_affinity() to apic_set_affinity() for consistency.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428978610-28986-25-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 9a797682fef5..727c62378a65 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -198,8 +198,6 @@ static inline void irq_complete_move(struct irq_cfg *c) { }
 #endif
 
 extern void apic_ack_edge(struct irq_data *data);
-extern int apic_set_affinity(struct irq_data *data, const struct cpumask *mask,
-			     unsigned int *dest_id);
 #else	/*  CONFIG_X86_LOCAL_APIC */
 static inline void lock_vector_lock(void) {}
 static inline void unlock_vector_lock(void) {}

commit f970510cc55e41d21ca30feb56873aaeb57ec18d
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:30:00 2015 +0800

    x86/irq: Make functions only used in vector.c static
    
    Function {assign|clear}_irq_vector() and apic_retrigger_irq() are only
    used in vector.c, so make them static.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428978610-28986-24-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index bb2c990b97ef..9a797682fef5 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -188,8 +188,6 @@ extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 extern void lock_vector_lock(void);
 extern void unlock_vector_lock(void);
-extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
-extern void clear_irq_vector(int irq, struct irq_cfg *cfg);
 extern void setup_vector_irq(int cpu);
 #ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
@@ -199,7 +197,6 @@ static inline void send_cleanup_vector(struct irq_cfg *c) { }
 static inline void irq_complete_move(struct irq_cfg *c) { }
 #endif
 
-extern int apic_retrigger_irq(struct irq_data *data);
 extern void apic_ack_edge(struct irq_data *data);
 extern int apic_set_affinity(struct irq_data *data, const struct cpumask *mask,
 			     unsigned int *dest_id);

commit a2cbbb47fd90ef1161ce22b099de5c6095f8365f
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:29:59 2015 +0800

    x86/irq: Remove unused alloc_irq_and_cfg_at()
    
    There's no caller of alloc_irq_and_cfg_at() anymore, so remove it.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428978610-28986-23-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index f000b58cbc0c..bb2c990b97ef 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -186,7 +186,6 @@ extern void copy_irq_alloc_info(struct irq_alloc_info *dst,
 				struct irq_alloc_info *src);
 extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
-extern struct irq_cfg *alloc_irq_and_cfg_at(unsigned int at, int node);
 extern void lock_vector_lock(void);
 extern void unlock_vector_lock(void);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);

commit 4467715a44cca2fa41d25f3d32b737bd2331a8d9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:29:53 2015 +0800

    x86/irq: Move irq_cfg.irq_2_pin into io_apic.c
    
    Now only io_apic.c accesses struct irq_cfg.irq_2_pin, so move irq_2_pin
    into struct mp_chip_data in io_apic.c to clean up struct irq_cfg further.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1428978610-28986-17-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e47bc4de5630..f000b58cbc0c 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -176,13 +176,6 @@ struct irq_cfg {
 	unsigned int		dest_apicid;
 	u8			vector;
 	u8			move_in_progress : 1;
-	union {
-#ifdef CONFIG_X86_IO_APIC
-		struct {
-			struct list_head	irq_2_pin;
-		};
-#endif
-	};
 };
 
 extern struct irq_domain *x86_vector_domain;

commit 9c72496698a4dadd406d159f7735851a63ef9412
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:29:52 2015 +0800

    irq_remapping/amd: Move struct irq_2_irte into amd_iommu.c
    
    Now only amd_iommu.c access irq_2_irte, so move it from hw_irq.h into
    amd_iommu.c.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428978610-28986-16-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1e0ee1029ef6..e47bc4de5630 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -94,14 +94,6 @@ extern void trace_call_function_single_interrupt(void);
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
 #endif /* CONFIG_TRACING */
 
-#ifdef CONFIG_IRQ_REMAP
-/* AMD specific interrupt remapping information */
-struct irq_2_irte {
-	u16 devid; /* Device ID for IRTE table */
-	u16 index; /* Index into IRTE table*/
-};
-#endif	/* CONFIG_IRQ_REMAP */
-
 struct irq_domain;
 
 #ifdef	CONFIG_X86_LOCAL_APIC
@@ -184,11 +176,6 @@ struct irq_cfg {
 	unsigned int		dest_apicid;
 	u8			vector;
 	u8			move_in_progress : 1;
-#ifdef CONFIG_IRQ_REMAP
-	union {
-		struct irq_2_irte  irq_2_irte;
-	};
-#endif
 	union {
 #ifdef CONFIG_X86_IO_APIC
 		struct {

commit 099c5c03487f6bca30c628e14e666788dd61fb33
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:29:51 2015 +0800

    irq_remapping/vt-d: Move struct irq_2_iommu into intel_irq_remapping.c
    
    Now only intel_irq_remapping.c access irq_2_iommu, so move it from
    hw_irq.h into intel_irq_remapping.c.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428978610-28986-15-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 86e4698a0025..1e0ee1029ef6 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -95,14 +95,6 @@ extern void trace_call_function_single_interrupt(void);
 #endif /* CONFIG_TRACING */
 
 #ifdef CONFIG_IRQ_REMAP
-/* Intel specific interrupt remapping information */
-struct irq_2_iommu {
-	struct intel_iommu *iommu;
-	u16 irte_index;
-	u16 sub_handle;
-	u8  irte_mask;
-};
-
 /* AMD specific interrupt remapping information */
 struct irq_2_irte {
 	u16 devid; /* Device ID for IRTE table */
@@ -194,7 +186,6 @@ struct irq_cfg {
 	u8			move_in_progress : 1;
 #ifdef CONFIG_IRQ_REMAP
 	union {
-		struct irq_2_iommu irq_2_iommu;
 		struct irq_2_irte  irq_2_irte;
 	};
 #endif

commit bac4f90784efb858cfafdd7401dede6ef9563818
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Apr 14 10:29:50 2015 +0800

    x86/irq: Remove irq_cfg.irq_remapped
    
    Now there is no user of irq_cfg.irq_remapped, so remove it.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428978610-28986-14-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 75d0db1db8a0..86e4698a0025 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -193,7 +193,6 @@ struct irq_cfg {
 	u8			vector;
 	u8			move_in_progress : 1;
 #ifdef CONFIG_IRQ_REMAP
-	u8			remapped : 1;
 	union {
 		struct irq_2_iommu irq_2_iommu;
 		struct irq_2_irte  irq_2_irte;

commit 43fe1abc18a237581663a51da4c2f8e57684c223
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:44 2015 +0800

    x86/uv: Use hierarchical irqdomain to manage UV interrupts
    
    Enhance UV code to support hierarchical irqdomain, it helps to make
    the architecture more clear.
    
    We construct hwirq based on mmr_blade and mmr_offset, but mmr_offset
    has type unsigned long, it may exceed the range of irq_hw_number_t. So
    help about the way to construct hwirq based on mmr_blade and
    mmr_offset is welcomed!
    
    Folded a patch from Dimitri Sivanich <sivanich@sgi.com> to fix a bug
    on UV platforms, please refer to:
    http://lkml.org/lkml/2014/12/16/351
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428905519-23704-23-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 5e0b031d1a7d..75d0db1db8a0 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -123,6 +123,7 @@ enum irq_alloc_type {
 	X86_IRQ_ALLOC_TYPE_MSI,
 	X86_IRQ_ALLOC_TYPE_MSIX,
 	X86_IRQ_ALLOC_TYPE_DMAR,
+	X86_IRQ_ALLOC_TYPE_UV,
 };
 
 struct irq_alloc_info {
@@ -168,6 +169,14 @@ struct irq_alloc_info {
 			struct pci_dev	*ht_dev;
 			void		*ht_update;
 		};
+#endif
+#ifdef	CONFIG_X86_UV
+		struct {
+			int		uv_limit;
+			int		uv_blade;
+			unsigned long	uv_offset;
+			char		*uv_name;
+		};
 #endif
 	};
 };

commit 49e07d8f28c05347f237146a9ec66f6d958db83e
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:43 2015 +0800

    x86/htirq: Use hierarchical irqdomain to manage Hypertransport interrupts
    
    We have slightly changed the architecture interfaces to support htirq
    PCI driver. It's safe because currently Hypertransport interrupt is
    only enabled on x86 platforms.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428905519-23704-22-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index bf1725047c27..5e0b031d1a7d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -160,6 +160,14 @@ struct irq_alloc_info {
 			int		dmar_id;
 			void		*dmar_data;
 		};
+#endif
+#ifdef	CONFIG_HT_IRQ
+		struct {
+			int		ht_pos;
+			int		ht_idx;
+			struct pci_dev	*ht_dev;
+			void		*ht_update;
+		};
 #endif
 	};
 };
@@ -227,6 +235,11 @@ extern void arch_init_msi_domain(struct irq_domain *domain);
 #else
 static inline void arch_init_msi_domain(struct irq_domain *domain) { }
 #endif
+#ifdef	CONFIG_HT_IRQ
+extern void arch_init_htirq_domain(struct irq_domain *domain);
+#else
+static inline void arch_init_htirq_domain(struct irq_domain *domain) { }
+#endif
 
 /* Statistics */
 extern atomic_t irq_err_count;

commit 0921f1da6425f05a1f56803069124b7ec13b79e2
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:42 2015 +0800

    x86/irq: Use hierarchical irqdomain to manage DMAR interrupts
    
    Enhance DMAR code to support hierarchical irqdomain, it helps to make
    the architecture more clear.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428905519-23704-21-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 05829e973a2a..bf1725047c27 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -122,6 +122,7 @@ enum irq_alloc_type {
 	X86_IRQ_ALLOC_TYPE_HPET,
 	X86_IRQ_ALLOC_TYPE_MSI,
 	X86_IRQ_ALLOC_TYPE_MSIX,
+	X86_IRQ_ALLOC_TYPE_DMAR,
 };
 
 struct irq_alloc_info {
@@ -153,6 +154,12 @@ struct irq_alloc_info {
 			u32		ioapic_valid : 1;
 			struct IO_APIC_route_entry *ioapic_entry;
 		};
+#endif
+#ifdef	CONFIG_DMAR_TABLE
+		struct {
+			int		dmar_id;
+			void		*dmar_data;
+		};
 #endif
 	};
 };

commit 52f518a3a7c2f80551a38d38be28bc9f335e713c
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:35 2015 +0800

    x86/MSI: Use hierarchical irqdomains to manage MSI interrupts
    
    Enhance MSI code to support hierarchical irqdomains, it helps to make
    the architecture more clear.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428905519-23704-14-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 75a97a5bbfa8..05829e973a2a 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -110,9 +110,10 @@ struct irq_2_irte {
 };
 #endif	/* CONFIG_IRQ_REMAP */
 
+struct irq_domain;
+
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
-struct irq_domain;
 struct pci_dev;
 struct msi_desc;
 
@@ -214,6 +215,12 @@ static inline void lock_vector_lock(void) {}
 static inline void unlock_vector_lock(void) {}
 #endif	/* CONFIG_X86_LOCAL_APIC */
 
+#ifdef	CONFIG_PCI_MSI
+extern void arch_init_msi_domain(struct irq_domain *domain);
+#else
+static inline void arch_init_msi_domain(struct irq_domain *domain) { }
+#endif
+
 /* Statistics */
 extern atomic_t irq_err_count;
 extern atomic_t irq_mis_count;

commit 947045a2aac1157c85a24984c9a8128846ae7266
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:30 2015 +0800

    irq_remapping: Introduce new interfaces to support hierarchical irqdomains
    
    Introduce new interfaces for interrupt remapping drivers to support
    hierarchical irqdomains:
    
    1) irq_remapping_get_ir_irq_domain(): get irqdomain associated with an
       interrupt remapping unit. IOAPIC/HPET drivers use this interface to
       get parent interrupt remapping irqdomain.
    
    2) irq_remapping_get_irq_domain(): get irqdomain for an IRQ allocation.
       This is mainly used to support MSI irqdomain. We must build one MSI
       irqdomain for each interrupt remapping unit. MSI driver calls this
       interface to get MSI irqdomain associated with an IR irqdomain which
       manages the PCI devices. In a further step we will store the irqdomain
       pointer in the device struct to avoid this call in the irq allocation
       path.
    
    Architecture specific hooks:
    1) arch_get_ir_parent_domain(): get parent irqdomain for IR irqdomain,
       which is x86_vector_domain on x86 platforms.
    2) arch_create_msi_irq_domain(): create an MSI irqdomain associated with
       the interrupt remapping unit.
    
    We also add following callbacks into struct irq_remap_ops:
            struct irq_domain *(*get_ir_irq_domain)(struct irq_alloc_info *);
            struct irq_domain *(*get_irq_domain)(struct irq_alloc_info *);
    
    Once all clients of IR have been converted to the new hierarchical irqdomain
    interfaces, we will:
    1) Remove set_ioapic_entry, set_affinity, free_irq, compose_msi_msg,
       msi_alloc_irq, msi_setup_irq, setup_hpet_msi from struct remap_osp
    2) Remove setup_ioapic_remapped_entry, free_remapped_irq,
       compose_remapped_msi_msg, setup_hpet_msi_remapped, setup_remapped_irq.
    3) Simplify x86_io_apic_ops and x86_msi.
    
    We can achieve a way clearer architecture with all these changes
    applied.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428905519-23704-9-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 5b951ac56aa1..75a97a5bbfa8 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -113,10 +113,47 @@ struct irq_2_irte {
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
 struct irq_domain;
+struct pci_dev;
+struct msi_desc;
+
+enum irq_alloc_type {
+	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
+	X86_IRQ_ALLOC_TYPE_HPET,
+	X86_IRQ_ALLOC_TYPE_MSI,
+	X86_IRQ_ALLOC_TYPE_MSIX,
+};
 
 struct irq_alloc_info {
+	enum irq_alloc_type	type;
 	u32			flags;
 	const struct cpumask	*mask;	/* CPU mask for vector allocation */
+	union {
+		int		unused;
+#ifdef	CONFIG_HPET_TIMER
+		struct {
+			int		hpet_id;
+			int		hpet_index;
+			void		*hpet_data;
+		};
+#endif
+#ifdef	CONFIG_PCI_MSI
+		struct {
+			struct pci_dev	*msi_dev;
+			irq_hw_number_t	msi_hwirq;
+		};
+#endif
+#ifdef	CONFIG_X86_IO_APIC
+		struct {
+			int		ioapic_id;
+			int		ioapic_pin;
+			int		ioapic_node;
+			u32		ioapic_trigger : 1;
+			u32		ioapic_polarity : 1;
+			u32		ioapic_valid : 1;
+			struct IO_APIC_route_entry *ioapic_entry;
+		};
+#endif
+	};
 };
 
 enum {

commit b5dc8e6c21e7ffba0246bf39cea97805c142bf85
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:24 2015 +0800

    x86/irq: Use hierarchical irqdomain to manage CPU interrupt vectors
    
    Abstract CPU local APIC as an interrupt controller and create an
    irqdomain for it to manage CPU interrupt vectors. It's the base to
    enable hierarchical irqdomains on x86 systems.
    
    The final irqdomain hierarchy will look like this:
    
    IOAPIC domain    ----|
    MSI/MSI-x domain ----> [Interrupt Remapping domain] -> CPU vector domain
    HPET_IRQ domain  ----|                                         ^
                                                                   |
    DMAR domain      ----------------------------------------------|
    HT_IRQ domain    ----------------------------------------------|
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1428905519-23704-3-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index cda96954cbbf..5b951ac56aa1 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -112,6 +112,17 @@ struct irq_2_irte {
 
 #ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_data;
+struct irq_domain;
+
+struct irq_alloc_info {
+	u32			flags;
+	const struct cpumask	*mask;	/* CPU mask for vector allocation */
+};
+
+enum {
+	/* Allocate contiguous CPU vectors */
+	X86_IRQ_ALLOC_CONTIGUOUS_VECTORS		= 0x1,
+};
 
 struct irq_cfg {
 	cpumask_var_t		domain;
@@ -135,6 +146,12 @@ struct irq_cfg {
 	};
 };
 
+extern struct irq_domain *x86_vector_domain;
+
+extern void init_irq_alloc_info(struct irq_alloc_info *info,
+				const struct cpumask *mask);
+extern void copy_irq_alloc_info(struct irq_alloc_info *dst,
+				struct irq_alloc_info *src);
 extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 extern struct irq_cfg *alloc_irq_and_cfg_at(unsigned int at, int node);

commit 5f0052f9522b84269e1b3b435a806f873d992702
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:23 2015 +0800

    x86/irq: Save destination CPU ID in irq_cfg
    
    Cache destination CPU APIC ID into struct irq_cfg when assigning vector
    for interrupt. Upper layer just needs to read the cached APIC ID instead
    of calling apic->cpu_mask_to_apicid_and(), it helps to hide APIC driver
    details from IOAPIC/HPET/MSI drivers..
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Link: http://lkml.kernel.org/r/1428905519-23704-2-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e9571ddabc4f..cda96954cbbf 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -116,6 +116,7 @@ struct irq_data;
 struct irq_cfg {
 	cpumask_var_t		domain;
 	cpumask_var_t		old_domain;
+	unsigned int		dest_apicid;
 	u8			vector;
 	u8			move_in_progress : 1;
 #ifdef CONFIG_IRQ_REMAP

commit 3304c9c37bef30ebd2ef71d986e6568372ce80f8
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Fri Apr 3 21:49:13 2015 +0200

    x86/asm/entry/irq: Simplify interrupt dispatch table (IDT) layout
    
    Interrupt entry points are handled with the following code,
    each 32-byte code block contains seven entry points:
    
                    ...
                    [push][jump 22] // 4 bytes
                    [push][jump 18] // 4 bytes
                    [push][jump 14] // 4 bytes
                    [push][jump 10] // 4 bytes
                    [push][jump  6] // 4 bytes
                    [push][jump  2] // 4 bytes
                    [push][jump common_interrupt][padding] // 8 bytes
    
                    [push][jump]
                    [push][jump]
                    [push][jump]
                    [push][jump]
                    [push][jump]
                    [push][jump]
                    [push][jump common_interrupt][padding]
    
                    [padding_2]
            common_interrupt:
    
    And there is a table which holds pointers to every entry point,
    IOW: to every push.
    
    In cold cache, two jumps are still costlier than one, even
    though we get the benefit of them residing in the same
    cacheline.
    
    This change replaces short jumps with near ones to
    'common_interrupt', and pads every push+jump pair to 8 bytes. This
    way, each interrupt takes only one jump.
    
    This change replaces ".p2align CONFIG_X86_L1_CACHE_SHIFT" before
    dispatch table with ".align 8" - we do not need anything
    stronger than that.
    
    The table of entry addresses (the interrupt[] array) is no
    longer necessary, the address of entries can be easily
    calculated as (irq_entries_start + i*8).
    
       text    data     bss     dec     hex filename
      12546       0       0   12546    3102 entry_64.o.before
      11626       0       0   11626    2d6a entry_64.o
    
    The size decrease is because 1656 bytes of .init.rodata are
    gone. That's initdata, though. The resident size does go up a
    bit.
    
    Run-tested (32 and 64 bits).
    
    Acked-and-Tested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Will Drewry <wad@chromium.org>
    Link: http://lkml.kernel.org/r/1428090553-7283-1-git-send-email-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 9662290e0b20..e9571ddabc4f 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -181,10 +181,9 @@ extern __visible void smp_call_function_single_interrupt(struct pt_regs *);
 extern __visible void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
-extern void (*__initconst interrupt[FIRST_SYSTEM_VECTOR
-				    - FIRST_EXTERNAL_VECTOR])(void);
+extern char irq_entries_start[];
 #ifdef CONFIG_TRACING
-#define trace_interrupt interrupt
+#define trace_irq_entries_start irq_entries_start
 #endif
 
 #define VECTOR_UNDEFINED	(-1)

commit 8643e28da27d6d50f772409b8dc80bdab52239fb
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:12:04 2014 +0800

    x86, irq: Move IOAPIC related declarations from hw_irq.h into io_apic.h
    
    Clean up code by moving IOAPIC related declarations from hw_irq.h into
    io_apic.h.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Christian Gmeiner <christian.gmeiner@gmail.com>
    Cc: Aubrey <aubrey.li@linux.intel.com>
    Cc: Ryan Desfosses <ryan@desfo.org>
    Cc: Quentin Lambert <lambert.quentin@gmail.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: http://lkml.kernel.org/r/1414397531-28254-14-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index a7235777a478..9662290e0b20 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -159,39 +159,6 @@ static inline void lock_vector_lock(void) {}
 static inline void unlock_vector_lock(void) {}
 #endif	/* CONFIG_X86_LOCAL_APIC */
 
-/* IOAPIC */
-#ifdef CONFIG_X86_IO_APIC
-struct io_apic_irq_attr {
-	int ioapic;
-	int ioapic_pin;
-	int trigger;
-	int polarity;
-};
-
-static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
-					int ioapic, int ioapic_pin,
-					int trigger, int polarity)
-{
-	irq_attr->ioapic	= ioapic;
-	irq_attr->ioapic_pin	= ioapic_pin;
-	irq_attr->trigger	= trigger;
-	irq_attr->polarity	= polarity;
-}
-
-extern void setup_IO_APIC(void);
-extern void enable_IO_APIC(void);
-extern void disable_IO_APIC(void);
-extern void setup_ioapic_dest(void);
-extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
-extern void print_IO_APICs(void);
-
-extern unsigned long io_apic_irqs;
-#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
-#else	/* CONFIG_X86_IO_APIC */
-#define IO_APIC_IRQ(x)	0
-static inline void print_IO_APICs(void) {}
-#endif	/* CONFIG_X86_IO_APIC */
-
 /* Statistics */
 extern atomic_t irq_err_count;
 extern atomic_t irq_mis_count;

commit f0e5bf758348e7205a33de50c894e75f9bc89714
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 5 10:12:27 2014 +0100

    x86, irq: Make UP version of irq_complete_move() an inline stub
    
    No point for having an empty real function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index ef50db16bb44..a7235777a478 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -144,10 +144,11 @@ extern void clear_irq_vector(int irq, struct irq_cfg *cfg);
 extern void setup_vector_irq(int cpu);
 #ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
+extern void irq_complete_move(struct irq_cfg *cfg);
 #else
 static inline void send_cleanup_vector(struct irq_cfg *c) { }
+static inline void irq_complete_move(struct irq_cfg *c) { }
 #endif
-extern void irq_complete_move(struct irq_cfg *cfg);
 
 extern int apic_retrigger_irq(struct irq_data *data);
 extern void apic_ack_edge(struct irq_data *data);

commit 74afab7af7d9aeba86b3b8e39670cf7d0058f6df
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:12:00 2014 +0800

    x86, irq: Move local APIC related code from io_apic.c into vector.c
    
    Create arch/x86/kernel/apic/vector.c to host local APIC related code,
    prepare for making MSI/HT_IRQ independent of IOAPIC.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1414397531-28254-10-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 454c9e4056e6..ef50db16bb44 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -111,6 +111,8 @@ struct irq_2_irte {
 #endif	/* CONFIG_IRQ_REMAP */
 
 #ifdef	CONFIG_X86_LOCAL_APIC
+struct irq_data;
+
 struct irq_cfg {
 	cpumask_var_t		domain;
 	cpumask_var_t		old_domain;
@@ -134,28 +136,27 @@ struct irq_cfg {
 
 extern struct irq_cfg *irq_cfg(unsigned int irq);
 extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
-extern void setup_vector_irq(int cpu);
+extern struct irq_cfg *alloc_irq_and_cfg_at(unsigned int at, int node);
+extern void lock_vector_lock(void);
+extern void unlock_vector_lock(void);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
+extern void clear_irq_vector(int irq, struct irq_cfg *cfg);
+extern void setup_vector_irq(int cpu);
 #ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
 #else
 static inline void send_cleanup_vector(struct irq_cfg *c) { }
 #endif
+extern void irq_complete_move(struct irq_cfg *cfg);
 
-struct irq_data;
-int apic_set_affinity(struct irq_data *, const struct cpumask *,
-		      unsigned int *dest_id);
-#endif	/* CONFIG_X86_LOCAL_APIC */
-
-#ifdef CONFIG_X86_IO_APIC
-extern void lock_vector_lock(void);
-extern void unlock_vector_lock(void);
-extern void __setup_vector_irq(int cpu);
-#else
+extern int apic_retrigger_irq(struct irq_data *data);
+extern void apic_ack_edge(struct irq_data *data);
+extern int apic_set_affinity(struct irq_data *data, const struct cpumask *mask,
+			     unsigned int *dest_id);
+#else	/*  CONFIG_X86_LOCAL_APIC */
 static inline void lock_vector_lock(void) {}
 static inline void unlock_vector_lock(void) {}
-static inline void __setup_vector_irq(int cpu) {}
-#endif
+#endif	/* CONFIG_X86_LOCAL_APIC */
 
 /* IOAPIC */
 #ifdef CONFIG_X86_IO_APIC
@@ -181,11 +182,13 @@ extern void enable_IO_APIC(void);
 extern void disable_IO_APIC(void);
 extern void setup_ioapic_dest(void);
 extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
+extern void print_IO_APICs(void);
 
 extern unsigned long io_apic_irqs;
 #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
 #else	/* CONFIG_X86_IO_APIC */
 #define IO_APIC_IRQ(x)	0
+static inline void print_IO_APICs(void) {}
 #endif	/* CONFIG_X86_IO_APIC */
 
 /* Statistics */

commit 55a0e2b122c26c7496ea85754bceddc05dba402b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:11:59 2014 +0800

    x86, irq: Introduce helpers to access struct irq_cfg
    
    Change irq_cfg() from static to extern, also introduce helper function
    irqd_cfg(). Later we can rewrite these two helpers when enabling
    hierarchy irqdomain.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1414397531-28254-9-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e1acbbaf47ca..454c9e4056e6 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -132,6 +132,8 @@ struct irq_cfg {
 	};
 };
 
+extern struct irq_cfg *irq_cfg(unsigned int irq);
+extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 extern void setup_vector_irq(int cpu);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 #ifdef CONFIG_SMP

commit cb39288cd6c6dfd0e87c6e161d9da1ec6974f4b8
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:11:57 2014 +0800

    x86, irq: Rename local APIC related functions in io_apic.c as apic_xxx()
    
    Rename local APIC related functions in io_apic.c as apic_xxx() instead
    of ioapic_xxx(), later they will be moved into separate file.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1414397531-28254-7-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 9e2d08b4737b..e1acbbaf47ca 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -141,8 +141,8 @@ static inline void send_cleanup_vector(struct irq_cfg *c) { }
 #endif
 
 struct irq_data;
-int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
-			  unsigned int *dest_id);
+int apic_set_affinity(struct irq_data *, const struct cpumask *,
+		      unsigned int *dest_id);
 #endif	/* CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_IO_APIC

commit 26011eee04f7144a4bcb150386b43e6e881f8fa1
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:11:56 2014 +0800

    x86, irq: Refine hw_irq.h to prepare for irqdomain support
    
    Refine hw_irq.h to prepare for irqdomain support by:
    
    1) guarding common APIC related interfaces with CONFIG_X86_LOCAL_APIC
    2) guarding interrupt remapping related interfaces with CONFIG_IRQ_REMAP
    3) guarding IOAPIC related interfaces with CONFIG_X86_IO_APIC
    
    No functional changes.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1414397531-28254-6-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 66e59e646deb..9e2d08b4737b 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -94,30 +94,7 @@ extern void trace_call_function_single_interrupt(void);
 #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
 #endif /* CONFIG_TRACING */
 
-/* IOAPIC */
-#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
-extern unsigned long io_apic_irqs;
-
-extern void setup_IO_APIC(void);
-extern void disable_IO_APIC(void);
-
-struct io_apic_irq_attr {
-	int ioapic;
-	int ioapic_pin;
-	int trigger;
-	int polarity;
-};
-
-static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
-					int ioapic, int ioapic_pin,
-					int trigger, int polarity)
-{
-	irq_attr->ioapic	= ioapic;
-	irq_attr->ioapic_pin	= ioapic_pin;
-	irq_attr->trigger	= trigger;
-	irq_attr->polarity	= polarity;
-}
-
+#ifdef CONFIG_IRQ_REMAP
 /* Intel specific interrupt remapping information */
 struct irq_2_iommu {
 	struct intel_iommu *iommu;
@@ -131,14 +108,10 @@ struct irq_2_irte {
 	u16 devid; /* Device ID for IRTE table */
 	u16 index; /* Index into IRTE table*/
 };
+#endif	/* CONFIG_IRQ_REMAP */
 
-/*
- * This is performance-critical, we want to do it O(1)
- *
- * Most irqs are mapped 1:1 with pins.
- */
+#ifdef	CONFIG_X86_LOCAL_APIC
 struct irq_cfg {
-	struct list_head	irq_2_pin;
 	cpumask_var_t		domain;
 	cpumask_var_t		old_domain;
 	u8			vector;
@@ -150,8 +123,16 @@ struct irq_cfg {
 		struct irq_2_irte  irq_2_irte;
 	};
 #endif
+	union {
+#ifdef CONFIG_X86_IO_APIC
+		struct {
+			struct list_head	irq_2_pin;
+		};
+#endif
+	};
 };
 
+extern void setup_vector_irq(int cpu);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 #ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
@@ -162,10 +143,48 @@ static inline void send_cleanup_vector(struct irq_cfg *c) { }
 struct irq_data;
 int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
 			  unsigned int *dest_id);
-extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
-extern void setup_ioapic_dest(void);
+#endif	/* CONFIG_X86_LOCAL_APIC */
+
+#ifdef CONFIG_X86_IO_APIC
+extern void lock_vector_lock(void);
+extern void unlock_vector_lock(void);
+extern void __setup_vector_irq(int cpu);
+#else
+static inline void lock_vector_lock(void) {}
+static inline void unlock_vector_lock(void) {}
+static inline void __setup_vector_irq(int cpu) {}
+#endif
+
+/* IOAPIC */
+#ifdef CONFIG_X86_IO_APIC
+struct io_apic_irq_attr {
+	int ioapic;
+	int ioapic_pin;
+	int trigger;
+	int polarity;
+};
+
+static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
+					int ioapic, int ioapic_pin,
+					int trigger, int polarity)
+{
+	irq_attr->ioapic	= ioapic;
+	irq_attr->ioapic_pin	= ioapic_pin;
+	irq_attr->trigger	= trigger;
+	irq_attr->polarity	= polarity;
+}
 
+extern void setup_IO_APIC(void);
 extern void enable_IO_APIC(void);
+extern void disable_IO_APIC(void);
+extern void setup_ioapic_dest(void);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
+
+extern unsigned long io_apic_irqs;
+#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+#else	/* CONFIG_X86_IO_APIC */
+#define IO_APIC_IRQ(x)	0
+#endif	/* CONFIG_X86_IO_APIC */
 
 /* Statistics */
 extern atomic_t irq_err_count;
@@ -200,17 +219,6 @@ extern void (*__initconst interrupt[FIRST_SYSTEM_VECTOR
 
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);
-extern void setup_vector_irq(int cpu);
-
-#ifdef CONFIG_X86_IO_APIC
-extern void lock_vector_lock(void);
-extern void unlock_vector_lock(void);
-extern void __setup_vector_irq(int cpu);
-#else
-static inline void lock_vector_lock(void) {}
-static inline void unlock_vector_lock(void) {}
-static inline void __setup_vector_irq(int cpu) {}
-#endif
 
 #endif /* !ASSEMBLY_ */
 

commit a178b87b20803aa1cf991f39616e51f4939fbcaf
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Oct 27 16:11:55 2014 +0800

    x86, irq: Convert irq_2_pin list to generic list
    
    Use generic list to replace private list implementation so we can use
    the existing helper functions.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1414397531-28254-5-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b12c45c5d8ec..66e59e646deb 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -138,7 +138,7 @@ struct irq_2_irte {
  * Most irqs are mapped 1:1 with pins.
  */
 struct irq_cfg {
-	struct irq_pin_list	*irq_2_pin;
+	struct list_head	irq_2_pin;
 	cpumask_var_t		domain;
 	cpumask_var_t		old_domain;
 	u8			vector;

commit 25d0d35ed7d4ded4ba90e6311c80f2eca65d12f0
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:11:54 2014 +0800

    x86, irq: Kill useless parameter 'irq_attr' of IO_APIC_get_PCI_irq_vector()
    
    None of the callers requires irq_attr to be filled
    in. IO_APIC_get_PCI_irq_vector() does not do anything useful with it
    either.
    
    Remove the parameter and fixup the call sites.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Ryan Desfosses <ryan@desfo.org>
    Cc: Quentin Lambert <lambert.quentin@gmail.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: http://lkml.kernel.org/r/1414397531-28254-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 8dbe237bd806..b12c45c5d8ec 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -162,7 +162,7 @@ static inline void send_cleanup_vector(struct irq_cfg *c) { }
 struct irq_data;
 int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
 			  unsigned int *dest_id);
-extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
 extern void setup_ioapic_dest(void);
 
 extern void enable_IO_APIC(void);

commit 2414e021ac8d588f1b09f64891f69a3e26feadf1
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Nov 3 08:39:43 2014 +0000

    x86: Avoid building unused IRQ entry stubs
    
    When X86_LOCAL_APIC (i.e. unconditionally on x86-64),
    first_system_vector will never end up being higher than
    LOCAL_TIMER_VECTOR (0xef), and hence building stubs for vectors
    0xef...0xff is pointlessly reducing code density. Deal with this at
    build time already.
    
    Taking into consideration that X86_64 implies X86_LOCAL_APIC, also
    simplify (and hence make easier to read and more consistent with the
    change done here) some #if-s in arch/x86/kernel/irqinit.c.
    
    While we could further improve the packing of the IRQ entry stubs (the
    four ones now left in the last set could be fit into the four padding
    bytes each of the final four sets have) this doesn't seem to provide
    any real benefit: Both irq_entries_start and common_interrupt getting
    cache line aligned, eliminating the 30th set would just produce 32
    bytes of padding between the 29th and common_interrupt.
    
    [ tglx: Folded lguest fix from Dan Carpenter ]
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: lguest@lists.ozlabs.org
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Link: http://lkml.kernel.org/r/54574D5F0200007800044389@mail.emea.novell.com
    Link: http://lkml.kernel.org/r/20141115185718.GB6530@mwanda
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index fa5d1e768ba3..8dbe237bd806 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -189,7 +189,8 @@ extern __visible void smp_call_function_single_interrupt(struct pt_regs *);
 extern __visible void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
-extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
+extern void (*__initconst interrupt[FIRST_SYSTEM_VECTOR
+				    - FIRST_EXTERNAL_VECTOR])(void);
 #ifdef CONFIG_TRACING
 #define trace_interrupt interrupt
 #endif

commit e32c67e0cbb3921bffe1cc306628c0074d2f43bc
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 16:12:11 2014 +0800

    x86, irq: Provide empty send_cleanup_vector() stub for UP builds
    
    Define an empty send_cleanup_vector() for UP kernel to fix link error
    of undefined reference, which is used by uv_irq and irq_remapping.
    
    [ tglx: Made it an inline stub and moved it ahead of the file split
            changes ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1414397531-28254-21-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 4615906d83df..fa5d1e768ba3 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -153,7 +153,11 @@ struct irq_cfg {
 };
 
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
+#ifdef CONFIG_SMP
 extern void send_cleanup_vector(struct irq_cfg *);
+#else
+static inline void send_cleanup_vector(struct irq_cfg *c) { }
+#endif
 
 struct irq_data;
 int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,

commit 79a51b25badae79d2da6f7b54530adf56697f669
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Apr 2 08:13:47 2014 -0400

    x86/irq: Clean up VECTOR_UNDEFINED and VECTOR_RETRIGGERED definition
    
    During another patch review, David Rientjes noted that
    VECTOR_UNDEFINED and VECTOR_RETRIGGERED should be defined with ()s
    so that they are not erroneously used in an arithmetic operation.
    
    Suggested-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Yang Zhang <yang.z.zhang@Intel.com>
    Link: http://lkml.kernel.org/r/1396440827-18352-1-git-send-email-prarit@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index a307b7530e54..4615906d83df 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -190,8 +190,8 @@ extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
 #define trace_interrupt interrupt
 #endif
 
-#define VECTOR_UNDEFINED	-1
-#define VECTOR_RETRIGGERED	-2
+#define VECTOR_UNDEFINED	(-1)
+#define VECTOR_RETRIGGERED	(-2)
 
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);

commit c5f9ee3d665a7660b296aa1e91949ae3376f0d07
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Tue Feb 25 12:05:34 2014 -0800

    x86, platforms: Remove SGI Visual Workstation
    
    The SGI Visual Workstation seems to be dead; remove support so we
    don't have to continue maintaining it.
    
    Cc: Andrey Panin <pazke@donpac.ru>
    Cc: Michael Reed <mdr@sgi.com>
    Link: http://lkml.kernel.org/r/530CFD6C.7040705@zytor.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 67d69b8e2d20..a307b7530e54 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -98,7 +98,6 @@ extern void trace_call_function_single_interrupt(void);
 #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 extern unsigned long io_apic_irqs;
 
-extern void init_VISWS_APIC_irqs(void);
 extern void setup_IO_APIC(void);
 extern void disable_IO_APIC(void);
 

commit 9345005f4eed805308193658d12e4e7e9c261e74
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Sun Jan 5 11:10:52 2014 -0500

    x86/irq: Fix do_IRQ() interrupt warning for cpu hotplug retriggered irqs
    
    During heavy CPU-hotplug operations the following spurious kernel warnings
    can trigger:
    
      do_IRQ: No ... irq handler for vector (irq -1)
    
      [ See: https://bugzilla.kernel.org/show_bug.cgi?id=64831 ]
    
    When downing a cpu it is possible that there are unhandled irqs
    left in the APIC IRR register.  The following code path shows
    how the problem can occur:
    
     1. CPU 5 is to go down.
    
     2. cpu_disable() on CPU 5 executes with interrupt flag cleared
        by local_irq_save() via stop_machine().
    
     3. IRQ 12 asserts on CPU 5, setting IRR but not ISR because
        interrupt flag is cleared (CPU unabled to handle the irq)
    
     4. IRQs are migrated off of CPU 5, and the vectors' irqs are set
        to -1. 5. stop_machine() finishes cpu_disable()
    
     6. cpu_die() for CPU 5 executes in normal context.
    
     7. CPU 5 attempts to handle IRQ 12 because the IRR is set for
        IRQ 12.  The code attempts to find the vector's IRQ and cannot
        because it has been set to -1. 8. do_IRQ() warning displays
        warning about CPU 5 IRQ 12.
    
    I added a debug printk to output which CPU & vector was
    retriggered and discovered that that we are getting bogus
    events.  I see a 100% correlation between this debug printk in
    fixup_irqs() and the do_IRQ() warning.
    
    This patchset resolves this by adding definitions for
    VECTOR_UNDEFINED(-1) and VECTOR_RETRIGGERED(-2) and modifying
    the code to use them.
    
    Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=64831
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Reviewed-by: Rui Wang <rui.y.wang@intel.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Yang Zhang <yang.z.zhang@Intel.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: janet.morgan@Intel.com
    Cc: tony.luck@Intel.com
    Cc: ruiv.wang@gmail.com
    Link: http://lkml.kernel.org/r/1388938252-16627-1-git-send-email-prarit@redhat.com
    [ Cleaned up the code a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index cba45d99ac1a..67d69b8e2d20 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -191,6 +191,9 @@ extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
 #define trace_interrupt interrupt
 #endif
 
+#define VECTOR_UNDEFINED	-1
+#define VECTOR_RETRIGGERED	-2
+
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);
 extern void setup_vector_irq(int cpu);

commit 25c74b10bacead867478480170083f69cfc0db48
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Wed Oct 30 16:37:00 2013 -0400

    x86, trace: Register exception handler to trace IDT
    
    This patch registers exception handlers for tracing to a trace IDT.
    
    To implemented it in set_intr_gate(), this patch does followings.
     - Register the exception handlers to
       the trace IDT by prepending "trace_" to the handler's names.
     - Also, newly introduce trace_page_fault() to add tracepoints
       in a subsequent patch.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Link: http://lkml.kernel.org/r/52716DEC.5050204@hds.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 92b3bae08b74..cba45d99ac1a 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -187,6 +187,9 @@ extern __visible void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
 extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
+#ifdef CONFIG_TRACING
+#define trace_interrupt interrupt
+#endif
 
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);

commit 1d9090e2fb32c84277cef6e72a21be7f78c929f4
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Aug 5 15:02:37 2013 -0700

    x86, asmlinkage: Make all interrupt handlers asmlinkage / __visible
    
    These handlers are all referenced from assembler stubs, so need
    to be visible.
    
    The handlers without arguments become asmlinkage, the others __visible
    to not force regparms(0) on x86-32.
    
    I put it all into a single patch, please let me know if you want
    it it split up.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1375740170-7446-4-git-send-email-andi@firstfloor.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e4ac559c4a24..92b3bae08b74 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -26,56 +26,56 @@
 #include <asm/sections.h>
 
 /* Interrupt handlers registered during init_IRQ */
-extern void apic_timer_interrupt(void);
-extern void x86_platform_ipi(void);
-extern void kvm_posted_intr_ipi(void);
-extern void error_interrupt(void);
-extern void irq_work_interrupt(void);
-
-extern void spurious_interrupt(void);
-extern void thermal_interrupt(void);
-extern void reschedule_interrupt(void);
-
-extern void invalidate_interrupt(void);
-extern void invalidate_interrupt0(void);
-extern void invalidate_interrupt1(void);
-extern void invalidate_interrupt2(void);
-extern void invalidate_interrupt3(void);
-extern void invalidate_interrupt4(void);
-extern void invalidate_interrupt5(void);
-extern void invalidate_interrupt6(void);
-extern void invalidate_interrupt7(void);
-extern void invalidate_interrupt8(void);
-extern void invalidate_interrupt9(void);
-extern void invalidate_interrupt10(void);
-extern void invalidate_interrupt11(void);
-extern void invalidate_interrupt12(void);
-extern void invalidate_interrupt13(void);
-extern void invalidate_interrupt14(void);
-extern void invalidate_interrupt15(void);
-extern void invalidate_interrupt16(void);
-extern void invalidate_interrupt17(void);
-extern void invalidate_interrupt18(void);
-extern void invalidate_interrupt19(void);
-extern void invalidate_interrupt20(void);
-extern void invalidate_interrupt21(void);
-extern void invalidate_interrupt22(void);
-extern void invalidate_interrupt23(void);
-extern void invalidate_interrupt24(void);
-extern void invalidate_interrupt25(void);
-extern void invalidate_interrupt26(void);
-extern void invalidate_interrupt27(void);
-extern void invalidate_interrupt28(void);
-extern void invalidate_interrupt29(void);
-extern void invalidate_interrupt30(void);
-extern void invalidate_interrupt31(void);
-
-extern void irq_move_cleanup_interrupt(void);
-extern void reboot_interrupt(void);
-extern void threshold_interrupt(void);
-
-extern void call_function_interrupt(void);
-extern void call_function_single_interrupt(void);
+extern asmlinkage void apic_timer_interrupt(void);
+extern asmlinkage void x86_platform_ipi(void);
+extern asmlinkage void kvm_posted_intr_ipi(void);
+extern asmlinkage void error_interrupt(void);
+extern asmlinkage void irq_work_interrupt(void);
+
+extern asmlinkage void spurious_interrupt(void);
+extern asmlinkage void thermal_interrupt(void);
+extern asmlinkage void reschedule_interrupt(void);
+
+extern asmlinkage void invalidate_interrupt(void);
+extern asmlinkage void invalidate_interrupt0(void);
+extern asmlinkage void invalidate_interrupt1(void);
+extern asmlinkage void invalidate_interrupt2(void);
+extern asmlinkage void invalidate_interrupt3(void);
+extern asmlinkage void invalidate_interrupt4(void);
+extern asmlinkage void invalidate_interrupt5(void);
+extern asmlinkage void invalidate_interrupt6(void);
+extern asmlinkage void invalidate_interrupt7(void);
+extern asmlinkage void invalidate_interrupt8(void);
+extern asmlinkage void invalidate_interrupt9(void);
+extern asmlinkage void invalidate_interrupt10(void);
+extern asmlinkage void invalidate_interrupt11(void);
+extern asmlinkage void invalidate_interrupt12(void);
+extern asmlinkage void invalidate_interrupt13(void);
+extern asmlinkage void invalidate_interrupt14(void);
+extern asmlinkage void invalidate_interrupt15(void);
+extern asmlinkage void invalidate_interrupt16(void);
+extern asmlinkage void invalidate_interrupt17(void);
+extern asmlinkage void invalidate_interrupt18(void);
+extern asmlinkage void invalidate_interrupt19(void);
+extern asmlinkage void invalidate_interrupt20(void);
+extern asmlinkage void invalidate_interrupt21(void);
+extern asmlinkage void invalidate_interrupt22(void);
+extern asmlinkage void invalidate_interrupt23(void);
+extern asmlinkage void invalidate_interrupt24(void);
+extern asmlinkage void invalidate_interrupt25(void);
+extern asmlinkage void invalidate_interrupt26(void);
+extern asmlinkage void invalidate_interrupt27(void);
+extern asmlinkage void invalidate_interrupt28(void);
+extern asmlinkage void invalidate_interrupt29(void);
+extern asmlinkage void invalidate_interrupt30(void);
+extern asmlinkage void invalidate_interrupt31(void);
+
+extern asmlinkage void irq_move_cleanup_interrupt(void);
+extern asmlinkage void reboot_interrupt(void);
+extern asmlinkage void threshold_interrupt(void);
+
+extern asmlinkage void call_function_interrupt(void);
+extern asmlinkage void call_function_single_interrupt(void);
 
 #ifdef CONFIG_TRACING
 /* Interrupt handlers registered during init_IRQ */
@@ -172,22 +172,18 @@ extern atomic_t irq_mis_count;
 extern void eisa_set_level_irq(unsigned int irq);
 
 /* SMP */
-extern void smp_apic_timer_interrupt(struct pt_regs *);
-extern void smp_spurious_interrupt(struct pt_regs *);
-extern void smp_x86_platform_ipi(struct pt_regs *);
-extern void smp_error_interrupt(struct pt_regs *);
+extern __visible void smp_apic_timer_interrupt(struct pt_regs *);
+extern __visible void smp_spurious_interrupt(struct pt_regs *);
+extern __visible void smp_x86_platform_ipi(struct pt_regs *);
+extern __visible void smp_error_interrupt(struct pt_regs *);
 #ifdef CONFIG_X86_IO_APIC
 extern asmlinkage void smp_irq_move_cleanup_interrupt(void);
 #endif
 #ifdef CONFIG_SMP
-extern void smp_reschedule_interrupt(struct pt_regs *);
-extern void smp_call_function_interrupt(struct pt_regs *);
-extern void smp_call_function_single_interrupt(struct pt_regs *);
-#ifdef CONFIG_X86_32
-extern void smp_invalidate_interrupt(struct pt_regs *);
-#else
-extern asmlinkage void smp_invalidate_interrupt(struct pt_regs *);
-#endif
+extern __visible void smp_reschedule_interrupt(struct pt_regs *);
+extern __visible void smp_call_function_interrupt(struct pt_regs *);
+extern __visible void smp_call_function_single_interrupt(struct pt_regs *);
+extern __visible void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
 extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);

commit cf910e83ae23692fdeefc7e506e504c4c468d38a
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Thu Jun 20 11:46:53 2013 -0400

    x86, trace: Add irq vector tracepoints
    
    [Purpose of this patch]
    
    As Vaibhav explained in the thread below, tracepoints for irq vectors
    are useful.
    
    http://www.spinics.net/lists/mm-commits/msg85707.html
    
    <snip>
    The current interrupt traces from irq_handler_entry and irq_handler_exit
    provide when an interrupt is handled.  They provide good data about when
    the system has switched to kernel space and how it affects the currently
    running processes.
    
    There are some IRQ vectors which trigger the system into kernel space,
    which are not handled in generic IRQ handlers.  Tracing such events gives
    us the information about IRQ interaction with other system events.
    
    The trace also tells where the system is spending its time.  We want to
    know which cores are handling interrupts and how they are affecting other
    processes in the system.  Also, the trace provides information about when
    the cores are idle and which interrupts are changing that state.
    <snip>
    
    On the other hand, my usecase is tracing just local timer event and
    getting a value of instruction pointer.
    
    I suggested to add an argument local timer event to get instruction pointer before.
    But there is another way to get it with external module like systemtap.
    So, I don't need to add any argument to irq vector tracepoints now.
    
    [Patch Description]
    
    Vaibhav's patch shared a trace point ,irq_vector_entry/irq_vector_exit, in all events.
    But there is an above use case to trace specific irq_vector rather than tracing all events.
    In this case, we are concerned about overhead due to unwanted events.
    
    So, add following tracepoints instead of introducing irq_vector_entry/exit.
    so that we can enable them independently.
       - local_timer_vector
       - reschedule_vector
       - call_function_vector
       - call_function_single_vector
       - irq_work_entry_vector
       - error_apic_vector
       - thermal_apic_vector
       - threshold_apic_vector
       - spurious_apic_vector
       - x86_platform_ipi_vector
    
    Also, introduce a logic switching IDT at enabling/disabling time so that a time penalty
    makes a zero when tracepoints are disabled. Detailed explanations are as follows.
     - Create trace irq handlers with entering_irq()/exiting_irq().
     - Create a new IDT, trace_idt_table, at boot time by adding a logic to
       _set_gate(). It is just a copy of original idt table.
     - Register the new handlers for tracpoints to the new IDT by introducing
       macros to alloc_intr_gate() called at registering time of irq_vector handlers.
     - Add checking, whether irq vector tracing is on/off, into load_current_idt().
       This has to be done below debug checking for these reasons.
       - Switching to debug IDT may be kicked while tracing is enabled.
       - On the other hands, switching to trace IDT is kicked only when debugging
         is disabled.
    
    In addition, the new IDT is created only when CONFIG_TRACING is enabled to avoid being
    used for other purposes.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Link: http://lkml.kernel.org/r/51C323ED.5050708@hds.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1da97efad08a..e4ac559c4a24 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -77,6 +77,23 @@ extern void threshold_interrupt(void);
 extern void call_function_interrupt(void);
 extern void call_function_single_interrupt(void);
 
+#ifdef CONFIG_TRACING
+/* Interrupt handlers registered during init_IRQ */
+extern void trace_apic_timer_interrupt(void);
+extern void trace_x86_platform_ipi(void);
+extern void trace_error_interrupt(void);
+extern void trace_irq_work_interrupt(void);
+extern void trace_spurious_interrupt(void);
+extern void trace_thermal_interrupt(void);
+extern void trace_reschedule_interrupt(void);
+extern void trace_threshold_interrupt(void);
+extern void trace_call_function_interrupt(void);
+extern void trace_call_function_single_interrupt(void);
+#define trace_irq_move_cleanup_interrupt  irq_move_cleanup_interrupt
+#define trace_reboot_interrupt  reboot_interrupt
+#define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
+#endif /* CONFIG_TRACING */
+
 /* IOAPIC */
 #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 extern unsigned long io_apic_irqs;

commit d78f2664832f8d70e36422af9a10e44276dced48
Author: Yang Zhang <yang.z.zhang@Intel.com>
Date:   Thu Apr 11 19:25:11 2013 +0800

    KVM: VMX: Register a new IPI for posted interrupt
    
    Posted Interrupt feature requires a special IPI to deliver posted interrupt
    to guest. And it should has a high priority so the interrupt will not be
    blocked by others.
    Normally, the posted interrupt will be consumed by vcpu if target vcpu is
    running and transparent to OS. But in some cases, the interrupt will arrive
    when target vcpu is scheduled out. And host will see it. So we need to
    register a dump handler to handle it.
    
    Signed-off-by: Yang Zhang <yang.z.zhang@Intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Gleb Natapov <gleb@redhat.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 10a78c3d3d5a..1da97efad08a 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -28,6 +28,7 @@
 /* Interrupt handlers registered during init_IRQ */
 extern void apic_timer_interrupt(void);
 extern void x86_platform_ipi(void);
+extern void kvm_posted_intr_ipi(void);
 extern void error_interrupt(void);
 extern void irq_work_interrupt(void);
 

commit 9b1b0e42f54bc452817f4bb6a8d939afe4f04303
Author: Joerg Roedel <joro@8bytes.org>
Date:   Wed Sep 26 12:44:45 2012 +0200

    x86, io-apic: Move CONFIG_IRQ_REMAP code out of x86 core
    
    Move all the code to either to the header file
    asm/irq_remapping.h or to drivers/iommu/.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>
    Acked-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index fc89a2a9b04a..10a78c3d3d5a 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -127,6 +127,7 @@ struct irq_cfg {
 	u8			vector;
 	u8			move_in_progress : 1;
 #ifdef CONFIG_IRQ_REMAP
+	u8			remapped : 1;
 	union {
 		struct irq_2_iommu irq_2_iommu;
 		struct irq_2_irte  irq_2_irte;

commit 819508d302e5b6d6dacb5c3d5e4756091e32cc7d
Author: Joerg Roedel <joro@8bytes.org>
Date:   Wed Sep 26 12:44:44 2012 +0200

    x86, irq: Add data structure to keep AMD specific irq remapping information
    
    Add a data structure to store information the IOMMU driver
    can use to get from a 'struct irq_cfg' to the remapping
    entry.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>
    Acked-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index eb92a6ed2be7..fc89a2a9b04a 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -101,6 +101,7 @@ static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
 	irq_attr->polarity	= polarity;
 }
 
+/* Intel specific interrupt remapping information */
 struct irq_2_iommu {
 	struct intel_iommu *iommu;
 	u16 irte_index;
@@ -108,6 +109,12 @@ struct irq_2_iommu {
 	u8  irte_mask;
 };
 
+/* AMD specific interrupt remapping information */
+struct irq_2_irte {
+	u16 devid; /* Device ID for IRTE table */
+	u16 index; /* Index into IRTE table*/
+};
+
 /*
  * This is performance-critical, we want to do it O(1)
  *
@@ -120,7 +127,10 @@ struct irq_cfg {
 	u8			vector;
 	u8			move_in_progress : 1;
 #ifdef CONFIG_IRQ_REMAP
-	struct irq_2_iommu	irq_2_iommu;
+	union {
+		struct irq_2_iommu irq_2_iommu;
+		struct irq_2_irte  irq_2_irte;
+	};
 #endif
 };
 

commit d3f138106b4b40640dc667f0222fd9f137387b32
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Aug 23 17:05:25 2011 -0700

    iommu: Rename the DMAR and INTR_REMAP config options
    
    Change the CONFIG_DMAR to CONFIG_INTEL_IOMMU to be consistent
    with the other IOMMU options.
    
    Rename the CONFIG_INTR_REMAP to CONFIG_IRQ_REMAP to match the
    irq subsystem name.
    
    And define the CONFIG_DMAR_TABLE for the common ACPI DMAR
    routines shared by both CONFIG_INTEL_IOMMU and CONFIG_IRQ_REMAP.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: yinghai@kernel.org
    Cc: youquan.song@intel.com
    Cc: joerg.roedel@amd.com
    Cc: tony.luck@intel.com
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/20110824001456.558630224@sbsiddha-desk.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 09199052060f..eb92a6ed2be7 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -119,7 +119,7 @@ struct irq_cfg {
 	cpumask_var_t		old_domain;
 	u8			vector;
 	u8			move_in_progress : 1;
-#ifdef CONFIG_INTR_REMAP
+#ifdef CONFIG_IRQ_REMAP
 	struct irq_2_iommu	irq_2_iommu;
 #endif
 };

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 13f5504c76c0..09199052060f 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -21,7 +21,7 @@
 #include <linux/profile.h>
 #include <linux/smp.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/irq.h>
 #include <asm/sections.h>
 

commit b77e70bf3535e0bd5472e0681f41cce4ae0598bb
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Wed Jun 8 10:56:02 2011 +0900

    x86, mce: Replace MCE_SELF_VECTOR by irq_work
    
    The MCE handler uses a special vector for self IPI to invoke
    post-emergency processing in an interrupt context, e.g. call an
    NMI-unsafe function, wakeup loggers, schedule time-consuming work for
    recovery, etc.
    
    This mechanism is now generalized by the following commit:
    
     > e360adbe29241a0194e10e20595360dd7b98a2b3
     > Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
     > Date:   Thu Oct 14 14:01:34 2010 +0800
     >
     >  irq_work: Add generic hardirq context callbacks
     >
     >  Provide a mechanism that allows running code in IRQ context. It is
     >  most useful for NMI code that needs to interact with the rest of the
     >  system -- like wakeup a task to drain buffers.
     :
    
    So change to use provided generic mechanism.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Link: http://lkml.kernel.org/r/4DEED6B2.6080005@jp.fujitsu.com
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index bb9efe8706e2..13f5504c76c0 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -34,7 +34,6 @@ extern void irq_work_interrupt(void);
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);
 extern void reschedule_interrupt(void);
-extern void mce_self_interrupt(void);
 
 extern void invalidate_interrupt(void);
 extern void invalidate_interrupt0(void);

commit 3a09fb4570a1cce11472b8e5da3f6ee409f529d5
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Jan 17 10:52:05 2011 +0800

    x86: Allocate 32 tlb_invalidate_interrupt handler stubs
    
    Add up to 32 invalidate_interrupt handlers. How many handlers are
    added depends on NUM_INVALIDATE_TLB_VECTORS. So if
    NUM_INVALIDATE_TLB_VECTORS is smaller than 32, we reduce code
    size.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    LKML-Reference: <1295232725.1949.708.camel@sli10-conroe>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 0274ec5a7e62..bb9efe8706e2 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -45,6 +45,30 @@ extern void invalidate_interrupt4(void);
 extern void invalidate_interrupt5(void);
 extern void invalidate_interrupt6(void);
 extern void invalidate_interrupt7(void);
+extern void invalidate_interrupt8(void);
+extern void invalidate_interrupt9(void);
+extern void invalidate_interrupt10(void);
+extern void invalidate_interrupt11(void);
+extern void invalidate_interrupt12(void);
+extern void invalidate_interrupt13(void);
+extern void invalidate_interrupt14(void);
+extern void invalidate_interrupt15(void);
+extern void invalidate_interrupt16(void);
+extern void invalidate_interrupt17(void);
+extern void invalidate_interrupt18(void);
+extern void invalidate_interrupt19(void);
+extern void invalidate_interrupt20(void);
+extern void invalidate_interrupt21(void);
+extern void invalidate_interrupt22(void);
+extern void invalidate_interrupt23(void);
+extern void invalidate_interrupt24(void);
+extern void invalidate_interrupt25(void);
+extern void invalidate_interrupt26(void);
+extern void invalidate_interrupt27(void);
+extern void invalidate_interrupt28(void);
+extern void invalidate_interrupt29(void);
+extern void invalidate_interrupt30(void);
+extern void invalidate_interrupt31(void);
 
 extern void irq_move_cleanup_interrupt(void);
 extern void reboot_interrupt(void);

commit 4a60cfa9457749f7987fd4f3c956dbba5a281129
Merge: 62bea97f54d8 27afdf2008da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 14:11:46 2010 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (96 commits)
      apic, x86: Use BIOS settings for IBS and MCE threshold interrupt LVT offsets
      apic, x86: Check if EILVT APIC registers are available (AMD only)
      x86: ioapic: Call free_irte only if interrupt remapping enabled
      arm: Use ARCH_IRQ_INIT_FLAGS
      genirq, ARM: Fix boot on ARM platforms
      genirq: Fix CONFIG_GENIRQ_NO_DEPRECATED=y build
      x86: Switch sparse_irq allocations to GFP_KERNEL
      genirq: Switch sparse_irq allocator to GFP_KERNEL
      genirq: Make sparse_lock a mutex
      x86: lguest: Use new irq allocator
      genirq: Remove the now unused sparse irq leftovers
      genirq: Sanitize dynamic irq handling
      genirq: Remove arch_init_chip_data()
      x86: xen: Sanitise sparse_irq handling
      x86: Use sane enumeration
      x86: uv: Clean up the direct access to irq_desc
      x86: Make io_apic.c local functions static
      genirq: Remove irq_2_iommu
      x86: Speed up the irq_remapped check in hot pathes
      intr_remap: Simplify the code further
      ...
    
    Fix up trivial conflicts in arch/x86/Kconfig

commit e360adbe29241a0194e10e20595360dd7b98a2b3
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Thu Oct 14 14:01:34 2010 +0800

    irq_work: Add generic hardirq context callbacks
    
    Provide a mechanism that allows running code in IRQ context. It is
    most useful for NMI code that needs to interact with the rest of the
    system -- like wakeup a task to drain buffers.
    
    Perf currently has such a mechanism, so extract that and provide it as
    a generic feature, independent of perf so that others may also
    benefit.
    
    The IRQ context callback is generated through self-IPIs where
    possible, or on architectures like powerpc the decrementer (the
    built-in timer facility) is set to generate an interrupt immediately.
    
    Architectures that don't have anything like this get to do with a
    callback from the timer tick. These architectures can call
    irq_work_run() at the tail of any IRQ handlers that might enqueue such
    work (like the perf IRQ handler) to avoid undue latencies in
    processing the work.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Kyle McMartin <kyle@mcmartin.ca>
    Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    [ various fixes ]
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    LKML-Reference: <1287036094.7768.291.camel@yhuang-dev>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 46c0fe05f230..3a54a1ca1a02 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -29,7 +29,7 @@
 extern void apic_timer_interrupt(void);
 extern void x86_platform_ipi(void);
 extern void error_interrupt(void);
-extern void perf_pending_interrupt(void);
+extern void irq_work_interrupt(void);
 
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);

commit 48b2650196364e4ef124efb841b63c2326e4ccb2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 30 11:43:08 2010 +0200

    x86: uv: Clean up the direct access to irq_desc
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index e756c4bfed94..d5905fd8ba41 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -101,7 +101,6 @@ struct irq_cfg {
 #endif
 };
 
-extern struct irq_cfg *irq_cfg(unsigned int);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 extern void send_cleanup_vector(struct irq_cfg *);
 

commit 423f085952fd7253407cb92984cc2d495a564481
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 10 11:39:09 2010 +0200

    x86: Embedd irq_2_iommu into irq_cfg
    
    That interrupt remapping code is x86 specific and tied to the io_apic
    code. No need for separate allocator functions in the interrupt
    remapping code. This allows to simplify the code and irq_2_iommu is
    small (13 bytes on 64bit) so it's not a real problem even if interrupt
    remapping is runtime disabled. If it's compile time disabled the
    impact is zero.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 76848f27b1ac..e756c4bfed94 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -78,6 +78,13 @@ static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
 	irq_attr->polarity	= polarity;
 }
 
+struct irq_2_iommu {
+	struct intel_iommu *iommu;
+	u16 irte_index;
+	u16 sub_handle;
+	u8  irte_mask;
+};
+
 /*
  * This is performance-critical, we want to do it O(1)
  *
@@ -89,6 +96,9 @@ struct irq_cfg {
 	cpumask_var_t		old_domain;
 	u8			vector;
 	u8			move_in_progress : 1;
+#ifdef CONFIG_INTR_REMAP
+	struct irq_2_iommu	irq_2_iommu;
+#endif
 };
 
 extern struct irq_cfg *irq_cfg(unsigned int);

commit f7e909eae444ff733ecc5628af76d89c363ab480
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 8 21:40:23 2010 +0200

    x86: Prepare the affinity common functions for taking struct irq_data *
    
    While at it rename it to sensible function names and fix the return
    value from unsigned to int for __ioapic_set_affinity (set_desc_affinity).
    Returning -1 in a function returning unsigned int is somewhat strange.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 46c0fe05f230..76848f27b1ac 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -95,9 +95,9 @@ extern struct irq_cfg *irq_cfg(unsigned int);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 extern void send_cleanup_vector(struct irq_cfg *);
 
-struct irq_desc;
-extern unsigned int set_desc_affinity(struct irq_desc *, const struct cpumask *,
-				      unsigned int *dest_id);
+struct irq_data;
+int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
+			  unsigned int *dest_id);
 extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 extern void setup_ioapic_dest(void);
 

commit 36e9e1eab777e077f7484d309ff676d0568e27d1
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 15 14:33:06 2010 -0800

    x86: Handle legacy PIC interrupts on all the cpu's
    
    Ingo Molnar reported that with the recent changes of not
    statically blocking IRQ0_VECTOR..IRQ15_VECTOR's on all the
    cpu's, broke an AMD platform (with Nvidia chipset) boot when
    "noapic" boot option is used.
    
    On this platform, legacy PIC interrupts are getting delivered to
    all the cpu's instead of just the boot cpu. Thus not
    initializing the vector to irq mapping for the legacy irq's
    resulted in not handling certain interrupts causing boot hang.
    
    Fix this by initializing the vector to irq mapping on all the
    logical cpu's, if the legacy IRQ is handled by the legacy PIC.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    [ -v2: io-apic-enabled improvement ]
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    LKML-Reference: <1268692386.3296.43.camel@sbs-t61.sc.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index a929c9ede33d..46c0fe05f230 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -133,6 +133,7 @@ extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
 
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);
+extern void setup_vector_irq(int cpu);
 
 #ifdef CONFIG_X86_IO_APIC
 extern void lock_vector_lock(void);

commit b81bb373a7e832a43921356aa1291044d7f52fb1
Author: Jacob Pan <jacob.jun.pan@intel.com>
Date:   Mon Nov 9 11:27:04 2009 -0800

    x86, pic: Make use of legacy_pic abstraction
    
    This patch replaces legacy PIC-related global variable and functions
    with the new legacy_pic abstraction.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    LKML-Reference: <43F901BD926A4E43B106BF17856F07559FB80D04@orsmsx508.amr.corp.intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index eeac829a0f44..a929c9ede33d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -53,13 +53,6 @@ extern void threshold_interrupt(void);
 extern void call_function_interrupt(void);
 extern void call_function_single_interrupt(void);
 
-/* PIC specific functions */
-extern void disable_8259A_irq(unsigned int irq);
-extern void enable_8259A_irq(unsigned int irq);
-extern int i8259A_irq_pending(unsigned int irq);
-extern void make_8259A_irq(unsigned int irq);
-extern void init_8259A(int aeoi);
-
 /* IOAPIC */
 #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 extern unsigned long io_apic_irqs;

commit 18374d89e5fe96772102f44f535efb1198d9be08
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Dec 17 18:29:46 2009 -0800

    x86, irq: Allow 0xff for /proc/irq/[n]/smp_affinity on an 8-cpu system
    
    John Blackwood reported:
    > on an older Dell PowerEdge 6650 system with 8 cpus (4 are hyper-threaded),
    > and  32 bit (x86) kernel, once you change the irq smp_affinity of an irq
    > to be less than all cpus in the system, you can never change really the
    > irq smp_affinity back to be all cpus in the system (0xff) again,
    > even though no error status is returned on the "/bin/echo ff >
    > /proc/irq/[n]/smp_affinity" operation.
    >
    > This is due to that fact that BAD_APICID has the same value as
    > all cpus (0xff) on 32bit kernels, and thus the value returned from
    > set_desc_affinity() via the cpu_mask_to_apicid_and() function is treated
    > as a failure in set_ioapic_affinity_irq_desc(), and no affinity changes
    > are made.
    
    set_desc_affinity() is already checking if the incoming cpu mask
    intersects with the cpu online mask or not. So there is no need
    for the apic op cpu_mask_to_apicid_and() to check again
    and return BAD_APICID.
    
    Remove the BAD_APICID return value from cpu_mask_to_apicid_and()
    and also fix set_desc_affinity() to return -1 instead of using BAD_APICID
    to represent error conditions (as cpu_mask_to_apicid_and() can return
    logical or physical apicid values and BAD_APICID is really to represent
    bad physical apic id).
    
    Reported-by: John Blackwood <john.blackwood@ccur.com>
    Root-caused-by: John Blackwood <john.blackwood@ccur.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    LKML-Reference: <1261103386.2535.409.camel@sbs-t61>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 08c48a81841f..eeac829a0f44 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -103,7 +103,8 @@ extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 extern void send_cleanup_vector(struct irq_cfg *);
 
 struct irq_desc;
-extern unsigned int set_desc_affinity(struct irq_desc *, const struct cpumask *);
+extern unsigned int set_desc_affinity(struct irq_desc *, const struct cpumask *,
+				      unsigned int *dest_id);
 extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 extern void setup_ioapic_dest(void);
 

commit 4646575daf21f544fc2f7e8d90d8c488948fcc7c
Merge: 86ed4aa457f9 581f202bcd60
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 13:38:21 2009 -0800

    Merge branch 'x86-uv-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-uv-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: UV RTC: Always enable RTC clocksource
      x86: UV RTC: Rename generic_interrupt to x86_platform_ipi
      x86: UV RTC: Clean up error handling
      x86: UV RTC: Add clocksource only boot option
      x86: UV RTC: Fix early expiry handling

commit 23359a88e7eca3c4f402562b102f23014db3c2aa
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Oct 26 14:24:33 2009 -0800

    x86: Remove move_cleanup_count from irq_cfg
    
    move_cleanup_count for each irq in irq_cfg is keeping track of
    the total number of cpus that need to free the corresponding
    vectors associated with the irq which has now been migrated to
    new destination. As long as this move_cleanup_count is non-zero
    (i.e., as long as we have n't freed the vector allocations on
    the old destinations) we were preventing the irq's further
    migration.
    
    This cleanup count is unnecessary and it is enough to not allow
    the irq migration till we send the cleanup vector to the
    previous irq destination, for which we already have irq_cfg's
    move_in_progress.  All we need to make sure is that we free the
    vector at the old desintation but we don't need to wait till
    that gets freed.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Gary Hade <garyhade@us.ibm.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    LKML-Reference: <20091026230001.752968906@sbs-t61.sc.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1984ce9a13d2..6e124269fd4b 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -94,7 +94,6 @@ struct irq_cfg {
 	struct irq_pin_list	*irq_2_pin;
 	cpumask_var_t		domain;
 	cpumask_var_t		old_domain;
-	unsigned		move_cleanup_count;
 	u8			vector;
 	u8			move_in_progress : 1;
 };

commit 4a4de9c7d7111ce4caf422b856756125d8304f9d
Author: Dimitri Sivanich <sivanich@sgi.com>
Date:   Wed Oct 14 09:22:57 2009 -0500

    x86: UV RTC: Rename generic_interrupt to x86_platform_ipi
    
    Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
    LKML-Reference: <20091014142257.GE11048@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index ba180d93b08c..95207ca5c6f1 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -27,7 +27,7 @@
 
 /* Interrupt handlers registered during init_IRQ */
 extern void apic_timer_interrupt(void);
-extern void generic_interrupt(void);
+extern void x86_platform_ipi(void);
 extern void error_interrupt(void);
 extern void perf_pending_interrupt(void);
 
@@ -101,7 +101,7 @@ extern void eisa_set_level_irq(unsigned int irq);
 /* SMP */
 extern void smp_apic_timer_interrupt(struct pt_regs *);
 extern void smp_spurious_interrupt(struct pt_regs *);
-extern void smp_generic_interrupt(struct pt_regs *);
+extern void smp_x86_platform_ipi(struct pt_regs *);
 extern void smp_error_interrupt(struct pt_regs *);
 #ifdef CONFIG_X86_IO_APIC
 extern asmlinkage void smp_irq_move_cleanup_interrupt(void);

commit 7ec13187ef48b04bb7f6dfa266c7271a52d009c2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Oct 14 15:06:42 2009 +0200

    x86, apic: Fix prototype in hw_irq.h
    
    This warning:
    
     In file included from arch/x86/include/asm/ipi.h:23,
                      from arch/x86/kernel/apic/apic_noop.c:27:
     arch/x86/include/asm/hw_irq.h:105: warning: struct irq_desc declared inside parameter list
     arch/x86/include/asm/hw_irq.h:105: warning: its scope is only this definition or declaration, which is probably not what you want
    
    triggers because irq_desc is defined after hw_irq.h is included
    in irq.h. Since it's pointer reference only, a forward declaration
    of the type will solve the problem.
    
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 56f0877c9329..1984ce9a13d2 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -102,6 +102,8 @@ struct irq_cfg {
 extern struct irq_cfg *irq_cfg(unsigned int);
 extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
 extern void send_cleanup_vector(struct irq_cfg *);
+
+struct irq_desc;
 extern unsigned int set_desc_affinity(struct irq_desc *, const struct cpumask *);
 extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 extern void setup_ioapic_dest(void);

commit 9338ad6ffb70eca97f335d93c54943828c8b209e
Author: Dimitri Sivanich <sivanich@sgi.com>
Date:   Tue Oct 13 15:32:36 2009 -0500

    x86, apic: Move SGI UV functionality out of generic IO-APIC code
    
    Move UV specific functionality out of the generic IO-APIC code.
    
    Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
    LKML-Reference: <20091013203236.GD20543@sgi.com>
    [ Cleaned up the code some more in their new places. ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index ba180d93b08c..56f0877c9329 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -79,14 +79,31 @@ static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
 					int ioapic, int ioapic_pin,
 					int trigger, int polarity)
 {
-	irq_attr->ioapic     = ioapic;
-	irq_attr->ioapic_pin = ioapic_pin;
-	irq_attr->trigger    = trigger;
-	irq_attr->polarity   = polarity;
+	irq_attr->ioapic	= ioapic;
+	irq_attr->ioapic_pin	= ioapic_pin;
+	irq_attr->trigger	= trigger;
+	irq_attr->polarity	= polarity;
 }
 
-extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin,
-					struct io_apic_irq_attr *irq_attr);
+/*
+ * This is performance-critical, we want to do it O(1)
+ *
+ * Most irqs are mapped 1:1 with pins.
+ */
+struct irq_cfg {
+	struct irq_pin_list	*irq_2_pin;
+	cpumask_var_t		domain;
+	cpumask_var_t		old_domain;
+	unsigned		move_cleanup_count;
+	u8			vector;
+	u8			move_in_progress : 1;
+};
+
+extern struct irq_cfg *irq_cfg(unsigned int);
+extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
+extern void send_cleanup_vector(struct irq_cfg *);
+extern unsigned int set_desc_affinity(struct irq_desc *, const struct cpumask *);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 extern void setup_ioapic_dest(void);
 
 extern void enable_IO_APIC(void);

commit 0d5959723e1db3fd7323c198a50c16cecf96c7a9
Merge: 62fdac5913f7 512626a04e72
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 11 23:31:52 2009 +0200

    Merge branch 'linus' into x86/mce3
    
    Conflicts:
            arch/x86/kernel/cpu/mcheck/mce_64.c
            arch/x86/kernel/irq.c
    
    Merge reason: Resolve the conflicts above.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 940010c5a314a7bd9b498593bc6ba1718ac5aec5
Merge: 8dc8e5e8bc0c 991ec02cdca3
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 11 17:55:42 2009 +0200

    Merge branch 'linus' into perfcounters/core
    
    Conflicts:
            arch/x86/kernel/irqinit.c
            arch/x86/kernel/irqinit_64.c
            arch/x86/kernel/traps.c
            arch/x86/mm/fault.c
            include/linux/sched.h
            kernel/exit.c

commit 7dc3ca39cb1e22eedbf1207ff9ac7bf682fc0f6d
Merge: aa98936e4f42 a4046f8d299e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 15:49:36 2009 -0700

    Merge branch 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, nmi: Use predefined numbers instead of hardcoded one
      x86: asm/processor.h: remove double declaration
      x86, mtrr: replace MTRRdefType_MSR with msr-index's MSR_MTRRdefType
      x86, mtrr: replace MTRRfix4K_C0000_MSR with msr-index's MSR_MTRRfix4K_C0000
      x86, mtrr: remove mtrr MSRs double declaration
      x86, mtrr: replace MTRRfix16K_80000_MSR with msr-index's MSR_MTRRfix16K_80000
      x86, mtrr: replace MTRRfix64K_00000_MSR with msr-index's MSR_MTRRfix64K_00000
      x86, mtrr: replace MTRRcap_MSR with msr-index's MSR_MTRRcap
      x86: mce: remove duplicated #include
      x86: msr-index.h remove duplicate MSR C001_0015 declaration
      x86: clean up arch/x86/kernel/tsc_sync.c a bit
      x86: use symbolic name for VM86_SIGNAL when used as vm86 default return
      x86: added 'ifndef _ASM_X86_IOMAP_H' to iomap.h
      x86: avoid multiple declaration of kstack_depth_to_print
      x86: vdso/vma.c declare vdso_enabled and arch_setup_additional_pages before they get used
      x86: clean up declarations and variables
      x86: apic/x2apic_cluster.c x86_cpu_to_logical_apicid should be static
      x86 early quirks: eliminate unused function

commit 4ef702c10b5df18ab04921fc252c26421d4d6c75
Author: Andi Kleen <andi@firstfloor.org>
Date:   Wed May 27 21:56:52 2009 +0200

    x86: fix panic with interrupts off (needed for MCE)
    
    For some time each panic() called with interrupts disabled
    triggered the !irqs_disabled() WARN_ON in smp_call_function(),
    producing ugly backtraces and confusing users.
    
    This is a common situation with machine checks for example which
    tend to call panic with interrupts disabled, but will also hit
    in other situations e.g. panic during early boot.  In fact it
    means that panic cannot be called in many circumstances, which
    would be bad.
    
    This all started with the new fancy queued smp_call_function,
    which is then used by the shutdown path to shut down the other
    CPUs.
    
    On closer examination it turned out that the fancy RCU
    smp_call_function() does lots of things not suitable in a panic
    situation anyways, like allocating memory and relying on complex
    system state.
    
    I originally tried to patch this over by checking for panic
    there, but it was quite complicated and the original patch
    was also not very popular.  This also didn't fix some of the
    underlying complexity problems.
    
    The new code in post 2.6.29 tries to patch around this by
    checking for oops_in_progress, but that is not enough to make
    this fully safe and I don't think that's a real solution
    because panic has to be reliable.
    
    So instead use an own vector to reboot.  This makes the reboot
    code extremly straight forward, which is definitely a big plus
    in a panic situation where it is important to avoid relying on
    too much kernel state.  The new simple code is also safe to be
    called from interupts off region because it is very very simple.
    
    There can be situations where it is important that panic
    is reliable.  For example on a fatal machine check the panic
    is needed to get the system up again and running as quickly
    as possible.  So it's important that panic is reliable and
    all function it calls simple.
    
    This is why I came up with this simple vector scheme.
    It's very hard to beat in simplicity.  Vectors are not
    particularly precious anymore since all big systems are
    using per CPU vectors.
    
    Another possibility would have been to use an NMI similar
    to kdump, but there is still the problem that NMIs don't
    work reliably on some systems due to BIOS issues.  NMIs
    would have been able to stop CPUs running with interrupts
    off too.  In the sake of universal reliability I opted for
    using a non NMI vector for now.
    
    I put the reboot vector into the highest priority bucket of
    the APIC vectors and moved the 64bit UV_BAU message down
    instead into the next lower priority.
    
    [ Impact: bug fix, fixes an old regression ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 4e59197e29ba..1c8f28a63058 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -45,6 +45,7 @@ extern void invalidate_interrupt6(void);
 extern void invalidate_interrupt7(void);
 
 extern void irq_move_cleanup_interrupt(void);
+extern void reboot_interrupt(void);
 extern void threshold_interrupt(void);
 
 extern void call_function_interrupt(void);

commit ccc3c3192ae78dd56dcdf5353fd1a9ef5f9a3e2b
Author: Andi Kleen <andi@firstfloor.org>
Date:   Wed May 27 21:56:54 2009 +0200

    x86, mce: implement bootstrapping for machine check wakeups
    
    Machine checks support waking up the mcelog daemon quickly.
    
    The original wake up code for this was pretty ugly, relying on
    a idle notifier and a special process flag. The reason it did
    it this way is that the machine check handler is not subject
    to normal interrupt locking rules so it's not safe
    to call wake_up().  Instead it set a process flag
    and then either did the wakeup in the syscall return
    or in the idle notifier.
    
    This patch adds a new "bootstraping" method as replacement.
    
    The idea is that the handler checks if it's in a state where
    it is unsafe to call wake_up(). If it's safe it calls it directly.
    When it's not safe -- that is it interrupted in a critical
    section with interrupts disables -- it uses a new "self IPI" to trigger
    an IPI to its own CPU. This can be done safely because IPI
    triggers are atomic with some care. The IPI is raised
    once the interrupts are reenabled and can then safely call
    wake_up().
    
    When APICs are disabled the event is just queued and will be picked up
    eventually by the next polling timer. I think that's a reasonable
    compromise, since it should only happen quite rarely.
    
    Contains fixes from Ying Huang.
    
    [ solve conflict on irqinit, make it work on 32bit (entry_arch.h) - HS ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index a7d14bbae110..4e59197e29ba 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -32,6 +32,7 @@ extern void error_interrupt(void);
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);
 extern void reschedule_interrupt(void);
+extern void mce_self_interrupt(void);
 
 extern void invalidate_interrupt(void);
 extern void invalidate_interrupt0(void);

commit a32881066e58346f2901afe0ebdfbf0c562877e5
Author: Yong Wang <yong.y.wang@linux.intel.com>
Date:   Wed Jun 3 13:12:55 2009 +0800

    perf_counter/x86: Remove the IRQ (non-NMI) handling bits
    
    Remove the IRQ (non-NMI) handling bits as NMI will be used always.
    
    Signed-off-by: Yong Wang <yong.y.wang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: John Kacur <jkacur@redhat.com>
    LKML-Reference: <20090603051255.GA2791@ywang-moblin2.bj.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 7309c0ad6902..4b4921d7a28e 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -29,7 +29,6 @@
 extern void apic_timer_interrupt(void);
 extern void generic_interrupt(void);
 extern void error_interrupt(void);
-extern void perf_counter_interrupt(void);
 extern void perf_pending_interrupt(void);
 
 extern void spurious_interrupt(void);

commit e5198075c67a22ec9a09565b1ce88d3d3f5ba855
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri May 15 13:05:16 2009 -0700

    x86, apic: introduce io_apic_irq_attr
    
    according to Ingo, io_apic irq-setup related functions have too many
    parameters with a repetitive signature.
    
    So reduce related funcs to get less params by passing a pointer
    to a newly defined io_apic_irq_attr structure.
    
    v2: io_apic_irq ==> irq_attr
        triggering ==> trigger
    
    v3: add set_io_apic_irq_attr
    
    [ Impact: cleanup ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Len Brown <lenb@kernel.org>
    LKML-Reference: <4A08ACD3.2070401@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 26a40ab70131..a7d14bbae110 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -63,9 +63,26 @@ extern unsigned long io_apic_irqs;
 extern void init_VISWS_APIC_irqs(void);
 extern void setup_IO_APIC(void);
 extern void disable_IO_APIC(void);
+
+struct io_apic_irq_attr {
+	int ioapic;
+	int ioapic_pin;
+	int trigger;
+	int polarity;
+};
+
+static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
+					int ioapic, int ioapic_pin,
+					int trigger, int polarity)
+{
+	irq_attr->ioapic     = ioapic;
+	irq_attr->ioapic_pin = ioapic_pin;
+	irq_attr->trigger    = trigger;
+	irq_attr->polarity   = polarity;
+}
+
 extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin,
-					int *ioapic, int *ioapic_pin,
-					int *trigger, int *polarity);
+					struct io_apic_irq_attr *irq_attr);
 extern void setup_ioapic_dest(void);
 
 extern void enable_IO_APIC(void);

commit e20c06fd6950265a899edd96a02dc2e6ae2d1ce5
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed May 6 10:08:22 2009 -0700

    x86/pci: add 4 more return parameters to IO_APIC_get_PCI_irq_vector()
    
    To prepare those params for pcibios_irq_enable() to call setup_io_apic_routing().
    
    [ Impact: extend function call API to prepare for new functionality ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <4A01C406.2040303@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b762ea49bd70..26a40ab70131 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -63,7 +63,9 @@ extern unsigned long io_apic_irqs;
 extern void init_VISWS_APIC_irqs(void);
 extern void setup_IO_APIC(void);
 extern void disable_IO_APIC(void);
-extern int IO_APIC_get_PCI_irq_vector(int bus, int slot, int fn);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin,
+					int *ioapic, int *ioapic_pin,
+					int *trigger, int *polarity);
 extern void setup_ioapic_dest(void);
 
 extern void enable_IO_APIC(void);

commit 2c1b284e4fa260fd922b9a65c99169e2630c6862
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Sat Apr 11 00:03:10 2009 +0530

    x86: clean up declarations and variables
    
    Impact: cleanup, no code changed
    
     - syscalls.h       update declarations due to unifications
     - irq.c            declare smp_generic_interrupt() before it gets used
     - process.c        declare sys_fork() and sys_vfork() before they get used
     - tsc.c            rename tsc_khz shadowed variable
     - apic/probe_32.c  declare apic_default before it gets used
     - apic/nmi.c       prev_nmi_count should be unsigned
     - apic/io_apic.c   declare smp_irq_move_cleanup_interrupt() before it gets used
     - mm/init.c        declare direct_gbpages and free_initrd_mem before they get used
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinder@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b762ea49bd70..be9ae4111c94 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -78,7 +78,11 @@ extern void eisa_set_level_irq(unsigned int irq);
 /* SMP */
 extern void smp_apic_timer_interrupt(struct pt_regs *);
 extern void smp_spurious_interrupt(struct pt_regs *);
+extern void smp_generic_interrupt(struct pt_regs *);
 extern void smp_error_interrupt(struct pt_regs *);
+#ifdef CONFIG_X86_IO_APIC
+extern asmlinkage void smp_irq_move_cleanup_interrupt(void);
+#endif
 #ifdef CONFIG_SMP
 extern void smp_reschedule_interrupt(struct pt_regs *);
 extern void smp_call_function_interrupt(struct pt_regs *);

commit b6276f353bf490add62dcf7db0ebd75baa3e1a37
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Apr 6 11:45:03 2009 +0200

    perf_counter: x86: self-IPI for pending work
    
    Implement set_perf_counter_pending() with a self-IPI so that it will
    run ASAP in a usable context.
    
    For now use a second IRQ vector, because the primary vector pokes
    the apic in funny ways that seem to confuse things.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    LKML-Reference: <20090406094517.724626696@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index ae80f64973e0..7309c0ad6902 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -30,6 +30,7 @@ extern void apic_timer_interrupt(void);
 extern void generic_interrupt(void);
 extern void error_interrupt(void);
 extern void perf_counter_interrupt(void);
+extern void perf_pending_interrupt(void);
 
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);

commit f541ae326fa120fa5c57433e4d9a133df212ce41
Merge: e255357764f9 0221c81b1b8e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Apr 6 09:02:57 2009 +0200

    Merge branch 'linus' into perfcounters/core-v2
    
    Merge reason: we have gathered quite a few conflicts, need to merge upstream
    
    Conflicts:
            arch/powerpc/kernel/Makefile
            arch/x86/ia32/ia32entry.S
            arch/x86/include/asm/hardirq.h
            arch/x86/include/asm/unistd_32.h
            arch/x86/include/asm/unistd_64.h
            arch/x86/kernel/cpu/common.c
            arch/x86/kernel/irq.c
            arch/x86/kernel/syscall_table_32.S
            arch/x86/mm/iomap_32.c
            include/linux/sched.h
            kernel/Makefile
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit acaabe795a62bba089c185917af86b44654313dc
Author: Dimitri Sivanich <sivanich@sgi.com>
Date:   Wed Mar 4 12:56:05 2009 -0600

    x86: UV, SGI RTC: add generic system vector
    
    This patch allocates a system interrupt vector for various platform
    specific uses.
    
    Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: john stultz <johnstul@us.ibm.com>
    LKML-Reference: <20090304185605.GA24419@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 370e1c83bb49..b762ea49bd70 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -27,6 +27,7 @@
 
 /* Interrupt handlers registered during init_IRQ */
 extern void apic_timer_interrupt(void);
+extern void generic_interrupt(void);
 extern void error_interrupt(void);
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);

commit b1864e9a1afef41709886072c6e6248def0386f4
Merge: e9c4ffb11f0b 7032e8696726
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Feb 13 09:49:38 2009 +0100

    Merge branch 'x86/core' into perfcounters/core
    
    Conflicts:
            arch/x86/Kconfig
            arch/x86/kernel/apic.c
            arch/x86/kernel/setup_percpu.c

commit bf56957d176c279175464f385f3eb03d65819328
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Feb 9 12:05:48 2009 -0800

    xen: expose enable_IO_APIC for 32-bit
    
    enable_IO_APIC() is defined for both 32- and 64-bit x86, so it should
    be declared for both.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1b82781b898d..370e1c83bb49 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -65,9 +65,7 @@ extern void disable_IO_APIC(void);
 extern int IO_APIC_get_PCI_irq_vector(int bus, int slot, int fn);
 extern void setup_ioapic_dest(void);
 
-#ifdef CONFIG_X86_64
 extern void enable_IO_APIC(void);
-#endif
 
 /* Statistics */
 extern atomic_t irq_err_count;

commit abcaa2b8319a7673e76c2391cb5de3045ab1b401
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Feb 8 16:18:03 2009 -0800

    x86: use NR_IRQS_LEGACY to replace 16
    
    Impact: cleanup
    
    also could kill platform_legacy_irq
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 1a20e3d12006..1b82781b898d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -25,8 +25,6 @@
 #include <asm/irq.h>
 #include <asm/sections.h>
 
-#define platform_legacy_irq(irq)	((irq) < 16)
-
 /* Interrupt handlers registered during init_IRQ */
 extern void apic_timer_interrupt(void);
 extern void error_interrupt(void);
@@ -58,7 +56,7 @@ extern void make_8259A_irq(unsigned int irq);
 extern void init_8259A(int aeoi);
 
 /* IOAPIC */
-#define IO_APIC_IRQ(x) (((x) >= 16) || ((1<<(x)) & io_apic_irqs))
+#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 extern unsigned long io_apic_irqs;
 
 extern void init_VISWS_APIC_irqs(void);

commit c5e954820335ef5aed1662b70aaf5deb9de16735
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 30 17:29:27 2009 -0800

    x86: move default_ipi_xx back to ipi.c
    
    Impact: cleanup
    
    only leave _default_ipi_xx etc in .h
    
    Beyond the cleanup factor, this saves a bit of code size as well:
    
        text           data     bss     dec             hex filename
     7281931        1630144 1463304 10375379         9e50d3 vmlinux.before
     7281753        1630144 1463304 10375201         9e5021 vmlinux.after
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 3ef2bded97ac..1a20e3d12006 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -71,12 +71,6 @@ extern void setup_ioapic_dest(void);
 extern void enable_IO_APIC(void);
 #endif
 
-/* IPI functions */
-#ifdef CONFIG_X86_32
-extern void default_send_IPI_self(int vector);
-#endif
-extern void default_send_IPI(int dest, int vector);
-
 /* Statistics */
 extern atomic_t irq_err_count;
 extern atomic_t irq_mis_count;

commit ed74ca6d5a3e57eb0969d4e14e46cf9f88d25d3f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Jan 31 02:16:04 2009 +0100

    x86, voyager: move Voyager-specific defines to voyager.h
    
    They dont belong into the generic headers.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 415507973968..3ef2bded97ac 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -84,16 +84,6 @@ extern atomic_t irq_mis_count;
 /* EISA */
 extern void eisa_set_level_irq(unsigned int irq);
 
-/* Voyager functions */
-extern asmlinkage void vic_cpi_interrupt(void);
-extern asmlinkage void vic_sys_interrupt(void);
-extern asmlinkage void vic_cmn_interrupt(void);
-extern asmlinkage void qic_timer_interrupt(void);
-extern asmlinkage void qic_invalidate_interrupt(void);
-extern asmlinkage void qic_reschedule_interrupt(void);
-extern asmlinkage void qic_enable_irq_interrupt(void);
-extern asmlinkage void qic_call_function_interrupt(void);
-
 /* SMP */
 extern void smp_apic_timer_interrupt(struct pt_regs *);
 extern void smp_spurious_interrupt(struct pt_regs *);

commit 3e5095d15276efd14a45393666b1bb7536bf179f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jan 27 17:07:08 2009 +0100

    x86: replace CONFIG_X86_SMP with CONFIG_SMP
    
    The x86/Voyager subarch used to have this distinction between
     'x86 SMP support' and 'Voyager SMP support':
    
     config X86_SMP
            bool
            depends on SMP && ((X86_32 && !X86_VOYAGER) || X86_64)
    
    This is a pointless distinction - Voyager can (and already does) use
    smp_ops to implement various SMP quirks it has - and it can be extended
    more to cover all the specialities of Voyager.
    
    So remove this complication in the Kconfig space.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index bfa921fad133..415507973968 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -98,7 +98,7 @@ extern asmlinkage void qic_call_function_interrupt(void);
 extern void smp_apic_timer_interrupt(struct pt_regs *);
 extern void smp_spurious_interrupt(struct pt_regs *);
 extern void smp_error_interrupt(struct pt_regs *);
-#ifdef CONFIG_X86_SMP
+#ifdef CONFIG_SMP
 extern void smp_reschedule_interrupt(struct pt_regs *);
 extern void smp_call_function_interrupt(struct pt_regs *);
 extern void smp_call_function_single_interrupt(struct pt_regs *);

commit dac5f4121df3c39fdb2ea57acd669a0ae19e46f8
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 28 15:42:24 2009 +0100

    x86, apic: untangle the send_IPI_*() jungle
    
    Our send_IPI_*() methods and definitions are a twisted mess: the same
    symbol is defined to different things depending on .config details,
    in a non-transparent way.
    
     - spread out the quirks into separately named per apic driver methods
    
     - prefix the standard PC methods with default_
    
     - get rid of wrapper macro obfuscation
    
     - clean up various details
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 8de644b6b959..bfa921fad133 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -73,9 +73,9 @@ extern void enable_IO_APIC(void);
 
 /* IPI functions */
 #ifdef CONFIG_X86_32
-extern void send_IPI_self(int vector);
+extern void default_send_IPI_self(int vector);
 #endif
-extern void send_IPI(int dest, int vector);
+extern void default_send_IPI(int dest, int vector);
 
 /* Statistics */
 extern atomic_t irq_err_count;

commit 241771ef016b5c0c83cd7a4372a74321c973c1e6
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Dec 3 10:39:53 2008 +0100

    performance counters: x86 support
    
    Implement performance counters for x86 Intel CPUs.
    
    It's simplified right now: the PERFMON CPU feature is assumed,
    which is available in Core2 and later Intel CPUs.
    
    The design is flexible to be extended to more CPU types as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 8de644b6b959..aa93e53b85ee 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -30,6 +30,8 @@
 /* Interrupt handlers registered during init_IRQ */
 extern void apic_timer_interrupt(void);
 extern void error_interrupt(void);
+extern void perf_counter_interrupt(void);
+
 extern void spurious_interrupt(void);
 extern void thermal_interrupt(void);
 extern void reschedule_interrupt(void);

commit 939b787130bf22887a09d8fd2641a094dcef8c22
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Nov 11 13:51:52 2008 -0800

    x86: 64 bits: shrink and align IRQ stubs
    
    Move the IRQ stub generation to assembly to simplify it and for
    consistency with 32 bits.  Doing it in a C file with asm() statements
    doesn't help clarity, and it prevents some optimizations.
    
    Shrink the IRQ stubs down to just over four bytes per (we fit seven
    into a 32-byte chunk.)  This shrinks the total icache consumption of
    the IRQ stubs down to an even kilobyte, if all of them are in active
    use.
    
    The downside is that we end up with a double jump, which could have a
    negative effect on some pipelines.  The double jump is always inside
    the same cacheline on any modern chips.
    
    To get the most effect, cache-align the IRQ stubs.
    
    This makes the 64-bit code match changes already done to the 32-bit
    code, and should open up irqinit*.c for unification.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 27d33f92afe2..8de644b6b959 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -109,9 +109,7 @@ extern asmlinkage void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 #endif
 
-#ifdef CONFIG_X86_32
 extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
-#endif
 
 typedef int vector_irq_t[NR_VECTORS];
 DECLARE_PER_CPU(vector_irq_t, vector_irq);

commit 4687518c4cb7807fbeff21770e309080f9eb7f2f
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Nov 11 13:03:07 2008 -0800

    x86: 32 bit: interrupt stub consistency with 64 bit
    
    Don't generate interrupt stubs for interrupt vectors below
    FIRST_EXTERNAL_VECTOR, and make the table of interrupt vectors
    (interrupt[]) __initconst.  Both of these changes both conserve memory
    and improve consistency with 64 bits.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index b97aecb0b61d..27d33f92afe2 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -110,7 +110,7 @@ extern asmlinkage void smp_invalidate_interrupt(struct pt_regs *);
 #endif
 
 #ifdef CONFIG_X86_32
-extern void (*const interrupt[NR_VECTORS])(void);
+extern void (*__initconst interrupt[NR_VECTORS-FIRST_EXTERNAL_VECTOR])(void);
 #endif
 
 typedef int vector_irq_t[NR_VECTORS];

commit 1965aae3c98397aad957412413c07e97b1bd4e64
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Oct 22 22:26:29 2008 -0700

    x86: Fix ASM_X86__ header guards
    
    Change header guards named "ASM_X86__*" to "_ASM_X86_*" since:
    
    a. the double underscore is ugly and pointless.
    b. no leading underscore violates namespace constraints.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index 749d042f0556..b97aecb0b61d 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -1,5 +1,5 @@
-#ifndef ASM_X86__HW_IRQ_H
-#define ASM_X86__HW_IRQ_H
+#ifndef _ASM_X86_HW_IRQ_H
+#define _ASM_X86_HW_IRQ_H
 
 /*
  * (C) 1992, 1993 Linus Torvalds, (C) 1997 Ingo Molnar
@@ -128,4 +128,4 @@ static inline void __setup_vector_irq(int cpu) {}
 
 #endif /* !ASSEMBLY_ */
 
-#endif /* ASM_X86__HW_IRQ_H */
+#endif /* _ASM_X86_HW_IRQ_H */

commit bb8985586b7a906e116db835c64773b7a7d51663
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 17 21:05:42 2008 -0400

    x86, um: ... and asm-x86 move
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
new file mode 100644
index 000000000000..749d042f0556
--- /dev/null
+++ b/arch/x86/include/asm/hw_irq.h
@@ -0,0 +1,131 @@
+#ifndef ASM_X86__HW_IRQ_H
+#define ASM_X86__HW_IRQ_H
+
+/*
+ * (C) 1992, 1993 Linus Torvalds, (C) 1997 Ingo Molnar
+ *
+ * moved some of the old arch/i386/kernel/irq.h to here. VY
+ *
+ * IRQ/IPI changes taken from work by Thomas Radke
+ * <tomsoft@informatik.tu-chemnitz.de>
+ *
+ * hacked by Andi Kleen for x86-64.
+ * unified by tglx
+ */
+
+#include <asm/irq_vectors.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/percpu.h>
+#include <linux/profile.h>
+#include <linux/smp.h>
+
+#include <asm/atomic.h>
+#include <asm/irq.h>
+#include <asm/sections.h>
+
+#define platform_legacy_irq(irq)	((irq) < 16)
+
+/* Interrupt handlers registered during init_IRQ */
+extern void apic_timer_interrupt(void);
+extern void error_interrupt(void);
+extern void spurious_interrupt(void);
+extern void thermal_interrupt(void);
+extern void reschedule_interrupt(void);
+
+extern void invalidate_interrupt(void);
+extern void invalidate_interrupt0(void);
+extern void invalidate_interrupt1(void);
+extern void invalidate_interrupt2(void);
+extern void invalidate_interrupt3(void);
+extern void invalidate_interrupt4(void);
+extern void invalidate_interrupt5(void);
+extern void invalidate_interrupt6(void);
+extern void invalidate_interrupt7(void);
+
+extern void irq_move_cleanup_interrupt(void);
+extern void threshold_interrupt(void);
+
+extern void call_function_interrupt(void);
+extern void call_function_single_interrupt(void);
+
+/* PIC specific functions */
+extern void disable_8259A_irq(unsigned int irq);
+extern void enable_8259A_irq(unsigned int irq);
+extern int i8259A_irq_pending(unsigned int irq);
+extern void make_8259A_irq(unsigned int irq);
+extern void init_8259A(int aeoi);
+
+/* IOAPIC */
+#define IO_APIC_IRQ(x) (((x) >= 16) || ((1<<(x)) & io_apic_irqs))
+extern unsigned long io_apic_irqs;
+
+extern void init_VISWS_APIC_irqs(void);
+extern void setup_IO_APIC(void);
+extern void disable_IO_APIC(void);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int slot, int fn);
+extern void setup_ioapic_dest(void);
+
+#ifdef CONFIG_X86_64
+extern void enable_IO_APIC(void);
+#endif
+
+/* IPI functions */
+#ifdef CONFIG_X86_32
+extern void send_IPI_self(int vector);
+#endif
+extern void send_IPI(int dest, int vector);
+
+/* Statistics */
+extern atomic_t irq_err_count;
+extern atomic_t irq_mis_count;
+
+/* EISA */
+extern void eisa_set_level_irq(unsigned int irq);
+
+/* Voyager functions */
+extern asmlinkage void vic_cpi_interrupt(void);
+extern asmlinkage void vic_sys_interrupt(void);
+extern asmlinkage void vic_cmn_interrupt(void);
+extern asmlinkage void qic_timer_interrupt(void);
+extern asmlinkage void qic_invalidate_interrupt(void);
+extern asmlinkage void qic_reschedule_interrupt(void);
+extern asmlinkage void qic_enable_irq_interrupt(void);
+extern asmlinkage void qic_call_function_interrupt(void);
+
+/* SMP */
+extern void smp_apic_timer_interrupt(struct pt_regs *);
+extern void smp_spurious_interrupt(struct pt_regs *);
+extern void smp_error_interrupt(struct pt_regs *);
+#ifdef CONFIG_X86_SMP
+extern void smp_reschedule_interrupt(struct pt_regs *);
+extern void smp_call_function_interrupt(struct pt_regs *);
+extern void smp_call_function_single_interrupt(struct pt_regs *);
+#ifdef CONFIG_X86_32
+extern void smp_invalidate_interrupt(struct pt_regs *);
+#else
+extern asmlinkage void smp_invalidate_interrupt(struct pt_regs *);
+#endif
+#endif
+
+#ifdef CONFIG_X86_32
+extern void (*const interrupt[NR_VECTORS])(void);
+#endif
+
+typedef int vector_irq_t[NR_VECTORS];
+DECLARE_PER_CPU(vector_irq_t, vector_irq);
+
+#ifdef CONFIG_X86_IO_APIC
+extern void lock_vector_lock(void);
+extern void unlock_vector_lock(void);
+extern void __setup_vector_irq(int cpu);
+#else
+static inline void lock_vector_lock(void) {}
+static inline void unlock_vector_lock(void) {}
+static inline void __setup_vector_irq(int cpu) {}
+#endif
+
+#endif /* !ASSEMBLY_ */
+
+#endif /* ASM_X86__HW_IRQ_H */
