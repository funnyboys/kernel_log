commit 248ed51048c40d36728e70914e38bffd7821da57
Author: Changbin Du <changbin.du@gmail.com>
Date:   Sat Jan 11 20:54:27 2020 +0800

    x86/nmi: Remove irq_work from the long duration NMI handler
    
    First, printk() is NMI-context safe now since the safe printk() has been
    implemented and it already has an irq_work to make NMI-context safe.
    
    Second, this NMI irq_work actually does not work if a NMI handler causes
    panic by watchdog timeout. It has no chance to run in such case, while
    the safe printk() will flush its per-cpu buffers before panicking.
    
    While at it, repurpose the irq_work callback into a function which
    concentrates the NMI duration checking and makes the code easier to
    follow.
    
     [ bp: Massage. ]
    
    Signed-off-by: Changbin Du <changbin.du@gmail.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200111125427.15662-1-changbin.du@gmail.com

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 75ded1d13d98..9d5d949e662e 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -41,7 +41,6 @@ struct nmiaction {
 	struct list_head	list;
 	nmi_handler_t		handler;
 	u64			max_duration;
-	struct irq_work		irq_work;
 	unsigned long		flags;
 	const char		*name;
 };

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 5f2fc4441b11..75ded1d13d98 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _ASM_X86_NMI_H
 #define _ASM_X86_NMI_H
 

commit e90c78535283dd0ded3bf2e484890d14dba2d527
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Feb 3 18:02:09 2014 +0100

    x86/nmi: Push duration printk() to irq context
    
    Calling printk() from NMI context is bad (TM), so move it to IRQ
    context.
    
    In doing so we slightly change (probably wreck) the debugfs
    nmi_longest_ns thingy, in that it doesn't update to reflect the
    longest, nor does writing to it reset the count.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Link: http://lkml.kernel.org/n/tip-rdw0au56a5ymis1u8p48c12d@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 86f9301903c8..5f2fc4441b11 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -1,6 +1,7 @@
 #ifndef _ASM_X86_NMI_H
 #define _ASM_X86_NMI_H
 
+#include <linux/irq_work.h>
 #include <linux/pm.h>
 #include <asm/irq.h>
 #include <asm/io.h>
@@ -38,6 +39,8 @@ typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);
 struct nmiaction {
 	struct list_head	list;
 	nmi_handler_t		handler;
+	u64			max_duration;
+	struct irq_work		irq_work;
 	unsigned long		flags;
 	const char		*name;
 };

commit b52e0a7c4e4100f8683af508664e60e1603070f9
Author: Michel Lespinasse <walken@google.com>
Date:   Thu Jun 6 04:41:15 2013 -0700

    x86: Fix trigger_all_cpu_backtrace() implementation
    
    The following change fixes the x86 implementation of
    trigger_all_cpu_backtrace(), which was previously (accidentally,
    as far as I can tell) disabled to always return false as on
    architectures that do not implement this function.
    
    trigger_all_cpu_backtrace(), as defined in include/linux/nmi.h,
    should call arch_trigger_all_cpu_backtrace() if available, or
    return false if the underlying arch doesn't implement this
    function.
    
    x86 did provide a suitable arch_trigger_all_cpu_backtrace()
    implementation, but it wasn't actually being used because it was
    declared in asm/nmi.h, which linux/nmi.h doesn't include. Also,
    linux/nmi.h couldn't easily be fixed by including asm/nmi.h,
    because that file is not available on all architectures.
    
    I am proposing to fix this by moving the x86 definition of
    arch_trigger_all_cpu_backtrace() to asm/irq.h.
    
    Tested via: echo l > /proc/sysrq-trigger
    
    Before the change, this uses a fallback implementation which
    shows backtraces on active CPUs (using
    smp_call_function_interrupt() )
    
    After the change, this shows NMI backtraces on all CPUs
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1370518875-1346-1-git-send-email-walken@google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c0fa356e90de..86f9301903c8 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -18,9 +18,7 @@ extern int proc_nmi_enabled(struct ctl_table *, int ,
 			void __user *, size_t *, loff_t *);
 extern int unknown_nmi_panic;
 
-void arch_trigger_all_cpu_backtrace(void);
-#define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
-#endif
+#endif /* CONFIG_X86_LOCAL_APIC */
 
 #define NMI_FLAG_FIRST	1
 

commit 0718467c859f5571dc48d294596f841096f6a47a
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Mon Jun 18 15:56:33 2012 -0400

    x86/nmi: Clean up register_nmi_handler() usage
    
    Implement a cleaner and easier to maintain version for the section
    warning fixes implemented in commit eeaaa96a3a21
    ("x86/nmi: Fix section mismatch warnings on 32-bit").
    
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Link: http://lkml.kernel.org/r/1340049393-17771-1-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index dc580c42851c..c0fa356e90de 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -44,28 +44,14 @@ struct nmiaction {
 	const char		*name;
 };
 
-#define register_nmi_handler(t, fn, fg, n)		\
+#define register_nmi_handler(t, fn, fg, n, init...)	\
 ({							\
-	static struct nmiaction fn##_na = {		\
+	static struct nmiaction init fn##_na = {	\
 		.handler = (fn),			\
 		.name = (n),				\
 		.flags = (fg),				\
 	};						\
-	__register_nmi_handler((t), &fn##_na);	\
-})
-
-/*
- * For special handlers that register/unregister in the
- * init section only.  This should be considered rare.
- */
-#define register_nmi_handler_initonly(t, fn, fg, n)		\
-({							\
-	static struct nmiaction fn##_na __initdata = {		\
-		.handler = (fn),			\
-		.name = (n),				\
-		.flags = (fg),				\
-	};						\
-	__register_nmi_handler((t), &fn##_na);	\
+	__register_nmi_handler((t), &fn##_na);		\
 })
 
 int __register_nmi_handler(unsigned int, struct nmiaction *);

commit eeaaa96a3a2134a174100afd129bb0891d05f4b2
Author: Don Zickus <dzickus@redhat.com>
Date:   Wed Jun 6 10:05:42 2012 -0400

    x86/nmi: Fix section mismatch warnings on 32-bit
    
    It was reported that compiling for 32-bit caused a bunch of
    section mismatch warnings:
    
     VDSOSYM arch/x86/vdso/vdso32-syms.lds
      LD      arch/x86/vdso/built-in.o
      LD      arch/x86/built-in.o
    
     WARNING: arch/x86/built-in.o(.data+0x5af0): Section mismatch in
     reference from the variable test_nmi_ipi_callback_na.10451 to
     the function .init.text:test_nmi_ipi_callback() [...]
    
     WARNING: arch/x86/built-in.o(.data+0x5b04): Section mismatch in
     reference from the variable nmi_unk_cb_na.10399 to the function
     .init.text:nmi_unk_cb() The variable nmi_unk_cb_na.10399
     references the function __init nmi_unk_cb() [...]
    
    Both of these are attributed to the internal representation of
    the nmiaction struct created during register_nmi_handler.  The
    reason for this is that those structs are not defined in the
    init section whereas the rest of the code in nmi_selftest.c is.
    
    To resolve this, I created a new #define,
    register_nmi_handler_initonly, that tags the struct as
    __initdata to resolve the mismatch.  This #define should only be
    used in rare situations where the register/unregister is called
    during init of the kernel.
    
    Big thanks to Jan Beulich for decoding this for me as I didn't
    have a clue what was going on.
    
    Reported-by: Witold Baryluk <baryluk@smp.if.uj.edu.pl>
    Tested-by: Witold Baryluk <baryluk@smp.if.uj.edu.pl>
    Cc: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Link: http://lkml.kernel.org/r/1338991542-23000-1-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 0e3793b821ef..dc580c42851c 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -54,6 +54,20 @@ struct nmiaction {
 	__register_nmi_handler((t), &fn##_na);	\
 })
 
+/*
+ * For special handlers that register/unregister in the
+ * init section only.  This should be considered rare.
+ */
+#define register_nmi_handler_initonly(t, fn, fg, n)		\
+({							\
+	static struct nmiaction fn##_na __initdata = {		\
+		.handler = (fn),			\
+		.name = (n),				\
+		.flags = (fg),				\
+	};						\
+	__register_nmi_handler((t), &fn##_na);	\
+})
+
 int __register_nmi_handler(unsigned int, struct nmiaction *);
 
 void unregister_nmi_handler(unsigned int, const char *);

commit 6ff968cca1dfebd4b6fcade87c11658dbfc96932
Author: Betty Dall <betty.dall@hp.com>
Date:   Fri Apr 27 14:40:55 2012 -0600

    x86/nmi: Fix the type of the nmiaction.flags field
    
    This patch changes the type of the struct nmiaction flags field
    to unsigned long from unsigned int. All the usages of the flags
    field are unsigned long already. There is only one flag used
    currently, NMI_FLAG_FIRST, but having the wrong size could cause
    a truncation bug in the future on 64 bit architectures.
    
    Signed-off-by: Betty Dall <betty.dall@hp.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Link: http://lkml.kernel.org/r/1335559255-13454-1-git-send-email-betty.dall@hp.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index a1a836c8131c..0e3793b821ef 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -40,7 +40,7 @@ typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);
 struct nmiaction {
 	struct list_head	list;
 	nmi_handler_t		handler;
-	unsigned int		flags;
+	unsigned long		flags;
 	const char		*name;
 };
 

commit 72b3fb24713755cf9740b403e95aa67ceedf3509
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Thu Mar 29 16:11:17 2012 -0400

    x86/nmi: Fix page faults by nmiaction if kmemcheck is enabled
    
    This patch tries to fix the problem of page fault exception
    caused by accessing nmiaction structure in nmi if kmemcheck
    is enabled.
    
    If kmemcheck is enabled, the memory allocated through slab are
    in pages that are marked non-present, so that some checks could
    be done in the page fault handling code ( e.g. whether the
    memory is read before written to ).
    
    As nmiaction is allocated in this way, so it resides in a
    non-present page. Then there is a page fault while the nmi code
    accessing the nmiaction structure, which would then cause a
    warning by WARN_ON_ONCE(in_nmi()) in kmemcheck_fault(), called
    by do_page_fault().
    
    This significantly simplifies the code as well, as the whole
    dynamic allocation dance goes away.
    
    v2: as Peter suggested, changed the nmiaction to use static
        storage.
    
    v3: as Peter suggested, use macro to shorten the codes. Also
        keep the original usage of register_nmi_handler, so users of
        this call doesn't need change.
    
    Tested-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Fixes: https://lkml.org/lkml/2012/3/2/356
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    [ simplified the wrappers ]
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: thomas.mingarelli@hp.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1333051877-15755-4-git-send-email-dzickus@redhat.com
    [ tidied the patch a bit ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 07162dfbff84..a1a836c8131c 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -37,8 +37,24 @@ enum {
 
 typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);
 
-int register_nmi_handler(unsigned int, nmi_handler_t, unsigned long,
-			 const char *);
+struct nmiaction {
+	struct list_head	list;
+	nmi_handler_t		handler;
+	unsigned int		flags;
+	const char		*name;
+};
+
+#define register_nmi_handler(t, fn, fg, n)		\
+({							\
+	static struct nmiaction fn##_na = {		\
+		.handler = (fn),			\
+		.name = (n),				\
+		.flags = (fg),				\
+	};						\
+	__register_nmi_handler((t), &fn##_na);	\
+})
+
+int __register_nmi_handler(unsigned int, struct nmiaction *);
 
 void unregister_nmi_handler(unsigned int, const char *);
 

commit 553222f3e81f18da31b2552e18dc519715198590
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Mar 29 16:11:16 2012 -0400

    x86/nmi: Add new NMI queues to deal with IO_CHK and SERR
    
    In discussions with Thomas Mingarelli about hpwdt, he explained
    to me some issues they were some when using their virtual NMI
    button to test the hpwdt driver.
    
    It turns out the virtual NMI button used on HP's machines do no
    send unknown NMIs but instead send IO_CHK NMIs.  The way the
    kernel code is written, the hpwdt driver can not register itself
    against that type of NMI and therefore can not successfully
    capture system information before panic'ing.
    
    To solve this I created two new NMI queues to allow driver to
    register against the IO_CHK and SERR NMIs.  Or in the hpwdt all
    three (if you include unknown NMIs too).
    
    The change is straightforward and just mimics what the unknown
    NMI does.
    
    Reported-and-tested-by: Thomas Mingarelli <thomas.mingarelli@hp.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1333051877-15755-3-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index fd3f9f18cf3f..07162dfbff84 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -27,6 +27,8 @@ void arch_trigger_all_cpu_backtrace(void);
 enum {
 	NMI_LOCAL=0,
 	NMI_UNKNOWN,
+	NMI_SERR,
+	NMI_IO_CHECK,
 	NMI_MAX
 };
 

commit b227e23399dc59977aa42c49bd668bdab7a61812
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Sep 30 15:06:22 2011 -0400

    x86, nmi: Add in logic to handle multiple events and unknown NMIs
    
    Previous patches allow the NMI subsystem to process multipe NMI events
    in one NMI.  As previously discussed this can cause issues when an event
    triggered another NMI but is processed in the current NMI.  This causes the
    next NMI to go unprocessed and become an 'unknown' NMI.
    
    To handle this, we first have to flag whether or not the NMI handler handled
    more than one event or not.  If it did, then there exists a chance that
    the next NMI might be already processed.  Once the NMI is flagged as a
    candidate to be swallowed, we next look for a back-to-back NMI condition.
    
    This is determined by looking at the %rip from pt_regs.  If it is the same
    as the previous NMI, it is assumed the cpu did not have a chance to jump
    back into a non-NMI context and execute code and instead handled another NMI.
    
    If both of those conditions are true then we will swallow any unknown NMI.
    
    There still exists a chance that we accidentally swallow a real unknown NMI,
    but for now things seem better.
    
    An optimization has also been added to the nmi notifier rountine.  Because x86
    can latch up to one NMI while currently processing an NMI, we don't have to
    worry about executing _all_ the handlers in a standalone NMI.  The idea is
    if multiple NMIs come in, the second NMI will represent them.  For those
    back-to-back NMI cases, we have the potentail to drop NMIs.  Therefore only
    execute all the handlers in the second half of a detected back-to-back NMI.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1317409584-23662-5-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 53610957feaf..fd3f9f18cf3f 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -42,5 +42,6 @@ void unregister_nmi_handler(unsigned int, const char *);
 
 void stop_nmi(void);
 void restart_nmi(void);
+void local_touch_nmi(void);
 
 #endif /* _ASM_X86_NMI_H */

commit 9c48f1c629ecfa114850c03f875c6691003214de
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Sep 30 15:06:21 2011 -0400

    x86, nmi: Wire up NMI handlers to new routines
    
    Just convert all the files that have an nmi handler to the new routines.
    Most of it is straight forward conversion.  A couple of places needed some
    tweaking like kgdb which separates the debug notifier from the nmi handler
    and mce removes a call to notify_die.
    
    [Thanks to Ying for finding out the history behind that mce call
    
    https://lkml.org/lkml/2010/5/27/114
    
    And Boris responding that he would like to remove that call because of it
    
    https://lkml.org/lkml/2011/9/21/163]
    
    The things that get converted are the registeration/unregistration routines
    and the nmi handler itself has its args changed along with code removal
    to check which list it is on (most are on one NMI list except for kgdb
    which has both an NMI routine and an NMI Unknown routine).
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Corey Minyard <minyard@acm.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Jack Steiner <steiner@sgi.com>
    Link: http://lkml.kernel.org/r/1317409584-23662-4-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 480b69b75756..53610957feaf 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -22,26 +22,6 @@ void arch_trigger_all_cpu_backtrace(void);
 #define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
 #endif
 
-/*
- * Define some priorities for the nmi notifier call chain.
- *
- * Create a local nmi bit that has a higher priority than
- * external nmis, because the local ones are more frequent.
- *
- * Also setup some default high/normal/low settings for
- * subsystems to registers with.  Using 4 bits to separate
- * the priorities.  This can go a lot higher if needed be.
- */
-
-#define NMI_LOCAL_SHIFT		16	/* randomly picked */
-#define NMI_LOCAL_BIT		(1ULL << NMI_LOCAL_SHIFT)
-#define NMI_HIGH_PRIOR		(1ULL << 8)
-#define NMI_NORMAL_PRIOR	(1ULL << 4)
-#define NMI_LOW_PRIOR		(1ULL << 0)
-#define NMI_LOCAL_HIGH_PRIOR	(NMI_LOCAL_BIT | NMI_HIGH_PRIOR)
-#define NMI_LOCAL_NORMAL_PRIOR	(NMI_LOCAL_BIT | NMI_NORMAL_PRIOR)
-#define NMI_LOCAL_LOW_PRIOR	(NMI_LOCAL_BIT | NMI_LOW_PRIOR)
-
 #define NMI_FLAG_FIRST	1
 
 enum {

commit c9126b2ee8adb9235941cedbf558d39a9e65642d
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Sep 30 15:06:20 2011 -0400

    x86, nmi: Create new NMI handler routines
    
    The NMI handlers used to rely on the notifier infrastructure.  This worked
    great until we wanted to support handling multiple events better.
    
    One of the key ideas to the nmi handling is to process _all_ the handlers for
    each NMI.  The reason behind this switch is because NMIs are edge triggered.
    If enough NMIs are triggered, then they could be lost because the cpu can
    only latch at most one NMI (besides the one currently being processed).
    
    In order to deal with this we have decided to process all the NMI handlers
    for each NMI.  This allows the handlers to determine if they recieved an
    event or not (the ones that can not determine this will be left to fend
    for themselves on the unknown NMI list).
    
    As a result of this change it is now possible to have an extra NMI that
    was destined to be received for an already processed event.  Because the
    event was processed in the previous NMI, this NMI gets dropped and becomes
    an 'unknown' NMI.  This of course will cause printks that scare people.
    
    However, we prefer to have extra NMIs as opposed to losing NMIs and as such
    are have developed a basic mechanism to catch most of them.  That will be
    a later patch.
    
    To accomplish this idea, I unhooked the nmi handlers from the notifier
    routines and created a new mechanism loosely based on doIRQ.  The reason
    for this is the notifier routines have a couple of shortcomings.  One we
    could't guarantee all future NMI handlers used NOTIFY_OK instead of
    NOTIFY_STOP.  Second, we couldn't keep track of the number of events being
    handled in each routine (most only handle one, perf can handle more than one).
    Third, I wanted to eventually display which nmi handlers are registered in
    the system in /proc/interrupts to help see who is generating NMIs.
    
    The patch below just implements the new infrastructure but doesn't wire it up
    yet (that is the next patch).  Its design is based on doIRQ structs and the
    atomic notifier routines.  So the rcu stuff in the patch isn't entirely untested
    (as the notifier routines have soaked it) but it should be double checked in
    case I copied the code wrong.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1317409584-23662-3-git-send-email-dzickus@redhat.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 4886a68f267e..480b69b75756 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -42,6 +42,24 @@ void arch_trigger_all_cpu_backtrace(void);
 #define NMI_LOCAL_NORMAL_PRIOR	(NMI_LOCAL_BIT | NMI_NORMAL_PRIOR)
 #define NMI_LOCAL_LOW_PRIOR	(NMI_LOCAL_BIT | NMI_LOW_PRIOR)
 
+#define NMI_FLAG_FIRST	1
+
+enum {
+	NMI_LOCAL=0,
+	NMI_UNKNOWN,
+	NMI_MAX
+};
+
+#define NMI_DONE	0
+#define NMI_HANDLED	1
+
+typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);
+
+int register_nmi_handler(unsigned int, nmi_handler_t, unsigned long,
+			 const char *);
+
+void unregister_nmi_handler(unsigned int, const char *);
+
 void stop_nmi(void);
 void restart_nmi(void);
 

commit 0d2eb44f631d9d0a826efa3156f157477fdaecf4
Author: Lucas De Marchi <lucas.de.marchi@gmail.com>
Date:   Thu Mar 17 16:24:16 2011 -0300

    x86: Fix common misspellings
    
    They were generated by 'codespell' and then manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: trivial@kernel.org
    LKML-Reference: <1300389856-1099-3-git-send-email-lucas.demarchi@profusion.mobi>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 07f46016d3ff..4886a68f267e 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -29,8 +29,8 @@ void arch_trigger_all_cpu_backtrace(void);
  * external nmis, because the local ones are more frequent.
  *
  * Also setup some default high/normal/low settings for
- * subsystems to registers with.  Using 4 bits to seperate
- * the priorities.  This can go alot higher if needed be.
+ * subsystems to registers with.  Using 4 bits to separate
+ * the priorities.  This can go a lot higher if needed be.
  */
 
 #define NMI_LOCAL_SHIFT		16	/* randomly picked */

commit 02ca752e4181e219e243cd61a60dd1da47251f11
Author: Jan Beulich <JBeulich@novell.com>
Date:   Thu Feb 17 15:51:40 2011 +0000

    x86: Remove die_nmi()
    
    With no caller left, the function and the DIE_NMIWATCHDOG
    enumerator can both go away.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Don Zickus <dzickus@redhat.com>
    LKML-Reference: <4D5D521C0200007800032702@vpn.id2.novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c76f5b92b840..07f46016d3ff 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -7,7 +7,6 @@
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
-extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);

commit 166d751479c6d4e5b17dfc1f204a9c4397c9b3f1
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Jan 6 16:18:49 2011 -0500

    x86, NMI: Add priorities to handlers
    
    In order to consolidate the NMI die_chain events, we need to setup the priorities
    for the die notifiers.
    
    I started by defining a bunch of common priorities that can be used by the
    notifier blocks.  Then I modified the notifier blocks to use the newly created
    priorities.
    
    Now that the priorities are straightened out, it should be easier to remove the
    event DIE_NMI_IPI.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1294348732-15030-4-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c4021b953510..c76f5b92b840 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -23,6 +23,26 @@ void arch_trigger_all_cpu_backtrace(void);
 #define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
 #endif
 
+/*
+ * Define some priorities for the nmi notifier call chain.
+ *
+ * Create a local nmi bit that has a higher priority than
+ * external nmis, because the local ones are more frequent.
+ *
+ * Also setup some default high/normal/low settings for
+ * subsystems to registers with.  Using 4 bits to seperate
+ * the priorities.  This can go alot higher if needed be.
+ */
+
+#define NMI_LOCAL_SHIFT		16	/* randomly picked */
+#define NMI_LOCAL_BIT		(1ULL << NMI_LOCAL_SHIFT)
+#define NMI_HIGH_PRIOR		(1ULL << 8)
+#define NMI_NORMAL_PRIOR	(1ULL << 4)
+#define NMI_LOW_PRIOR		(1ULL << 0)
+#define NMI_LOCAL_HIGH_PRIOR	(NMI_LOCAL_BIT | NMI_HIGH_PRIOR)
+#define NMI_LOCAL_NORMAL_PRIOR	(NMI_LOCAL_BIT | NMI_NORMAL_PRIOR)
+#define NMI_LOCAL_LOW_PRIOR	(NMI_LOCAL_BIT | NMI_LOW_PRIOR)
+
 void stop_nmi(void);
 void restart_nmi(void);
 

commit 4a7863cc2eb5f9804f1c4e9156619a801cd7f14f
Author: Don Zickus <dzickus@redhat.com>
Date:   Wed Dec 22 14:00:03 2010 -0500

    x86, nmi_watchdog: Remove ARCH_HAS_NMI_WATCHDOG and rely on CONFIG_HARDLOCKUP_DETECTOR
    
    The x86 arch has shifted its use of the nmi_watchdog from a
    local implementation to the global one provide by
    kernel/watchdog.c.  This shift has caused a whole bunch of
    compile problems under different config options.  I attempt to
    simplify things with the patch below.
    
    In order to simplify things, I had to come to terms with the
    meaning of two terms ARCH_HAS_NMI_WATCHDOG and
    CONFIG_HARDLOCKUP_DETECTOR.  Basically they mean the same thing,
    the former on a local level and the latter on a global level.
    
    With the old x86 nmi watchdog gone, there is no need to rely on
    defining the ARCH_HAS_NMI_WATCHDOG variable because it doesn't
    make sense any more.  x86 will now use the global
    implementation.
    
    The changes below do a few things.  First it changes the few
    places that relied on ARCH_HAS_NMI_WATCHDOG to use
    CONFIG_X86_LOCAL_APIC (the former was an alias for the latter
    anyway, so nothing unusual here).  Those pieces of code were
    relying more on local apic functionality the nmi watchdog
    functionality, so the change should make sense.
    
    Second, I removed the x86 implementation of
    touch_nmi_watchdog().  It isn't need now, instead x86 will rely
    on kernel/watchdog.c's implementation.
    
    Third, I removed the #define ARCH_HAS_NMI_WATCHDOG itself from
    x86.  And tweaked the include/linux/nmi.h file to tell users to
    look for an externally defined touch_nmi_watchdog in the case of
    ARCH_HAS_NMI_WATCHDOG _or_ CONFIG_HARDLOCKUP_DETECTOR. This
    changes removes some of the ugliness in that file.
    
    Finally, I added a Kconfig dependency for
    CONFIG_HARDLOCKUP_DETECTOR that said you can't have
    ARCH_HAS_NMI_WATCHDOG _and_ CONFIG_HARDLOCKUP_DETECTOR.  You can
    only have one nmi_watchdog.
    
    Tested with
    ARCH=i386: allnoconfig, defconfig, allyesconfig, (various broken
    configs) ARCH=x86_64: allnoconfig, defconfig, allyesconfig,
    (various broken configs)
    
    Hopefully, after this patch I won't get any more compile broken
    emails. :-)
    
    v3:
      changed a couple of 'linux/nmi.h' -> 'asm/nmi.h' to pick-up correct function
      prototypes when CONFIG_HARDLOCKUP_DETECTOR is not set.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: fweisbec@gmail.com
    LKML-Reference: <1293044403-14117-1-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 3545838cddeb..c4021b953510 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -5,7 +5,7 @@
 #include <asm/irq.h>
 #include <asm/io.h>
 
-#ifdef ARCH_HAS_NMI_WATCHDOG
+#ifdef CONFIG_X86_LOCAL_APIC
 
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);

commit 072b198a4ad48bd722ec6d203d65422a4698eae7
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Nov 12 11:22:24 2010 -0500

    x86, nmi_watchdog: Remove all stub function calls from old nmi_watchdog
    
    Now that the bulk of the old nmi_watchdog is gone, remove all
    the stub variables and hooks associated with it.
    
    This touches lots of files mainly because of how the io_apic
    nmi_watchdog was implemented.  Now that the io_apic nmi_watchdog
    is forever gone, remove all its fingers.
    
    Most of this code was not being exercised by virtue of
    nmi_watchdog != NMI_IO_APIC, so there shouldn't be anything to
    risky here.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: gorcunov@openvz.org
    LKML-Reference: <1289578944-28564-3-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 33292ec848ca..3545838cddeb 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -7,35 +7,13 @@
 
 #ifdef ARCH_HAS_NMI_WATCHDOG
 
-/**
- * do_nmi_callback
- *
- * Check to see if a callback exists and execute it.  Return 1
- * if the handler exists and was handled successfully.
- */
-int do_nmi_callback(struct pt_regs *regs, int cpu);
-
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
-extern int check_nmi_watchdog(void);
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);
 extern int reserve_evntsel_nmi(unsigned int);
 extern void release_evntsel_nmi(unsigned int);
 
-extern void setup_apic_nmi_watchdog(void *);
-extern void stop_apic_nmi_watchdog(void *);
-extern void disable_timer_nmi_watchdog(void);
-extern void enable_timer_nmi_watchdog(void);
-extern void cpu_nmi_set_wd_enabled(void);
-
-extern atomic_t nmi_active;
-extern unsigned int nmi_watchdog;
-#define NMI_NONE	0
-#define NMI_IO_APIC	1
-#define NMI_LOCAL_APIC	2
-#define NMI_INVALID	3
-
 struct ctl_table;
 extern int proc_nmi_enabled(struct ctl_table *, int ,
 			void __user *, size_t *, loff_t *);
@@ -43,33 +21,8 @@ extern int unknown_nmi_panic;
 
 void arch_trigger_all_cpu_backtrace(void);
 #define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
-
-static inline void localise_nmi_watchdog(void)
-{
-	if (nmi_watchdog == NMI_IO_APIC)
-		nmi_watchdog = NMI_LOCAL_APIC;
-}
-
-/* check if nmi_watchdog is active (ie was specified at boot) */
-static inline int nmi_watchdog_active(void)
-{
-	/*
-	 * actually it should be:
-	 * 	return (nmi_watchdog == NMI_LOCAL_APIC ||
-	 * 		nmi_watchdog == NMI_IO_APIC)
-	 * but since they are power of two we could use a
-	 * cheaper way --cvg
-	 */
-	return nmi_watchdog & (NMI_LOCAL_APIC | NMI_IO_APIC);
-}
 #endif
 
-void lapic_watchdog_stop(void);
-int lapic_watchdog_init(unsigned nmi_hz);
-int lapic_wd_event(unsigned nmi_hz);
-unsigned lapic_adjust_nmi_hz(unsigned hz);
-void disable_lapic_nmi_watchdog(void);
-void enable_lapic_nmi_watchdog(void);
 void stop_nmi(void);
 void restart_nmi(void);
 

commit 5f2b0ba4d94b3ac23cbc4b7f675d98eb677a760a
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Nov 12 11:22:23 2010 -0500

    x86, nmi_watchdog: Remove the old nmi_watchdog
    
    Now that we have a new nmi_watchdog that is more generic and
    sits on top of the perf subsystem, we really do not need the old
    nmi_watchdog any more.
    
    In addition, the old nmi_watchdog doesn't really work if you are
    using the default clocksource, hpet.  The old nmi_watchdog code
    relied on local apic interrupts to determine if the cpu is still
    alive.  With hpet as the clocksource, these interrupts don't
    increment any more and the old nmi_watchdog triggers false
    postives.
    
    This piece removes the old nmi_watchdog code and stubs out any
    variables and functions calls.  The stubs are the same ones used
    by the new nmi_watchdog code, so it should be well tested.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: gorcunov@openvz.org
    LKML-Reference: <1289578944-28564-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 932f0f86b4b7..33292ec848ca 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -17,9 +17,6 @@ int do_nmi_callback(struct pt_regs *regs, int cpu);
 
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int check_nmi_watchdog(void);
-#if !defined(CONFIG_LOCKUP_DETECTOR)
-extern int nmi_watchdog_enabled;
-#endif
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);
@@ -30,7 +27,6 @@ extern void setup_apic_nmi_watchdog(void *);
 extern void stop_apic_nmi_watchdog(void *);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason);
 extern void cpu_nmi_set_wd_enabled(void);
 
 extern atomic_t nmi_active;

commit 58687acba59266735adb8ccd9b5b9aa2c7cd205b
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri May 7 17:11:44 2010 -0400

    lockup_detector: Combine nmi_watchdog and softlockup detector
    
    The new nmi_watchdog (which uses the perf event subsystem) is very
    similar in structure to the softlockup detector.  Using Ingo's
    suggestion, I combined the two functionalities into one file:
    kernel/watchdog.c.
    
    Now both the nmi_watchdog (or hardlockup detector) and softlockup
    detector sit on top of the perf event subsystem, which is run every
    60 seconds or so to see if there are any lockups.
    
    To detect hardlockups, cpus not responding to interrupts, I
    implemented an hrtimer that runs 5 times for every perf event
    overflow event.  If that stops counting on a cpu, then the cpu is
    most likely in trouble.
    
    To detect softlockups, tasks not yielding to the scheduler, I used the
    previous kthread idea that now gets kicked every time the hrtimer fires.
    If the kthread isn't being scheduled neither is anyone else and the
    warning is printed to the console.
    
    I tested this on x86_64 and both the softlockup and hardlockup paths
    work.
    
    V2:
    - cleaned up the Kconfig and softlockup combination
    - surrounded hardlockup cases with #ifdef CONFIG_PERF_EVENTS_NMI
    - seperated out the softlockup case from perf event subsystem
    - re-arranged the enabling/disabling nmi watchdog from proc space
    - added cpumasks for hardlockup failure cases
    - removed fallback to soft events if no PMU exists for hard events
    
    V3:
    - comment cleanups
    - drop support for older softlockup code
    - per_cpu cleanups
    - completely remove software clock base hardlockup detector
    - use per_cpu masking on hard/soft lockup detection
    - #ifdef cleanups
    - rename config option NMI_WATCHDOG to LOCKUP_DETECTOR
    - documentation additions
    
    V4:
    - documentation fixes
    - convert per_cpu to __get_cpu_var
    - powerpc compile fixes
    
    V5:
    - split apart warn flags for hard and soft lockups
    
    TODO:
    - figure out how to make an arch-agnostic clock2cycles call
      (if possible) to feed into perf events as a sample period
    
    [fweisbec: merged conflict patch]
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    LKML-Reference: <1273266711-18706-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 5b41b0feb6db..932f0f86b4b7 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -17,7 +17,7 @@ int do_nmi_callback(struct pt_regs *regs, int cpu);
 
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int check_nmi_watchdog(void);
-#if !defined(CONFIG_NMI_WATCHDOG)
+#if !defined(CONFIG_LOCKUP_DETECTOR)
 extern int nmi_watchdog_enabled;
 #endif
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);

commit 504d7cf10ee42bb76b9556859f23d4121dee0a77
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Feb 12 17:19:19 2010 -0500

    nmi_watchdog: Compile and portability fixes
    
    The original patch was x86_64 centric.  Changed the code to make
    it less so.
    
    ested by building and running on a powerpc.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: peterz@infradead.org
    Cc: gorcunov@gmail.com
    Cc: aris@redhat.com
    LKML-Reference: <1266013161-31197-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 93da9c3f3341..5b41b0feb6db 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -17,7 +17,9 @@ int do_nmi_callback(struct pt_regs *regs, int cpu);
 
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int check_nmi_watchdog(void);
+#if !defined(CONFIG_NMI_WATCHDOG)
 extern int nmi_watchdog_enabled;
+#endif
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);

commit fd2a50a0240f5f5b59070474eabd83a85720a406
Author: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
Date:   Thu Dec 24 01:54:47 2009 +0000

    x86, perfctr: Remove unused func avail_to_resrv_perfctr_nmi()
    
    avail_to_resrv_perfctr_nmi() is neither EXPORT'd, nor used in
    the file. So remove it.
    
    Signed-off-by: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
    Acked-by: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: oprofile-list@lists.sf.net
    LKML-Reference: <20091224015441.6005.4408.sendpatchset@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 139d4c1a33a7..93da9c3f3341 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -19,7 +19,6 @@ extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int check_nmi_watchdog(void);
 extern int nmi_watchdog_enabled;
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
-extern int avail_to_resrv_perfctr_nmi(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);
 extern int reserve_evntsel_nmi(unsigned int);

commit 8d65af789f3e2cf4cfbdbf71a0f7a61ebcd41d38
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Sep 23 15:57:19 2009 -0700

    sysctl: remove "struct file *" argument of ->proc_handler
    
    It's unused.
    
    It isn't needed -- read or write flag is already passed and sysctl
    shouldn't care about the rest.
    
    It _was_ used in two places at arch/frv for some reason.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index e63cf7d441e1..139d4c1a33a7 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -40,8 +40,7 @@ extern unsigned int nmi_watchdog;
 #define NMI_INVALID	3
 
 struct ctl_table;
-struct file;
-extern int proc_nmi_enabled(struct ctl_table *, int , struct file *,
+extern int proc_nmi_enabled(struct ctl_table *, int ,
 			void __user *, size_t *, loff_t *);
 extern int unknown_nmi_panic;
 

commit 47cab6a722d44c71c4f8224017ef548522243cf4
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Aug 3 09:31:54 2009 +0200

    debug lockups: Improve lockup detection, fix generic arch fallback
    
    As Andrew noted, my previous patch ("debug lockups: Improve lockup
    detection") broke/removed SysRq-L support from architecture that do
    not provide a __trigger_all_cpu_backtrace implementation.
    
    Restore a fallback path and clean up the SysRq-L machinery a bit:
    
     - Rename the arch method to arch_trigger_all_cpu_backtrace()
    
     - Simplify the define
    
     - Document the method a bit - in the hope of more architectures
       adding support for it.
    
    [ The patch touches Sparc code for the rename. ]
    
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    LKML-Reference: <20090802140809.7ec4bb6b.akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c86e5ed4af51..e63cf7d441e1 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -45,8 +45,8 @@ extern int proc_nmi_enabled(struct ctl_table *, int , struct file *,
 			void __user *, size_t *, loff_t *);
 extern int unknown_nmi_panic;
 
-void __trigger_all_cpu_backtrace(void);
-#define trigger_all_cpu_backtrace() __trigger_all_cpu_backtrace()
+void arch_trigger_all_cpu_backtrace(void);
+#define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
 
 static inline void localise_nmi_watchdog(void)
 {

commit c7210e1ff8a95a0a6dba0d04a95b3ddd9d165fab
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Thu Jul 2 22:35:35 2009 +0530

    x86: Remove unused function lapic_watchdog_ok()
    
    lapic_watchdog_ok() is a global function but no one is using it.
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1246554335.2242.29.camel@jaswinder.satnam>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c97264409934..c86e5ed4af51 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -72,7 +72,6 @@ void lapic_watchdog_stop(void);
 int lapic_watchdog_init(unsigned nmi_hz);
 int lapic_wd_event(unsigned nmi_hz);
 unsigned lapic_adjust_nmi_hz(unsigned hz);
-int lapic_watchdog_ok(void);
 void disable_lapic_nmi_watchdog(void);
 void enable_lapic_nmi_watchdog(void);
 void stop_nmi(void);

commit a4046f8d299e00e9855ae292527c2d66a42670eb
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Sun Jun 7 12:19:37 2009 +0400

    x86, nmi: Use predefined numbers instead of hardcoded one
    
    [ Impact: cleanup ]
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    LKML-Reference: <20090607081937.GC4547@lenovo>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index c45a0a568dff..c97264409934 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -64,7 +64,7 @@ static inline int nmi_watchdog_active(void)
 	 * but since they are power of two we could use a
 	 * cheaper way --cvg
 	 */
-	return nmi_watchdog & 0x3;
+	return nmi_watchdog & (NMI_LOCAL_APIC | NMI_IO_APIC);
 }
 #endif
 

commit 1965aae3c98397aad957412413c07e97b1bd4e64
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Oct 22 22:26:29 2008 -0700

    x86: Fix ASM_X86__ header guards
    
    Change header guards named "ASM_X86__*" to "_ASM_X86_*" since:
    
    a. the double underscore is ugly and pointless.
    b. no leading underscore violates namespace constraints.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index a53f829a97c5..c45a0a568dff 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -1,5 +1,5 @@
-#ifndef ASM_X86__NMI_H
-#define ASM_X86__NMI_H
+#ifndef _ASM_X86_NMI_H
+#define _ASM_X86_NMI_H
 
 #include <linux/pm.h>
 #include <asm/irq.h>
@@ -78,4 +78,4 @@ void enable_lapic_nmi_watchdog(void);
 void stop_nmi(void);
 void restart_nmi(void);
 
-#endif /* ASM_X86__NMI_H */
+#endif /* _ASM_X86_NMI_H */

commit bb8985586b7a906e116db835c64773b7a7d51663
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 17 21:05:42 2008 -0400

    x86, um: ... and asm-x86 move
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
new file mode 100644
index 000000000000..a53f829a97c5
--- /dev/null
+++ b/arch/x86/include/asm/nmi.h
@@ -0,0 +1,81 @@
+#ifndef ASM_X86__NMI_H
+#define ASM_X86__NMI_H
+
+#include <linux/pm.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#ifdef ARCH_HAS_NMI_WATCHDOG
+
+/**
+ * do_nmi_callback
+ *
+ * Check to see if a callback exists and execute it.  Return 1
+ * if the handler exists and was handled successfully.
+ */
+int do_nmi_callback(struct pt_regs *regs, int cpu);
+
+extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
+extern int check_nmi_watchdog(void);
+extern int nmi_watchdog_enabled;
+extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
+extern int avail_to_resrv_perfctr_nmi(unsigned int);
+extern int reserve_perfctr_nmi(unsigned int);
+extern void release_perfctr_nmi(unsigned int);
+extern int reserve_evntsel_nmi(unsigned int);
+extern void release_evntsel_nmi(unsigned int);
+
+extern void setup_apic_nmi_watchdog(void *);
+extern void stop_apic_nmi_watchdog(void *);
+extern void disable_timer_nmi_watchdog(void);
+extern void enable_timer_nmi_watchdog(void);
+extern int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason);
+extern void cpu_nmi_set_wd_enabled(void);
+
+extern atomic_t nmi_active;
+extern unsigned int nmi_watchdog;
+#define NMI_NONE	0
+#define NMI_IO_APIC	1
+#define NMI_LOCAL_APIC	2
+#define NMI_INVALID	3
+
+struct ctl_table;
+struct file;
+extern int proc_nmi_enabled(struct ctl_table *, int , struct file *,
+			void __user *, size_t *, loff_t *);
+extern int unknown_nmi_panic;
+
+void __trigger_all_cpu_backtrace(void);
+#define trigger_all_cpu_backtrace() __trigger_all_cpu_backtrace()
+
+static inline void localise_nmi_watchdog(void)
+{
+	if (nmi_watchdog == NMI_IO_APIC)
+		nmi_watchdog = NMI_LOCAL_APIC;
+}
+
+/* check if nmi_watchdog is active (ie was specified at boot) */
+static inline int nmi_watchdog_active(void)
+{
+	/*
+	 * actually it should be:
+	 * 	return (nmi_watchdog == NMI_LOCAL_APIC ||
+	 * 		nmi_watchdog == NMI_IO_APIC)
+	 * but since they are power of two we could use a
+	 * cheaper way --cvg
+	 */
+	return nmi_watchdog & 0x3;
+}
+#endif
+
+void lapic_watchdog_stop(void);
+int lapic_watchdog_init(unsigned nmi_hz);
+int lapic_wd_event(unsigned nmi_hz);
+unsigned lapic_adjust_nmi_hz(unsigned hz);
+int lapic_watchdog_ok(void);
+void disable_lapic_nmi_watchdog(void);
+void enable_lapic_nmi_watchdog(void);
+void stop_nmi(void);
+void restart_nmi(void);
+
+#endif /* ASM_X86__NMI_H */
