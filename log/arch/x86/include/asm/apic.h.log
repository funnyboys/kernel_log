commit a16be368dd3fb695077cc9bc59c988b548955eec
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:43 2020 +0200

    x86/entry: Convert various hypervisor vectors to IDTENTRY_SYSVEC
    
    Convert various hypervisor vectors to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.647997594@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a5416865b6fa..2cc44e957c31 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -519,26 +519,6 @@ static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
 static inline void apic_smt_update(void) { }
 #endif
 
-extern void irq_enter(void);
-extern void irq_exit(void);
-
-static inline void entering_irq(void)
-{
-	irq_enter();
-	kvm_set_cpu_l1tf_flush_l1d();
-}
-
-static inline void entering_ack_irq(void)
-{
-	entering_irq();
-	ack_APIC_irq();
-}
-
-static inline void exiting_irq(void)
-{
-	irq_exit();
-}
-
 extern void ioapic_zap_locks(void);
 
 #endif /* _ASM_X86_APIC_H */

commit 720909a7abd351535bfb485a0ecce03c2e4467e2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:41 2020 +0200

    x86/entry: Convert various system vectors
    
    Convert various system vectors to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.464812973@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 19e94af9cc5d..a5416865b6fa 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -534,24 +534,11 @@ static inline void entering_ack_irq(void)
 	ack_APIC_irq();
 }
 
-static inline void ipi_entering_ack_irq(void)
-{
-	irq_enter();
-	ack_APIC_irq();
-	kvm_set_cpu_l1tf_flush_l1d();
-}
-
 static inline void exiting_irq(void)
 {
 	irq_exit();
 }
 
-static inline void exiting_ack_irq(void)
-{
-	ack_APIC_irq();
-	irq_exit();
-}
-
 extern void ioapic_zap_locks(void);
 
 #endif /* _ASM_X86_APIC_H */

commit 6f1a4891a5928a5969c87fa5a584844c983ec823
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 31 15:26:52 2020 +0100

    x86/apic/msi: Plug non-maskable MSI affinity race
    
    Evan tracked down a subtle race between the update of the MSI message and
    the device raising an interrupt internally on PCI devices which do not
    support MSI masking. The update of the MSI message is non-atomic and
    consists of either 2 or 3 sequential 32bit wide writes to the PCI config
    space.
    
       - Write address low 32bits
       - Write address high 32bits (If supported by device)
       - Write data
    
    When an interrupt is migrated then both address and data might change, so
    the kernel attempts to mask the MSI interrupt first. But for MSI masking is
    optional, so there exist devices which do not provide it. That means that
    if the device raises an interrupt internally between the writes then a MSI
    message is sent built from half updated state.
    
    On x86 this can lead to spurious interrupts on the wrong interrupt
    vector when the affinity setting changes both address and data. As a
    consequence the device interrupt can be lost causing the device to
    become stuck or malfunctioning.
    
    Evan tried to handle that by disabling MSI accross an MSI message
    update. That's not feasible because disabling MSI has issues on its own:
    
     If MSI is disabled the PCI device is routing an interrupt to the legacy
     INTx mechanism. The INTx delivery can be disabled, but the disablement is
     not working on all devices.
    
     Some devices lose interrupts when both MSI and INTx delivery are disabled.
    
    Another way to solve this would be to enforce the allocation of the same
    vector on all CPUs in the system for this kind of screwed devices. That
    could be done, but it would bring back the vector space exhaustion problems
    which got solved a few years ago.
    
    Fortunately the high address (if supported by the device) is only relevant
    when X2APIC is enabled which implies interrupt remapping. In the interrupt
    remapping case the affinity setting is happening at the interrupt remapping
    unit and the PCI MSI message is programmed only once when the PCI device is
    initialized.
    
    That makes it possible to solve it with a two step update:
    
      1) Target the MSI msg to the new vector on the current target CPU
    
      2) Target the MSI msg to the new vector on the new target CPU
    
    In both cases writing the MSI message is only changing a single 32bit word
    which prevents the issue of inconsistency.
    
    After writing the final destination it is necessary to check whether the
    device issued an interrupt while the intermediate state #1 (new vector,
    current CPU) was in effect.
    
    This is possible because the affinity change is always happening on the
    current target CPU. The code runs with interrupts disabled, so the
    interrupt can be detected by checking the IRR of the local APIC. If the
    vector is pending in the IRR then the interrupt is retriggered on the new
    target CPU by sending an IPI for the associated vector on the target CPU.
    
    This can cause spurious interrupts on both the local and the new target
    CPU.
    
     1) If the new vector is not in use on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then interrupt entry code will
        ignore that spurious interrupt. The vector is marked so that the
        'No irq handler for vector' warning is supressed once.
    
     2) If the new vector is in use already on the local CPU then the IRR check
        might see an pending interrupt from the device which is using this
        vector. The IPI to the new target CPU will then invoke the handler of
        the device, which got the affinity change, even if that device did not
        issue an interrupt
    
     3) If the new vector is in use already on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then the handler of the device which
        uses that vector on the local CPU will be invoked.
    
    expose issues in device driver interrupt handlers which are not prepared to
    handle a spurious interrupt correctly. This not a regression, it's just
    exposing something which was already broken as spurious interrupts can
    happen for a lot of reasons and all driver handlers need to be able to deal
    with them.
    
    Reported-by: Evan Green <evgreen@chromium.org>
    Debugged-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/87imkr4s7n.fsf@nanos.tec.linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index be0b9cf941c4..19e94af9cc5d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -454,6 +454,14 @@ static inline void ack_APIC_irq(void)
 	apic_eoi();
 }
 
+
+static inline bool lapic_vector_set_in_irr(unsigned int vector)
+{
+	u32 irr = apic_read(APIC_IRR + (vector / 32 * 0x10));
+
+	return !!(irr & (1U << (vector % 32)));
+}
+
 static inline unsigned default_get_apic_id(unsigned long x)
 {
 	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));

commit 979923871f69a4dc926658f9f9a1a4c1bde57552
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 23 12:54:53 2020 +0100

    x86/timer: Don't skip PIT setup when APIC is disabled or in legacy mode
    
    Tony reported a boot regression caused by the recent workaround for systems
    which have a disabled (clock gate off) PIT.
    
    On his machine the kernel fails to initialize the PIT because
    apic_needs_pit() does not take into account whether the local APIC
    interrupt delivery mode will actually allow to setup and use the local
    APIC timer. This should be easy to reproduce with acpi=off on the
    command line which also disables HPET.
    
    Due to the way the PIT/HPET and APIC setup ordering works (APIC setup can
    require working PIT/HPET) the information is not available at the point
    where apic_needs_pit() makes this decision.
    
    To address this, split out the interrupt mode selection from
    apic_intr_mode_init(), invoke the selection before making the decision
    whether PIT is required or not, and add the missing checks into
    apic_needs_pit().
    
    Fixes: c8c4076723da ("x86/timer: Skip PIT initialization on modern chipsets")
    Reported-by: Anthony Buckley <tony.buckley000@gmail.com>
    Tested-by: Anthony Buckley <tony.buckley000@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Daniel Drake <drake@endlessm.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206125
    Link: https://lore.kernel.org/r/87sgk6tmk2.fsf@nanos.tec.linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2ebc17d9c72c..be0b9cf941c4 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -140,6 +140,7 @@ extern void apic_soft_disable(void);
 extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
+extern void apic_intr_mode_select(void);
 extern void apic_intr_mode_init(void);
 extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
@@ -188,6 +189,7 @@ static inline void disable_local_APIC(void) { }
 # define setup_secondary_APIC_clock x86_init_noop
 static inline void lapic_update_tsc_freq(void) { }
 static inline void init_bsp_APIC(void) { }
+static inline void apic_intr_mode_select(void) { }
 static inline void apic_intr_mode_init(void) { }
 static inline void lapic_assign_system_vectors(void) { }
 static inline void lapic_assign_legacy_vector(unsigned int i, bool r) { }

commit 2510d09e9dabc265341f164e0b45b2dfdcb7ef36
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 22 20:47:29 2019 +0200

    x86/apic/flat64: Remove the IPI shorthand decision logic
    
    All callers of apic->send_IPI_all() and apic->send_IPI_allbutself() contain
    the decision logic for shorthand invocation already and invoke
    send_IPI_mask() if the prereqisites are not satisfied.
    
    Remove the now redundant decision logic in the APIC code and the duplicate
    helper in probe_64.c.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20190722105221.042964120@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index de86c6c15228..2ebc17d9c72c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -468,10 +468,6 @@ static inline unsigned default_get_apic_id(unsigned long x)
 #define TRAMPOLINE_PHYS_LOW		0x467
 #define TRAMPOLINE_PHYS_HIGH		0x469
 
-#ifdef CONFIG_X86_64
-extern void apic_send_IPI_self(int vector);
-#endif
-
 extern void generic_bigsmp_probe(void);
 
 #ifdef CONFIG_X86_LOCAL_APIC

commit 22ca7ee933a39f542ff6f81fc64f8036eff56519
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 22 20:47:23 2019 +0200

    x86/apic: Provide and use helper for send_IPI_allbutself()
    
    To support IPI shorthands wrap invocations of apic->send_IPI_allbutself()
    in a helper function, so the static key controlling the shorthand mode is
    only in one place.
    
    Fixup all callers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20190722105220.492691679@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4a0d349ab44d..de86c6c15228 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -177,6 +177,8 @@ extern void lapic_online(void);
 extern void lapic_offline(void);
 extern bool apic_needs_pit(void);
 
+extern void apic_send_IPI_allbutself(unsigned int vector);
+
 #else /* !CONFIG_X86_LOCAL_APIC */
 static inline void lapic_shutdown(void) { }
 #define local_apic_timer_c2_ok		1

commit 6a1cb5f5c6413222b8532722562dd1edb5fdfd38
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 22 20:47:22 2019 +0200

    x86/apic: Add static key to Control IPI shorthands
    
    The IPI shorthand functionality delivers IPI/NMI broadcasts to all CPUs in
    the system. This can have similar side effects as the MCE broadcasting when
    CPUs are waiting in the BIOS or are offlined.
    
    The kernel tracks already the state of offlined CPUs whether they have been
    brought up at least once so that the CR4 MCE bit is set to make sure that
    MCE broadcasts can't brick the machine.
    
    Utilize that information and compare it to the cpu_present_mask. If all
    present CPUs have been brought up at least once then the broadcast side
    effect is mitigated by disabling regular interrupt/IPI delivery in the APIC
    itself and by the cpu offline check at the begin of the NMI handler.
    
    Use a static key to switch between broadcasting via shorthands or sending
    the IPI/NMI one by one.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20190722105220.386410643@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index cae7e0d02476..4a0d349ab44d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -505,8 +505,10 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 
 #ifdef CONFIG_SMP
 bool apic_id_is_primary_thread(unsigned int id);
+void apic_smt_update(void);
 #else
 static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
+static inline void apic_smt_update(void) { }
 #endif
 
 extern void irq_enter(void);

commit 60dcaad5736faff5a6b1abba5a292499f57197fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 24 17:25:52 2019 +0200

    x86/hotplug: Silence APIC and NMI when CPU is dead
    
    In order to support IPI/NMI broadcasting via the shorthand mechanism side
    effects of shorthands need to be mitigated:
    
     Shorthand IPIs and NMIs hit all CPUs including unplugged CPUs
    
    Neither of those can be handled on unplugged CPUs for obvious reasons.
    
    It would be trivial to just fully disable the APIC via the enable bit in
    MSR_APICBASE. But that's not possible because clearing that bit on systems
    based on the 3 wire APIC bus would require a hardware reset to bring it
    back as the APIC would lose track of bus arbitration. On systems with FSB
    delivery APICBASE could be disabled, but it has to be guaranteed that no
    interrupt is sent to the APIC while in that state and it's not clear from
    the SDM whether it still responds to INIT/SIPI messages.
    
    Therefore stay on the safe side and switch the APIC into soft disabled mode
    so it won't deliver any regular vector to the CPU.
    
    NMIs are still propagated to the 'dead' CPUs. To mitigate that add a check
    for the CPU being offline on early nmi entry and if so bail.
    
    Note, this cannot use the stop/restart_nmi() magic which is used in the
    alternatives code. A dead CPU cannot invoke nmi_enter() or anything else
    due to RCU and other reasons.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1907241723290.1791@nanos.tec.linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f53eda2c986b..cae7e0d02476 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -136,6 +136,7 @@ extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
 extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
+extern void apic_soft_disable(void);
 extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);

commit 82e574782345aa634e1544e80da85d71a9dbde19
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 22 20:47:15 2019 +0200

    x86/apic/uv: Make x2apic_extra_bits static
    
    Not used outside of the UV apic source.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20190722105219.725264153@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e647aa095867..f53eda2c986b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -467,8 +467,6 @@ static inline unsigned default_get_apic_id(unsigned long x)
 
 #ifdef CONFIG_X86_64
 extern void apic_send_IPI_self(int vector);
-
-DECLARE_PER_CPU(int, x2apic_extra_bits);
 #endif
 
 extern void generic_bigsmp_probe(void);

commit ec6335586953b0df32f83ef696002063090c7aef
Author: Qian Cai <cai@lca.pw>
Date:   Mon Jul 8 17:36:45 2019 -0400

    x86/apic: Silence -Wtype-limits compiler warnings
    
    There are many compiler warnings like this,
    
    In file included from ./arch/x86/include/asm/smp.h:13,
                     from ./arch/x86/include/asm/mmzone_64.h:11,
                     from ./arch/x86/include/asm/mmzone.h:5,
                     from ./include/linux/mmzone.h:969,
                     from ./include/linux/gfp.h:6,
                     from ./include/linux/mm.h:10,
                     from arch/x86/kernel/apic/io_apic.c:34:
    arch/x86/kernel/apic/io_apic.c: In function 'check_timer':
    ./arch/x86/include/asm/apic.h:37:11: warning: comparison of unsigned
    expression >= 0 is always true [-Wtype-limits]
       if ((v) <= apic_verbosity) \
               ^~
    arch/x86/kernel/apic/io_apic.c:2160:2: note: in expansion of macro
    'apic_printk'
      apic_printk(APIC_QUIET, KERN_INFO "..TIMER: vector=0x%02X "
      ^~~~~~~~~~~
    ./arch/x86/include/asm/apic.h:37:11: warning: comparison of unsigned
    expression >= 0 is always true [-Wtype-limits]
       if ((v) <= apic_verbosity) \
               ^~
    arch/x86/kernel/apic/io_apic.c:2207:4: note: in expansion of macro
    'apic_printk'
        apic_printk(APIC_QUIET, KERN_ERR "..MP-BIOS bug: "
        ^~~~~~~~~~~
    
    APIC_QUIET is 0, so silence them by making apic_verbosity type int.
    
    Signed-off-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/1562621805-24789-1-git-send-email-cai@lca.pw

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 050e5f9ebf81..e647aa095867 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -49,7 +49,7 @@ static inline void generic_apic_probe(void)
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
-extern unsigned int apic_verbosity;
+extern int apic_verbosity;
 extern int local_apic_timer_c2_ok;
 
 extern int disable_apic;

commit 0902d5011cfaabd6a09326299ef77e1c8735fb89
Merge: 927ba67a63c7 f8a8fe61fec8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:22:57 2019 -0700

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x96 apic updates from Thomas Gleixner:
     "Updates for the x86 APIC interrupt handling and APIC timer:
    
       - Fix a long standing issue with spurious interrupts which was caused
         by the big vector management rework a few years ago. Robert Hodaszi
         provided finally enough debug data and an excellent initial failure
         analysis which allowed to understand the underlying issues.
    
         This contains a change to the core interrupt management code which
         is required to handle this correctly for the APIC/IO_APIC. The core
         changes are NOOPs for most architectures except ARM64. ARM64 is not
         impacted by the change as confirmed by Marc Zyngier.
    
       - Newer systems allow to disable the PIT clock for power saving
         causing panic in the timer interrupt delivery check of the IO/APIC
         when the HPET timer is not enabled either. While the clock could be
         turned on this would cause an endless whack a mole game to chase
         the proper register in each affected chipset.
    
         These systems provide the relevant frequencies for TSC, CPU and the
         local APIC timer via CPUID and/or MSRs, which allows to avoid the
         PIT/HPET based calibration. As the calibration code is the only
         usage of the legacy timers on modern systems and is skipped anyway
         when the frequencies are known already, there is no point in
         setting up the PIT and actually checking for the interrupt delivery
         via IO/APIC.
    
         To achieve this on a wide variety of platforms, the CPUID/MSR based
         frequency readout has been made more robust, which also allowed to
         remove quite some workarounds which turned out to be not longer
         required. Thanks to Daniel Drake for analysis, patches and
         verification"
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/irq: Seperate unused system vectors from spurious entry again
      x86/irq: Handle spurious interrupt after shutdown gracefully
      x86/ioapic: Implement irq_get_irqchip_state() callback
      genirq: Add optional hardware synchronization for shutdown
      genirq: Fix misleading synchronize_irq() documentation
      genirq: Delay deactivation in free_irq()
      x86/timer: Skip PIT initialization on modern chipsets
      x86/apic: Use non-atomic operations when possible
      x86/apic: Make apic_bsp_setup() static
      x86/tsc: Set LAPIC timer period to crystal clock frequency
      x86/apic: Rename 'lapic_timer_frequency' to 'lapic_timer_period'
      x86/tsc: Use CPUID.0x16 to calculate missing crystal frequency

commit c8c4076723daca08bf35ccd68f22ea1c6219e207
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 28 15:23:07 2019 +0800

    x86/timer: Skip PIT initialization on modern chipsets
    
    Recent Intel chipsets including Skylake and ApolloLake have a special
    ITSSPRC register which allows the 8254 PIT to be gated.  When gated, the
    8254 registers can still be programmed as normal, but there are no IRQ0
    timer interrupts.
    
    Some products such as the Connex L1430 and exone go Rugged E11 use this
    register to ship with the PIT gated by default. This causes Linux to fail
    to boot:
    
      Kernel panic - not syncing: IO-APIC + timer doesn't work! Boot with
      apic=debug and send a report.
    
    The panic happens before the framebuffer is initialized, so to the user, it
    appears as an early boot hang on a black screen.
    
    Affected products typically have a BIOS option that can be used to enable
    the 8254 and make Linux work (Chipset -> South Cluster Configuration ->
    Miscellaneous Configuration -> 8254 Clock Gating), however it would be best
    to make Linux support the no-8254 case.
    
    Modern sytems allow to discover the TSC and local APIC timer frequencies,
    so the calibration against the PIT is not required. These systems have
    always running timers and the local APIC timer works also in deep power
    states.
    
    So the setup of the PIT including the IO-APIC timer interrupt delivery
    checks are a pointless exercise.
    
    Skip the PIT setup and the IO-APIC timer interrupt checks on these systems,
    which avoids the panic caused by non ticking PITs and also speeds up the
    boot process.
    
    Thanks to Daniel for providing the changelog, initial analysis of the
    problem and testing against a variety of machines.
    
    Reported-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Daniel Drake <drake@endlessm.com>
    Cc: bp@alien8.de
    Cc: hpa@zytor.com
    Cc: linux@endlessm.com
    Cc: rafael.j.wysocki@intel.com
    Cc: hdegoede@redhat.com
    Link: https://lkml.kernel.org/r/20190628072307.24678-1-drake@endlessm.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c986e32b5a48..693a0ad56019 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -173,6 +173,7 @@ extern void lapic_assign_system_vectors(void);
 extern void lapic_assign_legacy_vector(unsigned int isairq, bool replace);
 extern void lapic_online(void);
 extern void lapic_offline(void);
+extern bool apic_needs_pit(void);
 
 #else /* !CONFIG_X86_LOCAL_APIC */
 static inline void lapic_shutdown(void) { }
@@ -186,6 +187,7 @@ static inline void init_bsp_APIC(void) { }
 static inline void apic_intr_mode_init(void) { }
 static inline void lapic_assign_system_vectors(void) { }
 static inline void lapic_assign_legacy_vector(unsigned int i, bool r) { }
+static inline bool apic_needs_pit(void) { return true; }
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_X2APIC

commit 748b170ca19ab67b891279cce258d1defe73c5ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 16 15:41:24 2019 +0200

    x86/apic: Make apic_bsp_setup() static
    
    No user outside of apic.c. Remove the stale and bogus function comment
    while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index fc505a84aa93..c986e32b5a48 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -154,7 +154,6 @@ static inline int apic_force_enable(unsigned long addr)
 extern int apic_force_enable(unsigned long addr);
 #endif
 
-extern void apic_bsp_setup(bool upmode);
 extern void apic_ap_setup(void);
 
 /*

commit 7e300dabb7e74097137b4ed28a1f9887a7f2ac5b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:25 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 223
    
    Based on 1 normalized pattern(s):
    
      subject to the gnu public license v 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171440.130801526@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 130e81e10fc7..1340fa53b575 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 #ifndef _ASM_X86_APIC_H
 #define _ASM_X86_APIC_H
 
@@ -273,7 +274,6 @@ struct irq_data;
 
 /*
  * Copyright 2004 James Cleverdon, IBM.
- * Subject to the GNU Public License, v.2
  *
  * Generic APIC sub-arch data struct.
  *

commit 52ae346bd26c7a8b17ea82e9a09671e98c5402b7
Author: Daniel Drake <drake@endlessm.com>
Date:   Thu May 9 13:54:16 2019 +0800

    x86/apic: Rename 'lapic_timer_frequency' to 'lapic_timer_period'
    
    This variable is a period unit (number of clock cycles per jiffy),
    not a frequency (which is number of cycles per second).
    
    Give it a more appropriate name.
    
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: len.brown@intel.com
    Cc: linux@endlessm.com
    Cc: rafael.j.wysocki@intel.com
    Link: http://lkml.kernel.org/r/20190509055417.13152-2-drake@endlessm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 130e81e10fc7..fc505a84aa93 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -52,7 +52,7 @@ extern unsigned int apic_verbosity;
 extern int local_apic_timer_c2_ok;
 
 extern int disable_apic;
-extern unsigned int lapic_timer_frequency;
+extern unsigned int lapic_timer_period;
 
 extern enum apic_intr_mode_id apic_intr_mode;
 enum apic_intr_mode_id {

commit ffcba43ff66c7dab34ec700debd491d2a4d319b4
Author: Nicolai Stange <nstange@suse.de>
Date:   Sun Jul 29 13:06:04 2018 +0200

    x86/irq: Let interrupt handlers set kvm_cpu_l1tf_flush_l1d
    
    The last missing piece to having vmx_l1d_flush() take interrupts after
    VMEXIT into account is to set the kvm_cpu_l1tf_flush_l1d per-cpu flag on
    irq entry.
    
    Issue calls to kvm_set_cpu_l1tf_flush_l1d() from entering_irq(),
    ipi_entering_ack_irq(), smp_reschedule_interrupt() and
    uv_bau_message_interrupt().
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 9362a3aae927..130e81e10fc7 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -10,6 +10,7 @@
 #include <asm/fixmap.h>
 #include <asm/mpspec.h>
 #include <asm/msr.h>
+#include <asm/hardirq.h>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
 
@@ -514,6 +515,7 @@ extern void irq_exit(void);
 static inline void entering_irq(void)
 {
 	irq_enter();
+	kvm_set_cpu_l1tf_flush_l1d();
 }
 
 static inline void entering_ack_irq(void)
@@ -526,6 +528,7 @@ static inline void ipi_entering_ack_irq(void)
 {
 	irq_enter();
 	ack_APIC_irq();
+	kvm_set_cpu_l1tf_flush_l1d();
 }
 
 static inline void exiting_irq(void)

commit 506a66f374891ff08e064a058c446b336c5ac760
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 29 16:05:47 2018 +0200

    Revert "x86/apic: Ignore secondary threads if nosmt=force"
    
    Dave Hansen reported, that it's outright dangerous to keep SMT siblings
    disabled completely so they are stuck in the BIOS and wait for SIPI.
    
    The reason is that Machine Check Exceptions are broadcasted to siblings and
    the soft disabled sibling has CR4.MCE = 0. If a MCE is delivered to a
    logical core with CR4.MCE = 0, it asserts IERR#, which shuts down or
    reboots the machine. The MCE chapter in the SDM contains the following
    blurb:
    
        Because the logical processors within a physical package are tightly
        coupled with respect to shared hardware resources, both logical
        processors are notified of machine check errors that occur within a
        given physical processor. If machine-check exceptions are enabled when
        a fatal error is reported, all the logical processors within a physical
        package are dispatched to the machine-check exception handler. If
        machine-check exceptions are disabled, the logical processors enter the
        shutdown state and assert the IERR# signal. When enabling machine-check
        exceptions, the MCE flag in control register CR4 should be set for each
        logical processor.
    
    Reverting the commit which ignores siblings at enumeration time solves only
    half of the problem. The core cpuhotplug logic needs to be adjusted as
    well.
    
    This thoughtful engineered mechanism also turns the boot process on all
    Intel HT enabled systems into a MCE lottery. MCE is enabled on the boot CPU
    before the secondary CPUs are brought up. Depending on the number of
    physical cores the window in which this situation can happen is smaller or
    larger. On a HSW-EX it's about 750ms:
    
    MCE is enabled on the boot CPU:
    
    [    0.244017] mce: CPU supports 22 MCE banks
    
    The corresponding sibling #72 boots:
    
    [    1.008005] .... node  #0, CPUs:    #72
    
    That means if an MCE hits on physical core 0 (logical CPUs 0 and 72)
    between these two points the machine is going to shutdown. At least it's a
    known safe state.
    
    It's obvious that the early boot can be hit by an MCE as well and then runs
    into the same situation because MCEs are not yet enabled on the boot CPU.
    But after enabling them on the boot CPU, it does not make any sense to
    prevent the kernel from recovering.
    
    Adjust the nosmt kernel parameter documentation as well.
    
    Reverts: 2207def700f9 ("x86/apic: Ignore secondary threads if nosmt=force")
    Reported-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Luck <tony.luck@intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ef40e4acd7c2..9362a3aae927 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -504,10 +504,8 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 
 #ifdef CONFIG_SMP
 bool apic_id_is_primary_thread(unsigned int id);
-bool apic_id_disabled(unsigned int id);
 #else
 static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
-static inline bool apic_id_disabled(unsigned int id) { return false; }
 #endif
 
 extern void irq_enter(void);

commit 2207def700f902f169fc237b717252c326f9e464
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 5 14:00:11 2018 +0200

    x86/apic: Ignore secondary threads if nosmt=force
    
    nosmt on the kernel command line merely prevents the onlining of the
    secondary SMT siblings.
    
    nosmt=force makes the APIC detection code ignore the secondary SMT siblings
    completely, so they even do not show up as possible CPUs. That reduces the
    amount of memory allocations for per cpu variables and saves other
    resources from being allocated too large.
    
    This is not fully equivalent to disabling SMT in the BIOS because the low
    level SMT enabling in the BIOS can result in partitioning of resources
    between the siblings, which is not undone by just ignoring them. Some CPUs
    can use the full resources when their sibling is not onlined, but this is
    depending on the CPU family and model and it's not well documented whether
    this applies to all partitioned resources. That means depending on the
    workload disabling SMT in the BIOS might result in better performance.
    
    Linus analysis of the Intel manual:
    
      The intel optimization manual is not very clear on what the partitioning
      rules are.
    
      I find:
    
        "In general, the buffers for staging instructions between major pipe
         stages  are partitioned. These buffers include µop queues after the
         execution trace cache, the queues after the register rename stage, the
         reorder buffer which stages instructions for retirement, and the load
         and store buffers.
    
         In the case of load and store buffers, partitioning also provided an
         easier implementation to maintain memory ordering for each logical
         processor and detect memory ordering violations"
    
      but some of that partitioning may be relaxed if the HT thread is "not
      active":
    
        "In Intel microarchitecture code name Sandy Bridge, the micro-op queue
         is statically partitioned to provide 28 entries for each logical
         processor,  irrespective of software executing in single thread or
         multiple threads. If one logical processor is not active in Intel
         microarchitecture code name Ivy Bridge, then a single thread executing
         on that processor  core can use the 56 entries in the micro-op queue"
    
      but I do not know what "not active" means, and how dynamic it is. Some of
      that partitioning may be entirely static and depend on the early BIOS
      disabling of HT, and even if we park the cores, the resources will just be
      wasted.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 9362a3aae927..ef40e4acd7c2 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -504,8 +504,10 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 
 #ifdef CONFIG_SMP
 bool apic_id_is_primary_thread(unsigned int id);
+bool apic_id_disabled(unsigned int id);
 #else
 static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
+static inline bool apic_id_disabled(unsigned int id) { return false; }
 #endif
 
 extern void irq_enter(void);

commit 6a4d2657e048f096c7ffcad254010bd94891c8c0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 29 17:50:22 2018 +0200

    x86/smp: Provide topology_is_primary_thread()
    
    If the CPU is supporting SMT then the primary thread can be found by
    checking the lower APIC ID bits for zero. smp_num_siblings is used to build
    the mask for the APIC ID bits which need to be taken into account.
    
    This uses the MPTABLE or ACPI/MADT supplied APIC ID, which can be different
    than the initial APIC ID in CPUID. But according to AMD the lower bits have
    to be consistent. Intel gave a tentative confirmation as well.
    
    Preparatory patch to support disabling SMT at boot/runtime.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 74a9e06b6cfd..9362a3aae927 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -502,6 +502,12 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 
+#ifdef CONFIG_SMP
+bool apic_id_is_primary_thread(unsigned int id);
+#else
+static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
+#endif
+
 extern void irq_enter(void);
 extern void irq_exit(void);
 

commit c0255770ccdc77ef2184d2a0a2e0cde09d2b44a4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 4 17:33:55 2018 +0200

    x86/apic: Provide apic_ack_irq()
    
    apic_ack_edge() is explicitely for handling interrupt affinity cleanup when
    interrupt remapping is not available or disable.
    
    Remapped interrupts and also some of the platform specific special
    interrupts, e.g. UV, invoke ack_APIC_irq() directly.
    
    To address the issue of failing an affinity update with -EBUSY the delayed
    affinity mechanism can be reused, but ack_APIC_irq() does not handle
    that. Adding this to ack_APIC_irq() is not possible, because that function
    is also used for exceptions and directly handled interrupts like IPIs.
    
    Create a new function, which just contains the conditional invocation of
    irq_move_irq() and the final ack_APIC_irq().
    
    Reuse the new function in apic_ack_edge().
    
    Preparatory change for the real fix.
    
    Fixes: dccfe3147b42 ("x86/vector: Simplify vector move cleanup")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Song Liu <songliubraving@fb.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <liu.song.a23@gmail.com>
    Cc: Dmitry Safonov <0x7f454c46@gmail.com>
    Cc: stable@vger.kernel.org
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Tariq Toukan <tariqt@mellanox.com>
    Link: https://lkml.kernel.org/r/20180604162224.471925894@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 08acd954f00e..74a9e06b6cfd 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -436,6 +436,8 @@ static inline void apic_set_eoi_write(void (*eoi_write)(u32 reg, u32 v)) {}
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 
+extern void apic_ack_irq(struct irq_data *data);
+
 static inline void ack_APIC_irq(void)
 {
 	/*

commit ef389b734691cdc8beb009dd402135dcdcb86a56
Merge: a774635db5c4 c76fc9826075
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Apr 12 09:42:34 2018 +0200

    Merge branch 'WIP.x86/asm' into x86/urgent, because the topic is ready
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a774635db5c430cbf21fa5d2f2df3d23aaa8e782
Author: Li RongQing <lirongqing@baidu.com>
Date:   Tue Apr 10 09:16:06 2018 +0800

    x86/apic: Fix signedness bug in APIC ID validity checks
    
    The APIC ID as parsed from ACPI MADT is validity checked with the
    apic->apic_id_valid() callback, which depends on the selected APIC type.
    
    For non X2APIC types APIC IDs >= 0xFF are invalid, but values > 0x7FFFFFFF
    are detected as valid. This happens because the 'apicid' argument of the
    apic_id_valid() callback is type 'int'. So the resulting comparison
    
       apicid < 0xFF
    
    evaluates to true for all unsigned int values > 0x7FFFFFFF which are handed
    to default_apic_id_valid(). As a consequence, invalid APIC IDs in !X2APIC
    mode are considered valid and accounted as possible CPUs.
    
    Change the apicid argument type of the apic_id_valid() callback to u32 so
    the evaluation is unsigned and returns the correct result.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Cc: jgross@suse.com
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/1523322966-10296-1-git-send-email-lirongqing@baidu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 98722773391d..f01eef8b392e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -319,7 +319,7 @@ struct apic {
 	/* Probe, setup and smpboot functions */
 	int	(*probe)(void);
 	int	(*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
-	int	(*apic_id_valid)(int apicid);
+	int	(*apic_id_valid)(u32 apicid);
 	int	(*apic_id_registered)(void);
 
 	bool	(*check_apicid_used)(physid_mask_t *map, int apicid);
@@ -492,7 +492,7 @@ static inline unsigned int read_apic_id(void)
 	return apic->get_apic_id(reg);
 }
 
-extern int default_apic_id_valid(int apicid);
+extern int default_apic_id_valid(u32 apicid);
 extern int default_acpi_madt_oem_check(char *, char *);
 extern void default_setup_apic_routing(void);
 

commit e25283bf83bd97a61007ab383695f4872e2eb43f
Author: David Rientjes <rientjes@google.com>
Date:   Sun Mar 25 14:04:30 2018 -0700

    x86/apic: Finish removing unused callbacks
    
    The ->cpu_mask_to_apicid() and ->vector_allocation_domain() callbacks are
    now unused, so remove them.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: baab1e84b112 ("x86/apic: Remove unused callbacks")
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1803251403540.80485@chino.kir.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c6a32019ff54..40a3d3642f3a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -304,12 +304,6 @@ struct apic {
 	u32	irq_delivery_mode;
 	u32	irq_dest_mode;
 
-	/* Functions and data related to vector allocation */
-	void	(*vector_allocation_domain)(int cpu, struct cpumask *retmask,
-					    const struct cpumask *mask);
-	int	(*cpu_mask_to_apicid)(const struct cpumask *cpumask,
-				      struct irq_data *irqdata,
-				      unsigned int *apicid);
 	u32	(*calc_dest_apicid)(unsigned int cpu);
 
 	/* ICR related functions */
@@ -499,17 +493,7 @@ extern void default_setup_apic_routing(void);
 extern u32 apic_default_calc_apicid(unsigned int cpu);
 extern u32 apic_flat_calc_apicid(unsigned int cpu);
 
-extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
-				   struct irq_data *irqdata,
-				   unsigned int *apicid);
-extern int default_cpu_mask_to_apicid(const struct cpumask *cpumask,
-				      struct irq_data *irqdata,
-				      unsigned int *apicid);
 extern bool default_check_apicid_used(physid_mask_t *map, int apicid);
-extern void flat_vector_allocation_domain(int cpu, struct cpumask *retmask,
-				   const struct cpumask *mask);
-extern void default_vector_allocation_domain(int cpu, struct cpumask *retmask,
-				      const struct cpumask *mask);
 extern void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap);
 extern int default_cpu_present_to_apicid(int mps_cpu);
 extern int default_check_phys_apicid_present(int phys_apicid);

commit b753a2b79a5bbad35dfaf8d3dba964727c30654a
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Feb 14 14:25:54 2018 +0800

    x86/apic: Make setup_local_APIC() static
    
    This function isn't used outside of apic.c, so let's mark it static.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bhe@redhat.com
    Cc: ebiederm@xmission.com
    Link: http://lkml.kernel.org/r/20180214062554.21020-1-douly.fnst@cn.fujitsu.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 6e1990d69865..c6a32019ff54 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -138,7 +138,6 @@ extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
 extern void apic_intr_mode_init(void);
-extern void setup_local_APIC(void);
 extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);

commit ccf5355d05cd891522267f04b2723002e7f061de
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Jan 17 15:37:48 2018 +0800

    x86/apic: Simplify init_bsp_APIC() usage
    
    Since CONFIG_X86_64 selects CONFIG_X86_LOCAL_APIC, the following
    condition:
    
      #if defined(CONFIG_X86_64) || defined(CONFIG_X86_LOCAL_APIC)
    
    is equivalent to:
    
      #if defined(CONFIG_X86_LOCAL_APIC)
    
    ... and we can eliminate that #ifdef by providing an empty
    init_bsp_APIC() stub in the !CONFIG_X86_LOCAL_APIC case.
    
    Also add some comments to explain why we call init_bsp_APIC().
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: mroos@linux.ee
    Cc: ville.syrjala@linux.intel.com
    Link: http://lkml.kernel.org/r/20180117073748.23905-1-douly.fnst@cn.fujitsu.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 98722773391d..6e1990d69865 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -183,6 +183,7 @@ static inline void disable_local_APIC(void) { }
 # define setup_boot_APIC_clock x86_init_noop
 # define setup_secondary_APIC_clock x86_init_noop
 static inline void lapic_update_tsc_freq(void) { }
+static inline void init_bsp_APIC(void) { }
 static inline void apic_intr_mode_init(void) { }
 static inline void lapic_assign_system_vectors(void) { }
 static inline void lapic_assign_legacy_vector(unsigned int i, bool r) { }

commit fc90ccfd286eabb05ec54521367df8663cf0bbbf
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 28 16:53:50 2017 +0200

    Revert "x86/apic: Remove init_bsp_APIC()"
    
    This reverts commit b371ae0d4a194b178817b0edfb6a7395c7aec37a. It causes
    boot hangs on old P3/P4 systems when the local APIC is enforced in UP mode.
    
    Reported-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/20171128145350.21560-1-ville.syrjala@linux.intel.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a9e57f08bfa6..98722773391d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -136,6 +136,7 @@ extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
+extern void init_bsp_APIC(void);
 extern void apic_intr_mode_init(void);
 extern void setup_local_APIC(void);
 extern void init_apic_mappings(void);

commit 2cffad7bad83157f89332872015f4305d2ac09ac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:53 2017 +0200

    x86/irq: Simplify hotplug vector accounting
    
    Before a CPU is taken offline the number of active interrupt vectors on the
    outgoing CPU and the number of vectors which are available on the other
    online CPUs are counted and compared. If the active vectors are more than
    the available vectors on the other CPUs then the CPU hot-unplug operation
    is aborted. This again uses loop based search and is inaccurate.
    
    The bitmap matrix allocator has accurate accounting information and can
    tell exactly whether the vector space is sufficient or not.
    
    Emit a message when the number of globaly reserved (unallocated) vectors is
    larger than the number of available vectors after offlining a CPU because
    after that point request_irq() might fail.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213156.351193962@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 7a8651921ed5..a9e57f08bfa6 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -386,6 +386,7 @@ extern struct apic *__apicdrivers[], *__apicdrivers_end[];
  */
 #ifdef CONFIG_SMP
 extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
+extern int lapic_can_unplug_cpu(void);
 #endif
 
 #ifdef CONFIG_X86_LOCAL_APIC

commit 0fa115da408f645cca419a60a5af8f4426ad4188
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:38 2017 +0200

    x86/irq/vector: Initialize matrix allocator
    
    Initialize the matrix allocator and add the proper accounting points to the
    code.
    
    No functional change, just preparation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213155.108410660@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 01bcaa8b62b3..7a8651921ed5 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -169,6 +169,10 @@ static inline int apic_is_clustered_box(void)
 #endif
 
 extern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
+extern void lapic_assign_system_vectors(void);
+extern void lapic_assign_legacy_vector(unsigned int isairq, bool replace);
+extern void lapic_online(void);
+extern void lapic_offline(void);
 
 #else /* !CONFIG_X86_LOCAL_APIC */
 static inline void lapic_shutdown(void) { }
@@ -179,6 +183,8 @@ static inline void disable_local_APIC(void) { }
 # define setup_secondary_APIC_clock x86_init_noop
 static inline void lapic_update_tsc_freq(void) { }
 static inline void apic_intr_mode_init(void) { }
+static inline void lapic_assign_system_vectors(void) { }
+static inline void lapic_assign_legacy_vector(unsigned int i, bool r) { }
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_X2APIC

commit 9f9e3bb1cf2ecba7697bfb5e350ad2648e69dbdf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:37 2017 +0200

    x86/apic: Add replacement for cpu_mask_to_apicid()
    
    As preparation for replacing the vector allocator, provide a new function
    which takes a cpu number instead of a cpu mask to calculate/lookup the
    resulting APIC destination id.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ff0bddabaa04..01bcaa8b62b3 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -303,6 +303,7 @@ struct apic {
 	int	(*cpu_mask_to_apicid)(const struct cpumask *cpumask,
 				      struct irq_data *irqdata,
 				      unsigned int *apicid);
+	u32	(*calc_dest_apicid)(unsigned int cpu);
 
 	/* ICR related functions */
 	u64	(*icr_read)(void);
@@ -486,6 +487,10 @@ static inline unsigned int read_apic_id(void)
 extern int default_apic_id_valid(int apicid);
 extern int default_acpi_madt_oem_check(char *, char *);
 extern void default_setup_apic_routing(void);
+
+extern u32 apic_default_calc_apicid(unsigned int cpu);
+extern u32 apic_flat_calc_apicid(unsigned int cpu);
+
 extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
 				   struct irq_data *irqdata,
 				   unsigned int *apicid);

commit c1d1ee9ac1793d939ba1a1322767cc5f77a5b8fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:25 2017 +0200

    x86/apic: Get rid of apic->target_cpus
    
    The target_cpus() callback of the apic struct is not really useful. Some
    APICs return cpu_online_mask and others cpus_all_mask. The latter is bogus
    as it does not take holes in the cpus_possible_mask into account.
    
    Replace it with cpus_online_mask which makes the most sense and remove the
    callback.
    
    The usage sites will be removed in a later step anyway, so get rid of it
    now to have incremental changes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213154.070850916@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e3e0883fa96f..ff0bddabaa04 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -298,7 +298,6 @@ struct apic {
 	u32	irq_dest_mode;
 
 	/* Functions and data related to vector allocation */
-	const struct cpumask *(*target_cpus)(void);
 	void	(*vector_allocation_domain)(int cpu, struct cpumask *retmask,
 					    const struct cpumask *mask);
 	int	(*cpu_mask_to_apicid)(const struct cpumask *cpumask,
@@ -484,8 +483,6 @@ static inline unsigned int read_apic_id(void)
 	return apic->get_apic_id(reg);
 }
 
-extern const struct cpumask *default_target_cpus(void);
-extern const struct cpumask *online_target_cpus(void);
 extern int default_apic_id_valid(int apicid);
 extern int default_acpi_madt_oem_check(char *, char *);
 extern void default_setup_apic_routing(void);

commit 72f48a38505de105e798d4783942df073aeab7ac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:23 2017 +0200

    x86/apic: Reorganize struct apic
    
    struct apic has just grown over time by adding function pointers in random
    places. Reorganize it so it becomes more cache line friendly.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.913642524@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1081cfb4f159..e3e0883fa96f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -274,73 +274,63 @@ struct irq_data;
  * James Cleverdon.
  */
 struct apic {
-	char *name;
-
-	int (*probe)(void);
-	int (*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
-	int (*apic_id_valid)(int apicid);
-	int (*apic_id_registered)(void);
-
-	u32 irq_delivery_mode;
-	u32 irq_dest_mode;
-
+	/* Hotpath functions first */
+	void	(*eoi_write)(u32 reg, u32 v);
+	void	(*native_eoi_write)(u32 reg, u32 v);
+	void	(*write)(u32 reg, u32 v);
+	u32	(*read)(u32 reg);
+
+	/* IPI related functions */
+	void	(*wait_icr_idle)(void);
+	u32	(*safe_wait_icr_idle)(void);
+
+	void	(*send_IPI)(int cpu, int vector);
+	void	(*send_IPI_mask)(const struct cpumask *mask, int vector);
+	void	(*send_IPI_mask_allbutself)(const struct cpumask *msk, int vec);
+	void	(*send_IPI_allbutself)(int vector);
+	void	(*send_IPI_all)(int vector);
+	void	(*send_IPI_self)(int vector);
+
+	/* dest_logical is used by the IPI functions */
+	u32	dest_logical;
+	u32	disable_esr;
+	u32	irq_delivery_mode;
+	u32	irq_dest_mode;
+
+	/* Functions and data related to vector allocation */
 	const struct cpumask *(*target_cpus)(void);
+	void	(*vector_allocation_domain)(int cpu, struct cpumask *retmask,
+					    const struct cpumask *mask);
+	int	(*cpu_mask_to_apicid)(const struct cpumask *cpumask,
+				      struct irq_data *irqdata,
+				      unsigned int *apicid);
 
-	int disable_esr;
-
-	int dest_logical;
-	bool (*check_apicid_used)(physid_mask_t *map, int apicid);
-
-	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask,
-					 const struct cpumask *mask);
-	void (*init_apic_ldr)(void);
-
-	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
-
-	void (*setup_apic_routing)(void);
-	int (*cpu_present_to_apicid)(int mps_cpu);
-	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
-	int (*check_phys_apicid_present)(int phys_apicid);
-	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
+	/* ICR related functions */
+	u64	(*icr_read)(void);
+	void	(*icr_write)(u32 low, u32 high);
 
-	unsigned int (*get_apic_id)(unsigned long x);
-	/* Can't be NULL on 64-bit */
-	u32 (*set_apic_id)(unsigned int id);
+	/* Probe, setup and smpboot functions */
+	int	(*probe)(void);
+	int	(*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
+	int	(*apic_id_valid)(int apicid);
+	int	(*apic_id_registered)(void);
 
-	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
-				  struct irq_data *irqdata,
-				  unsigned int *apicid);
+	bool	(*check_apicid_used)(physid_mask_t *map, int apicid);
+	void	(*init_apic_ldr)(void);
+	void	(*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
+	void	(*setup_apic_routing)(void);
+	int	(*cpu_present_to_apicid)(int mps_cpu);
+	void	(*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
+	int	(*check_phys_apicid_present)(int phys_apicid);
+	int	(*phys_pkg_id)(int cpuid_apic, int index_msb);
 
-	/* ipi */
-	void (*send_IPI)(int cpu, int vector);
-	void (*send_IPI_mask)(const struct cpumask *mask, int vector);
-	void (*send_IPI_mask_allbutself)(const struct cpumask *mask,
-					 int vector);
-	void (*send_IPI_allbutself)(int vector);
-	void (*send_IPI_all)(int vector);
-	void (*send_IPI_self)(int vector);
+	u32	(*get_apic_id)(unsigned long x);
+	u32	(*set_apic_id)(unsigned int id);
 
 	/* wakeup_secondary_cpu */
-	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
-
-	void (*inquire_remote_apic)(int apicid);
+	int	(*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
 
-	/* apic ops */
-	u32 (*read)(u32 reg);
-	void (*write)(u32 reg, u32 v);
-	/*
-	 * ->eoi_write() has the same signature as ->write().
-	 *
-	 * Drivers can support both ->eoi_write() and ->write() by passing the same
-	 * callback value. Kernel can override ->eoi_write() and fall back
-	 * on write for EOI.
-	 */
-	void (*eoi_write)(u32 reg, u32 v);
-	void (*native_eoi_write)(u32 reg, u32 v);
-	u64 (*icr_read)(void);
-	void (*icr_write)(u32 low, u32 high);
-	void (*wait_icr_idle)(void);
-	u32 (*safe_wait_icr_idle)(void);
+	void	(*inquire_remote_apic)(int apicid);
 
 #ifdef CONFIG_X86_32
 	/*
@@ -355,6 +345,7 @@ struct apic {
 	 */
 	int (*x86_32_early_logical_apicid)(int cpu);
 #endif
+	char	*name;
 };
 
 /*

commit 83a105229c59e433409e4d86e9bb915ca281235c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:22 2017 +0200

    x86/apic: Move common APIC callbacks
    
    Move more apic struct specific functions out of the header and the apic
    management code into the common source file.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.834421893@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 6561ea088b6a..1081cfb4f159 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -476,94 +476,45 @@ DECLARE_PER_CPU(int, x2apic_extra_bits);
 
 extern void generic_bigsmp_probe(void);
 
-
 #ifdef CONFIG_X86_LOCAL_APIC
 
 #include <asm/smp.h>
 
 #define APIC_DFR_VALUE	(APIC_DFR_FLAT)
 
-static inline const struct cpumask *default_target_cpus(void)
-{
-#ifdef CONFIG_SMP
-	return cpu_online_mask;
-#else
-	return cpumask_of(0);
-#endif
-}
-
-static inline const struct cpumask *online_target_cpus(void)
-{
-	return cpu_online_mask;
-}
-
 DECLARE_EARLY_PER_CPU_READ_MOSTLY(u16, x86_bios_cpu_apicid);
 
+extern struct apic apic_noop;
 
 static inline unsigned int read_apic_id(void)
 {
-	unsigned int reg;
-
-	reg = apic_read(APIC_ID);
+	unsigned int reg = apic_read(APIC_ID);
 
 	return apic->get_apic_id(reg);
 }
 
-static inline int default_apic_id_valid(int apicid)
-{
-	return (apicid < 255);
-}
-
+extern const struct cpumask *default_target_cpus(void);
+extern const struct cpumask *online_target_cpus(void);
+extern int default_apic_id_valid(int apicid);
 extern int default_acpi_madt_oem_check(char *, char *);
-
 extern void default_setup_apic_routing(void);
-
-extern struct apic apic_noop;
-
 extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
 				   struct irq_data *irqdata,
 				   unsigned int *apicid);
 extern int default_cpu_mask_to_apicid(const struct cpumask *cpumask,
 				      struct irq_data *irqdata,
 				      unsigned int *apicid);
-
-static inline void
-flat_vector_allocation_domain(int cpu, struct cpumask *retmask,
-			      const struct cpumask *mask)
-{
-	/* Careful. Some cpus do not strictly honor the set of cpus
-	 * specified in the interrupt destination when using lowest
-	 * priority interrupt delivery mode.
-	 *
-	 * In particular there was a hyperthreading cpu observed to
-	 * deliver interrupts to the wrong hyperthread when only one
-	 * hyperthread was specified in the interrupt desitination.
-	 */
-	cpumask_clear(retmask);
-	cpumask_bits(retmask)[0] = APIC_ALL_CPUS;
-}
-
-static inline void
-default_vector_allocation_domain(int cpu, struct cpumask *retmask,
-				 const struct cpumask *mask)
-{
-	cpumask_copy(retmask, cpumask_of(cpu));
-}
-
-static inline bool default_check_apicid_used(physid_mask_t *map, int apicid)
-{
-	return physid_isset(apicid, *map);
-}
-
-static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)
-{
-	*retmap = *phys_map;
-}
-
+extern bool default_check_apicid_used(physid_mask_t *map, int apicid);
+extern void flat_vector_allocation_domain(int cpu, struct cpumask *retmask,
+				   const struct cpumask *mask);
+extern void default_vector_allocation_domain(int cpu, struct cpumask *retmask,
+				      const struct cpumask *mask);
+extern void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap);
 extern int default_cpu_present_to_apicid(int mps_cpu);
 extern int default_check_phys_apicid_present(int phys_apicid);
 
 #endif /* CONFIG_X86_LOCAL_APIC */
+
 extern void irq_enter(void);
 extern void irq_exit(void);
 

commit 64063505835663c67cf18524c46e1eb70d30fb54
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:21 2017 +0200

    x86/apic: Sanitize 32/64bit APIC callbacks
    
    The 32bit and the 64bit implementation of default_cpu_present_to_apicid()
    and default_check_phys_apicid_present() are exactly the same, but
    implemented and located differently.
    
    Move them to common apic code and get rid of the pointless difference.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.757329991@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index cf10be9afde0..6561ea088b6a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -472,9 +472,6 @@ static inline unsigned default_get_apic_id(unsigned long x)
 extern void apic_send_IPI_self(int vector);
 
 DECLARE_PER_CPU(int, x2apic_extra_bits);
-
-extern int default_cpu_present_to_apicid(int mps_cpu);
-extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
 extern void generic_bigsmp_probe(void);
@@ -563,35 +560,8 @@ static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_ma
 	*retmap = *phys_map;
 }
 
-static inline int __default_cpu_present_to_apicid(int mps_cpu)
-{
-	if (mps_cpu < nr_cpu_ids && cpu_present(mps_cpu))
-		return (int)per_cpu(x86_bios_cpu_apicid, mps_cpu);
-	else
-		return BAD_APICID;
-}
-
-static inline int
-__default_check_phys_apicid_present(int phys_apicid)
-{
-	return physid_isset(phys_apicid, phys_cpu_present_map);
-}
-
-#ifdef CONFIG_X86_32
-static inline int default_cpu_present_to_apicid(int mps_cpu)
-{
-	return __default_cpu_present_to_apicid(mps_cpu);
-}
-
-static inline int
-default_check_phys_apicid_present(int phys_apicid)
-{
-	return __default_check_phys_apicid_present(phys_apicid);
-}
-#else
 extern int default_cpu_present_to_apicid(int mps_cpu);
 extern int default_check_phys_apicid_present(int phys_apicid);
-#endif
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 extern void irq_enter(void);

commit 1da91779e1fb79aaed3de118a156b7040f6147c5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:20 2017 +0200

    x86/apic: Move APIC noop specific functions
    
    Move more inlines to the place where they belong.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.677743545@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 06a023b2dca1..cf10be9afde0 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -523,13 +523,6 @@ extern void default_setup_apic_routing(void);
 
 extern struct apic apic_noop;
 
-#ifdef CONFIG_X86_32
-static inline int noop_x86_32_early_logical_apicid(int cpu)
-{
-	return BAD_APICID;
-}
-#endif
-
 extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
 				   struct irq_data *irqdata,
 				   unsigned int *apicid);

commit 0801bbaac00b2c729adb1b1b0e0945ca8bbea088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:19 2017 +0200

    x86/apic: Move probe32 specific APIC functions
    
    The apic functions which are used in probe_32.c are implemented as inlines
    or in apic.c. There is no reason to have them at random places.
    
    Move them to the actual usage site and make them static.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.596768194@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 63f4ad5123cc..06a023b2dca1 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -524,31 +524,10 @@ extern void default_setup_apic_routing(void);
 extern struct apic apic_noop;
 
 #ifdef CONFIG_X86_32
-
 static inline int noop_x86_32_early_logical_apicid(int cpu)
 {
 	return BAD_APICID;
 }
-
-/*
- * Set up the logical destination ID.
- *
- * Intel recommends to set DFR, LDR and TPR before enabling
- * an APIC.  See e.g. "AP-388 82489DX User's Manual" (Intel
- * document number 292116).  So here it goes...
- */
-extern void default_init_apic_ldr(void);
-
-static inline int default_apic_id_registered(void)
-{
-	return physid_isset(read_apic_id(), phys_cpu_present_map);
-}
-
-static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
-{
-	return cpuid_apic >> index_msb;
-}
-
 #endif
 
 extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,

commit 57e0aa446176493f69a8f8e270e9c4addca80772
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:18 2017 +0200

    x86/apic: Sanitize return value of check_apicid_used()
    
    The check is boolean, but the function returns unsigned long for no value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.516730518@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 86a3a359e603..63f4ad5123cc 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -289,7 +289,7 @@ struct apic {
 	int disable_esr;
 
 	int dest_logical;
-	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
+	bool (*check_apicid_used)(physid_mask_t *map, int apicid);
 
 	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask,
 					 const struct cpumask *mask);
@@ -581,7 +581,7 @@ default_vector_allocation_domain(int cpu, struct cpumask *retmask,
 	cpumask_copy(retmask, cpumask_of(cpu));
 }
 
-static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)
+static inline bool default_check_apicid_used(physid_mask_t *map, int apicid)
 {
 	return physid_isset(apicid, *map);
 }

commit 727657e6205d201e9acdb5d2c25bc1cd63c0ab16
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:17 2017 +0200

    x86/apic: Sanitize return value of apic.set_apic_id()
    
    The set_apic_id() callback returns an unsigned long value which is handed
    in to apic_write() as the value argument u32.
    
    Adjust the return value so it returns u32 right away.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.437208268@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 7d247b2d8c54..86a3a359e603 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -305,7 +305,7 @@ struct apic {
 
 	unsigned int (*get_apic_id)(unsigned long x);
 	/* Can't be NULL on 64-bit */
-	unsigned long (*set_apic_id)(unsigned int id);
+	u32 (*set_apic_id)(unsigned int id);
 
 	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
 				  struct irq_data *irqdata,

commit b371ae0d4a194b178817b0edfb6a7395c7aec37a
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Sep 13 17:12:55 2017 +0800

    x86/apic: Remove init_bsp_APIC()
    
    init_bsp_APIC() which works for the virtual wire mode is used in ISA irq
    initialization at boot time.
    
    With the new APIC interrupt delivery mode scheme, which initializes the
    APIC before the first interrupt is expected, init_bsp_APIC() is not longer
    required and can be removed.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/1505293975-26005-13-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 983a0dc564b3..7d247b2d8c54 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -136,7 +136,6 @@ extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
-extern void init_bsp_APIC(void);
 extern void apic_intr_mode_init(void);
 extern void setup_local_APIC(void);
 extern void init_apic_mappings(void);

commit 0c759131ae568f2e620485662104ab8c1e770c81
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Sep 13 17:12:50 2017 +0800

    x86/apic: Unify interrupt mode setup for UP system
    
    In UniProcessor kernel with UP_LATE_INIT=y, the interrupt delivery mode is
    initialized in up_late_init().
    
    Use the new unified apic_intr_mode_init() function and remove
    APIC_init_uniprocessor().
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/1505293975-26005-8-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 01f3fc8f8691..983a0dc564b3 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -144,7 +144,6 @@ void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern void lapic_update_tsc_freq(void);
-extern int APIC_init_uniprocessor(void);
 
 #ifdef CONFIG_X86_64
 static inline int apic_force_enable(unsigned long addr)

commit 4f45ed9f848f0721967e2f79e5409b6538894a43
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Sep 13 17:12:49 2017 +0800

    x86/apic: Mark the apic_intr_mode extern for sanity check cleanup
    
    Calling native_smp_prepare_cpus() to prepare for SMP bootup, does some
    sanity checking, enables APIC mode and disables SMP feature.
    
    Now, APIC mode setup has been unified to apic_intr_mode_init(), some sanity
    checks are redundant and need to be cleanup.
    
    Mark the apic_intr_mode extern to refine the switch and remove the
    redundant sanity check.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/1505293975-26005-7-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4e550c742130..01f3fc8f8691 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -53,6 +53,15 @@ extern int local_apic_timer_c2_ok;
 extern int disable_apic;
 extern unsigned int lapic_timer_frequency;
 
+extern enum apic_intr_mode_id apic_intr_mode;
+enum apic_intr_mode_id {
+	APIC_PIC,
+	APIC_VIRTUAL_WIRE,
+	APIC_VIRTUAL_WIRE_NO_CONFIG,
+	APIC_SYMMETRIC_IO,
+	APIC_SYMMETRIC_IO_NO_ROUTING
+};
+
 #ifdef CONFIG_SMP
 extern void __inquire_remote_apic(int apicid);
 #else /* CONFIG_SMP */

commit 4b1244b45c16cef63fa3282e5bb1cc4fa1aef06a
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Sep 13 17:12:47 2017 +0800

    x86/apic: Move logical APIC ID away from apic_bsp_setup()
    
    apic_bsp_setup() sets and returns logical APIC ID for initializing
    cpu0_logical_apicid in a SMP-capable system.
    
    The id has nothing to do with the initialization of local APIC and I/O
    APIC. And apic_bsp_setup() should be called for interrupt mode setup only.
    
    Move the id setup into a separate helper function for cleanup and mark
    apic_bsp_setup() void.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/1505293975-26005-5-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1a970f5a6e75..4e550c742130 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -146,7 +146,7 @@ static inline int apic_force_enable(unsigned long addr)
 extern int apic_force_enable(unsigned long addr);
 #endif
 
-extern int apic_bsp_setup(bool upmode);
+extern void apic_bsp_setup(bool upmode);
 extern void apic_ap_setup(void);
 
 /*

commit 4b1669e8d1e4e6cb65b3b114fced6ca9bc39ddea
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Sep 13 17:12:45 2017 +0800

    x86/apic: Prepare for unifying the interrupt delivery modes setup
    
    There are three places which initialize the interrupt delivery modes:
    
    1) init_bsp_APIC() which is called early might setup the through-local-APIC
       virtual wire mode on non SMP systems.
    
    2) In an SMP-capable system, native_smp_prepare_cpus() tries to switch to
       symmetric I/O model.
    
    3) In UP system with UP_LATE_INIT=y, the local APIC and I/O APIC are set up
       in smp_init().
    
    There is no technical reason to make these initializations at random places
    and run the kernel with the potentially wrong mode through the early boot
    stage, but it has a problematic side effect: The late switch to symmetric
    I/O mode causes dump-capture kernel to hang when the kernel command line
    option 'notsc' is active.
    
    Provide a new function to unify that three positions. Preparatory patch to
    initialize an interrupt mode directly.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Cc: bhe@redhat.com
    Link: https://lkml.kernel.org/r/1505293975-26005-3-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5f01671c68f2..1a970f5a6e75 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -128,6 +128,7 @@ extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
+extern void apic_intr_mode_init(void);
 extern void setup_local_APIC(void);
 extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
@@ -170,6 +171,7 @@ static inline void disable_local_APIC(void) { }
 # define setup_boot_APIC_clock x86_init_noop
 # define setup_secondary_APIC_clock x86_init_noop
 static inline void lapic_update_tsc_freq(void) { }
+static inline void apic_intr_mode_init(void) { }
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_X2APIC

commit 0e24f7c9f67e218546ad44160d2a12d9d8be0171
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:44 2017 +0200

    x86/apic: Add irq_data argument to apic->cpu_mask_to_apicid()
    
    The decision to which CPUs an interrupt is effectively routed happens in
    the various apic->cpu_mask_to_apicid() implementations
    
    To support effective affinity masks this information needs to be updated in
    irq_data. Add a pointer to irq_data to the callbacks and feed it through
    the call chain.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.720739075@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 3e64e99edc36..5f01671c68f2 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -252,6 +252,8 @@ static inline int x2apic_enabled(void) { return 0; }
 #define	x2apic_supported()	(0)
 #endif /* !CONFIG_X86_X2APIC */
 
+struct irq_data;
+
 /*
  * Copyright 2004 James Cleverdon, IBM.
  * Subject to the GNU Public License, v.2
@@ -297,6 +299,7 @@ struct apic {
 	unsigned long (*set_apic_id)(unsigned int id);
 
 	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
+				  struct irq_data *irqdata,
 				  unsigned int *apicid);
 
 	/* ipi */
@@ -540,8 +543,10 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 #endif
 
 extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
+				   struct irq_data *irqdata,
 				   unsigned int *apicid);
 extern int default_cpu_mask_to_apicid(const struct cpumask *cpumask,
+				      struct irq_data *irqdata,
 				      unsigned int *apicid);
 
 static inline void

commit 91cd9cb7ee1c081304d0e61f09e9faccb33d3df7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:43 2017 +0200

    x86/apic: Move cpumask and to core code
    
    All implementations of apic->cpu_mask_to_apicid_and() and the two incoming
    cpumasks to search for the target.
    
    Move that operation to the call site and rename it to cpu_mask_to_apicid()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.641575516@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a86be0a082d0..3e64e99edc36 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -296,9 +296,8 @@ struct apic {
 	/* Can't be NULL on 64-bit */
 	unsigned long (*set_apic_id)(unsigned int id);
 
-	int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
-				      const struct cpumask *andmask,
-				      unsigned int *apicid);
+	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
+				  unsigned int *apicid);
 
 	/* ipi */
 	void (*send_IPI)(int cpu, int vector);
@@ -540,12 +539,10 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 
 #endif
 
-extern int flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-				       const struct cpumask *andmask,
-				       unsigned int *apicid);
-extern int default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-					  const struct cpumask *andmask,
-					  unsigned int *apicid);
+extern int flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
+				   unsigned int *apicid);
+extern int default_cpu_mask_to_apicid(const struct cpumask *cpumask,
+				      unsigned int *apicid);
 
 static inline void
 flat_vector_allocation_domain(int cpu, struct cpumask *retmask,

commit ad95212ee6e0b62f38b287b40c9ab6a1ba3e892b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:40 2017 +0200

    x86/apic: Move flat_cpu_mask_to_apicid_and() into C source
    
    No point in having inlines assigned to function pointers at multiple
    places. Just bloats the text.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.405975721@linutronix.de

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bdffcd9eab2b..a86be0a082d0 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -540,28 +540,12 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 
 #endif
 
-static inline int
-flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			    const struct cpumask *andmask,
-			    unsigned int *apicid)
-{
-	unsigned long cpu_mask = cpumask_bits(cpumask)[0] &
-				 cpumask_bits(andmask)[0] &
-				 cpumask_bits(cpu_online_mask)[0] &
-				 APIC_ALL_CPUS;
-
-	if (likely(cpu_mask)) {
-		*apicid = (unsigned int)cpu_mask;
-		return 0;
-	} else {
-		return -EINVAL;
-	}
-}
-
-extern int
-default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			       const struct cpumask *andmask,
-			       unsigned int *apicid);
+extern int flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+				       const struct cpumask *andmask,
+				       unsigned int *apicid);
+extern int default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+					  const struct cpumask *andmask,
+					  unsigned int *apicid);
 
 static inline void
 flat_vector_allocation_domain(int cpu, struct cpumask *retmask,

commit 5d64d209c4f672e221ea304106b30793f10d95a4
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Wed Mar 8 19:07:50 2017 +0800

    x86/apic: Remove the SET_APIC_ID(x) macro
    
    The SET_APIC_ID() macro obfusates the code. Remove it to increase
    readability and add a comment to the apic struct to document that the
    callback is required on 64-bit.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Link: http://lkml.kernel.org/r/1488971270-14359-1-git-send-email-douly.fnst@cn.fujitsu.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 730ef65e8393..bdffcd9eab2b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -252,12 +252,6 @@ static inline int x2apic_enabled(void) { return 0; }
 #define	x2apic_supported()	(0)
 #endif /* !CONFIG_X86_X2APIC */
 
-#ifdef CONFIG_X86_64
-#define	SET_APIC_ID(x)		(apic->set_apic_id(x))
-#else
-
-#endif
-
 /*
  * Copyright 2004 James Cleverdon, IBM.
  * Subject to the GNU Public License, v.2
@@ -299,6 +293,7 @@ struct apic {
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
 
 	unsigned int (*get_apic_id)(unsigned long x);
+	/* Can't be NULL on 64-bit */
 	unsigned long (*set_apic_id)(unsigned int id);
 
 	int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,

commit 1a79a72c65b8f1b4f44e166d1fb5cad560461b26
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Feb 6 09:58:35 2017 +0100

    sched/headers, x86/apic: Remove the <linux/pm.h> header inclusion from <asm/apic.h>
    
    We want to simplify <linux/sched.h>'s header dependencies, but one
    roadblock to that is <asm/apic.h>'s inclusion of pm.h,
    which brings in other, problematic headers.
    
    Remove it, as it appears to be entirely spurious, apic.h does not
    actually make use of any PM facilities.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eff8e36aaf72..730ef65e8393 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -2,7 +2,6 @@
 #define _ASM_X86_APIC_H
 
 #include <linux/cpumask.h>
-#include <linux/pm.h>
 
 #include <asm/alternative.h>
 #include <asm/cpufeature.h>

commit a585df8edabdb47ae25214ebb3a627ca7ce800d3
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Jan 20 21:29:41 2017 +0100

    x86/MSR: Carve out bare minimum accessors
    
    Add __rdmsr() and __wrmsr() which *only* read and write an MSR with
    exception handling. Those are going to be used in early code, like the
    microcode loader, which cannot stomach tracing code piggybacking on the
    MSR operation.
    
    While at it, get rid of __native_write_msr_notrace().
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20170120202955.4091-3-bp@alien8.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 0c5fbc68e82d..eff8e36aaf72 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -195,7 +195,7 @@ static inline void native_apic_msr_write(u32 reg, u32 v)
 
 static inline void native_apic_msr_eoi_write(u32 reg, u32 v)
 {
-	wrmsr_notrace(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);
+	__wrmsr(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);
 }
 
 static inline u32 native_apic_msr_read(u32 reg)

commit 212f30008a284a9312d95dad6cc237ff81173d73
Merge: 6f3be0f04354 34bc3560c657
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 12 14:55:04 2016 -0800

    Merge branch 'x86-idle-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 idle updates from Ingo Molnar:
     "There were two bigger changes in this development cycle:
    
       - remove idle notifiers:
    
           32 files changed, 74 insertions(+), 803 deletions(-)
    
         These notifiers were of questionable value and the main usecase,
         the i7300 driver, was essentially unmaintained and can be removed,
         plus modern power management concepts don't need the callback - so
         use this golden opportunity and get rid of this opaque and fragile
         callback from a latency sensitive code path.
    
         (Len Brown, Thomas Gleixner)
    
       - improve the AMD Erratum 400 workaround that used high overhead MSR
         polling in the idle loop (Borisla Petkov, Thomas Gleixner)"
    
    * 'x86-idle-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86: Remove empty idle.h header
      x86/amd: Simplify AMD E400 aware idle routine
      x86/amd: Check for the C1E bug post ACPI subsystem init
      x86/bugs: Separate AMD E400 erratum and C1E bug
      x86/cpufeature: Provide helper to set bugs bits
      x86/idle: Remove enter_idle(), exit_idle()
      x86: Remove x86_test_and_clear_bit_percpu()
      x86/idle: Remove is_idle flag
      x86/idle: Remove idle_notifier
      i7300_idle: Remove this driver

commit 34bc3560c657d3d4fb17367ed9bfda803166dce0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 9 19:29:12 2016 +0100

    x86: Remove empty idle.h header
    
    One include less is always a good thing(tm). Good riddance.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lkml.kernel.org/r/20161209182912.2726-6-bp@alien8.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5731274bfdba..30a5642eb405 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -11,7 +11,6 @@
 #include <asm/fixmap.h>
 #include <asm/mpspec.h>
 #include <asm/msr.h>
-#include <asm/idle.h>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
 

commit 7a3e686e1bb57c34f73d3f19d620fe29035a6c99
Author: Len Brown <len.brown@intel.com>
Date:   Fri Nov 18 01:23:21 2016 -0500

    x86/idle: Remove enter_idle(), exit_idle()
    
    Upon removal of the is_idle flag, these routines became NOPs.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/822f2c22cc5890f7b8ea0eeec60277eb44505b4e.1479449716.git.len.brown@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f5aaf6c83222..5731274bfdba 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -639,7 +639,6 @@ extern void irq_exit(void);
 static inline void entering_irq(void)
 {
 	irq_enter();
-	exit_idle();
 }
 
 static inline void entering_ack_irq(void)

commit 8ca225520e278e41396dab0524989f4848626f83
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Mon Nov 7 11:13:40 2016 +0800

    x86/apic: Prevent tracing on apic_msr_write_eoi()
    
    The following RCU lockdep warning led to adding irq_enter()/irq_exit() into
    smp_reschedule_interrupt():
    
     RCU used illegally from idle CPU!
     rcu_scheduler_active = 1, debug_locks = 0
     RCU used illegally from extended quiescent state!
     no locks held by swapper/1/0.
    
      do_trace_write_msr
      native_write_msr
      native_apic_msr_eoi_write
      smp_reschedule_interrupt
      reschedule_interrupt
    
    As Peterz pointed out:
    
    | So now we're making a very frequent interrupt slower because of debug
    | code.
    |
    | The thing is, many many smp_reschedule_interrupt() invocations don't
    | actually execute anything much at all and are only sent to tickle the
    | return to user path (which does the actual preemption).
    |
    | Having to do the whole irq_enter/irq_exit dance just for this unlikely
    | debug case totally blows.
    
    Use the wrmsr_notrace() variant in native_apic_msr_write_eoi, annotate the
    kvm variant with notrace and add a native_apic_eoi callback to the apic
    structure so KVM guests are covered as well.
    
    This allows to revert the irq_enter/irq_exit dance in
    smp_reschedule_interrupt().
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Cc: kvm@vger.kernel.org
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1478488420-5982-3-git-send-email-wanpeng.li@hotmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f5aaf6c83222..a5a0bcfde76a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -196,7 +196,7 @@ static inline void native_apic_msr_write(u32 reg, u32 v)
 
 static inline void native_apic_msr_eoi_write(u32 reg, u32 v)
 {
-	wrmsr(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);
+	wrmsr_notrace(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);
 }
 
 static inline u32 native_apic_msr_read(u32 reg)
@@ -332,6 +332,7 @@ struct apic {
 	 * on write for EOI.
 	 */
 	void (*eoi_write)(u32 reg, u32 v);
+	void (*native_eoi_write)(u32 reg, u32 v);
 	u64 (*icr_read)(void);
 	void (*icr_write)(u32 low, u32 high);
 	void (*wait_icr_idle)(void);

commit b0f48706a176b71a6e54f399d7404bbeeaa7cfab
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Sun Sep 18 19:34:51 2016 +0800

    x86/apic: Order irq_enter/exit() calls correctly vs. ack_APIC_irq()
    
    ===============================
    [ INFO: suspicious RCU usage. ]
    4.8.0-rc6+ #5 Not tainted
    -------------------------------
    ./arch/x86/include/asm/msr-trace.h:47 suspicious rcu_dereference_check() usage!
    
    other info that might help us debug this:
    
    RCU used illegally from idle CPU!
    rcu_scheduler_active = 1, debug_locks = 0
    RCU used illegally from extended quiescent state!
    no locks held by swapper/2/0.
    
    stack backtrace:
    CPU: 2 PID: 0 Comm: swapper/2 Not tainted 4.8.0-rc6+ #5
    Hardware name: Dell Inc. OptiPlex 7020/0F5C5X, BIOS A03 01/08/2015
     0000000000000000 ffff8d1bd6003f10 ffffffff94446949 ffff8d1bd4a68000
     0000000000000001 ffff8d1bd6003f40 ffffffff940e9247 ffff8d1bbdfcf3d0
     000000000000080b 0000000000000000 0000000000000000 ffff8d1bd6003f70
    Call Trace:
     <IRQ>  [<ffffffff94446949>] dump_stack+0x99/0xd0
     [<ffffffff940e9247>] lockdep_rcu_suspicious+0xe7/0x120
     [<ffffffff9448e0d5>] do_trace_write_msr+0x135/0x140
     [<ffffffff9406e750>] native_write_msr+0x20/0x30
     [<ffffffff9406503d>] native_apic_msr_eoi_write+0x1d/0x30
     [<ffffffff9405b17e>] smp_trace_call_function_interrupt+0x1e/0x270
     [<ffffffff948cb1d6>] trace_call_function_interrupt+0x96/0xa0
     <EOI>  [<ffffffff947200f4>] ? cpuidle_enter_state+0xe4/0x360
     [<ffffffff947200df>] ? cpuidle_enter_state+0xcf/0x360
     [<ffffffff947203a7>] cpuidle_enter+0x17/0x20
     [<ffffffff940df008>] cpu_startup_entry+0x338/0x4d0
     [<ffffffff9405bfc4>] start_secondary+0x154/0x180
    
    This can be reproduced readily by running ftrace test case of kselftest.
    
    Move the irq_enter() call before ack_APIC_irq(), because irq_enter() tells
    the RCU susbstems to end the extended quiescent state, so that the
    following trace call in ack_APIC_irq() works correctly. The same applies to
    exiting_ack_irq() which calls ack_APIC_irq() after irq_exit().
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wanpeng Li <wanpeng.li@hotmail.com>
    Link: http://lkml.kernel.org/r/1474198491-3738-1-git-send-email-wanpeng.li@hotmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 124357773ffa..f5aaf6c83222 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -650,8 +650,8 @@ static inline void entering_ack_irq(void)
 
 static inline void ipi_entering_ack_irq(void)
 {
-	ack_APIC_irq();
 	irq_enter();
+	ack_APIC_irq();
 }
 
 static inline void exiting_irq(void)
@@ -661,9 +661,8 @@ static inline void exiting_irq(void)
 
 static inline void exiting_ack_irq(void)
 {
-	irq_exit();
-	/* Ack only at the end to avoid potential reentry */
 	ack_APIC_irq();
+	irq_exit();
 }
 
 extern void ioapic_zap_locks(void);

commit 6731b0d611a1274f9e785fa0189ac2aeeabd0591
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Jul 14 17:22:55 2016 +0200

    x86/timers/apic: Inform TSC deadline clockevent device about recalibration
    
    This patch eliminates a source of imprecise APIC timer interrupts,
    which imprecision may result in double interrupts or even late
    interrupts.
    
    The TSC deadline clockevent devices' configuration and registration
    happens before the TSC frequency calibration is refined in
    tsc_refine_calibration_work().
    
    This results in the TSC clocksource and the TSC deadline clockevent
    devices being configured with slightly different frequencies: the former
    gets the refined one and the latter are configured with the inaccurate
    frequency detected earlier by means of the "Fast TSC calibration using PIT".
    
    Within the APIC code, introduce the notifier function
    lapic_update_tsc_freq() which reconfigures all per-CPU TSC deadline
    clockevent devices with the current tsc_khz.
    
    Call it from the TSC code after TSC calibration refinement has happened.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Christopher S. Hall <christopher.s.hall@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Link: http://lkml.kernel.org/r/20160714152255.18295-3-nicstange@gmail.com
    [ Pushed #ifdef CONFIG_X86_LOCAL_APIC into header, improved changelog. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f5befd4945f2..124357773ffa 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -135,6 +135,7 @@ extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
+extern void lapic_update_tsc_freq(void);
 extern int APIC_init_uniprocessor(void);
 
 #ifdef CONFIG_X86_64
@@ -170,6 +171,7 @@ static inline void init_apic_mappings(void) { }
 static inline void disable_local_APIC(void) { }
 # define setup_boot_APIC_clock x86_init_noop
 # define setup_secondary_APIC_clock x86_init_noop
+static inline void lapic_update_tsc_freq(void) { }
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_X2APIC

commit 102bb9fef68a21f357dc813d4792666c8295bc35
Author: Wei Jiangang <weijg.fnst@cn.fujitsu.com>
Date:   Thu Jul 14 10:24:06 2016 +0800

    x86/apic: Remove the unused struct apic::apic_id_mask field
    
    The only user verify_local_APIC() had been removed by commit:
    
      4399c03c6780 ("x86/apic: Remove verify_local_APIC()")
    
    ... so there is no need to keep it.
    
    Signed-off-by: Wei Jiangang <weijg.fnst@cn.fujitsu.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: boris.ostrovsky@oracle.com
    Cc: bsd@redhat.com
    Cc: david.vrabel@citrix.com
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: xen-devel@lists.xenproject.org
    Link: http://lkml.kernel.org/r/1468463046-20849-1-git-send-email-weijg.fnst@cn.fujitsu.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bc27611fa58f..f5befd4945f2 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -300,7 +300,6 @@ struct apic {
 
 	unsigned int (*get_apic_id)(unsigned long x);
 	unsigned long (*set_apic_id)(unsigned int id);
-	unsigned long apic_id_mask;
 
 	int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
 				      const struct cpumask *andmask,

commit 62436a4d36c94d202784cd8a997ff8bb4b880237
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Mar 29 17:41:57 2016 +0200

    x86/cpufeature: Remove cpu_has_x2apic
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1459266123-21878-5-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 98f25bbafac4..bc27611fa58f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -239,10 +239,10 @@ extern void __init check_x2apic(void);
 extern void x2apic_setup(void);
 static inline int x2apic_enabled(void)
 {
-	return cpu_has_x2apic && apic_is_x2apic_enabled();
+	return boot_cpu_has(X86_FEATURE_X2APIC) && apic_is_x2apic_enabled();
 }
 
-#define x2apic_supported()	(cpu_has_x2apic)
+#define x2apic_supported()	(boot_cpu_has(X86_FEATURE_X2APIC))
 #else /* !CONFIG_X86_X2APIC */
 static inline void check_x2apic(void) { }
 static inline void x2apic_setup(void) { }

commit 7834c10313fb823e538f2772be78edcdeed2e6e3
Author: Dave Jones <davej@codemonkey.org.uk>
Date:   Mon Mar 14 21:20:54 2016 -0400

    x86/apic: Fix suspicious RCU usage in smp_trace_call_function_interrupt()
    
    Since 4.4, I've been able to trigger this occasionally:
    
    ===============================
    [ INFO: suspicious RCU usage. ]
    4.5.0-rc7-think+ #3 Not tainted
    Cc: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/20160315012054.GA17765@codemonkey.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    
    -------------------------------
    ./arch/x86/include/asm/msr-trace.h:47 suspicious rcu_dereference_check() usage!
    
    other info that might help us debug this:
    
    RCU used illegally from idle CPU!
    rcu_scheduler_active = 1, debug_locks = 1
    RCU used illegally from extended quiescent state!
    no locks held by swapper/3/0.
    
    stack backtrace:
    CPU: 3 PID: 0 Comm: swapper/3 Not tainted 4.5.0-rc7-think+ #3
     ffffffff92f821e0 1f3e5c340597d7fc ffff880468e07f10 ffffffff92560c2a
     ffff880462145280 0000000000000001 ffff880468e07f40 ffffffff921376a6
     ffffffff93665ea0 0000cc7c876d28da 0000000000000005 ffffffff9383dd60
    Call Trace:
     <IRQ>  [<ffffffff92560c2a>] dump_stack+0x67/0x9d
     [<ffffffff921376a6>] lockdep_rcu_suspicious+0xe6/0x100
     [<ffffffff925ae7a7>] do_trace_write_msr+0x127/0x1a0
     [<ffffffff92061c83>] native_apic_msr_eoi_write+0x23/0x30
     [<ffffffff92054408>] smp_trace_call_function_interrupt+0x38/0x360
     [<ffffffff92d1ca60>] trace_call_function_interrupt+0x90/0xa0
     <EOI>  [<ffffffff92ac5124>] ? cpuidle_enter_state+0x1b4/0x520
    
    Move the entering_irq() call before ack_APIC_irq(), because entering_irq()
    tells the RCU susbstems to end the extended quiescent state, so that the
    following trace call in ack_APIC_irq() works correctly.
    
    Suggested-by: Andi Kleen <ak@linux.intel.com>
    Fixes: 4787c368a9bc "x86/tracing: Add irq_enter/exit() in smp_trace_reschedule_interrupt()"
    Signed-off-by: Dave Jones <davej@codemonkey.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 0899cfc8dfe8..98f25bbafac4 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -643,8 +643,8 @@ static inline void entering_irq(void)
 
 static inline void entering_ack_irq(void)
 {
-	ack_APIC_irq();
 	entering_irq();
+	ack_APIC_irq();
 }
 
 static inline void ipi_entering_ack_irq(void)

commit cd4d09ec6f6c12a2cc3db5b7d8876a325a53545b
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Jan 26 22:12:04 2016 +0100

    x86/cpufeature: Carve out X86_FEATURE_*
    
    Move them to a separate header and have the following
    dependency:
    
      x86/cpufeatures.h <- x86/processor.h <- x86/cpufeature.h
    
    This makes it easier to use the header in asm code and not
    include the whole cpufeature.h and add guards for asm.
    
    Suggested-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1453842730-28463-5-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c80f6b6f3da2..0899cfc8dfe8 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -6,7 +6,6 @@
 
 #include <asm/alternative.h>
 #include <asm/cpufeature.h>
-#include <asm/processor.h>
 #include <asm/apicdef.h>
 #include <linux/atomic.h>
 #include <asm/fixmap.h>

commit b7c4948e9881fb38b048269f376fb4bf194ce24a
Author: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
Date:   Mon Dec 14 11:19:12 2015 +0100

    x86/apic: Introduce apic_extnmi command line parameter
    
    This patch introduces a command line parameter apic_extnmi:
    
     apic_extnmi=( bsp|all|none )
    
    The default value is "bsp" and this is the current behavior: only the
    Boot-Strapping Processor receives an external NMI.
    
    "all" allows external NMIs to be broadcast to all CPUs. This would
    raise the success rate of panic on NMI when BSP hangs in NMI context
    or the external NMI is swallowed by other NMI handlers on the BSP.
    
    If you specify "none", no CPUs receive external NMIs. This is useful for
    the dump capture kernel so that it cannot be shot down by accidentally
    pressing the external NMI button (on platforms which have it) while
    saving a crash dump.
    
    Signed-off-by: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Bandan Das <bsd@redhat.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: kexec@lists.infradead.org
    Cc: linux-doc@vger.kernel.org
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: x86-ml <x86@kernel.org>
    Link: http://lkml.kernel.org/r/20151210014632.25437.43778.stgit@softrs
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 7f62ad47d7e4..c80f6b6f3da2 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -23,6 +23,11 @@
 #define APIC_VERBOSE 1
 #define APIC_DEBUG   2
 
+/* Macros for apic_extnmi which controls external NMI masking */
+#define APIC_EXTNMI_BSP		0 /* Default */
+#define APIC_EXTNMI_ALL		1
+#define APIC_EXTNMI_NONE	2
+
 /*
  * Define the default level of output to be very little
  * This can be turned up by using apic=verbose for more

commit 539da7877275edb21a76aa02fb2c147eff02c559
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 22:57:00 2015 +0000

    x86/apic: Add a single-target IPI function to the apic
    
    We still fall back on the "send mask" versions if an apic definition
    doesn't have the single-target version, but at least this allows the
    (trivial) case for the common clustered x2apic case.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Borislav Petkov <bp@alien.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mike Travis <travis@sgi.com>
    Cc: Daniel J Blueman <daniel@numascale.com>
    Link: http://lkml.kernel.org/r/20151104220848.737120838@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a30316bf801a..7f62ad47d7e4 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -303,6 +303,7 @@ struct apic {
 				      unsigned int *apicid);
 
 	/* ipi */
+	void (*send_IPI)(int cpu, int vector);
 	void (*send_IPI_mask)(const struct cpumask *mask, int vector);
 	void (*send_IPI_mask_allbutself)(const struct cpumask *mask,
 					 int vector);

commit e02ae3871355194a61b03a07d96fd71e81d7eff9
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Sep 28 12:26:31 2015 +0200

    x86/x2apic: Make stub functions available even if !CONFIG_X86_LOCAL_APIC
    
    Some CONFIG_X86_X2APIC functions, especially x2apic_enabled(), are not
    declared if !CONFIG_X86_LOCAL_APIC.  However, the same stubs that work
    for !CONFIG_X86_X2APIC are okay even if there is no local APIC support
    at all.
    
    Avoid the introduction of #ifdefs by moving the x2apic declarations
    completely outside the CONFIG_X86_LOCAL_APIC block.  (Unfortunately,
    diff generation messes up the actual change that this patch makes).
    There is no semantic change because CONFIG_X86_X2APIC depends on
    CONFIG_X86_LOCAL_APIC.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Feng Wu <feng.wu@intel.com>
    Link: http://lkml.kernel.org/r/1443435991-35750-1-git-send-email-pbonzini@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ebf6d5e5668c..a30316bf801a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -115,6 +115,59 @@ static inline bool apic_is_x2apic_enabled(void)
 	return msr & X2APIC_ENABLE;
 }
 
+extern void enable_IR_x2apic(void);
+
+extern int get_physical_broadcast(void);
+
+extern int lapic_get_maxlvt(void);
+extern void clear_local_APIC(void);
+extern void disconnect_bsp_APIC(int virt_wire_setup);
+extern void disable_local_APIC(void);
+extern void lapic_shutdown(void);
+extern void sync_Arb_IDs(void);
+extern void init_bsp_APIC(void);
+extern void setup_local_APIC(void);
+extern void init_apic_mappings(void);
+void register_lapic_address(unsigned long address);
+extern void setup_boot_APIC_clock(void);
+extern void setup_secondary_APIC_clock(void);
+extern int APIC_init_uniprocessor(void);
+
+#ifdef CONFIG_X86_64
+static inline int apic_force_enable(unsigned long addr)
+{
+	return -1;
+}
+#else
+extern int apic_force_enable(unsigned long addr);
+#endif
+
+extern int apic_bsp_setup(bool upmode);
+extern void apic_ap_setup(void);
+
+/*
+ * On 32bit this is mach-xxx local
+ */
+#ifdef CONFIG_X86_64
+extern int apic_is_clustered_box(void);
+#else
+static inline int apic_is_clustered_box(void)
+{
+	return 0;
+}
+#endif
+
+extern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
+
+#else /* !CONFIG_X86_LOCAL_APIC */
+static inline void lapic_shutdown(void) { }
+#define local_apic_timer_c2_ok		1
+static inline void init_apic_mappings(void) { }
+static inline void disable_local_APIC(void) { }
+# define setup_boot_APIC_clock x86_init_noop
+# define setup_secondary_APIC_clock x86_init_noop
+#endif /* !CONFIG_X86_LOCAL_APIC */
+
 #ifdef CONFIG_X86_X2APIC
 /*
  * Make previous memory operations globally visible before
@@ -186,67 +239,14 @@ static inline int x2apic_enabled(void)
 }
 
 #define x2apic_supported()	(cpu_has_x2apic)
-#else
+#else /* !CONFIG_X86_X2APIC */
 static inline void check_x2apic(void) { }
 static inline void x2apic_setup(void) { }
 static inline int x2apic_enabled(void) { return 0; }
 
 #define x2apic_mode		(0)
 #define	x2apic_supported()	(0)
-#endif
-
-extern void enable_IR_x2apic(void);
-
-extern int get_physical_broadcast(void);
-
-extern int lapic_get_maxlvt(void);
-extern void clear_local_APIC(void);
-extern void disconnect_bsp_APIC(int virt_wire_setup);
-extern void disable_local_APIC(void);
-extern void lapic_shutdown(void);
-extern void sync_Arb_IDs(void);
-extern void init_bsp_APIC(void);
-extern void setup_local_APIC(void);
-extern void init_apic_mappings(void);
-void register_lapic_address(unsigned long address);
-extern void setup_boot_APIC_clock(void);
-extern void setup_secondary_APIC_clock(void);
-extern int APIC_init_uniprocessor(void);
-
-#ifdef CONFIG_X86_64
-static inline int apic_force_enable(unsigned long addr)
-{
-	return -1;
-}
-#else
-extern int apic_force_enable(unsigned long addr);
-#endif
-
-extern int apic_bsp_setup(bool upmode);
-extern void apic_ap_setup(void);
-
-/*
- * On 32bit this is mach-xxx local
- */
-#ifdef CONFIG_X86_64
-extern int apic_is_clustered_box(void);
-#else
-static inline int apic_is_clustered_box(void)
-{
-	return 0;
-}
-#endif
-
-extern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
-
-#else /* !CONFIG_X86_LOCAL_APIC */
-static inline void lapic_shutdown(void) { }
-#define local_apic_timer_c2_ok		1
-static inline void init_apic_mappings(void) { }
-static inline void disable_local_APIC(void) { }
-# define setup_boot_APIC_clock x86_init_noop
-# define setup_secondary_APIC_clock x86_init_noop
-#endif /* !CONFIG_X86_LOCAL_APIC */
+#endif /* !CONFIG_X86_X2APIC */
 
 #ifdef CONFIG_X86_64
 #define	SET_APIC_ID(x)		(apic->set_apic_id(x))

commit 656bba306827a44ed73b3f93f75bb3147de17fae
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 16 11:45:48 2015 -0400

    x86/smpboot: Remove APIC.wait_for_init_deassert and atomic init_deasserted
    
    Both the per-APIC flag ".wait_for_init_deassert",
    and the global atomic_t "init_deasserted"
    are dead code -- remove them.
    
    For all APIC types, "wait_for_master()"
    prevents an AP from proceeding until the BSP has set
    cpu_callout_mask, making "init_deasserted" {unnecessary}:
    
            BSP: <de-assert INIT>
            ...
            BSP: {set init_deasserted}
            AP: wait_for_master()
                    set cpu_initialized_mask
                    wait for cpu_callout_mask
            BSP: test cpu_initialized_mask
            BSP: set cpu_callout_mask
            AP: test cpu_callout_mask
            AP: {wait for init_deasserted}
            ...
            AP: <touch APIC>
    
    Deleting the {dead code} above is necessary to enable
    some parallelism in a future patch.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Igor Mammedov <imammedo@redhat.com>
    Cc: Jan H. Schönherr <jschoenh@amazon.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Zhu Guihua <zhugh.fnst@cn.fujitsu.com>
    Link: http://lkml.kernel.org/r/de4b3a9bab894735e285870b5296da25ee6a8a5a.1439739165.git.len.brown@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c8393634ca0c..ebf6d5e5668c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -313,7 +313,6 @@ struct apic {
 	/* wakeup_secondary_cpu */
 	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
 
-	bool wait_for_init_deassert;
 	void (*inquire_remote_apic)(int apicid);
 
 	/* apic ops */
@@ -378,7 +377,6 @@ extern struct apic *__apicdrivers[], *__apicdrivers_end[];
  * APIC functionality to boot other CPUs - only used on SMP:
  */
 #ifdef CONFIG_SMP
-extern atomic_t init_deasserted;
 extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
 #endif
 

commit 6dc178760553605c58d78bd403dfcb4e042c5b72
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 15 15:50:45 2015 +0200

    x86: Consolidate irq entering inlines
    
    smp.c and irq_work.c implement the same inline helper. Move it to
    apic.h and use it everywhere.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 976b86a325e5..c8393634ca0c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -644,6 +644,12 @@ static inline void entering_ack_irq(void)
 	entering_irq();
 }
 
+static inline void ipi_entering_ack_irq(void)
+{
+	ack_APIC_irq();
+	irq_enter();
+}
+
 static inline void exiting_irq(void)
 {
 	irq_exit();

commit 60f898eeaaa1c5d0162a4240bacf33a6c87ecef6
Merge: 977e1ba50893 3b75232d5568
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 13:16:36 2015 -0700

    Merge branch 'x86-asm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 asm changes from Ingo Molnar:
     "There were lots of changes in this development cycle:
    
       - over 100 separate cleanups, restructuring changes, speedups and
         fixes in the x86 system call, irq, trap and other entry code, part
         of a heroic effort to deobfuscate a decade old spaghetti asm code
         and its C code dependencies (Denys Vlasenko, Andy Lutomirski)
    
       - alternatives code fixes and enhancements (Borislav Petkov)
    
       - simplifications and cleanups to the compat code (Brian Gerst)
    
       - signal handling fixes and new x86 testcases (Andy Lutomirski)
    
       - various other fixes and cleanups
    
      By their nature many of these changes are risky - we tried to test
      them well on many different x86 systems (there are no known
      regressions), and they are split up finely to help bisection - but
      there's still a fair bit of residual risk left so caveat emptor"
    
    * 'x86-asm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (148 commits)
      perf/x86/64: Report regs_user->ax too in get_regs_user()
      perf/x86/64: Simplify regs_user->abi setting code in get_regs_user()
      perf/x86/64: Do report user_regs->cx while we are in syscall, in get_regs_user()
      perf/x86/64: Do not guess user_regs->cs, ss, sp in get_regs_user()
      x86/asm/entry/32: Tidy up JNZ instructions after TESTs
      x86/asm/entry/64: Reduce padding in execve stubs
      x86/asm/entry/64: Remove GET_THREAD_INFO() in ret_from_fork
      x86/asm/entry/64: Simplify jumps in ret_from_fork
      x86/asm/entry/64: Remove a redundant jump
      x86/asm/entry/64: Optimize [v]fork/clone stubs
      x86/asm/entry: Zero EXTRA_REGS for stub32_execve() too
      x86/asm/entry/64: Move stub_x32_execvecloser() to stub_execveat()
      x86/asm/entry/64: Use common code for rt_sigreturn() epilogue
      x86/asm/entry/64: Add forgotten CFI annotation
      x86/asm/entry/irq: Simplify interrupt dispatch table (IDT) layout
      x86/asm/entry/64: Move opportunistic sysret code to syscall code path
      x86, selftests: Add sigreturn selftest
      x86/alternatives: Guard NOPs optimization
      x86/asm/entry: Clear EXTRA_REGS for all executable formats
      x86/signal: Remove pax argument from restore_sigcontext
      ...

commit 4399c03c6780ed75fa26e09a7b3a175b3aac5760
Author: Bandan Das <bsd@redhat.com>
Date:   Tue Mar 31 16:43:17 2015 -0400

    x86/apic: Remove verify_local_APIC()
    
    __verify_local_APIC() is detritus from the early APIC days.
    Its return value isn't used anywhere and the information it
    prints when debug is enabled is already part of APIC
    initialization messages printed to syslog. Off with it!
    
    Signed-off-by: Bandan Das <bsd@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/jpgy4mcsxsq.fsf@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index efc3b22d896e..08f217354442 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -204,7 +204,6 @@ extern void clear_local_APIC(void);
 extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
-extern int verify_local_APIC(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
 extern void setup_local_APIC(void);

commit a930dc4543a2b213deb9fde12682716edff8a4a6
Author: Borislav Petkov <bp@suse.de>
Date:   Sun Jan 18 17:48:18 2015 +0100

    x86/asm: Cleanup prefetch primitives
    
    This is based on a patch originally by hpa.
    
    With the current improvements to the alternatives, we can simply use %P1
    as a mem8 operand constraint and rely on the toolchain to generate the
    proper instruction sizes. For example, on 32-bit, where we use an empty
    old instruction we get:
    
      apply_alternatives: feat: 6*32+8, old: (c104648b, len: 4), repl: (c195566c, len: 4)
      c104648b: alt_insn: 90 90 90 90
      c195566c: rpl_insn: 0f 0d 4b 5c
    
      ...
    
      apply_alternatives: feat: 6*32+8, old: (c18e09b4, len: 3), repl: (c1955948, len: 3)
      c18e09b4: alt_insn: 90 90 90
      c1955948: rpl_insn: 0f 0d 08
    
      ...
    
      apply_alternatives: feat: 6*32+8, old: (c1190cf9, len: 7), repl: (c1955a79, len: 7)
      c1190cf9: alt_insn: 90 90 90 90 90 90 90
      c1955a79: rpl_insn: 0f 0d 0d a0 d4 85 c1
    
    all with the proper padding done depending on the size of the
    replacement instruction the compiler generates.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index efc3b22d896e..8118e94d50ab 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -91,7 +91,7 @@ static inline void native_apic_mem_write(u32 reg, u32 v)
 {
 	volatile u32 *addr = (volatile u32 *)(APIC_BASE + reg);
 
-	alternative_io("movl %0, %1", "xchgl %0, %1", X86_BUG_11AP,
+	alternative_io("movl %0, %P1", "xchgl %0, %P1", X86_BUG_11AP,
 		       ASM_OUTPUT2("=r" (v), "=m" (*addr)),
 		       ASM_OUTPUT2("0" (v), "m" (*addr)));
 }

commit b273c2c2f2d2d13dc0bfa8923d52fbaf8fa56ae8
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Mon Feb 2 20:27:11 2015 +0100

    x86/apic: Fix the devicetree build in certain configs
    
    Without this patch:
    
      LD      init/built-in.o
      arch/x86/built-in.o: In function `dtb_lapic_setup': kernel/devicetree.c:155:
      undefined reference to `apic_force_enable'
      Makefile:923: recipe for target 'vmlinux' failed
      make: *** [vmlinux] Error 1
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Reviewed-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Link: http://lkml.kernel.org/r/1422905231-16067-1-git-send-email-ricardo.ribalda@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 92003f3c8a42..efc3b22d896e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -213,7 +213,15 @@ void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
+
+#ifdef CONFIG_X86_64
+static inline int apic_force_enable(unsigned long addr)
+{
+	return -1;
+}
+#else
 extern int apic_force_enable(unsigned long addr);
+#endif
 
 extern int apic_bsp_setup(bool upmode);
 extern void apic_ap_setup(void);

commit 374aab339f10f0510cec0e79d752d31d84b08aa2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:44 2015 +0000

    x86/apic: Reuse apic_bsp_setup() for UP APIC setup
    
    Extend apic_bsp_setup() so the same code flow can be used for
    APIC_init_uniprocessor().
    
    Folded Jiangs fix to provide proper ordering of the UP setup.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211704.084765674@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 92f34042be85..92003f3c8a42 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -215,7 +215,7 @@ extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
 extern int apic_force_enable(unsigned long addr);
 
-extern int apic_bsp_setup(void);
+extern int apic_bsp_setup(bool upmode);
 extern void apic_ap_setup(void);
 
 /*

commit 05f7e46d2aac359b6bcfc06b302bdd03ca0bcada
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:40 2015 +0000

    x86/smpboot: Move apic init code to apic.c
    
    We better provide proper functions which implement the required code
    flow in the apic code rather than letting the smpboot code open code
    it. That allows to make more functions static and confines the APIC
    functionality to apic.c where it belongs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Borislav Petkov <bp@alien8.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: http://lkml.kernel.org/r/20150115211703.907616730@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ac60c603f8dd..92f34042be85 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -201,7 +201,6 @@ extern int get_physical_broadcast(void);
 
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
-extern void connect_bsp_APIC(void);
 extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
@@ -209,8 +208,6 @@ extern int verify_local_APIC(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
 extern void setup_local_APIC(void);
-extern void end_local_APIC_setup(void);
-extern void bsp_end_local_APIC_setup(void);
 extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
@@ -218,6 +215,9 @@ extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
 extern int apic_force_enable(unsigned long addr);
 
+extern int apic_bsp_setup(void);
+extern void apic_ap_setup(void);
+
 /*
  * On 32bit this is mach-xxx local
  */

commit 659006bf3ae37a08706907ce1a36ddf57c9131d2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:26 2015 +0000

    x86/x2apic: Split enable and setup function
    
    enable_x2apic() is a convoluted unreadable mess because it is used for
    both enablement in early boot and for setup in cpu_init().
    
    Split the code into x2apic_enable() for enablement and x2apic_setup()
    for setup of (secondary cpus). Make use of the new state tracking to
    simplify the logic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211703.129287153@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5d7488e9b66e..ac60c603f8dd 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -179,7 +179,7 @@ static inline u64 native_x2apic_icr_read(void)
 extern int x2apic_mode;
 extern int x2apic_phys;
 extern void __init check_x2apic(void);
-extern void enable_x2apic(void);
+extern void x2apic_setup(void);
 static inline int x2apic_enabled(void)
 {
 	return cpu_has_x2apic && apic_is_x2apic_enabled();
@@ -188,7 +188,7 @@ static inline int x2apic_enabled(void)
 #define x2apic_supported()	(cpu_has_x2apic)
 #else
 static inline void check_x2apic(void) { }
-static inline void enable_x2apic(void) { }
+static inline void x2apic_setup(void) { }
 static inline int x2apic_enabled(void) { return 0; }
 
 #define x2apic_mode		(0)

commit 44e25ff9e6912347a1a54c757fc75681d0dc42d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:24 2015 +0000

    x86/x2apic: Disable x2apic from nox2apic setup
    
    There is no point in postponing the hardware disablement of x2apic. It
    can be disabled right away in the nox2apic setup function.
    
    Disable it right away and set the state to DISABLED . This allows to
    remove all the nox2apic conditionals all over the place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211703.051214090@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 951caa17d8ba..5d7488e9b66e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -187,7 +187,6 @@ static inline int x2apic_enabled(void)
 
 #define x2apic_supported()	(cpu_has_x2apic)
 #else
-static inline void disable_x2apic(void) { }
 static inline void check_x2apic(void) { }
 static inline void enable_x2apic(void) { }
 static inline int x2apic_enabled(void) { return 0; }

commit 55eae7de727e9ecc814853ec364fbbb352c337df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:19 2015 +0000

    x86/x2apic: Move code in conditional region
    
    No point in having try_to_enable_x2apic() outside of the
    CONFIG_X86_X2APIC section and having inline functions and more ifdefs
    to deal with it. Move the code into the existing ifdef section and
    remove the inline cruft.
    
    Fixup the printk about not enabling interrupt remapping as suggested
    by Boris.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211702.795388613@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ca8deb484d03..951caa17d8ba 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -186,27 +186,11 @@ static inline int x2apic_enabled(void)
 }
 
 #define x2apic_supported()	(cpu_has_x2apic)
-static inline void x2apic_force_phys(void)
-{
-	x2apic_phys = 1;
-}
 #else
-static inline void disable_x2apic(void)
-{
-}
-static inline void check_x2apic(void)
-{
-}
-static inline void enable_x2apic(void)
-{
-}
-static inline int x2apic_enabled(void)
-{
-	return 0;
-}
-static inline void x2apic_force_phys(void)
-{
-}
+static inline void disable_x2apic(void) { }
+static inline void check_x2apic(void) { }
+static inline void enable_x2apic(void) { }
+static inline int x2apic_enabled(void) { return 0; }
 
 #define x2apic_mode		(0)
 #define	x2apic_supported()	(0)

commit d524165cb8dbb2ce5916cd7682236b9324ae2644
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:17 2015 +0000

    x86/apic: Check x2apic early
    
    No point in delaying the x2apic detection for the CONFIG_X86_X2APIC=n
    case to enable_IR_x2apic(). We rather detect that before we try to
    setup anything there.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211702.702479404@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 392bbcf35471..ca8deb484d03 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -178,7 +178,7 @@ static inline u64 native_x2apic_icr_read(void)
 
 extern int x2apic_mode;
 extern int x2apic_phys;
-extern void check_x2apic(void);
+extern void __init check_x2apic(void);
 extern void enable_x2apic(void);
 static inline int x2apic_enabled(void)
 {

commit 2ca5b40479246087695d9e6343075b47ee6887ea
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:14 2015 +0000

    x86/ioapic: Check x2apic really
    
    The x2apic_preenabled flag is just a horrible hack and if X2APIC
    support is disabled it does not reflect the actual hardware
    state. Check the hardware instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/20150115211702.541280622@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index d2225fdc953e..392bbcf35471 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -178,7 +178,6 @@ static inline u64 native_x2apic_icr_read(void)
 
 extern int x2apic_mode;
 extern int x2apic_phys;
-extern int x2apic_preenabled;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
 static inline int x2apic_enabled(void)
@@ -210,7 +209,6 @@ static inline void x2apic_force_phys(void)
 }
 
 #define x2apic_mode		(0)
-#define	x2apic_preenabled	(0)
 #define	x2apic_supported()	(0)
 #endif
 

commit 81a46dd8249d7fa72a8557e58a38aa984e6b5e16
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:11 2015 +0000

    x86/apic: Make x2apic_mode depend on CONFIG_X86_X2APIC
    
    No point in having a static variable around which is always 0. Let the
    compiler optimize code out if disabled.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Borislav Petkov <bp@alien8.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: http://lkml.kernel.org/r/20150115211702.363274310@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1a8ba26c2fbd..d2225fdc953e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -106,8 +106,6 @@ extern u32 native_safe_apic_wait_icr_idle(void);
 extern void native_apic_icr_write(u32 low, u32 id);
 extern u64 native_apic_icr_read(void);
 
-extern int x2apic_mode;
-
 static inline bool apic_is_x2apic_enabled(void)
 {
 	u64 msr;
@@ -178,6 +176,7 @@ static inline u64 native_x2apic_icr_read(void)
 	return val;
 }
 
+extern int x2apic_mode;
 extern int x2apic_phys;
 extern int x2apic_preenabled;
 extern void check_x2apic(void);
@@ -210,8 +209,9 @@ static inline void x2apic_force_phys(void)
 {
 }
 
-#define	x2apic_preenabled 0
-#define	x2apic_supported()	0
+#define x2apic_mode		(0)
+#define	x2apic_preenabled	(0)
+#define	x2apic_supported()	(0)
 #endif
 
 extern void enable_IR_x2apic(void);

commit 8d80696060eedf49c080c0f2cf39a20ae7e787f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 15 21:22:09 2015 +0000

    x86/apic: Avoid open coded x2apic detection
    
    enable_IR_x2apic() grew a open coded x2apic detection. Implement a
    proper helper function which shares the code with the already existing
    x2apic_enabled().
    
    Made it use rdmsrl_safe as suggested by Boris.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: http://lkml.kernel.org/r/20150115211702.285038186@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 465b309af254..1a8ba26c2fbd 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -108,6 +108,15 @@ extern u64 native_apic_icr_read(void);
 
 extern int x2apic_mode;
 
+static inline bool apic_is_x2apic_enabled(void)
+{
+	u64 msr;
+
+	if (rdmsrl_safe(MSR_IA32_APICBASE, &msr))
+		return false;
+	return msr & X2APIC_ENABLE;
+}
+
 #ifdef CONFIG_X86_X2APIC
 /*
  * Make previous memory operations globally visible before
@@ -175,15 +184,7 @@ extern void check_x2apic(void);
 extern void enable_x2apic(void);
 static inline int x2apic_enabled(void)
 {
-	u64 msr;
-
-	if (!cpu_has_x2apic)
-		return 0;
-
-	rdmsrl(MSR_IA32_APICBASE, msr);
-	if (msr & X2APIC_ENABLE)
-		return 1;
-	return 0;
+	return cpu_has_x2apic && apic_is_x2apic_enabled();
 }
 
 #define x2apic_supported()	(cpu_has_x2apic)

commit 81c02a21b293faecab725f691d709111831e1944
Merge: d27c0d90184a 3eec595235c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 13 18:23:32 2014 -0600

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86/apic updates from Thomas Gleixner:
     "This is a major overhaul to the x86 apic subsystem consisting of the
      following parts:
    
       - Remove obsolete APIC driver abstractions (David Rientjes)
    
       - Use the irqdomain facilities to dynamically allocate IRQs for
         IOAPICs.  This is a prerequisite to enable IOAPIC hotplug support,
         and it also frees up wasted vectors (Jiang Liu)
    
       - Misc fixlets.
    
      Despite the hickup in Ingos previous pull request - caused by the
      missing fixup for the suspend/resume issue reported by Borislav - I
      strongly recommend that this update finds its way into 3.17.  Some
      history for you:
    
      This is preparatory work for physical IOAPIC hotplug.  The first
      attempt to support this was done by Yinghai and I shot it down because
      it just added another layer of obscurity and complexity to the already
      existing mess without tackling the underlying shortcomings of the
      current implementation.
    
      After quite some on- and offlist discussions, I requested that the
      design of this functionality must use generic infrastructure, i.e.
      irq domains, which provide all the mechanisms to dynamically map linux
      interrupt numbers to physical interrupts.
    
      Jiang picked up the idea and did a great job of consolidating the
      existing interfaces to manage the x86 (IOAPIC) interrupt system by
      utilizing irq domains.
    
      The testing in tip, Linux-next and inside of Intel on various machines
      did not unearth any oddities until Borislav exposed it to one of his
      oddball machines.  The issue was resolved quickly, but unfortunately
      the fix fell through the cracks and did not hit the tip tree before
      Ingo sent the pull request.  Not entirely Ingos fault, I also assumed
      that the fix was already merged when Ingo asked me whether he could
      send it.
    
      Nevertheless this work has a proper design, has undergone several
      rounds of review and the final fallout after applying it to tip and
      integrating it into Linux-next has been more than moderate.  It's the
      ground work not only for IOAPIC hotplug, it will also allow us to move
      the lowlevel vector allocation into the irqdomain hierarchy, which
      will benefit other architectures as well.  Patches are posted already,
      but they are on hold for two weeks, see below.
    
      I really appreciate the competence and responsiveness Jiang has shown
      in course of this endavour.  So I'm sure that any fallout of this will
      be addressed in a timely manner.
    
      FYI, I'm vanishing for 2 weeks into my annual kids summer camp kitchen
      duty^Wvacation, while you folks are drooling at KS/LinuxCon :) But HPA
      will have a look at the hopefully zero fallout until I'm back"
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (53 commits)
      x86, irq, PCI: Keep IRQ assignment for PCI devices during suspend/hibernation
      x86/apic/vsmp: Make is_vsmp_box() static
      x86, apic: Remove enable_apic_mode callback
      x86, apic: Remove setup_portio_remap callback
      x86, apic: Remove multi_timer_check callback
      x86, apic: Replace noop_check_apicid_used
      x86, apic: Remove check_apicid_present callback
      x86, apic: Remove mps_oem_check callback
      x86, apic: Remove smp_callin_clear_local_apic callback
      x86, apic: Replace trampoline physical addresses with defaults
      x86, apic: Remove x86_32_numa_cpu_node callback
      x86: intel-mid: Use the new io_apic interfaces
      x86, vsmp: Remove is_vsmp_box() from apic_is_clustered_box()
      x86, irq: Clean up irqdomain transition code
      x86, irq, devicetree: Release IOAPIC pin when PCI device is disabled
      x86, irq, SFI: Release IOAPIC pin when PCI device is disabled
      x86, irq, mpparse: Release IOAPIC pin when PCI device is disabled
      x86, irq, ACPI: Release IOAPIC pin when PCI device is disabled
      x86, irq: Introduce helper functions to release IOAPIC pin
      x86, irq: Simplify the way to handle ISA IRQ
      ...

commit 2f078b9cb8798cdabb7c2ff24b0b683eea546f96
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:51 2014 -0700

    x86, apic: Remove enable_apic_mode callback
    
    The enable_apic_mode() apic callback is never called, so remove it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302352320.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e776ed29b74c..c31fded99cf4 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -303,7 +303,6 @@ struct apic {
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 	int (*check_phys_apicid_present)(int phys_apicid);
-	void (*enable_apic_mode)(void);
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
 
 	unsigned int (*get_apic_id)(unsigned long x);

commit 11a8318ef5a69cdb9be61f726d6e078d70af6129
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:47 2014 -0700

    x86, apic: Remove setup_portio_remap callback
    
    Since commit b5660ba76b41 ("x86, platforms: Remove NUMAQ") removed NUMAQ,
    the setup_portio_remap() apic callback has been obsolete.  Remove it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302351480.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index d8da5fc6a54d..e776ed29b74c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -302,7 +302,6 @@ struct apic {
 	void (*setup_apic_routing)(void);
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
-	void (*setup_portio_remap)(void);
 	int (*check_phys_apicid_present)(int phys_apicid);
 	void (*enable_apic_mode)(void);
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);

commit e76661ba09353efd04e3435ac15bb9444f5cf1fa
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:43 2014 -0700

    x86, apic: Remove multi_timer_check callback
    
    Since commit b5660ba76b41 ("x86, platforms: Remove NUMAQ") removed NUMAQ,
    the multi_timer_check() apic callback has been obsolete.  Remove it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302351120.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e1c0c2d4a961..d8da5fc6a54d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -300,7 +300,6 @@ struct apic {
 	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
 
 	void (*setup_apic_routing)(void);
-	int (*multi_timer_check)(int apic, int irq);
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 	void (*setup_portio_remap)(void);

commit 658ffd7e6f5ce62e15df99df5f9e181d76ffda8e
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:37 2014 -0700

    x86, apic: Remove check_apicid_present callback
    
    The check_apicid_present() apic callback is never called, so remove it
    and functions that implement it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302350160.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 86d155026c3e..e1c0c2d4a961 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -292,7 +292,6 @@ struct apic {
 
 	int dest_logical;
 	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
-	unsigned long (*check_apicid_present)(int apicid);
 
 	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask,
 					 const struct cpumask *mask);
@@ -608,11 +607,6 @@ static inline unsigned long default_check_apicid_used(physid_mask_t *map, int ap
 	return physid_isset(apicid, *map);
 }
 
-static inline unsigned long default_check_apicid_present(int bit)
-{
-	return physid_isset(bit, phys_cpu_present_map);
-}
-
 static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)
 {
 	*retmap = *phys_map;

commit c460b5d34018d71fdeb8540620690883db3f959b
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:34 2014 -0700

    x86, apic: Remove mps_oem_check callback
    
    Since commit b5660ba76b41 ("x86, platforms: Remove NUMAQ") removed NUMAQ,
    the mps_oem_check() apic callback has been obsolete.  Remove it.
    
    This allows generic_mps_oem_check() to be removed as well.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302349390.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index b8c1380690e7..86d155026c3e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -309,13 +309,6 @@ struct apic {
 	void (*enable_apic_mode)(void);
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
 
-	/*
-	 * When one of the next two hooks returns 1 the apic
-	 * is switched to this. Essentially they are additional
-	 * probe functions:
-	 */
-	int (*mps_oem_check)(struct mpc_table *mpc, char *oem, char *productid);
-
 	unsigned int (*get_apic_id)(unsigned long x);
 	unsigned long (*set_apic_id)(unsigned int id);
 	unsigned long apic_id_mask;

commit 300eddf967920d35affa75db77c50c0fa493446a
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:30 2014 -0700

    x86, apic: Remove smp_callin_clear_local_apic callback
    
    Since commit b5660ba76b41 ("x86, platforms: Remove NUMAQ") removed NUMAQ,
    the smp_callin_clear_local_apic() apic callback has been obsolete.
    Remove it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302349040.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2201c262b00c..b8c1380690e7 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -336,7 +336,6 @@ struct apic {
 	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
 
 	bool wait_for_init_deassert;
-	void (*smp_callin_clear_local_apic)(void);
 	void (*inquire_remote_apic)(int apicid);
 
 	/* apic ops */

commit 6ab1b27c849106647c42b3ea0681a039552e24fa
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:27 2014 -0700

    x86, apic: Replace trampoline physical addresses with defaults
    
    The trampoline_phys_{high,low} members of struct apic are always
    initialized to DEFAULT_TRAMPOLINE_PHYS_HIGH and TRAMPOLINE_PHYS_LOW,
    respectively.  Hardwire the constants and remove the unneeded members.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302348330.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 067c2f83e329..2201c262b00c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -335,9 +335,6 @@ struct apic {
 	/* wakeup_secondary_cpu */
 	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
 
-	int trampoline_phys_low;
-	int trampoline_phys_high;
-
 	bool wait_for_init_deassert;
 	void (*smp_callin_clear_local_apic)(void);
 	void (*inquire_remote_apic)(int apicid);
@@ -480,10 +477,10 @@ static inline unsigned default_get_apic_id(unsigned long x)
 }
 
 /*
- * Warm reset vector default position:
+ * Warm reset vector position:
  */
-#define DEFAULT_TRAMPOLINE_PHYS_LOW		0x467
-#define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
+#define TRAMPOLINE_PHYS_LOW		0x467
+#define TRAMPOLINE_PHYS_HIGH		0x469
 
 #ifdef CONFIG_X86_64
 extern void apic_send_IPI_self(int vector);

commit 80a2670379b777ea45f2f6c73b2d2bc3f99066c8
Author: David Rientjes <rientjes@google.com>
Date:   Wed Jul 30 23:53:24 2014 -0700

    x86, apic: Remove x86_32_numa_cpu_node callback
    
    Since commit b5660ba76b41 ("x86, platforms: Remove NUMAQ") removed NUMAQ,
    the x86_32_numa_cpu_node() apic callback has been obsolete.  Remove it.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1407302348060.17503@chino.kir.corp.google.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index b40ea7e4bae9..067c2f83e329 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -370,14 +370,6 @@ struct apic {
 	 * won't be applied properly during early boot in this case.
 	 */
 	int (*x86_32_early_logical_apicid)(int cpu);
-
-	/*
-	 * Optional method called from setup_local_APIC() after logical
-	 * apicid is guaranteed to be known to initialize apicid -> node
-	 * mapping if NUMA initialization hasn't done so already.  Don't
-	 * add new users.
-	 */
-	int (*x86_32_numa_cpu_node)(int cpu);
 #endif
 };
 

commit 411cf9ee2946492c0ac7eca48422fcf94a723ce5
Author: Oren Twaig <oren@scalemp.com>
Date:   Sun Jun 29 13:01:08 2014 +0300

    x86, vsmp: Remove is_vsmp_box() from apic_is_clustered_box()
    
    When a vSMP Foundation box is detected, the function apic_cluster_num() counts
    the number of APIC clusters found. If more than one found, a multi board
    configuration is assumed, and TSC marked as unstable. This behavior is
    incorrect as vSMP Foundation may use processors from single node only, attached
    to memory of other nodes - and such node may have more than one APIC cluster
    (typically any recent intel box has more than single APIC_CLUSTERID(x)).
    
    To fix this, we simply remove the code which detects a vSMP Foundation box and
    affects apic_is_clusted_box() return value. This can be done because later the
    kernel checks by itself if the TSC is stable using the
    check_tsc_sync_[source|target]() functions and marks TSC as unstable if needed.
    
    Acked-by: Shai Fultheim <shai@scalemp.com>
    Signed-off-by: Oren Twaig <oren@scalemp.com>
    Link: http://lkml.kernel.org/r/1404036068-11674-1-git-send-email-oren@scalemp.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 69ed79aa9085..b40ea7e4bae9 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -85,14 +85,6 @@ static inline bool apic_from_smp_config(void)
 #include <asm/paravirt.h>
 #endif
 
-#ifdef CONFIG_X86_64
-extern int is_vsmp_box(void);
-#else
-static inline int is_vsmp_box(void)
-{
-	return 0;
-}
-#endif
 extern int setup_profiling_timer(unsigned int);
 
 static inline void native_apic_mem_write(u32 reg, u32 v)

commit a491cc902ca495365e9cd45154b60d8c702d86da
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 9 16:19:32 2014 +0800

    x86, mpparse: Simplify arch/x86/include/asm/mpspec.h
    
    Simplify arch/x86/include/asm/mpspec.h by
    1) Change max_physical_apicid to static as it's only used in apic.c.
    2) Kill declaration of mpc_default_type, it's never defined.
    3) Delete default_acpi_madt_oem_check(), it has already been declared
       in apic.h.
    4) Make default_acpi_madt_oem_check() depends on CONFIG_X86_LOCAL_APIC
       instead of CONFIG_X86_64 to support i386.
    5) Change mp_override_legacy_irq(), mp_config_acpi_legacy_irqs() and
       mp_register_gsi() as static because they are only used in acpi/boot.c.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: HATAYAMA Daisuke <d.hatayama@jp.fujitsu.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1402302011-23642-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 19b0ebafcd3e..69ed79aa9085 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -502,8 +502,6 @@ static inline unsigned default_get_apic_id(unsigned long x)
 #define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
 
 #ifdef CONFIG_X86_64
-extern int default_acpi_madt_oem_check(char *, char *);
-
 extern void apic_send_IPI_self(int vector);
 
 DECLARE_PER_CPU(int, x2apic_extra_bits);
@@ -552,6 +550,8 @@ static inline int default_apic_id_valid(int apicid)
 	return (apicid < 255);
 }
 
+extern int default_acpi_madt_oem_check(char *, char *);
+
 extern void default_setup_apic_routing(void);
 
 extern struct apic apic_noop;

commit 9b13a93df267af681a66a6a738bf1af10102da7d
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Jun 18 00:06:23 2014 +0200

    x86, cpufeature: Convert more "features" to bugs
    
    X86_FEATURE_FXSAVE_LEAK, X86_FEATURE_11AP and
    X86_FEATURE_CLFLUSH_MONITOR are not really features but synthetic bits
    we use for applying different bug workarounds. Call them what they
    really are, and make sure they get the proper cross-CPU behavior (OR
    rather than AND).
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: http://lkml.kernel.org/r/1403042783-23278-1-git-send-email-bp@alien8.de
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 19b0ebafcd3e..79752f2bdec5 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -99,7 +99,7 @@ static inline void native_apic_mem_write(u32 reg, u32 v)
 {
 	volatile u32 *addr = (volatile u32 *)(APIC_BASE + reg);
 
-	alternative_io("movl %0, %1", "xchgl %0, %1", X86_FEATURE_11AP,
+	alternative_io("movl %0, %1", "xchgl %0, %1", X86_BUG_11AP,
 		       ASM_OUTPUT2("=r" (v), "=m" (*addr)),
 		       ASM_OUTPUT2("0" (v), "m" (*addr)));
 }

commit dc9788f40a769d967de3eb5a7aee8c1a70094d32
Author: David Rientjes <rientjes@google.com>
Date:   Tue Feb 4 23:55:06 2014 -0800

    x86/apic: Always define nox2apic and define it as initdata
    
    The "nox2apic" variable can be defined as __initdata since it is
    only used for bootstrap.  It can now unconditionally be defined
    since it will later be freed.
    
    At the same time, it is also better off as a bool.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1402042354380.7839@chino.kir.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index b4c561dbe3ba..19b0ebafcd3e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -217,7 +217,6 @@ static inline void x2apic_force_phys(void)
 {
 }
 
-#define	nox2apic	0
 #define	x2apic_preenabled 0
 #define	x2apic_supported()	0
 #endif

commit 6d4989835e5418fdfda764fce7294246f80cf464
Author: David Rientjes <rientjes@google.com>
Date:   Tue Feb 4 23:55:04 2014 -0800

    x86/apic: Remove unused function prototypes
    
    Some function prototypes declared in asm/apic.h are never
    defined, so remove them.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1402042354210.7839@chino.kir.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c1d3074b8514..b4c561dbe3ba 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -93,9 +93,6 @@ static inline int is_vsmp_box(void)
 	return 0;
 }
 #endif
-extern void xapic_wait_icr_idle(void);
-extern u32 safe_xapic_wait_icr_idle(void);
-extern void xapic_icr_write(u32, u32);
 extern int setup_profiling_timer(unsigned int);
 
 static inline void native_apic_mem_write(u32 reg, u32 v)
@@ -184,7 +181,6 @@ extern int x2apic_phys;
 extern int x2apic_preenabled;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
-extern void x2apic_icr_write(u32 low, u32 id);
 static inline int x2apic_enabled(void)
 {
 	u64 msr;

commit 465822cfc8cb850ba76046965cc7b6fd1f8c3d73
Author: David Rientjes <rientjes@google.com>
Date:   Tue Feb 4 23:55:01 2014 -0800

    x86/apic: Switch wait_for_init_deassert() to a bool flag
    
    Now that there is only a single wait_for_init_deassert()
    function, just convert the member of struct apic to a bool to
    determine whether we need to wait for init_deassert to become
    non-zero.
    
    There are no more callers of default_wait_for_init_deassert(),
    so fold it into the caller.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1402042354010.7839@chino.kir.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2ef701381e2a..c1d3074b8514 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -351,7 +351,7 @@ struct apic {
 	int trampoline_phys_low;
 	int trampoline_phys_high;
 
-	void (*wait_for_init_deassert)(atomic_t *deassert);
+	bool wait_for_init_deassert;
 	void (*smp_callin_clear_local_apic)(void);
 	void (*inquire_remote_apic)(int apicid);
 
@@ -517,12 +517,6 @@ extern int default_cpu_present_to_apicid(int mps_cpu);
 extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
-static inline void default_wait_for_init_deassert(atomic_t *deassert)
-{
-	while (!atomic_read(deassert))
-		cpu_relax();
-}
-
 extern void generic_bigsmp_probe(void);
 
 

commit d3c63ae1e2e35e4250390c079dc3fb7291347f5c
Author: David Rientjes <rientjes@google.com>
Date:   Tue Feb 4 23:54:58 2014 -0800

    x86/apic: Only use default_wait_for_init_deassert()
    
    es7000_wait_for_init_deassert() is functionally equivalent to
    default_wait_for_init_deassert(), so remove the duplicate code
    and use only a single function.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1402042353030.7839@chino.kir.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1d2091a226bc..2ef701381e2a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -521,7 +521,6 @@ static inline void default_wait_for_init_deassert(atomic_t *deassert)
 {
 	while (!atomic_read(deassert))
 		cpu_relax();
-	return;
 }
 
 extern void generic_bigsmp_probe(void);

commit 17405453f4ad0220721a29978692081be6392b8f
Author: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
Date:   Tue Aug 20 16:01:07 2013 +0900

    x86/ioapic/kcrash: Prevent crash_kexec() from deadlocking on ioapic_lock
    
    Prevent crash_kexec() from deadlocking on ioapic_lock. When
    crash_kexec() is executed on a CPU, the CPU will take ioapic_lock
    in disable_IO_APIC(). So if the cpu gets an NMI while locking
    ioapic_lock, a deadlock will happen.
    
    In this patch, ioapic_lock is zapped/initialized before disable_IO_APIC().
    
    You can reproduce this deadlock the following way:
    
    1. Add mdelay(1000) after raw_spin_lock_irqsave() in
       native_ioapic_set_affinity()@arch/x86/kernel/apic/io_apic.c
    
       Although the deadlock can occur without this modification, it will increase
       the potential of the deadlock problem.
    
    2. Build and install the kernel
    
    3. Set up the OS which will run panic() and kexec when NMI is injected
        # echo "kernel.unknown_nmi_panic=1" >> /etc/sysctl.conf
        # vim /etc/default/grub
          add "nmi_watchdog=0 crashkernel=256M" in GRUB_CMDLINE_LINUX line
        # grub2-mkconfig
    
    4. Reboot the OS
    
    5. Run following command for each vcpu on the guest
        # while true; do echo <CPU num> > /proc/irq/<IO-APIC-edge or IO-APIC-fasteoi>/smp_affinitity; done;
       By running this command, cpus will get ioapic_lock for setting affinity.
    
    6. Inject NMI (push a dump button or execute 'virsh inject-nmi <domain>' if you
       use VM). After injecting NMI, panic() is called in an nmi-handler context.
       Then, kexec will normally run in panic(), but the operation will be stopped
       by deadlock on ioapic_lock in crash_kexec()->machine_crash_shutdown()->
       native_machine_crash_shutdown()->disable_IO_APIC()->clear_IO_APIC()->
       clear_IO_APIC_pin()->ioapic_read_entry().
    
    Signed-off-by: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Zhang Yanfei <zhangyanfei@cn.fujitsu.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: yrl.pp-manager.tt@hitachi.com
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Link: http://lkml.kernel.org/r/20130820070107.28245.83806.stgit@yunodevel
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f8119b582c3c..1d2091a226bc 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -715,4 +715,6 @@ static inline void exiting_ack_irq(void)
 	ack_APIC_irq();
 }
 
+extern void ioapic_zap_locks(void);
+
 #endif /* _ASM_X86_APIC_H */

commit eddc0e922a3530e0f22cef170229bcae3a7d5e31
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Thu Jun 20 11:45:17 2013 -0400

    x86, trace: Introduce entering/exiting_irq()
    
    When implementing tracepoints in interrupt handers, if the tracepoints are
    simply added in the performance sensitive path of interrupt handers,
    it may cause potential performance problem due to the time penalty.
    
    To solve the problem, an idea is to prepare non-trace/trace irq handers and
    switch their IDTs at the enabling/disabling time.
    
    So, let's introduce entering_irq()/exiting_irq() for pre/post-
    processing of each irq handler.
    
    A way to use them is as follows.
    
    Non-trace irq handler:
    smp_irq_handler()
    {
            entering_irq();         /* pre-processing of this handler */
            __smp_irq_handler();    /*
                                     * common logic between non-trace and trace handlers
                                     * in a vector.
                                     */
            exiting_irq();          /* post-processing of this handler */
    
    }
    
    Trace irq_handler:
    smp_trace_irq_handler()
    {
            entering_irq();         /* pre-processing of this handler */
            trace_irq_entry();      /* tracepoint for irq entry */
            __smp_irq_handler();    /*
                                     * common logic between non-trace and trace handlers
                                     * in a vector.
                                     */
            trace_irq_exit();       /* tracepoint for irq exit */
            exiting_irq();          /* post-processing of this handler */
    
    }
    
    If tracepoints can place outside entering_irq()/exiting_irq() as follows,
    it looks cleaner.
    
    smp_trace_irq_handler()
    {
            trace_irq_entry();
            smp_irq_handler();
            trace_irq_exit();
    }
    
    But it doesn't work.
    The problem is with irq_enter/exit() being called. They must be called before
    trace_irq_enter/exit(),  because of the rcu_irq_enter() must be called before
    any tracepoints are used, as tracepoints use  rcu to synchronize.
    
    As a possible alternative, we may be able to call irq_enter() first as follows
    if irq_enter() can nest.
    
    smp_trace_irq_hander()
    {
            irq_entry();
            trace_irq_entry();
            smp_irq_handler();
            trace_irq_exit();
            irq_exit();
    }
    
    But it doesn't work, either.
    If irq_enter() is nested, it may have a time penalty because it has to check if it
    was already called or not. The time penalty is not desired in performance sensitive
    paths even if it is tiny.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Link: http://lkml.kernel.org/r/51C3238D.9040706@hds.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 338803422239..f8119b582c3c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -12,6 +12,7 @@
 #include <asm/fixmap.h>
 #include <asm/mpspec.h>
 #include <asm/msr.h>
+#include <asm/idle.h>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
 
@@ -687,5 +688,31 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
 #endif /* CONFIG_X86_LOCAL_APIC */
+extern void irq_enter(void);
+extern void irq_exit(void);
+
+static inline void entering_irq(void)
+{
+	irq_enter();
+	exit_idle();
+}
+
+static inline void entering_ack_irq(void)
+{
+	ack_APIC_irq();
+	entering_irq();
+}
+
+static inline void exiting_irq(void)
+{
+	irq_exit();
+}
+
+static inline void exiting_ack_irq(void)
+{
+	irq_exit();
+	/* Ack only at the end to avoid potential reentry */
+	ack_APIC_irq();
+}
 
 #endif /* _ASM_X86_APIC_H */

commit 75fdd155eaf755aa183ca9844a9a178b7a0e3959
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:42 2012 -0700

    sections: fix section conflicts in arch/x86
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f34261296ffb..338803422239 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -409,7 +409,7 @@ extern struct apic *apic;
  * to enforce the order with in them.
  */
 #define apic_driver(sym)					\
-	static struct apic *__apicdrivers_##sym __used		\
+	static const struct apic *__apicdrivers_##sym __used		\
 	__aligned(sizeof(struct apic *))			\
 	__section(.apicdrivers) = { &sym }
 

commit 4cb38750d49010ae72e718d46605ac9ba5a851b4
Merge: 0a2fe19ccc4b 7efa1c87963d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 13:17:17 2012 -0700

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86/mm changes from Peter Anvin:
     "The big change here is the patchset by Alex Shi to use INVLPG to flush
      only the affected pages when we only need to flush a small page range.
    
      It also removes the special INVALIDATE_TLB_VECTOR interrupts (32
      vectors!) and replace it with an ordinary IPI function call."
    
    Fix up trivial conflicts in arch/x86/include/asm/apic.h (added code next
    to changed line)
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/tlb: Fix build warning and crash when building for !SMP
      x86/tlb: do flush_tlb_kernel_range by 'invlpg'
      x86/tlb: replace INVALIDATE_TLB_VECTOR by CALL_FUNCTION_VECTOR
      x86/tlb: enable tlb flush range support for x86
      mm/mmu_gather: enable tlb flush range in generic mmu_gather
      x86/tlb: add tlb_flushall_shift knob into debugfs
      x86/tlb: add tlb_flushall_shift for specific CPU
      x86/tlb: fall back to flush all when meet a THP large page
      x86/flush_tlb: try flush_tlb_single one by one in flush_tlb_range
      x86/tlb_info: get last level TLB entry number of CPU
      x86: Add read_mostly declaration/definition to variables from smp.h
      x86: Define early read-mostly per-cpu macros

commit 5fecc9d8f59e765c2a48379dd7c6f5cf88c7d75a
Merge: 3c4cfadef6a1 1a577b72475d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 12:01:20 2012 -0700

    Merge tag 'kvm-3.6-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Avi Kivity:
     "Highlights include
      - full big real mode emulation on pre-Westmere Intel hosts (can be
        disabled with emulate_invalid_guest_state=0)
      - relatively small ppc and s390 updates
      - PCID/INVPCID support in guests
      - EOI avoidance; 3.6 guests should perform better on 3.6 hosts on
        interrupt intensive workloads)
      - Lockless write faults during live migration
      - EPT accessed/dirty bits support for new Intel processors"
    
    Fix up conflicts in:
     - Documentation/virtual/kvm/api.txt:
    
       Stupid subchapter numbering, added next to each other.
    
     - arch/powerpc/kvm/booke_interrupts.S:
    
       PPC asm changes clashing with the KVM fixes
    
     - arch/s390/include/asm/sigp.h, arch/s390/kvm/sigp.c:
    
       Duplicated commits through the kvm tree and the s390 tree, with
       subsequent edits in the KVM tree.
    
    * tag 'kvm-3.6-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (93 commits)
      KVM: fix race with level interrupts
      x86, hyper: fix build with !CONFIG_KVM_GUEST
      Revert "apic: fix kvm build on UP without IOAPIC"
      KVM guest: switch to apic_set_eoi_write, apic_write
      apic: add apic_set_eoi_write for PV use
      KVM: VMX: Implement PCID/INVPCID for guests with EPT
      KVM: Add x86_hyper_kvm to complete detect_hypervisor_platform check
      KVM: PPC: Critical interrupt emulation support
      KVM: PPC: e500mc: Fix tlbilx emulation for 64-bit guests
      KVM: PPC64: booke: Set interrupt computation mode for 64-bit host
      KVM: PPC: bookehv: Add ESR flag to Data Storage Interrupt
      KVM: PPC: bookehv64: Add support for std/ld emulation.
      booke: Added crit/mc exception handler for e500v2
      booke/bookehv: Add host crit-watchdog exception support
      KVM: MMU: document mmu-lock and fast page fault
      KVM: MMU: fix kvm_mmu_pagetable_walk tracepoint
      KVM: MMU: trace fast page fault
      KVM: MMU: fast path of handling guest page fault
      KVM: MMU: introduce SPTE_MMU_WRITEABLE bit
      KVM: MMU: fold tlb flush judgement into mmu_spte_update
      ...

commit ebf7d2e9939f6571ef0b7381e7f95eb10f0c686b
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun Jul 15 15:56:58 2012 +0300

    Revert "apic: fix kvm build on UP without IOAPIC"
    
    This reverts commit f9808b7fd422b965cea52e05ba470e0a473c53d3.
    After commit 'kvm: switch to apic_set_eoi_write, apic_write'
    the stubs are no longer needed as kvm does not look at apicdrivers anymore.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Avi Kivity <avi@redhat.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ff8dff645e80..839b8f58a272 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -417,12 +417,7 @@ extern struct apic *apic;
 	__aligned(sizeof(struct apic *))				\
 	__section(.apicdrivers) = { &sym1, &sym2 }
 
-#ifdef CONFIG_X86_LOCAL_APIC
 extern struct apic *__apicdrivers[], *__apicdrivers_end[];
-#else
-#define __apicdrivers ((struct apic **)NULL)
-#define __apicdrivers_end ((struct apic **)NULL)
-#endif
 
 /*
  * APIC functionality to boot other CPUs - only used on SMP:

commit 1551df646dd42122e17401013dba7a509d0f1b0d
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun Jul 15 15:56:46 2012 +0300

    apic: add apic_set_eoi_write for PV use
    
    KVM PV EOI optimization overrides eoi_write apic op with its own
    version. Add an API for this to avoid meddling with core x86 apic driver
    data structures directly.
    
    For KVM use, we don't need any guarantees about when the switch to the
    new op will take place, so it could in theory use this API after SMP init,
    but it currently doesn't, and restricting callers to early init makes it
    clear that it's safe as it won't race with actual APIC driver use.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Avi Kivity <avi@redhat.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index aa5b2eec3602..ff8dff645e80 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -469,6 +469,8 @@ static inline u32 safe_apic_wait_icr_idle(void)
 	return apic->safe_wait_icr_idle();
 }
 
+extern void __init apic_set_eoi_write(void (*eoi_write)(u32 reg, u32 v));
+
 #else /* CONFIG_X86_LOCAL_APIC */
 
 static inline u32 apic_read(u32 reg) { return 0; }
@@ -478,6 +480,7 @@ static inline u64 apic_icr_read(void) { return 0; }
 static inline void apic_icr_write(u32 low, u32 high) { }
 static inline void apic_wait_icr_idle(void) { }
 static inline u32 safe_apic_wait_icr_idle(void) { return 0; }
+static inline void apic_set_eoi_write(void (*eoi_write)(u32 reg, u32 v)) {}
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 

commit 1ac322d0b169c95ce34d55b3ed6d40ce1a5f3a02
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Jun 25 13:38:28 2012 -0700

    x86/apic/x2apic: Limit the vector reservation to the user specified mask
    
    For the x2apic cluster mode, vector for an interrupt is
    currently reserved on all the cpu's that are part of the x2apic
    cluster. But the interrupts will be routed only to the cluster
    (derived from the first cpu in the mask) members specified in
    the mask. So there is no need to reserve the vector in the
    unused cluster members.
    
    Modify __assign_irq_vector() to reserve the vectors based on the
    user specified irq destination mask. If the new mask is a proper
    subset of the currently used mask, cleanup the vector allocation
    on the unused cpu members.
    
    Also, allow the apic driver to tune the vector domain based on
    the affinity mask (which in most cases is the user-specified
    mask).
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Link: http://lkml.kernel.org/r/1340656709-11423-3-git-send-email-suresh.b.siddha@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 8bebeb8952fb..88093c1d44fd 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -306,7 +306,8 @@ struct apic {
 	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
 	unsigned long (*check_apicid_present)(int apicid);
 
-	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
+	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask,
+					 const struct cpumask *mask);
 	void (*init_apic_ldr)(void);
 
 	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
@@ -615,7 +616,8 @@ default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 			       unsigned int *apicid);
 
 static inline void
-flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
+flat_vector_allocation_domain(int cpu, struct cpumask *retmask,
+			      const struct cpumask *mask)
 {
 	/* Careful. Some cpus do not strictly honor the set of cpus
 	 * specified in the interrupt destination when using lowest
@@ -630,7 +632,8 @@ flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
 }
 
 static inline void
-default_vector_allocation_domain(int cpu, struct cpumask *retmask)
+default_vector_allocation_domain(int cpu, struct cpumask *retmask,
+				 const struct cpumask *mask)
 {
 	cpumask_copy(retmask, cpumask_of(cpu));
 }

commit b39f25a849d7677a7dbf183f2483fd41c201a5ce
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Jun 25 13:38:27 2012 -0700

    x86/apic: Optimize cpu traversal in __assign_irq_vector() using domain membership
    
    Currently __assign_irq_vector() goes through each cpu in the
    specified mask until it finds a free vector in all the cpu's
    that are part of the same interrupt domain. We visit all the
    interrupt domain sibling cpus to reserve the free vector. So,
    when we fail to find a free vector in an interrupt domain, it is
    safe to continue our search with a cpu belonging to a new
    interrupt domain. No need to go through each cpu, if the domain
    containing that cpu is already visited.
    
    Use the irq_cfg's old_domain to track the visited domains and
    optimize the cpu traversal while finding a free vector in the
    given cpumask.
    
    NOTE: We can also optimize the search by using for_each_cpu() and
    skip the current cpu, if it is not the first cpu in the mask
    returned by the vector_allocation_domain(). But re-using the
    cfg->old_domain to track the visited domains will be slightly
    faster.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Link: http://lkml.kernel.org/r/1340656709-11423-2-git-send-email-suresh.b.siddha@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eec240e12091..8bebeb8952fb 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -306,7 +306,7 @@ struct apic {
 	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
 	unsigned long (*check_apicid_present)(int apicid);
 
-	bool (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
+	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
 	void (*init_apic_ldr)(void);
 
 	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
@@ -614,7 +614,7 @@ default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 			       const struct cpumask *andmask,
 			       unsigned int *apicid);
 
-static inline bool
+static inline void
 flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
 {
 	/* Careful. Some cpus do not strictly honor the set of cpus
@@ -627,14 +627,12 @@ flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
 	 */
 	cpumask_clear(retmask);
 	cpumask_bits(retmask)[0] = APIC_ALL_CPUS;
-	return false;
 }
 
-static inline bool
+static inline void
 default_vector_allocation_domain(int cpu, struct cpumask *retmask)
 {
 	cpumask_copy(retmask, cpumask_of(cpu));
-	return true;
 }
 
 static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)

commit f9808b7fd422b965cea52e05ba470e0a473c53d3
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun Jul 1 18:05:06 2012 +0300

    apic: fix kvm build on UP without IOAPIC
    
    On UP i386, when APIC is disabled
    # CONFIG_X86_UP_APIC is not set
    # CONFIG_PCI_IOAPIC is not set
    
    code looking at apicdrivers never has any effect but it
    still gets compiled in. In particular, this causes
    build failures with kvm, but it generally bloats the kernel
    unnecessarily.
    
    Fix by defining both __apicdrivers and __apicdrivers_end
    to be NULL when CONFIG_X86_LOCAL_APIC is unset: I verified
    that as the result any loop scanning __apicdrivers gets optimized out by
    the compiler.
    
    Warning: a .config with apic disabled doesn't seem to boot
    for me (even without this patch). Still verifying why,
    meanwhile this patch is compile-tested only.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eaff4790ed96..aa5b2eec3602 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -417,7 +417,12 @@ extern struct apic *apic;
 	__aligned(sizeof(struct apic *))				\
 	__section(.apicdrivers) = { &sym1, &sym2 }
 
+#ifdef CONFIG_X86_LOCAL_APIC
 extern struct apic *__apicdrivers[], *__apicdrivers_end[];
+#else
+#define __apicdrivers ((struct apic **)NULL)
+#define __apicdrivers_end ((struct apic **)NULL)
+#endif
 
 /*
  * APIC functionality to boot other CPUs - only used on SMP:

commit a5a391561bc25898ba1a702a0c4b028aa5b11ce9
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Jun 14 09:49:35 2012 +0200

    x86/apic: Eliminate cpu_mask_to_apicid() operation
    
    Since there are only two locations where cpu_mask_to_apicid() is
    called from, remove the operation and use only
    cpu_mask_to_apicid_and() instead.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Suggested-and-acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120614074935.GE3383@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1ed3eead2039..eec240e12091 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -331,8 +331,6 @@ struct apic {
 	unsigned long (*set_apic_id)(unsigned int id);
 	unsigned long apic_id_mask;
 
-	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
-				  unsigned int *apicid);
 	int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
 				      const struct cpumask *andmask,
 				      unsigned int *apicid);
@@ -594,9 +592,15 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 #endif
 
 static inline int
-__flat_cpu_mask_to_apicid(unsigned long cpu_mask, unsigned int *apicid)
+flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+			    const struct cpumask *andmask,
+			    unsigned int *apicid)
 {
-	cpu_mask = cpu_mask & APIC_ALL_CPUS & cpumask_bits(cpu_online_mask)[0];
+	unsigned long cpu_mask = cpumask_bits(cpumask)[0] &
+				 cpumask_bits(andmask)[0] &
+				 cpumask_bits(cpu_online_mask)[0] &
+				 APIC_ALL_CPUS;
+
 	if (likely(cpu_mask)) {
 		*apicid = (unsigned int)cpu_mask;
 		return 0;
@@ -605,27 +609,6 @@ __flat_cpu_mask_to_apicid(unsigned long cpu_mask, unsigned int *apicid)
 	}
 }
 
-static inline int
-flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
-			unsigned int *apicid)
-{
-	return __flat_cpu_mask_to_apicid(cpumask_bits(cpumask)[0], apicid);
-}
-
-static inline int
-flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			    const struct cpumask *andmask,
-			    unsigned int *apicid)
-{
-	unsigned long mask1 = cpumask_bits(cpumask)[0];
-	unsigned long mask2 = cpumask_bits(andmask)[0];
-	return __flat_cpu_mask_to_apicid(mask1 & mask2, apicid);
-}
-
-extern int
-default_cpu_mask_to_apicid(const struct cpumask *cpumask,
-			   unsigned int *apicid);
-
 extern int
 default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 			       const struct cpumask *andmask,

commit 0816b0f0365539c8f6280634d2c1778d0108d8f5
Author: Vlad Zolotarov <vlad@scalemp.com>
Date:   Mon Jun 11 12:56:52 2012 +0300

    x86: Add read_mostly declaration/definition to variables from smp.h
    
    Add "read-mostly" qualifier to the following variables in
    smp.h:
    
     - cpu_sibling_map
     - cpu_core_map
     - cpu_llc_shared_map
     - cpu_llc_id
     - cpu_number
     - x86_cpu_to_apicid
     - x86_bios_cpu_apicid
     - x86_cpu_to_logical_apicid
    
    As long as all the variables above are only written during the
    initialization, this change is meant to prevent the false
    sharing. More specifically, on vSMP Foundation platform
    x86_cpu_to_apicid shared the same internode_cache_line with
    frequently written lapic_events.
    
    From the analysis of the first 33 per_cpu variables out of 219
    (memories they describe, to be more specific) the 8 have read_mostly
    nature (tlb_vector_offset, cpu_loops_per_jiffy, xen_debug_irq, etc.)
    and 25 are frequently written (irq_stack_union, gdt_page,
    exception_stacks, idt_desc, etc.).
    
    Assuming that the spread of the rest of the per_cpu variables is
    similar, identifying the read mostly memories will make more sense
    in terms of long-term code maintenance comparing to identifying
    frequently written memories.
    
    Signed-off-by: Vlad Zolotarov <vlad@scalemp.com>
    Acked-by: Shai Fultheim <shai@scalemp.com>
    Cc: Shai Fultheim (Shai@ScaleMP.com) <Shai@scalemp.com>
    Cc: ido@wizery.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1719258.EYKzE4Zbq5@vlad
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eaff4790ed96..a907d4d251a8 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -537,7 +537,7 @@ static inline const struct cpumask *default_target_cpus(void)
 #endif
 }
 
-DECLARE_EARLY_PER_CPU(u16, x86_bios_cpu_apicid);
+DECLARE_EARLY_PER_CPU_READ_MOSTLY(u16, x86_bios_cpu_apicid);
 
 
 static inline unsigned int read_apic_id(void)

commit 4988a40c3981212fa8c64da68722affc1cb6697a
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Jun 7 15:16:25 2012 +0200

    x86/apic: Make cpu_mask_to_apicid() operations check cpu_online_mask
    
    Currently cpu_mask_to_apicid() should not get a offline CPU with
    the cpumask. Otherwise some apic drivers might try to access
    non-existent per-cpu variables (i.e. x2apic). In that regard
    cpu_mask_to_apicid() and cpu_mask_to_apicid_and() operations are
    inconsistent.
    
    This fix makes the two operations do not rely on calling
    functions and always return the apicid for only online CPUs. As
    result, the meaning and implementations of cpu_mask_to_apicid()
    and cpu_mask_to_apicid_and() operations become straight.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120607131624.GG4759@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ae91f9c7e360..1ed3eead2039 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -596,7 +596,7 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 static inline int
 __flat_cpu_mask_to_apicid(unsigned long cpu_mask, unsigned int *apicid)
 {
-	cpu_mask &= APIC_ALL_CPUS;
+	cpu_mask = cpu_mask & APIC_ALL_CPUS & cpumask_bits(cpu_online_mask)[0];
 	if (likely(cpu_mask)) {
 		*apicid = (unsigned int)cpu_mask;
 		return 0;
@@ -619,9 +619,7 @@ flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 {
 	unsigned long mask1 = cpumask_bits(cpumask)[0];
 	unsigned long mask2 = cpumask_bits(andmask)[0];
-	unsigned long mask3 = cpumask_bits(cpu_online_mask)[0];
-
-	return __flat_cpu_mask_to_apicid(mask1 & mask2 & mask3, apicid);
+	return __flat_cpu_mask_to_apicid(mask1 & mask2, apicid);
 }
 
 extern int

commit ff164324123c0fe181d8de7dadcc7b3fbe25f2cf
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Jun 7 15:15:59 2012 +0200

    x86/apic: Make cpu_mask_to_apicid() operations return error code
    
    Current cpu_mask_to_apicid() and cpu_mask_to_apicid_and()
    implementations have few shortcomings:
    
    1. A value returned by cpu_mask_to_apicid() is written to
    hardware registers unconditionally. Should BAD_APICID get ever
    returned it will be written to a hardware too. But the value of
    BAD_APICID is not universal across all hardware in all modes and
    might cause unexpected results, i.e. interrupts might get routed
    to CPUs that are not configured to receive it.
    
    2. Because the value of BAD_APICID is not universal it is
    counter- intuitive to return it for a hardware where it does not
    make sense (i.e. x2apic).
    
    3. cpu_mask_to_apicid_and() operation is thought as an
    complement to cpu_mask_to_apicid() that only applies a AND mask
    on top of a cpumask being passed. Yet, as consequence of 18374d8
    commit the two operations are inconsistent in that of:
      cpu_mask_to_apicid() should not get a offline CPU with the cpumask
      cpu_mask_to_apicid_and() should not fail and return BAD_APICID
    These limitations are impossible to realize just from looking at
    the operations prototypes.
    
    Most of these shortcomings are resolved by returning a error
    code instead of BAD_APICID. As the result, faults are reported
    back early rather than possibilities to cause a unexpected
    behaviour exist (in case of [1]).
    
    The only exception is setup_timer_IRQ0_pin() routine. Although
    obviously controversial to this fix, its existing behaviour is
    preserved to not break the fragile check_timer() and would
    better addressed in a separate fix.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120607131559.GF4759@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e3fecd50d5ca..ae91f9c7e360 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -331,9 +331,11 @@ struct apic {
 	unsigned long (*set_apic_id)(unsigned int id);
 	unsigned long apic_id_mask;
 
-	unsigned int (*cpu_mask_to_apicid)(const struct cpumask *cpumask);
-	unsigned int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
-					       const struct cpumask *andmask);
+	int (*cpu_mask_to_apicid)(const struct cpumask *cpumask,
+				  unsigned int *apicid);
+	int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
+				      const struct cpumask *andmask,
+				      unsigned int *apicid);
 
 	/* ipi */
 	void (*send_IPI_mask)(const struct cpumask *mask, int vector);
@@ -591,29 +593,45 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 
 #endif
 
-static inline unsigned int
-flat_cpu_mask_to_apicid(const struct cpumask *cpumask)
+static inline int
+__flat_cpu_mask_to_apicid(unsigned long cpu_mask, unsigned int *apicid)
 {
-	return cpumask_bits(cpumask)[0] & APIC_ALL_CPUS;
+	cpu_mask &= APIC_ALL_CPUS;
+	if (likely(cpu_mask)) {
+		*apicid = (unsigned int)cpu_mask;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
 }
 
-static inline unsigned int
+static inline int
+flat_cpu_mask_to_apicid(const struct cpumask *cpumask,
+			unsigned int *apicid)
+{
+	return __flat_cpu_mask_to_apicid(cpumask_bits(cpumask)[0], apicid);
+}
+
+static inline int
 flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			    const struct cpumask *andmask)
+			    const struct cpumask *andmask,
+			    unsigned int *apicid)
 {
 	unsigned long mask1 = cpumask_bits(cpumask)[0];
 	unsigned long mask2 = cpumask_bits(andmask)[0];
 	unsigned long mask3 = cpumask_bits(cpu_online_mask)[0];
 
-	return (unsigned int)(mask1 & mask2 & mask3);
+	return __flat_cpu_mask_to_apicid(mask1 & mask2 & mask3, apicid);
 }
 
-extern unsigned int
-default_cpu_mask_to_apicid(const struct cpumask *cpumask);
+extern int
+default_cpu_mask_to_apicid(const struct cpumask *cpumask,
+			   unsigned int *apicid);
 
-extern unsigned int
+extern int
 default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			       const struct cpumask *andmask);
+			       const struct cpumask *andmask,
+			       unsigned int *apicid);
 
 static inline bool
 flat_vector_allocation_domain(int cpu, struct cpumask *retmask)

commit 8637e38aff14d048b649075114023023a2e80fba
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Jun 7 15:15:44 2012 +0200

    x86/apic: Avoid useless scanning thru a cpumask in assign_irq_vector()
    
    In case of static vector allocation domains (i.e. flat) if all
    vector numbers are exhausted, an attempt to assign a new vector
    will lead to useless scans through all CPUs in the cpumask, even
    though it is known that each new pass would fail. Make this
    corner case less painful by letting report whether the vector
    allocation domain depends on passed arguments or not and stop
    scanning early.
    
    The same could have been achived by introducing a static flag to
    the apic operations. But let's allow vector_allocation_domain()
    have more intelligence here and decide dynamically, in case we
    would need it in the future.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120607131542.GE4759@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index feb2dbdae9ec..e3fecd50d5ca 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -306,7 +306,7 @@ struct apic {
 	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
 	unsigned long (*check_apicid_present)(int apicid);
 
-	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
+	bool (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
 	void (*init_apic_ldr)(void);
 
 	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
@@ -615,7 +615,7 @@ extern unsigned int
 default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 			       const struct cpumask *andmask);
 
-static inline void
+static inline bool
 flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
 {
 	/* Careful. Some cpus do not strictly honor the set of cpus
@@ -628,12 +628,14 @@ flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
 	 */
 	cpumask_clear(retmask);
 	cpumask_bits(retmask)[0] = APIC_ALL_CPUS;
+	return false;
 }
 
-static inline void
+static inline bool
 default_vector_allocation_domain(int cpu, struct cpumask *retmask)
 {
 	cpumask_copy(retmask, cpumask_of(cpu));
+	return true;
 }
 
 static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)

commit 9d8e10667624ea6411f04495aef1fa4a8a778ee8
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Jun 7 15:14:49 2012 +0200

    x86/apic: Factor out default vector_allocation_domain() operation
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120607131449.GC4759@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bef571769e68..feb2dbdae9ec 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -615,6 +615,27 @@ extern unsigned int
 default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 			       const struct cpumask *andmask);
 
+static inline void
+flat_vector_allocation_domain(int cpu, struct cpumask *retmask)
+{
+	/* Careful. Some cpus do not strictly honor the set of cpus
+	 * specified in the interrupt destination when using lowest
+	 * priority interrupt delivery mode.
+	 *
+	 * In particular there was a hyperthreading cpu observed to
+	 * deliver interrupts to the wrong hyperthread when only one
+	 * hyperthread was specified in the interrupt desitination.
+	 */
+	cpumask_clear(retmask);
+	cpumask_bits(retmask)[0] = APIC_ALL_CPUS;
+}
+
+static inline void
+default_vector_allocation_domain(int cpu, struct cpumask *retmask)
+{
+	cpumask_copy(retmask, cpumask_of(cpu));
+}
+
 static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)
 {
 	return physid_isset(apicid, *map);

commit 6398268d2bc454735f11e08705e858f9fdf5c750
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Tue Jun 5 13:23:44 2012 +0200

    x86/apic: Factor out default cpu_mask_to_apicid() operations
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120605112340.GA11454@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index fc38195d6405..bef571769e68 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -592,14 +592,14 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 #endif
 
 static inline unsigned int
-default_cpu_mask_to_apicid(const struct cpumask *cpumask)
+flat_cpu_mask_to_apicid(const struct cpumask *cpumask)
 {
 	return cpumask_bits(cpumask)[0] & APIC_ALL_CPUS;
 }
 
 static inline unsigned int
-default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
-			       const struct cpumask *andmask)
+flat_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+			    const struct cpumask *andmask)
 {
 	unsigned long mask1 = cpumask_bits(cpumask)[0];
 	unsigned long mask2 = cpumask_bits(andmask)[0];
@@ -608,6 +608,13 @@ default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 	return (unsigned int)(mask1 & mask2 & mask3);
 }
 
+extern unsigned int
+default_cpu_mask_to_apicid(const struct cpumask *cpumask);
+
+extern unsigned int
+default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+			       const struct cpumask *andmask);
+
 static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)
 {
 	return physid_isset(apicid, *map);

commit bf721d3a3bc7a731add45c8078b142b494ab413e
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Tue Jun 5 13:23:29 2012 +0200

    x86/apic: Factor out default target_cpus() operation
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20120605112324.GA11449@dhcp-26-207.brq.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eaff4790ed96..fc38195d6405 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -537,6 +537,11 @@ static inline const struct cpumask *default_target_cpus(void)
 #endif
 }
 
+static inline const struct cpumask *online_target_cpus(void)
+{
+	return cpu_online_mask;
+}
+
 DECLARE_EARLY_PER_CPU(u16, x86_bios_cpu_apicid);
 
 

commit 0ab711ae6ab0db7696b43c74f9ba9de4d7fc1deb
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed May 16 19:03:58 2012 +0300

    x86/apic: Implement EIO micro-optimization
    
    We know both register and value for eoi beforehand,
    so there's no need to check it and no need to do math
    to calculate the msr. Saves instructions/branches
    on each EOI when using x2apic.
    
    I looked at the objdump output to verify that the
    generated code looks right and actually is shorter.
    
    The real improvemements will be on the KVM guest side
    though, those come in a later patch.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: gleb@redhat.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/e019d1a125316f10d3e3a4b2f6bda41473f4fb72.1337184153.git.mst@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bf8d065dd977..eaff4790ed96 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -138,6 +138,11 @@ static inline void native_apic_msr_write(u32 reg, u32 v)
 	wrmsr(APIC_BASE_MSR + (reg >> 4), v, 0);
 }
 
+static inline void native_apic_msr_eoi_write(u32 reg, u32 v)
+{
+	wrmsr(APIC_BASE_MSR + (APIC_EOI >> 4), APIC_EOI_ACK, 0);
+}
+
 static inline u32 native_apic_msr_read(u32 reg)
 {
 	u64 msr;

commit 2a43195d831997551da93e6b3c22c965e93fe9cc
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed May 16 19:03:52 2012 +0300

    x86/apic: Add apic->eoi_write() callback
    
    Add eoi_write callback so that kvm can override
    eoi accesses without touching the rest of the apic.
    As a side-effect, this will enable a micro-optimization
    for apics using msr.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: gleb@redhat.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/0df425d746c49ac2ecc405174df87752869629d2.1337184153.git.mst@redhat.com
    [ tidied it up a bit ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a09e9ab0bbdf..bf8d065dd977 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -351,6 +351,14 @@ struct apic {
 	/* apic ops */
 	u32 (*read)(u32 reg);
 	void (*write)(u32 reg, u32 v);
+	/*
+	 * ->eoi_write() has the same signature as ->write().
+	 *
+	 * Drivers can support both ->eoi_write() and ->write() by passing the same
+	 * callback value. Kernel can override ->eoi_write() and fall back
+	 * on write for EOI.
+	 */
+	void (*eoi_write)(u32 reg, u32 v);
 	u64 (*icr_read)(void);
 	void (*icr_write)(u32 low, u32 high);
 	void (*wait_icr_idle)(void);
@@ -426,6 +434,11 @@ static inline void apic_write(u32 reg, u32 val)
 	apic->write(reg, val);
 }
 
+static inline void apic_eoi(void)
+{
+	apic->eoi_write(APIC_EOI, APIC_EOI_ACK);
+}
+
 static inline u64 apic_icr_read(void)
 {
 	return apic->icr_read();
@@ -450,6 +463,7 @@ static inline u32 safe_apic_wait_icr_idle(void)
 
 static inline u32 apic_read(u32 reg) { return 0; }
 static inline void apic_write(u32 reg, u32 val) { }
+static inline void apic_eoi(void) { }
 static inline u64 apic_icr_read(void) { return 0; }
 static inline void apic_icr_write(u32 low, u32 high) { }
 static inline void apic_wait_icr_idle(void) { }
@@ -463,7 +477,7 @@ static inline void ack_APIC_irq(void)
 	 * ack_APIC_irq() actually gets compiled as a single instruction
 	 * ... yummie.
 	 */
-	apic_write(APIC_EOI, APIC_EOI_ACK);
+	apic_eoi();
 }
 
 static inline unsigned default_get_apic_id(unsigned long x)

commit 4ebcc243901c48ee3baba6bdf179c7315fa8806f
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed May 16 19:03:44 2012 +0300

    x86/apic: Use symbolic APIC_EOI_ACK
    
    Use the symbol instead of hard-coded numbers,
    now that the reason for the value is documented
    where the constant is defined we don't need to
    duplicate this explanation in code.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: gleb@redhat.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/ecbe4c79d69c172378e47e5a587ff5cd10293c9f.1337184153.git.mst@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index d85410171260..a09e9ab0bbdf 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -463,9 +463,7 @@ static inline void ack_APIC_irq(void)
 	 * ack_APIC_irq() actually gets compiled as a single instruction
 	 * ... yummie.
 	 */
-
-	/* Docs say use 0 for future compatibility */
-	apic_write(APIC_EOI, 0);
+	apic_write(APIC_EOI, APIC_EOI_ACK);
 }
 
 static inline unsigned default_get_apic_id(unsigned long x)

commit 6b8212a313dae341ef3a2e413dfec5c4dea59617
Merge: bcd550745fc5 8abc3122aa02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 14:28:26 2012 -0700

    Merge branch 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 updates from Ingo Molnar.
    
    This touches some non-x86 files due to the sanitized INLINE_SPIN_UNLOCK
    config usage.
    
    Fixed up trivial conflicts due to just header include changes (removing
    headers due to cpu_idle() merge clashing with the <asm/system.h> split).
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/apic/amd: Be more verbose about LVT offset assignments
      x86, tls: Off by one limit check
      x86/ioapic: Add io_apic_ops driver layer to allow interception
      x86/olpc: Add debugfs interface for EC commands
      x86: Merge the x86_32 and x86_64 cpu_idle() functions
      x86/kconfig: Remove CONFIG_TR=y from the defconfigs
      x86: Stop recursive fault in print_context_stack after stack overflow
      x86/io_apic: Move and reenable irq only when CONFIG_GENERIC_PENDING_IRQ=y
      x86/apic: Add separate apic_id_valid() functions for selected apic drivers
      locking/kconfig: Simplify INLINE_SPIN_UNLOCK usage
      x86/kconfig: Update defconfigs
      x86: Fix excessive MSR print out when show_msr is not specified

commit f05e798ad4c09255f590f5b2c00a7ca6c172f983
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:11:12 2012 +0100

    Disintegrate asm/system.h for X86
    
    Disintegrate asm/system.h for X86.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    cc: x86@kernel.org

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a9371c91718c..4b2caeefe1a2 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -11,7 +11,6 @@
 #include <linux/atomic.h>
 #include <asm/fixmap.h>
 #include <asm/mpspec.h>
-#include <asm/system.h>
 #include <asm/msr.h>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1

commit b7157acf429e6aef690646ba964b9ebd25049ec2
Author: Steffen Persvold <sp@numascale.com>
Date:   Fri Mar 16 20:25:35 2012 +0100

    x86/apic: Add separate apic_id_valid() functions for selected apic drivers
    
    As suggested by Suresh Siddha and Yinghai Lu:
    
    For x2apic pre-enabled systems, apic driver is set already early
    through early_acpi_boot_init()/early_acpi_process_madt()/
    acpi_parse_madt()/default_acpi_madt_oem_check() path so that
    apic_id_valid() checking will be sufficient during MADT and SRAT
    parsing.
    
    For non-x2apic pre-enabled systems, all apic ids should be less
    than 255.
    
    This allows us to substitute the checks in
    arch/x86/kernel/acpi/boot.c::acpi_parse_x2apic() and
    arch/x86/mm/srat.c::acpi_numa_x2apic_affinity_init() with
    apic->apic_id_valid().
    
    In addition we can avoid feigning the x2apic cpu feature in the
    NumaChip apic code.
    
    The following apic drivers have separate apic_id_valid()
    functions which will accept x2apic type IDs :
    
     x2apic_phys
     x2apic_cluster
     x2apic_uv_x
     apic_numachip
    
    Signed-off-by: Steffen Persvold <sp@numascale.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Daniel J Blueman <daniel@numascale-asia.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Jack Steiner <steiner@sgi.com>
    Link: http://lkml.kernel.org/r/1331925935-13372-1-git-send-email-sp@numascale.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a9371c91718c..d3eaac44860a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -535,7 +535,7 @@ static inline unsigned int read_apic_id(void)
 
 static inline int default_apic_id_valid(int apicid)
 {
-	return x2apic_mode || (apicid < 255);
+	return (apicid < 255);
 }
 
 extern void default_setup_apic_routing(void);

commit fa63030e9c79e37b4d4e63b39ffb09cfb7aa0fe4
Author: Daniel J Blueman <daniel@numascale-asia.com>
Date:   Wed Mar 14 15:17:34 2012 +0800

    x86/platform: Move APIC ID validity check into platform APIC code
    
    Move APIC ID validity check into platform APIC code, so it can
    be overridden when needed. For NumaChip systems, always trust
    MADT, as it's constructed with high APIC IDs.
    
    Behaviour verifies on standard x86 systems and on NumaChip
    systems with this, and compile-tested with allyesconfig.
    
    Signed-off-by: Daniel J Blueman <daniel@numascale-asia.com>
    Reviewed-by: Steffen Persvold <sp@numascale.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Link: http://lkml.kernel.org/r/1331709454-27966-1-git-send-email-daniel@numascale-asia.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 3ab9bdd87e79..a9371c91718c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -288,6 +288,7 @@ struct apic {
 
 	int (*probe)(void);
 	int (*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
+	int (*apic_id_valid)(int apicid);
 	int (*apic_id_registered)(void);
 
 	u32 irq_delivery_mode;
@@ -532,6 +533,11 @@ static inline unsigned int read_apic_id(void)
 	return apic->get_apic_id(reg);
 }
 
+static inline int default_apic_id_valid(int apicid)
+{
+	return x2apic_mode || (apicid < 255);
+}
+
 extern void default_setup_apic_routing(void);
 
 extern struct apic apic_noop;

commit a31bc32760992a2c68f3d6bf7da9f760c0fd7c41
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 23 11:01:43 2011 -0800

    x86, x2apic: Allow "nox2apic" to disable x2apic mode setup by BIOS
    
    Currently "nox2apic" boot parameter was not enabling x2apic mode if the cpu,
    kernel are all capable of enabling x2apic mode and the OS handover
    happened in xapic mode.
    
    However If the bios enabled x2apic prior to OS handover, using "nox2apic"
    boot parameter had no effect.
    
    If the boot cpu's apicid is < 255, enable "nox2apic" boot parameter to
    disable the x2apic mode setup by the bios. This will enable the kernel to
    fallback to xapic mode and bringup only the cpu's which has apic-id < 255.
    
    -v2: fix patch error and two compiling warning
            make disable_x2apic to be __init
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Link: http://lkml.kernel.org/r/CAE9FiQUeB-3uxJAMiHsz=uPWoFv5Hg1pVepz7aU6YtqOxMC-=Q@mail.gmail.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a12d57193fef..3ab9bdd87e79 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -216,6 +216,7 @@ static inline void x2apic_force_phys(void)
 {
 }
 
+#define	nox2apic	0
 #define	x2apic_preenabled 0
 #define	x2apic_supported()	0
 #endif

commit fb209bd891645bb87b9618b724f0b4928e0df3de
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Dec 21 17:45:17 2011 -0800

    x86, x2apic: Fallback to xapic when BIOS doesn't setup interrupt-remapping
    
    On some of the recent Intel SNB platforms, by default bios is pre-enabling
    x2apic mode in the cpu with out setting up interrupt-remapping.
    This case was resulting in the kernel to panic as the cpu is already in
    x2apic mode but the OS was not able to enable interrupt-remapping (which
    is a pre-req for using x2apic capability).
    
    On these platforms all the apic-ids are < 255 and the kernel can fallback to
    xapic mode if the bios has not enabled interrupt-remapping (which is
    mostly the case if the bios has not exported interrupt-remapping tables to the
    OS).
    
    Reported-by: Berck E. Nash <flyboy@gmail.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/20111222014632.600418637@sbsiddha-desk.sc.intel.com
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a0f541a30944..a12d57193fef 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -176,6 +176,7 @@ static inline u64 native_x2apic_icr_read(void)
 }
 
 extern int x2apic_phys;
+extern int x2apic_preenabled;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
 extern void x2apic_icr_write(u32 low, u32 id);
@@ -198,6 +199,9 @@ static inline void x2apic_force_phys(void)
 	x2apic_phys = 1;
 }
 #else
+static inline void disable_x2apic(void)
+{
+}
 static inline void check_x2apic(void)
 {
 }

commit b49d7d877ff96428c8cd2076b33ba72bf85ceaba
Author: Fernando Luis Vazquez Cao <fernando@oss.ntt.co.jp>
Date:   Thu Dec 15 11:32:24 2011 +0900

    x86: Convert per-cpu counter icr_read_retry_count into a member of irq_stat
    
    LAPIC related statistics are grouped inside the per-cpu
    structure irq_stat, so there is no need for icr_read_retry_count
    to be a standalone per-cpu variable.
    
    This patch moves icr_read_retry_count to where it belongs.
    
    Suggested-y: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Fernando Luis Vazquez Cao <fernando@oss.ntt.co.jp>
    Cc: Jörn Engel <joern@logfs.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5fe0bd574756..a0f541a30944 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -411,8 +411,6 @@ extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
-DECLARE_PER_CPU(unsigned, icr_read_retry_count);
-
 static inline u32 apic_read(u32 reg)
 {
 	return apic->read(reg);

commit 346b46be5f10e4d247160ea94ac34450be60ce1e
Author: Fernando Luis Vázquez Cao <fernando@oss.ntt.co.jp>
Date:   Tue Dec 13 11:51:53 2011 +0900

    x86: Add per-cpu stat counter for APIC ICR read tries
    
    In the IPI delivery slow path (NMI delivery) we retry the ICR
    read to check for delivery completion a limited number of times.
    
    [ The reason for the limited retries is that some of the places
      where it is used (cpu boot, kdump, etc) IPI delivery might not
      succeed (due to a firmware bug or system crash, for example)
      and in such a case it is better to give up and resume
      execution of other code. ]
    
    This patch adds a new entry to /proc/interrupts, RTR, which
    tells user space the number of times we retried the ICR read in
    the IPI delivery slow path.
    
    This should give some insight into how well the APIC
    message delivery hardware is working - if the counts are way
    too large then we are hitting a (very-) slow path way too
    often.
    
    Signed-off-by: Fernando Luis Vazquez Cao <fernando@oss.ntt.co.jp>
    Cc: Jörn Engel <joern@logfs.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Link: http://lkml.kernel.org/n/tip-vzsp20lo2xdzh5f70g0eis2s@git.kernel.org
    [ extended the changelog ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1a6c09af048f..5fe0bd574756 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -410,6 +410,9 @@ extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
 #endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
+
+DECLARE_PER_CPU(unsigned, icr_read_retry_count);
+
 static inline u32 apic_read(u32 reg)
 {
 	return apic->read(reg);

commit 1ade93efd0a3dda5b0c0afda8ab8f4bd12938c1b
Author: Jacob Pan <jacob.jun.pan@intel.com>
Date:   Thu Nov 10 13:42:40 2011 +0000

    x86/apic: Allow use of lapic timer early calibration result
    
    lapic timer calibration can be combined with tsc in platform
    specific calibration functions. if such calibration result is
    obtained early, we can skip the redundant calibration loops.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 9b7273cb2193..1a6c09af048f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -49,6 +49,7 @@ extern unsigned int apic_verbosity;
 extern int local_apic_timer_c2_ok;
 
 extern int disable_apic;
+extern unsigned int lapic_timer_frequency;
 
 #ifdef CONFIG_SMP
 extern void __inquire_remote_apic(int apicid);

commit 838312be46f3abfbdc175f81c3e54a857994476d
Author: Jan Beulich <JBeulich@suse.com>
Date:   Wed Sep 28 16:44:54 2011 +0100

    apic, i386/bigsmp: Fix false warnings regarding logical APIC ID mismatches
    
    These warnings (generally one per CPU) are a result of
    initializing x86_cpu_to_logical_apicid while apic_default is
    still in use, but the check in setup_local_APIC() being done
    when apic_bigsmp was already used as an override in
    default_setup_apic_routing():
    
     Overriding APIC driver with bigsmp
     Enabling APIC mode:  Physflat.  Using 5 I/O APICs
     ------------[ cut here ]------------
     WARNING: at .../arch/x86/kernel/apic/apic.c:1239
     ...
     CPU 1 irqstacks, hard=f1c9a000 soft=f1c9c000
     Booting Node   0, Processors  #1
     smpboot cpu 1: start_ip = 9e000
     Initializing CPU#1
     ------------[ cut here ]------------
     WARNING: at .../arch/x86/kernel/apic/apic.c:1239
     setup_local_APIC+0x137/0x46b() Hardware name: ...
     CPU1 logical APIC ID: 2 != 8
     ...
    
    Fix this (for the time being, i.e. until
    x86_32_early_logical_apicid() will get removed again, as Tejun
    says ought to be possible) by overriding the previously stored
    values at the point where the APIC driver gets overridden.
    
    v2: Move this and the pre-existing override logic into
        arch/x86/kernel/apic/bigsmp_32.c.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Cc: <stable@kernel.org> (2.6.39 and onwards)
    Link: http://lkml.kernel.org/r/4E835D16020000780005844C@nat28.tlf.novell.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 7b3ca8324b69..9b7273cb2193 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -495,7 +495,7 @@ static inline void default_wait_for_init_deassert(atomic_t *deassert)
 	return;
 }
 
-extern struct apic *generic_bigsmp_probe(void);
+extern void generic_bigsmp_probe(void);
 
 
 #ifdef CONFIG_X86_LOCAL_APIC

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4a0b7c7e2cce..7b3ca8324b69 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -8,7 +8,7 @@
 #include <asm/cpufeature.h>
 #include <asm/processor.h>
 #include <asm/apicdef.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/fixmap.h>
 #include <asm/mpspec.h>
 #include <asm/system.h>

commit 1a8880a14270814dae0d226a2ad065d30587e60a
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Fri May 20 17:51:20 2011 -0700

    x86, apic: Make apic drivers static
    
    Apic probe now looks at the apic drivers listed in the
    .apicdrivers section. Remove apic_probe[] and make each apic
    driver static.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Tested-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: steiner@sgi.com
    Cc: gorcunov@openvz.org
    Cc: yinghai@kernel.org
    Link: http://lkml.kernel.org/r/20110521005526.341718626@sbsiddha-MOBL3.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f37703dc69fe..4a0b7c7e2cce 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -478,15 +478,10 @@ static inline unsigned default_get_apic_id(unsigned long x)
 #define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
 
 #ifdef CONFIG_X86_64
-extern struct apic apic_flat;
-extern struct apic apic_physflat;
-extern struct apic apic_x2apic_cluster;
-extern struct apic apic_x2apic_phys;
 extern int default_acpi_madt_oem_check(char *, char *);
 
 extern void apic_send_IPI_self(int vector);
 
-extern struct apic apic_x2apic_uv_x;
 DECLARE_PER_CPU(int, x2apic_extra_bits);
 
 extern int default_cpu_present_to_apicid(int mps_cpu);
@@ -536,8 +531,6 @@ extern struct apic apic_noop;
 
 #ifdef CONFIG_X86_32
 
-extern struct apic apic_default;
-
 static inline int noop_x86_32_early_logical_apicid(int cpu)
 {
 	return BAD_APICID;

commit 69c252ffce77f4e38347d536ee4eab4aa162dc67
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Fri May 20 17:51:19 2011 -0700

    x86, apic: Clean up bigsmp apic selection code
    
    Make generic_bigsmp_probe() return struct apic *. This will
    avoid exporting apic_bigsmp, which will be consistent with
    others.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Tested-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: steiner@sgi.com
    Cc: gorcunov@openvz.org
    Cc: yinghai@kernel.org
    Link: http://lkml.kernel.org/r/20110521005526.252703851@sbsiddha-MOBL3.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 80b243c7f0f0..f37703dc69fe 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -500,7 +500,7 @@ static inline void default_wait_for_init_deassert(atomic_t *deassert)
 	return;
 }
 
-extern void generic_bigsmp_probe(void);
+extern struct apic *generic_bigsmp_probe(void);
 
 
 #ifdef CONFIG_X86_LOCAL_APIC

commit 107e0e0cd85beeee05af7ea374fda14d037ee500
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Fri May 20 17:51:17 2011 -0700

    x86, apic: Introduce .apicdrivers section to find the list of apic drivers
    
    This will pave the way for each apic driver to be self-contained
    and eliminate the need for apic_probe[].
    
    Order in which apic drivers are listed in the .apicdrivers
    section is important, as this determines the apic probe order.
    And this is enforced by the ordering of apic driver files in the
    Makefile and the macros apic_driver()/apic_drivers().
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Tested-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: steiner@sgi.com
    Cc: gorcunov@openvz.org
    Cc: yinghai@kernel.org
    Link: http://lkml.kernel.org/r/20110521005526.068775085@sbsiddha-MOBL3.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a0c46f061210..80b243c7f0f0 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -380,6 +380,26 @@ struct apic {
  */
 extern struct apic *apic;
 
+/*
+ * APIC drivers are probed based on how they are listed in the .apicdrivers
+ * section. So the order is important and enforced by the ordering
+ * of different apic driver files in the Makefile.
+ *
+ * For the files having two apic drivers, we use apic_drivers()
+ * to enforce the order with in them.
+ */
+#define apic_driver(sym)					\
+	static struct apic *__apicdrivers_##sym __used		\
+	__aligned(sizeof(struct apic *))			\
+	__section(.apicdrivers) = { &sym }
+
+#define apic_drivers(sym1, sym2)					\
+	static struct apic *__apicdrivers_##sym1##sym2[2] __used	\
+	__aligned(sizeof(struct apic *))				\
+	__section(.apicdrivers) = { &sym1, &sym2 }
+
+extern struct apic *__apicdrivers[], *__apicdrivers_end[];
+
 /*
  * APIC functionality to boot other CPUs - only used on SMP:
  */

commit 84914ed0ec6787d38e84b510f92ad4ca3a572fd8
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 2 14:18:52 2011 +0200

    x86-32, NUMA: Make apic->x86_32_numa_cpu_node() optional
    
    NUMAQ is the only meaningful user of this callback and
    setup_local_APIC() the only callsite.  Stop torturing everyone else by
    making the callback optional and removing all the boilerplate
    implementations and assignments.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2b7d573be549..a0c46f061210 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -363,7 +363,12 @@ struct apic {
 	 */
 	int (*x86_32_early_logical_apicid)(int cpu);
 
-	/* determine CPU -> NUMA node mapping */
+	/*
+	 * Optional method called from setup_local_APIC() after logical
+	 * apicid is guaranteed to be known to initialize apicid -> node
+	 * mapping if NUMA initialization hasn't done so already.  Don't
+	 * add new users.
+	 */
 	int (*x86_32_numa_cpu_node)(int cpu);
 #endif
 };
@@ -537,8 +542,6 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 	return cpuid_apic >> index_msb;
 }
 
-extern int default_x86_32_numa_cpu_node(int cpu);
-
 #endif
 
 static inline unsigned int

commit ca444564a947034557a85357b3911d067cac4b8f
Author: Jean Delvare <khali@linux-fr.org>
Date:   Fri Mar 25 15:20:14 2011 +0100

    x86: Stop including <linux/delay.h> in two asm header files
    
    Stop including <linux/delay.h> in x86 header files which don't
    need it. This will let the compiler complain when this header is
    not included by source files when it should, so that
    contributors can fix the problem before building on other
    architectures starts to fail.
    
    Credits go to Geert for the idea.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: James E.J. Bottomley <James.Bottomley@suse.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    LKML-Reference: <20110325152014.297890ec@endymion.delvare>
    [ this also fixes an upstream build bug in drivers/media/rc/ite-cir.c ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a279d98ea95e..2b7d573be549 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -2,7 +2,6 @@
 #define _ASM_X86_APIC_H
 
 #include <linux/cpumask.h>
-#include <linux/delay.h>
 #include <linux/pm.h>
 
 #include <asm/alternative.h>

commit d10902812c9cd5583130a4ebb9ad19c60b68149d
Merge: 181f977d134a 25874a299ef8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 20:01:36 2011 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (27 commits)
      x86: Clean up apic.c and apic.h
      x86: Remove superflous goal definition of tsc_sync
      x86: dt: Correct local apic documentation in device tree bindings
      x86: dt: Cleanup local apic setup
      x86: dt: Fix OLPC=y/INTEL_CE=n build
      rtc: cmos: Add OF bindings
      x86: ce4100: Use OF to setup devices
      x86: ioapic: Add OF bindings for IO_APIC
      x86: dtb: Add generic bus probe
      x86: dtb: Add support for PCI devices backed by dtb nodes
      x86: dtb: Add device tree support for HPET
      x86: dtb: Add early parsing of IO_APIC
      x86: dtb: Add irq domain abstraction
      x86: dtb: Add a device tree for CE4100
      x86: Add device tree support
      x86: e820: Remove conditional early mapping in parse_e820_ext
      x86: OLPC: Make OLPC=n build again
      x86: OLPC: Remove extra OLPC_OPENFIRMWARE_DT indirection
      x86: OLPC: Cleanup config maze completely
      x86: OLPC: Hide OLPC_OPENFIRMWARE config switch
      ...
    
    Fix up conflicts in arch/x86/platform/ce4100/ce4100.c

commit 8460b3e5bc64955aeefdd8357b3bf7b5ff79b3f2
Merge: 56396e6823fe 521cb40b0c44
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Mar 15 08:29:44 2011 +0100

    Merge commit 'v2.6.38' into x86/mm
    
    Conflicts:
            arch/x86/mm/numa_64.c
    
    Merge reason: Resolve the conflict, update the branch to .38.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 25874a299ef8037df03ce4ada570bc4e42f9748f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Fri Mar 11 08:02:36 2011 +0100

    x86: Clean up apic.c and apic.h
    
    This patch moves some functions and variables into init
    sections, makes a function static and removes some lines of
    cruft.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
    LKML-Reference: <1299826956-8607-2-git-send-email-henne@nachtwindheim.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4afe512120a9..5b7d5137e167 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -220,7 +220,6 @@ extern void enable_IR_x2apic(void);
 
 extern int get_physical_broadcast(void);
 
-extern void apic_disable(void);
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
 extern void connect_bsp_APIC(void);
@@ -228,7 +227,6 @@ extern void disconnect_bsp_APIC(int virt_wire_setup);
 extern void disable_local_APIC(void);
 extern void lapic_shutdown(void);
 extern int verify_local_APIC(void);
-extern void cache_APIC_registers(void);
 extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
 extern void setup_local_APIC(void);
@@ -239,7 +237,6 @@ void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
-extern void enable_NMI_through_LVT0(void);
 extern int apic_force_enable(unsigned long addr);
 
 /*
@@ -261,7 +258,6 @@ static inline void lapic_shutdown(void) { }
 #define local_apic_timer_c2_ok		1
 static inline void init_apic_mappings(void) { }
 static inline void disable_local_APIC(void) { }
-static inline void apic_disable(void) { }
 # define setup_boot_APIC_clock x86_init_noop
 # define setup_secondary_APIC_clock x86_init_noop
 #endif /* !CONFIG_X86_LOCAL_APIC */

commit a906fdaacca49917d83e5032dfc31f694249ad10
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 16:09:31 2011 +0100

    x86: dt: Cleanup local apic setup
    
    Up to now we force enable the local apic in the devicetree setup
    uncoditionally and set smp_found_config unconditionally to 1 when a
    devicetree blob is available. This breaks, when local apic is disabled
    in the Kconfig.
    
    Make it consistent by initializing device tree explicitely before
    smp_get_config() so a non lapic configuration could be used as well.
    To be functional that would require to implement PIT as an interrupt
    host, but the only user of this code until now is ce4100 which
    requires apics to be available. So we leave this up to those who need
    it.
    
    Tested-by: Sebastian Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 3c896946f4cc..4afe512120a9 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -240,7 +240,7 @@ extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
 extern void enable_NMI_through_LVT0(void);
-extern int apic_force_enable(void);
+extern int apic_force_enable(unsigned long addr);
 
 /*
  * On 32bit this is mach-xxx local

commit 2fb270f3212a1e6a73f86f76c85caee93aae4386
Author: Jan Beulich <JBeulich@novell.com>
Date:   Wed Feb 9 08:21:02 2011 +0000

    x86: Fix section mismatch in LAPIC initialization
    
    Additionally doing things conditionally upon smp_processor_id()
    being zero is generally a bad idea, as this means CPU 0 cannot
    be offlined and brought back online later again.
    
    While there may be other places where this is done, I think adding
    more of those should be avoided so that some day SMP can really
    become "symmetrical".
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    LKML-Reference: <4D525C7E0200007800030EE1@vpn.id2.novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5e3969c36d7f..3c896946f4cc 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -233,6 +233,7 @@ extern void sync_Arb_IDs(void);
 extern void init_bsp_APIC(void);
 extern void setup_local_APIC(void);
 extern void end_local_APIC_setup(void);
+extern void bsp_end_local_APIC_setup(void);
 extern void init_apic_mappings(void);
 void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);

commit 89e5dc218e084e13a3996db6693b01478912f4ee
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Jan 23 14:37:38 2011 +0100

    x86: Replace apic->apicid_to_node() with ->x86_32_numa_cpu_node()
    
    apic->apicid_to_node() is 32bit specific apic operation which
    determines NUMA node for a CPU.  Depending on the APIC
    implementation, it can be easier to determine NUMA node from
    either physical or logical apicid.  Currently,
    ->apicid_to_node() takes @logical_apicid and calls
    hard_smp_processor_id() if the physical apicid is needed.
    
    This prevents NUMA mapping from being queried from a different
    CPU, which in turn makes it impossible to initialize NUMA
    mapping before SMP bringup.
    
    This patch replaces apic->apicid_to_node() with
    ->x86_32_numa_cpu_node() which takes @cpu, from which both
    logical and physical apicids can easily be determined.  While at
    it, drop duplicate implementations from bigsmp_32 and summit_32,
    and use the default one.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Pekka Enberg <penberg@kernel.org>
    Cc: eric.dumazet@gmail.com
    Cc: yinghai@kernel.org
    Cc: brgerst@gmail.com
    Cc: gorcunov@gmail.com
    Cc: shaohui.zheng@intel.com
    Cc: rientjes@google.com
    LKML-Reference: <1295789862-25482-13-git-send-email-tj@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index efb073b5c743..ad30ca4b6fe9 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -306,7 +306,6 @@ struct apic {
 
 	void (*setup_apic_routing)(void);
 	int (*multi_timer_check)(int apic, int irq);
-	int (*apicid_to_node)(int logical_apicid);
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 	void (*setup_portio_remap)(void);
@@ -367,6 +366,9 @@ struct apic {
 	 * won't be applied properly during early boot in this case.
 	 */
 	int (*x86_32_early_logical_apicid)(int cpu);
+
+	/* determine CPU -> NUMA node mapping */
+	int (*x86_32_numa_cpu_node)(int cpu);
 #endif
 };
 
@@ -539,7 +541,7 @@ static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
 	return cpuid_apic >> index_msb;
 }
 
-extern int default_apicid_to_node(int logical_apicid);
+extern int default_x86_32_numa_cpu_node(int cpu);
 
 #endif
 

commit acb8bc09c6185e4d3d582d0076aaa6a89f19d8c5
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Jan 23 14:37:33 2011 +0100

    x86: Add apic->x86_32_early_logical_apicid()
    
    On x86_32, the mapping between cpu and logical apic ID differs
    depending on the specific apic implementation in use.  The
    mapping is initialized while bringing up CPUs; however, this
    makes early inits ignore memory topology.
    
    Add a x86_32 specific apic->x86_32_early_logical_apicid() which
    is called early during boot to query the mapping.  The mapping
    is later verified against the result of init_apic_ldr().  The
    method is allowed to return BAD_APICID if it can't be determined
    early.
    
    noop variant which always returns BAD_APICID is implemented and
    added to all x86_32 apic implementations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: eric.dumazet@gmail.com
    Cc: yinghai@kernel.org
    Cc: brgerst@gmail.com
    Cc: gorcunov@gmail.com
    Cc: penberg@kernel.org
    Cc: shaohui.zheng@intel.com
    Cc: rientjes@google.com
    LKML-Reference: <1295789862-25482-8-git-send-email-tj@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index d1aa0c3e7a5c..efb073b5c743 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -354,6 +354,20 @@ struct apic {
 	void (*icr_write)(u32 low, u32 high);
 	void (*wait_icr_idle)(void);
 	u32 (*safe_wait_icr_idle)(void);
+
+#ifdef CONFIG_X86_32
+	/*
+	 * Called very early during boot from get_smp_config().  It should
+	 * return the logical apicid.  x86_[bios]_cpu_to_apicid is
+	 * initialized before this function is called.
+	 *
+	 * If logical apicid can't be determined that early, the function
+	 * may return BAD_APICID.  Logical apicid will be configured after
+	 * init_apic_ldr() while bringing up CPUs.  Note that NUMA affinity
+	 * won't be applied properly during early boot in this case.
+	 */
+	int (*x86_32_early_logical_apicid)(int cpu);
+#endif
 };
 
 /*
@@ -501,6 +515,11 @@ extern struct apic apic_noop;
 
 extern struct apic apic_default;
 
+static inline int noop_x86_32_early_logical_apicid(int cpu)
+{
+	return BAD_APICID;
+}
+
 /*
  * Set up the logical destination ID.
  *

commit 7632611f534340182c832d2b139cb19676f24e1a
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Jan 23 14:37:32 2011 +0100

    x86: Kill apic->cpu_to_logical_apicid()
    
    After the previous patch, apic->cpu_to_logical_apicid() is no
    longer used.  Kill it.
    
    For apic types with custom cpu_to_logical_apicid() which is also
    used for other purposes, remove the function and modify its
    users to do the mapping directly.
    
    #ifdef's on CONFIG_SMP in es7000_32 and summit_32 are ignored
    during conversion as they are not used for UP kernels.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: eric.dumazet@gmail.com
    Cc: yinghai@kernel.org
    Cc: brgerst@gmail.com
    Cc: gorcunov@gmail.com
    Cc: penberg@kernel.org
    Cc: shaohui.zheng@intel.com
    Cc: rientjes@google.com
    LKML-Reference: <1295789862-25482-7-git-send-email-tj@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index eb139eced850..d1aa0c3e7a5c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -307,7 +307,6 @@ struct apic {
 	void (*setup_apic_routing)(void);
 	int (*multi_timer_check)(int apic, int irq);
 	int (*apicid_to_node)(int logical_apicid);
-	int (*cpu_to_logical_apicid)(int cpu);
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 	void (*setup_portio_remap)(void);
@@ -557,12 +556,6 @@ static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_ma
 	*retmap = *phys_map;
 }
 
-/* Mapping from cpu number to logical apicid */
-static inline int default_cpu_to_logical_apicid(int cpu)
-{
-	return 1 << cpu;
-}
-
 static inline int __default_cpu_present_to_apicid(int mps_cpu)
 {
 	if (mps_cpu < nr_cpu_ids && cpu_present(mps_cpu))

commit 4c321ff8a01a95badf5d5403d80ca4e0ab07fce7
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Jan 23 14:37:30 2011 +0100

    x86: Replace cpu_2_logical_apicid[] with early percpu variable
    
    Unlike x86_64, on x86_32, the mapping from cpu to logical apicid
    may vary depending on apic in use.  cpu_2_logical_apicid[] array
    is used for this mapping.  Replace it with early percpu variable
    x86_cpu_to_logical_apicid to make it better aligned with other
    mappings.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: eric.dumazet@gmail.com
    Cc: yinghai@kernel.org
    Cc: brgerst@gmail.com
    Cc: gorcunov@gmail.com
    Cc: penberg@kernel.org
    Cc: shaohui.zheng@intel.com
    Cc: rientjes@google.com
    LKML-Reference: <1295789862-25482-5-git-send-email-tj@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 5e3969c36d7f..eb139eced850 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -595,8 +595,4 @@ extern int default_check_phys_apicid_present(int phys_apicid);
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 
-#ifdef CONFIG_X86_32
-extern u8 cpu_2_logical_apicid[NR_CPUS];
-#endif
-
 #endif /* _ASM_X86_APIC_H */

commit f1157141636848f52c5f74040bed0ba355cf59b7
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Dec 7 00:55:29 2010 -0800

    x86, apic: Remove early_init_lapic_mapping()
    
    It is almost the same as smp_register_lapic_addr(). We just need to
    let smp_read_mpc() call smp_register_lapic_addr() when early==1.
    
    Add the apic_printk to smp_register_lapic_address()
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    LKML-Reference: <4CFDF681.3030509@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1cc42cfa1372..5e3969c36d7f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -245,7 +245,6 @@ extern int apic_force_enable(void);
  * On 32bit this is mach-xxx local
  */
 #ifdef CONFIG_X86_64
-extern void early_init_lapic_mapping(void);
 extern int apic_is_clustered_box(void);
 #else
 static inline int apic_is_clustered_box(void)

commit c0104d38a740b25662c592c71f6907676510289c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Dec 7 00:55:17 2010 -0800

    x86, apic: Unify identical register_lapic_address() functions
    
    They are the same, move the common function to apic.c to allow
    further cleanups.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Len Brown <lenb@kernel.org>
    LKML-Reference: <4CFDF675.4060305@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index cf12007796db..1cc42cfa1372 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -234,6 +234,7 @@ extern void init_bsp_APIC(void);
 extern void setup_local_APIC(void);
 extern void end_local_APIC_setup(void);
 extern void init_apic_mappings(void);
+void register_lapic_address(unsigned long address);
 extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);

commit d834a9dcecae834cd6b2bc5e50e1907738d9cf6a
Merge: a38c5380ef9f f658bcfb2607
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 9 18:17:25 2010 +0100

    Merge branch 'x86/amd-nb' into x86/apic-cleanups
    
    Reason: apic cleanup series depends on x86/apic, x86/amd-nb x86/platform
    
    Conflicts:
            arch/x86/include/asm/io_apic.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 0059b2436a86fedb2747f654f8e10a67e97d8614
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Nov 8 22:20:29 2010 +0100

    x86: Address gcc4.6 "set but not used" warnings in apic.h
    
    native_apic_msr_read() and x2apic_enabled() use rdmsr(msr, low, high),
    but only use the low part.
    
    gcc4.6 complains about this:
    .../apic.h:144:11: warning: variable 'high' set but not used [-Wunused-but-set-variable]
    
    rdmsr() is just a wrapper around rdmsrl() which splits the 64bit value
    into low and high, so using rdmsrl() directly solves this.
    
    [tglx: Changed the variables to u64 as suggested by Cyrill. It's less
           confusing and has no code impact as this is 64bit only anyway.
           Massaged changelog as well. ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: x86@kernel.org
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    LKML-Reference: <1289251229-19589-1-git-send-email-andi@firstfloor.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 286de34b0ed6..f6ce0bda3b98 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -141,13 +141,13 @@ static inline void native_apic_msr_write(u32 reg, u32 v)
 
 static inline u32 native_apic_msr_read(u32 reg)
 {
-	u32 low, high;
+	u64 msr;
 
 	if (reg == APIC_DFR)
 		return -1;
 
-	rdmsr(APIC_BASE_MSR + (reg >> 4), low, high);
-	return low;
+	rdmsrl(APIC_BASE_MSR + (reg >> 4), msr);
+	return (u32)msr;
 }
 
 static inline void native_x2apic_wait_icr_idle(void)
@@ -181,12 +181,12 @@ extern void enable_x2apic(void);
 extern void x2apic_icr_write(u32 low, u32 id);
 static inline int x2apic_enabled(void)
 {
-	int msr, msr2;
+	u64 msr;
 
 	if (!cpu_has_x2apic)
 		return 0;
 
-	rdmsr(MSR_IA32_APICBASE, msr, msr2);
+	rdmsrl(MSR_IA32_APICBASE, msr);
 	if (msr & X2APIC_ENABLE)
 		return 1;
 	return 0;

commit 5a7ae78fd478624df3059cb6f55056b85d074acc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 19 10:46:28 2010 -0700

    x86: Allow platforms to force enable apic
    
    Some embedded x86 platforms don't setup the APIC in the
    BIOS/bootloader and would be forced to add "lapic" on the kernel
    command line. That's a bit akward.
    
    Split out the force enable code from detect_init_APIC() and allow
    platform code to call it from the platform setup. That avoids the
    command line parameter and possible replication of the MSR dance in
    the force enable code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <1287510389-8388-1-git-send-email-dirk.brandewie@gmail.com>
    Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 286de34b0ed6..ad50aaae396f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -238,6 +238,7 @@ extern void setup_boot_APIC_clock(void);
 extern void setup_secondary_APIC_clock(void);
 extern int APIC_init_uniprocessor(void);
 extern void enable_NMI_through_LVT0(void);
+extern int apic_force_enable(void);
 
 /*
  * On 32bit this is mach-xxx local

commit 27afdf2008da0b8878a73e32e4eb12381b84e224
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Oct 6 12:27:54 2010 +0200

    apic, x86: Use BIOS settings for IBS and MCE threshold interrupt LVT offsets
    
    We want the BIOS to setup the EILVT APIC registers. The offsets
    were hardcoded and BIOS settings were overwritten by the OS.
    Now, the subsystems for MCE threshold and IBS determine the LVT
    offset from the registers the BIOS has setup. If the BIOS setup
    is buggy on a family 10h system, a workaround enables IBS. If
    the OS determines an invalid register setup, a "[Firmware Bug]:
    " error message is reported.
    
    We need this change also for upcomming cpu families.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    LKML-Reference: <1286360874-1471-3-git-send-email-robert.richter@amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 1fa03e04ae44..286de34b0ed6 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -252,9 +252,7 @@ static inline int apic_is_clustered_box(void)
 }
 #endif
 
-extern u8 setup_APIC_eilvt_mce(u8 vector, u8 msg_type, u8 mask);
-extern u8 setup_APIC_eilvt_ibs(u8 vector, u8 msg_type, u8 mask);
-
+extern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
 
 #else /* !CONFIG_X86_LOCAL_APIC */
 static inline void lapic_shutdown(void) { }

commit d674cd1963129b70bc5f631c51fb30fb73213fb2
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Wed Mar 17 13:37:00 2010 +0300

    x86, apic: Allow to use certain functions without APIC built-in support
    
    In case even if the kernel is configured so that
    no APIC support is built-in we still may allow
    to use certain apic functions as dummy calls.
    
    In particular we start using it in perf-events code.
    
    Note that this is not that same as NOOP apic driver (which
    is used if APIC support is present but no physical APIC is
    available), this is for the case when we don't have apic code
    compiled in at all.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <20100317104356.011052632@openvz.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index b4ac2cdcb64f..1fa03e04ae44 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -373,6 +373,7 @@ extern atomic_t init_deasserted;
 extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
 #endif
 
+#ifdef CONFIG_X86_LOCAL_APIC
 static inline u32 apic_read(u32 reg)
 {
 	return apic->read(reg);
@@ -403,10 +404,19 @@ static inline u32 safe_apic_wait_icr_idle(void)
 	return apic->safe_wait_icr_idle();
 }
 
+#else /* CONFIG_X86_LOCAL_APIC */
+
+static inline u32 apic_read(u32 reg) { return 0; }
+static inline void apic_write(u32 reg, u32 val) { }
+static inline u64 apic_icr_read(void) { return 0; }
+static inline void apic_icr_write(u32 low, u32 high) { }
+static inline void apic_wait_icr_idle(void) { }
+static inline u32 safe_apic_wait_icr_idle(void) { return 0; }
+
+#endif /* CONFIG_X86_LOCAL_APIC */
 
 static inline void ack_APIC_irq(void)
 {
-#ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * ack_APIC_irq() actually gets compiled as a single instruction
 	 * ... yummie.
@@ -414,7 +424,6 @@ static inline void ack_APIC_irq(void)
 
 	/* Docs say use 0 for future compatibility */
 	apic_write(APIC_EOI, 0);
-#endif
 }
 
 static inline unsigned default_get_apic_id(unsigned long x)

commit 7abc07531383ac7f727cc9d44e1360a829f2082e
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Tue Nov 10 01:06:59 2009 +0300

    x86: apic: Do not use stacked physid_mask_t
    
    We should not use physid_mask_t as a stack based
    variable in apic code. This type depends on MAX_APICS
    parameter which may be huge enough.
    
    Especially it became a problem with apic NOOP driver which
    is portable between 32 bit and 64 bit environment
    (where we have really huge MAX_APICS).
    
    So apic driver should operate with pointers and a caller
    in turn should aware of allocation physid_mask_t variable.
    
    As a side (but positive) effect -- we may use already
    implemented physid_set_mask_of_physid function eliminating
    default_apicid_to_cpu_present completely.
    
    Note that physids_coerce and physids_promote turned into static
    inline from macro (since macro hides the fact that parameter is
    being interpreted as unsigned long, make it explicit).
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    LKML-Reference: <20091109220659.GA5568@lenovo>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 08a5f420e07b..b4ac2cdcb64f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -297,20 +297,20 @@ struct apic {
 	int disable_esr;
 
 	int dest_logical;
-	unsigned long (*check_apicid_used)(physid_mask_t bitmap, int apicid);
+	unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
 	unsigned long (*check_apicid_present)(int apicid);
 
 	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
 	void (*init_apic_ldr)(void);
 
-	physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map);
+	void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);
 
 	void (*setup_apic_routing)(void);
 	int (*multi_timer_check)(int apic, int irq);
 	int (*apicid_to_node)(int logical_apicid);
 	int (*cpu_to_logical_apicid)(int cpu);
 	int (*cpu_present_to_apicid)(int mps_cpu);
-	physid_mask_t (*apicid_to_cpu_present)(int phys_apicid);
+	void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 	void (*setup_portio_remap)(void);
 	int (*check_phys_apicid_present)(int phys_apicid);
 	void (*enable_apic_mode)(void);
@@ -534,9 +534,9 @@ default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 	return (unsigned int)(mask1 & mask2 & mask3);
 }
 
-static inline unsigned long default_check_apicid_used(physid_mask_t bitmap, int apicid)
+static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)
 {
-	return physid_isset(apicid, bitmap);
+	return physid_isset(apicid, *map);
 }
 
 static inline unsigned long default_check_apicid_present(int bit)
@@ -544,9 +544,9 @@ static inline unsigned long default_check_apicid_present(int bit)
 	return physid_isset(bit, phys_cpu_present_map);
 }
 
-static inline physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map)
+static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)
 {
-	return phys_map;
+	*retmap = *phys_map;
 }
 
 /* Mapping from cpu number to logical apicid */
@@ -585,11 +585,6 @@ extern int default_cpu_present_to_apicid(int mps_cpu);
 extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
-static inline physid_mask_t default_apicid_to_cpu_present(int phys_apicid)
-{
-	return physid_mask_of_physid(phys_apicid);
-}
-
 #endif /* CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_32

commit 9844ab11c763bfed9f054c82366b19dcda66aca9
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Wed Oct 14 00:07:03 2009 +0400

    x86, apic: Introduce the NOOP apic driver
    
    Introduce NOOP APIC driver. We should use it in case if apic was
    disabled due to hardware of software/firmware problems (including
    user requested to disable it case).
    
    The driver is attempting to catch any inappropriate apic operation
    call with warning issue.
    
    Also it is possible to use some apic operation like IPI calls,
    read/write without checking for apic presence which should make
    callers code easier.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: yinghai@kernel.org
    Cc: macro@linux-mips.org
    LKML-Reference: <20091013201022.534682104@openvz.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 474d80d3e6cc..08a5f420e07b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -488,6 +488,8 @@ static inline unsigned int read_apic_id(void)
 
 extern void default_setup_apic_routing(void);
 
+extern struct apic apic_noop;
+
 #ifdef CONFIG_X86_32
 
 extern struct apic apic_default;

commit bfefb7a0c6e08736f2d5917c468467f134bf28bb
Merge: 8d0cc631f6dd 78f28b7c5553
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Sep 20 20:24:58 2009 +0200

    Merge branch 'linus' into x86/urgent
    
    Merge reason: Bring in changes that the next patch will depend on.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 8312136fa8b0a3ec7323bbb1a46be8c0c26e994e
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Tue Sep 15 11:12:30 2009 +0400

    x86, apic: Fix missed handling of discrete apics
    
    In case of discrete (pretty old) apics we may have cpu_has_apic bit
    not set but have to check if smp_found_config (MP spec) is there
    and apic was not disabled.
    
    Also don't forget to print apic/io-apic for such case as well.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <20090915071230.GA10604@lenovo>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 586b7adb8e53..9a86fb40490d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -65,6 +65,19 @@ static inline void default_inquire_remote_apic(int apicid)
 		__inquire_remote_apic(apicid);
 }
 
+/*
+ * With 82489DX we can't rely on apic feature bit
+ * retrieved via cpuid but still have to deal with
+ * such an apic chip so we assume that SMP configuration
+ * is found from MP table (64bit case uses ACPI mostly
+ * which set smp presence flag as well so we are safe
+ * to use this helper too).
+ */
+static inline bool apic_from_smp_config(void)
+{
+	return smp_found_config && !disable_apic;
+}
+
 /*
  * Basic functions accessing APICs.
  */

commit 78f28b7c555359c67c2a0d23f7436e915329421e
Merge: 3240a77b515f 7bd867dfb4e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 14:05:47 2009 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (38 commits)
      x86: Move get/set_wallclock to x86_platform_ops
      x86: platform: Fix section annotations
      x86: apic namespace cleanup
      x86: Distangle ioapic and i8259
      x86: Add Moorestown early detection
      x86: Add hardware_subarch ID for Moorestown
      x86: Add early platform detection
      x86: Move tsc_init to late_time_init
      x86: Move tsc_calibration to x86_init_ops
      x86: Replace the now identical time_32/64.c by time.c
      x86: time_32/64.c unify profile_pc
      x86: Move calibrate_cpu to tsc.c
      x86: Make timer setup and global variables the same in time_32/64.c
      x86: Remove mca bus ifdef from timer interrupt
      x86: Simplify timer_ack magic in time_32.c
      x86: Prepare unification of time_32/64.c
      x86: Remove do_timer hook
      x86: Add timer_init to x86_init_ops
      x86: Move percpu clockevents setup to x86_init_ops
      x86: Move xen_post_allocator_init into xen_pagetable_setup_done
      ...
    
    Fix up conflicts in arch/x86/include/asm/io_apic.h

commit e11dadabf443dc3101f28b74d8b9d56870a87db4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 31 15:18:40 2009 +0200

    x86: apic namespace cleanup
    
    boot_cpu_physical_apicid is a global variable and used as function
    argument as well. Rename the function arguments to avoid confusion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 6f15b29005a1..d6a0f2636a61 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -292,7 +292,7 @@ struct apic {
 	int (*cpu_present_to_apicid)(int mps_cpu);
 	physid_mask_t (*apicid_to_cpu_present)(int phys_apicid);
 	void (*setup_portio_remap)(void);
-	int (*check_phys_apicid_present)(int boot_cpu_physical_apicid);
+	int (*check_phys_apicid_present)(int phys_apicid);
 	void (*enable_apic_mode)(void);
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
 
@@ -426,7 +426,7 @@ extern struct apic apic_x2apic_uv_x;
 DECLARE_PER_CPU(int, x2apic_extra_bits);
 
 extern int default_cpu_present_to_apicid(int mps_cpu);
-extern int default_check_phys_apicid_present(int boot_cpu_physical_apicid);
+extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
 static inline void default_wait_for_init_deassert(atomic_t *deassert)
@@ -542,9 +542,9 @@ static inline int __default_cpu_present_to_apicid(int mps_cpu)
 }
 
 static inline int
-__default_check_phys_apicid_present(int boot_cpu_physical_apicid)
+__default_check_phys_apicid_present(int phys_apicid)
 {
-	return physid_isset(boot_cpu_physical_apicid, phys_cpu_present_map);
+	return physid_isset(phys_apicid, phys_cpu_present_map);
 }
 
 #ifdef CONFIG_X86_32
@@ -554,13 +554,13 @@ static inline int default_cpu_present_to_apicid(int mps_cpu)
 }
 
 static inline int
-default_check_phys_apicid_present(int boot_cpu_physical_apicid)
+default_check_phys_apicid_present(int phys_apicid)
 {
-	return __default_check_phys_apicid_present(boot_cpu_physical_apicid);
+	return __default_check_phys_apicid_present(phys_apicid);
 }
 #else
 extern int default_cpu_present_to_apicid(int mps_cpu);
-extern int default_check_phys_apicid_present(int boot_cpu_physical_apicid);
+extern int default_check_phys_apicid_present(int phys_apicid);
 #endif
 
 static inline physid_mask_t default_apicid_to_cpu_present(int phys_apicid)

commit 736decac643e8982655e22ac7f0e5e61c5b7f9bd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Aug 19 12:35:53 2009 +0200

    x86: Move percpu clockevents setup to x86_init_ops
    
    paravirt overrides the setup of the default apic timers as per cpu
    timers. Moorestown needs to override that as well.
    
    Move it to x86_init_ops setup and create a separate x86_cpuinit struct
    which holds the function for the secondary evtl. hotplugabble CPUs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bb7d47925847..6f15b29005a1 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -70,9 +70,6 @@ static inline void default_inquire_remote_apic(int apicid)
  */
 #ifdef CONFIG_PARAVIRT
 #include <asm/paravirt.h>
-#else
-#define setup_boot_clock setup_boot_APIC_clock
-#define setup_secondary_clock setup_secondary_APIC_clock
 #endif
 
 #ifdef CONFIG_X86_64
@@ -245,6 +242,8 @@ static inline void lapic_shutdown(void) { }
 static inline void init_apic_mappings(void) { }
 static inline void disable_local_APIC(void) { }
 static inline void apic_disable(void) { }
+# define setup_boot_APIC_clock x86_init_noop
+# define setup_secondary_APIC_clock x86_init_noop
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_64

commit ce69a784504222c3ab6f1b3c357d09ec5772127a
Author: Gleb Natapov <gleb@redhat.com>
Date:   Mon Jul 20 15:24:17 2009 +0300

    x86/apic: Enable x2APIC without interrupt remapping under KVM
    
    KVM would like to provide x2APIC interface to a guest without emulating
    interrupt remapping device. The reason KVM prefers guest to use x2APIC
    is that x2APIC interface is better virtualizable and provides better
    performance than mmio xAPIC interface:
    
     - msr exits are faster than mmio (no page table walk, emulation)
     - no need to read back ICR to look at the busy bit
     - one 64 bit ICR write instead of two 32 bit writes
     - shared code with the Hyper-V paravirt interface
    
    Included patch changes x2APIC enabling logic to enable it even if IR
    initialization failed, but kernel runs under KVM and no apic id is
    greater than 255 (if there is one spec requires BIOS to move to x2apic
    mode before starting an OS).
    
    -v2: fix build
    -v3: fix bug causing compiler warning
    
    Signed-off-by: Gleb Natapov <gleb@redhat.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Sheng Yang <sheng@linux.intel.com>
    Cc: "avi@redhat.com" <avi@redhat.com>
    LKML-Reference: <20090720122417.GR5638@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index bb7d47925847..586b7adb8e53 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -183,6 +183,10 @@ static inline int x2apic_enabled(void)
 }
 
 #define x2apic_supported()	(cpu_has_x2apic)
+static inline void x2apic_force_phys(void)
+{
+	x2apic_phys = 1;
+}
 #else
 static inline void check_x2apic(void)
 {
@@ -194,6 +198,9 @@ static inline int x2apic_enabled(void)
 {
 	return 0;
 }
+static inline void x2apic_force_phys(void)
+{
+}
 
 #define	x2apic_preenabled 0
 #define	x2apic_supported()	0

commit 9b29e8228a5c2a169436a1a90a60b1f88cb35cd1
Merge: bec706838ec2 0b8c3d5ab000
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 16:15:14 2009 -0700

    Merge branch 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Clear TS in irq_ts_save() when in an atomic section
      x86: Detect use of extended APIC ID for AMD CPUs
      x86: memtest: remove 64-bit division
      x86, UV: Fix macros for multiple coherency domains
      x86: Fix non-lazy GS handling in sys_vm86()
      x86: Add quirk for reboot stalls on a Dell Optiplex 360
      x86: Fix UV BAU activation descriptor init

commit 7dc3ca39cb1e22eedbf1207ff9ac7bf682fc0f6d
Merge: aa98936e4f42 a4046f8d299e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 15:49:36 2009 -0700

    Merge branch 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, nmi: Use predefined numbers instead of hardcoded one
      x86: asm/processor.h: remove double declaration
      x86, mtrr: replace MTRRdefType_MSR with msr-index's MSR_MTRRdefType
      x86, mtrr: replace MTRRfix4K_C0000_MSR with msr-index's MSR_MTRRfix4K_C0000
      x86, mtrr: remove mtrr MSRs double declaration
      x86, mtrr: replace MTRRfix16K_80000_MSR with msr-index's MSR_MTRRfix16K_80000
      x86, mtrr: replace MTRRfix64K_00000_MSR with msr-index's MSR_MTRRfix64K_00000
      x86, mtrr: replace MTRRcap_MSR with msr-index's MSR_MTRRcap
      x86: mce: remove duplicated #include
      x86: msr-index.h remove duplicate MSR C001_0015 declaration
      x86: clean up arch/x86/kernel/tsc_sync.c a bit
      x86: use symbolic name for VM86_SIGNAL when used as vm86 default return
      x86: added 'ifndef _ASM_X86_IOMAP_H' to iomap.h
      x86: avoid multiple declaration of kstack_depth_to_print
      x86: vdso/vma.c declare vdso_enabled and arch_setup_additional_pages before they get used
      x86: clean up declarations and variables
      x86: apic/x2apic_cluster.c x86_cpu_to_logical_apicid should be static
      x86 early quirks: eliminate unused function

commit 42937e81a82b6bbc51a309c83da140b3a7ca5945
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Mon Jun 8 15:55:09 2009 +0200

    x86: Detect use of extended APIC ID for AMD CPUs
    
    Booting a 32-bit kernel on Magny-Cours results in the following panic:
    
      ...
      Using APIC driver default
      ...
      Overriding APIC driver with bigsmp
      ...
      Getting VERSION: 80050010
      Getting VERSION: 80050010
      Getting ID: 10000000
      Getting ID: ef000000
      Getting LVT0: 700
      Getting LVT1: 10000
      Kernel panic - not syncing: Boot APIC ID in local APIC unexpected (16 vs 0)
      Pid: 1, comm: swapper Not tainted 2.6.30-rcX #2
      Call Trace:
       [<c05194da>] ? panic+0x38/0xd3
       [<c0743102>] ? native_smp_prepare_cpus+0x259/0x31f
       [<c073b19d>] ? kernel_init+0x3e/0x141
       [<c073b15f>] ? kernel_init+0x0/0x141
       [<c020325f>] ? kernel_thread_helper+0x7/0x10
    
    The reason is that default_get_apic_id handled extension of local APIC
    ID field just in case of XAPIC.
    
    Thus for this AMD CPU, default_get_apic_id() returns 0 and
    bigsmp_get_apic_id() returns 16 which leads to the respective kernel
    panic.
    
    This patch introduces a Linux specific feature flag to indicate
    support for extended APIC id (8 bits instead of 4 bits width) and sets
    the flag on AMD CPUs if applicable.
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Cc: <stable@kernel.org>
    LKML-Reference: <20090608135509.GA12431@alberich.amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 42f2f8377422..9b2c04910e0d 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -410,7 +410,7 @@ static inline unsigned default_get_apic_id(unsigned long x)
 {
 	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
 
-	if (APIC_XAPIC(ver))
+	if (APIC_XAPIC(ver) || boot_cpu_has(X86_FEATURE_EXTD_APICID))
 		return (x >> 24) & 0xFF;
 	else
 		return (x >> 24) & 0x0F;

commit fc1edaf9e7cc4d4696f83dee495b8f158d01c4eb
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Apr 20 13:02:27 2009 -0700

    x86: x2apic, IR: Clean up X86_X2APIC and INTR_REMAP config checks
    
    Add x2apic_supported() to clean up CONFIG_X86_X2APIC checks.
    
    Fix CONFIG_INTR_REMAP checks.
    
    [ Impact: cleanup ]
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: dwmw2@infradead.org
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Weidong Han <weidong.han@intel.com>
    LKML-Reference: <20090420200450.128993000@linux-os.sc.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index fbdd65446c7a..3738438a91f5 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -107,8 +107,7 @@ extern u32 native_safe_apic_wait_icr_idle(void);
 extern void native_apic_icr_write(u32 low, u32 id);
 extern u64 native_apic_icr_read(void);
 
-#define EIM_8BIT_APIC_ID	0
-#define EIM_32BIT_APIC_ID	1
+extern int x2apic_mode;
 
 #ifdef CONFIG_X86_X2APIC
 /*
@@ -166,7 +165,7 @@ static inline u64 native_x2apic_icr_read(void)
 	return val;
 }
 
-extern int x2apic, x2apic_phys;
+extern int x2apic_phys;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
 extern void x2apic_icr_write(u32 low, u32 id);
@@ -182,6 +181,8 @@ static inline int x2apic_enabled(void)
 		return 1;
 	return 0;
 }
+
+#define x2apic_supported()	(cpu_has_x2apic)
 #else
 static inline void check_x2apic(void)
 {
@@ -194,9 +195,8 @@ static inline int x2apic_enabled(void)
 	return 0;
 }
 
-#define	x2apic	0
 #define	x2apic_preenabled 0
-
+#define	x2apic_supported()	0
 #endif
 
 extern void enable_IR_x2apic(void);

commit 937582382c71b75b29fbb92615629494e1a05ac0
Author: Weidong Han <weidong.han@intel.com>
Date:   Fri Apr 17 16:42:14 2009 +0800

    x86, intr-remap: enable interrupt remapping early
    
    Currently, when x2apic is not enabled, interrupt remapping
    will be enabled in init_dmars(), where it is too late to remap
    ioapic interrupts, that is, ioapic interrupts are really in
    compatibility mode, not remappable mode.
    
    This patch always enables interrupt remapping before ioapic
    setup, it guarantees all interrupts will be remapped when
    interrupt remapping is enabled. Thus it doesn't need to set
    the compatibility interrupt bit.
    
    [ Impact: refactor intr-remap init sequence, enable fuller remap mode ]
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: iommu@lists.linux-foundation.org
    Cc: allen.m.kay@intel.com
    Cc: fenghua.yu@intel.com
    LKML-Reference: <1239957736-6161-4-git-send-email-weidong.han@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index d4cb7e590c06..fbdd65446c7a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -169,7 +169,6 @@ static inline u64 native_x2apic_icr_read(void)
 extern int x2apic, x2apic_phys;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
-extern void enable_IR_x2apic(void);
 extern void x2apic_icr_write(u32 low, u32 id);
 static inline int x2apic_enabled(void)
 {
@@ -190,18 +189,18 @@ static inline void check_x2apic(void)
 static inline void enable_x2apic(void)
 {
 }
-static inline void enable_IR_x2apic(void)
-{
-}
 static inline int x2apic_enabled(void)
 {
 	return 0;
 }
 
 #define	x2apic	0
+#define	x2apic_preenabled 0
 
 #endif
 
+extern void enable_IR_x2apic(void);
+
 extern int get_physical_broadcast(void);
 
 extern void apic_disable(void);

commit 5d0ae2db6deac4f15dac4f42f23bc56448fc8d4d
Author: Weidong Han <weidong.han@intel.com>
Date:   Fri Apr 17 16:42:13 2009 +0800

    x86, intr-remap: fix ack for interrupt remapping
    
    Shouldn't call ack_apic_edge() in ir_ack_apic_edge(), because
    ack_apic_edge() does more than just ack: it also does irq migration
    in the non-interrupt-remapping case. But there is no such need for
    interrupt-remapping case, as irq migration is done in the process
    context.
    
    Similarly, ir_ack_apic_level() shouldn't call ack_apic_level, and
    instead should do the local cpu's EOI + directed EOI to the io-apic.
    
    ack_x2APIC_irq() is not neccessary, because ack_APIC_irq() will use MSR
    write for x2apic, and uncached write for non-x2apic.
    
    [ Impact: simplify/standardize intr-remap IRQ acking, fix on !x2apic ]
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: iommu@lists.linux-foundation.org
    Cc: allen.m.kay@intel.com
    Cc: fenghua.yu@intel.com
    LKML-Reference: <1239957736-6161-3-git-send-email-weidong.han@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2bd5a463fd1f..d4cb7e590c06 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -204,14 +204,6 @@ static inline int x2apic_enabled(void)
 
 extern int get_physical_broadcast(void);
 
-#ifdef CONFIG_X86_X2APIC
-static inline void ack_x2APIC_irq(void)
-{
-	/* Docs say use 0 for future compatibility */
-	native_apic_msr_write(APIC_EOI, 0);
-}
-#endif
-
 extern void apic_disable(void);
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);

commit 08306ce61d6848e6fbf74fa4cc693c3fb29e943f
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Sun Apr 12 20:47:41 2009 +0400

    x86: apic - introduce dummy apic operations
    
    Impact: refactor, speed up and robustize code
    
    In case if apic was disabled by kernel option
    or by hardware limits we can use dummy operations
    in apic->write to simplify the ack_APIC_irq() code.
    
    At the lame time the patch fixes the missed EOI in
    do_IRQ function (which has place if kernel is compiled
    as X86-32 and interrupt without handler happens where
    apic was not asked to be disabled via kernel option).
    
    Note that native_apic_write_dummy() consists of
    WARN_ON_ONCE to catch any buggy writes on enabled
    APICs. Could be removed after some time of testing.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    LKML-Reference: <20090412165058.724788431@openvz.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 42f2f8377422..2bd5a463fd1f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -212,6 +212,7 @@ static inline void ack_x2APIC_irq(void)
 }
 #endif
 
+extern void apic_disable(void);
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
 extern void connect_bsp_APIC(void);
@@ -252,7 +253,7 @@ static inline void lapic_shutdown(void) { }
 #define local_apic_timer_c2_ok		1
 static inline void init_apic_mappings(void) { }
 static inline void disable_local_APIC(void) { }
-
+static inline void apic_disable(void) { }
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #ifdef CONFIG_X86_64

commit 2c1b284e4fa260fd922b9a65c99169e2630c6862
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Sat Apr 11 00:03:10 2009 +0530

    x86: clean up declarations and variables
    
    Impact: cleanup, no code changed
    
     - syscalls.h       update declarations due to unifications
     - irq.c            declare smp_generic_interrupt() before it gets used
     - process.c        declare sys_fork() and sys_vfork() before they get used
     - tsc.c            rename tsc_khz shadowed variable
     - apic/probe_32.c  declare apic_default before it gets used
     - apic/nmi.c       prev_nmi_count should be unsigned
     - apic/io_apic.c   declare smp_irq_move_cleanup_interrupt() before it gets used
     - mm/init.c        declare direct_gbpages and free_initrd_mem before they get used
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinder@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 42f2f8377422..5773660c8cd5 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -478,6 +478,9 @@ static inline unsigned int read_apic_id(void)
 extern void default_setup_apic_routing(void);
 
 #ifdef CONFIG_X86_32
+
+extern struct apic apic_default;
+
 /*
  * Set up the logical destination ID.
  *

commit d0b03bd1c6725a3463290d7f9626e4b583518a5a
Author: Han, Weidong <weidong.han@intel.com>
Date:   Fri Apr 3 17:15:50 2009 +0800

    x2apic/intr-remap: decouple interrupt remapping from x2apic
    
    interrupt remapping must be enabled before enabling x2apic, but
    interrupt remapping doesn't depend on x2apic, it can be used
    separately. Enable interrupt remapping in init_dmars even x2apic
    is not supported.
    
    [dwmw2: Update Kconfig accordingly, fix build with INTR_REMAP && !X2APIC]
    
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f9f0866ed6f8..42f2f8377422 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -107,11 +107,10 @@ extern u32 native_safe_apic_wait_icr_idle(void);
 extern void native_apic_icr_write(u32 low, u32 id);
 extern u64 native_apic_icr_read(void);
 
-#ifdef CONFIG_X86_X2APIC
-
 #define EIM_8BIT_APIC_ID	0
 #define EIM_32BIT_APIC_ID	1
 
+#ifdef CONFIG_X86_X2APIC
 /*
  * Make previous memory operations globally visible before
  * sending the IPI through x2apic wrmsr. We need a serializing instruction or

commit b24696bc55f66fecc30715e003f10fc2555a9271
Author: Fenghua Yu <fenghua.yu@intel.com>
Date:   Fri Mar 27 14:22:44 2009 -0700

    Intel IOMMU Suspend/Resume Support - Interrupt Remapping
    
    This patch enables suspend/resume for interrupt remapping. During suspend,
    interrupt remapping is disabled. When resume, interrupt remapping is enabled
    again.
    
    Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index df8a300dfe6c..f9f0866ed6f8 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -108,6 +108,10 @@ extern void native_apic_icr_write(u32 low, u32 id);
 extern u64 native_apic_icr_read(void);
 
 #ifdef CONFIG_X86_X2APIC
+
+#define EIM_8BIT_APIC_ID	0
+#define EIM_32BIT_APIC_ID	1
+
 /*
  * Make previous memory operations globally visible before
  * sending the IPI through x2apic wrmsr. We need a serializing instruction or

commit 70511134f61bd6e5eed19f767381f9fb3e762d49
Author: Ravikiran G Thirumalai <kiran@scalex86.org>
Date:   Mon Mar 23 23:14:29 2009 -0700

    Revert "x86: don't compile vsmp_64 for 32bit"
    
    Partial revert of commit 129d8bc828e011bda0b7110a097bf3a0167f966e
    titled 'x86: don't compile vsmp_64 for 32bit'
    
    Commit reverted to compile vsmp_64.c if CONFIG_X86_64 is defined,
    since is_vsmp_box() needs to indicate that TSCs are not synchronized, and
    hence, not a valid time source, even when CONFIG_X86_VSMP is not defined.
    
    Signed-off-by: Ravikiran Thirumalai <kiran@scalex86.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: shai@scalex86.org
    LKML-Reference: <20090324061429.GH7278@localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 130a9e2b4586..df8a300dfe6c 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -75,7 +75,7 @@ static inline void default_inquire_remote_apic(int apicid)
 #define setup_secondary_clock setup_secondary_APIC_clock
 #endif
 
-#ifdef CONFIG_X86_VSMP
+#ifdef CONFIG_X86_64
 extern int is_vsmp_box(void);
 #else
 static inline int is_vsmp_box(void)

commit f56e5034121c4911a155ba907076ab920754626d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Mar 24 14:16:30 2009 -0700

    x86: use default_cpu_mask_to_apicid for 64bit
    
    Impact: cleanup
    
    Use online_mask directly on 64bit too.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49C94DAE.9070300@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 00f5962d82d0..130a9e2b4586 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -489,10 +489,19 @@ static inline int default_apic_id_registered(void)
 	return physid_isset(read_apic_id(), phys_cpu_present_map);
 }
 
+static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
+{
+	return cpuid_apic >> index_msb;
+}
+
+extern int default_apicid_to_node(int logical_apicid);
+
+#endif
+
 static inline unsigned int
 default_cpu_mask_to_apicid(const struct cpumask *cpumask)
 {
-	return cpumask_bits(cpumask)[0];
+	return cpumask_bits(cpumask)[0] & APIC_ALL_CPUS;
 }
 
 static inline unsigned int
@@ -506,15 +515,6 @@ default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
 	return (unsigned int)(mask1 & mask2 & mask3);
 }
 
-static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
-{
-	return cpuid_apic >> index_msb;
-}
-
-extern int default_apicid_to_node(int logical_apicid);
-
-#endif
-
 static inline unsigned long default_check_apicid_used(physid_mask_t bitmap, int apicid)
 {
 	return physid_isset(apicid, bitmap);

commit ce4e240c279a31096f74afa6584a62d64a1ba8c8
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Mar 17 10:16:54 2009 -0800

    x86: add x2apic_wrmsr_fence() to x2apic flush tlb paths
    
    Impact: optimize APIC IPI related barriers
    
    Uncached MMIO accesses for xapic are inherently serializing and hence
    we don't need explicit barriers for xapic IPI paths.
    
    x2apic MSR writes/reads don't have serializing semantics and hence need
    a serializing instruction or mfence, to make all the previous memory
    stores globally visisble before the x2apic msr write for IPI.
    
    Add x2apic_wrmsr_fence() in flush tlb path to x2apic specific paths.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: "steiner@sgi.com" <steiner@sgi.com>
    Cc: Nick Piggin <npiggin@suse.de>
    LKML-Reference: <1237313814.27006.203.camel@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 6d5b6f0900e1..00f5962d82d0 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -108,6 +108,16 @@ extern void native_apic_icr_write(u32 low, u32 id);
 extern u64 native_apic_icr_read(void);
 
 #ifdef CONFIG_X86_X2APIC
+/*
+ * Make previous memory operations globally visible before
+ * sending the IPI through x2apic wrmsr. We need a serializing instruction or
+ * mfence for this.
+ */
+static inline void x2apic_wrmsr_fence(void)
+{
+	asm volatile("mfence" : : : "memory");
+}
+
 static inline void native_apic_msr_write(u32 reg, u32 v)
 {
 	if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||

commit cf6567fe40c55e9cffca7355cd34e50fb2871e4e
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 16 17:05:00 2009 -0700

    x86, x2apic: fix clear_local_APIC() in the presence of x2apic
    
    Impact: cleanup, paranoia
    
    We were not clearing the local APIC in clear_local_APIC() in the
    presence of x2apic. Fix it.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 394d177d721b..6d5b6f0900e1 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -184,6 +184,9 @@ static inline int x2apic_enabled(void)
 {
 	return 0;
 }
+
+#define	x2apic	0
+
 #endif
 
 extern int get_physical_broadcast(void);

commit b2b352590d94651579e6914ecdb08d30b2cb5f19
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 5 15:15:44 2009 +0100

    x86: UV, SGI RTC: add generic system vector, build fix on UP
    
    Make ack_APIC_irq() build on !SMP && !APIC too.
    
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    LKML-Reference: <20090304185605.GA24419@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4ef949c1972e..394d177d721b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -379,6 +379,7 @@ static inline u32 safe_apic_wait_icr_idle(void)
 
 static inline void ack_APIC_irq(void)
 {
+#ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * ack_APIC_irq() actually gets compiled as a single instruction
 	 * ... yummie.
@@ -386,6 +387,7 @@ static inline void ack_APIC_irq(void)
 
 	/* Docs say use 0 for future compatibility */
 	apic_write(APIC_EOI, 0);
+#endif
 }
 
 static inline unsigned default_get_apic_id(unsigned long x)

commit 1f5bcabf1b997d6b76a09114b5a79423495a1263
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Feb 26 13:51:40 2009 +0100

    x86: apic: simplify secondary CPU wakeup methods
    
    Impact: cleanup
    
    - rename apic->wakeup_cpu  to apic->wakeup_secondary_cpu, to
      make it apparent that this is an SMP-only method
    
    - handle NULL ->wakeup_secondary_cpus to mean the default INIT
      wakeup sequence - this allows simplification of the APIC
      driver templates.
    
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 0fbf6f1520fa..4ef949c1972e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -313,7 +313,7 @@ struct apic {
 	void (*send_IPI_self)(int vector);
 
 	/* wakeup_secondary_cpu */
-	int (*wakeup_cpu)(int apicid, unsigned long start_eip);
+	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
 
 	int trampoline_phys_low;
 	int trampoline_phys_high;
@@ -344,13 +344,6 @@ extern struct apic *apic;
 #ifdef CONFIG_SMP
 extern atomic_t init_deasserted;
 extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
-extern int wakeup_secondary_cpu_via_init(int apicid, unsigned long start_eip);
-#else
-static inline int
-wakeup_secondary_cpu_via_init(int apicid, unsigned long start_eip)
-{
-	return 0;
-}
 #endif
 
 static inline u32 apic_read(u32 reg)

commit 0917c01f8e793f57a53cf886533d4c75c67f6e89
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Feb 26 12:47:40 2009 +0100

    x86: remove update_apic from x86_quirks, fix
    
    Impact: build fix
    
    wakeup_secondary_cpu_via_init(), the default platform method for
    booting a secondary CPU, is always used on UP due to probe_32.c,
    if CONFIG_X86_LOCAL_APIC is enabled but SMP is off.
    
    So provide a UP wrapper inline as well.
    
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 24e21273e30b..0fbf6f1520fa 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -331,10 +331,27 @@ struct apic {
 	u32 (*safe_wait_icr_idle)(void);
 };
 
+/*
+ * Pointer to the local APIC driver in use on this system (there's
+ * always just one such driver in use - the kernel decides via an
+ * early probing process which one it picks - and then sticks to it):
+ */
 extern struct apic *apic;
+
+/*
+ * APIC functionality to boot other CPUs - only used on SMP:
+ */
+#ifdef CONFIG_SMP
 extern atomic_t init_deasserted;
 extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
 extern int wakeup_secondary_cpu_via_init(int apicid, unsigned long start_eip);
+#else
+static inline int
+wakeup_secondary_cpu_via_init(int apicid, unsigned long start_eip)
+{
+	return 0;
+}
+#endif
 
 static inline u32 apic_read(u32 reg)
 {

commit 129d8bc828e011bda0b7110a097bf3a0167f966e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 25 21:20:50 2009 -0800

    x86: don't compile vsmp_64 for 32bit
    
    Impact: cleanup
    
    that is only needed when CONFIG_X86_VSMP is defined with 64bit
    also remove dead code about PCI, because CONFIG_X86_VSMP depends on PCI
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Ravikiran Thirumalai <kiran@scalex86.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 860504178e94..24e21273e30b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -75,7 +75,14 @@ static inline void default_inquire_remote_apic(int apicid)
 #define setup_secondary_clock setup_secondary_APIC_clock
 #endif
 
+#ifdef CONFIG_X86_VSMP
 extern int is_vsmp_box(void);
+#else
+static inline int is_vsmp_box(void)
+{
+	return 0;
+}
+#endif
 extern void xapic_wait_icr_idle(void);
 extern u32 safe_xapic_wait_icr_idle(void);
 extern void xapic_icr_write(u32, u32);

commit 2b6163bf5772644068694583816fa41e8474239f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 25 20:50:49 2009 -0800

    x86: remove update_apic from x86_quirks
    
    Impact: cleanup
    
    x86_quirks->update_apic() calling looks crazy. so try to remove it:
    
     1. every apic take wakeup_cpu member directly
     2. separate es7000_apic to es7000_apic_cluster
     3. use uv_wakeup_cpu directly
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a6208dc74633..860504178e94 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -325,6 +325,9 @@ struct apic {
 };
 
 extern struct apic *apic;
+extern atomic_t init_deasserted;
+extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
+extern int wakeup_secondary_cpu_via_init(int apicid, unsigned long start_eip);
 
 static inline u32 apic_read(u32 reg)
 {
@@ -384,9 +387,7 @@ static inline unsigned default_get_apic_id(unsigned long x)
 #define DEFAULT_TRAMPOLINE_PHYS_LOW		0x467
 #define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
 
-#ifdef CONFIG_X86_32
-extern void es7000_update_apic_to_cluster(void);
-#else
+#ifdef CONFIG_X86_64
 extern struct apic apic_flat;
 extern struct apic apic_physflat;
 extern struct apic apic_x2apic_cluster;

commit ef1f87aa7ba6224bef1b750b3272ba281d8f43ed
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Sat Feb 21 14:23:21 2009 -0800

    x86: select x2apic ops in early apic probe only if x2apic mode is enabled
    
    If BIOS hands over the control to OS in legacy xapic mode, select
    legacy xapic related ops in the early apic probe and shift to x2apic
    ops later in the boot sequence, only after enabling x2apic mode.
    
    If BIOS hands over the control in x2apic mode, select x2apic related
    ops in the early apic probe.
    
    This fixes the early boot panic, where we were selecting x2apic ops,
    while the cpu is still in legacy xapic mode.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index dce1bf696cca..a6208dc74633 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -146,7 +146,7 @@ static inline u64 native_x2apic_icr_read(void)
 	return val;
 }
 
-extern int x2apic;
+extern int x2apic, x2apic_phys;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
 extern void enable_IR_x2apic(void);

commit be163a159b223e94b3180afdd47a8d468eb9a492
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 17 16:28:46 2009 +0100

    x86, apic: rename 'genapic' to 'apic'
    
    Impact: cleanup
    
    Now that all APIC code is consolidated there's nothing 'gen' about
    apics anymore - so rename 'struct genapic' to 'struct apic'.
    
    This shortens the code and is nicer to read as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 122d8eda275f..dce1bf696cca 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -248,7 +248,7 @@ static inline void disable_local_APIC(void) { }
  * Martin Bligh, Andi Kleen, James Bottomley, John Stultz, and
  * James Cleverdon.
  */
-struct genapic {
+struct apic {
 	char *name;
 
 	int (*probe)(void);
@@ -283,7 +283,7 @@ struct genapic {
 	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
 
 	/*
-	 * When one of the next two hooks returns 1 the genapic
+	 * When one of the next two hooks returns 1 the apic
 	 * is switched to this. Essentially they are additional
 	 * probe functions:
 	 */
@@ -324,7 +324,7 @@ struct genapic {
 	u32 (*safe_wait_icr_idle)(void);
 };
 
-extern struct genapic *apic;
+extern struct apic *apic;
 
 static inline u32 apic_read(u32 reg)
 {
@@ -385,17 +385,17 @@ static inline unsigned default_get_apic_id(unsigned long x)
 #define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
 
 #ifdef CONFIG_X86_32
-extern void es7000_update_genapic_to_cluster(void);
+extern void es7000_update_apic_to_cluster(void);
 #else
-extern struct genapic apic_flat;
-extern struct genapic apic_physflat;
-extern struct genapic apic_x2apic_cluster;
-extern struct genapic apic_x2apic_phys;
+extern struct apic apic_flat;
+extern struct apic apic_physflat;
+extern struct apic apic_x2apic_cluster;
+extern struct apic apic_x2apic_phys;
 extern int default_acpi_madt_oem_check(char *, char *);
 
 extern void apic_send_IPI_self(int vector);
 
-extern struct genapic apic_x2apic_uv_x;
+extern struct apic apic_x2apic_uv_x;
 DECLARE_PER_CPU(int, x2apic_extra_bits);
 
 extern int default_cpu_present_to_apicid(int mps_cpu);

commit ab6fb7c0b03e2c3286f316c840347be8b9ee3d9f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 17 16:22:09 2009 +0100

    x86, apic: remove ->store_NMI_vector()
    
    Impact: cleanup
    
    It's not used by anything anymore.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 2cdd19e4536f..122d8eda275f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -313,7 +313,6 @@ struct genapic {
 
 	void (*wait_for_init_deassert)(atomic_t *deassert);
 	void (*smp_callin_clear_local_apic)(void);
-	void (*store_NMI_vector)(unsigned short *high, unsigned short *low);
 	void (*inquire_remote_apic)(int apicid);
 
 	/* apic ops */

commit 2f205bc47f615b7bd0c7aba817d67ce25760eaf1
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 17 14:45:30 2009 +0100

    x86, apic: clean up the cpu_2_logical_apiciddeclaration
    
    extern declarations were scattered in 4 files - consolidate them
    into apic.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index c07f5fbf43c8..2cdd19e4536f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -541,4 +541,8 @@ static inline physid_mask_t default_apicid_to_cpu_present(int phys_apicid)
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 
+#ifdef CONFIG_X86_32
+extern u8 cpu_2_logical_apicid[NR_CPUS];
+#endif
+
 #endif /* _ASM_X86_APIC_H */

commit e2780a68f889c9d7ec8e78d58a3a2be8cfebf202
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 17 13:52:29 2009 +0100

    x86, apic: merge genapic.h into apic.h
    
    Impact: cleanup
    
    Reduce the number of include files to worry about.
    Also, most of the users of APIC facilities had to
    include genapic.h already, which embedded apic.h,
    so the distinction was meaningless.
    
    [ include apic.h from genapic.h for compatibility. ]
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 4f56e053d347..c07f5fbf43c8 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -1,15 +1,18 @@
 #ifndef _ASM_X86_APIC_H
 #define _ASM_X86_APIC_H
 
-#include <linux/pm.h>
+#include <linux/cpumask.h>
 #include <linux/delay.h>
+#include <linux/pm.h>
 
 #include <asm/alternative.h>
-#include <asm/fixmap.h>
-#include <asm/apicdef.h>
+#include <asm/cpufeature.h>
 #include <asm/processor.h>
+#include <asm/apicdef.h>
+#include <asm/atomic.h>
+#include <asm/fixmap.h>
+#include <asm/mpspec.h>
 #include <asm/system.h>
-#include <asm/cpufeature.h>
 #include <asm/msr.h>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
@@ -235,4 +238,307 @@ static inline void disable_local_APIC(void) { }
 
 #endif
 
+/*
+ * Copyright 2004 James Cleverdon, IBM.
+ * Subject to the GNU Public License, v.2
+ *
+ * Generic APIC sub-arch data struct.
+ *
+ * Hacked for x86-64 by James Cleverdon from i386 architecture code by
+ * Martin Bligh, Andi Kleen, James Bottomley, John Stultz, and
+ * James Cleverdon.
+ */
+struct genapic {
+	char *name;
+
+	int (*probe)(void);
+	int (*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
+	int (*apic_id_registered)(void);
+
+	u32 irq_delivery_mode;
+	u32 irq_dest_mode;
+
+	const struct cpumask *(*target_cpus)(void);
+
+	int disable_esr;
+
+	int dest_logical;
+	unsigned long (*check_apicid_used)(physid_mask_t bitmap, int apicid);
+	unsigned long (*check_apicid_present)(int apicid);
+
+	void (*vector_allocation_domain)(int cpu, struct cpumask *retmask);
+	void (*init_apic_ldr)(void);
+
+	physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map);
+
+	void (*setup_apic_routing)(void);
+	int (*multi_timer_check)(int apic, int irq);
+	int (*apicid_to_node)(int logical_apicid);
+	int (*cpu_to_logical_apicid)(int cpu);
+	int (*cpu_present_to_apicid)(int mps_cpu);
+	physid_mask_t (*apicid_to_cpu_present)(int phys_apicid);
+	void (*setup_portio_remap)(void);
+	int (*check_phys_apicid_present)(int boot_cpu_physical_apicid);
+	void (*enable_apic_mode)(void);
+	int (*phys_pkg_id)(int cpuid_apic, int index_msb);
+
+	/*
+	 * When one of the next two hooks returns 1 the genapic
+	 * is switched to this. Essentially they are additional
+	 * probe functions:
+	 */
+	int (*mps_oem_check)(struct mpc_table *mpc, char *oem, char *productid);
+
+	unsigned int (*get_apic_id)(unsigned long x);
+	unsigned long (*set_apic_id)(unsigned int id);
+	unsigned long apic_id_mask;
+
+	unsigned int (*cpu_mask_to_apicid)(const struct cpumask *cpumask);
+	unsigned int (*cpu_mask_to_apicid_and)(const struct cpumask *cpumask,
+					       const struct cpumask *andmask);
+
+	/* ipi */
+	void (*send_IPI_mask)(const struct cpumask *mask, int vector);
+	void (*send_IPI_mask_allbutself)(const struct cpumask *mask,
+					 int vector);
+	void (*send_IPI_allbutself)(int vector);
+	void (*send_IPI_all)(int vector);
+	void (*send_IPI_self)(int vector);
+
+	/* wakeup_secondary_cpu */
+	int (*wakeup_cpu)(int apicid, unsigned long start_eip);
+
+	int trampoline_phys_low;
+	int trampoline_phys_high;
+
+	void (*wait_for_init_deassert)(atomic_t *deassert);
+	void (*smp_callin_clear_local_apic)(void);
+	void (*store_NMI_vector)(unsigned short *high, unsigned short *low);
+	void (*inquire_remote_apic)(int apicid);
+
+	/* apic ops */
+	u32 (*read)(u32 reg);
+	void (*write)(u32 reg, u32 v);
+	u64 (*icr_read)(void);
+	void (*icr_write)(u32 low, u32 high);
+	void (*wait_icr_idle)(void);
+	u32 (*safe_wait_icr_idle)(void);
+};
+
+extern struct genapic *apic;
+
+static inline u32 apic_read(u32 reg)
+{
+	return apic->read(reg);
+}
+
+static inline void apic_write(u32 reg, u32 val)
+{
+	apic->write(reg, val);
+}
+
+static inline u64 apic_icr_read(void)
+{
+	return apic->icr_read();
+}
+
+static inline void apic_icr_write(u32 low, u32 high)
+{
+	apic->icr_write(low, high);
+}
+
+static inline void apic_wait_icr_idle(void)
+{
+	apic->wait_icr_idle();
+}
+
+static inline u32 safe_apic_wait_icr_idle(void)
+{
+	return apic->safe_wait_icr_idle();
+}
+
+
+static inline void ack_APIC_irq(void)
+{
+	/*
+	 * ack_APIC_irq() actually gets compiled as a single instruction
+	 * ... yummie.
+	 */
+
+	/* Docs say use 0 for future compatibility */
+	apic_write(APIC_EOI, 0);
+}
+
+static inline unsigned default_get_apic_id(unsigned long x)
+{
+	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
+
+	if (APIC_XAPIC(ver))
+		return (x >> 24) & 0xFF;
+	else
+		return (x >> 24) & 0x0F;
+}
+
+/*
+ * Warm reset vector default position:
+ */
+#define DEFAULT_TRAMPOLINE_PHYS_LOW		0x467
+#define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469
+
+#ifdef CONFIG_X86_32
+extern void es7000_update_genapic_to_cluster(void);
+#else
+extern struct genapic apic_flat;
+extern struct genapic apic_physflat;
+extern struct genapic apic_x2apic_cluster;
+extern struct genapic apic_x2apic_phys;
+extern int default_acpi_madt_oem_check(char *, char *);
+
+extern void apic_send_IPI_self(int vector);
+
+extern struct genapic apic_x2apic_uv_x;
+DECLARE_PER_CPU(int, x2apic_extra_bits);
+
+extern int default_cpu_present_to_apicid(int mps_cpu);
+extern int default_check_phys_apicid_present(int boot_cpu_physical_apicid);
+#endif
+
+static inline void default_wait_for_init_deassert(atomic_t *deassert)
+{
+	while (!atomic_read(deassert))
+		cpu_relax();
+	return;
+}
+
+extern void generic_bigsmp_probe(void);
+
+
+#ifdef CONFIG_X86_LOCAL_APIC
+
+#include <asm/smp.h>
+
+#define APIC_DFR_VALUE	(APIC_DFR_FLAT)
+
+static inline const struct cpumask *default_target_cpus(void)
+{
+#ifdef CONFIG_SMP
+	return cpu_online_mask;
+#else
+	return cpumask_of(0);
+#endif
+}
+
+DECLARE_EARLY_PER_CPU(u16, x86_bios_cpu_apicid);
+
+
+static inline unsigned int read_apic_id(void)
+{
+	unsigned int reg;
+
+	reg = apic_read(APIC_ID);
+
+	return apic->get_apic_id(reg);
+}
+
+extern void default_setup_apic_routing(void);
+
+#ifdef CONFIG_X86_32
+/*
+ * Set up the logical destination ID.
+ *
+ * Intel recommends to set DFR, LDR and TPR before enabling
+ * an APIC.  See e.g. "AP-388 82489DX User's Manual" (Intel
+ * document number 292116).  So here it goes...
+ */
+extern void default_init_apic_ldr(void);
+
+static inline int default_apic_id_registered(void)
+{
+	return physid_isset(read_apic_id(), phys_cpu_present_map);
+}
+
+static inline unsigned int
+default_cpu_mask_to_apicid(const struct cpumask *cpumask)
+{
+	return cpumask_bits(cpumask)[0];
+}
+
+static inline unsigned int
+default_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
+			       const struct cpumask *andmask)
+{
+	unsigned long mask1 = cpumask_bits(cpumask)[0];
+	unsigned long mask2 = cpumask_bits(andmask)[0];
+	unsigned long mask3 = cpumask_bits(cpu_online_mask)[0];
+
+	return (unsigned int)(mask1 & mask2 & mask3);
+}
+
+static inline int default_phys_pkg_id(int cpuid_apic, int index_msb)
+{
+	return cpuid_apic >> index_msb;
+}
+
+extern int default_apicid_to_node(int logical_apicid);
+
+#endif
+
+static inline unsigned long default_check_apicid_used(physid_mask_t bitmap, int apicid)
+{
+	return physid_isset(apicid, bitmap);
+}
+
+static inline unsigned long default_check_apicid_present(int bit)
+{
+	return physid_isset(bit, phys_cpu_present_map);
+}
+
+static inline physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map)
+{
+	return phys_map;
+}
+
+/* Mapping from cpu number to logical apicid */
+static inline int default_cpu_to_logical_apicid(int cpu)
+{
+	return 1 << cpu;
+}
+
+static inline int __default_cpu_present_to_apicid(int mps_cpu)
+{
+	if (mps_cpu < nr_cpu_ids && cpu_present(mps_cpu))
+		return (int)per_cpu(x86_bios_cpu_apicid, mps_cpu);
+	else
+		return BAD_APICID;
+}
+
+static inline int
+__default_check_phys_apicid_present(int boot_cpu_physical_apicid)
+{
+	return physid_isset(boot_cpu_physical_apicid, phys_cpu_present_map);
+}
+
+#ifdef CONFIG_X86_32
+static inline int default_cpu_present_to_apicid(int mps_cpu)
+{
+	return __default_cpu_present_to_apicid(mps_cpu);
+}
+
+static inline int
+default_check_phys_apicid_present(int boot_cpu_physical_apicid)
+{
+	return __default_check_phys_apicid_present(boot_cpu_physical_apicid);
+}
+#else
+extern int default_cpu_present_to_apicid(int mps_cpu);
+extern int default_check_phys_apicid_present(int boot_cpu_physical_apicid);
+#endif
+
+static inline physid_mask_t default_apicid_to_cpu_present(int phys_apicid)
+{
+	return physid_mask_of_physid(phys_apicid);
+}
+
+#endif /* CONFIG_X86_LOCAL_APIC */
+
 #endif /* _ASM_X86_APIC_H */

commit c1eeb2de41d7015678bdd412b48a5f071b84e29a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Feb 16 23:02:14 2009 -0800

    x86: fold apic_ops into genapic
    
    Impact: cleanup
    
    make it simpler, don't need have one extra struct.
    
    v2: fix the sgi_uv build
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index dc1db99cd40e..4f56e053d347 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -92,6 +92,12 @@ static inline u32 native_apic_mem_read(u32 reg)
 	return *((volatile u32 *)(APIC_BASE + reg));
 }
 
+extern void native_apic_wait_icr_idle(void);
+extern u32 native_safe_apic_wait_icr_idle(void);
+extern void native_apic_icr_write(u32 low, u32 id);
+extern u64 native_apic_icr_read(void);
+
+#ifdef CONFIG_X86_X2APIC
 static inline void native_apic_msr_write(u32 reg, u32 v)
 {
 	if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||
@@ -112,7 +118,31 @@ static inline u32 native_apic_msr_read(u32 reg)
 	return low;
 }
 
-#ifdef CONFIG_X86_X2APIC
+static inline void native_x2apic_wait_icr_idle(void)
+{
+	/* no need to wait for icr idle in x2apic */
+	return;
+}
+
+static inline u32 native_safe_x2apic_wait_icr_idle(void)
+{
+	/* no need to wait for icr idle in x2apic */
+	return 0;
+}
+
+static inline void native_x2apic_icr_write(u32 low, u32 id)
+{
+	wrmsrl(APIC_BASE_MSR + (APIC_ICR >> 4), ((__u64) id) << 32 | low);
+}
+
+static inline u64 native_x2apic_icr_read(void)
+{
+	unsigned long val;
+
+	rdmsrl(APIC_BASE_MSR + (APIC_ICR >> 4), val);
+	return val;
+}
+
 extern int x2apic;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
@@ -146,47 +176,6 @@ static inline int x2apic_enabled(void)
 }
 #endif
 
-struct apic_ops {
-	u32 (*read)(u32 reg);
-	void (*write)(u32 reg, u32 v);
-	u64 (*icr_read)(void);
-	void (*icr_write)(u32 low, u32 high);
-	void (*wait_icr_idle)(void);
-	u32 (*safe_wait_icr_idle)(void);
-};
-
-extern struct apic_ops *apic_ops;
-
-static inline u32 apic_read(u32 reg)
-{
-	return apic_ops->read(reg);
-}
-
-static inline void apic_write(u32 reg, u32 val)
-{
-	apic_ops->write(reg, val);
-}
-
-static inline u64 apic_icr_read(void)
-{
-	return apic_ops->icr_read();
-}
-
-static inline void apic_icr_write(u32 low, u32 high)
-{
-	apic_ops->icr_write(low, high);
-}
-
-static inline void apic_wait_icr_idle(void)
-{
-	apic_ops->wait_icr_idle();
-}
-
-static inline u32 safe_apic_wait_icr_idle(void)
-{
-	return apic_ops->safe_wait_icr_idle();
-}
-
 extern int get_physical_broadcast(void);
 
 #ifdef CONFIG_X86_X2APIC
@@ -197,18 +186,6 @@ static inline void ack_x2APIC_irq(void)
 }
 #endif
 
-
-static inline void ack_APIC_irq(void)
-{
-	/*
-	 * ack_APIC_irq() actually gets compiled as a single instruction
-	 * ... yummie.
-	 */
-
-	/* Docs say use 0 for future compatibility */
-	apic_write(APIC_EOI, 0);
-}
-
 extern int lapic_get_maxlvt(void);
 extern void clear_local_APIC(void);
 extern void connect_bsp_APIC(void);
@@ -256,18 +233,6 @@ static inline void disable_local_APIC(void) { }
 #define	SET_APIC_ID(x)		(apic->set_apic_id(x))
 #else
 
-#ifdef CONFIG_X86_LOCAL_APIC
-static inline unsigned default_get_apic_id(unsigned long x)
-{
-	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
-
-	if (APIC_XAPIC(ver))
-		return (x >> 24) & 0xFF;
-	else
-		return (x >> 24) & 0x0F;
-}
-#endif
-
 #endif
 
 #endif /* _ASM_X86_APIC_H */

commit 06cd9a7dc8a58186060a91b6ddc031057435fd34
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Feb 16 17:29:58 2009 -0800

    x86: add x2apic config
    
    Impact: cleanup
    
    so could deselect x2apic
    and INTR_REMAP will select x2apic
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index fba49f66228f..dc1db99cd40e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -112,7 +112,7 @@ static inline u32 native_apic_msr_read(u32 reg)
 	return low;
 }
 
-#ifndef CONFIG_X86_32
+#ifdef CONFIG_X86_X2APIC
 extern int x2apic;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
@@ -131,7 +131,19 @@ static inline int x2apic_enabled(void)
 	return 0;
 }
 #else
-#define x2apic_enabled()	0
+static inline void check_x2apic(void)
+{
+}
+static inline void enable_x2apic(void)
+{
+}
+static inline void enable_IR_x2apic(void)
+{
+}
+static inline int x2apic_enabled(void)
+{
+	return 0;
+}
 #endif
 
 struct apic_ops {
@@ -177,7 +189,7 @@ static inline u32 safe_apic_wait_icr_idle(void)
 
 extern int get_physical_broadcast(void);
 
-#ifdef CONFIG_X86_64
+#ifdef CONFIG_X86_X2APIC
 static inline void ack_x2APIC_irq(void)
 {
 	/* Docs say use 0 for future compatibility */

commit 160d8dac12932ad6eb4a359b66521e2e3282ea7d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Feb 11 11:27:39 2009 +0100

    x86, apic: make generic_apic_probe() generally available
    
    Impact: build fix
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index f4835a1be360..fba49f66228f 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -33,7 +33,13 @@
 	} while (0)
 
 
+#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86_32)
 extern void generic_apic_probe(void);
+#else
+static inline void generic_apic_probe(void)
+{
+}
+#endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
 

commit 3c552ac8a747d6c26d13302c54d71dae9f56f4ac
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon Feb 9 12:05:47 2009 -0800

    x86: make apic_* operations inline functions
    
    Mainly to get proper type-checking and consistency.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index b03711d7990b..f4835a1be360 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -139,12 +139,35 @@ struct apic_ops {
 
 extern struct apic_ops *apic_ops;
 
-#define apic_read (apic_ops->read)
-#define apic_write (apic_ops->write)
-#define apic_icr_read (apic_ops->icr_read)
-#define apic_icr_write (apic_ops->icr_write)
-#define apic_wait_icr_idle (apic_ops->wait_icr_idle)
-#define safe_apic_wait_icr_idle (apic_ops->safe_wait_icr_idle)
+static inline u32 apic_read(u32 reg)
+{
+	return apic_ops->read(reg);
+}
+
+static inline void apic_write(u32 reg, u32 val)
+{
+	apic_ops->write(reg, val);
+}
+
+static inline u64 apic_icr_read(void)
+{
+	return apic_ops->icr_read();
+}
+
+static inline void apic_icr_write(u32 low, u32 high)
+{
+	apic_ops->icr_write(low, high);
+}
+
+static inline void apic_wait_icr_idle(void)
+{
+	apic_ops->wait_icr_idle();
+}
+
+static inline u32 safe_apic_wait_icr_idle(void)
+{
+	return apic_ops->safe_wait_icr_idle();
+}
 
 extern int get_physical_broadcast(void);
 

commit 6bda2c8b32febeb38ee128047253751e080bad52
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 28 19:32:55 2009 +0100

    x86: remove subarchitecture support
    
    Remove the 32-bit subarchitecture support code.
    
    All subarchitectures but Voyager have been converted. Voyager will be
    done later or will be removed.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 6a77068e261a..b03711d7990b 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -215,6 +215,7 @@ static inline void disable_local_APIC(void) { }
 #define	SET_APIC_ID(x)		(apic->set_apic_id(x))
 #else
 
+#ifdef CONFIG_X86_LOCAL_APIC
 static inline unsigned default_get_apic_id(unsigned long x)
 {
 	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
@@ -224,6 +225,7 @@ static inline unsigned default_get_apic_id(unsigned long x)
 	else
 		return (x >> 24) & 0x0F;
 }
+#endif
 
 #endif
 

commit 1dcdd3d15ecea0c22a09d4d001a39d425fceff2c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 28 17:55:37 2009 +0100

    x86: remove mach_apic.h
    
    Spread mach_apic.h definitions into genapic.h. (with some knock-on effects
    on smp.h and apic.h.)
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 3a3202074c63..6a77068e261a 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -215,7 +215,7 @@ static inline void disable_local_APIC(void) { }
 #define	SET_APIC_ID(x)		(apic->set_apic_id(x))
 #else
 
-static inline unsigned default_get_apic_id(unsigned long x) 
+static inline unsigned default_get_apic_id(unsigned long x)
 {
 	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
 

commit 1f75ed0c1311a50ed393bcac258de65680d360e5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 28 17:36:56 2009 +0100

    x86: remove mach_apicdef.h
    
    Move its definitions into apic.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e8f030440bc7..3a3202074c63 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -211,4 +211,20 @@ static inline void disable_local_APIC(void) { }
 
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
+#ifdef CONFIG_X86_64
+#define	SET_APIC_ID(x)		(apic->set_apic_id(x))
+#else
+
+static inline unsigned default_get_apic_id(unsigned long x) 
+{
+	unsigned int ver = GET_APIC_VERSION(apic_read(APIC_LVR));
+
+	if (APIC_XAPIC(ver))
+		return (x >> 24) & 0xFF;
+	else
+		return (x >> 24) & 0x0F;
+}
+
+#endif
+
 #endif /* _ASM_X86_APIC_H */

commit 0939e4fd351c58d08d25650797749f18904461af
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 28 17:16:25 2009 +0100

    x86, smp: eliminate asm/mach-default/mach_wakecpu.h
    
    Spread mach_wakecpu.h's definitions into apic.h and genapic.h
    and remove mach_wakecpu.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ab1d51a8855e..e8f030440bc7 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -41,6 +41,21 @@ extern unsigned int apic_verbosity;
 extern int local_apic_timer_c2_ok;
 
 extern int disable_apic;
+
+#ifdef CONFIG_SMP
+extern void __inquire_remote_apic(int apicid);
+#else /* CONFIG_SMP */
+static inline void __inquire_remote_apic(int apicid)
+{
+}
+#endif /* CONFIG_SMP */
+
+static inline void default_inquire_remote_apic(int apicid)
+{
+	if (apic_verbosity >= APIC_DEBUG)
+		__inquire_remote_apic(apicid);
+}
+
 /*
  * Basic functions accessing APICs.
  */

commit ec8c842a524888fdcccece337d91798e3e8af880
Author: Jaswinder Singh Rajput <jaswinder@infradead.org>
Date:   Tue Dec 30 22:46:36 2008 +0530

    x86: apic.c: xapic_icr_read and x2apic_icr_read should be static
    
    Impact: cleanup, reduce kernel size a bit, avoid sparse warning
    
    Fixes sparse warning:
    arch/x86/kernel/apic.c:270:5: warning: symbol 'x2apic_icr_read' was not declared. Should it be static?
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index e644bf6f90dc..ab1d51a8855e 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -54,7 +54,6 @@ extern int disable_apic;
 extern int is_vsmp_box(void);
 extern void xapic_wait_icr_idle(void);
 extern u32 safe_xapic_wait_icr_idle(void);
-extern u64 xapic_icr_read(void);
 extern void xapic_icr_write(u32, u32);
 extern int setup_profiling_timer(unsigned int);
 

commit b6b301aa9fba57b114c3a00f5f43abf672bd4ecd
Author: Jaswinder Singh <jaswinder@infradead.org>
Date:   Tue Dec 23 21:52:33 2008 +0530

    x86: apic.c x2apic_preenabled and disable_x2apic should be static
    
    Impact: cleanup, reduce kernel size a bit, avoid sparse warning
    
    Fixes sparse warning:
    
      arch/x86/kernel/apic.c:103:5: warning: symbol 'disable_x2apic' was not declared. Should it be static?
    
    Signed-off-by: Jaswinder Singh <jaswinder@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 25caa0738af5..e644bf6f90dc 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -93,7 +93,7 @@ static inline u32 native_apic_msr_read(u32 reg)
 }
 
 #ifndef CONFIG_X86_32
-extern int x2apic, x2apic_preenabled;
+extern int x2apic;
 extern void check_x2apic(void);
 extern void enable_x2apic(void);
 extern void enable_IR_x2apic(void);

commit d3ec5cae0921611ceae06464ef6291012dd9849f
Author: Ivan Vecera <ivecera@redhat.com>
Date:   Tue Nov 11 14:33:44 2008 +0100

    x86: call machine_shutdown and stop all CPUs in native_machine_halt
    
    Impact: really halt all CPUs on halt
    
    Function machine_halt (resp. native_machine_halt) is empty for x86
    architectures. When command 'halt -f' is invoked, the message "System
    halted." is displayed but this is not really true because all CPUs are
    still running.
    
    There are also similar inconsistencies for other arches (some uses
    power-off for halt or forever-loop with IRQs enabled/disabled).
    
    IMO there should be used the same approach for all architectures OR
    what does the message "System halted" really mean?
    
    This patch fixes it for x86.
    
    Signed-off-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index 3b1510b4fc57..25caa0738af5 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -193,6 +193,7 @@ extern u8 setup_APIC_eilvt_ibs(u8 vector, u8 msg_type, u8 mask);
 static inline void lapic_shutdown(void) { }
 #define local_apic_timer_c2_ok		1
 static inline void init_apic_mappings(void) { }
+static inline void disable_local_APIC(void) { }
 
 #endif /* !CONFIG_X86_LOCAL_APIC */
 

commit 1965aae3c98397aad957412413c07e97b1bd4e64
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Oct 22 22:26:29 2008 -0700

    x86: Fix ASM_X86__ header guards
    
    Change header guards named "ASM_X86__*" to "_ASM_X86_*" since:
    
    a. the double underscore is ugly and pointless.
    b. no leading underscore violates namespace constraints.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index ef1d72dbdfe0..3b1510b4fc57 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -1,5 +1,5 @@
-#ifndef ASM_X86__APIC_H
-#define ASM_X86__APIC_H
+#ifndef _ASM_X86_APIC_H
+#define _ASM_X86_APIC_H
 
 #include <linux/pm.h>
 #include <linux/delay.h>
@@ -196,4 +196,4 @@ static inline void init_apic_mappings(void) { }
 
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
-#endif /* ASM_X86__APIC_H */
+#endif /* _ASM_X86_APIC_H */

commit bb8985586b7a906e116db835c64773b7a7d51663
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 17 21:05:42 2008 -0400

    x86, um: ... and asm-x86 move
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
new file mode 100644
index 000000000000..ef1d72dbdfe0
--- /dev/null
+++ b/arch/x86/include/asm/apic.h
@@ -0,0 +1,199 @@
+#ifndef ASM_X86__APIC_H
+#define ASM_X86__APIC_H
+
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+#include <asm/alternative.h>
+#include <asm/fixmap.h>
+#include <asm/apicdef.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/cpufeature.h>
+#include <asm/msr.h>
+
+#define ARCH_APICTIMER_STOPS_ON_C3	1
+
+/*
+ * Debugging macros
+ */
+#define APIC_QUIET   0
+#define APIC_VERBOSE 1
+#define APIC_DEBUG   2
+
+/*
+ * Define the default level of output to be very little
+ * This can be turned up by using apic=verbose for more
+ * information and apic=debug for _lots_ of information.
+ * apic_verbosity is defined in apic.c
+ */
+#define apic_printk(v, s, a...) do {       \
+		if ((v) <= apic_verbosity) \
+			printk(s, ##a);    \
+	} while (0)
+
+
+extern void generic_apic_probe(void);
+
+#ifdef CONFIG_X86_LOCAL_APIC
+
+extern unsigned int apic_verbosity;
+extern int local_apic_timer_c2_ok;
+
+extern int disable_apic;
+/*
+ * Basic functions accessing APICs.
+ */
+#ifdef CONFIG_PARAVIRT
+#include <asm/paravirt.h>
+#else
+#define setup_boot_clock setup_boot_APIC_clock
+#define setup_secondary_clock setup_secondary_APIC_clock
+#endif
+
+extern int is_vsmp_box(void);
+extern void xapic_wait_icr_idle(void);
+extern u32 safe_xapic_wait_icr_idle(void);
+extern u64 xapic_icr_read(void);
+extern void xapic_icr_write(u32, u32);
+extern int setup_profiling_timer(unsigned int);
+
+static inline void native_apic_mem_write(u32 reg, u32 v)
+{
+	volatile u32 *addr = (volatile u32 *)(APIC_BASE + reg);
+
+	alternative_io("movl %0, %1", "xchgl %0, %1", X86_FEATURE_11AP,
+		       ASM_OUTPUT2("=r" (v), "=m" (*addr)),
+		       ASM_OUTPUT2("0" (v), "m" (*addr)));
+}
+
+static inline u32 native_apic_mem_read(u32 reg)
+{
+	return *((volatile u32 *)(APIC_BASE + reg));
+}
+
+static inline void native_apic_msr_write(u32 reg, u32 v)
+{
+	if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||
+	    reg == APIC_LVR)
+		return;
+
+	wrmsr(APIC_BASE_MSR + (reg >> 4), v, 0);
+}
+
+static inline u32 native_apic_msr_read(u32 reg)
+{
+	u32 low, high;
+
+	if (reg == APIC_DFR)
+		return -1;
+
+	rdmsr(APIC_BASE_MSR + (reg >> 4), low, high);
+	return low;
+}
+
+#ifndef CONFIG_X86_32
+extern int x2apic, x2apic_preenabled;
+extern void check_x2apic(void);
+extern void enable_x2apic(void);
+extern void enable_IR_x2apic(void);
+extern void x2apic_icr_write(u32 low, u32 id);
+static inline int x2apic_enabled(void)
+{
+	int msr, msr2;
+
+	if (!cpu_has_x2apic)
+		return 0;
+
+	rdmsr(MSR_IA32_APICBASE, msr, msr2);
+	if (msr & X2APIC_ENABLE)
+		return 1;
+	return 0;
+}
+#else
+#define x2apic_enabled()	0
+#endif
+
+struct apic_ops {
+	u32 (*read)(u32 reg);
+	void (*write)(u32 reg, u32 v);
+	u64 (*icr_read)(void);
+	void (*icr_write)(u32 low, u32 high);
+	void (*wait_icr_idle)(void);
+	u32 (*safe_wait_icr_idle)(void);
+};
+
+extern struct apic_ops *apic_ops;
+
+#define apic_read (apic_ops->read)
+#define apic_write (apic_ops->write)
+#define apic_icr_read (apic_ops->icr_read)
+#define apic_icr_write (apic_ops->icr_write)
+#define apic_wait_icr_idle (apic_ops->wait_icr_idle)
+#define safe_apic_wait_icr_idle (apic_ops->safe_wait_icr_idle)
+
+extern int get_physical_broadcast(void);
+
+#ifdef CONFIG_X86_64
+static inline void ack_x2APIC_irq(void)
+{
+	/* Docs say use 0 for future compatibility */
+	native_apic_msr_write(APIC_EOI, 0);
+}
+#endif
+
+
+static inline void ack_APIC_irq(void)
+{
+	/*
+	 * ack_APIC_irq() actually gets compiled as a single instruction
+	 * ... yummie.
+	 */
+
+	/* Docs say use 0 for future compatibility */
+	apic_write(APIC_EOI, 0);
+}
+
+extern int lapic_get_maxlvt(void);
+extern void clear_local_APIC(void);
+extern void connect_bsp_APIC(void);
+extern void disconnect_bsp_APIC(int virt_wire_setup);
+extern void disable_local_APIC(void);
+extern void lapic_shutdown(void);
+extern int verify_local_APIC(void);
+extern void cache_APIC_registers(void);
+extern void sync_Arb_IDs(void);
+extern void init_bsp_APIC(void);
+extern void setup_local_APIC(void);
+extern void end_local_APIC_setup(void);
+extern void init_apic_mappings(void);
+extern void setup_boot_APIC_clock(void);
+extern void setup_secondary_APIC_clock(void);
+extern int APIC_init_uniprocessor(void);
+extern void enable_NMI_through_LVT0(void);
+
+/*
+ * On 32bit this is mach-xxx local
+ */
+#ifdef CONFIG_X86_64
+extern void early_init_lapic_mapping(void);
+extern int apic_is_clustered_box(void);
+#else
+static inline int apic_is_clustered_box(void)
+{
+	return 0;
+}
+#endif
+
+extern u8 setup_APIC_eilvt_mce(u8 vector, u8 msg_type, u8 mask);
+extern u8 setup_APIC_eilvt_ibs(u8 vector, u8 msg_type, u8 mask);
+
+
+#else /* !CONFIG_X86_LOCAL_APIC */
+static inline void lapic_shutdown(void) { }
+#define local_apic_timer_c2_ok		1
+static inline void init_apic_mappings(void) { }
+
+#endif /* !CONFIG_X86_LOCAL_APIC */
+
+#endif /* ASM_X86__APIC_H */
