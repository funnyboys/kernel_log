commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index d8bfa98fca98..678fb546f0a7 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -1,22 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef _ASM_UPROBES_H
 #define _ASM_UPROBES_H
 /*
  * User-space Probes (UProbes) for x86
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Copyright (C) IBM Corporation, 2008-2011
  * Authors:
  *	Srikar Dronamraju

commit e7ed9d9bd0375c74fe6e27d8bc73d3c6f4c8c3bc
Author: Yonghong Song <yhs@fb.com>
Date:   Thu Nov 30 16:12:02 2017 -0800

    uprobes/x86: Emulate push insns for uprobe on x86
    
    Uprobe is a tracing mechanism for userspace programs.
    Typical uprobe will incur overhead of two traps.
    First trap is caused by replaced trap insn, and
    the second trap is to execute the original displaced
    insn in user space.
    
    To reduce the overhead, kernel provides hooks
    for architectures to emulate the original insn
    and skip the second trap. In x86, emulation
    is done for certain branch insns.
    
    This patch extends the emulation to "push <reg>"
    insns. These insns are typical in the beginning
    of the function. For example, bcc
    in https://github.com/iovisor/bcc repo provides
    tools to measure funclantency, detect memleak, etc.
    The tools will place uprobes in the beginning of
    function and possibly uretprobes at the end of function.
    This patch is able to reduce the trap overhead for
    uprobe from 2 to 1.
    
    Without this patch, uretprobe will typically incur
    three traps. With this patch, if the function starts
    with "push" insn, the number of traps can be
    reduced from 3 to 2.
    
    An experiment was conducted on two local VMs,
    fedora 26 64-bit VM and 32-bit VM, both 4 processors
    and 4GB memory, booted with latest tip repo (and this patch).
    The host is MacBook with intel i7 processor.
    
    The test program looks like:
    
      #include <stdio.h>
      #include <stdlib.h>
      #include <time.h>
      #include <sys/time.h>
    
      static void test() __attribute__((noinline));
      void test() {}
      int main() {
        struct timeval start, end;
    
        gettimeofday(&start, NULL);
        for (int i = 0; i < 1000000; i++) {
          test();
        }
        gettimeofday(&end, NULL);
    
        printf("%ld\n", ((end.tv_sec * 1000000 + end.tv_usec)
                         - (start.tv_sec * 1000000 + start.tv_usec)));
        return 0;
      }
    
    The program is compiled without optimization, and
    the first insn for function "test" is "push %rbp".
    The host is relatively idle.
    
    Before the test run, the uprobe is inserted as below for uprobe:
      echo 'p <binary>:<test_func_offset>' > /sys/kernel/debug/tracing/uprobe_events
      echo 1 > /sys/kernel/debug/tracing/events/uprobes/enable
    and for uretprobe:
      echo 'r <binary>:<test_func_offset>' > /sys/kernel/debug/tracing/uprobe_events
      echo 1 > /sys/kernel/debug/tracing/events/uprobes/enable
    
    Unit: microsecond(usec) per loop iteration
    
    x86_64          W/ this patch   W/O this patch
    uprobe          1.55            3.1
    uretprobe       2.0             3.6
    
    x86_32          W/ this patch   W/O this patch
    uprobe          1.41            3.5
    uretprobe       1.75            4.0
    
    You can see that this patch significantly reduced the overhead,
    50% for uprobe and 44% for uretprobe on x86_64, and even more
    on x86_32.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: kernel-team@fb.com
    Link: http://lkml.kernel.org/r/20171201001202.3706564-1-yhs@fb.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 74f4c2ff6427..d8bfa98fca98 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -53,6 +53,10 @@ struct arch_uprobe {
 			u8	fixups;
 			u8	ilen;
 		} 			defparam;
+		struct {
+			u8	reg_offset;	/* to the start of pt_regs */
+			u8	ilen;
+		}			push;
 	};
 };
 

commit 5cdb76d6f0b657c1140de74ed5af7cc8c5ed5faf
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Jun 1 21:13:46 2014 +0200

    uprobes/x86: Rename arch_uprobe->def to ->defparam, minor comment updates
    
    Purely cosmetic, no changes in .o,
    
    1. As Jim pointed out arch_uprobe->def looks ambiguous, rename it to
       ->defparam.
    
    2. Add the comment into default_post_xol_op() to explain "regs->sp +=".
    
    3. Remove the stale part of the comment in arch_uprobe_analyze_insn().
    
    Suggested-by: Jim Keniston <jkenisto@us.ibm.com>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 7be3c079e389..74f4c2ff6427 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -52,7 +52,7 @@ struct arch_uprobe {
 		struct {
 			u8	fixups;
 			u8	ilen;
-		} 			def;
+		} 			defparam;
 	};
 };
 

commit 50204c6f6dd01b5bce1b53e0b003d01849455512
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Thu May 1 16:52:46 2014 +0200

    uprobes/x86: Simplify rip-relative handling
    
    It is possible to replace rip-relative addressing mode with addressing
    mode of the same length: (reg+disp32). This eliminates the need to fix
    up immediate and correct for changing instruction length.
    
    And we can kill arch_uprobe->def.riprel_target.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index a040d493a4f9..7be3c079e389 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -50,9 +50,6 @@ struct arch_uprobe {
 			u8	opc1;
 		}			branch;
 		struct {
-#ifdef CONFIG_X86_64
-			long	riprel_target;
-#endif
 			u8	fixups;
 			u8	ilen;
 		} 			def;

commit 1dc76e6eacef271230d9ff6fd0f91824bda03f44
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Apr 25 18:06:19 2014 +0200

    uprobes/x86: Kill adjust_ret_addr(), simplify UPROBE_FIX_CALL logic
    
    The only insn which could have both UPROBE_FIX_IP and UPROBE_FIX_CALL
    was 0xe8 "call relative", and now it is handled by branch_xol_ops.
    
    So we can change default_post_xol_op(UPROBE_FIX_CALL) to simply push
    the address of next insn == utask->vaddr + insn.length, just we need
    to record insn.length into the new auprobe->def.ilen member.
    
    Note: if/when we teach branch_xol_ops to support jcxz/loopz we can
    remove the "correction" logic, UPROBE_FIX_IP can use the same address.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 9ce25ce04fee..a040d493a4f9 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -54,6 +54,7 @@ struct arch_uprobe {
 			long	riprel_target;
 #endif
 			u8	fixups;
+			u8	ilen;
 		} 			def;
 	};
 };

commit 78d9af4cd375880a574327210eb9dab572618364
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Thu Apr 24 18:52:37 2014 +0200

    uprobes/x86: Cleanup the usage of arch_uprobe->def.fixups, make it u8
    
    handle_riprel_insn() assumes that nobody else could modify ->fixups
    before. This is correct but fragile, change it to use "|=".
    
    Also make ->fixups u8, we are going to add the new members into the
    union. It is not clear why UPROBE_FIX_RIP_.X lived in the upper byte,
    redefine them so that they can fit into u8.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 72caff7afbde..9ce25ce04fee 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -53,7 +53,7 @@ struct arch_uprobe {
 #ifdef CONFIG_X86_64
 			long	riprel_target;
 #endif
-			u16	fixups;
+			u8	fixups;
 		} 			def;
 	};
 };

commit 97aa5cddbe9e01521137f337624469374e3cbde5
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Apr 22 16:20:55 2014 +0200

    uprobes/x86: Move default_xol_ops's data into arch_uprobe->def
    
    Finally we can move arch_uprobe->fixups/rip_rela_target_address
    into the new "def" struct and place this struct in the union, they
    are only used by default_xol_ops paths.
    
    The patch also renames rip_rela_target_address to riprel_target just
    to make this name shorter.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 93bee7b93854..72caff7afbde 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -41,18 +41,20 @@ struct arch_uprobe {
 		u8			ixol[MAX_UINSN_BYTES];
 	};
 
-	u16				fixups;
 	const struct uprobe_xol_ops	*ops;
 
 	union {
-#ifdef CONFIG_X86_64
-		unsigned long			rip_rela_target_address;
-#endif
 		struct {
 			s32	offs;
 			u8	ilen;
 			u8	opc1;
-		}				branch;
+		}			branch;
+		struct {
+#ifdef CONFIG_X86_64
+			long	riprel_target;
+#endif
+			u16	fixups;
+		} 			def;
 	};
 };
 

commit 8e89c0be171b1a9ed2ba67168733ca811bb45d5c
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Apr 6 18:11:02 2014 +0200

    uprobes/x86: Emulate relative call's
    
    See the previous "Emulate unconditional relative jmp's" which explains
    why we can not execute "jmp" out-of-line, the same applies to "call".
    
    Emulating of rip-relative call is trivial, we only need to additionally
    push the ret-address. If this fails, we execute this instruction out of
    line and this should trigger the trap, the probed application should die
    or the same insn will be restarted if a signal handler expands the stack.
    We do not even need ->post_xol() for this case.
    
    But there is a corner (and almost theoretical) case: another thread can
    expand the stack right before we execute this insn out of line. In this
    case it hit the same problem we are trying to solve. So we simply turn
    the probed insn into "call 1f; 1:" and add ->post_xol() which restores
    ->sp and restarts.
    
    Many thanks to Jonathan who finally found the standalone reproducer,
    otherwise I would never resolve the "random SIGSEGV's under systemtap"
    bug-report. Now that the problem is clear we can write the simplified
    test-case:
    
            void probe_func(void), callee(void);
    
            int failed = 1;
    
            asm (
                    ".text\n"
                    ".align 4096\n"
                    ".globl probe_func\n"
                    "probe_func:\n"
                    "call callee\n"
                    "ret"
            );
    
            /*
             * This assumes that:
             *
             *      - &probe_func = 0x401000 + a_bit, aligned = 0x402000
             *
             *      - xol_vma->vm_start = TASK_SIZE_MAX - PAGE_SIZE = 0x7fffffffe000
             *        as xol_add_vma() asks; the 1st slot = 0x7fffffffe080
             *
             * so we can target the non-canonical address from xol_vma using
             * the simple math below, 100 * 4096 is just the random offset
             */
            asm (".org . + 0x800000000000 - 0x7fffffffe080 - 5 - 1  + 100 * 4096\n");
    
            void callee(void)
            {
                    failed = 0;
            }
    
            int main(void)
            {
                    probe_func();
                    return failed;
            }
    
    It SIGSEGV's if you probe "probe_func" (although this is not very reliable,
    randomize_va_space/etc can change the placement of xol area).
    
    Note: as Denys Vlasenko pointed out, amd and intel treat "callw" (0x66 0xe8)
    differently. This patch relies on lib/insn.c and thus implements the intel's
    behaviour: 0x66 is simply ignored. Fortunately nothing sane should ever use
    this insn, so we postpone the fix until we decide what should we do; emulate
    or not, support or not, etc.
    
    Reported-by: Jonathan Lebon <jlebon@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index e9fd4d5537ed..93bee7b93854 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -51,6 +51,7 @@ struct arch_uprobe {
 		struct {
 			s32	offs;
 			u8	ilen;
+			u8	opc1;
 		}				branch;
 	};
 };

commit 7ba6db2d688bdf83049a18c8e55b2d1e58e8b0bc
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sat Apr 5 20:05:02 2014 +0200

    uprobes/x86: Emulate unconditional relative jmp's
    
    Currently we always execute all insns out-of-line, including relative
    jmp's and call's. This assumes that even if regs->ip points to nowhere
    after the single-step, default_post_xol_op(UPROBE_FIX_IP) logic will
    update it correctly.
    
    However, this doesn't work if this regs->ip == xol_vaddr + insn_offset
    is not canonical. In this case CPU generates #GP and general_protection()
    kills the task which tries to execute this insn out-of-line.
    
    Now that we have uprobe_xol_ops we can teach uprobes to emulate these
    insns and solve the problem. This patch adds branch_xol_ops which has
    a single branch_emulate_op() hook, so far it can only handle rel8/32
    relative jmp's.
    
    TODO: move ->fixup into the union along with rip_rela_target_address.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reported-by: Jonathan Lebon <jlebon@redhat.com>
    Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 9f8210bcbb49..e9fd4d5537ed 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -44,9 +44,15 @@ struct arch_uprobe {
 	u16				fixups;
 	const struct uprobe_xol_ops	*ops;
 
+	union {
 #ifdef CONFIG_X86_64
-	unsigned long			rip_rela_target_address;
+		unsigned long			rip_rela_target_address;
 #endif
+		struct {
+			s32	offs;
+			u8	ilen;
+		}				branch;
+	};
 };
 
 struct arch_uprobe_task {

commit 8ad8e9d3fd64f101eed6652964670672d699e563
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Mar 31 21:01:31 2014 +0200

    uprobes/x86: Introduce uprobe_xol_ops and arch_uprobe->ops
    
    Introduce arch_uprobe->ops pointing to the "struct uprobe_xol_ops",
    move the current UPROBE_FIX_{RIP*,IP,CALL} code into the default
    set of methods and change arch_uprobe_pre/post_xol() accordingly.
    
    This way we can add the new uprobe_xol_ops's to handle the insns
    which need the special processing (rip-relative jmp/call at least).
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 3087ea9c5f2e..9f8210bcbb49 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -33,12 +33,17 @@ typedef u8 uprobe_opcode_t;
 #define UPROBE_SWBP_INSN		0xcc
 #define UPROBE_SWBP_INSN_SIZE		   1
 
+struct uprobe_xol_ops;
+
 struct arch_uprobe {
-	u16				fixups;
 	union {
 		u8			insn[MAX_UINSN_BYTES];
 		u8			ixol[MAX_UINSN_BYTES];
 	};
+
+	u16				fixups;
+	const struct uprobe_xol_ops	*ops;
+
 #ifdef CONFIG_X86_64
 	unsigned long			rip_rela_target_address;
 #endif

commit 8a8de66c4f6ebd0f6d3da026ec24339aa5d1db12
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Nov 4 20:27:13 2013 +0100

    uprobes: Introduce arch_uprobe->ixol
    
    Currently xol_get_insn_slot() assumes that we should simply copy
    arch_uprobe->insn[] which is (ignoring arch_uprobe_analyze_insn)
    just the copy of the original insn.
    
    This is not true for arm which needs to create another insn to
    execute it out-of-line.
    
    So this patch simply adds the new member, ->ixol into the union.
    This doesn't make any difference for x86 and powerpc, but arm
    can divorce insn/ixol and initialize the correct xol insn in
    arch_uprobe_analyze_insn().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index b20b4d68b934..3087ea9c5f2e 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -35,7 +35,10 @@ typedef u8 uprobe_opcode_t;
 
 struct arch_uprobe {
 	u16				fixups;
-	u8				insn[MAX_UINSN_BYTES];
+	union {
+		u8			insn[MAX_UINSN_BYTES];
+		u8			ixol[MAX_UINSN_BYTES];
+	};
 #ifdef CONFIG_X86_64
 	unsigned long			rip_rela_target_address;
 #endif

commit 3820b4d2789f5166afdb136bb14f93166e6cfbc2
Author: David A. Long <dave.long@linaro.org>
Date:   Tue Oct 15 17:04:16 2013 -0400

    uprobes: Move function declarations out of arch
    
    Move the function declarations from the arch headers to the common
    header, since only the function bodies are architecture-specific.
    These changes are from Vincent Rabin's uprobes patch.
    
    [ oleg: update arch/powerpc/include/asm/uprobes.h ]
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: David A. Long <dave.long@linaro.org>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 6e5197910fd8..b20b4d68b934 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -49,11 +49,4 @@ struct arch_uprobe_task {
 	unsigned int			saved_tf;
 };
 
-extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);
-extern int  arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
-extern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
-extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
-extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
-extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
-extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
 #endif	/* _ASM_UPROBES_H */

commit 791eca10107f2886c1915d91c99a3b022a75909c
Author: Anton Arapov <anton@redhat.com>
Date:   Wed Apr 3 18:00:33 2013 +0200

    uretprobes/x86: Hijack return address
    
    Hijack the return address and replace it with a trampoline address.
    
    Signed-off-by: Anton Arapov <anton@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 8ff8be7835ab..6e5197910fd8 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -55,4 +55,5 @@ extern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
 extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
 #endif	/* _ASM_UPROBES_H */

commit baedbf02b1912225d60dd7403acb4b4e003088b5
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Sep 3 17:02:16 2012 +0200

    uprobes: Make arch_uprobe_task->saved_trap_nr "unsigned int"
    
    Make arch_uprobe_task->saved_trap_nr "unsigned int" and move it down
    after ->saved_scratch_register, this changes sizeof() from 24 to 16.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index d561ff5a3d4d..8ff8be7835ab 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -42,10 +42,10 @@ struct arch_uprobe {
 };
 
 struct arch_uprobe_task {
-	unsigned long			saved_trap_nr;
 #ifdef CONFIG_X86_64
 	unsigned long			saved_scratch_register;
 #endif
+	unsigned int			saved_trap_nr;
 	unsigned int			saved_tf;
 };
 

commit 3a4664aa8362d9fa9110828f55afa9f9fcd7e484
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Sep 3 16:05:10 2012 +0200

    uprobes/x86: Xol should send SIGTRAP if X86_EFLAGS_TF was set
    
    arch_uprobe_disable_step() correctly preserves X86_EFLAGS_TF and
    returns to user-mode. But this means the application gets SIGTRAP
    only after the next insn.
    
    This means that UPROBE_CLEAR_TF logic is not really right. _enable
    should only record the state of X86_EFLAGS_TF, and _disable should
    check it separately from UPROBE_FIX_SETF.
    
    Remove arch_uprobe_task->restore_flags, add ->saved_tf instead, and
    change enable/disable accordingly. This assumes that the probed insn
    was not trapped, see the next patch.
    
    arch_uprobe_skip_sstep() logic has the same problem, change it to
    check X86_EFLAGS_TF and send SIGTRAP as well. We will cleanup this
    all after we fold enable/disable_step into pre/post_hol hooks.
    
    Note: send_sig(SIGTRAP) is not actually right, we need send_sigtrap().
    But this needs more changes, handle_swbp() does the same and this is
    equally wrong.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index cee58624cb30..d561ff5a3d4d 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -46,8 +46,7 @@ struct arch_uprobe_task {
 #ifdef CONFIG_X86_64
 	unsigned long			saved_scratch_register;
 #endif
-#define UPROBE_CLEAR_TF			(1 << 0)
-	unsigned int			restore_flags;
+	unsigned int			saved_tf;
 };
 
 extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);

commit bdc1e47217315be14ba04881b0a4c8ecb3ff320c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Aug 20 12:47:34 2012 +0200

    uprobes/x86: Implement x86 specific arch_uprobe_*_step
    
    The arch specific implementation behaves like user_enable_single_step()
    except that it does not disable single stepping if it was already
    enabled by ptrace. This allows the debugger to single step over an
    uprobe. The state of block stepping is not restored. It makes only sense
    together with TF and if that was enabled then the debugger is notified.
    
    Note: this is still not correct. For example, TIF_SINGLESTEP check
    is not right, the application itself can set X86_EFLAGS_TF. And otoh
    we leak TIF_SINGLESTEP (set by enable) if the probed insn is "popf".
    See the next patches, we need the changes in arch/x86/kernel/step.c
    first.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index f3971bbcd1de..cee58624cb30 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -46,6 +46,8 @@ struct arch_uprobe_task {
 #ifdef CONFIG_X86_64
 	unsigned long			saved_scratch_register;
 #endif
+#define UPROBE_CLEAR_TF			(1 << 0)
+	unsigned int			restore_flags;
 };
 
 extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);

commit 7eb9ba5ed312ec6ed9d22259c5da1acb7cf4bd29
Author: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
Date:   Fri Jun 8 15:02:57 2012 +0530

    uprobes: Pass probed vaddr to arch_uprobe_analyze_insn()
    
    On RISC architectures like powerpc, instructions are fixed size.
    Instruction analysis on such platforms is just a matter of
    (insn % 4). Pass the vaddr at which the uprobe is to be inserted so
    that arch_uprobe_analyze_insn() can flag misaligned registration
    requests.
    
    Signed-off-by: Ananth N Mavinakaynahalli <ananth@in.ibm.com>
    Cc: michael@ellerman.id.au
    Cc: antonb@thinktux.localdomain
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: benh@kernel.crashing.org
    Cc: peterz@infradead.org
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Jim Keniston <jkenisto@us.ibm.com>
    Cc: oleg@redhat.com
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20120608093257.GG13409@in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 1e9bed14f7ae..f3971bbcd1de 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -48,7 +48,7 @@ struct arch_uprobe_task {
 #endif
 };
 
-extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm);
+extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);
 extern int  arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);

commit 0326f5a94ddea33fa331b2519f4172f4fb387baa
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Tue Mar 13 23:30:11 2012 +0530

    uprobes/core: Handle breakpoint and singlestep exceptions
    
    Uprobes uses exception notifiers to get to know if a thread hit
    a breakpoint or a singlestep exception.
    
    When a thread hits a uprobe or is singlestepping post a uprobe
    hit, the uprobe exception notifier sets its TIF_UPROBE bit,
    which will then be checked on its return to userspace path
    (do_notify_resume() ->uprobe_notify_resume()), where the
    consumers handlers are run (in task context) based on the
    defined filters.
    
    Uprobe hits are thread specific and hence we need to maintain
    information about if a task hit a uprobe, what uprobe was hit,
    the slot where the original instruction was copied for xol so
    that it can be singlestepped with appropriate fixups.
    
    In some cases, special care is needed for instructions that are
    executed out of line (xol). These are architecture specific
    artefacts, such as handling RIP relative instructions on x86_64.
    
    Since the instruction at which the uprobe was inserted is
    executed out of line, architecture specific fixups are added so
    that the thread continues normal execution in the presence of a
    uprobe.
    
    Postpone the signals until we execute the probed insn.
    post_xol() path does a recalc_sigpending() before return to
    user-mode, this ensures the signal can't be lost.
    
    Uprobes relies on DIE_DEBUG notification to notify if a
    singlestep is complete.
    
    Adds x86 specific uprobe exception notifiers and appropriate
    hooks needed to determine a uprobe hit and subsequent post
    processing.
    
    Add requisite x86 fixups for xol for uprobes. Specific cases
    needing fixups include relative jumps (x86_64), calls, etc.
    
    Where possible, we check and skip singlestepping the
    breakpointed instructions. For now we skip single byte as well
    as few multibyte nop instructions. However this can be extended
    to other instructions too.
    
    Credits to Oleg Nesterov for suggestions/patches related to
    signal, breakpoint, singlestep handling code.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120313180011.29771.89027.sendpatchset@srdronam.in.ibm.com
    [ Performed various cleanliness edits ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 0500391f57d0..1e9bed14f7ae 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -23,6 +23,8 @@
  *	Jim Keniston
  */
 
+#include <linux/notifier.h>
+
 typedef u8 uprobe_opcode_t;
 
 #define MAX_UINSN_BYTES			  16
@@ -39,5 +41,17 @@ struct arch_uprobe {
 #endif
 };
 
-extern int arch_uprobes_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm);
+struct arch_uprobe_task {
+	unsigned long			saved_trap_nr;
+#ifdef CONFIG_X86_64
+	unsigned long			saved_scratch_register;
+#endif
+};
+
+extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm);
+extern int  arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
+extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
+extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 #endif	/* _ASM_UPROBES_H */

commit 5cb4ac3a583d4ee18c8682ab857e093c4a0d0895
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:45 2012 +0530

    uprobes/core: Rename bkpt to swbp
    
    bkpt doesnt seem to be a correct abbrevation for breakpoint.
    Choice was between bp and breakpoint. Since bp can refer to
    things other than breakpoint, use swbp to refer to breakpoints.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092545.5379.91251.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 384f1bebf884..0500391f57d0 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -28,8 +28,8 @@ typedef u8 uprobe_opcode_t;
 #define MAX_UINSN_BYTES			  16
 #define UPROBE_XOL_SLOT_BYTES		 128	/* to keep it cache aligned */
 
-#define UPROBE_BKPT_INSN		0xcc
-#define UPROBE_BKPT_INSN_SIZE		   1
+#define UPROBE_SWBP_INSN		0xcc
+#define UPROBE_SWBP_INSN_SIZE		   1
 
 struct arch_uprobe {
 	u16				fixups;

commit e3343e6a2819ff5d0dfc4bb5c9fb7f9a4d04da73
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:30 2012 +0530

    uprobes/core: Make order of function parameters consistent across functions
    
    If a function takes struct uprobe or struct arch_uprobe, then it
    is passed as the first parameter.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092530.5379.18394.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 5c399e446512..384f1bebf884 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -39,5 +39,5 @@ struct arch_uprobe {
 #endif
 };
 
-extern int arch_uprobes_analyze_insn(struct mm_struct *mm, struct arch_uprobe *arch_uprobe);
+extern int arch_uprobes_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm);
 #endif	/* _ASM_UPROBES_H */

commit 900771a483ef28915a48066d7895d8252315607a
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:14 2012 +0530

    uprobes/core: Make macro names consistent
    
    Rename macros that refer to individual uprobe to start with
    UPROBE_ instead of UPROBES_.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092514.5379.36595.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index f7ce310a429d..5c399e446512 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -26,10 +26,10 @@
 typedef u8 uprobe_opcode_t;
 
 #define MAX_UINSN_BYTES			  16
-#define UPROBES_XOL_SLOT_BYTES		 128	/* to keep it cache aligned */
+#define UPROBE_XOL_SLOT_BYTES		 128	/* to keep it cache aligned */
 
-#define UPROBES_BKPT_INSN		0xcc
-#define UPROBES_BKPT_INSN_SIZE		   1
+#define UPROBE_BKPT_INSN		0xcc
+#define UPROBE_BKPT_INSN_SIZE		   1
 
 struct arch_uprobe {
 	u16				fixups;

commit 3ff54efdfaace9e9b2b7c1959a865be6b91de96c
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Wed Feb 22 14:46:02 2012 +0530

    uprobes/core: Move insn to arch specific structure
    
    Few cleanups suggested by Ingo Molnar.
    
    - Rename struct uprobe_arch_info to struct arch_uprobe.
    - Move insn from struct uprobe to struct arch_uprobe.
    - Make arch specific uprobe functions to accept struct arch_uprobe
      instead of  struct uprobe.
    - Move struct uprobe to kernel/uprobes.c from include/linux/uprobes.h
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Josh Stone <jistone@redhat.com>
    Link: http://lkml.kernel.org/r/20120222091602.15880.40249.sendpatchset@srdronam.in.ibm.com
    [ Made various small improvements ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 072df3902636..f7ce310a429d 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -31,13 +31,13 @@ typedef u8 uprobe_opcode_t;
 #define UPROBES_BKPT_INSN		0xcc
 #define UPROBES_BKPT_INSN_SIZE		   1
 
-struct uprobe_arch_info {
+struct arch_uprobe {
 	u16				fixups;
+	u8				insn[MAX_UINSN_BYTES];
 #ifdef CONFIG_X86_64
 	unsigned long			rip_rela_target_address;
 #endif
 };
 
-struct uprobe;
-extern int arch_uprobes_analyze_insn(struct mm_struct *mm, struct uprobe *uprobe);
+extern int arch_uprobes_analyze_insn(struct mm_struct *mm, struct arch_uprobe *arch_uprobe);
 #endif	/* _ASM_UPROBES_H */

commit 7b2d81d48a2d8e37efb6ce7b4d5ef58822b30d89
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Feb 17 09:27:41 2012 +0100

    uprobes/core: Clean up, refactor and improve the code
    
    Make the uprobes code readable to me:
    
     - improve the Kconfig text so that a mere mortal gets some idea
       what CONFIG_UPROBES=y is really about
    
     - do trivial renames to standardize around the uprobes_*() namespace
    
     - clean up and simplify various code flow details
    
     - separate basic blocks of functionality
    
     - line break artifact and white space related removal
    
     - use standard local varible definition blocks
    
     - use vertical spacing to make things more readable
    
     - remove unnecessary volatile
    
     - restructure comment blocks to make them more uniform and
       more readable in general
    
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Jim Keniston <jkenisto@us.ibm.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Link: http://lkml.kernel.org/n/tip-ewbwhb8o6navvllsauu7k07p@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
index 8208234391ff..072df3902636 100644
--- a/arch/x86/include/asm/uprobes.h
+++ b/arch/x86/include/asm/uprobes.h
@@ -1,7 +1,7 @@
 #ifndef _ASM_UPROBES_H
 #define _ASM_UPROBES_H
 /*
- * Userspace Probes (UProbes) for x86
+ * User-space Probes (UProbes) for x86
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,19 +24,20 @@
  */
 
 typedef u8 uprobe_opcode_t;
-#define MAX_UINSN_BYTES 16
-#define UPROBES_XOL_SLOT_BYTES	128	/* to keep it cache aligned */
 
-#define UPROBES_BKPT_INSN 0xcc
-#define UPROBES_BKPT_INSN_SIZE 1
+#define MAX_UINSN_BYTES			  16
+#define UPROBES_XOL_SLOT_BYTES		 128	/* to keep it cache aligned */
+
+#define UPROBES_BKPT_INSN		0xcc
+#define UPROBES_BKPT_INSN_SIZE		   1
 
 struct uprobe_arch_info {
-	u16			fixups;
+	u16				fixups;
 #ifdef CONFIG_X86_64
-	unsigned long rip_rela_target_address;
+	unsigned long			rip_rela_target_address;
 #endif
 };
 
 struct uprobe;
-extern int analyze_insn(struct mm_struct *mm, struct uprobe *uprobe);
+extern int arch_uprobes_analyze_insn(struct mm_struct *mm, struct uprobe *uprobe);
 #endif	/* _ASM_UPROBES_H */

commit 2b144498350860b6ee9dc57ff27a93ad488de5dc
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Thu Feb 9 14:56:42 2012 +0530

    uprobes, mm, x86: Add the ability to install and remove uprobes breakpoints
    
    Add uprobes support to the core kernel, with x86 support.
    
    This commit adds the kernel facilities, the actual uprobes
    user-space ABI and perf probe support comes in later commits.
    
    General design:
    
    Uprobes are maintained in an rb-tree indexed by inode and offset
    (the offset here is from the start of the mapping). For a unique
    (inode, offset) tuple, there can be at most one uprobe in the
    rb-tree.
    
    Since the (inode, offset) tuple identifies a unique uprobe, more
    than one user may be interested in the same uprobe. This provides
    the ability to connect multiple 'consumers' to the same uprobe.
    
    Each consumer defines a handler and a filter (optional). The
    'handler' is run every time the uprobe is hit, if it matches the
    'filter' criteria.
    
    The first consumer of a uprobe causes the breakpoint to be
    inserted at the specified address and subsequent consumers are
    appended to this list.  On subsequent probes, the consumer gets
    appended to the existing list of consumers. The breakpoint is
    removed when the last consumer unregisters. For all other
    unregisterations, the consumer is removed from the list of
    consumers.
    
    Given a inode, we get a list of the mms that have mapped the
    inode. Do the actual registration if mm maps the page where a
    probe needs to be inserted/removed.
    
    We use a temporary list to walk through the vmas that map the
    inode.
    
    - The number of maps that map the inode, is not known before we
      walk the rmap and keeps changing.
    - extending vm_area_struct wasn't recommended, it's a
      size-critical data structure.
    - There can be more than one maps of the inode in the same mm.
    
    We add callbacks to the mmap methods to keep an eye on text vmas
    that are of interest to uprobes.  When a vma of interest is mapped,
    we insert the breakpoint at the right address.
    
    Uprobe works by replacing the instruction at the address defined
    by (inode, offset) with the arch specific breakpoint
    instruction. We save a copy of the original instruction at the
    uprobed address.
    
    This is needed for:
    
     a. executing the instruction out-of-line (xol).
     b. instruction analysis for any subsequent fixups.
     c. restoring the instruction back when the uprobe is unregistered.
    
    We insert or delete a breakpoint instruction, and this
    breakpoint instruction is assumed to be the smallest instruction
    available on the platform. For fixed size instruction platforms
    this is trivially true, for variable size instruction platforms
    the breakpoint instruction is typically the smallest (often a
    single byte).
    
    Writing the instruction is done by COWing the page and changing
    the instruction during the copy, this even though most platforms
    allow atomic writes of the breakpoint instruction. This also
    mirrors the behaviour of a ptrace() memory write to a PRIVATE
    file map.
    
    The core worker is derived from KSM's replace_page() logic.
    
    In essence, similar to KSM:
    
     a. allocate a new page and copy over contents of the page that
        has the uprobed vaddr
     b. modify the copy and insert the breakpoint at the required
        address
     c. switch the original page with the copy containing the
        breakpoint
     d. flush page tables.
    
    replace_page() is being replicated here because of some minor
    changes in the type of pages and also because Hugh Dickins had
    plans to improve replace_page() for KSM specific work.
    
    Instruction analysis on x86 is based on instruction decoder and
    determines if an instruction can be probed and determines the
    necessary fixups after singlestep.  Instruction analysis is done
    at probe insertion time so that we avoid having to repeat the
    same analysis every time a probe is hit.
    
    A lot of code here is due to the improvement/suggestions/inputs
    from Peter Zijlstra.
    
    Changelog:
    
    (v10):
     - Add code to clear REX.B prefix as suggested by Denys Vlasenko
       and Masami Hiramatsu.
    
    (v9):
     - Use insn_offset_modrm as suggested by Masami Hiramatsu.
    
    (v7):
    
     Handle comments from Peter Zijlstra:
    
     - Dont take reference to inode. (expect inode to uprobe_register to be sane).
     - Use PTR_ERR to set the return value.
     - No need to take reference to inode.
     - use PTR_ERR to return error value.
     - register and uprobe_unregister share code.
    
    (v5):
    
     - Modified del_consumer as per comments from Peter.
     - Drop reference to inode before dropping reference to uprobe.
     - Use i_size_read(inode) instead of inode->i_size.
     - Ensure uprobe->consumers is NULL, before __uprobe_unregister() is called.
     - Includes errno.h as recommended by Stephen Rothwell to fix a build issue
       on sparc defconfig
     - Remove restrictions while unregistering.
     - Earlier code leaked inode references under some conditions while
       registering/unregistering.
     - Continue the vma-rmap walk even if the intermediate vma doesnt
       meet the requirements.
     - Validate the vma found by find_vma before inserting/removing the
       breakpoint
     - Call del_consumer under mutex_lock.
     - Use hash locks.
     - Handle mremap.
     - Introduce find_least_offset_node() instead of close match logic in
       find_uprobe
     - Uprobes no more depends on MM_OWNER; No reference to task_structs
       while inserting/removing a probe.
     - Uses read_mapping_page instead of grab_cache_page so that the pages
       have valid content.
     - pass NULL to get_user_pages for the task parameter.
     - call SetPageUptodate on the new page allocated in write_opcode.
     - fix leaking a reference to the new page under certain conditions.
     - Include Instruction Decoder if Uprobes gets defined.
     - Remove const attributes for instruction prefix arrays.
     - Uses mm_context to know if the application is 32 bit.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Also-written-by: Jim Keniston <jkenisto@us.ibm.com>
    Reviewed-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Roland McGrath <roland@hack.frob.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Denys Vlasenko <vda.linux@googlemail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linux-mm <linux-mm@kvack.org>
    Link: http://lkml.kernel.org/r/20120209092642.GE16600@linux.vnet.ibm.com
    [ Made various small edits to the commit log ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/uprobes.h b/arch/x86/include/asm/uprobes.h
new file mode 100644
index 000000000000..8208234391ff
--- /dev/null
+++ b/arch/x86/include/asm/uprobes.h
@@ -0,0 +1,42 @@
+#ifndef _ASM_UPROBES_H
+#define _ASM_UPROBES_H
+/*
+ * Userspace Probes (UProbes) for x86
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2008-2011
+ * Authors:
+ *	Srikar Dronamraju
+ *	Jim Keniston
+ */
+
+typedef u8 uprobe_opcode_t;
+#define MAX_UINSN_BYTES 16
+#define UPROBES_XOL_SLOT_BYTES	128	/* to keep it cache aligned */
+
+#define UPROBES_BKPT_INSN 0xcc
+#define UPROBES_BKPT_INSN_SIZE 1
+
+struct uprobe_arch_info {
+	u16			fixups;
+#ifdef CONFIG_X86_64
+	unsigned long rip_rela_target_address;
+#endif
+};
+
+struct uprobe;
+extern int analyze_insn(struct mm_struct *mm, struct uprobe *uprobe);
+#endif	/* _ASM_UPROBES_H */
