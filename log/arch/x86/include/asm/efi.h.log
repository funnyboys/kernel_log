commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 129e62146cbc..e7d2ccfdd507 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -3,13 +3,13 @@
 #define _ASM_X86_EFI_H
 
 #include <asm/fpu/api.h>
-#include <linux/pgtable.h>
 #include <asm/processor-flags.h>
 #include <asm/tlb.h>
 #include <asm/nospec-branch.h>
 #include <asm/mmu_context.h>
 #include <linux/build_bug.h>
 #include <linux/kernel.h>
+#include <linux/pgtable.h>
 
 extern unsigned long efi_fw_vendor, efi_config_table;
 

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 89dcc7aa7e2c..129e62146cbc 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -3,7 +3,7 @@
 #define _ASM_X86_EFI_H
 
 #include <asm/fpu/api.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/processor-flags.h>
 #include <asm/tlb.h>
 #include <asm/nospec-branch.h>

commit 9b47c5275614a16fd64359fab73fe6c736bf57a0
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:07:10 2020 -0400

    efi/libstub: Add definitions for console input and events
    
    Add the required typedefs etc for using con_in's simple text input
    protocol, and for using the boottime event services.
    
    Also add the prototype for the "stall" boot service.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-19-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 6b9ab0d8b2a7..89dcc7aa7e2c 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -9,6 +9,7 @@
 #include <asm/nospec-branch.h>
 #include <asm/mmu_context.h>
 #include <linux/build_bug.h>
+#include <linux/kernel.h>
 
 extern unsigned long efi_fw_vendor, efi_config_table;
 
@@ -293,6 +294,15 @@ static inline u32 efi64_convert_status(efi_status_t status)
 #define __efi64_argmap_allocate_pool(type, size, buffer)		\
 	((type), (size), efi64_zero_upper(buffer))
 
+#define __efi64_argmap_create_event(type, tpl, f, c, event)		\
+	((type), (tpl), (f), (c), efi64_zero_upper(event))
+
+#define __efi64_argmap_set_timer(event, type, time)			\
+	((event), (type), lower_32_bits(time), upper_32_bits(time))
+
+#define __efi64_argmap_wait_for_event(num, event, index)		\
+	((num), (event), efi64_zero_upper(index))
+
 #define __efi64_argmap_handle_protocol(handle, protocol, interface)	\
 	((handle), (protocol), efi64_zero_upper(interface))
 

commit de8c55208c3865d0532466097b0244fbea1d9089
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 4 11:02:48 2020 -0400

    efi/libstub: Fix mixed mode boot issue after macro refactor
    
    Commit
    
      22090f84bc3f ("efi/libstub: unify EFI call wrappers for non-x86")
    
    refactored the macros that are used to provide wrappers for mixed-mode
    calls on x86, allowing us to boot a 64-bit kernel on 32-bit firmware.
    
    Unfortunately, this broke mixed mode boot due to the fact that
    efi_is_native() is not a macro on x86.
    
    All of these macros should go together, so rather than testing each one
    to see if it is defined, condition the generic macro definitions on a
    new ARCH_HAS_EFISTUB_WRAPPERS, and remove the wrapper definitions on x86
    as well if CONFIG_EFI_MIXED is not enabled.
    
    Fixes: 22090f84bc3f ("efi/libstub: unify EFI call wrappers for non-x86")
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200504150248.62482-1-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index cd0c3fbf6156..6b9ab0d8b2a7 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -225,13 +225,15 @@ efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
 
 /* arch specific definitions used by the stub code */
 
-extern const bool efi_is64;
+#ifdef CONFIG_EFI_MIXED
+
+#define ARCH_HAS_EFISTUB_WRAPPERS
 
 static inline bool efi_is_64bit(void)
 {
-	if (IS_ENABLED(CONFIG_EFI_MIXED))
-		return efi_is64;
-	return IS_ENABLED(CONFIG_X86_64);
+	extern const bool efi_is64;
+
+	return efi_is64;
 }
 
 static inline bool efi_is_native(void)
@@ -356,6 +358,15 @@ static inline u32 efi64_convert_status(efi_status_t status)
 						   runtime),		\
 				    func, __VA_ARGS__))
 
+#else /* CONFIG_EFI_MIXED */
+
+static inline bool efi_is_64bit(void)
+{
+	return IS_ENABLED(CONFIG_X86_64);
+}
+
+#endif /* CONFIG_EFI_MIXED */
+
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);
 

commit 0a75561489f534cf2e8f6883e0cf8cdf51c534c5
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Apr 16 21:15:23 2020 +0200

    efi/libstub/x86: Avoid getter function for efi_is64
    
    We no longer need to take special care when using global variables
    in the EFI stub, so switch to a simple symbol reference for efi_is64.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 78e839925a81..cd0c3fbf6156 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -225,14 +225,19 @@ efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
 
 /* arch specific definitions used by the stub code */
 
-__attribute_const__ bool efi_is_64bit(void);
+extern const bool efi_is64;
+
+static inline bool efi_is_64bit(void)
+{
+	if (IS_ENABLED(CONFIG_EFI_MIXED))
+		return efi_is64;
+	return IS_ENABLED(CONFIG_X86_64);
+}
 
 static inline bool efi_is_native(void)
 {
 	if (!IS_ENABLED(CONFIG_X86_64))
 		return true;
-	if (!IS_ENABLED(CONFIG_EFI_MIXED))
-		return true;
 	return efi_is_64bit();
 }
 

commit ccc27ae77494252965aedca68588e7457829cfad
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Apr 16 18:38:06 2020 +0200

    efi/libstub: Drop __pure getter for efi_system_table
    
    The practice of using __pure getter functions to access global
    variables in the EFI stub dates back to the time when we had to
    carefully prevent GOT entries from being emitted, because we
    could not rely on the toolchain to do this for us.
    
    Today, we use the hidden visibility pragma for all EFI stub source
    files, which now all live in the same subdirectory, and we apply a
    sanity check on the objects, so we can get rid of these getter
    functions and simply refer to global data objects directly.
    
    Start with efi_system_table(), and convert it into a global variable.
    While at it, make it a pointer-to-const, because we can.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index f59cba117dcb..78e839925a81 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -339,15 +339,17 @@ static inline u32 efi64_convert_status(efi_status_t status)
 
 #define efi_bs_call(func, ...)						\
 	(efi_is_native()						\
-		? efi_system_table()->boottime->func(__VA_ARGS__)	\
-		: __efi64_thunk_map(efi_table_attr(efi_system_table(),	\
-				boottime), func, __VA_ARGS__))
+		? efi_system_table->boottime->func(__VA_ARGS__)		\
+		: __efi64_thunk_map(efi_table_attr(efi_system_table,	\
+						   boottime),		\
+				    func, __VA_ARGS__))
 
 #define efi_rt_call(func, ...)						\
 	(efi_is_native()						\
-		? efi_system_table()->runtime->func(__VA_ARGS__)	\
-		: __efi64_thunk_map(efi_table_attr(efi_system_table(),	\
-				runtime), func, __VA_ARGS__))
+		? efi_system_table->runtime->func(__VA_ARGS__)		\
+		: __efi64_thunk_map(efi_table_attr(efi_system_table,	\
+						   runtime),		\
+				    func, __VA_ARGS__))
 
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);

commit b4b89a02724245c4f4eda9dbfb7895ddf122ca7f
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Mar 19 22:00:24 2020 -0400

    efi/gop: Add prototypes for query_mode and set_mode
    
    Add prototypes and argmap for the Graphics Output Protocol's QueryMode
    and SetMode functions.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200320020028.1936003-11-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 8391c115c0ec..f59cba117dcb 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -307,6 +307,10 @@ static inline u32 efi64_convert_status(efi_status_t status)
 #define __efi64_argmap_load_file(protocol, path, policy, bufsize, buf)	\
 	((protocol), (path), (policy), efi64_zero_upper(bufsize), (buf))
 
+/* Graphics Output Protocol */
+#define __efi64_argmap_query_mode(gop, mode, size, info)		\
+	((gop), (mode), efi64_zero_upper(size), efi64_zero_upper(info))
+
 /*
  * The macros below handle the plumbing for the argument mapping. To add a
  * mapping for a specific EFI method, simply define a macro

commit a088b858f16af85e3db359b6c6aaa92dd3bc0921
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Apr 10 09:43:20 2020 +0200

    efi/x86: Revert struct layout change to fix kexec boot regression
    
    Commit
    
      0a67361dcdaa29 ("efi/x86: Remove runtime table address from kexec EFI setup data")
    
    removed the code that retrieves the non-remapped UEFI runtime services
    pointer from the data structure provided by kexec, as it was never really
    needed on the kexec boot path: mapping the runtime services table at its
    non-remapped address is only needed when calling SetVirtualAddressMap(),
    which never happens during a kexec boot in the first place.
    
    However, dropping the 'runtime' member from struct efi_setup_data was a
    mistake. That struct is shared ABI between the kernel and the kexec tooling
    for x86, and so we cannot simply change its layout. So let's put back the
    removed field, but call it 'unused' to reflect the fact that we never look
    at its contents. While at it, add a comment to remind our future selves
    that the layout is external ABI.
    
    Fixes: 0a67361dcdaa29 ("efi/x86: Remove runtime table address from kexec EFI setup data")
    Reported-by: Theodore Ts'o <tytso@mit.edu>
    Tested-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index cdcf48d52a12..8391c115c0ec 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -178,8 +178,10 @@ extern void efi_free_boot_services(void);
 extern pgd_t * __init efi_uv1_memmap_phys_prolog(void);
 extern void __init efi_uv1_memmap_phys_epilog(pgd_t *save_pgd);
 
+/* kexec external ABI */
 struct efi_setup_data {
 	u64 fw_vendor;
+	u64 __unused;
 	u64 tables;
 	u64 smbios;
 	u64 reserved[8];

commit 3b8f44fc0810d51b58837cf7fdba3f72f8cffcdc
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Feb 16 00:03:25 2020 +0100

    efi/libstub/x86: Use Exit() boot service to exit the stub on errors
    
    Currently, we either return with an error [from efi_pe_entry()] or
    enter a deadloop [in efi_main()] if any fatal errors occur during
    execution of the EFI stub. Let's switch to calling the Exit() EFI boot
    service instead in both cases, so that we
    a) can get rid of the deadloop, and simply return to the boot manager
       if any errors occur during execution of the stub, including during
       the call to ExitBootServices(),
    b) can also return cleanly from efi_pe_entry() or efi_main() in mixed
       mode, once we introduce support for LoadImage/StartImage based mixed
       mode in the next patch.
    
    Note that on systems running downstream GRUBs [which do not use LoadImage
    or StartImage to boot the kernel, and instead, pass their own image
    handle as the loaded image handle], calling Exit() will exit from GRUB
    rather than from the kernel, but this is a tolerable side effect.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0de57151c732..cdcf48d52a12 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -270,6 +270,11 @@ static inline void *efi64_zero_upper(void *p)
 	return p;
 }
 
+static inline u32 efi64_convert_status(efi_status_t status)
+{
+	return (u32)(status | (u64)status >> 32);
+}
+
 #define __efi64_argmap_free_pages(addr, size)				\
 	((addr), 0, (size))
 
@@ -288,6 +293,9 @@ static inline void *efi64_zero_upper(void *p)
 #define __efi64_argmap_locate_device_path(protocol, path, handle)	\
 	((protocol), (path), efi64_zero_upper(handle))
 
+#define __efi64_argmap_exit(handle, status, size, data)			\
+	((handle), efi64_convert_status(status), (size), (data))
+
 /* PCI I/O */
 #define __efi64_argmap_get_location(protocol, seg, bus, dev, func)	\
 	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\

commit 59f2a619a2db86111e8bb30f349aebff6eb75baa
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 09:44:43 2020 +0100

    efi: Add 'runtime' pointer to struct efi
    
    Instead of going through the EFI system table each time, just copy the
    runtime services table pointer into struct efi directly. This is the
    last use of the system table pointer in struct efi, allowing us to
    drop it in a future patch, along with a fair amount of quirky handling
    of the translated address.
    
    Note that usually, the runtime services pointer changes value during
    the call to SetVirtualAddressMap(), so grab the updated value as soon
    as that call returns. (Mixed mode uses a 1:1 mapping, and kexec boot
    enters with the updated address in the system table, so in those cases,
    we don't need to do anything here)
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 78fc28da2e29..0de57151c732 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -218,7 +218,8 @@ extern void efi_thunk_runtime_setup(void);
 efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
 					 unsigned long descriptor_size,
 					 u32 descriptor_version,
-					 efi_memory_desc_t *virtual_map);
+					 efi_memory_desc_t *virtual_map,
+					 unsigned long systab_phys);
 
 /* arch specific definitions used by the stub code */
 

commit 9cd437ac0ef4f324a92e2579784b03bb487ae7fb
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:23:21 2020 +0100

    efi/x86: Make fw_vendor, config_table and runtime sysfs nodes x86 specific
    
    There is some code that exposes physical addresses of certain parts of
    the EFI firmware implementation via sysfs nodes. These nodes are only
    used on x86, and are of dubious value to begin with, so let's move
    their handling into the x86 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index ee867f01b2f6..78fc28da2e29 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -10,6 +10,8 @@
 #include <asm/mmu_context.h>
 #include <linux/build_bug.h>
 
+extern unsigned long efi_fw_vendor, efi_config_table;
+
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
  * with preserved alignment on virtual addresses starting from -4G down

commit 0a67361dcdaa29dca1e77ebac919c62e93a8b3bc
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 16:15:00 2020 +0100

    efi/x86: Remove runtime table address from kexec EFI setup data
    
    Since commit 33b85447fa61946b ("efi/x86: Drop two near identical versions
    of efi_runtime_init()"), we no longer map the EFI runtime services table
    before calling SetVirtualAddressMap(), which means we don't need the 1:1
    mapped physical address of this table, and so there is no point in passing
    the address via EFI setup data on kexec boot.
    
    Note that the kexec tools will still look for this address in sysfs, so
    we still need to provide it.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index fcb21e3d13c5..ee867f01b2f6 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -178,7 +178,6 @@ extern void __init efi_uv1_memmap_phys_epilog(pgd_t *save_pgd);
 
 struct efi_setup_data {
 	u64 fw_vendor;
-	u64 runtime;
 	u64 tables;
 	u64 smbios;
 	u64 reserved[8];

commit 2931d526d5674940d916a4b513a681ee3562e574
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:48 2020 +0100

    efi/libstub: Make the LoadFile EFI protocol accessible
    
    Add the protocol definitions, GUIDs and mixed mode glue so that
    the EFI loadfile protocol can be used from the stub. This will
    be used in a future patch to load the initrd.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 9ced980b123b..fcb21e3d13c5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -291,6 +291,10 @@ static inline void *efi64_zero_upper(void *p)
 	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\
 	 efi64_zero_upper(dev), efi64_zero_upper(func))
 
+/* LoadFile */
+#define __efi64_argmap_load_file(protocol, path, policy, bufsize, buf)	\
+	((protocol), (path), (policy), efi64_zero_upper(bufsize), (buf))
+
 /*
  * The macros below handle the plumbing for the argument mapping. To add a
  * mapping for a specific EFI method, simply define a macro

commit abd268685a21cb5d0c991bb21a88ea0c1d2e15d8
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:47 2020 +0100

    efi/libstub: Expose LocateDevicePath boot service
    
    We will be adding support for loading the initrd from a GUIDed
    device path in a subsequent patch, so update the prototype of
    the LocateDevicePath() boot service to make it callable from
    our code.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 85f79accd3f8..9ced980b123b 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -283,6 +283,9 @@ static inline void *efi64_zero_upper(void *p)
 #define __efi64_argmap_locate_protocol(protocol, reg, interface)	\
 	((protocol), (reg), efi64_zero_upper(interface))
 
+#define __efi64_argmap_locate_device_path(protocol, path, handle)	\
+	((protocol), (path), efi64_zero_upper(handle))
+
 /* PCI I/O */
 #define __efi64_argmap_get_location(protocol, seg, bus, dev, func)	\
 	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\

commit 1e45bf7372c48c78e1f7e538fd3e612946f6ad20
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:40 2020 +0100

    efi/libstub/x86: Permit cmdline data to be allocated above 4 GB
    
    We now support cmdline data that is located in memory that is not
    32-bit addressable, so relax the allocation limit on systems where
    this feature is enabled.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 86169a24b0d8..85f79accd3f8 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -34,8 +34,6 @@ static inline bool efi_have_uv1_memmap(void)
 #define EFI32_LOADER_SIGNATURE	"EL32"
 #define EFI64_LOADER_SIGNATURE	"EL64"
 
-#define MAX_CMDLINE_ADDRESS	UINT_MAX
-
 #define ARCH_EFI_IRQ_FLAGS_MASK	X86_EFLAGS_IF
 
 /*

commit 1f299fad1e312947c974c6a1d8a3a484f27a6111
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 13 18:22:39 2020 +0100

    efi/x86: Limit EFI old memory map to SGI UV machines
    
    We carry a quirk in the x86 EFI code to switch back to an older
    method of mapping the EFI runtime services memory regions, because
    it was deemed risky at the time to implement a new method without
    providing a fallback to the old method in case problems arose.
    
    Such problems did arise, but they appear to be limited to SGI UV1
    machines, and so these are the only ones for which the fallback gets
    enabled automatically (via a DMI quirk). The fallback can be enabled
    manually as well, by passing efi=old_map, but there is very little
    evidence that suggests that this is something that is being relied
    upon in the field.
    
    Given that UV1 support is not enabled by default by the distros
    (Ubuntu, Fedora), there is no point in carrying this fallback code
    all the time if there are no other users. So let's move it into the
    UV support code, and document that efi=old_map now requires this
    support code to be enabled.
    
    Note that efi=old_map has been used in the past on other SGI UV
    machines to work around kernel regressions in production, so we
    keep the option to enable it by hand, but only if the kernel was
    built with UV support.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-8-ardb@kernel.org

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0a58468a7203..86169a24b0d8 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -20,13 +20,16 @@
  * This is the main reason why we're doing stable VA mappings for RT
  * services.
  *
- * This flag is used in conjunction with a chicken bit called
- * "efi=old_map" which can be used as a fallback to the old runtime
- * services mapping method in case there's some b0rkage with a
- * particular EFI implementation (haha, it is hard to hold up the
- * sarcasm here...).
+ * SGI UV1 machines are known to be incompatible with this scheme, so we
+ * provide an opt-out for these machines via a DMI quirk that sets the
+ * attribute below.
  */
-#define EFI_OLD_MEMMAP		EFI_ARCH_1
+#define EFI_UV1_MEMMAP         EFI_ARCH_1
+
+static inline bool efi_have_uv1_memmap(void)
+{
+	return IS_ENABLED(CONFIG_X86_UV) && efi_enabled(EFI_UV1_MEMMAP);
+}
 
 #define EFI32_LOADER_SIGNATURE	"EL32"
 #define EFI64_LOADER_SIGNATURE	"EL64"
@@ -119,7 +122,7 @@ struct efi_scratch {
 	kernel_fpu_begin();						\
 	firmware_restrict_branch_speculation_start();			\
 									\
-	if (!efi_enabled(EFI_OLD_MEMMAP))				\
+	if (!efi_have_uv1_memmap())					\
 		efi_switch_mm(&efi_mm);					\
 })
 
@@ -128,7 +131,7 @@ struct efi_scratch {
 
 #define arch_efi_call_virt_teardown()					\
 ({									\
-	if (!efi_enabled(EFI_OLD_MEMMAP))				\
+	if (!efi_have_uv1_memmap())					\
 		efi_switch_mm(efi_scratch.prev_mm);			\
 									\
 	firmware_restrict_branch_speculation_end();			\
@@ -172,6 +175,8 @@ extern void efi_delete_dummy_variable(void);
 extern void efi_switch_mm(struct mm_struct *mm);
 extern void efi_recover_from_page_fault(unsigned long phys_addr);
 extern void efi_free_boot_services(void);
+extern pgd_t * __init efi_uv1_memmap_phys_prolog(void);
+extern void __init efi_uv1_memmap_phys_epilog(pgd_t *save_pgd);
 
 struct efi_setup_data {
 	u64 fw_vendor;
@@ -203,10 +208,7 @@ static inline bool efi_runtime_supported(void)
 	if (IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT))
 		return true;
 
-	if (IS_ENABLED(CONFIG_EFI_MIXED) && !efi_enabled(EFI_OLD_MEMMAP))
-		return true;
-
-	return false;
+	return IS_ENABLED(CONFIG_EFI_MIXED);
 }
 
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);

commit 796eb8d26a57f917bf22d781666aeab491f5c4f1
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 13 18:22:33 2020 +0100

    efi/libstub/x86: Use const attribute for efi_is_64bit()
    
    Reshuffle the x86 stub code a bit so that we can tag the efi_is_64bit()
    function with the 'const' attribute, which permits the compiler to
    optimize away any redundant calls. Since we have two different entry
    points for 32 and 64 bit firmware in the startup code, this also
    simplifies the C code since we'll enter it with the efi_is64 variable
    already set.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-2-ardb@kernel.org

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 383f7a0fc170..0a58468a7203 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -221,7 +221,7 @@ efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
 
 /* arch specific definitions used by the stub code */
 
-__pure bool efi_is_64bit(void);
+__attribute_const__ bool efi_is_64bit(void);
 
 static inline bool efi_is_native(void)
 {

commit 4444f8541dad16fefd9b8807ad1451e806ef1d94
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Fri Jan 3 12:39:50 2020 +0100

    efi: Allow disabling PCI busmastering on bridges during boot
    
    Add an option to disable the busmaster bit in the control register on
    all PCI bridges before calling ExitBootServices() and passing control
    to the runtime kernel. System firmware may configure the IOMMU to prevent
    malicious PCI devices from being able to attack the OS via DMA. However,
    since firmware can't guarantee that the OS is IOMMU-aware, it will tear
    down IOMMU configuration when ExitBootServices() is called. This leaves
    a window between where a hostile device could still cause damage before
    Linux configures the IOMMU again.
    
    If CONFIG_EFI_DISABLE_PCI_DMA is enabled or "efi=disable_early_pci_dma"
    is passed on the command line, the EFI stub will clear the busmaster bit
    on all PCI bridges before ExitBootServices() is called. This will
    prevent any malicious PCI devices from being able to perform DMA until
    the kernel reenables busmastering after configuring the IOMMU.
    
    This option may cause failures with some poorly behaved hardware and
    should not be enabled without testing. The kernel commandline options
    "efi=disable_early_pci_dma" or "efi=no_disable_early_pci_dma" may be
    used to override the default. Note that PCI devices downstream from PCI
    bridges are disconnected from their drivers first, using the UEFI
    driver model API, so that DMA can be disabled safely at the bridge
    level.
    
    [ardb: disconnect PCI I/O handles first, as suggested by Arvind]
    
    Co-developed-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <matthewgarrett@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-18-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 166f0386719e..383f7a0fc170 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -283,6 +283,11 @@ static inline void *efi64_zero_upper(void *p)
 #define __efi64_argmap_locate_protocol(protocol, reg, interface)	\
 	((protocol), (reg), efi64_zero_upper(interface))
 
+/* PCI I/O */
+#define __efi64_argmap_get_location(protocol, seg, bus, dev, func)	\
+	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\
+	 efi64_zero_upper(dev), efi64_zero_upper(func))
+
 /*
  * The macros below handle the plumbing for the argument mapping. To add a
  * mapping for a specific EFI method, simply define a macro

commit ea7d87f98fa9675076fb5ad208d889b217e83889
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Fri Jan 3 12:39:49 2020 +0100

    efi/x86: Allow translating 64-bit arguments for mixed mode calls
    
    Introduce the ability to define macros to perform argument translation
    for the calls that need it, and define them for the boot services that
    we currently use.
    
    When calling 32-bit firmware methods in mixed mode, all output
    parameters that are 32-bit according to the firmware, but 64-bit in the
    kernel (ie OUT UINTN * or OUT VOID **) must be initialized in the
    kernel, or the upper 32 bits may contain garbage. Define macros that
    zero out the upper 32 bits of the output before invoking the firmware
    method.
    
    When a 32-bit EFI call takes 64-bit arguments, the mixed-mode call must
    push the two 32-bit halves as separate arguments onto the stack. This
    can be achieved by splitting the argument into its two halves when
    calling the assembler thunk. Define a macro to do this for the
    free_pages boot service.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-17-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index cfc450085584..166f0386719e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -243,22 +243,83 @@ static inline bool efi_is_native(void)
 		: (__typeof__(inst->attr))				\
 			efi_mixed_mode_cast(inst->mixed_mode.attr))
 
+/*
+ * The following macros allow translating arguments if necessary from native to
+ * mixed mode. The use case for this is to initialize the upper 32 bits of
+ * output parameters, and where the 32-bit method requires a 64-bit argument,
+ * which must be split up into two arguments to be thunked properly.
+ *
+ * As examples, the AllocatePool boot service returns the address of the
+ * allocation, but it will not set the high 32 bits of the address. To ensure
+ * that the full 64-bit address is initialized, we zero-init the address before
+ * calling the thunk.
+ *
+ * The FreePages boot service takes a 64-bit physical address even in 32-bit
+ * mode. For the thunk to work correctly, a native 64-bit call of
+ * 	free_pages(addr, size)
+ * must be translated to
+ * 	efi64_thunk(free_pages, addr & U32_MAX, addr >> 32, size)
+ * so that the two 32-bit halves of addr get pushed onto the stack separately.
+ */
+
+static inline void *efi64_zero_upper(void *p)
+{
+	((u32 *)p)[1] = 0;
+	return p;
+}
+
+#define __efi64_argmap_free_pages(addr, size)				\
+	((addr), 0, (size))
+
+#define __efi64_argmap_get_memory_map(mm_size, mm, key, size, ver)	\
+	((mm_size), (mm), efi64_zero_upper(key), efi64_zero_upper(size), (ver))
+
+#define __efi64_argmap_allocate_pool(type, size, buffer)		\
+	((type), (size), efi64_zero_upper(buffer))
+
+#define __efi64_argmap_handle_protocol(handle, protocol, interface)	\
+	((handle), (protocol), efi64_zero_upper(interface))
+
+#define __efi64_argmap_locate_protocol(protocol, reg, interface)	\
+	((protocol), (reg), efi64_zero_upper(interface))
+
+/*
+ * The macros below handle the plumbing for the argument mapping. To add a
+ * mapping for a specific EFI method, simply define a macro
+ * __efi64_argmap_<method name>, following the examples above.
+ */
+
+#define __efi64_thunk_map(inst, func, ...)				\
+	efi64_thunk(inst->mixed_mode.func,				\
+		__efi64_argmap(__efi64_argmap_ ## func(__VA_ARGS__),	\
+			       (__VA_ARGS__)))
+
+#define __efi64_argmap(mapped, args)					\
+	__PASTE(__efi64_argmap__, __efi_nargs(__efi_eat mapped))(mapped, args)
+#define __efi64_argmap__0(mapped, args) __efi_eval mapped
+#define __efi64_argmap__1(mapped, args) __efi_eval args
+
+#define __efi_eat(...)
+#define __efi_eval(...) __VA_ARGS__
+
+/* The three macros below handle dispatching via the thunk if needed */
+
 #define efi_call_proto(inst, func, ...)					\
 	(efi_is_native()						\
 		? inst->func(inst, ##__VA_ARGS__)			\
-		: efi64_thunk(inst->mixed_mode.func, inst, ##__VA_ARGS__))
+		: __efi64_thunk_map(inst, func, inst, ##__VA_ARGS__))
 
 #define efi_bs_call(func, ...)						\
 	(efi_is_native()						\
 		? efi_system_table()->boottime->func(__VA_ARGS__)	\
-		: efi64_thunk(efi_table_attr(efi_system_table(),	\
-				boottime)->mixed_mode.func, __VA_ARGS__))
+		: __efi64_thunk_map(efi_table_attr(efi_system_table(),	\
+				boottime), func, __VA_ARGS__))
 
 #define efi_rt_call(func, ...)						\
 	(efi_is_native()						\
 		? efi_system_table()->runtime->func(__VA_ARGS__)	\
-		: efi64_thunk(efi_table_attr(efi_system_table(),	\
-				runtime)->mixed_mode.func, __VA_ARGS__))
+		: __efi64_thunk_map(efi_table_attr(efi_system_table(),	\
+				runtime), func, __VA_ARGS__))
 
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);

commit 14b864f4b5c402fe1ca394042beeea6fdf54f8f5
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Fri Jan 3 12:39:48 2020 +0100

    efi/x86: Check number of arguments to variadic functions
    
    On x86 we need to thunk through assembler stubs to call the EFI services
    for mixed mode, and for runtime services in 64-bit mode. The assembler
    stubs have limits on how many arguments it handles. Introduce a few
    macros to check that we do not try to pass too many arguments to the
    stubs.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-16-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index e7e9c6e057f9..cfc450085584 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -8,6 +8,7 @@
 #include <asm/tlb.h>
 #include <asm/nospec-branch.h>
 #include <asm/mmu_context.h>
+#include <linux/build_bug.h>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
@@ -34,6 +35,45 @@
 
 #define ARCH_EFI_IRQ_FLAGS_MASK	X86_EFLAGS_IF
 
+/*
+ * The EFI services are called through variadic functions in many cases. These
+ * functions are implemented in assembler and support only a fixed number of
+ * arguments. The macros below allows us to check at build time that we don't
+ * try to call them with too many arguments.
+ *
+ * __efi_nargs() will return the number of arguments if it is 7 or less, and
+ * cause a BUILD_BUG otherwise. The limitations of the C preprocessor make it
+ * impossible to calculate the exact number of arguments beyond some
+ * pre-defined limit. The maximum number of arguments currently supported by
+ * any of the thunks is 7, so this is good enough for now and can be extended
+ * in the obvious way if we ever need more.
+ */
+
+#define __efi_nargs(...) __efi_nargs_(__VA_ARGS__)
+#define __efi_nargs_(...) __efi_nargs__(0, ##__VA_ARGS__,	\
+	__efi_arg_sentinel(7), __efi_arg_sentinel(6),		\
+	__efi_arg_sentinel(5), __efi_arg_sentinel(4),		\
+	__efi_arg_sentinel(3), __efi_arg_sentinel(2),		\
+	__efi_arg_sentinel(1), __efi_arg_sentinel(0))
+#define __efi_nargs__(_0, _1, _2, _3, _4, _5, _6, _7, n, ...)	\
+	__take_second_arg(n,					\
+		({ BUILD_BUG_ON_MSG(1, "__efi_nargs limit exceeded"); 8; }))
+#define __efi_arg_sentinel(n) , n
+
+/*
+ * __efi_nargs_check(f, n, ...) will cause a BUILD_BUG if the ellipsis
+ * represents more than n arguments.
+ */
+
+#define __efi_nargs_check(f, n, ...)					\
+	__efi_nargs_check_(f, __efi_nargs(__VA_ARGS__), n)
+#define __efi_nargs_check_(f, p, n) __efi_nargs_check__(f, p, n)
+#define __efi_nargs_check__(f, p, n) ({					\
+	BUILD_BUG_ON_MSG(						\
+		(p) > (n),						\
+		#f " called with too many arguments (" #p ">" #n ")");	\
+})
+
 #ifdef CONFIG_X86_32
 #define arch_efi_call_virt_setup()					\
 ({									\
@@ -56,7 +96,12 @@
 
 #define EFI_LOADER_SIGNATURE	"EL64"
 
-extern asmlinkage u64 efi_call(void *fp, ...);
+extern asmlinkage u64 __efi_call(void *fp, ...);
+
+#define efi_call(...) ({						\
+	__efi_nargs_check(efi_call, 7, __VA_ARGS__);			\
+	__efi_call(__VA_ARGS__);					\
+})
 
 /*
  * struct efi_scratch - Scratch space used while switching to/from efi_mm
@@ -139,7 +184,12 @@ struct efi_setup_data {
 extern u64 efi_setup;
 
 #ifdef CONFIG_EFI
-extern efi_status_t efi64_thunk(u32, ...);
+extern efi_status_t __efi64_thunk(u32, ...);
+
+#define efi64_thunk(...) ({						\
+	__efi_nargs_check(efi64_thunk, 6, __VA_ARGS__);			\
+	__efi64_thunk(__VA_ARGS__);					\
+})
 
 static inline bool efi_is_mixed(void)
 {

commit ea5e1919b44f09fce72d919fbb87f9611fc700a6
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:43 2020 +0100

    efi/x86: Simplify mixed mode call wrapper
    
    Calling 32-bit EFI runtime services from a 64-bit OS involves
    switching back to the flat mapping with a stack carved out of
    memory that is 32-bit addressable.
    
    There is no need to actually execute the 64-bit part of this
    routine from the flat mapping as well, as long as the entry
    and return address fit in 32 bits. There is also no need to
    preserve part of the calling context in global variables: we
    can simply push the old stack pointer value to the new stack,
    and keep the return address from the code32 section in EBX.
    
    While at it, move the conditional check whether to invoke
    the mixed mode version of SetVirtualAddressMap() into the
    64-bit implementation of the wrapper routine.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-11-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index cb08035b89a0..e7e9c6e057f9 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -164,12 +164,6 @@ extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 extern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);
 
 extern void efi_thunk_runtime_setup(void);
-extern efi_status_t efi_thunk_set_virtual_address_map(
-	void *phys_set_virtual_address_map,
-	unsigned long memory_map_size,
-	unsigned long descriptor_size,
-	u32 descriptor_version,
-	efi_memory_desc_t *virtual_map);
 efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
 					 unsigned long descriptor_size,
 					 u32 descriptor_version,

commit a46d674068b69b3897fc0d659e25f74b7ab52647
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:41 2020 +0100

    efi/x86: Simplify i386 efi_call_phys() firmware call wrapper
    
    The variadic efi_call_phys() wrapper that exists on i386 was
    originally created to call into any EFI firmware runtime service,
    but in practice, we only use it once, to call SetVirtualAddressMap()
    during early boot.
    The flexibility provided by the variadic nature also makes it
    type unsafe, and makes the assembler code more complicated than
    needed, since it has to deal with an unknown number of arguments
    living on the stack.
    
    So clean this up, by renaming the helper to efi_call_svam(), and
    dropping the unneeded complexity. Let's also drop the reference
    to the efi_phys struct and grab the address from the EFI system
    table directly.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-9-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index e29e5dc0b750..cb08035b89a0 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -35,9 +35,6 @@
 #define ARCH_EFI_IRQ_FLAGS_MASK	X86_EFLAGS_IF
 
 #ifdef CONFIG_X86_32
-
-extern asmlinkage unsigned long efi_call_phys(void *, ...);
-
 #define arch_efi_call_virt_setup()					\
 ({									\
 	kernel_fpu_begin();						\

commit 6982947045734480b8b57521e8068073fe36bd14
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:40 2020 +0100

    efi/x86: Split SetVirtualAddresMap() wrappers into 32 and 64 bit versions
    
    Split the phys_efi_set_virtual_address_map() routine into 32 and 64 bit
    versions, so we can simplify them individually in subsequent patches.
    
    There is very little overlap between the logic anyway, and this has
    already been factored out in prolog/epilog routines which are completely
    different between 32 bit and 64 bit. So let's take it one step further,
    and get rid of the overlap completely.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-8-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 09c3fc468793..e29e5dc0b750 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -61,8 +61,6 @@ extern asmlinkage unsigned long efi_call_phys(void *, ...);
 
 extern asmlinkage u64 efi_call(void *fp, ...);
 
-#define efi_call_phys(f, args...)		efi_call((f), args)
-
 /*
  * struct efi_scratch - Scratch space used while switching to/from efi_mm
  * @phys_stack: stack used during EFI Mixed Mode
@@ -115,8 +113,6 @@ extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 extern struct efi_scratch efi_scratch;
 extern void __init efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int __init efi_memblock_x86_reserve_range(void);
-extern pgd_t * __init efi_call_phys_prolog(void);
-extern void __init efi_call_phys_epilog(pgd_t *save_pgd);
 extern void __init efi_print_memmap(void);
 extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
@@ -177,6 +173,10 @@ extern efi_status_t efi_thunk_set_virtual_address_map(
 	unsigned long descriptor_size,
 	u32 descriptor_version,
 	efi_memory_desc_t *virtual_map);
+efi_status_t efi_set_virtual_address_map(unsigned long memory_map_size,
+					 unsigned long descriptor_size,
+					 u32 descriptor_version,
+					 efi_memory_desc_t *virtual_map);
 
 /* arch specific definitions used by the stub code */
 

commit 89ed486532c4d155565cc4b7984a918ee3c58f80
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:38 2020 +0100

    efi/x86: Avoid redundant cast of EFI firmware service pointer
    
    All EFI firmware call prototypes have been annotated as __efiapi,
    permitting us to attach attributes regarding the calling convention
    by overriding __efiapi to an architecture specific value.
    
    On 32-bit x86, EFI firmware calls use the plain calling convention
    where all arguments are passed via the stack, and cleaned up by the
    caller. Let's add this to the __efiapi definition so we no longer
    need to cast the function pointers before invoking them.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-6-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index b35b5d423e9d..09c3fc468793 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -51,13 +51,7 @@ extern asmlinkage unsigned long efi_call_phys(void *, ...);
 })
 
 
-/*
- * Wrap all the virtual calls in a way that forces the parameters on the stack.
- */
-#define arch_efi_call_virt(p, f, args...)				\
-({									\
-	((efi_##f##_t __attribute__((regparm(0)))*) p->f)(args);	\
-})
+#define arch_efi_call_virt(p, f, args...)	p->f(args)
 
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 

commit 6cfcd6f001b42fdbe6948cd113a5024945a8f50f
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:36 2020 +0100

    efi/x86: Re-disable RT services for 32-bit kernels running on 64-bit EFI
    
    Commit a8147dba75b1 ("efi/x86: Rename efi_is_native() to efi_is_mixed()")
    renamed and refactored efi_is_native() into efi_is_mixed(), but failed
    to take into account that these are not diametrical opposites.
    
    Mixed mode is a construct that permits 64-bit kernels to boot on 32-bit
    firmware, but there is another non-native combination which is supported,
    i.e., 32-bit kernels booting on 64-bit firmware, but only for boot and not
    for runtime services. Also, mixed mode can be disabled in Kconfig, in
    which case the 64-bit kernel can still be booted from 32-bit firmware,
    but without access to runtime services.
    
    Due to this oversight, efi_runtime_supported() now incorrectly returns
    true for such configurations, resulting in crashes at boot. So fix this
    by making efi_runtime_supported() aware of this.
    
    As a side effect, some efi_thunk_xxx() stubs have become obsolete, so
    remove them as well.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-4-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 2d1378f19b74..b35b5d423e9d 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -163,10 +163,10 @@ static inline bool efi_is_mixed(void)
 
 static inline bool efi_runtime_supported(void)
 {
-	if (!efi_is_mixed())
+	if (IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT))
 		return true;
 
-	if (!efi_enabled(EFI_OLD_MEMMAP))
+	if (IS_ENABLED(CONFIG_EFI_MIXED) && !efi_enabled(EFI_OLD_MEMMAP))
 		return true;
 
 	return false;
@@ -176,7 +176,6 @@ extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 
 extern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);
 
-#ifdef CONFIG_EFI_MIXED
 extern void efi_thunk_runtime_setup(void);
 extern efi_status_t efi_thunk_set_virtual_address_map(
 	void *phys_set_virtual_address_map,
@@ -184,19 +183,6 @@ extern efi_status_t efi_thunk_set_virtual_address_map(
 	unsigned long descriptor_size,
 	u32 descriptor_version,
 	efi_memory_desc_t *virtual_map);
-#else
-static inline void efi_thunk_runtime_setup(void) {}
-static inline efi_status_t efi_thunk_set_virtual_address_map(
-	void *phys_set_virtual_address_map,
-	unsigned long memory_map_size,
-	unsigned long descriptor_size,
-	u32 descriptor_version,
-	efi_memory_desc_t *virtual_map)
-{
-	return EFI_SUCCESS;
-}
-#endif /* CONFIG_EFI_MIXED */
-
 
 /* arch specific definitions used by the stub code */
 

commit 966291f6344d7eb6fc3204381a426bafa20a3d18
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:23 2019 +0100

    efi/libstub: Rename efi_call_early/_runtime macros to be more intuitive
    
    The macros efi_call_early and efi_call_runtime are used to call EFI
    boot services and runtime services, respectively. However, the naming
    is confusing, given that the early vs runtime distinction may suggest
    that these are used for calling the same set of services either early
    or late (== at runtime), while in reality, the sets of services they
    can be used with are completely disjoint, and efi_call_runtime is also
    only usable in 'early' code.
    
    So do a global sweep to replace all occurrences with efi_bs_call or
    efi_rt_call, respectively, where BS and RT match the idiom used by
    the UEFI spec to refer to boot time or runtime services.
    
    While at it, use 'func' as the macro parameter name for the function
    pointers, which is less likely to collide and cause weird build errors.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-24-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 39814a0a92f7..2d1378f19b74 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -227,17 +227,17 @@ static inline bool efi_is_native(void)
 		? inst->func(inst, ##__VA_ARGS__)			\
 		: efi64_thunk(inst->mixed_mode.func, inst, ##__VA_ARGS__))
 
-#define efi_call_early(f, ...)						\
+#define efi_bs_call(func, ...)						\
 	(efi_is_native()						\
-		? efi_system_table()->boottime->f(__VA_ARGS__)		\
+		? efi_system_table()->boottime->func(__VA_ARGS__)	\
 		: efi64_thunk(efi_table_attr(efi_system_table(),	\
-				boottime)->mixed_mode.f, __VA_ARGS__))
+				boottime)->mixed_mode.func, __VA_ARGS__))
 
-#define efi_call_runtime(f, ...)					\
+#define efi_rt_call(func, ...)						\
 	(efi_is_native()						\
-		? efi_system_table()->runtime->f(__VA_ARGS__)		\
+		? efi_system_table()->runtime->func(__VA_ARGS__)	\
 		: efi64_thunk(efi_table_attr(efi_system_table(),	\
-				runtime)->mixed_mode.f, __VA_ARGS__))
+				runtime)->mixed_mode.func, __VA_ARGS__))
 
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);

commit 99ea8b1db2d23ac856bf3ee0673628df088a21ea
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:22 2019 +0100

    efi/libstub: Drop 'table' argument from efi_table_attr() macro
    
    None of the definitions of the efi_table_attr() still refer to
    their 'table' argument so let's get rid of it entirely.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-23-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index b7cd14e3a634..39814a0a92f7 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -216,16 +216,11 @@ static inline bool efi_is_native(void)
 		__builtin_types_compatible_p(u32, __typeof__(attr)),	\
 			(unsigned long)(attr), (attr))
 
-#define efi_table_attr(table, attr, instance) ({			\
-	__typeof__(instance->attr) __ret;				\
-	if (efi_is_native()) {						\
-		__ret = instance->attr;					\
-	} else {							\
-		__ret = (__typeof__(__ret))				\
-			efi_mixed_mode_cast(instance->mixed_mode.attr);	\
-	}								\
-	__ret;								\
-})
+#define efi_table_attr(inst, attr)					\
+	(efi_is_native()						\
+		? inst->attr						\
+		: (__typeof__(inst->attr))				\
+			efi_mixed_mode_cast(inst->mixed_mode.attr))
 
 #define efi_call_proto(inst, func, ...)					\
 	(efi_is_native()						\
@@ -235,16 +230,14 @@ static inline bool efi_is_native(void)
 #define efi_call_early(f, ...)						\
 	(efi_is_native()						\
 		? efi_system_table()->boottime->f(__VA_ARGS__)		\
-		: efi64_thunk(efi_table_attr(efi_boot_services,		\
-			boottime, efi_system_table())->mixed_mode.f,	\
-			__VA_ARGS__))
+		: efi64_thunk(efi_table_attr(efi_system_table(),	\
+				boottime)->mixed_mode.f, __VA_ARGS__))
 
 #define efi_call_runtime(f, ...)					\
 	(efi_is_native()						\
 		? efi_system_table()->runtime->f(__VA_ARGS__)		\
-		: efi64_thunk(efi_table_attr(efi_runtime_services,	\
-			runtime, efi_system_table())->mixed_mode.f,	\
-			__VA_ARGS__))
+		: efi64_thunk(efi_table_attr(efi_system_table(),	\
+				runtime)->mixed_mode.f, __VA_ARGS__))
 
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);

commit 47c0fd39b7b81f51cc8f767c34a57d12289bdc60
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:21 2019 +0100

    efi/libstub: Drop protocol argument from efi_call_proto() macro
    
    After refactoring the mixed mode support code, efi_call_proto()
    no longer uses its protocol argument in any of its implementation,
    so let's remove it altogether.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-22-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 1817f350618e..b7cd14e3a634 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -227,10 +227,10 @@ static inline bool efi_is_native(void)
 	__ret;								\
 })
 
-#define efi_call_proto(protocol, f, instance, ...)			\
+#define efi_call_proto(inst, func, ...)					\
 	(efi_is_native()						\
-		? instance->f(instance, ##__VA_ARGS__)			\
-		: efi64_thunk(instance->mixed_mode.f, instance,	##__VA_ARGS__))
+		? inst->func(inst, ##__VA_ARGS__)			\
+		: efi64_thunk(inst->mixed_mode.func, inst, ##__VA_ARGS__))
 
 #define efi_call_early(f, ...)						\
 	(efi_is_native()						\

commit c3710de5065d63f8b16d160a118cc50ae09050b4
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:17 2019 +0100

    efi/libstub/x86: Drop __efi_early() export and efi_config struct
    
    The various pointers we stash in the efi_config struct which we
    retrieve using __efi_early() are simply copies of the ones in
    the EFI system table, which we have started accessing directly
    in the previous patch. So drop all the __efi_early() related
    plumbing, as well as all the assembly code dealing with efi_config,
    which allows us to move the PE/COFF entry point to C code as well.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-18-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 001905daa110..1817f350618e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -200,32 +200,14 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 
 /* arch specific definitions used by the stub code */
 
-struct efi_config {
-	u64 image_handle;
-	u64 table;
-	u64 runtime_services;
-	u64 boot_services;
-	u64 text_output;
-	bool is64;
-} __packed;
-
-__pure const struct efi_config *__efi_early(void);
-
-static inline bool efi_is_64bit(void)
-{
-	if (!IS_ENABLED(CONFIG_X86_64))
-		return false;
-
-	if (!IS_ENABLED(CONFIG_EFI_MIXED))
-		return true;
-
-	return __efi_early()->is64;
-}
+__pure bool efi_is_64bit(void);
 
 static inline bool efi_is_native(void)
 {
 	if (!IS_ENABLED(CONFIG_X86_64))
 		return true;
+	if (!IS_ENABLED(CONFIG_EFI_MIXED))
+		return true;
 	return efi_is_64bit();
 }
 
@@ -252,18 +234,16 @@ static inline bool efi_is_native(void)
 
 #define efi_call_early(f, ...)						\
 	(efi_is_native()						\
-		? ((efi_boot_services_t *)(unsigned long)		\
-			__efi_early()->boot_services)->f(__VA_ARGS__)	\
-		: efi64_thunk(((efi_boot_services_t *)(unsigned long)	\
-			__efi_early()->boot_services)->mixed_mode.f,	\
+		? efi_system_table()->boottime->f(__VA_ARGS__)		\
+		: efi64_thunk(efi_table_attr(efi_boot_services,		\
+			boottime, efi_system_table())->mixed_mode.f,	\
 			__VA_ARGS__))
 
 #define efi_call_runtime(f, ...)					\
 	(efi_is_native()						\
-		? ((efi_runtime_services_t *)(unsigned long)		\
-			__efi_early()->runtime_services)->f(__VA_ARGS__)\
-		: efi64_thunk(((efi_runtime_services_t *)(unsigned long)\
-			__efi_early()->runtime_services)->mixed_mode.f,	\
+		? efi_system_table()->runtime->f(__VA_ARGS__)		\
+		: efi64_thunk(efi_table_attr(efi_runtime_services,	\
+			runtime, efi_system_table())->mixed_mode.f,	\
 			__VA_ARGS__))
 
 extern bool efi_reboot_required(void);

commit afc4cc71cf78a8d691023da8ebcc31c3394a1674
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:13 2019 +0100

    efi/libstub/x86: Avoid thunking for native firmware calls
    
    We use special wrapper routines to invoke firmware services in the
    native case as well as the mixed mode case. For mixed mode, the need
    is obvious, but for the native cases, we can simply rely on the
    compiler to generate the indirect call, given that GCC now has
    support for the MS calling convention (and has had it for quite some
    time now). Note that on i386, the decompressor and the EFI stub are not
    built with -mregparm=3 like the rest of the i386 kernel, so we can
    safely allow the compiler to emit the indirect calls here as well.
    
    So drop all the wrappers and indirection, and switch to either native
    calls, or direct calls into the thunk routine for mixed mode.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-14-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index c27323cb49e5..001905daa110 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -152,6 +152,7 @@ struct efi_setup_data {
 extern u64 efi_setup;
 
 #ifdef CONFIG_EFI
+extern efi_status_t efi64_thunk(u32, ...);
 
 static inline bool efi_is_mixed(void)
 {
@@ -205,7 +206,6 @@ struct efi_config {
 	u64 runtime_services;
 	u64 boot_services;
 	u64 text_output;
-	efi_status_t (*call)(unsigned long, ...);
 	bool is64;
 } __packed;
 
@@ -235,30 +235,36 @@ static inline bool efi_is_native(void)
 			(unsigned long)(attr), (attr))
 
 #define efi_table_attr(table, attr, instance) ({			\
-	__typeof__(((table##_t *)0)->attr) __ret;			\
+	__typeof__(instance->attr) __ret;				\
 	if (efi_is_native()) {						\
-		__ret = ((table##_t *)(unsigned long)instance)->attr;	\
+		__ret = instance->attr;					\
 	} else {							\
-		__ret = (__typeof__(__ret))efi_mixed_mode_cast(		\
-		((table##_t *)(unsigned long)instance)->mixed_mode.attr);\
+		__ret = (__typeof__(__ret))				\
+			efi_mixed_mode_cast(instance->mixed_mode.attr);	\
 	}								\
 	__ret;								\
 })
 
 #define efi_call_proto(protocol, f, instance, ...)			\
-	__efi_early()->call((unsigned long)				\
-				efi_table_attr(protocol, f, instance),	\
-		instance, ##__VA_ARGS__)
+	(efi_is_native()						\
+		? instance->f(instance, ##__VA_ARGS__)			\
+		: efi64_thunk(instance->mixed_mode.f, instance,	##__VA_ARGS__))
 
 #define efi_call_early(f, ...)						\
-	__efi_early()->call((unsigned long)				\
-				efi_table_attr(efi_boot_services, f,	\
-		__efi_early()->boot_services), __VA_ARGS__)
+	(efi_is_native()						\
+		? ((efi_boot_services_t *)(unsigned long)		\
+			__efi_early()->boot_services)->f(__VA_ARGS__)	\
+		: efi64_thunk(((efi_boot_services_t *)(unsigned long)	\
+			__efi_early()->boot_services)->mixed_mode.f,	\
+			__VA_ARGS__))
 
 #define efi_call_runtime(f, ...)					\
-	__efi_early()->call((unsigned long)				\
-				efi_table_attr(efi_runtime_services, f,	\
-		__efi_early()->runtime_services), __VA_ARGS__)
+	(efi_is_native()						\
+		? ((efi_runtime_services_t *)(unsigned long)		\
+			__efi_early()->runtime_services)->f(__VA_ARGS__)\
+		: efi64_thunk(((efi_runtime_services_t *)(unsigned long)\
+			__efi_early()->runtime_services)->mixed_mode.f,	\
+			__VA_ARGS__))
 
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);

commit f958efe97596837f9504fc38d75ef8e284bc0ebd
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:09 2019 +0100

    efi/libstub: Distinguish between native/mixed not 32/64 bit
    
    Currently, we support mixed mode by casting all boot time firmware
    calls to 64-bit explicitly on native 64-bit systems, and to 32-bit
    on 32-bit systems or 64-bit systems running with 32-bit firmware.
    
    Due to this explicit awareness of the bitness in the code, we do a
    lot of casting even on generic code that is shared with other
    architectures, where mixed mode does not even exist. This casting
    leads to loss of coverage of type checking by the compiler, which
    we should try to avoid.
    
    So instead of distinguishing between 32-bit vs 64-bit, distinguish
    between native vs mixed, and limit all the nasty casting and
    pointer mangling to the code that actually deals with mixed mode.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-10-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 6094e7f49a99..c27323cb49e5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -222,21 +222,42 @@ static inline bool efi_is_64bit(void)
 	return __efi_early()->is64;
 }
 
-#define efi_table_attr(table, attr, instance)				\
-	(efi_is_64bit() ?						\
-		((table##_64_t *)(unsigned long)instance)->attr :	\
-		((table##_32_t *)(unsigned long)instance)->attr)
+static inline bool efi_is_native(void)
+{
+	if (!IS_ENABLED(CONFIG_X86_64))
+		return true;
+	return efi_is_64bit();
+}
+
+#define efi_mixed_mode_cast(attr)					\
+	__builtin_choose_expr(						\
+		__builtin_types_compatible_p(u32, __typeof__(attr)),	\
+			(unsigned long)(attr), (attr))
+
+#define efi_table_attr(table, attr, instance) ({			\
+	__typeof__(((table##_t *)0)->attr) __ret;			\
+	if (efi_is_native()) {						\
+		__ret = ((table##_t *)(unsigned long)instance)->attr;	\
+	} else {							\
+		__ret = (__typeof__(__ret))efi_mixed_mode_cast(		\
+		((table##_t *)(unsigned long)instance)->mixed_mode.attr);\
+	}								\
+	__ret;								\
+})
 
 #define efi_call_proto(protocol, f, instance, ...)			\
-	__efi_early()->call(efi_table_attr(protocol, f, instance),	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(protocol, f, instance),	\
 		instance, ##__VA_ARGS__)
 
 #define efi_call_early(f, ...)						\
-	__efi_early()->call(efi_table_attr(efi_boot_services, f,	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(efi_boot_services, f,	\
 		__efi_early()->boot_services), __VA_ARGS__)
 
 #define efi_call_runtime(f, ...)					\
-	__efi_early()->call(efi_table_attr(efi_runtime_services, f,	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(efi_runtime_services, f,	\
 		__efi_early()->runtime_services), __VA_ARGS__)
 
 extern bool efi_reboot_required(void);

commit a8147dba75b188bff87d4ad072db84a0b70d716d
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:06 2019 +0100

    efi/x86: Rename efi_is_native() to efi_is_mixed()
    
    The ARM architecture does not permit combining 32-bit and 64-bit code
    at the same privilege level, and so EFI mixed mode is strictly a x86
    concept.
    
    In preparation of turning the 32/64 bit distinction in shared stub
    code to a native vs mixed one, refactor x86's current use of the
    helper function efi_is_native() into efi_is_mixed().
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-7-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 59c19e0b6027..6094e7f49a99 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -153,17 +153,19 @@ extern u64 efi_setup;
 
 #ifdef CONFIG_EFI
 
-static inline bool efi_is_native(void)
+static inline bool efi_is_mixed(void)
 {
-	return IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT);
+	if (!IS_ENABLED(CONFIG_EFI_MIXED))
+		return false;
+	return IS_ENABLED(CONFIG_X86_64) && !efi_enabled(EFI_64BIT);
 }
 
 static inline bool efi_runtime_supported(void)
 {
-	if (efi_is_native())
+	if (!efi_is_mixed())
 		return true;
 
-	if (IS_ENABLED(CONFIG_EFI_MIXED) && !efi_enabled(EFI_OLD_MEMMAP))
+	if (!efi_enabled(EFI_OLD_MEMMAP))
 		return true;
 
 	return false;

commit 58ec655a75731c83f403e9c04ffd66aa6b3cd4d5
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:05 2019 +0100

    efi/libstub: Remove unused __efi_call_early() macro
    
    The macro __efi_call_early() is defined by various architectures but
    never used. Let's get rid of it.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-6-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index d028e9acdf1c..59c19e0b6027 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -233,9 +233,6 @@ static inline bool efi_is_64bit(void)
 	__efi_early()->call(efi_table_attr(efi_boot_services, f,	\
 		__efi_early()->boot_services), __VA_ARGS__)
 
-#define __efi_call_early(f, ...)					\
-	__efi_early()->call((unsigned long)f, __VA_ARGS__);
-
 #define efi_call_runtime(f, ...)					\
 	__efi_early()->call(efi_table_attr(efi_runtime_services, f,	\
 		__efi_early()->runtime_services), __VA_ARGS__)

commit 199c8471761273b7e287914cee968ddf21dfbfe0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:26 2019 -0800

    x86/efi: Add efi_fake_mem support for EFI_MEMORY_SP
    
    Given that EFI_MEMORY_SP is platform BIOS policy decision for marking
    memory ranges as "reserved for a specific purpose" there will inevitably
    be scenarios where the BIOS omits the attribute in situations where it
    is desired. Unlike other attributes if the OS wants to reserve this
    memory from the kernel the reservation needs to happen early in init. So
    early, in fact, that it needs to happen before e820__memblock_setup()
    which is a pre-requisite for efi_fake_memmap() that wants to allocate
    memory for the updated table.
    
    Introduce an x86 specific efi_fake_memmap_early() that can search for
    attempts to set EFI_MEMORY_SP via efi_fake_mem and update the e820 table
    accordingly.
    
    The KASLR code that scans the command line looking for user-directed
    memory reservations also needs to be updated to consider
    "efi_fake_mem=nn@ss:0x40000" requests.
    
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 45f853bce869..d028e9acdf1c 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -263,4 +263,12 @@ static inline void efi_reserve_boot_services(void)
 }
 #endif /* CONFIG_EFI */
 
+#ifdef CONFIG_EFI_FAKE_MEMMAP
+extern void __init efi_fake_memmap_early(void);
+#else
+static inline void efi_fake_memmap_early(void)
+{
+}
+#endif
+
 #endif /* _ASM_X86_EFI_H */

commit 6950e31b35fdf4588cbbdec1813091bb02cf8871
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:05 2019 -0800

    x86/efi: Push EFI_MEMMAP check into leaf routines
    
    In preparation for adding another EFI_MEMMAP dependent call that needs
    to occur before e820__memblock_setup() fixup the existing efi calls to
    check for EFI_MEMMAP internally. This ends up being cleaner than the
    alternative of checking EFI_MEMMAP multiple times in setup_arch().
    
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 43a82e59c59d..45f853bce869 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -140,7 +140,6 @@ extern void efi_delete_dummy_variable(void);
 extern void efi_switch_mm(struct mm_struct *mm);
 extern void efi_recover_from_page_fault(unsigned long phys_addr);
 extern void efi_free_boot_services(void);
-extern void efi_reserve_boot_services(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;
@@ -244,6 +243,8 @@ static inline bool efi_is_64bit(void)
 extern bool efi_reboot_required(void);
 extern bool efi_is_table_address(unsigned long phys_addr);
 
+extern void efi_find_mirror(void);
+extern void efi_reserve_boot_services(void);
 #else
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
 static inline bool efi_reboot_required(void)
@@ -254,6 +255,12 @@ static inline  bool efi_is_table_address(unsigned long phys_addr)
 {
 	return false;
 }
+static inline void efi_find_mirror(void)
+{
+}
+static inline void efi_reserve_boot_services(void)
+{
+}
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */

commit e55f31a599478fb06a5a5d95e019e963322535cb
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 15:36:45 2019 +0200

    efi: x86: move efi_is_table_address() into arch/x86
    
    The function efi_is_table_address() and the associated array of table
    pointers is specific to x86. Since we will be adding some more x86
    specific tables, let's move this code out of the generic code first.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 606a4b6a9812..43a82e59c59d 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -242,6 +242,7 @@ static inline bool efi_is_64bit(void)
 		__efi_early()->runtime_services), __VA_ARGS__)
 
 extern bool efi_reboot_required(void);
+extern bool efi_is_table_address(unsigned long phys_addr);
 
 #else
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
@@ -249,6 +250,10 @@ static inline bool efi_reboot_required(void)
 {
 	return false;
 }
+static inline  bool efi_is_table_address(unsigned long phys_addr)
+{
+	return false;
+}
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */

commit 69c1f396f25b805aeff08f06d2e992c315ee5b1e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Feb 2 10:41:18 2019 +0100

    efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation
    
    Move the x86 EFI earlyprintk implementation to a shared location under
    drivers/firmware and tweak it slightly so we can expose it as an earlycon
    implementation (which is generic) rather than earlyprintk (which is only
    implemented for a few architectures)
    
    This also involves switching to write-combine mappings by default (which
    is required on ARM since device mappings lack memory semantics, and so
    memcpy/memset may not be used on them), and adding support for shared
    memory framebuffers on cache coherent non-x86 systems (which do not
    tolerate mismatched attributes).
    
    Note that 32-bit ARM does not populate its struct screen_info early
    enough for earlycon=efifb to work, so it is disabled there.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-10-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 107283b1eb1e..606a4b6a9812 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -170,7 +170,6 @@ static inline bool efi_runtime_supported(void)
 	return false;
 }
 
-extern struct console early_efi_console;
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 
 extern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);

commit d6e867a6ae13bc02cd01c535764e5b051d26cf28
Merge: db2ab474c4a4 12209993e98c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 26 17:37:51 2018 -0800

    Merge branch 'x86-fpu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 fpu updates from Ingo Molnar:
     "Misc preparatory changes for an upcoming FPU optimization that will
      delay the loading of FPU registers to return-to-userspace"
    
    * 'x86-fpu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/fpu: Don't export __kernel_fpu_{begin,end}()
      x86/fpu: Update comment for __raw_xsave_addr()
      x86/fpu: Add might_fault() to user_insn()
      x86/pkeys: Make init_pkru_value static
      x86/thread_info: Remove _TIF_ALLWORK_MASK
      x86/process/32: Remove asm/math_emu.h include
      x86/fpu: Use unsigned long long shift in xfeature_uncompacted_offset()

commit 312a466155108329c458049dc76a21ad56106960
Merge: 6e54df001ac9 4b1bacab61aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 26 17:03:51 2018 -0800

    Merge branch 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 cleanups from Ingo Molnar:
     "Misc cleanups"
    
    * 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/kprobes: Remove trampoline_handler() prototype
      x86/kernel: Fix more -Wmissing-prototypes warnings
      x86: Fix various typos in comments
      x86/headers: Fix -Wmissing-prototypes warning
      x86/process: Avoid unnecessary NULL check in get_wchan()
      x86/traps: Complete prototype declarations
      x86/mce: Fix -Wmissing-prototypes warnings
      x86/gart: Rewrite early_gart_iommu_check() comment

commit 12209993e98c5fa1855c467f22a24e3d5b8be205
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Nov 29 16:02:10 2018 +0100

    x86/fpu: Don't export __kernel_fpu_{begin,end}()
    
    There is one user of __kernel_fpu_begin() and before invoking it,
    it invokes preempt_disable(). So it could invoke kernel_fpu_begin()
    right away. The 32bit version of arch_efi_call_virt_setup() and
    arch_efi_call_virt_teardown() does this already.
    
    The comment above *kernel_fpu*() claims that before invoking
    __kernel_fpu_begin() preemption should be disabled and that KVM is a
    good example of doing it. Well, KVM doesn't do that since commit
    
      f775b13eedee2 ("x86,kvm: move qemu/guest FPU switching out to vcpu_run")
    
    so it is not an example anymore.
    
    With EFI gone as the last user of __kernel_fpu_{begin|end}(), both can
    be made static and not exported anymore.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Rik van Riel <riel@surriel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "Jason A. Donenfeld" <Jason@zx2c4.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Nicolai Stange <nstange@suse.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: kvm ML <kvm@vger.kernel.org>
    Cc: linux-efi <linux-efi@vger.kernel.org>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20181129150210.2k4mawt37ow6c2vq@linutronix.de

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index eea40d52ca78..45864898f7e5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -82,8 +82,7 @@ struct efi_scratch {
 #define arch_efi_call_virt_setup()					\
 ({									\
 	efi_sync_low_kernel_mappings();					\
-	preempt_disable();						\
-	__kernel_fpu_begin();						\
+	kernel_fpu_begin();						\
 	firmware_restrict_branch_speculation_start();			\
 									\
 	if (!efi_enabled(EFI_OLD_MEMMAP))				\
@@ -99,8 +98,7 @@ struct efi_scratch {
 		efi_switch_mm(efi_scratch.prev_mm);			\
 									\
 	firmware_restrict_branch_speculation_end();			\
-	__kernel_fpu_end();						\
-	preempt_enable();						\
+	kernel_fpu_end();						\
 })
 
 extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,

commit a97673a1c43d005a3ae215f4ca8b4bbb5691aea1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Dec 3 10:47:34 2018 +0100

    x86: Fix various typos in comments
    
    Go over arch/x86/ and fix common typos in comments,
    and a typo in an actual function argument name.
    
    No change in functionality intended.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index eea40d52ca78..db45773a63b6 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -19,7 +19,7 @@
  * This is the main reason why we're doing stable VA mappings for RT
  * services.
  *
- * This flag is used in conjuction with a chicken bit called
+ * This flag is used in conjunction with a chicken bit called
  * "efi=old_map" which can be used as a fallback to the old runtime
  * services mapping method in case there's some b0rkage with a
  * particular EFI implementation (haha, it is hard to hold up the

commit 47c33a095e1fae376d74b4160a0d73c1a4e73969
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Thu Nov 29 18:12:25 2018 +0100

    x86/efi: Move efi_<reserve/free>_boot_services() to arch/x86
    
    efi_<reserve/free>_boot_services() are x86 specific quirks and as such
    should be in asm/efi.h, so move them from linux/efi.h. Also, call
    efi_free_boot_services() from __efi_enter_virtual_mode() as it is x86
    specific call and ideally shouldn't be part of init/main.c
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index eea40d52ca78..d1e64ac80b9c 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -141,6 +141,8 @@ extern int __init efi_reuse_config(u64 tables, int nr_tables);
 extern void efi_delete_dummy_variable(void);
 extern void efi_switch_mm(struct mm_struct *mm);
 extern void efi_recover_from_page_fault(unsigned long phys_addr);
+extern void efi_free_boot_services(void);
+extern void efi_reserve_boot_services(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 3425d934fc0312f62024163736a7afe4de20c10f
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Sep 11 12:15:22 2018 -0700

    efi/x86: Handle page faults occurring while running EFI runtime services
    
    Memory accesses performed by UEFI runtime services should be limited to:
    - reading/executing from EFI_RUNTIME_SERVICES_CODE memory regions
    - reading/writing from/to EFI_RUNTIME_SERVICES_DATA memory regions
    - reading/writing by-ref arguments
    - reading/writing from/to the stack.
    
    Accesses outside these regions may cause the kernel to hang because the
    memory region requested by the firmware isn't mapped in efi_pgd, which
    causes a page fault in ring 0 and the kernel fails to handle it, leading
    to die(). To save kernel from hanging, add an EFI specific page fault
    handler which recovers from such faults by
    1. If the efi runtime service is efi_reset_system(), reboot the machine
       through BIOS.
    2. If the efi runtime service is _not_ efi_reset_system(), then freeze
       efi_rts_wq and schedule a new process.
    
    The EFI page fault handler offers us two advantages:
    1. Avoid potential hangs caused by buggy firmware.
    2. Shout loud that the firmware is buggy and hence is not a kernel bug.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Suggested-by: Matt Fleming <matt@codeblueprint.co.uk>
    Based-on-code-from: Ricardo Neri <ricardo.neri@intel.com>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [ardb: clarify commit log]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index cec5fae23eb3..eea40d52ca78 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -140,6 +140,7 @@ extern void __init efi_apply_memmap_quirks(void);
 extern int __init efi_reuse_config(u64 tables, int nr_tables);
 extern void efi_delete_dummy_variable(void);
 extern void efi_switch_mm(struct mm_struct *mm);
+extern void efi_recover_from_page_fault(unsigned long phys_addr);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 03781e40890c18bdea40092355b61431d0073c1d
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Mon Mar 12 09:43:55 2018 +0000

    x86/efi: Use efi_switch_mm() rather than manually twiddling with %cr3
    
    Use helper function efi_switch_mm() to switch to/from efi_mm when
    invoking any UEFI runtime services.
    
    Likewise, we need to switch back to previous mm (mm context stolen
    by efi_mm) after the above calls return successfully. We can use
    efi_switch_mm() helper function only with x86_64 kernel and
    "efi=old_map" disabled because, x86_32 and efi=old_map do not use
    efi_pgd, rather they use swapper_pg_dir.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    [ardb: add #include of sched/task.h for task_lock/_unlock]
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Lee, Chun-Yi <jlee@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-efi@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index c62443fa7d0a..cec5fae23eb3 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -70,14 +70,13 @@ extern asmlinkage u64 efi_call(void *fp, ...);
 #define efi_call_phys(f, args...)		efi_call((f), args)
 
 /*
- * Scratch space used for switching the pagetable in the EFI stub
+ * struct efi_scratch - Scratch space used while switching to/from efi_mm
+ * @phys_stack: stack used during EFI Mixed Mode
+ * @prev_mm:    store/restore stolen mm_struct while switching to/from efi_mm
  */
 struct efi_scratch {
-	u64	r15;
-	u64	prev_cr3;
-	pgd_t	*efi_pgt;
-	bool	use_pgd;
-	u64	phys_stack;
+	u64			phys_stack;
+	struct mm_struct	*prev_mm;
 } __packed;
 
 #define arch_efi_call_virt_setup()					\
@@ -87,11 +86,8 @@ struct efi_scratch {
 	__kernel_fpu_begin();						\
 	firmware_restrict_branch_speculation_start();			\
 									\
-	if (efi_scratch.use_pgd) {					\
-		efi_scratch.prev_cr3 = __read_cr3();			\
-		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
-		__flush_tlb_all();					\
-	}								\
+	if (!efi_enabled(EFI_OLD_MEMMAP))				\
+		efi_switch_mm(&efi_mm);					\
 })
 
 #define arch_efi_call_virt(p, f, args...)				\
@@ -99,10 +95,8 @@ struct efi_scratch {
 
 #define arch_efi_call_virt_teardown()					\
 ({									\
-	if (efi_scratch.use_pgd) {					\
-		write_cr3(efi_scratch.prev_cr3);			\
-		__flush_tlb_all();					\
-	}								\
+	if (!efi_enabled(EFI_OLD_MEMMAP))				\
+		efi_switch_mm(efi_scratch.prev_mm);			\
 									\
 	firmware_restrict_branch_speculation_end();			\
 	__kernel_fpu_end();						\
@@ -145,6 +139,7 @@ extern void __init efi_dump_pagetable(void);
 extern void __init efi_apply_memmap_quirks(void);
 extern int __init efi_reuse_config(u64 tables, int nr_tables);
 extern void efi_delete_dummy_variable(void);
+extern void efi_switch_mm(struct mm_struct *mm);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 7e904a91bf6049071ef9d605a52f863ae774081d
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Mon Mar 12 08:44:56 2018 +0000

    efi: Use efi_mm in x86 as well as ARM
    
    Presently, only ARM uses mm_struct to manage EFI page tables and EFI
    runtime region mappings. As this is the preferred approach, let's make
    this data structure common across architectures. Specially, for x86,
    using this data structure improves code maintainability and readability.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    [ardb: don't #include the world to get a declaration of struct mm_struct]
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Lee, Chun-Yi <jlee@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180312084500.10764-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index a399c1ebf6f0..c62443fa7d0a 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -7,6 +7,7 @@
 #include <asm/processor-flags.h>
 #include <asm/tlb.h>
 #include <asm/nospec-branch.h>
+#include <asm/mmu_context.h>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,

commit dd84441a797150dcc49298ec95c459a8891d8bb1
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Mon Feb 19 10:50:54 2018 +0000

    x86/speculation: Use IBRS if available before calling into firmware
    
    Retpoline means the kernel is safe because it has no indirect branches.
    But firmware isn't, so use IBRS for firmware calls if it's available.
    
    Block preemption while IBRS is set, although in practice the call sites
    already had to be doing that.
    
    Ignore hpwdt.c for now. It's taking spinlocks and calling into firmware
    code, from an NMI handler. I don't want to touch that with a bargepole.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: arjan.van.de.ven@intel.com
    Cc: bp@alien8.de
    Cc: dave.hansen@intel.com
    Cc: jmattson@google.com
    Cc: karahmed@amazon.de
    Cc: kvm@vger.kernel.org
    Cc: pbonzini@redhat.com
    Cc: rkrcmar@redhat.com
    Link: http://lkml.kernel.org/r/1519037457-7643-2-git-send-email-dwmw@amazon.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 85f6ccb80b91..a399c1ebf6f0 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -6,6 +6,7 @@
 #include <asm/pgtable.h>
 #include <asm/processor-flags.h>
 #include <asm/tlb.h>
+#include <asm/nospec-branch.h>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
@@ -36,8 +37,18 @@
 
 extern asmlinkage unsigned long efi_call_phys(void *, ...);
 
-#define arch_efi_call_virt_setup()	kernel_fpu_begin()
-#define arch_efi_call_virt_teardown()	kernel_fpu_end()
+#define arch_efi_call_virt_setup()					\
+({									\
+	kernel_fpu_begin();						\
+	firmware_restrict_branch_speculation_start();			\
+})
+
+#define arch_efi_call_virt_teardown()					\
+({									\
+	firmware_restrict_branch_speculation_end();			\
+	kernel_fpu_end();						\
+})
+
 
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
@@ -73,6 +84,7 @@ struct efi_scratch {
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
+	firmware_restrict_branch_speculation_start();			\
 									\
 	if (efi_scratch.use_pgd) {					\
 		efi_scratch.prev_cr3 = __read_cr3();			\
@@ -91,6 +103,7 @@ struct efi_scratch {
 		__flush_tlb_all();					\
 	}								\
 									\
+	firmware_restrict_branch_speculation_end();			\
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 })

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 796ff6c1aa53..85f6ccb80b91 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _ASM_X86_EFI_H
 #define _ASM_X86_EFI_H
 

commit 0825f49f225bd24c3ae46ff2bb716067e3684fc3
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 12 14:37:31 2017 -0700

    x86/efi: move asmlinkage before return type
    
    Make the code like the rest of the kernel.
    
    Link: http://lkml.kernel.org/r/1cd3d401626e51ea0e2333a860e76e80bc560a4c.1499284835.git.joe@perches.com
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index d2ff779f347e..796ff6c1aa53 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -33,7 +33,7 @@
 
 #ifdef CONFIG_X86_32
 
-extern unsigned long asmlinkage efi_call_phys(void *, ...);
+extern asmlinkage unsigned long efi_call_phys(void *, ...);
 
 #define arch_efi_call_virt_setup()	kernel_fpu_begin()
 #define arch_efi_call_virt_teardown()	kernel_fpu_end()
@@ -52,7 +52,7 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #define EFI_LOADER_SIGNATURE	"EL64"
 
-extern u64 asmlinkage efi_call(void *fp, ...);
+extern asmlinkage u64 efi_call(void *fp, ...);
 
 #define efi_call_phys(f, args...)		efi_call((f), args)
 

commit 6c690ee1039b251e583fc65b28da30e97d6a7385
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Jun 12 10:26:14 2017 -0700

    x86/mm: Split read_cr3() into read_cr3_pa() and __read_cr3()
    
    The kernel has several code paths that read CR3.  Most of them assume that
    CR3 contains the PGD's physical address, whereas some of them awkwardly
    use PHYSICAL_PAGE_MASK to mask off low bits.
    
    Add explicit mask macros for CR3 and convert all of the CR3 readers.
    This will keep them from breaking when PCID is enabled.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: xen-devel <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/883f8fb121f4616c1c1427ad87350bb2f5ffeca1.1497288170.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 2f77bcefe6b4..d2ff779f347e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -74,7 +74,7 @@ struct efi_scratch {
 	__kernel_fpu_begin();						\
 									\
 	if (efi_scratch.use_pgd) {					\
-		efi_scratch.prev_cr3 = read_cr3();			\
+		efi_scratch.prev_cr3 = __read_cr3();			\
 		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
 		__flush_tlb_all();					\
 	}								\

commit a2cd2f3f29f26782b7484b32e2af172e29313717
Author: David Howells <dhowells@redhat.com>
Date:   Mon Feb 6 11:22:40 2017 +0000

    x86/efi: Allow invocation of arbitrary runtime services
    
    Provide the ability to perform mixed-mode runtime service calls for x86 in
    the same way the following commit provided the ability to invoke for boot
    services:
    
      0a637ee61247bd ("x86/efi: Allow invocation of arbitrary boot services")
    
    Suggested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1486380166-31868-2-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index e99675b9c861..2f77bcefe6b4 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -191,6 +191,7 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 struct efi_config {
 	u64 image_handle;
 	u64 table;
+	u64 runtime_services;
 	u64 boot_services;
 	u64 text_output;
 	efi_status_t (*call)(unsigned long, ...);
@@ -226,6 +227,10 @@ static inline bool efi_is_64bit(void)
 #define __efi_call_early(f, ...)					\
 	__efi_early()->call((unsigned long)f, __VA_ARGS__);
 
+#define efi_call_runtime(f, ...)					\
+	__efi_early()->call(efi_table_attr(efi_runtime_services, f,	\
+		__efi_early()->runtime_services), __VA_ARGS__)
+
 extern bool efi_reboot_required(void);
 
 #else

commit 3552fdf29f01e5a889e88202dc55b67aa6766620
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Nov 12 21:32:35 2016 +0000

    efi: Allow bitness-agnostic protocol calls
    
    We already have a macro to invoke boot services which on x86 adapts
    automatically to the bitness of the EFI firmware:  efi_call_early().
    
    The macro allows sharing of functions across arches and bitness variants
    as long as those functions only call boot services.  However in practice
    functions in the EFI stub contain a mix of boot services calls and
    protocol calls.
    
    Add an efi_call_proto() macro for bitness-agnostic protocol calls to
    allow sharing more code across arches as well as deduplicating 32 bit
    and 64 bit code paths.
    
    On x86, implement it using a new efi_table_attr() macro for bitness-
    agnostic table lookups.  Refactor efi_call_early() to make use of the
    same macro.  (The resulting object code remains identical.)
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-8-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 389d700b961e..e99675b9c861 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -210,12 +210,18 @@ static inline bool efi_is_64bit(void)
 	return __efi_early()->is64;
 }
 
+#define efi_table_attr(table, attr, instance)				\
+	(efi_is_64bit() ?						\
+		((table##_64_t *)(unsigned long)instance)->attr :	\
+		((table##_32_t *)(unsigned long)instance)->attr)
+
+#define efi_call_proto(protocol, f, instance, ...)			\
+	__efi_early()->call(efi_table_attr(protocol, f, instance),	\
+		instance, ##__VA_ARGS__)
+
 #define efi_call_early(f, ...)						\
-	__efi_early()->call(efi_is_64bit() ?				\
-		((efi_boot_services_64_t *)(unsigned long)		\
-			__efi_early()->boot_services)->f :		\
-		((efi_boot_services_32_t *)(unsigned long)		\
-			__efi_early()->boot_services)->f, __VA_ARGS__)
+	__efi_early()->call(efi_table_attr(efi_boot_services, f,	\
+		__efi_early()->boot_services), __VA_ARGS__)
 
 #define __efi_call_early(f, ...)					\
 	__efi_early()->call((unsigned long)f, __VA_ARGS__);

commit 0a637ee61247bd4bed9b2a07568ef7a1cfc76187
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Aug 22 12:01:21 2016 +0200

    x86/efi: Allow invocation of arbitrary boot services
    
    We currently allow invocation of 8 boot services with efi_call_early().
    Not included are LocateHandleBuffer and LocateProtocol in particular.
    For graphics output or to retrieve PCI ROMs and Apple device properties,
    we're thus forced to use the LocateHandle + AllocatePool + LocateHandle
    combo, which is cumbersome and needs more code.
    
    The ARM folks allow invocation of the full set of boot services but are
    restricted to our 8 boot services in functions shared across arches.
    
    Thus, rather than adding just LocateHandleBuffer and LocateProtocol to
    struct efi_config, let's rework efi_call_early() to allow invocation of
    arbitrary boot services by selecting the 64 bit vs 32 bit code path in
    the macro itself.
    
    When compiling for 32 bit or for 64 bit without mixed mode, the unused
    code path is optimized away and the binary code is the same as before.
    But on 64 bit with mixed mode enabled, this commit adds one compare
    instruction to each invocation of a boot service and, depending on the
    code path selected, two jump instructions. (Most of the time gcc
    arranges the jumps in the 32 bit code path.) The result is a minuscule
    performance penalty and the binary code becomes slightly larger and more
    difficult to read when disassembled. This isn't a hot path, so these
    drawbacks are arguably outweighed by the attainable simplification of
    the C code. We have some overhead anyway for thunking or conversion
    between calling conventions.
    
    The 8 boot services can consequently be removed from struct efi_config.
    
    No functional change intended (for now).
    
    Example -- invocation of free_pool before (64 bit code path):
    0x2d4      movq  %ds:efi_early, %rdx          ; efi_early
    0x2db      movq  %ss:arg_0-0x20(%rsp), %rsi
    0x2e0      xorl  %eax, %eax
    0x2e2      movq  %ds:0x28(%rdx), %rdi         ; efi_early->free_pool
    0x2e6      callq *%ds:0x58(%rdx)              ; efi_early->call()
    
    Example -- invocation of free_pool after (64 / 32 bit mixed code path):
    0x0dc      movq  %ds:efi_early, %rax          ; efi_early
    0x0e3      cmpb  $0, %ds:0x28(%rax)           ; !efi_early->is64 ?
    0x0e7      movq  %ds:0x20(%rax), %rdx         ; efi_early->call()
    0x0eb      movq  %ds:0x10(%rax), %rax         ; efi_early->boot_services
    0x0ef      je    $0x150
    0x0f1      movq  %ds:0x48(%rax), %rdi         ; free_pool (64 bit)
    0x0f5      xorl  %eax, %eax
    0x0f7      callq *%rdx
    ...
    0x150      movl  %ds:0x30(%rax), %edi         ; free_pool (32 bit)
    0x153      jmp   $0x0f5
    
    Size of eboot.o text section:
    CONFIG_X86_32:                         6464 before, 6318 after
    CONFIG_X86_64 && !CONFIG_EFI_MIXED:    7670 before, 7573 after
    CONFIG_X86_64 &&  CONFIG_EFI_MIXED:    7670 before, 8319 after
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index f14655e7726a..389d700b961e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -191,14 +191,7 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 struct efi_config {
 	u64 image_handle;
 	u64 table;
-	u64 allocate_pool;
-	u64 allocate_pages;
-	u64 get_memory_map;
-	u64 free_pool;
-	u64 free_pages;
-	u64 locate_handle;
-	u64 handle_protocol;
-	u64 exit_boot_services;
+	u64 boot_services;
 	u64 text_output;
 	efi_status_t (*call)(unsigned long, ...);
 	bool is64;
@@ -218,7 +211,11 @@ static inline bool efi_is_64bit(void)
 }
 
 #define efi_call_early(f, ...)						\
-	__efi_early()->call(__efi_early()->f, __VA_ARGS__);
+	__efi_early()->call(efi_is_64bit() ?				\
+		((efi_boot_services_64_t *)(unsigned long)		\
+			__efi_early()->boot_services)->f :		\
+		((efi_boot_services_32_t *)(unsigned long)		\
+			__efi_early()->boot_services)->f, __VA_ARGS__)
 
 #define __efi_call_early(f, ...)					\
 	__efi_early()->call((unsigned long)f, __VA_ARGS__);

commit 27571616385af9c2d6a3e570b06baf86f5aa04b1
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 6 08:05:32 2016 +0200

    x86/efi: Optimize away setup_gop32/64 if unused
    
    Commit 2c23b73c2d02 ("x86/efi: Prepare GOP handling code for reuse
    as generic code") introduced an efi_is_64bit() macro to x86 which
    previously only existed for arm arches.  The macro is used to
    choose between the 64 bit or 32 bit code path in gop.c at runtime.
    
    However the code path that's going to be taken is known at compile
    time when compiling for x86_32 or for x86_64 with mixed mode disabled.
    Amend the macro to eliminate the unused code path in those cases.
    
    Size of gop.o text section:
    CONFIG_X86_32:                         1758 before, 1299 after
    CONFIG_X86_64 && !CONFIG_EFI_MIXED:    2201 before, 1406 after
    CONFIG_X86_64 &&  CONFIG_EFI_MIXED:    2201 before and after
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 4630e2bfa8fb..f14655e7726a 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -206,14 +206,23 @@ struct efi_config {
 
 __pure const struct efi_config *__efi_early(void);
 
+static inline bool efi_is_64bit(void)
+{
+	if (!IS_ENABLED(CONFIG_X86_64))
+		return false;
+
+	if (!IS_ENABLED(CONFIG_EFI_MIXED))
+		return true;
+
+	return __efi_early()->is64;
+}
+
 #define efi_call_early(f, ...)						\
 	__efi_early()->call(__efi_early()->f, __VA_ARGS__);
 
 #define __efi_call_early(f, ...)					\
 	__efi_early()->call((unsigned long)f, __VA_ARGS__);
 
-#define efi_is_64bit()		__efi_early()->is64
-
 extern bool efi_reboot_required(void);
 
 #else

commit 9479c7cebfb568f8b8b424be7f1cac120e9eea95
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Feb 26 21:22:05 2016 +0000

    efi: Refactor efi_memmap_init_early() into arch-neutral code
    
    Every EFI architecture apart from ia64 needs to setup the EFI memory
    map at efi.memmap, and the code for doing that is essentially the same
    across all implementations. Therefore, it makes sense to factor this
    out into the common code under drivers/firmware/efi/.
    
    The only slight variation is the data structure out of which we pull
    the initial memory map information, such as physical address, memory
    descriptor size and version, etc. We can address this by passing a
    generic data structure (struct efi_memory_map_data) as the argument to
    efi_memmap_init_early() which contains the minimum info required for
    initialising the memory map.
    
    In the process, this patch also fixes a few undesirable implementation
    differences:
    
     - ARM and arm64 were failing to clear the EFI_MEMMAP bit when
       unmapping the early EFI memory map. EFI_MEMMAP indicates whether
       the EFI memory map is mapped (not the regions contained within) and
       can be traversed.  It's more correct to set the bit as soon as we
       memremap() the passed in EFI memmap.
    
     - Rename efi_unmmap_memmap() to efi_memmap_unmap() to adhere to the
       regular naming scheme.
    
    This patch also uses a read-write mapping for the memory map instead
    of the read-only mapping currently used on ARM and arm64. x86 needs
    the ability to update the memory map in-place when assigning virtual
    addresses to regions (efi_map_region()) and tagging regions when
    reserving boot services (efi_reserve_boot_services()).
    
    There's no way for the generic fake_mem code to know which mapping to
    use without introducing some arch-specific constant/hook, so just use
    read-write since read-only is of dubious value for the EFI memory map.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index d0bb76d81402..4630e2bfa8fb 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -117,7 +117,6 @@ extern int __init efi_memblock_x86_reserve_range(void);
 extern pgd_t * __init efi_call_phys_prolog(void);
 extern void __init efi_call_phys_epilog(pgd_t *save_pgd);
 extern void __init efi_print_memmap(void);
-extern void __init efi_unmap_memmap(void);
 extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);

commit 0f657262d5f99ad86b9a63fb5dcd29036c2ed916
Merge: 425dbc6db34d 55920d31f1e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 15:34:18 2016 -0700

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 mm updates from Ingo Molnar:
     "Various x86 low level modifications:
    
       - preparatory work to support virtually mapped kernel stacks (Andy
         Lutomirski)
    
       - support for 64-bit __get_user() on 32-bit kernels (Benjamin
         LaHaise)
    
       - (involved) workaround for Knights Landing CPU erratum (Dave Hansen)
    
       - MPX enhancements (Dave Hansen)
    
       - mremap() extension to allow remapping of the special VDSO vma, for
         purposes of user level context save/restore (Dmitry Safonov)
    
       - hweight and entry code cleanups (Borislav Petkov)
    
       - bitops code generation optimizations and cleanups with modern GCC
         (H. Peter Anvin)
    
       - syscall entry code optimizations (Paolo Bonzini)"
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (43 commits)
      x86/mm/cpa: Add missing comment in populate_pdg()
      x86/mm/cpa: Fix populate_pgd(): Stop trying to deallocate failed PUDs
      x86/syscalls: Add compat_sys_preadv64v2/compat_sys_pwritev64v2
      x86/smp: Remove unnecessary initialization of thread_info::cpu
      x86/smp: Remove stack_smp_processor_id()
      x86/uaccess: Move thread_info::addr_limit to thread_struct
      x86/dumpstack: Rename thread_struct::sig_on_uaccess_error to sig_on_uaccess_err
      x86/uaccess: Move thread_info::uaccess_err and thread_info::sig_on_uaccess_err to thread_struct
      x86/dumpstack: When OOPSing, rewind the stack before do_exit()
      x86/mm/64: In vmalloc_fault(), use CR3 instead of current->active_mm
      x86/dumpstack/64: Handle faults when printing the "Stack: " part of an OOPS
      x86/dumpstack: Try harder to get a call trace on stack overflow
      x86/mm: Remove kernel_unmap_pages_in_pgd() and efi_cleanup_page_tables()
      x86/mm/cpa: In populate_pgd(), don't set the PGD entry until it's populated
      x86/mm/hotplug: Don't remove PGD entries in remove_pagetable()
      x86/mm: Use pte_none() to test for empty PTE
      x86/mm: Disallow running with 32-bit PTEs to work around erratum
      x86/mm: Ignore A/D bits in pte/pmd/pud_none()
      x86/mm: Move swap offset/type up in PTE to work around erratum
      x86/entry: Inline enter_from_user_mode()
      ...

commit d92fc69ccac4c0a20679fdbdc81b2010685a6f33
Author: Andy Lutomirski <luto@kernel.org>
Date:   Thu Jul 14 13:22:51 2016 -0700

    x86/mm: Remove kernel_unmap_pages_in_pgd() and efi_cleanup_page_tables()
    
    kernel_unmap_pages_in_pgd() is dangerous: if a PGD entry in
    init_mm.pgd were to be cleared, callers would need to ensure that
    the pgd entry hadn't been propagated to any other pgd.
    
    Its only caller was efi_cleanup_page_tables(), and that, in turn,
    was unused, so just delete both functions.  This leaves a couple of
    other helpers unused, so delete them, too.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Borislav Petkov <bp@suse.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/77ff20fdde3b75cd393be5559ad8218870520248.1468527351.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 78d1e7467eae..45ea38df86d4 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -125,7 +125,6 @@ extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
 extern int __init efi_alloc_page_tables(void);
 extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
-extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_update_mappings(void);

commit 80e75596079f0a41f905836ad0ccaac68ba33612
Author: Alex Thorlton <athorlton@sgi.com>
Date:   Sat Jun 25 08:20:27 2016 +0100

    efi: Convert efi_call_virt() to efi_call_virt_pointer()
    
    This commit makes a few slight modifications to the efi_call_virt() macro
    to get it to work with function pointers that are stored in locations
    other than efi.systab->runtime, and renames the macro to
    efi_call_virt_pointer().  The majority of the changes here are to pull
    these macros up into header files so that they can be accessed from
    outside of drivers/firmware/efi/runtime-wrappers.c.
    
    The most significant change not directly related to the code move is to
    add an extra "p" argument into the appropriate efi_call macros, and use
    that new argument in place of the, formerly hard-coded,
    efi.systab->runtime pointer.
    
    The last piece of the puzzle was to add an efi_call_virt() macro back into
    drivers/firmware/efi/runtime-wrappers.c to wrap around the new
    efi_call_virt_pointer() macro - this was mainly to keep the code from
    looking too cluttered by adding a bunch of extra references to
    efi.systab->runtime everywhere.
    
    Note that I also broke up the code in the efi_call_virt_pointer() macro a
    bit in the process of moving it.
    
    Signed-off-by: Alex Thorlton <athorlton@sgi.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roy Franz <roy.franz@linaro.org>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1466839230-12781-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 78d1e7467eae..55b4596ef688 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -41,10 +41,9 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
  */
-#define arch_efi_call_virt(f, args...)					\
+#define arch_efi_call_virt(p, f, args...)				\
 ({									\
-	((efi_##f##_t __attribute__((regparm(0)))*)			\
-		efi.systab->runtime->f)(args);				\
+	((efi_##f##_t __attribute__((regparm(0)))*) p->f)(args);	\
 })
 
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
@@ -81,8 +80,8 @@ struct efi_scratch {
 	}								\
 })
 
-#define arch_efi_call_virt(f, args...)					\
-	efi_call((void *)efi.systab->runtime->f, args)			\
+#define arch_efi_call_virt(p, f, args...)				\
+	efi_call((void *)p->f, args)					\
 
 #define arch_efi_call_virt_teardown()					\
 ({									\

commit 9788375dc4cdc9c00645028384fb40402eab774f
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Apr 25 21:07:11 2016 +0100

    x86/efi: Enable runtime call flag checking
    
    Define ARCH_EFI_IRQ_FLAGS_MASK for x86, which will enable the generic
    runtime wrapper code to detect when firmware erroneously modifies flags
    over a runtime services function call.
    
    For x86 (both 32-bit and 64-bit), we only need check the interrupt flag.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Harald Hoyer harald@redhat.com
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Raphael Hertzog <hertzog@debian.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-40-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index fb085ce00bd2..78d1e7467eae 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -3,6 +3,7 @@
 
 #include <asm/fpu/api.h>
 #include <asm/pgtable.h>
+#include <asm/processor-flags.h>
 #include <asm/tlb.h>
 
 /*
@@ -28,8 +29,9 @@
 
 #define MAX_CMDLINE_ADDRESS	UINT_MAX
 
-#ifdef CONFIG_X86_32
+#define ARCH_EFI_IRQ_FLAGS_MASK	X86_EFLAGS_IF
 
+#ifdef CONFIG_X86_32
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 

commit bc25f9dba149a1392b016a6d35300c8d79177298
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Apr 25 21:07:06 2016 +0100

    x86/efi: Move to generic {__,}efi_call_virt()
    
    Now there's a common template for {__,}efi_call_virt(), remove the
    duplicate logic from the x86 EFI code.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-35-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 8747abe8872f..fb085ce00bd2 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -33,28 +33,16 @@
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
+#define arch_efi_call_virt_setup()	kernel_fpu_begin()
+#define arch_efi_call_virt_teardown()	kernel_fpu_end()
+
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
  */
-
-/* Use this macro if your virtual returns a non-void value */
-#define efi_call_virt(f, args...) \
-({									\
-	efi_status_t __s;						\
-	kernel_fpu_begin();						\
-	__s = ((efi_##f##_t __attribute__((regparm(0)))*)		\
-		efi.systab->runtime->f)(args);				\
-	kernel_fpu_end();						\
-	__s;								\
-})
-
-/* Use this macro if your virtual call does not return any value */
-#define __efi_call_virt(f, args...) \
+#define arch_efi_call_virt(f, args...)					\
 ({									\
-	kernel_fpu_begin();						\
 	((efi_##f##_t __attribute__((regparm(0)))*)			\
 		efi.systab->runtime->f)(args);				\
-	kernel_fpu_end();						\
 })
 
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
@@ -78,10 +66,8 @@ struct efi_scratch {
 	u64	phys_stack;
 } __packed;
 
-#define efi_call_virt(f, ...)						\
+#define arch_efi_call_virt_setup()					\
 ({									\
-	efi_status_t __s;						\
-									\
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
@@ -91,9 +77,13 @@ struct efi_scratch {
 		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
 		__flush_tlb_all();					\
 	}								\
-									\
-	__s = efi_call((void *)efi.systab->runtime->f, __VA_ARGS__);	\
-									\
+})
+
+#define arch_efi_call_virt(f, args...)					\
+	efi_call((void *)efi.systab->runtime->f, args)			\
+
+#define arch_efi_call_virt_teardown()					\
+({									\
 	if (efi_scratch.use_pgd) {					\
 		write_cr3(efi_scratch.prev_cr3);			\
 		__flush_tlb_all();					\
@@ -101,15 +91,8 @@ struct efi_scratch {
 									\
 	__kernel_fpu_end();						\
 	preempt_enable();						\
-	__s;								\
 })
 
-/*
- * All X86_64 virt calls return non-void values. Thus, use non-void call for
- * virt calls that would be void on X86_32.
- */
-#define __efi_call_virt(f, args...) efi_call_virt(f, args)
-
 extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 					u32 type, u64 attribute);
 

commit 21289ec02b41c4b928a0b3de1778b325d714eea3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:50 2016 +0100

    x86/efi/efifb: Move DMI based quirks handling out of generic code
    
    The efifb quirks handling based on DMI identification of the platform is
    specific to x86, so move it to x86 arch code.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-19-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 10e440770371..8747abe8872f 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -180,6 +180,8 @@ static inline bool efi_runtime_supported(void)
 extern struct console early_efi_console;
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 
+extern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);
+
 #ifdef CONFIG_EFI_MIXED
 extern void efi_thunk_runtime_setup(void);
 extern efi_status_t efi_thunk_set_virtual_address_map(

commit 2c23b73c2d0249c499c4784b6db08dcfc6b7b3b0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:48 2016 +0100

    x86/efi: Prepare GOP handling code for reuse as generic code
    
    In preparation of moving this code to drivers/firmware/efi and reusing
    it on ARM and arm64, apply any changes that will be required to make this
    code build for other architectures. This should make it easier to track
    down problems that this move may cause to its operation on x86.
    
    Note that the generic version uses slightly different ways of casting the
    protocol methods and some other variables to the correct types, since such
    method calls are not loosely typed on ARM and arm64 as they are on x86.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-17-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 53748c45e488..10e440770371 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -225,6 +225,11 @@ __pure const struct efi_config *__efi_early(void);
 #define efi_call_early(f, ...)						\
 	__efi_early()->call(__efi_early()->f, __VA_ARGS__);
 
+#define __efi_call_early(f, ...)					\
+	__efi_early()->call((unsigned long)f, __VA_ARGS__);
+
+#define efi_is_64bit()		__efi_early()->is64
+
 extern bool efi_reboot_required(void);
 
 #else

commit 24b5e20f11a75866bbffc46c30a22fa50612a769
Merge: 26660a4046b1 d367cef0a7f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 20 18:58:18 2016 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes are:
    
       - Use separate EFI page tables when executing EFI firmware code.
         This isolates the EFI context from the rest of the kernel, which
         has security and general robustness advantages.  (Matt Fleming)
    
       - Run regular UEFI firmware with interrupts enabled.  This is already
         the status quo under other OSs.  (Ard Biesheuvel)
    
       - Various x86 EFI enhancements, such as the use of non-executable
         attributes for EFI memory mappings.  (Sai Praneeth Prakhya)
    
       - Various arm64 UEFI enhancements.  (Ard Biesheuvel)
    
       - ... various fixes and cleanups.
    
      The separate EFI page tables feature got delayed twice already,
      because it's an intrusive change and we didn't feel confident about
      it - third time's the charm we hope!"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU
      x86/efi: Only map kernel text for EFI mixed mode
      x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
      x86/mm/pat: Don't implicitly allow _PAGE_RW in kernel_map_pages_in_pgd()
      efi/arm*: Perform hardware compatibility check
      efi/arm64: Check for h/w support before booting a >4 KB granular kernel
      efi/arm: Check for LPAE support before booting a LPAE kernel
      efi/arm-init: Use read-only early mappings
      efi/efistub: Prevent __init annotations from being used
      arm64/vmlinux.lds.S: Handle .init.rodata.xxx and .init.bss sections
      efi/arm64: Drop __init annotation from handle_kernel_image()
      x86/mm/pat: Use _PAGE_GLOBAL bit for EFI page table mappings
      efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled
      efi: Reformat GUID tables to follow the format in UEFI spec
      efi: Add Persistent Memory type name
      efi: Add NV memory attribute
      x86/efi: Show actual ending addresses in efi_print_memmap
      x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0
      efivars: Use to_efivar_entry
      efi: Runtime-wrapper: Get rid of the rtc_lock spinlock
      ...

commit 48fcb2d0216103d15306caa4814e2381104df6d8
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Jan 11 11:47:49 2016 +0100

    efi: stub: use high allocation for converted command line
    
    Before we can move the command line processing before the allocation
    of the kernel, which is required for detecting the 'nokaslr' option
    which controls that allocation, move the converted command line higher
    up in memory, to prevent it from interfering with the kernel itself.
    
    Since x86 needs the address to fit in 32 bits, use UINT_MAX as the upper
    bound there. Otherwise, use ULONG_MAX (i.e., no limit)
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0010c78c4998..08b1f2f6ea50 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -25,6 +25,8 @@
 #define EFI32_LOADER_SIGNATURE	"EL32"
 #define EFI64_LOADER_SIGNATURE	"EL64"
 
+#define MAX_CMDLINE_ADDRESS	UINT_MAX
+
 #ifdef CONFIG_X86_32
 
 

commit 6d0cc887d571e96f928be83f094322451fd4bf6f
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Feb 17 12:36:05 2016 +0000

    x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
    
    Now that we have EFI memory region bits that indicate which regions do
    not need execute permission or read/write permission in the page tables,
    let's use them.
    
    We also check for EFI_NX_PE_DATA and only enforce the restrictive
    mappings if it's present (to allow us to ignore buggy firmware that sets
    bits it didn't mean to and to preserve backwards compatibility).
    
    Instead of assuming that firmware would set appropriate attributes in
    memory descriptor like EFI_MEMORY_RO for code and EFI_MEMORY_XP for
    data, we can expect some firmware out there which might only set *type*
    in memory descriptor to be EFI_RUNTIME_SERVICES_CODE or
    EFI_RUNTIME_SERVICES_DATA leaving away attribute. This will lead to
    improper mappings of EFI runtime regions. In order to avoid it, we check
    attribute and type of memory descriptor to update mappings and moreover
    Windows works this way.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Lee, Chun-Yi <jlee@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1455712566-16727-13-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 8fd9e637629a..7bb206f73915 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -141,7 +141,7 @@ extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pa
 extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
-extern void __init efi_runtime_mkexec(void);
+extern void __init efi_runtime_update_mappings(void);
 extern void __init efi_dump_pagetable(void);
 extern void __init efi_apply_memmap_quirks(void);
 extern int __init efi_reuse_config(u64 tables, int nr_tables);

commit 67a9108ed4313b85a9c53406d80dc1ae3f8c3e36
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Nov 27 21:09:34 2015 +0000

    x86/efi: Build our own page table structures
    
    With commit e1a58320a38d ("x86/mm: Warn on W^X mappings") all
    users booting on 64-bit UEFI machines see the following warning,
    
      ------------[ cut here ]------------
      WARNING: CPU: 7 PID: 1 at arch/x86/mm/dump_pagetables.c:225 note_page+0x5dc/0x780()
      x86/mm: Found insecure W+X mapping at address ffff88000005f000/0xffff88000005f000
      ...
      x86/mm: Checked W+X mappings: FAILED, 165660 W+X pages found.
      ...
    
    This is caused by mapping EFI regions with RWX permissions.
    There isn't much we can do to restrict the permissions for these
    regions due to the way the firmware toolchains mix code and
    data, but we can at least isolate these mappings so that they do
    not appear in the regular kernel page tables.
    
    In commit d2f7cbe7b26a ("x86/efi: Runtime services virtual
    mapping") we started using 'trampoline_pgd' to map the EFI
    regions because there was an existing identity mapping there
    which we use during the SetVirtualAddressMap() call and for
    broken firmware that accesses those addresses.
    
    But 'trampoline_pgd' shares some PGD entries with
    'swapper_pg_dir' and does not provide the isolation we require.
    Notably the virtual address for __START_KERNEL_map and
    MODULES_START are mapped by the same PGD entry so we need to be
    more careful when copying changes over in
    efi_sync_low_kernel_mappings().
    
    This patch doesn't go the full mile, we still want to share some
    PGD entries with 'swapper_pg_dir'. Having completely separate
    page tables brings its own issues such as synchronising new
    mappings after memory hotplug and module loading. Sharing also
    keeps memory usage down.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1448658575-17029-6-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 347eeacb06a8..8fd9e637629a 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -136,6 +136,7 @@ extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
+extern int __init efi_alloc_page_tables(void);
 extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);

commit c9f2a9a65e4855b74d92cdad688f6ee4a1a323ff
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Nov 27 21:09:33 2015 +0000

    x86/efi: Hoist page table switching code into efi_call_virt()
    
    This change is a prerequisite for pending patches that switch to
    a dedicated EFI page table, instead of using 'trampoline_pgd'
    which shares PGD entries with 'swapper_pg_dir'. The pending
    patches make it impossible to dereference the runtime service
    function pointer without first switching %cr3.
    
    It's true that we now have duplicated switching code in
    efi_call_virt() and efi_call_phys_{prolog,epilog}() but we are
    sacrificing code duplication for a little more clarity and the
    ease of writing the page table switching code in C instead of
    asm.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1448658575-17029-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0010c78c4998..347eeacb06a8 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -3,6 +3,7 @@
 
 #include <asm/fpu/api.h>
 #include <asm/pgtable.h>
+#include <asm/tlb.h>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
@@ -64,6 +65,17 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 
 #define efi_call_phys(f, args...)		efi_call((f), args)
 
+/*
+ * Scratch space used for switching the pagetable in the EFI stub
+ */
+struct efi_scratch {
+	u64	r15;
+	u64	prev_cr3;
+	pgd_t	*efi_pgt;
+	bool	use_pgd;
+	u64	phys_stack;
+} __packed;
+
 #define efi_call_virt(f, ...)						\
 ({									\
 	efi_status_t __s;						\
@@ -71,7 +83,20 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
+									\
+	if (efi_scratch.use_pgd) {					\
+		efi_scratch.prev_cr3 = read_cr3();			\
+		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
+		__flush_tlb_all();					\
+	}								\
+									\
 	__s = efi_call((void *)efi.systab->runtime->f, __VA_ARGS__);	\
+									\
+	if (efi_scratch.use_pgd) {					\
+		write_cr3(efi_scratch.prev_cr3);			\
+		__flush_tlb_all();					\
+	}								\
+									\
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 	__s;								\

commit 790a2ee2427852cff50993c98f15ed88511e9af0
Merge: c7d77a7980e4 0f96a99dab36
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Oct 14 16:05:40 2015 +0200

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into core/efi
    
    Pull v4.4 EFI updates from Matt Fleming:
    
      - Make the EFI System Resource Table (ESRT) driver explicitly
        non-modular by ripping out the module_* code since Kconfig doesn't
        allow it to be built as a module anyway. (Paul Gortmaker)
    
      - Make the x86 efi=debug kernel parameter, which enables EFI debug
        code and output, generic and usable by arm64. (Leif Lindholm)
    
      - Add support to the x86 EFI boot stub for 64-bit Graphics Output
        Protocol frame buffer addresses. (Matt Fleming)
    
      - Detect when the UEFI v2.5 EFI_PROPERTIES_TABLE feature is enabled
        in the firmware and set an efi.flags bit so the kernel knows when
        it can apply more strict runtime mapping attributes - Ard Biesheuvel
    
      - Auto-load the efi-pstore module on EFI systems, just like we
        currently do for the efivars module. (Ben Hutchings)
    
      - Add "efi_fake_mem" kernel parameter which allows the system's EFI
        memory map to be updated with additional attributes for specific
        memory ranges. This is useful for testing the kernel code that handles
        the EFI_MEMORY_MORE_RELIABLE memmap bit even if your firmware
        doesn't include support. (Taku Izumi)
    
    Note: there is a semantic conflict between the following two commits:
    
      8a53554e12e9 ("x86/efi: Fix multiple GOP device support")
      ae2ee627dc87 ("efifb: Add support for 64-bit frame buffer addresses")
    
    I fixed up the interaction in the merge commit, changing the type of
    current_fb_base from u32 to u64.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0bbea1ce98ed44779736ecc54ca9cdbca2b95544
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Wed Sep 30 19:20:00 2015 +0900

    x86/efi: Rename print_efi_memmap() to efi_print_memmap()
    
    This patch renames print_efi_memmap() to efi_print_memmap() and
    make it global function so that we can invoke it outside of
    arch/x86/platform/efi/efi.c
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 155162ea0e00..cfee9d4b02af 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -93,6 +93,7 @@ extern void __init efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int __init efi_memblock_x86_reserve_range(void);
 extern pgd_t * __init efi_call_phys_prolog(void);
 extern void __init efi_call_phys_epilog(pgd_t *save_pgd);
+extern void __init efi_print_memmap(void);
 extern void __init efi_unmap_memmap(void);
 extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);

commit a523841ee4e506fa1f05ff3a85b1e6d8176a3d4d
Author: Andrey Ryabinin <ryabinin.a.a@gmail.com>
Date:   Thu Oct 1 15:36:48 2015 -0700

    arch/x86/include/asm/efi.h: fix build failure
    
    With KMEMCHECK=y, KASAN=n:
    
      arch/x86/platform/efi/efi.c:673:3: error: implicit declaration of function `memcpy' [-Werror=implicit-function-declaration]
      arch/x86/platform/efi/efi_64.c:139:2: error: implicit declaration of function `memcpy' [-Werror=implicit-function-declaration]
      arch/x86/include/asm/desc.h:121:2: error: implicit declaration of function `memcpy' [-Werror=implicit-function-declaration]
    
    Don't #undef memcpy if KASAN=n.
    
    Fixes: 769a8089c1fd ("x86, efi, kasan: #undef memset/memcpy/memmove per arch")
    Signed-off-by: Andrey Ryabinin <ryabinin.a.a@gmail.com>
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index ab5f1d447ef9..ae68be92f755 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -86,6 +86,7 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 					u32 type, u64 attribute);
 
+#ifdef CONFIG_KASAN
 /*
  * CONFIG_KASAN may redefine memset to __memset.  __memset function is present
  * only in kernel binary.  Since the EFI stub linked into a separate binary it
@@ -95,6 +96,7 @@ extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 #undef memcpy
 #undef memset
 #undef memmove
+#endif
 
 #endif /* CONFIG_X86_32 */
 

commit 769a8089c1fd2fe94c13e66fe6e03d7820953ee3
Author: Andrey Ryabinin <ryabinin.a.a@gmail.com>
Date:   Tue Sep 22 14:59:17 2015 -0700

    x86, efi, kasan: #undef memset/memcpy/memmove per arch
    
    In not-instrumented code KASAN replaces instrumented memset/memcpy/memmove
    with not-instrumented analogues __memset/__memcpy/__memove.
    
    However, on x86 the EFI stub is not linked with the kernel.  It uses
    not-instrumented mem*() functions from arch/x86/boot/compressed/string.c
    
    So we don't replace them with __mem*() variants in EFI stub.
    
    On ARM64 the EFI stub is linked with the kernel, so we should replace
    mem*() functions with __mem*(), because the EFI stub runs before KASAN
    sets up early shadow.
    
    So let's move these #undef mem* into arch's asm/efi.h which is also
    included by the EFI stub.
    
    Also, this will fix the warning in 32-bit build reported by kbuild test
    robot:
    
            efi-stub-helper.c:599:2: warning: implicit declaration of function 'memcpy'
    
    [akpm@linux-foundation.org: use 80 cols in comment]
    Signed-off-by: Andrey Ryabinin <ryabinin.a.a@gmail.com>
    Reported-by: Fengguang Wu <fengguang.wu@gmail.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 155162ea0e00..ab5f1d447ef9 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -86,6 +86,16 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 					u32 type, u64 attribute);
 
+/*
+ * CONFIG_KASAN may redefine memset to __memset.  __memset function is present
+ * only in kernel binary.  Since the EFI stub linked into a separate binary it
+ * doesn't have __memset().  So we should use standard memset from
+ * arch/x86/boot/compressed/string.c.  The same applies to memcpy and memmove.
+ */
+#undef memcpy
+#undef memset
+#undef memmove
+
 #endif /* CONFIG_X86_32 */
 
 extern struct efi_scratch efi_scratch;

commit df6b35f409af0a8ff1ef62f552b8402f3fef8665
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Apr 24 02:46:00 2015 +0200

    x86/fpu: Rename i387.h to fpu/api.h
    
    We already have fpu/types.h, move i387.h to fpu/api.h.
    
    The file name has become a misnomer anyway: it offers generic FPU APIs,
    but is not limited to i387 functionality.
    
    Reviewed-by: Borislav Petkov <bp@alien8.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3738b138b843..155162ea0e00 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -1,7 +1,7 @@
 #ifndef _ASM_X86_EFI_H
 #define _ASM_X86_EFI_H
 
-#include <asm/i387.h>
+#include <asm/fpu/api.h>
 #include <asm/pgtable.h>
 
 /*

commit 744937b0b12a669f298949c4a810794c59fead98
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Mar 3 07:48:50 2015 +0100

    efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction
    
    Currently x86-64 efi_call_phys_prolog() saves into a global variable (save_pgd),
    and efi_call_phys_epilog() restores the kernel pagetables from that global
    variable.
    
    Change this to a cleaner save/restore pattern where the saving function returns
    the saved object and the restore function restores that.
    
    Apply the same concept to the 32-bit code as well.
    
    Plus this approach, as an added bonus, allows us to express the
    !efi_enabled(EFI_OLD_MEMMAP) situation in a clean fashion as well,
    via a 'NULL' return value.
    
    Cc: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 25bce45c6fc4..3738b138b843 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -2,6 +2,8 @@
 #define _ASM_X86_EFI_H
 
 #include <asm/i387.h>
+#include <asm/pgtable.h>
+
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
  * with preserved alignment on virtual addresses starting from -4G down
@@ -89,8 +91,8 @@ extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 extern struct efi_scratch efi_scratch;
 extern void __init efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int __init efi_memblock_x86_reserve_range(void);
-extern void __init efi_call_phys_prolog(void);
-extern void __init efi_call_phys_epilog(void);
+extern pgd_t * __init efi_call_phys_prolog(void);
+extern void __init efi_call_phys_epilog(pgd_t *save_pgd);
 extern void __init efi_unmap_memmap(void);
 extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);

commit 243b6754cd17112bbf0724ed3c13446b48cf6a28
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Nov 5 17:00:56 2014 +0100

    efi/x86: Move x86 back to libstub
    
    This reverts commit 84be880560fb, which itself reverted my original
    attempt to move x86 from #include'ing .c files from across the tree
    to using the EFI stub built as a static library.
    
    The issue that affected the original approach was that splitting
    the implementation into several .o files resulted in the variable
    'efi_early' becoming a global with external linkage, which under
    -fPIC implies that references to it must go through the GOT. However,
    dealing with this additional GOT entry turned out to be troublesome
    on some EFI implementations. (GCC's visibility=hidden attribute is
    supposed to lift this requirement, but it turned out not to work on
    the 32-bit build.)
    
    Instead, use a pure getter function to get a reference to efi_early.
    This approach results in no additional GOT entries being generated,
    so there is no need for any changes in the early GOT handling.
    
    Tested-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 9b11757975d0..25bce45c6fc4 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -158,6 +158,30 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 }
 #endif /* CONFIG_EFI_MIXED */
 
+
+/* arch specific definitions used by the stub code */
+
+struct efi_config {
+	u64 image_handle;
+	u64 table;
+	u64 allocate_pool;
+	u64 allocate_pages;
+	u64 get_memory_map;
+	u64 free_pool;
+	u64 free_pages;
+	u64 locate_handle;
+	u64 handle_protocol;
+	u64 exit_boot_services;
+	u64 text_output;
+	efi_status_t (*call)(unsigned long, ...);
+	bool is64;
+} __packed;
+
+__pure const struct efi_config *__efi_early(void);
+
+#define efi_call_early(f, ...)						\
+	__efi_early()->call(__efi_early()->f, __VA_ARGS__);
+
 extern bool efi_reboot_required(void);
 
 #else

commit 75b128573b275d5a5a7210b98c4b8cb3b39c12e7
Merge: fe82dcec6442 7efe665903d0
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Oct 3 22:15:56 2014 +0100

    Merge branch 'next' into efi-next-merge
    
    Conflicts:
            arch/x86/boot/compressed/eboot.c

commit 60b4dc7720a5251f5dbda69ad404e0bcb3cb6bfb
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Sep 30 15:03:38 2014 +0100

    efi: Delete the in_nmi() conditional runtime locking
    
    commit 5dc3826d9f08 ("efi: Implement mandatory locking for UEFI Runtime
    Services") implemented some conditional locking when accessing variable
    runtime services that Ingo described as "pretty disgusting".
    
    The intention with the !efi_in_nmi() checks was to avoid live-locks when
    trying to write pstore crash data into an EFI variable. Such lockless
    accesses are allowed according to the UEFI specification when we're in a
    "non-recoverable" state, but whether or not things are implemented
    correctly in actual firmware implementations remains an unanswered
    question, and so it would seem sensible to avoid doing any kind of
    unsynchronized variable accesses.
    
    Furthermore, the efi_in_nmi() tests are inadequate because they don't
    account for the case where we call EFI variable services from panic or
    oops callbacks and aren't executing in NMI context. In other words,
    live-locking is still possible.
    
    Let's just remove the conditional locking altogether. Now we've got the
    ->set_variable_nonblocking() EFI variable operation we can abort if the
    runtime lock is already held. Aborting is by far the safest option.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index abba1fe1db5e..408ad6d3222e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -86,8 +86,6 @@ extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 
 #endif /* CONFIG_X86_32 */
 
-#define efi_in_nmi()	in_nmi()
-
 extern struct efi_scratch efi_scratch;
 extern void __init efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int __init efi_memblock_x86_reserve_range(void);

commit 4e78eb056136b002ecdfbbf61436fedfb8a3c76b
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Sep 7 19:42:17 2014 +0200

    x86/efi: Mark initialization code as such
    
    The 32 bit and 64 bit implementations differ in their __init annotations
    for some functions referenced from the common EFI code. Namely, the 32
    bit variant is missing some of the __init annotations the 64 bit variant
    has.
    
    To solve the colliding annotations, mark the corresponding functions in
    efi_32.c as initialization code, too -- as it is such.
    
    Actually, quite a few more functions are only used during initialization
    and therefore can be marked __init. They are therefore annotated, too.
    Also add the __init annotation to the prototypes in the efi.h header so
    users of those functions will see it's meant as initialization code
    only.
    
    This patch also fixes the "prelog" typo. ("prologue" / "epilogue" might
    be more appropriate but this is C code after all, not an opera! :D)
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index ce7b1c5ff78d..abba1fe1db5e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -81,25 +81,25 @@ extern u64 asmlinkage efi_call(void *fp, ...);
  */
 #define __efi_call_virt(f, args...) efi_call_virt(f, args)
 
-extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
-				 u32 type, u64 attribute);
+extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
+					u32 type, u64 attribute);
 
 #endif /* CONFIG_X86_32 */
 
 #define efi_in_nmi()	in_nmi()
 
 extern struct efi_scratch efi_scratch;
-extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
-extern int efi_memblock_x86_reserve_range(void);
-extern void efi_call_phys_prelog(void);
-extern void efi_call_phys_epilog(void);
-extern void efi_unmap_memmap(void);
-extern void efi_memory_uc(u64 addr, unsigned long size);
+extern void __init efi_set_executable(efi_memory_desc_t *md, bool executable);
+extern int __init efi_memblock_x86_reserve_range(void);
+extern void __init efi_call_phys_prolog(void);
+extern void __init efi_call_phys_epilog(void);
+extern void __init efi_unmap_memmap(void);
+extern void __init efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
-extern int efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
-extern void efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
+extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
+extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_mkexec(void);

commit 609206854767559ecbb1c308bbd6ef7af13d8c6e
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Sep 7 19:42:15 2014 +0200

    x86/efi: Unexport add_efi_memmap variable
    
    This variable was accidentally exported, even though it's only used in
    this compilation unit and only during initialization.
    
    Remove the bogus export, make the variable static instead and mark it
    as __initdata.
    
    Fixes: 200001eb140e ("x86 boot: only pick up additional EFI memmap...")
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 5375df643818..ce7b1c5ff78d 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -88,7 +88,6 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 
 #define efi_in_nmi()	in_nmi()
 
-extern int add_efi_memmap;
 extern struct efi_scratch efi_scratch;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);

commit 24ffd84b606dafa93a5f8f6e6dbaa06fbde11632
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Sep 7 19:42:14 2014 +0200

    x86/efi: Remove unused efi_call* macros
    
    Complement commit 62fa6e69a436 ("x86/efi: Delete most of the efi_call*
    macros") and delete the stub macros for the !CONFIG_EFI case, too. In
    fact, there are no EFI calls in this case so we don't need a dummy for
    efi_call() even.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index b39ee5f2c02d..5375df643818 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -188,16 +188,6 @@ extern struct efi_config *efi_early;
 extern bool efi_reboot_required(void);
 
 #else
-/*
- * IF EFI is not configured, have the EFI calls return -ENOSYS.
- */
-#define efi_call0(_f)					(-ENOSYS)
-#define efi_call1(_f, _a1)				(-ENOSYS)
-#define efi_call2(_f, _a1, _a2)				(-ENOSYS)
-#define efi_call3(_f, _a1, _a2, _a3)			(-ENOSYS)
-#define efi_call4(_f, _a1, _a2, _a3, _a4)		(-ENOSYS)
-#define efi_call5(_f, _a1, _a2, _a3, _a4, _a5)		(-ENOSYS)
-#define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
 static inline bool efi_reboot_required(void)
 {

commit 161485e8273001e56b2f20755ad9b6217b601fb3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Aug 4 18:16:00 2014 +0200

    efi: Implement mandatory locking for UEFI Runtime Services
    
    According to section 7.1 of the UEFI spec, Runtime Services are not fully
    reentrant, and there are particular combinations of calls that need to be
    serialized. Use a spinlock to serialize all Runtime Services with respect
    to all others, even if this is more than strictly needed.
    
    We've managed to get away without requiring a runtime services lock
    until now because most of the interactions with EFI involve EFI
    variables, and those operations are already serialised with
    __efivars->lock.
    
    Some of the assumptions underlying the decision whether locks are
    needed or not (e.g., SetVariable() against ResetSystem()) may not
    apply universally to all [new] architectures that implement UEFI.
    Rather than try to reason our way out of this, let's just implement at
    least what the spec requires in terms of locking.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 044a2fd3c5fe..b39ee5f2c02d 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -86,6 +86,8 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 
 #endif /* CONFIG_X86_32 */
 
+#define efi_in_nmi()	in_nmi()
+
 extern int add_efi_memmap;
 extern struct efi_scratch efi_scratch;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);

commit 84be880560fbbd0b6a6ef973bee85dbd4ca52198
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Sep 23 10:37:43 2014 +0100

    Revert "efi/x86: efistub: Move shared dependencies to <asm/efi.h>"
    
    This reverts commit f23cf8bd5c1f ("efi/x86: efistub: Move shared
    dependencies to <asm/efi.h>") as well as the x86 parts of commit
    f4f75ad5741f ("efi: efistub: Convert into static library").
    
    The road leading to these two reverts is long and winding.
    
    The above two commits were merged during the v3.17 merge window and
    turned the common EFI boot stub code into a static library. This
    necessitated making some symbols global in the x86 boot stub which
    introduced new entries into the early boot GOT.
    
    The problem was that we weren't fixing up the newly created GOT entries
    before invoking the EFI boot stub, which sometimes resulted in hangs or
    resets. This failure was reported by Maarten on his Macbook pro.
    
    The proposed fix was commit 9cb0e394234d ("x86/efi: Fixup GOT in all
    boot code paths"). However, that caused issues for Linus when booting
    his Sony Vaio Pro 11. It was subsequently reverted in commit
    f3670394c29f.
    
    So that leaves us back with Maarten's Macbook pro not booting.
    
    At this stage in the release cycle the least risky option is to revert
    the x86 EFI boot stub to the pre-merge window code structure where we
    explicitly #include efi-stub-helper.c instead of linking with the static
    library. The arm64 code remains unaffected.
    
    We can take another swing at the x86 parts for v3.18.
    
    Conflicts:
            arch/x86/include/asm/efi.h
    
    Tested-by: Josh Boyer <jwboyer@fedoraproject.org>
    Tested-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org> [arm64]
    Tested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>,
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 044a2fd3c5fe..0ec241ede5a2 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -159,30 +159,6 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 }
 #endif /* CONFIG_EFI_MIXED */
 
-
-/* arch specific definitions used by the stub code */
-
-struct efi_config {
-	u64 image_handle;
-	u64 table;
-	u64 allocate_pool;
-	u64 allocate_pages;
-	u64 get_memory_map;
-	u64 free_pool;
-	u64 free_pages;
-	u64 locate_handle;
-	u64 handle_protocol;
-	u64 exit_boot_services;
-	u64 text_output;
-	efi_status_t (*call)(unsigned long, ...);
-	bool is64;
-} __packed;
-
-extern struct efi_config *efi_early;
-
-#define efi_call_early(f, ...)						\
-	efi_early->call(efi_early->f, __VA_ARGS__);
-
 extern bool efi_reboot_required(void);
 
 #else

commit 44be28e9dd9880dca3e2cbf7a844f2114e67f2cb
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jun 13 12:39:55 2014 +0100

    x86/reboot: Add EFI reboot quirk for ACPI Hardware Reduced flag
    
    It appears that the BayTrail-T class of hardware requires EFI in order
    to powerdown and reboot and no other reliable method exists.
    
    This quirk is generally applicable to all hardware that has the ACPI
    Hardware Reduced bit set, since usually ACPI would be the preferred
    method.
    
    Cc: Len Brown <len.brown@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 9043f365ebf5..044a2fd3c5fe 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -183,6 +183,8 @@ extern struct efi_config *efi_early;
 #define efi_call_early(f, ...)						\
 	efi_early->call(efi_early->f, __VA_ARGS__);
 
+extern bool efi_reboot_required(void);
+
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.
@@ -195,6 +197,10 @@ extern struct efi_config *efi_early;
 #define efi_call5(_f, _a1, _a2, _a3, _a4, _a5)		(-ENOSYS)
 #define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
+static inline bool efi_reboot_required(void)
+{
+	return false;
+}
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */

commit f23cf8bd5c1f49fb12459797d88b8407af93383d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 2 14:54:40 2014 +0200

    efi/x86: efistub: Move shared dependencies to <asm/efi.h>
    
    This moves definitions depended upon both by code under arch/x86/boot
    and under drivers/firmware/efi to <asm/efi.h>. This is in preparation of
    turning the stub code under drivers/firmware/efi into a static library.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3dbf56eb540d..9043f365ebf5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -158,6 +158,31 @@ static inline efi_status_t efi_thunk_set_virtual_address_map(
 	return EFI_SUCCESS;
 }
 #endif /* CONFIG_EFI_MIXED */
+
+
+/* arch specific definitions used by the stub code */
+
+struct efi_config {
+	u64 image_handle;
+	u64 table;
+	u64 allocate_pool;
+	u64 allocate_pages;
+	u64 get_memory_map;
+	u64 free_pool;
+	u64 free_pages;
+	u64 locate_handle;
+	u64 handle_protocol;
+	u64 exit_boot_services;
+	u64 text_output;
+	efi_status_t (*call)(unsigned long, ...);
+	bool is64;
+} __packed;
+
+extern struct efi_config *efi_early;
+
+#define efi_call_early(f, ...)						\
+	efi_early->call(efi_early->f, __VA_ARGS__);
+
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.

commit eeb9db09f738993c63ecb5aedf950a1e4fe4bd3f
Author: Saurabh Tangri <saurabh.tangri@intel.com>
Date:   Mon Jun 2 05:18:35 2014 -0700

    x86/efi: Move all workarounds to a separate file quirks.c
    
    Currently, it's difficult to find all the workarounds that are
    applied when running on EFI, because they're littered throughout
    various code paths. This change moves all of them into a separate
    file with the hope that it will be come the single location for all
    our well documented quirks.
    
    Signed-off-by: Saurabh Tangri <saurabh.tangri@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 1eb5f6433ad8..3dbf56eb540d 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -104,6 +104,8 @@ extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_mkexec(void);
 extern void __init efi_dump_pagetable(void);
 extern void __init efi_apply_memmap_quirks(void);
+extern int __init efi_reuse_config(u64 tables, int nr_tables);
+extern void efi_delete_dummy_variable(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit b738c6ea49b4e98e6ca0651da82a610f996a16ae
Author: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date:   Thu Mar 27 15:10:43 2014 -0700

    x86/efi: Save and restore FPU context around efi_calls (i386)
    
    Do a complete FPU context save/restore around the EFI calls. This required
    as runtime EFI firmware may potentially use the FPU.
    
    This change covers only the i386 configuration.
    
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0b19187cc882..1eb5f6433ad8 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -34,10 +34,23 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 /* Use this macro if your virtual returns a non-void value */
 #define efi_call_virt(f, args...) \
-	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
+({									\
+	efi_status_t __s;						\
+	kernel_fpu_begin();						\
+	__s = ((efi_##f##_t __attribute__((regparm(0)))*)		\
+		efi.systab->runtime->f)(args);				\
+	kernel_fpu_end();						\
+	__s;								\
+})
 
 /* Use this macro if your virtual call does not return any value */
-#define __efi_call_virt(f, args...) efi_call_virt(f, args)
+#define __efi_call_virt(f, args...) \
+({									\
+	kernel_fpu_begin();						\
+	((efi_##f##_t __attribute__((regparm(0)))*)			\
+		efi.systab->runtime->f)(args);				\
+	kernel_fpu_end();						\
+})
 
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 

commit de05764e0b2a3d9559e099a2e134f8cef4500fdd
Author: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date:   Thu Mar 27 15:10:42 2014 -0700

    x86/efi: Save and restore FPU context around efi_calls (x86_64)
    
    Do a complete FPU context save/restore around the EFI calls. This required
    as runtime EFI firmware may potentially use the FPU.
    
    This change covers only the x86_64 configuration.
    
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 19292e7cae58..0b19187cc882 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -1,6 +1,7 @@
 #ifndef _ASM_X86_EFI_H
 #define _ASM_X86_EFI_H
 
+#include <asm/i387.h>
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
  * with preserved alignment on virtual addresses starting from -4G down
@@ -54,7 +55,9 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 									\
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
+	__kernel_fpu_begin();						\
 	__s = efi_call((void *)efi.systab->runtime->f, __VA_ARGS__);	\
+	__kernel_fpu_end();						\
 	preempt_enable();						\
 	__s;								\
 })

commit 982e239cd2c73d2c70e14615a42c0c7391415a44
Author: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date:   Thu Mar 27 15:10:41 2014 -0700

    x86/efi: Implement a __efi_call_virt macro
    
    For i386, all the EFI system runtime services functions return efi_status_t
    except efi_reset_system_system. Therefore, not all functions can be covered
    by the same macro in case the macro needs to do more than calling the function
    (i.e., return a value). The purpose of the __efi_call_virt macro is to be used
    when no return value is expected.
    
    For x86_64, this macro would not be needed as all the runtime services return
    u64. However, the same code is used for both x86_64 and i386. Thus, the macro
    __efi_call_virt is also defined to not break compilation.
    
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index e3975597b289..19292e7cae58 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -31,9 +31,13 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
  */
 
+/* Use this macro if your virtual returns a non-void value */
 #define efi_call_virt(f, args...) \
 	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
 
+/* Use this macro if your virtual call does not return any value */
+#define __efi_call_virt(f, args...) efi_call_virt(f, args)
+
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 
 #else /* !CONFIG_X86_32 */
@@ -55,6 +59,12 @@ extern u64 asmlinkage efi_call(void *fp, ...);
 	__s;								\
 })
 
+/*
+ * All X86_64 virt calls return non-void values. Thus, use non-void call for
+ * virt calls that would be void on X86_32.
+ */
+#define __efi_call_virt(f, args...) efi_call_virt(f, args)
+
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 				 u32 type, u64 attribute);
 

commit 62fa6e69a436f662090f3996538adb9e568817f6
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Thu Mar 27 15:10:39 2014 -0700

    x86/efi: Delete most of the efi_call* macros
    
    We really only need one phys and one virt function call, and then only
    one assembly function to make firmware calls.
    
    Since we are not using the C type system anyway, we're not really losing
    much by deleting the macros apart from no longer having a check that
    we are passing the correct number of parameters. The lack of duplicated
    code seems like a worthwhile trade-off.
    
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0869434eaf72..e3975597b289 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -27,16 +27,6 @@
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
-#define efi_call_phys0(f)		efi_call_phys(f)
-#define efi_call_phys1(f, a1)		efi_call_phys(f, a1)
-#define efi_call_phys2(f, a1, a2)	efi_call_phys(f, a1, a2)
-#define efi_call_phys3(f, a1, a2, a3)	efi_call_phys(f, a1, a2, a3)
-#define efi_call_phys4(f, a1, a2, a3, a4)	\
-	efi_call_phys(f, a1, a2, a3, a4)
-#define efi_call_phys5(f, a1, a2, a3, a4, a5)	\
-	efi_call_phys(f, a1, a2, a3, a4, a5)
-#define efi_call_phys6(f, a1, a2, a3, a4, a5, a6)	\
-	efi_call_phys(f, a1, a2, a3, a4, a5, a6)
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
  */
@@ -44,75 +34,27 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 #define efi_call_virt(f, args...) \
 	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
 
-#define efi_call_virt0(f)		efi_call_virt(f)
-#define efi_call_virt1(f, a1)		efi_call_virt(f, a1)
-#define efi_call_virt2(f, a1, a2)	efi_call_virt(f, a1, a2)
-#define efi_call_virt3(f, a1, a2, a3)	efi_call_virt(f, a1, a2, a3)
-#define efi_call_virt4(f, a1, a2, a3, a4)	\
-	efi_call_virt(f, a1, a2, a3, a4)
-#define efi_call_virt5(f, a1, a2, a3, a4, a5)	\
-	efi_call_virt(f, a1, a2, a3, a4, a5)
-#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
-	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
-
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 
 #else /* !CONFIG_X86_32 */
 
-extern u64 efi_call0(void *fp);
-extern u64 efi_call1(void *fp, u64 arg1);
-extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);
-extern u64 efi_call3(void *fp, u64 arg1, u64 arg2, u64 arg3);
-extern u64 efi_call4(void *fp, u64 arg1, u64 arg2, u64 arg3, u64 arg4);
-extern u64 efi_call5(void *fp, u64 arg1, u64 arg2, u64 arg3,
-		     u64 arg4, u64 arg5);
-extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
-		     u64 arg4, u64 arg5, u64 arg6);
-
-#define efi_call_phys0(f)			\
-	efi_call0((f))
-#define efi_call_phys1(f, a1)			\
-	efi_call1((f), (u64)(a1))
-#define efi_call_phys2(f, a1, a2)			\
-	efi_call2((f), (u64)(a1), (u64)(a2))
-#define efi_call_phys3(f, a1, a2, a3)				\
-	efi_call3((f), (u64)(a1), (u64)(a2), (u64)(a3))
-#define efi_call_phys4(f, a1, a2, a3, a4)				\
-	efi_call4((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
-		  (u64)(a4))
-#define efi_call_phys5(f, a1, a2, a3, a4, a5)				\
-	efi_call5((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
-		  (u64)(a4), (u64)(a5))
-#define efi_call_phys6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_call6((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
-		  (u64)(a4), (u64)(a5), (u64)(a6))
-
-#define _efi_call_virtX(x, f, ...)					\
+#define EFI_LOADER_SIGNATURE	"EL64"
+
+extern u64 asmlinkage efi_call(void *fp, ...);
+
+#define efi_call_phys(f, args...)		efi_call((f), args)
+
+#define efi_call_virt(f, ...)						\
 ({									\
 	efi_status_t __s;						\
 									\
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
-	__s = efi_call##x((void *)efi.systab->runtime->f, __VA_ARGS__);	\
+	__s = efi_call((void *)efi.systab->runtime->f, __VA_ARGS__);	\
 	preempt_enable();						\
 	__s;								\
 })
 
-#define efi_call_virt0(f)				\
-	_efi_call_virtX(0, f)
-#define efi_call_virt1(f, a1)				\
-	_efi_call_virtX(1, f, (u64)(a1))
-#define efi_call_virt2(f, a1, a2)			\
-	_efi_call_virtX(2, f, (u64)(a1), (u64)(a2))
-#define efi_call_virt3(f, a1, a2, a3)			\
-	_efi_call_virtX(3, f, (u64)(a1), (u64)(a2), (u64)(a3))
-#define efi_call_virt4(f, a1, a2, a3, a4)		\
-	_efi_call_virtX(4, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4))
-#define efi_call_virt5(f, a1, a2, a3, a4, a5)		\
-	_efi_call_virtX(5, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5))
-#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
-	_efi_call_virtX(6, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
-
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 				 u32 type, u64 attribute);
 

commit 994448f1afa6689bafbebaf7412b23b541b41ef5
Merge: 4fd69331ad22 18c46461d9e4
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Mar 5 18:15:37 2014 +0000

    Merge remote-tracking branch 'tip/x86/efi-mixed' into efi-for-mingo
    
    Conflicts:
            arch/x86/kernel/setup.c
            arch/x86/platform/efi/efi.c
            arch/x86/platform/efi/efi_64.c

commit 4fd69331ad227a4d8de26592d017b73e00caca9f
Merge: 69e608411473 0ac09f9f8cd1
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Mar 5 17:22:57 2014 +0000

    Merge remote-tracking branch 'tip/x86/urgent' into efi-for-mingo
    
    Conflicts:
            arch/x86/include/asm/efi.h

commit a5d90c923bcfb9632d998ed06e9569216ad695f3
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Mar 4 17:02:17 2014 +0100

    x86/efi: Quirk out SGI UV
    
    Alex reported hitting the following BUG after the EFI 1:1 virtual
    mapping work was merged,
    
     kernel BUG at arch/x86/mm/init_64.c:351!
     invalid opcode: 0000 [#1] SMP
     Call Trace:
      [<ffffffff818aa71d>] init_extra_mapping_uc+0x13/0x15
      [<ffffffff818a5e20>] uv_system_init+0x22b/0x124b
      [<ffffffff8108b886>] ? clockevents_register_device+0x138/0x13d
      [<ffffffff81028dbb>] ? setup_APIC_timer+0xc5/0xc7
      [<ffffffff8108b620>] ? clockevent_delta2ns+0xb/0xd
      [<ffffffff818a3a92>] ? setup_boot_APIC_clock+0x4a8/0x4b7
      [<ffffffff8153d955>] ? printk+0x72/0x74
      [<ffffffff818a1757>] native_smp_prepare_cpus+0x389/0x3d6
      [<ffffffff818957bc>] kernel_init_freeable+0xb7/0x1fb
      [<ffffffff81535530>] ? rest_init+0x74/0x74
      [<ffffffff81535539>] kernel_init+0x9/0xff
      [<ffffffff81541dfc>] ret_from_fork+0x7c/0xb0
      [<ffffffff81535530>] ? rest_init+0x74/0x74
    
    Getting this thing to work with the new mapping scheme would need more
    work, so automatically switch to the old memmap layout for SGI UV.
    
    Acked-by: Russ Anderson <rja@sgi.com>
    Cc: Alex Thorlton <athorlton@sgi.com
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3d6b9f81cc68..acd86c850414 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -134,6 +134,7 @@ extern void efi_setup_page_tables(void);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_mkexec(void);
+extern void __init efi_apply_memmap_quirks(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 7d453eee36ae4cf30fc2f2faae54f634c4f863b7
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jan 10 18:52:06 2014 +0000

    x86/efi: Wire up CONFIG_EFI_MIXED
    
    Add the Kconfig option and bump the kernel header version so that boot
    loaders can check whether the handover code is available if they want.
    
    The xloadflags field in the bzImage header is also updated to reflect
    that the kernel supports both entry points by setting both of
    XLF_EFI_HANDOVER_32 and XLF_EFI_HANDOVER_64 when CONFIG_EFI_MIXED=y.
    XLF_CAN_BE_LOADED_ABOVE_4G is disabled so that the kernel text is
    guaranteed to be addressable with 32-bits.
    
    Note that no boot loaders should be using the bits set in xloadflags to
    decide which entry point to jump to. The entire scheme is based on the
    concept that 32-bit bootloaders always jump to ->handover_offset and
    64-bit loaders always jump to ->handover_offset + 512. We set both bits
    merely to inform the boot loader that it's safe to use the native
    handover offset even if the machine type in the PE/COFF header claims
    otherwise.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 85935e6f69f3..a3837254e320 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -152,6 +152,17 @@ static inline bool efi_is_native(void)
 	return IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT);
 }
 
+static inline bool efi_runtime_supported(void)
+{
+	if (efi_is_native())
+		return true;
+
+	if (IS_ENABLED(CONFIG_EFI_MIXED) && !efi_enabled(EFI_OLD_MEMMAP))
+		return true;
+
+	return false;
+}
+
 extern struct console early_efi_console;
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 

commit 4f9dbcfc40299ddaa780fe8c1cd74998c1be3af5
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jan 10 18:48:30 2014 +0000

    x86/efi: Add mixed runtime services support
    
    Setup the runtime services based on whether we're booting in EFI native
    mode or not. For non-native mode we need to thunk from 64-bit into
    32-bit mode before invoking the EFI runtime services.
    
    Using the runtime services after SetVirtualAddressMap() is slightly more
    complicated because we need to ensure that all the addresses we pass to
    the firmware are below the 4GB boundary so that they can be addressed
    with 32-bit pointers, see efi_setup_page_tables().
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 85856868507b..85935e6f69f3 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -154,6 +154,27 @@ static inline bool efi_is_native(void)
 
 extern struct console early_efi_console;
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);
+
+#ifdef CONFIG_EFI_MIXED
+extern void efi_thunk_runtime_setup(void);
+extern efi_status_t efi_thunk_set_virtual_address_map(
+	void *phys_set_virtual_address_map,
+	unsigned long memory_map_size,
+	unsigned long descriptor_size,
+	u32 descriptor_version,
+	efi_memory_desc_t *virtual_map);
+#else
+static inline void efi_thunk_runtime_setup(void) {}
+static inline efi_status_t efi_thunk_set_virtual_address_map(
+	void *phys_set_virtual_address_map,
+	unsigned long memory_map_size,
+	unsigned long descriptor_size,
+	u32 descriptor_version,
+	efi_memory_desc_t *virtual_map)
+{
+	return EFI_SUCCESS;
+}
+#endif /* CONFIG_EFI_MIXED */
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.

commit b8ff87a6158886771677e6dc8139bac6e3cba717
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jan 10 15:54:31 2014 +0000

    x86/efi: Firmware agnostic handover entry points
    
    The EFI handover code only works if the "bitness" of the firmware and
    the kernel match, i.e. 64-bit firmware and 64-bit kernel - it is not
    possible to mix the two. This goes against the tradition that a 32-bit
    kernel can be loaded on a 64-bit BIOS platform without having to do
    anything special in the boot loader. Linux distributions, for one thing,
    regularly run only 32-bit kernels on their live media.
    
    Despite having only one 'handover_offset' field in the kernel header,
    EFI boot loaders use two separate entry points to enter the kernel based
    on the architecture the boot loader was compiled for,
    
        (1) 32-bit loader: handover_offset
        (2) 64-bit loader: handover_offset + 512
    
    Since we already have two entry points, we can leverage them to infer
    the bitness of the firmware we're running on, without requiring any boot
    loader modifications, by making (1) and (2) valid entry points for both
    CONFIG_X86_32 and CONFIG_X86_64 kernels.
    
    To be clear, a 32-bit boot loader will always use (1) and a 64-bit boot
    loader will always use (2). It's just that, if a single kernel image
    supports (1) and (2) that image can be used with both 32-bit and 64-bit
    boot loaders, and hence both 32-bit and 64-bit EFI.
    
    (1) and (2) must be 512 bytes apart at all times, but that is already
    part of the boot ABI and we could never change that delta without
    breaking existing boot loaders anyhow.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3d6b9f81cc68..85856868507b 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -19,9 +19,11 @@
  */
 #define EFI_OLD_MEMMAP		EFI_ARCH_1
 
+#define EFI32_LOADER_SIGNATURE	"EL32"
+#define EFI64_LOADER_SIGNATURE	"EL64"
+
 #ifdef CONFIG_X86_32
 
-#define EFI_LOADER_SIGNATURE	"EL32"
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
@@ -57,8 +59,6 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #else /* !CONFIG_X86_32 */
 
-#define EFI_LOADER_SIGNATURE	"EL64"
-
 extern u64 efi_call0(void *fp);
 extern u64 efi_call1(void *fp, u64 arg1);
 extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);

commit b7b898ae0c0a82489511a1ce1b35f26215e6beb5
Author: Borislav Petkov <bp@suse.de>
Date:   Sat Jan 18 12:48:17 2014 +0100

    x86/efi: Make efi virtual runtime map passing more robust
    
    Currently, running SetVirtualAddressMap() and passing the physical
    address of the virtual map array was working only by a lucky coincidence
    because the memory was present in the EFI page table too. Until Toshi
    went and booted this on a big HP box - the krealloc() manner of resizing
    the memmap we're doing did allocate from such physical addresses which
    were not mapped anymore and boom:
    
    http://lkml.kernel.org/r/1386806463.1791.295.camel@misato.fc.hp.com
    
    One way to take care of that issue is to reimplement the krealloc thing
    but with pages. We start with contiguous pages of order 1, i.e. 2 pages,
    and when we deplete that memory (shouldn't happen all that often but you
    know firmware) we realloc the next power-of-two pages.
    
    Having the pages, it is much more handy and easy to map them into the
    EFI page table with the already existing mapping code which we're using
    for building the virtual mappings.
    
    Thanks to Toshi Kani and Matt for the great debugging help.
    
    Reported-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 4afd3b3b658f..e985d6bf7d3a 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -129,7 +129,8 @@ extern void efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
-extern void efi_setup_page_tables(void);
+extern int efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
+extern void efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_mkexec(void);

commit 11cc851254b4bc3bd4430be8db2a41469303a427
Author: Borislav Petkov <bp@suse.de>
Date:   Sat Jan 18 12:48:15 2014 +0100

    x86/efi: Dump the EFI page table
    
    This is very useful for debugging issues with the recently added
    pagetable switching code for EFI virtual mode.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index a7a8bd89024e..4afd3b3b658f 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -133,6 +133,7 @@ extern void efi_setup_page_tables(void);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
 extern void __init efi_runtime_mkexec(void);
+extern void __init efi_dump_pagetable(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 3e909599215456928e6b42a04f11c2517881570b
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Jan 15 13:21:22 2014 +0000

    efi: Move facility flags to struct efi
    
    As we grow support for more EFI architectures they're going to want the
    ability to query which EFI features are available on the running system.
    Instead of storing this information in an architecture-specific place,
    stick it in the global 'struct efi', which is already the central
    location for EFI state.
    
    While we're at it, let's change the return value of efi_enabled() to be
    bool and replace all references to 'facility' with 'feature', which is
    the usual word used to describe the attributes of the running system.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3d6b9f81cc68..a7a8bd89024e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -119,7 +119,6 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;
-extern unsigned long x86_efi_facility;
 extern struct efi_scratch efi_scratch;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);

commit c55d016f7a930dd1c995336017123b469a8c8f5a
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Feb 14 08:24:24 2014 +0100

    x86/efi: Fix 32-bit fallout
    
    We do not enable the new efi memmap on 32-bit and thus we need to run
    runtime_code_page_mkexec() unconditionally there. Fix that.
    
    Reported-and-tested-by: Lejun Zhu <lejun.zhu@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 3b978c472d08..3d6b9f81cc68 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -132,6 +132,8 @@ extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
 extern void efi_setup_page_tables(void);
 extern void __init old_map_region(efi_memory_desc_t *md);
+extern void __init runtime_code_page_mkexec(void);
+extern void __init efi_runtime_mkexec(void);
 
 struct efi_setup_data {
 	u64 fw_vendor;

commit 5c12af0c41e3417e1939095325920463b5f8e726
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Jan 3 11:56:49 2014 +0800

    x86/efi: parse_efi_setup() build fix
    
    In case without CONFIG_EFI, there will be below build error:
    
       arch/x86/built-in.o: In function `setup_arch':
      (.init.text+0x9dc): undefined reference to `parse_efi_setup'
    
    Thus fix it by adding blank inline function in asm/efi.h
    Also remove an unused declaration for variable efi_data_len.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 4d1ba80b6ff1..3b978c472d08 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -142,8 +142,6 @@ struct efi_setup_data {
 };
 
 extern u64 efi_setup;
-extern u32 efi_data_len;
-extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 
 #ifdef CONFIG_EFI
 
@@ -153,7 +151,7 @@ static inline bool efi_is_native(void)
 }
 
 extern struct console early_efi_console;
-
+extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.
@@ -165,6 +163,7 @@ extern struct console early_efi_console;
 #define efi_call4(_f, _a1, _a2, _a3, _a4)		(-ENOSYS)
 #define efi_call5(_f, _a1, _a2, _a3, _a4, _a5)		(-ENOSYS)
 #define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
+static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */

commit 1fec0533693cd74f2d1a46edd29449cfee429df0
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:19 2013 +0800

    x86/efi: Pass necessary EFI data for kexec via setup_data
    
    Add a new setup_data type SETUP_EFI for kexec use.  Passing the saved
    fw_vendor, runtime, config tables and EFI runtime mappings.
    
    When entering virtual mode, directly mapping the EFI runtime regions
    which we passed in previously. And skip the step to call
    SetVirtualAddressMap().
    
    Specially for HP z420 workstation we need save the smbios physical
    address.  The kernel boot sequence proceeds in the following order.
    Step 2 requires efi.smbios to be the physical address.  However, I found
    that on HP z420 EFI system table has a virtual address of SMBIOS in step
    1.  Hence, we need set it back to the physical address with the smbios
    in efi_setup_data.  (When it is still the physical address, it simply
    sets the same value.)
    
    1. efi_init() - Set efi.smbios from EFI system table
    2. dmi_scan_machine() - Temporary map efi.smbios to access SMBIOS table
    3. efi_enter_virtual_mode() - Map EFI ranges
    
    Tested on ovmf+qemu, lenovo thinkpad, a dell laptop and an
    HP z420 workstation.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 9fbaeb239bde..4d1ba80b6ff1 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -133,6 +133,18 @@ extern void efi_sync_low_kernel_mappings(void);
 extern void efi_setup_page_tables(void);
 extern void __init old_map_region(efi_memory_desc_t *md);
 
+struct efi_setup_data {
+	u64 fw_vendor;
+	u64 runtime;
+	u64 tables;
+	u64 smbios;
+	u64 reserved[8];
+};
+
+extern u64 efi_setup;
+extern u32 efi_data_len;
+extern void parse_efi_setup(u64 phys_addr, u32 data_len);
+
 #ifdef CONFIG_EFI
 
 static inline bool efi_is_native(void)

commit 3b2664964bc886ae9d5127c8d3708b1acc0626d2
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:14 2013 +0800

    x86/efi: Add a wrapper function efi_map_region_fixed()
    
    Kexec kernel will use saved runtime virtual mapping, so add a new
    function efi_map_region_fixed() for directly mapping a md to md->virt.
    
    The md is passed in from 1st kernel, the virtual addr is saved in
    md->virt_addr.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 89a05b0507b9..9fbaeb239bde 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -128,6 +128,7 @@ extern void efi_call_phys_epilog(void);
 extern void efi_unmap_memmap(void);
 extern void efi_memory_uc(u64 addr, unsigned long size);
 extern void __init efi_map_region(efi_memory_desc_t *md);
+extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
 extern void efi_setup_page_tables(void);
 extern void __init old_map_region(efi_memory_desc_t *md);

commit d2f7cbe7b26a74dbbbf8f325b2a6fd01bc34032c
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Oct 31 17:25:08 2013 +0100

    x86/efi: Runtime services virtual mapping
    
    We map the EFI regions needed for runtime services non-contiguously,
    with preserved alignment on virtual addresses starting from -4G down
    for a total max space of 64G. This way, we provide for stable runtime
    services addresses across kernels so that a kexec'd kernel can still use
    them.
    
    Thus, they're mapped in a separate pagetable so that we don't pollute
    the kernel namespace.
    
    Add an efi= kernel command line parameter for passing miscellaneous
    options and chicken bits from the command line.
    
    While at it, add a chicken bit called "efi=old_map" which can be used as
    a fallback to the old runtime services mapping method in case there's
    some b0rkage with a particular EFI implementation (haha, it is hard to
    hold up the sarcasm here...).
    
    Also, add the UEFI RT VA space to Documentation/x86/x86_64/mm.txt.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 65c6e6e3a552..89a05b0507b9 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -1,6 +1,24 @@
 #ifndef _ASM_X86_EFI_H
 #define _ASM_X86_EFI_H
 
+/*
+ * We map the EFI regions needed for runtime services non-contiguously,
+ * with preserved alignment on virtual addresses starting from -4G down
+ * for a total max space of 64G. This way, we provide for stable runtime
+ * services addresses across kernels so that a kexec'd kernel can still
+ * use them.
+ *
+ * This is the main reason why we're doing stable VA mappings for RT
+ * services.
+ *
+ * This flag is used in conjuction with a chicken bit called
+ * "efi=old_map" which can be used as a fallback to the old runtime
+ * services mapping method in case there's some b0rkage with a
+ * particular EFI implementation (haha, it is hard to hold up the
+ * sarcasm here...).
+ */
+#define EFI_OLD_MEMMAP		EFI_ARCH_1
+
 #ifdef CONFIG_X86_32
 
 #define EFI_LOADER_SIGNATURE	"EL32"
@@ -69,24 +87,31 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4), (u64)(a5), (u64)(a6))
 
+#define _efi_call_virtX(x, f, ...)					\
+({									\
+	efi_status_t __s;						\
+									\
+	efi_sync_low_kernel_mappings();					\
+	preempt_disable();						\
+	__s = efi_call##x((void *)efi.systab->runtime->f, __VA_ARGS__);	\
+	preempt_enable();						\
+	__s;								\
+})
+
 #define efi_call_virt0(f)				\
-	efi_call0((efi.systab->runtime->f))
-#define efi_call_virt1(f, a1)					\
-	efi_call1((efi.systab->runtime->f), (u64)(a1))
-#define efi_call_virt2(f, a1, a2)					\
-	efi_call2((efi.systab->runtime->f), (u64)(a1), (u64)(a2))
-#define efi_call_virt3(f, a1, a2, a3)					\
-	efi_call3((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
-		  (u64)(a3))
-#define efi_call_virt4(f, a1, a2, a3, a4)				\
-	efi_call4((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
-		  (u64)(a3), (u64)(a4))
-#define efi_call_virt5(f, a1, a2, a3, a4, a5)				\
-	efi_call5((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
-		  (u64)(a3), (u64)(a4), (u64)(a5))
-#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_call6((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
-		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
+	_efi_call_virtX(0, f)
+#define efi_call_virt1(f, a1)				\
+	_efi_call_virtX(1, f, (u64)(a1))
+#define efi_call_virt2(f, a1, a2)			\
+	_efi_call_virtX(2, f, (u64)(a1), (u64)(a2))
+#define efi_call_virt3(f, a1, a2, a3)			\
+	_efi_call_virtX(3, f, (u64)(a1), (u64)(a2), (u64)(a3))
+#define efi_call_virt4(f, a1, a2, a3, a4)		\
+	_efi_call_virtX(4, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4))
+#define efi_call_virt5(f, a1, a2, a3, a4, a5)		\
+	_efi_call_virtX(5, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5))
+#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
+	_efi_call_virtX(6, f, (u64)(a1), (u64)(a2), (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 				 u32 type, u64 attribute);
@@ -95,12 +120,17 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 
 extern int add_efi_memmap;
 extern unsigned long x86_efi_facility;
+extern struct efi_scratch efi_scratch;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);
 extern void efi_unmap_memmap(void);
 extern void efi_memory_uc(u64 addr, unsigned long size);
+extern void __init efi_map_region(efi_memory_desc_t *md);
+extern void efi_sync_low_kernel_mappings(void);
+extern void efi_setup_page_tables(void);
+extern void __init old_map_region(efi_memory_desc_t *md);
 
 #ifdef CONFIG_EFI
 

commit 72548e836b0c4abbb652e791dee9c91203a9a4c6
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Oct 4 09:36:56 2013 +0100

    x86/efi: Add EFI framebuffer earlyprintk support
    
    It's incredibly difficult to diagnose early EFI boot issues without
    special hardware because earlyprintk=vga doesn't work on EFI systems.
    
    Add support for writing to the EFI framebuffer, via earlyprintk=efi,
    which will actually give users a chance of providing debug output.
    
    Cc: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 0062a0125041..65c6e6e3a552 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -109,6 +109,8 @@ static inline bool efi_is_native(void)
 	return IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT);
 }
 
+extern struct console early_efi_console;
+
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.

commit 4d6f843a38fa26035598f1f35181aa5f328db897
Merge: 55a0d3ff603a d3768d885c6c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 2 16:25:50 2013 -0700

    Merge branch 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 EFI changes from Ingo Molnar:
     "Two fixes that should in principle increase robustness of our
      interaction with the EFI firmware, and a cleanup"
    
    * 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, efi: retry ExitBootServices() on failure
      efi: Convert runtime services function ptrs
      UEFI: Don't pass boot services regions to SetVirtualAddressMap()

commit 43ab0476a648053e5998bf081f47f215375a4502
Author: Borislav Petkov <bp@suse.de>
Date:   Sun Jun 2 14:56:07 2013 +0200

    efi: Convert runtime services function ptrs
    
    ... to void * like the boot services and lose all the void * casts. No
    functionality change.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 2fb5d5884e23..5b33686b6995 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -52,40 +52,40 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 		     u64 arg4, u64 arg5, u64 arg6);
 
 #define efi_call_phys0(f)			\
-	efi_call0((void *)(f))
+	efi_call0((f))
 #define efi_call_phys1(f, a1)			\
-	efi_call1((void *)(f), (u64)(a1))
+	efi_call1((f), (u64)(a1))
 #define efi_call_phys2(f, a1, a2)			\
-	efi_call2((void *)(f), (u64)(a1), (u64)(a2))
+	efi_call2((f), (u64)(a1), (u64)(a2))
 #define efi_call_phys3(f, a1, a2, a3)				\
-	efi_call3((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3))
+	efi_call3((f), (u64)(a1), (u64)(a2), (u64)(a3))
 #define efi_call_phys4(f, a1, a2, a3, a4)				\
-	efi_call4((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+	efi_call4((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4))
 #define efi_call_phys5(f, a1, a2, a3, a4, a5)				\
-	efi_call5((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+	efi_call5((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4), (u64)(a5))
 #define efi_call_phys6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_call6((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+	efi_call6((f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4), (u64)(a5), (u64)(a6))
 
 #define efi_call_virt0(f)				\
-	efi_call0((void *)(efi.systab->runtime->f))
+	efi_call0((efi.systab->runtime->f))
 #define efi_call_virt1(f, a1)					\
-	efi_call1((void *)(efi.systab->runtime->f), (u64)(a1))
+	efi_call1((efi.systab->runtime->f), (u64)(a1))
 #define efi_call_virt2(f, a1, a2)					\
-	efi_call2((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
+	efi_call2((efi.systab->runtime->f), (u64)(a1), (u64)(a2))
 #define efi_call_virt3(f, a1, a2, a3)					\
-	efi_call3((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call3((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3))
 #define efi_call_virt4(f, a1, a2, a3, a4)				\
-	efi_call4((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call4((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4))
 #define efi_call_virt5(f, a1, a2, a3, a4, a5)				\
-	efi_call5((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call5((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5))
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call6((efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,

commit f8b8404337de4e2466e2e1139ea68b1f8295974f
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Sat Jun 1 16:06:20 2013 -0400

    Modify UEFI anti-bricking code
    
    This patch reworks the UEFI anti-bricking code, including an effective
    reversion of cc5a080c and 31ff2f20. It turns out that calling
    QueryVariableInfo() from boot services results in some firmware
    implementations jumping to physical addresses even after entering virtual
    mode, so until we have 1:1 mappings for UEFI runtime space this isn't
    going to work so well.
    
    Reverting these gets us back to the situation where we'd refuse to create
    variables on some systems because they classify deleted variables as "used"
    until the firmware triggers a garbage collection run, which they won't do
    until they reach a lower threshold. This results in it being impossible to
    install a bootloader, which is unhelpful.
    
    Feedback from Samsung indicates that the firmware doesn't need more than
    5KB of storage space for its own purposes, so that seems like a reasonable
    threshold. However, there's still no guarantee that a platform will attempt
    garbage collection merely because it drops below this threshold. It seems
    that this is often only triggered if an attempt to write generates a
    genuine EFI_OUT_OF_RESOURCES error. We can force that by attempting to
    create a variable larger than the remaining space. This should fail, but if
    it somehow succeeds we can then immediately delete it.
    
    I've tested this on the UEFI machines I have available, but I don't have
    a Samsung and so can't verify that it avoids the bricking problem.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Lee, Chun-Y <jlee@suse.com> [ dummy variable cleanup ]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 2fb5d5884e23..60c89f30c727 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -102,13 +102,6 @@ extern void efi_call_phys_epilog(void);
 extern void efi_unmap_memmap(void);
 extern void efi_memory_uc(u64 addr, unsigned long size);
 
-struct efi_var_bootdata {
-	struct setup_data data;
-	u64 store_size;
-	u64 remaining_size;
-	u64 max_var_size;
-};
-
 #ifdef CONFIG_EFI
 
 static inline bool efi_is_native(void)

commit cc5a080c5d40c36089bb08a8a16fa3fc7047fe0f
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Mon Apr 15 13:09:46 2013 -0700

    efi: Pass boot services variable info to runtime code
    
    EFI variables can be flagged as being accessible only within boot services.
    This makes it awkward for us to figure out how much space they use at
    runtime. In theory we could figure this out by simply comparing the results
    from QueryVariableInfo() to the space used by all of our variables, but
    that fails if the platform doesn't garbage collect on every boot. Thankfully,
    calling QueryVariableInfo() while still inside boot services gives a more
    reliable answer. This patch passes that information from the EFI boot stub
    up to the efi platform code.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 60c89f30c727..2fb5d5884e23 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -102,6 +102,13 @@ extern void efi_call_phys_epilog(void);
 extern void efi_unmap_memmap(void);
 extern void efi_memory_uc(u64 addr, unsigned long size);
 
+struct efi_var_bootdata {
+	struct setup_data data;
+	u64 store_size;
+	u64 remaining_size;
+	u64 max_var_size;
+};
+
 #ifdef CONFIG_EFI
 
 static inline bool efi_is_native(void)

commit 6b59e366e074d3962e04f01efb8acc10a33c0e1e
Author: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
Date:   Thu Feb 14 09:07:35 2013 +0900

    x86, efi: remove duplicate code in setup_arch() by using, efi_is_native()
    
    The check, "IS_ENABLED(CONFIG_X86_64) != efi_enabled(EFI_64BIT)",
    in setup_arch() can be replaced by efi_is_enabled(). This change
    remove duplicate code and improve readability.
    
    Signed-off-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 28677c55113f..60c89f30c727 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -102,7 +102,14 @@ extern void efi_call_phys_epilog(void);
 extern void efi_unmap_memmap(void);
 extern void efi_memory_uc(u64 addr, unsigned long size);
 
-#ifndef CONFIG_EFI
+#ifdef CONFIG_EFI
+
+static inline bool efi_is_native(void)
+{
+	return IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT);
+}
+
+#else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.
  */

commit 83e68189745ad931c2afd45d8ee3303929233e7f
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Nov 14 09:42:35 2012 +0000

    efi: Make 'efi_enabled' a function to query EFI facilities
    
    Originally 'efi_enabled' indicated whether a kernel was booted from
    EFI firmware. Over time its semantics have changed, and it now
    indicates whether or not we are booted on an EFI machine with
    bit-native firmware, e.g. 64-bit kernel with 64-bit firmware.
    
    The immediate motivation for this patch is the bug report at,
    
        https://bugs.launchpad.net/ubuntu-cdimage/+bug/1040557
    
    which details how running a platform driver on an EFI machine that is
    designed to run under BIOS can cause the machine to become
    bricked. Also, the following report,
    
        https://bugzilla.kernel.org/show_bug.cgi?id=47121
    
    details how running said driver can also cause Machine Check
    Exceptions. Drivers need a new means of detecting whether they're
    running on an EFI machine, as sadly the expression,
    
        if (!efi_enabled)
    
    hasn't been a sufficient condition for quite some time.
    
    Users actually want to query 'efi_enabled' for different reasons -
    what they really want access to is the list of available EFI
    facilities.
    
    For instance, the x86 reboot code needs to know whether it can invoke
    the ResetSystem() function provided by the EFI runtime services, while
    the ACPI OSL code wants to know whether the EFI config tables were
    mapped successfully. There are also checks in some of the platform
    driver code to simply see if they're running on an EFI machine (which
    would make it a bad idea to do BIOS-y things).
    
    This patch is a prereq for the samsung-laptop fix patch.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Steve Langasek <steve.langasek@canonical.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 6e8fdf5ad113..28677c55113f 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -94,6 +94,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;
+extern unsigned long x86_efi_facility;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);

commit 11520e5e7c1855fc3bf202bb3be35a39d9efa034
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 15 15:15:24 2012 -0800

    Revert "x86-64/efi: Use EFI to deal with platform wall clock (again)"
    
    This reverts commit bd52276fa1d4 ("x86-64/efi: Use EFI to deal with
    platform wall clock (again)"), and the two supporting commits:
    
      da5a108d05b4: "x86/kernel: remove tboot 1:1 page table creation code"
    
      185034e72d59: "x86, efi: 1:1 pagetable mapping for virtual EFI calls")
    
    as they all depend semantically on commit 53b87cf088e2 ("x86, mm:
    Include the entire kernel memory map in trampoline_pgd") that got
    reverted earlier due to the problems it caused.
    
    This was pointed out by Yinghai Lu, and verified by me on my Macbook Air
    that uses EFI.
    
    Pointed-out-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index fd13815fe85c..6e8fdf5ad113 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -69,37 +69,23 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4), (u64)(a5), (u64)(a6))
 
-extern unsigned long efi_call_virt_prelog(void);
-extern void efi_call_virt_epilog(unsigned long);
-
-#define efi_callx(x, func, ...)					\
-	({							\
-		efi_status_t __status;				\
-		unsigned long __pgd;				\
-								\
-		__pgd = efi_call_virt_prelog();			\
-		__status = efi_call##x(func, __VA_ARGS__);	\
-		efi_call_virt_epilog(__pgd);			\
-		__status;					\
-	})
-
 #define efi_call_virt0(f)				\
-	efi_callx(0, (void *)(efi.systab->runtime->f))
+	efi_call0((void *)(efi.systab->runtime->f))
 #define efi_call_virt1(f, a1)					\
-	efi_callx(1, (void *)(efi.systab->runtime->f), (u64)(a1))
+	efi_call1((void *)(efi.systab->runtime->f), (u64)(a1))
 #define efi_call_virt2(f, a1, a2)					\
-	efi_callx(2, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
+	efi_call2((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
 #define efi_call_virt3(f, a1, a2, a3)					\
-	efi_callx(3, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call3((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3))
 #define efi_call_virt4(f, a1, a2, a3, a4)				\
-	efi_callx(4, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call4((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4))
 #define efi_call_virt5(f, a1, a2, a3, a4, a5)				\
-	efi_callx(5, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call5((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5))
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_callx(6, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,

commit d42b3a2906a10b732ea7d7f849d49be79d242ef0
Merge: 18dd0bf22b6f e83af1f18c78
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 10:08:40 2012 -0800

    Merge branch 'core-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 EFI update from Peter Anvin:
     "EFI tree, from Matt Fleming.  Most of the patches are the new efivarfs
      filesystem by Matt Garrett & co.  The balance are support for EFI
      wallclock in the absence of a hardware-specific driver, and various
      fixes and cleanups."
    
    * 'core-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      efivarfs: Make efivarfs_fill_super() static
      x86, efi: Check table header length in efi_bgrt_init()
      efivarfs: Use query_variable_info() to limit kmalloc()
      efivarfs: Fix return value of efivarfs_file_write()
      efivarfs: Return a consistent error when efivarfs_get_inode() fails
      efivarfs: Make 'datasize' unsigned long
      efivarfs: Add unique magic number
      efivarfs: Replace magic number with sizeof(attributes)
      efivarfs: Return an error if we fail to read a variable
      efi: Clarify GUID length calculations
      efivarfs: Implement exclusive access for {get,set}_variable
      efivarfs: efivarfs_fill_super() ensure we clean up correctly on error
      efivarfs: efivarfs_fill_super() ensure we free our temporary name
      efivarfs: efivarfs_fill_super() fix inode reference counts
      efivarfs: efivarfs_create() ensure we drop our reference on inode on error
      efivarfs: efivarfs_file_read ensure we free data in error paths
      x86-64/efi: Use EFI to deal with platform wall clock (again)
      x86/kernel: remove tboot 1:1 page table creation code
      x86, efi: 1:1 pagetable mapping for virtual EFI calls
      x86, mm: Include the entire kernel memory map in trampoline_pgd
      ...

commit 185034e72d591f9465e5e18f937ed642e7ea0070
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Sep 7 18:28:04 2012 +0100

    x86, efi: 1:1 pagetable mapping for virtual EFI calls
    
    Some firmware still needs a 1:1 (virt->phys) mapping even after we've
    called SetVirtualAddressMap(). So install the mapping alongside our
    existing kernel mapping whenever we make EFI calls in virtual mode.
    
    This bug was discovered on ASUS machines where the firmware
    implementation of GetTime() accesses the RTC device via physical
    addresses, even though that's bogus per the UEFI spec since we've
    informed the firmware via SetVirtualAddressMap() that the boottime
    memory map is no longer valid.
    
    This bug seems to be present in a lot of consumer devices, so there's
    not a lot we can do about this spec violation apart from workaround
    it.
    
    Cc: JérômeCarretero <cJ-ko@zougloub.eu>
    Cc: Vasco Dias <rafa.vasco@gmail.com>
    Acked-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index c9dcc181d4d1..ae3bf3b8da71 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -69,23 +69,37 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
 		  (u64)(a4), (u64)(a5), (u64)(a6))
 
+extern unsigned long efi_call_virt_prelog(void);
+extern void efi_call_virt_epilog(unsigned long);
+
+#define efi_callx(x, func, ...)					\
+	({							\
+		efi_status_t __status;				\
+		unsigned long __pgd;				\
+								\
+		__pgd = efi_call_virt_prelog();			\
+		__status = efi_call##x(func, __VA_ARGS__);	\
+		efi_call_virt_epilog(__pgd);			\
+		__status;					\
+	})
+
 #define efi_call_virt0(f)				\
-	efi_call0((void *)(efi.systab->runtime->f))
+	efi_callx(0, (void *)(efi.systab->runtime->f))
 #define efi_call_virt1(f, a1)					\
-	efi_call1((void *)(efi.systab->runtime->f), (u64)(a1))
+	efi_callx(1, (void *)(efi.systab->runtime->f), (u64)(a1))
 #define efi_call_virt2(f, a1, a2)					\
-	efi_call2((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
+	efi_callx(2, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
 #define efi_call_virt3(f, a1, a2, a3)					\
-	efi_call3((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_callx(3, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3))
 #define efi_call_virt4(f, a1, a2, a3, a4)				\
-	efi_call4((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_callx(4, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4))
 #define efi_call_virt5(f, a1, a2, a3, a4, a5)				\
-	efi_call5((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_callx(5, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5))
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)			\
-	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+	efi_callx(6, (void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,

commit 8b724e2a12d553cad8ad412846511c783a92d25e
Merge: f82f64dd9f48 5189c2a7c776
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Oct 26 10:17:38 2012 +0200

    Merge tag 'efi-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into x86/urgent
    
    Pull EFI fixes from Matt Fleming:
    
     "Fix oops with EFI variables on mixed 32/64-bit firmware/kernels and
      document EFI git repository location on kernel.org."
    
    Conflicts:
            arch/x86/include/asm/efi.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 5189c2a7c7769ee9d037d76c1a7b8550ccf3481c
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Oct 24 10:00:44 2012 -0700

    x86: efi: Turn off efi_enabled after setup on mixed fw/kernel
    
    When 32-bit EFI is used with 64-bit kernel (or vice versa), turn off
    efi_enabled once setup is done. Beyond setup, it is normally used to
    determine if runtime services are available and we will have none.
    
    This will resolve issues stemming from efivars modprobe panicking on a
    32/64-bit setup, as well as some reboot issues on similar setups.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=45991
    
    Reported-by: Marko Kohtala <marko.kohtala@gmail.com>
    Reported-by: Maxim Kammerer <mk@dee.su>
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
    Cc: stable@kernel.org # 3.4 - 3.6
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index c9dcc181d4d1..029189db84de 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -98,6 +98,7 @@ extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);
+extern void efi_unmap_memmap(void);
 
 #ifndef CONFIG_EFI
 /*

commit 3e8fa263a97079c74880675c451587bb6899e661
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Oct 19 13:25:46 2012 +0100

    x86/efi: Fix oops caused by incorrect set_memory_uc() usage
    
    Calling __pa() with an ioremap'd address is invalid. If we
    encounter an efi_memory_desc_t without EFI_MEMORY_WB set in
    ->attribute we currently call set_memory_uc(), which in turn
    calls __pa() on a potentially ioremap'd address.
    
    On CONFIG_X86_32 this results in the following oops:
    
      BUG: unable to handle kernel paging request at f7f22280
      IP: [<c10257b9>] reserve_ram_pages_type+0x89/0x210
      *pdpt = 0000000001978001 *pde = 0000000001ffb067 *pte = 0000000000000000
      Oops: 0000 [#1] PREEMPT SMP
      Modules linked in:
    
      Pid: 0, comm: swapper Not tainted 3.0.0-acpi-efi-0805 #3
       EIP: 0060:[<c10257b9>] EFLAGS: 00010202 CPU: 0
       EIP is at reserve_ram_pages_type+0x89/0x210
       EAX: 0070e280 EBX: 38714000 ECX: f7814000 EDX: 00000000
       ESI: 00000000 EDI: 38715000 EBP: c189fef0 ESP: c189fea8
       DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
      Process swapper (pid: 0, ti=c189e000 task=c18bbe60 task.ti=c189e000)
      Stack:
       80000200 ff108000 00000000 c189ff00 00038714 00000000 00000000 c189fed0
       c104f8ca 00038714 00000000 00038715 00000000 00000000 00038715 00000000
       00000010 38715000 c189ff48 c1025aff 38715000 00000000 00000010 00000000
      Call Trace:
       [<c104f8ca>] ? page_is_ram+0x1a/0x40
       [<c1025aff>] reserve_memtype+0xdf/0x2f0
       [<c1024dc9>] set_memory_uc+0x49/0xa0
       [<c19334d0>] efi_enter_virtual_mode+0x1c2/0x3aa
       [<c19216d4>] start_kernel+0x291/0x2f2
       [<c19211c7>] ? loglevel+0x1b/0x1b
       [<c19210bf>] i386_start_kernel+0xbf/0xc8
    
    The only time we can call set_memory_uc() for a memory region is
    when it is part of the direct kernel mapping. For the case where
    we ioremap a memory region we must leave it alone.
    
    This patch reimplements the fix from e8c7106280a3 ("x86, efi:
    Calling __pa() with an ioremap()ed address is invalid") which
    was reverted in e1ad783b12ec because it caused a regression on
    some MacBooks (they hung at boot). The regression was caused
    because the commit only marked EFI_RUNTIME_SERVICES_DATA as
    E820_RESERVED_EFI, when it should have marked all regions that
    have the EFI_MEMORY_RUNTIME attribute.
    
    Despite first impressions, it's not possible to use
    ioremap_cache() to map all cached memory regions on
    CONFIG_X86_64 because of the way that the memory map might be
    configured as detailed in the following bug report,
    
            https://bugzilla.redhat.com/show_bug.cgi?id=748516
    
    e.g. some of the EFI memory regions *need* to be mapped as part
    of the direct kernel mapping.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Huang Ying <huang.ying.caritas@gmail.com>
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1350649546-23541-1-git-send-email-matt@console-pimps.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index c9dcc181d4d1..36ff332da130 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -35,7 +35,7 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
 
-#define efi_ioremap(addr, size, type)		ioremap_cache(addr, size)
+#define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
 
 #else /* !CONFIG_X86_32 */
 
@@ -89,7 +89,7 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
 extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
-				 u32 type);
+				 u32 type, u64 attribute);
 
 #endif /* CONFIG_X86_32 */
 
@@ -98,6 +98,7 @@ extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);
+extern void efi_memory_uc(u64 addr, unsigned long size);
 
 #ifndef CONFIG_EFI
 /*

commit 1adbfa3511ee1c1118e16a9a0246870f12fef4e6
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Feb 12 13:24:29 2012 -0800

    x86, efi: Allow basic init with mixed 32/64-bit efi/kernel
    
    Traditionally the kernel has refused to setup EFI at all if there's been
    a mismatch in 32/64-bit mode between EFI and the kernel.
    
    On some platforms that boot natively through EFI (Chrome OS being one),
    we still need to get at least some of the static data such as memory
    configuration out of EFI. Runtime services aren't as critical, and
    it's a significant amount of work to implement switching between the
    operating modes to call between kernel and firmware for thise cases. So
    I'm ignoring it for now.
    
    v5:
    * Fixed some printk strings based on feedback
    * Renamed 32/64-bit specific types to not have _ prefix
    * Fixed bug in printout of efi runtime disablement
    
    v4:
    * Some of the earlier cleanup was accidentally reverted by this patch, fixed.
    * Reworded some messages to not have to line wrap printk strings
    
    v3:
    * Reorganized to a series of patches to make it easier to review, and
      do some of the cleanups I had left out before.
    
    v2:
    * Added graceful error handling for 32-bit kernel that gets passed
      EFI data above 4GB.
    * Removed some warnings that were missed in first version.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Link: http://lkml.kernel.org/r/1329081869-20779-6-git-send-email-olof@lixom.net
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 844f735fd63a..c9dcc181d4d1 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -95,7 +95,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 
 extern int add_efi_memmap;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
-extern void efi_memblock_x86_reserve_range(void);
+extern int efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);
 

commit bcede2f64a3b5cb50c0bdec1553ab480fd75d659
Merge: d0b9706c20eb 2d2da60fb40a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 11 19:12:33 2012 -0800

    Merge branch 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, efi: Break up large initrd reads
      x86, efi: EFI boot stub support
      efi: Add EFI file I/O data types
      efi.h: Add boottime->locate_handle search types
      efi.h: Add graphics protocol guids
      efi.h: Add allocation types for boottime->allocate_pages()
      efi.h: Add efi_image_loaded_t
      efi.h: Add struct definition for boot time services
      x86: Don't use magic strings for EFI loader signature
      x86: Add missing bzImage fields to struct setup_header

commit e1ad783b12ec8b69da83479c5d21a0d8180bc519
Author: Keith Packard <keithp@keithp.com>
Date:   Sun Dec 11 16:12:42 2011 -0800

    Revert "x86, efi: Calling __pa() with an ioremap()ed address is invalid"
    
    This hangs my MacBook Air at boot time; I get no console
    messages at all. I reverted this on top of -rc5 and my machine
    boots again.
    
    This reverts commit e8c7106280a305e1ff2a3a8a4dfce141469fb039.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Huang Ying <huang.ying.caritas@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1321621751-3650-1-git-send-email-matt@console
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index b8d8bfcd44a9..7093e4a6a0bc 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -33,6 +33,8 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
 
+#define efi_ioremap(addr, size, type)		ioremap_cache(addr, size)
+
 #else /* !CONFIG_X86_32 */
 
 extern u64 efi_call0(void *fp);
@@ -82,6 +84,9 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
+extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
+				 u32 type);
+
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;

commit f7d7d01be53cb47e0ae212c4e968aa28b82d2138
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:56:14 2011 +0000

    x86: Don't use magic strings for EFI loader signature
    
    Introduce a symbol, EFI_LOADER_SIGNATURE instead of using the magic
    strings, which also helps to reduce the amount of ifdeffery.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index b8d8bfcd44a9..26d8c18d5faa 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -3,6 +3,8 @@
 
 #ifdef CONFIG_X86_32
 
+#define EFI_LOADER_SIGNATURE	"EL32"
+
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #define efi_call_phys0(f)		efi_call_phys(f)
@@ -35,6 +37,8 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #else /* !CONFIG_X86_32 */
 
+#define EFI_LOADER_SIGNATURE	"EL64"
+
 extern u64 efi_call0(void *fp);
 extern u64 efi_call1(void *fp, u64 arg1);
 extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);

commit e8c7106280a305e1ff2a3a8a4dfce141469fb039
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Nov 18 13:09:11 2011 +0000

    x86, efi: Calling __pa() with an ioremap()ed address is invalid
    
    If we encounter an efi_memory_desc_t without EFI_MEMORY_WB set
    in ->attribute we currently call set_memory_uc(), which in turn
    calls __pa() on a potentially ioremap'd address.
    
    On CONFIG_X86_32 this is invalid, resulting in the following
    oops on some machines:
    
      BUG: unable to handle kernel paging request at f7f22280
      IP: [<c10257b9>] reserve_ram_pages_type+0x89/0x210
      [...]
    
      Call Trace:
       [<c104f8ca>] ? page_is_ram+0x1a/0x40
       [<c1025aff>] reserve_memtype+0xdf/0x2f0
       [<c1024dc9>] set_memory_uc+0x49/0xa0
       [<c19334d0>] efi_enter_virtual_mode+0x1c2/0x3aa
       [<c19216d4>] start_kernel+0x291/0x2f2
       [<c19211c7>] ? loglevel+0x1b/0x1b
       [<c19210bf>] i386_start_kernel+0xbf/0xc8
    
    A better approach to this problem is to map the memory region
    with the correct attributes from the start, instead of modifying
    it after the fact. The uncached case can be handled by
    ioremap_nocache() and the cached by ioremap_cache().
    
    Despite first impressions, it's not possible to use
    ioremap_cache() to map all cached memory regions on
    CONFIG_X86_64 because EFI_RUNTIME_SERVICES_DATA regions really
    don't like being mapped into the vmalloc space, as detailed in
    the following bug report,
    
            https://bugzilla.redhat.com/show_bug.cgi?id=748516
    
    Therefore, we need to ensure that any EFI_RUNTIME_SERVICES_DATA
    regions are covered by the direct kernel mapping table on
    CONFIG_X86_64. To accomplish this we now map E820_RESERVED_EFI
    regions via the direct kernel mapping with the initial call to
    init_memory_mapping() in setup_arch(), whereas previously these
    regions wouldn't be mapped if they were after the last E820_RAM
    region until efi_ioremap() was called. Doing it this way allows
    us to delete efi_ioremap() completely.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Huang Ying <huang.ying.caritas@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1321621751-3650-1-git-send-email-matt@console-pimps.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 7093e4a6a0bc..b8d8bfcd44a9 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -33,8 +33,6 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
 
-#define efi_ioremap(addr, size, type)		ioremap_cache(addr, size)
-
 #else /* !CONFIG_X86_32 */
 
 extern u64 efi_call0(void *fp);
@@ -84,9 +82,6 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
-extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
-				 u32 type);
-
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;

commit 9cd2b07c197e3ff594fc04f5fb3d86efbeab6ad8
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu May 5 15:19:43 2011 -0400

    x86, efi: Consolidate EFI nx control
    
    The core EFI code and 64-bit EFI code currently have independent
    implementations of code for setting memory regions as executable or not.
    Let's consolidate them.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Link: http://lkml.kernel.org/r/1304623186-18261-2-git-send-email-mjg@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 8e4a16508d4e..7093e4a6a0bc 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -90,6 +90,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;
+extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern void efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);

commit a9ce6bc15100023b411f8117e53a016d61889800
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Aug 25 13:39:17 2010 -0700

    x86, memblock: Replace e820_/_early string with memblock_
    
    1.include linux/memblock.h directly. so later could reduce e820.h reference.
    2 this patch is done by sed scripts mainly
    
    -v2: use MEMBLOCK_ERROR instead of -1ULL or -1UL
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 8406ed7f9926..8e4a16508d4e 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -90,7 +90,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;
-extern void efi_reserve_early(void);
+extern void efi_memblock_x86_reserve_range(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);
 

commit 6a7bbd57ed50bb62c9a81ae5f2e202ca689e5964
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Aug 3 22:38:10 2009 +1000

    x86: Make 64-bit efi_ioremap use ioremap on MMIO regions
    
    Booting current 64-bit x86 kernels on the latest Apple MacBook
    (MacBook5,2) via EFI gives the following warning:
    
    [    0.182209] ------------[ cut here ]------------
    [    0.182222] WARNING: at arch/x86/mm/pageattr.c:581 __cpa_process_fault+0x44/0xa0()
    [    0.182227] Hardware name: MacBook5,2
    [    0.182231] CPA: called for zero pte. vaddr = ffff8800ffe00000 cpa->vaddr = ffff8800ffe00000
    [    0.182236] Modules linked in:
    [    0.182242] Pid: 0, comm: swapper Not tainted 2.6.31-rc4 #6
    [    0.182246] Call Trace:
    [    0.182254]  [<ffffffff8102c754>] ? __cpa_process_fault+0x44/0xa0
    [    0.182261]  [<ffffffff81048668>] warn_slowpath_common+0x78/0xd0
    [    0.182266]  [<ffffffff81048744>] warn_slowpath_fmt+0x64/0x70
    [    0.182272]  [<ffffffff8102c7ec>] ? update_page_count+0x3c/0x50
    [    0.182280]  [<ffffffff818d25c5>] ? phys_pmd_init+0x140/0x22e
    [    0.182286]  [<ffffffff8102c754>] __cpa_process_fault+0x44/0xa0
    [    0.182292]  [<ffffffff8102ce60>] __change_page_attr_set_clr+0x5f0/0xb40
    [    0.182301]  [<ffffffff810d1035>] ? vm_unmap_aliases+0x175/0x190
    [    0.182307]  [<ffffffff8102d4ae>] change_page_attr_set_clr+0xfe/0x3d0
    [    0.182314]  [<ffffffff8102dcca>] _set_memory_uc+0x2a/0x30
    [    0.182319]  [<ffffffff8102dd4b>] set_memory_uc+0x7b/0xb0
    [    0.182327]  [<ffffffff818afe31>] efi_enter_virtual_mode+0x2ad/0x2c9
    [    0.182334]  [<ffffffff818a1c66>] start_kernel+0x2db/0x3f4
    [    0.182340]  [<ffffffff818a1289>] x86_64_start_reservations+0x99/0xb9
    [    0.182345]  [<ffffffff818a1389>] x86_64_start_kernel+0xe0/0xf2
    [    0.182357] ---[ end trace 4eaa2a86a8e2da22 ]---
    [    0.182982] init_memory_mapping: 00000000ffffc000-0000000100000000
    [    0.182993]  00ffffc000 - 0100000000 page 4k
    
    This happens because the 64-bit version of efi_ioremap calls
    init_memory_mapping for all addresses, regardless of whether they are
    RAM or MMIO.  The EFI tables on this machine ask for runtime access to
    some MMIO regions:
    
    [    0.000000] EFI: mem195: type=11, attr=0x8000000000000000, range=[0x0000000093400000-0x0000000093401000) (0MB)
    [    0.000000] EFI: mem196: type=11, attr=0x8000000000000000, range=[0x00000000ffc00000-0x00000000ffc40000) (0MB)
    [    0.000000] EFI: mem197: type=11, attr=0x8000000000000000, range=[0x00000000ffc40000-0x00000000ffc80000) (0MB)
    [    0.000000] EFI: mem198: type=11, attr=0x8000000000000000, range=[0x00000000ffc80000-0x00000000ffca4000) (0MB)
    [    0.000000] EFI: mem199: type=11, attr=0x8000000000000000, range=[0x00000000ffca4000-0x00000000ffcb4000) (0MB)
    [    0.000000] EFI: mem200: type=11, attr=0x8000000000000000, range=[0x00000000ffcb4000-0x00000000ffffc000) (3MB)
    [    0.000000] EFI: mem201: type=11, attr=0x8000000000000000, range=[0x00000000ffffc000-0x0000000100000000) (0MB)
    
    This arranges to pass the EFI memory type through to efi_ioremap, and
    makes efi_ioremap use ioremap rather than init_memory_mapping if the
    type is EFI_MEMORY_MAPPED_IO.  With this, the above warning goes away.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <19062.55858.533494.471153@cargo.ozlabs.ibm.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index edc90f23e708..8406ed7f9926 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -33,7 +33,7 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 #define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
 	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
 
-#define efi_ioremap(addr, size)			ioremap_cache(addr, size)
+#define efi_ioremap(addr, size, type)		ioremap_cache(addr, size)
 
 #else /* !CONFIG_X86_32 */
 
@@ -84,7 +84,8 @@ extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
 	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
 		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
 
-extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size);
+extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
+				 u32 type);
 
 #endif /* CONFIG_X86_32 */
 

commit dd39ecf522ba86c70809715af46e6557f6491131
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Mar 4 10:58:33 2009 +0800

    x86: EFI: Back efi_ioremap with init_memory_mapping instead of FIX_MAP
    
    Impact: Fix boot failure on EFI system with large runtime memory range
    
    Brian Maly reported that some EFI system with large runtime memory
    range can not boot. Because the FIX_MAP used to map runtime memory
    range is smaller than run time memory range.
    
    This patch fixes this issue by re-implement efi_ioremap() with
    init_memory_mapping().
    
    Reported-and-tested-by: Brian Maly <bmaly@redhat.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Cc: Brian Maly <bmaly@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1236135513.6204.306.camel@yhuang-dev.sh.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index ca5ffb2856b6..edc90f23e708 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -37,8 +37,6 @@ extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
 #else /* !CONFIG_X86_32 */
 
-#define MAX_EFI_IO_PAGES	100
-
 extern u64 efi_call0(void *fp);
 extern u64 efi_call1(void *fp, u64 arg1);
 extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);

commit cbafbc826bf645f7fbbfbb2ff20138e5ccb4700e
Author: Jaswinder Singh Rajput <jaswinder@infradead.org>
Date:   Mon Dec 29 20:36:40 2008 +0530

    x86: efi.c declare add_efi_memmap before they get used
    
    Impact: cleanup, avoid sparse warning
    
    Fixes this sparse warning:
    
      arch/x86/kernel/efi.c:67:5: warning: symbol 'add_efi_memmap' was not declared. Should it be static?
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index a2e545c91c35..ca5ffb2856b6 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -90,6 +90,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size);
 
 #endif /* CONFIG_X86_32 */
 
+extern int add_efi_memmap;
 extern void efi_reserve_early(void);
 extern void efi_call_phys_prelog(void);
 extern void efi_call_phys_epilog(void);

commit 1965aae3c98397aad957412413c07e97b1bd4e64
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Oct 22 22:26:29 2008 -0700

    x86: Fix ASM_X86__ header guards
    
    Change header guards named "ASM_X86__*" to "_ASM_X86_*" since:
    
    a. the double underscore is ugly and pointless.
    b. no leading underscore violates namespace constraints.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 313438e63348..a2e545c91c35 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -1,5 +1,5 @@
-#ifndef ASM_X86__EFI_H
-#define ASM_X86__EFI_H
+#ifndef _ASM_X86_EFI_H
+#define _ASM_X86_EFI_H
 
 #ifdef CONFIG_X86_32
 
@@ -107,4 +107,4 @@ extern void efi_call_phys_epilog(void);
 #define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
 #endif /* CONFIG_EFI */
 
-#endif /* ASM_X86__EFI_H */
+#endif /* _ASM_X86_EFI_H */

commit bb8985586b7a906e116db835c64773b7a7d51663
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 17 21:05:42 2008 -0400

    x86, um: ... and asm-x86 move
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
new file mode 100644
index 000000000000..313438e63348
--- /dev/null
+++ b/arch/x86/include/asm/efi.h
@@ -0,0 +1,110 @@
+#ifndef ASM_X86__EFI_H
+#define ASM_X86__EFI_H
+
+#ifdef CONFIG_X86_32
+
+extern unsigned long asmlinkage efi_call_phys(void *, ...);
+
+#define efi_call_phys0(f)		efi_call_phys(f)
+#define efi_call_phys1(f, a1)		efi_call_phys(f, a1)
+#define efi_call_phys2(f, a1, a2)	efi_call_phys(f, a1, a2)
+#define efi_call_phys3(f, a1, a2, a3)	efi_call_phys(f, a1, a2, a3)
+#define efi_call_phys4(f, a1, a2, a3, a4)	\
+	efi_call_phys(f, a1, a2, a3, a4)
+#define efi_call_phys5(f, a1, a2, a3, a4, a5)	\
+	efi_call_phys(f, a1, a2, a3, a4, a5)
+#define efi_call_phys6(f, a1, a2, a3, a4, a5, a6)	\
+	efi_call_phys(f, a1, a2, a3, a4, a5, a6)
+/*
+ * Wrap all the virtual calls in a way that forces the parameters on the stack.
+ */
+
+#define efi_call_virt(f, args...) \
+	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
+
+#define efi_call_virt0(f)		efi_call_virt(f)
+#define efi_call_virt1(f, a1)		efi_call_virt(f, a1)
+#define efi_call_virt2(f, a1, a2)	efi_call_virt(f, a1, a2)
+#define efi_call_virt3(f, a1, a2, a3)	efi_call_virt(f, a1, a2, a3)
+#define efi_call_virt4(f, a1, a2, a3, a4)	\
+	efi_call_virt(f, a1, a2, a3, a4)
+#define efi_call_virt5(f, a1, a2, a3, a4, a5)	\
+	efi_call_virt(f, a1, a2, a3, a4, a5)
+#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)	\
+	efi_call_virt(f, a1, a2, a3, a4, a5, a6)
+
+#define efi_ioremap(addr, size)			ioremap_cache(addr, size)
+
+#else /* !CONFIG_X86_32 */
+
+#define MAX_EFI_IO_PAGES	100
+
+extern u64 efi_call0(void *fp);
+extern u64 efi_call1(void *fp, u64 arg1);
+extern u64 efi_call2(void *fp, u64 arg1, u64 arg2);
+extern u64 efi_call3(void *fp, u64 arg1, u64 arg2, u64 arg3);
+extern u64 efi_call4(void *fp, u64 arg1, u64 arg2, u64 arg3, u64 arg4);
+extern u64 efi_call5(void *fp, u64 arg1, u64 arg2, u64 arg3,
+		     u64 arg4, u64 arg5);
+extern u64 efi_call6(void *fp, u64 arg1, u64 arg2, u64 arg3,
+		     u64 arg4, u64 arg5, u64 arg6);
+
+#define efi_call_phys0(f)			\
+	efi_call0((void *)(f))
+#define efi_call_phys1(f, a1)			\
+	efi_call1((void *)(f), (u64)(a1))
+#define efi_call_phys2(f, a1, a2)			\
+	efi_call2((void *)(f), (u64)(a1), (u64)(a2))
+#define efi_call_phys3(f, a1, a2, a3)				\
+	efi_call3((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3))
+#define efi_call_phys4(f, a1, a2, a3, a4)				\
+	efi_call4((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+		  (u64)(a4))
+#define efi_call_phys5(f, a1, a2, a3, a4, a5)				\
+	efi_call5((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+		  (u64)(a4), (u64)(a5))
+#define efi_call_phys6(f, a1, a2, a3, a4, a5, a6)			\
+	efi_call6((void *)(f), (u64)(a1), (u64)(a2), (u64)(a3),		\
+		  (u64)(a4), (u64)(a5), (u64)(a6))
+
+#define efi_call_virt0(f)				\
+	efi_call0((void *)(efi.systab->runtime->f))
+#define efi_call_virt1(f, a1)					\
+	efi_call1((void *)(efi.systab->runtime->f), (u64)(a1))
+#define efi_call_virt2(f, a1, a2)					\
+	efi_call2((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2))
+#define efi_call_virt3(f, a1, a2, a3)					\
+	efi_call3((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+		  (u64)(a3))
+#define efi_call_virt4(f, a1, a2, a3, a4)				\
+	efi_call4((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+		  (u64)(a3), (u64)(a4))
+#define efi_call_virt5(f, a1, a2, a3, a4, a5)				\
+	efi_call5((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+		  (u64)(a3), (u64)(a4), (u64)(a5))
+#define efi_call_virt6(f, a1, a2, a3, a4, a5, a6)			\
+	efi_call6((void *)(efi.systab->runtime->f), (u64)(a1), (u64)(a2), \
+		  (u64)(a3), (u64)(a4), (u64)(a5), (u64)(a6))
+
+extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size);
+
+#endif /* CONFIG_X86_32 */
+
+extern void efi_reserve_early(void);
+extern void efi_call_phys_prelog(void);
+extern void efi_call_phys_epilog(void);
+
+#ifndef CONFIG_EFI
+/*
+ * IF EFI is not configured, have the EFI calls return -ENOSYS.
+ */
+#define efi_call0(_f)					(-ENOSYS)
+#define efi_call1(_f, _a1)				(-ENOSYS)
+#define efi_call2(_f, _a1, _a2)				(-ENOSYS)
+#define efi_call3(_f, _a1, _a2, _a3)			(-ENOSYS)
+#define efi_call4(_f, _a1, _a2, _a3, _a4)		(-ENOSYS)
+#define efi_call5(_f, _a1, _a2, _a3, _a4, _a5)		(-ENOSYS)
+#define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
+#endif /* CONFIG_EFI */
+
+#endif /* ASM_X86__EFI_H */
