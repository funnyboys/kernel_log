commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 62d4111c1c54..844d60eb1882 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_ASM_X86_SIGCONTEXT_H
 #define _UAPI_ASM_X86_SIGCONTEXT_H
 

commit 6c25da5ad55d48c41b8909bc1f4e3cd5d85bb499
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Feb 16 15:09:03 2016 -0800

    x86/signal/64: Re-add support for SS in the 64-bit signal context
    
    This is a second attempt to make the improvements from c6f2062935c8
    ("x86/signal/64: Fix SS handling for signals delivered to 64-bit
    programs"), which was reverted by 51adbfbba5c6 ("x86/signal/64: Add
    support for SS in the 64-bit signal context").
    
    This adds two new uc_flags flags.  UC_SIGCONTEXT_SS will be set for
    all 64-bit signals (including x32).  It indicates that the saved SS
    field is valid and that the kernel supports the new behavior.
    
    The goal is to fix a problems with signal handling in 64-bit tasks:
    SS wasn't saved in the 64-bit signal context, making it awkward to
    determine what SS was at the time of signal delivery and making it
    impossible to return to a non-flat SS (as calling sigreturn clobbers
    SS).
    
    This also made it extremely difficult for 64-bit tasks to return to
    fully-defined 16-bit contexts, because only the kernel can easily do
    espfix64, but sigreturn was unable to set a non-flag SS:ESP.
    (DOSEMU has a monstrous hack to partially work around this
    limitation.)
    
    If we could go back in time, the correct fix would be to make 64-bit
    signals work just like 32-bit signals with respect to SS: save it
    in signal context, reset it when delivering a signal, and restore
    it in sigreturn.
    
    Unfortunately, doing that (as I tried originally) breaks DOSEMU:
    DOSEMU wouldn't reset the signal context's SS when clearing the LDT
    and changing the saved CS to 64-bit mode, since it predates the SS
    context field existing in the first place.
    
    This patch is a bit more complicated, and it tries to balance a
    bunch of goals.  It makes most cases of changing ucontext->ss during
    signal handling work as expected.
    
    I do this by special-casing the interesting case.  On sigreturn,
    ucontext->ss will be honored by default, unless the ucontext was
    created from scratch by an old program and had a 64-bit CS
    (unfortunately, CRIU can do this) or was the result of changing a
    32-bit signal context to 64-bit without resetting SS (as DOSEMU
    does).
    
    For the benefit of new 64-bit software that uses segmentation (new
    versions of DOSEMU might), the new behavior can be detected with a
    new ucontext flag UC_SIGCONTEXT_SS.
    
    To avoid compilation issues, __pad0 is left as an alias for ss in
    ucontext.
    
    The nitty-gritty details are documented in the header file.
    
    This patch also re-enables the sigreturn_64 and ldt_gdt_64 selftests,
    as the kernel change allows both of them to pass.
    
    Tested-by: Stas Sergeev <stsp@list.ru>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Acked-by: Borislav Petkov <bp@alien8.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/749149cbfc3e75cd7fcdad69a854b399d792cc6f.1455664054.git.luto@kernel.org
    [ Small readability edit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 702c40468859..62d4111c1c54 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -256,7 +256,7 @@ struct sigcontext_64 {
 	__u16				cs;
 	__u16				gs;
 	__u16				fs;
-	__u16				__pad0;
+	__u16				ss;
 	__u64				err;
 	__u64				trapno;
 	__u64				oldmask;
@@ -368,7 +368,10 @@ struct sigcontext {
 	 */
 	__u16				gs;
 	__u16				fs;
-	__u16				__pad0;
+	union {
+		__u16			ss;	/* If UC_SIGCONTEXT_SS */
+		__u16			__pad0;	/* Alias name for old (!UC_SIGCONTEXT_SS) user-space */
+	};
 	__u64				err;
 	__u64				trapno;
 	__u64				oldmask;

commit e54fdcca70a33a7e447e526b305db85e978c0563
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Feb 16 15:09:01 2016 -0800

    x86/signal/64: Add a comment about sigcontext->fs and gs
    
    These fields have a strange history.  This tries to document it.
    
    This borrows from 9a036b93a344 ("x86/signal/64: Remove 'fs' and 'gs'
    from sigcontext"), which was reverted by ed596cde9425 ("Revert x86
    sigcontext cleanups").
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Acked-by: Borislav Petkov <bp@alien8.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stas Sergeev <stsp@list.ru>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/baa78f3c84106fa5acbc319377b1850602f5deec.1455664054.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index d485232f1e9f..702c40468859 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -341,6 +341,31 @@ struct sigcontext {
 	__u64				rip;
 	__u64				eflags;		/* RFLAGS */
 	__u16				cs;
+
+	/*
+	 * Prior to 2.5.64 ("[PATCH] x86-64 updates for 2.5.64-bk3"),
+	 * Linux saved and restored fs and gs in these slots.  This
+	 * was counterproductive, as fsbase and gsbase were never
+	 * saved, so arch_prctl was presumably unreliable.
+	 *
+	 * These slots should never be reused without extreme caution:
+	 *
+	 *  - Some DOSEMU versions stash fs and gs in these slots manually,
+	 *    thus overwriting anything the kernel expects to be preserved
+	 *    in these slots.
+	 *
+	 *  - If these slots are ever needed for any other purpose,
+	 *    there is some risk that very old 64-bit binaries could get
+	 *    confused.  I doubt that many such binaries still work,
+	 *    though, since the same patch in 2.5.64 also removed the
+	 *    64-bit set_thread_area syscall, so it appears that there
+	 *    is no TLS API beyond modify_ldt that works in both pre-
+	 *    and post-2.5.64 kernels.
+	 *
+	 * If the kernel ever adds explicit fs, gs, fsbase, and gsbase
+	 * save/restore, it will most likely need to be opt-in and use
+	 * different context slots.
+	 */
 	__u16				gs;
 	__u16				fs;
 	__u16				__pad0;

commit 0e2815de552a638295cfdaf0865e575573bf263e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Sep 9 09:12:44 2015 +0200

    x86/headers: Clean up too long lines
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bp@alien8.de
    Cc: brgerst@gmail.com
    Cc: dvlasenk@redhat.com
    Cc: luto@amacapital.net
    Cc: mikko.rapeli@iki.fi
    Cc: oleg@redhat.com
    Link: http://lkml.kernel.org/r/20150909071244.GM3644@twins.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 4411e6a8f8e7..d485232f1e9f 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -2,16 +2,16 @@
 #define _UAPI_ASM_X86_SIGCONTEXT_H
 
 /*
- * Linux signal context definitions. The sigcontext includes a complex hierarchy of CPU
- * and FPU state, available to user-space (on the stack) when a signal handler is
- * executed.
+ * Linux signal context definitions. The sigcontext includes a complex
+ * hierarchy of CPU and FPU state, available to user-space (on the stack) when
+ * a signal handler is executed.
  *
- * As over the years this ABI grew from its very simple roots towards supporting more and
- * more CPU state organically, some of the details (which were rather clever hacks back
- * in the days) became a bit quirky by today.
+ * As over the years this ABI grew from its very simple roots towards
+ * supporting more and more CPU state organically, some of the details (which
+ * were rather clever hacks back in the days) became a bit quirky by today.
  *
- * The current ABI includes flexible provisions for future extensions, so we won't have
- * to grow new quirks for quite some time. Promise!
+ * The current ABI includes flexible provisions for future extensions, so we
+ * won't have to grow new quirks for quite some time. Promise!
  */
 
 #include <linux/compiler.h>
@@ -23,27 +23,32 @@
 
 /*
  * Bytes 464..511 in the current 512-byte layout of the FXSAVE/FXRSTOR frame
- * are reserved for SW usage. On CPUs supporting XSAVE/XRSTOR, these bytes
- * are used to extend the fpstate pointer in the sigcontext, which now
- * includes the extended state information along with fpstate information.
+ * are reserved for SW usage. On CPUs supporting XSAVE/XRSTOR, these bytes are
+ * used to extend the fpstate pointer in the sigcontext, which now includes the
+ * extended state information along with fpstate information.
  *
- * If sw_reserved.magic1 == FP_XSTATE_MAGIC1 then there's a sw_reserved.extended_size
- * bytes large extended context area present. (The last 32-bit word of this extended
- * area (at the fpstate+extended_size-FP_XSTATE_MAGIC2_SIZE address) is set to
+ * If sw_reserved.magic1 == FP_XSTATE_MAGIC1 then there's a
+ * sw_reserved.extended_size bytes large extended context area present. (The
+ * last 32-bit word of this extended area (at the
+ * fpstate+extended_size-FP_XSTATE_MAGIC2_SIZE address) is set to
  * FP_XSTATE_MAGIC2 so that you can sanity check your size calculations.)
  *
- * This extended area typically grows with newer CPUs that have larger and larger
- * XSAVE areas.
+ * This extended area typically grows with newer CPUs that have larger and
+ * larger XSAVE areas.
  */
 struct _fpx_sw_bytes {
-	/* If set to FP_XSTATE_MAGIC1 then this is an xstate context. 0 if a legacy frame. */
+	/*
+	 * If set to FP_XSTATE_MAGIC1 then this is an xstate context.
+	 * 0 if a legacy frame.
+	 */
 	__u32				magic1;
 
 	/*
 	 * Total size of the fpstate area:
 	 *
 	 *  - if magic1 == 0 then it's sizeof(struct _fpstate)
-	 *  - if magic1 == FP_XSTATE_MAGIC1 then it's sizeof(struct _xstate) plus extensions (if any)
+	 *  - if magic1 == FP_XSTATE_MAGIC1 then it's sizeof(struct _xstate)
+	 *    plus extensions (if any)
 	 */
 	__u32				extended_size;
 
@@ -66,13 +71,13 @@ struct _fpx_sw_bytes {
 /*
  * As documented in the iBCS2 standard:
  *
- * The first part of "struct _fpstate" is just the normal i387
- * hardware setup, the extra "status" word is used to save the
- * coprocessor status word before entering the handler.
+ * The first part of "struct _fpstate" is just the normal i387 hardware setup,
+ * the extra "status" word is used to save the coprocessor status word before
+ * entering the handler.
  *
- * The FPU state data structure has had to grow to accommodate the
- * extended FPU state required by the Streaming SIMD Extensions.
- * There is no documented standard to accomplish this at the moment.
+ * The FPU state data structure has had to grow to accommodate the extended FPU
+ * state required by the Streaming SIMD Extensions.  There is no documented
+ * standard to accomplish this at the moment.
  */
 
 /* 10-byte legacy floating point register: */
@@ -137,8 +142,8 @@ struct _fpstate_32 {
  *        'struct _fpstate' so that you can always assume the _fpstate portion
  *        exists so that you can check the magic value.
  *
- * Note2: Reserved fields may someday contain valuable data. Always save/restore
- *        them when you change signal frames.
+ * Note2: Reserved fields may someday contain valuable data. Always
+ *	  save/restore them when you change signal frames.
  */
 struct _fpstate_64 {
 	__u16				cwd;

commit 8fcb346b910e860d2525457742ae984c4ddc64b5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:41 2015 +0200

    x86/headers: Convert sigcontext_ia32 uses to sigcontext_32
    
    Use the new name in kernel code, and move the old name to the
    user-space-only legacy section of the UAPI header.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-14-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 592bfafd5cb2..4411e6a8f8e7 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -190,6 +190,9 @@ struct _xstate {
 	/* New processor state extensions go here: */
 };
 
+/*
+ * The 32-bit signal frame:
+ */
 struct sigcontext_32 {
 	__u16				gs, __gsh;
 	__u16				fs, __fsh;
@@ -223,8 +226,9 @@ struct sigcontext_32 {
 	__u32				cr2;
 };
 
-#define sigcontext_ia32 sigcontext_32
-
+/*
+ * The 64-bit signal frame:
+ */
 struct sigcontext_64 {
 	__u64				r8;
 	__u64				r9;
@@ -282,7 +286,9 @@ struct sigcontext_64 {
  */
 #ifndef __KERNEL__
 
-#define _fpstate_ia32 _fpstate_32
+#define _fpstate_ia32			_fpstate_32
+#define sigcontext_ia32			sigcontext_32
+
 
 # ifdef __i386__
 struct sigcontext {

commit db1e031401c6abab983919e882916d028f3b385e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:40 2015 +0200

    x86/headers: Unify 'struct sigcontext_ia32' and 'struct sigcontext_32'
    
    The two structures are identical - merge them and keep the
    legacy name as a define.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-13-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index d0def259d545..592bfafd5cb2 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -223,6 +223,8 @@ struct sigcontext_32 {
 	__u32				cr2;
 };
 
+#define sigcontext_ia32 sigcontext_32
+
 struct sigcontext_64 {
 	__u64				r8;
 	__u64				r9;

commit 530e5c827182a7a5322c55276b0617fd06874c24
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:39 2015 +0200

    x86/headers: Make sigcontext pointers bit independent
    
    Before we can eliminate the duplication between 'struct
    sigcontext_32' and 'struct sigcontext_ia32', make the 'fpstate'
    pointer field in 'struct sigcontext_32' bit independent.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-12-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 3591cef6d7d2..d0def259d545 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -218,7 +218,7 @@ struct sigcontext_32 {
 	 * of extended memory layout. See comments at the definition of
 	 * (struct _fpx_sw_bytes)
 	 */
-	void __user			*fpstate; /* Zero when no FPU/extended context */
+	__u32				fpstate; /* Zero when no FPU/extended context */
 	__u32				oldmask;
 	__u32				cr2;
 };
@@ -258,7 +258,7 @@ struct sigcontext_64 {
 	 * of extended memory layout. See comments at the definition of
 	 * (struct _fpx_sw_bytes)
 	 */
-	void __user			*fpstate; /* Zero when no FPU/extended context */
+	__u64				fpstate; /* Zero when no FPU/extended context */
 	__u64				reserved1[8];
 };
 

commit f2c609bca0b6526810fa22330ce4d173cc023ef8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:38 2015 +0200

    x86/headers: Move the 'struct sigcontext' definitions into the UAPI header
    
    Our goal is to eliminate the duplicate struct sigcontext_ia32
    definition, so move the kernel's primary sigcontext type into
    the UAPI header, defining these two variants:
    
            struct sigcontext_32
            struct sigcontext_64
    
    ... and map them to 'struct sigcontext'.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-11-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index ca542e37c783..3591cef6d7d2 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -190,6 +190,89 @@ struct _xstate {
 	/* New processor state extensions go here: */
 };
 
+struct sigcontext_32 {
+	__u16				gs, __gsh;
+	__u16				fs, __fsh;
+	__u16				es, __esh;
+	__u16				ds, __dsh;
+	__u32				di;
+	__u32				si;
+	__u32				bp;
+	__u32				sp;
+	__u32				bx;
+	__u32				dx;
+	__u32				cx;
+	__u32				ax;
+	__u32				trapno;
+	__u32				err;
+	__u32				ip;
+	__u16				cs, __csh;
+	__u32				flags;
+	__u32				sp_at_signal;
+	__u16				ss, __ssh;
+
+	/*
+	 * fpstate is really (struct _fpstate *) or (struct _xstate *)
+	 * depending on the FP_XSTATE_MAGIC1 encoded in the SW reserved
+	 * bytes of (struct _fpstate) and FP_XSTATE_MAGIC2 present at the end
+	 * of extended memory layout. See comments at the definition of
+	 * (struct _fpx_sw_bytes)
+	 */
+	void __user			*fpstate; /* Zero when no FPU/extended context */
+	__u32				oldmask;
+	__u32				cr2;
+};
+
+struct sigcontext_64 {
+	__u64				r8;
+	__u64				r9;
+	__u64				r10;
+	__u64				r11;
+	__u64				r12;
+	__u64				r13;
+	__u64				r14;
+	__u64				r15;
+	__u64				di;
+	__u64				si;
+	__u64				bp;
+	__u64				bx;
+	__u64				dx;
+	__u64				ax;
+	__u64				cx;
+	__u64				sp;
+	__u64				ip;
+	__u64				flags;
+	__u16				cs;
+	__u16				gs;
+	__u16				fs;
+	__u16				__pad0;
+	__u64				err;
+	__u64				trapno;
+	__u64				oldmask;
+	__u64				cr2;
+
+	/*
+	 * fpstate is really (struct _fpstate *) or (struct _xstate *)
+	 * depending on the FP_XSTATE_MAGIC1 encoded in the SW reserved
+	 * bytes of (struct _fpstate) and FP_XSTATE_MAGIC2 present at the end
+	 * of extended memory layout. See comments at the definition of
+	 * (struct _fpx_sw_bytes)
+	 */
+	void __user			*fpstate; /* Zero when no FPU/extended context */
+	__u64				reserved1[8];
+};
+
+/*
+ * Create the real 'struct sigcontext' type:
+ */
+#ifdef __KERNEL__
+# ifdef __i386__
+#  define sigcontext sigcontext_32
+# else
+#  define sigcontext sigcontext_64
+# endif
+#endif
+
 /*
  * The old user-space sigcontext definition, just in case user-space still
  * relies on it. The kernel definition (in asm/sigcontext.h) has unified

commit 86e9fc3a0ecdd3c21a938e325daf462ca1724f68
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:36 2015 +0200

    x86/headers: Convert uses of _fpstate_ia32 to _fpstate_32
    
    Remove uses of _fpstate_ia32 from the kernel, and move the
    legacy _fpstate_ia32 definition to the user-space only portion
    of the header.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-9-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 85811167821f..ca542e37c783 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -165,8 +165,6 @@ struct _fpstate_64 {
 # define _fpstate _fpstate_64
 #endif
 
-#define _fpstate_ia32 _fpstate_32
-
 struct _header {
 	__u64				xfeatures;
 	__u64				reserved1[2];
@@ -198,6 +196,9 @@ struct _xstate {
  * field names but otherwise the same layout.
  */
 #ifndef __KERNEL__
+
+#define _fpstate_ia32 _fpstate_32
+
 # ifdef __i386__
 struct sigcontext {
 	__u16				gs, __gsh;

commit 7bb0dc2222779b4cbf1ec9ad651e500e62fa5b11
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:35 2015 +0200

    x86/headers: Unify 'struct _fpstate_ia32' and i386 struct _fpstate
    
    'struct _fpstate_ia32' and 'struct _fpstate' on i386 are
    identical in all fields, except 'padding1' being named
    'padding'.
    
    We unify the two structures and add a union that is both named
    'padding1' and 'padding', in the (unlikely) case there's
    user-space code that relies on the padding field name.
    
    We rename the two main types to be:
    
      struct _fpstate_32
      struct _fpstate_64
    
    for the 32-bit and 64-bit frame, and map them to the main and
    compat structure names (_fpstate) depending on whether we are on
    32-bit or on 64-bit kernels.
    
    We also keep the old _fpstate_ia32 name as a legacy name.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-8-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 9df4df3e40ef..85811167821f 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -95,9 +95,10 @@ struct _xmmreg {
 
 #define X86_FXSR_MAGIC			0x0000
 
-#ifdef __i386__
-
-struct _fpstate {
+/*
+ * The 32-bit FPU frame:
+ */
+struct _fpstate_32 {
 	/* Legacy FPU environment: */
 	__u32				cw;
 	__u32				sw;
@@ -117,7 +118,10 @@ struct _fpstate {
 	__u32				reserved;
 	struct _fpxreg			_fxsr_st[8];	/* FXSR FPU reg data is ignored */
 	struct _xmmreg			_xmm[8];	/* First 8 XMM registers */
-	__u32				padding1[44];	/* Second 8 XMM registers plus padding */
+	union {
+		__u32			padding1[44];	/* Second 8 XMM registers plus padding */
+		__u32			padding[44];	/* Alias name for old user-space */
+	};
 
 	union {
 		__u32			padding2[12];
@@ -125,10 +129,8 @@ struct _fpstate {
 	};
 };
 
-#else /* __x86_64__: */
-
 /*
- * The FXSAVE frame.
+ * The 64-bit FPU frame. (FXSAVE format and later)
  *
  * Note1: If sw_reserved.magic1 == FP_XSTATE_MAGIC1 then the structure is
  *        larger: 'struct _xstate'. Note that 'struct _xstate' embedds
@@ -138,7 +140,7 @@ struct _fpstate {
  * Note2: Reserved fields may someday contain valuable data. Always save/restore
  *        them when you change signal frames.
  */
-struct _fpstate {
+struct _fpstate_64 {
 	__u16				cwd;
 	__u16				swd;
 	/* Note this is not the same as the 32-bit/x87/FSAVE twd: */
@@ -157,7 +159,13 @@ struct _fpstate {
 	};
 };
 
-#endif /* __x86_64__ */
+#ifdef __i386__
+# define _fpstate _fpstate_32
+#else
+# define _fpstate _fpstate_64
+#endif
+
+#define _fpstate_ia32 _fpstate_32
 
 struct _header {
 	__u64				xfeatures;

commit 337a167d1a5b2704414679d1a993220a4613ec13
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:34 2015 +0200

    x86/headers: Unify register type definitions between 32-bit compat and i386
    
    The following sigcontext related types were duplicated across
    native 32-bit and compat 32-bit headers:
    
      struct _fpreg;
      struct _fpxreg;
      struct _xmmreg;
    
      X86_FXSR_MAGIC
    
    Unify them.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-7-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 07b0e32a1d23..9df4df3e40ef 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -63,7 +63,6 @@ struct _fpx_sw_bytes {
 	__u32				padding[7];
 };
 
-#ifdef __i386__
 /*
  * As documented in the iBCS2 standard:
  *
@@ -96,6 +95,8 @@ struct _xmmreg {
 
 #define X86_FXSR_MAGIC			0x0000
 
+#ifdef __i386__
+
 struct _fpstate {
 	/* Legacy FPU environment: */
 	__u32				cw;

commit 3f623a5b27c150451387e358774131780dbd2407
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:33 2015 +0200

    x86/headers: Use ABI types consistently in sigcontext*.h
    
    Use the __u16/32/64 types we standardized on in ABI definitions
    - and which most of this header was already using.
    
    This will allow us to more obviously unify the compat header
    into the main header.
    
    No change in functionality.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-6-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 40d6cbac08c6..07b0e32a1d23 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -78,48 +78,48 @@ struct _fpx_sw_bytes {
 
 /* 10-byte legacy floating point register: */
 struct _fpreg {
-	unsigned short			significand[4];
-	unsigned short			exponent;
+	__u16				significand[4];
+	__u16				exponent;
 };
 
 /* 16-byte floating point register: */
 struct _fpxreg {
-	unsigned short			significand[4];
-	unsigned short			exponent;
-	unsigned short			padding[3];
+	__u16				significand[4];
+	__u16				exponent;
+	__u16				padding[3];
 };
 
 /* 16-byte XMM register: */
 struct _xmmreg {
-	unsigned long			element[4];
+	__u32				element[4];
 };
 
 #define X86_FXSR_MAGIC			0x0000
 
 struct _fpstate {
 	/* Legacy FPU environment: */
-	unsigned long			cw;
-	unsigned long			sw;
-	unsigned long			tag;
-	unsigned long			ipoff;
-	unsigned long			cssel;
-	unsigned long			dataoff;
-	unsigned long			datasel;
+	__u32				cw;
+	__u32				sw;
+	__u32				tag;
+	__u32				ipoff;
+	__u32				cssel;
+	__u32				dataoff;
+	__u32				datasel;
 	struct _fpreg			_st[8];
-	unsigned short			status;
-	unsigned short			magic;		/* 0xffff: regular FPU data only */
+	__u16				status;
+	__u16				magic;		/* 0xffff: regular FPU data only */
 							/* 0x0000: FXSR FPU data */
 
 	/* FXSR FPU environment */
-	unsigned long			_fxsr_env[6];	/* FXSR FPU env is ignored */
-	unsigned long			mxcsr;
-	unsigned long			reserved;
+	__u32				_fxsr_env[6];	/* FXSR FPU env is ignored */
+	__u32				mxcsr;
+	__u32				reserved;
 	struct _fpxreg			_fxsr_st[8];	/* FXSR FPU reg data is ignored */
 	struct _xmmreg			_xmm[8];	/* First 8 XMM registers */
-	unsigned long			padding1[44];	/* Second 8 XMM registers plus padding */
+	__u32				padding1[44];	/* Second 8 XMM registers plus padding */
 
 	union {
-		unsigned long		padding2[12];
+		__u32			padding2[12];
 		struct _fpx_sw_bytes	sw_reserved;	/* Potential extended state is encoded here */
 	};
 };
@@ -191,28 +191,28 @@ struct _xstate {
 #ifndef __KERNEL__
 # ifdef __i386__
 struct sigcontext {
-	unsigned short			gs, __gsh;
-	unsigned short			fs, __fsh;
-	unsigned short			es, __esh;
-	unsigned short			ds, __dsh;
-	unsigned long			edi;
-	unsigned long			esi;
-	unsigned long			ebp;
-	unsigned long			esp;
-	unsigned long			ebx;
-	unsigned long			edx;
-	unsigned long			ecx;
-	unsigned long			eax;
-	unsigned long			trapno;
-	unsigned long			err;
-	unsigned long			eip;
-	unsigned short			cs, __csh;
-	unsigned long			eflags;
-	unsigned long			esp_at_signal;
-	unsigned short			ss, __ssh;
+	__u16				gs, __gsh;
+	__u16				fs, __fsh;
+	__u16				es, __esh;
+	__u16				ds, __dsh;
+	__u32				edi;
+	__u32				esi;
+	__u32				ebp;
+	__u32				esp;
+	__u32				ebx;
+	__u32				edx;
+	__u32				ecx;
+	__u32				eax;
+	__u32				trapno;
+	__u32				err;
+	__u32				eip;
+	__u16				cs, __csh;
+	__u32				eflags;
+	__u32				esp_at_signal;
+	__u16				ss, __ssh;
 	struct _fpstate __user		*fpstate;
-	unsigned long			oldmask;
-	unsigned long			cr2;
+	__u32				oldmask;
+	__u32				cr2;
 };
 # else /* __x86_64__: */
 struct sigcontext {

commit 128f8257a17a47b9a40f550cc2f36458cd8c07b0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:32 2015 +0200

    x86/headers: Separate out legacy user-space structure definitions
    
    Better separate the user-space struct sigcontext definitions
    from the kernel definitions, so that we can unify the kernel
    definitions with sigcontext32.h.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-5-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index f89b2f1abe7c..40d6cbac08c6 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -124,36 +124,6 @@ struct _fpstate {
 	};
 };
 
-# ifndef __KERNEL__
-/*
- * User-space might still rely on the old definition:
- */
-struct sigcontext {
-	unsigned short			gs, __gsh;
-	unsigned short			fs, __fsh;
-	unsigned short			es, __esh;
-	unsigned short			ds, __dsh;
-	unsigned long			edi;
-	unsigned long			esi;
-	unsigned long			ebp;
-	unsigned long			esp;
-	unsigned long			ebx;
-	unsigned long			edx;
-	unsigned long			ecx;
-	unsigned long			eax;
-	unsigned long			trapno;
-	unsigned long			err;
-	unsigned long			eip;
-	unsigned short			cs, __csh;
-	unsigned long			eflags;
-	unsigned long			esp_at_signal;
-	unsigned short			ss, __ssh;
-	struct _fpstate __user		*fpstate;
-	unsigned long			oldmask;
-	unsigned long			cr2;
-};
-# endif /* !__KERNEL__ */
-
 #else /* __x86_64__: */
 
 /*
@@ -186,10 +156,65 @@ struct _fpstate {
 	};
 };
 
-# ifndef __KERNEL__
+#endif /* __x86_64__ */
+
+struct _header {
+	__u64				xfeatures;
+	__u64				reserved1[2];
+	__u64				reserved2[5];
+};
+
+struct _ymmh_state {
+	/* 16x YMM registers, 16 bytes each: */
+	__u32				ymmh_space[64];
+};
+
 /*
- * User-space might still rely on the old definition:
+ * Extended state pointed to by sigcontext::fpstate.
+ *
+ * In addition to the fpstate, information encoded in _xstate::xstate_hdr
+ * indicates the presence of other extended state information supported
+ * by the CPU and kernel:
  */
+struct _xstate {
+	struct _fpstate			fpstate;
+	struct _header			xstate_hdr;
+	struct _ymmh_state		ymmh;
+	/* New processor state extensions go here: */
+};
+
+/*
+ * The old user-space sigcontext definition, just in case user-space still
+ * relies on it. The kernel definition (in asm/sigcontext.h) has unified
+ * field names but otherwise the same layout.
+ */
+#ifndef __KERNEL__
+# ifdef __i386__
+struct sigcontext {
+	unsigned short			gs, __gsh;
+	unsigned short			fs, __fsh;
+	unsigned short			es, __esh;
+	unsigned short			ds, __dsh;
+	unsigned long			edi;
+	unsigned long			esi;
+	unsigned long			ebp;
+	unsigned long			esp;
+	unsigned long			ebx;
+	unsigned long			edx;
+	unsigned long			ecx;
+	unsigned long			eax;
+	unsigned long			trapno;
+	unsigned long			err;
+	unsigned long			eip;
+	unsigned short			cs, __csh;
+	unsigned long			eflags;
+	unsigned long			esp_at_signal;
+	unsigned short			ss, __ssh;
+	struct _fpstate __user		*fpstate;
+	unsigned long			oldmask;
+	unsigned long			cr2;
+};
+# else /* __x86_64__: */
 struct sigcontext {
 	__u64				r8;
 	__u64				r9;
@@ -223,33 +248,7 @@ struct sigcontext {
 #  endif
 	__u64				reserved1[8];
 };
-# endif /* !__KERNEL__ */
-
-#endif /* __x86_64__ */
-
-struct _header {
-	__u64				xfeatures;
-	__u64				reserved1[2];
-	__u64				reserved2[5];
-};
-
-struct _ymmh_state {
-	/* 16x YMM registers, 16 bytes each: */
-	__u32				ymmh_space[64];
-};
-
-/*
- * Extended state pointed to by sigcontext::fpstate.
- *
- * In addition to the fpstate, information encoded in _xstate::xstate_hdr
- * indicates the presence of other extended state information supported
- * by the CPU and kernel:
- */
-struct _xstate {
-	struct _fpstate			fpstate;
-	struct _header			xstate_hdr;
-	struct _ymmh_state		ymmh;
-	/* New processor state extensions go here: */
-};
+# endif /* __x86_64__ */
+#endif /* !__KERNEL__ */
 
 #endif /* _UAPI_ASM_X86_SIGCONTEXT_H */

commit cbf5f4fbf435e871e59d49653d555266b8796efc
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Sep 5 09:32:31 2015 +0200

    x86/headers: Clean up and better document uapi/asm/sigcontext.h
    
    Clean up sigcontext.h:
    
     - the explanations were full of typos and were hard to read in general
     - use consistent and readable vertical spacing
     - fix, harmonize and extend comments
    
    No field name has been changed, user-space might be relying on
    them.
    
    Acked-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1441438363-9999-4-git-send-email-mingo@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 40836a9a7250..f89b2f1abe7c 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -1,221 +1,255 @@
 #ifndef _UAPI_ASM_X86_SIGCONTEXT_H
 #define _UAPI_ASM_X86_SIGCONTEXT_H
 
+/*
+ * Linux signal context definitions. The sigcontext includes a complex hierarchy of CPU
+ * and FPU state, available to user-space (on the stack) when a signal handler is
+ * executed.
+ *
+ * As over the years this ABI grew from its very simple roots towards supporting more and
+ * more CPU state organically, some of the details (which were rather clever hacks back
+ * in the days) became a bit quirky by today.
+ *
+ * The current ABI includes flexible provisions for future extensions, so we won't have
+ * to grow new quirks for quite some time. Promise!
+ */
+
 #include <linux/compiler.h>
 #include <linux/types.h>
 
-#define FP_XSTATE_MAGIC1	0x46505853U
-#define FP_XSTATE_MAGIC2	0x46505845U
-#define FP_XSTATE_MAGIC2_SIZE	sizeof(FP_XSTATE_MAGIC2)
+#define FP_XSTATE_MAGIC1		0x46505853U
+#define FP_XSTATE_MAGIC2		0x46505845U
+#define FP_XSTATE_MAGIC2_SIZE		sizeof(FP_XSTATE_MAGIC2)
 
 /*
- * bytes 464..511 in the current 512byte layout of fxsave/fxrstor frame
- * are reserved for SW usage. On cpu's supporting xsave/xrstor, these bytes
- * are used to extended the fpstate pointer in the sigcontext, which now
+ * Bytes 464..511 in the current 512-byte layout of the FXSAVE/FXRSTOR frame
+ * are reserved for SW usage. On CPUs supporting XSAVE/XRSTOR, these bytes
+ * are used to extend the fpstate pointer in the sigcontext, which now
  * includes the extended state information along with fpstate information.
  *
- * Presence of FP_XSTATE_MAGIC1 at the beginning of this SW reserved
- * area and FP_XSTATE_MAGIC2 at the end of memory layout
- * (extended_size - FP_XSTATE_MAGIC2_SIZE) indicates the presence of the
- * extended state information in the memory layout pointed by the fpstate
- * pointer in sigcontext.
+ * If sw_reserved.magic1 == FP_XSTATE_MAGIC1 then there's a sw_reserved.extended_size
+ * bytes large extended context area present. (The last 32-bit word of this extended
+ * area (at the fpstate+extended_size-FP_XSTATE_MAGIC2_SIZE address) is set to
+ * FP_XSTATE_MAGIC2 so that you can sanity check your size calculations.)
+ *
+ * This extended area typically grows with newer CPUs that have larger and larger
+ * XSAVE areas.
  */
 struct _fpx_sw_bytes {
-	__u32 magic1;		/* FP_XSTATE_MAGIC1 */
-	__u32 extended_size;	/* total size of the layout referred by
-				 * fpstate pointer in the sigcontext.
-				 */
-	__u64 xfeatures;
-				/* feature bit mask (including fp/sse/extended
-				 * state) that is present in the memory
-				 * layout.
-				 */
-	__u32 xstate_size;	/* actual xsave state size, based on the
-				 * features saved in the layout.
-				 * 'extended_size' will be greater than
-				 * 'xstate_size'.
-				 */
-	__u32 padding[7];	/*  for future use. */
+	/* If set to FP_XSTATE_MAGIC1 then this is an xstate context. 0 if a legacy frame. */
+	__u32				magic1;
+
+	/*
+	 * Total size of the fpstate area:
+	 *
+	 *  - if magic1 == 0 then it's sizeof(struct _fpstate)
+	 *  - if magic1 == FP_XSTATE_MAGIC1 then it's sizeof(struct _xstate) plus extensions (if any)
+	 */
+	__u32				extended_size;
+
+	/*
+	 * Feature bit mask (including FP/SSE/extended state) that is present
+	 * in the memory layout:
+	 */
+	__u64				xfeatures;
+
+	/*
+	 * Actual XSAVE state size, based on the xfeatures saved in the layout.
+	 * 'extended_size' is greater than 'xstate_size':
+	 */
+	__u32				xstate_size;
+
+	/* For future use: */
+	__u32				padding[7];
 };
 
 #ifdef __i386__
 /*
- * As documented in the iBCS2 standard..
+ * As documented in the iBCS2 standard:
  *
  * The first part of "struct _fpstate" is just the normal i387
  * hardware setup, the extra "status" word is used to save the
  * coprocessor status word before entering the handler.
  *
- * Pentium III FXSR, SSE support
- *	Gareth Hughes <gareth@valinux.com>, May 2000
- *
  * The FPU state data structure has had to grow to accommodate the
  * extended FPU state required by the Streaming SIMD Extensions.
  * There is no documented standard to accomplish this at the moment.
  */
+
+/* 10-byte legacy floating point register: */
 struct _fpreg {
-	unsigned short significand[4];
-	unsigned short exponent;
+	unsigned short			significand[4];
+	unsigned short			exponent;
 };
 
+/* 16-byte floating point register: */
 struct _fpxreg {
-	unsigned short significand[4];
-	unsigned short exponent;
-	unsigned short padding[3];
+	unsigned short			significand[4];
+	unsigned short			exponent;
+	unsigned short			padding[3];
 };
 
+/* 16-byte XMM register: */
 struct _xmmreg {
-	unsigned long element[4];
+	unsigned long			element[4];
 };
 
+#define X86_FXSR_MAGIC			0x0000
+
 struct _fpstate {
-	/* Regular FPU environment */
-	unsigned long	cw;
-	unsigned long	sw;
-	unsigned long	tag;
-	unsigned long	ipoff;
-	unsigned long	cssel;
-	unsigned long	dataoff;
-	unsigned long	datasel;
-	struct _fpreg	_st[8];
-	unsigned short	status;
-	unsigned short	magic;		/* 0xffff = regular FPU data only */
+	/* Legacy FPU environment: */
+	unsigned long			cw;
+	unsigned long			sw;
+	unsigned long			tag;
+	unsigned long			ipoff;
+	unsigned long			cssel;
+	unsigned long			dataoff;
+	unsigned long			datasel;
+	struct _fpreg			_st[8];
+	unsigned short			status;
+	unsigned short			magic;		/* 0xffff: regular FPU data only */
+							/* 0x0000: FXSR FPU data */
 
 	/* FXSR FPU environment */
-	unsigned long	_fxsr_env[6];	/* FXSR FPU env is ignored */
-	unsigned long	mxcsr;
-	unsigned long	reserved;
-	struct _fpxreg	_fxsr_st[8];	/* FXSR FPU reg data is ignored */
-	struct _xmmreg	_xmm[8];
-	unsigned long	padding1[44];
+	unsigned long			_fxsr_env[6];	/* FXSR FPU env is ignored */
+	unsigned long			mxcsr;
+	unsigned long			reserved;
+	struct _fpxreg			_fxsr_st[8];	/* FXSR FPU reg data is ignored */
+	struct _xmmreg			_xmm[8];	/* First 8 XMM registers */
+	unsigned long			padding1[44];	/* Second 8 XMM registers plus padding */
 
 	union {
-		unsigned long	padding2[12];
-		struct _fpx_sw_bytes sw_reserved; /* represents the extended
-						   * state info */
+		unsigned long		padding2[12];
+		struct _fpx_sw_bytes	sw_reserved;	/* Potential extended state is encoded here */
 	};
 };
 
-#define X86_FXSR_MAGIC		0x0000
-
-#ifndef __KERNEL__
+# ifndef __KERNEL__
 /*
  * User-space might still rely on the old definition:
  */
 struct sigcontext {
-	unsigned short gs, __gsh;
-	unsigned short fs, __fsh;
-	unsigned short es, __esh;
-	unsigned short ds, __dsh;
-	unsigned long edi;
-	unsigned long esi;
-	unsigned long ebp;
-	unsigned long esp;
-	unsigned long ebx;
-	unsigned long edx;
-	unsigned long ecx;
-	unsigned long eax;
-	unsigned long trapno;
-	unsigned long err;
-	unsigned long eip;
-	unsigned short cs, __csh;
-	unsigned long eflags;
-	unsigned long esp_at_signal;
-	unsigned short ss, __ssh;
-	struct _fpstate __user *fpstate;
-	unsigned long oldmask;
-	unsigned long cr2;
+	unsigned short			gs, __gsh;
+	unsigned short			fs, __fsh;
+	unsigned short			es, __esh;
+	unsigned short			ds, __dsh;
+	unsigned long			edi;
+	unsigned long			esi;
+	unsigned long			ebp;
+	unsigned long			esp;
+	unsigned long			ebx;
+	unsigned long			edx;
+	unsigned long			ecx;
+	unsigned long			eax;
+	unsigned long			trapno;
+	unsigned long			err;
+	unsigned long			eip;
+	unsigned short			cs, __csh;
+	unsigned long			eflags;
+	unsigned long			esp_at_signal;
+	unsigned short			ss, __ssh;
+	struct _fpstate __user		*fpstate;
+	unsigned long			oldmask;
+	unsigned long			cr2;
 };
-#endif /* !__KERNEL__ */
+# endif /* !__KERNEL__ */
 
-#else /* __i386__ */
+#else /* __x86_64__: */
 
-/* FXSAVE frame */
-/* Note: reserved1/2 may someday contain valuable data. Always save/restore
-   them when you change signal frames. */
+/*
+ * The FXSAVE frame.
+ *
+ * Note1: If sw_reserved.magic1 == FP_XSTATE_MAGIC1 then the structure is
+ *        larger: 'struct _xstate'. Note that 'struct _xstate' embedds
+ *        'struct _fpstate' so that you can always assume the _fpstate portion
+ *        exists so that you can check the magic value.
+ *
+ * Note2: Reserved fields may someday contain valuable data. Always save/restore
+ *        them when you change signal frames.
+ */
 struct _fpstate {
-	__u16	cwd;
-	__u16	swd;
-	__u16	twd;		/* Note this is not the same as the
-				   32bit/x87/FSAVE twd */
-	__u16	fop;
-	__u64	rip;
-	__u64	rdp;
-	__u32	mxcsr;
-	__u32	mxcsr_mask;
-	__u32	st_space[32];	/* 8*16 bytes for each FP-reg */
-	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg  */
-	__u32	reserved2[12];
+	__u16				cwd;
+	__u16				swd;
+	/* Note this is not the same as the 32-bit/x87/FSAVE twd: */
+	__u16				twd;
+	__u16				fop;
+	__u64				rip;
+	__u64				rdp;
+	__u32				mxcsr;
+	__u32				mxcsr_mask;
+	__u32				st_space[32];	/*  8x  FP registers, 16 bytes each */
+	__u32				xmm_space[64];	/* 16x XMM registers, 16 bytes each */
+	__u32				reserved2[12];
 	union {
-		__u32	reserved3[12];
-		struct _fpx_sw_bytes sw_reserved; /* represents the extended
-						   * state information */
+		__u32			reserved3[12];
+		struct _fpx_sw_bytes	sw_reserved;	/* Potential extended state is encoded here */
 	};
 };
 
-#ifndef __KERNEL__
+# ifndef __KERNEL__
 /*
  * User-space might still rely on the old definition:
  */
 struct sigcontext {
-	__u64 r8;
-	__u64 r9;
-	__u64 r10;
-	__u64 r11;
-	__u64 r12;
-	__u64 r13;
-	__u64 r14;
-	__u64 r15;
-	__u64 rdi;
-	__u64 rsi;
-	__u64 rbp;
-	__u64 rbx;
-	__u64 rdx;
-	__u64 rax;
-	__u64 rcx;
-	__u64 rsp;
-	__u64 rip;
-	__u64 eflags;		/* RFLAGS */
-	__u16 cs;
-	__u16 gs;
-	__u16 fs;
-	__u16 __pad0;
-	__u64 err;
-	__u64 trapno;
-	__u64 oldmask;
-	__u64 cr2;
-	struct _fpstate __user *fpstate;	/* zero when no FPU context */
-#ifdef __ILP32__
-	__u32 __fpstate_pad;
-#endif
-	__u64 reserved1[8];
+	__u64				r8;
+	__u64				r9;
+	__u64				r10;
+	__u64				r11;
+	__u64				r12;
+	__u64				r13;
+	__u64				r14;
+	__u64				r15;
+	__u64				rdi;
+	__u64				rsi;
+	__u64				rbp;
+	__u64				rbx;
+	__u64				rdx;
+	__u64				rax;
+	__u64				rcx;
+	__u64				rsp;
+	__u64				rip;
+	__u64				eflags;		/* RFLAGS */
+	__u16				cs;
+	__u16				gs;
+	__u16				fs;
+	__u16				__pad0;
+	__u64				err;
+	__u64				trapno;
+	__u64				oldmask;
+	__u64				cr2;
+	struct _fpstate __user		*fpstate;	/* Zero when no FPU context */
+#  ifdef __ILP32__
+	__u32				__fpstate_pad;
+#  endif
+	__u64				reserved1[8];
 };
-#endif /* !__KERNEL__ */
+# endif /* !__KERNEL__ */
 
-#endif /* !__i386__ */
+#endif /* __x86_64__ */
 
 struct _header {
-	__u64 xfeatures;
-	__u64 reserved1[2];
-	__u64 reserved2[5];
+	__u64				xfeatures;
+	__u64				reserved1[2];
+	__u64				reserved2[5];
 };
 
 struct _ymmh_state {
-	/* 16 * 16 bytes for each YMMH-reg */
-	__u32 ymmh_space[64];
+	/* 16x YMM registers, 16 bytes each: */
+	__u32				ymmh_space[64];
 };
 
 /*
- * Extended state pointed by the fpstate pointer in the sigcontext.
- * In addition to the fpstate, information encoded in the xstate_hdr
- * indicates the presence of other extended state information
- * supported by the processor and OS.
+ * Extended state pointed to by sigcontext::fpstate.
+ *
+ * In addition to the fpstate, information encoded in _xstate::xstate_hdr
+ * indicates the presence of other extended state information supported
+ * by the CPU and kernel:
  */
 struct _xstate {
-	struct _fpstate fpstate;
-	struct _header xstate_hdr;
-	struct _ymmh_state ymmh;
-	/* new processor state extensions go here */
+	struct _fpstate			fpstate;
+	struct _header			xstate_hdr;
+	struct _ymmh_state		ymmh;
+	/* New processor state extensions go here: */
 };
 
 #endif /* _UAPI_ASM_X86_SIGCONTEXT_H */

commit ed596cde9425509ec6ce88e19f03e9b13b6f518b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 13 08:25:20 2015 -0700

    Revert x86 sigcontext cleanups
    
    This reverts commits 9a036b93a344 ("x86/signal/64: Remove 'fs' and 'gs'
    from sigcontext") and c6f2062935c8 ("x86/signal/64: Fix SS handling for
    signals delivered to 64-bit programs").
    
    They were cleanups, but they break dosemu by changing the signal return
    behavior (and removing 'fs' and 'gs' from the sigcontext struct - while
    not actually changing any behavior - causes build problems).
    
    Reported-and-tested-by: Stas Sergeev <stsp@list.ru>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 0e8a973de9ee..40836a9a7250 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -177,24 +177,9 @@ struct sigcontext {
 	__u64 rip;
 	__u64 eflags;		/* RFLAGS */
 	__u16 cs;
-
-	/*
-	 * Prior to 2.5.64 ("[PATCH] x86-64 updates for 2.5.64-bk3"),
-	 * Linux saved and restored fs and gs in these slots.  This
-	 * was counterproductive, as fsbase and gsbase were never
-	 * saved, so arch_prctl was presumably unreliable.
-	 *
-	 * If these slots are ever needed for any other purpose, there
-	 * is some risk that very old 64-bit binaries could get
-	 * confused.  I doubt that many such binaries still work,
-	 * though, since the same patch in 2.5.64 also removed the
-	 * 64-bit set_thread_area syscall, so it appears that there is
-	 * no TLS API that works in both pre- and post-2.5.64 kernels.
-	 */
-	__u16 __pad2;		/* Was gs. */
-	__u16 __pad1;		/* Was fs. */
-
-	__u16 ss;
+	__u16 gs;
+	__u16 fs;
+	__u16 __pad0;
 	__u64 err;
 	__u64 trapno;
 	__u64 oldmask;

commit 400e4b209166dcd3e3a155401c57bdc6413bf715
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Apr 24 10:19:47 2015 +0200

    x86/fpu: Rename xsave.header::xstate_bv to 'xfeatures'
    
    'xsave.header::xstate_bv' is a misnomer - what does 'bv' stand for?
    
    It probably comes from the 'XGETBV' instruction name, but I could
    not find in the Intel documentation where that abbreviation comes
    from. It could mean 'bit vector' - or something else?
    
    But how about - instead of guessing about a weird name - we named
    the field in an obvious and descriptive way that tells us exactly
    what it does?
    
    So rename it to 'xfeatures', which is a bitmask of the
    xfeatures that are fpstate_active in that context structure.
    
    Eyesore like:
    
               fpu->state->xsave.xsave_hdr.xstate_bv |= XSTATE_FP;
    
    is now much more readable:
    
               fpu->state->xsave.header.xfeatures |= XSTATE_FP;
    
    Which form is not just infinitely more readable, but is also
    shorter as well.
    
    Reviewed-by: Borislav Petkov <bp@alien8.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 7f850f7b5c45..0e8a973de9ee 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -25,7 +25,7 @@ struct _fpx_sw_bytes {
 	__u32 extended_size;	/* total size of the layout referred by
 				 * fpstate pointer in the sigcontext.
 				 */
-	__u64 xstate_bv;
+	__u64 xfeatures;
 				/* feature bit mask (including fp/sse/extended
 				 * state) that is present in the memory
 				 * layout.
@@ -210,7 +210,7 @@ struct sigcontext {
 #endif /* !__i386__ */
 
 struct _header {
-	__u64 xstate_bv;
+	__u64 xfeatures;
 	__u64 reserved1[2];
 	__u64 reserved2[5];
 };

commit 3a54450b5ed1671a6adecf501a0b4d4c1d27235d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Apr 24 10:14:36 2015 +0200

    x86/fpu: Rename 'xsave_hdr' to 'header'
    
    Code like:
    
               fpu->state->xsave.xsave_hdr.xstate_bv |= XSTATE_FP;
    
    is an eyesore, because not only is the words 'xsave' and 'state'
    are repeated twice times (!), but also because of the 'hdr' and 'bv'
    abbreviations that are pretty meaningless at a first glance.
    
    Start cleaning this up by renaming 'xsave_hdr' to 'header'.
    
    Reviewed-by: Borislav Petkov <bp@alien8.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 16dc4e8a2cd3..7f850f7b5c45 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -209,7 +209,7 @@ struct sigcontext {
 
 #endif /* !__i386__ */
 
-struct _xsave_hdr {
+struct _header {
 	__u64 xstate_bv;
 	__u64 reserved1[2];
 	__u64 reserved2[5];
@@ -228,7 +228,7 @@ struct _ymmh_state {
  */
 struct _xstate {
 	struct _fpstate fpstate;
-	struct _xsave_hdr xstate_hdr;
+	struct _header xstate_hdr;
 	struct _ymmh_state ymmh;
 	/* new processor state extensions go here */
 };

commit 9a036b93a344235b7899401d04e97c34f3a2554c
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Thu Mar 12 13:57:52 2015 -0700

    x86/signal/64: Remove 'fs' and 'gs' from sigcontext
    
    As far as I can tell, these fields have been set to zero on save
    and ignored on restore since Linux was imported into git.
    Rename them '__pad1' and '__pad2' to avoid confusion.  This may
    also allow us to recycle them some day.
    
    This also adds a comment clarifying the history of those fields.
    
    I'm intentionally avoiding calling either of them '__pad0': the
    field formerly known as '__pad0' is now 'ss'.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/844f8490e938780c03355be4c9b69eb4c494bf4e.1426193719.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index 076b11fd6fa1..16dc4e8a2cd3 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -177,8 +177,23 @@ struct sigcontext {
 	__u64 rip;
 	__u64 eflags;		/* RFLAGS */
 	__u16 cs;
-	__u16 gs;
-	__u16 fs;
+
+	/*
+	 * Prior to 2.5.64 ("[PATCH] x86-64 updates for 2.5.64-bk3"),
+	 * Linux saved and restored fs and gs in these slots.  This
+	 * was counterproductive, as fsbase and gsbase were never
+	 * saved, so arch_prctl was presumably unreliable.
+	 *
+	 * If these slots are ever needed for any other purpose, there
+	 * is some risk that very old 64-bit binaries could get
+	 * confused.  I doubt that many such binaries still work,
+	 * though, since the same patch in 2.5.64 also removed the
+	 * 64-bit set_thread_area syscall, so it appears that there is
+	 * no TLS API that works in both pre- and post-2.5.64 kernels.
+	 */
+	__u16 __pad2;		/* Was gs. */
+	__u16 __pad1;		/* Was fs. */
+
 	__u16 ss;
 	__u64 err;
 	__u64 trapno;

commit c6f2062935c8fcb31235799eaee8bcd5b649936b
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Thu Mar 12 13:57:51 2015 -0700

    x86/signal/64: Fix SS handling for signals delivered to 64-bit programs
    
    The comment in the signal code says that apps can save/restore
    other segments on their own.  It's true that apps can *save* SS
    on their own, but there's no way for apps to restore it: SYSCALL
    effectively resets SS to __USER_DS, so any value that user code
    tries to load into SS gets lost on entry to sigreturn.
    
    This recycles two padding bytes in the segment selector area for SS.
    
    While we're at it, we need a second change to make this useful.
    
    If the signal we're delivering is caused by a bad SS value,
    saving that value isn't enough.  We need to remove that bad
    value from the regs before we try to deliver the signal.  Oddly,
    the i386 code already got this right.
    
    I suspect that 64-bit programs that try to run 16-bit code and
    use signals will have a lot of trouble without this.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/405594361340a2ec32f8e2b115c142df0e180d8e.1426193719.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
index d8b9f9081e86..076b11fd6fa1 100644
--- a/arch/x86/include/uapi/asm/sigcontext.h
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -179,7 +179,7 @@ struct sigcontext {
 	__u16 cs;
 	__u16 gs;
 	__u16 fs;
-	__u16 __pad0;
+	__u16 ss;
 	__u64 err;
 	__u64 trapno;
 	__u64 oldmask;

commit af170c5061dd78512c469e6e2d211980cdb2c193
Author: David Howells <dhowells@redhat.com>
Date:   Fri Dec 14 22:37:13 2012 +0000

    UAPI: (Scripted) Disintegrate arch/x86/include/asm
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h
new file mode 100644
index 000000000000..d8b9f9081e86
--- /dev/null
+++ b/arch/x86/include/uapi/asm/sigcontext.h
@@ -0,0 +1,221 @@
+#ifndef _UAPI_ASM_X86_SIGCONTEXT_H
+#define _UAPI_ASM_X86_SIGCONTEXT_H
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+
+#define FP_XSTATE_MAGIC1	0x46505853U
+#define FP_XSTATE_MAGIC2	0x46505845U
+#define FP_XSTATE_MAGIC2_SIZE	sizeof(FP_XSTATE_MAGIC2)
+
+/*
+ * bytes 464..511 in the current 512byte layout of fxsave/fxrstor frame
+ * are reserved for SW usage. On cpu's supporting xsave/xrstor, these bytes
+ * are used to extended the fpstate pointer in the sigcontext, which now
+ * includes the extended state information along with fpstate information.
+ *
+ * Presence of FP_XSTATE_MAGIC1 at the beginning of this SW reserved
+ * area and FP_XSTATE_MAGIC2 at the end of memory layout
+ * (extended_size - FP_XSTATE_MAGIC2_SIZE) indicates the presence of the
+ * extended state information in the memory layout pointed by the fpstate
+ * pointer in sigcontext.
+ */
+struct _fpx_sw_bytes {
+	__u32 magic1;		/* FP_XSTATE_MAGIC1 */
+	__u32 extended_size;	/* total size of the layout referred by
+				 * fpstate pointer in the sigcontext.
+				 */
+	__u64 xstate_bv;
+				/* feature bit mask (including fp/sse/extended
+				 * state) that is present in the memory
+				 * layout.
+				 */
+	__u32 xstate_size;	/* actual xsave state size, based on the
+				 * features saved in the layout.
+				 * 'extended_size' will be greater than
+				 * 'xstate_size'.
+				 */
+	__u32 padding[7];	/*  for future use. */
+};
+
+#ifdef __i386__
+/*
+ * As documented in the iBCS2 standard..
+ *
+ * The first part of "struct _fpstate" is just the normal i387
+ * hardware setup, the extra "status" word is used to save the
+ * coprocessor status word before entering the handler.
+ *
+ * Pentium III FXSR, SSE support
+ *	Gareth Hughes <gareth@valinux.com>, May 2000
+ *
+ * The FPU state data structure has had to grow to accommodate the
+ * extended FPU state required by the Streaming SIMD Extensions.
+ * There is no documented standard to accomplish this at the moment.
+ */
+struct _fpreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+};
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	unsigned long element[4];
+};
+
+struct _fpstate {
+	/* Regular FPU environment */
+	unsigned long	cw;
+	unsigned long	sw;
+	unsigned long	tag;
+	unsigned long	ipoff;
+	unsigned long	cssel;
+	unsigned long	dataoff;
+	unsigned long	datasel;
+	struct _fpreg	_st[8];
+	unsigned short	status;
+	unsigned short	magic;		/* 0xffff = regular FPU data only */
+
+	/* FXSR FPU environment */
+	unsigned long	_fxsr_env[6];	/* FXSR FPU env is ignored */
+	unsigned long	mxcsr;
+	unsigned long	reserved;
+	struct _fpxreg	_fxsr_st[8];	/* FXSR FPU reg data is ignored */
+	struct _xmmreg	_xmm[8];
+	unsigned long	padding1[44];
+
+	union {
+		unsigned long	padding2[12];
+		struct _fpx_sw_bytes sw_reserved; /* represents the extended
+						   * state info */
+	};
+};
+
+#define X86_FXSR_MAGIC		0x0000
+
+#ifndef __KERNEL__
+/*
+ * User-space might still rely on the old definition:
+ */
+struct sigcontext {
+	unsigned short gs, __gsh;
+	unsigned short fs, __fsh;
+	unsigned short es, __esh;
+	unsigned short ds, __dsh;
+	unsigned long edi;
+	unsigned long esi;
+	unsigned long ebp;
+	unsigned long esp;
+	unsigned long ebx;
+	unsigned long edx;
+	unsigned long ecx;
+	unsigned long eax;
+	unsigned long trapno;
+	unsigned long err;
+	unsigned long eip;
+	unsigned short cs, __csh;
+	unsigned long eflags;
+	unsigned long esp_at_signal;
+	unsigned short ss, __ssh;
+	struct _fpstate __user *fpstate;
+	unsigned long oldmask;
+	unsigned long cr2;
+};
+#endif /* !__KERNEL__ */
+
+#else /* __i386__ */
+
+/* FXSAVE frame */
+/* Note: reserved1/2 may someday contain valuable data. Always save/restore
+   them when you change signal frames. */
+struct _fpstate {
+	__u16	cwd;
+	__u16	swd;
+	__u16	twd;		/* Note this is not the same as the
+				   32bit/x87/FSAVE twd */
+	__u16	fop;
+	__u64	rip;
+	__u64	rdp;
+	__u32	mxcsr;
+	__u32	mxcsr_mask;
+	__u32	st_space[32];	/* 8*16 bytes for each FP-reg */
+	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg  */
+	__u32	reserved2[12];
+	union {
+		__u32	reserved3[12];
+		struct _fpx_sw_bytes sw_reserved; /* represents the extended
+						   * state information */
+	};
+};
+
+#ifndef __KERNEL__
+/*
+ * User-space might still rely on the old definition:
+ */
+struct sigcontext {
+	__u64 r8;
+	__u64 r9;
+	__u64 r10;
+	__u64 r11;
+	__u64 r12;
+	__u64 r13;
+	__u64 r14;
+	__u64 r15;
+	__u64 rdi;
+	__u64 rsi;
+	__u64 rbp;
+	__u64 rbx;
+	__u64 rdx;
+	__u64 rax;
+	__u64 rcx;
+	__u64 rsp;
+	__u64 rip;
+	__u64 eflags;		/* RFLAGS */
+	__u16 cs;
+	__u16 gs;
+	__u16 fs;
+	__u16 __pad0;
+	__u64 err;
+	__u64 trapno;
+	__u64 oldmask;
+	__u64 cr2;
+	struct _fpstate __user *fpstate;	/* zero when no FPU context */
+#ifdef __ILP32__
+	__u32 __fpstate_pad;
+#endif
+	__u64 reserved1[8];
+};
+#endif /* !__KERNEL__ */
+
+#endif /* !__i386__ */
+
+struct _xsave_hdr {
+	__u64 xstate_bv;
+	__u64 reserved1[2];
+	__u64 reserved2[5];
+};
+
+struct _ymmh_state {
+	/* 16 * 16 bytes for each YMMH-reg */
+	__u32 ymmh_space[64];
+};
+
+/*
+ * Extended state pointed by the fpstate pointer in the sigcontext.
+ * In addition to the fpstate, information encoded in the xstate_hdr
+ * indicates the presence of other extended state information
+ * supported by the processor and OS.
+ */
+struct _xstate {
+	struct _fpstate fpstate;
+	struct _xsave_hdr xstate_hdr;
+	struct _ymmh_state ymmh;
+	/* new processor state extensions go here */
+};
+
+#endif /* _UAPI_ASM_X86_SIGCONTEXT_H */
