commit ac94be498f84f7327533b62faca4c3da64434904
Merge: dce7cd62754b 8c5bd25bf42e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Nov 15 10:30:50 2019 +0100

    Merge branch 'linus' into x86/hyperv
    
    Pick up upstream fixes to avoid conflicts.

commit b264f57fde0c686c5c1dfdd0c21992c49196bb87
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sun Oct 27 16:19:38 2019 +0100

    x86/hyperv: Micro-optimize send_ipi_one()
    
    When sending an IPI to a single CPU there is no need to deal with cpumasks.
    
    With 2 CPU guest on WS2019 a minor (like 3%, 8043 -> 7761 CPU cycles)
    improvement with smp_call_function_single() loop benchmark can be seeb. The
    optimization, however, is tiny and straitforward. Also, send_ipi_one() is
    important for PV spinlock kick.
    
    Switching to the regular APIC IPI send for CPU > 64 case does not make
    sense as it is twice as expesive (12650 CPU cycles for __send_ipi_mask_ex()
    call, 26000 for orig_apic.send_IPI(cpu, vector)).
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Reviewed-by: Roman Kagan <rkagan@virtuozzo.com>
    Link: https://lkml.kernel.org/r/20191027151938.7296-1-vkuznets@redhat.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 5c056b8aebef..86c8674e92f4 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -194,10 +194,20 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 
 static bool __send_ipi_one(int cpu, int vector)
 {
-	struct cpumask mask = CPU_MASK_NONE;
+	int vp = hv_cpu_number_to_vp_number(cpu);
 
-	cpumask_set_cpu(cpu, &mask);
-	return __send_ipi_mask(&mask, vector);
+	trace_hyperv_send_ipi_one(cpu, vector);
+
+	if (!hv_hypercall_pg || (vp == VP_INVAL))
+		return false;
+
+	if ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))
+		return false;
+
+	if (vp >= 64)
+		return __send_ipi_mask_ex(cpumask_of(cpu), vector);
+
+	return !hv_do_fast_hypercall16(HVCALL_SEND_IPI, vector, BIT_ULL(vp));
 }
 
 static void hv_send_ipi(int cpu, int vector)

commit e211288b72f15259da86eed6eca680758dbe9e74
Author: Roman Kagan <rkagan@virtuozzo.com>
Date:   Thu Oct 10 12:33:05 2019 +0000

    x86/hyperv: Make vapic support x2apic mode
    
    Now that there's Hyper-V IOMMU driver, Linux can switch to x2apic mode
    when supported by the vcpus.
    
    However, the apic access functions for Hyper-V enlightened apic assume
    xapic mode only.
    
    As a result, Linux fails to bring up secondary cpus when run as a guest
    in QEMU/KVM with both hv_apic and x2apic enabled.
    
    According to Michael Kelley, when in x2apic mode, the Hyper-V synthetic
    apic MSRs behave exactly the same as the corresponding architectural
    x2apic MSRs, so there's no need to override the apic accessors.  The
    only exception is hv_apic_eoi_write, which benefits from lazy EOI when
    available; however, its implementation works for both xapic and x2apic
    modes.
    
    Fixes: 29217a474683 ("iommu/hyper-v: Add Hyper-V stub IOMMU driver")
    Fixes: 6b48cb5f8347 ("X86/Hyper-V: Enlighten APIC access")
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Roman Kagan <rkagan@virtuozzo.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191010123258.16919-1-rkagan@virtuozzo.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 5c056b8aebef..e01078e93dd3 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -260,11 +260,21 @@ void __init hv_apic_init(void)
 	}
 
 	if (ms_hyperv.hints & HV_X64_APIC_ACCESS_RECOMMENDED) {
-		pr_info("Hyper-V: Using MSR based APIC access\n");
+		pr_info("Hyper-V: Using enlightened APIC (%s mode)",
+			x2apic_enabled() ? "x2apic" : "xapic");
+		/*
+		 * With x2apic, architectural x2apic MSRs are equivalent to the
+		 * respective synthetic MSRs, so there's no need to override
+		 * the apic accessors.  The only exception is
+		 * hv_apic_eoi_write, because it benefits from lazy EOI when
+		 * available, but it works for both xapic and x2apic modes.
+		 */
 		apic_set_eoi_write(hv_apic_eoi_write);
-		apic->read      = hv_apic_read;
-		apic->write     = hv_apic_write;
-		apic->icr_write = hv_apic_icr_write;
-		apic->icr_read  = hv_apic_icr_read;
+		if (!x2apic_enabled()) {
+			apic->read      = hv_apic_read;
+			apic->write     = hv_apic_write;
+			apic->icr_write = hv_apic_icr_write;
+			apic->icr_read  = hv_apic_icr_read;
+		}
 	}
 }

commit ba696429d290690db967e5f49463df4b2c1314a4
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Apr 3 19:03:09 2019 +0200

    x86/hyper-v: Implement EOI assist
    
    Hyper-V TLFS suggests an optimization to avoid imminent VMExit on EOI:
    "The OS performs an EOI by atomically writing zero to the EOI Assist field
    of the virtual VP assist page and checking whether the "No EOI required"
    field was previously zero. If it was, the OS must write to the
    HV_X64_APIC_EOI MSR thereby triggering an intercept into the hypervisor."
    
    Implement the optimization in Linux.
    
    Tested-by: Long Li <longli@microsoft.com>
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael Kelley (EOSG) <Michael.H.Kelley@microsoft.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-hyperv@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190403170309.4107-1-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 8eb6fbee8e13..5c056b8aebef 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -86,6 +86,11 @@ static void hv_apic_write(u32 reg, u32 val)
 
 static void hv_apic_eoi_write(u32 reg, u32 val)
 {
+	struct hv_vp_assist_page *hvp = hv_vp_assist_page[smp_processor_id()];
+
+	if (hvp && (xchg(&hvp->apic_assist, 0) & 0x1))
+		return;
+
 	wrmsr(HV_X64_MSR_EOI, val, 0);
 }
 

commit 5140a6f471137205687428b0b8f12f7187bffd18
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sun Sep 23 08:20:22 2018 +0000

    x86/hyperv: Remove unused include
    
    Remove including <linux/version.h>. It's not needed.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: <devel@linuxdriverproject.org>
    Cc: <kernel-janitors@vger.kernel.org>
    Link: https://lkml.kernel.org/r/1537690822-97455-1-git-send-email-yuehaibing@huawei.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 2c43e3055948..8eb6fbee8e13 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -20,7 +20,6 @@
  */
 
 #include <linux/types.h>
-#include <linux/version.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
 #include <linux/clockchips.h>

commit a1efa9b70097a7ebb7c0a10bb72648776771b281
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Aug 27 18:48:57 2018 +0200

    x86/hyper-v: rename ipi_arg_{ex,non_ex} structures
    
    These structures are going to be used from KVM code so let's make
    their names reflect their Hyper-V origin.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Roman Kagan <rkagan@virtuozzo.com>
    Acked-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 5b0f613428c2..2c43e3055948 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -95,8 +95,8 @@ static void hv_apic_eoi_write(u32 reg, u32 val)
  */
 static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 {
-	struct ipi_arg_ex **arg;
-	struct ipi_arg_ex *ipi_arg;
+	struct hv_send_ipi_ex **arg;
+	struct hv_send_ipi_ex *ipi_arg;
 	unsigned long flags;
 	int nr_bank = 0;
 	int ret = 1;
@@ -105,7 +105,7 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 		return false;
 
 	local_irq_save(flags);
-	arg = (struct ipi_arg_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
+	arg = (struct hv_send_ipi_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
 
 	ipi_arg = *arg;
 	if (unlikely(!ipi_arg))
@@ -135,7 +135,7 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 {
 	int cur_cpu, vcpu;
-	struct ipi_arg_non_ex ipi_arg;
+	struct hv_send_ipi ipi_arg;
 	int ret = 1;
 
 	trace_hyperv_send_ipi_mask(mask, vector);

commit be0e16ce7c3bf9855f1ef5ae46cf889e1784ddea
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Jul 20 03:50:09 2018 +0000

    x86/hyper-v: Fix wrong merge conflict resolution
    
    When the mapping betwween the Linux notion of CPU ID to the hypervisor's
    notion of CPU ID is not initialized, IPI must fall back to the
    non-enlightened path.
    
    The recent merge of upstream changes into the hyperv branch resolved a
    merge conflict wronly by returning success in that case, which results in
    the IPI not being sent at all. Fix it up.
    
    Fixes: 8f63e9230dec ("Merge branch 'x86/urgent' into x86/hyperv")
    Reported-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: gregkh@linuxfoundation.org
    Cc: devel@linuxdriverproject.org
    Cc: olaf@aepfle.de
    Cc: apw@canonical.com
    Cc: jasowang@redhat.com
    Cc: hpa@zytor.com
    Cc: sthemmin@microsoft.com
    Cc: Michael.H.Kelley@microsoft.com
    Cc: vkuznets@redhat.com
    Link: https://lkml.kernel.org/r/20180720035009.3995-1-kys@linuxonhyperv.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 0c3c9f8fee77..5b0f613428c2 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -168,7 +168,7 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	for_each_cpu(cur_cpu, mask) {
 		vcpu = hv_cpu_number_to_vp_number(cur_cpu);
 		if (vcpu == VP_INVAL)
-			return true;
+			return false;
 
 		/*
 		 * This particular version of the IPI hypercall can

commit 8f63e9230decb06ea9068feaf0845c0eb39ab890
Merge: 58ec5e9c9044 1268ed0c474a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 6 12:35:56 2018 +0200

    Merge branch 'x86/urgent' into x86/hyperv
    
    Integrate the upstream bug fix to resolve the resulting conflict in
    __send_ipi_mask().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1268ed0c474a5c8f165ef386f3310521b5e00e27
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Jul 3 16:01:55 2018 -0700

    x86/hyper-v: Fix the circular dependency in IPI enlightenment
    
    The IPI hypercalls depend on being able to map the Linux notion of CPU ID
    to the hypervisor's notion of the CPU ID. The array hv_vp_index[] provides
    this mapping. Code for populating this array depends on the IPI functionality.
    Break this circular dependency.
    
    [ tglx: Use a proper define instead of '-1' with a u32 variable as pointed
            out by Vitaly ]
    
    Fixes: 68bb7bfb7985 ("X86/Hyper-V: Enable IPI enlightenments")
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Michael Kelley <mikelley@microsoft.com>
    Cc: gregkh@linuxfoundation.org
    Cc: devel@linuxdriverproject.org
    Cc: olaf@aepfle.de
    Cc: apw@canonical.com
    Cc: jasowang@redhat.com
    Cc: hpa@zytor.com
    Cc: sthemmin@microsoft.com
    Cc: Michael.H.Kelley@microsoft.com
    Cc: vkuznets@redhat.com
    Link: https://lkml.kernel.org/r/20180703230155.15160-1-kys@linuxonhyperv.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index f68855499391..402338365651 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -114,6 +114,8 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 		ipi_arg->vp_set.format = HV_GENERIC_SET_SPARSE_4K;
 		nr_bank = cpumask_to_vpset(&(ipi_arg->vp_set), mask);
 	}
+	if (nr_bank < 0)
+		goto ipi_mask_ex_done;
 	if (!nr_bank)
 		ipi_arg->vp_set.format = HV_GENERIC_SET_ALL;
 
@@ -158,6 +160,9 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 
 	for_each_cpu(cur_cpu, mask) {
 		vcpu = hv_cpu_number_to_vp_number(cur_cpu);
+		if (vcpu == VP_INVAL)
+			goto ipi_mask_done;
+
 		/*
 		 * This particular version of the IPI hypercall can
 		 * only target upto 64 CPUs.

commit 58ec5e9c9044bd7e1c0bcc6ad822b2e909f49732
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Jun 22 19:06:25 2018 +0200

    x86/hyper-v: Trace PV IPI send
    
    Trace Hyper-V PV IPIs the same way we do PV TLB flush.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Tianyu Lan <Tianyu.Lan@microsoft.com>
    Cc: "Michael Kelley (EOSG)" <Michael.H.Kelley@microsoft.com>
    Link: https://lkml.kernel.org/r/20180622170625.30688-5-vkuznets@redhat.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index ee962784d25b..657a2b8c738a 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -31,6 +31,8 @@
 #include <asm/mshyperv.h>
 #include <asm/apic.h>
 
+#include <asm/trace/hyperv.h>
+
 static struct apic orig_apic;
 
 static u64 hv_apic_icr_read(void)
@@ -134,6 +136,8 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	struct ipi_arg_non_ex ipi_arg;
 	int ret = 1;
 
+	trace_hyperv_send_ipi_mask(mask, vector);
+
 	if (cpumask_empty(mask))
 		return true;
 

commit 4bd06060762bc7e4834ecf9daeb78834f7a29582
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Jun 22 19:06:24 2018 +0200

    x86/hyper-v: Use cheaper HVCALL_SEND_IPI hypercall when possible
    
    When there is no need to send an IPI to a CPU with VP number > 64
    we can do the job with fast HVCALL_SEND_IPI hypercall.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: devel@linuxdriverproject.org
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Tianyu Lan <Tianyu.Lan@microsoft.com>
    Cc: "Michael Kelley (EOSG)" <Michael.H.Kelley@microsoft.com>
    Link: https://lkml.kernel.org/r/20180622170625.30688-4-vkuznets@redhat.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 90055f89223b..ee962784d25b 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -99,6 +99,9 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 	int nr_bank = 0;
 	int ret = 1;
 
+	if (!(ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
+		return false;
+
 	local_irq_save(flags);
 	arg = (struct ipi_arg_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
 
@@ -140,8 +143,18 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	if ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))
 		return false;
 
-	if ((ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
-		return __send_ipi_mask_ex(mask, vector);
+	/*
+	 * From the supplied CPU set we need to figure out if we can get away
+	 * with cheaper HVCALL_SEND_IPI hypercall. This is possible when the
+	 * highest VP number in the set is < 64. As VP numbers are usually in
+	 * ascending order and match Linux CPU ids, here is an optimization:
+	 * we check the VP number for the highest bit in the supplied set first
+	 * so we can quickly find out if using HVCALL_SEND_IPI_EX hypercall is
+	 * a must. We will also check all VP numbers when walking the supplied
+	 * CPU set to remain correct in all cases.
+	 */
+	if (hv_cpu_number_to_vp_number(cpumask_last(mask)) >= 64)
+		goto do_ex_hypercall;
 
 	ipi_arg.vector = vector;
 	ipi_arg.cpu_mask = 0;
@@ -153,16 +166,17 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 		 * only target upto 64 CPUs.
 		 */
 		if (vcpu >= 64)
-			goto ipi_mask_done;
+			goto do_ex_hypercall;
 
 		__set_bit(vcpu, (unsigned long *)&ipi_arg.cpu_mask);
 	}
 
 	ret = hv_do_fast_hypercall16(HVCALL_SEND_IPI, ipi_arg.vector,
 				     ipi_arg.cpu_mask);
-
-ipi_mask_done:
 	return ((ret == 0) ? true : false);
+
+do_ex_hypercall:
+	return __send_ipi_mask_ex(mask, vector);
 }
 
 static bool __send_ipi_one(int cpu, int vector)
@@ -218,10 +232,7 @@ static void hv_send_ipi_self(int vector)
 void __init hv_apic_init(void)
 {
 	if (ms_hyperv.hints & HV_X64_CLUSTER_IPI_RECOMMENDED) {
-		if ((ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
-			pr_info("Hyper-V: Using ext hypercalls for IPI\n");
-		else
-			pr_info("Hyper-V: Using IPI hypercalls\n");
+		pr_info("Hyper-V: Using IPI hypercalls\n");
 		/*
 		 * Set the IPI entry points.
 		 */

commit d8e6b232cfdd5d141c03e40a14c1c781480ea05e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Jun 22 19:06:23 2018 +0200

    x86/hyper-v: Use 'fast' hypercall for HVCALL_SEND_IPI
    
    Current Hyper-V TLFS (v5.0b) claims that HvCallSendSyntheticClusterIpi
    hypercall can't be 'fast' (passing parameters through registers) but
    apparently this is not true, Windows always uses 'fast' version. We can
    do the same in Linux too.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: devel@linuxdriverproject.org
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Tianyu Lan <Tianyu.Lan@microsoft.com>
    Cc: "Michael Kelley (EOSG)" <Michael.H.Kelley@microsoft.com>
    Link: https://lkml.kernel.org/r/20180622170625.30688-3-vkuznets@redhat.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index f68855499391..90055f89223b 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -128,10 +128,8 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 {
 	int cur_cpu, vcpu;
-	struct ipi_arg_non_ex **arg;
-	struct ipi_arg_non_ex *ipi_arg;
+	struct ipi_arg_non_ex ipi_arg;
 	int ret = 1;
-	unsigned long flags;
 
 	if (cpumask_empty(mask))
 		return true;
@@ -145,16 +143,8 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	if ((ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
 		return __send_ipi_mask_ex(mask, vector);
 
-	local_irq_save(flags);
-	arg = (struct ipi_arg_non_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
-
-	ipi_arg = *arg;
-	if (unlikely(!ipi_arg))
-		goto ipi_mask_done;
-
-	ipi_arg->vector = vector;
-	ipi_arg->reserved = 0;
-	ipi_arg->cpu_mask = 0;
+	ipi_arg.vector = vector;
+	ipi_arg.cpu_mask = 0;
 
 	for_each_cpu(cur_cpu, mask) {
 		vcpu = hv_cpu_number_to_vp_number(cur_cpu);
@@ -165,13 +155,13 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 		if (vcpu >= 64)
 			goto ipi_mask_done;
 
-		__set_bit(vcpu, (unsigned long *)&ipi_arg->cpu_mask);
+		__set_bit(vcpu, (unsigned long *)&ipi_arg.cpu_mask);
 	}
 
-	ret = hv_do_hypercall(HVCALL_SEND_IPI, ipi_arg, NULL);
+	ret = hv_do_fast_hypercall16(HVCALL_SEND_IPI, ipi_arg.vector,
+				     ipi_arg.cpu_mask);
 
 ipi_mask_done:
-	local_irq_restore(flags);
 	return ((ret == 0) ? true : false);
 }
 

commit 2d2ccf24939cf369f7473c7e4ea309891be91848
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat May 19 21:22:48 2018 +0200

    x86/Hyper-V/hv_apic: Build the Hyper-V APIC conditionally
    
    The Hyper-V APIC code is built when CONFIG_HYPERV is enabled but the actual
    code in that file is guarded with CONFIG_X86_64. There is no point in doing
    this. Neither is there a point in having the CONFIG_HYPERV guard in there
    because the containing directory is not built when CONFIG_HYPERV=n.
    
    Further for the hv_init_apic() function a stub is provided only for
    CONFIG_HYPERV=n, which is pointless as the callsite is not compiled at
    all. But for X86_32 the stub is missing and the build fails.
    
    Clean that up:
    
      - Compile hv_apic.c only when CONFIG_X86_64=y
      - Make the stub for hv_init_apic() available when CONFG_X86_64=n
    
    Fixes: 6b48cb5f8347 ("X86/Hyper-V: Enlighten APIC access")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Michael Kelley <mikelley@microsoft.com>

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index d3ff6e255924..f68855499391 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -31,9 +31,6 @@
 #include <asm/mshyperv.h>
 #include <asm/apic.h>
 
-#ifdef CONFIG_X86_64
-#if IS_ENABLED(CONFIG_HYPERV)
-
 static struct apic orig_apic;
 
 static u64 hv_apic_icr_read(void)
@@ -257,6 +254,3 @@ void __init hv_apic_init(void)
 		apic->icr_read  = hv_apic_icr_read;
 	}
 }
-
-#endif /* CONFIG_HYPERV */
-#endif /* CONFIG_X86_64 */

commit 61eeb1f6d1f2648a218855d7c8d44f16df242ef3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat May 19 16:38:59 2018 +0200

    x86/Hyper-V/hv_apic: Include asm/apic.h
    
    Not all configurations magically include asm/apic.h, but the Hyper-V code
    requires it. Include it explicitely.
    
    Fixes: 6b48cb5f8347 ("X86/Hyper-V: Enlighten APIC access")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Michael Kelley <mikelley@microsoft.com>

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 192b6ad6a361..d3ff6e255924 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -29,6 +29,7 @@
 #include <linux/cpuhotplug.h>
 #include <asm/hypervisor.h>
 #include <asm/mshyperv.h>
+#include <asm/apic.h>
 
 #ifdef CONFIG_X86_64
 #if IS_ENABLED(CONFIG_HYPERV)

commit 366f03b0cf90ef55f063d4a54cf62b0ac9b6da9d
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed May 16 14:53:32 2018 -0700

    X86/Hyper-V: Enhanced IPI enlightenment
    
    Support enhanced IPI enlightenments (to target more than 64 CPUs).
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: olaf@aepfle.de
    Cc: sthemmin@microsoft.com
    Cc: gregkh@linuxfoundation.org
    Cc: jasowang@redhat.com
    Cc: Michael.H.Kelley@microsoft.com
    Cc: hpa@zytor.com
    Cc: apw@canonical.com
    Cc: devel@linuxdriverproject.org
    Cc: vkuznets@redhat.com
    Link: https://lkml.kernel.org/r/20180516215334.6547-3-kys@linuxonhyperv.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 3e0de61f1a7c..192b6ad6a361 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -93,6 +93,40 @@ static void hv_apic_eoi_write(u32 reg, u32 val)
 /*
  * IPI implementation on Hyper-V.
  */
+static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
+{
+	struct ipi_arg_ex **arg;
+	struct ipi_arg_ex *ipi_arg;
+	unsigned long flags;
+	int nr_bank = 0;
+	int ret = 1;
+
+	local_irq_save(flags);
+	arg = (struct ipi_arg_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
+
+	ipi_arg = *arg;
+	if (unlikely(!ipi_arg))
+		goto ipi_mask_ex_done;
+
+	ipi_arg->vector = vector;
+	ipi_arg->reserved = 0;
+	ipi_arg->vp_set.valid_bank_mask = 0;
+
+	if (!cpumask_equal(mask, cpu_present_mask)) {
+		ipi_arg->vp_set.format = HV_GENERIC_SET_SPARSE_4K;
+		nr_bank = cpumask_to_vpset(&(ipi_arg->vp_set), mask);
+	}
+	if (!nr_bank)
+		ipi_arg->vp_set.format = HV_GENERIC_SET_ALL;
+
+	ret = hv_do_rep_hypercall(HVCALL_SEND_IPI_EX, 0, nr_bank,
+			      ipi_arg, NULL);
+
+ipi_mask_ex_done:
+	local_irq_restore(flags);
+	return ((ret == 0) ? true : false);
+}
+
 static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 {
 	int cur_cpu, vcpu;
@@ -110,6 +144,9 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	if ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))
 		return false;
 
+	if ((ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
+		return __send_ipi_mask_ex(mask, vector);
+
 	local_irq_save(flags);
 	arg = (struct ipi_arg_non_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
 
@@ -193,7 +230,10 @@ static void hv_send_ipi_self(int vector)
 void __init hv_apic_init(void)
 {
 	if (ms_hyperv.hints & HV_X64_CLUSTER_IPI_RECOMMENDED) {
-		pr_info("Hyper-V: Using IPI hypercalls\n");
+		if ((ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
+			pr_info("Hyper-V: Using ext hypercalls for IPI\n");
+		else
+			pr_info("Hyper-V: Using IPI hypercalls\n");
 		/*
 		 * Set the IPI entry points.
 		 */

commit 68bb7bfb7985df2bd15c2dc975cb68b7a901488a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed May 16 14:53:31 2018 -0700

    X86/Hyper-V: Enable IPI enlightenments
    
    Hyper-V supports hypercalls to implement IPI; use them.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: olaf@aepfle.de
    Cc: sthemmin@microsoft.com
    Cc: gregkh@linuxfoundation.org
    Cc: jasowang@redhat.com
    Cc: Michael.H.Kelley@microsoft.com
    Cc: hpa@zytor.com
    Cc: apw@canonical.com
    Cc: devel@linuxdriverproject.org
    Cc: vkuznets@redhat.com
    Link: https://lkml.kernel.org/r/20180516215334.6547-2-kys@linuxonhyperv.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index ca20e31d311c..3e0de61f1a7c 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -33,6 +33,8 @@
 #ifdef CONFIG_X86_64
 #if IS_ENABLED(CONFIG_HYPERV)
 
+static struct apic orig_apic;
+
 static u64 hv_apic_icr_read(void)
 {
 	u64 reg_val;
@@ -88,8 +90,123 @@ static void hv_apic_eoi_write(u32 reg, u32 val)
 	wrmsr(HV_X64_MSR_EOI, val, 0);
 }
 
+/*
+ * IPI implementation on Hyper-V.
+ */
+static bool __send_ipi_mask(const struct cpumask *mask, int vector)
+{
+	int cur_cpu, vcpu;
+	struct ipi_arg_non_ex **arg;
+	struct ipi_arg_non_ex *ipi_arg;
+	int ret = 1;
+	unsigned long flags;
+
+	if (cpumask_empty(mask))
+		return true;
+
+	if (!hv_hypercall_pg)
+		return false;
+
+	if ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))
+		return false;
+
+	local_irq_save(flags);
+	arg = (struct ipi_arg_non_ex **)this_cpu_ptr(hyperv_pcpu_input_arg);
+
+	ipi_arg = *arg;
+	if (unlikely(!ipi_arg))
+		goto ipi_mask_done;
+
+	ipi_arg->vector = vector;
+	ipi_arg->reserved = 0;
+	ipi_arg->cpu_mask = 0;
+
+	for_each_cpu(cur_cpu, mask) {
+		vcpu = hv_cpu_number_to_vp_number(cur_cpu);
+		/*
+		 * This particular version of the IPI hypercall can
+		 * only target upto 64 CPUs.
+		 */
+		if (vcpu >= 64)
+			goto ipi_mask_done;
+
+		__set_bit(vcpu, (unsigned long *)&ipi_arg->cpu_mask);
+	}
+
+	ret = hv_do_hypercall(HVCALL_SEND_IPI, ipi_arg, NULL);
+
+ipi_mask_done:
+	local_irq_restore(flags);
+	return ((ret == 0) ? true : false);
+}
+
+static bool __send_ipi_one(int cpu, int vector)
+{
+	struct cpumask mask = CPU_MASK_NONE;
+
+	cpumask_set_cpu(cpu, &mask);
+	return __send_ipi_mask(&mask, vector);
+}
+
+static void hv_send_ipi(int cpu, int vector)
+{
+	if (!__send_ipi_one(cpu, vector))
+		orig_apic.send_IPI(cpu, vector);
+}
+
+static void hv_send_ipi_mask(const struct cpumask *mask, int vector)
+{
+	if (!__send_ipi_mask(mask, vector))
+		orig_apic.send_IPI_mask(mask, vector);
+}
+
+static void hv_send_ipi_mask_allbutself(const struct cpumask *mask, int vector)
+{
+	unsigned int this_cpu = smp_processor_id();
+	struct cpumask new_mask;
+	const struct cpumask *local_mask;
+
+	cpumask_copy(&new_mask, mask);
+	cpumask_clear_cpu(this_cpu, &new_mask);
+	local_mask = &new_mask;
+	if (!__send_ipi_mask(local_mask, vector))
+		orig_apic.send_IPI_mask_allbutself(mask, vector);
+}
+
+static void hv_send_ipi_allbutself(int vector)
+{
+	hv_send_ipi_mask_allbutself(cpu_online_mask, vector);
+}
+
+static void hv_send_ipi_all(int vector)
+{
+	if (!__send_ipi_mask(cpu_online_mask, vector))
+		orig_apic.send_IPI_all(vector);
+}
+
+static void hv_send_ipi_self(int vector)
+{
+	if (!__send_ipi_one(smp_processor_id(), vector))
+		orig_apic.send_IPI_self(vector);
+}
+
 void __init hv_apic_init(void)
 {
+	if (ms_hyperv.hints & HV_X64_CLUSTER_IPI_RECOMMENDED) {
+		pr_info("Hyper-V: Using IPI hypercalls\n");
+		/*
+		 * Set the IPI entry points.
+		 */
+		orig_apic = *apic;
+
+		apic->send_IPI = hv_send_ipi;
+		apic->send_IPI_mask = hv_send_ipi_mask;
+		apic->send_IPI_mask_allbutself = hv_send_ipi_mask_allbutself;
+		apic->send_IPI_allbutself = hv_send_ipi_allbutself;
+		apic->send_IPI_all = hv_send_ipi_all;
+		apic->send_IPI_self = hv_send_ipi_self;
+	}
+
 	if (ms_hyperv.hints & HV_X64_APIC_ACCESS_RECOMMENDED) {
 		pr_info("Hyper-V: Using MSR based APIC access\n");
 		apic_set_eoi_write(hv_apic_eoi_write);

commit 6b48cb5f8347bc0153ff1d7b075db92e6723ffdb
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed May 16 14:53:30 2018 -0700

    X86/Hyper-V: Enlighten APIC access
    
    Hyper-V supports MSR based APIC access; implement
    the enlightenment.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: olaf@aepfle.de
    Cc: sthemmin@microsoft.com
    Cc: gregkh@linuxfoundation.org
    Cc: jasowang@redhat.com
    Cc: Michael.H.Kelley@microsoft.com
    Cc: hpa@zytor.com
    Cc: apw@canonical.com
    Cc: devel@linuxdriverproject.org
    Cc: vkuznets@redhat.com
    Link: https://lkml.kernel.org/r/20180516215334.6547-1-kys@linuxonhyperv.com

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
new file mode 100644
index 000000000000..ca20e31d311c
--- /dev/null
+++ b/arch/x86/hyperv/hv_apic.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * Hyper-V specific APIC code.
+ *
+ * Copyright (C) 2018, Microsoft, Inc.
+ *
+ * Author : K. Y. Srinivasan <kys@microsoft.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/clockchips.h>
+#include <linux/hyperv.h>
+#include <linux/slab.h>
+#include <linux/cpuhotplug.h>
+#include <asm/hypervisor.h>
+#include <asm/mshyperv.h>
+
+#ifdef CONFIG_X86_64
+#if IS_ENABLED(CONFIG_HYPERV)
+
+static u64 hv_apic_icr_read(void)
+{
+	u64 reg_val;
+
+	rdmsrl(HV_X64_MSR_ICR, reg_val);
+	return reg_val;
+}
+
+static void hv_apic_icr_write(u32 low, u32 id)
+{
+	u64 reg_val;
+
+	reg_val = SET_APIC_DEST_FIELD(id);
+	reg_val = reg_val << 32;
+	reg_val |= low;
+
+	wrmsrl(HV_X64_MSR_ICR, reg_val);
+}
+
+static u32 hv_apic_read(u32 reg)
+{
+	u32 reg_val, hi;
+
+	switch (reg) {
+	case APIC_EOI:
+		rdmsr(HV_X64_MSR_EOI, reg_val, hi);
+		return reg_val;
+	case APIC_TASKPRI:
+		rdmsr(HV_X64_MSR_TPR, reg_val, hi);
+		return reg_val;
+
+	default:
+		return native_apic_mem_read(reg);
+	}
+}
+
+static void hv_apic_write(u32 reg, u32 val)
+{
+	switch (reg) {
+	case APIC_EOI:
+		wrmsr(HV_X64_MSR_EOI, val, 0);
+		break;
+	case APIC_TASKPRI:
+		wrmsr(HV_X64_MSR_TPR, val, 0);
+		break;
+	default:
+		native_apic_mem_write(reg, val);
+	}
+}
+
+static void hv_apic_eoi_write(u32 reg, u32 val)
+{
+	wrmsr(HV_X64_MSR_EOI, val, 0);
+}
+
+void __init hv_apic_init(void)
+{
+	if (ms_hyperv.hints & HV_X64_APIC_ACCESS_RECOMMENDED) {
+		pr_info("Hyper-V: Using MSR based APIC access\n");
+		apic_set_eoi_write(hv_apic_eoi_write);
+		apic->read      = hv_apic_read;
+		apic->write     = hv_apic_write;
+		apic->icr_write = hv_apic_icr_write;
+		apic->icr_read  = hv_apic_icr_read;
+	}
+}
+
+#endif /* CONFIG_HYPERV */
+#endif /* CONFIG_X86_64 */
