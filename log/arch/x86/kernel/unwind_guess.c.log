commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index 4f0e17b90463..c49f10ffd8cd 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/sched.h>
 #include <linux/ftrace.h>
 #include <asm/ptrace.h>

commit ee9f8fce99640811b2b8e79d0d1dbe8bab69ba67
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Jul 24 18:36:57 2017 -0500

    x86/unwind: Add the ORC unwinder
    
    Add the new ORC unwinder which is enabled by CONFIG_ORC_UNWINDER=y.
    It plugs into the existing x86 unwinder framework.
    
    It relies on objtool to generate the needed .orc_unwind and
    .orc_unwind_ip sections.
    
    For more details on why ORC is used instead of DWARF, see
    Documentation/x86/orc-unwinder.txt - but the short version is
    that it's a simplified, fundamentally more robust debugninfo
    data structure, which also allows up to two orders of magnitude
    faster lookups than the DWARF unwinder - which matters to
    profiling workloads like perf.
    
    Thanks to Andy Lutomirski for the performance improvement ideas:
    splitting the ORC unwind table into two parallel arrays and creating a
    fast lookup table to search a subset of the unwind table.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/0a6cbfb40f8da99b7a45a1a8302dc6aef16ec812.1500938583.git.jpoimboe@redhat.com
    [ Extended the changelog. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index 039f36738e49..4f0e17b90463 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -19,6 +19,11 @@ unsigned long unwind_get_return_address(struct unwind_state *state)
 }
 EXPORT_SYMBOL_GPL(unwind_get_return_address);
 
+unsigned long *unwind_get_return_address_ptr(struct unwind_state *state)
+{
+	return NULL;
+}
+
 bool unwind_next_frame(struct unwind_state *state)
 {
 	struct stack_info *info = &state->stack_info;

commit e335bb51cc15e80ac180701a0d335ef1c050828e
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Apr 17 08:44:00 2017 -0500

    x86/unwind: Ensure stack pointer is aligned
    
    With frame pointers disabled, on some older versions of GCC (like
    4.8.3), it's possible for the stack pointer to get aligned at a
    half-word boundary:
    
      00000000000004d0 <fib_table_lookup>:
           4d0:       41 57                   push   %r15
           4d2:       41 56                   push   %r14
           4d4:       41 55                   push   %r13
           4d6:       41 54                   push   %r12
           4d8:       55                      push   %rbp
           4d9:       53                      push   %rbx
           4da:       48 83 ec 24             sub    $0x24,%rsp
    
    In such a case, the unwinder ends up reading the entire stack at the
    wrong alignment.  Then the last read goes past the end of the stack,
    hitting the stack guard page:
    
      BUG: stack guard page was hit at ffffc900217c4000 (stack is ffffc900217c0000..ffffc900217c3fff)
      kernel stack overflow (page fault): 0000 [#1] SMP
      ...
    
    Fix it by ensuring the stack pointer is properly aligned before
    unwinding.
    
    Reported-by: Jirka Hladky <jhladky@redhat.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Fixes: 7c7900f89770 ("x86/unwind: Add new unwind interface and implementations")
    Link: http://lkml.kernel.org/r/cff33847cc9b02fa548625aa23268ac574460d8d.1492436590.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index 22881ddcbb9f..039f36738e49 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -34,7 +34,7 @@ bool unwind_next_frame(struct unwind_state *state)
 				return true;
 		}
 
-		state->sp = info->next_sp;
+		state->sp = PTR_ALIGN(info->next_sp, sizeof(long));
 
 	} while (!get_stack_info(state->sp, state->task, info,
 				 &state->stack_mask));
@@ -49,7 +49,7 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	memset(state, 0, sizeof(*state));
 
 	state->task = task;
-	state->sp   = first_frame;
+	state->sp   = PTR_ALIGN(first_frame, sizeof(long));
 
 	get_stack_info(first_frame, state->task, &state->stack_info,
 		       &state->stack_mask);

commit 55f856e640560494518eaf24fe9d2d2089fba71a
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Sun Nov 27 23:13:07 2016 -0600

    x86/unwind: Fix guess-unwinder regression
    
    My attempt at fixing some KASAN false positive warnings was rather brain
    dead, and it broke the guess unwinder.  With frame pointers disabled,
    /proc/<pid>/stack is broken:
    
      # cat /proc/1/stack
      [<ffffffffffffffff>] 0xffffffffffffffff
    
    Restore the code flow to more closely resemble its previous state, while
    still using READ_ONCE_NOCHECK() macros to silence KASAN false positives.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: c2d75e03d630 ("x86/unwind: Prevent KASAN false positive warnings in guess unwinder")
    Link: http://lkml.kernel.org/r/b824f92c2c22eca5ec95ac56bd2a7c84cf0b9df9.1480309971.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index b80e8bf43cc6..22881ddcbb9f 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -7,11 +7,13 @@
 
 unsigned long unwind_get_return_address(struct unwind_state *state)
 {
-	unsigned long addr = READ_ONCE_NOCHECK(*state->sp);
+	unsigned long addr;
 
 	if (unwind_done(state))
 		return 0;
 
+	addr = READ_ONCE_NOCHECK(*state->sp);
+
 	return ftrace_graph_ret_addr(state->task, &state->graph_idx,
 				     addr, state->sp);
 }
@@ -25,11 +27,12 @@ bool unwind_next_frame(struct unwind_state *state)
 		return false;
 
 	do {
-		unsigned long addr = READ_ONCE_NOCHECK(*state->sp);
+		for (state->sp++; state->sp < info->end; state->sp++) {
+			unsigned long addr = READ_ONCE_NOCHECK(*state->sp);
 
-		for (state->sp++; state->sp < info->end; state->sp++)
 			if (__kernel_text_address(addr))
 				return true;
+		}
 
 		state->sp = info->next_sp;
 

commit c2d75e03d6307bda0e14b616818a6f7b09fd623a
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Thu Nov 17 09:57:23 2016 -0600

    x86/unwind: Prevent KASAN false positive warnings in guess unwinder
    
    The guess unwinder scans the entire stack, which can cause KASAN
    "stack-out-of-bounds" false positive warnings.  Tell KASAN to ignore it.
    
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Stephane Eranian <eranian@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Cc: davej@codemonkey.org.uk
    Cc: dvyukov@google.com
    Link: http://lkml.kernel.org/r/61939c0b2b2d63ce97ba59cba3b00fd47c2962cf.1479398226.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index 2d721e533cf4..b80e8bf43cc6 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -7,11 +7,13 @@
 
 unsigned long unwind_get_return_address(struct unwind_state *state)
 {
+	unsigned long addr = READ_ONCE_NOCHECK(*state->sp);
+
 	if (unwind_done(state))
 		return 0;
 
 	return ftrace_graph_ret_addr(state->task, &state->graph_idx,
-				     *state->sp, state->sp);
+				     addr, state->sp);
 }
 EXPORT_SYMBOL_GPL(unwind_get_return_address);
 
@@ -23,8 +25,10 @@ bool unwind_next_frame(struct unwind_state *state)
 		return false;
 
 	do {
+		unsigned long addr = READ_ONCE_NOCHECK(*state->sp);
+
 		for (state->sp++; state->sp < info->end; state->sp++)
-			if (__kernel_text_address(*state->sp))
+			if (__kernel_text_address(addr))
 				return true;
 
 		state->sp = info->next_sp;

commit 7fbe6ac02485504b964b283aca62b36b4313ca79
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Oct 24 08:31:27 2016 -0500

    x86/unwind: Fix empty stack dereference in guess unwinder
    
    Vince Waver reported the following bug:
    
      WARNING: CPU: 0 PID: 21338 at arch/x86/mm/fault.c:435 vmalloc_fault+0x58/0x1f0
      CPU: 0 PID: 21338 Comm: perf_fuzzer Not tainted 4.8.0+ #37
      Hardware name: Hewlett-Packard HP Compaq Pro 6305 SFF/1850, BIOS K06 v02.57 08/16/2013
      Call Trace:
       <NMI>  ? dump_stack+0x46/0x59
       ? __warn+0xd5/0xee
       ? vmalloc_fault+0x58/0x1f0
       ? __do_page_fault+0x6d/0x48e
       ? perf_log_throttle+0xa4/0xf4
       ? trace_page_fault+0x22/0x30
       ? __unwind_start+0x28/0x42
       ? perf_callchain_kernel+0x75/0xac
       ? get_perf_callchain+0x13a/0x1f0
       ? perf_callchain+0x6a/0x6c
       ? perf_prepare_sample+0x71/0x2eb
       ? perf_event_output_forward+0x1a/0x54
       ? __default_send_IPI_shortcut+0x10/0x2d
       ? __perf_event_overflow+0xfb/0x167
       ? x86_pmu_handle_irq+0x113/0x150
       ? native_read_msr+0x6/0x34
       ? perf_event_nmi_handler+0x22/0x39
       ? perf_ibs_nmi_handler+0x4a/0x51
       ? perf_event_nmi_handler+0x22/0x39
       ? nmi_handle+0x4d/0xf0
       ? perf_ibs_handle_irq+0x3d1/0x3d1
       ? default_do_nmi+0x3c/0xd5
       ? do_nmi+0x92/0x102
       ? end_repeat_nmi+0x1a/0x1e
       ? entry_SYSCALL_64_after_swapgs+0x12/0x4a
       ? entry_SYSCALL_64_after_swapgs+0x12/0x4a
       ? entry_SYSCALL_64_after_swapgs+0x12/0x4a
       <EOE> ^A4---[ end trace 632723104d47d31a ]---
      BUG: stack guard page was hit at ffffc90008500000 (stack is ffffc900084fc000..ffffc900084fffff)
      kernel stack overflow (page fault): 0000 [#1] SMP
      ...
    
    The NMI hit in the entry code right after setting up the stack pointer
    from 'cpu_current_top_of_stack', so the kernel stack was empty.  The
    'guess' version of __unwind_start() attempted to dereference the "top of
    stack" pointer, which is not actually *on* the stack.
    
    Add a check in the guess unwinder to deal with an empty stack.  (The
    frame pointer unwinder already has such a check.)
    
    Reported-by: Vince Weaver <vincent.weaver@maine.edu>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 7c7900f89770 ("x86/unwind: Add new unwind interface and implementations")
    Link: http://lkml.kernel.org/r/20161024133127.e5evgeebdbohnmpb@treble
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index 9298993dc8b7..2d721e533cf4 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -47,7 +47,14 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	get_stack_info(first_frame, state->task, &state->stack_info,
 		       &state->stack_mask);
 
-	if (!__kernel_text_address(*first_frame))
+	/*
+	 * The caller can provide the address of the first frame directly
+	 * (first_frame) or indirectly (regs->sp) to indicate which stack frame
+	 * to start unwinding at.  Skip ahead until we reach it.
+	 */
+	if (!unwind_done(state) &&
+	    (!on_stack(&state->stack_info, first_frame, sizeof(long)) ||
+	    !__kernel_text_address(*first_frame)))
 		unwind_next_frame(state);
 }
 EXPORT_SYMBOL_GPL(__unwind_start);

commit cfee9eddcd61e28b73468647fc4aa7ff2d706254
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Thu Oct 6 00:28:40 2016 -0500

    x86/unwind: Fix oprofile module link error
    
    When compiling on x86 with CONFIG_OPROFILE=m and CONFIG_FRAME_POINTER=n,
    the oprofile module fails to link:
    
      ERROR: ftrace_graph_ret_addr" [arch/x86/oprofile/oprofile.ko] undefined!
    
    The problem was introduced when oprofile was converted to use the new
    x86 unwinder.  When frame pointers are disabled, the "guess" unwinder's
    unwind_get_return_address() is an inline function which calls
    ftrace_graph_ret_addr(), which is not exported.
    
    Fix it by converting the "guess" version of unwind_get_return_address()
    to an exported out-of-line function, just like its frame pointer
    counterpart.
    
    Reported-by: Karl Beldan <karl.beldan@gmail.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: ec2ad9ccf12d ("oprofile/x86: Convert x86_backtrace() to use the new unwinder")
    Link: http://lkml.kernel.org/r/be08d589f6474df78364e081c42777e382af9352.1475731632.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
index b5a834c93065..9298993dc8b7 100644
--- a/arch/x86/kernel/unwind_guess.c
+++ b/arch/x86/kernel/unwind_guess.c
@@ -5,6 +5,16 @@
 #include <asm/stacktrace.h>
 #include <asm/unwind.h>
 
+unsigned long unwind_get_return_address(struct unwind_state *state)
+{
+	if (unwind_done(state))
+		return 0;
+
+	return ftrace_graph_ret_addr(state->task, &state->graph_idx,
+				     *state->sp, state->sp);
+}
+EXPORT_SYMBOL_GPL(unwind_get_return_address);
+
 bool unwind_next_frame(struct unwind_state *state)
 {
 	struct stack_info *info = &state->stack_info;

commit 7c7900f89770d7fba96100d8a9e18043a1af3973
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Fri Sep 16 14:18:12 2016 -0500

    x86/unwind: Add new unwind interface and implementations
    
    The x86 stack dump code is a bit of a mess.  dump_trace() uses
    callbacks, and each user of it seems to have slightly different
    requirements, so there are several slightly different callbacks floating
    around.
    
    Also there are some upcoming features which will need more changes to
    the stack dump code, including the printing of stack pt_regs, reliable
    stack detection for live patching, and a DWARF unwinder.  Each of those
    features would at least need more callbacks and/or callback interfaces,
    resulting in a much bigger mess than what we have today.
    
    Before doing all that, we should try to clean things up and replace
    dump_trace() with something cleaner and more flexible.
    
    The new unwinder is a simple state machine which was heavily inspired by
    a suggestion from Andy Lutomirski:
    
      https://lkml.kernel.org/r/CALCETrUbNTqaM2LRyXGRx=kVLRPeY5A3Pc6k4TtQxF320rUT=w@mail.gmail.com
    
    It's also similar to the libunwind API:
    
      http://www.nongnu.org/libunwind/man/libunwind(3).html
    
    Some if its advantages:
    
    - Simplicity: no more callback sprawl and less code duplication.
    
    - Flexibility: it allows the caller to stop and inspect the stack state
      at each step in the unwinding process.
    
    - Modularity: the unwinder code, console stack dump code, and stack
      metadata analysis code are all better separated so that changing one
      of them shouldn't have much of an impact on any of the others.
    
    Two implementations are added which conform to the new unwind interface:
    
    - The frame pointer unwinder which is used for CONFIG_FRAME_POINTER=y.
    
    - The "guess" unwinder which is used for CONFIG_FRAME_POINTER=n.  This
      isn't an "unwinder" per se.  All it does is scan the stack for kernel
      text addresses.  But with no frame pointers, guesses are better than
      nothing in most cases.
    
    Suggested-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Byungchul Park <byungchul.park@lge.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nilay Vaish <nilayvaish@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/6dc2f909c47533d213d0505f0a113e64585bec82.1474045023.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/unwind_guess.c b/arch/x86/kernel/unwind_guess.c
new file mode 100644
index 000000000000..b5a834c93065
--- /dev/null
+++ b/arch/x86/kernel/unwind_guess.c
@@ -0,0 +1,43 @@
+#include <linux/sched.h>
+#include <linux/ftrace.h>
+#include <asm/ptrace.h>
+#include <asm/bitops.h>
+#include <asm/stacktrace.h>
+#include <asm/unwind.h>
+
+bool unwind_next_frame(struct unwind_state *state)
+{
+	struct stack_info *info = &state->stack_info;
+
+	if (unwind_done(state))
+		return false;
+
+	do {
+		for (state->sp++; state->sp < info->end; state->sp++)
+			if (__kernel_text_address(*state->sp))
+				return true;
+
+		state->sp = info->next_sp;
+
+	} while (!get_stack_info(state->sp, state->task, info,
+				 &state->stack_mask));
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(unwind_next_frame);
+
+void __unwind_start(struct unwind_state *state, struct task_struct *task,
+		    struct pt_regs *regs, unsigned long *first_frame)
+{
+	memset(state, 0, sizeof(*state));
+
+	state->task = task;
+	state->sp   = first_frame;
+
+	get_stack_info(first_frame, state->task, &state->stack_info,
+		       &state->stack_mask);
+
+	if (!__kernel_text_address(*first_frame))
+		unwind_next_frame(state);
+}
+EXPORT_SYMBOL_GPL(__unwind_start);
