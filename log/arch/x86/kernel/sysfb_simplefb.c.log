commit dacc9092336be20b01642afe1a51720b31f60369
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Tue Jan 7 18:04:10 2020 -0500

    x86/sysfb: Fix check for bad VRAM size
    
    When checking whether the reported lfb_size makes sense, the height
    * stride result is page-aligned before seeing whether it exceeds the
    reported size.
    
    This doesn't work if height * stride is not an exact number of pages.
    For example, as reported in the kernel bugzilla below, an 800x600x32 EFI
    framebuffer gets skipped because of this.
    
    Move the PAGE_ALIGN to after the check vs size.
    
    Reported-by: Christopher Head <chead@chead.ca>
    Tested-by: Christopher Head <chead@chead.ca>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206051
    Link: https://lkml.kernel.org/r/20200107230410.2291947-1-nivedita@alum.mit.edu

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 01f0e2263b86..298fc1edd9c9 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -90,11 +90,11 @@ __init int create_simplefb(const struct screen_info *si,
 	if (si->orig_video_isVGA == VIDEO_TYPE_VLFB)
 		size <<= 16;
 	length = mode->height * mode->stride;
-	length = PAGE_ALIGN(length);
 	if (length > size) {
 		printk(KERN_WARNING "sysfb: VRAM smaller than advertised\n");
 		return -EINVAL;
 	}
+	length = PAGE_ALIGN(length);
 
 	/* setup IORESOURCE_MEM as framebuffer memory */
 	memset(&res, 0, sizeof(res));

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 85195d447a92..01f0e2263b86 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -1,11 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Generic System Framebuffers on x86
  * Copyright (c) 2012-2013 David Herrmann <dh.herrmann@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  */
 
 /*

commit f96acec8c8020807429d21324547f4b904c37177
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Tue Nov 15 13:01:58 2016 +0100

    x86/sysfb: Fix lfb_size calculation
    
    The screen_info.lfb_size field is shifted by 16 bits *only* in case of
    VBE. This has historical reasons since VBE advertised it similarly.
    However, in case of EFI framebuffers, the size is no longer shifted. Fix
    the x86 simple-framebuffer setup code to use the correct size in the
    non-VBE case.
    
    While at it, avoid variable abbreviations and rename 'len' to 'length',
    and use the correct types matching the screen_info definition.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tom Gundersen <teg@jklm.no>
    Link: http://lkml.kernel.org/r/20161115120158.15388-3-dh.herrmann@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 35b86415871f..85195d447a92 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -66,8 +66,8 @@ __init int create_simplefb(const struct screen_info *si,
 {
 	struct platform_device *pd;
 	struct resource res;
-	unsigned long len;
-	u64 base;
+	u64 base, size;
+	u32 length;
 
 	/*
 	 * If the 64BIT_BASE capability is set, ext_lfb_base will contain the
@@ -82,11 +82,20 @@ __init int create_simplefb(const struct screen_info *si,
 		return -EINVAL;
 	}
 
-	/* don't use lfb_size as it may contain the whole VMEM instead of only
-	 * the part that is occupied by the framebuffer */
-	len = mode->height * mode->stride;
-	len = PAGE_ALIGN(len);
-	if (len > (u64)si->lfb_size << 16) {
+	/*
+	 * Don't use lfb_size as IORESOURCE size, since it may contain the
+	 * entire VMEM, and thus require huge mappings. Use just the part we
+	 * need, that is, the part where the framebuffer is located. But verify
+	 * that it does not exceed the advertised VMEM.
+	 * Note that in case of VBE, the lfb_size is shifted by 16 bits for
+	 * historical reasons.
+	 */
+	size = si->lfb_size;
+	if (si->orig_video_isVGA == VIDEO_TYPE_VLFB)
+		size <<= 16;
+	length = mode->height * mode->stride;
+	length = PAGE_ALIGN(length);
+	if (length > size) {
 		printk(KERN_WARNING "sysfb: VRAM smaller than advertised\n");
 		return -EINVAL;
 	}
@@ -96,7 +105,7 @@ __init int create_simplefb(const struct screen_info *si,
 	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	res.name = simplefb_resname;
 	res.start = base;
-	res.end = res.start + len - 1;
+	res.end = res.start + length - 1;
 	if (res.end <= res.start)
 		return -EINVAL;
 

commit 9164b4ceb7b492a77c7fe770a4b9d1375c9cd45a
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Tue Nov 15 13:01:57 2016 +0100

    x86/sysfb: Add support for 64bit EFI lfb_base
    
    The screen_info object was extended to support 64-bit lfb_base addresses
    in:
    
      ae2ee627dc87 ("efifb: Add support for 64-bit frame buffer addresses")
    
    However, the x86 simple-framebuffer setup code never made use of it. Fix
    it to properly assemble and verify the lfb_base before advertising
    simple-framebuffer devices.
    
    In particular, this means if VIDEO_CAPABILITY_64BIT_BASE is set, the
    screen_info->ext_lfb_base field will contain the upper 32bit of the
    actual lfb_base. Make sure the address is not 0 (i.e., unset), as well as
    does not overflow the physical address type.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tom Gundersen <teg@jklm.no>
    Link: http://lkml.kernel.org/r/20161115120158.15388-2-dh.herrmann@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 764a29f84de7..35b86415871f 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -67,6 +67,20 @@ __init int create_simplefb(const struct screen_info *si,
 	struct platform_device *pd;
 	struct resource res;
 	unsigned long len;
+	u64 base;
+
+	/*
+	 * If the 64BIT_BASE capability is set, ext_lfb_base will contain the
+	 * upper half of the base address. Assemble the address, then make sure
+	 * it is valid and we can actually access it.
+	 */
+	base = si->lfb_base;
+	if (si->capabilities & VIDEO_CAPABILITY_64BIT_BASE)
+		base |= (u64)si->ext_lfb_base << 32;
+	if (!base || (u64)(resource_size_t)base != base) {
+		printk(KERN_DEBUG "sysfb: inaccessible VRAM base\n");
+		return -EINVAL;
+	}
 
 	/* don't use lfb_size as it may contain the whole VMEM instead of only
 	 * the part that is occupied by the framebuffer */
@@ -81,8 +95,8 @@ __init int create_simplefb(const struct screen_info *si,
 	memset(&res, 0, sizeof(res));
 	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	res.name = simplefb_resname;
-	res.start = si->lfb_base;
-	res.end = si->lfb_base + len - 1;
+	res.start = base;
+	res.end = res.start + len - 1;
 	if (res.end <= res.start)
 		return -EINVAL;
 

commit 76ef0db72f8b74bb92e24775d9d7f5ab26352bec
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Oct 17 22:01:05 2014 +0200

    x86/simplefb: Use PTR_ERR_OR_ZERO
    
    Replace IS_ERR/PTR_ERR
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Link: http://lkml.kernel.org/r/1413576066-26925-1-git-send-email-fabf@skynet.be
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 86179d409893..764a29f84de7 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -88,8 +88,5 @@ __init int create_simplefb(const struct screen_info *si,
 
 	pd = platform_device_register_resndata(NULL, "simple-framebuffer", 0,
 					       &res, 1, mode, sizeof(*mode));
-	if (IS_ERR(pd))
-		return PTR_ERR(pd);
-
-	return 0;
+	return PTR_ERR_OR_ZERO(pd);
 }

commit 29d274b8d3e2404cd1832b3a999b12f9d1e1d895
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Wed Oct 2 16:41:04 2013 +0200

    x86/simplefb: Mark framebuffer mem-resources as IORESOURCE_BUSY to avoid bootup warning
    
    IORESOURCE_BUSY is used to mark temporary driver mem-resources
    instead of global regions. This suppresses warnings if regions
    overlap with a region marked as BUSY.
    
    This was always the case for VESA/VGA/EFI framebuffer regions so
    do the same for simplefb regions. The reason we do this is to
    allow device handover to real GPU drivers like
    i915/radeon/nouveau which get the same regions via PCI BARs.
    
    Maybe at some point we will be able to unregister platform
    devices properly during the handover. In this case the simplefb
    region would get removed before the new region is created.
    However, this is currently not the case and would require rather
    huge changes in remove_conflicting_framebuffers(). Add the BUSY
    marker now and try to eventually rewrite the handover for a next release.
    
    Also see kernel/resource.c for more information:
    
      /*
       * if a resource is "BUSY", it's not a hardware resource
       * but a driver mapping of such a resource; we don't want
       * to warn for those; some drivers legitimately map only
       * partial hardware resources. (example: vesafb)
       */
    
    This suppresses warnings like:
    
      ------------[ cut here ]------------
      WARNING: CPU: 2 PID: 199 at arch/x86/mm/ioremap.c:171 __ioremap_caller+0x2e3/0x390()
      Info: mapping multiple BARs. Your kernel is fine.
      Call Trace:
        dump_stack+0x54/0x8d
        warn_slowpath_common+0x7d/0xa0
        warn_slowpath_fmt+0x4c/0x50
        iomem_map_sanity_check+0xac/0xe0
        __ioremap_caller+0x2e3/0x390
        ioremap_wc+0x32/0x40
        i915_driver_load+0x670/0xf50 [i915]
        ...
    
    Reported-by: Tom Gundersen <teg@jklm.no>
    Tested-by: Tom Gundersen <teg@jklm.no>
    Tested-by: Pavel Roskin <proski@gnu.org>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Link: http://lkml.kernel.org/r/1380724864-1757-1-git-send-email-dh.herrmann@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 4ebd636b04b8..86179d409893 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -79,7 +79,7 @@ __init int create_simplefb(const struct screen_info *si,
 
 	/* setup IORESOURCE_MEM as framebuffer memory */
 	memset(&res, 0, sizeof(res));
-	res.flags = IORESOURCE_MEM;
+	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	res.name = simplefb_resname;
 	res.start = si->lfb_base;
 	res.end = si->lfb_base + len - 1;

commit e33a29a5ae711162c6b6fefc0a2ef18f4a4254bf
Author: Tom Gundersen <teg@jklm.no>
Date:   Tue Oct 1 18:18:40 2013 +0200

    x86/simplefb: Fix overflow causing bogus fall-back
    
    On my MacBook Air lfb_size is 4M, which makes the bitshit
    overflow (to 256GB - larger than 32 bits), meaning we fall
    back to efifb unnecessarily.
    
    Cast to u64 to avoid the overflow.
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Link: http://lkml.kernel.org/r/1380644320-1026-1-git-send-email-teg@jklm.no
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
index 22513e96b012..4ebd636b04b8 100644
--- a/arch/x86/kernel/sysfb_simplefb.c
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -72,7 +72,7 @@ __init int create_simplefb(const struct screen_info *si,
 	 * the part that is occupied by the framebuffer */
 	len = mode->height * mode->stride;
 	len = PAGE_ALIGN(len);
-	if (len > si->lfb_size << 16) {
+	if (len > (u64)si->lfb_size << 16) {
 		printk(KERN_WARNING "sysfb: VRAM smaller than advertised\n");
 		return -EINVAL;
 	}

commit e3263ab389a7bc9398c3d366819d6f39b9cfd677
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 2 14:05:22 2013 +0200

    x86: provide platform-devices for boot-framebuffers
    
    The current situation regarding boot-framebuffers (VGA, VESA/VBE, EFI) on
    x86 causes troubles when loading multiple fbdev drivers. The global
    "struct screen_info" does not provide any state-tracking about which
    drivers use the FBs. request_mem_region() theoretically works, but
    unfortunately vesafb/efifb ignore it due to quirks for broken boards.
    
    Avoid this by creating a platform framebuffer devices with a pointer
    to the "struct screen_info" as platform-data. Drivers can now create
    platform-drivers and the driver-core will refuse multiple drivers being
    active simultaneously.
    
    We keep the screen_info available for backwards-compatibility. Drivers
    can be converted in follow-up patches.
    
    Different devices are created for VGA/VESA/EFI FBs to allow multiple
    drivers to be loaded on distro kernels. We create:
     - "vesa-framebuffer" for VBE/VESA graphics FBs
     - "efi-framebuffer" for EFI FBs
     - "platform-framebuffer" for everything else
    This allows to load vesafb, efifb and others simultaneously and each
    picks up only the supported FB types.
    
    Apart from platform-framebuffer devices, this also introduces a
    compatibility option for "simple-framebuffer" drivers which recently got
    introduced for OF based systems. If CONFIG_X86_SYSFB is selected, we
    try to match the screen_info against a simple-framebuffer supported
    format. If we succeed, we create a "simple-framebuffer" device instead
    of a platform-framebuffer.
    This allows to reuse the simplefb.c driver across architectures and also
    to introduce a SimpleDRM driver. There is no need to have vesafb.c,
    efifb.c, simplefb.c and more just to have architecture specific quirks
    in their setup-routines.
    
    Instead, we now move the architecture specific quirks into x86-setup and
    provide a generic simple-framebuffer. For backwards-compatibility (if
    strange formats are used), we still allow vesafb/efifb to be loaded
    simultaneously and pick up all remaining devices.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Link: http://lkml.kernel.org/r/1375445127-15480-4-git-send-email-dh.herrmann@gmail.com
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c
new file mode 100644
index 000000000000..22513e96b012
--- /dev/null
+++ b/arch/x86/kernel/sysfb_simplefb.c
@@ -0,0 +1,95 @@
+/*
+ * Generic System Framebuffers on x86
+ * Copyright (c) 2012-2013 David Herrmann <dh.herrmann@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ * simple-framebuffer probing
+ * Try to convert "screen_info" into a "simple-framebuffer" compatible mode.
+ * If the mode is incompatible, we return "false" and let the caller create
+ * legacy nodes instead.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/platform_data/simplefb.h>
+#include <linux/platform_device.h>
+#include <linux/screen_info.h>
+#include <asm/sysfb.h>
+
+static const char simplefb_resname[] = "BOOTFB";
+static const struct simplefb_format formats[] = SIMPLEFB_FORMATS;
+
+/* try parsing x86 screen_info into a simple-framebuffer mode struct */
+__init bool parse_mode(const struct screen_info *si,
+		       struct simplefb_platform_data *mode)
+{
+	const struct simplefb_format *f;
+	__u8 type;
+	unsigned int i;
+
+	type = si->orig_video_isVGA;
+	if (type != VIDEO_TYPE_VLFB && type != VIDEO_TYPE_EFI)
+		return false;
+
+	for (i = 0; i < ARRAY_SIZE(formats); ++i) {
+		f = &formats[i];
+		if (si->lfb_depth == f->bits_per_pixel &&
+		    si->red_size == f->red.length &&
+		    si->red_pos == f->red.offset &&
+		    si->green_size == f->green.length &&
+		    si->green_pos == f->green.offset &&
+		    si->blue_size == f->blue.length &&
+		    si->blue_pos == f->blue.offset &&
+		    si->rsvd_size == f->transp.length &&
+		    si->rsvd_pos == f->transp.offset) {
+			mode->format = f->name;
+			mode->width = si->lfb_width;
+			mode->height = si->lfb_height;
+			mode->stride = si->lfb_linelength;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+__init int create_simplefb(const struct screen_info *si,
+			   const struct simplefb_platform_data *mode)
+{
+	struct platform_device *pd;
+	struct resource res;
+	unsigned long len;
+
+	/* don't use lfb_size as it may contain the whole VMEM instead of only
+	 * the part that is occupied by the framebuffer */
+	len = mode->height * mode->stride;
+	len = PAGE_ALIGN(len);
+	if (len > si->lfb_size << 16) {
+		printk(KERN_WARNING "sysfb: VRAM smaller than advertised\n");
+		return -EINVAL;
+	}
+
+	/* setup IORESOURCE_MEM as framebuffer memory */
+	memset(&res, 0, sizeof(res));
+	res.flags = IORESOURCE_MEM;
+	res.name = simplefb_resname;
+	res.start = si->lfb_base;
+	res.end = si->lfb_base + len - 1;
+	if (res.end <= res.start)
+		return -EINVAL;
+
+	pd = platform_device_register_resndata(NULL, "simple-framebuffer", 0,
+					       &res, 1, mode, sizeof(*mode));
+	if (IS_ERR(pd))
+		return PTR_ERR(pd);
+
+	return 0;
+}
