commit e0748539e3d594dd26f0d27a270f14720b22a406
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Nov 29 14:23:03 2019 +0800

    x86/intel: Disable HPET on Intel Ice Lake platforms
    
    Like CFL and CFL-H, ICL SoC has skewed HPET timer once it hits PC10.
    So let's disable HPET on ICL.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bp@alien8.de
    Cc: feng.tang@intel.com
    Cc: harry.pan@intel.com
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20191129062303.18982-2-kai.heng.feng@canonical.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 606711f5ebf8..2f9ec14be3b1 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -714,6 +714,8 @@ static struct chipset early_qrk[] __initdata = {
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{ PCI_VENDOR_ID_INTEL, 0x3ec4,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
+	{ PCI_VENDOR_ID_INTEL, 0x8a12,
+		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{ PCI_VENDOR_ID_BROADCOM, 0x4331,
 	  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},
 	{}

commit f8edbde885bbcab6a2b4a1b5ca614e6ccb807577
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Nov 29 14:23:02 2019 +0800

    x86/intel: Disable HPET on Intel Coffee Lake H platforms
    
    Coffee Lake H SoC has similar behavior as Coffee Lake, skewed HPET timer
    once the SoCs entered PC10.
    
    So let's disable HPET on CFL-H platforms.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bp@alien8.de
    Cc: feng.tang@intel.com
    Cc: harry.pan@intel.com
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20191129062303.18982-1-kai.heng.feng@canonical.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 4cba91ec8049..606711f5ebf8 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -710,6 +710,8 @@ static struct chipset early_qrk[] __initdata = {
 	 */
 	{ PCI_VENDOR_ID_INTEL, 0x0f00,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
+	{ PCI_VENDOR_ID_INTEL, 0x3e20,
+		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{ PCI_VENDOR_ID_INTEL, 0x3ec4,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{ PCI_VENDOR_ID_BROADCOM, 0x4331,

commit fc5db58539b49351e76f19817ed1102bf7c712d0
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Oct 16 18:38:16 2019 +0800

    x86/quirks: Disable HPET on Intel Coffe Lake platforms
    
    Some Coffee Lake platforms have a skewed HPET timer once the SoCs entered
    PC10, which in consequence marks TSC as unstable because HPET is used as
    watchdog clocksource for TSC.
    
    Harry Pan tried to work around it in the clocksource watchdog code [1]
    thereby creating a circular dependency between HPET and TSC. This also
    ignores the fact, that HPET is not only unsuitable as watchdog clocksource
    on these systems, it becomes unusable in general.
    
    Disable HPET on affected platforms.
    
    Suggested-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=203183
    Link: https://lore.kernel.org/lkml/20190516090651.1396-1-harry.pan@intel.com/ [1]
    Link: https://lkml.kernel.org/r/20191016103816.30650-1-kai.heng.feng@canonical.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6f6b1d04dadf..4cba91ec8049 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -710,6 +710,8 @@ static struct chipset early_qrk[] __initdata = {
 	 */
 	{ PCI_VENDOR_ID_INTEL, 0x0f00,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
+	{ PCI_VENDOR_ID_INTEL, 0x3ec4,
+		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{ PCI_VENDOR_ID_BROADCOM, 0x4331,
 	  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},
 	{}

commit 6b2436aeb945961f86e2b6b74be1a4b1a372a1a4
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Fri Jul 12 14:02:39 2019 -0700

    x86/gpu: add TGL stolen memory support
    
    Reuse Gen11 stolen memory changes since Tiger Lake uses the same BSM
    register (and format).
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712210238.5622-1-lucas.demarchi@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6c4f01540833..6f6b1d04dadf 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -549,6 +549,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_CNL_IDS(&gen9_early_ops),
 	INTEL_ICL_11_IDS(&gen11_early_ops),
 	INTEL_EHL_IDS(&gen11_early_ops),
+	INTEL_TGL_12_IDS(&gen11_early_ops),
 };
 
 struct resource intel_graphics_stolen_res __ro_after_init = DEFINE_RES_MEM(0, 0);

commit d53fef0be4a5f2f12219c231cdb6f838fbbf680c
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Mar 15 12:19:38 2019 -0700

    x86/gpu: add ElkhartLake to gen11 early quirks
    
    Let's reserve EHL stolen memory for graphics.
    
    ElkhartLake is a gen11 platform which is compatible with
    ICL changes.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190315191938.22211-2-rodrigo.vivi@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index f91d3ed2df62..6c4f01540833 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -548,6 +548,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_GLK_IDS(&gen9_early_ops),
 	INTEL_CNL_IDS(&gen9_early_ops),
 	INTEL_ICL_11_IDS(&gen11_early_ops),
+	INTEL_EHL_IDS(&gen11_early_ops),
 };
 
 struct resource intel_graphics_stolen_res __ro_after_init = DEFINE_RES_MEM(0, 0);

commit 86d35d4e7625f7c056d81316da107bd3a7564fb3
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Mar 26 07:40:54 2019 +0000

    drm/i915: Split Pineview device info into desktop and mobile
    
    This allows the IS_PINEVIEW_<G|M> macros to be removed and avoid
    duplication of device ids already defined in i915_pciids.h.
    
    !IS_MOBILE check can be used in place of existing IS_PINEVIEW_G call
    sites.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190326074057.27833-2-tvrtko.ursulin@linux.intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 50d5848bf22e..f91d3ed2df62 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -525,7 +525,8 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_I945G_IDS(&gen3_early_ops),
 	INTEL_I945GM_IDS(&gen3_early_ops),
 	INTEL_VLV_IDS(&gen6_early_ops),
-	INTEL_PINEVIEW_IDS(&gen3_early_ops),
+	INTEL_PINEVIEW_G_IDS(&gen3_early_ops),
+	INTEL_PINEVIEW_M_IDS(&gen3_early_ops),
 	INTEL_I965G_IDS(&gen3_early_ops),
 	INTEL_G33_IDS(&gen3_early_ops),
 	INTEL_I965GM_IDS(&gen3_early_ops),

commit ef8e0ff97ae8168ffe1558a5726a8b348c8228a3
Merge: 294f96ae8aa5 ef821e3f14e8
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jul 20 12:29:23 2018 +1000

    Merge tag 'drm-intel-next-2018-07-19' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    On GEM side:
    
    - GuC related fixes (Chris, Michal)
    - GTT read-only pages support (Jon, Chris)
    - More selftests fixes (Chris)
    - More GPU reset improvements (Chris)
    - Flush caches after GGTT writes (Chris)
    - Handle recursive shrinker for vma->last_active allocation (Chris)
    - Other execlists fixes (Chris)
    
    On Display side:
    
    - GLK HDMI fix (Clint)
    - Rework and cleanup around HPD pin (Ville)
    - Preparation work for Display Stream Compression support coming on ICL (Anusha)
    - Nuke LVDS lid notification (Ville)
    - Assume eDP is always connected (Ville)
    - Kill intel panel detection (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Fri 20 Jul 2018 01:51:45 AM AEST
    # gpg:                using RSA key FA625F640EEB13CA
    # gpg: Good signature from "Rodrigo Vivi <rodrigo.vivi@intel.com>"
    # gpg:                 aka "Rodrigo Vivi <rodrigo.vivi@gmail.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 6D20 7068 EEDD 6509 1C2C  E2A3 FA62 5F64 0EEB 13CA
    
    # Conflicts:
    #       drivers/gpu/drm/i915/intel_lrc.c
    Link: https://patchwork.freedesktop.org/patch/msgid/20180719171257.GA12199@intel.com

commit db0c8d8b031d2b5960f6407f7f2ca20e97e00605
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri May 4 13:32:51 2018 -0700

    x86/gpu: reserve ICL's graphics stolen memory
    
    ICL changes the registers and addresses to 64 bits.
    
    I also briefly looked at implementing an u64 version of the PCI config
    read functions, but I concluded this wouldn't be trivial, so it's not
    worth doing it for a single user that can't have any racing problems
    while reading the register in two separate operations.
    
    v2:
     - Scrub the development (non-public) changelog (Joonas).
     - Remove the i915.ko bits so this can be easily backported in order
       to properly avoid stolen memory even on machines without i915.ko
       (Joonas).
     - CC stable for the reasons above.
    
    Issue: VIZ-9250
    CC: stable@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Fixes: 412310019a20 ("drm/i915/icl: Add initial Icelake definitions.")
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180504203252.28048-1-paulo.r.zanoni@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bae0d32e327b..72c2cf961d44 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -340,6 +340,18 @@ static resource_size_t __init gen3_stolen_base(int num, int slot, int func,
 	return bsm & INTEL_BSM_MASK;
 }
 
+static resource_size_t __init gen11_stolen_base(int num, int slot, int func,
+						resource_size_t stolen_size)
+{
+	u64 bsm;
+
+	bsm = read_pci_config(num, slot, func, INTEL_GEN11_BSM_DW0);
+	bsm &= INTEL_BSM_MASK;
+	bsm |= (u64)read_pci_config(num, slot, func, INTEL_GEN11_BSM_DW1) << 32;
+
+	return bsm;
+}
+
 static resource_size_t __init i830_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
@@ -500,6 +512,11 @@ static const struct intel_early_ops chv_early_ops __initconst = {
 	.stolen_size = chv_stolen_size,
 };
 
+static const struct intel_early_ops gen11_early_ops __initconst = {
+	.stolen_base = gen11_stolen_base,
+	.stolen_size = gen9_stolen_size,
+};
+
 static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_I830_IDS(&i830_early_ops),
 	INTEL_I845G_IDS(&i845_early_ops),
@@ -531,6 +548,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_CFL_IDS(&gen9_early_ops),
 	INTEL_GLK_IDS(&gen9_early_ops),
 	INTEL_CNL_IDS(&gen9_early_ops),
+	INTEL_ICL_11_IDS(&gen11_early_ops),
 };
 
 struct resource intel_graphics_stolen_res __ro_after_init = DEFINE_RES_MEM(0, 0);

commit a7a3153a98d581196ce092e0b83cac2c4ee1fd1f
Author: Joe Perches <joe@perches.com>
Date:   Wed May 9 08:15:45 2018 -0700

    x86/early-quirks: Rename duplicate define of dev_err
    
    dev_err is becoming a macro calling _dev_err to allow prefixing of
    dev_fmt to any dev_<level> use that has a #define dev_fmt(fmt) similar
    to the existing #define pr_fmt(fmt) uses.
    
    Remove this dev_err macro and convert the existing two uses to pr_err.
    This allows clean compilation in the patch that introduces dev_fmt which
    can prefix dev_<level> logging macros with arbitrary content similar to
    the #define pr_fmt macro.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Link: https://lkml.kernel.org/r/8fb4b2a77d50e21ae1f7e4e267e68691efe2c270.1525878372.git.joe@perches.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bae0d32e327b..da5d8ac60062 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -28,8 +28,6 @@
 #include <asm/irq_remapping.h>
 #include <asm/early_ioremap.h>
 
-#define dev_err(msg)  pr_err("pci 0000:%02x:%02x.%d: %s", bus, slot, func, msg)
-
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
 	u32 htcfg;
@@ -617,7 +615,8 @@ static void __init apple_airport_reset(int bus, int slot, int func)
 
 		pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0) {
-			dev_err("Cannot power up Apple AirPort card\n");
+			pr_err("pci 0000:%02x:%02x.%d: Cannot power up Apple AirPort card\n",
+			       bus, slot, func);
 			return;
 		}
 	}
@@ -628,7 +627,8 @@ static void __init apple_airport_reset(int bus, int slot, int func)
 
 	mmio = early_ioremap(addr, BCM4331_MMIO_SIZE);
 	if (!mmio) {
-		dev_err("Cannot iomap Apple AirPort card\n");
+		pr_err("pci 0000:%02x:%02x.%d: Cannot iomap Apple AirPort card\n",
+		       bus, slot, func);
 		return;
 	}
 

commit 33aa69ed8aacd92dea12671e52eb3ca6ac2d7a49
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Wed Dec 13 12:04:25 2017 -0800

    x86/gpu: add CFL to early quirks
    
    CFL was missing from intel_early_ids[]. The PCI ID needs to be there to
    allow the memory region to be stolen, otherwise we could have RAM being
    arbitrarily overwritten if for example we keep using the UEFI framebuffer,
    depending on how BIOS has set up the e820 map.
    
    Fixes: b056f8f3d6b9 ("drm/i915/cfl: Add Coffee Lake PCI IDs for S Skus.")
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86@kernel.org
    Cc: <stable@vger.kernel.org> # v4.13+ 0890540e21cf drm/i915: add GT number to intel_device_info
    Cc: <stable@vger.kernel.org> # v4.13+ 41693fd52373 drm/i915/kbl: Change a KBL pci id to GT2 from GT1.5
    Cc: <stable@vger.kernel.org> # v4.13+
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171213200425.2954-1-lucas.demarchi@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 3cbb2c78a9df..bae0d32e327b 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -528,6 +528,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_SKL_IDS(&gen9_early_ops),
 	INTEL_BXT_IDS(&gen9_early_ops),
 	INTEL_KBL_IDS(&gen9_early_ops),
+	INTEL_CFL_IDS(&gen9_early_ops),
 	INTEL_GLK_IDS(&gen9_early_ops),
 	INTEL_CNL_IDS(&gen9_early_ops),
 };

commit 3b51b6f31aa81c435601ab7eed244a120731c781
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Mon Dec 11 15:18:16 2017 +0000

    x86/early-quirks: replace the magical increment start values
    
    Replace the magical +2, +9 etc. with +MB, which is far easier to read.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211151822.20953-4-matthew.auld@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6c1624889011..3cbb2c78a9df 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -428,9 +428,9 @@ static resource_size_t __init chv_stolen_size(int num, int slot, int func)
 	if (gms < 0x11)
 		return gms * MB(32);
 	else if (gms < 0x17)
-		return (gms - 0x11 + 2) * MB(4);
+		return (gms - 0x11) * MB(4) + MB(8);
 	else
-		return (gms - 0x17 + 9) * MB(4);
+		return (gms - 0x17) * MB(4) + MB(36);
 }
 
 static resource_size_t __init gen9_stolen_size(int num, int slot, int func)
@@ -446,7 +446,7 @@ static resource_size_t __init gen9_stolen_size(int num, int slot, int func)
 	if (gms < 0xf0)
 		return gms * MB(32);
 	else
-		return (gms - 0xf0 + 1) * MB(4);
+		return (gms - 0xf0) * MB(4) + MB(4);
 }
 
 struct intel_early_ops {

commit 55f56fc46020ea59273ddb5de0bdc41b7da45c73
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Mon Dec 11 15:18:15 2017 +0000

    x86/early-quirks: export the stolen region as a resource
    
    We duplicate the stolen discovery code in early-quirks and in i915,
    however if we just export the region as a resource from early-quirks we
    can nuke the duplication.
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211151822.20953-3-matthew.auld@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index a18de5fb9e68..6c1624889011 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -532,6 +532,9 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_CNL_IDS(&gen9_early_ops),
 };
 
+struct resource intel_graphics_stolen_res __ro_after_init = DEFINE_RES_MEM(0, 0);
+EXPORT_SYMBOL(intel_graphics_stolen_res);
+
 static void __init
 intel_graphics_stolen(int num, int slot, int func,
 		      const struct intel_early_ops *early_ops)
@@ -546,8 +549,12 @@ intel_graphics_stolen(int num, int slot, int func,
 		return;
 
 	end = base + size - 1;
-	printk(KERN_INFO "Reserving Intel graphics memory at %pa-%pa\n",
-	       &base, &end);
+
+	intel_graphics_stolen_res.start = base;
+	intel_graphics_stolen_res.end = end;
+
+	printk(KERN_INFO "Reserving Intel graphics memory at %pR\n",
+	       &intel_graphics_stolen_res);
 
 	/* Mark this space as reserved */
 	e820__range_add(base, size, E820_TYPE_RESERVED);

commit 6f9fa996c9bf3d86406df95982c7b3def38eb76f
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Mon Dec 11 15:18:14 2017 +0000

    x86/early-quirks: Extend Intel graphics stolen memory placement to 64bit
    
    To give upcoming SKU BIOSes more flexibility in placing the Intel
    graphics stolen memory, make all variables storing the placement or size
    compatible with full 64 bit range.
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211151822.20953-2-matthew.auld@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 1e82f787c160..a18de5fb9e68 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -243,7 +243,7 @@ static void __init intel_remapping_check(int num, int slot, int func)
 #define KB(x)	((x) * 1024UL)
 #define MB(x)	(KB (KB (x)))
 
-static size_t __init i830_tseg_size(void)
+static resource_size_t __init i830_tseg_size(void)
 {
 	u8 esmramc = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);
 
@@ -256,7 +256,7 @@ static size_t __init i830_tseg_size(void)
 		return KB(512);
 }
 
-static size_t __init i845_tseg_size(void)
+static resource_size_t __init i845_tseg_size(void)
 {
 	u8 esmramc = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);
 	u8 tseg_size = esmramc & I845_TSEG_SIZE_MASK;
@@ -273,7 +273,7 @@ static size_t __init i845_tseg_size(void)
 	return 0;
 }
 
-static size_t __init i85x_tseg_size(void)
+static resource_size_t __init i85x_tseg_size(void)
 {
 	u8 esmramc = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);
 
@@ -283,12 +283,12 @@ static size_t __init i85x_tseg_size(void)
 	return MB(1);
 }
 
-static size_t __init i830_mem_size(void)
+static resource_size_t __init i830_mem_size(void)
 {
 	return read_pci_config_byte(0, 0, 0, I830_DRB3) * MB(32);
 }
 
-static size_t __init i85x_mem_size(void)
+static resource_size_t __init i85x_mem_size(void)
 {
 	return read_pci_config_byte(0, 0, 1, I85X_DRB3) * MB(32);
 }
@@ -297,36 +297,36 @@ static size_t __init i85x_mem_size(void)
  * On 830/845/85x the stolen memory base isn't available in any
  * register. We need to calculate it as TOM-TSEG_SIZE-stolen_size.
  */
-static phys_addr_t __init i830_stolen_base(int num, int slot, int func,
-					   size_t stolen_size)
+static resource_size_t __init i830_stolen_base(int num, int slot, int func,
+					       resource_size_t stolen_size)
 {
-	return (phys_addr_t)i830_mem_size() - i830_tseg_size() - stolen_size;
+	return i830_mem_size() - i830_tseg_size() - stolen_size;
 }
 
-static phys_addr_t __init i845_stolen_base(int num, int slot, int func,
-					   size_t stolen_size)
+static resource_size_t __init i845_stolen_base(int num, int slot, int func,
+					       resource_size_t stolen_size)
 {
-	return (phys_addr_t)i830_mem_size() - i845_tseg_size() - stolen_size;
+	return i830_mem_size() - i845_tseg_size() - stolen_size;
 }
 
-static phys_addr_t __init i85x_stolen_base(int num, int slot, int func,
-					   size_t stolen_size)
+static resource_size_t __init i85x_stolen_base(int num, int slot, int func,
+					       resource_size_t stolen_size)
 {
-	return (phys_addr_t)i85x_mem_size() - i85x_tseg_size() - stolen_size;
+	return i85x_mem_size() - i85x_tseg_size() - stolen_size;
 }
 
-static phys_addr_t __init i865_stolen_base(int num, int slot, int func,
-					   size_t stolen_size)
+static resource_size_t __init i865_stolen_base(int num, int slot, int func,
+					       resource_size_t stolen_size)
 {
 	u16 toud = 0;
 
 	toud = read_pci_config_16(0, 0, 0, I865_TOUD);
 
-	return (phys_addr_t)(toud << 16) + i845_tseg_size();
+	return toud * KB(64) + i845_tseg_size();
 }
 
-static phys_addr_t __init gen3_stolen_base(int num, int slot, int func,
-					   size_t stolen_size)
+static resource_size_t __init gen3_stolen_base(int num, int slot, int func,
+					       resource_size_t stolen_size)
 {
 	u32 bsm;
 
@@ -337,10 +337,10 @@ static phys_addr_t __init gen3_stolen_base(int num, int slot, int func,
 	 */
 	bsm = read_pci_config(num, slot, func, INTEL_BSM);
 
-	return (phys_addr_t)bsm & INTEL_BSM_MASK;
+	return bsm & INTEL_BSM_MASK;
 }
 
-static size_t __init i830_stolen_size(int num, int slot, int func)
+static resource_size_t __init i830_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -361,7 +361,7 @@ static size_t __init i830_stolen_size(int num, int slot, int func)
 	return 0;
 }
 
-static size_t __init gen3_stolen_size(int num, int slot, int func)
+static resource_size_t __init gen3_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -390,7 +390,7 @@ static size_t __init gen3_stolen_size(int num, int slot, int func)
 	return 0;
 }
 
-static size_t __init gen6_stolen_size(int num, int slot, int func)
+static resource_size_t __init gen6_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -398,10 +398,10 @@ static size_t __init gen6_stolen_size(int num, int slot, int func)
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
 	gms = (gmch_ctrl >> SNB_GMCH_GMS_SHIFT) & SNB_GMCH_GMS_MASK;
 
-	return (size_t)gms * MB(32);
+	return gms * MB(32);
 }
 
-static size_t __init gen8_stolen_size(int num, int slot, int func)
+static resource_size_t __init gen8_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -409,10 +409,10 @@ static size_t __init gen8_stolen_size(int num, int slot, int func)
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
 	gms = (gmch_ctrl >> BDW_GMCH_GMS_SHIFT) & BDW_GMCH_GMS_MASK;
 
-	return (size_t)gms * MB(32);
+	return gms * MB(32);
 }
 
-static size_t __init chv_stolen_size(int num, int slot, int func)
+static resource_size_t __init chv_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -426,14 +426,14 @@ static size_t __init chv_stolen_size(int num, int slot, int func)
 	 * 0x17 to 0x1d: 4MB increments start at 36MB
 	 */
 	if (gms < 0x11)
-		return (size_t)gms * MB(32);
+		return gms * MB(32);
 	else if (gms < 0x17)
-		return (size_t)(gms - 0x11 + 2) * MB(4);
+		return (gms - 0x11 + 2) * MB(4);
 	else
-		return (size_t)(gms - 0x17 + 9) * MB(4);
+		return (gms - 0x17 + 9) * MB(4);
 }
 
-static size_t __init gen9_stolen_size(int num, int slot, int func)
+static resource_size_t __init gen9_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 	u16 gms;
@@ -444,14 +444,15 @@ static size_t __init gen9_stolen_size(int num, int slot, int func)
 	/* 0x0  to 0xef: 32MB increments starting at 0MB */
 	/* 0xf0 to 0xfe: 4MB increments starting at 4MB */
 	if (gms < 0xf0)
-		return (size_t)gms * MB(32);
+		return gms * MB(32);
 	else
-		return (size_t)(gms - 0xf0 + 1) * MB(4);
+		return (gms - 0xf0 + 1) * MB(4);
 }
 
 struct intel_early_ops {
-	size_t (*stolen_size)(int num, int slot, int func);
-	phys_addr_t (*stolen_base)(int num, int slot, int func, size_t size);
+	resource_size_t (*stolen_size)(int num, int slot, int func);
+	resource_size_t (*stolen_base)(int num, int slot, int func,
+				       resource_size_t size);
 };
 
 static const struct intel_early_ops i830_early_ops __initconst = {
@@ -535,8 +536,8 @@ static void __init
 intel_graphics_stolen(int num, int slot, int func,
 		      const struct intel_early_ops *early_ops)
 {
-	phys_addr_t base, end;
-	size_t size;
+	resource_size_t base, size;
+	resource_size_t end;
 
 	size = early_ops->stolen_size(num, slot, func);
 	base = early_ops->stolen_base(num, slot, func, size);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 927abeaf63e2..1e82f787c160 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Various workarounds for chipset bugs.
    This code runs very early and can't use the regular PCI subsystem
    The entries are keyed to PCI bridges which usually identify chipsets

commit 53ac64aac9af8cd0e5456c8a9bb68c47b571b0a9
Merge: 439644096c1a 298bd7fb26cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:45:03 2017 -0700

    Merge tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These include a usual ACPICA code update (this time to upstream
      revision 20170728), a fix for a boot crash on some systems with
      Thunderbolt devices connected at boot time, a rework of the handling
      of PCI bridges when setting up device wakeup, new support for Apple
      device properties, support for DMA configurations reported via ACPI on
      ARM64, APEI-related updates, ACPI EC driver updates and assorted minor
      modifications in several places.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170728
         including:
          * Alias operator handling update (Bob Moore).
          * Deferred resolution of reference package elements (Bob Moore).
          * Support for the _DMA method in walk resources (Bob Moore).
          * Tables handling update and support for deferred table
            verification (Lv Zheng).
          * Update of SMMU models for IORT (Robin Murphy).
          * Compiler and disassembler updates (Alex James, Erik Schmauss,
            Ganapatrao Kulkarni, James Morse).
          * Tools updates (Erik Schmauss, Lv Zheng).
          * Assorted minor fixes and cleanups (Bob Moore, Kees Cook, Lv
            Zheng, Shao Ming).
    
       - Rework the initialization of non-wakeup GPEs with method handlers
         in order to address a boot crash on some systems with Thunderbolt
         devices connected at boot time where we miss an early hotplug event
         due to a delay in GPE enabling (Rafael Wysocki).
    
       - Rework the handling of PCI bridges when setting up ACPI-based
         device wakeup in order to avoid disabling wakeup for bridges
         prematurely (Rafael Wysocki).
    
       - Consolidate Apple DMI checks throughout the tree, add support for
         Apple device properties to the device properties framework and use
         these properties for the handling of I2C and SPI devices on Apple
         systems (Lukas Wunner).
    
       - Add support for _DMA to the ACPI-based device properties lookup
         code and make it possible to use the information from there to
         configure DMA regions on ARM64 systems (Lorenzo Pieralisi).
    
       - Fix several issues in the APEI code, add support for exporting the
         BERT error region over sysfs and update APEI MAINTAINERS entry with
         reviewers information (Borislav Petkov, Dongjiu Geng, Loc Ho, Punit
         Agrawal, Tony Luck, Yazen Ghannam).
    
       - Fix a potential initialization ordering issue in the ACPI EC driver
         and clean it up somewhat (Lv Zheng).
    
       - Update the ACPI SPCR driver to extend the existing XGENE 8250
         workaround in it to a new platform (m400) and to work around an
         Xgene UART clock issue (Graeme Gregory).
    
       - Add a new utility function to the ACPI core to support using ACPI
         OEM ID / OEM Table ID / Revision for system identification in
         blacklisting or similar and switch over the existing code already
         using this information to this new interface (Toshi Kani).
    
       - Fix an xpower PMIC issue related to GPADC reads that always return
         0 without extra pin manipulations (Hans de Goede).
    
       - Add statements to print debug messages in a couple of places in the
         ACPI core for easier diagnostics (Rafael Wysocki).
    
       - Clean up the ACPI processor driver slightly (Colin Ian King, Hanjun
         Guo).
    
       - Clean up the ACPI x86 boot code somewhat (Andy Shevchenko).
    
       - Add a quirk for Dell OptiPlex 9020M to the ACPI backlight driver
         (Alex Hung).
    
       - Assorted fixes, cleanups and updates related to ACPI (Amitoj Kaur
         Chawla, Bhumika Goyal, Frank Rowand, Jean Delvare, Punit Agrawal,
         Ronald Tschalär, Sumeet Pawnikar)"
    
    * tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (75 commits)
      ACPI / APEI: Suppress message if HEST not present
      intel_pstate: convert to use acpi_match_platform_list()
      ACPI / blacklist: add acpi_match_platform_list()
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources
      ACPI: make device_attribute const
      ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
      ACPI: APEI: fix the wrong iteration of generic error status block
      ACPI / processor: make function acpi_processor_check_duplicates() static
      ACPI / EC: Clean up EC GPE mask flag
      ACPI: EC: Fix possible issues related to EC initialization order
      ACPI / PM: Add debug statements to acpi_pm_notify_handler()
      ACPI: Add debug statements to acpi_global_event_handler()
      ACPI / scan: Enable GPEs before scanning the namespace
      ACPICA: Make it possible to enable runtime GPEs earlier
      ACPICA: Dispatch active GPEs at init time
      ACPI: SPCR: work around clock issue on xgene UART
      ACPI: SPCR: extend XGENE 8250 workaround to m400
      ACPI / LPSS: Don't abort ACPI scan on missing mem resource
      mailbox: pcc: Drop uninformative output during boot
      ACPI/IORT: Add IORT named component memory address limits
      ...

commit 630b3aff8a51c90ef15b59c9560ac35e40e7ec09
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Aug 1 14:10:41 2017 +0200

    treewide: Consolidate Apple DMI checks
    
    We're about to amend ACPI bus scan with DMI checks whether we're running
    on a Mac to support Apple device properties in AML.  The DMI checks are
    performed for every single device, adding overhead for everything x86
    that isn't Apple, which is the majority.  Rafael and Andy therefore
    request to perform the DMI match only once and cache the result.
    
    Outside of ACPI various other Apple DMI checks exist and it seems
    reasonable to use the cached value there as well.  Rafael, Andy and
    Darren suggest performing the DMI check in arch code and making it
    available with a header in include/linux/platform_data/x86/.
    
    To this end, add early_platform_quirks() to arch/x86/kernel/quirks.c
    to perform the DMI check and invoke it from setup_arch().  Switch over
    all existing Apple DMI checks, thereby fixing two deficiencies:
    
    * They are now #defined to false on non-x86 arches and can thus be
      optimized away if they're located in cross-arch code.
    
    * Some of them only match "Apple Inc." but not "Apple Computer, Inc.",
      which is used by BIOSes released between January 2006 (when the first
      x86 Macs started shipping) and January 2007 (when the company name
      changed upon introduction of the iPhone).
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Suggested-by: Darren Hart <dvhart@infradead.org>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index d907c3d8633f..a70a65ae798a 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -12,10 +12,10 @@
 #include <linux/pci.h>
 #include <linux/acpi.h>
 #include <linux/delay.h>
-#include <linux/dmi.h>
 #include <linux/pci_ids.h>
 #include <linux/bcma/bcma.h>
 #include <linux/bcma/bcma_regs.h>
+#include <linux/platform_data/x86/apple.h>
 #include <drm/i915_drm.h>
 #include <asm/pci-direct.h>
 #include <asm/dma.h>
@@ -593,7 +593,7 @@ static void __init apple_airport_reset(int bus, int slot, int func)
 	u64 addr;
 	int i;
 
-	if (!dmi_match(DMI_SYS_VENDOR, "Apple Inc."))
+	if (!x86_apple_machine)
 		return;
 
 	/* Card may have been put into PCI_D3hot by grub quirk */

commit 2e1e9d48939edad49a9f06762ecfc9c73666d489
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Wed Jul 5 18:00:45 2017 -0700

    x86/gpu: CNL uses the same GMS values as SKL
    
    So don't forget to reserve its stolen memory bits.
    
    v2: Add ack and remove "TODO" from commit message.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499302845-17856-1-git-send-email-rodrigo.vivi@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index d907c3d8633f..a4516ca4c4f3 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -527,6 +527,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_BXT_IDS(&gen9_early_ops),
 	INTEL_KBL_IDS(&gen9_early_ops),
 	INTEL_GLK_IDS(&gen9_early_ops),
+	INTEL_CNL_IDS(&gen9_early_ops),
 };
 
 static void __init

commit 2f34c1231bfc9f2550f934acb268ac7315fb3837
Merge: a3719f34fdb6 8b03d1ed2c43
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 3 11:44:24 2017 -0700

    Merge tag 'drm-for-v4.12' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm u pdates from Dave Airlie:
     "This is the main drm pull request for v4.12. Apart from two fixes
      pulls, everything should have been in drm-next for at least 2 weeks.
    
      The biggest thing in here is AMD released the public headers for their
      upcoming VEGA GPUs. These as always are quite a sizeable chunk of
      header files. They've also added initial non-display support for those
      GPUs, though they aren't available in production yet.
    
      Otherwise it's pretty much normal.
    
      New bridge drivers:
       - megachips-stdpxxxx-ge-b850v3-fw LVDS->DP++
       - generic LVDS bridge support.
    
      Core:
       - Displayport link train failure reporting to userspace
       - debugfs interface cleaned up
       - subsystem TODO in kerneldoc now
       - Extended fbdev support (flipping and vblank wait)
       - drm_platform removed
       - EDP CRC support in helper
       - HF-VSDB SCDC support in EDID parser
       - Lots of code cleanups and header extraction
       - Thunderbolt external GPU awareness
       - Atomic helper improvements
       - Documentation improvements
    
      panel:
       - Sitronix and Samsung new panel support
    
      amdgpu:
       - Preliminary vega10 support
       - Multi-level page table support
       - GPU sensor support for userspace
       - PRT support for sparse buffers
       - SR-IOV improvements
       - Non-contig VRAM CPU mapping
    
      i915:
       - Atomic modesetting enabled by default on Gen5+
       - LSPCON improvements
       - Atomic state handling for cdclk
       - GPU reset improvements
       - In-kernel unit tests
       - Geminilake improvements and color manager support
       - Designware i2c fixes
       - vblank evasion improvements
       - Hotplug safe connector iterators
       - GVT scheduler QoS support
       - GVT Kabylake support
    
      nouveau:
       - Acceleration support for Pascal (GP10x).
       - Rearchitecture of code handling proprietary signed firmware
       - Fix GTX 970 with odd MMU configuration
       - GP10B support
       - GP107 acceleration support
    
      vmwgfx:
       - Atomic modesetting support for vmwgfx
    
      omapdrm:
       - Support for render nodes
       - Refactor omapdss code
       - Fix some probe ordering issues
       - Fix too dark RGB565 rendering
    
      sunxi:
       - prelim rework for multiple pipes.
    
      mali-dp:
       - Color management support
       - Plane scaling
       - Power management improvements
    
      imx-drm:
       - Prefetch Resolve Engine/Gasket on i.MX6QP
       - Deferred plane disabling
       - Separate alpha support
    
      mediatek:
       - Mediatek SoC MT2701 support
    
      rcar-du:
       - Gen3 HDMI support
    
      msm:
       - 4k support for newer chips
       - OPP bindings for gpu
       - prep work for per-process pagetables
    
      vc4:
       - HDMI audio support
       - fixes
    
      qxl:
       - minor fixes.
    
      dw-hdmi:
       - PHY improvements
       - CSC fixes
       - Amlogic GX SoC support"
    
    * tag 'drm-for-v4.12' of git://people.freedesktop.org/~airlied/linux: (1778 commits)
      drm/nouveau/fb/gf100-: Fix 32 bit wraparound in new ram detection
      drm/nouveau/secboot/gm20b: fix the error return code in gm20b_secboot_tegra_read_wpr()
      drm/nouveau/kms: Increase max retries in scanout position queries.
      drm/nouveau/bios/bitP: check that table is long enough for optional pointers
      drm/nouveau/fifo/nv40: no ctxsw for pre-nv44 mpeg engine
      drm: mali-dp: use div_u64 for expensive 64-bit divisions
      drm/i915: Confirm the request is still active before adding it to the await
      drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
      drm/i915/selftests: Allocate inode/file dynamically
      drm/i915: Fix system hang with EI UP masked on Haswell
      drm/i915: checking for NULL instead of IS_ERR() in mock selftests
      drm/i915: Perform link quality check unconditionally during long pulse
      drm/i915: Fix use after free in lpe_audio_platdev_destroy()
      drm/i915: Use the right mapping_gfp_mask for final shmem allocation
      drm/i915: Make legacy cursor updates more unsynced
      drm/i915: Apply a cond_resched() to the saturated signaler
      drm/i915: Park the signaler before sleeping
      drm: mali-dp: Check the mclk rate and allow up/down scaling
      drm: mali-dp: Enable image enhancement when scaling
      drm: mali-dp: Add plane upscaling support
      ...

commit f9748fa045851041ba69a1d2899971746f29c9d5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 18:00:35 2017 +0100

    x86/boot/e820: Simplify the e820__update_table() interface
    
    The e820__update_table() parameters are pretty complex:
    
      arch/x86/include/asm/e820/api.h:extern int  e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map);
    
    But 90% of the usage is trivial:
    
      arch/x86/kernel/e820.c:       if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
      arch/x86/kernel/e820.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/e820.c:               if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
      arch/x86/kernel/e820.c:       e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
      arch/x86/kernel/early-quirks.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/setup.c:      e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/setup.c:              e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/platform/efi/efi.c:  e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/xen/setup.c: e820__update_table(xen_e820_table.entries, ARRAY_SIZE(xen_e820_table.entries),
      arch/x86/xen/setup.c: e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/xen/setup.c: e820__update_table(xen_e820_table.entries, ARRAY_SIZE(xen_e820_table.entries),
    
    as it only uses an exiting struct e820_table's entries array, its size and
    its current number of entries as input and output arguments.
    
    Only one use is non-trivial:
    
      arch/x86/kernel/e820.c:       e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
    
    ... which call updates the E820 table in the zeropage in-situ, and the layout there does not
    match that of 'struct e820_table' (in particular nr_entries is at a different offset,
    hardcoded by the boot protocol).
    
    Simplify all this by introducing a low level __e820__update_table() API that
    the zeropage update call can use, and simplifying the main e820__update_table()
    call signature down to:
    
            int e820__update_table(struct e820_table *table);
    
    This visibly simplifies all the call sites:
    
      arch/x86/include/asm/e820/api.h:extern int  e820__update_table(struct e820_table *table);
      arch/x86/include/asm/e820/types.h: * call to e820__update_table() to remove duplicates.  The allowance
      arch/x86/kernel/e820.c: * The return value from e820__update_table() is zero if it
      arch/x86/kernel/e820.c:int __init e820__update_table(struct e820_table *table)
      arch/x86/kernel/e820.c:       if (e820__update_table(e820_table))
      arch/x86/kernel/e820.c:       e820__update_table(e820_table_firmware);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table);
      arch/x86/kernel/e820.c:               if (e820__update_table(e820_table) < 0)
      arch/x86/kernel/early-quirks.c:       e820__update_table(e820_table);
      arch/x86/kernel/setup.c:      e820__update_table(e820_table);
      arch/x86/kernel/setup.c:              e820__update_table(e820_table);
      arch/x86/platform/efi/efi.c:  e820__update_table(e820_table);
      arch/x86/xen/setup.c: e820__update_table(&xen_e820_table);
      arch/x86/xen/setup.c: e820__update_table(e820_table);
      arch/x86/xen/setup.c: e820__update_table(&xen_e820_table);
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 2220a4c03adf..ff7e4b3988ed 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,7 +547,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820__range_add(base, size, E820_TYPE_RESERVED);
-	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit 09821ff1d50a1ecade182c2a68a90f835e257eef
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:09:33 2017 +0100

    x86/boot/e820: Prefix the E820_* type names with "E820_TYPE_"
    
    So there's a number of constants that start with "E820" but which
    are not types - these create a confusing mixture when seen together
    with 'enum e820_type' values:
    
            E820MAP
            E820NR
            E820_X_MAX
            E820MAX
    
    To better differentiate the 'enum e820_type' values prefix them
    with E820_TYPE_.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 81a10ab15be9..2220a4c03adf 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -546,7 +546,7 @@ intel_graphics_stolen(int num, int slot, int func,
 	       &base, &end);
 
 	/* Mark this space as reserved */
-	e820__range_add(base, size, E820_RESERVED);
+	e820__range_add(base, size, E820_TYPE_RESERVED);
 	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 }
 

commit ab6bc04cfdbd5da00a85909c054770a606e7c804
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:19:36 2017 +0100

    x86/boot/e820: Create coherent API function names for E820 range operations
    
    We have these three related functions:
    
     extern void e820_add_region(u64 start, u64 size, int type);
     extern u64  e820_update_range(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820_remove_range(u64 start, u64 size, unsigned old_type, int checktype);
    
    But it's not clear from the naming that they are 3 operations based around the
    same 'memory range' concept. Rename them to better signal this, and move
    the prototypes next to each other:
    
     extern void e820__range_add   (u64 start, u64 size, int type);
     extern u64  e820__range_update(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820__range_remove(u64 start, u64 size, unsigned old_type, int checktype);
    
    Note that this improved organization of the functions shows another problem that was easy
    to miss before: sometimes the E820 entry type is 'int', sometimes 'unsigned int' - but this
    will be fixed in a separate patch.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 66722f447401..81a10ab15be9 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -546,7 +546,7 @@ intel_graphics_stolen(int num, int slot, int func,
 	       &base, &end);
 
 	/* Mark this space as reserved */
-	e820_add_region(base, size, E820_RESERVED);
+	e820__range_add(base, size, E820_RESERVED);
 	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 }
 

commit f52355a99fc06f609ca6a61098d78e476d56f526
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:09:20 2017 +0100

    x86/boot/e820: Rename sanitize_e820_table() to e820__update_table()
    
    sanitize_e820_table() is a minor misnomer in that it suggests that
    the E820 table requires sanitizing - which implies that it will only
    do anything if the E820 table is irregular (not sane).
    
    That is wrong, because sanitize_e820_table() also does a very regular
    sorting of the E820 table, which is a necessity in the basic
    append-only flow of E820 updates the kernel is allowed to perform to
    it.
    
    So rename it to e820__update_table() to include that purpose as well.
    
    This also lines up all the table-update functions into a coherent
    naming family:
    
      int  e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map);
    
      void e820__update_table_print(void);
      void e820__update_table_firmware(void);
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 4f52758accbc..66722f447401 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,7 +547,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);
-	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit bf495573fae84451a8a26215fafb5b62e387ddaf
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 14:06:21 2017 +0100

    x86/boot/e820: Harmonize the 'struct e820_table' fields
    
    So the e820_table->map and e820_table->nr_map names are a bit
    confusing, because it's not clear what a 'map' really means
    (it could be a bitmap, or some other data structure), nor is
    it clear what nr_map means (is it a current index, or some
    other count).
    
    Rename the fields from:
    
     e820_table->map        =>     e820_table->entries
     e820_table->nr_map     =>     e820_table->nr_entries
    
    which makes it abundantly clear that these are entries
    of the table, and that the size of the table is ->nr_entries.
    
    Propagate the changes to all affected files. Where necessary,
    adjust local variable names to better reflect the new field names.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index a6cdf9b9c7a9..4f52758accbc 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,7 +547,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);
-	sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map);
+	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit 61a50101638254d38e3f4281265b44de0f2cba4e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 13:54:38 2017 +0100

    x86/boot/e820: Rename everything to e820_table
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 31d755534c36..a6cdf9b9c7a9 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,7 +547,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);
-	sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map);
+	sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit acd4c048728814505fae8e224cf9074bd1ad291e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 13:20:53 2017 +0100

    x86/boot/e820: Rename 'e820_map' variables to 'e820_array'
    
    In line with the rename to 'struct e820_array', harmonize the naming of common e820
    table variable names as well:
    
     e820          =>  e820_array
     e820_saved    =>  e820_array_saved
     e820_map      =>  e820_array
     initial_e820  =>  e820_array_init
    
    This makes the variable names more consistent  and easier to grep for.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6a08e25a48d8..31d755534c36 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,7 +547,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);
-	sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map);
+	sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit bc384c77e3bb3df2b396f4fb246b452571896c5e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Jan 24 16:47:22 2017 -0200

    x86/gpu: GLK uses the same GMS values as SKL
    
    So don't forget to reserve its stolen memory bits.
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Cc: x86@kernel.org
    Reviewed-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1485283642-14401-1-git-send-email-paulo.r.zanoni@intel.com

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6a08e25a48d8..23c4f1ce0718 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -526,6 +526,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_SKL_IDS(&gen9_early_ops),
 	INTEL_BXT_IDS(&gen9_early_ops),
 	INTEL_KBL_IDS(&gen9_early_ops),
+	INTEL_GLK_IDS(&gen9_early_ops),
 };
 
 static void __init

commit 6b25e21fa6f26d0f0d45f161d169029411c84286
Merge: a379f71a30dd 69405d3da98b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 11 18:12:22 2016 -0700

    Merge tag 'drm-for-v4.9' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Core:
       - Fence destaging work
       - DRIVER_LEGACY to split off legacy drm drivers
       - drm_mm refactoring
       - Splitting drm_crtc.c into chunks and documenting better
       - Display info fixes
       - rbtree support for prime buffer lookup
       - Simple VGA DAC driver
    
      Panel:
       - Add Nexus 7 panel
       - More simple panels
    
      i915:
       - Refactoring GEM naming
       - Refactored vma/active tracking
       - Lockless request lookups
       - Better stolen memory support
       - FBC fixes
       - SKL watermark fixes
       - VGPU improvements
       - dma-buf fencing support
       - Better DP dongle support
    
      amdgpu:
       - Powerplay for Iceland asics
       - Improved GPU reset support
       - UVD/VEC powergating support for CZ/ST
       - Preinitialised VRAM buffer support
       - Virtual display support
       - Initial SI support
       - GTT rework
       - PCI shutdown callback support
       - HPD IRQ storm fixes
    
      amdkfd:
       - bugfixes
    
      tilcdc:
       - Atomic modesetting support
    
      mediatek:
       - AAL + GAMMA engine support
       - Hook up gamma LUT
       - Temporal dithering support
    
      imx:
       - Pixel clock from devicetree
       - drm bridge support for LVDS bridges
       - active plane reconfiguration
       - VDIC deinterlacer support
       - Frame synchronisation unit support
       - Color space conversion support
    
      analogix:
       - PSR support
       - Better panel on/off support
    
      rockchip:
       - rk3399 vop/crtc support
       - PSR support
    
      vc4:
       - Interlaced vblank timing
       - 3D rendering CPU overhead reduction
       - HDMI output fixes
    
      tda998x:
       - HDMI audio ASoC support
    
      sunxi:
       - Allwinner A33 support
       - better TCON support
    
      msm:
       - DT binding cleanups
       - Explicit fence-fd support
    
      sti:
       - remove sti415/416 support
    
      etnaviv:
       - MMUv2 refactoring
       - GC3000 support
    
      exynos:
       - Refactoring HDMI DCC/PHY
       - G2D pm regression fix
       - Page fault issues with wait for vblank
    
      There is no nouveau work in this tree, as Ben didn't get a pull
      request in, and he was fighting moving to atomic and adding mst
      support, so maybe best it waits for a cycle"
    
    * tag 'drm-for-v4.9' of git://people.freedesktop.org/~airlied/linux: (1412 commits)
      drm/crtc: constify drm_crtc_index parameter
      drm/i915: Fix conflict resolution from backmerge of v4.8-rc8 to drm-next
      drm/i915/guc: Unwind GuC workqueue reservation if request construction fails
      drm/i915: Reset the breadcrumbs IRQ more carefully
      drm/i915: Force relocations via cpu if we run out of idle aperture
      drm/i915: Distinguish last emitted request from last submitted request
      drm/i915: Allow DP to work w/o EDID
      drm/i915: Move long hpd handling into the hotplug work
      drm/i915/execlists: Reinitialise context image after GPU hang
      drm/i915: Use correct index for backtracking HUNG semaphores
      drm/i915: Unalias obj->phys_handle and obj->userptr
      drm/i915: Just clear the mmiodebug before a register access
      drm/i915/gen9: only add the planes actually affected by ddb changes
      drm/i915: Allow PCH DPLL sharing regardless of DPLL_SDVO_HIGH_SPEED
      drm/i915/bxt: Fix HDMI DPLL configuration
      drm/i915/gen9: fix the watermark res_blocks value
      drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations
      drm/i915/gen9: minimum scanlines for Y tile is not always 4
      drm/i915/gen9: fix the WaWmMemoryReadLatency implementation
      drm/i915/kbl: KBL also needs to run the SAGV code
      ...

commit 475339684ef19e46f4702e2d185a869a5c454688
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Sat Sep 17 23:39:26 2016 +0200

    x86/e820: Prepare e280 code for switch to dynamic storage
    
    This patch turns e820 and e820_saved into pointers to e820 tables,
    of the same size as before.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160917213927.1787-2-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index de7501edb21c..18bb3a639197 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -555,7 +555,7 @@ intel_graphics_stolen(int num, int slot, int func,
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);
-	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
+	sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map);
 }
 
 static void __init intel_graphics_quirks(int num, int slot, int func)

commit 8d9c20e1d1e3833b5c4dab33d59cb92ea162da6a
Author: Carlos Santa <carlos.santa@intel.com>
Date:   Wed Aug 17 12:30:37 2016 -0700

    drm/i915: Remove .is_mobile field from platform struct
    
    As recommended by Ville Syrjala removing .is_mobile field from the
    platform struct definition for vlv and hsw+ GPUs as there's no need to
    make the distinction in later hardware anymore. Keep it for older GPUs
    as it is still needed for ilk-ivb.
    
    Signed-off-by: Carlos Santa <carlos.santa@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 8b8852bc2f4a..f306698a4cb4 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -507,8 +507,7 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_I915GM_IDS(&gen3_early_ops),
 	INTEL_I945G_IDS(&gen3_early_ops),
 	INTEL_I945GM_IDS(&gen3_early_ops),
-	INTEL_VLV_M_IDS(&gen6_early_ops),
-	INTEL_VLV_D_IDS(&gen6_early_ops),
+	INTEL_VLV_IDS(&gen6_early_ops),
 	INTEL_PINEVIEW_IDS(&gen3_early_ops),
 	INTEL_I965G_IDS(&gen3_early_ops),
 	INTEL_G33_IDS(&gen3_early_ops),
@@ -521,10 +520,8 @@ static const struct pci_device_id intel_early_ids[] __initconst = {
 	INTEL_SNB_M_IDS(&gen6_early_ops),
 	INTEL_IVB_M_IDS(&gen6_early_ops),
 	INTEL_IVB_D_IDS(&gen6_early_ops),
-	INTEL_HSW_D_IDS(&gen6_early_ops),
-	INTEL_HSW_M_IDS(&gen6_early_ops),
-	INTEL_BDW_M_IDS(&gen8_early_ops),
-	INTEL_BDW_D_IDS(&gen8_early_ops),
+	INTEL_HSW_IDS(&gen6_early_ops),
+	INTEL_BDW_IDS(&gen8_early_ops),
 	INTEL_CHV_IDS(&chv_early_ops),
 	INTEL_SKL_IDS(&gen9_early_ops),
 	INTEL_BXT_IDS(&gen9_early_ops),

commit d721b02fd00bf133580f431b82ef37f3b746dfb2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Aug 8 13:58:39 2016 +0300

    drm/i915: Account for TSEG size when determining 865G stolen base
    
    Looks like the TSEG lives just above TOUD, stolen comes after TSEG.
    
    The spec seems somewhat self-contradictory in places, in the ESMRAMC
    register desctription it says:
     TSEG Size:
      10=(TOUD + 512 KB) to TOUD
      11 =(TOUD + 1 MB) to TOUD
    
    so that agrees with TSEG being at TOUD. But the example given
    elsehwere in the spec says:
    
     TOUD equals 62.5 MB = 03E7FFFFh
     TSEG selected as 512 KB in size,
     Graphics local memory selected as 1 MB in size
     General System RAM available in system = 62.5 MB
     General system RAM range00000000h to 03E7FFFFh
     TSEG address range03F80000h to 03FFFFFFh
     TSEG pre-allocated from03F80000h to 03FFFFFFh
     Graphics local memory pre-allocated from03E80000h to 03F7FFFFh
    
    so here we have TSEG above stolen.
    
    Real world evidence agrees with the TOUD->TSEG->stolen order however, so
    let's fix up the code to account for the TSEG size.
    
    Cc: Taketo Kabe <fdporg@vega.pgw.jp>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: stable@vger.kernel.org
    Fixes: 0ad98c74e093 ("drm/i915: Determine the stolen memory base address on gen2")
    Fixes: a4dff76924fe ("x86/gpu: Add Intel graphics stolen memory quirk for gen2 platforms")
    Reported-by: Taketo Kabe <fdporg@vega.pgw.jp>
    Tested-by: Taketo Kabe <fdporg@vega.pgw.jp>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=96473
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470653919-27251-1-git-send-email-ville.syrjala@linux.intel.com
    Link: http://download.intel.com/design/chipsets/datashts/25251405.pdf
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index de7501edb21c..8b8852bc2f4a 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -317,16 +317,11 @@ static phys_addr_t __init i85x_stolen_base(int num, int slot, int func,
 static phys_addr_t __init i865_stolen_base(int num, int slot, int func,
 					   size_t stolen_size)
 {
-	u16 toud;
+	u16 toud = 0;
 
-	/*
-	 * FIXME is the graphics stolen memory region
-	 * always at TOUD? Ie. is it always the last
-	 * one to be allocated by the BIOS?
-	 */
 	toud = read_pci_config_16(0, 0, 0, I865_TOUD);
 
-	return (phys_addr_t)toud << 16;
+	return (phys_addr_t)(toud << 16) + i845_tseg_size();
 }
 
 static phys_addr_t __init gen3_stolen_base(int num, int slot, int func,

commit 5e580523d9128a4d8364fe89d36c38fc7819c8dd
Merge: c11dea5b0290 523d939ef98f
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 26 17:26:29 2016 +1000

    Backmerge tag 'v4.7' into drm-next
    
    Linux 4.7
    
    As requested by Daniel Vetter as the conflicts were getting messy.

commit abb2bafd295fe962bbadc329dbfb2146457283ac
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Jun 12 12:31:53 2016 +0200

    x86/quirks: Add early quirk to reset Apple AirPort card
    
    The EFI firmware on Macs contains a full-fledged network stack for
    downloading OS X images from osrecovery.apple.com. Unfortunately
    on Macs introduced 2011 and 2012, EFI brings up the Broadcom 4331
    wireless card on every boot and leaves it enabled even after
    ExitBootServices has been called. The card continues to assert its IRQ
    line, causing spurious interrupts if the IRQ is shared. It also corrupts
    memory by DMAing received packets, allowing for remote code execution
    over the air. This only stops when a driver is loaded for the wireless
    card, which may be never if the driver is not installed or blacklisted.
    
    The issue seems to be constrained to the Broadcom 4331. Chris Milsted
    has verified that the newer Broadcom 4360 built into the MacBookPro11,3
    (2013/2014) does not exhibit this behaviour. The chances that Apple will
    ever supply a firmware fix for the older machines appear to be zero.
    
    The solution is to reset the card on boot by writing to a reset bit in
    its mmio space. This must be done as an early quirk and not as a plain
    vanilla PCI quirk to successfully combat memory corruption by DMAed
    packets: Matthew Garrett found out in 2012 that the packets are written
    to EfiBootServicesData memory (http://mjg59.dreamwidth.org/11235.html).
    This type of memory is made available to the page allocator by
    efi_free_boot_services(). Plain vanilla PCI quirks run much later, in
    subsys initcall level. In-between a time window would be open for memory
    corruption. Random crashes occurring in this time window and attributed
    to DMAed packets have indeed been observed in the wild by Chris
    Bainbridge.
    
    When Matthew Garrett analyzed the memory corruption issue in 2012, he
    sought to fix it with a grub quirk which transitions the card to D3hot:
    http://git.savannah.gnu.org/cgit/grub.git/commit/?id=9d34bb85da56
    
    This approach does not help users with other bootloaders and while it
    may prevent DMAed packets, it does not cure the spurious interrupts
    emanating from the card. Unfortunately the card's mmio space is
    inaccessible in D3hot, so to reset it, we have to undo the effect of
    Matthew's grub patch and transition the card back to D0.
    
    Note that the quirk takes a few shortcuts to reduce the amount of code:
    The size of BAR 0 and the location of the PM capability is identical
    on all affected machines and therefore hardcoded. Only the address of
    BAR 0 differs between models. Also, it is assumed that the BCMA core
    currently mapped is the 802.11 core. The EFI driver seems to always take
    care of this.
    
    Michael Büsch, Bjorn Helgaas and Matt Fleming contributed feedback
    towards finding the best solution to this problem.
    
    The following should be a comprehensive list of affected models:
        iMac13,1        2012  21.5"       [Root Port 00:1c.3 = 8086:1e16]
        iMac13,2        2012  27"         [Root Port 00:1c.3 = 8086:1e16]
        Macmini5,1      2011  i5 2.3 GHz  [Root Port 00:1c.1 = 8086:1c12]
        Macmini5,2      2011  i5 2.5 GHz  [Root Port 00:1c.1 = 8086:1c12]
        Macmini5,3      2011  i7 2.0 GHz  [Root Port 00:1c.1 = 8086:1c12]
        Macmini6,1      2012  i5 2.5 GHz  [Root Port 00:1c.1 = 8086:1e12]
        Macmini6,2      2012  i7 2.3 GHz  [Root Port 00:1c.1 = 8086:1e12]
        MacBookPro8,1   2011  13"         [Root Port 00:1c.1 = 8086:1c12]
        MacBookPro8,2   2011  15"         [Root Port 00:1c.1 = 8086:1c12]
        MacBookPro8,3   2011  17"         [Root Port 00:1c.1 = 8086:1c12]
        MacBookPro9,1   2012  15"         [Root Port 00:1c.1 = 8086:1e12]
        MacBookPro9,2   2012  13"         [Root Port 00:1c.1 = 8086:1e12]
        MacBookPro10,1  2012  15"         [Root Port 00:1c.1 = 8086:1e12]
        MacBookPro10,2  2012  13"         [Root Port 00:1c.1 = 8086:1e12]
    
    For posterity, spurious interrupts caused by the Broadcom 4331 wireless
    card resulted in splats like this (stacktrace omitted):
    
        irq 17: nobody cared (try booting with the "irqpoll" option)
        handlers:
        [<ffffffff81374370>] pcie_isr
        [<ffffffffc0704550>] sdhci_irq [sdhci] threaded [<ffffffffc07013c0>] sdhci_thread_irq [sdhci]
        [<ffffffffc0a0b960>] azx_interrupt [snd_hda_codec]
        Disabling IRQ #17
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=79301
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=111781
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=728916
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=895951#c16
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1009819
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1098621
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1149632#c5
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1279130
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1332732
    Tested-by: Konstantin Simanov <k.simanov@stlk.ru>        # [MacBookPro8,1]
    Tested-by: Lukas Wunner <lukas@wunner.de>                # [MacBookPro9,1]
    Tested-by: Bryan Paradis <bryan.paradis@gmail.com>       # [MacBookPro9,2]
    Tested-by: Andrew Worsley <amworsley@gmail.com>          # [MacBookPro10,1]
    Tested-by: Chris Bainbridge <chris.bainbridge@gmail.com> # [MacBookPro10,2]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafał Miłecki <zajec5@gmail.com>
    Acked-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Chris Milsted <cmilsted@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Michael Buesch <m@bues.ch>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: b43-dev@lists.infradead.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: stable@vger.kernel.org
    Cc: stable@vger.kernel.org # 123456789abc: x86/quirks: Apply nvidia_bugs quirk only on root bus
    Cc: stable@vger.kernel.org # 123456789abc: x86/quirks: Reintroduce scanning of secondary buses
    Link: http://lkml.kernel.org/r/48d0972ac82a53d460e5fce77a07b2560db95203.1465690253.git.lukas@wunner.de
    [ Did minor readability edits. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index ea60c05c2487..57b71373bae3 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -11,7 +11,11 @@
 
 #include <linux/pci.h>
 #include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/pci_ids.h>
+#include <linux/bcma/bcma.h>
+#include <linux/bcma/bcma_regs.h>
 #include <drm/i915_drm.h>
 #include <asm/pci-direct.h>
 #include <asm/dma.h>
@@ -21,6 +25,9 @@
 #include <asm/iommu.h>
 #include <asm/gart.h>
 #include <asm/irq_remapping.h>
+#include <asm/early_ioremap.h>
+
+#define dev_err(msg)  pr_err("pci 0000:%02x:%02x.%d: %s", bus, slot, func, msg)
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
@@ -597,6 +604,61 @@ static void __init force_disable_hpet(int num, int slot, int func)
 #endif
 }
 
+#define BCM4331_MMIO_SIZE	16384
+#define BCM4331_PM_CAP		0x40
+#define bcma_aread32(reg)	ioread32(mmio + 1 * BCMA_CORE_SIZE + reg)
+#define bcma_awrite32(reg, val)	iowrite32(val, mmio + 1 * BCMA_CORE_SIZE + reg)
+
+static void __init apple_airport_reset(int bus, int slot, int func)
+{
+	void __iomem *mmio;
+	u16 pmcsr;
+	u64 addr;
+	int i;
+
+	if (!dmi_match(DMI_SYS_VENDOR, "Apple Inc."))
+		return;
+
+	/* Card may have been put into PCI_D3hot by grub quirk */
+	pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);
+
+	if ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0) {
+		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
+		write_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL, pmcsr);
+		mdelay(10);
+
+		pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);
+		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0) {
+			dev_err("Cannot power up Apple AirPort card\n");
+			return;
+		}
+	}
+
+	addr  =      read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);
+	addr |= (u64)read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_1) << 32;
+	addr &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	mmio = early_ioremap(addr, BCM4331_MMIO_SIZE);
+	if (!mmio) {
+		dev_err("Cannot iomap Apple AirPort card\n");
+		return;
+	}
+
+	pr_info("Resetting Apple AirPort card (left enabled by EFI)\n");
+
+	for (i = 0; bcma_aread32(BCMA_RESET_ST) && i < 30; i++)
+		udelay(10);
+
+	bcma_awrite32(BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
+	bcma_aread32(BCMA_RESET_CTL);
+	udelay(1);
+
+	bcma_awrite32(BCMA_RESET_CTL, 0);
+	bcma_aread32(BCMA_RESET_CTL);
+	udelay(10);
+
+	early_iounmap(mmio, BCM4331_MMIO_SIZE);
+}
 
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
@@ -639,6 +701,8 @@ static struct chipset early_qrk[] __initdata = {
 	 */
 	{ PCI_VENDOR_ID_INTEL, 0x0f00,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
+	{ PCI_VENDOR_ID_BROADCOM, 0x4331,
+	  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},
 	{}
 };
 

commit 850c321027c2e31d0afc71588974719a4b565550
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Jun 12 12:31:53 2016 +0200

    x86/quirks: Reintroduce scanning of secondary buses
    
    We used to scan secondary buses until the following commit that
    was applied in 2009:
    
      8659c406ade3 ("x86: only scan the root bus in early PCI quirks")
    
    which commit constrained early quirks to the root bus only. Its
    motivation was to prevent application of the nvidia_bugs quirk
    on secondary buses.
    
    We're about to add a quirk to reset the Broadcom 4331 wireless card on
    2011/2012 Macs, which is located on a secondary bus behind a PCIe root
    port. To facilitate that, reintroduce scanning of secondary buses.
    
    The commit message of 8659c406ade3 notes that scanning only the root bus
    "saves quite some unnecessary scanning work". The algorithm used prior
    to 8659c406ade3 was particularly time consuming because it scanned
    buses 0 to 31 brute force. To avoid lengthening boot time, employ a
    recursive strategy which only scans buses that are actually reachable
    from the root bus.
    
    Yinghai Lu pointed out that the secondary bus number read from a
    bridge's config space may be invalid, in particular a value of 0 would
    cause an infinite loop. The PCI core goes beyond that and recurses to a
    child bus only if its bus number is greater than the parent bus number
    (see pci_scan_bridge()). Since the root bus is numbered 0, this implies
    that secondary buses may not be 0. Do the same on early scanning.
    
    If this algorithm is found to significantly impact boot time or cause
    infinite loops on broken hardware, it would be possible to limit its
    recursion depth: The Broadcom 4331 quirk applies at depth 1, all others
    at depth 0, so the bus need not be scanned deeper than that for now. An
    alternative approach would be to revert to scanning only the root bus,
    and apply the Broadcom 4331 quirk to the root ports 8086:1c12, 8086:1e12
    and 8086:1e16. Apple always positioned the card behind either of these
    three ports. The quirk would then check presence of the card in slot 0
    below the root port and do its deed.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/f0daa70dac1a9b2483abdb31887173eb6ab77bdf.1465690253.git.lukas@wunner.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 256976fe2666..ea60c05c2487 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -610,12 +610,6 @@ struct chipset {
 	void (*f)(int num, int slot, int func);
 };
 
-/*
- * Only works for devices on the root bus. If you add any devices
- * not on bus 0 readd another loop level in early_quirks(). But
- * be careful because at least the Nvidia quirk here relies on
- * only matching on bus 0.
- */
 static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
@@ -648,6 +642,8 @@ static struct chipset early_qrk[] __initdata = {
 	{}
 };
 
+static void __init early_pci_scan_bus(int bus);
+
 /**
  * check_dev_quirk - apply early quirks to a given PCI device
  * @num: bus number
@@ -656,7 +652,7 @@ static struct chipset early_qrk[] __initdata = {
  *
  * Check the vendor & device ID against the early quirks table.
  *
- * If the device is single function, let early_quirks() know so we don't
+ * If the device is single function, let early_pci_scan_bus() know so we don't
  * poke at this device again.
  */
 static int __init check_dev_quirk(int num, int slot, int func)
@@ -665,6 +661,7 @@ static int __init check_dev_quirk(int num, int slot, int func)
 	u16 vendor;
 	u16 device;
 	u8 type;
+	u8 sec;
 	int i;
 
 	class = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);
@@ -692,25 +689,36 @@ static int __init check_dev_quirk(int num, int slot, int func)
 
 	type = read_pci_config_byte(num, slot, func,
 				    PCI_HEADER_TYPE);
+
+	if ((type & 0x7f) == PCI_HEADER_TYPE_BRIDGE) {
+		sec = read_pci_config_byte(num, slot, func, PCI_SECONDARY_BUS);
+		if (sec > num)
+			early_pci_scan_bus(sec);
+	}
+
 	if (!(type & 0x80))
 		return -1;
 
 	return 0;
 }
 
-void __init early_quirks(void)
+static void __init early_pci_scan_bus(int bus)
 {
 	int slot, func;
 
-	if (!early_pci_allowed())
-		return;
-
 	/* Poor man's PCI discovery */
-	/* Only scan the root bus */
 	for (slot = 0; slot < 32; slot++)
 		for (func = 0; func < 8; func++) {
 			/* Only probe function 0 on single fn devices */
-			if (check_dev_quirk(0, slot, func))
+			if (check_dev_quirk(bus, slot, func))
 				break;
 		}
 }
+
+void __init early_quirks(void)
+{
+	if (!early_pci_allowed())
+		return;
+
+	early_pci_scan_bus(0);
+}

commit 447d29d1d3aed839e74c2401ef63387780ac51ed
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Jun 12 12:31:53 2016 +0200

    x86/quirks: Apply nvidia_bugs quirk only on root bus
    
    Since the following commit:
    
      8659c406ade3 ("x86: only scan the root bus in early PCI quirks")
    
    ... early quirks are only applied to devices on the root bus.
    
    The motivation was to prevent application of the nvidia_bugs quirk on
    secondary buses.
    
    We're about to reintroduce scanning of secondary buses for a quirk to
    reset the Broadcom 4331 wireless card on 2011/2012 Macs. To prevent
    regressions, open code the requirement to apply nvidia_bugs only on the
    root bus.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/4d5477c1d76b2f0387a780f2142bbcdd9fee869b.1465690253.git.lukas@wunner.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bca14c899137..256976fe2666 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -75,6 +75,13 @@ static void __init nvidia_bugs(int num, int slot, int func)
 {
 #ifdef CONFIG_ACPI
 #ifdef CONFIG_X86_IO_APIC
+	/*
+	 * Only applies to Nvidia root ports (bus 0) and not to
+	 * Nvidia graphics cards with PCI ports on secondary buses.
+	 */
+	if (num)
+		return;
+
 	/*
 	 * All timer overrides on Nvidia are
 	 * wrong unless HPET is enabled.

commit 01e5d3b42e2047dd6bc80e722d9f84b654c7dcfb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon May 9 17:39:42 2016 +0100

    x86: Silence 32bit compiler warning in intel_graphics_stolen()
    
    arch/x86/kernel/early-quirks.c: In function ‘intel_graphics_stolen’:
    arch/x86/kernel/early-quirks.c:539:9: warning: format ‘%llx’ expects
    argument of type ‘long long unsigned int’, but argument 2 has type ‘phys_addr_t’ [-Wformat=]
             "0x%llx-0x%llx\n", base, base + size - 1);
             ^
    arch/x86/kernel/early-quirks.c:539:9: warning: format ‘%llx’ expects
    argument of type ‘long long unsigned int’, but argument 3 has type ‘phys_addr_t’ [-Wformat=]
    
    v2: Use %pa for addresses
    
    Fixes: ee0629cfd3c16 (drm/i915: Function per early graphics quirk)
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> #v1
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462811982-1567-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index d2f75b49236c..757390eb562b 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -526,7 +526,7 @@ static void __init
 intel_graphics_stolen(int num, int slot, int func,
 		      const struct intel_early_ops *early_ops)
 {
-	phys_addr_t base;
+	phys_addr_t base, end;
 	size_t size;
 
 	size = early_ops->stolen_size(num, slot, func);
@@ -535,8 +535,9 @@ intel_graphics_stolen(int num, int slot, int func,
 	if (!size || !base)
 		return;
 
-	printk(KERN_INFO "Reserving Intel graphics stolen memory at "
-	       "0x%llx-0x%llx\n", base, base + size - 1);
+	end = base + size - 1;
+	printk(KERN_INFO "Reserving Intel graphics memory at %pa-%pa\n",
+	       &base, &end);
 
 	/* Mark this space as reserved */
 	e820_add_region(base, size, E820_RESERVED);

commit ee0629cfd3c16c716801c84e939ff5db5e23f54d
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Apr 22 13:45:49 2016 +0300

    drm/i915: Function per early graphics quirk
    
    Move graphics stolen memory related early quirk into a function to
    allow easy adding of other graphics quirks to fix memory maps on
    machines running old BIOS versions.
    
    While at it;
    - _funcs -> _ops to follow de facto naming
    - make the iteration code tad more readable
    - remove unused variables
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Acked-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 70e0ab66df2f..d2f75b49236c 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -423,11 +423,6 @@ static size_t __init chv_stolen_size(int num, int slot, int func)
 		return (size_t)(gms - 0x17 + 9) * MB(4);
 }
 
-struct intel_stolen_funcs {
-	size_t (*size)(int num, int slot, int func);
-	phys_addr_t (*base)(int num, int slot, int func, size_t size);
-};
-
 static size_t __init gen9_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
@@ -444,115 +439,129 @@ static size_t __init gen9_stolen_size(int num, int slot, int func)
 		return (size_t)(gms - 0xf0 + 1) * MB(4);
 }
 
-typedef size_t (*stolen_size_fn)(int num, int slot, int func);
+struct intel_early_ops {
+	size_t (*stolen_size)(int num, int slot, int func);
+	phys_addr_t (*stolen_base)(int num, int slot, int func, size_t size);
+};
 
-static const struct intel_stolen_funcs i830_stolen_funcs __initconst = {
-	.base = i830_stolen_base,
-	.size = i830_stolen_size,
+static const struct intel_early_ops i830_early_ops __initconst = {
+	.stolen_base = i830_stolen_base,
+	.stolen_size = i830_stolen_size,
 };
 
-static const struct intel_stolen_funcs i845_stolen_funcs __initconst = {
-	.base = i845_stolen_base,
-	.size = i830_stolen_size,
+static const struct intel_early_ops i845_early_ops __initconst = {
+	.stolen_base = i845_stolen_base,
+	.stolen_size = i830_stolen_size,
 };
 
-static const struct intel_stolen_funcs i85x_stolen_funcs __initconst = {
-	.base = i85x_stolen_base,
-	.size = gen3_stolen_size,
+static const struct intel_early_ops i85x_early_ops __initconst = {
+	.stolen_base = i85x_stolen_base,
+	.stolen_size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs i865_stolen_funcs __initconst = {
-	.base = i865_stolen_base,
-	.size = gen3_stolen_size,
+static const struct intel_early_ops i865_early_ops __initconst = {
+	.stolen_base = i865_stolen_base,
+	.stolen_size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen3_stolen_funcs __initconst = {
-	.base = gen3_stolen_base,
-	.size = gen3_stolen_size,
+static const struct intel_early_ops gen3_early_ops __initconst = {
+	.stolen_base = gen3_stolen_base,
+	.stolen_size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen6_stolen_funcs __initconst = {
-	.base = gen3_stolen_base,
-	.size = gen6_stolen_size,
+static const struct intel_early_ops gen6_early_ops __initconst = {
+	.stolen_base = gen3_stolen_base,
+	.stolen_size = gen6_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen8_stolen_funcs __initconst = {
-	.base = gen3_stolen_base,
-	.size = gen8_stolen_size,
+static const struct intel_early_ops gen8_early_ops __initconst = {
+	.stolen_base = gen3_stolen_base,
+	.stolen_size = gen8_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen9_stolen_funcs __initconst = {
-	.base = gen3_stolen_base,
-	.size = gen9_stolen_size,
+static const struct intel_early_ops gen9_early_ops __initconst = {
+	.stolen_base = gen3_stolen_base,
+	.stolen_size = gen9_stolen_size,
 };
 
-static const struct intel_stolen_funcs chv_stolen_funcs __initconst = {
-	.base = gen3_stolen_base,
-	.size = chv_stolen_size,
+static const struct intel_early_ops chv_early_ops __initconst = {
+	.stolen_base = gen3_stolen_base,
+	.stolen_size = chv_stolen_size,
 };
 
-static const struct pci_device_id intel_stolen_ids[] __initconst = {
-	INTEL_I830_IDS(&i830_stolen_funcs),
-	INTEL_I845G_IDS(&i845_stolen_funcs),
-	INTEL_I85X_IDS(&i85x_stolen_funcs),
-	INTEL_I865G_IDS(&i865_stolen_funcs),
-	INTEL_I915G_IDS(&gen3_stolen_funcs),
-	INTEL_I915GM_IDS(&gen3_stolen_funcs),
-	INTEL_I945G_IDS(&gen3_stolen_funcs),
-	INTEL_I945GM_IDS(&gen3_stolen_funcs),
-	INTEL_VLV_M_IDS(&gen6_stolen_funcs),
-	INTEL_VLV_D_IDS(&gen6_stolen_funcs),
-	INTEL_PINEVIEW_IDS(&gen3_stolen_funcs),
-	INTEL_I965G_IDS(&gen3_stolen_funcs),
-	INTEL_G33_IDS(&gen3_stolen_funcs),
-	INTEL_I965GM_IDS(&gen3_stolen_funcs),
-	INTEL_GM45_IDS(&gen3_stolen_funcs),
-	INTEL_G45_IDS(&gen3_stolen_funcs),
-	INTEL_IRONLAKE_D_IDS(&gen3_stolen_funcs),
-	INTEL_IRONLAKE_M_IDS(&gen3_stolen_funcs),
-	INTEL_SNB_D_IDS(&gen6_stolen_funcs),
-	INTEL_SNB_M_IDS(&gen6_stolen_funcs),
-	INTEL_IVB_M_IDS(&gen6_stolen_funcs),
-	INTEL_IVB_D_IDS(&gen6_stolen_funcs),
-	INTEL_HSW_D_IDS(&gen6_stolen_funcs),
-	INTEL_HSW_M_IDS(&gen6_stolen_funcs),
-	INTEL_BDW_M_IDS(&gen8_stolen_funcs),
-	INTEL_BDW_D_IDS(&gen8_stolen_funcs),
-	INTEL_CHV_IDS(&chv_stolen_funcs),
-	INTEL_SKL_IDS(&gen9_stolen_funcs),
-	INTEL_BXT_IDS(&gen9_stolen_funcs),
-	INTEL_KBL_IDS(&gen9_stolen_funcs),
+static const struct pci_device_id intel_early_ids[] __initconst = {
+	INTEL_I830_IDS(&i830_early_ops),
+	INTEL_I845G_IDS(&i845_early_ops),
+	INTEL_I85X_IDS(&i85x_early_ops),
+	INTEL_I865G_IDS(&i865_early_ops),
+	INTEL_I915G_IDS(&gen3_early_ops),
+	INTEL_I915GM_IDS(&gen3_early_ops),
+	INTEL_I945G_IDS(&gen3_early_ops),
+	INTEL_I945GM_IDS(&gen3_early_ops),
+	INTEL_VLV_M_IDS(&gen6_early_ops),
+	INTEL_VLV_D_IDS(&gen6_early_ops),
+	INTEL_PINEVIEW_IDS(&gen3_early_ops),
+	INTEL_I965G_IDS(&gen3_early_ops),
+	INTEL_G33_IDS(&gen3_early_ops),
+	INTEL_I965GM_IDS(&gen3_early_ops),
+	INTEL_GM45_IDS(&gen3_early_ops),
+	INTEL_G45_IDS(&gen3_early_ops),
+	INTEL_IRONLAKE_D_IDS(&gen3_early_ops),
+	INTEL_IRONLAKE_M_IDS(&gen3_early_ops),
+	INTEL_SNB_D_IDS(&gen6_early_ops),
+	INTEL_SNB_M_IDS(&gen6_early_ops),
+	INTEL_IVB_M_IDS(&gen6_early_ops),
+	INTEL_IVB_D_IDS(&gen6_early_ops),
+	INTEL_HSW_D_IDS(&gen6_early_ops),
+	INTEL_HSW_M_IDS(&gen6_early_ops),
+	INTEL_BDW_M_IDS(&gen8_early_ops),
+	INTEL_BDW_D_IDS(&gen8_early_ops),
+	INTEL_CHV_IDS(&chv_early_ops),
+	INTEL_SKL_IDS(&gen9_early_ops),
+	INTEL_BXT_IDS(&gen9_early_ops),
+	INTEL_KBL_IDS(&gen9_early_ops),
 };
 
-static void __init intel_graphics_stolen(int num, int slot, int func)
+static void __init
+intel_graphics_stolen(int num, int slot, int func,
+		      const struct intel_early_ops *early_ops)
 {
+	phys_addr_t base;
 	size_t size;
+
+	size = early_ops->stolen_size(num, slot, func);
+	base = early_ops->stolen_base(num, slot, func, size);
+
+	if (!size || !base)
+		return;
+
+	printk(KERN_INFO "Reserving Intel graphics stolen memory at "
+	       "0x%llx-0x%llx\n", base, base + size - 1);
+
+	/* Mark this space as reserved */
+	e820_add_region(base, size, E820_RESERVED);
+	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
+}
+
+static void __init intel_graphics_quirks(int num, int slot, int func)
+{
+	const struct intel_early_ops *early_ops;
+	u16 device;
 	int i;
-	phys_addr_t start;
-	u16 device, subvendor, subdevice;
 
 	device = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);
-	subvendor = read_pci_config_16(num, slot, func,
-				       PCI_SUBSYSTEM_VENDOR_ID);
-	subdevice = read_pci_config_16(num, slot, func, PCI_SUBSYSTEM_ID);
-
-	for (i = 0; i < ARRAY_SIZE(intel_stolen_ids); i++) {
-		if (intel_stolen_ids[i].device == device) {
-			const struct intel_stolen_funcs *stolen_funcs =
-				(const struct intel_stolen_funcs *)intel_stolen_ids[i].driver_data;
-			size = stolen_funcs->size(num, slot, func);
-			start = stolen_funcs->base(num, slot, func, size);
-			if (size && start) {
-				printk(KERN_INFO "Reserving Intel graphics stolen memory at 0x%llx-0x%llx\n",
-				       start, start + size - 1);
-				/* Mark this space as reserved */
-				e820_add_region(start, size, E820_RESERVED);
-				sanitize_e820_map(e820.map,
-						  ARRAY_SIZE(e820.map),
-						  &e820.nr_map);
-			}
-			return;
-		}
+
+	for (i = 0; i < ARRAY_SIZE(intel_early_ids); i++) {
+		kernel_ulong_t driver_data = intel_early_ids[i].driver_data;
+
+		if (intel_early_ids[i].device != device)
+			continue;
+
+		early_ops = (typeof(early_ops))driver_data;
+
+		intel_graphics_stolen(num, slot, func, early_ops);
+
+		return;
 	}
 }
 
@@ -601,7 +610,7 @@ static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_INTEL, 0x3406, PCI_CLASS_BRIDGE_HOST,
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA, PCI_ANY_ID,
-	  QFLAG_APPLY_ONCE, intel_graphics_stolen },
+	  QFLAG_APPLY_ONCE, intel_graphics_quirks },
 	/*
 	 * HPET on the current version of the Baytrail platform has accuracy
 	 * problems: it will halt in deep idle state - so we disable it.

commit c0dd3460b28626430b83b9bf80af4c5a2bd4a53b
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Apr 22 13:29:26 2016 +0300

    drm/i915: Canonicalize stolen memory calculations
    
    Move the better constructs/comments from i915_gem_stolen.c to
    early-quirks.c and increase readability in preparation of only
    having one set of functions.
    
    - intel_stolen_base -> gen3_stolen_base
    - use phys_addr_t instead of u32 for address for future proofing
    
    v2:
    - Print the invalid register values (Chris)
      (Omitting the register prefix as it's visible from backtrace.)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Acked-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bca14c899137..70e0ab66df2f 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -223,36 +223,19 @@ static void __init intel_remapping_check(int num, int slot, int func)
  * despite the efforts of the "RAM buffer" approach, which simply rounds
  * memory boundaries up to 64M to try to catch space that may decode
  * as RAM and so is not suitable for MMIO.
- *
- * And yes, so far on current devices the base addr is always under 4G.
  */
-static u32 __init intel_stolen_base(int num, int slot, int func, size_t stolen_size)
-{
-	u32 base;
-
-	/*
-	 * For the PCI IDs in this quirk, the stolen base is always
-	 * in 0x5c, aka the BDSM register (yes that's really what
-	 * it's called).
-	 */
-	base = read_pci_config(num, slot, func, 0x5c);
-	base &= ~((1<<20) - 1);
-
-	return base;
-}
 
 #define KB(x)	((x) * 1024UL)
 #define MB(x)	(KB (KB (x)))
-#define GB(x)	(MB (KB (x)))
 
 static size_t __init i830_tseg_size(void)
 {
-	u8 tmp = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);
+	u8 esmramc = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);
 
-	if (!(tmp & TSEG_ENABLE))
+	if (!(esmramc & TSEG_ENABLE))
 		return 0;
 
-	if (tmp & I830_TSEG_SIZE_1M)
+	if (esmramc & I830_TSEG_SIZE_1M)
 		return MB(1);
 	else
 		return KB(512);
@@ -260,27 +243,26 @@ static size_t __init i830_tseg_size(void)
 
 static size_t __init i845_tseg_size(void)
 {
-	u8 tmp = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);
+	u8 esmramc = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);
+	u8 tseg_size = esmramc & I845_TSEG_SIZE_MASK;
 
-	if (!(tmp & TSEG_ENABLE))
+	if (!(esmramc & TSEG_ENABLE))
 		return 0;
 
-	switch (tmp & I845_TSEG_SIZE_MASK) {
-	case I845_TSEG_SIZE_512K:
-		return KB(512);
-	case I845_TSEG_SIZE_1M:
-		return MB(1);
+	switch (tseg_size) {
+	case I845_TSEG_SIZE_512K:	return KB(512);
+	case I845_TSEG_SIZE_1M:		return MB(1);
 	default:
-		WARN_ON(1);
-		return 0;
+		WARN(1, "Unknown ESMRAMC value: %x!\n", esmramc);
 	}
+	return 0;
 }
 
 static size_t __init i85x_tseg_size(void)
 {
-	u8 tmp = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);
+	u8 esmramc = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);
 
-	if (!(tmp & TSEG_ENABLE))
+	if (!(esmramc & TSEG_ENABLE))
 		return 0;
 
 	return MB(1);
@@ -300,174 +282,166 @@ static size_t __init i85x_mem_size(void)
  * On 830/845/85x the stolen memory base isn't available in any
  * register. We need to calculate it as TOM-TSEG_SIZE-stolen_size.
  */
-static u32 __init i830_stolen_base(int num, int slot, int func, size_t stolen_size)
+static phys_addr_t __init i830_stolen_base(int num, int slot, int func,
+					   size_t stolen_size)
 {
-	return i830_mem_size() - i830_tseg_size() - stolen_size;
+	return (phys_addr_t)i830_mem_size() - i830_tseg_size() - stolen_size;
 }
 
-static u32 __init i845_stolen_base(int num, int slot, int func, size_t stolen_size)
+static phys_addr_t __init i845_stolen_base(int num, int slot, int func,
+					   size_t stolen_size)
 {
-	return i830_mem_size() - i845_tseg_size() - stolen_size;
+	return (phys_addr_t)i830_mem_size() - i845_tseg_size() - stolen_size;
 }
 
-static u32 __init i85x_stolen_base(int num, int slot, int func, size_t stolen_size)
+static phys_addr_t __init i85x_stolen_base(int num, int slot, int func,
+					   size_t stolen_size)
 {
-	return i85x_mem_size() - i85x_tseg_size() - stolen_size;
+	return (phys_addr_t)i85x_mem_size() - i85x_tseg_size() - stolen_size;
 }
 
-static u32 __init i865_stolen_base(int num, int slot, int func, size_t stolen_size)
+static phys_addr_t __init i865_stolen_base(int num, int slot, int func,
+					   size_t stolen_size)
 {
+	u16 toud;
+
 	/*
 	 * FIXME is the graphics stolen memory region
 	 * always at TOUD? Ie. is it always the last
 	 * one to be allocated by the BIOS?
 	 */
-	return read_pci_config_16(0, 0, 0, I865_TOUD) << 16;
+	toud = read_pci_config_16(0, 0, 0, I865_TOUD);
+
+	return (phys_addr_t)toud << 16;
+}
+
+static phys_addr_t __init gen3_stolen_base(int num, int slot, int func,
+					   size_t stolen_size)
+{
+	u32 bsm;
+
+	/* Almost universally we can find the Graphics Base of Stolen Memory
+	 * at register BSM (0x5c) in the igfx configuration space. On a few
+	 * (desktop) machines this is also mirrored in the bridge device at
+	 * different locations, or in the MCHBAR.
+	 */
+	bsm = read_pci_config(num, slot, func, INTEL_BSM);
+
+	return (phys_addr_t)bsm & INTEL_BSM_MASK;
 }
 
 static size_t __init i830_stolen_size(int num, int slot, int func)
 {
-	size_t stolen_size;
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);
-
-	switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
-	case I830_GMCH_GMS_STOLEN_512:
-		stolen_size = KB(512);
-		break;
-	case I830_GMCH_GMS_STOLEN_1024:
-		stolen_size = MB(1);
-		break;
-	case I830_GMCH_GMS_STOLEN_8192:
-		stolen_size = MB(8);
-		break;
-	case I830_GMCH_GMS_LOCAL:
-		/* local memory isn't part of the normal address space */
-		stolen_size = 0;
-		break;
+	gms = gmch_ctrl & I830_GMCH_GMS_MASK;
+
+	switch (gms) {
+	case I830_GMCH_GMS_STOLEN_512:	return KB(512);
+	case I830_GMCH_GMS_STOLEN_1024:	return MB(1);
+	case I830_GMCH_GMS_STOLEN_8192:	return MB(8);
+	/* local memory isn't part of the normal address space */
+	case I830_GMCH_GMS_LOCAL:	return 0;
 	default:
-		return 0;
+		WARN(1, "Unknown GMCH_CTRL value: %x!\n", gmch_ctrl);
 	}
 
-	return stolen_size;
+	return 0;
 }
 
 static size_t __init gen3_stolen_size(int num, int slot, int func)
 {
-	size_t stolen_size;
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);
-
-	switch (gmch_ctrl & I855_GMCH_GMS_MASK) {
-	case I855_GMCH_GMS_STOLEN_1M:
-		stolen_size = MB(1);
-		break;
-	case I855_GMCH_GMS_STOLEN_4M:
-		stolen_size = MB(4);
-		break;
-	case I855_GMCH_GMS_STOLEN_8M:
-		stolen_size = MB(8);
-		break;
-	case I855_GMCH_GMS_STOLEN_16M:
-		stolen_size = MB(16);
-		break;
-	case I855_GMCH_GMS_STOLEN_32M:
-		stolen_size = MB(32);
-		break;
-	case I915_GMCH_GMS_STOLEN_48M:
-		stolen_size = MB(48);
-		break;
-	case I915_GMCH_GMS_STOLEN_64M:
-		stolen_size = MB(64);
-		break;
-	case G33_GMCH_GMS_STOLEN_128M:
-		stolen_size = MB(128);
-		break;
-	case G33_GMCH_GMS_STOLEN_256M:
-		stolen_size = MB(256);
-		break;
-	case INTEL_GMCH_GMS_STOLEN_96M:
-		stolen_size = MB(96);
-		break;
-	case INTEL_GMCH_GMS_STOLEN_160M:
-		stolen_size = MB(160);
-		break;
-	case INTEL_GMCH_GMS_STOLEN_224M:
-		stolen_size = MB(224);
-		break;
-	case INTEL_GMCH_GMS_STOLEN_352M:
-		stolen_size = MB(352);
-		break;
+	gms = gmch_ctrl & I855_GMCH_GMS_MASK;
+
+	switch (gms) {
+	case I855_GMCH_GMS_STOLEN_1M:	return MB(1);
+	case I855_GMCH_GMS_STOLEN_4M:	return MB(4);
+	case I855_GMCH_GMS_STOLEN_8M:	return MB(8);
+	case I855_GMCH_GMS_STOLEN_16M:	return MB(16);
+	case I855_GMCH_GMS_STOLEN_32M:	return MB(32);
+	case I915_GMCH_GMS_STOLEN_48M:	return MB(48);
+	case I915_GMCH_GMS_STOLEN_64M:	return MB(64);
+	case G33_GMCH_GMS_STOLEN_128M:	return MB(128);
+	case G33_GMCH_GMS_STOLEN_256M:	return MB(256);
+	case INTEL_GMCH_GMS_STOLEN_96M:	return MB(96);
+	case INTEL_GMCH_GMS_STOLEN_160M:return MB(160);
+	case INTEL_GMCH_GMS_STOLEN_224M:return MB(224);
+	case INTEL_GMCH_GMS_STOLEN_352M:return MB(352);
 	default:
-		stolen_size = 0;
-		break;
+		WARN(1, "Unknown GMCH_CTRL value: %x!\n", gmch_ctrl);
 	}
 
-	return stolen_size;
+	return 0;
 }
 
 static size_t __init gen6_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
-	gmch_ctrl >>= SNB_GMCH_GMS_SHIFT;
-	gmch_ctrl &= SNB_GMCH_GMS_MASK;
+	gms = (gmch_ctrl >> SNB_GMCH_GMS_SHIFT) & SNB_GMCH_GMS_MASK;
 
-	return gmch_ctrl << 25; /* 32 MB units */
+	return (size_t)gms * MB(32);
 }
 
 static size_t __init gen8_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
-	gmch_ctrl >>= BDW_GMCH_GMS_SHIFT;
-	gmch_ctrl &= BDW_GMCH_GMS_MASK;
-	return gmch_ctrl << 25; /* 32 MB units */
+	gms = (gmch_ctrl >> BDW_GMCH_GMS_SHIFT) & BDW_GMCH_GMS_MASK;
+
+	return (size_t)gms * MB(32);
 }
 
 static size_t __init chv_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
-	gmch_ctrl >>= SNB_GMCH_GMS_SHIFT;
-	gmch_ctrl &= SNB_GMCH_GMS_MASK;
+	gms = (gmch_ctrl >> SNB_GMCH_GMS_SHIFT) & SNB_GMCH_GMS_MASK;
 
 	/*
 	 * 0x0  to 0x10: 32MB increments starting at 0MB
 	 * 0x11 to 0x16: 4MB increments starting at 8MB
 	 * 0x17 to 0x1d: 4MB increments start at 36MB
 	 */
-	if (gmch_ctrl < 0x11)
-		return gmch_ctrl << 25;
-	else if (gmch_ctrl < 0x17)
-		return (gmch_ctrl - 0x11 + 2) << 22;
+	if (gms < 0x11)
+		return (size_t)gms * MB(32);
+	else if (gms < 0x17)
+		return (size_t)(gms - 0x11 + 2) * MB(4);
 	else
-		return (gmch_ctrl - 0x17 + 9) << 22;
+		return (size_t)(gms - 0x17 + 9) * MB(4);
 }
 
 struct intel_stolen_funcs {
 	size_t (*size)(int num, int slot, int func);
-	u32 (*base)(int num, int slot, int func, size_t size);
+	phys_addr_t (*base)(int num, int slot, int func, size_t size);
 };
 
 static size_t __init gen9_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
+	u16 gms;
 
 	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
-	gmch_ctrl >>= BDW_GMCH_GMS_SHIFT;
-	gmch_ctrl &= BDW_GMCH_GMS_MASK;
+	gms = (gmch_ctrl >> BDW_GMCH_GMS_SHIFT) & BDW_GMCH_GMS_MASK;
 
-	if (gmch_ctrl < 0xf0)
-		return gmch_ctrl << 25; /* 32 MB units */
+	/* 0x0  to 0xef: 32MB increments starting at 0MB */
+	/* 0xf0 to 0xfe: 4MB increments starting at 4MB */
+	if (gms < 0xf0)
+		return (size_t)gms * MB(32);
 	else
-		/* 4MB increments starting at 0xf0 for 4MB */
-		return (gmch_ctrl - 0xf0 + 1) << 22;
+		return (size_t)(gms - 0xf0 + 1) * MB(4);
 }
 
 typedef size_t (*stolen_size_fn)(int num, int slot, int func);
@@ -493,27 +467,27 @@ static const struct intel_stolen_funcs i865_stolen_funcs __initconst = {
 };
 
 static const struct intel_stolen_funcs gen3_stolen_funcs __initconst = {
-	.base = intel_stolen_base,
+	.base = gen3_stolen_base,
 	.size = gen3_stolen_size,
 };
 
 static const struct intel_stolen_funcs gen6_stolen_funcs __initconst = {
-	.base = intel_stolen_base,
+	.base = gen3_stolen_base,
 	.size = gen6_stolen_size,
 };
 
 static const struct intel_stolen_funcs gen8_stolen_funcs __initconst = {
-	.base = intel_stolen_base,
+	.base = gen3_stolen_base,
 	.size = gen8_stolen_size,
 };
 
 static const struct intel_stolen_funcs gen9_stolen_funcs __initconst = {
-	.base = intel_stolen_base,
+	.base = gen3_stolen_base,
 	.size = gen9_stolen_size,
 };
 
 static const struct intel_stolen_funcs chv_stolen_funcs __initconst = {
-	.base = intel_stolen_base,
+	.base = gen3_stolen_base,
 	.size = chv_stolen_size,
 };
 
@@ -554,7 +528,7 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 {
 	size_t size;
 	int i;
-	u32 start;
+	phys_addr_t start;
 	u16 device, subvendor, subdevice;
 
 	device = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);
@@ -569,8 +543,8 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 			size = stolen_funcs->size(num, slot, func);
 			start = stolen_funcs->base(num, slot, func, size);
 			if (size && start) {
-				printk(KERN_INFO "Reserving Intel graphics stolen memory at 0x%x-0x%x\n",
-				       start, start + (u32)size - 1);
+				printk(KERN_INFO "Reserving Intel graphics stolen memory at 0x%llx-0x%llx\n",
+				       start, start + size - 1);
 				/* Mark this space as reserved */
 				e820_add_region(start, size, E820_RESERVED);
 				sanitize_e820_map(e820.map,

commit 92907cbbef8625bb3998d1eb385fc88f23c97a3f
Merge: 15fbfccfe92c 1ec218373b8e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 23 09:04:05 2015 +0100

    Merge tag 'v4.4-rc2' into drm-intel-next-queued
    
    Linux 4.4-rc2
    
    Backmerge to get at
    
    commit 1b0e3a049efe471c399674fd954500ce97438d30
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Thu Nov 5 23:04:11 2015 +0200
    
        drm/i915/skl: disable display side power well support for now
    
    so that we can proplery re-eanble skl power wells in -next.
    
    Conflicts are just adjacent lines changed, except for intel_fbdev.c
    where we need to interleave the changs. Nothing nefarious.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 00ce5c8a66fb2241d4fed9645b12a1cbce97b798
Author: Deepak S <deepak.s@intel.com>
Date:   Thu Oct 29 10:22:01 2015 -0700

    drm/i915/kbl: Kabylake uses the same GMS values as Skylake
    
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Deepak S <deepak.s@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446139321-2818-2-git-send-email-rodrigo.vivi@intel.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 9f9cc682e561..5b85bf0e23fe 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -547,6 +547,7 @@ static const struct pci_device_id intel_stolen_ids[] __initconst = {
 	INTEL_CHV_IDS(&chv_stolen_funcs),
 	INTEL_SKL_IDS(&gen9_stolen_funcs),
 	INTEL_BXT_IDS(&gen9_stolen_funcs),
+	INTEL_KBL_IDS(&gen9_stolen_funcs),
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)

commit 3d45ac4b35cbdf942f2a45b2b927f2ef6a8bda48
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Oct 19 04:35:44 2015 -0600

    timers/x86/hpet: Type adjustments
    
    Standardize on bool instead of an inconsistent mixture of u8 and plain 'int'.
    
    Also use u32 or 'unsigned int' instead of 'unsigned long' when a 32-bit type
    suffices, generating slightly better code on x86-64.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/5624E3A002000078000AC49A@prv-mh.provo.novell.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 9f9cc682e561..db9a675e751b 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -584,7 +584,7 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 static void __init force_disable_hpet(int num, int slot, int func)
 {
 #ifdef CONFIG_HPET_TIMER
-	boot_hpet_disable = 1;
+	boot_hpet_disable = true;
 	pr_info("x86/hpet: Will disable the HPET for this platform because it's not reliable\n");
 #endif
 }

commit 099bfbfc7fbbe22356c02f0caf709ac32e1126ea
Merge: 22165fa79814 c5fd936e992d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 13:18:51 2015 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for v4.2.
    
      I've one other new driver from freescale on my radar, it's been posted
      and reviewed, I'd just like to get someone to give it a last look, so
      maybe I'll send it or maybe I'll leave it.
    
      There is no major nouveau changes in here, Ben was working on
      something big, and we agreed it was a bit late, there wasn't anything
      else he considered urgent to merge.
    
      There might be another msm pull for some bits that are waiting on
      arm-soc, I'll see how we time it.
    
      This touches some "of" stuff, acks are in place except for the fixes
      to the build in various configs,t hat I just applied.
    
      Summary:
    
      New drivers:
          - virtio-gpu:
                    KMS only pieces of driver for virtio-gpu in qemu.
                    This is just the first part of this driver, enough to run
                    unaccelerated userspace on. As qemu merges more we'll start
                    adding the 3D features for the virgl 3d work.
          - amdgpu:
                    a new driver from AMD to driver their newer GPUs. (VI+)
                    It contains a new cleaner userspace API, and is a clean
                    break from radeon moving forward, that AMD are going to
                    concentrate on. It also contains a set of register headers
                    auto generated from AMD internal database.
    
      core:
          - atomic modesetting API completed, enabled by default now.
          - Add support for mode_id blob to atomic ioctl to complete interface.
          - bunch of Displayport MST fixes
          - lots of misc fixes.
    
      panel:
          - new simple panels
          - fix some long-standing build issues with bridge drivers
    
      radeon:
          - VCE1 support
          - add a GPU reset counter for userspace
          - lots of fixes.
    
      amdkfd:
          - H/W debugger support module
          - static user-mode queues
          - support killing all the waves when a process terminates
          - use standard DECLARE_BITMAP
    
      i915:
          - Add Broxton support
          - S3, rotation support for Skylake
          - RPS booting tuning
          - CPT modeset sequence fixes
          - ns2501 dither support
          - enable cmd parser on haswell
          - cdclk handling fixes
          - gen8 dynamic pte allocation
          - lots of atomic conversion work
    
      exynos:
          - Add atomic modesetting support
          - Add iommu support
          - Consolidate drm driver initialization
          - and MIC, DECON and MIPI-DSI support for exynos5433
    
      omapdrm:
          - atomic modesetting support (fixes lots of things in rewrite)
    
      tegra:
          - DP aux transaction fixes
          - iommu support fix
    
      msm:
          - adreno a306 support
          - various dsi bits
          - various 64-bit fixes
          - NV12MT support
    
      rcar-du:
          - atomic and misc fixes
    
      sti:
          - fix HDMI timing complaince
    
      tilcdc:
          - use drm component API to access tda998x driver
          - fix module unloading
    
      qxl:
          - stability fixes"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (872 commits)
      drm/nouveau: Pause between setting gpu to D3hot and cutting the power
      drm/dp/mst: close deadlock in connector destruction.
      drm: Always enable atomic API
      drm/vgem: Set unique to "vgem"
      of: fix a build error to of_graph_get_endpoint_by_regs function
      drm/dp/mst: take lock around looking up the branch device on hpd irq
      drm/dp/mst: make sure mst_primary mstb is valid in work function
      of: add EXPORT_SYMBOL for of_graph_get_endpoint_by_regs
      ARM: dts: rename the clock of MIPI DSI 'pll_clk' to 'sclk_mipi'
      drm/atomic: Don't set crtc_state->enable manually
      drm/exynos: dsi: do not set TE GPIO direction by input
      drm/exynos: dsi: add support for MIC driver as a bridge
      drm/exynos: dsi: add support for Exynos5433
      drm/exynos: dsi: make use of array for clock access
      drm/exynos: dsi: make use of driver data for static values
      drm/exynos: dsi: add macros for register access
      drm/exynos: dsi: rename pll_clk to sclk_clk
      drm/exynos: mic: add MIC driver
      of: add helper for getting endpoint node of specific identifiers
      drm/exynos: add Exynos5433 decon driver
      ...

commit b58d930750135d6c5b8e5aa084c0e9303c78c286
Author: Feng Tang <feng.tang@intel.com>
Date:   Mon Jun 15 17:40:01 2015 +0800

    x86/platform/intel/baytrail: Add comments about why we disabled HPET on Baytrail
    
    This question has been asked many times, and finally I found the
    official document which explains the problem of HPET on Baytrail,
    that it will halt in deep idle states.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john.stultz@linaro.org
    Cc: len.brown@intel.com
    Cc: matthew.lee@intel.com
    Link: http://lkml.kernel.org/r/1434361201-31743-1-git-send-email-feng.tang@intel.com
    [ Prettified things a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index fe9f0b79a18b..5cb9a4d6f623 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -627,8 +627,12 @@ static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA, PCI_ANY_ID,
 	  QFLAG_APPLY_ONCE, intel_graphics_stolen },
 	/*
-	 * HPET on current version of Baytrail platform has accuracy
-	 * problems, disable it for now:
+	 * HPET on the current version of the Baytrail platform has accuracy
+	 * problems: it will halt in deep idle state - so we disable it.
+	 *
+	 * More details can be found in section 18.10.1.3 of the datasheet:
+	 *
+	 *    http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/atom-z8000-datasheet-vol-1.pdf
 	 */
 	{ PCI_VENDOR_ID_INTEL, 0x0f00,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},

commit 31d4dcf705c33da28e3688bfb1f11889cf8b29f9
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Tue Mar 17 11:39:30 2015 +0200

    drm/i915/bxt: Broxton uses the same GMS values as Skylake
    
    v2: Rebase on top of the early-quirks rework from Ville.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com> (v1)
    Reviewed-by: Sivakumar Thulasimani <sivakumar.thulasimani@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index fe9f0b79a18b..ab470e475199 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -546,6 +546,7 @@ static const struct pci_device_id intel_stolen_ids[] __initconst = {
 	INTEL_BDW_D_IDS(&gen8_stolen_funcs),
 	INTEL_CHV_IDS(&chv_stolen_funcs),
 	INTEL_SKL_IDS(&gen9_stolen_funcs),
+	INTEL_BXT_IDS(&gen9_stolen_funcs),
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)

commit 663750141ed953c42b6b0e3cfb2450453bc38151
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Thu Jan 9 18:02:46 2014 +0000

    drm/i915/skl: Add the additional graphics stolen sizes
    
    Skylake introduces new stolen memory sizes starting at 0xf0 (4MB) and
    growing by 4MB increments from there.
    
    v2: Rebase on top of the early-quirk changes from Ville.
    
    v3: Rebase on top of the PCI_IDS/IDS macro rename
    
    Reviewed-by: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 2e1a6853e00c..fe9f0b79a18b 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -455,6 +455,23 @@ struct intel_stolen_funcs {
 	u32 (*base)(int num, int slot, int func, size_t size);
 };
 
+static size_t __init gen9_stolen_size(int num, int slot, int func)
+{
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
+	gmch_ctrl >>= BDW_GMCH_GMS_SHIFT;
+	gmch_ctrl &= BDW_GMCH_GMS_MASK;
+
+	if (gmch_ctrl < 0xf0)
+		return gmch_ctrl << 25; /* 32 MB units */
+	else
+		/* 4MB increments starting at 0xf0 for 4MB */
+		return (gmch_ctrl - 0xf0 + 1) << 22;
+}
+
+typedef size_t (*stolen_size_fn)(int num, int slot, int func);
+
 static const struct intel_stolen_funcs i830_stolen_funcs __initconst = {
 	.base = i830_stolen_base,
 	.size = i830_stolen_size,
@@ -490,6 +507,11 @@ static const struct intel_stolen_funcs gen8_stolen_funcs __initconst = {
 	.size = gen8_stolen_size,
 };
 
+static const struct intel_stolen_funcs gen9_stolen_funcs __initconst = {
+	.base = intel_stolen_base,
+	.size = gen9_stolen_size,
+};
+
 static const struct intel_stolen_funcs chv_stolen_funcs __initconst = {
 	.base = intel_stolen_base,
 	.size = chv_stolen_size,
@@ -523,6 +545,7 @@ static const struct pci_device_id intel_stolen_ids[] __initconst = {
 	INTEL_BDW_M_IDS(&gen8_stolen_funcs),
 	INTEL_BDW_D_IDS(&gen8_stolen_funcs),
 	INTEL_CHV_IDS(&chv_stolen_funcs),
+	INTEL_SKL_IDS(&gen9_stolen_funcs),
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)

commit 8d4ad9d4bb0a618c975a32d77087694ec6336f68
Merge: 5ea1f752ae04 9e9a928eed87
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 5 20:28:59 2014 +1000

    Merge commit '9e9a928eed8796a0a1aaed7e0b676db86ba84594' into drm-next
    
    Merge drm-fixes into drm-next.
    
    Both i915 and radeon need this done for later patches.
    
    Conflicts:
            drivers/gpu/drm/drm_crtc_helper.c
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/i915/i915_gem.c
            drivers/gpu/drm/i915/i915_gem_execbuffer.c
            drivers/gpu/drm/i915/i915_gem_gtt.c

commit 36dfcea47a862421154e9943ada5f8147bcbd43c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu May 8 22:19:42 2014 +0300

    x86/gpu: Sprinkle const, __init and __initconst to stolen memory quirks
    
    gen8_stolen_size() is missing __init, so add it.
    
    Also all the intel_stolen_funcs structures can be marked
    __initconst.
    
    intel_stolen_ids[] can also be made const if we replace the
    __initdata with __initconst.
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 832357541787..f96098fda1a2 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -418,7 +418,7 @@ static size_t __init gen6_stolen_size(int num, int slot, int func)
 	return gmch_ctrl << 25; /* 32 MB units */
 }
 
-static size_t gen8_stolen_size(int num, int slot, int func)
+static size_t __init gen8_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 
@@ -454,47 +454,47 @@ struct intel_stolen_funcs {
 	u32 (*base)(int num, int slot, int func, size_t size);
 };
 
-static const struct intel_stolen_funcs i830_stolen_funcs = {
+static const struct intel_stolen_funcs i830_stolen_funcs __initconst = {
 	.base = i830_stolen_base,
 	.size = i830_stolen_size,
 };
 
-static const struct intel_stolen_funcs i845_stolen_funcs = {
+static const struct intel_stolen_funcs i845_stolen_funcs __initconst = {
 	.base = i845_stolen_base,
 	.size = i830_stolen_size,
 };
 
-static const struct intel_stolen_funcs i85x_stolen_funcs = {
+static const struct intel_stolen_funcs i85x_stolen_funcs __initconst = {
 	.base = i85x_stolen_base,
 	.size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs i865_stolen_funcs = {
+static const struct intel_stolen_funcs i865_stolen_funcs __initconst = {
 	.base = i865_stolen_base,
 	.size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen3_stolen_funcs = {
+static const struct intel_stolen_funcs gen3_stolen_funcs __initconst = {
 	.base = intel_stolen_base,
 	.size = gen3_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen6_stolen_funcs = {
+static const struct intel_stolen_funcs gen6_stolen_funcs __initconst = {
 	.base = intel_stolen_base,
 	.size = gen6_stolen_size,
 };
 
-static const struct intel_stolen_funcs gen8_stolen_funcs = {
+static const struct intel_stolen_funcs gen8_stolen_funcs __initconst = {
 	.base = intel_stolen_base,
 	.size = gen8_stolen_size,
 };
 
-static const struct intel_stolen_funcs chv_stolen_funcs = {
+static const struct intel_stolen_funcs chv_stolen_funcs __initconst = {
 	.base = intel_stolen_base,
 	.size = chv_stolen_size,
 };
 
-static struct pci_device_id intel_stolen_ids[] __initdata = {
+static const struct pci_device_id intel_stolen_ids[] __initconst = {
 	INTEL_I830_IDS(&i830_stolen_funcs),
 	INTEL_I845G_IDS(&i845_stolen_funcs),
 	INTEL_I85X_IDS(&i85x_stolen_funcs),

commit 3e3b2c39081c7f22f300da89b6e922a4dd2899d3
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Thu May 8 22:19:41 2014 +0300

    x86/gpu: Implement stolen memory size early quirk for CHV
    
    CHV uses the same bits as SNB/VLV to code the Graphics Mode Select field
    (GFX stolen memory size) with the addition of finer granularity modes:
    4MB increments from 0x11 (8MB) to 0x1d.
    
    Values strictly above 0x1d are either reserved or not supported.
    
    v2: 4MB increments, not 8MB. 32MB has been omitted from the list of new
        values (Ville Syrjälä)
    
    v3: Also correctly interpret GGMS (GTT Graphics Memory Size) (Ville
        Syrjälä)
    
    v4: Don't assign a value that needs 20bits or more to a u16 (Rafael
        Barbalho)
    
    [vsyrjala: v5: Split from i915 changes and add chv_stolen_funcs]
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Rafael Barbalho <rafael.barbalho@intel.com>
    Tested-by: Rafael Barbalho <rafael.barbalho@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6e2537c32190..832357541787 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -428,6 +428,26 @@ static size_t gen8_stolen_size(int num, int slot, int func)
 	return gmch_ctrl << 25; /* 32 MB units */
 }
 
+static size_t __init chv_stolen_size(int num, int slot, int func)
+{
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
+	gmch_ctrl >>= SNB_GMCH_GMS_SHIFT;
+	gmch_ctrl &= SNB_GMCH_GMS_MASK;
+
+	/*
+	 * 0x0  to 0x10: 32MB increments starting at 0MB
+	 * 0x11 to 0x16: 4MB increments starting at 8MB
+	 * 0x17 to 0x1d: 4MB increments start at 36MB
+	 */
+	if (gmch_ctrl < 0x11)
+		return gmch_ctrl << 25;
+	else if (gmch_ctrl < 0x17)
+		return (gmch_ctrl - 0x11 + 2) << 22;
+	else
+		return (gmch_ctrl - 0x17 + 9) << 22;
+}
 
 struct intel_stolen_funcs {
 	size_t (*size)(int num, int slot, int func);
@@ -469,6 +489,11 @@ static const struct intel_stolen_funcs gen8_stolen_funcs = {
 	.size = gen8_stolen_size,
 };
 
+static const struct intel_stolen_funcs chv_stolen_funcs = {
+	.base = intel_stolen_base,
+	.size = chv_stolen_size,
+};
+
 static struct pci_device_id intel_stolen_ids[] __initdata = {
 	INTEL_I830_IDS(&i830_stolen_funcs),
 	INTEL_I845G_IDS(&i845_stolen_funcs),
@@ -495,7 +520,8 @@ static struct pci_device_id intel_stolen_ids[] __initdata = {
 	INTEL_HSW_D_IDS(&gen6_stolen_funcs),
 	INTEL_HSW_M_IDS(&gen6_stolen_funcs),
 	INTEL_BDW_M_IDS(&gen8_stolen_funcs),
-	INTEL_BDW_D_IDS(&gen8_stolen_funcs)
+	INTEL_BDW_D_IDS(&gen8_stolen_funcs),
+	INTEL_CHV_IDS(&chv_stolen_funcs),
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)

commit 62187910b0fc7a75cfec9c30fda58ce2f39d689b
Author: Feng Tang <feng.tang@intel.com>
Date:   Thu Apr 24 16:18:18 2014 +0800

    x86/intel: Add quirk to disable HPET for the Baytrail platform
    
    HPET on current Baytrail platform has accuracy problem to be
    used as reliable clocksource/clockevent, so add a early quirk to
    disable it.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1398327498-13163-2-git-send-email-feng.tang@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 6e2537c32190..6cda0baeac9d 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -17,6 +17,7 @@
 #include <asm/dma.h>
 #include <asm/io_apic.h>
 #include <asm/apic.h>
+#include <asm/hpet.h>
 #include <asm/iommu.h>
 #include <asm/gart.h>
 #include <asm/irq_remapping.h>
@@ -530,6 +531,15 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 	}
 }
 
+static void __init force_disable_hpet(int num, int slot, int func)
+{
+#ifdef CONFIG_HPET_TIMER
+	boot_hpet_disable = 1;
+	pr_info("x86/hpet: Will disable the HPET for this platform because it's not reliable\n");
+#endif
+}
+
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -567,6 +577,12 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA, PCI_ANY_ID,
 	  QFLAG_APPLY_ONCE, intel_graphics_stolen },
+	/*
+	 * HPET on current version of Baytrail platform has accuracy
+	 * problems, disable it for now:
+	 */
+	{ PCI_VENDOR_ID_INTEL, 0x0f00,
+		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
 	{}
 };
 

commit 86e587623a0ca8426267dad8d3eaebd6fc2d00f1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Sun Apr 13 12:45:03 2014 +0300

    x86/gpu: Fix sign extension issue in Intel graphics stolen memory quirks
    
    Have the KB(),MB(),GB() macros produce unsigned longs to avoid
    unintended sign extension issues with the gen2 memory size
    detection.
    
    What happens is first the uint8_t returned by
    read_pci_config_byte() gets promoted to an int which gets
    multiplied by another int from the MB() macro, and finally the
    result gets sign extended to size_t.
    
    Although this shouldn't be a problem in practice as all affected
    gen2 platforms are 32bit AFAIK, so size_t will be 32 bits.
    
    Reported-by: Bjorn Helgaas <bhelgaas@google.com>
    Suggested-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1397382303-17525-1-git-send-email-ville.syrjala@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index b0cc3809723d..6e2537c32190 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -240,7 +240,7 @@ static u32 __init intel_stolen_base(int num, int slot, int func, size_t stolen_s
 	return base;
 }
 
-#define KB(x)	((x) * 1024)
+#define KB(x)	((x) * 1024UL)
 #define MB(x)	(KB (KB (x)))
 #define GB(x)	(MB (KB (x)))
 

commit 40e9963e622cf28ecef258e3dddb04457b65681c
Merge: 8eab6cd031c1 0534af01cca3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 11 12:04:15 2014 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pullx86 core platform updates from Peter Anvin:
     "This is the x86/platform branch with the objectionable IOSF patches
      removed.
    
      What is left is proper memory handling for Intel GPUs, and a change to
      the Calgary IOMMU code which will be required to make kexec work
      sanely on those platforms after some upcoming kexec changes"
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, calgary: Use 8M TCE table size by default
      x86/gpu: Print the Intel graphics stolen memory range
      x86/gpu: Add Intel graphics stolen memory quirk for gen2 platforms
      x86/gpu: Add vfunc for Intel graphics stolen memory base address

commit 6f8a1b335fde143b7407036e2368d3cd6eb55674
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Mar 12 14:44:33 2014 -0400

    x86: Adjust irq remapping quirk for older revisions of 5500/5520 chipsets
    
    Commit 03bbcb2e7e2 (iommu/vt-d: add quirk for broken interrupt
    remapping on 55XX chipsets) properly disables irq remapping on the
    5500/5520 chipsets that don't correctly perform that feature.
    
    However, when I wrote it, I followed the errata sheet linked in that
    commit too closely, and explicitly tied the activation of the quirk to
    revision 0x13 of the chip, under the assumption that earlier revisions
    were not in the field.  Recently a system was reported to be suffering
    from this remap bug and the quirk hadn't triggered, because the
    revision id register read at a lower value that 0x13, so the quirk
    test failed improperly.  Given this, it seems only prudent to adjust
    this quirk so that any revision less than 0x13 has the quirk asserted.
    
    [ tglx: Removed the 0x12 comparison of pci id 3405 as this is covered
            by the <= 0x13 check already ]
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1394649873-14913-1-git-send-email-nhorman@tuxdriver.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bc4a088f9023..6d7d5a1260a6 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -203,18 +203,15 @@ static void __init intel_remapping_check(int num, int slot, int func)
 	revision = read_pci_config_byte(num, slot, func, PCI_REVISION_ID);
 
 	/*
- 	 * Revision 13 of all triggering devices id in this quirk have
-	 * a problem draining interrupts when irq remapping is enabled,
-	 * and should be flagged as broken.  Additionally revisions 0x12
-	 * and 0x22 of device id 0x3405 has this problem.
+	 * Revision <= 13 of all triggering devices id in this quirk
+	 * have a problem draining interrupts when irq remapping is
+	 * enabled, and should be flagged as broken. Additionally
+	 * revision 0x22 of device id 0x3405 has this problem.
 	 */
-	if (revision == 0x13)
+	if (revision <= 0x13)
 		set_irq_remapping_broken();
-	else if ((device == 0x3405) &&
-	    ((revision == 0x12) ||
-	     (revision == 0x22)))
+	else if (device == 0x3405 && revision == 0x22)
 		set_irq_remapping_broken();
-
 }
 
 /*

commit c71ef7b3c3be3337deaf1eb28dd26e0d5d4b4aa7
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Feb 5 21:29:00 2014 +0200

    x86/gpu: Print the Intel graphics stolen memory range
    
    Print an informative message when reserving the graphics stolen
    memory region in the early quirk.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1391628540-23072-4-git-send-email-ville.syrjala@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 5218dd209ede..52f36e660625 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -520,6 +520,8 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 			size = stolen_funcs->size(num, slot, func);
 			start = stolen_funcs->base(num, slot, func, size);
 			if (size && start) {
+				printk(KERN_INFO "Reserving Intel graphics stolen memory at 0x%x-0x%x\n",
+				       start, start + (u32)size - 1);
 				/* Mark this space as reserved */
 				e820_add_region(start, size, E820_RESERVED);
 				sanitize_e820_map(e820.map,

commit a4dff76924fe4f6d53a9f34196a67a32149e7270
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Feb 5 21:28:59 2014 +0200

    x86/gpu: Add Intel graphics stolen memory quirk for gen2 platforms
    
    There isn't an explicit stolen memory base register on gen2.
    Some old comment in the i915 code suggests we should get it via
    max_low_pfn_mapped, but that's clearly a bad idea on my MGM.
    
    The e820 map in said machine looks like this:
    
            BIOS-e820: [mem 0x0000000000000000-0x000000000009f7ff] usable
            BIOS-e820: [mem 0x000000000009f800-0x000000000009ffff] reserved
            BIOS-e820: [mem 0x00000000000ce000-0x00000000000cffff] reserved
            BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved
            BIOS-e820: [mem 0x0000000000100000-0x000000001f6effff] usable
            BIOS-e820: [mem 0x000000001f6f0000-0x000000001f6f7fff] ACPI data
            BIOS-e820: [mem 0x000000001f6f8000-0x000000001f6fffff] ACPI NVS
            BIOS-e820: [mem 0x000000001f700000-0x000000001fffffff] reserved
            BIOS-e820: [mem 0x00000000fec10000-0x00000000fec1ffff] reserved
            BIOS-e820: [mem 0x00000000ffb00000-0x00000000ffbfffff] reserved
            BIOS-e820: [mem 0x00000000fff00000-0x00000000ffffffff] reserved
    
    That makes max_low_pfn_mapped = 1f6f0000, so assuming our stolen
    memory would start there would place it on top of some ACPI
    memory regions. So not a good idea as already stated.
    
    The 9MB region after the ACPI regions at 0x1f700000 however
    looks promising given that the macine reports the stolen memory
    size to be 8MB. Looking at the PGTBL_CTL register, the GTT
    entries are at offset 0x1fee00000, and given that the GTT
    entries occupy 128KB, it looks like the stolen memory could
    start at 0x1f700000 and the GTT entries would occupy the last
    128KB of the stolen memory.
    
    After some more digging through chipset documentation, I've
    determined the BIOS first allocates space for something called
    TSEG (something to do with SMM) from the top of memory, and then
    it allocates the graphics stolen memory below that. Accordind to
    the chipset documentation TSEG has a fixed size of 1MB on 855.
    So that explains the top 1MB in the e820 region. And it also
    confirms that the GTT entries are in fact at the end of the the
    stolen memory region.
    
    Derive the stolen memory base address on gen2 the same as the
    BIOS does (TOM-TSEG_SIZE-stolen_size). There are a few
    differences between the registers on various gen2 chipsets, so a
    few different codepaths are required.
    
    865G is again bit more special since it seems to support enough
    memory to hit 4GB address space issues. This means the PCI
    allocations will also affect the location of the stolen memory.
    Fortunately there appears to be the TOUD register which may give
    us the correct answer directly. But the chipset docs are a bit
    unclear, so I'm not 100% sure that the graphics stolen memory is
    always the last thing the BIOS steals. Someone would need to
    verify it on a real system.
    
    I tested this on the my 830 and 855 machines, and so far
    everything looks peachy.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1391628540-23072-3-git-send-email-ville.syrjala@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index fddd4d05d1fa..5218dd209ede 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -247,6 +247,114 @@ static u32 __init intel_stolen_base(int num, int slot, int func, size_t stolen_s
 #define MB(x)	(KB (KB (x)))
 #define GB(x)	(MB (KB (x)))
 
+static size_t __init i830_tseg_size(void)
+{
+	u8 tmp = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);
+
+	if (!(tmp & TSEG_ENABLE))
+		return 0;
+
+	if (tmp & I830_TSEG_SIZE_1M)
+		return MB(1);
+	else
+		return KB(512);
+}
+
+static size_t __init i845_tseg_size(void)
+{
+	u8 tmp = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);
+
+	if (!(tmp & TSEG_ENABLE))
+		return 0;
+
+	switch (tmp & I845_TSEG_SIZE_MASK) {
+	case I845_TSEG_SIZE_512K:
+		return KB(512);
+	case I845_TSEG_SIZE_1M:
+		return MB(1);
+	default:
+		WARN_ON(1);
+		return 0;
+	}
+}
+
+static size_t __init i85x_tseg_size(void)
+{
+	u8 tmp = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);
+
+	if (!(tmp & TSEG_ENABLE))
+		return 0;
+
+	return MB(1);
+}
+
+static size_t __init i830_mem_size(void)
+{
+	return read_pci_config_byte(0, 0, 0, I830_DRB3) * MB(32);
+}
+
+static size_t __init i85x_mem_size(void)
+{
+	return read_pci_config_byte(0, 0, 1, I85X_DRB3) * MB(32);
+}
+
+/*
+ * On 830/845/85x the stolen memory base isn't available in any
+ * register. We need to calculate it as TOM-TSEG_SIZE-stolen_size.
+ */
+static u32 __init i830_stolen_base(int num, int slot, int func, size_t stolen_size)
+{
+	return i830_mem_size() - i830_tseg_size() - stolen_size;
+}
+
+static u32 __init i845_stolen_base(int num, int slot, int func, size_t stolen_size)
+{
+	return i830_mem_size() - i845_tseg_size() - stolen_size;
+}
+
+static u32 __init i85x_stolen_base(int num, int slot, int func, size_t stolen_size)
+{
+	return i85x_mem_size() - i85x_tseg_size() - stolen_size;
+}
+
+static u32 __init i865_stolen_base(int num, int slot, int func, size_t stolen_size)
+{
+	/*
+	 * FIXME is the graphics stolen memory region
+	 * always at TOUD? Ie. is it always the last
+	 * one to be allocated by the BIOS?
+	 */
+	return read_pci_config_16(0, 0, 0, I865_TOUD) << 16;
+}
+
+static size_t __init i830_stolen_size(int num, int slot, int func)
+{
+	size_t stolen_size;
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);
+
+	switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
+	case I830_GMCH_GMS_STOLEN_512:
+		stolen_size = KB(512);
+		break;
+	case I830_GMCH_GMS_STOLEN_1024:
+		stolen_size = MB(1);
+		break;
+	case I830_GMCH_GMS_STOLEN_8192:
+		stolen_size = MB(8);
+		break;
+	case I830_GMCH_GMS_LOCAL:
+		/* local memory isn't part of the normal address space */
+		stolen_size = 0;
+		break;
+	default:
+		return 0;
+	}
+
+	return stolen_size;
+}
+
 static size_t __init gen3_stolen_size(int num, int slot, int func)
 {
 	size_t stolen_size;
@@ -329,6 +437,26 @@ struct intel_stolen_funcs {
 	u32 (*base)(int num, int slot, int func, size_t size);
 };
 
+static const struct intel_stolen_funcs i830_stolen_funcs = {
+	.base = i830_stolen_base,
+	.size = i830_stolen_size,
+};
+
+static const struct intel_stolen_funcs i845_stolen_funcs = {
+	.base = i845_stolen_base,
+	.size = i830_stolen_size,
+};
+
+static const struct intel_stolen_funcs i85x_stolen_funcs = {
+	.base = i85x_stolen_base,
+	.size = gen3_stolen_size,
+};
+
+static const struct intel_stolen_funcs i865_stolen_funcs = {
+	.base = i865_stolen_base,
+	.size = gen3_stolen_size,
+};
+
 static const struct intel_stolen_funcs gen3_stolen_funcs = {
 	.base = intel_stolen_base,
 	.size = gen3_stolen_size,
@@ -345,6 +473,10 @@ static const struct intel_stolen_funcs gen8_stolen_funcs = {
 };
 
 static struct pci_device_id intel_stolen_ids[] __initdata = {
+	INTEL_I830_IDS(&i830_stolen_funcs),
+	INTEL_I845G_IDS(&i845_stolen_funcs),
+	INTEL_I85X_IDS(&i85x_stolen_funcs),
+	INTEL_I865G_IDS(&i865_stolen_funcs),
 	INTEL_I915G_IDS(&gen3_stolen_funcs),
 	INTEL_I915GM_IDS(&gen3_stolen_funcs),
 	INTEL_I945G_IDS(&gen3_stolen_funcs),

commit 52ca70454ea5ff29bc39f7871d28f8e6f4713867
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Feb 5 21:28:58 2014 +0200

    x86/gpu: Add vfunc for Intel graphics stolen memory base address
    
    For gen2 devices we're going to need another way to determine
    the stolen memory base address. Make that into a vfunc as well.
    
    Also drop the bogus inline keyword from gen8_stolen_size().
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1391628540-23072-2-git-send-email-ville.syrjala@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index bc4a088f9023..fddd4d05d1fa 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -228,7 +228,7 @@ static void __init intel_remapping_check(int num, int slot, int func)
  *
  * And yes, so far on current devices the base addr is always under 4G.
  */
-static u32 __init intel_stolen_base(int num, int slot, int func)
+static u32 __init intel_stolen_base(int num, int slot, int func, size_t stolen_size)
 {
 	u32 base;
 
@@ -313,7 +313,7 @@ static size_t __init gen6_stolen_size(int num, int slot, int func)
 	return gmch_ctrl << 25; /* 32 MB units */
 }
 
-static inline size_t gen8_stolen_size(int num, int slot, int func)
+static size_t gen8_stolen_size(int num, int slot, int func)
 {
 	u16 gmch_ctrl;
 
@@ -323,31 +323,50 @@ static inline size_t gen8_stolen_size(int num, int slot, int func)
 	return gmch_ctrl << 25; /* 32 MB units */
 }
 
-typedef size_t (*stolen_size_fn)(int num, int slot, int func);
+
+struct intel_stolen_funcs {
+	size_t (*size)(int num, int slot, int func);
+	u32 (*base)(int num, int slot, int func, size_t size);
+};
+
+static const struct intel_stolen_funcs gen3_stolen_funcs = {
+	.base = intel_stolen_base,
+	.size = gen3_stolen_size,
+};
+
+static const struct intel_stolen_funcs gen6_stolen_funcs = {
+	.base = intel_stolen_base,
+	.size = gen6_stolen_size,
+};
+
+static const struct intel_stolen_funcs gen8_stolen_funcs = {
+	.base = intel_stolen_base,
+	.size = gen8_stolen_size,
+};
 
 static struct pci_device_id intel_stolen_ids[] __initdata = {
-	INTEL_I915G_IDS(gen3_stolen_size),
-	INTEL_I915GM_IDS(gen3_stolen_size),
-	INTEL_I945G_IDS(gen3_stolen_size),
-	INTEL_I945GM_IDS(gen3_stolen_size),
-	INTEL_VLV_M_IDS(gen6_stolen_size),
-	INTEL_VLV_D_IDS(gen6_stolen_size),
-	INTEL_PINEVIEW_IDS(gen3_stolen_size),
-	INTEL_I965G_IDS(gen3_stolen_size),
-	INTEL_G33_IDS(gen3_stolen_size),
-	INTEL_I965GM_IDS(gen3_stolen_size),
-	INTEL_GM45_IDS(gen3_stolen_size),
-	INTEL_G45_IDS(gen3_stolen_size),
-	INTEL_IRONLAKE_D_IDS(gen3_stolen_size),
-	INTEL_IRONLAKE_M_IDS(gen3_stolen_size),
-	INTEL_SNB_D_IDS(gen6_stolen_size),
-	INTEL_SNB_M_IDS(gen6_stolen_size),
-	INTEL_IVB_M_IDS(gen6_stolen_size),
-	INTEL_IVB_D_IDS(gen6_stolen_size),
-	INTEL_HSW_D_IDS(gen6_stolen_size),
-	INTEL_HSW_M_IDS(gen6_stolen_size),
-	INTEL_BDW_M_IDS(gen8_stolen_size),
-	INTEL_BDW_D_IDS(gen8_stolen_size)
+	INTEL_I915G_IDS(&gen3_stolen_funcs),
+	INTEL_I915GM_IDS(&gen3_stolen_funcs),
+	INTEL_I945G_IDS(&gen3_stolen_funcs),
+	INTEL_I945GM_IDS(&gen3_stolen_funcs),
+	INTEL_VLV_M_IDS(&gen6_stolen_funcs),
+	INTEL_VLV_D_IDS(&gen6_stolen_funcs),
+	INTEL_PINEVIEW_IDS(&gen3_stolen_funcs),
+	INTEL_I965G_IDS(&gen3_stolen_funcs),
+	INTEL_G33_IDS(&gen3_stolen_funcs),
+	INTEL_I965GM_IDS(&gen3_stolen_funcs),
+	INTEL_GM45_IDS(&gen3_stolen_funcs),
+	INTEL_G45_IDS(&gen3_stolen_funcs),
+	INTEL_IRONLAKE_D_IDS(&gen3_stolen_funcs),
+	INTEL_IRONLAKE_M_IDS(&gen3_stolen_funcs),
+	INTEL_SNB_D_IDS(&gen6_stolen_funcs),
+	INTEL_SNB_M_IDS(&gen6_stolen_funcs),
+	INTEL_IVB_M_IDS(&gen6_stolen_funcs),
+	INTEL_IVB_D_IDS(&gen6_stolen_funcs),
+	INTEL_HSW_D_IDS(&gen6_stolen_funcs),
+	INTEL_HSW_M_IDS(&gen6_stolen_funcs),
+	INTEL_BDW_M_IDS(&gen8_stolen_funcs),
+	INTEL_BDW_D_IDS(&gen8_stolen_funcs)
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)
@@ -364,10 +383,10 @@ static void __init intel_graphics_stolen(int num, int slot, int func)
 
 	for (i = 0; i < ARRAY_SIZE(intel_stolen_ids); i++) {
 		if (intel_stolen_ids[i].device == device) {
-			stolen_size_fn stolen_size =
-				(stolen_size_fn)intel_stolen_ids[i].driver_data;
-			size = stolen_size(num, slot, func);
-			start = intel_stolen_base(num, slot, func);
+			const struct intel_stolen_funcs *stolen_funcs =
+				(const struct intel_stolen_funcs *)intel_stolen_ids[i].driver_data;
+			size = stolen_funcs->size(num, slot, func);
+			start = stolen_funcs->base(num, slot, func, size);
 			if (size && start) {
 				/* Mark this space as reserved */
 				e820_add_region(start, size, E820_RESERVED);

commit 7bd40c16ccb2cb6877dd00b0e66249c171e6fa43
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Nov 12 10:17:39 2013 -0800

    x86/early quirk: use gen6 stolen detection for VLV
    
    We've always been able to use either method on VLV, but it appears more
    recent BIOSes only support the gen6 method, so switch over to that.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=71370
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 96f958d8cd45..bc4a088f9023 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -330,8 +330,8 @@ static struct pci_device_id intel_stolen_ids[] __initdata = {
 	INTEL_I915GM_IDS(gen3_stolen_size),
 	INTEL_I945G_IDS(gen3_stolen_size),
 	INTEL_I945GM_IDS(gen3_stolen_size),
-	INTEL_VLV_M_IDS(gen3_stolen_size),
-	INTEL_VLV_D_IDS(gen3_stolen_size),
+	INTEL_VLV_M_IDS(gen6_stolen_size),
+	INTEL_VLV_D_IDS(gen6_stolen_size),
 	INTEL_PINEVIEW_IDS(gen3_stolen_size),
 	INTEL_I965G_IDS(gen3_stolen_size),
 	INTEL_G33_IDS(gen3_stolen_size),

commit 9459d252378aea80d28dc12bfec9a0d31b2a61bf
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Sun Nov 3 16:53:55 2013 -0800

    drm/i915/bdw: support GMS and GGMS changes
    
    All the BARs have the ability to grow.
    
    v2: Pulled out the simulator workaround to a separate patch.
    Rebased.
    
    v3: Rebase onto latest vlv patches from Jesse.
    
    v4: Rebased on top of the early stolen quirk patch from Jesse.
    
    v5: Use the new macro names.
    s/INTEL_BDW_PCI_IDS_D/INTEL_BDW_D_IDS
    s/INTEL_BDW_PCI_IDS_M/INTEL_BDW_M_IDS
    It's Jesse's fault for not following the convention I originally set.
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index b3cd3ebae077..96f958d8cd45 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -313,6 +313,16 @@ static size_t __init gen6_stolen_size(int num, int slot, int func)
 	return gmch_ctrl << 25; /* 32 MB units */
 }
 
+static inline size_t gen8_stolen_size(int num, int slot, int func)
+{
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
+	gmch_ctrl >>= BDW_GMCH_GMS_SHIFT;
+	gmch_ctrl &= BDW_GMCH_GMS_MASK;
+	return gmch_ctrl << 25; /* 32 MB units */
+}
+
 typedef size_t (*stolen_size_fn)(int num, int slot, int func);
 
 static struct pci_device_id intel_stolen_ids[] __initdata = {
@@ -336,6 +346,8 @@ static struct pci_device_id intel_stolen_ids[] __initdata = {
 	INTEL_IVB_D_IDS(gen6_stolen_size),
 	INTEL_HSW_D_IDS(gen6_stolen_size),
 	INTEL_HSW_M_IDS(gen6_stolen_size),
+	INTEL_BDW_M_IDS(gen8_stolen_size),
+	INTEL_BDW_D_IDS(gen8_stolen_size)
 };
 
 static void __init intel_graphics_stolen(int num, int slot, int func)

commit 814c5f1f52a4beb3710317022acd6ad34fc0b6b9
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jul 26 13:32:52 2013 -0700

    x86: add early quirk for reserving Intel graphics stolen memory v5
    
    Systems with Intel graphics controllers set aside memory exclusively for
    gfx driver use.  This memory is not always marked in the E820 as
    reserved or as RAM, and so is subject to overlap from E820 manipulation
    later in the boot process.  On some systems, MMIO space is allocated on
    top, despite the efforts of the "RAM buffer" approach, which simply
    rounds memory boundaries up to 64M to try to catch space that may decode
    as RAM and so is not suitable for MMIO.
    
    v2: use read_pci_config for 32 bit reads instead of adding a new one
        (Chris)
        add gen6 stolen size function (Chris)
    v3: use a function pointer (Chris)
        drop gen2 bits (Daniel)
    v4: call e820_sanitize_map after adding the region
    v5: fixup comments (Peter)
        simplify loop (Chris)
    
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=66726
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=66844
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 63bdb29b2549..b3cd3ebae077 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -12,6 +12,7 @@
 #include <linux/pci.h>
 #include <linux/acpi.h>
 #include <linux/pci_ids.h>
+#include <drm/i915_drm.h>
 #include <asm/pci-direct.h>
 #include <asm/dma.h>
 #include <asm/io_apic.h>
@@ -216,6 +217,157 @@ static void __init intel_remapping_check(int num, int slot, int func)
 
 }
 
+/*
+ * Systems with Intel graphics controllers set aside memory exclusively
+ * for gfx driver use.  This memory is not marked in the E820 as reserved
+ * or as RAM, and so is subject to overlap from E820 manipulation later
+ * in the boot process.  On some systems, MMIO space is allocated on top,
+ * despite the efforts of the "RAM buffer" approach, which simply rounds
+ * memory boundaries up to 64M to try to catch space that may decode
+ * as RAM and so is not suitable for MMIO.
+ *
+ * And yes, so far on current devices the base addr is always under 4G.
+ */
+static u32 __init intel_stolen_base(int num, int slot, int func)
+{
+	u32 base;
+
+	/*
+	 * For the PCI IDs in this quirk, the stolen base is always
+	 * in 0x5c, aka the BDSM register (yes that's really what
+	 * it's called).
+	 */
+	base = read_pci_config(num, slot, func, 0x5c);
+	base &= ~((1<<20) - 1);
+
+	return base;
+}
+
+#define KB(x)	((x) * 1024)
+#define MB(x)	(KB (KB (x)))
+#define GB(x)	(MB (KB (x)))
+
+static size_t __init gen3_stolen_size(int num, int slot, int func)
+{
+	size_t stolen_size;
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);
+
+	switch (gmch_ctrl & I855_GMCH_GMS_MASK) {
+	case I855_GMCH_GMS_STOLEN_1M:
+		stolen_size = MB(1);
+		break;
+	case I855_GMCH_GMS_STOLEN_4M:
+		stolen_size = MB(4);
+		break;
+	case I855_GMCH_GMS_STOLEN_8M:
+		stolen_size = MB(8);
+		break;
+	case I855_GMCH_GMS_STOLEN_16M:
+		stolen_size = MB(16);
+		break;
+	case I855_GMCH_GMS_STOLEN_32M:
+		stolen_size = MB(32);
+		break;
+	case I915_GMCH_GMS_STOLEN_48M:
+		stolen_size = MB(48);
+		break;
+	case I915_GMCH_GMS_STOLEN_64M:
+		stolen_size = MB(64);
+		break;
+	case G33_GMCH_GMS_STOLEN_128M:
+		stolen_size = MB(128);
+		break;
+	case G33_GMCH_GMS_STOLEN_256M:
+		stolen_size = MB(256);
+		break;
+	case INTEL_GMCH_GMS_STOLEN_96M:
+		stolen_size = MB(96);
+		break;
+	case INTEL_GMCH_GMS_STOLEN_160M:
+		stolen_size = MB(160);
+		break;
+	case INTEL_GMCH_GMS_STOLEN_224M:
+		stolen_size = MB(224);
+		break;
+	case INTEL_GMCH_GMS_STOLEN_352M:
+		stolen_size = MB(352);
+		break;
+	default:
+		stolen_size = 0;
+		break;
+	}
+
+	return stolen_size;
+}
+
+static size_t __init gen6_stolen_size(int num, int slot, int func)
+{
+	u16 gmch_ctrl;
+
+	gmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);
+	gmch_ctrl >>= SNB_GMCH_GMS_SHIFT;
+	gmch_ctrl &= SNB_GMCH_GMS_MASK;
+
+	return gmch_ctrl << 25; /* 32 MB units */
+}
+
+typedef size_t (*stolen_size_fn)(int num, int slot, int func);
+
+static struct pci_device_id intel_stolen_ids[] __initdata = {
+	INTEL_I915G_IDS(gen3_stolen_size),
+	INTEL_I915GM_IDS(gen3_stolen_size),
+	INTEL_I945G_IDS(gen3_stolen_size),
+	INTEL_I945GM_IDS(gen3_stolen_size),
+	INTEL_VLV_M_IDS(gen3_stolen_size),
+	INTEL_VLV_D_IDS(gen3_stolen_size),
+	INTEL_PINEVIEW_IDS(gen3_stolen_size),
+	INTEL_I965G_IDS(gen3_stolen_size),
+	INTEL_G33_IDS(gen3_stolen_size),
+	INTEL_I965GM_IDS(gen3_stolen_size),
+	INTEL_GM45_IDS(gen3_stolen_size),
+	INTEL_G45_IDS(gen3_stolen_size),
+	INTEL_IRONLAKE_D_IDS(gen3_stolen_size),
+	INTEL_IRONLAKE_M_IDS(gen3_stolen_size),
+	INTEL_SNB_D_IDS(gen6_stolen_size),
+	INTEL_SNB_M_IDS(gen6_stolen_size),
+	INTEL_IVB_M_IDS(gen6_stolen_size),
+	INTEL_IVB_D_IDS(gen6_stolen_size),
+	INTEL_HSW_D_IDS(gen6_stolen_size),
+	INTEL_HSW_M_IDS(gen6_stolen_size),
+};
+
+static void __init intel_graphics_stolen(int num, int slot, int func)
+{
+	size_t size;
+	int i;
+	u32 start;
+	u16 device, subvendor, subdevice;
+
+	device = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);
+	subvendor = read_pci_config_16(num, slot, func,
+				       PCI_SUBSYSTEM_VENDOR_ID);
+	subdevice = read_pci_config_16(num, slot, func, PCI_SUBSYSTEM_ID);
+
+	for (i = 0; i < ARRAY_SIZE(intel_stolen_ids); i++) {
+		if (intel_stolen_ids[i].device == device) {
+			stolen_size_fn stolen_size =
+				(stolen_size_fn)intel_stolen_ids[i].driver_data;
+			size = stolen_size(num, slot, func);
+			start = intel_stolen_base(num, slot, func);
+			if (size && start) {
+				/* Mark this space as reserved */
+				e820_add_region(start, size, E820_RESERVED);
+				sanitize_e820_map(e820.map,
+						  ARRAY_SIZE(e820.map),
+						  &e820.nr_map);
+			}
+			return;
+		}
+	}
+}
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -251,6 +403,8 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{ PCI_VENDOR_ID_INTEL, 0x3406, PCI_CLASS_BRIDGE_HOST,
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
+	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_CLASS_DISPLAY_VGA, PCI_ANY_ID,
+	  QFLAG_APPLY_ONCE, intel_graphics_stolen },
 	{}
 };
 

commit 803075dba31c17af110e1d9a915fe7262165b213
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jul 17 07:13:59 2013 -0400

    x86/iommu/vt-d: Expand interrupt remapping quirk to cover x58 chipset
    
    Recently we added an early quirk to detect 5500/5520 chipsets
    with early revisions that had problems with irq draining with
    interrupt remapping enabled:
    
      commit 03bbcb2e7e292838bb0244f5a7816d194c911d62
      Author: Neil Horman <nhorman@tuxdriver.com>
      Date:   Tue Apr 16 16:38:32 2013 -0400
    
          iommu/vt-d: add quirk for broken interrupt remapping on 55XX chipsets
    
    It turns out this same problem is present in the intel X58
    chipset as well. See errata 69 here:
    
      http://www.intel.com/content/www/us/en/chipsets/x58-express-specification-update.html
    
    This patch extends the pci early quirk so that the chip
    devices/revisions specified in the above update are also covered
    in the same way:
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Acked-by: Donald Dutile <ddutile@redhat.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Andrew Cooper <andrew.cooper3@citrix.com>
    Cc: Malcolm Crossley <malcolm.crossley@citrix.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1374059639-8631-1-git-send-email-nhorman@tuxdriver.com
    [ Small edits. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 94ab6b90dd3f..63bdb29b2549 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -196,15 +196,23 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 static void __init intel_remapping_check(int num, int slot, int func)
 {
 	u8 revision;
+	u16 device;
 
+	device = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);
 	revision = read_pci_config_byte(num, slot, func, PCI_REVISION_ID);
 
 	/*
-	 * Revision 0x13 of this chipset supports irq remapping
-	 * but has an erratum that breaks its behavior, flag it as such
+ 	 * Revision 13 of all triggering devices id in this quirk have
+	 * a problem draining interrupts when irq remapping is enabled,
+	 * and should be flagged as broken.  Additionally revisions 0x12
+	 * and 0x22 of device id 0x3405 has this problem.
 	 */
 	if (revision == 0x13)
 		set_irq_remapping_broken();
+	else if ((device == 0x3405) &&
+	    ((revision == 0x12) ||
+	     (revision == 0x22)))
+		set_irq_remapping_broken();
 
 }
 
@@ -239,6 +247,8 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
 	{ PCI_VENDOR_ID_INTEL, 0x3403, PCI_CLASS_BRIDGE_HOST,
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
+	{ PCI_VENDOR_ID_INTEL, 0x3405, PCI_CLASS_BRIDGE_HOST,
+	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{ PCI_VENDOR_ID_INTEL, 0x3406, PCI_CLASS_BRIDGE_HOST,
 	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{}

commit 03bbcb2e7e292838bb0244f5a7816d194c911d62
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue Apr 16 16:38:32 2013 -0400

    iommu/vt-d: add quirk for broken interrupt remapping on 55XX chipsets
    
    A few years back intel published a spec update:
    http://www.intel.com/content/dam/doc/specification-update/5520-and-5500-chipset-ioh-specification-update.pdf
    
    For the 5520 and 5500 chipsets which contained an errata (specificially errata
    53), which noted that these chipsets can't properly do interrupt remapping, and
    as a result the recommend that interrupt remapping be disabled in bios.  While
    many vendors have a bios update to do exactly that, not all do, and of course
    not all users update their bios to a level that corrects the problem.  As a
    result, occasionally interrupts can arrive at a cpu even after affinity for that
    interrupt has be moved, leading to lost or spurrious interrupts (usually
    characterized by the message:
    kernel: do_IRQ: 7.71 No irq handler for vector (irq -1)
    
    There have been several incidents recently of people seeing this error, and
    investigation has shown that they have system for which their BIOS level is such
    that this feature was not properly turned off.  As such, it would be good to
    give them a reminder that their systems are vulnurable to this problem.  For
    details of those that reported the problem, please see:
    https://bugzilla.redhat.com/show_bug.cgi?id=887006
    
    [ Joerg: Removed CONFIG_IRQ_REMAP ifdef from early-quirks.c ]
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Prarit Bhargava <prarit@redhat.com>
    CC: Don Zickus <dzickus@redhat.com>
    CC: Don Dutile <ddutile@redhat.com>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Asit Mallick <asit.k.mallick@intel.com>
    CC: David Woodhouse <dwmw2@infradead.org>
    CC: linux-pci@vger.kernel.org
    CC: Joerg Roedel <joro@8bytes.org>
    CC: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    CC: Arkadiusz Miśkiewicz <arekm@maven.pl>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 3755ef494390..94ab6b90dd3f 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -18,6 +18,7 @@
 #include <asm/apic.h>
 #include <asm/iommu.h>
 #include <asm/gart.h>
+#include <asm/irq_remapping.h>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
@@ -192,6 +193,21 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 }
 #endif
 
+static void __init intel_remapping_check(int num, int slot, int func)
+{
+	u8 revision;
+
+	revision = read_pci_config_byte(num, slot, func, PCI_REVISION_ID);
+
+	/*
+	 * Revision 0x13 of this chipset supports irq remapping
+	 * but has an erratum that breaks its behavior, flag it as such
+	 */
+	if (revision == 0x13)
+		set_irq_remapping_broken();
+
+}
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -221,6 +237,10 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
+	{ PCI_VENDOR_ID_INTEL, 0x3403, PCI_CLASS_BRIDGE_HOST,
+	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
+	{ PCI_VENDOR_ID_INTEL, 0x3406, PCI_CLASS_BRIDGE_HOST,
+	  PCI_BASE_CLASS_BRIDGE, 0, intel_remapping_check },
 	{}
 };
 

commit 1d3e09a304e6c4e004ca06356578b171e8735d3c
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Mar 15 15:31:37 2011 +0100

    x86, quirk: Fix SB600 revision check
    
    Commit 7f74f8f28a2bd9db9404f7d364e2097a0c42cc12
    (x86 quirk: Fix polarity for IRQ0 pin2 override on SB800
    systems) introduced a regression. It removed some SB600 specific
    code to determine the revision ID without adapting a
    corresponding revision ID check for SB600.
    
    See this mail thread:
    
      http://marc.info/?l=linux-kernel&m=129980296006380&w=2
    
    This patch adapts the corresponding check to cover all SB600
    revisions.
    
    Tested-by: Wang Lei <f3d27b@gmail.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: stable@kernel.org # 38.x, 37.x, 32.x
    LKML-Reference: <20110315143137.GD29499@alberich.amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 9efbdcc56425..3755ef494390 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -159,7 +159,12 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 	if (rev >= 0x40)
 		acpi_fix_pin2_polarity = 1;
 
-	if (rev > 0x13)
+	/*
+	 * SB600: revisions 0x11, 0x12, 0x13, 0x14, ...
+	 * SB700: revisions 0x39, 0x3a, ...
+	 * SB800: revisions 0x40, 0x41, ...
+	 */
+	if (rev >= 0x39)
 		return;
 
 	if (acpi_use_timer_override)

commit 7f74f8f28a2bd9db9404f7d364e2097a0c42cc12
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Thu Feb 24 15:53:46 2011 +0100

    x86 quirk: Fix polarity for IRQ0 pin2 override on SB800 systems
    
    On some SB800 systems polarity for IOAPIC pin2 is wrongly
    specified as low active by BIOS. This caused system hangs after
    resume from S3 when HPET was used in one-shot mode on such
    systems because a timer interrupt was missed (HPET signal is
    high active).
    
    For more details see:
    
      http://marc.info/?l=linux-kernel&m=129623757413868
    
    Tested-by: Manoj Iyer <manoj.iyer@canonical.com>
    Tested-by: Andre Przywara <andre.przywara@amd.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: stable@kernel.org # 37.x, 32.x
    LKML-Reference: <20110224145346.GD3658@alberich.amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 76b8cd953dee..9efbdcc56425 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -143,15 +143,10 @@ static void __init ati_bugs(int num, int slot, int func)
 
 static u32 __init ati_sbx00_rev(int num, int slot, int func)
 {
-	u32 old, d;
+	u32 d;
 
-	d = read_pci_config(num, slot, func, 0x70);
-	old = d;
-	d &= ~(1<<8);
-	write_pci_config(num, slot, func, 0x70, d);
 	d = read_pci_config(num, slot, func, 0x8);
 	d &= 0xff;
-	write_pci_config(num, slot, func, 0x70, old);
 
 	return d;
 }
@@ -160,13 +155,16 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 {
 	u32 d, rev;
 
-	if (acpi_use_timer_override)
-		return;
-
 	rev = ati_sbx00_rev(num, slot, func);
+	if (rev >= 0x40)
+		acpi_fix_pin2_polarity = 1;
+
 	if (rev > 0x13)
 		return;
 
+	if (acpi_use_timer_override)
+		return;
+
 	/* check for IRQ0 interrupt swap */
 	d = read_pci_config(num, slot, func, 0x64);
 	if (!(d & (1<<14)))

commit d60a2793ba562c6ea9bbf62112da3e6342adcf83
Merge: 781c5a67f152 40ffa9379198
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 13:18:06 2010 -0700

    Merge branch 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Remove stale pmtimer_64.c
      x86, cleanups: Use clear_page/copy_page rather than memset/memcpy
      x86: Remove unnecessary #ifdef ACPI/X86_IO_ACPI
      x86, cleanup: Remove obsolete boot_cpu_id variable

commit 54ff7e595d763d894104d421b103a89f7becf47c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 14 22:10:21 2010 +0200

    x86: hpet: Work around hardware stupidity
    
    This more or less reverts commits 08be979 (x86: Force HPET
    readback_cmp for all ATI chipsets) and 30a564be (x86, hpet: Restrict
    read back to affected ATI chipsets) to the status of commit 8da854c
    (x86, hpet: Erratum workaround for read after write of HPET
    comparator).
    
    The delta to commit 8da854c is mostly comments and the change from
    WARN_ONCE to printk_once as we know the call path of this function
    already.
    
    This needs really in depth explanation:
    
    First of all the HPET design is a complete failure. Having a counter
    compare register which generates an interrupt on matching values
    forces the software to do at least one superfluous readback of the
    counter register.
    
    While it is nice in theory to program "absolute" time events it is
    practically useless because the timer runs at some absurd frequency
    which can never be matched to real world units. So we are forced to
    calculate a relative delta and this forces a readout of the actual
    counter value, adding the delta and programming the compare
    register. When the delta is small enough we run into the danger that
    we program a compare value which is already in the past. Due to the
    compare for equal nature of HPET we need to read back the counter
    value after writing the compare rehgister (btw. this is necessary for
    absolute timeouts as well) to make sure that we did not miss the timer
    event. We try to work around that by setting the minimum delta to a
    value which is larger than the theoretical time which elapses between
    the counter readout and the compare register write, but that's only
    true in theory. A NMI or SMI which hits between the readout and the
    write can easily push us beyond that limit. This would result in
    waiting for the next HPET timer interrupt until the 32bit wraparound
    of the counter happens which takes about 306 seconds.
    
    So we designed the next event function to look like:
    
       match = read_cnt() + delta;
       write_compare_ref(match);
       return read_cnt() < match ? 0 : -ETIME;
    
    At some point we got into trouble with certain ATI chipsets. Even the
    above "safe" procedure failed. The reason was that the write to the
    compare register was delayed probably for performance reasons. The
    theory was that they wanted to avoid the synchronization of the write
    with the HPET clock, which is understandable. So the write does not
    hit the compare register directly instead it goes to some intermediate
    register which is copied to the real compare register in sync with the
    HPET clock. That opens another window for hitting the dreaded "wait
    for a wraparound" problem.
    
    To work around that "optimization" we added a read back of the compare
    register which either enforced the update of the just written value or
    just delayed the readout of the counter enough to avoid the issue. We
    unfortunately never got any affirmative info from ATI/AMD about this.
    
    One thing is sure, that we nuked the performance "optimization" that
    way completely and I'm pretty sure that the result is worse than
    before some HW folks came up with those.
    
    Just for paranoia reasons I added a check whether the read back
    compare register value was the same as the value we wrote right
    before. That paranoia check triggered a couple of years after it was
    added on an Intel ICH9 chipset. Venki added a workaround (commit
    8da854c) which was reading the compare register twice when the first
    check failed. We considered this to be a penalty in general and
    restricted the readback (thus the wasted CPU cycles) to the known to
    be affected ATI chipsets.
    
    This turned out to be a utterly wrong decision. 2.6.35 testers
    experienced massive problems and finally one of them bisected it down
    to commit 30a564be which spured some further investigation.
    
    Finally we got confirmation that the write to the compare register can
    be delayed by up to two HPET clock cycles which explains the problems
    nicely. All we can do about this is to go back to Venki's initial
    workaround in a slightly modified version.
    
    Just for the record I need to say, that all of this could have been
    avoided if hardware designers and of course the HPET committee would
    have thought about the consequences for a split second. It's out of my
    comprehension why designing a working timer is so hard. There are two
    ways to achieve it:
    
     1) Use a counter wrap around aware compare_reg <= counter_reg
        implementation instead of the easy compare_reg == counter_reg
    
        Downsides:
    
            - It needs more silicon.
    
            - It needs a readout of the counter to apply a relative
              timeout. This is necessary as the counter does not run in
              any useful (and adjustable) frequency and there is no
              guarantee that the counter which is used for timer events is
              the same which is used for reading the actual time (and
              therefor for calculating the delta)
    
        Upsides:
    
            - None
    
      2) Use a simple down counter for relative timer events
    
        Downsides:
    
            - Absolute timeouts are not possible, which is not a problem
              at all in the context of an OS and the expected
              max. latencies/jitter (also see Downsides of #1)
    
       Upsides:
    
            - It needs less or equal silicon.
    
            - It works ALWAYS
    
            - It is way faster than a compare register based solution (One
              write versus one write plus at least one and up to four
              reads)
    
    I would not be so grumpy about all of this, if I would not have been
    ignored for many years when pointing out these flaws to various
    hardware folks. I really hate timers (at least those which seem to be
    designed by janitors).
    
    Though finally we got a reasonable explanation plus a solution and I
    want to thank all the folks involved in chasing it down and providing
    valuable input to this.
    
    Bisected-by: Nix <nix@esperi.org.uk>
    Reported-by: Artur Skawina <art.08.09@gmail.com>
    Reported-by: Damien Wyart <damien.wyart@free.fr>
    Reported-by: John Drescher <drescherjm@gmail.com>
    Cc: Venkatesh Pallipadi <venki@google.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Andreas Herrmann <andreas.herrmann3@amd.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: stable@kernel.org
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index e5cc7e82e60d..ebdb85cf2686 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -18,7 +18,6 @@
 #include <asm/apic.h>
 #include <asm/iommu.h>
 #include <asm/gart.h>
-#include <asm/hpet.h>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
@@ -192,21 +191,6 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 }
 #endif
 
-/*
- * Force the read back of the CMP register in hpet_next_event()
- * to work around the problem that the CMP register write seems to be
- * delayed. See hpet_next_event() for details.
- *
- * We do this on all SMBUS incarnations for now until we have more
- * information about the affected chipsets.
- */
-static void __init ati_hpet_bugs(int num, int slot, int func)
-{
-#ifdef CONFIG_HPET_TIMER
-	hpet_readback_cmp = 1;
-#endif
-}
-
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -236,8 +220,6 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
-	{ PCI_VENDOR_ID_ATI, PCI_ANY_ID,
-	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_hpet_bugs },
 	{}
 };
 

commit 0f1cf415f00286a38f5ce35b459342dbfc895b50
Author: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
Date:   Mon Sep 6 16:36:18 2010 +0200

    x86: Remove unnecessary #ifdef ACPI/X86_IO_ACPI
    
    The ACPI/X86_IO_ACPI ifdef isn't necessary at this point,
    because it is checked in an outer ifdef level already and has no
    effect here.
    
    Cleanup only, no functional effect.
    
    Signed-off-by: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>
    Cc: vamos-dev@i4.informatik.uni-erlangen.de
    LKML-Reference: <d4376e6d79b8dc0f89a4b3ce4a880904a7b93ead.1283782701.git.qy03fugy@stud.informatik.uni-erlangen.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index e5cc7e82e60d..e4bd78c160d8 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -97,7 +97,6 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
-#if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)
 #if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)
 static u32 __init ati_ixp4x0_rev(int num, int slot, int func)
 {
@@ -116,7 +115,6 @@ static u32 __init ati_ixp4x0_rev(int num, int slot, int func)
 	d &= 0xff;
 	return d;
 }
-#endif
 
 static void __init ati_bugs(int num, int slot, int func)
 {

commit 08be97962bf338161325d4901642f956ce8c1adb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 14 21:36:27 2010 +0200

    x86: Force HPET readback_cmp for all ATI chipsets
    
    commit 30a564be (x86, hpet: Restrict read back to affected ATI
    chipset) restricted the workaround for the HPET bug to SMX00
    chipsets. This was reasonable as those were the only ones against
    which we ever got a bug report.
    
    Stephan Wolf reported now that this patch breaks his IXP400 based
    machine. Though it's confirmed to work on other IXP400 based systems.
    
    To error out on the safe side, we force the HPET readback workaround
    for all ATI SMbus class chipsets.
    
    Reported-by: Stephan Wolf <stephan@letzte-bankreihe.de>
    LKML-Reference: <alpine.LFD.2.00.1007142134140.3321@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Stephan Wolf <stephan@letzte-bankreihe.de>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index ebdb85cf2686..e5cc7e82e60d 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -18,6 +18,7 @@
 #include <asm/apic.h>
 #include <asm/iommu.h>
 #include <asm/gart.h>
+#include <asm/hpet.h>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
@@ -191,6 +192,21 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 }
 #endif
 
+/*
+ * Force the read back of the CMP register in hpet_next_event()
+ * to work around the problem that the CMP register write seems to be
+ * delayed. See hpet_next_event() for details.
+ *
+ * We do this on all SMBUS incarnations for now until we have more
+ * information about the affected chipsets.
+ */
+static void __init ati_hpet_bugs(int num, int slot, int func)
+{
+#ifdef CONFIG_HPET_TIMER
+	hpet_readback_cmp = 1;
+#endif
+}
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -220,6 +236,8 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
+	{ PCI_VENDOR_ID_ATI, PCI_ANY_ID,
+	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_hpet_bugs },
 	{}
 };
 

commit a59dacfdc9ba06903652fa4883bf1106278b18ec
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Oct 17 14:38:08 2008 +0200

    x86 early quirks: eliminate unused function
    
    Impact: cleanup
    
    this warning:
    
      arch/x86/kernel/early-quirks.c:99: warning: ‘ati_ixp4x0_rev’ defined but not used
    
    triggers because ati_ixp4x0_rev() is only used in the
    ACPI && X86_IO_APIC case.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 76b8cd953dee..ebdb85cf2686 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -96,6 +96,7 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
+#if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)
 #if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)
 static u32 __init ati_ixp4x0_rev(int num, int slot, int func)
 {
@@ -114,6 +115,7 @@ static u32 __init ati_ixp4x0_rev(int num, int slot, int func)
 	d &= 0xff;
 	return d;
 }
+#endif
 
 static void __init ati_bugs(int num, int slot, int func)
 {

commit 8659c406ade32f47da2c95889094801921d6330a
Author: Andi Kleen <andi@firstfloor.org>
Date:   Fri Jan 9 12:17:39 2009 -0800

    x86: only scan the root bus in early PCI quirks
    
    We found a situation on Linus' machine that the Nvidia timer quirk hit on
    a Intel chipset system.  The problem is that the system has a fancy Nvidia
    card with an own PCI bridge, and the early-quirks code looking for any
    NVidia bridge triggered on it incorrectly.  This didn't lead a boot
    failure by luck, but the timer routing code selecting the wrong timer
    first and some ugly messages.  It might lead to real problems on other
    systems.
    
    I checked all the devices which are currently checked for by early_quirks
    and it turns out they are all located in the root bus zero.
    
    So change the early-quirks loop to only scan bus 0.  This incidently also
    saves quite some unnecessary scanning work, because early_quirks doesn't
    go through all the non root busses.
    
    The graphics card is not on bus 0, so it is not matched anymore.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 744aa7fc49d5..76b8cd953dee 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -201,6 +201,12 @@ struct chipset {
 	void (*f)(int num, int slot, int func);
 };
 
+/*
+ * Only works for devices on the root bus. If you add any devices
+ * not on bus 0 readd another loop level in early_quirks(). But
+ * be careful because at least the Nvidia quirk here relies on
+ * only matching on bus 0.
+ */
 static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
@@ -267,17 +273,17 @@ static int __init check_dev_quirk(int num, int slot, int func)
 
 void __init early_quirks(void)
 {
-	int num, slot, func;
+	int slot, func;
 
 	if (!early_pci_allowed())
 		return;
 
 	/* Poor man's PCI discovery */
-	for (num = 0; num < 32; num++)
-		for (slot = 0; slot < 32; slot++)
-			for (func = 0; func < 8; func++) {
-				/* Only probe function 0 on single fn devices */
-				if (check_dev_quirk(num, slot, func))
-					break;
-			}
+	/* Only scan the root bus */
+	for (slot = 0; slot < 32; slot++)
+		for (func = 0; func < 8; func++) {
+			/* Only probe function 0 on single fn devices */
+			if (check_dev_quirk(0, slot, func))
+				break;
+		}
 }

commit 1d9b16d1690fe5edb1c907fe4746681cf026cdf3
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Thu Nov 27 18:39:15 2008 +0100

    x86: move GART specific stuff from iommu.h to gart.h
    
    Impact: cleanup
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 1b894b72c0f5..744aa7fc49d5 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -17,6 +17,7 @@
 #include <asm/io_apic.h>
 #include <asm/apic.h>
 #include <asm/iommu.h>
+#include <asm/gart.h>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {

commit 52168e60f7d86d83124903098ac8c2dba93cd1c4
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri Nov 14 13:47:31 2008 +0000

    Revert "x86: blacklist DMAR on Intel G31/G33 chipsets"
    
    This reverts commit e51af6630848406fc97adbd71443818cdcda297b, which was
    wrongly hoovered up and submitted about a month after a better fix had
    already been merged.
    
    The better fix is commit cbda1ba898647aeb4ee770b803c922f595e97731
    ("PCI/iommu: blacklist DMAR on Intel G31/G33 chipsets"), where we do
    this blacklisting based on the DMI identification for the offending
    motherboard, since sometimes this chipset (or at least a chipset with
    the same PCI ID) apparently _does_ actually have an IOMMU.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 3ce029ffaa55..1b894b72c0f5 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -188,20 +188,6 @@ static void __init ati_bugs_contd(int num, int slot, int func)
 }
 #endif
 
-#ifdef CONFIG_DMAR
-static void __init intel_g33_dmar(int num, int slot, int func)
-{
-	struct acpi_table_header *dmar_tbl;
-	acpi_status status;
-
-	status = acpi_get_table(ACPI_SIG_DMAR, 0, &dmar_tbl);
-	if (ACPI_SUCCESS(status)) {
-		printk(KERN_INFO "BIOS BUG: DMAR advertised on Intel G31/G33 chipset -- ignoring\n");
-		dmar_disabled = 1;
-	}
-}
-#endif
-
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -225,10 +211,6 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
-#ifdef CONFIG_DMAR
-	{ PCI_VENDOR_ID_INTEL, 0x29c0,
-	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, intel_g33_dmar },
-#endif
 	{}
 };
 

commit 26adcfbf00e0726b4469070aa2f530dcf963f484
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 14 21:01:15 2008 +0200

    x86: SB600: skip ACPI IRQ0 override if it is not routed to INT2 of IOAPIC
    
    On some more HP laptops BIOS reports an IRQ0 override
    but the SB600 chipset is configured such that timer
    interrupts go to INT0 of IOAPIC.
    
    Check IRQ0 routing and if it is routed to INT0 of IOAPIC skip the
    timer override.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=11715
    http://bugzilla.kernel.org/show_bug.cgi?id=11516
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 733c4f8d42ea..3ce029ffaa55 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -95,7 +95,8 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
-static u32 ati_ixp4x0_rev(int num, int slot, int func)
+#if defined(CONFIG_ACPI) && defined(CONFIG_X86_IO_APIC)
+static u32 __init ati_ixp4x0_rev(int num, int slot, int func)
 {
 	u32 d;
 	u8  b;
@@ -115,7 +116,6 @@ static u32 ati_ixp4x0_rev(int num, int slot, int func)
 
 static void __init ati_bugs(int num, int slot, int func)
 {
-#if defined(CONFIG_ACPI) && defined (CONFIG_X86_IO_APIC)
 	u32 d;
 	u8  b;
 
@@ -138,9 +138,56 @@ static void __init ati_bugs(int num, int slot, int func)
 		printk(KERN_INFO "If you got timer trouble "
 		       "try acpi_use_timer_override\n");
 	}
-#endif
 }
 
+static u32 __init ati_sbx00_rev(int num, int slot, int func)
+{
+	u32 old, d;
+
+	d = read_pci_config(num, slot, func, 0x70);
+	old = d;
+	d &= ~(1<<8);
+	write_pci_config(num, slot, func, 0x70, d);
+	d = read_pci_config(num, slot, func, 0x8);
+	d &= 0xff;
+	write_pci_config(num, slot, func, 0x70, old);
+
+	return d;
+}
+
+static void __init ati_bugs_contd(int num, int slot, int func)
+{
+	u32 d, rev;
+
+	if (acpi_use_timer_override)
+		return;
+
+	rev = ati_sbx00_rev(num, slot, func);
+	if (rev > 0x13)
+		return;
+
+	/* check for IRQ0 interrupt swap */
+	d = read_pci_config(num, slot, func, 0x64);
+	if (!(d & (1<<14)))
+		acpi_skip_timer_override = 1;
+
+	if (acpi_skip_timer_override) {
+		printk(KERN_INFO "SB600 revision 0x%x\n", rev);
+		printk(KERN_INFO "Ignoring ACPI timer override.\n");
+		printk(KERN_INFO "If you got timer trouble "
+		       "try acpi_use_timer_override\n");
+	}
+}
+#else
+static void __init ati_bugs(int num, int slot, int func)
+{
+}
+
+static void __init ati_bugs_contd(int num, int slot, int func)
+{
+}
+#endif
+
 #ifdef CONFIG_DMAR
 static void __init intel_g33_dmar(int num, int slot, int func)
 {
@@ -176,6 +223,8 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
+	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
 #ifdef CONFIG_DMAR
 	{ PCI_VENDOR_ID_INTEL, 0x29c0,
 	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, intel_g33_dmar },

commit acbaa41a780490c791492c41144c774c04875af1
Merge: 8d89adf44cf7 fd0480883066
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Oct 12 12:43:21 2008 +0200

    Merge branch 'linus' into x86/quirks
    
    Conflicts:
            arch/x86/kernel/early-quirks.c

commit 33fb0e4eb53f16af312f9698f974e2e64af39c12
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 7 00:11:22 2008 +0200

    x86: SB450: skip IRQ0 override if it is not routed to INT2 of IOAPIC
    
    On some HP nx6... laptops (e.g. nx6325) BIOS reports an IRQ0 override
    but the SB450 chipset is configured such that timer interrupts goe to
    INT0 of IOAPIC.
    
    Check IRQ0 routing and if it is routed to INT0 of IOAPIC skip the
    timer override.
    
    [ This more generic PCI ID based quirk should alleviate the need for
      dmi_ignore_irq0_timer_override DMI quirks. ]
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Acked-by: "Maciej W. Rozycki" <macro@linux-mips.org>
    Tested-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 4353cf5e6fac..6b839b147644 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -95,6 +95,52 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
+static u32 ati_ixp4x0_rev(int num, int slot, int func)
+{
+	u32 d;
+	u8  b;
+
+	b = read_pci_config_byte(num, slot, func, 0xac);
+	b &= ~(1<<5);
+	write_pci_config_byte(num, slot, func, 0xac, b);
+
+	d = read_pci_config(num, slot, func, 0x70);
+	d |= 1<<8;
+	write_pci_config(num, slot, func, 0x70, d);
+
+	d = read_pci_config(num, slot, func, 0x8);
+	d &= 0xff;
+	return d;
+}
+
+static void __init ati_bugs(int num, int slot, int func)
+{
+#if defined(CONFIG_ACPI) && defined (CONFIG_X86_IO_APIC)
+	u32 d;
+	u8  b;
+
+	if (acpi_use_timer_override)
+		return;
+
+	d = ati_ixp4x0_rev(num, slot, func);
+	if (d  < 0x82)
+		acpi_skip_timer_override = 1;
+	else {
+		/* check for IRQ0 interrupt swap */
+		outb(0x72, 0xcd6); b = inb(0xcd7);
+		if (!(b & 0x2))
+			acpi_skip_timer_override = 1;
+	}
+
+	if (acpi_skip_timer_override) {
+		printk(KERN_INFO "SB4X0 revision 0x%x\n", d);
+		printk(KERN_INFO "Ignoring ACPI timer override.\n");
+		printk(KERN_INFO "If you got timer trouble "
+		       "try acpi_use_timer_override\n");
+	}
+#endif
+}
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -114,6 +160,8 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, via_bugs },
 	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,
 	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_SMBUS,
+	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{}
 };
 

commit e51af6630848406fc97adbd71443818cdcda297b
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Sep 4 09:54:37 2008 +0100

    x86: blacklist DMAR on Intel G31/G33 chipsets
    
    Some BIOSes (the Intel DG33BU, for example) wrongly claim to have DMAR
    when they don't. Avoid the resulting crashes when it doesn't work as
    expected.
    
    I'd still be grateful if someone could test it on a DG33BU with the old
    BIOS though, since I've killed mine. I tested the DMI version, but not
    this one.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 4353cf5e6fac..24bb5faf5efa 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -95,6 +95,20 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
+#ifdef CONFIG_DMAR
+static void __init intel_g33_dmar(int num, int slot, int func)
+{
+	struct acpi_table_header *dmar_tbl;
+	acpi_status status;
+
+	status = acpi_get_table(ACPI_SIG_DMAR, 0, &dmar_tbl);
+	if (ACPI_SUCCESS(status)) {
+		printk(KERN_INFO "BIOS BUG: DMAR advertised on Intel G31/G33 chipset -- ignoring\n");
+		dmar_disabled = 1;
+	}
+}
+#endif
+
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -114,6 +128,10 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, via_bugs },
 	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,
 	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },
+#ifdef CONFIG_DMAR
+	{ PCI_VENDOR_ID_INTEL, 0x29c0,
+	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, intel_g33_dmar },
+#endif
 	{}
 };
 

commit acee709cab689ec7703770e8b8cb5cc3a4abcb31
Merge: 33a37eb411d1 5ff4789d045c 35b680557f95 c4dc59ae7af8 7edf8891ad7a 9781f39fd209 48fe4a76e27d be54f9d1c8df 77e442461c74 caadbdce240c 5e5a29bf2624 e3a61b0a8c0e fec0962e0bed fab3b58d3b24 f2ba93929fdb 48ae74443403 3cabf37f6167 7019cc2dd6fa 2ddf9b7b3e66 e66d90fb4abd
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 21 16:37:17 2008 +0200

    Merge branches 'x86/urgent', 'x86/amd-iommu', 'x86/apic', 'x86/cleanups', 'x86/core', 'x86/cpu', 'x86/fixmap', 'x86/gart', 'x86/kprobes', 'x86/memtest', 'x86/modules', 'x86/nmi', 'x86/pat', 'x86/reboot', 'x86/setup', 'x86/step', 'x86/unify-pci', 'x86/uv', 'x86/xen' and 'xen-64bit' into x86/for-linus

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit 46a7fa270afbe5fddc6042a598cfe22977b0e989
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Jul 11 10:23:42 2008 +0900

    x86: make only GART code include gart.h
    
    gart.h has only GART-specific stuff. Only GART code needs it. Other
    IOMMU stuff should include iommu.h instead of gart.h.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Muli Ben-Yehuda <muli@il.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index a4665f37cfc5..510b8e367732 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -16,10 +16,7 @@
 #include <asm/dma.h>
 #include <asm/io_apic.h>
 #include <asm/apic.h>
-
-#ifdef CONFIG_GART_IOMMU
-#include <asm/gart.h>
-#endif
+#include <asm/iommu.h>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {

commit c987d12f8455b19b3b057d63bac3de161bd809fc
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 24 22:14:09 2008 -0700

    x86: remove end_pfn in 64bit
    
    and use max_pfn directly.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 84fd9f2a28ff..a4665f37cfc5 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -50,7 +50,7 @@ static void __init fix_hypertransport_config(int num, int slot, int func)
 static void __init via_bugs(int  num, int slot, int func)
 {
 #ifdef CONFIG_GART_IOMMU
-	if ((end_pfn > MAX_DMA32_PFN ||  force_iommu) &&
+	if ((max_pfn > MAX_DMA32_PFN ||  force_iommu) &&
 	    !gart_iommu_aperture_allowed) {
 		printk(KERN_INFO
 		       "Looks like a VIA chipset. Disabling IOMMU."

commit ecd29476ae0143b1c3641edfa76c0fc3e9ad3021
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed May 21 22:09:19 2008 +0100

    x86: I/O APIC: remove parameters to fiddle with the 8259A
    
    Remove the "disable_8254_timer" and "enable_8254_timer" kernel
    parameters.  Now that AEOI acknowledgements are no longer needed for
    correct timer operation, the 8259A can be kept disabled unconditionally
    unless interrupts, either timer or watchdog ones, are actually passed
    through it.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 9f51e1ea9e82..84fd9f2a28ff 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -98,17 +98,6 @@ static void __init nvidia_bugs(int num, int slot, int func)
 
 }
 
-static void __init ati_bugs(int num, int slot, int func)
-{
-#ifdef CONFIG_X86_IO_APIC
-	if (timer_over_8254 == 1) {
-		timer_over_8254 = 0;
-		printk(KERN_INFO
-		"ATI board detected. Disabling timer routing over 8254.\n");
-	}
-#endif
-}
-
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
@@ -126,8 +115,6 @@ static struct chipset early_qrk[] __initdata = {
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
 	{ PCI_VENDOR_ID_VIA, PCI_ANY_ID,
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, via_bugs },
-	{ PCI_VENDOR_ID_ATI, PCI_ANY_ID,
-	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, ati_bugs },
 	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,
 	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },
 	{}

commit 15650a2f644a2f15738cf22807c090d89328f500
Author: Jesse Barnes <jbarnes@hobbes.lan>
Date:   Mon Jun 16 15:29:45 2008 -0700

    x86/PCI: fixup early quirk probing
    
    On x86, we do early PCI probing to apply some quirks for chipset bugs.
    However, in a recent cleanup (7bcbc78dea92fdf0947fa48e248da3c993a5690f) a
    thinko was introduced that causes us to probe all subfunctions of even single
    function devices (a function was factored out of an inner loop and a "break"
    became a "return").  Fix that up by making check_dev_quirk() return a value so
    we can keep the factored code intact.
    
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 9f51e1ea9e82..8566fea647eb 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -133,7 +133,18 @@ static struct chipset early_qrk[] __initdata = {
 	{}
 };
 
-static void __init check_dev_quirk(int num, int slot, int func)
+/**
+ * check_dev_quirk - apply early quirks to a given PCI device
+ * @num: bus number
+ * @slot: slot number
+ * @func: PCI function
+ *
+ * Check the vendor & device ID against the early quirks table.
+ *
+ * If the device is single function, let early_quirks() know so we don't
+ * poke at this device again.
+ */
+static int __init check_dev_quirk(int num, int slot, int func)
 {
 	u16 class;
 	u16 vendor;
@@ -144,7 +155,7 @@ static void __init check_dev_quirk(int num, int slot, int func)
 	class = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);
 
 	if (class == 0xffff)
-		return;
+		return -1; /* no class, treat as single function */
 
 	vendor = read_pci_config_16(num, slot, func, PCI_VENDOR_ID);
 
@@ -167,7 +178,9 @@ static void __init check_dev_quirk(int num, int slot, int func)
 	type = read_pci_config_byte(num, slot, func,
 				    PCI_HEADER_TYPE);
 	if (!(type & 0x80))
-		return;
+		return -1;
+
+	return 0;
 }
 
 void __init early_quirks(void)
@@ -180,6 +193,9 @@ void __init early_quirks(void)
 	/* Poor man's PCI discovery */
 	for (num = 0; num < 32; num++)
 		for (slot = 0; slot < 32; slot++)
-			for (func = 0; func < 8; func++)
-				check_dev_quirk(num, slot, func);
+			for (func = 0; func < 8; func++) {
+				/* Only probe function 0 on single fn devices */
+				if (check_dev_quirk(num, slot, func))
+					break;
+			}
 }

commit 85b74d6c119a7dae882569e57925eaafecc07859
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jan 30 13:33:37 2008 +0100

    x86: fix section mismatch warning in early-quirks.c
    
    Fix following warnings:
    WARNING: arch/x86/kernel/built-in.o(.text+0x139e1): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x139f5): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x13a0c): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x13a12): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x13a1a): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x13a36): Section mismatch: reference to .init.data:early_qrk in 'check_dev_quirk'
    WARNING: arch/x86/kernel/built-in.o(.text+0x13a42): Section mismatch: reference to .init.data:
    
    Warning was caused by access to the __initdata annotated variable
    from the non-annotated static function check_dev_quirk().
    check_dev_quirk() were only used from a function annotated
    __init so add __init annotation to check_dev_quirk() to fix it.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 3f88e437e843..9f51e1ea9e82 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -133,7 +133,7 @@ static struct chipset early_qrk[] __initdata = {
 	{}
 };
 
-static void check_dev_quirk(int num, int slot, int func)
+static void __init check_dev_quirk(int num, int slot, int func)
 {
 	u16 class;
 	u16 vendor;

commit 7bcbc78dea92fdf0947fa48e248da3c993a5690f
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jan 30 13:31:26 2008 +0100

    x86: clean up arch/x86/kernel/early-quirks.c
    
    clean up checkpatch errors. No code changed.
    
          text    data     bss     dec     hex filename
           705     120       0     825     339 early-quirks.o.before
           705     120       0     825     339 early-quirks.o.after
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index b55258e49208..3f88e437e843 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -32,10 +32,13 @@ static void __init fix_hypertransport_config(int num, int slot, int func)
 	 */
 	htcfg = read_pci_config(num, slot, func, 0x68);
 	if (htcfg & (1 << 18)) {
-		printk(KERN_INFO "Detected use of extended apic ids on hypertransport bus\n");
+		printk(KERN_INFO "Detected use of extended apic ids "
+				 "on hypertransport bus\n");
 		if ((htcfg & (1 << 17)) == 0) {
-			printk(KERN_INFO "Enabling hypertransport extended apic interrupt broadcast\n");
-			printk(KERN_INFO "Note this is a bios bug, please contact your hw vendor\n");
+			printk(KERN_INFO "Enabling hypertransport extended "
+					 "apic interrupt broadcast\n");
+			printk(KERN_INFO "Note this is a bios bug, "
+					 "please contact your hw vendor\n");
 			htcfg |= (1 << 17);
 			write_pci_config(num, slot, func, 0x68, htcfg);
 		}
@@ -130,6 +133,43 @@ static struct chipset early_qrk[] __initdata = {
 	{}
 };
 
+static void check_dev_quirk(int num, int slot, int func)
+{
+	u16 class;
+	u16 vendor;
+	u16 device;
+	u8 type;
+	int i;
+
+	class = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);
+
+	if (class == 0xffff)
+		return;
+
+	vendor = read_pci_config_16(num, slot, func, PCI_VENDOR_ID);
+
+	device = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);
+
+	for (i = 0; early_qrk[i].f != NULL; i++) {
+		if (((early_qrk[i].vendor == PCI_ANY_ID) ||
+			(early_qrk[i].vendor == vendor)) &&
+			((early_qrk[i].device == PCI_ANY_ID) ||
+			(early_qrk[i].device == device)) &&
+			(!((early_qrk[i].class ^ class) &
+			    early_qrk[i].class_mask))) {
+				if ((early_qrk[i].flags &
+				     QFLAG_DONE) != QFLAG_DONE)
+					early_qrk[i].f(num, slot, func);
+				early_qrk[i].flags |= QFLAG_APPLIED;
+			}
+	}
+
+	type = read_pci_config_byte(num, slot, func,
+				    PCI_HEADER_TYPE);
+	if (!(type & 0x80))
+		return;
+}
+
 void __init early_quirks(void)
 {
 	int num, slot, func;
@@ -138,45 +178,8 @@ void __init early_quirks(void)
 		return;
 
 	/* Poor man's PCI discovery */
-	for (num = 0; num < 32; num++) {
-		for (slot = 0; slot < 32; slot++) {
-			for (func = 0; func < 8; func++) {
-				u16 class;
-				u16 vendor;
-				u16 device;
-				u8 type;
-				int i;
-
-				class = read_pci_config_16(num,slot,func,
-							PCI_CLASS_REVISION);
-				if (class == 0xffff)
-					break;
-
-				vendor = read_pci_config_16(num, slot, func,
-							 PCI_VENDOR_ID);
-
-				device = read_pci_config_16(num, slot, func,
-							PCI_DEVICE_ID);
-
-				for(i=0;early_qrk[i].f != NULL;i++) {
-					if (((early_qrk[i].vendor == PCI_ANY_ID) ||
-					    (early_qrk[i].vendor == vendor)) &&
-					   ((early_qrk[i].device == PCI_ANY_ID) ||
-					    (early_qrk[i].device == device)) &&
-					   (!((early_qrk[i].class ^ class) &
-					     early_qrk[i].class_mask))) {
-						if ((early_qrk[i].flags & QFLAG_DONE) != QFLAG_DONE)
-							early_qrk[i].f(num, slot, func);
-						early_qrk[i].flags |= QFLAG_APPLIED;
-
-					}
-				}
-
-				type = read_pci_config_byte(num, slot, func,
-							    PCI_HEADER_TYPE);
-				if (!(type & 0x80))
-					break;
-			}
-		}
-	}
+	for (num = 0; num < 32; num++)
+		for (slot = 0; slot < 32; slot++)
+			for (func = 0; func < 8; func++)
+				check_dev_quirk(num, slot, func);
 }

commit c6b48324325ffb637c3aafb2d795408febf40198
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jan 30 13:31:25 2008 +0100

    x86, kexec: force x86 arches to boot kdump kernels on boot cpu
    
    Recently a kdump bug was discovered in which a system would hang inside
    calibrate_delay during the booting of the kdump kernel.  This was caused
    by the fact that the jiffies counter was not being incremented during
    timer calibration.  The root cause of this problem was found to be a
    bios misconfiguration of the hypertransport bus.  On system affected by
    this hang, the bios had assigned APIC ids which used extended apic bits
    (more than the nominal 4 bit ids's), but failed to configure bit 17 of
    the hypertransport transaction config register, which indicated that the
    mask for the destination field of interrupt packets accross the ht bus
    (see section 3.3.9 of
    http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/26094.PDF).
    If a crash occurs on a cpu with an APIC id that extends beyond 4 bits,
    it will not recieve interrupts during the kdump kernel boot, and this
    hang will be the result.  The fix is to add this patch, whcih add an
    early pci quirk check, to forcibly enable this bit in the httcfg
    register.  This enables all cpus on a system to receive interrupts, and
    allows kdump kernel bootup to procede normally.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 88bb83ec895f..b55258e49208 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -21,7 +21,30 @@
 #include <asm/gart.h>
 #endif
 
-static void __init via_bugs(void)
+static void __init fix_hypertransport_config(int num, int slot, int func)
+{
+	u32 htcfg;
+	/*
+	 * we found a hypertransport bus
+	 * make sure that we are broadcasting
+	 * interrupts to all cpus on the ht bus
+	 * if we're using extended apic ids
+	 */
+	htcfg = read_pci_config(num, slot, func, 0x68);
+	if (htcfg & (1 << 18)) {
+		printk(KERN_INFO "Detected use of extended apic ids on hypertransport bus\n");
+		if ((htcfg & (1 << 17)) == 0) {
+			printk(KERN_INFO "Enabling hypertransport extended apic interrupt broadcast\n");
+			printk(KERN_INFO "Note this is a bios bug, please contact your hw vendor\n");
+			htcfg |= (1 << 17);
+			write_pci_config(num, slot, func, 0x68, htcfg);
+		}
+	}
+
+
+}
+
+static void __init via_bugs(int  num, int slot, int func)
 {
 #ifdef CONFIG_GART_IOMMU
 	if ((end_pfn > MAX_DMA32_PFN ||  force_iommu) &&
@@ -44,7 +67,7 @@ static int __init nvidia_hpet_check(struct acpi_table_header *header)
 #endif /* CONFIG_X86_IO_APIC */
 #endif /* CONFIG_ACPI */
 
-static void __init nvidia_bugs(void)
+static void __init nvidia_bugs(int num, int slot, int func)
 {
 #ifdef CONFIG_ACPI
 #ifdef CONFIG_X86_IO_APIC
@@ -72,7 +95,7 @@ static void __init nvidia_bugs(void)
 
 }
 
-static void __init ati_bugs(void)
+static void __init ati_bugs(int num, int slot, int func)
 {
 #ifdef CONFIG_X86_IO_APIC
 	if (timer_over_8254 == 1) {
@@ -83,15 +106,27 @@ static void __init ati_bugs(void)
 #endif
 }
 
+#define QFLAG_APPLY_ONCE 	0x1
+#define QFLAG_APPLIED		0x2
+#define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
 struct chipset {
-	u16 vendor;
-	void (*f)(void);
+	u32 vendor;
+	u32 device;
+	u32 class;
+	u32 class_mask;
+	u32 flags;
+	void (*f)(int num, int slot, int func);
 };
 
 static struct chipset early_qrk[] __initdata = {
-	{ PCI_VENDOR_ID_NVIDIA, nvidia_bugs },
-	{ PCI_VENDOR_ID_VIA, via_bugs },
-	{ PCI_VENDOR_ID_ATI, ati_bugs },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
+	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
+	{ PCI_VENDOR_ID_VIA, PCI_ANY_ID,
+	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, via_bugs },
+	{ PCI_VENDOR_ID_ATI, PCI_ANY_ID,
+	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, ati_bugs },
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB,
+	  PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, fix_hypertransport_config },
 	{}
 };
 
@@ -106,27 +141,36 @@ void __init early_quirks(void)
 	for (num = 0; num < 32; num++) {
 		for (slot = 0; slot < 32; slot++) {
 			for (func = 0; func < 8; func++) {
-				u32 class;
-				u32 vendor;
+				u16 class;
+				u16 vendor;
+				u16 device;
 				u8 type;
 				int i;
-				class = read_pci_config(num,slot,func,
+
+				class = read_pci_config_16(num,slot,func,
 							PCI_CLASS_REVISION);
-				if (class == 0xffffffff)
+				if (class == 0xffff)
 					break;
 
-				if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
-					continue;
-
-				vendor = read_pci_config(num, slot, func,
+				vendor = read_pci_config_16(num, slot, func,
 							 PCI_VENDOR_ID);
-				vendor &= 0xffff;
 
-				for (i = 0; early_qrk[i].f; i++)
-					if (early_qrk[i].vendor == vendor) {
-						early_qrk[i].f();
-						return;
+				device = read_pci_config_16(num, slot, func,
+							PCI_DEVICE_ID);
+
+				for(i=0;early_qrk[i].f != NULL;i++) {
+					if (((early_qrk[i].vendor == PCI_ANY_ID) ||
+					    (early_qrk[i].vendor == vendor)) &&
+					   ((early_qrk[i].device == PCI_ANY_ID) ||
+					    (early_qrk[i].device == device)) &&
+					   (!((early_qrk[i].class ^ class) &
+					     early_qrk[i].class_mask))) {
+						if ((early_qrk[i].flags & QFLAG_DONE) != QFLAG_DONE)
+							early_qrk[i].f(num, slot, func);
+						early_qrk[i].flags |= QFLAG_APPLIED;
+
 					}
+				}
 
 				type = read_pci_config_byte(num, slot, func,
 							    PCI_HEADER_TYPE);

commit 0440d4c00dadf8b97657c0864e4d54a088430de8
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Wed Oct 24 12:49:50 2007 +0200

    x86 gart: rename symbols only used for the GART implementation
    
    This patch renames the 4 symbols iommu_hole_init(), iommu_aperture,
    iommu_aperture_allowed, iommu_aperture_disabled. All these symbols are only
    used for the GART implementation of IOMMUs.
    
    It adds and additional gart_ prefix to them.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index b8265c1ea0d3..88bb83ec895f 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -25,11 +25,11 @@ static void __init via_bugs(void)
 {
 #ifdef CONFIG_GART_IOMMU
 	if ((end_pfn > MAX_DMA32_PFN ||  force_iommu) &&
-	    !iommu_aperture_allowed) {
+	    !gart_iommu_aperture_allowed) {
 		printk(KERN_INFO
 		       "Looks like a VIA chipset. Disabling IOMMU."
 		       " Override with iommu=allowed\n");
-		iommu_aperture_disabled = 1;
+		gart_iommu_aperture_disabled = 1;
 	}
 #endif
 }

commit 966396d3a05c8049fce5c81c49138e5ee1b05443
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Wed Oct 24 12:49:48 2007 +0200

    x86 gart: rename CONFIG_IOMMU to CONFIG_GART_IOMMU
    
    This patch renames the IOMMU config option to GART_IOMMU because in fact it
    means the GART and not general support for an IOMMU on x86.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Muli Ben-Yehuda <muli@il.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 95e0de9a4e4b..b8265c1ea0d3 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -17,13 +17,13 @@
 #include <asm/io_apic.h>
 #include <asm/apic.h>
 
-#ifdef CONFIG_IOMMU
+#ifdef CONFIG_GART_IOMMU
 #include <asm/gart.h>
 #endif
 
 static void __init via_bugs(void)
 {
-#ifdef CONFIG_IOMMU
+#ifdef CONFIG_GART_IOMMU
 	if ((end_pfn > MAX_DMA32_PFN ||  force_iommu) &&
 	    !iommu_aperture_allowed) {
 		printk(KERN_INFO

commit 395624fcddd178de01a78aa88670a86ec919de77
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Wed Oct 24 12:49:47 2007 +0200

    x86 gart: rename iommu.h to gart.h
    
    This patch renames the include file asm-x86/iommu.h to asm-x86/gart.h to make
    clear to which IOMMU implementation it belongs. The patch also adds "GART" to
    the Kconfig line.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Muli Ben-Yehuda <muli@il.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index 639e6320518e..95e0de9a4e4b 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -18,7 +18,7 @@
 #include <asm/apic.h>
 
 #ifdef CONFIG_IOMMU
-#include <asm/iommu.h>
+#include <asm/gart.h>
 #endif
 
 static void __init via_bugs(void)

commit 03d0d20e640a6189ec85fa917259d94013b4d730
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Sat Oct 27 20:57:43 2007 +0200

    x86: fix compiler warnings in arch/x86/kernel/early-quirks.c
    
    fix this warning:
    
    arch/x86/kernel/early-quirks.c:40: warning: nvidia_hpet_check defined but not used
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
index dc34acbd54aa..639e6320518e 100644
--- a/arch/x86/kernel/early-quirks.c
+++ b/arch/x86/kernel/early-quirks.c
@@ -35,12 +35,14 @@ static void __init via_bugs(void)
 }
 
 #ifdef CONFIG_ACPI
+#ifdef CONFIG_X86_IO_APIC
 
 static int __init nvidia_hpet_check(struct acpi_table_header *header)
 {
 	return 0;
 }
-#endif
+#endif /* CONFIG_X86_IO_APIC */
+#endif /* CONFIG_ACPI */
 
 static void __init nvidia_bugs(void)
 {

commit 54ef34009a69f95c25685247e73673dfeb435c71
Author: Andi Kleen <ak@suse.de>
Date:   Fri Oct 19 20:35:03 2007 +0200

    x86: Unify i386 and x86-64 early quirks
    
    They were already very similar; just use the same file now.
    
    [ tglx: arch/x86 adaptation ]
    
    Cc: lenb@kernel.org
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c
new file mode 100644
index 000000000000..dc34acbd54aa
--- /dev/null
+++ b/arch/x86/kernel/early-quirks.c
@@ -0,0 +1,136 @@
+/* Various workarounds for chipset bugs.
+   This code runs very early and can't use the regular PCI subsystem
+   The entries are keyed to PCI bridges which usually identify chipsets
+   uniquely.
+   This is only for whole classes of chipsets with specific problems which
+   need early invasive action (e.g. before the timers are initialized).
+   Most PCI device specific workarounds can be done later and should be
+   in standard PCI quirks
+   Mainboard specific bugs should be handled by DMI entries.
+   CPU specific bugs in setup.c */
+
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <linux/pci_ids.h>
+#include <asm/pci-direct.h>
+#include <asm/dma.h>
+#include <asm/io_apic.h>
+#include <asm/apic.h>
+
+#ifdef CONFIG_IOMMU
+#include <asm/iommu.h>
+#endif
+
+static void __init via_bugs(void)
+{
+#ifdef CONFIG_IOMMU
+	if ((end_pfn > MAX_DMA32_PFN ||  force_iommu) &&
+	    !iommu_aperture_allowed) {
+		printk(KERN_INFO
+		       "Looks like a VIA chipset. Disabling IOMMU."
+		       " Override with iommu=allowed\n");
+		iommu_aperture_disabled = 1;
+	}
+#endif
+}
+
+#ifdef CONFIG_ACPI
+
+static int __init nvidia_hpet_check(struct acpi_table_header *header)
+{
+	return 0;
+}
+#endif
+
+static void __init nvidia_bugs(void)
+{
+#ifdef CONFIG_ACPI
+#ifdef CONFIG_X86_IO_APIC
+	/*
+	 * All timer overrides on Nvidia are
+	 * wrong unless HPET is enabled.
+	 * Unfortunately that's not true on many Asus boards.
+	 * We don't know yet how to detect this automatically, but
+	 * at least allow a command line override.
+	 */
+	if (acpi_use_timer_override)
+		return;
+
+	if (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {
+		acpi_skip_timer_override = 1;
+		printk(KERN_INFO "Nvidia board "
+		       "detected. Ignoring ACPI "
+		       "timer override.\n");
+		printk(KERN_INFO "If you got timer trouble "
+			"try acpi_use_timer_override\n");
+	}
+#endif
+#endif
+	/* RED-PEN skip them on mptables too? */
+
+}
+
+static void __init ati_bugs(void)
+{
+#ifdef CONFIG_X86_IO_APIC
+	if (timer_over_8254 == 1) {
+		timer_over_8254 = 0;
+		printk(KERN_INFO
+		"ATI board detected. Disabling timer routing over 8254.\n");
+	}
+#endif
+}
+
+struct chipset {
+	u16 vendor;
+	void (*f)(void);
+};
+
+static struct chipset early_qrk[] __initdata = {
+	{ PCI_VENDOR_ID_NVIDIA, nvidia_bugs },
+	{ PCI_VENDOR_ID_VIA, via_bugs },
+	{ PCI_VENDOR_ID_ATI, ati_bugs },
+	{}
+};
+
+void __init early_quirks(void)
+{
+	int num, slot, func;
+
+	if (!early_pci_allowed())
+		return;
+
+	/* Poor man's PCI discovery */
+	for (num = 0; num < 32; num++) {
+		for (slot = 0; slot < 32; slot++) {
+			for (func = 0; func < 8; func++) {
+				u32 class;
+				u32 vendor;
+				u8 type;
+				int i;
+				class = read_pci_config(num,slot,func,
+							PCI_CLASS_REVISION);
+				if (class == 0xffffffff)
+					break;
+
+				if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
+					continue;
+
+				vendor = read_pci_config(num, slot, func,
+							 PCI_VENDOR_ID);
+				vendor &= 0xffff;
+
+				for (i = 0; early_qrk[i].f; i++)
+					if (early_qrk[i].vendor == vendor) {
+						early_qrk[i].f();
+						return;
+					}
+
+				type = read_pci_config_byte(num, slot, func,
+							    PCI_HEADER_TYPE);
+				if (!(type & 0x80))
+					break;
+			}
+		}
+	}
+}
