commit 37d1a04b13a6d2fec91a6813fc034947a27db034
Merge: 37f8173dd849 97a9474aeb78
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 11 20:02:46 2020 +0200

    Rebase locking/kcsan to locking/urgent
    
    Merge the state of the locking kcsan branch before the read/write_once()
    and the atomics modifications got merged.
    
    Squash the fallout of the rebase on top of the read/write once and atomic
    fallback work into the merge. The history of the original branch is
    preserved in tag locking-kcsan-2020-06-02.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4c5b566c2193e2af82c891daa5303c8899e61044
Author: Kairui Song <kasong@redhat.com>
Date:   Tue Mar 31 02:15:44 2020 +0800

    crash_dump: Remove no longer used saved_max_pfn
    
    saved_max_pfn was originally introduced in commit
    
      92aa63a5a1bf ("[PATCH] kdump: Retrieve saved max pfn")
    
    It used to make sure that the user does not try to read the physical memory
    beyond saved_max_pfn. But since commit
    
      921d58c0e699 ("vmcore: remove saved_max_pfn check")
    
    it's no longer used for the check. This variable doesn't have any users
    anymore so just remove it.
    
     [ bp: Drop the Calgary IOMMU reference from the commit message. ]
    
    Signed-off-by: Kairui Song <kasong@redhat.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Link: https://lkml.kernel.org/r/20200330181544.1595733-1-kasong@redhat.com

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c5399e80c59c..4d13c57f370a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -910,14 +910,6 @@ static int __init parse_memmap_one(char *p)
 		return -EINVAL;
 
 	if (!strncmp(p, "exactmap", 8)) {
-#ifdef CONFIG_CRASH_DUMP
-		/*
-		 * If we are doing a crash dump, we still need to know
-		 * the real memory size before the original memory map is
-		 * reset.
-		 */
-		saved_max_pfn = e820__end_of_ram_pfn();
-#endif
 		e820_table->nr_entries = 0;
 		userdef = 1;
 		return 0;

commit 8efbc518b884e1db2dd6a6fce62d0112ab871dcf
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Feb 12 19:04:24 2020 +0800

    x86/kexec: Do not reserve EFI setup_data in the kexec e820 table
    
    The e820 table for the kexec kernel unconditionally marks setup_data as
    reserved because the second kernel can reuse setup_data passed by the
    1st kernel's boot loader, for example SETUP_PCI marked regions like PCI
    BIOS, etc.
    
    SETUP_EFI types, however, are used by kexec itself to enable EFI in the
    2nd kernel. Thus, it is pointless to add this type of setup_data to the
    kexec e820 table as reserved.
    
    IOW, what happens is this:
    
      -  1st physical boot: no SETUP_EFI.
    
      - kexec loads a new kernel and prepares a SETUP_EFI setup_data blob, then
      reboots the machine.
    
      - 2nd kernel sees SETUP_EFI, reserves it both in the e820 and in the
      kexec e820 table.
    
      - If another kexec load is executed, it prepares a new SETUP_EFI blob and
      then reboots the machine into the new kernel.
    
      5. The 3rd kexec-ed kernel has two SETUP_EFI ranges reserved. And so on...
    
    Thus skip SETUP_EFI while reserving setup_data in the e820_table_kexec
    table because it is not needed.
    
     [ bp: Heavily massage commit message, shorten line and improve comment. ]
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/20200212110424.GA2938@dhcp-128-65.nay.redhat.com

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c5399e80c59c..c92029651b85 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -999,7 +999,15 @@ void __init e820__reserve_setup_data(void)
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
 		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
-		e820__range_update_kexec(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+
+		/*
+		 * SETUP_EFI is supplied by kexec and does not need to be
+		 * reserved.
+		 */
+		if (data->type != SETUP_EFI)
+			e820__range_update_kexec(pa_data,
+						 sizeof(*data) + data->len,
+						 E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 
 		if (data->type == SETUP_INDIRECT &&
 		    ((struct setup_indirect *)data->data)->type != SETUP_INDIRECT) {

commit 6e9f879684b46331f51d0c76ebee981c788417db
Merge: 9e7a03233e02 782b59711e15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 26 19:25:25 2019 -0800

    Merge tag 'acpi-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20191018, add support for EFI specific purpose memory, update the ACPI
      EC driver to make it work on systems with hardware-reduced ACPI,
      improve ACPI-based device enumeration for some platforms, rework the
      lid blacklist handling in the button driver and add more lid quirks to
      it, unify ACPI _HID/_UID matching, fix assorted issues and clean up
      the code and documentation.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20191018
         including:
          * Fixes for Clang warnings (Bob Moore)
          * Fix for possible overflow in get_tick_count() (Bob Moore)
          * Introduction of acpi_unload_table() (Bob Moore)
          * Debugger and utilities updates (Erik Schmauss)
          * Fix for unloading tables loaded via configfs (Nikolaus Voss)
    
       - Add support for EFI specific purpose memory to optionally allow
         either application-exclusive or core-kernel-mm managed access to
         differentiated memory (Dan Williams)
    
       - Fix and clean up processing of the HMAT table (Brice Goglin, Qian
         Cai, Tao Xu)
    
       - Update the ACPI EC driver to make it work on systems with
         hardware-reduced ACPI (Daniel Drake)
    
       - Always build in support for the Generic Event Device (GED) to allow
         one kernel binary to work both on systems with full hardware ACPI
         and hardware-reduced ACPI (Arjan van de Ven)
    
       - Fix the table unload mechanism to unregister platform devices
         created when the given table was loaded (Andy Shevchenko)
    
       - Rework the lid blacklist handling in the button driver and add more
         lid quirks to it (Hans de Goede)
    
       - Improve ACPI-based device enumeration for some platforms based on
         Intel BayTrail SoCs (Hans de Goede)
    
       - Add an OpRegion driver for the Cherry Trail Crystal Cove PMIC and
         prevent handlers from being registered for unhandled PMIC OpRegions
         (Hans de Goede)
    
       - Unify ACPI _HID/_UID matching (Andy Shevchenko)
    
       - Clean up documentation and comments (Cao jin, James Pack, Kacper
         Piwi≈Ñski)"
    
    * tag 'acpi-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (52 commits)
      ACPI: OSI: Shoot duplicate word
      ACPI: HMAT: use %u instead of %d to print u32 values
      ACPI: NUMA: HMAT: fix a section mismatch
      ACPI: HMAT: don't mix pxm and nid when setting memory target processor_pxm
      ACPI: NUMA: HMAT: Register "soft reserved" memory as an "hmem" device
      ACPI: NUMA: HMAT: Register HMAT at device_initcall level
      device-dax: Add a driver for "hmem" devices
      dax: Fix alloc_dax_region() compile warning
      lib: Uplevel the pmem "region" ida to a global allocator
      x86/efi: Add efi_fake_mem support for EFI_MEMORY_SP
      arm/efi: EFI soft reservation to memblock
      x86/efi: EFI soft reservation to E820 enumeration
      efi: Common enable/disable infrastructure for EFI soft reservation
      x86/efi: Push EFI_MEMMAP check into leaf routines
      efi: Enumerate EFI_MEMORY_SP
      ACPI: NUMA: Establish a new drivers/acpi/numa/ directory
      ACPICA: Update version to 20191018
      ACPICA: debugger: remove leading whitespaces when converting a string to a buffer
      ACPICA: acpiexec: initialize all simple types and field units from user input
      ACPICA: debugger: add field unit support for acpi_db_get_next_token
      ...

commit b3c72fc9a78e74161f9d05ef7191706060628f8c
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Tue Nov 12 14:46:40 2019 +0100

    x86/boot: Introduce setup_indirect
    
    The setup_data is a bit awkward to use for extremely large data objects,
    both because the setup_data header has to be adjacent to the data object
    and because it has a 32-bit length field. However, it is important that
    intermediate stages of the boot process have a way to identify which
    chunks of memory are occupied by kernel data. Thus introduce an uniform
    way to specify such indirect data as setup_indirect struct and
    SETUP_INDIRECT type.
    
    And finally bump setup_header version in arch/x86/boot/header.S.
    
    Suggested-by: H. Peter Anvin (Intel) <hpa@zytor.com>
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Ross Philipson <ross.philipson@oracle.com>
    Reviewed-by: H. Peter Anvin (Intel) <hpa@zytor.com>
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: ard.biesheuvel@linaro.org
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: dave.hansen@linux.intel.com
    Cc: eric.snowberg@oracle.com
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: kanth.ghatraju@oracle.com
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi <linux-efi@vger.kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: rdunlap@infradead.org
    Cc: ross.philipson@oracle.com
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86-ml <x86@kernel.org>
    Cc: xen-devel@lists.xenproject.org
    Link: https://lkml.kernel.org/r/20191112134640.16035-4-daniel.kiper@oracle.com

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7da2bcd2b8eb..0bfe9a685b3b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -999,6 +999,17 @@ void __init e820__reserve_setup_data(void)
 		data = early_memremap(pa_data, sizeof(*data));
 		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 		e820__range_update_kexec(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+
+		if (data->type == SETUP_INDIRECT &&
+		    ((struct setup_indirect *)data->data)->type != SETUP_INDIRECT) {
+			e820__range_update(((struct setup_indirect *)data->data)->addr,
+					   ((struct setup_indirect *)data->data)->len,
+					   E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+			e820__range_update_kexec(((struct setup_indirect *)data->data)->addr,
+						 ((struct setup_indirect *)data->data)->len,
+						 E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+		}
+
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}

commit 262b45ae3ab4bf8e2caf1fcfd0d8307897519630
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:16 2019 -0800

    x86/efi: EFI soft reservation to E820 enumeration
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose".
    
    The proposed Linux behavior for specific purpose memory is that it is
    reserved for direct-access (device-dax) by default and not available for
    any kernel usage, not even as an OOM fallback.  Later, through udev
    scripts or another init mechanism, these device-dax claimed ranges can
    be reconfigured and hot-added to the available System-RAM with a unique
    node identifier. This device-dax management scheme implements "soft" in
    the "soft reserved" designation by allowing some or all of the
    reservation to be recovered as typical memory. This policy can be
    disabled at compile-time with CONFIG_EFI_SOFT_RESERVE=n, or runtime with
    efi=nosoftreserve.
    
    This patch introduces 2 new concepts at once given the entanglement
    between early boot enumeration relative to memory that can optionally be
    reserved from the kernel page allocator by default. The new concepts
    are:
    
    - E820_TYPE_SOFT_RESERVED: Upon detecting the EFI_MEMORY_SP
      attribute on EFI_CONVENTIONAL memory, update the E820 map with this
      new type. Only perform this classification if the
      CONFIG_EFI_SOFT_RESERVE=y policy is enabled, otherwise treat it as
      typical ram.
    
    - IORES_DESC_SOFT_RESERVED: Add a new I/O resource descriptor for
      a device driver to search iomem resources for application specific
      memory. Teach the iomem code to identify such ranges as "Soft Reserved".
    
    Note that the comment for do_add_efi_memmap() needed refreshing since it
    seemed to imply that the efi map might overflow the e820 table, but that
    is not an issue as of commit 7b6e4ba3cb1f "x86/boot/e820: Clean up the
    E820_X_MAX definition" that removed the 128 entry limit for
    e820__range_add().
    
    A follow-on change integrates parsing of the ACPI HMAT to identify the
    node and sub-range boundaries of EFI_MEMORY_SP designated memory. For
    now, just identify and reserve memory of this type.
    
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reported-by: kbuild test robot <lkp@intel.com>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7da2bcd2b8eb..9976106b57ec 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -190,6 +190,7 @@ static void __init e820_print_type(enum e820_type type)
 	case E820_TYPE_RAM:		/* Fall through: */
 	case E820_TYPE_RESERVED_KERN:	pr_cont("usable");			break;
 	case E820_TYPE_RESERVED:	pr_cont("reserved");			break;
+	case E820_TYPE_SOFT_RESERVED:	pr_cont("soft reserved");		break;
 	case E820_TYPE_ACPI:		pr_cont("ACPI data");			break;
 	case E820_TYPE_NVS:		pr_cont("ACPI NVS");			break;
 	case E820_TYPE_UNUSABLE:	pr_cont("unusable");			break;
@@ -1037,6 +1038,7 @@ static const char *__init e820_type_to_string(struct e820_entry *entry)
 	case E820_TYPE_PRAM:		return "Persistent Memory (legacy)";
 	case E820_TYPE_PMEM:		return "Persistent Memory";
 	case E820_TYPE_RESERVED:	return "Reserved";
+	case E820_TYPE_SOFT_RESERVED:	return "Soft Reserved";
 	default:			return "Unknown E820 type";
 	}
 }
@@ -1052,6 +1054,7 @@ static unsigned long __init e820_type_to_iomem_type(struct e820_entry *entry)
 	case E820_TYPE_PRAM:		/* Fall-through: */
 	case E820_TYPE_PMEM:		/* Fall-through: */
 	case E820_TYPE_RESERVED:	/* Fall-through: */
+	case E820_TYPE_SOFT_RESERVED:	/* Fall-through: */
 	default:			return IORESOURCE_MEM;
 	}
 }
@@ -1064,6 +1067,7 @@ static unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)
 	case E820_TYPE_PMEM:		return IORES_DESC_PERSISTENT_MEMORY;
 	case E820_TYPE_PRAM:		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
 	case E820_TYPE_RESERVED:	return IORES_DESC_RESERVED;
+	case E820_TYPE_SOFT_RESERVED:	return IORES_DESC_SOFT_RESERVED;
 	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
 	case E820_TYPE_RAM:		/* Fall-through: */
 	case E820_TYPE_UNUSABLE:	/* Fall-through: */
@@ -1078,11 +1082,12 @@ static bool __init do_mark_busy(enum e820_type type, struct resource *res)
 		return true;
 
 	/*
-	 * Treat persistent memory like device memory, i.e. reserve it
-	 * for exclusive use of a driver
+	 * Treat persistent memory and other special memory ranges like
+	 * device memory, i.e. reserve it for exclusive use of a driver
 	 */
 	switch (type) {
 	case E820_TYPE_RESERVED:
+	case E820_TYPE_SOFT_RESERVED:
 	case E820_TYPE_PRAM:
 	case E820_TYPE_PMEM:
 		return false;
@@ -1285,6 +1290,9 @@ void __init e820__memblock_setup(void)
 		if (end != (resource_size_t)end)
 			continue;
 
+		if (entry->type == E820_TYPE_SOFT_RESERVED)
+			memblock_reserve(entry->addr, entry->size);
+
 		if (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)
 			continue;
 

commit f709f81483d652b4ae5bbda2204b95593ce07c8f
Author: Yi Wang <wang.yi59@zte.com.cn>
Date:   Mon Jul 15 10:47:09 2019 +0800

    x86/e820: Use proper booleans instead of 0/1
    
    This fixes the following coccinelle warning:
    ./arch/x86/kernel/e820.c:89:9-10: WARNING: return of 0/1 in function '_e820__mapped_any' with return type bool
    
    Return type bool instead of 0/1.
    
    Signed-off-by: Yi Wang <wang.yi59@zte.com.cn>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/1563158829-44373-1-git-send-email-wang.yi59@zte.com.cn

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e69408bf664b..7da2bcd2b8eb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -86,9 +86,9 @@ static bool _e820__mapped_any(struct e820_table *table,
 			continue;
 		if (entry->addr >= end || entry->addr + entry->size <= start)
 			continue;
-		return 1;
+		return true;
 	}
-	return 0;
+	return false;
 }
 
 bool e820__mapped_raw_any(u64 start, u64 end, enum e820_type type)

commit ae9e13d621d6795ec1ad6bf10bd2549c6c3feca4
Author: Lianbo Jiang <lijiang@redhat.com>
Date:   Tue Apr 23 09:30:05 2019 +0800

    x86/e820, ioport: Add a new I/O resource descriptor IORES_DESC_RESERVED
    
    When executing the kexec_file_load() syscall, the first kernel needs to
    pass the e820 reserved ranges to the second kernel because some devices
    (PCI, for example) need them present in the kdump kernel for proper
    initialization.
    
    But the kernel can not exactly match the e820 reserved ranges when
    walking through the iomem resources using the default IORES_DESC_NONE
    descriptor, because there are several types of e820 ranges which are
    marked IORES_DESC_NONE, see e820_type_to_iores_desc().
    
    Therefore, add a new I/O resource descriptor called IORES_DESC_RESERVED
    to mark exactly those ranges. It will be used to match the reserved
    resource ranges when walking through iomem resources.
    
     [ bp: Massage commit message. ]
    
    Suggested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Lianbo Jiang <lijiang@redhat.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: bhe@redhat.com
    Cc: dave.hansen@linux.intel.com
    Cc: dyoung@redhat.com
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Huang Zijiang <huang.zijiang@zte.com.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: kexec@lists.infradead.org
    Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20190423013007.17838-2-lijiang@redhat.com

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 8f32e705a980..e69408bf664b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1063,10 +1063,10 @@ static unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)
 	case E820_TYPE_NVS:		return IORES_DESC_ACPI_NV_STORAGE;
 	case E820_TYPE_PMEM:		return IORES_DESC_PERSISTENT_MEMORY;
 	case E820_TYPE_PRAM:		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
+	case E820_TYPE_RESERVED:	return IORES_DESC_RESERVED;
 	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
 	case E820_TYPE_RAM:		/* Fall-through: */
 	case E820_TYPE_UNUSABLE:	/* Fall-through: */
-	case E820_TYPE_RESERVED:	/* Fall-through: */
 	default:			return IORES_DESC_NONE;
 	}
 }

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 76dd605ee2a3..8f32e705a980 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Low level x86 E820 memory map handling functions.
  *

commit 0c55671f84fffe591e8435c93a8c83286fd6b8eb
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Thu Jan 31 21:24:44 2019 +0100

    kvm, x86: Properly check whether a pfn is an MMIO or not
    
    pfn_valid check is not sufficient because it only checks if a page has a struct
    page or not, if "mem=" was passed to the kernel some valid pages won't have a
    struct page. This means that if guests were assigned valid memory that lies
    after the mem= boundary it will be passed uncached to the guest no matter what
    the guest caching attributes are for this memory.
    
    Introduce a new function e820__mapped_raw_any which is equivalent to
    e820__mapped_any but uses the original e820 unmodified and use it to
    identify real *RAM*.
    
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 2879e234e193..76dd605ee2a3 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -73,12 +73,13 @@ EXPORT_SYMBOL(pci_mem_start);
  * This function checks if any part of the range <start,end> is mapped
  * with type.
  */
-bool e820__mapped_any(u64 start, u64 end, enum e820_type type)
+static bool _e820__mapped_any(struct e820_table *table,
+			      u64 start, u64 end, enum e820_type type)
 {
 	int i;
 
-	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *entry = &e820_table->entries[i];
+	for (i = 0; i < table->nr_entries; i++) {
+		struct e820_entry *entry = &table->entries[i];
 
 		if (type && entry->type != type)
 			continue;
@@ -88,6 +89,17 @@ bool e820__mapped_any(u64 start, u64 end, enum e820_type type)
 	}
 	return 0;
 }
+
+bool e820__mapped_raw_any(u64 start, u64 end, enum e820_type type)
+{
+	return _e820__mapped_any(e820_table_firmware, start, end, type);
+}
+EXPORT_SYMBOL_GPL(e820__mapped_raw_any);
+
+bool e820__mapped_any(u64 start, u64 end, enum e820_type type)
+{
+	return _e820__mapped_any(e820_table, start, end, type);
+}
 EXPORT_SYMBOL_GPL(e820__mapped_any);
 
 /*

commit a667cb7a94d48a483fb5d6006fe04a440f1a42ce
Merge: cb1d150d809e 586187d7de71
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 10:39:53 2019 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge misc updates from Andrew Morton:
    
     - a few misc things
    
     - the rest of MM
    
    -  remove flex_arrays, replace with new simple radix-tree implementation
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (38 commits)
      Drop flex_arrays
      sctp: convert to genradix
      proc: commit to genradix
      generic radix trees
      selinux: convert to kvmalloc
      md: convert to kvmalloc
      openvswitch: convert to kvmalloc
      of: fix kmemleak crash caused by imbalance in early memory reservation
      mm: memblock: update comments and kernel-doc
      memblock: split checks whether a region should be skipped to a helper function
      memblock: remove memblock_{set,clear}_region_flags
      memblock: drop memblock_alloc_*_nopanic() variants
      memblock: memblock_alloc_try_nid: don't panic
      treewide: add checks for the return value of memblock_alloc*()
      swiotlb: add checks for the return value of memblock_alloc*()
      init/main: add checks for the return value of memblock_alloc*()
      mm/percpu: add checks for the return value of memblock_alloc*()
      sparc: add checks for the return value of memblock_alloc*()
      ia64: add checks for the return value of memblock_alloc*()
      arch: don't memset(0) memory returned by memblock_alloc()
      ...

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 5203ee4e6435..6831c8437951 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1092,6 +1092,9 @@ void __init e820__reserve_resources(void)
 
 	res = memblock_alloc(sizeof(*res) * e820_table->nr_entries,
 			     SMP_CACHE_BYTES);
+	if (!res)
+		panic("%s: Failed to allocate %zu bytes\n", __func__,
+		      sizeof(*res) * e820_table->nr_entries);
 	e820_res = res;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {

commit 42b46aeff2e366bad54bd1c069b7b5381d9be8b3
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:29:31 2019 -0700

    memblock: drop __memblock_alloc_base()
    
    The __memblock_alloc_base() function tries to allocate a memory up to
    the limit specified by its max_addr parameter.  Depending on the value
    of this parameter, the __memblock_alloc_base() can is replaced with the
    appropriate memblock_phys_alloc*() variant.
    
    Link: http://lkml.kernel.org/r/1548057848-15136-9-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Guo Ren <ren_guo@c-sky.com>                         [c-sky]
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Juergen Gross <jgross@suse.com>                     [Xen]
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a687d10da417..5203ee4e6435 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -775,7 +775,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 {
 	u64 addr;
 
-	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
+	addr = memblock_phys_alloc(size, align);
 	if (addr) {
 		e820__range_update_kexec(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
 		pr_info("update e820_table_kexec for e820__memblock_alloc_reserved()\n");

commit d14d7f14f177834788a276fc7b1317b539cedca2
Merge: 6cdfa54cd229 01bd2ac2f55a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 11 17:08:14 2019 -0700

    Merge tag 'for-linus-5.1a-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen updates from Juergen Gross:
     "xen fixes and features:
    
       - remove fallback code for very old Xen hypervisors
    
       - three patches for fixing Xen dom0 boot regressions
    
       - an old patch for Xen PCI passthrough which was never applied for
         unknown reasons
    
       - some more minor fixes and cleanup patches"
    
    * tag 'for-linus-5.1a-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip:
      xen: fix dom0 boot on huge systems
      xen, cpu_hotplug: Prevent an out of bounds access
      xen: remove pre-xen3 fallback handlers
      xen/ACPI: Switch to bitmap_zalloc()
      x86/xen: dont add memory above max allowed allocation
      x86: respect memory size limiting via mem= parameter
      xen/gntdev: Check and release imported dma-bufs on close
      xen/gntdev: Do not destroy context while dma-bufs are in use
      xen/pciback: Don't disable PCI_COMMAND on PCI device reset.
      xen-scsiback: mark expected switch fall-through
      xen: mark expected switch fall-through

commit 357b4da50a62e2fd70eacee21cdbd22d4c7a7b60
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Feb 14 11:42:39 2019 +0100

    x86: respect memory size limiting via mem= parameter
    
    When limiting memory size via kernel parameter "mem=" this should be
    respected even in case of memory made accessible via a PCI card.
    
    Today this kind of memory won't be made usable in initial memory
    setup as the memory won't be visible in E820 map, but it might be
    added when adding PCI devices due to corresponding ACPI table entries.
    
    Not respecting "mem=" can be corrected by adding a global max_mem_size
    variable set by parse_memopt() which will result in rejecting adding
    memory areas resulting in a memory size above the allowed limit.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: William Kucharski <william.kucharski@oracle.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 50895c2f937d..e67513e2cbbb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -14,6 +14,7 @@
 #include <linux/acpi.h>
 #include <linux/firmware-map.h>
 #include <linux/sort.h>
+#include <linux/memory_hotplug.h>
 
 #include <asm/e820/api.h>
 #include <asm/setup.h>
@@ -881,6 +882,10 @@ static int __init parse_memopt(char *p)
 
 	e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);
 
+#ifdef CONFIG_MEMORY_HOTPLUG
+	max_mem_size = mem_size;
+#endif
+
 	return 0;
 }
 early_param("mem", parse_memopt);

commit 345dca4ca7e65a46bf0b6e2e6b8ab2e998ec6e91
Author: Huang Zijiang <huang.zijiang@zte.com.cn>
Date:   Sat Jan 12 15:16:24 2019 +0800

    x86/e820: Replace kmalloc() + memcpy() with kmemdup()
    
    Use the equivalent kmemdup() directly instead of kmalloc() + memcpy().
    
    No functional changes.
    
     [ bp: rewrite commit message. ]
    
    Signed-off-by: Huang Zijiang <huang.zijiang@zte.com.cn>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: jschoenh@amazon.de
    Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86-ml <x86@kernel.org>
    Cc: xue.zhihong@zte.com.cn
    Link: https://lkml.kernel.org/r/1547277384-22156-1-git-send-email-wang.yi59@zte.com.cn

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 50895c2f937d..a687d10da417 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -671,21 +671,18 @@ __init void e820__reallocate_tables(void)
 	int size;
 
 	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table->nr_entries;
-	n = kmalloc(size, GFP_KERNEL);
+	n = kmemdup(e820_table, size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table, size);
 	e820_table = n;
 
 	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_kexec->nr_entries;
-	n = kmalloc(size, GFP_KERNEL);
+	n = kmemdup(e820_table_kexec, size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table_kexec, size);
 	e820_table_kexec = n;
 
 	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;
-	n = kmalloc(size, GFP_KERNEL);
+	n = kmemdup(e820_table_firmware, size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table_firmware, size);
 	e820_table_firmware = n;
 }
 

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 68ff62bffbab..50895c2f937d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1093,7 +1093,8 @@ void __init e820__reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = memblock_alloc(sizeof(*res) * e820_table->nr_entries, 0);
+	res = memblock_alloc(sizeof(*res) * e820_table->nr_entries,
+			     SMP_CACHE_BYTES);
 	e820_res = res;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a0ec4c37265a..68ff62bffbab 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -9,11 +9,10 @@
  * allocation code routines via a platform independent interface (memblock, etc.).
  */
 #include <linux/crash_dump.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/suspend.h>
 #include <linux/acpi.h>
 #include <linux/firmware-map.h>
-#include <linux/memblock.h>
 #include <linux/sort.h>
 
 #include <asm/e820/api.h>

commit 2a5bda5a624d6471d25e953b9adba5182ab1b51f
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:09 2018 -0700

    memblock: replace alloc_bootmem with memblock_alloc
    
    The alloc_bootmem(size) is a shortcut for allocation of SMP_CACHE_BYTES
    aligned memory. When the align parameter of memblock_alloc() is 0, the
    alignment is implicitly set to SMP_CACHE_BYTES and thus alloc_bootmem(size)
    and memblock_alloc(size, 0) are equivalent.
    
    The conversion is done using the following semantic patch:
    
    @@
    expression size;
    @@
    - alloc_bootmem(size)
    + memblock_alloc(size, 0)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-22-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d1f25c831447..a0ec4c37265a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1094,7 +1094,7 @@ void __init e820__reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(*res) * e820_table->nr_entries);
+	res = memblock_alloc(sizeof(*res) * e820_table->nr_entries, 0);
 	e820_res = res;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {

commit 9fd61bc95130d4971568b89c9548b5e0a4e18e0e
Author: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
Date:   Fri Oct 26 15:10:24 2018 -0700

    Revert "x86/e820: put !E820_TYPE_RAM regions into memblock.reserved"
    
    commit 124049decbb1 ("x86/e820: put !E820_TYPE_RAM regions into
    memblock.reserved") breaks movable_node kernel option because it changed
    the memory gap range to reserved memblock.  So, the node is marked as
    Normal zone even if the SRAT has Hot pluggable affinity.
    
        =====================================================================
        kernel: BIOS-e820: [mem 0x0000180000000000-0x0000180fffffffff] usable
        kernel: BIOS-e820: [mem 0x00001c0000000000-0x00001c0fffffffff] usable
        ...
        kernel: reserved[0x12]#011[0x0000181000000000-0x00001bffffffffff], 0x000003f000000000 bytes flags: 0x0
        ...
        kernel: ACPI: SRAT: Node 2 PXM 6 [mem 0x180000000000-0x1bffffffffff] hotplug
        kernel: ACPI: SRAT: Node 3 PXM 7 [mem 0x1c0000000000-0x1fffffffffff] hotplug
        ...
        kernel: Movable zone start for each node
        kernel:  Node 3: 0x00001c0000000000
        kernel: Early memory node ranges
        ...
        =====================================================================
    
    The original issue is fixed by the former patches, so let's revert commit
    124049decbb1 ("x86/e820: put !E820_TYPE_RAM regions into
    memblock.reserved").
    
    Link: http://lkml.kernel.org/r/20181002143821.5112-4-msys.mizuma@gmail.com
    Signed-off-by: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Reviewed-by: Pavel Tatashin <pavel.tatashin@microsoft.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Oscar Salvador <osalvador@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c88c23c658c1..d1f25c831447 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1248,7 +1248,6 @@ void __init e820__memblock_setup(void)
 {
 	int i;
 	u64 end;
-	u64 addr = 0;
 
 	/*
 	 * The bootstrap memblock region count maximum is 128 entries
@@ -1265,21 +1264,13 @@ void __init e820__memblock_setup(void)
 		struct e820_entry *entry = &e820_table->entries[i];
 
 		end = entry->addr + entry->size;
-		if (addr < entry->addr)
-			memblock_reserve(addr, entry->addr - addr);
-		addr = end;
 		if (end != (resource_size_t)end)
 			continue;
 
-		/*
-		 * all !E820_TYPE_RAM ranges (including gap ranges) are put
-		 * into memblock.reserved to make sure that struct pages in
-		 * such regions are not left uninitialized after bootup.
-		 */
 		if (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)
-			memblock_reserve(entry->addr, entry->size);
-		else
-			memblock_add(entry->addr, entry->size);
+			continue;
+
+		memblock_add(entry->addr, entry->size);
 	}
 
 	/* Throw away partial pages: */

commit 124049decbb121ec32742c94fb5d9d6bed8f24d8
Author: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
Date:   Wed Jun 27 23:26:13 2018 -0700

    x86/e820: put !E820_TYPE_RAM regions into memblock.reserved
    
    There is a kernel panic that is triggered when reading /proc/kpageflags
    on the kernel booted with kernel parameter 'memmap=nn[KMG]!ss[KMG]':
    
      BUG: unable to handle kernel paging request at fffffffffffffffe
      PGD 9b20e067 P4D 9b20e067 PUD 9b210067 PMD 0
      Oops: 0000 [#1] SMP PTI
      CPU: 2 PID: 1728 Comm: page-types Not tainted 4.17.0-rc6-mm1-v4.17-rc6-180605-0816-00236-g2dfb086ef02c+ #160
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.fc28 04/01/2014
      RIP: 0010:stable_page_flags+0x27/0x3c0
      Code: 00 00 00 0f 1f 44 00 00 48 85 ff 0f 84 a0 03 00 00 41 54 55 49 89 fc 53 48 8b 57 08 48 8b 2f 48 8d 42 ff 83 e2 01 48 0f 44 c7 <48> 8b 00 f6 c4 01 0f 84 10 03 00 00 31 db 49 8b 54 24 08 4c 89 e7
      RSP: 0018:ffffbbd44111fde0 EFLAGS: 00010202
      RAX: fffffffffffffffe RBX: 00007fffffffeff9 RCX: 0000000000000000
      RDX: 0000000000000001 RSI: 0000000000000202 RDI: ffffed1182fff5c0
      RBP: ffffffffffffffff R08: 0000000000000001 R09: 0000000000000001
      R10: ffffbbd44111fed8 R11: 0000000000000000 R12: ffffed1182fff5c0
      R13: 00000000000bffd7 R14: 0000000002fff5c0 R15: ffffbbd44111ff10
      FS:  00007efc4335a500(0000) GS:ffff93a5bfc00000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: fffffffffffffffe CR3: 00000000b2a58000 CR4: 00000000001406e0
      Call Trace:
       kpageflags_read+0xc7/0x120
       proc_reg_read+0x3c/0x60
       __vfs_read+0x36/0x170
       vfs_read+0x89/0x130
       ksys_pread64+0x71/0x90
       do_syscall_64+0x5b/0x160
       entry_SYSCALL_64_after_hwframe+0x44/0xa9
      RIP: 0033:0x7efc42e75e23
      Code: 09 00 ba 9f 01 00 00 e8 ab 81 f4 ff 66 2e 0f 1f 84 00 00 00 00 00 90 83 3d 29 0a 2d 00 00 75 13 49 89 ca b8 11 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 34 c3 48 83 ec 08 e8 db d3 01 00 48 89 04 24
    
    According to kernel bisection, this problem became visible due to commit
    f7f99100d8d9 ("mm: stop zeroing memory during allocation in vmemmap")
    which changes how struct pages are initialized.
    
    Memblock layout affects the pfn ranges covered by node/zone.  Consider
    that we have a VM with 2 NUMA nodes and each node has 4GB memory, and
    the default (no memmap= given) memblock layout is like below:
    
      MEMBLOCK configuration:
       memory size = 0x00000001fff75c00 reserved size = 0x000000000300c000
       memory.cnt  = 0x4
       memory[0x0]     [0x0000000000001000-0x000000000009efff], 0x000000000009e000 bytes on node 0 flags: 0x0
       memory[0x1]     [0x0000000000100000-0x00000000bffd6fff], 0x00000000bfed7000 bytes on node 0 flags: 0x0
       memory[0x2]     [0x0000000100000000-0x000000013fffffff], 0x0000000040000000 bytes on node 0 flags: 0x0
       memory[0x3]     [0x0000000140000000-0x000000023fffffff], 0x0000000100000000 bytes on node 1 flags: 0x0
       ...
    
    If you give memmap=1G!4G (so it just covers memory[0x2]),
    the range [0x100000000-0x13fffffff] is gone:
    
      MEMBLOCK configuration:
       memory size = 0x00000001bff75c00 reserved size = 0x000000000300c000
       memory.cnt  = 0x3
       memory[0x0]     [0x0000000000001000-0x000000000009efff], 0x000000000009e000 bytes on node 0 flags: 0x0
       memory[0x1]     [0x0000000000100000-0x00000000bffd6fff], 0x00000000bfed7000 bytes on node 0 flags: 0x0
       memory[0x2]     [0x0000000140000000-0x000000023fffffff], 0x0000000100000000 bytes on node 1 flags: 0x0
       ...
    
    This causes shrinking node 0's pfn range because it is calculated by the
    address range of memblock.memory.  So some of struct pages in the gap
    range are left uninitialized.
    
    We have a function zero_resv_unavail() which does zeroing the struct pages
    within the reserved unavailable range (i.e.  memblock.memory &&
    !memblock.reserved).  This patch utilizes it to cover all unavailable
    ranges by putting them into memblock.reserved.
    
    Link: http://lkml.kernel.org/r/20180615072947.GB23273@hori1.linux.bs1.fc.nec.co.jp
    Fixes: f7f99100d8d9 ("mm: stop zeroing memory during allocation in vmemmap")
    Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Tested-by: Oscar Salvador <osalvador@suse.de>
    Tested-by: "Herton R. Krzesinski" <herton@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Reviewed-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Cc: Steven Sistare <steven.sistare@oracle.com>
    Cc: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d1f25c831447..c88c23c658c1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1248,6 +1248,7 @@ void __init e820__memblock_setup(void)
 {
 	int i;
 	u64 end;
+	u64 addr = 0;
 
 	/*
 	 * The bootstrap memblock region count maximum is 128 entries
@@ -1264,13 +1265,21 @@ void __init e820__memblock_setup(void)
 		struct e820_entry *entry = &e820_table->entries[i];
 
 		end = entry->addr + entry->size;
+		if (addr < entry->addr)
+			memblock_reserve(addr, entry->addr - addr);
+		addr = end;
 		if (end != (resource_size_t)end)
 			continue;
 
+		/*
+		 * all !E820_TYPE_RAM ranges (including gap ranges) are put
+		 * into memblock.reserved to make sure that struct pages in
+		 * such regions are not left uninitialized after bootup.
+		 */
 		if (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)
-			continue;
-
-		memblock_add(entry->addr, entry->size);
+			memblock_reserve(entry->addr, entry->size);
+		else
+			memblock_add(entry->addr, entry->size);
 	}
 
 	/* Throw away partial pages: */

commit 1de392f5d5e803663abbd8ed084233f154152bcd
Author: Joe Perches <joe@perches.com>
Date:   Thu May 10 08:45:30 2018 -0700

    x86: Remove pr_fmt duplicate logging prefixes
    
    Converting pr_fmt from a default simple #define to use KBUILD_MODNAME
    added some duplicate prefixes.
    
    Remove the duplicate prefixes.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Link: https://lkml.kernel.org/r/e7b709a2b040af7faa81b0aa2c3a125aed628a82.1525964383.git.joe@perches.com

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 6a2cb1442e05..d1f25c831447 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -155,7 +155,8 @@ static void __init __e820__range_add(struct e820_table *table, u64 start, u64 si
 	int x = table->nr_entries;
 
 	if (x >= ARRAY_SIZE(table->entries)) {
-		pr_err("e820: too many entries; ignoring [mem %#010llx-%#010llx]\n", start, start + size - 1);
+		pr_err("too many entries; ignoring [mem %#010llx-%#010llx]\n",
+		       start, start + size - 1);
 		return;
 	}
 
@@ -190,9 +191,10 @@ void __init e820__print_table(char *who)
 	int i;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		pr_info("%s: [mem %#018Lx-%#018Lx] ", who,
-		       e820_table->entries[i].addr,
-		       e820_table->entries[i].addr + e820_table->entries[i].size - 1);
+		pr_info("%s: [mem %#018Lx-%#018Lx] ",
+			who,
+			e820_table->entries[i].addr,
+			e820_table->entries[i].addr + e820_table->entries[i].size - 1);
 
 		e820_print_type(e820_table->entries[i].type);
 		pr_cont("\n");
@@ -574,7 +576,7 @@ void __init e820__update_table_print(void)
 	if (e820__update_table(e820_table))
 		return;
 
-	pr_info("e820: modified physical RAM map:\n");
+	pr_info("modified physical RAM map:\n");
 	e820__print_table("modified");
 }
 
@@ -636,9 +638,8 @@ __init void e820__setup_pci_gap(void)
 	if (!found) {
 #ifdef CONFIG_X86_64
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
-		pr_err(
-			"e820: Cannot find an available gap in the 32-bit address range\n"
-			"e820: PCI devices with unassigned 32-bit BARs may not work!\n");
+		pr_err("Cannot find an available gap in the 32-bit address range\n");
+		pr_err("PCI devices with unassigned 32-bit BARs may not work!\n");
 #else
 		gapstart = 0x10000000;
 #endif
@@ -649,7 +650,8 @@ __init void e820__setup_pci_gap(void)
 	 */
 	pci_mem_start = gapstart;
 
-	pr_info("e820: [mem %#010lx-%#010lx] available for PCI devices\n", gapstart, gapstart + gapsize - 1);
+	pr_info("[mem %#010lx-%#010lx] available for PCI devices\n",
+		gapstart, gapstart + gapsize - 1);
 }
 
 /*
@@ -711,7 +713,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 
 	early_memunmap(sdata, data_len);
-	pr_info("e820: extended physical RAM map:\n");
+	pr_info("extended physical RAM map:\n");
 	e820__print_table("extended");
 }
 
@@ -780,7 +782,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820__range_update_kexec(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
-		pr_info("e820: update e820_table_kexec for e820__memblock_alloc_reserved()\n");
+		pr_info("update e820_table_kexec for e820__memblock_alloc_reserved()\n");
 		e820__update_table_kexec();
 	}
 
@@ -830,8 +832,8 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, enum e820_type
 	if (last_pfn > max_arch_pfn)
 		last_pfn = max_arch_pfn;
 
-	pr_info("e820: last_pfn = %#lx max_arch_pfn = %#lx\n",
-			 last_pfn, max_arch_pfn);
+	pr_info("last_pfn = %#lx max_arch_pfn = %#lx\n",
+		last_pfn, max_arch_pfn);
 	return last_pfn;
 }
 
@@ -1005,7 +1007,7 @@ void __init e820__finish_early_params(void)
 		if (e820__update_table(e820_table) < 0)
 			early_panic("Invalid user supplied memory map");
 
-		pr_info("e820: user-defined physical RAM map:\n");
+		pr_info("user-defined physical RAM map:\n");
 		e820__print_table("user");
 	}
 }
@@ -1238,7 +1240,7 @@ void __init e820__memory_setup(void)
 	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
 	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 
-	pr_info("e820: BIOS-provided physical RAM map:\n");
+	pr_info("BIOS-provided physical RAM map:\n");
 	e820__print_table(who);
 }
 

commit ef61f8a340fd6d49df6b367785743febc47320c1
Author: Jan H. Sch√∂nherr <jschoenh@amazon.de>
Date:   Sat Feb 3 00:10:20 2018 +0100

    x86/boot/e820: Implement a range manipulation operator
    
    Add a more versatile memmap= operator, which -- in addition to all the
    things that were possible before -- allows you to:
    
    - redeclare existing ranges -- before, you were limited to adding ranges;
    - drop any range -- like a mem= for any location;
    - use any e820 memory type -- not just some predefined ones.
    
    The syntax is:
    
      memmap=<size>%<offset>-<oldtype>+<newtype>
    
    Size and offset work as usual. The "-<oldtype>" and "+<newtype>" are
    optional and their existence determine the behavior: The command
    works on the specified range of memory limited to type <oldtype>
    (if specified). This memory is then configured to show up as <newtype>.
    If <newtype> is not specified, the memory is removed from the e820 map.
    
    Signed-off-by: Jan H. Sch√∂nherr <jschoenh@amazon.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20180202231020.15608-1-jschoenh@amazon.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 71c11ad5643e..6a2cb1442e05 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -924,6 +924,24 @@ static int __init parse_memmap_one(char *p)
 	} else if (*p == '!') {
 		start_at = memparse(p+1, &p);
 		e820__range_add(start_at, mem_size, E820_TYPE_PRAM);
+	} else if (*p == '%') {
+		enum e820_type from = 0, to = 0;
+
+		start_at = memparse(p + 1, &p);
+		if (*p == '-')
+			from = simple_strtoull(p + 1, &p, 0);
+		if (*p == '+')
+			to = simple_strtoull(p + 1, &p, 0);
+		if (*p != '\0')
+			return -EINVAL;
+		if (from && to)
+			e820__range_update(start_at, mem_size, from, to);
+		else if (to)
+			e820__range_add(start_at, mem_size, to);
+		else if (from)
+			e820__range_remove(start_at, mem_size, from, 1);
+		else
+			e820__range_remove(start_at, mem_size, 0, 0);
 	} else {
 		e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);
 	}

commit d68baa3fa6e4d703fd0c7954ee5c739789e7242f
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Mon Jul 17 16:10:12 2017 -0500

    x86/boot/e820: Add support to determine the E820 type of an address
    
    Add a function that will return the E820 type associated with an address
    range.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brijesh Singh <brijesh.singh@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Radim Krƒçm√°≈ô <rkrcmar@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Toshimitsu Kani <toshi.kani@hpe.com>
    Cc: kasan-dev@googlegroups.com
    Cc: kvm@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Cc: linux-mm@kvack.org
    Link: http://lkml.kernel.org/r/b797aaa588803bf33263d5dd8c32377668fa931a.1500319216.git.thomas.lendacky@amd.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 532da61d605c..71c11ad5643e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -96,7 +96,8 @@ EXPORT_SYMBOL_GPL(e820__mapped_any);
  * Note: this function only works correctly once the E820 table is sorted and
  * not-overlapping (at least for the range specified), which is the case normally.
  */
-bool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
+static struct e820_entry *__e820__mapped_all(u64 start, u64 end,
+					     enum e820_type type)
 {
 	int i;
 
@@ -122,9 +123,28 @@ bool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
 		 * coverage of the desired range exists:
 		 */
 		if (start >= end)
-			return 1;
+			return entry;
 	}
-	return 0;
+
+	return NULL;
+}
+
+/*
+ * This function checks if the entire range <start,end> is mapped with type.
+ */
+bool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
+{
+	return __e820__mapped_all(start, end, type);
+}
+
+/*
+ * This function returns the type associated with the range <start,end>.
+ */
+int e820__get_entry_type(u64 start, u64 end)
+{
+	struct e820_entry *entry = __e820__mapped_all(start, end, 0);
+
+	return entry ? entry->type : -EINVAL;
 }
 
 /*

commit 12df216c61c89e31e27e74146115a9728880ca6f
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jul 3 01:07:32 2017 +0800

    x86/boot/e820: Introduce the bootloader provided e820_table_firmware[] table
    
    Add the real e820_tabel_firmware[] that will not be modified by the kernel
    or the EFI boot stub under any circumstance.
    
    In addition to that modify the code so that e820_table_firmwarep[] is
    exposed via sysfs to represent the real firmware memory layout,
    rather than exposing the e820_table_kexec[] table.
    
    This fixes a hibernation bug/warning, which uses e820_table_kexec[] to check
    RAM layout consistency across hibernation/resume:
    
      The suspend kernel:
      [    0.000000] e820: update [mem 0x76671018-0x76679457] usable ==> usable
    
      The resume kernel:
      [    0.000000] e820: update [mem 0x7666f018-0x76677457] usable ==> usable
      ...
      [   15.752088] PM: Using 3 thread(s) for decompression.
      [   15.752088] PM: Loading and decompressing image data (471870 pages)...
      [   15.764971] Hibernate inconsistent memory map detected!
      [   15.770833] PM: Image mismatch: architecture specific data
    
    Actually it is safe to restore these pages because E820_TYPE_RAM and
    E820_TYPE_RESERVED_KERN are treated the same during hibernation, so
    the original e820 table provided by the bootloader is used for
    hibernation MD5 fingerprint checking.
    
    The side effect is that, this newly introduced variable might increase the
    kernel size at compile time.
    
    Suggested-by: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 591019031e23..532da61d605c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -20,10 +20,12 @@
 #include <asm/setup.h>
 
 /*
- * We organize the E820 table into two main data structures:
+ * We organize the E820 table into three main data structures:
  *
- * - 'e820_table_kexec': the original firmware version passed to us by the
- *   bootloader - not modified by the kernel. We use this to:
+ * - 'e820_table_firmware': the original firmware version passed to us by the
+ *   bootloader - not modified by the kernel. It is composed of two parts:
+ *   the first 128 E820 memory entries in boot_params.e820_table and the remaining
+ *   (if any) entries of the SETUP_E820_EXT nodes. We use this to:
  *
  *       - inform the user about the firmware's notion of memory layout
  *         via /sys/firmware/memmap
@@ -31,6 +33,14 @@
  *       - the hibernation code uses it to generate a kernel-independent MD5
  *         fingerprint of the physical memory layout of a system.
  *
+ * - 'e820_table_kexec': a slightly modified (by the kernel) firmware version
+ *   passed to us by the bootloader - the major difference between
+ *   e820_table_firmware[] and this one is that, the latter marks the setup_data
+ *   list created by the EFI boot stub as reserved, so that kexec can reuse the
+ *   setup_data information in the second kernel. Besides, e820_table_kexec[]
+ *   might also be modified by the kexec itself to fake a mptable.
+ *   We use this to:
+ *
  *       - kexec, which is a bootloader in disguise, uses the original E820
  *         layout to pass to the kexec-ed kernel. This way the original kernel
  *         can have a restricted E820 map while the kexec()-ed kexec-kernel
@@ -47,9 +57,11 @@
  */
 static struct e820_table e820_table_init		__initdata;
 static struct e820_table e820_table_kexec_init		__initdata;
+static struct e820_table e820_table_firmware_init	__initdata;
 
 struct e820_table *e820_table __refdata			= &e820_table_init;
 struct e820_table *e820_table_kexec __refdata		= &e820_table_kexec_init;
+struct e820_table *e820_table_firmware __refdata	= &e820_table_firmware_init;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -648,6 +660,12 @@ __init void e820__reallocate_tables(void)
 	BUG_ON(!n);
 	memcpy(n, e820_table_kexec, size);
 	e820_table_kexec = n;
+
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;
+	n = kmalloc(size, GFP_KERNEL);
+	BUG_ON(!n);
+	memcpy(n, e820_table_firmware, size);
+	e820_table_firmware = n;
 }
 
 /*
@@ -670,6 +688,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	e820__update_table(e820_table);
 
 	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
+	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
@@ -1064,8 +1083,9 @@ void __init e820__reserve_resources(void)
 		res++;
 	}
 
-	for (i = 0; i < e820_table_kexec->nr_entries; i++) {
-		struct e820_entry *entry = e820_table_kexec->entries + i;
+	/* Expose the bootloader-provided memory layout to the sysfs. */
+	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
+		struct e820_entry *entry = e820_table_firmware->entries + i;
 
 		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry));
 	}
@@ -1178,6 +1198,7 @@ void __init e820__memory_setup(void)
 	who = x86_init.resources.memory_setup();
 
 	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
+	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 
 	pr_info("e820: BIOS-provided physical RAM map:\n");
 	e820__print_table(who);

commit a09bae0f8aa08d4d76d0ebece26062a49ec51ac9
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jul 3 01:07:12 2017 +0800

    x86/boot/e820: Rename the e820_table_firmware to e820_table_kexec
    
    Currently the e820_table_firmware[] table is mainly used by the kexec,
    and it is not what it's supposed to be - despite its name it might be
    modified by the kernel.
    
    So change its name to e820_table_kexec[]. In the next patch we will
    introduce the real e820_table_firmware[] table.
    
    No functional change.
    
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c87223e5b1aa..591019031e23 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -22,7 +22,7 @@
 /*
  * We organize the E820 table into two main data structures:
  *
- * - 'e820_table_firmware': the original firmware version passed to us by the
+ * - 'e820_table_kexec': the original firmware version passed to us by the
  *   bootloader - not modified by the kernel. We use this to:
  *
  *       - inform the user about the firmware's notion of memory layout
@@ -46,10 +46,10 @@
  * specific memory layout data during early bootup.
  */
 static struct e820_table e820_table_init		__initdata;
-static struct e820_table e820_table_firmware_init	__initdata;
+static struct e820_table e820_table_kexec_init		__initdata;
 
 struct e820_table *e820_table __refdata			= &e820_table_init;
-struct e820_table *e820_table_firmware __refdata	= &e820_table_firmware_init;
+struct e820_table *e820_table_kexec __refdata		= &e820_table_kexec_init;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -470,9 +470,9 @@ u64 __init e820__range_update(u64 start, u64 size, enum e820_type old_type, enum
 	return __e820__range_update(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820__range_update_firmware(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)
+static u64 __init e820__range_update_kexec(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)
 {
-	return __e820__range_update(e820_table_firmware, start, size, old_type, new_type);
+	return __e820__range_update(e820_table_kexec, start, size, old_type, new_type);
 }
 
 /* Remove a range of memory from the E820 table: */
@@ -546,9 +546,9 @@ void __init e820__update_table_print(void)
 	e820__print_table("modified");
 }
 
-static void __init e820__update_table_firmware(void)
+static void __init e820__update_table_kexec(void)
 {
-	e820__update_table(e820_table_firmware);
+	e820__update_table(e820_table_kexec);
 }
 
 #define MAX_GAP_END 0x100000000ull
@@ -623,7 +623,7 @@ __init void e820__setup_pci_gap(void)
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820_table and e820_table_firmware are largish __initdata arrays.
+ * Initial e820_table and e820_table_kexec are largish __initdata arrays.
  *
  * Copy them to a (usually much smaller) dynamically allocated area that is
  * sized precisely after the number of e820 entries.
@@ -643,11 +643,11 @@ __init void e820__reallocate_tables(void)
 	memcpy(n, e820_table, size);
 	e820_table = n;
 
-	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_kexec->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table_firmware, size);
-	e820_table_firmware = n;
+	memcpy(n, e820_table_kexec, size);
+	e820_table_kexec = n;
 }
 
 /*
@@ -669,7 +669,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	__append_e820_table(extmap, entries);
 	e820__update_table(e820_table);
 
-	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
@@ -729,7 +729,7 @@ core_initcall(e820__register_nvs_regions);
 /*
  * Allocate the requested number of bytes with the requsted alignment
  * and return (the physical address) to the caller. Also register this
- * range in the 'firmware' E820 table as a reserved range.
+ * range in the 'kexec' E820 table as a reserved range.
  *
  * This allows kexec to fake a new mptable, as if it came from the real
  * system.
@@ -740,9 +740,9 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
-		e820__range_update_firmware(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
-		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
-		e820__update_table_firmware();
+		e820__range_update_kexec(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
+		pr_info("e820: update e820_table_kexec for e820__memblock_alloc_reserved()\n");
+		e820__update_table_kexec();
 	}
 
 	return addr;
@@ -925,13 +925,13 @@ void __init e820__reserve_setup_data(void)
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
 		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
-		e820__range_update_firmware(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+		e820__range_update_kexec(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}
 
 	e820__update_table(e820_table);
-	e820__update_table(e820_table_firmware);
+	e820__update_table(e820_table_kexec);
 
 	pr_info("extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");
@@ -1064,8 +1064,8 @@ void __init e820__reserve_resources(void)
 		res++;
 	}
 
-	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
-		struct e820_entry *entry = e820_table_firmware->entries + i;
+	for (i = 0; i < e820_table_kexec->nr_entries; i++) {
+		struct e820_entry *entry = e820_table_kexec->entries + i;
 
 		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry));
 	}
@@ -1177,7 +1177,7 @@ void __init e820__memory_setup(void)
 
 	who = x86_init.resources.memory_setup();
 
-	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
 
 	pr_info("e820: BIOS-provided physical RAM map:\n");
 	e820__print_table(who);

commit b7a67e02cd2b0d632114dcfb4bfb9b1d85dee325
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jul 3 01:06:28 2017 +0800

    x86/boot/e820: Avoid overwriting e820_table_firmware
    
    The following commit in 2013:
    
      77ea8c948953 ("x86: Reserve setup_data ranges late after parsing memmap cmdline")
    
    has fixed the issue of losing setup_data information by deferring the
    e820_reserve_setup_data() call until the early params have been parsed.
    
    But this also introduced a new problem that, during early params parsing,
    the kexec kernel might fake a mptable and saves it into the e820_table_firmware[]
    table (without saving the mptable to the e820_table[]), however the subsequent
    invoking of e820_reserve_setup_data() will overwrite the e820_table_firmware[]
    according to the e820_table[], thus the fake mptable information is lost.
    
    Fix this issue by updating the e820_table_firmware[] according to
    the setup_data information, but without overwriting it.
    
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d78a586ba8dc..c87223e5b1aa 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -669,6 +669,8 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	__append_e820_table(extmap, entries);
 	e820__update_table(e820_table);
 
+	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
 	e820__print_table("extended");
@@ -923,13 +925,13 @@ void __init e820__reserve_setup_data(void)
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
 		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+		e820__range_update_firmware(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}
 
 	e820__update_table(e820_table);
-
-	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+	e820__update_table(e820_table_firmware);
 
 	pr_info("extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");

commit ace2fb5a8b65d6aba530068ea9331f18e10ef565
Author: Colin King <colin.king@canonical.com>
Date:   Thu Apr 13 16:59:12 2017 +0100

    x86/boot/e820: Remove a redundant self assignment
    
    Remove a redundant self assignment of table->nr_entries, it does
    nothing and is an artifact of code simplification re-work.
    
    Detected by CoverityScan, CID#1428450 ("Self assignment")
    
    Fixes: 441ac2f33dd7 ("x86/boot/e820: Simplify e820__update_table()")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: kernel-janitors@vger.kernel.org
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Link: http://lkml.kernel.org/r/20170413155912.12078-1-colin.king@canonical.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 6e9b26fa6d05..d78a586ba8dc 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -270,7 +270,6 @@ int __init e820__update_table(struct e820_table *table)
 	if (table->nr_entries < 2)
 		return -1;
 
-	table->nr_entries = table->nr_entries;
 	BUG_ON(table->nr_entries > max_nr_entries);
 
 	/* Bail out if we find any unreasonable addresses in the map: */

commit e22af0be2cf654bb225f19750c6b9aab1627dc9e
Author: Borislav Petkov <bp@alien8.de>
Date:   Tue Jan 31 18:53:34 2017 +0100

    x86/boot: Fix pr_debug() API braindamage
    
    What looked like a straightforward conversion from printk(KERN_DEBUG, ...)
    to pr_debug() broke the boot log output:
    
      DMI:    /M57SLI-S4, BIOS FF 01/24/2008
     -e820: update [mem 0x00000000-0x00000fff] usable ==> reserved
     -e820: remove [mem 0x000a0000-0x000fffff] usable
     +usable ==> reserved
     +usable
      e820: last_pfn = 0x230000 max_arch_pfn = 0x400000000
    
     ...
    
      x86/PAT: Configuration [0-7]: WB  WC  UC- UC  WB  WC  UC- WT
     -e820: update [mem 0xd0000000-0xffffffff] usable ==> reserved
     +usable ==> reserved
    
    i.e. spurious (and nonsensical) kernel log entries were created...
    
    We need a pr_debug_and_I_mean_it() function which does nothing but
    printk(KERN_DEBUG...
    
    Signed-off-by: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    [ Wrote changelog. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e2fb20ac5135..6e9b26fa6d05 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -411,7 +411,7 @@ __e820__range_update(struct e820_table *table, u64 start, u64 size, enum e820_ty
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	pr_debug("e820: update [mem %#010Lx-%#010Lx] ", start, end - 1);
+	printk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ", start, end - 1);
 	e820_print_type(old_type);
 	pr_cont(" ==> ");
 	e820_print_type(new_type);
@@ -487,7 +487,7 @@ u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, bool
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	pr_debug("e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
+	printk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
 	if (check_type)
 		e820_print_type(old_type);
 	pr_cont("\n");
@@ -1121,7 +1121,7 @@ void __init e820__reserve_resources_late(void)
 		if (start >= end)
 			continue;
 
-		pr_debug("e820: reserve RAM buffer [mem %#010llx-%#010llx]\n", start, end);
+		printk(KERN_DEBUG "e820: reserve RAM buffer [mem %#010llx-%#010llx]\n", start, end);
 		reserve_region_with_split(&iomem_resource, start, end, "RAM buffer");
 	}
 }

commit 441ac2f33dd7860295cf1d225358ec01d38408b2
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Jan 30 09:24:39 2017 +0100

    x86/boot/e820: Simplify e820__update_table()
    
     - Remove the now unnecessary __e820__update_table() wrappery
    
     - Move statics out from function scope, to make the logic clearer
    
     - Rename local variables to be more in line with the rest of 820.c
    
     - Remove unnecessary local variables: old_nr, *nr_entries
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 2da2f7238a72..e2fb20ac5135 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -235,6 +235,11 @@ struct change_member {
 	unsigned long long	addr;
 };
 
+static struct change_member	change_point_list[2*E820_MAX_ENTRIES]	__initdata;
+static struct change_member	*change_point[2*E820_MAX_ENTRIES]	__initdata;
+static struct e820_entry	*overlap_list[E820_MAX_ENTRIES]		__initdata;
+static struct e820_entry	new_entries[E820_MAX_ENTRIES]		__initdata;
+
 static int __init cpcompare(const void *a, const void *b)
 {
 	struct change_member * const *app = a, * const *bpp = b;
@@ -252,51 +257,46 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->entry->addr) - (bp->addr != bp->entry->addr);
 }
 
-static int __init __e820__update_table(struct e820_entry *entries, u32 max_nr_entries, u32 *nr_entries)
+int __init e820__update_table(struct e820_table *table)
 {
-	static struct change_member change_point_list[2*E820_MAX_ENTRIES] __initdata;
-	static struct change_member *change_point[2*E820_MAX_ENTRIES] __initdata;
-	static struct e820_entry *overlap_list[E820_MAX_ENTRIES] __initdata;
-	static struct e820_entry new_entries[E820_MAX_ENTRIES] __initdata;
+	struct e820_entry *entries = table->entries;
+	u32 max_nr_entries = ARRAY_SIZE(table->entries);
 	enum e820_type current_type, last_type;
 	unsigned long long last_addr;
-	u32 chgidx;
-	u32 overlap_entries;
-	u32 new_nr_entries;
-	u32 old_nr, new_nr, chg_nr;
-	u32 i;
+	u32 new_nr_entries, overlap_entries;
+	u32 i, chg_idx, chg_nr;
 
 	/* If there's only one memory region, don't bother: */
-	if (*nr_entries < 2)
+	if (table->nr_entries < 2)
 		return -1;
 
-	old_nr = *nr_entries;
-	BUG_ON(old_nr > max_nr_entries);
+	table->nr_entries = table->nr_entries;
+	BUG_ON(table->nr_entries > max_nr_entries);
 
 	/* Bail out if we find any unreasonable addresses in the map: */
-	for (i = 0; i < old_nr; i++) {
+	for (i = 0; i < table->nr_entries; i++) {
 		if (entries[i].addr + entries[i].size < entries[i].addr)
 			return -1;
 	}
 
 	/* Create pointers for initial change-point information (for sorting): */
-	for (i = 0; i < 2 * old_nr; i++)
+	for (i = 0; i < 2 * table->nr_entries; i++)
 		change_point[i] = &change_point_list[i];
 
 	/*
 	 * Record all known change-points (starting and ending addresses),
 	 * omitting empty memory regions:
 	 */
-	chgidx = 0;
-	for (i = 0; i < old_nr; i++)	{
+	chg_idx = 0;
+	for (i = 0; i < table->nr_entries; i++)	{
 		if (entries[i].size != 0) {
-			change_point[chgidx]->addr	= entries[i].addr;
-			change_point[chgidx++]->entry	= &entries[i];
-			change_point[chgidx]->addr	= entries[i].addr + entries[i].size;
-			change_point[chgidx++]->entry	= &entries[i];
+			change_point[chg_idx]->addr	= entries[i].addr;
+			change_point[chg_idx++]->entry	= &entries[i];
+			change_point[chg_idx]->addr	= entries[i].addr + entries[i].size;
+			change_point[chg_idx++]->entry	= &entries[i];
 		}
 	}
-	chg_nr = chgidx;
+	chg_nr = chg_idx;
 
 	/* Sort change-point list by memory addresses (low -> high): */
 	sort(change_point, chg_nr, sizeof(*change_point), cpcompare, NULL);
@@ -308,15 +308,15 @@ static int __init __e820__update_table(struct e820_entry *entries, u32 max_nr_en
 	last_addr = 0;		 /* Start with 0 as last starting address */
 
 	/* Loop through change-points, determining effect on the new map: */
-	for (chgidx = 0; chgidx < chg_nr; chgidx++) {
+	for (chg_idx = 0; chg_idx < chg_nr; chg_idx++) {
 		/* Keep track of all overlapping entries */
-		if (change_point[chgidx]->addr == change_point[chgidx]->entry->addr) {
+		if (change_point[chg_idx]->addr == change_point[chg_idx]->entry->addr) {
 			/* Add map entry to overlap list (> 1 entry implies an overlap) */
-			overlap_list[overlap_entries++] = change_point[chgidx]->entry;
+			overlap_list[overlap_entries++] = change_point[chg_idx]->entry;
 		} else {
 			/* Remove entry from list (order independent, so swap with last): */
 			for (i = 0; i < overlap_entries; i++) {
-				if (overlap_list[i] == change_point[chgidx]->entry)
+				if (overlap_list[i] == change_point[chg_idx]->entry)
 					overlap_list[i] = overlap_list[overlap_entries-1];
 			}
 			overlap_entries--;
@@ -335,7 +335,7 @@ static int __init __e820__update_table(struct e820_entry *entries, u32 max_nr_en
 		/* Continue building up new map based on this information: */
 		if (current_type != last_type || current_type == E820_TYPE_PRAM) {
 			if (last_type != 0)	 {
-				new_entries[new_nr_entries].size = change_point[chgidx]->addr - last_addr;
+				new_entries[new_nr_entries].size = change_point[chg_idx]->addr - last_addr;
 				/* Move forward only if the new size was non-zero: */
 				if (new_entries[new_nr_entries].size != 0)
 					/* No more space left for new entries? */
@@ -343,29 +343,21 @@ static int __init __e820__update_table(struct e820_entry *entries, u32 max_nr_en
 						break;
 			}
 			if (current_type != 0)	{
-				new_entries[new_nr_entries].addr = change_point[chgidx]->addr;
+				new_entries[new_nr_entries].addr = change_point[chg_idx]->addr;
 				new_entries[new_nr_entries].type = current_type;
-				last_addr = change_point[chgidx]->addr;
+				last_addr = change_point[chg_idx]->addr;
 			}
 			last_type = current_type;
 		}
 	}
 
-	/* Retain count for the new entries: */
-	new_nr = new_nr_entries;
-
 	/* Copy the new entries into the original location: */
-	memcpy(entries, new_entries, new_nr*sizeof(*entries));
-	*nr_entries = new_nr;
+	memcpy(entries, new_entries, new_nr_entries*sizeof(*entries));
+	table->nr_entries = new_nr_entries;
 
 	return 0;
 }
 
-int __init e820__update_table(struct e820_table *table)
-{
-	return __e820__update_table(table->entries, ARRAY_SIZE(table->entries), &table->nr_entries);
-}
-
 static int __init __append_e820_table(struct boot_e820_entry *entries, u32 nr_entries)
 {
 	struct boot_e820_entry *entry = entries;

commit 7410aa1ca377aa8c5ed340647b5228e7b5d0494a
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jan 29 12:56:13 2017 +0100

    x86/boot/e820: Separate the E820 ABI structures from the in-kernel structures
    
    Linus pointed out that relying on the compiler to pack structures with
    enums is fragile not just for the kernel, but for external tooling as
    well which might rely on our UAPI headers.
    
    So separate the two from each other: introduce 'struct boot_e820_entry',
    which is the boot protocol entry format.
    
    This actually simplifies the code, as e820__update_table() is now never
    called directly with boot protocol table entries - we can rely on
    append_e820_table() and do a e820__update_table() call afterwards.
    
    ( This will allow further simplifications of __e820__update_table(),
      but that will be done in a separate patch. )
    
    This change also has the side effect of not modifying the bootparams structure
    anymore - which might be useful for debugging. In theory we could even constify
    the boot_params structure - at least from the E820 code's point of view.
    
    Remove the uapi/asm/e820/types.h file, as it's not used anymore - all
    kernel side E820 types are defined in asm/e820/types.h.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 20834a81854e..2da2f7238a72 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -366,9 +366,9 @@ int __init e820__update_table(struct e820_table *table)
 	return __e820__update_table(table->entries, ARRAY_SIZE(table->entries), &table->nr_entries);
 }
 
-static int __init __append_e820_table(struct e820_entry *entries, u32 nr_entries)
+static int __init __append_e820_table(struct boot_e820_entry *entries, u32 nr_entries)
 {
-	struct e820_entry *entry = entries;
+	struct boot_e820_entry *entry = entries;
 
 	while (nr_entries) {
 		u64 start = entry->addr;
@@ -397,7 +397,7 @@ static int __init __append_e820_table(struct e820_entry *entries, u32 nr_entries
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-static int __init append_e820_table(struct e820_entry *entries, u32 nr_entries)
+static int __init append_e820_table(struct boot_e820_entry *entries, u32 nr_entries)
 {
 	/* Only one memory region (or negative)? Ignore it */
 	if (nr_entries < 2)
@@ -668,12 +668,12 @@ __init void e820__reallocate_tables(void)
 void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 {
 	int entries;
-	struct e820_entry *extmap;
+	struct boot_e820_entry *extmap;
 	struct setup_data *sdata;
 
 	sdata = early_memremap(phys_addr, data_len);
 	entries = sdata->len / sizeof(*extmap);
-	extmap = (struct e820_entry *)(sdata->data);
+	extmap = (struct boot_e820_entry *)(sdata->data);
 
 	__append_e820_table(extmap, entries);
 	e820__update_table(e820_table);
@@ -1140,7 +1140,6 @@ void __init e820__reserve_resources_late(void)
 char *__init e820__memory_setup_default(void)
 {
 	char *who = "BIOS-e820";
-	u32 new_nr;
 
 	/*
 	 * Try to copy the BIOS-supplied E820-map.
@@ -1148,10 +1147,6 @@ char *__init e820__memory_setup_default(void)
 	 * Otherwise fake a memory map; one section from 0k->640k,
 	 * the next section from 1mb->appropriate_mem_k
 	 */
-	new_nr = boot_params.e820_entries;
-	__e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
-	boot_params.e820_entries = new_nr;
-
 	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries) < 0) {
 		u64 mem_size;
 
@@ -1169,6 +1164,9 @@ char *__init e820__memory_setup_default(void)
 		e820__range_add(HIGH_MEMORY, mem_size << 10, E820_TYPE_RAM);
 	}
 
+	/* We just appended a lot of ranges, sanitize the table: */
+	e820__update_table(e820_table);
+
 	return who;
 }
 
@@ -1182,7 +1180,7 @@ void __init e820__memory_setup(void)
 	char *who;
 
 	/* This is a firmware interface ABI - make sure we don't break it: */
-	BUILD_BUG_ON(sizeof(struct e820_entry) != 20);
+	BUILD_BUG_ON(sizeof(struct boot_e820_entry) != 20);
 
 	who = x86_init.resources.memory_setup();
 

commit c5231a57eb406c70a96f8e515abc49daa0af697b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jan 29 09:40:26 2017 +0100

    x86/boot/e820: Fix and clean up e820_type switch() statements
    
    A test-build of e820.o with -Wswitch-enum shows the following warnings:
    
      arch/x86/kernel/e820.c: In function ‚Äòe820_type_to_string‚Äô:
      arch/x86/kernel/e820.c:965:2: warning: enumeration value ‚ÄòE820_TYPE_RESERVED‚Äô not handled in switch [-Wswitch-enum]
        switch (entry->type) {
        ^
    
      arch/x86/kernel/e820.c: In function ‚Äòe820_type_to_iomem_type‚Äô:
      arch/x86/kernel/e820.c:979:2: warning: enumeration value ‚ÄòE820_TYPE_RESERVED‚Äô not handled in switch [-Wswitch-enum]
        switch (entry->type) {
        ^
    
      arch/x86/kernel/e820.c: In function ‚Äòe820_type_to_iores_desc‚Äô:
      arch/x86/kernel/e820.c:993:2: warning: enumeration value ‚ÄòE820_TYPE_RESERVED‚Äô not handled in switch [-Wswitch-enum]
        switch (entry->type) {
        ^
    
      arch/x86/kernel/e820.c: In function ‚Äòdo_mark_busy‚Äô:
      arch/x86/kernel/e820.c:1015:2: warning: enumeration value ‚ÄòE820_TYPE_RAM‚Äô not handled in switch [-Wswitch-enum]
        switch (type) {
                ^
    
    Here's the four warnings:
    
      - The one in e820_type_to_string() is a borderline bug, we should differentiate
        known-reserved E820 types from unknown types. Fix it by printing a separate
        message for unknown E820 types.
    
      - The ones in e820_type_to_iomem_type(), e820_type_to_iores_desc() and
        do_mark_busy() are worth documenting, at least to the extent of
        enumerating them explicitly.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d2c6468a8d38..20834a81854e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -970,7 +970,8 @@ static const char *__init e820_type_to_string(struct e820_entry *entry)
 	case E820_TYPE_UNUSABLE:	return "Unusable memory";
 	case E820_TYPE_PRAM:		return "Persistent Memory (legacy)";
 	case E820_TYPE_PMEM:		return "Persistent Memory";
-	default:			return "Reserved";
+	case E820_TYPE_RESERVED:	return "Reserved";
+	default:			return "Unknown E820 type";
 	}
 }
 
@@ -984,6 +985,7 @@ static unsigned long __init e820_type_to_iomem_type(struct e820_entry *entry)
 	case E820_TYPE_UNUSABLE:	/* Fall-through: */
 	case E820_TYPE_PRAM:		/* Fall-through: */
 	case E820_TYPE_PMEM:		/* Fall-through: */
+	case E820_TYPE_RESERVED:	/* Fall-through: */
 	default:			return IORESOURCE_MEM;
 	}
 }
@@ -998,11 +1000,12 @@ static unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)
 	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
 	case E820_TYPE_RAM:		/* Fall-through: */
 	case E820_TYPE_UNUSABLE:	/* Fall-through: */
+	case E820_TYPE_RESERVED:	/* Fall-through: */
 	default:			return IORES_DESC_NONE;
 	}
 }
 
-static bool __init do_mark_busy(u32 type, struct resource *res)
+static bool __init do_mark_busy(enum e820_type type, struct resource *res)
 {
 	/* this is the legacy bios/dos rom-shadow + mmio region */
 	if (res->start < (1ULL<<20))
@@ -1017,6 +1020,11 @@ static bool __init do_mark_busy(u32 type, struct resource *res)
 	case E820_TYPE_PRAM:
 	case E820_TYPE_PMEM:
 		return false;
+	case E820_TYPE_RESERVED_KERN:
+	case E820_TYPE_RAM:
+	case E820_TYPE_ACPI:
+	case E820_TYPE_NVS:
+	case E820_TYPE_UNUSABLE:
 	default:
 		return true;
 	}

commit 0c6fc11ac343c82d4a2f8348fa6f829e07c12554
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:52:16 2017 +0100

    x86/boot/e820: Rename the remaining E820 APIs to the e820__*() prefix
    
    Three more renames left:
    
       e820_end_of_ram_pfn()      =>  e820__end_of_ram_pfn()
       e820_end_of_low_ram_pfn()  =>  e820__end_of_low_ram_pfn()
       e820_reallocate_tables()   =>  e820__reallocate_tables()
    
    After this all E820 API calls are prefixed with "e820__", making
    it much easier to grep for E820 functionality in the kernel.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 9d179676a89e..d2c6468a8d38 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -641,7 +641,7 @@ __init void e820__setup_pci_gap(void)
  * All functions which modify them are __init functions, which won't exist
  * after free_initmem().
  */
-__init void e820_reallocate_tables(void)
+__init void e820__reallocate_tables(void)
 {
 	struct e820_table *n;
 	int size;
@@ -803,12 +803,12 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, enum e820_type
 	return last_pfn;
 }
 
-unsigned long __init e820_end_of_ram_pfn(void)
+unsigned long __init e820__end_of_ram_pfn(void)
 {
 	return e820_end_pfn(MAX_ARCH_PFN, E820_TYPE_RAM);
 }
 
-unsigned long __init e820_end_of_low_ram_pfn(void)
+unsigned long __init e820__end_of_low_ram_pfn(void)
 {
 	return e820_end_pfn(1UL << (32 - PAGE_SHIFT), E820_TYPE_RAM);
 }
@@ -867,7 +867,7 @@ static int __init parse_memmap_one(char *p)
 		 * the real memory size before the original memory map is
 		 * reset.
 		 */
-		saved_max_pfn = e820_end_of_ram_pfn();
+		saved_max_pfn = e820__end_of_ram_pfn();
 #endif
 		e820_table->nr_entries = 0;
 		userdef = 1;

commit dd618c7256121c753f3c7451e159f2ae53b73d3c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:49:39 2017 +0100

    x86/boot/e820: Remove unnecessary #include's
    
    A number of headers were included into e820.c unnecessarily - remove them.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 97d1250f7507..9d179676a89e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -8,13 +8,8 @@
  * quirks and other tweaks, and feeds that into the generic Linux memory
  * allocation code routines via a platform independent interface (memblock, etc.).
  */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
 #include <linux/crash_dump.h>
-#include <linux/export.h>
 #include <linux/bootmem.h>
-#include <linux/pfn.h>
 #include <linux/suspend.h>
 #include <linux/acpi.h>
 #include <linux/firmware-map.h>
@@ -22,9 +17,7 @@
 #include <linux/sort.h>
 
 #include <asm/e820/api.h>
-#include <asm/proto.h>
 #include <asm/setup.h>
-#include <asm/cpufeature.h>
 
 /*
  * We organize the E820 table into two main data structures:

commit 090d717164eec7d7bf7c0db396a123e1f9157dbf
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:44:12 2017 +0100

    x86/boot/e820: Rename e820_mark_nosave_regions() to e820__register_nosave_regions()
    
    This function is a minor misnomer: it is talking about 'marking' regions
    as nosave - while the hibernation API is called register_nosave_region()
    and the e820_mark_nosave_regions() is a wrapper around that functionality.
    
    So name it to be in line with the API it is derived from.
    
    ( Rename e820_mark_nvs_memory() to e820__register_nvs_regions(), for similar
      reasons. )
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 552cb9f74dd3..97d1250f7507 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -690,15 +690,15 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	e820__print_table("extended");
 }
 
-/**
+/*
  * Find the ranges of physical addresses that do not correspond to
- * E820 RAM areas and mark the corresponding pages as 'nosave' for
+ * E820 RAM areas and register the corresponding pages as 'nosave' for
  * hibernation (32-bit) or software suspend and suspend to RAM (64-bit).
  *
  * This function requires the E820 map to be sorted and without any
  * overlapping entries.
  */
-void __init e820_mark_nosave_regions(unsigned long limit_pfn)
+void __init e820__register_nosave_regions(unsigned long limit_pfn)
 {
 	int i;
 	unsigned long pfn = 0;
@@ -724,7 +724,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
  * Register ACPI NVS memory regions, so that we can save/restore them during
  * hibernation and the subsequent resume:
  */
-static int __init e820_mark_nvs_memory(void)
+static int __init e820__register_nvs_regions(void)
 {
 	int i;
 
@@ -737,7 +737,7 @@ static int __init e820_mark_nvs_memory(void)
 
 	return 0;
 }
-core_initcall(e820_mark_nvs_memory);
+core_initcall(e820__register_nvs_regions);
 #endif
 
 /*

commit 1506c8dc947251bfd02f8186b5e81657a9635112
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:41:14 2017 +0100

    x86/boot/e820: Rename e820_reserve_resources*() to e820__reserve_resources*()
    
    Also do some minor cleanups.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index aa80166a0ec6..552cb9f74dd3 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -629,7 +629,7 @@ __init void e820__setup_pci_gap(void)
 	}
 
 	/*
-	 * e820_reserve_resources_late protect stolen RAM already
+	 * e820__reserve_resources_late() protects stolen RAM already:
 	 */
 	pci_mem_start = gapstart;
 
@@ -1035,7 +1035,7 @@ static bool __init do_mark_busy(u32 type, struct resource *res)
 
 static struct resource __initdata *e820_res;
 
-void __init e820_reserve_resources(void)
+void __init e820__reserve_resources(void)
 {
 	int i;
 	struct resource *res;
@@ -1059,9 +1059,9 @@ void __init e820_reserve_resources(void)
 		res->desc  = e820_type_to_iores_desc(entry);
 
 		/*
-		 * don't register the region that could be conflicted with
-		 * pci device BAR resource and insert them later in
-		 * pcibios_resource_survey()
+		 * Don't register the region that could be conflicted with
+		 * PCI device BAR resources and insert them later in
+		 * pcibios_resource_survey():
 		 */
 		if (do_mark_busy(entry->type, res)) {
 			res->flags |= IORESOURCE_BUSY;
@@ -1077,7 +1077,9 @@ void __init e820_reserve_resources(void)
 	}
 }
 
-/* How much should we pad RAM ending depending on where it is? */
+/*
+ * How much should we pad the end of RAM, depending on where it is?
+ */
 static unsigned long __init ram_alignment(resource_size_t pos)
 {
 	unsigned long mb = pos >> 20;
@@ -1096,7 +1098,7 @@ static unsigned long __init ram_alignment(resource_size_t pos)
 
 #define MAX_RESOURCE_SIZE ((resource_size_t)-1)
 
-void __init e820_reserve_resources_late(void)
+void __init e820__reserve_resources_late(void)
 {
 	int i;
 	struct resource *res;

commit 81b3e090fa1f237d49c8feb2fa4afe2aabd3a4ff
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:34:55 2017 +0100

    x86/boot/e820: Use bool in query APIs
    
    Change e820__mapped_any() and e820__mapped_all()'s return type and
    e820__range_remove()'s check_type parameter to bool.
    
    Propagate it into arch/x86/pci/mmconfig-shared.c as this change
    affects a function signature there too.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 114625890337..aa80166a0ec6 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -68,7 +68,7 @@ EXPORT_SYMBOL(pci_mem_start);
  * This function checks if any part of the range <start,end> is mapped
  * with type.
  */
-int e820__mapped_any(u64 start, u64 end, enum e820_type type)
+bool e820__mapped_any(u64 start, u64 end, enum e820_type type)
 {
 	int i;
 
@@ -91,7 +91,7 @@ EXPORT_SYMBOL_GPL(e820__mapped_any);
  * Note: this function only works correctly once the E820 table is sorted and
  * not-overlapping (at least for the range specified), which is the case normally.
  */
-int __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
+bool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
 {
 	int i;
 
@@ -492,7 +492,7 @@ static u64 __init e820__range_update_firmware(u64 start, u64 size, enum e820_typ
 }
 
 /* Remove a range of memory from the E820 table: */
-u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int checktype)
+u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, bool check_type)
 {
 	int i;
 	u64 end;
@@ -503,7 +503,7 @@ u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int
 
 	end = start + size;
 	pr_debug("e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
-	if (checktype)
+	if (check_type)
 		e820_print_type(old_type);
 	pr_cont("\n");
 
@@ -512,7 +512,7 @@ u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int
 		u64 final_start, final_end;
 		u64 entry_end;
 
-		if (checktype && entry->type != old_type)
+		if (check_type && entry->type != old_type)
 			continue;
 
 		entry_end = entry->addr + entry->size;

commit 1a1270349a0710162a160eef4f2e360845e0f47d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 22:27:28 2017 +0100

    x86/boot/e820: Document e820__reserve_setup_data()
    
    Also clean it up a bit.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7dc430c03acb..114625890337 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -922,7 +922,12 @@ static int __init parse_memmap_opt(char *str)
 }
 early_param("memmap", parse_memmap_opt);
 
-void __init e820_reserve_setup_data(void)
+/*
+ * Reserve all entries from the bootloader's extensible data nodes list,
+ * because if present we are going to use it later on to fetch e820
+ * entries from it:
+ */
+void __init e820__reserve_setup_data(void)
 {
 	struct setup_data *data;
 	u64 pa_data;
@@ -939,8 +944,10 @@ void __init e820_reserve_setup_data(void)
 	}
 
 	e820__update_table(e820_table);
+
 	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
-	printk(KERN_INFO "extended physical RAM map:\n");
+
+	pr_info("extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");
 }
 

commit 9a02fd0f1efbace5939bc34c4080a175e8112e8c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 18:35:24 2017 +0100

    x86/boot/e820: Clean up __e820__update_table() et al
    
    The __e820__update_table() function has various weirdly named variables,
    such as 'pbios', 'biosmap' and 'pnr_map' which are pretty confusing
    and actively misleading at times.
    
    This weird naming found its way into other functions as well, such as
    __append_e820_table() and append_e820_table().
    
    Standardize the naming to make it all much easier to read:
    
            biosmap  ->  entries
            pbios    ->  entry
            nr_map   ->  nr_entries
            pnr_map  ->  nr_entries
            ...
    
    Also clean up the types used: entry indices routinely mixed u32 and int,
    standardize on u32 thoughout.
    
    Update the comments as well, while at it.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 49823e0a7aea..7dc430c03acb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -175,23 +175,23 @@ void __init e820__print_table(char *who)
 }
 
 /*
- * Sanitize the BIOS E820 map.
+ * Sanitize an E820 map.
  *
- * Some E820 responses include overlapping entries. The following
+ * Some E820 layouts include overlapping entries. The following
  * replaces the original E820 map with a new one, removing overlaps,
  * and resolving conflicting memory types in favor of highest
  * numbered type.
  *
- * The input parameter biosmap points to an array of 'struct
- * e820_entry' which on entry has elements in the range [0, *pnr_map)
- * valid, and which has space for up to max_nr_map entries.
+ * The input parameter 'entries' points to an array of 'struct
+ * e820_entry' which on entry has elements in the range [0, *nr_entries)
+ * valid, and which has space for up to max_nr_entries entries.
  * On return, the resulting sanitized E820 map entries will be in
- * overwritten in the same location, starting at biosmap.
+ * overwritten in the same location, starting at 'entries'.
  *
- * The integer pointed to by pnr_map must be valid on entry (the
- * current number of valid entries located at biosmap). If the
- * sanitizing succeeds the *pnr_map will be updated with the new
- * number of valid entries (something no more than max_nr_map).
+ * The integer pointed to by nr_entries must be valid on entry (the
+ * current number of valid entries located at 'entries'). If the
+ * sanitizing succeeds the *nr_entries will be updated with the new
+ * number of valid entries (something no more than max_nr_entries).
  *
  * The return value from e820__update_table() is zero if it
  * successfully 'sanitized' the map entries passed in, and is -1
@@ -236,8 +236,8 @@ void __init e820__print_table(char *who)
  *	   ______________________4_
  */
 struct change_member {
-	/* Pointer to the original BIOS entry: */
-	struct e820_entry	*pbios;
+	/* Pointer to the original entry: */
+	struct e820_entry	*entry;
 	/* Address for this change point: */
 	unsigned long long	addr;
 };
@@ -256,33 +256,33 @@ static int __init cpcompare(const void *a, const void *b)
 	if (ap->addr != bp->addr)
 		return ap->addr > bp->addr ? 1 : -1;
 
-	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
+	return (ap->addr != ap->entry->addr) - (bp->addr != bp->entry->addr);
 }
 
-static int __init __e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
+static int __init __e820__update_table(struct e820_entry *entries, u32 max_nr_entries, u32 *nr_entries)
 {
 	static struct change_member change_point_list[2*E820_MAX_ENTRIES] __initdata;
 	static struct change_member *change_point[2*E820_MAX_ENTRIES] __initdata;
 	static struct e820_entry *overlap_list[E820_MAX_ENTRIES] __initdata;
-	static struct e820_entry new_bios[E820_MAX_ENTRIES] __initdata;
+	static struct e820_entry new_entries[E820_MAX_ENTRIES] __initdata;
 	enum e820_type current_type, last_type;
 	unsigned long long last_addr;
-	int chgidx;
-	int overlap_entries;
-	int new_bios_entry;
-	int old_nr, new_nr, chg_nr;
-	int i;
+	u32 chgidx;
+	u32 overlap_entries;
+	u32 new_nr_entries;
+	u32 old_nr, new_nr, chg_nr;
+	u32 i;
 
 	/* If there's only one memory region, don't bother: */
-	if (*pnr_map < 2)
+	if (*nr_entries < 2)
 		return -1;
 
-	old_nr = *pnr_map;
-	BUG_ON(old_nr > max_nr_map);
+	old_nr = *nr_entries;
+	BUG_ON(old_nr > max_nr_entries);
 
-	/* Bail out if we find any unreasonable addresses in the BIOS map: */
+	/* Bail out if we find any unreasonable addresses in the map: */
 	for (i = 0; i < old_nr; i++) {
-		if (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)
+		if (entries[i].addr + entries[i].size < entries[i].addr)
 			return -1;
 	}
 
@@ -296,11 +296,11 @@ static int __init __e820__update_table(struct e820_entry *biosmap, int max_nr_ma
 	 */
 	chgidx = 0;
 	for (i = 0; i < old_nr; i++)	{
-		if (biosmap[i].size != 0) {
-			change_point[chgidx]->addr	= biosmap[i].addr;
-			change_point[chgidx++]->pbios	= &biosmap[i];
-			change_point[chgidx]->addr	= biosmap[i].addr + biosmap[i].size;
-			change_point[chgidx++]->pbios	= &biosmap[i];
+		if (entries[i].size != 0) {
+			change_point[chgidx]->addr	= entries[i].addr;
+			change_point[chgidx++]->entry	= &entries[i];
+			change_point[chgidx]->addr	= entries[i].addr + entries[i].size;
+			change_point[chgidx++]->entry	= &entries[i];
 		}
 	}
 	chg_nr = chgidx;
@@ -308,22 +308,22 @@ static int __init __e820__update_table(struct e820_entry *biosmap, int max_nr_ma
 	/* Sort change-point list by memory addresses (low -> high): */
 	sort(change_point, chg_nr, sizeof(*change_point), cpcompare, NULL);
 
-	/* Create a new BIOS memory map, removing overlaps: */
+	/* Create a new memory map, removing overlaps: */
 	overlap_entries = 0;	 /* Number of entries in the overlap table */
-	new_bios_entry = 0;	 /* Index for creating new bios map entries */
+	new_nr_entries = 0;	 /* Index for creating new map entries */
 	last_type = 0;		 /* Start with undefined memory type */
 	last_addr = 0;		 /* Start with 0 as last starting address */
 
-	/* Loop through change-points, determining effect on the new BIOS map: */
+	/* Loop through change-points, determining effect on the new map: */
 	for (chgidx = 0; chgidx < chg_nr; chgidx++) {
-		/* Keep track of all overlapping BIOS entries */
-		if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
+		/* Keep track of all overlapping entries */
+		if (change_point[chgidx]->addr == change_point[chgidx]->entry->addr) {
 			/* Add map entry to overlap list (> 1 entry implies an overlap) */
-			overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
+			overlap_list[overlap_entries++] = change_point[chgidx]->entry;
 		} else {
 			/* Remove entry from list (order independent, so swap with last): */
 			for (i = 0; i < overlap_entries; i++) {
-				if (overlap_list[i] == change_point[chgidx]->pbios)
+				if (overlap_list[i] == change_point[chgidx]->entry)
 					overlap_list[i] = overlap_list[overlap_entries-1];
 			}
 			overlap_entries--;
@@ -339,31 +339,31 @@ static int __init __e820__update_table(struct e820_entry *biosmap, int max_nr_ma
 				current_type = overlap_list[i]->type;
 		}
 
-		/* Continue building up new BIOS map based on this information: */
+		/* Continue building up new map based on this information: */
 		if (current_type != last_type || current_type == E820_TYPE_PRAM) {
 			if (last_type != 0)	 {
-				new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
+				new_entries[new_nr_entries].size = change_point[chgidx]->addr - last_addr;
 				/* Move forward only if the new size was non-zero: */
-				if (new_bios[new_bios_entry].size != 0)
-					/* No more space left for new BIOS entries? */
-					if (++new_bios_entry >= max_nr_map)
+				if (new_entries[new_nr_entries].size != 0)
+					/* No more space left for new entries? */
+					if (++new_nr_entries >= max_nr_entries)
 						break;
 			}
 			if (current_type != 0)	{
-				new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
-				new_bios[new_bios_entry].type = current_type;
+				new_entries[new_nr_entries].addr = change_point[chgidx]->addr;
+				new_entries[new_nr_entries].type = current_type;
 				last_addr = change_point[chgidx]->addr;
 			}
 			last_type = current_type;
 		}
 	}
 
-	/* Retain count for new BIOS entries: */
-	new_nr = new_bios_entry;
+	/* Retain count for the new entries: */
+	new_nr = new_nr_entries;
 
-	/* Copy new BIOS mapping into the original location: */
-	memcpy(biosmap, new_bios, new_nr*sizeof(*biosmap));
-	*pnr_map = new_nr;
+	/* Copy the new entries into the original location: */
+	memcpy(entries, new_entries, new_nr*sizeof(*entries));
+	*nr_entries = new_nr;
 
 	return 0;
 }
@@ -373,13 +373,15 @@ int __init e820__update_table(struct e820_table *table)
 	return __e820__update_table(table->entries, ARRAY_SIZE(table->entries), &table->nr_entries);
 }
 
-static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
+static int __init __append_e820_table(struct e820_entry *entries, u32 nr_entries)
 {
-	while (nr_map) {
-		u64 start = biosmap->addr;
-		u64 size = biosmap->size;
+	struct e820_entry *entry = entries;
+
+	while (nr_entries) {
+		u64 start = entry->addr;
+		u64 size = entry->size;
 		u64 end = start + size - 1;
-		u32 type = biosmap->type;
+		u32 type = entry->type;
 
 		/* Ignore the entry on 64-bit overflow: */
 		if (start > end && likely(size))
@@ -387,8 +389,8 @@ static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 
 		e820__range_add(start, size, type);
 
-		biosmap++;
-		nr_map--;
+		entry++;
+		nr_entries--;
 	}
 	return 0;
 }
@@ -402,13 +404,13 @@ static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
+static int __init append_e820_table(struct e820_entry *entries, u32 nr_entries)
 {
 	/* Only one memory region (or negative)? Ignore it */
-	if (nr_map < 2)
+	if (nr_entries < 2)
 		return -1;
 
-	return __append_e820_table(biosmap, nr_map);
+	return __append_e820_table(entries, nr_entries);
 }
 
 static u64 __init

commit f9748fa045851041ba69a1d2899971746f29c9d5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 18:00:35 2017 +0100

    x86/boot/e820: Simplify the e820__update_table() interface
    
    The e820__update_table() parameters are pretty complex:
    
      arch/x86/include/asm/e820/api.h:extern int  e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map);
    
    But 90% of the usage is trivial:
    
      arch/x86/kernel/e820.c:       if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
      arch/x86/kernel/e820.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/e820.c:               if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
      arch/x86/kernel/e820.c:       e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
      arch/x86/kernel/early-quirks.c:       e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/setup.c:      e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/kernel/setup.c:              e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/platform/efi/efi.c:  e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/xen/setup.c: e820__update_table(xen_e820_table.entries, ARRAY_SIZE(xen_e820_table.entries),
      arch/x86/xen/setup.c: e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
      arch/x86/xen/setup.c: e820__update_table(xen_e820_table.entries, ARRAY_SIZE(xen_e820_table.entries),
    
    as it only uses an exiting struct e820_table's entries array, its size and
    its current number of entries as input and output arguments.
    
    Only one use is non-trivial:
    
      arch/x86/kernel/e820.c:       e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
    
    ... which call updates the E820 table in the zeropage in-situ, and the layout there does not
    match that of 'struct e820_table' (in particular nr_entries is at a different offset,
    hardcoded by the boot protocol).
    
    Simplify all this by introducing a low level __e820__update_table() API that
    the zeropage update call can use, and simplifying the main e820__update_table()
    call signature down to:
    
            int e820__update_table(struct e820_table *table);
    
    This visibly simplifies all the call sites:
    
      arch/x86/include/asm/e820/api.h:extern int  e820__update_table(struct e820_table *table);
      arch/x86/include/asm/e820/types.h: * call to e820__update_table() to remove duplicates.  The allowance
      arch/x86/kernel/e820.c: * The return value from e820__update_table() is zero if it
      arch/x86/kernel/e820.c:int __init e820__update_table(struct e820_table *table)
      arch/x86/kernel/e820.c:       if (e820__update_table(e820_table))
      arch/x86/kernel/e820.c:       e820__update_table(e820_table_firmware);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table);
      arch/x86/kernel/e820.c:       e820__update_table(e820_table);
      arch/x86/kernel/e820.c:               if (e820__update_table(e820_table) < 0)
      arch/x86/kernel/early-quirks.c:       e820__update_table(e820_table);
      arch/x86/kernel/setup.c:      e820__update_table(e820_table);
      arch/x86/kernel/setup.c:              e820__update_table(e820_table);
      arch/x86/platform/efi/efi.c:  e820__update_table(e820_table);
      arch/x86/xen/setup.c: e820__update_table(&xen_e820_table);
      arch/x86/xen/setup.c: e820__update_table(e820_table);
      arch/x86/xen/setup.c: e820__update_table(&xen_e820_table);
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index da69addf6c34..49823e0a7aea 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -259,7 +259,7 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
+static int __init __e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_MAX_ENTRIES] __initdata;
 	static struct change_member *change_point[2*E820_MAX_ENTRIES] __initdata;
@@ -368,6 +368,11 @@ int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *p
 	return 0;
 }
 
+int __init e820__update_table(struct e820_table *table)
+{
+	return __e820__update_table(table->entries, ARRAY_SIZE(table->entries), &table->nr_entries);
+}
+
 static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 {
 	while (nr_map) {
@@ -548,7 +553,7 @@ u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int
 
 void __init e820__update_table_print(void)
 {
-	if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
+	if (e820__update_table(e820_table))
 		return;
 
 	pr_info("e820: modified physical RAM map:\n");
@@ -557,7 +562,7 @@ void __init e820__update_table_print(void)
 
 static void __init e820__update_table_firmware(void)
 {
-	e820__update_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
+	e820__update_table(e820_table_firmware);
 }
 
 #define MAX_GAP_END 0x100000000ull
@@ -676,7 +681,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	extmap = (struct e820_entry *)(sdata->data);
 
 	__append_e820_table(extmap, entries);
-	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table);
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
@@ -931,7 +936,7 @@ void __init e820_reserve_setup_data(void)
 		early_memunmap(data, sizeof(*data));
 	}
 
-	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table);
 	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 	printk(KERN_INFO "extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");
@@ -945,7 +950,7 @@ void __init e820_reserve_setup_data(void)
 void __init e820__finish_early_params(void)
 {
 	if (userdef) {
-		if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
+		if (e820__update_table(e820_table) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		pr_info("e820: user-defined physical RAM map:\n");
@@ -1132,7 +1137,7 @@ char *__init e820__memory_setup_default(void)
 	 * the next section from 1mb->appropriate_mem_k
 	 */
 	new_nr = boot_params.e820_entries;
-	e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
+	__e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
 	boot_params.e820_entries = new_nr;
 
 	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries) < 0) {

commit d88961b5d4366c33d35d9ad309791ed9e4424f6c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:48:08 2017 +0100

    x86/boot/e820: Clean up and standardize sizeof() uses
    
    There's various sizeof() uses in e820.c - standardize on the shortest
    and least error prone one, along the pattern of:
    
    -       memset(entry, 0, sizeof(struct e820_entry));
    +       memset(entry, 0, sizeof(*entry));
    
    ... because with this pattern in most cases it's immediately clear that
    we have used the right type - and the pattern is robust against changing
    the type as well.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 055ac2484729..da69addf6c34 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -306,7 +306,7 @@ int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *p
 	chg_nr = chgidx;
 
 	/* Sort change-point list by memory addresses (low -> high): */
-	sort(change_point, chg_nr, sizeof *change_point, cpcompare, NULL);
+	sort(change_point, chg_nr, sizeof(*change_point), cpcompare, NULL);
 
 	/* Create a new BIOS memory map, removing overlaps: */
 	overlap_entries = 0;	 /* Number of entries in the overlap table */
@@ -362,7 +362,7 @@ int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *p
 	new_nr = new_bios_entry;
 
 	/* Copy new BIOS mapping into the original location: */
-	memcpy(biosmap, new_bios, new_nr*sizeof(struct e820_entry));
+	memcpy(biosmap, new_bios, new_nr*sizeof(*biosmap));
 	*pnr_map = new_nr;
 
 	return 0;
@@ -513,7 +513,7 @@ u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int
 		/* Completely covered? */
 		if (entry->addr >= start && entry_end <= end) {
 			real_removed_size += entry->size;
-			memset(entry, 0, sizeof(struct e820_entry));
+			memset(entry, 0, sizeof(*entry));
 			continue;
 		}
 
@@ -672,7 +672,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	struct setup_data *sdata;
 
 	sdata = early_memremap(phys_addr, data_len);
-	entries = sdata->len / sizeof(struct e820_entry);
+	entries = sdata->len / sizeof(*extmap);
 	extmap = (struct e820_entry *)(sdata->data);
 
 	__append_e820_table(extmap, entries);
@@ -932,7 +932,7 @@ void __init e820_reserve_setup_data(void)
 	}
 
 	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
-	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
+	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 	printk(KERN_INFO "extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");
 }
@@ -1169,7 +1169,7 @@ void __init e820__memory_setup(void)
 
 	who = x86_init.resources.memory_setup();
 
-	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
+	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
 
 	pr_info("e820: BIOS-provided physical RAM map:\n");
 	e820__print_table(who);

commit 08b46d5dd869ea631d7c1c15535c930c8ea462e0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:29:08 2017 +0100

    x86/boot/e820: Clean up the E820 table size define names
    
    We've got a number of defines related to the E820 table and its size:
    
            E820MAP
            E820NR
            E820_X_MAX
            E820MAX
    
    The first two denote byte offsets into the zeropage (struct boot_params),
    and can are not used in the kernel and can be removed.
    
    The E820_*_MAX values have an inconsistent structure and it's unclear in any
    case what they mean. 'X' presuably goes for extended - but it's not very
    expressive altogether.
    
    Change these over to:
    
            E820_MAX_ENTRIES_ZEROPAGE
            E820_MAX_ENTRIES
    
    ... which are self-explanatory names.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 90dcd240a389..055ac2484729 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -261,10 +261,10 @@ static int __init cpcompare(const void *a, const void *b)
 
 int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
 {
-	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
-	static struct change_member *change_point[2*E820_X_MAX] __initdata;
-	static struct e820_entry *overlap_list[E820_X_MAX] __initdata;
-	static struct e820_entry new_bios[E820_X_MAX] __initdata;
+	static struct change_member change_point_list[2*E820_MAX_ENTRIES] __initdata;
+	static struct change_member *change_point[2*E820_MAX_ENTRIES] __initdata;
+	static struct e820_entry *overlap_list[E820_MAX_ENTRIES] __initdata;
+	static struct e820_entry new_bios[E820_MAX_ENTRIES] __initdata;
 	enum e820_type current_type, last_type;
 	unsigned long long last_addr;
 	int chgidx;

commit 09821ff1d50a1ecade182c2a68a90f835e257eef
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:09:33 2017 +0100

    x86/boot/e820: Prefix the E820_* type names with "E820_TYPE_"
    
    So there's a number of constants that start with "E820" but which
    are not types - these create a confusing mixture when seen together
    with 'enum e820_type' values:
    
            E820MAP
            E820NR
            E820_X_MAX
            E820MAX
    
    To better differentiate the 'enum e820_type' values prefix them
    with E820_TYPE_.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 79673843dc42..90dcd240a389 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -148,14 +148,14 @@ void __init e820__range_add(u64 start, u64 size, enum e820_type type)
 static void __init e820_print_type(enum e820_type type)
 {
 	switch (type) {
-	case E820_RAM:			/* Fall through: */
-	case E820_RESERVED_KERN:	pr_cont("usable");			break;
-	case E820_RESERVED:		pr_cont("reserved");			break;
-	case E820_ACPI:			pr_cont("ACPI data");			break;
-	case E820_NVS:			pr_cont("ACPI NVS");			break;
-	case E820_UNUSABLE:		pr_cont("unusable");			break;
-	case E820_PMEM:			/* Fall through: */
-	case E820_PRAM:			pr_cont("persistent (type %u)", type);	break;
+	case E820_TYPE_RAM:		/* Fall through: */
+	case E820_TYPE_RESERVED_KERN:	pr_cont("usable");			break;
+	case E820_TYPE_RESERVED:	pr_cont("reserved");			break;
+	case E820_TYPE_ACPI:		pr_cont("ACPI data");			break;
+	case E820_TYPE_NVS:		pr_cont("ACPI NVS");			break;
+	case E820_TYPE_UNUSABLE:	pr_cont("unusable");			break;
+	case E820_TYPE_PMEM:		/* Fall through: */
+	case E820_TYPE_PRAM:		pr_cont("persistent (type %u)", type);	break;
 	default:			pr_cont("type %u", type);		break;
 	}
 }
@@ -340,7 +340,7 @@ int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *p
 		}
 
 		/* Continue building up new BIOS map based on this information: */
-		if (current_type != last_type || current_type == E820_PRAM) {
+		if (current_type != last_type || current_type == E820_TYPE_PRAM) {
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
 				/* Move forward only if the new size was non-zero: */
@@ -704,7 +704,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 
 		pfn = PFN_DOWN(entry->addr + entry->size);
 
-		if (entry->type != E820_RAM && entry->type != E820_RESERVED_KERN)
+		if (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)
 			register_nosave_region(PFN_UP(entry->addr), pfn);
 
 		if (pfn >= limit_pfn)
@@ -724,7 +724,7 @@ static int __init e820_mark_nvs_memory(void)
 	for (i = 0; i < e820_table->nr_entries; i++) {
 		struct e820_entry *entry = &e820_table->entries[i];
 
-		if (entry->type == E820_NVS)
+		if (entry->type == E820_TYPE_NVS)
 			acpi_nvs_register(entry->addr, entry->size);
 	}
 
@@ -747,7 +747,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
-		e820__range_update_firmware(addr, size, E820_RAM, E820_RESERVED);
+		e820__range_update_firmware(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
 		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
 		e820__update_table_firmware();
 	}
@@ -805,12 +805,12 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, enum e820_type
 
 unsigned long __init e820_end_of_ram_pfn(void)
 {
-	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
+	return e820_end_pfn(MAX_ARCH_PFN, E820_TYPE_RAM);
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
-	return e820_end_pfn(1UL << (32 - PAGE_SHIFT), E820_RAM);
+	return e820_end_pfn(1UL << (32 - PAGE_SHIFT), E820_TYPE_RAM);
 }
 
 static void __init early_panic(char *msg)
@@ -846,7 +846,7 @@ static int __init parse_memopt(char *p)
 	if (mem_size == 0)
 		return -EINVAL;
 
-	e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
+	e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);
 
 	return 0;
 }
@@ -882,18 +882,18 @@ static int __init parse_memmap_one(char *p)
 	userdef = 1;
 	if (*p == '@') {
 		start_at = memparse(p+1, &p);
-		e820__range_add(start_at, mem_size, E820_RAM);
+		e820__range_add(start_at, mem_size, E820_TYPE_RAM);
 	} else if (*p == '#') {
 		start_at = memparse(p+1, &p);
-		e820__range_add(start_at, mem_size, E820_ACPI);
+		e820__range_add(start_at, mem_size, E820_TYPE_ACPI);
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
-		e820__range_add(start_at, mem_size, E820_RESERVED);
+		e820__range_add(start_at, mem_size, E820_TYPE_RESERVED);
 	} else if (*p == '!') {
 		start_at = memparse(p+1, &p);
-		e820__range_add(start_at, mem_size, E820_PRAM);
+		e820__range_add(start_at, mem_size, E820_TYPE_PRAM);
 	} else {
-		e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
+		e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_TYPE_RAM, 1);
 	}
 
 	return *p == '\0' ? 0 : -EINVAL;
@@ -926,7 +926,7 @@ void __init e820_reserve_setup_data(void)
 
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
-		e820__range_update(pa_data, sizeof(*data)+data->len, E820_RAM, E820_RESERVED_KERN);
+		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}
@@ -956,42 +956,42 @@ void __init e820__finish_early_params(void)
 static const char *__init e820_type_to_string(struct e820_entry *entry)
 {
 	switch (entry->type) {
-	case E820_RESERVED_KERN: /* Fall-through: */
-	case E820_RAM:		 return "System RAM";
-	case E820_ACPI:		 return "ACPI Tables";
-	case E820_NVS:		 return "ACPI Non-volatile Storage";
-	case E820_UNUSABLE:	 return "Unusable memory";
-	case E820_PRAM:		 return "Persistent Memory (legacy)";
-	case E820_PMEM:		 return "Persistent Memory";
-	default:		 return "Reserved";
+	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
+	case E820_TYPE_RAM:		return "System RAM";
+	case E820_TYPE_ACPI:		return "ACPI Tables";
+	case E820_TYPE_NVS:		return "ACPI Non-volatile Storage";
+	case E820_TYPE_UNUSABLE:	return "Unusable memory";
+	case E820_TYPE_PRAM:		return "Persistent Memory (legacy)";
+	case E820_TYPE_PMEM:		return "Persistent Memory";
+	default:			return "Reserved";
 	}
 }
 
 static unsigned long __init e820_type_to_iomem_type(struct e820_entry *entry)
 {
 	switch (entry->type) {
-	case E820_RESERVED_KERN: /* Fall-through: */
-	case E820_RAM:		 return IORESOURCE_SYSTEM_RAM;
-	case E820_ACPI:		 /* Fall-through: */
-	case E820_NVS:		 /* Fall-through: */
-	case E820_UNUSABLE:	 /* Fall-through: */
-	case E820_PRAM:		 /* Fall-through: */
-	case E820_PMEM:		 /* Fall-through: */
-	default:		 return IORESOURCE_MEM;
+	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
+	case E820_TYPE_RAM:		return IORESOURCE_SYSTEM_RAM;
+	case E820_TYPE_ACPI:		/* Fall-through: */
+	case E820_TYPE_NVS:		/* Fall-through: */
+	case E820_TYPE_UNUSABLE:	/* Fall-through: */
+	case E820_TYPE_PRAM:		/* Fall-through: */
+	case E820_TYPE_PMEM:		/* Fall-through: */
+	default:			return IORESOURCE_MEM;
 	}
 }
 
 static unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)
 {
 	switch (entry->type) {
-	case E820_ACPI:		 return IORES_DESC_ACPI_TABLES;
-	case E820_NVS:		 return IORES_DESC_ACPI_NV_STORAGE;
-	case E820_PMEM:		 return IORES_DESC_PERSISTENT_MEMORY;
-	case E820_PRAM:		 return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
-	case E820_RESERVED_KERN: /* Fall-through: */
-	case E820_RAM:		 /* Fall-through: */
-	case E820_UNUSABLE:	 /* Fall-through: */
-	default:		 return IORES_DESC_NONE;
+	case E820_TYPE_ACPI:		return IORES_DESC_ACPI_TABLES;
+	case E820_TYPE_NVS:		return IORES_DESC_ACPI_NV_STORAGE;
+	case E820_TYPE_PMEM:		return IORES_DESC_PERSISTENT_MEMORY;
+	case E820_TYPE_PRAM:		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
+	case E820_TYPE_RESERVED_KERN:	/* Fall-through: */
+	case E820_TYPE_RAM:		/* Fall-through: */
+	case E820_TYPE_UNUSABLE:	/* Fall-through: */
+	default:			return IORES_DESC_NONE;
 	}
 }
 
@@ -1006,9 +1006,9 @@ static bool __init do_mark_busy(u32 type, struct resource *res)
 	 * for exclusive use of a driver
 	 */
 	switch (type) {
-	case E820_RESERVED:
-	case E820_PRAM:
-	case E820_PMEM:
+	case E820_TYPE_RESERVED:
+	case E820_TYPE_PRAM:
+	case E820_TYPE_PMEM:
 		return false;
 	default:
 		return true;
@@ -1102,7 +1102,7 @@ void __init e820_reserve_resources_late(void)
 		struct e820_entry *entry = &e820_table->entries[i];
 		u64 start, end;
 
-		if (entry->type != E820_RAM)
+		if (entry->type != E820_TYPE_RAM)
 			continue;
 
 		start = entry->addr + entry->size;
@@ -1148,8 +1148,8 @@ char *__init e820__memory_setup_default(void)
 		}
 
 		e820_table->nr_entries = 0;
-		e820__range_add(0, LOWMEMSIZE(), E820_RAM);
-		e820__range_add(HIGH_MEMORY, mem_size << 10, E820_RAM);
+		e820__range_add(0, LOWMEMSIZE(), E820_TYPE_RAM);
+		e820__range_add(HIGH_MEMORY, mem_size << 10, E820_TYPE_RAM);
 	}
 
 	return who;
@@ -1198,7 +1198,7 @@ void __init e820__memblock_setup(void)
 		if (end != (resource_size_t)end)
 			continue;
 
-		if (entry->type != E820_RAM && entry->type != E820_RESERVED_KERN)
+		if (entry->type != E820_TYPE_RAM && entry->type != E820_TYPE_RESERVED_KERN)
 			continue;
 
 		memblock_add(entry->addr, entry->size);

commit 6afc03b86470f602d118825d09addfeeaef535f0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 16:52:34 2017 +0100

    x86/boot/e820: Use 'enum e820_type' when handling the e820 region type
    
    The E820 region type is put into four different types (!) when used in function
    parameters or local variables:
    
            unsigned type;
            int type;
            unsigned long current_type;
            u32 type;
    
    Use 'enum e820_type' in all these cases instead.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 010a289ddd9f..79673843dc42 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -68,7 +68,7 @@ EXPORT_SYMBOL(pci_mem_start);
  * This function checks if any part of the range <start,end> is mapped
  * with type.
  */
-int e820__mapped_any(u64 start, u64 end, unsigned type)
+int e820__mapped_any(u64 start, u64 end, enum e820_type type)
 {
 	int i;
 
@@ -91,7 +91,7 @@ EXPORT_SYMBOL_GPL(e820__mapped_any);
  * Note: this function only works correctly once the E820 table is sorted and
  * not-overlapping (at least for the range specified), which is the case normally.
  */
-int __init e820__mapped_all(u64 start, u64 end, unsigned type)
+int __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
 {
 	int i;
 
@@ -125,7 +125,7 @@ int __init e820__mapped_all(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel E820 map.
  */
-static void __init __e820__range_add(struct e820_table *table, u64 start, u64 size, int type)
+static void __init __e820__range_add(struct e820_table *table, u64 start, u64 size, enum e820_type type)
 {
 	int x = table->nr_entries;
 
@@ -140,12 +140,12 @@ static void __init __e820__range_add(struct e820_table *table, u64 start, u64 si
 	table->nr_entries++;
 }
 
-void __init e820__range_add(u64 start, u64 size, int type)
+void __init e820__range_add(u64 start, u64 size, enum e820_type type)
 {
 	__e820__range_add(e820_table, start, size, type);
 }
 
-static void __init e820_print_type(u32 type)
+static void __init e820_print_type(enum e820_type type)
 {
 	switch (type) {
 	case E820_RAM:			/* Fall through: */
@@ -265,7 +265,7 @@ int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *p
 	static struct change_member *change_point[2*E820_X_MAX] __initdata;
 	static struct e820_entry *overlap_list[E820_X_MAX] __initdata;
 	static struct e820_entry new_bios[E820_X_MAX] __initdata;
-	unsigned long current_type, last_type;
+	enum e820_type current_type, last_type;
 	unsigned long long last_addr;
 	int chgidx;
 	int overlap_entries;
@@ -407,7 +407,7 @@ static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
 }
 
 static u64 __init
-__e820__range_update(struct e820_table *table, u64 start, u64 size, unsigned old_type, unsigned new_type)
+__e820__range_update(struct e820_table *table, u64 start, u64 size, enum e820_type old_type, enum e820_type new_type)
 {
 	u64 end;
 	unsigned int i;
@@ -474,18 +474,18 @@ __e820__range_update(struct e820_table *table, u64 start, u64 size, unsigned old
 	return real_updated_size;
 }
 
-u64 __init e820__range_update(u64 start, u64 size, unsigned old_type, unsigned new_type)
+u64 __init e820__range_update(u64 start, u64 size, enum e820_type old_type, enum e820_type new_type)
 {
 	return __e820__range_update(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820__range_update_firmware(u64 start, u64 size, unsigned old_type, unsigned new_type)
+static u64 __init e820__range_update_firmware(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)
 {
 	return __e820__range_update(e820_table_firmware, start, size, old_type, new_type);
 }
 
 /* Remove a range of memory from the E820 table: */
-u64 __init e820__range_remove(u64 start, u64 size, unsigned old_type, int checktype)
+u64 __init e820__range_remove(u64 start, u64 size, enum e820_type old_type, int checktype)
 {
 	int i;
 	u64 end;
@@ -768,7 +768,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, enum e820_type type)
 {
 	int i;
 	unsigned long last_pfn = 0;

commit 09c5151339caea3a5752e577c66521f6e7443fe5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:01:06 2017 +0100

    x86/boot/e820: Use 'enum e820_type' in 'struct e820_entry'
    
    Use a stricter type for struct e820_entry. Add a build-time check to make
    sure the compiler won't ever pack the enum into a field smaller than
    'int'.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 511402d88795..010a289ddd9f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1164,6 +1164,9 @@ void __init e820__memory_setup(void)
 {
 	char *who;
 
+	/* This is a firmware interface ABI - make sure we don't break it: */
+	BUILD_BUG_ON(sizeof(struct e820_entry) != 20);
+
 	who = x86_init.resources.memory_setup();
 
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));

commit c594761d1d956bd71f121501bfb68dfd422c53cc
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:33:48 2017 +0100

    x86/boot/e820: Simplify e820_reserve_resources()
    
    Remove unnecessary duplications of "e820_table->entries[i]." via a local
    variable, plus pass in 'entry' to the type_to_*() functions which further
    improves the readability of the code - and other small tweaks.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index cdf224992c27..511402d88795 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -953,9 +953,9 @@ void __init e820__finish_early_params(void)
 	}
 }
 
-static const char *__init e820_type_to_string(int e820_type)
+static const char *__init e820_type_to_string(struct e820_entry *entry)
 {
-	switch (e820_type) {
+	switch (entry->type) {
 	case E820_RESERVED_KERN: /* Fall-through: */
 	case E820_RAM:		 return "System RAM";
 	case E820_ACPI:		 return "ACPI Tables";
@@ -967,9 +967,9 @@ static const char *__init e820_type_to_string(int e820_type)
 	}
 }
 
-static unsigned long __init e820_type_to_iomem_type(int e820_type)
+static unsigned long __init e820_type_to_iomem_type(struct e820_entry *entry)
 {
-	switch (e820_type) {
+	switch (entry->type) {
 	case E820_RESERVED_KERN: /* Fall-through: */
 	case E820_RAM:		 return IORESOURCE_SYSTEM_RAM;
 	case E820_ACPI:		 /* Fall-through: */
@@ -981,9 +981,9 @@ static unsigned long __init e820_type_to_iomem_type(int e820_type)
 	}
 }
 
-static unsigned long __init e820_type_to_iores_desc(int e820_type)
+static unsigned long __init e820_type_to_iores_desc(struct e820_entry *entry)
 {
-	switch (e820_type) {
+	switch (entry->type) {
 	case E820_ACPI:		 return IORES_DESC_ACPI_TABLES;
 	case E820_NVS:		 return IORES_DESC_ACPI_NV_STORAGE;
 	case E820_PMEM:		 return IORES_DESC_PERSISTENT_MEMORY;
@@ -1027,27 +1027,29 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(struct resource) * e820_table->nr_entries);
+	res = alloc_bootmem(sizeof(*res) * e820_table->nr_entries);
 	e820_res = res;
+
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		end = e820_table->entries[i].addr + e820_table->entries[i].size - 1;
+		struct e820_entry *entry = e820_table->entries + i;
+
+		end = entry->addr + entry->size - 1;
 		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-		res->name = e820_type_to_string(e820_table->entries[i].type);
-		res->start = e820_table->entries[i].addr;
-		res->end = end;
-
-		res->flags = e820_type_to_iomem_type(e820_table->entries[i].type);
-		res->desc = e820_type_to_iores_desc(e820_table->entries[i].type);
+		res->start = entry->addr;
+		res->end   = end;
+		res->name  = e820_type_to_string(entry);
+		res->flags = e820_type_to_iomem_type(entry);
+		res->desc  = e820_type_to_iores_desc(entry);
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (do_mark_busy(e820_table->entries[i].type, res)) {
+		if (do_mark_busy(entry->type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
@@ -1055,9 +1057,9 @@ void __init e820_reserve_resources(void)
 	}
 
 	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
-		struct e820_entry *entry = &e820_table_firmware->entries[i];
+		struct e820_entry *entry = e820_table_firmware->entries + i;
 
-		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry->type));
+		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry));
 	}
 }
 

commit be0c3f0fcade7ad67f484fa5dc00310813de6d7d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:24:02 2017 +0100

    x86/boot/e820: Rename e820_print_map() to e820__print_table()
    
    All other table-level methods are already named 'table' in some way,
    to change this one over to the (now consistent) nomenclature.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index f91901ab9263..cdf224992c27 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -160,7 +160,7 @@ static void __init e820_print_type(u32 type)
 	}
 }
 
-void __init e820_print_map(char *who)
+void __init e820__print_table(char *who)
 {
 	int i;
 
@@ -552,7 +552,7 @@ void __init e820__update_table_print(void)
 		return;
 
 	pr_info("e820: modified physical RAM map:\n");
-	e820_print_map("modified");
+	e820__print_table("modified");
 }
 
 static void __init e820__update_table_firmware(void)
@@ -680,7 +680,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
-	e820_print_map("extended");
+	e820__print_table("extended");
 }
 
 /**
@@ -934,7 +934,7 @@ void __init e820_reserve_setup_data(void)
 	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
 	printk(KERN_INFO "extended physical RAM map:\n");
-	e820_print_map("reserve setup_data");
+	e820__print_table("reserve setup_data");
 }
 
 /*
@@ -949,7 +949,7 @@ void __init e820__finish_early_params(void)
 			early_panic("Invalid user supplied memory map");
 
 		pr_info("e820: user-defined physical RAM map:\n");
-		e820_print_map("user");
+		e820__print_table("user");
 	}
 }
 
@@ -1167,7 +1167,7 @@ void __init e820__memory_setup(void)
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
 
 	pr_info("e820: BIOS-provided physical RAM map:\n");
-	e820_print_map(who);
+	e820__print_table(who);
 }
 
 void __init e820__memblock_setup(void)

commit ab6bc04cfdbd5da00a85909c054770a606e7c804
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:19:36 2017 +0100

    x86/boot/e820: Create coherent API function names for E820 range operations
    
    We have these three related functions:
    
     extern void e820_add_region(u64 start, u64 size, int type);
     extern u64  e820_update_range(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820_remove_range(u64 start, u64 size, unsigned old_type, int checktype);
    
    But it's not clear from the naming that they are 3 operations based around the
    same 'memory range' concept. Rename them to better signal this, and move
    the prototypes next to each other:
    
     extern void e820__range_add   (u64 start, u64 size, int type);
     extern u64  e820__range_update(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820__range_remove(u64 start, u64 size, unsigned old_type, int checktype);
    
    Note that this improved organization of the functions shows another problem that was easy
    to miss before: sometimes the E820 entry type is 'int', sometimes 'unsigned int' - but this
    will be fixed in a separate patch.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index cb25c7248656..f91901ab9263 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -125,7 +125,7 @@ int __init e820__mapped_all(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel E820 map.
  */
-static void __init __e820_add_region(struct e820_table *table, u64 start, u64 size, int type)
+static void __init __e820__range_add(struct e820_table *table, u64 start, u64 size, int type)
 {
 	int x = table->nr_entries;
 
@@ -140,9 +140,9 @@ static void __init __e820_add_region(struct e820_table *table, u64 start, u64 si
 	table->nr_entries++;
 }
 
-void __init e820_add_region(u64 start, u64 size, int type)
+void __init e820__range_add(u64 start, u64 size, int type)
 {
-	__e820_add_region(e820_table, start, size, type);
+	__e820__range_add(e820_table, start, size, type);
 }
 
 static void __init e820_print_type(u32 type)
@@ -380,7 +380,7 @@ static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 		if (start > end && likely(size))
 			return -1;
 
-		e820_add_region(start, size, type);
+		e820__range_add(start, size, type);
 
 		biosmap++;
 		nr_map--;
@@ -407,7 +407,7 @@ static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
 }
 
 static u64 __init
-__e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_type, unsigned new_type)
+__e820__range_update(struct e820_table *table, u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
 	u64 end;
 	unsigned int i;
@@ -444,8 +444,8 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 
 		/* New range is completely covered? */
 		if (entry->addr < start && entry_end > end) {
-			__e820_add_region(table, start, size, new_type);
-			__e820_add_region(table, end, entry_end - end, entry->type);
+			__e820__range_add(table, start, size, new_type);
+			__e820__range_add(table, end, entry_end - end, entry->type);
 			entry->size = start - entry->addr;
 			real_updated_size += size;
 			continue;
@@ -457,7 +457,7 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 		if (final_start >= final_end)
 			continue;
 
-		__e820_add_region(table, final_start, final_end - final_start, new_type);
+		__e820__range_add(table, final_start, final_end - final_start, new_type);
 
 		real_updated_size += final_end - final_start;
 
@@ -474,18 +474,18 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 	return real_updated_size;
 }
 
-u64 __init e820_update_range(u64 start, u64 size, unsigned old_type, unsigned new_type)
+u64 __init e820__range_update(u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_table, start, size, old_type, new_type);
+	return __e820__range_update(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820_update_range_firmware(u64 start, u64 size, unsigned old_type, unsigned new_type)
+static u64 __init e820__range_update_firmware(u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_table_firmware, start, size, old_type, new_type);
+	return __e820__range_update(e820_table_firmware, start, size, old_type, new_type);
 }
 
 /* Remove a range of memory from the E820 table: */
-u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checktype)
+u64 __init e820__range_remove(u64 start, u64 size, unsigned old_type, int checktype)
 {
 	int i;
 	u64 end;
@@ -519,7 +519,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 
 		/* Is the new range completely covered? */
 		if (entry->addr < start && entry_end > end) {
-			e820_add_region(end, entry_end - end, entry->type);
+			e820__range_add(end, entry_end - end, entry->type);
 			entry->size = start - entry->addr;
 			real_removed_size += size;
 			continue;
@@ -747,7 +747,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
-		e820_update_range_firmware(addr, size, E820_RAM, E820_RESERVED);
+		e820__range_update_firmware(addr, size, E820_RAM, E820_RESERVED);
 		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
 		e820__update_table_firmware();
 	}
@@ -846,7 +846,7 @@ static int __init parse_memopt(char *p)
 	if (mem_size == 0)
 		return -EINVAL;
 
-	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
+	e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
 	return 0;
 }
@@ -882,18 +882,18 @@ static int __init parse_memmap_one(char *p)
 	userdef = 1;
 	if (*p == '@') {
 		start_at = memparse(p+1, &p);
-		e820_add_region(start_at, mem_size, E820_RAM);
+		e820__range_add(start_at, mem_size, E820_RAM);
 	} else if (*p == '#') {
 		start_at = memparse(p+1, &p);
-		e820_add_region(start_at, mem_size, E820_ACPI);
+		e820__range_add(start_at, mem_size, E820_ACPI);
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
-		e820_add_region(start_at, mem_size, E820_RESERVED);
+		e820__range_add(start_at, mem_size, E820_RESERVED);
 	} else if (*p == '!') {
 		start_at = memparse(p+1, &p);
-		e820_add_region(start_at, mem_size, E820_PRAM);
+		e820__range_add(start_at, mem_size, E820_PRAM);
 	} else {
-		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
+		e820__range_remove(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 	}
 
 	return *p == '\0' ? 0 : -EINVAL;
@@ -926,7 +926,7 @@ void __init e820_reserve_setup_data(void)
 
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
-		e820_update_range(pa_data, sizeof(*data)+data->len, E820_RAM, E820_RESERVED_KERN);
+		e820__range_update(pa_data, sizeof(*data)+data->len, E820_RAM, E820_RESERVED_KERN);
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}
@@ -1146,8 +1146,8 @@ char *__init e820__memory_setup_default(void)
 		}
 
 		e820_table->nr_entries = 0;
-		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
-		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
+		e820__range_add(0, LOWMEMSIZE(), E820_RAM);
+		e820__range_add(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
 
 	return who;

commit 2df908baf52ccf8eaabe5576d1ecb2f972b1135f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:16:38 2017 +0100

    x86/boot/e820: Rename e820_setup_gap() to e820__setup_pci_gap()
    
    The e820_setup_gap() function name is unnecessarily silent about what
    kind of gap it sets up. Make it clear that it's about the PCI gap.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 804acee76aca..cb25c7248656 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -602,7 +602,7 @@ static int __init e820_search_gap(unsigned long *gapstart, unsigned long *gapsiz
  *
  * Hopefully the BIOS let enough space left.
  */
-__init void e820_setup_gap(void)
+__init void e820__setup_pci_gap(void)
 {
 	unsigned long gapstart, gapsize;
 	int found;

commit 3bce64f019a801f526cc38523c77ffda4e846155
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:14:25 2017 +0100

    x86/boot/e820: Rename e820_any_mapped()/e820_all_mapped() to e820__mapped_any()/e820__mapped_all()
    
    The 'any' and 'all' are modified to the 'mapped' concept, so move them last in the name.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0053c9f1f6e2..804acee76aca 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -68,7 +68,7 @@ EXPORT_SYMBOL(pci_mem_start);
  * This function checks if any part of the range <start,end> is mapped
  * with type.
  */
-int e820_any_mapped(u64 start, u64 end, unsigned type)
+int e820__mapped_any(u64 start, u64 end, unsigned type)
 {
 	int i;
 
@@ -83,7 +83,7 @@ int e820_any_mapped(u64 start, u64 end, unsigned type)
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(e820_any_mapped);
+EXPORT_SYMBOL_GPL(e820__mapped_any);
 
 /*
  * This function checks if the entire <start,end> range is mapped with 'type'.
@@ -91,7 +91,7 @@ EXPORT_SYMBOL_GPL(e820_any_mapped);
  * Note: this function only works correctly once the E820 table is sorted and
  * not-overlapping (at least for the range specified), which is the case normally.
  */
-int __init e820_all_mapped(u64 start, u64 end, unsigned type)
+int __init e820__mapped_all(u64 start, u64 end, unsigned type)
 {
 	int i;
 

commit f52355a99fc06f609ca6a61098d78e476d56f526
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:09:20 2017 +0100

    x86/boot/e820: Rename sanitize_e820_table() to e820__update_table()
    
    sanitize_e820_table() is a minor misnomer in that it suggests that
    the E820 table requires sanitizing - which implies that it will only
    do anything if the E820 table is irregular (not sane).
    
    That is wrong, because sanitize_e820_table() also does a very regular
    sorting of the E820 table, which is a necessity in the basic
    append-only flow of E820 updates the kernel is allowed to perform to
    it.
    
    So rename it to e820__update_table() to include that purpose as well.
    
    This also lines up all the table-update functions into a coherent
    naming family:
    
      int  e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map);
    
      void e820__update_table_print(void);
      void e820__update_table_firmware(void);
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 03af13c3c431..0053c9f1f6e2 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -193,7 +193,7 @@ void __init e820_print_map(char *who)
  * sanitizing succeeds the *pnr_map will be updated with the new
  * number of valid entries (something no more than max_nr_map).
  *
- * The return value from sanitize_e820_table() is zero if it
+ * The return value from e820__update_table() is zero if it
  * successfully 'sanitized' the map entries passed in, and is -1
  * if it did nothing, which can happen if either of (1) it was
  * only passed one map entry, or (2) any of the input map entries
@@ -259,7 +259,7 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init sanitize_e820_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
+int __init e820__update_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
 	static struct change_member *change_point[2*E820_X_MAX] __initdata;
@@ -548,7 +548,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 
 void __init e820__update_table_print(void)
 {
-	if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
+	if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
 		return;
 
 	pr_info("e820: modified physical RAM map:\n");
@@ -557,7 +557,7 @@ void __init e820__update_table_print(void)
 
 static void __init e820__update_table_firmware(void)
 {
-	sanitize_e820_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
+	e820__update_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
 }
 
 #define MAX_GAP_END 0x100000000ull
@@ -676,7 +676,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	extmap = (struct e820_entry *)(sdata->data);
 
 	__append_e820_table(extmap, entries);
-	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
@@ -931,7 +931,7 @@ void __init e820_reserve_setup_data(void)
 		early_memunmap(data, sizeof(*data));
 	}
 
-	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
 	printk(KERN_INFO "extended physical RAM map:\n");
 	e820_print_map("reserve setup_data");
@@ -945,7 +945,7 @@ void __init e820_reserve_setup_data(void)
 void __init e820__finish_early_params(void)
 {
 	if (userdef) {
-		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
+		if (e820__update_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		pr_info("e820: user-defined physical RAM map:\n");
@@ -1130,7 +1130,7 @@ char *__init e820__memory_setup_default(void)
 	 * the next section from 1mb->appropriate_mem_k
 	 */
 	new_nr = boot_params.e820_entries;
-	sanitize_e820_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
+	e820__update_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
 	boot_params.e820_entries = new_nr;
 
 	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries) < 0) {

commit 6464d294d251551223a2c359d8b74c6965b5740a
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:03:04 2017 +0100

    x86/boot/e820: Rename update_e820() to e820__update_table()
    
    update_e820() should have 'e820' as a prefix as most of the other E820
    functions have - but it's also a bit unclear about its purpose, as
    it's unclear what is updated - the whole table, or an entry?
    
    Also, the name does not express that it's a trivial wrapper
    around sanitize_e820_table() that also prints out the resulting
    table.
    
    So rename it to e820__update_table_print(). This also makes it
    harmonize with the e820__update_table_firmware() function which
    has a very similar purpose.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 93b5e3e5a3f0..03af13c3c431 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -546,7 +546,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 	return real_removed_size;
 }
 
-void __init update_e820(void)
+void __init e820__update_table_print(void)
 {
 	if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
 		return;
@@ -555,7 +555,7 @@ void __init update_e820(void)
 	e820_print_map("modified");
 }
 
-static void __init update_e820_table_firmware(void)
+static void __init e820__update_table_firmware(void)
 {
 	sanitize_e820_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
 }
@@ -749,7 +749,7 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 	if (addr) {
 		e820_update_range_firmware(addr, size, E820_RAM, E820_RESERVED);
 		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
-		update_e820_table_firmware();
+		e820__update_table_firmware();
 	}
 
 	return addr;

commit 5da217ca967b9d7a0bbbd8edd06749c99a4fe501
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 13:46:28 2017 +0100

    x86/boot/e820: Rename early_reserve_e820() to e820__memblock_alloc() and document it
    
    early_reserve_e820() is an early hack for kexec that does a limited fixup of the
    mptable and passes it to the kexec kernel as if it was the real thing.
    
    For this it needs to allocate memory - but no memory allocator is available yet
    beyond the memblock allocator, so early_reserve_e820() is really a wrapper
    around memblock_alloc() plus a hack to update the e820_table_firmware entries.
    
    The name 'reserve' is really a bit of a misnomer, as 'reserved' memory typically
    means memory completely inaccessible to the kernel - while here what we want to do
    is a special RAM allocation for our own purposes and insert that as RAM_RESERVED.
    
    Rename the function to e820__memblock_alloc_reserved() to better signal this dual
    purpose, plus document it better, which was omitted when it was merged. The barely
    comprehensible and cryptic comment:
    
      /*
       * pre allocated 4k and reserved it in memblock and e820_table_firmware
       */
      u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
    
    ... does not count as documentation, replace it with:
    
      /*
       * Allocate the requested number of bytes with the requsted alignment
       * and return (the physical address) to the caller. Also register this
       * range in the 'firmware' E820 table.
       *
       * This allows kexec to fake a new mptable, as if it came from the real
       * system.
       */
      u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 904ddb1343f2..93b5e3e5a3f0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -734,16 +734,21 @@ core_initcall(e820_mark_nvs_memory);
 #endif
 
 /*
- * pre allocated 4k and reserved it in memblock and e820_table_firmware
+ * Allocate the requested number of bytes with the requsted alignment
+ * and return (the physical address) to the caller. Also register this
+ * range in the 'firmware' E820 table as a reserved range.
+ *
+ * This allows kexec to fake a new mptable, as if it came from the real
+ * system.
  */
-u64 __init early_reserve_e820(u64 size, u64 align)
+u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 {
 	u64 addr;
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_firmware(addr, size, E820_RAM, E820_RESERVED);
-		pr_info("e820: update e820_table_firmware for early_reserve_e820\n");
+		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
 		update_e820_table_firmware();
 	}
 

commit 9641bdafd8571e2d86817935e4e7ffa6fa2c56b6
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 13:37:17 2017 +0100

    x86/boot/e820: Clarify the role of finish_e820_parsing() and rename it to e820__finish_early_params()
    
    finish_e820_parsing() is closely related to parse_early_params(), but the
    name does not tell us this clearly, so rename it to e820__finish_early_params().
    
    Also add a few comments to explain what the function does.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 79b9401bbbea..904ddb1343f2 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -932,7 +932,12 @@ void __init e820_reserve_setup_data(void)
 	e820_print_map("reserve setup_data");
 }
 
-void __init finish_e820_parsing(void)
+/*
+ * Called after parse_early_param(), after early parameters (such as mem=)
+ * have been processed, in which case we already have an E820 table filled in
+ * via the parameter callback function(s), but it's not sorted and printed yet:
+ */
+void __init e820__finish_early_params(void)
 {
 	if (userdef) {
 		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)

commit da92139bff5fb334981d56225d3d80e73125b51f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 13:25:45 2017 +0100

    x86/boot/e820: Move e820_reserve_setup_data() to e820.c
    
    The e820_reserve_setup_data() is local to arch/x86/kernel/setup.c,
    but it is E820 functionality - so move it to e820.c to better
    isolate E820 functionality.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d24c0f2b4a1c..79b9401bbbea 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -910,6 +910,28 @@ static int __init parse_memmap_opt(char *str)
 }
 early_param("memmap", parse_memmap_opt);
 
+void __init e820_reserve_setup_data(void)
+{
+	struct setup_data *data;
+	u64 pa_data;
+
+	pa_data = boot_params.hdr.setup_data;
+	if (!pa_data)
+		return;
+
+	while (pa_data) {
+		data = early_memremap(pa_data, sizeof(*data));
+		e820_update_range(pa_data, sizeof(*data)+data->len, E820_RAM, E820_RESERVED_KERN);
+		pa_data = data->next;
+		early_memunmap(data, sizeof(*data));
+	}
+
+	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
+	printk(KERN_INFO "extended physical RAM map:\n");
+	e820_print_map("reserve setup_data");
+}
+
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {

commit 914053c08e95b2577d5834d51d5962c922ad0a72
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 13:18:40 2017 +0100

    x86/boot/e820: Rename parse_e820_ext() to e820__memory_setup_extended()
    
    parse_e820_ext() is very similar to e820__memory_setup_default(), both are
    taking bootloader provided data, add it to the E820 table and then
    pass it sanitize_e820_table().
    
    Rename it to e820__memory_setup_extended() to better signal their similar role.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 5f8ba898e29d..d24c0f2b4a1c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -665,7 +665,7 @@ __init void e820_reallocate_tables(void)
  * the remaining (if any) entries are passed via the SETUP_E820_EXT node of
  * struct setup_data, which is parsed here.
  */
-void __init parse_e820_ext(u64 phys_addr, u32 data_len)
+void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 {
 	int entries;
 	struct e820_entry *extmap;

commit 4270fd8b4c27f08b9cfd7e2fc342d1a31217ba6b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 12:45:40 2017 +0100

    x86/boot/e820: Move the memblock_find_dma_reserve() function and rename it to memblock_set_dma_reserve()
    
    We introduced memblock_find_dma_reserve() in this commit:
    
       6f2a75369e75 x86, memblock: Use memblock_memory_size()/memblock_free_memory_size() to get correct dma_reserve
    
    But there's several problems with it:
    
     - The changelog is full of typos and is incomprehensible in general, and
       the comments in the code are not much better either.
    
     - The function was inexplicably placed into e820.c, while it has very
       little connection to the E820 table: when we call
       memblock_find_dma_reserve() then memblock is already set up and we
       are not using the E820 table anymore.
    
     - The function is a wrapper around set_dma_reserve(), but changed the 'set'
       name to 'find' - actively misleading about its primary purpose, which is
       still to set the DMA-reserve value.
    
     - The function is limited to 64-bit systems, but neither the changelog nor
       the comments explain why. The change would appear to be relevant to
       32-bit systems as well, as the ISA DMA zone is the first 16 MB of RAM.
    
    So address some of these problems:
    
     - Move it into arch/x86/mm/init.c, next to the other zone setup related
       functions.
    
     - Clean up the code flow and names of local variables a bit.
    
     - Rename it to memblock_set_dma_reserve()
    
     - Improve the comments.
    
    No change in functionality. Enabling it for 32-bit systems is left
    for a separate patch.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 4a8d905226c9..5f8ba898e29d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1172,34 +1172,3 @@ void __init e820__memblock_setup(void)
 
 	memblock_dump_all();
 }
-
-void __init memblock_find_dma_reserve(void)
-{
-#ifdef CONFIG_X86_64
-	u64 nr_pages = 0, nr_free_pages = 0;
-	unsigned long start_pfn, end_pfn;
-	phys_addr_t start, end;
-	int i;
-	u64 u;
-
-	/*
-	 * need to find out used area below MAX_DMA_PFN
-	 * need to use memblock to get free size in [0, MAX_DMA_PFN]
-	 * at first, and assume boot_mem will not take below MAX_DMA_PFN
-	 */
-	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {
-		start_pfn = min(start_pfn, MAX_DMA_PFN);
-		end_pfn = min(end_pfn, MAX_DMA_PFN);
-		nr_pages += end_pfn - start_pfn;
-	}
-
-	for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end, NULL) {
-		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
-		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
-		if (start_pfn < end_pfn)
-			nr_free_pages += end_pfn - start_pfn;
-	}
-
-	set_dma_reserve(nr_pages - nr_free_pages);
-#endif
-}

commit 01259ef1e0901310aa4a87754ff07a1b2fe6a433
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 12:27:45 2017 +0100

    x86/boot/e820: Convert printk(KERN_* ...) to pr_*()
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 48b1e36e7250..4a8d905226c9 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -130,7 +130,7 @@ static void __init __e820_add_region(struct e820_table *table, u64 start, u64 si
 	int x = table->nr_entries;
 
 	if (x >= ARRAY_SIZE(table->entries)) {
-		printk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n", start, start + size - 1);
+		pr_err("e820: too many entries; ignoring [mem %#010llx-%#010llx]\n", start, start + size - 1);
 		return;
 	}
 
@@ -149,14 +149,14 @@ static void __init e820_print_type(u32 type)
 {
 	switch (type) {
 	case E820_RAM:			/* Fall through: */
-	case E820_RESERVED_KERN:	printk(KERN_CONT "usable");			break;
-	case E820_RESERVED:		printk(KERN_CONT "reserved");			break;
-	case E820_ACPI:			printk(KERN_CONT "ACPI data");			break;
-	case E820_NVS:			printk(KERN_CONT "ACPI NVS");			break;
-	case E820_UNUSABLE:		printk(KERN_CONT "unusable");			break;
+	case E820_RESERVED_KERN:	pr_cont("usable");			break;
+	case E820_RESERVED:		pr_cont("reserved");			break;
+	case E820_ACPI:			pr_cont("ACPI data");			break;
+	case E820_NVS:			pr_cont("ACPI NVS");			break;
+	case E820_UNUSABLE:		pr_cont("unusable");			break;
 	case E820_PMEM:			/* Fall through: */
-	case E820_PRAM:			printk(KERN_CONT "persistent (type %u)", type);	break;
-	default:			printk(KERN_CONT "type %u", type);		break;
+	case E820_PRAM:			pr_cont("persistent (type %u)", type);	break;
+	default:			pr_cont("type %u", type);		break;
 	}
 }
 
@@ -165,12 +165,12 @@ void __init e820_print_map(char *who)
 	int i;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
+		pr_info("%s: [mem %#018Lx-%#018Lx] ", who,
 		       e820_table->entries[i].addr,
 		       e820_table->entries[i].addr + e820_table->entries[i].size - 1);
 
 		e820_print_type(e820_table->entries[i].type);
-		printk(KERN_CONT "\n");
+		pr_cont("\n");
 	}
 }
 
@@ -419,11 +419,11 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ", start, end - 1);
+	pr_debug("e820: update [mem %#010Lx-%#010Lx] ", start, end - 1);
 	e820_print_type(old_type);
-	printk(KERN_CONT " ==> ");
+	pr_cont(" ==> ");
 	e820_print_type(new_type);
-	printk(KERN_CONT "\n");
+	pr_cont("\n");
 
 	for (i = 0; i < table->nr_entries; i++) {
 		struct e820_entry *entry = &table->entries[i];
@@ -495,10 +495,10 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
+	pr_debug("e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
 	if (checktype)
 		e820_print_type(old_type);
-	printk(KERN_CONT "\n");
+	pr_cont("\n");
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
 		struct e820_entry *entry = &e820_table->entries[i];
@@ -551,7 +551,7 @@ void __init update_e820(void)
 	if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
 		return;
 
-	printk(KERN_INFO "e820: modified physical RAM map:\n");
+	pr_info("e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
 
@@ -613,7 +613,7 @@ __init void e820_setup_gap(void)
 	if (!found) {
 #ifdef CONFIG_X86_64
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
-		printk(KERN_ERR
+		pr_err(
 			"e820: Cannot find an available gap in the 32-bit address range\n"
 			"e820: PCI devices with unassigned 32-bit BARs may not work!\n");
 #else
@@ -626,7 +626,7 @@ __init void e820_setup_gap(void)
 	 */
 	pci_mem_start = gapstart;
 
-	printk(KERN_INFO "e820: [mem %#010lx-%#010lx] available for PCI devices\n", gapstart, gapstart + gapsize - 1);
+	pr_info("e820: [mem %#010lx-%#010lx] available for PCI devices\n", gapstart, gapstart + gapsize - 1);
 }
 
 /*
@@ -679,7 +679,7 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 
 	early_memunmap(sdata, data_len);
-	printk(KERN_INFO "e820: extended physical RAM map:\n");
+	pr_info("e820: extended physical RAM map:\n");
 	e820_print_map("extended");
 }
 
@@ -743,7 +743,7 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_firmware(addr, size, E820_RAM, E820_RESERVED);
-		printk(KERN_INFO "e820: update e820_table_firmware for early_reserve_e820\n");
+		pr_info("e820: update e820_table_firmware for early_reserve_e820\n");
 		update_e820_table_firmware();
 	}
 
@@ -793,7 +793,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	if (last_pfn > max_arch_pfn)
 		last_pfn = max_arch_pfn;
 
-	printk(KERN_INFO "e820: last_pfn = %#lx max_arch_pfn = %#lx\n",
+	pr_info("e820: last_pfn = %#lx max_arch_pfn = %#lx\n",
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }
@@ -829,7 +829,7 @@ static int __init parse_memopt(char *p)
 		setup_clear_cpu_cap(X86_FEATURE_PSE);
 		return 0;
 #else
-		printk(KERN_WARNING "mem=nopentium ignored! (only supported on x86_32)\n");
+		pr_warn("mem=nopentium ignored! (only supported on x86_32)\n");
 		return -EINVAL;
 #endif
 	}
@@ -916,7 +916,7 @@ void __init finish_e820_parsing(void)
 		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
 			early_panic("Invalid user supplied memory map");
 
-		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
+		pr_info("e820: user-defined physical RAM map:\n");
 		e820_print_map("user");
 	}
 }
@@ -1078,7 +1078,7 @@ void __init e820_reserve_resources_late(void)
 		if (start >= end)
 			continue;
 
-		printk(KERN_DEBUG "e820: reserve RAM buffer [mem %#010llx-%#010llx]\n", start, end);
+		pr_debug("e820: reserve RAM buffer [mem %#010llx-%#010llx]\n", start, end);
 		reserve_region_with_split(&iomem_resource, start, end, "RAM buffer");
 	}
 }
@@ -1134,7 +1134,7 @@ void __init e820__memory_setup(void)
 
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
 
-	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
+	pr_info("e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
 

commit e5540f8754042b376f117ea9ff5410c42936c7c2
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 12:16:17 2017 +0100

    x86/boot/e820: Consolidate 'struct e820_entry *entry' local variable names
    
    So the E820 code has a lot of cases of:
    
            struct e820_entry *ei;
    
    ... but the 'ei' name makes very little sense if you think about it, it's
    not an abbreviation of anything obviously related to E820 table entries.
    
    This results in weird looking lines such as:
    
                   if (type && ei->type != type)
    
    where you might have to double check what 'ei' really means, plus
    weird looking secondary variable names, such as:
    
            u64 ei_end;
    
    The 'ei' name was introduced in a single function over a decade ago, and
    then mindlessly cargo-copied over into other functions - with usage growing
    to over 60 uses altogether (!).
    
    ( My best guess is that it might have been originally meant as abbreviation
      of 'entry interval'. )
    
    Anyway, rename these to the much more obvious:
    
            struct e820_entry *entry;
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b8e216b3957a..48b1e36e7250 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -73,11 +73,11 @@ int e820_any_mapped(u64 start, u64 end, unsigned type)
 	int i;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 
-		if (type && ei->type != type)
+		if (type && entry->type != type)
 			continue;
-		if (ei->addr >= end || ei->addr + ei->size <= start)
+		if (entry->addr >= end || entry->addr + entry->size <= start)
 			continue;
 		return 1;
 	}
@@ -96,21 +96,21 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 	int i;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 
-		if (type && ei->type != type)
+		if (type && entry->type != type)
 			continue;
 
 		/* Is the region (part) in overlap with the current region? */
-		if (ei->addr >= end || ei->addr + ei->size <= start)
+		if (entry->addr >= end || entry->addr + entry->size <= start)
 			continue;
 
 		/*
 		 * If the region is at the beginning of <start,end> we move
 		 * 'start' to the end of the region since it's ok until there
 		 */
-		if (ei->addr <= start)
-			start = ei->addr + ei->size;
+		if (entry->addr <= start)
+			start = entry->addr + entry->size;
 
 		/*
 		 * If 'start' is now at or beyond 'end', we're done, full
@@ -426,34 +426,34 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 	printk(KERN_CONT "\n");
 
 	for (i = 0; i < table->nr_entries; i++) {
-		struct e820_entry *ei = &table->entries[i];
+		struct e820_entry *entry = &table->entries[i];
 		u64 final_start, final_end;
-		u64 ei_end;
+		u64 entry_end;
 
-		if (ei->type != old_type)
+		if (entry->type != old_type)
 			continue;
 
-		ei_end = ei->addr + ei->size;
+		entry_end = entry->addr + entry->size;
 
 		/* Completely covered by new range? */
-		if (ei->addr >= start && ei_end <= end) {
-			ei->type = new_type;
-			real_updated_size += ei->size;
+		if (entry->addr >= start && entry_end <= end) {
+			entry->type = new_type;
+			real_updated_size += entry->size;
 			continue;
 		}
 
 		/* New range is completely covered? */
-		if (ei->addr < start && ei_end > end) {
+		if (entry->addr < start && entry_end > end) {
 			__e820_add_region(table, start, size, new_type);
-			__e820_add_region(table, end, ei_end - end, ei->type);
-			ei->size = start - ei->addr;
+			__e820_add_region(table, end, entry_end - end, entry->type);
+			entry->size = start - entry->addr;
 			real_updated_size += size;
 			continue;
 		}
 
 		/* Partially covered: */
-		final_start = max(start, ei->addr);
-		final_end = min(end, ei_end);
+		final_start = max(start, entry->addr);
+		final_end = min(end, entry_end);
 		if (final_start >= final_end)
 			continue;
 
@@ -465,11 +465,11 @@ __e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_
 		 * Left range could be head or tail, so need to update
 		 * its size first:
 		 */
-		ei->size -= final_end - final_start;
-		if (ei->addr < final_start)
+		entry->size -= final_end - final_start;
+		if (entry->addr < final_start)
 			continue;
 
-		ei->addr = final_end;
+		entry->addr = final_end;
 	}
 	return real_updated_size;
 }
@@ -501,33 +501,33 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 	printk(KERN_CONT "\n");
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 		u64 final_start, final_end;
-		u64 ei_end;
+		u64 entry_end;
 
-		if (checktype && ei->type != old_type)
+		if (checktype && entry->type != old_type)
 			continue;
 
-		ei_end = ei->addr + ei->size;
+		entry_end = entry->addr + entry->size;
 
 		/* Completely covered? */
-		if (ei->addr >= start && ei_end <= end) {
-			real_removed_size += ei->size;
-			memset(ei, 0, sizeof(struct e820_entry));
+		if (entry->addr >= start && entry_end <= end) {
+			real_removed_size += entry->size;
+			memset(entry, 0, sizeof(struct e820_entry));
 			continue;
 		}
 
 		/* Is the new range completely covered? */
-		if (ei->addr < start && ei_end > end) {
-			e820_add_region(end, ei_end - end, ei->type);
-			ei->size = start - ei->addr;
+		if (entry->addr < start && entry_end > end) {
+			e820_add_region(end, entry_end - end, entry->type);
+			entry->size = start - entry->addr;
 			real_removed_size += size;
 			continue;
 		}
 
 		/* Partially covered: */
-		final_start = max(start, ei->addr);
-		final_end = min(end, ei_end);
+		final_start = max(start, entry->addr);
+		final_end = min(end, entry_end);
 		if (final_start >= final_end)
 			continue;
 
@@ -537,11 +537,11 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checkty
 		 * Left range could be head or tail, so need to update
 		 * the size first:
 		 */
-		ei->size -= final_end - final_start;
-		if (ei->addr < final_start)
+		entry->size -= final_end - final_start;
+		if (entry->addr < final_start)
 			continue;
 
-		ei->addr = final_end;
+		entry->addr = final_end;
 	}
 	return real_removed_size;
 }
@@ -697,15 +697,15 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	unsigned long pfn = 0;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 
-		if (pfn < PFN_UP(ei->addr))
-			register_nosave_region(pfn, PFN_UP(ei->addr));
+		if (pfn < PFN_UP(entry->addr))
+			register_nosave_region(pfn, PFN_UP(entry->addr));
 
-		pfn = PFN_DOWN(ei->addr + ei->size);
+		pfn = PFN_DOWN(entry->addr + entry->size);
 
-		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
-			register_nosave_region(PFN_UP(ei->addr), pfn);
+		if (entry->type != E820_RAM && entry->type != E820_RESERVED_KERN)
+			register_nosave_region(PFN_UP(entry->addr), pfn);
 
 		if (pfn >= limit_pfn)
 			break;
@@ -722,10 +722,10 @@ static int __init e820_mark_nvs_memory(void)
 	int i;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 
-		if (ei->type == E820_NVS)
-			acpi_nvs_register(ei->addr, ei->size);
+		if (entry->type == E820_NVS)
+			acpi_nvs_register(entry->addr, entry->size);
 	}
 
 	return 0;
@@ -770,15 +770,15 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
-		if (ei->type != type)
+		if (entry->type != type)
 			continue;
 
-		start_pfn = ei->addr >> PAGE_SHIFT;
-		end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
+		start_pfn = entry->addr >> PAGE_SHIFT;
+		end_pfn = (entry->addr + entry->size) >> PAGE_SHIFT;
 
 		if (start_pfn >= limit_pfn)
 			continue;
@@ -1155,16 +1155,16 @@ void __init e820__memblock_setup(void)
 	memblock_allow_resize();
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
-		struct e820_entry *ei = &e820_table->entries[i];
+		struct e820_entry *entry = &e820_table->entries[i];
 
-		end = ei->addr + ei->size;
+		end = entry->addr + entry->size;
 		if (end != (resource_size_t)end)
 			continue;
 
-		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
+		if (entry->type != E820_RAM && entry->type != E820_RESERVED_KERN)
 			continue;
 
-		memblock_add(ei->addr, ei->size);
+		memblock_add(entry->addr, entry->size);
 	}
 
 	/* Throw away partial pages: */

commit 4918e2286d0c023ee29c1f6d4e6d45e1aa420408
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 11:37:42 2017 +0100

    x86/boot/e820: Rename memblock_x86_fill() to e820__memblock_setup() and improve the explanations
    
    So memblock_x86_fill() is another E820 code misnomer:
    
     - nothing in its name tells us that it's part of the E820 subsystem ...
    
     - The 'fill' wording is ambiguous and doesn't tell us whether it's a single
       entry or some process - while the _real_ purpose of the function is hidden,
       which is to do a complete setup of the (platform independent) memblock regions.
    
    So rename it accordingly, to e820__memblock_setup().
    
    Also translate this incomprehensible and misleading comment:
    
            /*
             * EFI may have more than 128 entries
             * We are safe to enable resizing, beause memblock_x86_fill()
             * is rather later for x86
             */
            memblock_allow_resize();
    
    The worst aspect of this comment isn't even the sloppy typos, but that it
    casually mentions a '128' number with no explanation, which makes one lead
    to the assumption that this is related to the well-known limit of a maximum
    of 128 E820 entries passed via legacy bootloaders.
    
    But no, the _real_ meaning of 128 here is that of the memblock subsystem,
    which too happens to have a 128 entries limit for very early memblock
    regions (which is unrelated to E820), via INIT_MEMBLOCK_REGIONS ...
    
    So change the comment to a more comprehensible version:
    
            /*
             * The bootstrap memblock region count maximum is 128 entries
             * (INIT_MEMBLOCK_REGIONS), but EFI might pass us more E820 entries
             * than that - so allow memblock resizing.
             *
             * This is safe, because this call happens pretty late during x86 setup,
             * so we know about reserved memory regions already. (This is important
             * so that memblock resizing does no stomp over reserved areas.)
             */
            memblock_allow_resize();
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 624190fe86a7..b8e216b3957a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1138,15 +1138,19 @@ void __init e820__memory_setup(void)
 	e820_print_map(who);
 }
 
-void __init memblock_x86_fill(void)
+void __init e820__memblock_setup(void)
 {
 	int i;
 	u64 end;
 
 	/*
-	 * EFI may have more than 128 entries
-	 * We are safe to enable resizing, beause memblock_x86_fill()
-	 * is rather later for x86
+	 * The bootstrap memblock region count maximum is 128 entries
+	 * (INIT_MEMBLOCK_REGIONS), but EFI might pass us more E820 entries
+	 * than that - so allow memblock resizing.
+	 *
+	 * This is safe, because this call happens pretty late during x86 setup,
+	 * so we know about reserved memory regions already. (This is important
+	 * so that memblock resizing does no stomp over reserved areas.)
 	 */
 	memblock_allow_resize();
 
@@ -1163,7 +1167,7 @@ void __init memblock_x86_fill(void)
 		memblock_add(ei->addr, ei->size);
 	}
 
-	/* throw away partial pages */
+	/* Throw away partial pages: */
 	memblock_trim_memory(PAGE_SIZE);
 
 	memblock_dump_all();

commit 640e1b38b00550990cecd809021cd37716e45922
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 11:13:08 2017 +0100

    x86/boot/e820: Basic cleanup of e820.c
    
    Over the last decade or so e820.c has become an ureadable mess of
    tinkerware. Perform some very basic cleanups before doing more
    intricate cleanups, so that my eyes don't start bleeding when I look at it.
    
    Here's some of the excesses:
    
     - Total disregard of countless aspects of Documentation/CodingStyle.
    
     - Totally inconsistent hodge-podge of various coding styles and practices.
    
     - Gems like:
    
           (unsigned long long) e820_table->entries[i].addr
    
       ... which is a completely unnecessary type conversion of an u64 value.
    
     - Incomprehensible comments while there are major functions with absolutely
       no explanation - plus an armada of typos and grammar mistakes.
    
     - Mindless checkpatch artifacts such as:
    
             if (append_e820_table(boot_params.e820_table, boot_params.e820_entries)
               < 0) {
    
               for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,
                                       NULL) {
    
     - Actively misleading comments:
    
            /* In case someone cares... */
            return who;
    
       ( The usage site of the return value just a few lines further down makes it
         clear that we very much care about the return value, we use it to print
         out the e820 map... )
    
     - Colorfully inconsistent capitalization and punctuation throughout.
    
     - etc.
    
    This patch fixes only the worst excesses - there's more to fix.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 86d6d823e47e..624190fe86a7 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1,12 +1,12 @@
 /*
- * Handle the memory map.
- * The functions here do the job until bootmem takes over.
+ * Low level x86 E820 memory map handling functions.
  *
- *  Getting sanitize_e820_table() in sync with i386 version by applying change:
- *  -  Provisions for empty E820 memory regions (reported by certain BIOSes).
- *     Alex Achenbach <xela@slit.de>, December 2002.
- *  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
+ * The firmware and bootloader passes us the "E820 table", which is the primary
+ * physical memory layout description available about x86 systems.
  *
+ * The kernel takes the E820 memory layout and optionally modifies it with
+ * quirks and other tweaks, and feeds that into the generic Linux memory
+ * allocation code routines via a platform independent interface (memblock, etc.).
  */
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -27,13 +27,6 @@
 #include <asm/cpufeature.h>
 
 /*
- * The firmware and bootloader passes us an E820 table that is the primary
- * physical memory layout description available about x86 systems.
- *
- * The kernel takes the e820 memory layout and optionally modifies it with
- * quirks and other tweaks, and feeds that into the generic Linux memory
- * allocation code routines via a platform independent interface (memblock, etc.).
- *
  * We organize the E820 table into two main data structures:
  *
  * - 'e820_table_firmware': the original firmware version passed to us by the
@@ -45,16 +38,16 @@
  *       - the hibernation code uses it to generate a kernel-independent MD5
  *         fingerprint of the physical memory layout of a system.
  *
- *       - kexec, which is a bootloader in disguise, uses the original e820
+ *       - kexec, which is a bootloader in disguise, uses the original E820
  *         layout to pass to the kexec-ed kernel. This way the original kernel
- *         can have a restricted e820 map while the kexec()-ed kexec-kernel
+ *         can have a restricted E820 map while the kexec()-ed kexec-kernel
  *         can have access to full memory - etc.
  *
- * - 'e820_table': this is the main e820 table that is massaged by the
+ * - 'e820_table': this is the main E820 table that is massaged by the
  *   low level x86 platform code, or modified by boot parameters, before
  *   passed on to higher level MM layers.
  *
- * Once the e820 map has been converted to the standard Linux memory layout
+ * Once the E820 map has been converted to the standard Linux memory layout
  * information its role stops - modifying it has no effect and does not get
  * re-propagated. So itsmain role is a temporary bootstrap storage of firmware
  * specific memory layout data during early bootup.
@@ -75,8 +68,7 @@ EXPORT_SYMBOL(pci_mem_start);
  * This function checks if any part of the range <start,end> is mapped
  * with type.
  */
-int
-e820_any_mapped(u64 start, u64 end, unsigned type)
+int e820_any_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
@@ -94,10 +86,10 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 EXPORT_SYMBOL_GPL(e820_any_mapped);
 
 /*
- * This function checks if the entire range <start,end> is mapped with type.
+ * This function checks if the entire <start,end> range is mapped with 'type'.
  *
- * Note: this function only works correct if the e820 table is sorted and
- * not-overlapping, which is the case
+ * Note: this function only works correctly once the E820 table is sorted and
+ * not-overlapping (at least for the range specified), which is the case normally.
  */
 int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 {
@@ -108,18 +100,21 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 
 		if (type && ei->type != type)
 			continue;
-		/* is the region (part) in overlap with the current region ?*/
+
+		/* Is the region (part) in overlap with the current region? */
 		if (ei->addr >= end || ei->addr + ei->size <= start)
 			continue;
 
-		/* if the region is at the beginning of <start,end> we move
-		 * start to the end of the region since it's ok until there
+		/*
+		 * If the region is at the beginning of <start,end> we move
+		 * 'start' to the end of the region since it's ok until there
 		 */
 		if (ei->addr <= start)
 			start = ei->addr + ei->size;
+
 		/*
-		 * if start is now at or beyond end, we're done, full
-		 * coverage
+		 * If 'start' is now at or beyond 'end', we're done, full
+		 * coverage of the desired range exists:
 		 */
 		if (start >= end)
 			return 1;
@@ -128,16 +123,14 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 }
 
 /*
- * Add a memory region to the kernel e820 map.
+ * Add a memory region to the kernel E820 map.
  */
 static void __init __e820_add_region(struct e820_table *table, u64 start, u64 size, int type)
 {
 	int x = table->nr_entries;
 
 	if (x >= ARRAY_SIZE(table->entries)) {
-		printk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n",
-		       (unsigned long long) start,
-		       (unsigned long long) (start + size - 1));
+		printk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n", start, start + size - 1);
 		return;
 	}
 
@@ -155,29 +148,15 @@ void __init e820_add_region(u64 start, u64 size, int type)
 static void __init e820_print_type(u32 type)
 {
 	switch (type) {
-	case E820_RAM:
-	case E820_RESERVED_KERN:
-		printk(KERN_CONT "usable");
-		break;
-	case E820_RESERVED:
-		printk(KERN_CONT "reserved");
-		break;
-	case E820_ACPI:
-		printk(KERN_CONT "ACPI data");
-		break;
-	case E820_NVS:
-		printk(KERN_CONT "ACPI NVS");
-		break;
-	case E820_UNUSABLE:
-		printk(KERN_CONT "unusable");
-		break;
-	case E820_PMEM:
-	case E820_PRAM:
-		printk(KERN_CONT "persistent (type %u)", type);
-		break;
-	default:
-		printk(KERN_CONT "type %u", type);
-		break;
+	case E820_RAM:			/* Fall through: */
+	case E820_RESERVED_KERN:	printk(KERN_CONT "usable");			break;
+	case E820_RESERVED:		printk(KERN_CONT "reserved");			break;
+	case E820_ACPI:			printk(KERN_CONT "ACPI data");			break;
+	case E820_NVS:			printk(KERN_CONT "ACPI NVS");			break;
+	case E820_UNUSABLE:		printk(KERN_CONT "unusable");			break;
+	case E820_PMEM:			/* Fall through: */
+	case E820_PRAM:			printk(KERN_CONT "persistent (type %u)", type);	break;
+	default:			printk(KERN_CONT "type %u", type);		break;
 	}
 }
 
@@ -187,26 +166,26 @@ void __init e820_print_map(char *who)
 
 	for (i = 0; i < e820_table->nr_entries; i++) {
 		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
-		       (unsigned long long) e820_table->entries[i].addr,
-		       (unsigned long long)
-		       (e820_table->entries[i].addr + e820_table->entries[i].size - 1));
+		       e820_table->entries[i].addr,
+		       e820_table->entries[i].addr + e820_table->entries[i].size - 1);
+
 		e820_print_type(e820_table->entries[i].type);
 		printk(KERN_CONT "\n");
 	}
 }
 
 /*
- * Sanitize the BIOS e820 map.
+ * Sanitize the BIOS E820 map.
  *
- * Some e820 responses include overlapping entries. The following
- * replaces the original e820 map with a new one, removing overlaps,
+ * Some E820 responses include overlapping entries. The following
+ * replaces the original E820 map with a new one, removing overlaps,
  * and resolving conflicting memory types in favor of highest
  * numbered type.
  *
  * The input parameter biosmap points to an array of 'struct
  * e820_entry' which on entry has elements in the range [0, *pnr_map)
  * valid, and which has space for up to max_nr_map entries.
- * On return, the resulting sanitized e820 map entries will be in
+ * On return, the resulting sanitized E820 map entries will be in
  * overwritten in the same location, starting at biosmap.
  *
  * The integer pointed to by pnr_map must be valid on entry (the
@@ -257,8 +236,10 @@ void __init e820_print_map(char *who)
  *	   ______________________4_
  */
 struct change_member {
-	struct e820_entry *pbios; /* pointer to original bios entry */
-	unsigned long long addr; /* address for this change point */
+	/* Pointer to the original BIOS entry: */
+	struct e820_entry	*pbios;
+	/* Address for this change point: */
+	unsigned long long	addr;
 };
 
 static int __init cpcompare(const void *a, const void *b)
@@ -268,7 +249,7 @@ static int __init cpcompare(const void *a, const void *b)
 
 	/*
 	 * Inputs are pointers to two elements of change_point[].  If their
-	 * addresses are unequal, their difference dominates.  If the addresses
+	 * addresses are not equal, their difference dominates.  If the addresses
 	 * are equal, then consider one that represents the end of its region
 	 * to be greater than one that does not.
 	 */
@@ -278,8 +259,7 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init sanitize_e820_table(struct e820_entry *biosmap, int max_nr_map,
-			     u32 *pnr_map)
+int __init sanitize_e820_table(struct e820_entry *biosmap, int max_nr_map, u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
 	static struct change_member *change_point[2*E820_X_MAX] __initdata;
@@ -293,112 +273,96 @@ int __init sanitize_e820_table(struct e820_entry *biosmap, int max_nr_map,
 	int old_nr, new_nr, chg_nr;
 	int i;
 
-	/* if there's only one memory region, don't bother */
+	/* If there's only one memory region, don't bother: */
 	if (*pnr_map < 2)
 		return -1;
 
 	old_nr = *pnr_map;
 	BUG_ON(old_nr > max_nr_map);
 
-	/* bail out if we find any unreasonable addresses in bios map */
-	for (i = 0; i < old_nr; i++)
+	/* Bail out if we find any unreasonable addresses in the BIOS map: */
+	for (i = 0; i < old_nr; i++) {
 		if (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)
 			return -1;
+	}
 
-	/* create pointers for initial change-point information (for sorting) */
+	/* Create pointers for initial change-point information (for sorting): */
 	for (i = 0; i < 2 * old_nr; i++)
 		change_point[i] = &change_point_list[i];
 
-	/* record all known change-points (starting and ending addresses),
-	   omitting those that are for empty memory regions */
+	/*
+	 * Record all known change-points (starting and ending addresses),
+	 * omitting empty memory regions:
+	 */
 	chgidx = 0;
 	for (i = 0; i < old_nr; i++)	{
 		if (biosmap[i].size != 0) {
-			change_point[chgidx]->addr = biosmap[i].addr;
-			change_point[chgidx++]->pbios = &biosmap[i];
-			change_point[chgidx]->addr = biosmap[i].addr +
-				biosmap[i].size;
-			change_point[chgidx++]->pbios = &biosmap[i];
+			change_point[chgidx]->addr	= biosmap[i].addr;
+			change_point[chgidx++]->pbios	= &biosmap[i];
+			change_point[chgidx]->addr	= biosmap[i].addr + biosmap[i].size;
+			change_point[chgidx++]->pbios	= &biosmap[i];
 		}
 	}
 	chg_nr = chgidx;
 
-	/* sort change-point list by memory addresses (low -> high) */
+	/* Sort change-point list by memory addresses (low -> high): */
 	sort(change_point, chg_nr, sizeof *change_point, cpcompare, NULL);
 
-	/* create a new bios memory map, removing overlaps */
-	overlap_entries = 0;	 /* number of entries in the overlap table */
-	new_bios_entry = 0;	 /* index for creating new bios map entries */
-	last_type = 0;		 /* start with undefined memory type */
-	last_addr = 0;		 /* start with 0 as last starting address */
+	/* Create a new BIOS memory map, removing overlaps: */
+	overlap_entries = 0;	 /* Number of entries in the overlap table */
+	new_bios_entry = 0;	 /* Index for creating new bios map entries */
+	last_type = 0;		 /* Start with undefined memory type */
+	last_addr = 0;		 /* Start with 0 as last starting address */
 
-	/* loop through change-points, determining affect on the new bios map */
+	/* Loop through change-points, determining effect on the new BIOS map: */
 	for (chgidx = 0; chgidx < chg_nr; chgidx++) {
-		/* keep track of all overlapping bios entries */
-		if (change_point[chgidx]->addr ==
-		    change_point[chgidx]->pbios->addr) {
-			/*
-			 * add map entry to overlap list (> 1 entry
-			 * implies an overlap)
-			 */
-			overlap_list[overlap_entries++] =
-				change_point[chgidx]->pbios;
+		/* Keep track of all overlapping BIOS entries */
+		if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
+			/* Add map entry to overlap list (> 1 entry implies an overlap) */
+			overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
 		} else {
-			/*
-			 * remove entry from list (order independent,
-			 * so swap with last)
-			 */
+			/* Remove entry from list (order independent, so swap with last): */
 			for (i = 0; i < overlap_entries; i++) {
-				if (overlap_list[i] ==
-				    change_point[chgidx]->pbios)
-					overlap_list[i] =
-						overlap_list[overlap_entries-1];
+				if (overlap_list[i] == change_point[chgidx]->pbios)
+					overlap_list[i] = overlap_list[overlap_entries-1];
 			}
 			overlap_entries--;
 		}
 		/*
-		 * if there are overlapping entries, decide which
+		 * If there are overlapping entries, decide which
 		 * "type" to use (larger value takes precedence --
 		 * 1=usable, 2,3,4,4+=unusable)
 		 */
 		current_type = 0;
-		for (i = 0; i < overlap_entries; i++)
+		for (i = 0; i < overlap_entries; i++) {
 			if (overlap_list[i]->type > current_type)
 				current_type = overlap_list[i]->type;
-		/*
-		 * continue building up new bios map based on this
-		 * information
-		 */
+		}
+
+		/* Continue building up new BIOS map based on this information: */
 		if (current_type != last_type || current_type == E820_PRAM) {
 			if (last_type != 0)	 {
-				new_bios[new_bios_entry].size =
-					change_point[chgidx]->addr - last_addr;
-				/*
-				 * move forward only if the new size
-				 * was non-zero
-				 */
+				new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
+				/* Move forward only if the new size was non-zero: */
 				if (new_bios[new_bios_entry].size != 0)
-					/*
-					 * no more space left for new
-					 * bios entries ?
-					 */
+					/* No more space left for new BIOS entries? */
 					if (++new_bios_entry >= max_nr_map)
 						break;
 			}
 			if (current_type != 0)	{
-				new_bios[new_bios_entry].addr =
-					change_point[chgidx]->addr;
+				new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
 				new_bios[new_bios_entry].type = current_type;
 				last_addr = change_point[chgidx]->addr;
 			}
 			last_type = current_type;
 		}
 	}
-	/* retain count for new bios entries */
+
+	/* Retain count for new BIOS entries: */
 	new_nr = new_bios_entry;
 
-	/* copy new bios mapping into original location */
-	memcpy(biosmap, new_bios, new_nr * sizeof(struct e820_entry));
+	/* Copy new BIOS mapping into the original location: */
+	memcpy(biosmap, new_bios, new_nr*sizeof(struct e820_entry));
 	*pnr_map = new_nr;
 
 	return 0;
@@ -412,7 +376,7 @@ static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 		u64 end = start + size - 1;
 		u32 type = biosmap->type;
 
-		/* Overflow in 64 bits? Ignore the memory map. */
+		/* Ignore the entry on 64-bit overflow: */
 		if (start > end && likely(size))
 			return -1;
 
@@ -425,7 +389,7 @@ static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 }
 
 /*
- * Copy the BIOS e820 map into a safe place.
+ * Copy the BIOS E820 map into a safe place.
  *
  * Sanity-check it while we're at it..
  *
@@ -442,9 +406,8 @@ static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
 	return __append_e820_table(biosmap, nr_map);
 }
 
-static u64 __init __e820_update_range(struct e820_table *table, u64 start,
-					u64 size, unsigned old_type,
-					unsigned new_type)
+static u64 __init
+__e820_update_range(struct e820_table *table, u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
 	u64 end;
 	unsigned int i;
@@ -456,8 +419,7 @@ static u64 __init __e820_update_range(struct e820_table *table, u64 start,
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ",
-	       (unsigned long long) start, (unsigned long long) (end - 1));
+	printk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ", start, end - 1);
 	e820_print_type(old_type);
 	printk(KERN_CONT " ==> ");
 	e820_print_type(new_type);
@@ -472,14 +434,15 @@ static u64 __init __e820_update_range(struct e820_table *table, u64 start,
 			continue;
 
 		ei_end = ei->addr + ei->size;
-		/* totally covered by new range? */
+
+		/* Completely covered by new range? */
 		if (ei->addr >= start && ei_end <= end) {
 			ei->type = new_type;
 			real_updated_size += ei->size;
 			continue;
 		}
 
-		/* new range is totally covered? */
+		/* New range is completely covered? */
 		if (ei->addr < start && ei_end > end) {
 			__e820_add_region(table, start, size, new_type);
 			__e820_add_region(table, end, ei_end - end, ei->type);
@@ -488,45 +451,41 @@ static u64 __init __e820_update_range(struct e820_table *table, u64 start,
 			continue;
 		}
 
-		/* partially covered */
+		/* Partially covered: */
 		final_start = max(start, ei->addr);
 		final_end = min(end, ei_end);
 		if (final_start >= final_end)
 			continue;
 
-		__e820_add_region(table, final_start, final_end - final_start,
-				  new_type);
+		__e820_add_region(table, final_start, final_end - final_start, new_type);
 
 		real_updated_size += final_end - final_start;
 
 		/*
-		 * left range could be head or tail, so need to update
-		 * size at first.
+		 * Left range could be head or tail, so need to update
+		 * its size first:
 		 */
 		ei->size -= final_end - final_start;
 		if (ei->addr < final_start)
 			continue;
+
 		ei->addr = final_end;
 	}
 	return real_updated_size;
 }
 
-u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
-			     unsigned new_type)
+u64 __init e820_update_range(u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
 	return __e820_update_range(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820_update_range_firmware(u64 start, u64 size,
-					  unsigned old_type, unsigned new_type)
+static u64 __init e820_update_range_firmware(u64 start, u64 size, unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_table_firmware, start, size, old_type,
-				     new_type);
+	return __e820_update_range(e820_table_firmware, start, size, old_type, new_type);
 }
 
-/* make e820 not cover the range */
-u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
-			     int checktype)
+/* Remove a range of memory from the E820 table: */
+u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type, int checktype)
 {
 	int i;
 	u64 end;
@@ -536,8 +495,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ",
-	       (unsigned long long) start, (unsigned long long) (end - 1));
+	printk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ", start, end - 1);
 	if (checktype)
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
@@ -551,14 +509,15 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 			continue;
 
 		ei_end = ei->addr + ei->size;
-		/* totally covered? */
+
+		/* Completely covered? */
 		if (ei->addr >= start && ei_end <= end) {
 			real_removed_size += ei->size;
 			memset(ei, 0, sizeof(struct e820_entry));
 			continue;
 		}
 
-		/* new range is totally covered? */
+		/* Is the new range completely covered? */
 		if (ei->addr < start && ei_end > end) {
 			e820_add_region(end, ei_end - end, ei->type);
 			ei->size = start - ei->addr;
@@ -566,20 +525,22 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 			continue;
 		}
 
-		/* partially covered */
+		/* Partially covered: */
 		final_start = max(start, ei->addr);
 		final_end = min(end, ei_end);
 		if (final_start >= final_end)
 			continue;
+
 		real_removed_size += final_end - final_start;
 
 		/*
-		 * left range could be head or tail, so need to update
-		 * size at first.
+		 * Left range could be head or tail, so need to update
+		 * the size first:
 		 */
 		ei->size -= final_end - final_start;
 		if (ei->addr < final_start)
 			continue;
+
 		ei->addr = final_end;
 	}
 	return real_removed_size;
@@ -589,19 +550,22 @@ void __init update_e820(void)
 {
 	if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
 		return;
+
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
+
 static void __init update_e820_table_firmware(void)
 {
 	sanitize_e820_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
 }
+
 #define MAX_GAP_END 0x100000000ull
+
 /*
- * Search for a gap in the e820 memory space from 0 to MAX_GAP_END.
+ * Search for a gap in the E820 memory space from 0 to MAX_GAP_END (4GB).
  */
-static int __init e820_search_gap(unsigned long *gapstart,
-		unsigned long *gapsize)
+static int __init e820_search_gap(unsigned long *gapstart, unsigned long *gapsize)
 {
 	unsigned long long last = MAX_GAP_END;
 	int i = e820_table->nr_entries;
@@ -613,7 +577,7 @@ static int __init e820_search_gap(unsigned long *gapstart,
 
 		/*
 		 * Since "last" is at most 4GB, we know we'll
-		 * fit in 32 bits if this condition is true
+		 * fit in 32 bits if this condition is true:
 		 */
 		if (last > end) {
 			unsigned long gap = last - end;
@@ -631,9 +595,11 @@ static int __init e820_search_gap(unsigned long *gapstart,
 }
 
 /*
- * Search for the biggest gap in the low 32 bits of the e820
- * memory space.  We pass this space to PCI to assign MMIO resources
- * for hotplug or unconfigured devices in.
+ * Search for the biggest gap in the low 32 bits of the E820
+ * memory space. We pass this space to the PCI subsystem, so
+ * that it can assign MMIO resources for hotplug or
+ * unconfigured devices in.
+ *
  * Hopefully the BIOS let enough space left.
  */
 __init void e820_setup_gap(void)
@@ -648,8 +614,8 @@ __init void e820_setup_gap(void)
 #ifdef CONFIG_X86_64
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
 		printk(KERN_ERR
-	"e820: cannot find a gap in the 32bit address range\n"
-	"e820: PCI devices with unassigned 32bit BARs may break!\n");
+			"e820: Cannot find an available gap in the 32-bit address range\n"
+			"e820: PCI devices with unassigned 32-bit BARs may not work!\n");
 #else
 		gapstart = 0x10000000;
 #endif
@@ -660,43 +626,44 @@ __init void e820_setup_gap(void)
 	 */
 	pci_mem_start = gapstart;
 
-	printk(KERN_INFO
-	       "e820: [mem %#010lx-%#010lx] available for PCI devices\n",
-	       gapstart, gapstart + gapsize - 1);
+	printk(KERN_INFO "e820: [mem %#010lx-%#010lx] available for PCI devices\n", gapstart, gapstart + gapsize - 1);
 }
 
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820 and e820_table_firmware are largish __initdata arrays.
- * Copy them to (usually much smaller) dynamically allocated area.
- * This is done after all tweaks we ever do to them:
- * all functions which modify them are __init functions,
- * they won't exist after this point.
+ * Initial e820_table and e820_table_firmware are largish __initdata arrays.
+ *
+ * Copy them to a (usually much smaller) dynamically allocated area that is
+ * sized precisely after the number of e820 entries.
+ *
+ * This is done after we've performed all the fixes and tweaks to the tables.
+ * All functions which modify them are __init functions, which won't exist
+ * after free_initmem().
  */
 __init void e820_reallocate_tables(void)
 {
 	struct e820_table *n;
 	int size;
 
-	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table->nr_entries;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820_table, size);
 	e820_table = n;
 
-	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table_firmware->nr_entries;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820_table_firmware, size);
 	e820_table_firmware = n;
 }
 
-/**
- * Because of the size limitation of struct boot_params, only first
- * 128 E820 memory entries are passed to kernel via
- * boot_params.e820_table, others are passed via SETUP_E820_EXT node of
- * linked list of struct setup_data, which is parsed here.
+/*
+ * Because of the small fixed size of struct boot_params, only the first
+ * 128 E820 memory entries are passed to the kernel via boot_params.e820_table,
+ * the remaining (if any) entries are passed via the SETUP_E820_EXT node of
+ * struct setup_data, which is parsed here.
  */
 void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 {
@@ -707,8 +674,10 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	sdata = early_memremap(phys_addr, data_len);
 	entries = sdata->len / sizeof(struct e820_entry);
 	extmap = (struct e820_entry *)(sdata->data);
+
 	__append_e820_table(extmap, entries);
 	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
+
 	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
@@ -716,10 +685,10 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 
 /**
  * Find the ranges of physical addresses that do not correspond to
- * e820 RAM areas and mark the corresponding pages as nosave for
- * hibernation (32 bit) or software suspend and suspend to RAM (64 bit).
+ * E820 RAM areas and mark the corresponding pages as 'nosave' for
+ * hibernation (32-bit) or software suspend and suspend to RAM (64-bit).
  *
- * This function requires the e820 map to be sorted and without any
+ * This function requires the E820 map to be sorted and without any
  * overlapping entries.
  */
 void __init e820_mark_nosave_regions(unsigned long limit_pfn)
@@ -744,9 +713,9 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 }
 
 #ifdef CONFIG_ACPI
-/**
- * Mark ACPI NVS memory region, so that we can save/restore it during
- * hibernation and the subsequent resume.
+/*
+ * Register ACPI NVS memory regions, so that we can save/restore them during
+ * hibernation and the subsequent resume:
  */
 static int __init e820_mark_nvs_memory(void)
 {
@@ -828,6 +797,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }
+
 unsigned long __init e820_end_of_ram_pfn(void)
 {
 	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
@@ -846,7 +816,7 @@ static void __init early_panic(char *msg)
 
 static int userdef __initdata;
 
-/* "mem=nopentium" disables the 4MB page tables. */
+/* The "mem=nopentium" boot option disables 4MB page tables on 32-bit kernels: */
 static int __init parse_memopt(char *p)
 {
 	u64 mem_size;
@@ -866,9 +836,11 @@ static int __init parse_memopt(char *p)
 
 	userdef = 1;
 	mem_size = memparse(p, &p);
-	/* don't remove all of memory when handling "mem={invalid}" param */
+
+	/* Don't remove all memory when getting "mem={invalid}" parameter: */
 	if (mem_size == 0)
 		return -EINVAL;
+
 	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
 	return 0;
@@ -887,7 +859,7 @@ static int __init parse_memmap_one(char *p)
 #ifdef CONFIG_CRASH_DUMP
 		/*
 		 * If we are doing a crash dump, we still need to know
-		 * the real mem size before original memory map is
+		 * the real memory size before the original memory map is
 		 * reset.
 		 */
 		saved_max_pfn = e820_end_of_ram_pfn();
@@ -915,11 +887,13 @@ static int __init parse_memmap_one(char *p)
 	} else if (*p == '!') {
 		start_at = memparse(p+1, &p);
 		e820_add_region(start_at, mem_size, E820_PRAM);
-	} else
+	} else {
 		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
+	}
 
 	return *p == '\0' ? 0 : -EINVAL;
 }
+
 static int __init parse_memmap_opt(char *str)
 {
 	while (str) {
@@ -939,8 +913,7 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries),
-					&e820_table->nr_entries) < 0)
+		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
@@ -951,49 +924,42 @@ void __init finish_e820_parsing(void)
 static const char *__init e820_type_to_string(int e820_type)
 {
 	switch (e820_type) {
-	case E820_RESERVED_KERN:
-	case E820_RAM:	return "System RAM";
-	case E820_ACPI:	return "ACPI Tables";
-	case E820_NVS:	return "ACPI Non-volatile Storage";
-	case E820_UNUSABLE:	return "Unusable memory";
-	case E820_PRAM: return "Persistent Memory (legacy)";
-	case E820_PMEM: return "Persistent Memory";
-	default:	return "reserved";
+	case E820_RESERVED_KERN: /* Fall-through: */
+	case E820_RAM:		 return "System RAM";
+	case E820_ACPI:		 return "ACPI Tables";
+	case E820_NVS:		 return "ACPI Non-volatile Storage";
+	case E820_UNUSABLE:	 return "Unusable memory";
+	case E820_PRAM:		 return "Persistent Memory (legacy)";
+	case E820_PMEM:		 return "Persistent Memory";
+	default:		 return "Reserved";
 	}
 }
 
 static unsigned long __init e820_type_to_iomem_type(int e820_type)
 {
 	switch (e820_type) {
-	case E820_RESERVED_KERN:
-	case E820_RAM:
-		return IORESOURCE_SYSTEM_RAM;
-	case E820_ACPI:
-	case E820_NVS:
-	case E820_UNUSABLE:
-	case E820_PRAM:
-	case E820_PMEM:
-	default:
-		return IORESOURCE_MEM;
+	case E820_RESERVED_KERN: /* Fall-through: */
+	case E820_RAM:		 return IORESOURCE_SYSTEM_RAM;
+	case E820_ACPI:		 /* Fall-through: */
+	case E820_NVS:		 /* Fall-through: */
+	case E820_UNUSABLE:	 /* Fall-through: */
+	case E820_PRAM:		 /* Fall-through: */
+	case E820_PMEM:		 /* Fall-through: */
+	default:		 return IORESOURCE_MEM;
 	}
 }
 
 static unsigned long __init e820_type_to_iores_desc(int e820_type)
 {
 	switch (e820_type) {
-	case E820_ACPI:
-		return IORES_DESC_ACPI_TABLES;
-	case E820_NVS:
-		return IORES_DESC_ACPI_NV_STORAGE;
-	case E820_PMEM:
-		return IORES_DESC_PERSISTENT_MEMORY;
-	case E820_PRAM:
-		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
-	case E820_RESERVED_KERN:
-	case E820_RAM:
-	case E820_UNUSABLE:
-	default:
-		return IORES_DESC_NONE;
+	case E820_ACPI:		 return IORES_DESC_ACPI_TABLES;
+	case E820_NVS:		 return IORES_DESC_ACPI_NV_STORAGE;
+	case E820_PMEM:		 return IORES_DESC_PERSISTENT_MEMORY;
+	case E820_PRAM:		 return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
+	case E820_RESERVED_KERN: /* Fall-through: */
+	case E820_RAM:		 /* Fall-through: */
+	case E820_UNUSABLE:	 /* Fall-through: */
+	default:		 return IORES_DESC_NONE;
 	}
 }
 
@@ -1018,9 +984,11 @@ static bool __init do_mark_busy(u32 type, struct resource *res)
 }
 
 /*
- * Mark e820 reserved areas as busy for the resource manager.
+ * Mark E820 reserved areas as busy for the resource manager:
  */
+
 static struct resource __initdata *e820_res;
+
 void __init e820_reserve_resources(void)
 {
 	int i;
@@ -1056,9 +1024,8 @@ void __init e820_reserve_resources(void)
 
 	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
 		struct e820_entry *entry = &e820_table_firmware->entries[i];
-		firmware_map_add_early(entry->addr,
-			entry->addr + entry->size,
-			e820_type_to_string(entry->type));
+
+		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry->type));
 	}
 }
 
@@ -1094,7 +1061,7 @@ void __init e820_reserve_resources_late(void)
 	}
 
 	/*
-	 * Try to bump up RAM regions to reasonable boundaries to
+	 * Try to bump up RAM regions to reasonable boundaries, to
 	 * avoid stolen RAM:
 	 */
 	for (i = 0; i < e820_table->nr_entries; i++) {
@@ -1103,24 +1070,27 @@ void __init e820_reserve_resources_late(void)
 
 		if (entry->type != E820_RAM)
 			continue;
+
 		start = entry->addr + entry->size;
 		end = round_up(start, ram_alignment(start)) - 1;
 		if (end > MAX_RESOURCE_SIZE)
 			end = MAX_RESOURCE_SIZE;
 		if (start >= end)
 			continue;
-		printk(KERN_DEBUG
-		       "e820: reserve RAM buffer [mem %#010llx-%#010llx]\n",
-		       start, end);
-		reserve_region_with_split(&iomem_resource, start, end,
-					  "RAM buffer");
+
+		printk(KERN_DEBUG "e820: reserve RAM buffer [mem %#010llx-%#010llx]\n", start, end);
+		reserve_region_with_split(&iomem_resource, start, end, "RAM buffer");
 	}
 }
 
+/*
+ * Pass the firmware (bootloader) E820 map to the kernel and process it:
+ */
 char *__init e820__memory_setup_default(void)
 {
 	char *who = "BIOS-e820";
 	u32 new_nr;
+
 	/*
 	 * Try to copy the BIOS-supplied E820-map.
 	 *
@@ -1128,17 +1098,14 @@ char *__init e820__memory_setup_default(void)
 	 * the next section from 1mb->appropriate_mem_k
 	 */
 	new_nr = boot_params.e820_entries;
-	sanitize_e820_table(boot_params.e820_table,
-			ARRAY_SIZE(boot_params.e820_table),
-			&new_nr);
+	sanitize_e820_table(boot_params.e820_table, ARRAY_SIZE(boot_params.e820_table), &new_nr);
 	boot_params.e820_entries = new_nr;
-	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries)
-	  < 0) {
+
+	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries) < 0) {
 		u64 mem_size;
 
-		/* compare results from other methods and take the greater */
-		if (boot_params.alt_mem_k
-		    < boot_params.screen_info.ext_mem_k) {
+		/* Compare results from other methods and take the one that gives more RAM: */
+		if (boot_params.alt_mem_k < boot_params.screen_info.ext_mem_k) {
 			mem_size = boot_params.screen_info.ext_mem_k;
 			who = "BIOS-88";
 		} else {
@@ -1151,7 +1118,6 @@ char *__init e820__memory_setup_default(void)
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
 
-	/* In case someone cares... */
 	return who;
 }
 
@@ -1165,7 +1131,9 @@ void __init e820__memory_setup(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
+
 	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
+
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
@@ -1221,8 +1189,7 @@ void __init memblock_find_dma_reserve(void)
 		nr_pages += end_pfn - start_pfn;
 	}
 
-	for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,
-				NULL) {
+	for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end, NULL) {
 		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
 		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
 		if (start_pfn < end_pfn)

commit 544a0f47e7803443980496d6c9ae78b6c2b3dbcb
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 10:07:49 2017 +0100

    x86/boot/e820: Rename e820_table_saved to e820_table_firmware and improve the description
    
    So the 'e820_table_saved' is a bit of a misnomer that hides its real purpose.
    
    At first sight the name suggests that it's some sort save/restore mechanism,
    as this is how we typically name such facilities in the kernel.
    
    But that is not so, e820_table_saved is the original firmware version of the
    e820 table, not modified by the kernel. This table is displayed in the
    /sys/firmware/memmap file, and it's also used by the hibernation code to
    calculate a physical memory layout MD5 fingerprint checksum which is
    invariant of the kernel.
    
    So rename it to 'e820_table_firmware' and update all the comments to better
    describe the main e820 data strutures.
    
    Also rename:
    
      'initial_e820_table_saved'  =>  'e820_table_firmware_init'
      'e820_update_range_saved'   =>  'e820_update_range_firmware'
    
    ... to better match the new nomenclature.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7d12433ad056..86d6d823e47e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -27,23 +27,43 @@
 #include <asm/cpufeature.h>
 
 /*
- * The e820 table is the array that gets modified e.g. with command line parameters
- * and that is also registered with modifications in the kernel resource tree
- * with the iomem_resource as parent.
+ * The firmware and bootloader passes us an E820 table that is the primary
+ * physical memory layout description available about x86 systems.
  *
- * The e820_table_saved is directly saved after the BIOS-provided memory map is
- * copied. It doesn't get modified afterwards. It's registered for the
- * /sys/firmware/memmap interface.
+ * The kernel takes the e820 memory layout and optionally modifies it with
+ * quirks and other tweaks, and feeds that into the generic Linux memory
+ * allocation code routines via a platform independent interface (memblock, etc.).
  *
- * That memory map is not modified and is used as base for kexec. The kexec'd
- * kernel should get the same memory map as the firmware provides. Then the
- * user can e.g. boot the original kernel with mem=1G while still booting the
- * next kernel with full memory.
+ * We organize the E820 table into two main data structures:
+ *
+ * - 'e820_table_firmware': the original firmware version passed to us by the
+ *   bootloader - not modified by the kernel. We use this to:
+ *
+ *       - inform the user about the firmware's notion of memory layout
+ *         via /sys/firmware/memmap
+ *
+ *       - the hibernation code uses it to generate a kernel-independent MD5
+ *         fingerprint of the physical memory layout of a system.
+ *
+ *       - kexec, which is a bootloader in disguise, uses the original e820
+ *         layout to pass to the kexec-ed kernel. This way the original kernel
+ *         can have a restricted e820 map while the kexec()-ed kexec-kernel
+ *         can have access to full memory - etc.
+ *
+ * - 'e820_table': this is the main e820 table that is massaged by the
+ *   low level x86 platform code, or modified by boot parameters, before
+ *   passed on to higher level MM layers.
+ *
+ * Once the e820 map has been converted to the standard Linux memory layout
+ * information its role stops - modifying it has no effect and does not get
+ * re-propagated. So itsmain role is a temporary bootstrap storage of firmware
+ * specific memory layout data during early bootup.
  */
-static struct e820_table e820_table_init  __initdata;
-static struct e820_table initial_e820_table_saved  __initdata;
-struct e820_table *e820_table __refdata = &e820_table_init;
-struct e820_table *e820_table_saved __refdata = &initial_e820_table_saved;
+static struct e820_table e820_table_init		__initdata;
+static struct e820_table e820_table_firmware_init	__initdata;
+
+struct e820_table *e820_table __refdata			= &e820_table_init;
+struct e820_table *e820_table_firmware __refdata	= &e820_table_firmware_init;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -497,10 +517,10 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 	return __e820_update_range(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820_update_range_saved(u64 start, u64 size,
+static u64 __init e820_update_range_firmware(u64 start, u64 size,
 					  unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_table_saved, start, size, old_type,
+	return __e820_update_range(e820_table_firmware, start, size, old_type,
 				     new_type);
 }
 
@@ -572,9 +592,9 @@ void __init update_e820(void)
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
-static void __init update_e820_table_saved(void)
+static void __init update_e820_table_firmware(void)
 {
-	sanitize_e820_table(e820_table_saved->entries, ARRAY_SIZE(e820_table_saved->entries), &e820_table_saved->nr_entries);
+	sanitize_e820_table(e820_table_firmware->entries, ARRAY_SIZE(e820_table_firmware->entries), &e820_table_firmware->nr_entries);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -648,7 +668,7 @@ __init void e820_setup_gap(void)
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820 and e820_table_saved are largish __initdata arrays.
+ * Initial e820 and e820_table_firmware are largish __initdata arrays.
  * Copy them to (usually much smaller) dynamically allocated area.
  * This is done after all tweaks we ever do to them:
  * all functions which modify them are __init functions,
@@ -665,11 +685,11 @@ __init void e820_reallocate_tables(void)
 	memcpy(n, e820_table, size);
 	e820_table = n;
 
-	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table_saved->nr_entries;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table_firmware->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table_saved, size);
-	e820_table_saved = n;
+	memcpy(n, e820_table_firmware, size);
+	e820_table_firmware = n;
 }
 
 /**
@@ -745,7 +765,7 @@ core_initcall(e820_mark_nvs_memory);
 #endif
 
 /*
- * pre allocated 4k and reserved it in memblock and e820_table_saved
+ * pre allocated 4k and reserved it in memblock and e820_table_firmware
  */
 u64 __init early_reserve_e820(u64 size, u64 align)
 {
@@ -753,9 +773,9 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
-		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
-		printk(KERN_INFO "e820: update e820_table_saved for early_reserve_e820\n");
-		update_e820_table_saved();
+		e820_update_range_firmware(addr, size, E820_RAM, E820_RESERVED);
+		printk(KERN_INFO "e820: update e820_table_firmware for early_reserve_e820\n");
+		update_e820_table_firmware();
 	}
 
 	return addr;
@@ -1034,8 +1054,8 @@ void __init e820_reserve_resources(void)
 		res++;
 	}
 
-	for (i = 0; i < e820_table_saved->nr_entries; i++) {
-		struct e820_entry *entry = &e820_table_saved->entries[i];
+	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
+		struct e820_entry *entry = &e820_table_firmware->entries[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1145,7 +1165,7 @@ void __init e820__memory_setup(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
-	memcpy(e820_table_saved, e820_table, sizeof(struct e820_table));
+	memcpy(e820_table_firmware, e820_table, sizeof(struct e820_table));
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }

commit 103e206309639b615981e56008720806b4a102af
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 09:58:49 2017 +0100

    x86/boot/e820: Rename default_machine_specific_memory_setup() to e820__memory_setup_default()
    
    The default_machine_specific_memory_setup() is a mouthful and despite the
    many words it doesn't actually tell us clearly what it does.
    
    The function is the x86 legacy memory layout setup code, based on
    E820-formatted memory layout information passed by the bootloader
    via the boot_params.
    
    Rename it to e820__memory_setup_default() to better signal its purpose.
    
    Also rename the related higher level function to be consistent with
    this new naming:
    
        setup_memory_map() => e820__memory_setup()
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 6d73ad46ab35..7d12433ad056 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1097,7 +1097,7 @@ void __init e820_reserve_resources_late(void)
 	}
 }
 
-char *__init default_machine_specific_memory_setup(void)
+char *__init e820__memory_setup_default(void)
 {
 	char *who = "BIOS-e820";
 	u32 new_nr;
@@ -1135,7 +1135,12 @@ char *__init default_machine_specific_memory_setup(void)
 	return who;
 }
 
-void __init setup_memory_map(void)
+/*
+ * Calls e820__memory_setup_default() in essence to pick up the firmware/bootloader
+ * E820 map - with an optional platform quirk available for virtual platforms
+ * to override this method of boot environment processing:
+ */
+void __init e820__memory_setup(void)
 {
 	char *who;
 

commit bf495573fae84451a8a26215fafb5b62e387ddaf
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 14:06:21 2017 +0100

    x86/boot/e820: Harmonize the 'struct e820_table' fields
    
    So the e820_table->map and e820_table->nr_map names are a bit
    confusing, because it's not clear what a 'map' really means
    (it could be a bitmap, or some other data structure), nor is
    it clear what nr_map means (is it a current index, or some
    other count).
    
    Rename the fields from:
    
     e820_table->map        =>     e820_table->entries
     e820_table->nr_map     =>     e820_table->nr_entries
    
    which makes it abundantly clear that these are entries
    of the table, and that the size of the table is ->nr_entries.
    
    Propagate the changes to all affected files. Where necessary,
    adjust local variable names to better reflect the new field names.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ffaf94357d15..6d73ad46ab35 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -60,8 +60,8 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -83,8 +83,8 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -110,22 +110,21 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel e820 map.
  */
-static void __init __e820_add_region(struct e820_table *e820x, u64 start, u64 size,
-					 int type)
+static void __init __e820_add_region(struct e820_table *table, u64 start, u64 size, int type)
 {
-	int x = e820x->nr_map;
+	int x = table->nr_entries;
 
-	if (x >= ARRAY_SIZE(e820x->map)) {
+	if (x >= ARRAY_SIZE(table->entries)) {
 		printk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n",
 		       (unsigned long long) start,
 		       (unsigned long long) (start + size - 1));
 		return;
 	}
 
-	e820x->map[x].addr = start;
-	e820x->map[x].size = size;
-	e820x->map[x].type = type;
-	e820x->nr_map++;
+	table->entries[x].addr = start;
+	table->entries[x].size = size;
+	table->entries[x].type = type;
+	table->nr_entries++;
 }
 
 void __init e820_add_region(u64 start, u64 size, int type)
@@ -166,12 +165,12 @@ void __init e820_print_map(char *who)
 {
 	int i;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
+	for (i = 0; i < e820_table->nr_entries; i++) {
 		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
-		       (unsigned long long) e820_table->map[i].addr,
+		       (unsigned long long) e820_table->entries[i].addr,
 		       (unsigned long long)
-		       (e820_table->map[i].addr + e820_table->map[i].size - 1));
-		e820_print_type(e820_table->map[i].type);
+		       (e820_table->entries[i].addr + e820_table->entries[i].size - 1));
+		e820_print_type(e820_table->entries[i].type);
 		printk(KERN_CONT "\n");
 	}
 }
@@ -423,7 +422,7 @@ static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
 	return __append_e820_table(biosmap, nr_map);
 }
 
-static u64 __init __e820_update_range(struct e820_table *e820x, u64 start,
+static u64 __init __e820_update_range(struct e820_table *table, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
@@ -444,8 +443,8 @@ static u64 __init __e820_update_range(struct e820_table *e820x, u64 start,
 	e820_print_type(new_type);
 	printk(KERN_CONT "\n");
 
-	for (i = 0; i < e820x->nr_map; i++) {
-		struct e820_entry *ei = &e820x->map[i];
+	for (i = 0; i < table->nr_entries; i++) {
+		struct e820_entry *ei = &table->entries[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -462,8 +461,8 @@ static u64 __init __e820_update_range(struct e820_table *e820x, u64 start,
 
 		/* new range is totally covered? */
 		if (ei->addr < start && ei_end > end) {
-			__e820_add_region(e820x, start, size, new_type);
-			__e820_add_region(e820x, end, ei_end - end, ei->type);
+			__e820_add_region(table, start, size, new_type);
+			__e820_add_region(table, end, ei_end - end, ei->type);
 			ei->size = start - ei->addr;
 			real_updated_size += size;
 			continue;
@@ -475,7 +474,7 @@ static u64 __init __e820_update_range(struct e820_table *e820x, u64 start,
 		if (final_start >= final_end)
 			continue;
 
-		__e820_add_region(e820x, final_start, final_end - final_start,
+		__e820_add_region(table, final_start, final_end - final_start,
 				  new_type);
 
 		real_updated_size += final_end - final_start;
@@ -523,8 +522,8 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -568,15 +567,14 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	if (sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map))
+	if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries))
 		return;
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
 static void __init update_e820_table_saved(void)
 {
-	sanitize_e820_table(e820_table_saved->map, ARRAY_SIZE(e820_table_saved->map),
-				&e820_table_saved->nr_map);
+	sanitize_e820_table(e820_table_saved->entries, ARRAY_SIZE(e820_table_saved->entries), &e820_table_saved->nr_entries);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -586,12 +584,12 @@ static int __init e820_search_gap(unsigned long *gapstart,
 		unsigned long *gapsize)
 {
 	unsigned long long last = MAX_GAP_END;
-	int i = e820_table->nr_map;
+	int i = e820_table->nr_entries;
 	int found = 0;
 
 	while (--i >= 0) {
-		unsigned long long start = e820_table->map[i].addr;
-		unsigned long long end = start + e820_table->map[i].size;
+		unsigned long long start = e820_table->entries[i].addr;
+		unsigned long long end = start + e820_table->entries[i].size;
 
 		/*
 		 * Since "last" is at most 4GB, we know we'll
@@ -661,13 +659,13 @@ __init void e820_reallocate_tables(void)
 	struct e820_table *n;
 	int size;
 
-	size = offsetof(struct e820_table, map) + sizeof(struct e820_entry) * e820_table->nr_map;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820_table, size);
 	e820_table = n;
 
-	size = offsetof(struct e820_table, map) + sizeof(struct e820_entry) * e820_table_saved->nr_map;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry) * e820_table_saved->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820_table_saved, size);
@@ -690,7 +688,7 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	entries = sdata->len / sizeof(struct e820_entry);
 	extmap = (struct e820_entry *)(sdata->data);
 	__append_e820_table(extmap, entries);
-	sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map);
+	sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries), &e820_table->nr_entries);
 	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
@@ -709,8 +707,8 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	int i;
 	unsigned long pfn = 0;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 
 		if (pfn < PFN_UP(ei->addr))
 			register_nosave_region(pfn, PFN_UP(ei->addr));
@@ -734,8 +732,8 @@ static int __init e820_mark_nvs_memory(void)
 {
 	int i;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 
 		if (ei->type == E820_NVS)
 			acpi_nvs_register(ei->addr, ei->size);
@@ -782,8 +780,8 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	unsigned long last_pfn = 0;
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
@@ -874,7 +872,7 @@ static int __init parse_memmap_one(char *p)
 		 */
 		saved_max_pfn = e820_end_of_ram_pfn();
 #endif
-		e820_table->nr_map = 0;
+		e820_table->nr_entries = 0;
 		userdef = 1;
 		return 0;
 	}
@@ -921,8 +919,8 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		if (sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map),
-					&e820_table->nr_map) < 0)
+		if (sanitize_e820_table(e820_table->entries, ARRAY_SIZE(e820_table->entries),
+					&e820_table->nr_entries) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
@@ -1009,35 +1007,35 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(struct resource) * e820_table->nr_map);
+	res = alloc_bootmem(sizeof(struct resource) * e820_table->nr_entries);
 	e820_res = res;
-	for (i = 0; i < e820_table->nr_map; i++) {
-		end = e820_table->map[i].addr + e820_table->map[i].size - 1;
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		end = e820_table->entries[i].addr + e820_table->entries[i].size - 1;
 		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-		res->name = e820_type_to_string(e820_table->map[i].type);
-		res->start = e820_table->map[i].addr;
+		res->name = e820_type_to_string(e820_table->entries[i].type);
+		res->start = e820_table->entries[i].addr;
 		res->end = end;
 
-		res->flags = e820_type_to_iomem_type(e820_table->map[i].type);
-		res->desc = e820_type_to_iores_desc(e820_table->map[i].type);
+		res->flags = e820_type_to_iomem_type(e820_table->entries[i].type);
+		res->desc = e820_type_to_iores_desc(e820_table->entries[i].type);
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (do_mark_busy(e820_table->map[i].type, res)) {
+		if (do_mark_busy(e820_table->entries[i].type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
 		res++;
 	}
 
-	for (i = 0; i < e820_table_saved->nr_map; i++) {
-		struct e820_entry *entry = &e820_table_saved->map[i];
+	for (i = 0; i < e820_table_saved->nr_entries; i++) {
+		struct e820_entry *entry = &e820_table_saved->entries[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1069,7 +1067,7 @@ void __init e820_reserve_resources_late(void)
 	struct resource *res;
 
 	res = e820_res;
-	for (i = 0; i < e820_table->nr_map; i++) {
+	for (i = 0; i < e820_table->nr_entries; i++) {
 		if (!res->parent && res->end)
 			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
@@ -1079,8 +1077,8 @@ void __init e820_reserve_resources_late(void)
 	 * Try to bump up RAM regions to reasonable boundaries to
 	 * avoid stolen RAM:
 	 */
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *entry = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *entry = &e820_table->entries[i];
 		u64 start, end;
 
 		if (entry->type != E820_RAM)
@@ -1128,7 +1126,7 @@ char *__init default_machine_specific_memory_setup(void)
 			who = "BIOS-e801";
 		}
 
-		e820_table->nr_map = 0;
+		e820_table->nr_entries = 0;
 		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
@@ -1159,8 +1157,8 @@ void __init memblock_x86_fill(void)
 	 */
 	memblock_allow_resize();
 
-	for (i = 0; i < e820_table->nr_map; i++) {
-		struct e820_entry *ei = &e820_table->map[i];
+	for (i = 0; i < e820_table->nr_entries; i++) {
+		struct e820_entry *ei = &e820_table->entries[i];
 
 		end = ei->addr + ei->size;
 		if (end != (resource_size_t)end)

commit 61a50101638254d38e3f4281265b44de0f2cba4e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 13:54:38 2017 +0100

    x86/boot/e820: Rename everything to e820_table
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 49d47d6b1afe..ffaf94357d15 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -2,7 +2,7 @@
  * Handle the memory map.
  * The functions here do the job until bootmem takes over.
  *
- *  Getting sanitize_e820_array() in sync with i386 version by applying change:
+ *  Getting sanitize_e820_table() in sync with i386 version by applying change:
  *  -  Provisions for empty E820 memory regions (reported by certain BIOSes).
  *     Alex Achenbach <xela@slit.de>, December 2002.
  *  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
@@ -31,7 +31,7 @@
  * and that is also registered with modifications in the kernel resource tree
  * with the iomem_resource as parent.
  *
- * The e820_array_saved is directly saved after the BIOS-provided memory map is
+ * The e820_table_saved is directly saved after the BIOS-provided memory map is
  * copied. It doesn't get modified afterwards. It's registered for the
  * /sys/firmware/memmap interface.
  *
@@ -40,10 +40,10 @@
  * user can e.g. boot the original kernel with mem=1G while still booting the
  * next kernel with full memory.
  */
-static struct e820_array e820_array_init  __initdata;
-static struct e820_array initial_e820_array_saved  __initdata;
-struct e820_array *e820_array __refdata = &e820_array_init;
-struct e820_array *e820_array_saved __refdata = &initial_e820_array_saved;
+static struct e820_table e820_table_init  __initdata;
+static struct e820_table initial_e820_table_saved  __initdata;
+struct e820_table *e820_table __refdata = &e820_table_init;
+struct e820_table *e820_table_saved __refdata = &initial_e820_table_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -60,8 +60,8 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -83,8 +83,8 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -110,7 +110,7 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel e820 map.
  */
-static void __init __e820_add_region(struct e820_array *e820x, u64 start, u64 size,
+static void __init __e820_add_region(struct e820_table *e820x, u64 start, u64 size,
 					 int type)
 {
 	int x = e820x->nr_map;
@@ -130,7 +130,7 @@ static void __init __e820_add_region(struct e820_array *e820x, u64 start, u64 si
 
 void __init e820_add_region(u64 start, u64 size, int type)
 {
-	__e820_add_region(e820_array, start, size, type);
+	__e820_add_region(e820_table, start, size, type);
 }
 
 static void __init e820_print_type(u32 type)
@@ -166,12 +166,12 @@ void __init e820_print_map(char *who)
 {
 	int i;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
+	for (i = 0; i < e820_table->nr_map; i++) {
 		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
-		       (unsigned long long) e820_array->map[i].addr,
+		       (unsigned long long) e820_table->map[i].addr,
 		       (unsigned long long)
-		       (e820_array->map[i].addr + e820_array->map[i].size - 1));
-		e820_print_type(e820_array->map[i].type);
+		       (e820_table->map[i].addr + e820_table->map[i].size - 1));
+		e820_print_type(e820_table->map[i].type);
 		printk(KERN_CONT "\n");
 	}
 }
@@ -195,7 +195,7 @@ void __init e820_print_map(char *who)
  * sanitizing succeeds the *pnr_map will be updated with the new
  * number of valid entries (something no more than max_nr_map).
  *
- * The return value from sanitize_e820_array() is zero if it
+ * The return value from sanitize_e820_table() is zero if it
  * successfully 'sanitized' the map entries passed in, and is -1
  * if it did nothing, which can happen if either of (1) it was
  * only passed one map entry, or (2) any of the input map entries
@@ -259,7 +259,7 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init sanitize_e820_array(struct e820_entry *biosmap, int max_nr_map,
+int __init sanitize_e820_table(struct e820_entry *biosmap, int max_nr_map,
 			     u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
@@ -385,7 +385,7 @@ int __init sanitize_e820_array(struct e820_entry *biosmap, int max_nr_map,
 	return 0;
 }
 
-static int __init __append_e820_array(struct e820_entry *biosmap, int nr_map)
+static int __init __append_e820_table(struct e820_entry *biosmap, int nr_map)
 {
 	while (nr_map) {
 		u64 start = biosmap->addr;
@@ -414,16 +414,16 @@ static int __init __append_e820_array(struct e820_entry *biosmap, int nr_map)
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-static int __init append_e820_array(struct e820_entry *biosmap, int nr_map)
+static int __init append_e820_table(struct e820_entry *biosmap, int nr_map)
 {
 	/* Only one memory region (or negative)? Ignore it */
 	if (nr_map < 2)
 		return -1;
 
-	return __append_e820_array(biosmap, nr_map);
+	return __append_e820_table(biosmap, nr_map);
 }
 
-static u64 __init __e820_update_range(struct e820_array *e820x, u64 start,
+static u64 __init __e820_update_range(struct e820_table *e820x, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
@@ -495,13 +495,13 @@ static u64 __init __e820_update_range(struct e820_array *e820x, u64 start,
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 			     unsigned new_type)
 {
-	return __e820_update_range(e820_array, start, size, old_type, new_type);
+	return __e820_update_range(e820_table, start, size, old_type, new_type);
 }
 
 static u64 __init e820_update_range_saved(u64 start, u64 size,
 					  unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_array_saved, start, size, old_type,
+	return __e820_update_range(e820_table_saved, start, size, old_type,
 				     new_type);
 }
 
@@ -523,8 +523,8 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -568,15 +568,15 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	if (sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map))
+	if (sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map))
 		return;
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
-static void __init update_e820_array_saved(void)
+static void __init update_e820_table_saved(void)
 {
-	sanitize_e820_array(e820_array_saved->map, ARRAY_SIZE(e820_array_saved->map),
-				&e820_array_saved->nr_map);
+	sanitize_e820_table(e820_table_saved->map, ARRAY_SIZE(e820_table_saved->map),
+				&e820_table_saved->nr_map);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -586,12 +586,12 @@ static int __init e820_search_gap(unsigned long *gapstart,
 		unsigned long *gapsize)
 {
 	unsigned long long last = MAX_GAP_END;
-	int i = e820_array->nr_map;
+	int i = e820_table->nr_map;
 	int found = 0;
 
 	while (--i >= 0) {
-		unsigned long long start = e820_array->map[i].addr;
-		unsigned long long end = start + e820_array->map[i].size;
+		unsigned long long start = e820_table->map[i].addr;
+		unsigned long long end = start + e820_table->map[i].size;
 
 		/*
 		 * Since "last" is at most 4GB, we know we'll
@@ -650,7 +650,7 @@ __init void e820_setup_gap(void)
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820 and e820_array_saved are largish __initdata arrays.
+ * Initial e820 and e820_table_saved are largish __initdata arrays.
  * Copy them to (usually much smaller) dynamically allocated area.
  * This is done after all tweaks we ever do to them:
  * all functions which modify them are __init functions,
@@ -658,26 +658,26 @@ __init void e820_setup_gap(void)
  */
 __init void e820_reallocate_tables(void)
 {
-	struct e820_array *n;
+	struct e820_table *n;
 	int size;
 
-	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_array->nr_map;
+	size = offsetof(struct e820_table, map) + sizeof(struct e820_entry) * e820_table->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_array, size);
-	e820_array = n;
+	memcpy(n, e820_table, size);
+	e820_table = n;
 
-	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_array_saved->nr_map;
+	size = offsetof(struct e820_table, map) + sizeof(struct e820_entry) * e820_table_saved->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_array_saved, size);
-	e820_array_saved = n;
+	memcpy(n, e820_table_saved, size);
+	e820_table_saved = n;
 }
 
 /**
  * Because of the size limitation of struct boot_params, only first
  * 128 E820 memory entries are passed to kernel via
- * boot_params.e820_array, others are passed via SETUP_E820_EXT node of
+ * boot_params.e820_table, others are passed via SETUP_E820_EXT node of
  * linked list of struct setup_data, which is parsed here.
  */
 void __init parse_e820_ext(u64 phys_addr, u32 data_len)
@@ -689,8 +689,8 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	sdata = early_memremap(phys_addr, data_len);
 	entries = sdata->len / sizeof(struct e820_entry);
 	extmap = (struct e820_entry *)(sdata->data);
-	__append_e820_array(extmap, entries);
-	sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map);
+	__append_e820_table(extmap, entries);
+	sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map), &e820_table->nr_map);
 	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
@@ -709,8 +709,8 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	int i;
 	unsigned long pfn = 0;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 
 		if (pfn < PFN_UP(ei->addr))
 			register_nosave_region(pfn, PFN_UP(ei->addr));
@@ -734,8 +734,8 @@ static int __init e820_mark_nvs_memory(void)
 {
 	int i;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 
 		if (ei->type == E820_NVS)
 			acpi_nvs_register(ei->addr, ei->size);
@@ -747,7 +747,7 @@ core_initcall(e820_mark_nvs_memory);
 #endif
 
 /*
- * pre allocated 4k and reserved it in memblock and e820_array_saved
+ * pre allocated 4k and reserved it in memblock and e820_table_saved
  */
 u64 __init early_reserve_e820(u64 size, u64 align)
 {
@@ -756,8 +756,8 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
-		printk(KERN_INFO "e820: update e820_array_saved for early_reserve_e820\n");
-		update_e820_array_saved();
+		printk(KERN_INFO "e820: update e820_table_saved for early_reserve_e820\n");
+		update_e820_table_saved();
 	}
 
 	return addr;
@@ -782,8 +782,8 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	unsigned long last_pfn = 0;
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
@@ -874,7 +874,7 @@ static int __init parse_memmap_one(char *p)
 		 */
 		saved_max_pfn = e820_end_of_ram_pfn();
 #endif
-		e820_array->nr_map = 0;
+		e820_table->nr_map = 0;
 		userdef = 1;
 		return 0;
 	}
@@ -921,8 +921,8 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		if (sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map),
-					&e820_array->nr_map) < 0)
+		if (sanitize_e820_table(e820_table->map, ARRAY_SIZE(e820_table->map),
+					&e820_table->nr_map) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
@@ -1009,35 +1009,35 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(struct resource) * e820_array->nr_map);
+	res = alloc_bootmem(sizeof(struct resource) * e820_table->nr_map);
 	e820_res = res;
-	for (i = 0; i < e820_array->nr_map; i++) {
-		end = e820_array->map[i].addr + e820_array->map[i].size - 1;
+	for (i = 0; i < e820_table->nr_map; i++) {
+		end = e820_table->map[i].addr + e820_table->map[i].size - 1;
 		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-		res->name = e820_type_to_string(e820_array->map[i].type);
-		res->start = e820_array->map[i].addr;
+		res->name = e820_type_to_string(e820_table->map[i].type);
+		res->start = e820_table->map[i].addr;
 		res->end = end;
 
-		res->flags = e820_type_to_iomem_type(e820_array->map[i].type);
-		res->desc = e820_type_to_iores_desc(e820_array->map[i].type);
+		res->flags = e820_type_to_iomem_type(e820_table->map[i].type);
+		res->desc = e820_type_to_iores_desc(e820_table->map[i].type);
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (do_mark_busy(e820_array->map[i].type, res)) {
+		if (do_mark_busy(e820_table->map[i].type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
 		res++;
 	}
 
-	for (i = 0; i < e820_array_saved->nr_map; i++) {
-		struct e820_entry *entry = &e820_array_saved->map[i];
+	for (i = 0; i < e820_table_saved->nr_map; i++) {
+		struct e820_entry *entry = &e820_table_saved->map[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1069,7 +1069,7 @@ void __init e820_reserve_resources_late(void)
 	struct resource *res;
 
 	res = e820_res;
-	for (i = 0; i < e820_array->nr_map; i++) {
+	for (i = 0; i < e820_table->nr_map; i++) {
 		if (!res->parent && res->end)
 			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
@@ -1079,8 +1079,8 @@ void __init e820_reserve_resources_late(void)
 	 * Try to bump up RAM regions to reasonable boundaries to
 	 * avoid stolen RAM:
 	 */
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *entry = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *entry = &e820_table->map[i];
 		u64 start, end;
 
 		if (entry->type != E820_RAM)
@@ -1110,11 +1110,11 @@ char *__init default_machine_specific_memory_setup(void)
 	 * the next section from 1mb->appropriate_mem_k
 	 */
 	new_nr = boot_params.e820_entries;
-	sanitize_e820_array(boot_params.e820_array,
-			ARRAY_SIZE(boot_params.e820_array),
+	sanitize_e820_table(boot_params.e820_table,
+			ARRAY_SIZE(boot_params.e820_table),
 			&new_nr);
 	boot_params.e820_entries = new_nr;
-	if (append_e820_array(boot_params.e820_array, boot_params.e820_entries)
+	if (append_e820_table(boot_params.e820_table, boot_params.e820_entries)
 	  < 0) {
 		u64 mem_size;
 
@@ -1128,7 +1128,7 @@ char *__init default_machine_specific_memory_setup(void)
 			who = "BIOS-e801";
 		}
 
-		e820_array->nr_map = 0;
+		e820_table->nr_map = 0;
 		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
@@ -1142,7 +1142,7 @@ void __init setup_memory_map(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
-	memcpy(e820_array_saved, e820_array, sizeof(struct e820_array));
+	memcpy(e820_table_saved, e820_table, sizeof(struct e820_table));
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
@@ -1159,8 +1159,8 @@ void __init memblock_x86_fill(void)
 	 */
 	memblock_allow_resize();
 
-	for (i = 0; i < e820_array->nr_map; i++) {
-		struct e820_entry *ei = &e820_array->map[i];
+	for (i = 0; i < e820_table->nr_map; i++) {
+		struct e820_entry *ei = &e820_table->map[i];
 
 		end = ei->addr + ei->size;
 		if (end != (resource_size_t)end)

commit acd4c048728814505fae8e224cf9074bd1ad291e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 13:20:53 2017 +0100

    x86/boot/e820: Rename 'e820_map' variables to 'e820_array'
    
    In line with the rename to 'struct e820_array', harmonize the naming of common e820
    table variable names as well:
    
     e820          =>  e820_array
     e820_saved    =>  e820_array_saved
     e820_map      =>  e820_array
     initial_e820  =>  e820_array_init
    
    This makes the variable names more consistent  and easier to grep for.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 1f75b95185b8..49d47d6b1afe 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -2,7 +2,7 @@
  * Handle the memory map.
  * The functions here do the job until bootmem takes over.
  *
- *  Getting sanitize_e820_map() in sync with i386 version by applying change:
+ *  Getting sanitize_e820_array() in sync with i386 version by applying change:
  *  -  Provisions for empty E820 memory regions (reported by certain BIOSes).
  *     Alex Achenbach <xela@slit.de>, December 2002.
  *  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
@@ -27,11 +27,11 @@
 #include <asm/cpufeature.h>
 
 /*
- * The e820 map is the map that gets modified e.g. with command line parameters
+ * The e820 table is the array that gets modified e.g. with command line parameters
  * and that is also registered with modifications in the kernel resource tree
  * with the iomem_resource as parent.
  *
- * The e820_saved is directly saved after the BIOS-provided memory map is
+ * The e820_array_saved is directly saved after the BIOS-provided memory map is
  * copied. It doesn't get modified afterwards. It's registered for the
  * /sys/firmware/memmap interface.
  *
@@ -40,10 +40,10 @@
  * user can e.g. boot the original kernel with mem=1G while still booting the
  * next kernel with full memory.
  */
-static struct e820_array initial_e820  __initdata;
-static struct e820_array initial_e820_saved  __initdata;
-struct e820_array *e820 __refdata = &initial_e820;
-struct e820_array *e820_saved __refdata = &initial_e820_saved;
+static struct e820_array e820_array_init  __initdata;
+static struct e820_array initial_e820_array_saved  __initdata;
+struct e820_array *e820_array __refdata = &e820_array_init;
+struct e820_array *e820_array_saved __refdata = &initial_e820_array_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -60,8 +60,8 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -83,8 +83,8 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -130,7 +130,7 @@ static void __init __e820_add_region(struct e820_array *e820x, u64 start, u64 si
 
 void __init e820_add_region(u64 start, u64 size, int type)
 {
-	__e820_add_region(e820, start, size, type);
+	__e820_add_region(e820_array, start, size, type);
 }
 
 static void __init e820_print_type(u32 type)
@@ -166,12 +166,12 @@ void __init e820_print_map(char *who)
 {
 	int i;
 
-	for (i = 0; i < e820->nr_map; i++) {
+	for (i = 0; i < e820_array->nr_map; i++) {
 		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
-		       (unsigned long long) e820->map[i].addr,
+		       (unsigned long long) e820_array->map[i].addr,
 		       (unsigned long long)
-		       (e820->map[i].addr + e820->map[i].size - 1));
-		e820_print_type(e820->map[i].type);
+		       (e820_array->map[i].addr + e820_array->map[i].size - 1));
+		e820_print_type(e820_array->map[i].type);
 		printk(KERN_CONT "\n");
 	}
 }
@@ -195,7 +195,7 @@ void __init e820_print_map(char *who)
  * sanitizing succeeds the *pnr_map will be updated with the new
  * number of valid entries (something no more than max_nr_map).
  *
- * The return value from sanitize_e820_map() is zero if it
+ * The return value from sanitize_e820_array() is zero if it
  * successfully 'sanitized' the map entries passed in, and is -1
  * if it did nothing, which can happen if either of (1) it was
  * only passed one map entry, or (2) any of the input map entries
@@ -259,7 +259,7 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init sanitize_e820_map(struct e820_entry *biosmap, int max_nr_map,
+int __init sanitize_e820_array(struct e820_entry *biosmap, int max_nr_map,
 			     u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
@@ -385,7 +385,7 @@ int __init sanitize_e820_map(struct e820_entry *biosmap, int max_nr_map,
 	return 0;
 }
 
-static int __init __append_e820_map(struct e820_entry *biosmap, int nr_map)
+static int __init __append_e820_array(struct e820_entry *biosmap, int nr_map)
 {
 	while (nr_map) {
 		u64 start = biosmap->addr;
@@ -414,13 +414,13 @@ static int __init __append_e820_map(struct e820_entry *biosmap, int nr_map)
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-static int __init append_e820_map(struct e820_entry *biosmap, int nr_map)
+static int __init append_e820_array(struct e820_entry *biosmap, int nr_map)
 {
 	/* Only one memory region (or negative)? Ignore it */
 	if (nr_map < 2)
 		return -1;
 
-	return __append_e820_map(biosmap, nr_map);
+	return __append_e820_array(biosmap, nr_map);
 }
 
 static u64 __init __e820_update_range(struct e820_array *e820x, u64 start,
@@ -495,13 +495,13 @@ static u64 __init __e820_update_range(struct e820_array *e820x, u64 start,
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 			     unsigned new_type)
 {
-	return __e820_update_range(e820, start, size, old_type, new_type);
+	return __e820_update_range(e820_array, start, size, old_type, new_type);
 }
 
 static u64 __init e820_update_range_saved(u64 start, u64 size,
 					  unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(e820_saved, start, size, old_type,
+	return __e820_update_range(e820_array_saved, start, size, old_type,
 				     new_type);
 }
 
@@ -523,8 +523,8 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -568,15 +568,15 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	if (sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map))
+	if (sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map))
 		return;
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
-static void __init update_e820_saved(void)
+static void __init update_e820_array_saved(void)
 {
-	sanitize_e820_map(e820_saved->map, ARRAY_SIZE(e820_saved->map),
-				&e820_saved->nr_map);
+	sanitize_e820_array(e820_array_saved->map, ARRAY_SIZE(e820_array_saved->map),
+				&e820_array_saved->nr_map);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -586,12 +586,12 @@ static int __init e820_search_gap(unsigned long *gapstart,
 		unsigned long *gapsize)
 {
 	unsigned long long last = MAX_GAP_END;
-	int i = e820->nr_map;
+	int i = e820_array->nr_map;
 	int found = 0;
 
 	while (--i >= 0) {
-		unsigned long long start = e820->map[i].addr;
-		unsigned long long end = start + e820->map[i].size;
+		unsigned long long start = e820_array->map[i].addr;
+		unsigned long long end = start + e820_array->map[i].size;
 
 		/*
 		 * Since "last" is at most 4GB, we know we'll
@@ -650,7 +650,7 @@ __init void e820_setup_gap(void)
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820 and e820_saved are largish __initdata arrays.
+ * Initial e820 and e820_array_saved are largish __initdata arrays.
  * Copy them to (usually much smaller) dynamically allocated area.
  * This is done after all tweaks we ever do to them:
  * all functions which modify them are __init functions,
@@ -661,23 +661,23 @@ __init void e820_reallocate_tables(void)
 	struct e820_array *n;
 	int size;
 
-	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820->nr_map;
+	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_array->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820, size);
-	e820 = n;
+	memcpy(n, e820_array, size);
+	e820_array = n;
 
-	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_saved->nr_map;
+	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_array_saved->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_saved, size);
-	e820_saved = n;
+	memcpy(n, e820_array_saved, size);
+	e820_array_saved = n;
 }
 
 /**
  * Because of the size limitation of struct boot_params, only first
  * 128 E820 memory entries are passed to kernel via
- * boot_params.e820_map, others are passed via SETUP_E820_EXT node of
+ * boot_params.e820_array, others are passed via SETUP_E820_EXT node of
  * linked list of struct setup_data, which is parsed here.
  */
 void __init parse_e820_ext(u64 phys_addr, u32 data_len)
@@ -689,8 +689,8 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	sdata = early_memremap(phys_addr, data_len);
 	entries = sdata->len / sizeof(struct e820_entry);
 	extmap = (struct e820_entry *)(sdata->data);
-	__append_e820_map(extmap, entries);
-	sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map);
+	__append_e820_array(extmap, entries);
+	sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map), &e820_array->nr_map);
 	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
@@ -709,8 +709,8 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	int i;
 	unsigned long pfn = 0;
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 
 		if (pfn < PFN_UP(ei->addr))
 			register_nosave_region(pfn, PFN_UP(ei->addr));
@@ -734,8 +734,8 @@ static int __init e820_mark_nvs_memory(void)
 {
 	int i;
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 
 		if (ei->type == E820_NVS)
 			acpi_nvs_register(ei->addr, ei->size);
@@ -747,7 +747,7 @@ core_initcall(e820_mark_nvs_memory);
 #endif
 
 /*
- * pre allocated 4k and reserved it in memblock and e820_saved
+ * pre allocated 4k and reserved it in memblock and e820_array_saved
  */
 u64 __init early_reserve_e820(u64 size, u64 align)
 {
@@ -756,8 +756,8 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
-		printk(KERN_INFO "e820: update e820_saved for early_reserve_e820\n");
-		update_e820_saved();
+		printk(KERN_INFO "e820: update e820_array_saved for early_reserve_e820\n");
+		update_e820_array_saved();
 	}
 
 	return addr;
@@ -782,8 +782,8 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	unsigned long last_pfn = 0;
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
@@ -874,7 +874,7 @@ static int __init parse_memmap_one(char *p)
 		 */
 		saved_max_pfn = e820_end_of_ram_pfn();
 #endif
-		e820->nr_map = 0;
+		e820_array->nr_map = 0;
 		userdef = 1;
 		return 0;
 	}
@@ -921,8 +921,8 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		if (sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map),
-					&e820->nr_map) < 0)
+		if (sanitize_e820_array(e820_array->map, ARRAY_SIZE(e820_array->map),
+					&e820_array->nr_map) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
@@ -1009,35 +1009,35 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(struct resource) * e820->nr_map);
+	res = alloc_bootmem(sizeof(struct resource) * e820_array->nr_map);
 	e820_res = res;
-	for (i = 0; i < e820->nr_map; i++) {
-		end = e820->map[i].addr + e820->map[i].size - 1;
+	for (i = 0; i < e820_array->nr_map; i++) {
+		end = e820_array->map[i].addr + e820_array->map[i].size - 1;
 		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-		res->name = e820_type_to_string(e820->map[i].type);
-		res->start = e820->map[i].addr;
+		res->name = e820_type_to_string(e820_array->map[i].type);
+		res->start = e820_array->map[i].addr;
 		res->end = end;
 
-		res->flags = e820_type_to_iomem_type(e820->map[i].type);
-		res->desc = e820_type_to_iores_desc(e820->map[i].type);
+		res->flags = e820_type_to_iomem_type(e820_array->map[i].type);
+		res->desc = e820_type_to_iores_desc(e820_array->map[i].type);
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (do_mark_busy(e820->map[i].type, res)) {
+		if (do_mark_busy(e820_array->map[i].type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
 		res++;
 	}
 
-	for (i = 0; i < e820_saved->nr_map; i++) {
-		struct e820_entry *entry = &e820_saved->map[i];
+	for (i = 0; i < e820_array_saved->nr_map; i++) {
+		struct e820_entry *entry = &e820_array_saved->map[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1069,7 +1069,7 @@ void __init e820_reserve_resources_late(void)
 	struct resource *res;
 
 	res = e820_res;
-	for (i = 0; i < e820->nr_map; i++) {
+	for (i = 0; i < e820_array->nr_map; i++) {
 		if (!res->parent && res->end)
 			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
@@ -1079,8 +1079,8 @@ void __init e820_reserve_resources_late(void)
 	 * Try to bump up RAM regions to reasonable boundaries to
 	 * avoid stolen RAM:
 	 */
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *entry = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *entry = &e820_array->map[i];
 		u64 start, end;
 
 		if (entry->type != E820_RAM)
@@ -1110,11 +1110,11 @@ char *__init default_machine_specific_memory_setup(void)
 	 * the next section from 1mb->appropriate_mem_k
 	 */
 	new_nr = boot_params.e820_entries;
-	sanitize_e820_map(boot_params.e820_map,
-			ARRAY_SIZE(boot_params.e820_map),
+	sanitize_e820_array(boot_params.e820_array,
+			ARRAY_SIZE(boot_params.e820_array),
 			&new_nr);
 	boot_params.e820_entries = new_nr;
-	if (append_e820_map(boot_params.e820_map, boot_params.e820_entries)
+	if (append_e820_array(boot_params.e820_array, boot_params.e820_entries)
 	  < 0) {
 		u64 mem_size;
 
@@ -1128,7 +1128,7 @@ char *__init default_machine_specific_memory_setup(void)
 			who = "BIOS-e801";
 		}
 
-		e820->nr_map = 0;
+		e820_array->nr_map = 0;
 		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
@@ -1142,7 +1142,7 @@ void __init setup_memory_map(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
-	memcpy(e820_saved, e820, sizeof(struct e820_array));
+	memcpy(e820_array_saved, e820_array, sizeof(struct e820_array));
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
@@ -1159,8 +1159,8 @@ void __init memblock_x86_fill(void)
 	 */
 	memblock_allow_resize();
 
-	for (i = 0; i < e820->nr_map; i++) {
-		struct e820_entry *ei = &e820->map[i];
+	for (i = 0; i < e820_array->nr_map; i++) {
+		struct e820_entry *ei = &e820_array->map[i];
 
 		end = ei->addr + ei->size;
 		if (end != (resource_size_t)end)

commit e79d74d08547936a4c0ddf7711805dd2f8d82269
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 13:12:51 2017 +0100

    x86/boot/e820: Remove e820_mark_nosave_regions() definition uglies
    
    The e820_mark_nosave_regions definition has a number of ugly #ifdef
    conditions that unnecessarily uglify both the header and the
    e820.c file.
    
    Make this function unconditional: most distro kernels have hibernation
    enabled. If LTO functionality is added in the future it will be able
    to eliminate unused functions without uglifying the source code.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index eeb9c9963a6b..1f75b95185b8 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -696,8 +696,6 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	e820_print_map("extended");
 }
 
-#if defined(CONFIG_X86_64) || \
-	(defined(CONFIG_X86_32) && defined(CONFIG_HIBERNATION))
 /**
  * Find the ranges of physical addresses that do not correspond to
  * e820 RAM areas and mark the corresponding pages as nosave for
@@ -726,7 +724,6 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 			break;
 	}
 }
-#endif
 
 #ifdef CONFIG_ACPI
 /**

commit 8ec67d97bff592cc5b5325d1ee3646ebd7d635fc
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 12:54:38 2017 +0100

    x86/boot/e820: Rename the basic e820 data types to 'struct e820_entry' and 'struct e820_array'
    
    The 'e820entry' and 'e820map' names have various annoyances:
    
     - the missing underscore departs from the usual kernel style
       and makes the code look weird,
    
     - in the past I kept confusing the 'map' with the 'entry', because
       a 'map' is ambiguous in that regard,
    
     - it's not really clear from the 'e820map' that this is a regular
       C array.
    
    Rename them to 'struct e820_entry' and 'struct e820_array' accordingly.
    
    ( Leave the legacy UAPI header alone but do the rename in the bootparam.h
      and e820/types.h file - outside tools relying on these defines should
      either adjust their code, or should use the legacy header, or should
      create their private copies for the definitions. )
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 49d54c5002fa..eeb9c9963a6b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -40,10 +40,10 @@
  * user can e.g. boot the original kernel with mem=1G while still booting the
  * next kernel with full memory.
  */
-static struct e820map initial_e820  __initdata;
-static struct e820map initial_e820_saved  __initdata;
-struct e820map *e820 __refdata = &initial_e820;
-struct e820map *e820_saved __refdata = &initial_e820_saved;
+static struct e820_array initial_e820  __initdata;
+static struct e820_array initial_e820_saved  __initdata;
+struct e820_array *e820 __refdata = &initial_e820;
+struct e820_array *e820_saved __refdata = &initial_e820_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -61,7 +61,7 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 	int i;
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -84,7 +84,7 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 	int i;
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -110,7 +110,7 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel e820 map.
  */
-static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,
+static void __init __e820_add_region(struct e820_array *e820x, u64 start, u64 size,
 					 int type)
 {
 	int x = e820x->nr_map;
@@ -185,7 +185,7 @@ void __init e820_print_map(char *who)
  * numbered type.
  *
  * The input parameter biosmap points to an array of 'struct
- * e820entry' which on entry has elements in the range [0, *pnr_map)
+ * e820_entry' which on entry has elements in the range [0, *pnr_map)
  * valid, and which has space for up to max_nr_map entries.
  * On return, the resulting sanitized e820 map entries will be in
  * overwritten in the same location, starting at biosmap.
@@ -238,7 +238,7 @@ void __init e820_print_map(char *who)
  *	   ______________________4_
  */
 struct change_member {
-	struct e820entry *pbios; /* pointer to original bios entry */
+	struct e820_entry *pbios; /* pointer to original bios entry */
 	unsigned long long addr; /* address for this change point */
 };
 
@@ -259,13 +259,13 @@ static int __init cpcompare(const void *a, const void *b)
 	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
 }
 
-int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
+int __init sanitize_e820_map(struct e820_entry *biosmap, int max_nr_map,
 			     u32 *pnr_map)
 {
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
 	static struct change_member *change_point[2*E820_X_MAX] __initdata;
-	static struct e820entry *overlap_list[E820_X_MAX] __initdata;
-	static struct e820entry new_bios[E820_X_MAX] __initdata;
+	static struct e820_entry *overlap_list[E820_X_MAX] __initdata;
+	static struct e820_entry new_bios[E820_X_MAX] __initdata;
 	unsigned long current_type, last_type;
 	unsigned long long last_addr;
 	int chgidx;
@@ -379,13 +379,13 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	new_nr = new_bios_entry;
 
 	/* copy new bios mapping into original location */
-	memcpy(biosmap, new_bios, new_nr * sizeof(struct e820entry));
+	memcpy(biosmap, new_bios, new_nr * sizeof(struct e820_entry));
 	*pnr_map = new_nr;
 
 	return 0;
 }
 
-static int __init __append_e820_map(struct e820entry *biosmap, int nr_map)
+static int __init __append_e820_map(struct e820_entry *biosmap, int nr_map)
 {
 	while (nr_map) {
 		u64 start = biosmap->addr;
@@ -414,7 +414,7 @@ static int __init __append_e820_map(struct e820entry *biosmap, int nr_map)
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-static int __init append_e820_map(struct e820entry *biosmap, int nr_map)
+static int __init append_e820_map(struct e820_entry *biosmap, int nr_map)
 {
 	/* Only one memory region (or negative)? Ignore it */
 	if (nr_map < 2)
@@ -423,7 +423,7 @@ static int __init append_e820_map(struct e820entry *biosmap, int nr_map)
 	return __append_e820_map(biosmap, nr_map);
 }
 
-static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
+static u64 __init __e820_update_range(struct e820_array *e820x, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
@@ -445,7 +445,7 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 	printk(KERN_CONT "\n");
 
 	for (i = 0; i < e820x->nr_map; i++) {
-		struct e820entry *ei = &e820x->map[i];
+		struct e820_entry *ei = &e820x->map[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -524,7 +524,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 	printk(KERN_CONT "\n");
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -535,7 +535,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		/* totally covered? */
 		if (ei->addr >= start && ei_end <= end) {
 			real_removed_size += ei->size;
-			memset(ei, 0, sizeof(struct e820entry));
+			memset(ei, 0, sizeof(struct e820_entry));
 			continue;
 		}
 
@@ -658,16 +658,16 @@ __init void e820_setup_gap(void)
  */
 __init void e820_reallocate_tables(void)
 {
-	struct e820map *n;
+	struct e820_array *n;
 	int size;
 
-	size = offsetof(struct e820map, map) + sizeof(struct e820entry) * e820->nr_map;
+	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820, size);
 	e820 = n;
 
-	size = offsetof(struct e820map, map) + sizeof(struct e820entry) * e820_saved->nr_map;
+	size = offsetof(struct e820_array, map) + sizeof(struct e820_entry) * e820_saved->nr_map;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
 	memcpy(n, e820_saved, size);
@@ -683,12 +683,12 @@ __init void e820_reallocate_tables(void)
 void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 {
 	int entries;
-	struct e820entry *extmap;
+	struct e820_entry *extmap;
 	struct setup_data *sdata;
 
 	sdata = early_memremap(phys_addr, data_len);
-	entries = sdata->len / sizeof(struct e820entry);
-	extmap = (struct e820entry *)(sdata->data);
+	entries = sdata->len / sizeof(struct e820_entry);
+	extmap = (struct e820_entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map);
 	early_memunmap(sdata, data_len);
@@ -712,7 +712,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	unsigned long pfn = 0;
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 
 		if (pfn < PFN_UP(ei->addr))
 			register_nosave_region(pfn, PFN_UP(ei->addr));
@@ -738,7 +738,7 @@ static int __init e820_mark_nvs_memory(void)
 	int i;
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 
 		if (ei->type == E820_NVS)
 			acpi_nvs_register(ei->addr, ei->size);
@@ -786,7 +786,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
@@ -1040,7 +1040,7 @@ void __init e820_reserve_resources(void)
 	}
 
 	for (i = 0; i < e820_saved->nr_map; i++) {
-		struct e820entry *entry = &e820_saved->map[i];
+		struct e820_entry *entry = &e820_saved->map[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1083,7 +1083,7 @@ void __init e820_reserve_resources_late(void)
 	 * avoid stolen RAM:
 	 */
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *entry = &e820->map[i];
+		struct e820_entry *entry = &e820->map[i];
 		u64 start, end;
 
 		if (entry->type != E820_RAM)
@@ -1145,7 +1145,7 @@ void __init setup_memory_map(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
-	memcpy(e820_saved, e820, sizeof(struct e820map));
+	memcpy(e820_saved, e820, sizeof(struct e820_array));
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
@@ -1163,7 +1163,7 @@ void __init memblock_x86_fill(void)
 	memblock_allow_resize();
 
 	for (i = 0; i < e820->nr_map; i++) {
-		struct e820entry *ei = &e820->map[i];
+		struct e820_entry *ei = &e820->map[i];
 
 		end = ei->addr + ei->size;
 		if (end != (resource_size_t)end)

commit 66441bd3cfdcc03816b7009a296c284d70f629e1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 10:27:10 2017 +0100

    x86/boot/e820: Move asm/e820.h to asm/e820/api.h
    
    In line with asm/e820/types.h, move the e820 API declarations to
    asm/e820/api.h and update all usage sites.
    
    This is just a mechanical, obviously correct move & replace patch,
    there will be subsequent changes to clean up the code and to make
    better use of the new header organization.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b2bbad6ebe4d..49d54c5002fa 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -21,7 +21,7 @@
 #include <linux/memblock.h>
 #include <linux/sort.h>
 
-#include <asm/e820.h>
+#include <asm/e820/api.h>
 #include <asm/proto.h>
 #include <asm/setup.h>
 #include <asm/cpufeature.h>

commit c19a5f35e315837170ee337eed21c7087ea94192
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 11 15:49:04 2017 +0100

    x86/e820/32: Fix e820_search_gap() error handling on x86-32
    
    GCC correctly points out that on 32-bit kernels, e820_search_gap()
    not finding a start now leads to pci_mem_start ('gapstart') being set to an
    uninitialized value:
    
      arch/x86/kernel/e820.c: In function 'e820_setup_gap':
      arch/x86/kernel/e820.c:641:16: error: 'gapstart' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    This restores the behavior from before this cleanup:
    
      b4ed1d15b453 ("x86/e820: Make e820_search_gap() static and remove unused variables")
    
    ... defaulting to address 0x10000000 if nothing was found.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Fixes: b4ed1d15b453 ("x86/e820: Make e820_search_gap() static and remove unused variables")
    Link: http://lkml.kernel.org/r/20170111144926.695369-1-arnd@arndb.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 46f2afd3577a..b2bbad6ebe4d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -626,14 +626,16 @@ __init void e820_setup_gap(void)
 	gapsize = 0x400000;
 	found  = e820_search_gap(&gapstart, &gapsize);
 
-#ifdef CONFIG_X86_64
 	if (!found) {
+#ifdef CONFIG_X86_64
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
 		printk(KERN_ERR
 	"e820: cannot find a gap in the 32bit address range\n"
 	"e820: PCI devices with unassigned 32bit BARs may break!\n");
-	}
+#else
+		gapstart = 0x10000000;
 #endif
+	}
 
 	/*
 	 * e820_reserve_resources_late protect stolen RAM already

commit b4ed1d15b453c86b4b9362128bd7a0ecd95a105c
Author: Wei Yang <richard.weiyang@gmail.com>
Date:   Sun Dec 25 14:35:51 2016 +0000

    x86/e820: Make e820_search_gap() static and remove unused variables
    
    e820_search_gap() is just used locally now and the 'start_addr' and 'end_addr'
    parameters are fixed values. Also, 'gapstart' is not checked in this function
    anymore.
    
    So make the function static and remove those unused variables.
    
    Signed-off-by: Wei Yang <richard.weiyang@gmail.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: akataria@vmware.com
    Link: http://lkml.kernel.org/r/1482676551-11411-1-git-send-email-richard.weiyang@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 90e8dde3ec26..46f2afd3577a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -580,24 +580,19 @@ static void __init update_e820_saved(void)
 }
 #define MAX_GAP_END 0x100000000ull
 /*
- * Search for a gap in the e820 memory space from start_addr to end_addr.
+ * Search for a gap in the e820 memory space from 0 to MAX_GAP_END.
  */
-__init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
-		unsigned long start_addr, unsigned long long end_addr)
+static int __init e820_search_gap(unsigned long *gapstart,
+		unsigned long *gapsize)
 {
-	unsigned long long last;
+	unsigned long long last = MAX_GAP_END;
 	int i = e820->nr_map;
 	int found = 0;
 
-	last = (end_addr && end_addr < MAX_GAP_END) ? end_addr : MAX_GAP_END;
-
 	while (--i >= 0) {
 		unsigned long long start = e820->map[i].addr;
 		unsigned long long end = start + e820->map[i].size;
 
-		if (end < start_addr)
-			continue;
-
 		/*
 		 * Since "last" is at most 4GB, we know we'll
 		 * fit in 32 bits if this condition is true
@@ -628,9 +623,8 @@ __init void e820_setup_gap(void)
 	unsigned long gapstart, gapsize;
 	int found;
 
-	gapstart = 0x10000000;
 	gapsize = 0x400000;
-	found  = e820_search_gap(&gapstart, &gapsize, 0, MAX_GAP_END);
+	found  = e820_search_gap(&gapstart, &gapsize);
 
 #ifdef CONFIG_X86_64
 	if (!found) {

commit 23446cb66c073b827779e5eb3dec301623299b32
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Oct 12 11:01:48 2016 -0700

    x86/e820: Don't merge consecutive E820_PRAM ranges
    
    Commit:
    
      917db484dc6a ("x86/boot: Fix kdump, cleanup aborted E820_PRAM max_pfn manipulation")
    
    ... fixed up the broken manipulations of max_pfn in the presence of
    E820_PRAM ranges.
    
    However, it also broke the sanitize_e820_map() support for not merging
    E820_PRAM ranges.
    
    Re-introduce the enabling to keep resource boundaries between
    consecutive defined ranges. Otherwise, for example, an environment that
    boots with memmap=2G!8G,2G!10G will end up with a single 4G /dev/pmem0
    device instead of a /dev/pmem0 and /dev/pmem1 device 2G in size.
    
    Reported-by: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: <stable@vger.kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Zhang Yi <yizhan@redhat.com>
    Cc: linux-nvdimm@lists.01.org
    Fixes: 917db484dc6a ("x86/boot: Fix kdump, cleanup aborted E820_PRAM max_pfn manipulation")
    Link: http://lkml.kernel.org/r/147629530854.10618.10383744751594021268.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b85fe5f91c3f..90e8dde3ec26 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -350,7 +350,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 		 * continue building up new bios map based on this
 		 * information
 		 */
-		if (current_type != last_type) {
+		if (current_type != last_type || current_type == E820_PRAM) {
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]->addr - last_addr;

commit 917db484dc6a69969d317b3e57add4208a8d9d42
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Sep 21 12:50:45 2016 -0700

    x86/boot: Fix kdump, cleanup aborted E820_PRAM max_pfn manipulation
    
    In commit:
    
      ec776ef6bbe1 ("x86/mm: Add support for the non-standard protected e820 type")
    
    Christoph references the original patch I wrote implementing pmem support.
    The intent of the 'max_pfn' changes in that commit were to enable persistent
    memory ranges to be covered by the struct page memmap by default.
    
    However, that approach was abandoned when Christoph ported the patches [1], and
    that functionality has since been replaced by devm_memremap_pages().
    
    In the meantime, this max_pfn manipulation is confusing kdump [2] that
    assumes that everything covered by the max_pfn is "System RAM".  This
    results in kdump hanging or crashing.
    
     [1]: https://lists.01.org/pipermail/linux-nvdimm/2015-March/000348.html
     [2]: https://bugzilla.redhat.com/show_bug.cgi?id=1351098
    
    So fix it.
    
    Reported-by: Zhang Yi <yizhan@redhat.com>
    Reported-by: Jeff Moyer <jmoyer@redhat.com>
    Tested-by: Zhang Yi <yizhan@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.1 and later kernels
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-nvdimm@lists.01.org
    Fixes: ec776ef6bbe1 ("x86/mm: Add support for the non-standard protected e820 type")
    Link: http://lkml.kernel.org/r/147448744538.34910.11287693517367139607.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index bb8c69079c78..b85fe5f91c3f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -350,7 +350,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 		 * continue building up new bios map based on this
 		 * information
 		 */
-		if (current_type != last_type || current_type == E820_PRAM) {
+		if (current_type != last_type) {
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]->addr - last_addr;
@@ -783,7 +783,7 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 {
 	int i;
 	unsigned long last_pfn = 0;
@@ -794,11 +794,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
-		/*
-		 * Persistent memory is accounted as ram for purposes of
-		 * establishing max_pfn and mem_map.
-		 */
-		if (ei->type != E820_RAM && ei->type != E820_PRAM)
+		if (ei->type != type)
 			continue;
 
 		start_pfn = ei->addr >> PAGE_SHIFT;
@@ -823,12 +819,12 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
-	return e820_end_pfn(MAX_ARCH_PFN);
+	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
-	return e820_end_pfn(1UL << (32-PAGE_SHIFT));
+	return e820_end_pfn(1UL << (32 - PAGE_SHIFT), E820_RAM);
 }
 
 static void __init early_panic(char *msg)

commit 1827822902cf659d60d3413fd42c7e6cbd18df4d
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Sun Sep 18 20:21:25 2016 +0200

    x86/e820: Use much less memory for e820/e820_saved, save up to 120k
    
    The maximum size of e820 map array for EFI systems is defined as
    E820_X_MAX (E820MAX + 3 * MAX_NUMNODES).
    
    In x86_64 defconfig, this ends up with E820_X_MAX = 320, e820 and e820_saved
    are 6404 bytes each.
    
    With larger configs, for example Fedora kernels, E820_X_MAX = 3200, e820
    and e820_saved are 64004 bytes each. Most of this space is wasted.
    Typical machines have some 20-30 e820 areas at most.
    
    After previous patch, e820 and e820_saved are pointers to e280 maps.
    
    Change them to initially point to maps which are __initdata.
    
    At the very end of kernel init, just before __init[data] sections are freed
    in free_initmem(), allocate smaller blocks, copy maps there,
    and change pointers.
    
    The late switch makes sure that all functions which can be used to change
    e820 maps are no longer accessible (they are all __init functions).
    
    Run-tested.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160918182125.21000-1-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 585000c98d3e..bb8c69079c78 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -40,10 +40,10 @@
  * user can e.g. boot the original kernel with mem=1G while still booting the
  * next kernel with full memory.
  */
-static struct e820map initial_e820;
-static struct e820map initial_e820_saved;
-struct e820map *e820 = &initial_e820;
-struct e820map *e820_saved = &initial_e820_saved;
+static struct e820map initial_e820  __initdata;
+static struct e820map initial_e820_saved  __initdata;
+struct e820map *e820 __refdata = &initial_e820;
+struct e820map *e820_saved __refdata = &initial_e820_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;

commit 475339684ef19e46f4702e2d185a869a5c454688
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Sat Sep 17 23:39:26 2016 +0200

    x86/e820: Prepare e280 code for switch to dynamic storage
    
    This patch turns e820 and e820_saved into pointers to e820 tables,
    of the same size as before.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160917213927.1787-2-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 4d3dd9a713c7..585000c98d3e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -40,8 +40,10 @@
  * user can e.g. boot the original kernel with mem=1G while still booting the
  * next kernel with full memory.
  */
-struct e820map e820;
-struct e820map e820_saved;
+static struct e820map initial_e820;
+static struct e820map initial_e820_saved;
+struct e820map *e820 = &initial_e820;
+struct e820map *e820_saved = &initial_e820_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -58,8 +60,8 @@ e820_any_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -81,8 +83,8 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 {
 	int i;
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 
 		if (type && ei->type != type)
 			continue;
@@ -128,7 +130,7 @@ static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,
 
 void __init e820_add_region(u64 start, u64 size, int type)
 {
-	__e820_add_region(&e820, start, size, type);
+	__e820_add_region(e820, start, size, type);
 }
 
 static void __init e820_print_type(u32 type)
@@ -164,12 +166,12 @@ void __init e820_print_map(char *who)
 {
 	int i;
 
-	for (i = 0; i < e820.nr_map; i++) {
+	for (i = 0; i < e820->nr_map; i++) {
 		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
-		       (unsigned long long) e820.map[i].addr,
+		       (unsigned long long) e820->map[i].addr,
 		       (unsigned long long)
-		       (e820.map[i].addr + e820.map[i].size - 1));
-		e820_print_type(e820.map[i].type);
+		       (e820->map[i].addr + e820->map[i].size - 1));
+		e820_print_type(e820->map[i].type);
 		printk(KERN_CONT "\n");
 	}
 }
@@ -493,13 +495,13 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 			     unsigned new_type)
 {
-	return __e820_update_range(&e820, start, size, old_type, new_type);
+	return __e820_update_range(e820, start, size, old_type, new_type);
 }
 
 static u64 __init e820_update_range_saved(u64 start, u64 size,
 					  unsigned old_type, unsigned new_type)
 {
-	return __e820_update_range(&e820_saved, start, size, old_type,
+	return __e820_update_range(e820_saved, start, size, old_type,
 				     new_type);
 }
 
@@ -521,8 +523,8 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 		u64 final_start, final_end;
 		u64 ei_end;
 
@@ -566,15 +568,15 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map))
+	if (sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map))
 		return;
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
 static void __init update_e820_saved(void)
 {
-	sanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map),
-				&e820_saved.nr_map);
+	sanitize_e820_map(e820_saved->map, ARRAY_SIZE(e820_saved->map),
+				&e820_saved->nr_map);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -584,14 +586,14 @@ __init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
 		unsigned long start_addr, unsigned long long end_addr)
 {
 	unsigned long long last;
-	int i = e820.nr_map;
+	int i = e820->nr_map;
 	int found = 0;
 
 	last = (end_addr && end_addr < MAX_GAP_END) ? end_addr : MAX_GAP_END;
 
 	while (--i >= 0) {
-		unsigned long long start = e820.map[i].addr;
-		unsigned long long end = start + e820.map[i].size;
+		unsigned long long start = e820->map[i].addr;
+		unsigned long long end = start + e820->map[i].size;
 
 		if (end < start_addr)
 			continue;
@@ -649,6 +651,33 @@ __init void e820_setup_gap(void)
 	       gapstart, gapstart + gapsize - 1);
 }
 
+/*
+ * Called late during init, in free_initmem().
+ *
+ * Initial e820 and e820_saved are largish __initdata arrays.
+ * Copy them to (usually much smaller) dynamically allocated area.
+ * This is done after all tweaks we ever do to them:
+ * all functions which modify them are __init functions,
+ * they won't exist after this point.
+ */
+__init void e820_reallocate_tables(void)
+{
+	struct e820map *n;
+	int size;
+
+	size = offsetof(struct e820map, map) + sizeof(struct e820entry) * e820->nr_map;
+	n = kmalloc(size, GFP_KERNEL);
+	BUG_ON(!n);
+	memcpy(n, e820, size);
+	e820 = n;
+
+	size = offsetof(struct e820map, map) + sizeof(struct e820entry) * e820_saved->nr_map;
+	n = kmalloc(size, GFP_KERNEL);
+	BUG_ON(!n);
+	memcpy(n, e820_saved, size);
+	e820_saved = n;
+}
+
 /**
  * Because of the size limitation of struct boot_params, only first
  * 128 E820 memory entries are passed to kernel via
@@ -665,7 +694,7 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	entries = sdata->len / sizeof(struct e820entry);
 	extmap = (struct e820entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
-	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
+	sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map), &e820->nr_map);
 	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
@@ -686,8 +715,8 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 	int i;
 	unsigned long pfn = 0;
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 
 		if (pfn < PFN_UP(ei->addr))
 			register_nosave_region(pfn, PFN_UP(ei->addr));
@@ -712,8 +741,8 @@ static int __init e820_mark_nvs_memory(void)
 {
 	int i;
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 
 		if (ei->type == E820_NVS)
 			acpi_nvs_register(ei->addr, ei->size);
@@ -760,8 +789,8 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
 	unsigned long last_pfn = 0;
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
@@ -856,7 +885,7 @@ static int __init parse_memmap_one(char *p)
 		 */
 		saved_max_pfn = e820_end_of_ram_pfn();
 #endif
-		e820.nr_map = 0;
+		e820->nr_map = 0;
 		userdef = 1;
 		return 0;
 	}
@@ -903,8 +932,8 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map),
-					&e820.nr_map) < 0)
+		if (sanitize_e820_map(e820->map, ARRAY_SIZE(e820->map),
+					&e820->nr_map) < 0)
 			early_panic("Invalid user supplied memory map");
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
@@ -991,35 +1020,35 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem(sizeof(struct resource) * e820.nr_map);
+	res = alloc_bootmem(sizeof(struct resource) * e820->nr_map);
 	e820_res = res;
-	for (i = 0; i < e820.nr_map; i++) {
-		end = e820.map[i].addr + e820.map[i].size - 1;
+	for (i = 0; i < e820->nr_map; i++) {
+		end = e820->map[i].addr + e820->map[i].size - 1;
 		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-		res->name = e820_type_to_string(e820.map[i].type);
-		res->start = e820.map[i].addr;
+		res->name = e820_type_to_string(e820->map[i].type);
+		res->start = e820->map[i].addr;
 		res->end = end;
 
-		res->flags = e820_type_to_iomem_type(e820.map[i].type);
-		res->desc = e820_type_to_iores_desc(e820.map[i].type);
+		res->flags = e820_type_to_iomem_type(e820->map[i].type);
+		res->desc = e820_type_to_iores_desc(e820->map[i].type);
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (do_mark_busy(e820.map[i].type, res)) {
+		if (do_mark_busy(e820->map[i].type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}
 		res++;
 	}
 
-	for (i = 0; i < e820_saved.nr_map; i++) {
-		struct e820entry *entry = &e820_saved.map[i];
+	for (i = 0; i < e820_saved->nr_map; i++) {
+		struct e820entry *entry = &e820_saved->map[i];
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
@@ -1051,7 +1080,7 @@ void __init e820_reserve_resources_late(void)
 	struct resource *res;
 
 	res = e820_res;
-	for (i = 0; i < e820.nr_map; i++) {
+	for (i = 0; i < e820->nr_map; i++) {
 		if (!res->parent && res->end)
 			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
@@ -1061,8 +1090,8 @@ void __init e820_reserve_resources_late(void)
 	 * Try to bump up RAM regions to reasonable boundaries to
 	 * avoid stolen RAM:
 	 */
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *entry = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *entry = &e820->map[i];
 		u64 start, end;
 
 		if (entry->type != E820_RAM)
@@ -1110,7 +1139,7 @@ char *__init default_machine_specific_memory_setup(void)
 			who = "BIOS-e801";
 		}
 
-		e820.nr_map = 0;
+		e820->nr_map = 0;
 		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
@@ -1124,7 +1153,7 @@ void __init setup_memory_map(void)
 	char *who;
 
 	who = x86_init.resources.memory_setup();
-	memcpy(&e820_saved, &e820, sizeof(struct e820map));
+	memcpy(e820_saved, e820, sizeof(struct e820map));
 	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
@@ -1141,8 +1170,8 @@ void __init memblock_x86_fill(void)
 	 */
 	memblock_allow_resize();
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+	for (i = 0; i < e820->nr_map; i++) {
+		struct e820entry *ei = &e820->map[i];
 
 		end = ei->addr + ei->size;
 		if (end != (resource_size_t)end)

commit 8c2103f224216a45c1a4d7aebbc13f3e007cde34
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Sat Sep 17 23:39:25 2016 +0200

    x86/e820: Mark some static functions __init
    
    They are all called only from other __init functions in e820.c
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160917213927.1787-1-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 871f1863457d..4d3dd9a713c7 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -802,7 +802,7 @@ unsigned long __init e820_end_of_low_ram_pfn(void)
 	return e820_end_pfn(1UL << (32-PAGE_SHIFT));
 }
 
-static void early_panic(char *msg)
+static void __init early_panic(char *msg)
 {
 	early_printk(msg);
 	panic(msg);
@@ -912,7 +912,7 @@ void __init finish_e820_parsing(void)
 	}
 }
 
-static const char *e820_type_to_string(int e820_type)
+static const char *__init e820_type_to_string(int e820_type)
 {
 	switch (e820_type) {
 	case E820_RESERVED_KERN:
@@ -926,7 +926,7 @@ static const char *e820_type_to_string(int e820_type)
 	}
 }
 
-static unsigned long e820_type_to_iomem_type(int e820_type)
+static unsigned long __init e820_type_to_iomem_type(int e820_type)
 {
 	switch (e820_type) {
 	case E820_RESERVED_KERN:
@@ -942,7 +942,7 @@ static unsigned long e820_type_to_iomem_type(int e820_type)
 	}
 }
 
-static unsigned long e820_type_to_iores_desc(int e820_type)
+static unsigned long __init e820_type_to_iores_desc(int e820_type)
 {
 	switch (e820_type) {
 	case E820_ACPI:
@@ -961,7 +961,7 @@ static unsigned long e820_type_to_iores_desc(int e820_type)
 	}
 }
 
-static bool do_mark_busy(u32 type, struct resource *res)
+static bool __init do_mark_busy(u32 type, struct resource *res)
 {
 	/* this is the legacy bios/dos rom-shadow + mmio region */
 	if (res->start < (1ULL<<20))
@@ -1027,7 +1027,7 @@ void __init e820_reserve_resources(void)
 }
 
 /* How much should we pad RAM ending depending on where it is? */
-static unsigned long ram_alignment(resource_size_t pos)
+static unsigned long __init ram_alignment(resource_size_t pos)
 {
 	unsigned long mb = pos >> 20;
 

commit 3ec979658e5cc0fab86a42af79a650299e4d7135
Author: Wei Yang <richard.weiyang@gmail.com>
Date:   Sat Aug 20 01:40:13 2016 +0000

    x86/e820: Fix very large 'size' handling boundary condition
    
    The (start, size) tuple represents a range [start, start + size - 1],
    which means "start" and "start + size - 1" should be compared to see
    whether the range overflows.
    
    For example, a range with (start, size):
    
            (0xffffffff fffffff0, 0x00000000 00000010)
    
    represents
    
            [0xffffffff fffffff0, 0xffffffff ffffffff]
    
    ... would be judged overflow in the original code, while actually it is not.
    
    This patch fixes this and makes sure it still works when size is zero.
    
    Signed-off-by: Wei Yang <richard.weiyang@gmail.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: yinghai@kernel.org
    Link: http://lkml.kernel.org/r/1471657213-31817-1-git-send-email-richard.weiyang@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 621b501f8935..871f1863457d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -388,11 +388,11 @@ static int __init __append_e820_map(struct e820entry *biosmap, int nr_map)
 	while (nr_map) {
 		u64 start = biosmap->addr;
 		u64 size = biosmap->size;
-		u64 end = start + size;
+		u64 end = start + size - 1;
 		u32 type = biosmap->type;
 
 		/* Overflow in 64 bits? Ignore the memory map. */
-		if (start > end)
+		if (start > end && likely(size))
 			return -1;
 
 		e820_add_region(start, size, type);

commit ba33ea811e1ff6726abb7f8f96df38c2d7b50304
Merge: e23604edac2a d05004944206
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 09:32:27 2016 -0700

    Merge branch 'x86-asm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 asm updates from Ingo Molnar:
     "This is another big update. Main changes are:
    
       - lots of x86 system call (and other traps/exceptions) entry code
         enhancements.  In particular the complex parts of the 64-bit entry
         code have been migrated to C code as well, and a number of dusty
         corners have been refreshed.  (Andy Lutomirski)
    
       - vDSO special mapping robustification and general cleanups (Andy
         Lutomirski)
    
       - cpufeature refactoring, cleanups and speedups (Borislav Petkov)
    
       - lots of other changes ..."
    
    * 'x86-asm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (64 commits)
      x86/cpufeature: Enable new AVX-512 features
      x86/entry/traps: Show unhandled signal for i386 in do_trap()
      x86/entry: Call enter_from_user_mode() with IRQs off
      x86/entry/32: Change INT80 to be an interrupt gate
      x86/entry: Improve system call entry comments
      x86/entry: Remove TIF_SINGLESTEP entry work
      x86/entry/32: Add and check a stack canary for the SYSENTER stack
      x86/entry/32: Simplify and fix up the SYSENTER stack #DB/NMI fixup
      x86/entry: Only allocate space for tss_struct::SYSENTER_stack if needed
      x86/entry: Vastly simplify SYSENTER TF (single-step) handling
      x86/entry/traps: Clear DR6 early in do_debug() and improve the comment
      x86/entry/traps: Clear TIF_BLOCKSTEP on all debug exceptions
      x86/entry/32: Restore FLAGS on SYSEXIT
      x86/entry/32: Filter NT and speed up AC filtering in SYSENTER
      x86/entry/compat: In SYSENTER, sink AC clearing below the existing FLAGS test
      selftests/x86: In syscall_nt, test NT|TF as well
      x86/asm-offsets: Remove PARAVIRT_enabled
      x86/entry/32: Introduce and use X86_BUG_ESPFIX instead of paravirt_enabled
      uprobes: __create_xol_area() must nullify xol_mapping.fault
      x86/cpufeature: Create a new synthetic cpu capability for machine check recovery
      ...

commit cd4d09ec6f6c12a2cc3db5b7d8876a325a53545b
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Jan 26 22:12:04 2016 +0100

    x86/cpufeature: Carve out X86_FEATURE_*
    
    Move them to a separate header and have the following
    dependency:
    
      x86/cpufeatures.h <- x86/processor.h <- x86/cpufeature.h
    
    This makes it easier to use the header in asm code and not
    include the whole cpufeature.h and add guards for asm.
    
    Suggested-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1453842730-28463-5-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 569c1e4f96fe..b3c2a697820a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -24,6 +24,7 @@
 #include <asm/e820.h>
 #include <asm/proto.h>
 #include <asm/setup.h>
+#include <asm/cpufeature.h>
 
 /*
  * The e820 map is the map that gets modified e.g. with command line parameters

commit f33b14a4b96b185634848046f54fb0d5028566a9
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:20 2016 +0100

    x86/e820: Set System RAM type and descriptor
    
    Change e820_reserve_resources() to set 'flags' and 'desc' from
    e820 types.
    
    Set E820_RESERVED_KERN and E820_RAM's (System RAM) io resource
    type to IORESOURCE_SYSTEM_RAM.
    
    Do the same for "Kernel data", "Kernel code", and "Kernel bss",
    which are child nodes of System RAM.
    
    I/O resource descriptor is set to 'desc' for entries that are
    (and will be) target ranges of walk_iomem_res() and
    region_intersects().
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: WANG Chao <chaowang@redhat.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-mm <linux-mm@kvack.org>
    Link: http://lkml.kernel.org/r/1453841853-11383-5-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 569c1e4f96fe..837365f10912 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -925,6 +925,41 @@ static const char *e820_type_to_string(int e820_type)
 	}
 }
 
+static unsigned long e820_type_to_iomem_type(int e820_type)
+{
+	switch (e820_type) {
+	case E820_RESERVED_KERN:
+	case E820_RAM:
+		return IORESOURCE_SYSTEM_RAM;
+	case E820_ACPI:
+	case E820_NVS:
+	case E820_UNUSABLE:
+	case E820_PRAM:
+	case E820_PMEM:
+	default:
+		return IORESOURCE_MEM;
+	}
+}
+
+static unsigned long e820_type_to_iores_desc(int e820_type)
+{
+	switch (e820_type) {
+	case E820_ACPI:
+		return IORES_DESC_ACPI_TABLES;
+	case E820_NVS:
+		return IORES_DESC_ACPI_NV_STORAGE;
+	case E820_PMEM:
+		return IORES_DESC_PERSISTENT_MEMORY;
+	case E820_PRAM:
+		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;
+	case E820_RESERVED_KERN:
+	case E820_RAM:
+	case E820_UNUSABLE:
+	default:
+		return IORES_DESC_NONE;
+	}
+}
+
 static bool do_mark_busy(u32 type, struct resource *res)
 {
 	/* this is the legacy bios/dos rom-shadow + mmio region */
@@ -967,7 +1002,8 @@ void __init e820_reserve_resources(void)
 		res->start = e820.map[i].addr;
 		res->end = end;
 
-		res->flags = IORESOURCE_MEM;
+		res->flags = e820_type_to_iomem_type(e820.map[i].type);
+		res->desc = e820_type_to_iores_desc(e820.map[i].type);
 
 		/*
 		 * don't register the region that could be conflicted with

commit e6e5f84092b1f3a8733c20e26838af4e21a4854f
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Mon Sep 28 14:23:55 2015 +0200

    x86/e820: Deinline e820_type_to_string, save 126 bytes
    
    This function compiles to 102 bytes of machine code. It has two
    callsites.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Link: http://lkml.kernel.org/r/1443443037-22077-2-git-send-email-dvlasenk@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a102564d08eb..569c1e4f96fe 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -911,7 +911,7 @@ void __init finish_e820_parsing(void)
 	}
 }
 
-static inline const char *e820_type_to_string(int e820_type)
+static const char *e820_type_to_string(int e820_type)
 {
 	switch (e820_type) {
 	case E820_RESERVED_KERN:

commit 88793e5c774ec69351ef6b5200bb59f532e41bca
Merge: 1bc5e157ed2b 61031952f4c8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 29 10:34:42 2015 -0700

    Merge tag 'libnvdimm-for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/djbw/nvdimm
    
    Pull libnvdimm subsystem from Dan Williams:
     "The libnvdimm sub-system introduces, in addition to the
      libnvdimm-core, 4 drivers / enabling modules:
    
      NFIT:
        Instantiates an "nvdimm bus" with the core and registers memory
        devices (NVDIMMs) enumerated by the ACPI 6.0 NFIT (NVDIMM Firmware
        Interface table).
    
        After registering NVDIMMs the NFIT driver then registers "region"
        devices.  A libnvdimm-region defines an access mode and the
        boundaries of persistent memory media.  A region may span multiple
        NVDIMMs that are interleaved by the hardware memory controller.  In
        turn, a libnvdimm-region can be carved into a "namespace" device and
        bound to the PMEM or BLK driver which will attach a Linux block
        device (disk) interface to the memory.
    
      PMEM:
        Initially merged in v4.1 this driver for contiguous spans of
        persistent memory address ranges is re-worked to drive
        PMEM-namespaces emitted by the libnvdimm-core.
    
        In this update the PMEM driver, on x86, gains the ability to assert
        that writes to persistent memory have been flushed all the way
        through the caches and buffers in the platform to persistent media.
        See memcpy_to_pmem() and wmb_pmem().
    
      BLK:
        This new driver enables access to persistent memory media through
        "Block Data Windows" as defined by the NFIT.  The primary difference
        of this driver to PMEM is that only a small window of persistent
        memory is mapped into system address space at any given point in
        time.
    
        Per-NVDIMM windows are reprogrammed at run time, per-I/O, to access
        different portions of the media.  BLK-mode, by definition, does not
        support DAX.
    
      BTT:
        This is a library, optionally consumed by either PMEM or BLK, that
        converts a byte-accessible namespace into a disk with atomic sector
        update semantics (prevents sector tearing on crash or power loss).
    
        The sinister aspect of sector tearing is that most applications do
        not know they have a atomic sector dependency.  At least today's
        disk's rarely ever tear sectors and if they do one almost certainly
        gets a CRC error on access.  NVDIMMs will always tear and always
        silently.  Until an application is audited to be robust in the
        presence of sector-tearing the usage of BTT is recommended.
    
      Thanks to: Ross Zwisler, Jeff Moyer, Vishal Verma, Christoph Hellwig,
      Ingo Molnar, Neil Brown, Boaz Harrosh, Robert Elliott, Matthew Wilcox,
      Andy Rudoff, Linda Knippers, Toshi Kani, Nicholas Moulin, Rafael
      Wysocki, and Bob Moore"
    
    * tag 'libnvdimm-for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/djbw/nvdimm: (33 commits)
      arch, x86: pmem api for ensuring durability of persistent memory updates
      libnvdimm: Add sysfs numa_node to NVDIMM devices
      libnvdimm: Set numa_node to NVDIMM devices
      acpi: Add acpi_map_pxm_to_online_node()
      libnvdimm, nfit: handle unarmed dimms, mark namespaces read-only
      pmem: flag pmem block devices as non-rotational
      libnvdimm: enable iostat
      pmem: make_request cleanups
      libnvdimm, pmem: fix up max_hw_sectors
      libnvdimm, blk: add support for blk integrity
      libnvdimm, btt: add support for blk integrity
      fs/block_dev.c: skip rw_page if bdev has integrity
      libnvdimm: Non-Volatile Devices
      tools/testing/nvdimm: libnvdimm unit test infrastructure
      libnvdimm, nfit, nd_blk: driver for BLK-mode access persistent memory
      nd_btt: atomic sector updates
      libnvdimm: infrastructure for btt devices
      libnvdimm: write blk label set
      libnvdimm: write pmem label set
      libnvdimm: blk labels and namespace instantiation
      ...

commit fc6daaf93151877748f8096af6b3fddb147f22d6
Author: Tony Luck <tony.luck@intel.com>
Date:   Wed Jun 24 16:58:09 2015 -0700

    mm/memblock: add extra "flags" to memblock to allow selection of memory based on attribute
    
    Some high end Intel Xeon systems report uncorrectable memory errors as a
    recoverable machine check.  Linux has included code for some time to
    process these and just signal the affected processes (or even recover
    completely if the error was in a read only page that can be replaced by
    reading from disk).
    
    But we have no recovery path for errors encountered during kernel code
    execution.  Except for some very specific cases were are unlikely to ever
    be able to recover.
    
    Enter memory mirroring. Actually 3rd generation of memory mirroing.
    
    Gen1: All memory is mirrored
            Pro: No s/w enabling - h/w just gets good data from other side of the
                 mirror
            Con: Halves effective memory capacity available to OS/applications
    
    Gen2: Partial memory mirror - just mirror memory begind some memory controllers
            Pro: Keep more of the capacity
            Con: Nightmare to enable. Have to choose between allocating from
                 mirrored memory for safety vs. NUMA local memory for performance
    
    Gen3: Address range partial memory mirror - some mirror on each memory
          controller
            Pro: Can tune the amount of mirror and keep NUMA performance
            Con: I have to write memory management code to implement
    
    The current plan is just to use mirrored memory for kernel allocations.
    This has been broken into two phases:
    
    1) This patch series - find the mirrored memory, use it for boot time
       allocations
    
    2) Wade into mm/page_alloc.c and define a ZONE_MIRROR to pick up the
       unused mirrored memory from mm/memblock.c and only give it out to
       select kernel allocations (this is still being scoped because
       page_alloc.c is scary).
    
    This patch (of 3):
    
    Add extra "flags" to memblock to allow selection of memory based on
    attribute.  No functional changes
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Hanjun Guo <guohanjun@huawei.com>
    Cc: Xiexiuqi <xiexiuqi@huawei.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Naoya Horiguchi <nao.horiguchi@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e2ce85db2283..c8dda42cb6a3 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1123,7 +1123,8 @@ void __init memblock_find_dma_reserve(void)
 		nr_pages += end_pfn - start_pfn;
 	}
 
-	for_each_free_mem_range(u, NUMA_NO_NODE, &start, &end, NULL) {
+	for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,
+				NULL) {
 		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
 		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
 		if (start_pfn < end_pfn)

commit ad5fb870c486d932a1749d7853dd70f436a7e03f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 3 12:05:28 2015 -0400

    e820, efi: add ACPI 6.0 persistent memory types
    
    ACPI 6.0 formalizes e820-type-7 and efi-type-14 as persistent memory.
    Mark it "reserved" and allow it to be claimed by a persistent memory
    device driver.
    
    This definition is in addition to the Linux kernel's existing type-12
    definition that was recently added in support of shipping platforms with
    NVDIMM support that predate ACPI 6.0 (which now classifies type-12 as
    OEM reserved).
    
    Note, /proc/iomem can be consulted for differentiating legacy
    "Persistent Memory (legacy)" E820_PRAM vs standard "Persistent Memory"
    E820_PMEM.
    
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e2ce85db2283..c857d53269dd 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -149,6 +149,7 @@ static void __init e820_print_type(u32 type)
 	case E820_UNUSABLE:
 		printk(KERN_CONT "unusable");
 		break;
+	case E820_PMEM:
 	case E820_PRAM:
 		printk(KERN_CONT "persistent (type %u)", type);
 		break;
@@ -918,11 +919,32 @@ static inline const char *e820_type_to_string(int e820_type)
 	case E820_ACPI:	return "ACPI Tables";
 	case E820_NVS:	return "ACPI Non-volatile Storage";
 	case E820_UNUSABLE:	return "Unusable memory";
-	case E820_PRAM: return "Persistent RAM";
+	case E820_PRAM: return "Persistent Memory (legacy)";
+	case E820_PMEM: return "Persistent Memory";
 	default:	return "reserved";
 	}
 }
 
+static bool do_mark_busy(u32 type, struct resource *res)
+{
+	/* this is the legacy bios/dos rom-shadow + mmio region */
+	if (res->start < (1ULL<<20))
+		return true;
+
+	/*
+	 * Treat persistent memory like device memory, i.e. reserve it
+	 * for exclusive use of a driver
+	 */
+	switch (type) {
+	case E820_RESERVED:
+	case E820_PRAM:
+	case E820_PMEM:
+		return false;
+	default:
+		return true;
+	}
+}
+
 /*
  * Mark e820 reserved areas as busy for the resource manager.
  */
@@ -952,9 +974,7 @@ void __init e820_reserve_resources(void)
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (((e820.map[i].type != E820_RESERVED) &&
-		     (e820.map[i].type != E820_PRAM)) ||
-		     res->start < (1ULL<<20)) {
+		if (do_mark_busy(e820.map[i].type, res)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}

commit 34a984f7b0cc6355a1e0c184251d0d4cc86f44d2
Merge: 90d1c087861d 4c1eaa2344fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 18 11:42:49 2015 -0400

    Merge branch 'x86-pmem-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull PMEM driver from Ingo Molnar:
     "This is the initial support for the pmem block device driver:
      persistent non-volatile memory space mapped into the system's physical
      memory space as large physical memory regions.
    
      The driver is based on Intel code, written by Ross Zwisler, with fixes
      by Boaz Harrosh, integrated with x86 e820 memory resource management
      and tidied up by Christoph Hellwig.
    
      Note that there were two other separate pmem driver submissions to
      lkml: but apparently all parties (Ross Zwisler, Boaz Harrosh) are
      reasonably happy with this initial version.
    
      This version enables minimal support that enables persistent memory
      devices out in the wild to work as block devices, identified through a
      magic (non-standard) e820 flag and auto-discovered if
      CONFIG_X86_PMEM_LEGACY=y, or added explicitly through manipulating the
      memory maps via the "memmap=..." boot option with the new, special '!'
      modifier character.
    
      Limitations: this is a regular block device, and since the pmem areas
      are not struct page backed, they are invisible to the rest of the
      system (other than the block IO device), so direct IO to/from pmem
      areas, direct mmap() or XIP is not possible yet.  The page cache will
      also shadow and double buffer pmem contents, etc.
    
      Initial support is for x86"
    
    * 'x86-pmem-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      drivers/block/pmem: Fix 32-bit build warning in pmem_alloc()
      drivers/block/pmem: Add a driver for persistent memory
      x86/mm: Add support for the non-standard protected e820 type

commit ec776ef6bbe1734c29cd6bd05219cd93b2731bd4
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 1 09:12:18 2015 +0200

    x86/mm: Add support for the non-standard protected e820 type
    
    Various recent BIOSes support NVDIMMs or ADR using a
    non-standard e820 memory type, and Intel supplied reference
    Linux code using this type to various vendors.
    
    Wire this e820 table type up to export platform devices for the
    pmem driver so that we can use it in Linux.
    
    Based on earlier work from:
    
       Dave Jiang <dave.jiang@intel.com>
       Dan Williams <dan.j.williams@intel.com>
    
    Includes fixes for NUMA regions from Boaz Harrosh.
    
    Tested-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-nvdimm@ml01.01.org
    Link: http://lkml.kernel.org/r/1427872339-6688-2-git-send-email-hch@lst.de
    [ Minor cleanups. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 46201deee923..11cc7d54ec3f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -149,6 +149,9 @@ static void __init e820_print_type(u32 type)
 	case E820_UNUSABLE:
 		printk(KERN_CONT "unusable");
 		break;
+	case E820_PRAM:
+		printk(KERN_CONT "persistent (type %u)", type);
+		break;
 	default:
 		printk(KERN_CONT "type %u", type);
 		break;
@@ -343,7 +346,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 		 * continue building up new bios map based on this
 		 * information
 		 */
-		if (current_type != last_type)	{
+		if (current_type != last_type || current_type == E820_PRAM) {
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]->addr - last_addr;
@@ -688,6 +691,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 			register_nosave_region(pfn, PFN_UP(ei->addr));
 
 		pfn = PFN_DOWN(ei->addr + ei->size);
+
 		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
 			register_nosave_region(PFN_UP(ei->addr), pfn);
 
@@ -748,7 +752,7 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn)
 {
 	int i;
 	unsigned long last_pfn = 0;
@@ -759,7 +763,11 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
-		if (ei->type != type)
+		/*
+		 * Persistent memory is accounted as ram for purposes of
+		 * establishing max_pfn and mem_map.
+		 */
+		if (ei->type != E820_RAM && ei->type != E820_PRAM)
 			continue;
 
 		start_pfn = ei->addr >> PAGE_SHIFT;
@@ -784,12 +792,12 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
-	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
+	return e820_end_pfn(MAX_ARCH_PFN);
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
-	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
+	return e820_end_pfn(1UL << (32-PAGE_SHIFT));
 }
 
 static void early_panic(char *msg)
@@ -866,6 +874,9 @@ static int __init parse_memmap_one(char *p)
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
 		e820_add_region(start_at, mem_size, E820_RESERVED);
+	} else if (*p == '!') {
+		start_at = memparse(p+1, &p);
+		e820_add_region(start_at, mem_size, E820_PRAM);
 	} else
 		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
@@ -907,6 +918,7 @@ static inline const char *e820_type_to_string(int e820_type)
 	case E820_ACPI:	return "ACPI Tables";
 	case E820_NVS:	return "ACPI Non-volatile Storage";
 	case E820_UNUSABLE:	return "Unusable memory";
+	case E820_PRAM: return "Persistent RAM";
 	default:	return "reserved";
 	}
 }
@@ -940,7 +952,9 @@ void __init e820_reserve_resources(void)
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20)) {
+		if (((e820.map[i].type != E820_RESERVED) &&
+		     (e820.map[i].type != E820_PRAM)) ||
+		     res->start < (1ULL<<20)) {
 			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
 		}

commit 8d4a40bc0651ea51c196a3d3016d041c41ec19a2
Author: Juergen Gross <jgross@suse.com>
Date:   Tue Feb 24 10:13:28 2015 +0100

    x86/mm: Use early_memunmap() instead of early_iounmap()
    
    Memory mapped via early_memremap() should be unmapped with
    early_memunmap() instead of early_iounmap().
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Cc: matt.fleming@intel.com
    Link: http://lkml.kernel.org/r/1424769211-11378-2-git-send-email-jgross@suse.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 46201deee923..7d46bb260334 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -661,7 +661,7 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 	extmap = (struct e820entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
-	early_iounmap(sdata, data_len);
+	early_memunmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
 }

commit d574ffa1066003569ed5cdaeabf44597564ce975
Author: WANG Chao <chaowang@redhat.com>
Date:   Wed Jan 7 11:37:38 2015 +0800

    x86, e820: Clean up sanitize_e820_map() users
    
    The argument 3 of sanitize_e820_map() will only be updated upon a
    successful sanitization. Some of the callers have extra conditionals
    for the same purpose. Clean them up.
    
    default_machine_specific_memory_setup() must keep the extra
    conditional because boot_params.e820_entries is an u8 and not an u32,
    so the direct update would overwrite other fields in boot_params.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: WANG Chao <chaowang@redhat.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Lee Chun-Yi <joeyli.kernel@gmail.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Link: http://lkml.kernel.org/r/1420601859-18439-1-git-send-email-chaowang@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index dd2f07ae9d0c..46201deee923 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -184,9 +184,9 @@ void __init e820_print_map(char *who)
  * overwritten in the same location, starting at biosmap.
  *
  * The integer pointed to by pnr_map must be valid on entry (the
- * current number of valid entries located at biosmap) and will
- * be updated on return, with the new number of valid entries
- * (something no more than max_nr_map.)
+ * current number of valid entries located at biosmap). If the
+ * sanitizing succeeds the *pnr_map will be updated with the new
+ * number of valid entries (something no more than max_nr_map).
  *
  * The return value from sanitize_e820_map() is zero if it
  * successfully 'sanitized' the map entries passed in, and is -1
@@ -561,23 +561,15 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	u32 nr_map;
-
-	nr_map = e820.nr_map;
-	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr_map))
+	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map))
 		return;
-	e820.nr_map = nr_map;
 	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
 static void __init update_e820_saved(void)
 {
-	u32 nr_map;
-
-	nr_map = e820_saved.nr_map;
-	if (sanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map), &nr_map))
-		return;
-	e820_saved.nr_map = nr_map;
+	sanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map),
+				&e820_saved.nr_map);
 }
 #define MAX_GAP_END 0x100000000ull
 /*
@@ -898,11 +890,9 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		u32 nr = e820.nr_map;
-
-		if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr) < 0)
+		if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map),
+					&e820.nr_map) < 0)
 			early_panic("Invalid user supplied memory map");
-		e820.nr_map = nr;
 
 		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
 		e820_print_map("user");

commit 29258cf49eb794f00989fc47da8700759a42778b
Author: Xishi Qiu <qiuxishi@huawei.com>
Date:   Wed Dec 10 10:09:03 2014 +0800

    x86/mm: Use min() instead of min_t() in the e820 printout code
    
    The type of "MAX_DMA_PFN" and "xXx_pfn" are both unsigned long
    now, so use min() instead of min_t().
    
    Suggested-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Linux MM <linux-mm@kvack.org>
    Cc: <dave@sr71.net>
    Cc: Rik van Riel <riel@redhat.com>
    Link: http://lkml.kernel.org/r/5487AB3F.7050807@huawei.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 49f886481615..dd2f07ae9d0c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1114,8 +1114,8 @@ void __init memblock_find_dma_reserve(void)
 	 * at first, and assume boot_mem will not take below MAX_DMA_PFN
 	 */
 	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {
-		start_pfn = min_t(unsigned long, start_pfn, MAX_DMA_PFN);
-		end_pfn = min_t(unsigned long, end_pfn, MAX_DMA_PFN);
+		start_pfn = min(start_pfn, MAX_DMA_PFN);
+		end_pfn = min(end_pfn, MAX_DMA_PFN);
 		nr_pages += end_pfn - start_pfn;
 	}
 

commit 84779575554e2a19b9f6fc8d44f9763546a822ad
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Fri Sep 12 11:03:58 2014 +0800

    x86/mm, hibernate: Do not assume the first e820 area to be RAM
    
    In arch/x86/kernel/setup.c::trim_bios_range(), the codes
    introduced by 1b5576e6 (base on d8a9e6a5), it updates the first
    4Kb of memory to be E820_RESERVED region. That's because it's a
    BIOS owned area but generally not listed in the E820 table:
    
      e820: BIOS-provided physical RAM map:
      BIOS-e820: [mem 0x0000000000000000-0x0000000000096fff] usable
      BIOS-e820: [mem 0x0000000000097000-0x0000000000097fff] reserved
      ...
      e820: update [mem 0x00000000-0x00000fff] usable ==> reserved
      e820: remove [mem 0x000a0000-0x000fffff] usable
    
    But the region of first 4Kb didn't register to nosave memory:
    
      PM: Registered nosave memory: [mem 0x00097000-0x00097fff]
      PM: Registered nosave memory: [mem 0x000a0000-0x000fffff]
    
    The code in e820_mark_nosave_regions() assumes the first e820
    area to be RAM, so it causes the first 4Kb E820_RESERVED region
    ignored when register to nosave. This patch removed assumption
    of the first e820 area.
    
    Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Link: http://lkml.kernel.org/r/1410491038-17576-1-git-send-email-jlee@suse.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 988c00a1f60d..49f886481615 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -682,15 +682,14 @@ void __init parse_e820_ext(u64 phys_addr, u32 data_len)
  * hibernation (32 bit) or software suspend and suspend to RAM (64 bit).
  *
  * This function requires the e820 map to be sorted and without any
- * overlapping entries and assumes the first e820 area to be RAM.
+ * overlapping entries.
  */
 void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 {
 	int i;
-	unsigned long pfn;
+	unsigned long pfn = 0;
 
-	pfn = PFN_DOWN(e820.map[0].addr + e820.map[0].size);
-	for (i = 1; i < e820.nr_map; i++) {
+	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
 
 		if (pfn < PFN_UP(ei->addr))

commit 9a28f9dc8d10b619af9a37b1e27c41ada5415629
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Jan 21 15:50:53 2014 -0800

    x86/mm: memblock: switch to use NUMA_NO_NODE
    
    Update X86 code to use NUMA_NO_NODE instead of MAX_NUMNODES while
    calling memblock APIs, because memblock API will be changed to use
    NUMA_NO_NODE and will produce warning during boot otherwise.
    
    See:
     https://lkml.org/lkml/2013/12/9/898
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 174da5fc5a7b..988c00a1f60d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1120,7 +1120,7 @@ void __init memblock_find_dma_reserve(void)
 		nr_pages += end_pfn - start_pfn;
 	}
 
-	for_each_free_mem_range(u, MAX_NUMNODES, &start, &end, NULL) {
+	for_each_free_mem_range(u, NUMA_NO_NODE, &start, &end, NULL) {
 		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
 		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
 		if (start_pfn < end_pfn)

commit 30e46b574a1db7d14404e52dca8e1aa5f5155fd2
Author: Linn Crosetto <linn@hp.com>
Date:   Tue Aug 13 15:46:41 2013 -0600

    x86: avoid remapping data in parse_setup_data()
    
    Type SETUP_PCI, added by setup_efi_pci(), may advertise a ROM size
    larger than early_memremap() is able to handle, which is currently
    limited to 256kB. If this occurs it leads to a NULL dereference in
    parse_setup_data().
    
    To avoid this, remap the setup_data header and allow parsing functions
    for individual types to handle their own data remapping.
    
    Signed-off-by: Linn Crosetto <linn@hp.com>
    Link: http://lkml.kernel.org/r/1376430401-67445-1-git-send-email-linn@hp.com
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Reviewed-by: Pekka Enberg <penberg@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d32abeabbda5..174da5fc5a7b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -658,15 +658,18 @@ __init void e820_setup_gap(void)
  * boot_params.e820_map, others are passed via SETUP_E820_EXT node of
  * linked list of struct setup_data, which is parsed here.
  */
-void __init parse_e820_ext(struct setup_data *sdata)
+void __init parse_e820_ext(u64 phys_addr, u32 data_len)
 {
 	int entries;
 	struct e820entry *extmap;
+	struct setup_data *sdata;
 
+	sdata = early_memremap(phys_addr, data_len);
 	entries = sdata->len / sizeof(struct e820entry);
 	extmap = (struct e820entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
+	early_iounmap(sdata, data_len);
 	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
 }

commit 9710f581bb4c35589ac046b0cfc0deb7f369fc85
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Nov 16 19:39:23 2012 -0800

    x86, mm: Let "memmap=" take more entries one time
    
    Current "memmap=" only can take one entry every time.
    when we have more entries, we have to use memmap= for each of them.
    
    For pxe booting, we have command line length limitation, those extra
    "memmap=" would waste too much space.
    
    This patch make memmap= could take several entries one time,
    and those entries will be split with ','
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/1353123563-3103-47-git-send-email-yinghai@kernel.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index df06ade26bef..d32abeabbda5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -835,7 +835,7 @@ static int __init parse_memopt(char *p)
 }
 early_param("mem", parse_memopt);
 
-static int __init parse_memmap_opt(char *p)
+static int __init parse_memmap_one(char *p)
 {
 	char *oldp;
 	u64 start_at, mem_size;
@@ -877,6 +877,20 @@ static int __init parse_memmap_opt(char *p)
 
 	return *p == '\0' ? 0 : -EINVAL;
 }
+static int __init parse_memmap_opt(char *str)
+{
+	while (str) {
+		char *k = strchr(str, ',');
+
+		if (k)
+			*k++ = 0;
+
+		parse_memmap_one(str);
+		str = k;
+	}
+
+	return 0;
+}
 early_param("memmap", parse_memmap_opt);
 
 void __init finish_e820_parsing(void)

commit 6ede1fd3cb404c0016de6ac529df46d561bd558b
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Oct 22 16:35:18 2012 -0700

    x86, mm: Trim memory in memblock to be page aligned
    
    We will not map partial pages, so need to make sure memblock
    allocation will not allocate those bytes out.
    
    Also we will use for_each_mem_pfn_range() to loop to map memory
    range to keep them consistent.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/CAE9FiQVZirvaBMFYRfXMmWEcHbKSicQEHz4VAwUv0xFCk51ZNw@mail.gmail.com
    Acked-by: Jacob Shin <jacob.shin@amd.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: <stable@vger.kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ed858e9e9a74..df06ade26bef 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1077,6 +1077,9 @@ void __init memblock_x86_fill(void)
 		memblock_add(ei->addr, ei->size);
 	}
 
+	/* throw away partial pages */
+	memblock_trim_memory(PAGE_SIZE);
+
 	memblock_dump_all();
 }
 

commit 4ed940d4c34c21a1a356969a923f2815d608e0bf
Author: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
Date:   Mon Jul 30 14:41:13 2012 -0700

    firmware_map: make firmware_map_add_early() argument consistent with firmware_map_add_hotplug()
    
    There are two ways to create /sys/firmware/memmap/X sysfs:
    
      - firmware_map_add_early
        When the system starts, it is calledd from e820_reserve_resources()
      - firmware_map_add_hotplug
        When the memory is hot plugged, it is called from add_memory()
    
    But these functions are called without unifying value of end argument as
    below:
    
      - end argument of firmware_map_add_early()   : start + size - 1
      - end argument of firmware_map_add_hogplug() : start + size
    
    The patch unifies them to "start + size".  Even if applying the patch,
    /sys/firmware/memmap/X/end file content does not change.
    
    [akpm@linux-foundation.org: clarify comments]
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Dave Hansen <dave@linux.vnet.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 41857970517f..ed858e9e9a74 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -944,7 +944,7 @@ void __init e820_reserve_resources(void)
 	for (i = 0; i < e820_saved.nr_map; i++) {
 		struct e820entry *entry = &e820_saved.map[i];
 		firmware_map_add_early(entry->addr,
-			entry->addr + entry->size - 1,
+			entry->addr + entry->size,
 			e820_type_to_string(entry->type));
 	}
 }

commit 91eb0f67c38c7104766faa49c5aaee2b4876511e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 29 15:06:28 2012 -0700

    x86: print e820 physical addresses consistently with other parts of kernel
    
    Print physical address info in a style consistent with the %pR style used
    elsewhere in the kernel.  For example:
    
        -BIOS-provided physical RAM map:
        +e820: BIOS-provided physical RAM map:
        - BIOS-e820: 0000000000000100 - 000000000009e000 (usable)
        +BIOS-e820: [mem 0x0000000000000100-0x000000000009dfff] usable
        -Allocating PCI resources starting at 90000000 (gap: 90000000:6ed1c000)
        +e820: [mem 0x90000000-0xfed1bfff] available for PCI devices
        -reserve RAM buffer: 000000000009e000 - 000000000009ffff
        +e820: reserve RAM buffer [mem 0x0009e000-0x0009ffff]
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 62d61e9976eb..41857970517f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -113,7 +113,9 @@ static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,
 	int x = e820x->nr_map;
 
 	if (x >= ARRAY_SIZE(e820x->map)) {
-		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
+		printk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n",
+		       (unsigned long long) start,
+		       (unsigned long long) (start + size - 1));
 		return;
 	}
 
@@ -133,19 +135,19 @@ static void __init e820_print_type(u32 type)
 	switch (type) {
 	case E820_RAM:
 	case E820_RESERVED_KERN:
-		printk(KERN_CONT "(usable)");
+		printk(KERN_CONT "usable");
 		break;
 	case E820_RESERVED:
-		printk(KERN_CONT "(reserved)");
+		printk(KERN_CONT "reserved");
 		break;
 	case E820_ACPI:
-		printk(KERN_CONT "(ACPI data)");
+		printk(KERN_CONT "ACPI data");
 		break;
 	case E820_NVS:
-		printk(KERN_CONT "(ACPI NVS)");
+		printk(KERN_CONT "ACPI NVS");
 		break;
 	case E820_UNUSABLE:
-		printk(KERN_CONT "(unusable)");
+		printk(KERN_CONT "unusable");
 		break;
 	default:
 		printk(KERN_CONT "type %u", type);
@@ -158,10 +160,10 @@ void __init e820_print_map(char *who)
 	int i;
 
 	for (i = 0; i < e820.nr_map; i++) {
-		printk(KERN_INFO " %s: %016Lx - %016Lx ", who,
+		printk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,
 		       (unsigned long long) e820.map[i].addr,
 		       (unsigned long long)
-		       (e820.map[i].addr + e820.map[i].size));
+		       (e820.map[i].addr + e820.map[i].size - 1));
 		e820_print_type(e820.map[i].type);
 		printk(KERN_CONT "\n");
 	}
@@ -428,9 +430,8 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820 update range: %016Lx - %016Lx ",
-		       (unsigned long long) start,
-		       (unsigned long long) end);
+	printk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ",
+	       (unsigned long long) start, (unsigned long long) (end - 1));
 	e820_print_type(old_type);
 	printk(KERN_CONT " ==> ");
 	e820_print_type(new_type);
@@ -509,9 +510,8 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 		size = ULLONG_MAX - start;
 
 	end = start + size;
-	printk(KERN_DEBUG "e820 remove range: %016Lx - %016Lx ",
-		       (unsigned long long) start,
-		       (unsigned long long) end);
+	printk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ",
+	       (unsigned long long) start, (unsigned long long) (end - 1));
 	if (checktype)
 		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
@@ -567,7 +567,7 @@ void __init update_e820(void)
 	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr_map))
 		return;
 	e820.nr_map = nr_map;
-	printk(KERN_INFO "modified physical RAM map:\n");
+	printk(KERN_INFO "e820: modified physical RAM map:\n");
 	e820_print_map("modified");
 }
 static void __init update_e820_saved(void)
@@ -637,8 +637,8 @@ __init void e820_setup_gap(void)
 	if (!found) {
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
 		printk(KERN_ERR
-	"PCI: Warning: Cannot find a gap in the 32bit address range\n"
-	"PCI: Unassigned devices with 32bit resource registers may break!\n");
+	"e820: cannot find a gap in the 32bit address range\n"
+	"e820: PCI devices with unassigned 32bit BARs may break!\n");
 	}
 #endif
 
@@ -648,8 +648,8 @@ __init void e820_setup_gap(void)
 	pci_mem_start = gapstart;
 
 	printk(KERN_INFO
-	       "Allocating PCI resources starting at %lx (gap: %lx:%lx)\n",
-	       pci_mem_start, gapstart, gapsize);
+	       "e820: [mem %#010lx-%#010lx] available for PCI devices\n",
+	       gapstart, gapstart + gapsize - 1);
 }
 
 /**
@@ -667,7 +667,7 @@ void __init parse_e820_ext(struct setup_data *sdata)
 	extmap = (struct e820entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
-	printk(KERN_INFO "extended physical RAM map:\n");
+	printk(KERN_INFO "e820: extended physical RAM map:\n");
 	e820_print_map("extended");
 }
 
@@ -734,7 +734,7 @@ u64 __init early_reserve_e820(u64 size, u64 align)
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
-		printk(KERN_INFO "update e820_saved for early_reserve_e820\n");
+		printk(KERN_INFO "e820: update e820_saved for early_reserve_e820\n");
 		update_e820_saved();
 	}
 
@@ -784,7 +784,7 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 	if (last_pfn > max_arch_pfn)
 		last_pfn = max_arch_pfn;
 
-	printk(KERN_INFO "last_pfn = %#lx max_arch_pfn = %#lx\n",
+	printk(KERN_INFO "e820: last_pfn = %#lx max_arch_pfn = %#lx\n",
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }
@@ -888,7 +888,7 @@ void __init finish_e820_parsing(void)
 			early_panic("Invalid user supplied memory map");
 		e820.nr_map = nr;
 
-		printk(KERN_INFO "user-defined physical RAM map:\n");
+		printk(KERN_INFO "e820: user-defined physical RAM map:\n");
 		e820_print_map("user");
 	}
 }
@@ -996,8 +996,9 @@ void __init e820_reserve_resources_late(void)
 			end = MAX_RESOURCE_SIZE;
 		if (start >= end)
 			continue;
-		printk(KERN_DEBUG "reserve RAM buffer: %016llx - %016llx ",
-			       start, end);
+		printk(KERN_DEBUG
+		       "e820: reserve RAM buffer [mem %#010llx-%#010llx]\n",
+		       start, end);
 		reserve_region_with_split(&iomem_resource, start, end,
 					  "RAM buffer");
 	}
@@ -1047,7 +1048,7 @@ void __init setup_memory_map(void)
 
 	who = x86_init.resources.memory_setup();
 	memcpy(&e820_saved, &e820, sizeof(struct e820map));
-	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
+	printk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
 

commit 507a03c1cba0e32309223d23d19a1bfc0916c140
Merge: be405411f712 79ba0db69c58
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 18 15:51:48 2012 -0800

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
    
    This includes initial support for the recently published ACPI 5.0 spec.
    In particular, support for the "hardware-reduced" bit that eliminates
    the dependency on legacy hardware.
    
    APEI has patches resulting from testing on real hardware.
    
    Plus other random fixes.
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux: (52 commits)
      acpi/apei/einj: Add extensions to EINJ from rev 5.0 of acpi spec
      intel_idle: Split up and provide per CPU initialization func
      ACPI processor: Remove unneeded variable passed by acpi_processor_hotadd_init V2
      ACPI processor: Remove unneeded cpuidle_unregister_driver call
      intel idle: Make idle driver more robust
      intel_idle: Fix a cast to pointer from integer of different size warning in intel_idle
      ACPI: kernel-parameters.txt : Add intel_idle.max_cstate
      intel_idle: remove redundant local_irq_disable() call
      ACPI processor: Fix error path, also remove sysdev link
      ACPI: processor: fix acpi_get_cpuid for UP processor
      intel_idle: fix API misuse
      ACPI APEI: Convert atomicio routines
      ACPI: Export interfaces for ioremapping/iounmapping ACPI registers
      ACPI: Fix possible alignment issues with GAS 'address' references
      ACPI, ia64: Use SRAT table rev to use 8bit or 16/32bit PXM fields (ia64)
      ACPI, x86: Use SRAT table rev to use 8bit or 32bit PXM fields (x86/x86-64)
      ACPI: Store SRAT table revision
      ACPI, APEI, Resolve false conflict between ACPI NVS and APEI
      ACPI, Record ACPI NVS regions
      ACPI, APEI, EINJ, Refine the fix of resource conflict
      ...

commit b54ac6d2a25084667da781c7ca2cebef52a2bcdd
Author: Huang Ying <ying.huang@intel.com>
Date:   Thu Dec 8 11:25:49 2011 +0800

    ACPI, Record ACPI NVS regions
    
    Some firmware will access memory in ACPI NVS region via APEI.  That
    is, instructions in APEI ERST/EINJ table will read/write ACPI NVS
    region.  The original resource conflict checking in APEI code will
    check memory/ioport accessed by APEI via general resource management
    mechanism.  But ACPI NVS region is marked as busy already, so that the
    false resource conflict will prevent APEI ERST/EINJ to work.
    
    To fix this, this patch record ACPI NVS regions, so that we can avoid
    request resources for memory region inside it.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 303a0e48f076..51c3b186e5b9 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -714,7 +714,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 }
 #endif
 
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_ACPI
 /**
  * Mark ACPI NVS memory region, so that we can save/restore it during
  * hibernation and the subsequent resume.
@@ -727,7 +727,7 @@ static int __init e820_mark_nvs_memory(void)
 		struct e820entry *ei = &e820.map[i];
 
 		if (ei->type == E820_NVS)
-			suspend_nvs_register(ei->addr, ei->size);
+			acpi_nvs_register(ei->addr, ei->size);
 	}
 
 	return 0;

commit d0b9706c20ebb4ba181dc26e52ac9a6861abf425
Merge: 02d929502ce7 54eed6cb16ec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 11 19:12:10 2012 -0800

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/numa: Add constraints check for nid parameters
      mm, x86: Remove debug_pagealloc_enabled
      x86/mm: Initialize high mem before free_all_bootmem()
      arch/x86/kernel/e820.c: quiet sparse noise about plain integer as NULL pointer
      arch/x86/kernel/e820.c: Eliminate bubble sort from sanitize_e820_map()
      x86: Fix mmap random address range
      x86, mm: Unify zone_sizes_init()
      x86, mm: Prepare zone_sizes_init() for unification
      x86, mm: Use max_low_pfn for ZONE_NORMAL on 64-bit
      x86, mm: Wrap ZONE_DMA32 with CONFIG_ZONE_DMA32
      x86, mm: Use max_pfn instead of highend_pfn
      x86, mm: Move zone init from paging_init() on 64-bit
      x86, mm: Use MAX_DMA_PFN for ZONE_DMA on 32-bit

commit e1ad783b12ec8b69da83479c5d21a0d8180bc519
Author: Keith Packard <keithp@keithp.com>
Date:   Sun Dec 11 16:12:42 2011 -0800

    Revert "x86, efi: Calling __pa() with an ioremap()ed address is invalid"
    
    This hangs my MacBook Air at boot time; I get no console
    messages at all. I reverted this on top of -rc5 and my machine
    boots again.
    
    This reverts commit e8c7106280a305e1ff2a3a8a4dfce141469fb039.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Huang Ying <huang.ying.caritas@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1321621751-3650-1-git-send-email-matt@console
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 65ffd110a81b..303a0e48f076 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -135,7 +135,6 @@ static void __init e820_print_type(u32 type)
 		printk(KERN_CONT "(usable)");
 		break;
 	case E820_RESERVED:
-	case E820_RESERVED_EFI:
 		printk(KERN_CONT "(reserved)");
 		break;
 	case E820_ACPI:
@@ -784,7 +783,7 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 {
 	int i;
 	unsigned long last_pfn = 0;

commit e8c7106280a305e1ff2a3a8a4dfce141469fb039
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Nov 18 13:09:11 2011 +0000

    x86, efi: Calling __pa() with an ioremap()ed address is invalid
    
    If we encounter an efi_memory_desc_t without EFI_MEMORY_WB set
    in ->attribute we currently call set_memory_uc(), which in turn
    calls __pa() on a potentially ioremap'd address.
    
    On CONFIG_X86_32 this is invalid, resulting in the following
    oops on some machines:
    
      BUG: unable to handle kernel paging request at f7f22280
      IP: [<c10257b9>] reserve_ram_pages_type+0x89/0x210
      [...]
    
      Call Trace:
       [<c104f8ca>] ? page_is_ram+0x1a/0x40
       [<c1025aff>] reserve_memtype+0xdf/0x2f0
       [<c1024dc9>] set_memory_uc+0x49/0xa0
       [<c19334d0>] efi_enter_virtual_mode+0x1c2/0x3aa
       [<c19216d4>] start_kernel+0x291/0x2f2
       [<c19211c7>] ? loglevel+0x1b/0x1b
       [<c19210bf>] i386_start_kernel+0xbf/0xc8
    
    A better approach to this problem is to map the memory region
    with the correct attributes from the start, instead of modifying
    it after the fact. The uncached case can be handled by
    ioremap_nocache() and the cached by ioremap_cache().
    
    Despite first impressions, it's not possible to use
    ioremap_cache() to map all cached memory regions on
    CONFIG_X86_64 because EFI_RUNTIME_SERVICES_DATA regions really
    don't like being mapped into the vmalloc space, as detailed in
    the following bug report,
    
            https://bugzilla.redhat.com/show_bug.cgi?id=748516
    
    Therefore, we need to ensure that any EFI_RUNTIME_SERVICES_DATA
    regions are covered by the direct kernel mapping table on
    CONFIG_X86_64. To accomplish this we now map E820_RESERVED_EFI
    regions via the direct kernel mapping with the initial call to
    init_memory_mapping() in setup_arch(), whereas previously these
    regions wouldn't be mapped if they were after the last E820_RAM
    region until efi_ioremap() was called. Doing it this way allows
    us to delete efi_ioremap() completely.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Huang Ying <huang.ying.caritas@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1321621751-3650-1-git-send-email-matt@console-pimps.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 303a0e48f076..65ffd110a81b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -135,6 +135,7 @@ static void __init e820_print_type(u32 type)
 		printk(KERN_CONT "(usable)");
 		break;
 	case E820_RESERVED:
+	case E820_RESERVED_EFI:
 		printk(KERN_CONT "(reserved)");
 		break;
 	case E820_ACPI:
@@ -783,7 +784,7 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 /*
  * Find the highest page frame number we have available
  */
-static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
+unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 {
 	int i;
 	unsigned long last_pfn = 0;

commit 1aadc0560f46530f8a0f11055285b876a8a31770
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 8 10:22:08 2011 -0800

    memblock: s/memblock_analyze()/memblock_allow_resize()/ and update users
    
    The only function of memblock_analyze() is now allowing resize of
    memblock region arrays.  Rename it to memblock_allow_resize() and
    update its users.
    
    * The following users remain the same other than renaming.
    
      arm/mm/init.c::arm_memblock_init()
      microblaze/kernel/prom.c::early_init_devtree()
      powerpc/kernel/prom.c::early_init_devtree()
      openrisc/kernel/prom.c::early_init_devtree()
      sh/mm/init.c::paging_init()
      sparc/mm/init_64.c::paging_init()
      unicore32/mm/init.c::uc32_memblock_init()
    
    * In the following users, analyze was used to update total size which
      is no longer necessary.
    
      powerpc/kernel/machine_kexec.c::reserve_crashkernel()
      powerpc/kernel/prom.c::early_init_devtree()
      powerpc/mm/init_32.c::MMU_init()
      powerpc/mm/tlb_nohash.c::__early_init_mmu()
      powerpc/platforms/ps3/mm.c::ps3_mm_add_memory()
      powerpc/platforms/embedded6xx/wii.c::wii_memory_fixups()
      sh/kernel/machine_kexec.c::reserve_crashkernel()
    
    * x86/kernel/e820.c::memblock_x86_fill() was directly setting
      memblock_can_resize before populating memblock and calling analyze
      afterwards.  Call memblock_allow_resize() before start populating.
    
    memblock_can_resize is now static inside memblock.c.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: "H. Peter Anvin" <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 056e65d5012b..8071e2f3d6eb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1072,7 +1072,7 @@ void __init memblock_x86_fill(void)
 	 * We are safe to enable resizing, beause memblock_x86_fill()
 	 * is rather later for x86
 	 */
-	memblock_can_resize = 1;
+	memblock_allow_resize();
 
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
@@ -1087,7 +1087,6 @@ void __init memblock_x86_fill(void)
 		memblock_add(ei->addr, ei->size);
 	}
 
-	memblock_analyze();
 	memblock_dump_all();
 }
 

commit 706d9a9c8b5758390036b9980a2b12d809599777
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 15 14:48:56 2011 -0800

    arch/x86/kernel/e820.c: quiet sparse noise about plain integer as NULL pointer
    
    The last parameter to sort() is a pointer to the function used
    to swap items.  This parameter should be NULL, not 0, when not
    used.  This quiets the following sparse warning:
    
     warning: Using plain integer as NULL pointer
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: hartleys@visionengravers.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index f655f802260d..d6bd85352c81 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -296,7 +296,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	chg_nr = chgidx;
 
 	/* sort change-point list by memory addresses (low -> high) */
-	sort(change_point, chg_nr, sizeof *change_point, cpcompare, 0);
+	sort(change_point, chg_nr, sizeof *change_point, cpcompare, NULL);
 
 	/* create a new bios memory map, removing overlaps */
 	overlap_entries = 0;	 /* number of entries in the overlap table */

commit d1bbdd669298b7ca08284ddb29153dfc039dd89d
Author: Mike Ditto <mditto@google.com>
Date:   Tue Nov 15 14:46:50 2011 -0800

    arch/x86/kernel/e820.c: Eliminate bubble sort from sanitize_e820_map()
    
    Replace the bubble sort in sanitize_e820_map() with a call to
    the generic kernel sort function to avoid pathological
    performance with large maps.
    
    On large (thousands of entries) E820 maps, the previous code
    took minutes to run; with this change it's now milliseconds.
    
    Signed-off-by: Mike Ditto <mditto@google.com>
    Cc: sassmann@kpanic.de
    Cc: yuenn@google.com
    Cc: Stefan Assmann <sassmann@kpanic.de>
    Cc: Nancy Yuen <yuenn@google.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 303a0e48f076..f655f802260d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -19,6 +19,7 @@
 #include <linux/acpi.h>
 #include <linux/firmware-map.h>
 #include <linux/memblock.h>
+#include <linux/sort.h>
 
 #include <asm/e820.h>
 #include <asm/proto.h>
@@ -227,22 +228,38 @@ void __init e820_print_map(char *who)
  *	   ____________________33__
  *	   ______________________4_
  */
+struct change_member {
+	struct e820entry *pbios; /* pointer to original bios entry */
+	unsigned long long addr; /* address for this change point */
+};
+
+static int __init cpcompare(const void *a, const void *b)
+{
+	struct change_member * const *app = a, * const *bpp = b;
+	const struct change_member *ap = *app, *bp = *bpp;
+
+	/*
+	 * Inputs are pointers to two elements of change_point[].  If their
+	 * addresses are unequal, their difference dominates.  If the addresses
+	 * are equal, then consider one that represents the end of its region
+	 * to be greater than one that does not.
+	 */
+	if (ap->addr != bp->addr)
+		return ap->addr > bp->addr ? 1 : -1;
+
+	return (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);
+}
 
 int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 			     u32 *pnr_map)
 {
-	struct change_member {
-		struct e820entry *pbios; /* pointer to original bios entry */
-		unsigned long long addr; /* address for this change point */
-	};
 	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
 	static struct change_member *change_point[2*E820_X_MAX] __initdata;
 	static struct e820entry *overlap_list[E820_X_MAX] __initdata;
 	static struct e820entry new_bios[E820_X_MAX] __initdata;
-	struct change_member *change_tmp;
 	unsigned long current_type, last_type;
 	unsigned long long last_addr;
-	int chgidx, still_changing;
+	int chgidx;
 	int overlap_entries;
 	int new_bios_entry;
 	int old_nr, new_nr, chg_nr;
@@ -279,35 +296,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	chg_nr = chgidx;
 
 	/* sort change-point list by memory addresses (low -> high) */
-	still_changing = 1;
-	while (still_changing)	{
-		still_changing = 0;
-		for (i = 1; i < chg_nr; i++)  {
-			unsigned long long curaddr, lastaddr;
-			unsigned long long curpbaddr, lastpbaddr;
-
-			curaddr = change_point[i]->addr;
-			lastaddr = change_point[i - 1]->addr;
-			curpbaddr = change_point[i]->pbios->addr;
-			lastpbaddr = change_point[i - 1]->pbios->addr;
-
-			/*
-			 * swap entries, when:
-			 *
-			 * curaddr > lastaddr or
-			 * curaddr == lastaddr and curaddr == curpbaddr and
-			 * lastaddr != lastpbaddr
-			 */
-			if (curaddr < lastaddr ||
-			    (curaddr == lastaddr && curaddr == curpbaddr &&
-			     lastaddr != lastpbaddr)) {
-				change_tmp = change_point[i];
-				change_point[i] = change_point[i-1];
-				change_point[i-1] = change_tmp;
-				still_changing = 1;
-			}
-		}
-	}
+	sort(change_point, chg_nr, sizeof *change_point, cpcompare, 0);
 
 	/* create a new bios memory map, removing overlaps */
 	overlap_entries = 0;	 /* number of entries in the overlap table */

commit d4bbf7e7759afc172e2bfbc5c416324590049cdd
Merge: a150439c4a97 401d0069cb34
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 28 09:46:22 2011 -0800

    Merge branch 'master' into x86/memblock
    
    Conflicts & resolutions:
    
    * arch/x86/xen/setup.c
    
            dc91c728fd "xen: allow extra memory to be in multiple regions"
            24aa07882b "memblock, x86: Replace memblock_x86_reserve/free..."
    
            conflicted on xen_add_extra_mem() updates.  The resolution is
            trivial as the latter just want to replace
            memblock_x86_reserve_range() with memblock_reserve().
    
    * drivers/pci/intel-iommu.c
    
            166e9278a3f "x86/ia64: intel-iommu: move to drivers/iommu/"
            5dfe8660a3d "bootmem: Replace work_with_active_regions() with..."
    
            conflicted as the former moved the file under drivers/iommu/.
            Resolved by applying the chnages from the latter on the moved
            file.
    
    * mm/Kconfig
    
            6661672053a "memblock: add NO_BOOTMEM config symbol"
            c378ddd53f9 "memblock, x86: Make ARCH_DISCARD_MEMBLOCK a config option"
    
            conflicted trivially.  Both added config options.  Just
            letting both add their own options resolves the conflict.
    
    * mm/memblock.c
    
            d1f0ece6cdc "mm/memblock.c: small function definition fixes"
            ed7b56a799c "memblock: Remove memblock_memory_can_coalesce()"
    
            confliected.  The former updates function removed by the
            latter.  Resolution is trivial.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit 69c60c88eeb364ebf58432f9bc38033522d58767
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu May 26 12:22:53 2011 -0400

    x86: Fix files explicitly requiring export.h for EXPORT_SYMBOL/THIS_MODULE
    
    These files were implicitly getting EXPORT_SYMBOL via device.h
    which was including module.h, but that will be fixed up shortly.
    
    By fixing these now, we can avoid seeing things like:
    
    arch/x86/kernel/rtc.c:29: warning: type defaults to ‚Äòint‚Äô in declaration of ‚ÄòEXPORT_SYMBOL‚Äô
    arch/x86/kernel/pci-dma.c:20: warning: type defaults to ‚Äòint‚Äô in declaration of ‚ÄòEXPORT_SYMBOL‚Äô
    arch/x86/kernel/e820.c:69: warning: type defaults to ‚Äòint‚Äô in declaration of ‚ÄòEXPORT_SYMBOL_GPL‚Äô
    
    [ with input from Randy Dunlap <rdunlap@xenotime.net> and also
      from Stephen Rothwell <sfr@canb.auug.org.au> ]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3e2ef8425316..303a0e48f076 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/crash_dump.h>
+#include <linux/export.h>
 #include <linux/bootmem.h>
 #include <linux/pfn.h>
 #include <linux/suspend.h>

commit 6b5d41a1b97f5529284f16170211b87fd60264c0
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 12 11:16:03 2011 +0200

    memblock, x86: Reimplement memblock_find_dma_reserve() using iterators
    
    memblock_find_dma_reserve() wants to find out how much memory is
    reserved under MAX_DMA_PFN.  memblock_x86_memory_[free_]in_range() are
    used to find out the amounts of all available and free memory in the
    area, which are then subtracted to find out the amount of reservation.
    
    memblock_x86_memblock_[free_]in_range() are implemented using
    __memblock_x86_memory_in_range() which builds ranges from memblock and
    then count them, which is rather unnecessarily complex.
    
    This patch open codes the counting logic directly in
    memblock_find_dma_reserve() using memblock iterators and removes now
    unused __memblock_x86_memory_in_range() and find_range_array().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Link: http://lkml.kernel.org/r/1310462166-31469-11-git-send-email-tj@kernel.org
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b99d9402ae8b..84475f1e2201 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1093,15 +1093,30 @@ void __init memblock_x86_fill(void)
 void __init memblock_find_dma_reserve(void)
 {
 #ifdef CONFIG_X86_64
-	u64 free_size_pfn;
-	u64 mem_size_pfn;
+	u64 nr_pages = 0, nr_free_pages = 0;
+	unsigned long start_pfn, end_pfn;
+	phys_addr_t start, end;
+	int i;
+	u64 u;
+
 	/*
 	 * need to find out used area below MAX_DMA_PFN
 	 * need to use memblock to get free size in [0, MAX_DMA_PFN]
 	 * at first, and assume boot_mem will not take below MAX_DMA_PFN
 	 */
-	mem_size_pfn = memblock_x86_memory_in_range(0, MAX_DMA_PFN << PAGE_SHIFT) >> PAGE_SHIFT;
-	free_size_pfn = memblock_x86_free_memory_in_range(0, MAX_DMA_PFN << PAGE_SHIFT) >> PAGE_SHIFT;
-	set_dma_reserve(mem_size_pfn - free_size_pfn);
+	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {
+		start_pfn = min_t(unsigned long, start_pfn, MAX_DMA_PFN);
+		end_pfn = min_t(unsigned long, end_pfn, MAX_DMA_PFN);
+		nr_pages += end_pfn - start_pfn;
+	}
+
+	for_each_free_mem_range(u, MAX_NUMNODES, &start, &end, NULL) {
+		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
+		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
+		if (start_pfn < end_pfn)
+			nr_free_pages += end_pfn - start_pfn;
+	}
+
+	set_dma_reserve(nr_pages - nr_free_pages);
 #endif
 }

commit ab5d140b9eafae402aa3e673a63c5ef6164a9dd2
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 12 11:15:58 2011 +0200

    x86: Use __memblock_alloc_base() in early_reserve_e820()
    
    early_reserve_e820() implements its own ad-hoc early allocator using
    memblock_x86_find_in_range_size().  Use __memblock_alloc_base()
    instead and remove the unnecessary @startt parameter (it's top-down
    allocation anyway).
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Link: http://lkml.kernel.org/r/1310462166-31469-6-git-send-email-tj@kernel.org
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0f9ff58d06d7..b99d9402ae8b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -737,35 +737,17 @@ core_initcall(e820_mark_nvs_memory);
 /*
  * pre allocated 4k and reserved it in memblock and e820_saved
  */
-u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
+u64 __init early_reserve_e820(u64 size, u64 align)
 {
-	u64 size = 0;
 	u64 addr;
-	u64 start;
 
-	for (start = startt; ; start += size) {
-		start = memblock_x86_find_in_range_size(start, &size, align);
-		if (!start)
-			return 0;
-		if (size >= sizet)
-			break;
+	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
+	if (addr) {
+		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
+		printk(KERN_INFO "update e820_saved for early_reserve_e820\n");
+		update_e820_saved();
 	}
 
-#ifdef CONFIG_X86_32
-	if (start >= MAXMEM)
-		return 0;
-	if (start + size > MAXMEM)
-		size = MAXMEM - start;
-#endif
-
-	addr = round_down(start + size - sizet, align);
-	if (addr < start)
-		return 0;
-	memblock_x86_reserve_range(addr, addr + sizet, "new next");
-	e820_update_range_saved(addr, sizet, E820_RAM, E820_RESERVED);
-	printk(KERN_INFO "update e820_saved for early_reserve_e820\n");
-	update_e820_saved();
-
 	return addr;
 }
 

commit 1f5026a7e21e409c2b9dd54f6dfb9446511fb7c5
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 12 09:58:09 2011 +0200

    memblock: Kill MEMBLOCK_ERROR
    
    25818f0f28 (memblock: Make MEMBLOCK_ERROR be 0) thankfully made
    MEMBLOCK_ERROR 0 and there already are codes which expect error return
    to be 0.  There's no point in keeping MEMBLOCK_ERROR around.  End its
    misery.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Link: http://lkml.kernel.org/r/1310457490-3356-6-git-send-email-tj@kernel.org
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3e2ef8425316..0f9ff58d06d7 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -745,7 +745,7 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 
 	for (start = startt; ; start += size) {
 		start = memblock_x86_find_in_range_size(start, &size, align);
-		if (start == MEMBLOCK_ERROR)
+		if (!start)
 			return 0;
 		if (size >= sizet)
 			break;

commit 93a72052be81823fa1584b9be037d51924f9efa4
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Mar 23 16:43:29 2011 -0700

    crash_dump: export is_kdump_kernel to modules, consolidate elfcorehdr_addr, setup_elfcorehdr and saved_max_pfn
    
    The Xen PV drivers in a crashed HVM guest can not connect to the dom0
    backend drivers because both frontend and backend drivers are still in
    connected state.  To run the connection reset function only in case of a
    crashdump, the is_kdump_kernel() function needs to be available for the PV
    driver modules.
    
    Consolidate elfcorehdr_addr, setup_elfcorehdr and saved_max_pfn into
    kernel/crash_dump.c Also export elfcorehdr_addr to make is_kdump_kernel()
    usable for modules.
    
    Leave 'elfcorehdr' as early_param().  This changes powerpc from __setup()
    to early_param().  It adds an address range check from x86 also on ia64
    and powerpc.
    
    [akpm@linux-foundation.org: additional #includes]
    [akpm@linux-foundation.org: remove elfcorehdr_addr export]
    [akpm@linux-foundation.org: fix for Tejun's mm/nobootmem.c changes]
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index cdf5bfd9d4d5..3e2ef8425316 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>
+#include <linux/crash_dump.h>
 #include <linux/bootmem.h>
 #include <linux/pfn.h>
 #include <linux/suspend.h>

commit d10902812c9cd5583130a4ebb9ad19c60b68149d
Merge: 181f977d134a 25874a299ef8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 20:01:36 2011 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (27 commits)
      x86: Clean up apic.c and apic.h
      x86: Remove superflous goal definition of tsc_sync
      x86: dt: Correct local apic documentation in device tree bindings
      x86: dt: Cleanup local apic setup
      x86: dt: Fix OLPC=y/INTEL_CE=n build
      rtc: cmos: Add OF bindings
      x86: ce4100: Use OF to setup devices
      x86: ioapic: Add OF bindings for IO_APIC
      x86: dtb: Add generic bus probe
      x86: dtb: Add support for PCI devices backed by dtb nodes
      x86: dtb: Add device tree support for HPET
      x86: dtb: Add early parsing of IO_APIC
      x86: dtb: Add irq domain abstraction
      x86: dtb: Add a device tree for CE4100
      x86: Add device tree support
      x86: e820: Remove conditional early mapping in parse_e820_ext
      x86: OLPC: Make OLPC=n build again
      x86: OLPC: Remove extra OLPC_OPENFIRMWARE_DT indirection
      x86: OLPC: Cleanup config maze completely
      x86: OLPC: Hide OLPC_OPENFIRMWARE config switch
      ...
    
    Fix up conflicts in arch/x86/platform/ce4100/ce4100.c

commit f1c2b357148ec27fcc6ce0992211209a0ea20d8f
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Feb 22 21:07:36 2011 +0100

    x86: e820: Remove conditional early mapping in parse_e820_ext
    
    This patch ensures that the memory passed from parse_setup_data() is
    large enough to cover the complete data structure. That means that the
    conditional mapping in parse_e820_ext() can go.
    
    While here, I also attempt not to map two pages if the address is not
    aligned to a page boundary.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Cc: sodaville@linutronix.de
    Cc: devicetree-discuss@lists.ozlabs.org
    LKML-Reference: <1298405266-1624-2-git-send-email-bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 294f26da0c0c..5fad62684651 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -667,21 +667,15 @@ __init void e820_setup_gap(void)
  * boot_params.e820_map, others are passed via SETUP_E820_EXT node of
  * linked list of struct setup_data, which is parsed here.
  */
-void __init parse_e820_ext(struct setup_data *sdata, unsigned long pa_data)
+void __init parse_e820_ext(struct setup_data *sdata)
 {
-	u32 map_len;
 	int entries;
 	struct e820entry *extmap;
 
 	entries = sdata->len / sizeof(struct e820entry);
-	map_len = sdata->len + sizeof(struct setup_data);
-	if (map_len > PAGE_SIZE)
-		sdata = early_ioremap(pa_data, map_len);
 	extmap = (struct e820entry *)(sdata->data);
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
-	if (map_len > PAGE_SIZE)
-		early_iounmap(sdata, map_len);
 	printk(KERN_INFO "extended physical RAM map:\n");
 	e820_print_map("extended");
 }

commit 9a6d44b9adb777ca9549e88cd55bd8f2673c52a2
Author: Kamal Mostafa <kamal@canonical.com>
Date:   Thu Feb 3 17:38:05 2011 -0800

    x86: Emit "mem=nopentium ignored" warning when not supported
    
    Emit warning when "mem=nopentium" is specified on any arch other
    than x86_32 (the only that arch supports it).
    
    Signed-off-by: Kamal Mostafa <kamal@canonical.com>
    BugLink: http://bugs.launchpad.net/bugs/553464
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    LKML-Reference: <1296783486-23033-2-git-send-email-kamal@canonical.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: <stable@kernel.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 55a59d889dbd..0b5e2b546566 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -847,12 +847,15 @@ static int __init parse_memopt(char *p)
 	if (!p)
 		return -EINVAL;
 
-#ifdef CONFIG_X86_32
 	if (!strcmp(p, "nopentium")) {
+#ifdef CONFIG_X86_32
 		setup_clear_cpu_cap(X86_FEATURE_PSE);
 		return 0;
-	}
+#else
+		printk(KERN_WARNING "mem=nopentium ignored! (only supported on x86_32)\n");
+		return -EINVAL;
 #endif
+	}
 
 	userdef = 1;
 	mem_size = memparse(p, &p);

commit 77eed821accf5dd962b1f13bed0680e217e49112
Author: Kamal Mostafa <kamal@canonical.com>
Date:   Thu Feb 3 17:38:04 2011 -0800

    x86: Fix panic when handling "mem={invalid}" param
    
    Avoid removing all of memory and panicing when "mem={invalid}"
    is specified, e.g. mem=blahblah, mem=0, or mem=nopentium (on
    platforms other than x86_32).
    
    Signed-off-by: Kamal Mostafa <kamal@canonical.com>
    BugLink: http://bugs.launchpad.net/bugs/553464
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <stable@kernel.org> # .3x: as far back as it applies
    LKML-Reference: <1296783486-23033-1-git-send-email-kamal@canonical.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 294f26da0c0c..55a59d889dbd 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -856,6 +856,9 @@ static int __init parse_memopt(char *p)
 
 	userdef = 1;
 	mem_size = memparse(p, &p);
+	/* don't remove all of memory when handling "mem={invalid}" param */
+	if (mem_size == 0)
+		return -EINVAL;
 	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
 	return 0;

commit 976513dbfc1547c7b1822566923058655f0c32fd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 01:43:44 2011 +0100

    PM / ACPI: Move NVS saving and restoring code to drivers/acpi
    
    The saving of the ACPI NVS area during hibernation and suspend and
    restoring it during the subsequent resume is entirely specific to
    ACPI, so move it to drivers/acpi and drop the CONFIG_SUSPEND_NVS
    configuration option which is redundant.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0c2b7ef7a34d..294f26da0c0c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -14,6 +14,7 @@
 #include <linux/bootmem.h>
 #include <linux/pfn.h>
 #include <linux/suspend.h>
+#include <linux/acpi.h>
 #include <linux/firmware-map.h>
 #include <linux/memblock.h>
 

commit 6f2a75369e7561e800d86927ecd83c970996b21f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Aug 25 13:39:18 2010 -0700

    x86, memblock: Use memblock_memory_size()/memblock_free_memory_size() to get correct dma_reserve
    
    memblock_memory_size() will return memory size in memblock.memory.region.
    memblock_free_memory_size() will return free memory size in memblock.memory.region.
    
    So We can get exact reseved size in specified range.
    
    Set the size right after initmem_init(), because later bootmem API will
    get area above 16M. (except some fallback).
    
    Later after we remove the bootmem, We could call that just before paging_init().
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d5fd89462d79..0c2b7ef7a34d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1105,3 +1105,19 @@ void __init memblock_x86_fill(void)
 	memblock_analyze();
 	memblock_dump_all();
 }
+
+void __init memblock_find_dma_reserve(void)
+{
+#ifdef CONFIG_X86_64
+	u64 free_size_pfn;
+	u64 mem_size_pfn;
+	/*
+	 * need to find out used area below MAX_DMA_PFN
+	 * need to use memblock to get free size in [0, MAX_DMA_PFN]
+	 * at first, and assume boot_mem will not take below MAX_DMA_PFN
+	 */
+	mem_size_pfn = memblock_x86_memory_in_range(0, MAX_DMA_PFN << PAGE_SHIFT) >> PAGE_SHIFT;
+	free_size_pfn = memblock_x86_free_memory_in_range(0, MAX_DMA_PFN << PAGE_SHIFT) >> PAGE_SHIFT;
+	set_dma_reserve(mem_size_pfn - free_size_pfn);
+#endif
+}

commit a587d2daebcd2bc159d4348b6a7b028950a6d803
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Aug 25 13:39:18 2010 -0700

    x86: Remove not used early_res code
    
    and some functions in e820.c that are not used anymore
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a9221d18a5ed..d5fd89462d79 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -738,32 +738,6 @@ static int __init e820_mark_nvs_memory(void)
 core_initcall(e820_mark_nvs_memory);
 #endif
 
-/*
- * Find a free area with specified alignment in a specific range.
- */
-u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
-{
-	u64 mem = memblock_find_in_range(start, end, size, align);
-
-	if (mem == MEMBLOCK_ERROR)
-		return -1ULL;
-
-	return mem;
-}
-
-/*
- * Find next free range after *start
- */
-u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
-{
-	u64 mem = memblock_x86_find_in_range_size(start, sizep, align);
-
-	if (mem == MEMBLOCK_ERROR)
-		return -1ULL
-
-	return mem;
-}
-
 /*
  * pre allocated 4k and reserved it in memblock and e820_saved
  */
@@ -856,32 +830,6 @@ unsigned long __init e820_end_of_low_ram_pfn(void)
 	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
 }
 
-/* Walk the e820 map and register active regions within a node */
-void __init e820_register_active_regions(int nid, unsigned long start_pfn,
-					 unsigned long last_pfn)
-{
-	memblock_x86_register_active_regions(nid, start_pfn, last_pfn);
-}
-
-/*
- * Find the hole size (in bytes) in the memory range.
- * @start: starting address of the memory range to scan
- * @end: ending address of the memory range to scan
- */
-u64 __init e820_hole_size(u64 start, u64 end)
-{
-	return memblock_x86_hole_size(start, end);
-}
-
-void reserve_early(u64 start, u64 end, char *name)
-{
-	memblock_x86_reserve_range(start, end, name);
-}
-void free_early(u64 start, u64 end)
-{
-	memblock_x86_free_range(start, end);
-}
-
 static void early_panic(char *msg)
 {
 	early_printk(msg);

commit 72d7c3b33c980843e756681fb4867dc1efd62a76
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Aug 25 13:39:17 2010 -0700

    x86: Use memblock to replace early_res
    
    1. replace find_e820_area with memblock_find_in_range
    2. replace reserve_early with memblock_x86_reserve_range
    3. replace free_early with memblock_x86_free_range.
    4. NO_BOOTMEM will switch to use memblock too.
    5. use _e820, _early wrap in the patch, in following patch, will
       replace them all
    6. because memblock_x86_free_range support partial free, we can remove some special care
    7. Need to make sure that memblock_find_in_range() is called after memblock_x86_fill()
       so adjust some calling later in setup.c::setup_arch()
       -- corruption_check and mptable_update
    
    -v2: Move reserve_brk() early
        Before fill_memblock_area, to avoid overlap between brk and memblock_find_in_range()
        that could happen We have more then 128 RAM entry in E820 tables, and
        memblock_x86_fill() could use memblock_find_in_range() to find a new place for
        memblock.memory.region array.
        and We don't need to use extend_brk() after fill_memblock_area()
        So move reserve_brk() early before fill_memblock_area().
    -v3: Move find_smp_config early
        To make sure memblock_find_in_range not find wrong place, if BIOS doesn't put mptable
        in right place.
    -v4: Treat RESERVED_KERN as RAM in memblock.memory. and they are already in
        memblock.reserved already..
        use __NOT_KEEP_MEMBLOCK to make sure memblock related code could be freed later.
    -v5: Generic version __memblock_find_in_range() is going from high to low, and for 32bit
        active_region for 32bit does include high pages
        need to replace the limit with memblock.default_alloc_limit, aka get_max_mapped()
    -v6: Use current_limit instead
    -v7: check with MEMBLOCK_ERROR instead of -1ULL or -1L
    -v8: Set memblock_can_resize early to handle EFI with more RAM entries
    -v9: update after kmemleak changes in mainline
    
    Suggested-by: David S. Miller <davem@davemloft.net>
    Suggested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0d6fc71bedb1..a9221d18a5ed 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -15,6 +15,7 @@
 #include <linux/pfn.h>
 #include <linux/suspend.h>
 #include <linux/firmware-map.h>
+#include <linux/memblock.h>
 
 #include <asm/e820.h>
 #include <asm/proto.h>
@@ -742,69 +743,29 @@ core_initcall(e820_mark_nvs_memory);
  */
 u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
 {
-	int i;
-
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-		u64 addr;
-		u64 ei_start, ei_last;
+	u64 mem = memblock_find_in_range(start, end, size, align);
 
-		if (ei->type != E820_RAM)
-			continue;
-
-		ei_last = ei->addr + ei->size;
-		ei_start = ei->addr;
-		addr = find_early_area(ei_start, ei_last, start, end,
-					 size, align);
-
-		if (addr != -1ULL)
-			return addr;
-	}
-	return -1ULL;
-}
+	if (mem == MEMBLOCK_ERROR)
+		return -1ULL;
 
-u64 __init find_fw_memmap_area(u64 start, u64 end, u64 size, u64 align)
-{
-	return find_e820_area(start, end, size, align);
+	return mem;
 }
 
-u64 __init get_max_mapped(void)
-{
-	u64 end = max_pfn_mapped;
-
-	end <<= PAGE_SHIFT;
-
-	return end;
-}
 /*
  * Find next free range after *start
  */
 u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
 {
-	int i;
+	u64 mem = memblock_x86_find_in_range_size(start, sizep, align);
 
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-		u64 addr;
-		u64 ei_start, ei_last;
-
-		if (ei->type != E820_RAM)
-			continue;
-
-		ei_last = ei->addr + ei->size;
-		ei_start = ei->addr;
-		addr = find_early_area_size(ei_start, ei_last, start,
-					 sizep, align);
+	if (mem == MEMBLOCK_ERROR)
+		return -1ULL
 
-		if (addr != -1ULL)
-			return addr;
-	}
-
-	return -1ULL;
+	return mem;
 }
 
 /*
- * pre allocated 4k and reserved it in e820
+ * pre allocated 4k and reserved it in memblock and e820_saved
  */
 u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 {
@@ -813,8 +774,8 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 	u64 start;
 
 	for (start = startt; ; start += size) {
-		start = find_e820_area_size(start, &size, align);
-		if (!(start + 1))
+		start = memblock_x86_find_in_range_size(start, &size, align);
+		if (start == MEMBLOCK_ERROR)
 			return 0;
 		if (size >= sizet)
 			break;
@@ -830,10 +791,9 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 	addr = round_down(start + size - sizet, align);
 	if (addr < start)
 		return 0;
-	e820_update_range(addr, sizet, E820_RAM, E820_RESERVED);
+	memblock_x86_reserve_range(addr, addr + sizet, "new next");
 	e820_update_range_saved(addr, sizet, E820_RAM, E820_RESERVED);
-	printk(KERN_INFO "update e820 for early_reserve_e820\n");
-	update_e820();
+	printk(KERN_INFO "update e820_saved for early_reserve_e820\n");
 	update_e820_saved();
 
 	return addr;
@@ -895,52 +855,12 @@ unsigned long __init e820_end_of_low_ram_pfn(void)
 {
 	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
 }
-/*
- * Finds an active region in the address range from start_pfn to last_pfn and
- * returns its range in ei_startpfn and ei_endpfn for the e820 entry.
- */
-int __init e820_find_active_region(const struct e820entry *ei,
-				  unsigned long start_pfn,
-				  unsigned long last_pfn,
-				  unsigned long *ei_startpfn,
-				  unsigned long *ei_endpfn)
-{
-	u64 align = PAGE_SIZE;
-
-	*ei_startpfn = round_up(ei->addr, align) >> PAGE_SHIFT;
-	*ei_endpfn = round_down(ei->addr + ei->size, align) >> PAGE_SHIFT;
-
-	/* Skip map entries smaller than a page */
-	if (*ei_startpfn >= *ei_endpfn)
-		return 0;
-
-	/* Skip if map is outside the node */
-	if (ei->type != E820_RAM || *ei_endpfn <= start_pfn ||
-				    *ei_startpfn >= last_pfn)
-		return 0;
-
-	/* Check for overlaps */
-	if (*ei_startpfn < start_pfn)
-		*ei_startpfn = start_pfn;
-	if (*ei_endpfn > last_pfn)
-		*ei_endpfn = last_pfn;
-
-	return 1;
-}
 
 /* Walk the e820 map and register active regions within a node */
 void __init e820_register_active_regions(int nid, unsigned long start_pfn,
 					 unsigned long last_pfn)
 {
-	unsigned long ei_startpfn;
-	unsigned long ei_endpfn;
-	int i;
-
-	for (i = 0; i < e820.nr_map; i++)
-		if (e820_find_active_region(&e820.map[i],
-					    start_pfn, last_pfn,
-					    &ei_startpfn, &ei_endpfn))
-			add_active_range(nid, ei_startpfn, ei_endpfn);
+	memblock_x86_register_active_regions(nid, start_pfn, last_pfn);
 }
 
 /*
@@ -950,18 +870,16 @@ void __init e820_register_active_regions(int nid, unsigned long start_pfn,
  */
 u64 __init e820_hole_size(u64 start, u64 end)
 {
-	unsigned long start_pfn = start >> PAGE_SHIFT;
-	unsigned long last_pfn = end >> PAGE_SHIFT;
-	unsigned long ei_startpfn, ei_endpfn, ram = 0;
-	int i;
+	return memblock_x86_hole_size(start, end);
+}
 
-	for (i = 0; i < e820.nr_map; i++) {
-		if (e820_find_active_region(&e820.map[i],
-					    start_pfn, last_pfn,
-					    &ei_startpfn, &ei_endpfn))
-			ram += ei_endpfn - ei_startpfn;
-	}
-	return end - start - ((u64)ram << PAGE_SHIFT);
+void reserve_early(u64 start, u64 end, char *name)
+{
+	memblock_x86_reserve_range(start, end, name);
+}
+void free_early(u64 start, u64 end)
+{
+	memblock_x86_free_range(start, end);
 }
 
 static void early_panic(char *msg)
@@ -1210,3 +1128,32 @@ void __init setup_memory_map(void)
 	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
+
+void __init memblock_x86_fill(void)
+{
+	int i;
+	u64 end;
+
+	/*
+	 * EFI may have more than 128 entries
+	 * We are safe to enable resizing, beause memblock_x86_fill()
+	 * is rather later for x86
+	 */
+	memblock_can_resize = 1;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		end = ei->addr + ei->size;
+		if (end != (resource_size_t)end)
+			continue;
+
+		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
+			continue;
+
+		memblock_add(ei->addr, ei->size);
+	}
+
+	memblock_analyze();
+	memblock_dump_all();
+}

commit dd4c4f17d722ffeb2515bf781400675a30fcead7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 28 16:32:14 2010 -0400

    suspend: Move NVS save/restore code to generic suspend functionality
    
    Saving platform non-volatile state may be required for suspend to RAM as
    well as hibernation. Move it to more generic code.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7bca3c6a02fb..0d6fc71bedb1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -729,7 +729,7 @@ static int __init e820_mark_nvs_memory(void)
 		struct e820entry *ei = &e820.map[i];
 
 		if (ei->type == E820_NVS)
-			hibernate_nvs_register(ei->addr, ei->size);
+			suspend_nvs_register(ei->addr, ei->size);
 	}
 
 	return 0;

commit 9f3a5f52aa63d3aa4c64a7245153549bb66bad8c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Mar 29 22:38:29 2010 -0700

    x86: Make e820_remove_range to handle all covered case
    
    Rusty found on lguest with trim_bios_range, max_pfn is not right anymore, and
    looks e820_remove_range does not work right.
    
    [    0.000000] BIOS-provided physical RAM map:
    [    0.000000]  LGUEST: 0000000000000000 - 0000000004000000 (usable)
    [    0.000000] Notice: NX (Execute Disable) protection missing in CPU or disabled in BIOS!
    [    0.000000] DMI not present or invalid.
    [    0.000000] last_pfn = 0x3fa0 max_arch_pfn = 0x100000
    [    0.000000] init_memory_mapping: 0000000000000000-0000000003fa0000
    
    root cause is: the e820_remove_range doesn't handle the all covered
    case.  e820_remove_range(BIOS_START, BIOS_END - BIOS_START, ...)
    produces a bogus range as a result.
    
    Make it match e820_update_range() by handling that case too.
    
    Reported-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Tested-by: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <4BB18E55.6090903@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 740b440fbd73..7bca3c6a02fb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -519,29 +519,45 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 	printk(KERN_DEBUG "e820 remove range: %016Lx - %016Lx ",
 		       (unsigned long long) start,
 		       (unsigned long long) end);
-	e820_print_type(old_type);
+	if (checktype)
+		e820_print_type(old_type);
 	printk(KERN_CONT "\n");
 
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
 		u64 final_start, final_end;
+		u64 ei_end;
 
 		if (checktype && ei->type != old_type)
 			continue;
+
+		ei_end = ei->addr + ei->size;
 		/* totally covered? */
-		if (ei->addr >= start &&
-		    (ei->addr + ei->size) <= (start + size)) {
+		if (ei->addr >= start && ei_end <= end) {
 			real_removed_size += ei->size;
 			memset(ei, 0, sizeof(struct e820entry));
 			continue;
 		}
+
+		/* new range is totally covered? */
+		if (ei->addr < start && ei_end > end) {
+			e820_add_region(end, ei_end - end, ei->type);
+			ei->size = start - ei->addr;
+			real_removed_size += size;
+			continue;
+		}
+
 		/* partially covered */
 		final_start = max(start, ei->addr);
-		final_end = min(start + size, ei->addr + ei->size);
+		final_end = min(end, ei_end);
 		if (final_start >= final_end)
 			continue;
 		real_removed_size += final_end - final_start;
 
+		/*
+		 * left range could be head or tail, so need to update
+		 * size at first.
+		 */
 		ei->size -= final_end - final_start;
 		if (ei->addr < final_start)
 			continue;

commit 580e0ad21d6d6f932461d24b47041e3dd499c23f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Feb 16 18:40:35 2010 -0800

    core: Move early_res from arch/x86 to kernel/
    
    This makes the range reservation feature available to other
    architectures.
    
    -v2: add get_max_mapped, max_pfn_mapped only defined in x86...
         to fix PPC compiling
    -v3: according to hpa, add CONFIG_HAVE_EARLY_RES
    -v4: fix typo about EARLY_RES in config
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <4B7B5723.4070009@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 36918d8463ab..740b440fbd73 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -17,7 +17,6 @@
 #include <linux/firmware-map.h>
 
 #include <asm/e820.h>
-#include <asm/early_res.h>
 #include <asm/proto.h>
 #include <asm/setup.h>
 
@@ -752,6 +751,15 @@ u64 __init find_fw_memmap_area(u64 start, u64 end, u64 size, u64 align)
 {
 	return find_e820_area(start, end, size, align);
 }
+
+u64 __init get_max_mapped(void)
+{
+	u64 end = max_pfn_mapped;
+
+	end <<= PAGE_SHIFT;
+
+	return end;
+}
 /*
  * Find next free range after *start
  */

commit dd645cee7b50b61cb2d05b59eb6027679c437af6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:30 2010 -0800

    x86: Add find_fw_memmap_area
    
    ... so we can move early_res up.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-27-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b4e512b03aa7..36918d8463ab 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -748,6 +748,10 @@ u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
 	return -1ULL;
 }
 
+u64 __init find_fw_memmap_area(u64 start, u64 end, u64 size, u64 align)
+{
+	return find_e820_area(start, end, size, align);
+}
 /*
  * Find next free range after *start
  */

commit efdd0e81df0f23830c6d2cb971cf87f415b8dbdb
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:26 2010 -0800

    x86: Move back find_e820_area to e820.c
    
    Makes early_res.c more clean, so later could move it to /kernel.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-23-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 82db4015604e..b4e512b03aa7 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -722,6 +722,59 @@ static int __init e820_mark_nvs_memory(void)
 core_initcall(e820_mark_nvs_memory);
 #endif
 
+/*
+ * Find a free area with specified alignment in a specific range.
+ */
+u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 addr;
+		u64 ei_start, ei_last;
+
+		if (ei->type != E820_RAM)
+			continue;
+
+		ei_last = ei->addr + ei->size;
+		ei_start = ei->addr;
+		addr = find_early_area(ei_start, ei_last, start, end,
+					 size, align);
+
+		if (addr != -1ULL)
+			return addr;
+	}
+	return -1ULL;
+}
+
+/*
+ * Find next free range after *start
+ */
+u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 addr;
+		u64 ei_start, ei_last;
+
+		if (ei->type != E820_RAM)
+			continue;
+
+		ei_last = ei->addr + ei->size;
+		ei_start = ei->addr;
+		addr = find_early_area_size(ei_start, ei_last, start,
+					 sizep, align);
+
+		if (addr != -1ULL)
+			return addr;
+	}
+
+	return -1ULL;
+}
+
 /*
  * pre allocated 4k and reserved it in e820
  */

commit a678c2be75773e112f6d656a22a7f1645c4dbd6c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:24 2010 -0800

    x86: Separate early_res related code from e820.c
    
    ... to make e820.c smaller.
    
    -v2: fix 32bit compiling with MAX_DMA32_PFN
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-21-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 4004f10285d1..82db4015604e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -12,21 +12,14 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/bootmem.h>
-#include <linux/ioport.h>
-#include <linux/string.h>
-#include <linux/kexec.h>
-#include <linux/module.h>
-#include <linux/mm.h>
 #include <linux/pfn.h>
 #include <linux/suspend.h>
 #include <linux/firmware-map.h>
 
-#include <asm/pgtable.h>
-#include <asm/page.h>
 #include <asm/e820.h>
+#include <asm/early_res.h>
 #include <asm/proto.h>
 #include <asm/setup.h>
-#include <asm/trampoline.h>
 
 /*
  * The e820 map is the map that gets modified e.g. with command line parameters
@@ -729,538 +722,6 @@ static int __init e820_mark_nvs_memory(void)
 core_initcall(e820_mark_nvs_memory);
 #endif
 
-/*
- * Early reserved memory areas.
- */
-/*
- * need to make sure this one is bigger enough before
- * find_e820_area could be used
- */
-#define MAX_EARLY_RES_X 32
-
-struct early_res {
-	u64 start, end;
-	char name[15];
-	char overlap_ok;
-};
-static struct early_res early_res_x[MAX_EARLY_RES_X] __initdata;
-
-static int max_early_res __initdata = MAX_EARLY_RES_X;
-static struct early_res *early_res __initdata = &early_res_x[0];
-static int early_res_count __initdata;
-
-static int __init find_overlapped_early(u64 start, u64 end)
-{
-	int i;
-	struct early_res *r;
-
-	for (i = 0; i < max_early_res && early_res[i].end; i++) {
-		r = &early_res[i];
-		if (end > r->start && start < r->end)
-			break;
-	}
-
-	return i;
-}
-
-/*
- * Drop the i-th range from the early reservation map,
- * by copying any higher ranges down one over it, and
- * clearing what had been the last slot.
- */
-static void __init drop_range(int i)
-{
-	int j;
-
-	for (j = i + 1; j < max_early_res && early_res[j].end; j++)
-		;
-
-	memmove(&early_res[i], &early_res[i + 1],
-	       (j - 1 - i) * sizeof(struct early_res));
-
-	early_res[j - 1].end = 0;
-	early_res_count--;
-}
-
-/*
- * Split any existing ranges that:
- *  1) are marked 'overlap_ok', and
- *  2) overlap with the stated range [start, end)
- * into whatever portion (if any) of the existing range is entirely
- * below or entirely above the stated range.  Drop the portion
- * of the existing range that overlaps with the stated range,
- * which will allow the caller of this routine to then add that
- * stated range without conflicting with any existing range.
- */
-static void __init drop_overlaps_that_are_ok(u64 start, u64 end)
-{
-	int i;
-	struct early_res *r;
-	u64 lower_start, lower_end;
-	u64 upper_start, upper_end;
-	char name[15];
-
-	for (i = 0; i < max_early_res && early_res[i].end; i++) {
-		r = &early_res[i];
-
-		/* Continue past non-overlapping ranges */
-		if (end <= r->start || start >= r->end)
-			continue;
-
-		/*
-		 * Leave non-ok overlaps as is; let caller
-		 * panic "Overlapping early reservations"
-		 * when it hits this overlap.
-		 */
-		if (!r->overlap_ok)
-			return;
-
-		/*
-		 * We have an ok overlap.  We will drop it from the early
-		 * reservation map, and add back in any non-overlapping
-		 * portions (lower or upper) as separate, overlap_ok,
-		 * non-overlapping ranges.
-		 */
-
-		/* 1. Note any non-overlapping (lower or upper) ranges. */
-		strncpy(name, r->name, sizeof(name) - 1);
-
-		lower_start = lower_end = 0;
-		upper_start = upper_end = 0;
-		if (r->start < start) {
-		 	lower_start = r->start;
-			lower_end = start;
-		}
-		if (r->end > end) {
-			upper_start = end;
-			upper_end = r->end;
-		}
-
-		/* 2. Drop the original ok overlapping range */
-		drop_range(i);
-
-		i--;		/* resume for-loop on copied down entry */
-
-		/* 3. Add back in any non-overlapping ranges. */
-		if (lower_end)
-			reserve_early_overlap_ok(lower_start, lower_end, name);
-		if (upper_end)
-			reserve_early_overlap_ok(upper_start, upper_end, name);
-	}
-}
-
-static void __init __reserve_early(u64 start, u64 end, char *name,
-						int overlap_ok)
-{
-	int i;
-	struct early_res *r;
-
-	i = find_overlapped_early(start, end);
-	if (i >= max_early_res)
-		panic("Too many early reservations");
-	r = &early_res[i];
-	if (r->end)
-		panic("Overlapping early reservations "
-		      "%llx-%llx %s to %llx-%llx %s\n",
-		      start, end - 1, name?name:"", r->start,
-		      r->end - 1, r->name);
-	r->start = start;
-	r->end = end;
-	r->overlap_ok = overlap_ok;
-	if (name)
-		strncpy(r->name, name, sizeof(r->name) - 1);
-	early_res_count++;
-}
-
-/*
- * A few early reservtations come here.
- *
- * The 'overlap_ok' in the name of this routine does -not- mean it
- * is ok for these reservations to overlap an earlier reservation.
- * Rather it means that it is ok for subsequent reservations to
- * overlap this one.
- *
- * Use this entry point to reserve early ranges when you are doing
- * so out of "Paranoia", reserving perhaps more memory than you need,
- * just in case, and don't mind a subsequent overlapping reservation
- * that is known to be needed.
- *
- * The drop_overlaps_that_are_ok() call here isn't really needed.
- * It would be needed if we had two colliding 'overlap_ok'
- * reservations, so that the second such would not panic on the
- * overlap with the first.  We don't have any such as of this
- * writing, but might as well tolerate such if it happens in
- * the future.
- */
-void __init reserve_early_overlap_ok(u64 start, u64 end, char *name)
-{
-	drop_overlaps_that_are_ok(start, end);
-	__reserve_early(start, end, name, 1);
-}
-
-static void __init __check_and_double_early_res(u64 start)
-{
-	u64 end, size, mem;
-	struct early_res *new;
-
-	/* do we have enough slots left ? */
-	if ((max_early_res - early_res_count) > max(max_early_res/8, 2))
-		return;
-
-	/* double it */
-	end = max_pfn_mapped << PAGE_SHIFT;
-	size = sizeof(struct early_res) * max_early_res * 2;
-	mem = find_e820_area(start, end, size, sizeof(struct early_res));
-
-	if (mem == -1ULL)
-		panic("can not find more space for early_res array");
-
-	new = __va(mem);
-	/* save the first one for own */
-	new[0].start = mem;
-	new[0].end = mem + size;
-	new[0].overlap_ok = 0;
-	/* copy old to new */
-	if (early_res == early_res_x) {
-		memcpy(&new[1], &early_res[0],
-			 sizeof(struct early_res) * max_early_res);
-		memset(&new[max_early_res+1], 0,
-			 sizeof(struct early_res) * (max_early_res - 1));
-		early_res_count++;
-	} else {
-		memcpy(&new[1], &early_res[1],
-			 sizeof(struct early_res) * (max_early_res - 1));
-		memset(&new[max_early_res], 0,
-			 sizeof(struct early_res) * max_early_res);
-	}
-	memset(&early_res[0], 0, sizeof(struct early_res) * max_early_res);
-	early_res = new;
-	max_early_res *= 2;
-	printk(KERN_DEBUG "early_res array is doubled to %d at [%llx - %llx]\n",
-		max_early_res, mem, mem + size - 1);
-}
-
-/*
- * Most early reservations come here.
- *
- * We first have drop_overlaps_that_are_ok() drop any pre-existing
- * 'overlap_ok' ranges, so that we can then reserve this memory
- * range without risk of panic'ing on an overlapping overlap_ok
- * early reservation.
- */
-void __init reserve_early(u64 start, u64 end, char *name)
-{
-	if (start >= end)
-		return;
-
-	__check_and_double_early_res(end);
-
-	drop_overlaps_that_are_ok(start, end);
-	__reserve_early(start, end, name, 0);
-}
-
-void __init reserve_early_without_check(u64 start, u64 end, char *name)
-{
-	struct early_res *r;
-
-	if (start >= end)
-		return;
-
-	__check_and_double_early_res(end);
-
-	r = &early_res[early_res_count];
-
-	r->start = start;
-	r->end = end;
-	r->overlap_ok = 0;
-	if (name)
-		strncpy(r->name, name, sizeof(r->name) - 1);
-	early_res_count++;
-}
-
-void __init free_early(u64 start, u64 end)
-{
-	struct early_res *r;
-	int i;
-
-	i = find_overlapped_early(start, end);
-	r = &early_res[i];
-	if (i >= max_early_res || r->end != end || r->start != start)
-		panic("free_early on not reserved area: %llx-%llx!",
-			 start, end - 1);
-
-	drop_range(i);
-}
-
-#ifdef CONFIG_NO_BOOTMEM
-static void __init subtract_early_res(struct range *range, int az)
-{
-	int i, count;
-	u64 final_start, final_end;
-	int idx = 0;
-
-	count  = 0;
-	for (i = 0; i < max_early_res && early_res[i].end; i++)
-		count++;
-
-	/* need to skip first one ?*/
-	if (early_res != early_res_x)
-		idx = 1;
-
-#if 1
-	printk(KERN_INFO "Subtract (%d early reservations)\n", count);
-#endif
-	for (i = idx; i < count; i++) {
-		struct early_res *r = &early_res[i];
-#if 0
-		printk(KERN_INFO "  #%d [%010llx - %010llx] %15s", i,
-			r->start, r->end, r->name);
-#endif
-		final_start = PFN_DOWN(r->start);
-		final_end = PFN_UP(r->end);
-		if (final_start >= final_end) {
-#if 0
-			printk(KERN_CONT "\n");
-#endif
-			continue;
-		}
-#if 0
-		printk(KERN_CONT " subtract pfn [%010llx - %010llx]\n",
-			final_start, final_end);
-#endif
-		subtract_range(range, az, final_start, final_end);
-	}
-
-}
-
-int __init get_free_all_memory_range(struct range **rangep, int nodeid)
-{
-	int i, count;
-	u64 start = 0, end;
-	u64 size;
-	u64 mem;
-	struct range *range;
-	int nr_range;
-
-	count  = 0;
-	for (i = 0; i < max_early_res && early_res[i].end; i++)
-		count++;
-
-	count *= 2;
-
-	size = sizeof(struct range) * count;
-#ifdef MAX_DMA32_PFN
-	if (max_pfn_mapped > MAX_DMA32_PFN)
-		start = MAX_DMA32_PFN << PAGE_SHIFT;
-#endif
-	end = max_pfn_mapped << PAGE_SHIFT;
-	mem = find_e820_area(start, end, size, sizeof(struct range));
-	if (mem == -1ULL)
-		panic("can not find more space for range free");
-
-	range = __va(mem);
-	/* use early_node_map[] and early_res to get range array at first */
-	memset(range, 0, size);
-	nr_range = 0;
-
-	/* need to go over early_node_map to find out good range for node */
-	nr_range = add_from_early_node_map(range, count, nr_range, nodeid);
-	subtract_early_res(range, count);
-	nr_range = clean_sort_range(range, count);
-
-	/* need to clear it ? */
-	if (nodeid == MAX_NUMNODES) {
-		memset(&early_res[0], 0,
-			 sizeof(struct early_res) * max_early_res);
-		early_res = NULL;
-		max_early_res = 0;
-	}
-
-	*rangep = range;
-	return nr_range;
-}
-#else
-void __init early_res_to_bootmem(u64 start, u64 end)
-{
-	int i, count;
-	u64 final_start, final_end;
-	int idx = 0;
-
-	count  = 0;
-	for (i = 0; i < max_early_res && early_res[i].end; i++)
-		count++;
-
-	/* need to skip first one ?*/
-	if (early_res != early_res_x)
-		idx = 1;
-
-	printk(KERN_INFO "(%d/%d early reservations) ==> bootmem [%010llx - %010llx]\n",
-			 count - idx, max_early_res, start, end);
-	for (i = idx; i < count; i++) {
-		struct early_res *r = &early_res[i];
-		printk(KERN_INFO "  #%d [%010llx - %010llx] %16s", i,
-			r->start, r->end, r->name);
-		final_start = max(start, r->start);
-		final_end = min(end, r->end);
-		if (final_start >= final_end) {
-			printk(KERN_CONT "\n");
-			continue;
-		}
-		printk(KERN_CONT " ==> [%010llx - %010llx]\n",
-			final_start, final_end);
-		reserve_bootmem_generic(final_start, final_end - final_start,
-				BOOTMEM_DEFAULT);
-	}
-	/* clear them */
-	memset(&early_res[0], 0, sizeof(struct early_res) * max_early_res);
-	early_res = NULL;
-	max_early_res = 0;
-	early_res_count = 0;
-}
-#endif
-
-/* Check for already reserved areas */
-static inline int __init bad_addr(u64 *addrp, u64 size, u64 align)
-{
-	int i;
-	u64 addr = *addrp;
-	int changed = 0;
-	struct early_res *r;
-again:
-	i = find_overlapped_early(addr, addr + size);
-	r = &early_res[i];
-	if (i < max_early_res && r->end) {
-		*addrp = addr = round_up(r->end, align);
-		changed = 1;
-		goto again;
-	}
-	return changed;
-}
-
-/* Check for already reserved areas */
-static inline int __init bad_addr_size(u64 *addrp, u64 *sizep, u64 align)
-{
-	int i;
-	u64 addr = *addrp, last;
-	u64 size = *sizep;
-	int changed = 0;
-again:
-	last = addr + size;
-	for (i = 0; i < max_early_res && early_res[i].end; i++) {
-		struct early_res *r = &early_res[i];
-		if (last > r->start && addr < r->start) {
-			size = r->start - addr;
-			changed = 1;
-			goto again;
-		}
-		if (last > r->end && addr < r->end) {
-			addr = round_up(r->end, align);
-			size = last - addr;
-			changed = 1;
-			goto again;
-		}
-		if (last <= r->end && addr >= r->start) {
-			(*sizep)++;
-			return 0;
-		}
-	}
-	if (changed) {
-		*addrp = addr;
-		*sizep = size;
-	}
-	return changed;
-}
-
-/*
- * Find a free area with specified alignment in a specific range.
- * only with the area.between start to end is active range from early_node_map
- * so they are good as RAM
- */
-u64 __init find_early_area(u64 ei_start, u64 ei_last, u64 start, u64 end,
-			 u64 size, u64 align)
-{
-	u64 addr, last;
-
-	addr = round_up(ei_start, align);
-	if (addr < start)
-		addr = round_up(start, align);
-	if (addr >= ei_last)
-		goto out;
-	while (bad_addr(&addr, size, align) && addr+size <= ei_last)
-		;
-	last = addr + size;
-	if (last > ei_last)
-		goto out;
-	if (last > end)
-		goto out;
-
-	return addr;
-
-out:
-	return -1ULL;
-}
-
-/*
- * Find a free area with specified alignment in a specific range.
- */
-u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
-{
-	int i;
-
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-		u64 addr;
-		u64 ei_start, ei_last;
-
-		if (ei->type != E820_RAM)
-			continue;
-
-		ei_last = ei->addr + ei->size;
-		ei_start = ei->addr;
-		addr = find_early_area(ei_start, ei_last, start, end,
-					 size, align);
-
-		if (addr == -1ULL)
-			continue;
-
-		return addr;
-	}
-	return -1ULL;
-}
-
-/*
- * Find next free range after *start
- */
-u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
-{
-	int i;
-
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-		u64 addr, last;
-		u64 ei_last;
-
-		if (ei->type != E820_RAM)
-			continue;
-		addr = round_up(ei->addr, align);
-		ei_last = ei->addr + ei->size;
-		if (addr < start)
-			addr = round_up(start, align);
-		if (addr >= ei_last)
-			continue;
-		*sizep = ei_last - addr;
-		while (bad_addr_size(&addr, sizep, align) &&
-			addr + *sizep <= ei_last)
-			;
-		last = addr + *sizep;
-		if (last > ei_last)
-			continue;
-		return addr;
-	}
-
-	return -1ULL;
-}
-
 /*
  * pre allocated 4k and reserved it in e820
  */

commit db8f77c889542b09457b8b97efb311343c99a75d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:23 2010 -0800

    x86: Move bios page reserve early to head32/64.c
    
    So prepare to make one more clean of early_res.c.
    
    -v2: don't need to reserve first page in early_res
         because we already mark that in e820 as reserved already.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-20-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 90a85295f332..4004f10285d1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -743,29 +743,11 @@ struct early_res {
 	char name[15];
 	char overlap_ok;
 };
-static struct early_res early_res_x[MAX_EARLY_RES_X] __initdata = {
-	{ 0, PAGE_SIZE, "BIOS data page", 1 },	/* BIOS data page */
-#if defined(CONFIG_X86_32) && defined(CONFIG_X86_TRAMPOLINE)
-	/*
-	 * But first pinch a few for the stack/trampoline stuff
-	 * FIXME: Don't need the extra page at 4K, but need to fix
-	 * trampoline before removing it. (see the GDT stuff)
-	 */
-	{ PAGE_SIZE, PAGE_SIZE + PAGE_SIZE, "EX TRAMPOLINE", 1 },
-#endif
-
-	{}
-};
+static struct early_res early_res_x[MAX_EARLY_RES_X] __initdata;
 
 static int max_early_res __initdata = MAX_EARLY_RES_X;
 static struct early_res *early_res __initdata = &early_res_x[0];
-static int early_res_count __initdata =
-#ifdef CONFIG_X86_32
-	2
-#else
-	1
-#endif
-	;
+static int early_res_count __initdata;
 
 static int __init find_overlapped_early(u64 start, u64 end)
 {

commit 08677214e318297f228237be0042aac754f48f1d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:20 2010 -0800

    x86: Make 64 bit use early_res instead of bootmem before slab
    
    Finally we can use early_res to replace bootmem for x86_64 now.
    
    Still can use CONFIG_NO_BOOTMEM to enable it or not.
    
    -v2: fix 32bit compiling about MAX_DMA32_PFN
    -v3: folded bug fix from LKML message below
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <4B747239.4070907@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e09c18c8f3c1..90a85295f332 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -977,6 +977,25 @@ void __init reserve_early(u64 start, u64 end, char *name)
 	__reserve_early(start, end, name, 0);
 }
 
+void __init reserve_early_without_check(u64 start, u64 end, char *name)
+{
+	struct early_res *r;
+
+	if (start >= end)
+		return;
+
+	__check_and_double_early_res(end);
+
+	r = &early_res[early_res_count];
+
+	r->start = start;
+	r->end = end;
+	r->overlap_ok = 0;
+	if (name)
+		strncpy(r->name, name, sizeof(r->name) - 1);
+	early_res_count++;
+}
+
 void __init free_early(u64 start, u64 end)
 {
 	struct early_res *r;
@@ -991,6 +1010,94 @@ void __init free_early(u64 start, u64 end)
 	drop_range(i);
 }
 
+#ifdef CONFIG_NO_BOOTMEM
+static void __init subtract_early_res(struct range *range, int az)
+{
+	int i, count;
+	u64 final_start, final_end;
+	int idx = 0;
+
+	count  = 0;
+	for (i = 0; i < max_early_res && early_res[i].end; i++)
+		count++;
+
+	/* need to skip first one ?*/
+	if (early_res != early_res_x)
+		idx = 1;
+
+#if 1
+	printk(KERN_INFO "Subtract (%d early reservations)\n", count);
+#endif
+	for (i = idx; i < count; i++) {
+		struct early_res *r = &early_res[i];
+#if 0
+		printk(KERN_INFO "  #%d [%010llx - %010llx] %15s", i,
+			r->start, r->end, r->name);
+#endif
+		final_start = PFN_DOWN(r->start);
+		final_end = PFN_UP(r->end);
+		if (final_start >= final_end) {
+#if 0
+			printk(KERN_CONT "\n");
+#endif
+			continue;
+		}
+#if 0
+		printk(KERN_CONT " subtract pfn [%010llx - %010llx]\n",
+			final_start, final_end);
+#endif
+		subtract_range(range, az, final_start, final_end);
+	}
+
+}
+
+int __init get_free_all_memory_range(struct range **rangep, int nodeid)
+{
+	int i, count;
+	u64 start = 0, end;
+	u64 size;
+	u64 mem;
+	struct range *range;
+	int nr_range;
+
+	count  = 0;
+	for (i = 0; i < max_early_res && early_res[i].end; i++)
+		count++;
+
+	count *= 2;
+
+	size = sizeof(struct range) * count;
+#ifdef MAX_DMA32_PFN
+	if (max_pfn_mapped > MAX_DMA32_PFN)
+		start = MAX_DMA32_PFN << PAGE_SHIFT;
+#endif
+	end = max_pfn_mapped << PAGE_SHIFT;
+	mem = find_e820_area(start, end, size, sizeof(struct range));
+	if (mem == -1ULL)
+		panic("can not find more space for range free");
+
+	range = __va(mem);
+	/* use early_node_map[] and early_res to get range array at first */
+	memset(range, 0, size);
+	nr_range = 0;
+
+	/* need to go over early_node_map to find out good range for node */
+	nr_range = add_from_early_node_map(range, count, nr_range, nodeid);
+	subtract_early_res(range, count);
+	nr_range = clean_sort_range(range, count);
+
+	/* need to clear it ? */
+	if (nodeid == MAX_NUMNODES) {
+		memset(&early_res[0], 0,
+			 sizeof(struct early_res) * max_early_res);
+		early_res = NULL;
+		max_early_res = 0;
+	}
+
+	*rangep = range;
+	return nr_range;
+}
+#else
 void __init early_res_to_bootmem(u64 start, u64 end)
 {
 	int i, count;
@@ -1028,6 +1135,7 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 	max_early_res = 0;
 	early_res_count = 0;
 }
+#endif
 
 /* Check for already reserved areas */
 static inline int __init bad_addr(u64 *addrp, u64 size, u64 align)
@@ -1081,6 +1189,35 @@ static inline int __init bad_addr_size(u64 *addrp, u64 *sizep, u64 align)
 	return changed;
 }
 
+/*
+ * Find a free area with specified alignment in a specific range.
+ * only with the area.between start to end is active range from early_node_map
+ * so they are good as RAM
+ */
+u64 __init find_early_area(u64 ei_start, u64 ei_last, u64 start, u64 end,
+			 u64 size, u64 align)
+{
+	u64 addr, last;
+
+	addr = round_up(ei_start, align);
+	if (addr < start)
+		addr = round_up(start, align);
+	if (addr >= ei_last)
+		goto out;
+	while (bad_addr(&addr, size, align) && addr+size <= ei_last)
+		;
+	last = addr + size;
+	if (last > ei_last)
+		goto out;
+	if (last > end)
+		goto out;
+
+	return addr;
+
+out:
+	return -1ULL;
+}
+
 /*
  * Find a free area with specified alignment in a specific range.
  */
@@ -1090,24 +1227,20 @@ u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
 
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
-		u64 addr, last;
-		u64 ei_last;
+		u64 addr;
+		u64 ei_start, ei_last;
 
 		if (ei->type != E820_RAM)
 			continue;
-		addr = round_up(ei->addr, align);
+
 		ei_last = ei->addr + ei->size;
-		if (addr < start)
-			addr = round_up(start, align);
-		if (addr >= ei_last)
-			continue;
-		while (bad_addr(&addr, size, align) && addr+size <= ei_last)
-			;
-		last = addr + size;
-		if (last > ei_last)
-			continue;
-		if (last > end)
+		ei_start = ei->addr;
+		addr = find_early_area(ei_start, ei_last, start, end,
+					 size, align);
+
+		if (addr == -1ULL)
 			continue;
+
 		return addr;
 	}
 	return -1ULL;

commit 28b1c57d3c1f8df69c958f2ae7b9e4b67538ff4d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:17 2010 -0800

    x86: Dynamically increase early_res array size
    
    Use early_res_count to track the num, and use find_e820 to get a new
    buffer, then copy from the old to the new one.
    
    Also, clear early_res to prevent later invalid usage.
    
    -v2 _check_and_double_early_res should take new start
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-14-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7053f4adb8ed..e09c18c8f3c1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -916,6 +916,48 @@ void __init reserve_early_overlap_ok(u64 start, u64 end, char *name)
 	__reserve_early(start, end, name, 1);
 }
 
+static void __init __check_and_double_early_res(u64 start)
+{
+	u64 end, size, mem;
+	struct early_res *new;
+
+	/* do we have enough slots left ? */
+	if ((max_early_res - early_res_count) > max(max_early_res/8, 2))
+		return;
+
+	/* double it */
+	end = max_pfn_mapped << PAGE_SHIFT;
+	size = sizeof(struct early_res) * max_early_res * 2;
+	mem = find_e820_area(start, end, size, sizeof(struct early_res));
+
+	if (mem == -1ULL)
+		panic("can not find more space for early_res array");
+
+	new = __va(mem);
+	/* save the first one for own */
+	new[0].start = mem;
+	new[0].end = mem + size;
+	new[0].overlap_ok = 0;
+	/* copy old to new */
+	if (early_res == early_res_x) {
+		memcpy(&new[1], &early_res[0],
+			 sizeof(struct early_res) * max_early_res);
+		memset(&new[max_early_res+1], 0,
+			 sizeof(struct early_res) * (max_early_res - 1));
+		early_res_count++;
+	} else {
+		memcpy(&new[1], &early_res[1],
+			 sizeof(struct early_res) * (max_early_res - 1));
+		memset(&new[max_early_res], 0,
+			 sizeof(struct early_res) * max_early_res);
+	}
+	memset(&early_res[0], 0, sizeof(struct early_res) * max_early_res);
+	early_res = new;
+	max_early_res *= 2;
+	printk(KERN_DEBUG "early_res array is doubled to %d at [%llx - %llx]\n",
+		max_early_res, mem, mem + size - 1);
+}
+
 /*
  * Most early reservations come here.
  *
@@ -929,6 +971,8 @@ void __init reserve_early(u64 start, u64 end, char *name)
 	if (start >= end)
 		return;
 
+	__check_and_double_early_res(end);
+
 	drop_overlaps_that_are_ok(start, end);
 	__reserve_early(start, end, name, 0);
 }
@@ -957,6 +1001,10 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 	for (i = 0; i < max_early_res && early_res[i].end; i++)
 		count++;
 
+	/* need to skip first one ?*/
+	if (early_res != early_res_x)
+		idx = 1;
+
 	printk(KERN_INFO "(%d/%d early reservations) ==> bootmem [%010llx - %010llx]\n",
 			 count - idx, max_early_res, start, end);
 	for (i = idx; i < count; i++) {
@@ -974,6 +1022,11 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 		reserve_bootmem_generic(final_start, final_end - final_start,
 				BOOTMEM_DEFAULT);
 	}
+	/* clear them */
+	memset(&early_res[0], 0, sizeof(struct early_res) * max_early_res);
+	early_res = NULL;
+	max_early_res = 0;
+	early_res_count = 0;
 }
 
 /* Check for already reserved areas */

commit 264ebb182e85f30aa473fa2189d5d5ea173ec3ab
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:16 2010 -0800

    x86: Introduce max_early_res and early_res_count
    
    To prepare allocate early res array from fine_e820_area.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-13-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index f406efeb4dc4..7053f4adb8ed 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -732,14 +732,18 @@ core_initcall(e820_mark_nvs_memory);
 /*
  * Early reserved memory areas.
  */
-#define MAX_EARLY_RES 32
+/*
+ * need to make sure this one is bigger enough before
+ * find_e820_area could be used
+ */
+#define MAX_EARLY_RES_X 32
 
 struct early_res {
 	u64 start, end;
-	char name[16];
+	char name[15];
 	char overlap_ok;
 };
-static struct early_res early_res[MAX_EARLY_RES] __initdata = {
+static struct early_res early_res_x[MAX_EARLY_RES_X] __initdata = {
 	{ 0, PAGE_SIZE, "BIOS data page", 1 },	/* BIOS data page */
 #if defined(CONFIG_X86_32) && defined(CONFIG_X86_TRAMPOLINE)
 	/*
@@ -753,12 +757,22 @@ static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{}
 };
 
+static int max_early_res __initdata = MAX_EARLY_RES_X;
+static struct early_res *early_res __initdata = &early_res_x[0];
+static int early_res_count __initdata =
+#ifdef CONFIG_X86_32
+	2
+#else
+	1
+#endif
+	;
+
 static int __init find_overlapped_early(u64 start, u64 end)
 {
 	int i;
 	struct early_res *r;
 
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+	for (i = 0; i < max_early_res && early_res[i].end; i++) {
 		r = &early_res[i];
 		if (end > r->start && start < r->end)
 			break;
@@ -776,13 +790,14 @@ static void __init drop_range(int i)
 {
 	int j;
 
-	for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
+	for (j = i + 1; j < max_early_res && early_res[j].end; j++)
 		;
 
 	memmove(&early_res[i], &early_res[i + 1],
 	       (j - 1 - i) * sizeof(struct early_res));
 
 	early_res[j - 1].end = 0;
+	early_res_count--;
 }
 
 /*
@@ -801,9 +816,9 @@ static void __init drop_overlaps_that_are_ok(u64 start, u64 end)
 	struct early_res *r;
 	u64 lower_start, lower_end;
 	u64 upper_start, upper_end;
-	char name[16];
+	char name[15];
 
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+	for (i = 0; i < max_early_res && early_res[i].end; i++) {
 		r = &early_res[i];
 
 		/* Continue past non-overlapping ranges */
@@ -859,7 +874,7 @@ static void __init __reserve_early(u64 start, u64 end, char *name,
 	struct early_res *r;
 
 	i = find_overlapped_early(start, end);
-	if (i >= MAX_EARLY_RES)
+	if (i >= max_early_res)
 		panic("Too many early reservations");
 	r = &early_res[i];
 	if (r->end)
@@ -872,6 +887,7 @@ static void __init __reserve_early(u64 start, u64 end, char *name,
 	r->overlap_ok = overlap_ok;
 	if (name)
 		strncpy(r->name, name, sizeof(r->name) - 1);
+	early_res_count++;
 }
 
 /*
@@ -924,7 +940,7 @@ void __init free_early(u64 start, u64 end)
 
 	i = find_overlapped_early(start, end);
 	r = &early_res[i];
-	if (i >= MAX_EARLY_RES || r->end != end || r->start != start)
+	if (i >= max_early_res || r->end != end || r->start != start)
 		panic("free_early on not reserved area: %llx-%llx!",
 			 start, end - 1);
 
@@ -935,14 +951,15 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 {
 	int i, count;
 	u64 final_start, final_end;
+	int idx = 0;
 
 	count  = 0;
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++)
+	for (i = 0; i < max_early_res && early_res[i].end; i++)
 		count++;
 
-	printk(KERN_INFO "(%d early reservations) ==> bootmem [%010llx - %010llx]\n",
-			 count, start, end);
-	for (i = 0; i < count; i++) {
+	printk(KERN_INFO "(%d/%d early reservations) ==> bootmem [%010llx - %010llx]\n",
+			 count - idx, max_early_res, start, end);
+	for (i = idx; i < count; i++) {
 		struct early_res *r = &early_res[i];
 		printk(KERN_INFO "  #%d [%010llx - %010llx] %16s", i,
 			r->start, r->end, r->name);
@@ -969,7 +986,7 @@ static inline int __init bad_addr(u64 *addrp, u64 size, u64 align)
 again:
 	i = find_overlapped_early(addr, addr + size);
 	r = &early_res[i];
-	if (i < MAX_EARLY_RES && r->end) {
+	if (i < max_early_res && r->end) {
 		*addrp = addr = round_up(r->end, align);
 		changed = 1;
 		goto again;
@@ -986,7 +1003,7 @@ static inline int __init bad_addr_size(u64 *addrp, u64 *sizep, u64 align)
 	int changed = 0;
 again:
 	last = addr + size;
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+	for (i = 0; i < max_early_res && early_res[i].end; i++) {
 		struct early_res *r = &early_res[i];
 		if (last > r->start && addr < r->start) {
 			size = r->start - addr;

commit 79c601695870ca2a9c0ba9949a97d2be78ec07b2
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:14 2010 -0800

    x86: Print out RAM buffer information
    
    So we can check that early in the bootlog.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-11-git-send-email-yinghai@kernel.org>
    Reviewed-by: Christoph Lameter <cl@linux-foundation.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a966b753e496..f406efeb4dc4 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1429,6 +1429,8 @@ void __init e820_reserve_resources_late(void)
 			end = MAX_RESOURCE_SIZE;
 		if (start >= end)
 			continue;
+		printk(KERN_DEBUG "reserve RAM buffer: %016llx - %016llx ",
+			       start, end);
 		reserve_region_with_split(&iomem_resource, start, end,
 					  "RAM buffer");
 	}

commit 84abd88a70090cf00f9e45c3a81680874f17626e
Merge: 13ca0fcaa33f e28cab42f384
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Feb 10 16:55:28 2010 -0800

    Merge remote branch 'linus/master' into x86/bootmem

commit 1b5576e69a5fe168c08a159685ac366316ac9bbc
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 22 11:21:04 2010 +0800

    x86: Remove BIOS data range from e820
    
    In preparation for moving to the generic page_is_ram(), make explicit
    what we expect to be reserved and not reserved.
    
    Tested-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <20100122033004.335813103@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d17d482a04f4..230687ba5ba5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -517,11 +517,19 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 			     int checktype)
 {
 	int i;
+	u64 end;
 	u64 real_removed_size = 0;
 
 	if (size > (ULLONG_MAX - start))
 		size = ULLONG_MAX - start;
 
+	end = start + size;
+	printk(KERN_DEBUG "e820 remove range: %016Lx - %016Lx ",
+		       (unsigned long long) start,
+		       (unsigned long long) end);
+	e820_print_type(old_type);
+	printk(KERN_CONT "\n");
+
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
 		u64 final_start, final_end;

commit 9dad0fd5a73d4048dff18069733c0b515f68df74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Dec 22 15:40:39 2009 -0800

    x86: Fix size for ex trampoline with 32bit
    
    fix for error that is introduced by
    | x86: Use find_e820() instead of hard coded trampoline address
    
    it should end with PAGE_SIZE + PAGE_SIZE
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1261525263-13763-2-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 05ed7ab2ca48..a1a7876cadcb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -733,13 +733,13 @@ struct early_res {
 };
 static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{ 0, PAGE_SIZE, "BIOS data page", 1 },	/* BIOS data page */
-#ifdef CONFIG_X86_32
+#if defined(CONFIG_X86_32) && defined(CONFIG_X86_TRAMPOLINE)
 	/*
 	 * But first pinch a few for the stack/trampoline stuff
 	 * FIXME: Don't need the extra page at 4K, but need to fix
 	 * trampoline before removing it. (see the GDT stuff)
 	 */
-	{ PAGE_SIZE, PAGE_SIZE, "EX TRAMPOLINE", 1 },
+	{ PAGE_SIZE, PAGE_SIZE + PAGE_SIZE, "EX TRAMPOLINE", 1 },
 #endif
 
 	{}

commit 6a1e008a0915f502eb026fb995ea3e49d5b017f7
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Dec 15 17:59:03 2009 -0800

    x86: Increase MAX_EARLY_RES; insufficient on 32-bit NUMA
    
    Due to recent changes wakeup and mptable, we run out of early
    reservations on 32-bit NUMA.  Thus, adjust the available number.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <4B22D754.2020706@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index f50447d961c0..05ed7ab2ca48 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -724,7 +724,7 @@ core_initcall(e820_mark_nvs_memory);
 /*
  * Early reserved memory areas.
  */
-#define MAX_EARLY_RES 20
+#define MAX_EARLY_RES 32
 
 struct early_res {
 	u64 start, end;

commit 893f38d144a4d96d2483cd7c3801d26e1b2c23e9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Dec 10 13:07:22 2009 -0800

    x86: Use find_e820() instead of hard coded trampoline address
    
    Jens found the following crash/regression:
    
    [    0.000000] found SMP MP-table at [ffff8800000fdd80] fdd80
    [    0.000000] Kernel panic - not syncing: Overlapping early reservations 12-f011 MP-table mpc to 0-fff BIOS data page
    
    and
    
    [    0.000000] Kernel panic - not syncing: Overlapping early reservations 12-f011 MP-table mpc to 6000-7fff TRAMPOLINE
    
    and bisected it to b24c2a9 ("x86: Move find_smp_config()
    earlier and avoid bootmem usage").
    
    It turns out the BIOS is using the first 64k for mptable,
    without reserving it.
    
    So try to find good range for the real-mode trampoline instead of
    hard coding it, in case some bios tries to use that range for sth.
    
    Reported-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Tested-by: Jens Axboe <jens.axboe@oracle.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    LKML-Reference: <4B21630A.6000308@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d17d482a04f4..f50447d961c0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -732,7 +732,16 @@ struct early_res {
 	char overlap_ok;
 };
 static struct early_res early_res[MAX_EARLY_RES] __initdata = {
-	{ 0, PAGE_SIZE, "BIOS data page" },	/* BIOS data page */
+	{ 0, PAGE_SIZE, "BIOS data page", 1 },	/* BIOS data page */
+#ifdef CONFIG_X86_32
+	/*
+	 * But first pinch a few for the stack/trampoline stuff
+	 * FIXME: Don't need the extra page at 4K, but need to fix
+	 * trampoline before removing it. (see the GDT stuff)
+	 */
+	{ PAGE_SIZE, PAGE_SIZE, "EX TRAMPOLINE", 1 },
+#endif
+
 	{}
 };
 

commit 15b812f1d0a5ca8f5efe7f5882f468af10682ca8
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Oct 11 14:17:16 2009 -0700

    pci: increase alignment to make more space for hidden code
    
    As reported in
    
            http://bugzilla.kernel.org/show_bug.cgi?id=13940
    
    on some system when acpi are enabled, acpi clears some BAR for some
    devices without reason, and kernel will need to allocate devices for
    them.  It then apparently hits some undocumented resource conflict,
    resulting in non-working devices.
    
    Try to increase alignment to get more safe range for unassigned devices.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 85419bb7d4ab..d17d482a04f4 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1378,8 +1378,8 @@ static unsigned long ram_alignment(resource_size_t pos)
 	if (mb < 16)
 		return 1024*1024;
 
-	/* To 32MB for anything above that */
-	return 32*1024*1024;
+	/* To 64MB for anything above that */
+	return 64*1024*1024;
 }
 
 #define MAX_RESOURCE_SIZE ((resource_size_t)-1)

commit 3c1596efe167322dae87f8390d36f91ce2d7f936
Author: Jan Beulich <JBeulich@novell.com>
Date:   Mon Sep 21 17:03:06 2009 -0700

    mm: don't use alloc_bootmem_low() where not strictly needed
    
    Since alloc_bootmem() will never return inaccessible (via virtual
    addressing) memory anyway, using the ..._low() variant only makes sense
    when the physical address range of the allocated memory must fulfill
    further constraints, espacially since on 64-bits (or more generally in all
    cases where the pools the two variants allocate from are than the full
    available range.
    
    Probably the use in alloc_tce_table() could also be eliminated (based on
    code inspection of pci-calgary_64.c), but that seems too risky given I
    know nothing about that hardware and have no way to test it.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a3210ce1eccd..85419bb7d4ab 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1331,7 +1331,7 @@ void __init e820_reserve_resources(void)
 	struct resource *res;
 	u64 end;
 
-	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
+	res = alloc_bootmem(sizeof(struct resource) * e820.nr_map);
 	e820_res = res;
 	for (i = 0; i < e820.nr_map; i++) {
 		end = e820.map[i].addr + e820.map[i].size - 1;

commit 78f28b7c555359c67c2a0d23f7436e915329421e
Merge: 3240a77b515f 7bd867dfb4e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 14:05:47 2009 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (38 commits)
      x86: Move get/set_wallclock to x86_platform_ops
      x86: platform: Fix section annotations
      x86: apic namespace cleanup
      x86: Distangle ioapic and i8259
      x86: Add Moorestown early detection
      x86: Add hardware_subarch ID for Moorestown
      x86: Add early platform detection
      x86: Move tsc_init to late_time_init
      x86: Move tsc_calibration to x86_init_ops
      x86: Replace the now identical time_32/64.c by time.c
      x86: time_32/64.c unify profile_pc
      x86: Move calibrate_cpu to tsc.c
      x86: Make timer setup and global variables the same in time_32/64.c
      x86: Remove mca bus ifdef from timer interrupt
      x86: Simplify timer_ack magic in time_32.c
      x86: Prepare unification of time_32/64.c
      x86: Remove do_timer hook
      x86: Add timer_init to x86_init_ops
      x86: Move percpu clockevents setup to x86_init_ops
      x86: Move xen_post_allocator_init into xen_pagetable_setup_done
      ...
    
    Fix up conflicts in arch/x86/include/asm/io_apic.h

commit 0cc6d77e55eca9557bbe41bf2db94b31aa8fcb2a
Merge: 55e0715f612f 5051fd69773d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 14 08:01:47 2009 -0700

    Merge branch 'x86-setup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-setup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, e820: Guard against array overflowed in __e820_add_region()
      x86, setup: remove obsolete pre-Kconfig CONFIG_VIDEO_ variables

commit 6b18ae3e2ff62daa9f181401759161dd8de0aadf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 20 10:19:54 2009 +0200

    x86: Move memory_setup to x86_init_ops
    
    memory_setup is overridden by x86_quirks and by paravirts with weak
    functions and quirks. Unify the whole mess and make it an
    unconditional x86_init_ops function which defaults to the standard
    function and can be overridden by the early platform code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 5cb5725b2bae..0d804b907e80 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1455,28 +1455,11 @@ char *__init default_machine_specific_memory_setup(void)
 	return who;
 }
 
-char *__init __attribute__((weak)) machine_specific_memory_setup(void)
-{
-	if (x86_quirks->arch_memory_setup) {
-		char *who = x86_quirks->arch_memory_setup();
-
-		if (who)
-			return who;
-	}
-	return default_machine_specific_memory_setup();
-}
-
-/* Overridden in paravirt.c if CONFIG_PARAVIRT */
-char * __init __attribute__((weak)) memory_setup(void)
-{
-	return machine_specific_memory_setup();
-}
-
 void __init setup_memory_map(void)
 {
 	char *who;
 
-	who = memory_setup();
+	who = x86_init.resources.memory_setup();
 	memcpy(&e820_saved, &e820, sizeof(struct e820map));
 	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
 	e820_print_map(who);

commit 5051fd69773d2d044734b78516317a04d3774871
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Mon Aug 24 21:53:37 2009 +0400

    x86, e820: Guard against array overflowed in __e820_add_region()
    
    Better to be paranoid against unpredicted nr_map modifications.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    LKML-Reference: <20090824175551.146070377@openvz.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7271fa33d791..2e5e0faa99b5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -115,7 +115,7 @@ static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,
 {
 	int x = e820x->nr_map;
 
-	if (x == ARRAY_SIZE(e820x->map)) {
+	if (x >= ARRAY_SIZE(e820x->map)) {
 		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
 		return;
 	}

commit ad361c9884e809340f6daca80d56a9e9c871690a
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 6 13:05:40 2009 -0700

    Remove multiple KERN_ prefixes from printk formats
    
    Commit 5fd29d6ccbc98884569d6f3105aeca70858b3e0f ("printk: clean up
    handling of log-levels and newlines") changed printk semantics.  printk
    lines with multiple KERN_<level> prefixes are no longer emitted as
    before the patch.
    
    <level> is now included in the output on each additional use.
    
    Remove all uses of multiple KERN_<level>s in formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c4ca89d9aaf4..5cb5725b2bae 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -627,10 +627,9 @@ __init void e820_setup_gap(void)
 #ifdef CONFIG_X86_64
 	if (!found) {
 		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
-		printk(KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit "
-		       "address range\n"
-		       KERN_ERR "PCI: Unassigned devices with 32bit resource "
-		       "registers may break!\n");
+		printk(KERN_ERR
+	"PCI: Warning: Cannot find a gap in the 32bit address range\n"
+	"PCI: Unassigned devices with 32bit resource registers may break!\n");
 	}
 #endif
 

commit 7c5371c403abb29f01bc6cff6c5096abdf2dc524
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Jul 1 12:32:18 2009 -0700

    x86: add boundary check for 32bit res before expand e820 resource to alignment
    
    fix hang with HIGHMEM_64G and 32bit resource.  According to hpa and
    Linus, use (resource_size_t)-1 to fend off big ranges.
    
    Analyzed by hpa
    
    Reported-and-tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7271fa33d791..c4ca89d9aaf4 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1383,6 +1383,8 @@ static unsigned long ram_alignment(resource_size_t pos)
 	return 32*1024*1024;
 }
 
+#define MAX_RESOURCE_SIZE ((resource_size_t)-1)
+
 void __init e820_reserve_resources_late(void)
 {
 	int i;
@@ -1400,17 +1402,19 @@ void __init e820_reserve_resources_late(void)
 	 * avoid stolen RAM:
 	 */
 	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *entry = &e820_saved.map[i];
-		resource_size_t start, end;
+		struct e820entry *entry = &e820.map[i];
+		u64 start, end;
 
 		if (entry->type != E820_RAM)
 			continue;
 		start = entry->addr + entry->size;
-		end = round_up(start, ram_alignment(start));
-		if (start == end)
+		end = round_up(start, ram_alignment(start)) - 1;
+		if (end > MAX_RESOURCE_SIZE)
+			end = MAX_RESOURCE_SIZE;
+		if (start >= end)
 			continue;
-		reserve_region_with_split(&iomem_resource, start,
-						  end - 1, "RAM buffer");
+		reserve_region_with_split(&iomem_resource, start, end,
+					  "RAM buffer");
 	}
 }
 

commit 5d423ccd7ba4285f1084e91b26805e1d0ae978ed
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed May 6 08:07:52 2009 -0700

    x86/pci: remove rounding quirk from e820_setup_gap()
    
    Now that the e820 code explicitly reserves 'potentially dangerous'
    free physical memory address space to protect ACPI stolen RAM,
    there's no need for the rounding quirk in the PCI allocator anymore.
    
    Also, this quirk was open-ended iteration that could end up reserving
    a lot of free space and potentially breaking drivers - such as the one
    reported by Yannick Roehlly <yannick.roehlly@free.fr> where there's
    a PCI device with a large memory resource.
    
    So remove it.
    
    [ Impact: make more of the PCI hole available for assigning pci devices ]
    
    Reported-by: Yannick Roehlly <yannick.roehlly@free.fr>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jesse Barnes <jesse.barnes@intel.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <4A01A7C8.5090701@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a2335d9de052..7271fa33d791 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -617,7 +617,7 @@ __init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
  */
 __init void e820_setup_gap(void)
 {
-	unsigned long gapstart, gapsize, round;
+	unsigned long gapstart, gapsize;
 	int found;
 
 	gapstart = 0x10000000;
@@ -635,14 +635,9 @@ __init void e820_setup_gap(void)
 #endif
 
 	/*
-	 * See how much we want to round up: start off with
-	 * rounding to the next 1MB area.
+	 * e820_reserve_resources_late protect stolen RAM already
 	 */
-	round = 0x100000;
-	while ((gapsize >> 4) > round)
-		round += round;
-	/* Fun with two's complement */
-	pci_mem_start = (gapstart + round) & -round;
+	pci_mem_start = gapstart;
 
 	printk(KERN_INFO
 	       "Allocating PCI resources starting at %lx (gap: %lx:%lx)\n",

commit 45fbe3ee01b8e463b28c2751b5dcc0cbdc142d90
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 6 08:06:44 2009 -0700

    x86, e820, pci: reserve extra free space near end of RAM
    
    The point is to take all RAM resources we have, and
    _after_ we've added all the resources we've seen in
    the E820 tree, we then _also_ try to add fake reserved
    entries for any "round up to X" at the end of the RAM
    resources.
    
    [ Impact: improve PCI mem-resource allocation robustness, protect "stolen RAM" ]
    
    Reported-by: Yannick Roehlly <yannick.roehlly@free.fr>
    Acked-by: Jesse Barnes <jesse.barnes@intel.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: yannick.roehlly@free.fr
    LKML-Reference: <4A01A784.2050407@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 006281302925..a2335d9de052 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1371,6 +1371,23 @@ void __init e820_reserve_resources(void)
 	}
 }
 
+/* How much should we pad RAM ending depending on where it is? */
+static unsigned long ram_alignment(resource_size_t pos)
+{
+	unsigned long mb = pos >> 20;
+
+	/* To 64kB in the first megabyte */
+	if (!mb)
+		return 64*1024;
+
+	/* To 1MB in the first 16MB */
+	if (mb < 16)
+		return 1024*1024;
+
+	/* To 32MB for anything above that */
+	return 32*1024*1024;
+}
+
 void __init e820_reserve_resources_late(void)
 {
 	int i;
@@ -1382,6 +1399,24 @@ void __init e820_reserve_resources_late(void)
 			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
 	}
+
+	/*
+	 * Try to bump up RAM regions to reasonable boundaries to
+	 * avoid stolen RAM:
+	 */
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *entry = &e820_saved.map[i];
+		resource_size_t start, end;
+
+		if (entry->type != E820_RAM)
+			continue;
+		start = entry->addr + entry->size;
+		end = round_up(start, ram_alignment(start));
+		if (start == end)
+			continue;
+		reserve_region_with_split(&iomem_resource, start,
+						  end - 1, "RAM buffer");
+	}
 }
 
 char *__init default_machine_specific_memory_setup(void)

commit 61438766514a2d7f191ce1b3cf6812eabbef4ef7
Author: Jan Beulich <jbeulich@novell.com>
Date:   Wed May 6 13:02:19 2009 +0100

    x86: fix boot hang in early_reserve_e820()
    
    If the first non-reserved (sub-)range doesn't fit the size requested,
    an endless loop will be entered. If a range returned from
    find_e820_area_size() turns out insufficient in size, the range must
    be skipped before calling the function again.
    
    [ Impact: fixes boot hang on some platforms ]
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ef2c3563357d..006281302925 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1074,12 +1074,13 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 	u64 addr;
 	u64 start;
 
-	start = startt;
-	while (size < sizet && (start + 1))
+	for (start = startt; ; start += size) {
 		start = find_e820_area_size(start, &size, align);
-
-	if (size < sizet)
-		return 0;
+		if (!(start + 1))
+			return 0;
+		if (size >= sizet)
+			break;
+	}
 
 #ifdef CONFIG_X86_32
 	if (start >= MAXMEM)

commit ba639039d68cd978f4fa900a6533fe930609ed35
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Mon Mar 23 02:13:01 2009 +0530

    x86: e820 fix various signedness issues in setup.c and e820.c
    
    Impact: cleanup
    
    This fixed various signedness issues in setup.c and e820.c:
    arch/x86/kernel/setup.c:455:53: warning: incorrect type in argument 3 (different signedness)
    arch/x86/kernel/setup.c:455:53:    expected int *pnr_map
    arch/x86/kernel/setup.c:455:53:    got unsigned int extern [toplevel] *<noident>
    arch/x86/kernel/setup.c:639:53: warning: incorrect type in argument 3 (different signedness)
    arch/x86/kernel/setup.c:639:53:    expected int *pnr_map
    arch/x86/kernel/setup.c:639:53:    got unsigned int extern [toplevel] *<noident>
    arch/x86/kernel/setup.c:820:54: warning: incorrect type in argument 3 (different signedness)
    arch/x86/kernel/setup.c:820:54:    expected int *pnr_map
    arch/x86/kernel/setup.c:820:54:    got unsigned int extern [toplevel] *<noident>
    
    arch/x86/kernel/e820.c:670:53: warning: incorrect type in argument 3 (different signedness)
    arch/x86/kernel/e820.c:670:53:    expected int *pnr_map
    arch/x86/kernel/e820.c:670:53:    got unsigned int [toplevel] *<noident>
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index fb638d9ce6d2..ef2c3563357d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -233,7 +233,7 @@ void __init e820_print_map(char *who)
  */
 
 int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
-				int *pnr_map)
+			     u32 *pnr_map)
 {
 	struct change_member {
 		struct e820entry *pbios; /* pointer to original bios entry */
@@ -552,7 +552,7 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	int nr_map;
+	u32 nr_map;
 
 	nr_map = e820.nr_map;
 	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr_map))
@@ -563,7 +563,7 @@ void __init update_e820(void)
 }
 static void __init update_e820_saved(void)
 {
-	int nr_map;
+	u32 nr_map;
 
 	nr_map = e820_saved.nr_map;
 	if (sanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map), &nr_map))
@@ -1303,7 +1303,7 @@ early_param("memmap", parse_memmap_opt);
 void __init finish_e820_parsing(void)
 {
 	if (userdef) {
-		int nr = e820.nr_map;
+		u32 nr = e820.nr_map;
 
 		if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr) < 0)
 			early_panic("Invalid user supplied memory map");
@@ -1386,7 +1386,7 @@ void __init e820_reserve_resources_late(void)
 char *__init default_machine_specific_memory_setup(void)
 {
 	char *who = "BIOS-e820";
-	int new_nr;
+	u32 new_nr;
 	/*
 	 * Try to copy the BIOS-supplied E820-map.
 	 *

commit c61cf4cfe7c73c7aa62dde3ff82cd475b9c41481
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Mar 15 00:59:19 2009 -0700

    x86: print out more info in e820_update_range()
    
    Impact: help debug e820 bugs
    
    Try to print out more info, to catch wrong call parameters.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <49BCB557.3030000@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0c34ff49ff4d..fb638d9ce6d2 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -131,6 +131,31 @@ void __init e820_add_region(u64 start, u64 size, int type)
 	__e820_add_region(&e820, start, size, type);
 }
 
+static void __init e820_print_type(u32 type)
+{
+	switch (type) {
+	case E820_RAM:
+	case E820_RESERVED_KERN:
+		printk(KERN_CONT "(usable)");
+		break;
+	case E820_RESERVED:
+		printk(KERN_CONT "(reserved)");
+		break;
+	case E820_ACPI:
+		printk(KERN_CONT "(ACPI data)");
+		break;
+	case E820_NVS:
+		printk(KERN_CONT "(ACPI NVS)");
+		break;
+	case E820_UNUSABLE:
+		printk(KERN_CONT "(unusable)");
+		break;
+	default:
+		printk(KERN_CONT "type %u", type);
+		break;
+	}
+}
+
 void __init e820_print_map(char *who)
 {
 	int i;
@@ -140,27 +165,8 @@ void __init e820_print_map(char *who)
 		       (unsigned long long) e820.map[i].addr,
 		       (unsigned long long)
 		       (e820.map[i].addr + e820.map[i].size));
-		switch (e820.map[i].type) {
-		case E820_RAM:
-		case E820_RESERVED_KERN:
-			printk(KERN_CONT "(usable)\n");
-			break;
-		case E820_RESERVED:
-			printk(KERN_CONT "(reserved)\n");
-			break;
-		case E820_ACPI:
-			printk(KERN_CONT "(ACPI data)\n");
-			break;
-		case E820_NVS:
-			printk(KERN_CONT "(ACPI NVS)\n");
-			break;
-		case E820_UNUSABLE:
-			printk("(unusable)\n");
-			break;
-		default:
-			printk(KERN_CONT "type %u\n", e820.map[i].type);
-			break;
-		}
+		e820_print_type(e820.map[i].type);
+		printk(KERN_CONT "\n");
 	}
 }
 
@@ -437,6 +443,14 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 		size = ULLONG_MAX - start;
 
 	end = start + size;
+	printk(KERN_DEBUG "e820 update range: %016Lx - %016Lx ",
+		       (unsigned long long) start,
+		       (unsigned long long) end);
+	e820_print_type(old_type);
+	printk(KERN_CONT " ==> ");
+	e820_print_type(new_type);
+	printk(KERN_CONT "\n");
+
 	for (i = 0; i < e820x->nr_map; i++) {
 		struct e820entry *ei = &e820x->map[i];
 		u64 final_start, final_end;

commit 78a8b35bc7abf8b8333d6f625e08c0f7cc1c3742
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Mar 12 22:36:01 2009 -0700

    x86: make e820_update_range() handle small range update
    
    Impact: enhance e820 code to handle more cases
    
    Try to handle new range which could be covered by one entry.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: jbeulich@novell.com
    LKML-Reference: <49B9F0C1.10402@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 95b81c18b6bc..0c34ff49ff4d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -427,6 +427,7 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
+	u64 end;
 	unsigned int i;
 	u64 real_updated_size = 0;
 
@@ -435,21 +436,35 @@ static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 	if (size > (ULLONG_MAX - start))
 		size = ULLONG_MAX - start;
 
+	end = start + size;
 	for (i = 0; i < e820x->nr_map; i++) {
 		struct e820entry *ei = &e820x->map[i];
 		u64 final_start, final_end;
+		u64 ei_end;
+
 		if (ei->type != old_type)
 			continue;
-		/* totally covered? */
-		if (ei->addr >= start &&
-		    (ei->addr + ei->size) <= (start + size)) {
+
+		ei_end = ei->addr + ei->size;
+		/* totally covered by new range? */
+		if (ei->addr >= start && ei_end <= end) {
 			ei->type = new_type;
 			real_updated_size += ei->size;
 			continue;
 		}
+
+		/* new range is totally covered? */
+		if (ei->addr < start && ei_end > end) {
+			__e820_add_region(e820x, start, size, new_type);
+			__e820_add_region(e820x, end, ei_end - end, ei->type);
+			ei->size = start - ei->addr;
+			real_updated_size += size;
+			continue;
+		}
+
 		/* partially covered */
 		final_start = max(start, ei->addr);
-		final_end = min(start + size, ei->addr + ei->size);
+		final_end = min(end, ei_end);
 		if (final_start >= final_end)
 			continue;
 

commit 773e673de27297d07d852e7e9bfd1a695cae1da2
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Mar 12 21:35:18 2009 -0700

    x86: fix e820_update_range()
    
    Impact: fix left range size on head
    
    | commit 5c0e6f035df983210e4d22213aed624ced502d3d
    |    x86: fix code paths used by update_mptable
    |    Impact: fix crashes under Xen due to unrobust e820 code
    
    fixes one e820 bug, but introduces another bug.
    
    Need to update size for left range at first in case it is header.
    
    also add __e820_add_region take more parameter.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: jbeulich@novell.com
    LKML-Reference: <49B9E286.502@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3cf6681ac80d..95b81c18b6bc 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -110,19 +110,25 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel e820 map.
  */
-void __init e820_add_region(u64 start, u64 size, int type)
+static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,
+					 int type)
 {
-	int x = e820.nr_map;
+	int x = e820x->nr_map;
 
-	if (x == ARRAY_SIZE(e820.map)) {
+	if (x == ARRAY_SIZE(e820x->map)) {
 		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
 		return;
 	}
 
-	e820.map[x].addr = start;
-	e820.map[x].size = size;
-	e820.map[x].type = type;
-	e820.nr_map++;
+	e820x->map[x].addr = start;
+	e820x->map[x].size = size;
+	e820x->map[x].type = type;
+	e820x->nr_map++;
+}
+
+void __init e820_add_region(u64 start, u64 size, int type)
+{
+	__e820_add_region(&e820, start, size, type);
 }
 
 void __init e820_print_map(char *who)
@@ -417,11 +423,11 @@ static int __init append_e820_map(struct e820entry *biosmap, int nr_map)
 	return __append_e820_map(biosmap, nr_map);
 }
 
-static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
+static u64 __init __e820_update_range(struct e820map *e820x, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
-	unsigned int i, x;
+	unsigned int i;
 	u64 real_updated_size = 0;
 
 	BUG_ON(old_type == new_type);
@@ -447,22 +453,19 @@ static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
 		if (final_start >= final_end)
 			continue;
 
-		x = e820x->nr_map;
-		if (x == ARRAY_SIZE(e820x->map)) {
-			printk(KERN_ERR "Too many memory map entries!\n");
-			break;
-		}
-		e820x->map[x].addr = final_start;
-		e820x->map[x].size = final_end - final_start;
-		e820x->map[x].type = new_type;
-		e820x->nr_map++;
+		__e820_add_region(e820x, final_start, final_end - final_start,
+				  new_type);
 
 		real_updated_size += final_end - final_start;
 
+		/*
+		 * left range could be head or tail, so need to update
+		 * size at first.
+		 */
+		ei->size -= final_end - final_start;
 		if (ei->addr < final_start)
 			continue;
 		ei->addr = final_end;
-		ei->size -= final_end - final_start;
 	}
 	return real_updated_size;
 }
@@ -470,13 +473,13 @@ static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 			     unsigned new_type)
 {
-	return e820_update_range_map(&e820, start, size, old_type, new_type);
+	return __e820_update_range(&e820, start, size, old_type, new_type);
 }
 
 static u64 __init e820_update_range_saved(u64 start, u64 size,
 					  unsigned old_type, unsigned new_type)
 {
-	return e820_update_range_map(&e820_saved, start, size, old_type,
+	return __e820_update_range(&e820_saved, start, size, old_type,
 				     new_type);
 }
 

commit 5c0e6f035df983210e4d22213aed624ced502d3d
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Mar 12 13:07:23 2009 +0000

    x86: fix code paths used by update_mptable
    
    Impact: fix crashes under Xen due to unrobust e820 code
    
    find_e820_area_size() must return a properly distinguishable and
    out-of-bounds value when it fails, and -1UL does not meet that
    criteria on i386/PAE. Additionally, callers of the function must
    check against that value.
    
    early_reserve_e820() should be prepared for the region found to be
    outside of the addressable range on 32-bits.
    
    e820_update_range_map() should not blindly update e820, but should do
    all it work on the map it got a pointer passed for (which in 50% of the
    cases is &e820_saved). It must also not call e820_add_region(), as that
    again acts on e820 unconditionally.
    
    The issues were found when trying to make this option work in our Xen
    kernel (i.e. where some of the silent assumptions made in the code
    would not hold).
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    LKML-Reference: <49B9171B.76E4.0078.0@novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 508bec1cee27..3cf6681ac80d 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -421,7 +421,7 @@ static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
 					u64 size, unsigned old_type,
 					unsigned new_type)
 {
-	int i;
+	unsigned int i, x;
 	u64 real_updated_size = 0;
 
 	BUG_ON(old_type == new_type);
@@ -429,7 +429,7 @@ static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
 	if (size > (ULLONG_MAX - start))
 		size = ULLONG_MAX - start;
 
-	for (i = 0; i < e820.nr_map; i++) {
+	for (i = 0; i < e820x->nr_map; i++) {
 		struct e820entry *ei = &e820x->map[i];
 		u64 final_start, final_end;
 		if (ei->type != old_type)
@@ -446,14 +446,23 @@ static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
 		final_end = min(start + size, ei->addr + ei->size);
 		if (final_start >= final_end)
 			continue;
-		e820_add_region(final_start, final_end - final_start,
-					 new_type);
+
+		x = e820x->nr_map;
+		if (x == ARRAY_SIZE(e820x->map)) {
+			printk(KERN_ERR "Too many memory map entries!\n");
+			break;
+		}
+		e820x->map[x].addr = final_start;
+		e820x->map[x].size = final_end - final_start;
+		e820x->map[x].type = new_type;
+		e820x->nr_map++;
+
 		real_updated_size += final_end - final_start;
 
-		ei->size -= final_end - final_start;
 		if (ei->addr < final_start)
 			continue;
 		ei->addr = final_end;
+		ei->size -= final_end - final_start;
 	}
 	return real_updated_size;
 }
@@ -1020,8 +1029,8 @@ u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
 			continue;
 		return addr;
 	}
-	return -1UL;
 
+	return -1ULL;
 }
 
 /*
@@ -1034,13 +1043,22 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 	u64 start;
 
 	start = startt;
-	while (size < sizet)
+	while (size < sizet && (start + 1))
 		start = find_e820_area_size(start, &size, align);
 
 	if (size < sizet)
 		return 0;
 
+#ifdef CONFIG_X86_32
+	if (start >= MAXMEM)
+		return 0;
+	if (start + size > MAXMEM)
+		size = MAXMEM - start;
+#endif
+
 	addr = round_down(start + size - sizet, align);
+	if (addr < start)
+		return 0;
 	e820_update_range(addr, sizet, E820_RAM, E820_RESERVED);
 	e820_update_range_saved(addr, sizet, E820_RAM, E820_RESERVED);
 	printk(KERN_INFO "update e820 for early_reserve_e820\n");

commit 46cb27f5169d37be38be8e5729b9a0100e989fa8
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Feb 24 13:12:43 2009 -0800

    x86: check range in reserve_early()
    
    Impact: cleanup
    
    one 32-bit system reports:
    
    BIOS-provided physical RAM map:
     BIOS-e820: 0000000000000000 - 000000000009fc00 (usable)
     BIOS-e820: 000000000009fc00 - 00000000000a0000 (reserved)
     BIOS-e820: 00000000000f0000 - 0000000000100000 (reserved)
     BIOS-e820: 0000000000100000 - 000000001c000000 (usable)
     BIOS-e820: 00000000ffff0000 - 0000000100000000 (reserved)
    DMI 2.0 present.
    last_pfn = 0x1c000 max_arch_pfn = 0x100000
    kernel direct mapping tables up to 1c000000 @ 7000-c000
    ..
    RAMDISK: 1bc69000 - 1bfef4fa
    ..
    0MB HIGHMEM available.
    448MB LOWMEM available.
      mapped low ram: 0 - 1c000000
      low ram: 00000000 - 1c000000
      bootmap 00002000 - 00005800
    (9 early reservations) ==> bootmem [0000000000 - 001c000000]
      #0 [0000000000 - 0000001000]   BIOS data page ==> [0000000000 - 0000001000]
      #1 [0000001000 - 0000002000]    EX TRAMPOLINE ==> [0000001000 - 0000002000]
      #2 [0000006000 - 0000007000]       TRAMPOLINE ==> [0000006000 - 0000007000]
      #3 [0000400000 - 00009ed14c]    TEXT DATA BSS ==> [0000400000 - 00009ed14c]
      #4 [001bc69000 - 001bfef4fa]          RAMDISK ==> [001bc69000 - 001bfef4fa]
      #5 [00009ee000 - 00009f2000]    INIT_PG_TABLE ==> [00009ee000 - 00009f2000]
      #6 [000009f400 - 0000100000]    BIOS reserved ==> [000009f400 - 0000100000]
      #7 [0000007000 - 0000007000]          PGTABLE
      #8 [0000002000 - 0000006000]          BOOTMAP ==> [0000002000 - 0000006000]
    
    Notice the strange blank PGTABLE entry.
    
    The reason is init_pg_table is big enough, and zero range is called
    with init_memory_mapping/reserve_early().
    
    So try to check the range in reserve_early()
    
    v2: fix the reversed compare
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: nickpiggin@yahoo.com.au
    Cc: ink@jurassic.park.msu.ru
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e85826829cf2..508bec1cee27 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -858,6 +858,9 @@ void __init reserve_early_overlap_ok(u64 start, u64 end, char *name)
  */
 void __init reserve_early(u64 start, u64 end, char *name)
 {
+	if (start >= end)
+		return;
+
 	drop_overlaps_that_are_ok(start, end);
 	__reserve_early(start, end, name, 0);
 }

commit b2576e1d4408e134e2188c967b1f28af39cd79d4
Merge: 3cc8a5f4ba91 2150edc6c5cf
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 03:39:43 2009 -0500

    Merge branch 'linus' into release

commit b69edc76539be6a4aa39a22f85365fd4a3b3b9d2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 31 01:02:41 2008 +0100

    x86 hibernate: Mark ACPI NVS memory region at startup
    
    Introduce new initcall for marking the ACPI NVS memory at startup, so
    that it can be saved/restored during hibernation/resume.
    
    Based on a patch by Zhang Rui.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7aafeb5263ef..74c6a21fdc8c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -665,6 +665,27 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 }
 #endif
 
+#ifdef CONFIG_HIBERNATION
+/**
+ * Mark ACPI NVS memory region, so that we can save/restore it during
+ * hibernation and the subsequent resume.
+ */
+static int __init e820_mark_nvs_memory(void)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		if (ei->type == E820_NVS)
+			hibernate_nvs_register(ei->addr, ei->size);
+	}
+
+	return 0;
+}
+core_initcall(e820_mark_nvs_memory);
+#endif
+
 /*
  * Early reserved memory areas.
  */

commit 3e1e9002aa8b32bd4c95ac6c8fad376b7a8127fb
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Dec 8 00:50:22 2008 +0100

    x86: change static allocation of trampoline area
    
    Impact: fix trampoline sizing bug, save space
    
    While debugging a suspend-to-RAM related issue it occured to me that
    if the trampoline code had grown past 4 KB, we would have been
    allocating too little memory for it, since the 4 KB size of the
    trampoline is hardcoded into arch/x86/kernel/e820.c .  Change that
    by making the kernel compute the trampoline size and allocate as much
    memory as necessary.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7aafeb5263ef..65a13943e098 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -677,22 +677,6 @@ struct early_res {
 };
 static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{ 0, PAGE_SIZE, "BIOS data page" },	/* BIOS data page */
-#if defined(CONFIG_X86_64) && defined(CONFIG_X86_TRAMPOLINE)
-	{ TRAMPOLINE_BASE, TRAMPOLINE_BASE + 2 * PAGE_SIZE, "TRAMPOLINE" },
-#endif
-#if defined(CONFIG_X86_32) && defined(CONFIG_SMP)
-	/*
-	 * But first pinch a few for the stack/trampoline stuff
-	 * FIXME: Don't need the extra page at 4K, but need to fix
-	 * trampoline before removing it. (see the GDT stuff)
-	 */
-	{ PAGE_SIZE, PAGE_SIZE + PAGE_SIZE, "EX TRAMPOLINE" },
-	/*
-	 * Has to be in very low memory so we can execute
-	 * real-mode AP code.
-	 */
-	{ TRAMPOLINE_BASE, TRAMPOLINE_BASE + PAGE_SIZE, "TRAMPOLINE" },
-#endif
 	{}
 };
 

commit 1f98757776eafe31065be9118db6051afcf8643c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 1 10:17:22 2008 -0700

    x86: Clean up late e820 resource allocation
    
    This makes the late e820 resources use 'insert_resource_expand_to_fit()'
    instead of doing a 'reserve_region_with_split()', and also avoids
    marking them as IORESOURCE_BUSY.
    
    This results in us being perfectly happy to use pre-existing PCI
    resources even if they were marked as being in a reserved region, while
    still avoiding any _new_ allocations in the reserved regions.  It also
    makes for a simpler and more accurate resource tree.
    
    Example resource allocation from Jonathan Corbet, who has firmware that
    has an e820 reserved entry that covered a big range (e0000000-fed003ff),
    and that had various PCI resources in it set up by firmware.
    
    With old kernels, the reserved range would force us to re-allocate all
    pre-existing PCI resources, and his reserved range would end up looking
    like this:
    
            e0000000-fed003ff : reserved
              fec00000-fec00fff : IOAPIC 0
              fed00000-fed003ff : HPET 0
    
    where only the pre-allocated special regions (IOAPIC and HPET) were kept
    around.
    
    With 2.6.28-rc2, which uses 'reserve_region_with_split()', Jonathan's
    resource tree looked like this:
    
            e0000000-fe7fffff : reserved
            fe800000-fe8fffff : PCI Bus 0000:01
             fe800000-fe8fffff : reserved
            fe900000-fe9d9aff : reserved
            fe9d9b00-fe9d9bff : 0000:00:1f.3
             fe9d9b00-fe9d9bff : reserved
            fe9d9c00-fe9d9fff : 0000:00:1a.7
             fe9d9c00-fe9d9fff : reserved
            fe9da000-fe9dafff : 0000:00:03.3
             fe9da000-fe9dafff : reserved
            fe9db000-fe9dbfff : 0000:00:19.0
             fe9db000-fe9dbfff : reserved
            fe9dc000-fe9dffff : 0000:00:1b.0
             fe9dc000-fe9dffff : reserved
            fe9e0000-fe9fffff : 0000:00:19.0
             fe9e0000-fe9fffff : reserved
            fea00000-fea7ffff : 0000:00:02.0
             fea00000-fea7ffff : reserved
            fea80000-feafffff : 0000:00:02.1
             fea80000-feafffff : reserved
            feb00000-febfffff : 0000:00:02.0
             feb00000-febfffff : reserved
            fec00000-fed003ff : reserved
             fec00000-fec00fff : IOAPIC 0
             fed00000-fed003ff : HPET 0
    
    and because the reserved entry had been split and moved into the
    individual resources, and because it used the IORESOURCE_BUSY flag, the
    drivers that actually wanted to _use_ those resources couldn't actually
    attach to them:
    
            e1000e 0000:00:19.0: BAR 0: can't reserve mem region [0xfe9e0000-0xfe9fffff]
            HDA Intel 0000:00:1b.0: BAR 0: can't reserve mem region [0xfe9dc000-0xfe9dffff]
    
    with this patch, the resource tree instead becomes
    
            e0000000-fed003ff : reserved
              fe800000-fe8fffff : PCI Bus 0000:01
              fe9d9b00-fe9d9bff : 0000:00:1f.3
              fe9d9c00-fe9d9fff : 0000:00:1a.7
                fe9d9c00-fe9d9fff : ehci_hcd
              fe9da000-fe9dafff : 0000:00:03.3
              fe9db000-fe9dbfff : 0000:00:19.0
                fe9db000-fe9dbfff : e1000e
              fe9dc000-fe9dffff : 0000:00:1b.0
                fe9dc000-fe9dffff : ICH HD audio
              fe9e0000-fe9fffff : 0000:00:19.0
                fe9e0000-fe9fffff : e1000e
              fea00000-fea7ffff : 0000:00:02.0
              fea80000-feafffff : 0000:00:02.1
              feb00000-febfffff : 0000:00:02.0
              fec00000-fec00fff : IOAPIC 0
              fed00000-fed003ff : HPET 0
    
    ie the one reserved region now ends up surrounding all the PCI resources
    that were allocated inside of it by firmware, and because it is not
    marked BUSY, drivers have no problem attaching to the pre-allocated
    resources.
    
    Reported-and-tested-by: Jonathan Corbet <corbet@lwn.net>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Robert Hancock <hancockr@shaw.ca>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ce97bf3bed12..7aafeb5263ef 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1290,15 +1290,17 @@ void __init e820_reserve_resources(void)
 		res->start = e820.map[i].addr;
 		res->end = end;
 
-		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+		res->flags = IORESOURCE_MEM;
 
 		/*
 		 * don't register the region that could be conflicted with
 		 * pci device BAR resource and insert them later in
 		 * pcibios_resource_survey()
 		 */
-		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20))
+		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20)) {
+			res->flags |= IORESOURCE_BUSY;
 			insert_resource(&iomem_resource, res);
+		}
 		res++;
 	}
 
@@ -1318,7 +1320,7 @@ void __init e820_reserve_resources_late(void)
 	res = e820_res;
 	for (i = 0; i < e820.nr_map; i++) {
 		if (!res->parent && res->end)
-			reserve_region_with_split(&iomem_resource, res->start, res->end, res->name);
+			insert_resource_expand_to_fit(&iomem_resource, res);
 		res++;
 	}
 }

commit 6b2ada82101a08e2830fb29d7dc9b858be637dd4
Merge: 278429cff880 3b7ecb5d2ffd 77af7e3403e7 15160716eea5 1fa63a817d27 85462323555d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Oct 15 12:48:44 2008 +0200

    Merge branches 'core/softlockup', 'core/softirq', 'core/resources', 'core/printk' and 'core/misc' into core-v28-for-linus

commit 8308c54d7e312f7a03e2ce2057d0837e6fe3843f
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Thu Sep 11 01:31:50 2008 -0700

    generic: redefine resource_size_t as phys_addr_t
    
    There's no good reason why a resource_size_t shouldn't just be a
    physical address, so simply redefine it in terms of phys_addr_t.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 66e48aa2dd1b..477f4bb7e552 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1276,12 +1276,10 @@ void __init e820_reserve_resources(void)
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
 	for (i = 0; i < e820.nr_map; i++) {
 		end = e820.map[i].addr + e820.map[i].size - 1;
-#ifndef CONFIG_RESOURCES_64BIT
-		if (end > 0x100000000ULL) {
+		if (end != (resource_size_t)end) {
 			res++;
 			continue;
 		}
-#endif
 		res->name = e820_type_to_string(e820.map[i].type);
 		res->start = e820.map[i].addr;
 		res->end = end;

commit 59c37bf8924c30fbac7ebb66a1d92dcb9f05f6b1
Merge: ec70cae86986 adee14b2e155
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Sep 10 14:00:45 2008 +0200

    Merge commit 'v2.6.27-rc6' into x86/unify-cpu-detect
    
    Conflicts:
            arch/x86/kernel/cpu/amd.c
            arch/x86/kernel/cpu/common.c
            arch/x86/kernel/cpu/common_64.c
            arch/x86/kernel/cpu/feature_names.c
            include/asm-x86/cpufeature.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit d6be118a97ce51ca84035270f91c2bccecbfac5f
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Sep 9 09:56:08 2008 -0400

    x86: fix memmap=exactmap boot argument
    
    When using kdump modifying the e820 map is yielding strange results.
    
    For example starting with
    
     BIOS-provided physical RAM map:
     BIOS-e820: 0000000000000100 - 0000000000093400 (usable)
     BIOS-e820: 0000000000093400 - 00000000000a0000 (reserved)
     BIOS-e820: 0000000000100000 - 000000003fee0000 (usable)
     BIOS-e820: 000000003fee0000 - 000000003fef3000 (ACPI data)
     BIOS-e820: 000000003fef3000 - 000000003ff80000 (ACPI NVS)
     BIOS-e820: 000000003ff80000 - 0000000040000000 (reserved)
     BIOS-e820: 00000000e0000000 - 00000000f0000000 (reserved)
     BIOS-e820: 00000000fec00000 - 00000000fec10000 (reserved)
     BIOS-e820: 00000000fee00000 - 00000000fee01000 (reserved)
     BIOS-e820: 00000000ff000000 - 0000000100000000 (reserved)
    
    and booting with args
    
    memmap=exactmap memmap=640K@0K memmap=5228K@16384K memmap=125188K@22252K memmap=76K#1047424K memmap=564K#1047500K
    
    resulted in:
    
     user-defined physical RAM map:
     user: 0000000000000000 - 0000000000093400 (usable)
     user: 0000000000093400 - 00000000000a0000 (reserved)
     user: 0000000000100000 - 000000003fee0000 (usable)
     user: 000000003fee0000 - 000000003fef3000 (ACPI data)
     user: 000000003fef3000 - 000000003ff80000 (ACPI NVS)
     user: 000000003ff80000 - 0000000040000000 (reserved)
     user: 00000000e0000000 - 00000000f0000000 (reserved)
     user: 00000000fec00000 - 00000000fec10000 (reserved)
     user: 00000000fee00000 - 00000000fee01000 (reserved)
     user: 00000000ff000000 - 0000000100000000 (reserved)
    
    But should have resulted in:
    
     user-defined physical RAM map:
     user: 0000000000000000 - 00000000000a0000 (usable)
     user: 0000000001000000 - 000000000151b000 (usable)
     user: 00000000015bb000 - 0000000008ffc000 (usable)
     user: 000000003fee0000 - 000000003ff80000 (ACPI data)
    
    This is happening because of an improper usage of strcmp() in the
    e820 parsing code.  The strcmp() always returns !0 and never resets the
    value for e820.nr_map and returns an incorrect user-defined map.
    
    This patch fixes the problem.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 9af89078f7bb..66e48aa2dd1b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1203,7 +1203,7 @@ static int __init parse_memmap_opt(char *p)
 	if (!p)
 		return -EINVAL;
 
-	if (!strcmp(p, "exactmap")) {
+	if (!strncmp(p, "exactmap", 8)) {
 #ifdef CONFIG_CRASH_DUMP
 		/*
 		 * If we are doing a crash dump, we still need to know

commit fac8f1e4f99dff7a0c3a929f327d66f46de6fa21
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Sep 4 20:59:22 2008 +0200

    x86: split e820 reserved entries record to late, v7
    
    try to insert_resource second time, by expanding the resource...
    
    for case: e820 reserved entry is partially overlapped with bar res...
    
    hope it will never happen
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a7a71339bfb0..e24d1bc47b46 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1320,7 +1320,7 @@ void __init e820_reserve_resources_late(void)
 	res = e820_res;
 	for (i = 0; i < e820.nr_map; i++) {
 		if (!res->parent && res->end)
-			insert_resource(&iomem_resource, res);
+			reserve_region_with_split(&iomem_resource, res->start, res->end, res->name);
 		res++;
 	}
 }

commit a5444d15b611cf2ffe2bc52aaf11f2ac51882f89
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Aug 29 08:09:23 2008 +0200

    x86: split e820 reserved entries record to late v4
    
    this one replaces:
    
    | commit a2bd7274b47124d2fc4dfdb8c0591f545ba749dd
    | Author: Yinghai Lu <yhlu.kernel@gmail.com>
    | Date:   Mon Aug 25 00:56:08 2008 -0700
    |
    |    x86: fix HPET regression in 2.6.26 versus 2.6.25, check hpet against BAR, v3
    
    v2: insert e820 reserve resources before pnp_system_init
    v3: fix merging problem in tip/x86/core
    v4: address Linus's review about comments and condition in _late()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 523d6c5605d1..a7a71339bfb0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1271,12 +1271,12 @@ static inline const char *e820_type_to_string(int e820_type)
 /*
  * Mark e820 reserved areas as busy for the resource manager.
  */
-struct resource __initdata *e820_res;
+static struct resource __initdata *e820_res;
 void __init e820_reserve_resources(void)
 {
 	int i;
-	u64 end;
 	struct resource *res;
+	u64 end;
 
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
 	e820_res = res;
@@ -1293,6 +1293,12 @@ void __init e820_reserve_resources(void)
 		res->end = end;
 
 		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
+		/*
+		 * don't register the region that could be conflicted with
+		 * pci device BAR resource and insert them later in
+		 * pcibios_resource_survey()
+		 */
 		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20))
 			insert_resource(&iomem_resource, res);
 		res++;
@@ -1313,7 +1319,7 @@ void __init e820_reserve_resources_late(void)
 
 	res = e820_res;
 	for (i = 0; i < e820.nr_map; i++) {
-		if (e820.map[i].type == E820_RESERVED && res->start >= (1ULL<<20))
+		if (!res->parent && res->end)
 			insert_resource(&iomem_resource, res);
 		res++;
 	}

commit 58f7c98850a226d3fb05b1095af9f7c4ea3507ba
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Aug 28 13:52:25 2008 -0700

    x86: split e820 reserved entries record to late v2
    
    so could let BAR res register at first, or even pnp.
    
    v2: insert e820 reserve resources before pnp_system_init
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 291e6cd9f9c0..523d6c5605d1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1271,13 +1271,15 @@ static inline const char *e820_type_to_string(int e820_type)
 /*
  * Mark e820 reserved areas as busy for the resource manager.
  */
+struct resource __initdata *e820_res;
 void __init e820_reserve_resources(void)
 {
 	int i;
-	struct resource *res;
 	u64 end;
+	struct resource *res;
 
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
+	e820_res = res;
 	for (i = 0; i < e820.nr_map; i++) {
 		end = e820.map[i].addr + e820.map[i].size - 1;
 #ifndef CONFIG_RESOURCES_64BIT
@@ -1291,7 +1293,8 @@ void __init e820_reserve_resources(void)
 		res->end = end;
 
 		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-		insert_resource(&iomem_resource, res);
+		if (e820.map[i].type != E820_RESERVED || res->start < (1ULL<<20))
+			insert_resource(&iomem_resource, res);
 		res++;
 	}
 
@@ -1303,6 +1306,19 @@ void __init e820_reserve_resources(void)
 	}
 }
 
+void __init e820_reserve_resources_late(void)
+{
+	int i;
+	struct resource *res;
+
+	res = e820_res;
+	for (i = 0; i < e820.nr_map; i++) {
+		if (e820.map[i].type == E820_RESERVED && res->start >= (1ULL<<20))
+			insert_resource(&iomem_resource, res);
+		res++;
+	}
+}
+
 char *__init default_machine_specific_memory_setup(void)
 {
 	char *who = "BIOS-e820";

commit 671eef85a3e885dff4ce210d8774ad50a91d5967
Author: Cihula, Joseph <joseph.cihula@intel.com>
Date:   Wed Aug 20 16:43:07 2008 -0700

    x86, e820: add support for AddressRangeUnusuable ACPI memory type
    
    Add support for the E820_UNUSABLE memory type, which is defined in
    Revision 3.0b (Oct.  10, 2006) of the ACPI Specification on p.  394 Table
    14-1:
    
      AddressRangeUnusuable This range of address contains memory in which
      errors have been detected.  This range must not be used by the OSPM.
    
    Signed-off-by: Joseph Cihula <joseph.cihula@intel.com>
    Signed-off-by: Shane Wang <shane.wang@intel.com>
    Signed-off-by: Gang Wei <gang.wei@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 9af89078f7bb..291e6cd9f9c0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -148,6 +148,9 @@ void __init e820_print_map(char *who)
 		case E820_NVS:
 			printk(KERN_CONT "(ACPI NVS)\n");
 			break;
+		case E820_UNUSABLE:
+			printk("(unusable)\n");
+			break;
 		default:
 			printk(KERN_CONT "type %u\n", e820.map[i].type);
 			break;
@@ -1260,6 +1263,7 @@ static inline const char *e820_type_to_string(int e820_type)
 	case E820_RAM:	return "System RAM";
 	case E820_ACPI:	return "ACPI Tables";
 	case E820_NVS:	return "ACPI Non-volatile Storage";
+	case E820_UNUSABLE:	return "Unusable memory";
 	default:	return "reserved";
 	}
 }

commit 3c9cb6de1e5ad37d1558fdb0d9d2bed5a7bac0d9
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Jul 19 02:07:25 2008 -0700

    x86: introduce x86_quirks
    
    introduce x86_quirks array of boot-time quirk methods.
    
    No change in functionality intended.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 6c60aeaac15f..9af89078f7bb 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1299,11 +1299,6 @@ void __init e820_reserve_resources(void)
 	}
 }
 
-/*
- * Non-standard memory setup can be specified via this quirk:
- */
-char * (*arch_memory_setup_quirk)(void);
-
 char *__init default_machine_specific_memory_setup(void)
 {
 	char *who = "BIOS-e820";
@@ -1344,8 +1339,8 @@ char *__init default_machine_specific_memory_setup(void)
 
 char *__init __attribute__((weak)) machine_specific_memory_setup(void)
 {
-	if (arch_memory_setup_quirk) {
-		char *who = arch_memory_setup_quirk();
+	if (x86_quirks->arch_memory_setup) {
+		char *who = x86_quirks->arch_memory_setup();
 
 		if (who)
 			return who;

commit 5f1f2b3d9dbaee82cd532f28da459adcbf611499
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Fri Jul 18 16:16:23 2008 -0700

    x86: improve debug printout: add target bootmem range in early_res_to_bootmem()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index df1b32fa88db..6c60aeaac15f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -877,7 +877,8 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++)
 		count++;
 
-	printk(KERN_INFO "(%d early reservations) ==> bootmem\n", count);
+	printk(KERN_INFO "(%d early reservations) ==> bootmem [%010llx - %010llx]\n",
+			 count, start, end);
 	for (i = 0; i < count; i++) {
 		struct early_res *r = &early_res[i];
 		printk(KERN_INFO "  #%d [%010llx - %010llx] %16s", i,

commit e5849e71adcbb774ce40f09c1bcb48acca3b6da7
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Fri Jul 18 17:28:40 2008 -0700

    x86: remove arch_get_ram_range
    
    no user now
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 28c29180b380..df1b32fa88db 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1367,24 +1367,3 @@ void __init setup_memory_map(void)
 	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
 	e820_print_map(who);
 }
-
-#ifdef CONFIG_X86_64
-int __init arch_get_ram_range(int slot, u64 *addr, u64 *size)
-{
-	int i;
-
-	if (slot < 0 || slot >= e820.nr_map)
-		return -1;
-	for (i = slot; i < e820.nr_map; i++) {
-		if (e820.map[i].type != E820_RAM)
-			continue;
-		break;
-	}
-	if (i == e820.nr_map || e820.map[i].addr > (max_pfn << PAGE_SHIFT))
-		return -1;
-	*addr = e820.map[i].addr;
-	*size = min_t(u64, e820.map[i].size + e820.map[i].addr,
-		max_pfn << PAGE_SHIFT) - *addr;
-	return i + 1;
-}
-#endif

commit 7b479becdb8c1fb4ff6fbb2a4076c471c737b54c
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Jul 12 22:57:07 2008 -0700

    x86, e820: remove end_user_pfn
    
    end_user_pfn used to modify the meaning of the e820 maps.
    
    Now that all e820 operations are cleaned up, unified, tightened up,
    the e820 map always get updated to reality, we don't need to keep
    this secondary mechanism anymore.
    
    If you hit this commit in bisection it means something slipped through.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a5383ae2cbe3..28c29180b380 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1048,11 +1048,6 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 # define MAX_ARCH_PFN MAXMEM>>PAGE_SHIFT
 #endif
 
-/*
- * Last pfn which the user wants to use.
- */
-unsigned long __initdata end_user_pfn = MAX_ARCH_PFN;
-
 /*
  * Find the highest page frame number we have available
  */
@@ -1085,8 +1080,6 @@ static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 
 	if (last_pfn > max_arch_pfn)
 		last_pfn = max_arch_pfn;
-	if (last_pfn > end_user_pfn)
-		last_pfn = end_user_pfn;
 
 	printk(KERN_INFO "last_pfn = %#lx max_arch_pfn = %#lx\n",
 			 last_pfn, max_arch_pfn);
@@ -1131,12 +1124,6 @@ int __init e820_find_active_region(const struct e820entry *ei,
 	if (*ei_endpfn > last_pfn)
 		*ei_endpfn = last_pfn;
 
-	/* Obey end_user_pfn to save on memmap */
-	if (*ei_startpfn >= end_user_pfn)
-		return 0;
-	if (*ei_endpfn > end_user_pfn)
-		*ei_endpfn = end_user_pfn;
-
 	return 1;
 }
 
@@ -1201,7 +1188,6 @@ static int __init parse_memopt(char *p)
 
 	userdef = 1;
 	mem_size = memparse(p, &p);
-	end_user_pfn = mem_size>>PAGE_SHIFT;
 	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
 	return 0;
@@ -1245,10 +1231,9 @@ static int __init parse_memmap_opt(char *p)
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
 		e820_add_region(start_at, mem_size, E820_RESERVED);
-	} else {
-		end_user_pfn = (mem_size >> PAGE_SHIFT);
+	} else
 		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
-	}
+
 	return *p == '\0' ? 0 : -EINVAL;
 }
 early_param("memmap", parse_memmap_opt);

commit 6c82a000a29b93541b5b7db597a083c069755cc9
Merge: 5b4d2386c23e 39415a440ecc
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 11 21:22:18 2008 +0200

    Merge branch 'x86/generalize-visws' into x86/core

commit f361a450bf1ad14e2b003217dbf3958638631265
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Jul 10 20:38:26 2008 -0700

    x86: introduce max_low_pfn_mapped for 64-bit
    
    when more than 4g memory is installed, don't map the big hole below 4g.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3451e0b3f324..9f5002e0b35c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1056,7 +1056,7 @@ unsigned long __initdata end_user_pfn = MAX_ARCH_PFN;
 /*
  * Find the highest page frame number we have available
  */
-unsigned long __init e820_end(void)
+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)
 {
 	int i;
 	unsigned long last_pfn = 0;
@@ -1064,12 +1064,21 @@ unsigned long __init e820_end(void)
 
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
+		unsigned long start_pfn;
 		unsigned long end_pfn;
 
-		if (ei->type != E820_RAM)
+		if (ei->type != type)
 			continue;
 
+		start_pfn = ei->addr >> PAGE_SHIFT;
 		end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
+
+		if (start_pfn >= limit_pfn)
+			continue;
+		if (end_pfn > limit_pfn) {
+			last_pfn = limit_pfn;
+			break;
+		}
 		if (end_pfn > last_pfn)
 			last_pfn = end_pfn;
 	}
@@ -1083,7 +1092,15 @@ unsigned long __init e820_end(void)
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }
+unsigned long __init e820_end_of_ram_pfn(void)
+{
+	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
+}
 
+unsigned long __init e820_end_of_low_ram_pfn(void)
+{
+	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
+}
 /*
  * Finds an active region in the address range from start_pfn to last_pfn and
  * returns its range in ei_startpfn and ei_endpfn for the e820 entry.
@@ -1206,7 +1223,7 @@ static int __init parse_memmap_opt(char *p)
 		 * the real mem size before original memory map is
 		 * reset.
 		 */
-		saved_max_pfn = e820_end();
+		saved_max_pfn = e820_end_of_ram_pfn();
 #endif
 		e820.nr_map = 0;
 		userdef = 1;

commit 69a7704d7a80b2563278a0c55c2ca6d6202280dc
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Jul 10 04:17:00 2008 -0700

    x86: e820: user-defined memory maps: remove the range instead of update it to reserved
    
    also let mem= to print out modified e820 map too
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Bernhard Walle <bwalle@suse.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 9836a079cfd9..3451e0b3f324 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1165,6 +1165,8 @@ static void early_panic(char *msg)
 	panic(msg);
 }
 
+static int userdef __initdata;
+
 /* "mem=nopentium" disables the 4MB page tables. */
 static int __init parse_memopt(char *p)
 {
@@ -1180,17 +1182,15 @@ static int __init parse_memopt(char *p)
 	}
 #endif
 
+	userdef = 1;
 	mem_size = memparse(p, &p);
 	end_user_pfn = mem_size>>PAGE_SHIFT;
-	e820_update_range(mem_size, ULLONG_MAX - mem_size,
-		E820_RAM, E820_RESERVED);
+	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 
 	return 0;
 }
 early_param("mem", parse_memopt);
 
-static int userdef __initdata;
-
 static int __init parse_memmap_opt(char *p)
 {
 	char *oldp;
@@ -1230,8 +1230,7 @@ static int __init parse_memmap_opt(char *p)
 		e820_add_region(start_at, mem_size, E820_RESERVED);
 	} else {
 		end_user_pfn = (mem_size >> PAGE_SHIFT);
-		e820_update_range(mem_size, ULLONG_MAX - mem_size,
-			E820_RAM, E820_RESERVED);
+		e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
 	}
 	return *p == '\0' ? 0 : -EINVAL;
 }

commit 3b33553badcde952adcf3b3ba5faae38d7d85071
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jul 10 17:30:40 2008 +0200

    x86: add early quirk support
    
    Add early quirks support.
    
    In preparation of enabling the generic architecture to boot on a VISWS.
    
    This will allow us to remove the VISWS subarch and all its complications.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 9836a079cfd9..269d367d2ace 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1297,6 +1297,11 @@ void __init e820_reserve_resources(void)
 	}
 }
 
+/*
+ * Non-standard memory setup can be specified via this quirk:
+ */
+char * (*arch_memory_setup_quirk)(void);
+
 char *__init default_machine_specific_memory_setup(void)
 {
 	char *who = "BIOS-e820";
@@ -1337,6 +1342,12 @@ char *__init default_machine_specific_memory_setup(void)
 
 char *__init __attribute__((weak)) machine_specific_memory_setup(void)
 {
+	if (arch_memory_setup_quirk) {
+		char *who = arch_memory_setup_quirk();
+
+		if (who)
+			return who;
+	}
 	return default_machine_specific_memory_setup();
 }
 

commit 3d43ecd286e442792f2e899e6e06eb23ab3d99f6
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Wed Jul 9 20:17:50 2008 -0700

    x86: make e820_end return end_of_ram again for 64bit
    
    even on 64bit systems with less than 4G RAM, we can now use fixmap
    to handle acpi SIT near end of ram.
    
    change e820_end to e820_end_of_ram again?
    or e820_ram_pfn?
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 66fd5bd78318..9836a079cfd9 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1066,10 +1066,8 @@ unsigned long __init e820_end(void)
 		struct e820entry *ei = &e820.map[i];
 		unsigned long end_pfn;
 
-#ifdef CONFIG_X86_32
 		if (ei->type != E820_RAM)
 			continue;
-#endif
 
 		end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
 		if (end_pfn > last_pfn)

commit a737abd11ac4eb9f4226fa8c9f1d9b5be12a96c1
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Sat Jul 5 15:53:39 2008 +0400

    x86: e820 memmap - add checking for NULL early param
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: akpm@linux-foundation.org
    Cc: andi@firstfloor.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 292ebc7fe4d0..66fd5bd78318 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1198,6 +1198,9 @@ static int __init parse_memmap_opt(char *p)
 	char *oldp;
 	u64 start_at, mem_size;
 
+	if (!p)
+		return -EINVAL;
+
 	if (!strcmp(p, "exactmap")) {
 #ifdef CONFIG_CRASH_DUMP
 		/*

commit c22d4c1885130db9c07f6441ab461208a1ba16b2
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Wed Jul 9 03:01:14 2008 -0700

    x86: make e820_end return max ram type only for 32 bit
    
    to avoid warning from find_low_pfn_range for high pages size etc
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 2e08619a9c5c..292ebc7fe4d0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1066,6 +1066,11 @@ unsigned long __init e820_end(void)
 		struct e820entry *ei = &e820.map[i];
 		unsigned long end_pfn;
 
+#ifdef CONFIG_X86_32
+		if (ei->type != E820_RAM)
+			continue;
+#endif
+
 		end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
 		if (end_pfn > last_pfn)
 			last_pfn = end_pfn;

commit 2dc807b37b7b8c7df445513ad2b415df4ebcaf6d
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jul 8 18:56:38 2008 -0700

    x86: make max_pfn cover acpi table below 4g
    
    When system have 4g less ram installed, and acpi table sit
    near end of ram, make max_pfn cover them too,
    so 64bit kernel don't need to mess up fixmap.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: "Suresh Siddha" <suresh.b.siddha@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e07d4019e266..2e08619a9c5c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1056,12 +1056,20 @@ unsigned long __initdata end_user_pfn = MAX_ARCH_PFN;
 /*
  * Find the highest page frame number we have available
  */
-unsigned long __init e820_end_of_ram(void)
+unsigned long __init e820_end(void)
 {
-	unsigned long last_pfn;
+	int i;
+	unsigned long last_pfn = 0;
 	unsigned long max_arch_pfn = MAX_ARCH_PFN;
 
-	last_pfn = find_max_pfn_with_active_regions();
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		unsigned long end_pfn;
+
+		end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
+		if (end_pfn > last_pfn)
+			last_pfn = end_pfn;
+	}
 
 	if (last_pfn > max_arch_pfn)
 		last_pfn = max_arch_pfn;
@@ -1192,9 +1200,7 @@ static int __init parse_memmap_opt(char *p)
 		 * the real mem size before original memory map is
 		 * reset.
 		 */
-		e820_register_active_regions(0, 0, -1UL);
-		saved_max_pfn = e820_end_of_ram();
-		remove_all_active_ranges();
+		saved_max_pfn = e820_end();
 #endif
 		e820.nr_map = 0;
 		userdef = 1;

commit fc9036ea1a4b14229788e6df3936b451a6abac98
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Jul 3 11:39:00 2008 -0700

    x86: let early_reserve_e820 update e820_saved too
    
    so when it is called after early_param, e820_saved get updated too.
    esp for mpc update.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Bernhard Walle <bwalle@suse.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 13e32986cb5f..e07d4019e266 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -414,8 +414,9 @@ static int __init append_e820_map(struct e820entry *biosmap, int nr_map)
 	return __append_e820_map(biosmap, nr_map);
 }
 
-u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
-				unsigned new_type)
+static u64 __init e820_update_range_map(struct e820map *e820x, u64 start,
+					u64 size, unsigned old_type,
+					unsigned new_type)
 {
 	int i;
 	u64 real_updated_size = 0;
@@ -426,7 +427,7 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 		size = ULLONG_MAX - start;
 
 	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
+		struct e820entry *ei = &e820x->map[i];
 		u64 final_start, final_end;
 		if (ei->type != old_type)
 			continue;
@@ -454,6 +455,19 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 	return real_updated_size;
 }
 
+u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
+			     unsigned new_type)
+{
+	return e820_update_range_map(&e820, start, size, old_type, new_type);
+}
+
+static u64 __init e820_update_range_saved(u64 start, u64 size,
+					  unsigned old_type, unsigned new_type)
+{
+	return e820_update_range_map(&e820_saved, start, size, old_type,
+				     new_type);
+}
+
 /* make e820 not cover the range */
 u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 			     int checktype)
@@ -503,6 +517,15 @@ void __init update_e820(void)
 	printk(KERN_INFO "modified physical RAM map:\n");
 	e820_print_map("modified");
 }
+static void __init update_e820_saved(void)
+{
+	int nr_map;
+
+	nr_map = e820_saved.nr_map;
+	if (sanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map), &nr_map))
+		return;
+	e820_saved.nr_map = nr_map;
+}
 #define MAX_GAP_END 0x100000000ull
 /*
  * Search for a gap in the e820 memory space from start_addr to end_addr.
@@ -1007,8 +1030,10 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 
 	addr = round_down(start + size - sizet, align);
 	e820_update_range(addr, sizet, E820_RAM, E820_RESERVED);
+	e820_update_range_saved(addr, sizet, E820_RAM, E820_RESERVED);
 	printk(KERN_INFO "update e820 for early_reserve_e820\n");
 	update_e820();
+	update_e820_saved();
 
 	return addr;
 }

commit 0be15526beb4c228e0477221c62ec8ab0fc7440f
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Thu Jul 3 11:35:37 2008 -0700

    x86: move saving e820_saved to setup_memory_map
    
    so other path that will override memory_setup or
    machine_specific_memory_setup could have e820_saved too.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Bernhard Walle <bwalle@suse.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index fc1d579f212b..13e32986cb5f 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1294,8 +1294,6 @@ char *__init default_machine_specific_memory_setup(void)
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
 
-	memcpy(&e820_saved, &e820, sizeof(struct e820map));
-
 	/* In case someone cares... */
 	return who;
 }
@@ -1313,8 +1311,12 @@ char * __init __attribute__((weak)) memory_setup(void)
 
 void __init setup_memory_map(void)
 {
+	char *who;
+
+	who = memory_setup();
+	memcpy(&e820_saved, &e820, sizeof(struct e820map));
 	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
-	e820_print_map(memory_setup());
+	e820_print_map(who);
 }
 
 #ifdef CONFIG_X86_64

commit 5dfcf14d5b28174f94cbe9b4fb35d415db61c64a
Author: Bernhard Walle <bwalle@suse.de>
Date:   Fri Jun 27 13:12:55 2008 +0200

    x86: use FIRMWARE_MEMMAP on x86/E820
    
    This patch uses the /sys/firmware/memmap interface provided in the last patch
    on the x86 architecture when E820 is used. The patch copies the E820
    memory map very early, and registers the E820 map afterwards via
    firmware_map_add_early().
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Acked-by: Greg KH <gregkh@suse.de>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>
    Cc: kexec@lists.infradead.org
    Cc: yhlu.kernel@gmail.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d0335853ff52..fc1d579f212b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -19,6 +19,7 @@
 #include <linux/mm.h>
 #include <linux/pfn.h>
 #include <linux/suspend.h>
+#include <linux/firmware-map.h>
 
 #include <asm/pgtable.h>
 #include <asm/page.h>
@@ -27,7 +28,22 @@
 #include <asm/setup.h>
 #include <asm/trampoline.h>
 
+/*
+ * The e820 map is the map that gets modified e.g. with command line parameters
+ * and that is also registered with modifications in the kernel resource tree
+ * with the iomem_resource as parent.
+ *
+ * The e820_saved is directly saved after the BIOS-provided memory map is
+ * copied. It doesn't get modified afterwards. It's registered for the
+ * /sys/firmware/memmap interface.
+ *
+ * That memory map is not modified and is used as base for kexec. The kexec'd
+ * kernel should get the same memory map as the firmware provides. Then the
+ * user can e.g. boot the original kernel with mem=1G while still booting the
+ * next kernel with full memory.
+ */
 struct e820map e820;
+struct e820map e820_saved;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -1198,6 +1214,17 @@ void __init finish_e820_parsing(void)
 	}
 }
 
+static inline const char *e820_type_to_string(int e820_type)
+{
+	switch (e820_type) {
+	case E820_RESERVED_KERN:
+	case E820_RAM:	return "System RAM";
+	case E820_ACPI:	return "ACPI Tables";
+	case E820_NVS:	return "ACPI Non-volatile Storage";
+	default:	return "reserved";
+	}
+}
+
 /*
  * Mark e820 reserved areas as busy for the resource manager.
  */
@@ -1209,13 +1236,6 @@ void __init e820_reserve_resources(void)
 
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
 	for (i = 0; i < e820.nr_map; i++) {
-		switch (e820.map[i].type) {
-		case E820_RESERVED_KERN:
-		case E820_RAM:	res->name = "System RAM"; break;
-		case E820_ACPI:	res->name = "ACPI Tables"; break;
-		case E820_NVS:	res->name = "ACPI Non-volatile Storage"; break;
-		default:	res->name = "reserved";
-		}
 		end = e820.map[i].addr + e820.map[i].size - 1;
 #ifndef CONFIG_RESOURCES_64BIT
 		if (end > 0x100000000ULL) {
@@ -1223,6 +1243,7 @@ void __init e820_reserve_resources(void)
 			continue;
 		}
 #endif
+		res->name = e820_type_to_string(e820.map[i].type);
 		res->start = e820.map[i].addr;
 		res->end = end;
 
@@ -1230,6 +1251,13 @@ void __init e820_reserve_resources(void)
 		insert_resource(&iomem_resource, res);
 		res++;
 	}
+
+	for (i = 0; i < e820_saved.nr_map; i++) {
+		struct e820entry *entry = &e820_saved.map[i];
+		firmware_map_add_early(entry->addr,
+			entry->addr + entry->size - 1,
+			e820_type_to_string(entry->type));
+	}
 }
 
 char *__init default_machine_specific_memory_setup(void)
@@ -1266,6 +1294,8 @@ char *__init default_machine_specific_memory_setup(void)
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
 	}
 
+	memcpy(&e820_saved, &e820, sizeof(struct e820map));
+
 	/* In case someone cares... */
 	return who;
 }

commit 4fcc545a7479135332f511a54611820c9f4208a0
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jul 1 20:03:11 2008 -0700

    x86: make early_res_to_bootmem print out less 80 width chars
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index b01fa0d0dc7c..d0335853ff52 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -841,7 +841,7 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 	printk(KERN_INFO "(%d early reservations) ==> bootmem\n", count);
 	for (i = 0; i < count; i++) {
 		struct early_res *r = &early_res[i];
-		printk(KERN_INFO "  #%d [ %010llx - %010llx ] %16s", i,
+		printk(KERN_INFO "  #%d [%010llx - %010llx] %16s", i,
 			r->start, r->end, r->name);
 		final_start = max(start, r->start);
 		final_end = min(end, r->end);
@@ -849,7 +849,7 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 			printk(KERN_CONT "\n");
 			continue;
 		}
-		printk(KERN_CONT " ===> [ %010llx - %010llx ]\n",
+		printk(KERN_CONT " ==> [%010llx - %010llx]\n",
 			final_start, final_end);
 		reserve_bootmem_generic(final_start, final_end - final_start,
 				BOOTMEM_DEFAULT);

commit dc8e8120ad291074a5fb93cfb0418466c62f6019
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jul 1 20:02:16 2008 -0700

    x86: change copy_e820_map to append_e820_map
    
    so it has a more meaningful name.
    also change it to static.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index d3f6c5f6d3b1..b01fa0d0dc7c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -360,7 +360,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	return 0;
 }
 
-static int __init __copy_e820_map(struct e820entry *biosmap, int nr_map)
+static int __init __append_e820_map(struct e820entry *biosmap, int nr_map)
 {
 	while (nr_map) {
 		u64 start = biosmap->addr;
@@ -389,13 +389,13 @@ static int __init __copy_e820_map(struct e820entry *biosmap, int nr_map)
  * will have given us a memory map that we can use to properly
  * set up memory.  If we aren't, we'll fake a memory map.
  */
-int __init copy_e820_map(struct e820entry *biosmap, int nr_map)
+static int __init append_e820_map(struct e820entry *biosmap, int nr_map)
 {
 	/* Only one memory region (or negative)? Ignore it */
 	if (nr_map < 2)
 		return -1;
 
-	return __copy_e820_map(biosmap, nr_map);
+	return __append_e820_map(biosmap, nr_map);
 }
 
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
@@ -583,7 +583,7 @@ void __init parse_e820_ext(struct setup_data *sdata, unsigned long pa_data)
 	if (map_len > PAGE_SIZE)
 		sdata = early_ioremap(pa_data, map_len);
 	extmap = (struct e820entry *)(sdata->data);
-	__copy_e820_map(extmap, entries);
+	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
 	if (map_len > PAGE_SIZE)
 		early_iounmap(sdata, map_len);
@@ -1247,7 +1247,8 @@ char *__init default_machine_specific_memory_setup(void)
 			ARRAY_SIZE(boot_params.e820_map),
 			&new_nr);
 	boot_params.e820_entries = new_nr;
-	if (copy_e820_map(boot_params.e820_map, boot_params.e820_entries) < 0) {
+	if (append_e820_map(boot_params.e820_map, boot_params.e820_entries)
+	  < 0) {
 		u64 mem_size;
 
 		/* compare results from other methods and take the greater */

commit fd6493e16625b92a506fba13deda31c0be5f1cd4
Author: Alok Kataria <akataria@vmware.com>
Date:   Wed Jun 25 11:02:42 2008 -0700

    x86: cleanup e820_setup_gap(), v2
    
    e820_search_gap also take a end_addr parameter to limit search from
    start_addr to end_addr.
    
    Signed-off-by: AloK N Kataria <akataria@vmware.com>
    Acked-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: "lenb@kernel.org" <lenb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e03b89ac8f2b..d3f6c5f6d3b1 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -487,17 +487,19 @@ void __init update_e820(void)
 	printk(KERN_INFO "modified physical RAM map:\n");
 	e820_print_map("modified");
 }
-
+#define MAX_GAP_END 0x100000000ull
 /*
- * Search for a gap in the e820 memory space from start_addr to 2^32.
+ * Search for a gap in the e820 memory space from start_addr to end_addr.
  */
 __init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
-		unsigned long start_addr)
+		unsigned long start_addr, unsigned long long end_addr)
 {
-	unsigned long long last = 0x100000000ull;
+	unsigned long long last;
 	int i = e820.nr_map;
 	int found = 0;
 
+	last = (end_addr && end_addr < MAX_GAP_END) ? end_addr : MAX_GAP_END;
+
 	while (--i >= 0) {
 		unsigned long long start = e820.map[i].addr;
 		unsigned long long end = start + e820.map[i].size;
@@ -537,7 +539,7 @@ __init void e820_setup_gap(void)
 
 	gapstart = 0x10000000;
 	gapsize = 0x400000;
-	found  = e820_search_gap(&gapstart, &gapsize, 0);
+	found  = e820_search_gap(&gapstart, &gapsize, 0, MAX_GAP_END);
 
 #ifdef CONFIG_X86_64
 	if (!found) {

commit 28bb22379513ca3cac9d13766064a219c5fc21a9
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Jun 30 16:20:54 2008 -0700

    x86: move reserve_setup_data to setup.c
    
    Ying Huang would like setup_data to be reserved, but not included in the
    no save range.
    
    Here we try to modify the e820 table to reserve that range early.
    also add that in early_res in case bootloader messes up with the ramdisk.
    
    other solution would be
    1. add early_res_to_highmem...
    2. early_res_to_e820...
    but they could reserve another type memory wrongly, if early_res has some
    resource reserved early, and not needed later, but it is not removed from
    early_res in time. Like the RAMDISK (already handled).
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: andi@firstfloor.org
    Tested-by: Huang, Ying <ying.huang@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ba5ac880ea1e..e03b89ac8f2b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -120,6 +120,7 @@ void __init e820_print_map(char *who)
 		       (e820.map[i].addr + e820.map[i].size));
 		switch (e820.map[i].type) {
 		case E820_RAM:
+		case E820_RESERVED_KERN:
 			printk(KERN_CONT "(usable)\n");
 			break;
 		case E820_RESERVED:
@@ -611,7 +612,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 			register_nosave_region(pfn, PFN_UP(ei->addr));
 
 		pfn = PFN_DOWN(ei->addr + ei->size);
-		if (ei->type != E820_RAM)
+		if (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)
 			register_nosave_region(PFN_UP(ei->addr), pfn);
 
 		if (pfn >= limit_pfn)
@@ -1207,6 +1208,7 @@ void __init e820_reserve_resources(void)
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
 	for (i = 0; i < e820.nr_map; i++) {
 		switch (e820.map[i].type) {
+		case E820_RESERVED_KERN:
 		case E820_RAM:	res->name = "System RAM"; break;
 		case E820_ACPI:	res->name = "ACPI Tables"; break;
 		case E820_NVS:	res->name = "ACPI Non-volatile Storage"; break;

commit b4df32f4aeef8794d0135fc8dc250acb44cfee60
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Jun 28 17:49:59 2008 -0700

    x86: fix warning in e820_reserve_resources with 32bit
    
    when 64bit resource is not enabled, we get:
    
    arch/x86/kernel/e820.c: In function ‚Äòe820_reserve_resources‚Äô:
    arch/x86/kernel/e820.c:1217: warning: comparison is always false due to limited range of data type
    
    because res->start/end is resource_t aka u32. it will overflow.
    
    fix it with temp end of u64
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index fa77cb4185c3..ba5ac880ea1e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1202,6 +1202,7 @@ void __init e820_reserve_resources(void)
 {
 	int i;
 	struct resource *res;
+	u64 end;
 
 	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
 	for (i = 0; i < e820.nr_map; i++) {
@@ -1211,14 +1212,16 @@ void __init e820_reserve_resources(void)
 		case E820_NVS:	res->name = "ACPI Non-volatile Storage"; break;
 		default:	res->name = "reserved";
 		}
-		res->start = e820.map[i].addr;
-		res->end = res->start + e820.map[i].size - 1;
+		end = e820.map[i].addr + e820.map[i].size - 1;
 #ifndef CONFIG_RESOURCES_64BIT
-		if (res->end > 0x100000000ULL) {
+		if (end > 0x100000000ULL) {
 			res++;
 			continue;
 		}
 #endif
+		res->start = e820.map[i].addr;
+		res->end = end;
+
 		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 		insert_resource(&iomem_resource, res);
 		res++;

commit ab67715c7201be2fe729888a09007b6ba5bb2326
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Fri Jun 27 15:36:54 2008 -0700

    x86: early res print out alignment v2
    
    v2: fix print info to cont
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7b7685b78852..fa77cb4185c3 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -828,16 +828,26 @@ void __init free_early(u64 start, u64 end)
 
 void __init early_res_to_bootmem(u64 start, u64 end)
 {
-	int i;
+	int i, count;
 	u64 final_start, final_end;
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+
+	count  = 0;
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++)
+		count++;
+
+	printk(KERN_INFO "(%d early reservations) ==> bootmem\n", count);
+	for (i = 0; i < count; i++) {
 		struct early_res *r = &early_res[i];
+		printk(KERN_INFO "  #%d [ %010llx - %010llx ] %16s", i,
+			r->start, r->end, r->name);
 		final_start = max(start, r->start);
 		final_end = min(end, r->end);
-		if (final_start >= final_end)
+		if (final_start >= final_end) {
+			printk(KERN_CONT "\n");
 			continue;
-		printk(KERN_INFO "  early res: %d [%llx-%llx] %s\n", i,
-			final_start, final_end - 1, r->name);
+		}
+		printk(KERN_CONT " ===> [ %010llx - %010llx ]\n",
+			final_start, final_end);
 		reserve_bootmem_generic(final_start, final_end - final_start,
 				BOOTMEM_DEFAULT);
 	}

commit 611dfd7819e525b45f39ff15e0faf5f23551c113
Author: Bernhard Walle <bwalle@suse.de>
Date:   Wed Jun 25 21:39:16 2008 +0200

    x86: limit E820 map when a user-defined memory map is specified
    
    This patch brings back limiting of the E820 map when a user-defined
    E820 map is specified. While the behaviour of i386 (32 bit) was to limit
    the E820 map (and /proc/iomem), the behaviour of x86-64 (64 bit) was not to
    limit.
    
    That patch limits the E820 map again for both x86 architectures.
    
    Code was tested for compilation and booting on a 32 bit and 64 bit system.
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Acked-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: kexec@lists.infradead.org
    Cc: vgoyal@redhat.com
    Cc: Bernhard Walle <bwalle@suse.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 1dcb66533dfc..7b7685b78852 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1117,6 +1117,9 @@ static int __init parse_memopt(char *p)
 
 	mem_size = memparse(p, &p);
 	end_user_pfn = mem_size>>PAGE_SHIFT;
+	e820_update_range(mem_size, ULLONG_MAX - mem_size,
+		E820_RAM, E820_RESERVED);
+
 	return 0;
 }
 early_param("mem", parse_memopt);
@@ -1161,6 +1164,8 @@ static int __init parse_memmap_opt(char *p)
 		e820_add_region(start_at, mem_size, E820_RESERVED);
 	} else {
 		end_user_pfn = (mem_size >> PAGE_SHIFT);
+		e820_update_range(mem_size, ULLONG_MAX - mem_size,
+			E820_RAM, E820_RESERVED);
 	}
 	return *p == '\0' ? 0 : -EINVAL;
 }

commit 5dab8ec139be215fbaba216fb4aea914d0f4dac5
Author: Paul Jackson <pj@sgi.com>
Date:   Wed Jun 25 05:44:40 2008 -0700

    mm, generic, x86 boot: more tweaks to hex prints of some pfn addresses
    
    Fix some problems with (and applies on top of) a previous patch:
      x86 boot: show pfn addresses in hex not decimal in some kernel info printks
    
    Primarily change "0x%8lx" format, which displays with a right aligned
    space filled hex number (spaces between the "0x" prefix and the number),
    into "%0#10lx" format, which zero fills instead of space fills, and
    which uses the printf flag '#' to request the "0x" prefix instead of
    hard coding it.
    
    Also replace some other "0x%lx" formats with "%#lx", making use of the
    '#' printf flag again.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Cc: "Yinghai Lu" <yhlu.kernel@gmail.com>
    Cc: "Jack Steiner" <steiner@sgi.com>
    Cc: "Mike Travis" <travis@sgi.com>
    Cc: "Huang
    Cc: Ying" <ying.huang@intel.com>
    Cc: "Andi Kleen" <andi@firstfloor.org>
    Cc: "Andrew Morton" <akpm@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 22cfd665224c..1dcb66533dfc 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1014,7 +1014,7 @@ unsigned long __init e820_end_of_ram(void)
 	if (last_pfn > end_user_pfn)
 		last_pfn = end_user_pfn;
 
-	printk(KERN_INFO "last_pfn = 0x%lx max_arch_pfn = 0x%lx\n",
+	printk(KERN_INFO "last_pfn = %#lx max_arch_pfn = %#lx\n",
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }

commit 3381959da5a00ae8289cfbd28b0b6d228f2d1d46
Author: Alok Kataria <akataria@vmware.com>
Date:   Tue Jun 24 11:48:30 2008 -0700

    x86: cleanup e820_setup_gap(), add e820_search_gap(), v2
    
    This is a preparatory patch for the next patch in series.
    Moves some code from e820_setup_gap to a new function e820_search_gap.
    This patch is a part of a bug fix where we walk the ACPI table to calculate
    a gap for PCI optional devices.
    
    v1->v2: Patch on top of tip/master.
            Fixes a bug introduced in the last patch about the typeof "last".
            Also the new function e820_search_gap now returns if we found a gap in
            e820_map.
    
    Signed-off-by: Alok N Kataria <akataria@vmware.com>
    Cc: lenb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3900ff51bc68..22cfd665224c 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -488,26 +488,22 @@ void __init update_e820(void)
 }
 
 /*
- * Search for the biggest gap in the low 32 bits of the e820
- * memory space.  We pass this space to PCI to assign MMIO resources
- * for hotplug or unconfigured devices in.
- * Hopefully the BIOS let enough space left.
+ * Search for a gap in the e820 memory space from start_addr to 2^32.
  */
-__init void e820_setup_gap(void)
+__init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
+		unsigned long start_addr)
 {
-	unsigned long gapstart, gapsize, round;
-	unsigned long long last;
-	int i;
+	unsigned long long last = 0x100000000ull;
+	int i = e820.nr_map;
 	int found = 0;
 
-	last = 0x100000000ull;
-	gapstart = 0x10000000;
-	gapsize = 0x400000;
-	i = e820.nr_map;
 	while (--i >= 0) {
 		unsigned long long start = e820.map[i].addr;
 		unsigned long long end = start + e820.map[i].size;
 
+		if (end < start_addr)
+			continue;
+
 		/*
 		 * Since "last" is at most 4GB, we know we'll
 		 * fit in 32 bits if this condition is true
@@ -515,15 +511,32 @@ __init void e820_setup_gap(void)
 		if (last > end) {
 			unsigned long gap = last - end;
 
-			if (gap > gapsize) {
-				gapsize = gap;
-				gapstart = end;
+			if (gap >= *gapsize) {
+				*gapsize = gap;
+				*gapstart = end;
 				found = 1;
 			}
 		}
 		if (start < last)
 			last = start;
 	}
+	return found;
+}
+
+/*
+ * Search for the biggest gap in the low 32 bits of the e820
+ * memory space.  We pass this space to PCI to assign MMIO resources
+ * for hotplug or unconfigured devices in.
+ * Hopefully the BIOS let enough space left.
+ */
+__init void e820_setup_gap(void)
+{
+	unsigned long gapstart, gapsize, round;
+	int found;
+
+	gapstart = 0x10000000;
+	gapsize = 0x400000;
+	found  = e820_search_gap(&gapstart, &gapsize, 0);
 
 #ifdef CONFIG_X86_64
 	if (!found) {

commit c987d12f8455b19b3b057d63bac3de161bd809fc
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 24 22:14:09 2008 -0700

    x86: remove end_pfn in 64bit
    
    and use max_pfn directly.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 1b76b25b4d9a..3900ff51bc68 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -527,7 +527,7 @@ __init void e820_setup_gap(void)
 
 #ifdef CONFIG_X86_64
 	if (!found) {
-		gapstart = (end_pfn << PAGE_SHIFT) + 1024*1024;
+		gapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;
 		printk(KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit "
 		       "address range\n"
 		       KERN_ERR "PCI: Unassigned devices with 32bit resource "

commit 232b957ae93973a5f8619ef61b916744b747478c
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 24 14:58:38 2008 -0700

    x86: change size if e820_update/remove_range
    
    in case someone using crazy parameter while calling them.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 15b4393ff9bf..1b76b25b4d9a 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -405,6 +405,9 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 
 	BUG_ON(old_type == new_type);
 
+	if (size > (ULLONG_MAX - start))
+		size = ULLONG_MAX - start;
+
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
 		u64 final_start, final_end;
@@ -441,6 +444,9 @@ u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
 	int i;
 	u64 real_removed_size = 0;
 
+	if (size > (ULLONG_MAX - start))
+		size = ULLONG_MAX - start;
+
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
 		u64 final_start, final_end;

commit 976dd4dc99c3eaf45e3802ed46e3cc06a1ad8689
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 24 14:55:32 2008 -0700

    x86: fix e820_update_range size when overlapping
    
    before that we relay on sanitize_e820_map to remove the overlap.
    
    but e820_update_range(,,E820_RESERVED, E820_RAM) will not work
    
    this patch fix that
    
    who is going to use this?
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 512f779fc6af..15b4393ff9bf 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -425,6 +425,11 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 		e820_add_region(final_start, final_end - final_start,
 					 new_type);
 		real_updated_size += final_end - final_start;
+
+		ei->size -= final_end - final_start;
+		if (ei->addr < final_start)
+			continue;
+		ei->addr = final_end;
 	}
 	return real_updated_size;
 }

commit e2fc252e0ce695b4c4abe27bb073c35bd0d73252
Author: Paul Jackson <pj@sgi.com>
Date:   Sun Jun 22 07:22:12 2008 -0700

    x86 boot: show pfn addresses in hex not decimal in some kernel info printks
    
    Page frame numbers (the portion of physical addresses above the low
    order page offsets) are displayed in several kernel debug and info
    prints in decimal, not hex.  Decimal addresse are unreadable.  Use hex.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Cc: "Yinghai Lu" <yhlu.kernel@gmail.com>
    Cc: "Jack Steiner" <steiner@sgi.com>
    Cc: "Mike Travis" <travis@sgi.com>
    Cc: "Huang
    Cc: Ying" <ying.huang@intel.com>
    Cc: "Andi Kleen" <andi@firstfloor.org>
    Cc: "Andrew Morton" <akpm@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 600c9de237a0..512f779fc6af 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -990,7 +990,7 @@ unsigned long __init e820_end_of_ram(void)
 	if (last_pfn > end_user_pfn)
 		last_pfn = end_user_pfn;
 
-	printk(KERN_INFO "last_pfn = %lu max_arch_pfn = %lu\n",
+	printk(KERN_INFO "last_pfn = 0x%lx max_arch_pfn = 0x%lx\n",
 			 last_pfn, max_arch_pfn);
 	return last_pfn;
 }

commit c4ba1320b7075e9ce33ad0afaef43ba13260b4c2
Author: Paul Jackson <pj@sgi.com>
Date:   Sun Jun 22 07:22:07 2008 -0700

    x86 boot: allow overlapping early reserve memory ranges
    
    Add support for overlapping early memory reservations.
    
    In general, they still can't overlap, and will panic
    with "Overlapping early reservations" if they do overlap.
    
    But if a memory range is reserved with the new call:
        reserve_early_overlap_ok()
    rather than with the usual call:
        reserve_early()
    then subsequent early reservations are allowed to overlap.
    
    This new reserve_early_overlap_ok() call is only used in one
    place so far, which is the "BIOS reserved" reservation for the
    the EBDA region, which out of Paranoia reserves more than what
    the BIOS might have specified, and which thus might overlap with
    another legitimate early memory reservation (such as, perhaps,
    the EFI memmap.)
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Cc: "Yinghai Lu" <yhlu.kernel@gmail.com>
    Cc: "Jack Steiner" <steiner@sgi.com>
    Cc: "Mike Travis" <travis@sgi.com>
    Cc: "Huang
    Cc: Ying" <ying.huang@intel.com>
    Cc: "Andi Kleen" <andi@firstfloor.org>
    Cc: "Andrew Morton" <akpm@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 8a8afbdeb34e..600c9de237a0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -604,6 +604,7 @@ void __init e820_mark_nosave_regions(unsigned long limit_pfn)
 struct early_res {
 	u64 start, end;
 	char name[16];
+	char overlap_ok;
 };
 static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{ 0, PAGE_SIZE, "BIOS data page" },	/* BIOS data page */
@@ -640,7 +641,93 @@ static int __init find_overlapped_early(u64 start, u64 end)
 	return i;
 }
 
-void __init reserve_early(u64 start, u64 end, char *name)
+/*
+ * Drop the i-th range from the early reservation map,
+ * by copying any higher ranges down one over it, and
+ * clearing what had been the last slot.
+ */
+static void __init drop_range(int i)
+{
+	int j;
+
+	for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
+		;
+
+	memmove(&early_res[i], &early_res[i + 1],
+	       (j - 1 - i) * sizeof(struct early_res));
+
+	early_res[j - 1].end = 0;
+}
+
+/*
+ * Split any existing ranges that:
+ *  1) are marked 'overlap_ok', and
+ *  2) overlap with the stated range [start, end)
+ * into whatever portion (if any) of the existing range is entirely
+ * below or entirely above the stated range.  Drop the portion
+ * of the existing range that overlaps with the stated range,
+ * which will allow the caller of this routine to then add that
+ * stated range without conflicting with any existing range.
+ */
+static void __init drop_overlaps_that_are_ok(u64 start, u64 end)
+{
+	int i;
+	struct early_res *r;
+	u64 lower_start, lower_end;
+	u64 upper_start, upper_end;
+	char name[16];
+
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		r = &early_res[i];
+
+		/* Continue past non-overlapping ranges */
+		if (end <= r->start || start >= r->end)
+			continue;
+
+		/*
+		 * Leave non-ok overlaps as is; let caller
+		 * panic "Overlapping early reservations"
+		 * when it hits this overlap.
+		 */
+		if (!r->overlap_ok)
+			return;
+
+		/*
+		 * We have an ok overlap.  We will drop it from the early
+		 * reservation map, and add back in any non-overlapping
+		 * portions (lower or upper) as separate, overlap_ok,
+		 * non-overlapping ranges.
+		 */
+
+		/* 1. Note any non-overlapping (lower or upper) ranges. */
+		strncpy(name, r->name, sizeof(name) - 1);
+
+		lower_start = lower_end = 0;
+		upper_start = upper_end = 0;
+		if (r->start < start) {
+		 	lower_start = r->start;
+			lower_end = start;
+		}
+		if (r->end > end) {
+			upper_start = end;
+			upper_end = r->end;
+		}
+
+		/* 2. Drop the original ok overlapping range */
+		drop_range(i);
+
+		i--;		/* resume for-loop on copied down entry */
+
+		/* 3. Add back in any non-overlapping ranges. */
+		if (lower_end)
+			reserve_early_overlap_ok(lower_start, lower_end, name);
+		if (upper_end)
+			reserve_early_overlap_ok(upper_start, upper_end, name);
+	}
+}
+
+static void __init __reserve_early(u64 start, u64 end, char *name,
+						int overlap_ok)
 {
 	int i;
 	struct early_res *r;
@@ -656,14 +743,55 @@ void __init reserve_early(u64 start, u64 end, char *name)
 		      r->end - 1, r->name);
 	r->start = start;
 	r->end = end;
+	r->overlap_ok = overlap_ok;
 	if (name)
 		strncpy(r->name, name, sizeof(r->name) - 1);
 }
 
+/*
+ * A few early reservtations come here.
+ *
+ * The 'overlap_ok' in the name of this routine does -not- mean it
+ * is ok for these reservations to overlap an earlier reservation.
+ * Rather it means that it is ok for subsequent reservations to
+ * overlap this one.
+ *
+ * Use this entry point to reserve early ranges when you are doing
+ * so out of "Paranoia", reserving perhaps more memory than you need,
+ * just in case, and don't mind a subsequent overlapping reservation
+ * that is known to be needed.
+ *
+ * The drop_overlaps_that_are_ok() call here isn't really needed.
+ * It would be needed if we had two colliding 'overlap_ok'
+ * reservations, so that the second such would not panic on the
+ * overlap with the first.  We don't have any such as of this
+ * writing, but might as well tolerate such if it happens in
+ * the future.
+ */
+void __init reserve_early_overlap_ok(u64 start, u64 end, char *name)
+{
+	drop_overlaps_that_are_ok(start, end);
+	__reserve_early(start, end, name, 1);
+}
+
+/*
+ * Most early reservations come here.
+ *
+ * We first have drop_overlaps_that_are_ok() drop any pre-existing
+ * 'overlap_ok' ranges, so that we can then reserve this memory
+ * range without risk of panic'ing on an overlapping overlap_ok
+ * early reservation.
+ */
+void __init reserve_early(u64 start, u64 end, char *name)
+{
+	drop_overlaps_that_are_ok(start, end);
+	__reserve_early(start, end, name, 0);
+}
+
 void __init free_early(u64 start, u64 end)
 {
 	struct early_res *r;
-	int i, j;
+	int i;
 
 	i = find_overlapped_early(start, end);
 	r = &early_res[i];
@@ -671,13 +799,7 @@ void __init free_early(u64 start, u64 end)
 		panic("free_early on not reserved area: %llx-%llx!",
 			 start, end - 1);
 
-	for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
-		;
-
-	memmove(&early_res[i], &early_res[i + 1],
-	       (j - 1 - i) * sizeof(struct early_res));
-
-	early_res[j - 1].end = 0;
+	drop_range(i);
 }
 
 void __init early_res_to_bootmem(u64 start, u64 end)

commit 157fabf09594ab064b7ae92c81942af4b94663cb
Author: Paul Jackson <pj@sgi.com>
Date:   Sun Jun 22 07:21:57 2008 -0700

    x86 boot: e820 code indentation fix
    
    Fix indentation.  An earlier code merge got the
    indentation of four lines of code off by a tab.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Cc: "Yinghai Lu" <yhlu.kernel@gmail.com>
    Cc: "Jack Steiner" <steiner@sgi.com>
    Cc: "Mike Travis" <travis@sgi.com>
    Cc: "Huang
    Cc: Ying" <ying.huang@intel.com>
    Cc: "Andi Kleen" <andi@firstfloor.org>
    Cc: "Andrew Morton" <akpm@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index e285ea38c8e5..8a8afbdeb34e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -207,10 +207,10 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 		struct e820entry *pbios; /* pointer to original bios entry */
 		unsigned long long addr; /* address for this change point */
 	};
-static struct change_member change_point_list[2*E820_X_MAX] __initdata;
-static struct change_member *change_point[2*E820_X_MAX] __initdata;
-static struct e820entry *overlap_list[E820_X_MAX] __initdata;
-static struct e820entry new_bios[E820_X_MAX] __initdata;
+	static struct change_member change_point_list[2*E820_X_MAX] __initdata;
+	static struct change_member *change_point[2*E820_X_MAX] __initdata;
+	static struct e820entry *overlap_list[E820_X_MAX] __initdata;
+	static struct e820entry new_bios[E820_X_MAX] __initdata;
 	struct change_member *change_tmp;
 	unsigned long current_type, last_type;
 	unsigned long long last_addr;

commit 7a1fd9866cbb59a00006f1e0fd5726951b167c97
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Jun 21 14:48:05 2008 -0700

    x86: add e820_remove_range
    
    ... so could add real hole in e820
    
    agp check is using request_mem_region, and could fail if e820 is reserved...
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 7b613d2efb04..e285ea38c8e5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -429,6 +429,41 @@ u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 	return real_updated_size;
 }
 
+/* make e820 not cover the range */
+u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,
+			     int checktype)
+{
+	int i;
+	u64 real_removed_size = 0;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 final_start, final_end;
+
+		if (checktype && ei->type != old_type)
+			continue;
+		/* totally covered? */
+		if (ei->addr >= start &&
+		    (ei->addr + ei->size) <= (start + size)) {
+			real_removed_size += ei->size;
+			memset(ei, 0, sizeof(struct e820entry));
+			continue;
+		}
+		/* partially covered */
+		final_start = max(start, ei->addr);
+		final_end = min(start + size, ei->addr + ei->size);
+		if (final_start >= final_end)
+			continue;
+		real_removed_size += final_end - final_start;
+
+		ei->size -= final_end - final_start;
+		if (ei->addr < final_start)
+			continue;
+		ei->addr = final_end;
+	}
+	return real_removed_size;
+}
+
 void __init update_e820(void)
 {
 	int nr_map;

commit 95a71a45c250177854f7c530810c88a8a19a443b
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Wed Jun 18 17:27:08 2008 -0700

    x86: cleanup machine_specific_memory_setup, v2
    
    1. let 64bit support 88 and e801 too
    2. introduce default_machine_specific_memory_setup, and reuse it
       for voyager
    
    v2: fix 64 bit compiling
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 49477484a2fa..7b613d2efb04 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1029,7 +1029,7 @@ void __init e820_reserve_resources(void)
 	}
 }
 
-char *__init __attribute__((weak)) machine_specific_memory_setup(void)
+char *__init default_machine_specific_memory_setup(void)
 {
 	char *who = "BIOS-e820";
 	int new_nr;
@@ -1045,10 +1045,7 @@ char *__init __attribute__((weak)) machine_specific_memory_setup(void)
 			&new_nr);
 	boot_params.e820_entries = new_nr;
 	if (copy_e820_map(boot_params.e820_map, boot_params.e820_entries) < 0) {
-#ifdef CONFIG_X86_64
-		early_panic("Cannot find a valid memory map");
-#else
-		unsigned long mem_size;
+		u64 mem_size;
 
 		/* compare results from other methods and take the greater */
 		if (boot_params.alt_mem_k
@@ -1063,13 +1060,17 @@ char *__init __attribute__((weak)) machine_specific_memory_setup(void)
 		e820.nr_map = 0;
 		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
 		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
-#endif
 	}
 
 	/* In case someone cares... */
 	return who;
 }
 
+char *__init __attribute__((weak)) machine_specific_memory_setup(void)
+{
+	return default_machine_specific_memory_setup();
+}
+
 /* Overridden in paravirt.c if CONFIG_PARAVIRT */
 char * __init __attribute__((weak)) memory_setup(void)
 {

commit 064d25f12014ae1d97c2882f9ab874995321f2b2
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Jun 16 19:58:28 2008 -0700

    x86: merge setup_memory_map with e820
    
    ... and kill e820_32/64.c and e820_32/64.h
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 432c49178577..49477484a2fa 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -1029,4 +1029,76 @@ void __init e820_reserve_resources(void)
 	}
 }
 
+char *__init __attribute__((weak)) machine_specific_memory_setup(void)
+{
+	char *who = "BIOS-e820";
+	int new_nr;
+	/*
+	 * Try to copy the BIOS-supplied E820-map.
+	 *
+	 * Otherwise fake a memory map; one section from 0k->640k,
+	 * the next section from 1mb->appropriate_mem_k
+	 */
+	new_nr = boot_params.e820_entries;
+	sanitize_e820_map(boot_params.e820_map,
+			ARRAY_SIZE(boot_params.e820_map),
+			&new_nr);
+	boot_params.e820_entries = new_nr;
+	if (copy_e820_map(boot_params.e820_map, boot_params.e820_entries) < 0) {
+#ifdef CONFIG_X86_64
+		early_panic("Cannot find a valid memory map");
+#else
+		unsigned long mem_size;
+
+		/* compare results from other methods and take the greater */
+		if (boot_params.alt_mem_k
+		    < boot_params.screen_info.ext_mem_k) {
+			mem_size = boot_params.screen_info.ext_mem_k;
+			who = "BIOS-88";
+		} else {
+			mem_size = boot_params.alt_mem_k;
+			who = "BIOS-e801";
+		}
+
+		e820.nr_map = 0;
+		e820_add_region(0, LOWMEMSIZE(), E820_RAM);
+		e820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
+#endif
+	}
+
+	/* In case someone cares... */
+	return who;
+}
+
+/* Overridden in paravirt.c if CONFIG_PARAVIRT */
+char * __init __attribute__((weak)) memory_setup(void)
+{
+	return machine_specific_memory_setup();
+}
+
+void __init setup_memory_map(void)
+{
+	printk(KERN_INFO "BIOS-provided physical RAM map:\n");
+	e820_print_map(memory_setup());
+}
+
+#ifdef CONFIG_X86_64
+int __init arch_get_ram_range(int slot, u64 *addr, u64 *size)
+{
+	int i;
 
+	if (slot < 0 || slot >= e820.nr_map)
+		return -1;
+	for (i = slot; i < e820.nr_map; i++) {
+		if (e820.map[i].type != E820_RAM)
+			continue;
+		break;
+	}
+	if (i == e820.nr_map || e820.map[i].addr > (max_pfn << PAGE_SHIFT))
+		return -1;
+	*addr = e820.map[i].addr;
+	*size = min_t(u64, e820.map[i].size + e820.map[i].addr,
+		max_pfn << PAGE_SHIFT) - *addr;
+	return i + 1;
+}
+#endif

commit 41c094fd3ca54f1a71233049cf136ff94c91f4ae
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Jun 16 13:03:31 2008 -0700

    x86: move e820_resource_resources to e820.c
    
    and make 32-bit resource registration more like 64 bit.
    
    also move probe_roms back to setup_32.c
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 544dd12c70f4..432c49178577 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -998,3 +998,35 @@ void __init finish_e820_parsing(void)
 		e820_print_map("user");
 	}
 }
+
+/*
+ * Mark e820 reserved areas as busy for the resource manager.
+ */
+void __init e820_reserve_resources(void)
+{
+	int i;
+	struct resource *res;
+
+	res = alloc_bootmem_low(sizeof(struct resource) * e820.nr_map);
+	for (i = 0; i < e820.nr_map; i++) {
+		switch (e820.map[i].type) {
+		case E820_RAM:	res->name = "System RAM"; break;
+		case E820_ACPI:	res->name = "ACPI Tables"; break;
+		case E820_NVS:	res->name = "ACPI Non-volatile Storage"; break;
+		default:	res->name = "reserved";
+		}
+		res->start = e820.map[i].addr;
+		res->end = res->start + e820.map[i].size - 1;
+#ifndef CONFIG_RESOURCES_64BIT
+		if (res->end > 0x100000000ULL) {
+			res++;
+			continue;
+		}
+#endif
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+		insert_resource(&iomem_resource, res);
+		res++;
+	}
+}
+
+

commit 8c5beb50d3ec915d15c4d38aa37282309a65f14e
Author: Huang, Ying <ying.huang@intel.com>
Date:   Wed Jun 11 11:33:39 2008 +0800

    x86 boot: pass E820 memory map entries more than 128 via linked list of setup data
    
    Because of the size limits of struct boot_params (zero page), the
    maximum number of E820 memory map entries can be passed to kernel is
    128. As pointed by Paul Jackson, there is some machine produced by SGI
    with so many nodes that the number of E820 memory map entries is more
    than 128. To enabling Linux kernel on these system, a new setup data
    type named SETUP_E820_EXT is defined to pass additional memory map
    entries to Linux kernel.
    
    This patch is based on x86/auto-latest branch of git-x86 tree and has
    been tested on x86_64 and i386 platform.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ed46b7a6bc13..544dd12c70f4 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -359,6 +359,26 @@ static struct e820entry new_bios[E820_X_MAX] __initdata;
 	return 0;
 }
 
+static int __init __copy_e820_map(struct e820entry *biosmap, int nr_map)
+{
+	while (nr_map) {
+		u64 start = biosmap->addr;
+		u64 size = biosmap->size;
+		u64 end = start + size;
+		u32 type = biosmap->type;
+
+		/* Overflow in 64 bits? Ignore the memory map. */
+		if (start > end)
+			return -1;
+
+		e820_add_region(start, size, type);
+
+		biosmap++;
+		nr_map--;
+	}
+	return 0;
+}
+
 /*
  * Copy the BIOS e820 map into a safe place.
  *
@@ -374,19 +394,7 @@ int __init copy_e820_map(struct e820entry *biosmap, int nr_map)
 	if (nr_map < 2)
 		return -1;
 
-	do {
-		u64 start = biosmap->addr;
-		u64 size = biosmap->size;
-		u64 end = start + size;
-		u32 type = biosmap->type;
-
-		/* Overflow in 64 bits? Ignore the memory map. */
-		if (start > end)
-			return -1;
-
-		e820_add_region(start, size, type);
-	} while (biosmap++, --nr_map);
-	return 0;
+	return __copy_e820_map(biosmap, nr_map);
 }
 
 u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
@@ -496,6 +504,31 @@ __init void e820_setup_gap(void)
 	       pci_mem_start, gapstart, gapsize);
 }
 
+/**
+ * Because of the size limitation of struct boot_params, only first
+ * 128 E820 memory entries are passed to kernel via
+ * boot_params.e820_map, others are passed via SETUP_E820_EXT node of
+ * linked list of struct setup_data, which is parsed here.
+ */
+void __init parse_e820_ext(struct setup_data *sdata, unsigned long pa_data)
+{
+	u32 map_len;
+	int entries;
+	struct e820entry *extmap;
+
+	entries = sdata->len / sizeof(struct e820entry);
+	map_len = sdata->len + sizeof(struct setup_data);
+	if (map_len > PAGE_SIZE)
+		sdata = early_ioremap(pa_data, map_len);
+	extmap = (struct e820entry *)(sdata->data);
+	__copy_e820_map(extmap, entries);
+	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
+	if (map_len > PAGE_SIZE)
+		early_iounmap(sdata, map_len);
+	printk(KERN_INFO "extended physical RAM map:\n");
+	e820_print_map("extended");
+}
+
 #if defined(CONFIG_X86_64) || \
 	(defined(CONFIG_X86_32) && defined(CONFIG_HIBERNATION))
 /**

commit b5bc6c0e55000dab86b73f838f5ad02908b23755
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Jun 14 18:32:52 2008 -0700

    x86, mm: use add_highpages_with_active_regions() for high pages init v2
    
    use early_node_map to init high pages, so we can remove page_is_ram() and
    page_is_reserved_early() in the big loop with add_one_highpage
    
    also remove page_is_reserved_early(), it is not needed anymore.
    
    v2: fix the build of other platforms
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 5051ce744b4e..ed46b7a6bc13 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -612,17 +612,6 @@ void __init free_early(u64 start, u64 end)
 	early_res[j - 1].end = 0;
 }
 
-int __init page_is_reserved_early(unsigned long pagenr)
-{
-	u64 start = (u64)pagenr << PAGE_SHIFT;
-	int i;
-	struct early_res *r;
-
-	i = find_overlapped_early(start, start + PAGE_SIZE);
-	r = &early_res[i];
-	return (i < MAX_EARLY_RES && r->end);
-}
-
 void __init early_res_to_bootmem(u64 start, u64 end)
 {
 	int i;

commit d0be6bdea103b8d04c8a3495538b7c0011ae4129
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun Jun 15 18:58:51 2008 -0700

    x86: rename two e820 related functions
    
    rename update_memory_range to e820_update_range
    rename add_memory_region to e820_add_region
    
    to make it more clear that they are about e820 map operations.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 774063f11be0..5051ce744b4e 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -94,7 +94,7 @@ int __init e820_all_mapped(u64 start, u64 end, unsigned type)
 /*
  * Add a memory region to the kernel e820 map.
  */
-void __init add_memory_region(u64 start, u64 size, int type)
+void __init e820_add_region(u64 start, u64 size, int type)
 {
 	int x = e820.nr_map;
 
@@ -384,12 +384,12 @@ int __init copy_e820_map(struct e820entry *biosmap, int nr_map)
 		if (start > end)
 			return -1;
 
-		add_memory_region(start, size, type);
+		e820_add_region(start, size, type);
 	} while (biosmap++, --nr_map);
 	return 0;
 }
 
-u64 __init update_memory_range(u64 start, u64 size, unsigned old_type,
+u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
 				unsigned new_type)
 {
 	int i;
@@ -414,7 +414,7 @@ u64 __init update_memory_range(u64 start, u64 size, unsigned old_type,
 		final_end = min(start + size, ei->addr + ei->size);
 		if (final_start >= final_end)
 			continue;
-		add_memory_region(final_start, final_end - final_start,
+		e820_add_region(final_start, final_end - final_start,
 					 new_type);
 		real_updated_size += final_end - final_start;
 	}
@@ -774,7 +774,7 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 		return 0;
 
 	addr = round_down(start + size - sizet, align);
-	update_memory_range(addr, sizet, E820_RAM, E820_RESERVED);
+	e820_update_range(addr, sizet, E820_RAM, E820_RESERVED);
 	printk(KERN_INFO "update e820 for early_reserve_e820\n");
 	update_e820();
 
@@ -949,13 +949,13 @@ static int __init parse_memmap_opt(char *p)
 	userdef = 1;
 	if (*p == '@') {
 		start_at = memparse(p+1, &p);
-		add_memory_region(start_at, mem_size, E820_RAM);
+		e820_add_region(start_at, mem_size, E820_RAM);
 	} else if (*p == '#') {
 		start_at = memparse(p+1, &p);
-		add_memory_region(start_at, mem_size, E820_ACPI);
+		e820_add_region(start_at, mem_size, E820_ACPI);
 	} else if (*p == '$') {
 		start_at = memparse(p+1, &p);
-		add_memory_region(start_at, mem_size, E820_RESERVED);
+		e820_add_region(start_at, mem_size, E820_RESERVED);
 	} else {
 		end_user_pfn = (mem_size >> PAGE_SHIFT);
 	}

commit d2dbf343329dc777d77488743465f7be4245971d
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Fri Jun 13 02:00:56 2008 -0700

    x86: clean up reserve_bootmem_generic() and port it to 32-bit
    
    1. add reserve_bootmem_generic for 32bit
    2. change len to unsigned long
    3. make early_res_to_bootmem to use it
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 4f2cd5d179e2..774063f11be0 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -635,7 +635,7 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 			continue;
 		printk(KERN_INFO "  early res: %d [%llx-%llx] %s\n", i,
 			final_start, final_end - 1, r->name);
-		reserve_bootmem(final_start, final_end - final_start,
+		reserve_bootmem_generic(final_start, final_end - final_start,
 				BOOTMEM_DEFAULT);
 	}
 }

commit ab4a465e96adf2f3a8aaa95384bacfa9ab661e35
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 10 12:55:54 2008 -0700

    x86: e820 merge parsing of the mem=/memmap= boot parameters
    
    since we now have 32-bit support for e820_register_active_regions(),
    we can merge the parsing of the mem=/memmap= boot parameters.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 68aba413d403..4f2cd5d179e2 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -890,3 +890,89 @@ u64 __init e820_hole_size(u64 start, u64 end)
 	}
 	return end - start - ((u64)ram << PAGE_SHIFT);
 }
+
+static void early_panic(char *msg)
+{
+	early_printk(msg);
+	panic(msg);
+}
+
+/* "mem=nopentium" disables the 4MB page tables. */
+static int __init parse_memopt(char *p)
+{
+	u64 mem_size;
+
+	if (!p)
+		return -EINVAL;
+
+#ifdef CONFIG_X86_32
+	if (!strcmp(p, "nopentium")) {
+		setup_clear_cpu_cap(X86_FEATURE_PSE);
+		return 0;
+	}
+#endif
+
+	mem_size = memparse(p, &p);
+	end_user_pfn = mem_size>>PAGE_SHIFT;
+	return 0;
+}
+early_param("mem", parse_memopt);
+
+static int userdef __initdata;
+
+static int __init parse_memmap_opt(char *p)
+{
+	char *oldp;
+	u64 start_at, mem_size;
+
+	if (!strcmp(p, "exactmap")) {
+#ifdef CONFIG_CRASH_DUMP
+		/*
+		 * If we are doing a crash dump, we still need to know
+		 * the real mem size before original memory map is
+		 * reset.
+		 */
+		e820_register_active_regions(0, 0, -1UL);
+		saved_max_pfn = e820_end_of_ram();
+		remove_all_active_ranges();
+#endif
+		e820.nr_map = 0;
+		userdef = 1;
+		return 0;
+	}
+
+	oldp = p;
+	mem_size = memparse(p, &p);
+	if (p == oldp)
+		return -EINVAL;
+
+	userdef = 1;
+	if (*p == '@') {
+		start_at = memparse(p+1, &p);
+		add_memory_region(start_at, mem_size, E820_RAM);
+	} else if (*p == '#') {
+		start_at = memparse(p+1, &p);
+		add_memory_region(start_at, mem_size, E820_ACPI);
+	} else if (*p == '$') {
+		start_at = memparse(p+1, &p);
+		add_memory_region(start_at, mem_size, E820_RESERVED);
+	} else {
+		end_user_pfn = (mem_size >> PAGE_SHIFT);
+	}
+	return *p == '\0' ? 0 : -EINVAL;
+}
+early_param("memmap", parse_memmap_opt);
+
+void __init finish_e820_parsing(void)
+{
+	if (userdef) {
+		int nr = e820.nr_map;
+
+		if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr) < 0)
+			early_panic("Invalid user supplied memory map");
+		e820.nr_map = nr;
+
+		printk(KERN_INFO "user-defined physical RAM map:\n");
+		e820_print_map("user");
+	}
+}

commit df5f6c212cc049d1989b5ce71bb863a367c261e9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jun 10 16:38:41 2008 +0200

    x86: unify the reserve_bootmem() behavior of early_res_to_bootmem()
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index a706e9057ba5..68aba413d403 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -635,12 +635,8 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 			continue;
 		printk(KERN_INFO "  early res: %d [%llx-%llx] %s\n", i,
 			final_start, final_end - 1, r->name);
-#ifdef CONFIG_X86_64
-		reserve_bootmem_generic(final_start, final_end - final_start);
-#else
 		reserve_bootmem(final_start, final_end - final_start,
 				BOOTMEM_DEFAULT);
-#endif
 	}
 }
 

commit d0ec2c6f2c2f0478b34ae78b3e65f60a561ac807
Author: Huang, Ying <ying.huang@intel.com>
Date:   Mon Jun 2 14:26:18 2008 +0800

    x86: reserve highmem pages via reserve_early
    
    This patch makes early reserved highmem pages become reserved
    pages. This can be used for highmem pages allocated by bootloader such
    as EFI memory map, linked list of setup_data, etc.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Cc: andi@firstfloor.org
    Cc: mingo@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index ac5e9ebf70ea..a706e9057ba5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -612,6 +612,17 @@ void __init free_early(u64 start, u64 end)
 	early_res[j - 1].end = 0;
 }
 
+int __init page_is_reserved_early(unsigned long pagenr)
+{
+	u64 start = (u64)pagenr << PAGE_SHIFT;
+	int i;
+	struct early_res *r;
+
+	i = find_overlapped_early(start, start + PAGE_SIZE);
+	r = &early_res[i];
+	return (i < MAX_EARLY_RES && r->end);
+}
+
 void __init early_res_to_bootmem(u64 start, u64 end)
 {
 	int i;

commit d3fbe5ea9518b46a68e6b278974e92e2c3acef4a
Author: Huang, Ying <ying.huang@intel.com>
Date:   Mon Jun 2 14:26:14 2008 +0800

    x86: split out common code into find_overlapped_early()
    
    This patch clean up reserve_early() family functions by extracting the
    common part of reserve_early(), free_early() and bad_addr() into
    find_overlapped_early().
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Cc: andi@firstfloor.org
    Cc: mingo@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 5d33b9c08d1b..ac5e9ebf70ea 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -558,20 +558,34 @@ static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{}
 };
 
-void __init reserve_early(u64 start, u64 end, char *name)
+static int __init find_overlapped_early(u64 start, u64 end)
 {
 	int i;
 	struct early_res *r;
+
 	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
 		r = &early_res[i];
 		if (end > r->start && start < r->end)
-			panic("Overlapping early reservations %llx-%llx %s to %llx-%llx %s\n",
-			      start, end - 1, name?name:"", r->start,
-			      r->end - 1, r->name);
+			break;
 	}
+
+	return i;
+}
+
+void __init reserve_early(u64 start, u64 end, char *name)
+{
+	int i;
+	struct early_res *r;
+
+	i = find_overlapped_early(start, end);
 	if (i >= MAX_EARLY_RES)
 		panic("Too many early reservations");
 	r = &early_res[i];
+	if (r->end)
+		panic("Overlapping early reservations "
+		      "%llx-%llx %s to %llx-%llx %s\n",
+		      start, end - 1, name?name:"", r->start,
+		      r->end - 1, r->name);
 	r->start = start;
 	r->end = end;
 	if (name)
@@ -583,14 +597,11 @@ void __init free_early(u64 start, u64 end)
 	struct early_res *r;
 	int i, j;
 
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
-		r = &early_res[i];
-		if (start == r->start && end == r->end)
-			break;
-	}
-	if (i >= MAX_EARLY_RES || !early_res[i].end)
+	i = find_overlapped_early(start, end);
+	r = &early_res[i];
+	if (i >= MAX_EARLY_RES || r->end != end || r->start != start)
 		panic("free_early on not reserved area: %llx-%llx!",
-			 start, end);
+			 start, end - 1);
 
 	for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
 		;
@@ -626,17 +637,16 @@ void __init early_res_to_bootmem(u64 start, u64 end)
 static inline int __init bad_addr(u64 *addrp, u64 size, u64 align)
 {
 	int i;
-	u64 addr = *addrp, last;
+	u64 addr = *addrp;
 	int changed = 0;
+	struct early_res *r;
 again:
-	last = addr + size;
-	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
-		struct early_res *r = &early_res[i];
-		if (last >= r->start && addr < r->end) {
-			*addrp = addr = round_up(r->end, align);
-			changed = 1;
-			goto again;
-		}
+	i = find_overlapped_early(addr, addr + size);
+	r = &early_res[i];
+	if (i < MAX_EARLY_RES && r->end) {
+		*addrp = addr = round_up(r->end, align);
+		changed = 1;
+		goto again;
 	}
 	return changed;
 }

commit bd70e522afce2f7837d081dc52f261ecf9d4d2d5
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Wed Jun 4 13:21:29 2008 -0700

    x86: e820 max_arch_pfn typo fix for 64 bit
    
    should use right shift
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c140f731743b..5d33b9c08d1b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -771,7 +771,7 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 #  define MAX_ARCH_PFN		(1ULL<<(32-PAGE_SHIFT))
 # endif
 #else /* CONFIG_X86_32 */
-# define MAX_ARCH_PFN MAXMEM<<PAGE_SHIFT
+# define MAX_ARCH_PFN MAXMEM>>PAGE_SHIFT
 #endif
 
 /*

commit ee0c80fadfa56bf4f9d90c1c023429a6bd8edd69
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Jun 3 19:34:00 2008 -0700

    x86: move e820_register_active() to e820.c
    
    to prepare 32-bit to use it.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index cd2b99e27d43..c140f731743b 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -764,3 +764,112 @@ u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
 	return addr;
 }
 
+#ifdef CONFIG_X86_32
+# ifdef CONFIG_X86_PAE
+#  define MAX_ARCH_PFN		(1ULL<<(36-PAGE_SHIFT))
+# else
+#  define MAX_ARCH_PFN		(1ULL<<(32-PAGE_SHIFT))
+# endif
+#else /* CONFIG_X86_32 */
+# define MAX_ARCH_PFN MAXMEM<<PAGE_SHIFT
+#endif
+
+/*
+ * Last pfn which the user wants to use.
+ */
+unsigned long __initdata end_user_pfn = MAX_ARCH_PFN;
+
+/*
+ * Find the highest page frame number we have available
+ */
+unsigned long __init e820_end_of_ram(void)
+{
+	unsigned long last_pfn;
+	unsigned long max_arch_pfn = MAX_ARCH_PFN;
+
+	last_pfn = find_max_pfn_with_active_regions();
+
+	if (last_pfn > max_arch_pfn)
+		last_pfn = max_arch_pfn;
+	if (last_pfn > end_user_pfn)
+		last_pfn = end_user_pfn;
+
+	printk(KERN_INFO "last_pfn = %lu max_arch_pfn = %lu\n",
+			 last_pfn, max_arch_pfn);
+	return last_pfn;
+}
+
+/*
+ * Finds an active region in the address range from start_pfn to last_pfn and
+ * returns its range in ei_startpfn and ei_endpfn for the e820 entry.
+ */
+int __init e820_find_active_region(const struct e820entry *ei,
+				  unsigned long start_pfn,
+				  unsigned long last_pfn,
+				  unsigned long *ei_startpfn,
+				  unsigned long *ei_endpfn)
+{
+	u64 align = PAGE_SIZE;
+
+	*ei_startpfn = round_up(ei->addr, align) >> PAGE_SHIFT;
+	*ei_endpfn = round_down(ei->addr + ei->size, align) >> PAGE_SHIFT;
+
+	/* Skip map entries smaller than a page */
+	if (*ei_startpfn >= *ei_endpfn)
+		return 0;
+
+	/* Skip if map is outside the node */
+	if (ei->type != E820_RAM || *ei_endpfn <= start_pfn ||
+				    *ei_startpfn >= last_pfn)
+		return 0;
+
+	/* Check for overlaps */
+	if (*ei_startpfn < start_pfn)
+		*ei_startpfn = start_pfn;
+	if (*ei_endpfn > last_pfn)
+		*ei_endpfn = last_pfn;
+
+	/* Obey end_user_pfn to save on memmap */
+	if (*ei_startpfn >= end_user_pfn)
+		return 0;
+	if (*ei_endpfn > end_user_pfn)
+		*ei_endpfn = end_user_pfn;
+
+	return 1;
+}
+
+/* Walk the e820 map and register active regions within a node */
+void __init e820_register_active_regions(int nid, unsigned long start_pfn,
+					 unsigned long last_pfn)
+{
+	unsigned long ei_startpfn;
+	unsigned long ei_endpfn;
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++)
+		if (e820_find_active_region(&e820.map[i],
+					    start_pfn, last_pfn,
+					    &ei_startpfn, &ei_endpfn))
+			add_active_range(nid, ei_startpfn, ei_endpfn);
+}
+
+/*
+ * Find the hole size (in bytes) in the memory range.
+ * @start: starting address of the memory range to scan
+ * @end: ending address of the memory range to scan
+ */
+u64 __init e820_hole_size(u64 start, u64 end)
+{
+	unsigned long start_pfn = start >> PAGE_SHIFT;
+	unsigned long last_pfn = end >> PAGE_SHIFT;
+	unsigned long ei_startpfn, ei_endpfn, ram = 0;
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		if (e820_find_active_region(&e820.map[i],
+					    start_pfn, last_pfn,
+					    &ei_startpfn, &ei_endpfn))
+			ram += ei_endpfn - ei_startpfn;
+	}
+	return end - start - ((u64)ram << PAGE_SHIFT);
+}

commit 2944e16b25e7fb8b5ee0dd9dc7197a0f9e523cfd
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun Jun 1 13:17:38 2008 -0700

    x86: update mptable
    
    make mptable to be consistent with acpi routing, so we could:
    
    1. kexec kernel with acpi=off
    2. work around BIOSes where acpi routing is working, but mptable is
       not right, so can use kernel/kexec to start other OSes that don't have
       good acpi support.
    
    command line: update_mptable
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 0cd9132c9450..cd2b99e27d43 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -739,3 +739,28 @@ u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
 	return -1UL;
 
 }
+
+/*
+ * pre allocated 4k and reserved it in e820
+ */
+u64 __init early_reserve_e820(u64 startt, u64 sizet, u64 align)
+{
+	u64 size = 0;
+	u64 addr;
+	u64 start;
+
+	start = startt;
+	while (size < sizet)
+		start = find_e820_area_size(start, &size, align);
+
+	if (size < sizet)
+		return 0;
+
+	addr = round_down(start + size - sizet, align);
+	update_memory_range(addr, sizet, E820_RAM, E820_RESERVED);
+	printk(KERN_INFO "update e820 for early_reserve_e820\n");
+	update_e820();
+
+	return addr;
+}
+

commit bf62f3981c7076714e3b9f5fa6989a806cad02bf
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue May 20 20:10:58 2008 -0700

    x86: move e820_mark_nosave_regions to e820.c
    
    and make e820_mark_nosave_regions to take limit_pfn to use max_low_pfn
    for 32bit and end_pfn for 64bit
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 35da8cdbe5e6..0cd9132c9450 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -18,6 +18,7 @@
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/pfn.h>
+#include <linux/suspend.h>
 
 #include <asm/pgtable.h>
 #include <asm/page.h>
@@ -495,6 +496,37 @@ __init void e820_setup_gap(void)
 	       pci_mem_start, gapstart, gapsize);
 }
 
+#if defined(CONFIG_X86_64) || \
+	(defined(CONFIG_X86_32) && defined(CONFIG_HIBERNATION))
+/**
+ * Find the ranges of physical addresses that do not correspond to
+ * e820 RAM areas and mark the corresponding pages as nosave for
+ * hibernation (32 bit) or software suspend and suspend to RAM (64 bit).
+ *
+ * This function requires the e820 map to be sorted and without any
+ * overlapping entries and assumes the first e820 area to be RAM.
+ */
+void __init e820_mark_nosave_regions(unsigned long limit_pfn)
+{
+	int i;
+	unsigned long pfn;
+
+	pfn = PFN_DOWN(e820.map[0].addr + e820.map[0].size);
+	for (i = 1; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		if (pfn < PFN_UP(ei->addr))
+			register_nosave_region(pfn, PFN_UP(ei->addr));
+
+		pfn = PFN_DOWN(ei->addr + ei->size);
+		if (ei->type != E820_RAM)
+			register_nosave_region(PFN_UP(ei->addr), pfn);
+
+		if (pfn >= limit_pfn)
+			break;
+	}
+}
+#endif
 
 /*
  * Early reserved memory areas.

commit a4c81cf684350797939416c99effb9d3ae46bca6
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun May 18 01:18:57 2008 -0700

    x86: extend e820 ealy_res support 32bit
    
    move early_res related from e820_64.c to e820.c
    make edba detection to be done in head32.c
    remove smp_alloc_memory, because we have fixed trampoline address now.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    
     arch/x86/kernel/e820.c              |  214 ++++++++++++++++++++++++++++++++++++
     arch/x86/kernel/e820_64.c           |  196 --------------------------------
     arch/x86/kernel/head32.c            |   76 ++++++++++++
     arch/x86/kernel/setup_32.c          |  109 +++---------------
     arch/x86/kernel/smpboot.c           |   17 --
     arch/x86/kernel/trampoline.c        |    2
     arch/x86/mach-voyager/voyager_smp.c |    9 -
     include/asm-x86/e820.h              |    6 +
     include/asm-x86/e820_64.h           |    9 -
     include/asm-x86/smp.h               |    1
     arch/x86/kernel/e820.c              |  214 ++++++++++++++++++++++++++++++++++++
     arch/x86/kernel/e820_64.c           |  196 --------------------------------
     arch/x86/kernel/head32.c            |   76 ++++++++++++
     arch/x86/kernel/setup_32.c          |  109 +++---------------
     arch/x86/kernel/smpboot.c           |   17 --
     arch/x86/kernel/trampoline.c        |    2
     arch/x86/mach-voyager/voyager_smp.c |    9 -
     include/asm-x86/e820.h              |    6 +
     include/asm-x86/e820_64.h           |    9 -
     include/asm-x86/smp.h               |    1
     arch/x86/kernel/e820.c              |  214 ++++++++++++++++++++++++++++++++++++
     arch/x86/kernel/e820_64.c           |  196 --------------------------------
     arch/x86/kernel/head32.c            |   76 ++++++++++++
     arch/x86/kernel/setup_32.c          |  109 +++---------------
     arch/x86/kernel/smpboot.c           |   17 --
     arch/x86/kernel/trampoline.c        |    2
     arch/x86/mach-voyager/voyager_smp.c |    9 -
     include/asm-x86/e820.h              |    6 +
     include/asm-x86/e820_64.h           |    9 -
     include/asm-x86/smp.h               |    1
     10 files changed, 320 insertions(+), 319 deletions(-)
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 41c480ae47df..35da8cdbe5e6 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -22,7 +22,9 @@
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/e820.h>
+#include <asm/proto.h>
 #include <asm/setup.h>
+#include <asm/trampoline.h>
 
 struct e820map e820;
 
@@ -493,3 +495,215 @@ __init void e820_setup_gap(void)
 	       pci_mem_start, gapstart, gapsize);
 }
 
+
+/*
+ * Early reserved memory areas.
+ */
+#define MAX_EARLY_RES 20
+
+struct early_res {
+	u64 start, end;
+	char name[16];
+};
+static struct early_res early_res[MAX_EARLY_RES] __initdata = {
+	{ 0, PAGE_SIZE, "BIOS data page" },	/* BIOS data page */
+#if defined(CONFIG_X86_64) && defined(CONFIG_X86_TRAMPOLINE)
+	{ TRAMPOLINE_BASE, TRAMPOLINE_BASE + 2 * PAGE_SIZE, "TRAMPOLINE" },
+#endif
+#if defined(CONFIG_X86_32) && defined(CONFIG_SMP)
+	/*
+	 * But first pinch a few for the stack/trampoline stuff
+	 * FIXME: Don't need the extra page at 4K, but need to fix
+	 * trampoline before removing it. (see the GDT stuff)
+	 */
+	{ PAGE_SIZE, PAGE_SIZE + PAGE_SIZE, "EX TRAMPOLINE" },
+	/*
+	 * Has to be in very low memory so we can execute
+	 * real-mode AP code.
+	 */
+	{ TRAMPOLINE_BASE, TRAMPOLINE_BASE + PAGE_SIZE, "TRAMPOLINE" },
+#endif
+	{}
+};
+
+void __init reserve_early(u64 start, u64 end, char *name)
+{
+	int i;
+	struct early_res *r;
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		r = &early_res[i];
+		if (end > r->start && start < r->end)
+			panic("Overlapping early reservations %llx-%llx %s to %llx-%llx %s\n",
+			      start, end - 1, name?name:"", r->start,
+			      r->end - 1, r->name);
+	}
+	if (i >= MAX_EARLY_RES)
+		panic("Too many early reservations");
+	r = &early_res[i];
+	r->start = start;
+	r->end = end;
+	if (name)
+		strncpy(r->name, name, sizeof(r->name) - 1);
+}
+
+void __init free_early(u64 start, u64 end)
+{
+	struct early_res *r;
+	int i, j;
+
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		r = &early_res[i];
+		if (start == r->start && end == r->end)
+			break;
+	}
+	if (i >= MAX_EARLY_RES || !early_res[i].end)
+		panic("free_early on not reserved area: %llx-%llx!",
+			 start, end);
+
+	for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
+		;
+
+	memmove(&early_res[i], &early_res[i + 1],
+	       (j - 1 - i) * sizeof(struct early_res));
+
+	early_res[j - 1].end = 0;
+}
+
+void __init early_res_to_bootmem(u64 start, u64 end)
+{
+	int i;
+	u64 final_start, final_end;
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		struct early_res *r = &early_res[i];
+		final_start = max(start, r->start);
+		final_end = min(end, r->end);
+		if (final_start >= final_end)
+			continue;
+		printk(KERN_INFO "  early res: %d [%llx-%llx] %s\n", i,
+			final_start, final_end - 1, r->name);
+#ifdef CONFIG_X86_64
+		reserve_bootmem_generic(final_start, final_end - final_start);
+#else
+		reserve_bootmem(final_start, final_end - final_start,
+				BOOTMEM_DEFAULT);
+#endif
+	}
+}
+
+/* Check for already reserved areas */
+static inline int __init bad_addr(u64 *addrp, u64 size, u64 align)
+{
+	int i;
+	u64 addr = *addrp, last;
+	int changed = 0;
+again:
+	last = addr + size;
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		struct early_res *r = &early_res[i];
+		if (last >= r->start && addr < r->end) {
+			*addrp = addr = round_up(r->end, align);
+			changed = 1;
+			goto again;
+		}
+	}
+	return changed;
+}
+
+/* Check for already reserved areas */
+static inline int __init bad_addr_size(u64 *addrp, u64 *sizep, u64 align)
+{
+	int i;
+	u64 addr = *addrp, last;
+	u64 size = *sizep;
+	int changed = 0;
+again:
+	last = addr + size;
+	for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
+		struct early_res *r = &early_res[i];
+		if (last > r->start && addr < r->start) {
+			size = r->start - addr;
+			changed = 1;
+			goto again;
+		}
+		if (last > r->end && addr < r->end) {
+			addr = round_up(r->end, align);
+			size = last - addr;
+			changed = 1;
+			goto again;
+		}
+		if (last <= r->end && addr >= r->start) {
+			(*sizep)++;
+			return 0;
+		}
+	}
+	if (changed) {
+		*addrp = addr;
+		*sizep = size;
+	}
+	return changed;
+}
+
+/*
+ * Find a free area with specified alignment in a specific range.
+ */
+u64 __init find_e820_area(u64 start, u64 end, u64 size, u64 align)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 addr, last;
+		u64 ei_last;
+
+		if (ei->type != E820_RAM)
+			continue;
+		addr = round_up(ei->addr, align);
+		ei_last = ei->addr + ei->size;
+		if (addr < start)
+			addr = round_up(start, align);
+		if (addr >= ei_last)
+			continue;
+		while (bad_addr(&addr, size, align) && addr+size <= ei_last)
+			;
+		last = addr + size;
+		if (last > ei_last)
+			continue;
+		if (last > end)
+			continue;
+		return addr;
+	}
+	return -1ULL;
+}
+
+/*
+ * Find next free range after *start
+ */
+u64 __init find_e820_area_size(u64 start, u64 *sizep, u64 align)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 addr, last;
+		u64 ei_last;
+
+		if (ei->type != E820_RAM)
+			continue;
+		addr = round_up(ei->addr, align);
+		ei_last = ei->addr + ei->size;
+		if (addr < start)
+			addr = round_up(start, align);
+		if (addr >= ei_last)
+			continue;
+		*sizep = ei_last - addr;
+		while (bad_addr_size(&addr, sizep, align) &&
+			addr + *sizep <= ei_last)
+			;
+		last = addr + *sizep;
+		if (last > ei_last)
+			continue;
+		return addr;
+	}
+	return -1UL;
+
+}

commit 5b7eb2e9ef4e467a1248537b47a63bab265be3cc
Author: Paul Jackson <pj@sgi.com>
Date:   Wed May 14 08:15:52 2008 -0700

    x86 boot: longer comment explaining sanitize_e820_map routine
    
    Elaborate on the comment for sanitize_e820_map(), epxlaining more what
    it does, what it inputs, and what it returns.  Rearrange the placement of
    this comment to fit kernel conventions, before the routine's code rather
    than buried inside it.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 91abf5b2fb94..41c480ae47df 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -139,9 +139,64 @@ void __init e820_print_map(char *who)
  * Sanitize the BIOS e820 map.
  *
  * Some e820 responses include overlapping entries. The following
- * replaces the original e820 map with a new one, removing overlaps.
+ * replaces the original e820 map with a new one, removing overlaps,
+ * and resolving conflicting memory types in favor of highest
+ * numbered type.
  *
+ * The input parameter biosmap points to an array of 'struct
+ * e820entry' which on entry has elements in the range [0, *pnr_map)
+ * valid, and which has space for up to max_nr_map entries.
+ * On return, the resulting sanitized e820 map entries will be in
+ * overwritten in the same location, starting at biosmap.
+ *
+ * The integer pointed to by pnr_map must be valid on entry (the
+ * current number of valid entries located at biosmap) and will
+ * be updated on return, with the new number of valid entries
+ * (something no more than max_nr_map.)
+ *
+ * The return value from sanitize_e820_map() is zero if it
+ * successfully 'sanitized' the map entries passed in, and is -1
+ * if it did nothing, which can happen if either of (1) it was
+ * only passed one map entry, or (2) any of the input map entries
+ * were invalid (start + size < start, meaning that the size was
+ * so big the described memory range wrapped around through zero.)
+ *
+ *	Visually we're performing the following
+ *	(1,2,3,4 = memory types)...
+ *
+ *	Sample memory map (w/overlaps):
+ *	   ____22__________________
+ *	   ______________________4_
+ *	   ____1111________________
+ *	   _44_____________________
+ *	   11111111________________
+ *	   ____________________33__
+ *	   ___________44___________
+ *	   __________33333_________
+ *	   ______________22________
+ *	   ___________________2222_
+ *	   _________111111111______
+ *	   _____________________11_
+ *	   _________________4______
+ *
+ *	Sanitized equivalent (no overlap):
+ *	   1_______________________
+ *	   _44_____________________
+ *	   ___1____________________
+ *	   ____22__________________
+ *	   ______11________________
+ *	   _________1______________
+ *	   __________3_____________
+ *	   ___________44___________
+ *	   _____________33_________
+ *	   _______________2________
+ *	   ________________1_______
+ *	   _________________4______
+ *	   ___________________2____
+ *	   ____________________33__
+ *	   ______________________4_
  */
+
 int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 				int *pnr_map)
 {
@@ -162,43 +217,6 @@ static struct e820entry new_bios[E820_X_MAX] __initdata;
 	int old_nr, new_nr, chg_nr;
 	int i;
 
-	/*
-		Visually we're performing the following
-		(1,2,3,4 = memory types)...
-
-		Sample memory map (w/overlaps):
-		   ____22__________________
-		   ______________________4_
-		   ____1111________________
-		   _44_____________________
-		   11111111________________
-		   ____________________33__
-		   ___________44___________
-		   __________33333_________
-		   ______________22________
-		   ___________________2222_
-		   _________111111111______
-		   _____________________11_
-		   _________________4______
-
-		Sanitized equivalent (no overlap):
-		   1_______________________
-		   _44_____________________
-		   ___1____________________
-		   ____22__________________
-		   ______11________________
-		   _________1______________
-		   __________3_____________
-		   ___________44___________
-		   _____________33_________
-		   _______________2________
-		   ________________1_______
-		   _________________4______
-		   ___________________2____
-		   ____________________33__
-		   ______________________4_
-	*/
-
 	/* if there's only one memory region, don't bother */
 	if (*pnr_map < 2)
 		return -1;

commit 6e9bcc796b120d17b08dde7ab958b82ddb899889
Author: Paul Jackson <pj@sgi.com>
Date:   Wed May 14 08:15:46 2008 -0700

    x86 boot: change sanitize_e820_map parameter from byte to int to allow bigger memory maps
    
    The map size counter passed into, and back out of, sanitize_e820_map(),
    was an eight bit type (char or u8), as derived from its origins in
    legacy BIOS E820 structures.  This patch changes that type to an 'int',
    to allow this sanitize routine to also be used on larger maps (larger
    than the 256 count that fits in a char).  The legacy BIOS E820 interface
    of course does not change; that remains at 8 bits for this count, holding
    up to E820MAX == 128 entries.  But the kernel internals can handle more
    when those additional memory map entries are passed from the BIOS via
    EFI interfaces.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 3f7777b255aa..91abf5b2fb94 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -143,7 +143,7 @@ void __init e820_print_map(char *who)
  *
  */
 int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
-				char *pnr_map)
+				int *pnr_map)
 {
 	struct change_member {
 		struct e820entry *pbios; /* pointer to original bios entry */
@@ -204,6 +204,7 @@ static struct e820entry new_bios[E820_X_MAX] __initdata;
 		return -1;
 
 	old_nr = *pnr_map;
+	BUG_ON(old_nr > max_nr_map);
 
 	/* bail out if we find any unreasonable addresses in bios map */
 	for (i = 0; i < old_nr; i++)
@@ -401,7 +402,7 @@ u64 __init update_memory_range(u64 start, u64 size, unsigned old_type,
 
 void __init update_e820(void)
 {
-	u8 nr_map;
+	int nr_map;
 
 	nr_map = e820.nr_map;
 	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr_map))

commit 028b785888c523baccdf27af0cdbf1deb92edec0
Author: Paul Jackson <pj@sgi.com>
Date:   Wed May 14 08:15:40 2008 -0700

    x86 boot: extend some internal memory map arrays to handle larger EFI input
    
    Extend internal boot time memory tables to allow for up to
    three entries per node, which may be larger than the 128 E820MAX
    entries handled by the legacy BIOS E820 interface.  The EFI
    interface, if present, is capable of passing memory map
    entries for these larger node counts.
    
    This patch requires an earlier patch that rewrote code depending
    on these array sizes from using E820MAX explicitly to size loops,
    to instead using ARRAY_SIZE() of the applicable array.
    
    Another patch following this one will provide the code to pick
    up additional memory entries passed via the EFI interface from
    the BIOS and insert them in the following, now enlarged, arrays.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 2396b9da8027..3f7777b255aa 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -149,10 +149,10 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 		struct e820entry *pbios; /* pointer to original bios entry */
 		unsigned long long addr; /* address for this change point */
 	};
-	static struct change_member change_point_list[2*E820MAX] __initdata;
-	static struct change_member *change_point[2*E820MAX] __initdata;
-	static struct e820entry *overlap_list[E820MAX] __initdata;
-	static struct e820entry new_bios[E820MAX] __initdata;
+static struct change_member change_point_list[2*E820_X_MAX] __initdata;
+static struct change_member *change_point[2*E820_X_MAX] __initdata;
+static struct e820entry *overlap_list[E820_X_MAX] __initdata;
+static struct e820entry new_bios[E820_X_MAX] __initdata;
 	struct change_member *change_tmp;
 	unsigned long current_type, last_type;
 	unsigned long long last_addr;

commit c3965bd15118742d72b4bc1a290d37b3f081eb98
Author: Paul Jackson <pj@sgi.com>
Date:   Wed May 14 08:15:34 2008 -0700

    x86 boot: proper use of ARRAY_SIZE instead of repeated E820MAX constant
    
    This patch is motivated by a subsequent patch which will allow for more
    memory map entries on EFI supported systems than can be passed via the x86
    legacy BIOS E820 interface.  The legacy interface is limited to E820MAX ==
    128 memory entries, and that "E820MAX" manifest constant was used as the
    size for several arrays and loops over those arrays.
    
    The primary change in this patch is to change code loop sizes over those
    arrays from using the constant E820MAX, to using the ARRAY_SIZE() macro
    evaluated for the array being looped.  That way, a subsequent patch can
    change the size of some of these arrays, without breaking this code.
    
    This patch also adds a parameter to the sanitize_e820_map() routine,
    which had an implicit size for the array passed it of E820MAX entries.
    This new parameter explicitly passes the size of said array.  Once again,
    this will allow a subsequent patch to change that array size for some
    calls to sanitize_e820_map() without breaking the code.
    
    As part of enhancing the sanitize_e820_map() interface this way, I further
    combined the unnecessarily distinct x86_32 and x86_64 declarations for
    this routine into a single, commonly used, declaration.
    
    This patch in itself should make no difference to the resulting kernel
    binary.
    
    [ mingo@elte.hu: merged to -tip ]
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 2cb686f60d0d..2396b9da8027 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -95,7 +95,7 @@ void __init add_memory_region(u64 start, u64 size, int type)
 {
 	int x = e820.nr_map;
 
-	if (x == E820MAX) {
+	if (x == ARRAY_SIZE(e820.map)) {
 		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
 		return;
 	}
@@ -142,7 +142,8 @@ void __init e820_print_map(char *who)
  * replaces the original e820 map with a new one, removing overlaps.
  *
  */
-int __init sanitize_e820_map(struct e820entry *biosmap, char *pnr_map)
+int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
+				char *pnr_map)
 {
 	struct change_member {
 		struct e820entry *pbios; /* pointer to original bios entry */
@@ -314,7 +315,7 @@ int __init sanitize_e820_map(struct e820entry *biosmap, char *pnr_map)
 					 * no more space left for new
 					 * bios entries ?
 					 */
-					if (++new_bios_entry >= E820MAX)
+					if (++new_bios_entry >= max_nr_map)
 						break;
 			}
 			if (current_type != 0)	{
@@ -403,7 +404,7 @@ void __init update_e820(void)
 	u8 nr_map;
 
 	nr_map = e820.nr_map;
-	if (sanitize_e820_map(e820.map, &nr_map))
+	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &nr_map))
 		return;
 	e820.nr_map = nr_map;
 	printk(KERN_INFO "modified physical RAM map:\n");

commit b79cd8f1268bab57ff85b19d131f7f23deab2dee
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun May 11 00:30:15 2008 -0700

    x86: make e820.c to have common functions
    
    remove the duplicated copy of these functions.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
new file mode 100644
index 000000000000..2cb686f60d0d
--- /dev/null
+++ b/arch/x86/kernel/e820.c
@@ -0,0 +1,475 @@
+/*
+ * Handle the memory map.
+ * The functions here do the job until bootmem takes over.
+ *
+ *  Getting sanitize_e820_map() in sync with i386 version by applying change:
+ *  -  Provisions for empty E820 memory regions (reported by certain BIOSes).
+ *     Alex Achenbach <xela@slit.de>, December 2002.
+ *  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/kexec.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/pfn.h>
+
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/e820.h>
+#include <asm/setup.h>
+
+struct e820map e820;
+
+/* For PCI or other memory-mapped resources */
+unsigned long pci_mem_start = 0xaeedbabe;
+#ifdef CONFIG_PCI
+EXPORT_SYMBOL(pci_mem_start);
+#endif
+
+/*
+ * This function checks if any part of the range <start,end> is mapped
+ * with type.
+ */
+int
+e820_any_mapped(u64 start, u64 end, unsigned type)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		if (type && ei->type != type)
+			continue;
+		if (ei->addr >= end || ei->addr + ei->size <= start)
+			continue;
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(e820_any_mapped);
+
+/*
+ * This function checks if the entire range <start,end> is mapped with type.
+ *
+ * Note: this function only works correct if the e820 table is sorted and
+ * not-overlapping, which is the case
+ */
+int __init e820_all_mapped(u64 start, u64 end, unsigned type)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+
+		if (type && ei->type != type)
+			continue;
+		/* is the region (part) in overlap with the current region ?*/
+		if (ei->addr >= end || ei->addr + ei->size <= start)
+			continue;
+
+		/* if the region is at the beginning of <start,end> we move
+		 * start to the end of the region since it's ok until there
+		 */
+		if (ei->addr <= start)
+			start = ei->addr + ei->size;
+		/*
+		 * if start is now at or beyond end, we're done, full
+		 * coverage
+		 */
+		if (start >= end)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Add a memory region to the kernel e820 map.
+ */
+void __init add_memory_region(u64 start, u64 size, int type)
+{
+	int x = e820.nr_map;
+
+	if (x == E820MAX) {
+		printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
+		return;
+	}
+
+	e820.map[x].addr = start;
+	e820.map[x].size = size;
+	e820.map[x].type = type;
+	e820.nr_map++;
+}
+
+void __init e820_print_map(char *who)
+{
+	int i;
+
+	for (i = 0; i < e820.nr_map; i++) {
+		printk(KERN_INFO " %s: %016Lx - %016Lx ", who,
+		       (unsigned long long) e820.map[i].addr,
+		       (unsigned long long)
+		       (e820.map[i].addr + e820.map[i].size));
+		switch (e820.map[i].type) {
+		case E820_RAM:
+			printk(KERN_CONT "(usable)\n");
+			break;
+		case E820_RESERVED:
+			printk(KERN_CONT "(reserved)\n");
+			break;
+		case E820_ACPI:
+			printk(KERN_CONT "(ACPI data)\n");
+			break;
+		case E820_NVS:
+			printk(KERN_CONT "(ACPI NVS)\n");
+			break;
+		default:
+			printk(KERN_CONT "type %u\n", e820.map[i].type);
+			break;
+		}
+	}
+}
+
+/*
+ * Sanitize the BIOS e820 map.
+ *
+ * Some e820 responses include overlapping entries. The following
+ * replaces the original e820 map with a new one, removing overlaps.
+ *
+ */
+int __init sanitize_e820_map(struct e820entry *biosmap, char *pnr_map)
+{
+	struct change_member {
+		struct e820entry *pbios; /* pointer to original bios entry */
+		unsigned long long addr; /* address for this change point */
+	};
+	static struct change_member change_point_list[2*E820MAX] __initdata;
+	static struct change_member *change_point[2*E820MAX] __initdata;
+	static struct e820entry *overlap_list[E820MAX] __initdata;
+	static struct e820entry new_bios[E820MAX] __initdata;
+	struct change_member *change_tmp;
+	unsigned long current_type, last_type;
+	unsigned long long last_addr;
+	int chgidx, still_changing;
+	int overlap_entries;
+	int new_bios_entry;
+	int old_nr, new_nr, chg_nr;
+	int i;
+
+	/*
+		Visually we're performing the following
+		(1,2,3,4 = memory types)...
+
+		Sample memory map (w/overlaps):
+		   ____22__________________
+		   ______________________4_
+		   ____1111________________
+		   _44_____________________
+		   11111111________________
+		   ____________________33__
+		   ___________44___________
+		   __________33333_________
+		   ______________22________
+		   ___________________2222_
+		   _________111111111______
+		   _____________________11_
+		   _________________4______
+
+		Sanitized equivalent (no overlap):
+		   1_______________________
+		   _44_____________________
+		   ___1____________________
+		   ____22__________________
+		   ______11________________
+		   _________1______________
+		   __________3_____________
+		   ___________44___________
+		   _____________33_________
+		   _______________2________
+		   ________________1_______
+		   _________________4______
+		   ___________________2____
+		   ____________________33__
+		   ______________________4_
+	*/
+
+	/* if there's only one memory region, don't bother */
+	if (*pnr_map < 2)
+		return -1;
+
+	old_nr = *pnr_map;
+
+	/* bail out if we find any unreasonable addresses in bios map */
+	for (i = 0; i < old_nr; i++)
+		if (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)
+			return -1;
+
+	/* create pointers for initial change-point information (for sorting) */
+	for (i = 0; i < 2 * old_nr; i++)
+		change_point[i] = &change_point_list[i];
+
+	/* record all known change-points (starting and ending addresses),
+	   omitting those that are for empty memory regions */
+	chgidx = 0;
+	for (i = 0; i < old_nr; i++)	{
+		if (biosmap[i].size != 0) {
+			change_point[chgidx]->addr = biosmap[i].addr;
+			change_point[chgidx++]->pbios = &biosmap[i];
+			change_point[chgidx]->addr = biosmap[i].addr +
+				biosmap[i].size;
+			change_point[chgidx++]->pbios = &biosmap[i];
+		}
+	}
+	chg_nr = chgidx;
+
+	/* sort change-point list by memory addresses (low -> high) */
+	still_changing = 1;
+	while (still_changing)	{
+		still_changing = 0;
+		for (i = 1; i < chg_nr; i++)  {
+			unsigned long long curaddr, lastaddr;
+			unsigned long long curpbaddr, lastpbaddr;
+
+			curaddr = change_point[i]->addr;
+			lastaddr = change_point[i - 1]->addr;
+			curpbaddr = change_point[i]->pbios->addr;
+			lastpbaddr = change_point[i - 1]->pbios->addr;
+
+			/*
+			 * swap entries, when:
+			 *
+			 * curaddr > lastaddr or
+			 * curaddr == lastaddr and curaddr == curpbaddr and
+			 * lastaddr != lastpbaddr
+			 */
+			if (curaddr < lastaddr ||
+			    (curaddr == lastaddr && curaddr == curpbaddr &&
+			     lastaddr != lastpbaddr)) {
+				change_tmp = change_point[i];
+				change_point[i] = change_point[i-1];
+				change_point[i-1] = change_tmp;
+				still_changing = 1;
+			}
+		}
+	}
+
+	/* create a new bios memory map, removing overlaps */
+	overlap_entries = 0;	 /* number of entries in the overlap table */
+	new_bios_entry = 0;	 /* index for creating new bios map entries */
+	last_type = 0;		 /* start with undefined memory type */
+	last_addr = 0;		 /* start with 0 as last starting address */
+
+	/* loop through change-points, determining affect on the new bios map */
+	for (chgidx = 0; chgidx < chg_nr; chgidx++) {
+		/* keep track of all overlapping bios entries */
+		if (change_point[chgidx]->addr ==
+		    change_point[chgidx]->pbios->addr) {
+			/*
+			 * add map entry to overlap list (> 1 entry
+			 * implies an overlap)
+			 */
+			overlap_list[overlap_entries++] =
+				change_point[chgidx]->pbios;
+		} else {
+			/*
+			 * remove entry from list (order independent,
+			 * so swap with last)
+			 */
+			for (i = 0; i < overlap_entries; i++) {
+				if (overlap_list[i] ==
+				    change_point[chgidx]->pbios)
+					overlap_list[i] =
+						overlap_list[overlap_entries-1];
+			}
+			overlap_entries--;
+		}
+		/*
+		 * if there are overlapping entries, decide which
+		 * "type" to use (larger value takes precedence --
+		 * 1=usable, 2,3,4,4+=unusable)
+		 */
+		current_type = 0;
+		for (i = 0; i < overlap_entries; i++)
+			if (overlap_list[i]->type > current_type)
+				current_type = overlap_list[i]->type;
+		/*
+		 * continue building up new bios map based on this
+		 * information
+		 */
+		if (current_type != last_type)	{
+			if (last_type != 0)	 {
+				new_bios[new_bios_entry].size =
+					change_point[chgidx]->addr - last_addr;
+				/*
+				 * move forward only if the new size
+				 * was non-zero
+				 */
+				if (new_bios[new_bios_entry].size != 0)
+					/*
+					 * no more space left for new
+					 * bios entries ?
+					 */
+					if (++new_bios_entry >= E820MAX)
+						break;
+			}
+			if (current_type != 0)	{
+				new_bios[new_bios_entry].addr =
+					change_point[chgidx]->addr;
+				new_bios[new_bios_entry].type = current_type;
+				last_addr = change_point[chgidx]->addr;
+			}
+			last_type = current_type;
+		}
+	}
+	/* retain count for new bios entries */
+	new_nr = new_bios_entry;
+
+	/* copy new bios mapping into original location */
+	memcpy(biosmap, new_bios, new_nr * sizeof(struct e820entry));
+	*pnr_map = new_nr;
+
+	return 0;
+}
+
+/*
+ * Copy the BIOS e820 map into a safe place.
+ *
+ * Sanity-check it while we're at it..
+ *
+ * If we're lucky and live on a modern system, the setup code
+ * will have given us a memory map that we can use to properly
+ * set up memory.  If we aren't, we'll fake a memory map.
+ */
+int __init copy_e820_map(struct e820entry *biosmap, int nr_map)
+{
+	/* Only one memory region (or negative)? Ignore it */
+	if (nr_map < 2)
+		return -1;
+
+	do {
+		u64 start = biosmap->addr;
+		u64 size = biosmap->size;
+		u64 end = start + size;
+		u32 type = biosmap->type;
+
+		/* Overflow in 64 bits? Ignore the memory map. */
+		if (start > end)
+			return -1;
+
+		add_memory_region(start, size, type);
+	} while (biosmap++, --nr_map);
+	return 0;
+}
+
+u64 __init update_memory_range(u64 start, u64 size, unsigned old_type,
+				unsigned new_type)
+{
+	int i;
+	u64 real_updated_size = 0;
+
+	BUG_ON(old_type == new_type);
+
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		u64 final_start, final_end;
+		if (ei->type != old_type)
+			continue;
+		/* totally covered? */
+		if (ei->addr >= start &&
+		    (ei->addr + ei->size) <= (start + size)) {
+			ei->type = new_type;
+			real_updated_size += ei->size;
+			continue;
+		}
+		/* partially covered */
+		final_start = max(start, ei->addr);
+		final_end = min(start + size, ei->addr + ei->size);
+		if (final_start >= final_end)
+			continue;
+		add_memory_region(final_start, final_end - final_start,
+					 new_type);
+		real_updated_size += final_end - final_start;
+	}
+	return real_updated_size;
+}
+
+void __init update_e820(void)
+{
+	u8 nr_map;
+
+	nr_map = e820.nr_map;
+	if (sanitize_e820_map(e820.map, &nr_map))
+		return;
+	e820.nr_map = nr_map;
+	printk(KERN_INFO "modified physical RAM map:\n");
+	e820_print_map("modified");
+}
+
+/*
+ * Search for the biggest gap in the low 32 bits of the e820
+ * memory space.  We pass this space to PCI to assign MMIO resources
+ * for hotplug or unconfigured devices in.
+ * Hopefully the BIOS let enough space left.
+ */
+__init void e820_setup_gap(void)
+{
+	unsigned long gapstart, gapsize, round;
+	unsigned long long last;
+	int i;
+	int found = 0;
+
+	last = 0x100000000ull;
+	gapstart = 0x10000000;
+	gapsize = 0x400000;
+	i = e820.nr_map;
+	while (--i >= 0) {
+		unsigned long long start = e820.map[i].addr;
+		unsigned long long end = start + e820.map[i].size;
+
+		/*
+		 * Since "last" is at most 4GB, we know we'll
+		 * fit in 32 bits if this condition is true
+		 */
+		if (last > end) {
+			unsigned long gap = last - end;
+
+			if (gap > gapsize) {
+				gapsize = gap;
+				gapstart = end;
+				found = 1;
+			}
+		}
+		if (start < last)
+			last = start;
+	}
+
+#ifdef CONFIG_X86_64
+	if (!found) {
+		gapstart = (end_pfn << PAGE_SHIFT) + 1024*1024;
+		printk(KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit "
+		       "address range\n"
+		       KERN_ERR "PCI: Unassigned devices with 32bit resource "
+		       "registers may break!\n");
+	}
+#endif
+
+	/*
+	 * See how much we want to round up: start off with
+	 * rounding to the next 1MB area.
+	 */
+	round = 0x100000;
+	while ((gapsize >> 4) > round)
+		round += round;
+	/* Fun with two's complement */
+	pci_mem_start = (gapstart + round) & -round;
+
+	printk(KERN_INFO
+	       "Allocating PCI resources starting at %lx (gap: %lx:%lx)\n",
+	       pci_mem_start, gapstart, gapsize);
+}
+
