commit 5fafbebc86a0043ca5bbd8d3ce4f63dc5a02ad8e
Author: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
Date:   Thu Apr 23 18:09:47 2020 +0530

    x86/boot: Add kstrtoul() from lib/
    
    Add kstrtoul() to ../boot/ to be used by facilities there too.
    
     [
       bp: Massage, make _kstrtoul() static. Prepend function names with
       "boot_". This is a temporary workaround for build errors like:
    
       ld: arch/x86/boot/compressed/acpi.o: in function `count_immovable_mem_regions':
       acpi.c:(.text+0x463): undefined reference to `_kstrtoul'
       make[2]: *** [arch/x86/boot/compressed/Makefile:117: arch/x86/boot/compressed/vmlinux] Error 1
    
       due to the namespace clash between x86/boot/ and kernel proper.
       Future reorg will get rid of the linux/linux/ namespace as much as
       possible so that x86/boot/ can be independent from kernel proper. ]
    
    Signed-off-by: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/1587645588-7130-2-git-send-email-vamshi.k.sthambamkadi@gmail.com

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 8272a4492844..8a3fff9128bb 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -117,7 +117,6 @@ static unsigned int simple_guess_base(const char *cp)
  * @endp: A pointer to the end of the parsed string will be placed here
  * @base: The number base to use
  */
-
 unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
 {
 	unsigned long long result = 0;
@@ -335,3 +334,45 @@ int kstrtoull(const char *s, unsigned int base, unsigned long long *res)
 		s++;
 	return _kstrtoull(s, base, res);
 }
+
+static int _kstrtoul(const char *s, unsigned int base, unsigned long *res)
+{
+	unsigned long long tmp;
+	int rv;
+
+	rv = kstrtoull(s, base, &tmp);
+	if (rv < 0)
+		return rv;
+	if (tmp != (unsigned long)tmp)
+		return -ERANGE;
+	*res = tmp;
+	return 0;
+}
+
+/**
+ * kstrtoul - convert a string to an unsigned long
+ * @s: The start of the string. The string must be null-terminated, and may also
+ *  include a single newline before its terminating null. The first character
+ *  may also be a plus sign, but not a minus sign.
+ * @base: The number base to use. The maximum supported base is 16. If base is
+ *  given as 0, then the base of the string is automatically detected with the
+ *  conventional semantics - If it begins with 0x the number will be parsed as a
+ *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be
+ *  parsed as an octal number. Otherwise it will be parsed as a decimal.
+ * @res: Where to write the result of the conversion on success.
+ *
+ * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
+ * Used as a replacement for the simple_strtoull.
+ */
+int boot_kstrtoul(const char *s, unsigned int base, unsigned long *res)
+{
+	/*
+	 * We want to shortcut function call, but
+	 * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.
+	 */
+	if (sizeof(unsigned long) == sizeof(unsigned long long) &&
+	    __alignof__(unsigned long) == __alignof__(unsigned long long))
+		return kstrtoull(s, base, (unsigned long long *)res);
+	else
+		return _kstrtoul(s, base, res);
+}

commit 4ce97317f41d38584fb93578e922fcd19e535f5b
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Wed Aug 7 15:15:32 2019 -0700

    x86/purgatory: Do not use __builtin_memcpy and __builtin_memset
    
    Implementing memcpy and memset in terms of __builtin_memcpy and
    __builtin_memset is problematic.
    
    GCC at -O2 will replace calls to the builtins with calls to memcpy and
    memset (but will generate an inline implementation at -Os).  Clang will
    replace the builtins with these calls regardless of optimization level.
    $ llvm-objdump -dr arch/x86/purgatory/string.o | tail
    
    0000000000000339 memcpy:
         339: 48 b8 00 00 00 00 00 00 00 00 movabsq $0, %rax
                    000000000000033b:  R_X86_64_64  memcpy
         343: ff e0                         jmpq    *%rax
    
    0000000000000345 memset:
         345: 48 b8 00 00 00 00 00 00 00 00 movabsq $0, %rax
                    0000000000000347:  R_X86_64_64  memset
         34f: ff e0
    
    Such code results in infinite recursion at runtime. This is observed
    when doing kexec.
    
    Instead, reuse an implementation from arch/x86/boot/compressed/string.c.
    This requires to implement a stub function for warn(). Also, Clang may
    lower memcmp's that compare against 0 to bcmp's, so add a small definition,
    too. See also: commit 5f074f3e192f ("lib/string.c: implement a basic bcmp")
    
    Fixes: 8fc5b4d4121c ("purgatory: core purgatory functionality")
    Reported-by: Vaibhav Rustagi <vaibhavrustagi@google.com>
    Debugged-by: Vaibhav Rustagi <vaibhavrustagi@google.com>
    Debugged-by: Manoj Gupta <manojgupta@google.com>
    Suggested-by: Alistair Delva <adelva@google.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Vaibhav Rustagi <vaibhavrustagi@google.com>
    Cc: stable@vger.kernel.org
    Link: https://bugs.chromium.org/p/chromium/issues/detail?id=984056
    Link: https://lkml.kernel.org/r/20190807221539.94583-1-ndesaulniers@google.com

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 401e30ca0a75..8272a4492844 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -37,6 +37,14 @@ int memcmp(const void *s1, const void *s2, size_t len)
 	return diff;
 }
 
+/*
+ * Clang may lower `memcmp == 0` to `bcmp == 0`.
+ */
+int bcmp(const void *s1, const void *s2, size_t len)
+{
+	return memcmp(s1, s2, len);
+}
+
 int strcmp(const char *str1, const char *str2)
 {
 	const unsigned char *s1 = (const unsigned char *)str1;

commit 97873a3daf611594a7f92cc88bd8c5c8c526e1a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:30 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 497
    
    Based on 1 normalized pattern(s):
    
      this file is part of the linux kernel and is made available under
      the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 28 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.534229504@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 90154df8f125..401e30ca0a75 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* -*- linux-c -*- ------------------------------------------------------- *
  *
  *   Copyright (C) 1991, 1992 Linus Torvalds
  *   Copyright 2007 rPath, Inc. - All Rights Reserved
  *
- *   This file is part of the Linux kernel, and is made available under
- *   the terms of the GNU General Public License version 2.
- *
  * ----------------------------------------------------------------------- */
 
 /*

commit a9c640ac96e19b3966357ec9bb586edd2e1e74de
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Thu Mar 14 15:14:57 2019 -0700

    x86/boot: Restrict header scope to make Clang happy
    
    The inclusion of <linux/kernel.h> was causing issue as the definition of
    __arch_hweight64 from arch/x86/include/asm/arch_hweight.h eventually gets
    included. The definition is problematic when compiled with -m16 (all code
    in arch/x86/boot/ is) as the "D" inline assembly constraint is rejected
    by both compilers when passed an argument of type long long (regardless
    of signedness, anything smaller is fine).
    
    Because GCC performs inlining before semantic analysis, and
    __arch_hweight64 is dead in this translation unit, GCC does not report
    any issues at compile time.  Clang does the semantic analysis in the
    front end, before inlining (run in the middle) can determine the code is
    dead. I consider this another case of PR33587, which I think we can do
    more work to solve.
    
    It turns out that arch/x86/boot/string.c doesn't actually need
    linux/kernel.h, simply linux/limits.h and linux/compiler.h.
    
    Suggested-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Cc: bp@alien8.de
    Cc: niravd@google.com
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Chao Fan <fanc.fnst@cn.fujitsu.com>
    Cc: Uros Bizjak <ubizjak@gmail.com>
    Link: https://bugs.llvm.org/show_bug.cgi?id=33587
    Link: https://github.com/ClangBuiltLinux/linux/issues/347
    Link: https://lkml.kernel.org/r/20190314221458.83047-1-ndesaulniers@google.com

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 315a67b8896b..90154df8f125 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -13,8 +13,9 @@
  */
 
 #include <linux/types.h>
-#include <linux/kernel.h>
+#include <linux/compiler.h>
 #include <linux/errno.h>
+#include <linux/limits.h>
 #include <asm/asm.h>
 #include "ctype.h"
 #include "string.h"

commit de50ce20cd05da4d1a7e5709a12fc23bc0b66be9
Author: Chao Fan <fanc.fnst@cn.fujitsu.com>
Date:   Wed Jan 23 19:08:44 2019 +0800

    x86/boot: Copy kstrtoull() to boot/string.c
    
    Copy kstrtoull() and the other necessary functions from lib/kstrtox.c
    to boot/string.c so that code in boot/ can use kstrtoull() and the old
    simple_strtoull() can gradually be phased out.
    
    Using div_u64() from math64.h directly will cause the dividend to be
    handled as a 64-bit value and cause the infamous __divdi3 linker error
    due to gcc trying to use its library function for the 64-bit division.
    
    Therefore, separate the dividend into an upper and lower part.
    
     [ bp: Rewrite commit message. ]
    
    Signed-off-by: Chao Fan <fanc.fnst@cn.fujitsu.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: bhe@redhat.com
    Cc: caoj.fnst@cn.fujitsu.com
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: indou.takao@jp.fujitsu.com
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: kasong@redhat.com
    Cc: Kees Cook <keescook@chromium.org>
    Cc: msys.mizuma@gmail.com
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20190123110850.12433-2-fanc.fnst@cn.fujitsu.com

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index c4428a176973..315a67b8896b 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -13,10 +13,14 @@
  */
 
 #include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
 #include <asm/asm.h>
 #include "ctype.h"
 #include "string.h"
 
+#define KSTRTOX_OVERFLOW       (1U << 31)
+
 /*
  * Undef these macros so that the functions that we provide
  * here will have the correct names regardless of how string.h
@@ -187,3 +191,140 @@ char *strchr(const char *s, int c)
 			return NULL;
 	return (char *)s;
 }
+
+static inline u64 __div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
+{
+	union {
+		u64 v64;
+		u32 v32[2];
+	} d = { dividend };
+	u32 upper;
+
+	upper = d.v32[1];
+	d.v32[1] = 0;
+	if (upper >= divisor) {
+		d.v32[1] = upper / divisor;
+		upper %= divisor;
+	}
+	asm ("divl %2" : "=a" (d.v32[0]), "=d" (*remainder) :
+		"rm" (divisor), "0" (d.v32[0]), "1" (upper));
+	return d.v64;
+}
+
+static inline u64 __div_u64(u64 dividend, u32 divisor)
+{
+	u32 remainder;
+
+	return __div_u64_rem(dividend, divisor, &remainder);
+}
+
+static inline char _tolower(const char c)
+{
+	return c | 0x20;
+}
+
+static const char *_parse_integer_fixup_radix(const char *s, unsigned int *base)
+{
+	if (*base == 0) {
+		if (s[0] == '0') {
+			if (_tolower(s[1]) == 'x' && isxdigit(s[2]))
+				*base = 16;
+			else
+				*base = 8;
+		} else
+			*base = 10;
+	}
+	if (*base == 16 && s[0] == '0' && _tolower(s[1]) == 'x')
+		s += 2;
+	return s;
+}
+
+/*
+ * Convert non-negative integer string representation in explicitly given radix
+ * to an integer.
+ * Return number of characters consumed maybe or-ed with overflow bit.
+ * If overflow occurs, result integer (incorrect) is still returned.
+ *
+ * Don't you dare use this function.
+ */
+static unsigned int _parse_integer(const char *s,
+				   unsigned int base,
+				   unsigned long long *p)
+{
+	unsigned long long res;
+	unsigned int rv;
+
+	res = 0;
+	rv = 0;
+	while (1) {
+		unsigned int c = *s;
+		unsigned int lc = c | 0x20; /* don't tolower() this line */
+		unsigned int val;
+
+		if ('0' <= c && c <= '9')
+			val = c - '0';
+		else if ('a' <= lc && lc <= 'f')
+			val = lc - 'a' + 10;
+		else
+			break;
+
+		if (val >= base)
+			break;
+		/*
+		 * Check for overflow only if we are within range of
+		 * it in the max base we support (16)
+		 */
+		if (unlikely(res & (~0ull << 60))) {
+			if (res > __div_u64(ULLONG_MAX - val, base))
+				rv |= KSTRTOX_OVERFLOW;
+		}
+		res = res * base + val;
+		rv++;
+		s++;
+	}
+	*p = res;
+	return rv;
+}
+
+static int _kstrtoull(const char *s, unsigned int base, unsigned long long *res)
+{
+	unsigned long long _res;
+	unsigned int rv;
+
+	s = _parse_integer_fixup_radix(s, &base);
+	rv = _parse_integer(s, base, &_res);
+	if (rv & KSTRTOX_OVERFLOW)
+		return -ERANGE;
+	if (rv == 0)
+		return -EINVAL;
+	s += rv;
+	if (*s == '\n')
+		s++;
+	if (*s)
+		return -EINVAL;
+	*res = _res;
+	return 0;
+}
+
+/**
+ * kstrtoull - convert a string to an unsigned long long
+ * @s: The start of the string. The string must be null-terminated, and may also
+ *  include a single newline before its terminating null. The first character
+ *  may also be a plus sign, but not a minus sign.
+ * @base: The number base to use. The maximum supported base is 16. If base is
+ *  given as 0, then the base of the string is automatically detected with the
+ *  conventional semantics - If it begins with 0x the number will be parsed as a
+ *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be
+ *  parsed as an octal number. Otherwise it will be parsed as a decimal.
+ * @res: Where to write the result of the conversion on success.
+ *
+ * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
+ * Used as a replacement for the obsolete simple_strtoull. Return code must
+ * be checked.
+ */
+int kstrtoull(const char *s, unsigned int base, unsigned long long *res)
+{
+	if (s[0] == '+')
+		s++;
+	return _kstrtoull(s, base, res);
+}

commit 216a37202f10b7d78f2f98e26a6681f367165f05
Author: Uros Bizjak <ubizjak@gmail.com>
Date:   Fri Jun 29 16:28:44 2018 +0200

    x86/boot: Use CC_SET()/CC_OUT() instead of open coding it
    
    Remove open-coded uses of set instructions with CC_SET()/CC_OUT().
    
    Signed-off-by: Uros Bizjak <ubizjak@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20180629142844.15200-1-ubizjak@gmail.com

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 16f49123d747..c4428a176973 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/types.h>
+#include <asm/asm.h>
 #include "ctype.h"
 #include "string.h"
 
@@ -28,8 +29,8 @@
 int memcmp(const void *s1, const void *s2, size_t len)
 {
 	bool diff;
-	asm("repe; cmpsb; setnz %0"
-	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	asm("repe; cmpsb" CC_SET(nz)
+	    : CC_OUT(nz) (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
 

commit 18d5e6c34a8eda438d5ad8b3b15f42dab01bf05d
Author: Michael Davidson <md@google.com>
Date:   Mon Jul 24 16:51:55 2017 -0700

    x86/boot: #undef memcpy() et al in string.c
    
    undef memcpy() and friends in boot/string.c so that the functions
    defined here will have the correct names, otherwise we end up
    up trying to redefine __builtin_memcpy() etc.
    
    Surprisingly, GCC allows this (and, helpfully, discards the
    __builtin_ prefix from the function name when compiling it),
    but clang does not.
    
    Adding these #undef's appears to preserve what I assume was
    the original intent of the code.
    
    Signed-off-by: Michael Davidson <md@google.com>
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bernhard.Rosenkranzer@linaro.org
    Cc: Greg Hackmann <ghackmann@google.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20170724235155.79255-1-mka@chromium.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 630e3664906b..16f49123d747 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -16,6 +16,15 @@
 #include "ctype.h"
 #include "string.h"
 
+/*
+ * Undef these macros so that the functions that we provide
+ * here will have the correct names regardless of how string.h
+ * may have chosen to #define them.
+ */
+#undef memcpy
+#undef memset
+#undef memcmp
+
 int memcmp(const void *s1, const void *s2, size_t len)
 {
 	bool diff;

commit d52e7d5a952c5e35783f96e8c5b7fcffbb0d7c60
Author: Baoquan He <bhe@redhat.com>
Date:   Sat May 13 13:46:28 2017 +0800

    x86/KASLR: Parse all 'memmap=' boot option entries
    
    In commit:
    
      f28442497b5c ("x86/boot: Fix KASLR and memmap= collision")
    
    ... the memmap= option is parsed so that KASLR can avoid those reserved
    regions. It uses cmdline_find_option() to get the value if memmap=
    is specified, however the problem is that cmdline_find_option() can only
    find the last entry if multiple memmap entries are provided. This
    is not correct.
    
    Address this by checking each command line token for a "memmap=" match
    and parse each instance instead of using cmdline_find_option().
    
    Signed-off-by: Baoquan He <bhe@redhat.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: dan.j.williams@intel.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: dyoung@redhat.com
    Cc: m.mizuma@jp.fujitsu.com
    Link: http://lkml.kernel.org/r/1494654390-23861-2-git-send-email-bhe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 5457b02fc050..630e3664906b 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -122,6 +122,14 @@ unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int bas
 	return result;
 }
 
+long simple_strtol(const char *cp, char **endp, unsigned int base)
+{
+	if (*cp == '-')
+		return -simple_strtoull(cp + 1, endp, base);
+
+	return simple_strtoull(cp, endp, base);
+}
+
 /**
  * strlen - Find the length of a string
  * @s: The string to be sized

commit 9a1f4150fe932fb892c05084029b3718b8ed1baf
Merge: f28442497b5c 1b1bc42c1692
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 09:30:11 2017 +0100

    Merge branch 'linus' into x86/boot, to pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f28442497b5caf7bf573ade22a7f8d3559e3ef56
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jan 11 16:20:01 2017 -0700

    x86/boot: Fix KASLR and memmap= collision
    
    CONFIG_RANDOMIZE_BASE=y relocates the kernel to a random base address.
    
    However it does not take into account the memmap= parameter passed in from
    the kernel command line. This results in the kernel sometimes being put in
    the middle of memmap.
    
    Teach KASLR to not insert the kernel in memmap defined regions. We support
    up to 4 memmap regions: any additional regions will cause KASLR to disable.
    
    The mem_avoid set has been augmented to add up to 4 unusable regions of
    memmaps provided by the user to exclude those regions from the set of valid
    address range to insert the uncompressed kernel image.
    
    The nn@ss ranges will be skipped by the mem_avoid set since it indicates
    that memory is useable.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Baoquan He <bhe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: dan.j.williams@intel.com
    Cc: david@fromorbit.com
    Cc: linux-nvdimm@lists.01.org
    Link: http://lkml.kernel.org/r/148417664156.131935.2248592164852799738.stgit@djiang5-desk3.ch.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index cc3bd583dce1..93d9b991e6b1 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -155,3 +155,16 @@ char *strstr(const char *s1, const char *s2)
 	}
 	return NULL;
 }
+
+/**
+ * strchr - Find the first occurrence of the character c in the string s.
+ * @s: the string to be searched
+ * @c: the character to search for
+ */
+char *strchr(const char *s, int c)
+{
+	while (*s != (char)c)
+		if (*s++ == '\0')
+			return NULL;
+	return (char *)s;
+}

commit fac69d0efad08fc15e4dbfc116830782acc0dc9a
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Sat Jan 7 10:38:31 2017 +0100

    x86/boot: Add missing declaration of string functions
    
    Add the missing declarations of basic string functions to string.h to allow
    a clean build.
    
    Fixes: 5be865661516 ("String-handling functions for the new x86 setup code.")
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Link: http://lkml.kernel.org/r/1483781911-21399-1-git-send-email-hofrat@osadl.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index cc3bd583dce1..9e240fcba784 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -14,6 +14,7 @@
 
 #include <linux/types.h>
 #include "ctype.h"
+#include "string.h"
 
 int memcmp(const void *s1, const void *s2, size_t len)
 {

commit 117780eef7740729e803bdcc0d5f2f48137ea8e3
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Jun 8 12:38:38 2016 -0700

    x86, asm: use bool for bitops and other assembly outputs
    
    The gcc people have confirmed that using "bool" when combined with
    inline assembly always is treated as a byte-sized operand that can be
    assumed to be 0 or 1, which is exactly what the SET instruction
    emits.  Change the output types and intermediate variables of as many
    operations as practical to "bool".
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Link: http://lkml.kernel.org/r/1465414726-197858-3-git-send-email-hpa@linux.intel.com
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 318b8465d302..cc3bd583dce1 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -17,7 +17,7 @@
 
 int memcmp(const void *s1, const void *s2, size_t len)
 {
-	u8 diff;
+	bool diff;
 	asm("repe; cmpsb; setnz %0"
 	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;

commit 1c1d046be692493d00a4831d4fbc266745008e09
Author: Arjun Sreedharan <arjun024@gmail.com>
Date:   Mon Mar 16 21:07:47 2015 +0530

    x86/boot: Standardize strcmp()
    
    strcmp() is always expected to return 0 when arguments are equal,
    negative when its first argument @str1 is less than its second argument
    @str2 and a positive value otherwise. Previously strcmp("a", "b")
    returned 1. Now it gives -1, as it is supposed to.
    
    Until now this bug never triggered, because all uses for strcmp() in the
    boot code tested for nonzero:
    
      triton:~/tip> git grep strcmp arch/x86/boot/
      arch/x86/boot/boot.h:int strcmp(const char *str1, const char *str2);
      arch/x86/boot/edd.c:            if (!strcmp(eddarg, "skipmbr") || !strcmp(eddarg, "skip")) {
      arch/x86/boot/edd.c:            else if (!strcmp(eddarg, "off"))
      arch/x86/boot/edd.c:            else if (!strcmp(eddarg, "on"))
    
    should in the future strcmp() be used in a comparative way in the boot
    code, it might have led to (not so subtle) bugs.
    
    Signed-off-by: Arjun Sreedharan <arjun024@gmail.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426520267-1803-1-git-send-email-arjun024@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 493f3fd9f139..318b8465d302 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -30,7 +30,7 @@ int strcmp(const char *str1, const char *str2)
 	int delta = 0;
 
 	while (*s1 || *s2) {
-		delta = *s2 - *s1;
+		delta = *s1 - *s2;
 		if (delta)
 			return delta;
 		s1++;

commit a9a17104a112a67a7bf0679b734704c130eb5faa
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Apr 25 13:46:12 2014 -0400

    x86, boot: Remove misc.h inclusion from compressed/string.c
    
    Given the fact that we removed inclusion of boot.h from boot/string.c
    does not look like we need misc.h inclusion in compressed/string.c. So
    remove it.
    
    misc.h was also pulling in string_32.h which in turn had macros for
    memcmp and memcpy. So we don't need to #undef memcmp and memcpy anymore.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Link: http://lkml.kernel.org/r/1398447972-27896-3-git-send-email-vgoyal@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index aca52b83e31d..493f3fd9f139 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -15,12 +15,6 @@
 #include <linux/types.h>
 #include "ctype.h"
 
-/*
- * This file gets included in compressed/string.c which might pull in
- * string_32.h and which in turn maps memcmp to __builtin_memcmp(). Undo
- * that first.
- */
-#undef memcmp
 int memcmp(const void *s1, const void *s2, size_t len)
 {
 	u8 diff;

commit 3d379225c458097d41d104b4f78f40ee97719333
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Apr 25 13:46:11 2014 -0400

    x86, boot: Do not include boot.h in string.c
    
    string.c does not require whole of boot.h. Just inclusion of linux/types.h
    and ctypes.h seems to be sufficient.
    
    Keep list of stuff being included in string.c to bare minimal so that
    string.c can be included in other places easily.
    
    For example, Currently boot/compressed/string.c includes boot/string.c
    but looks like it does not want boot/boot.h. Hence there is a define
    in boot/compressed/misc.h "define BOOT_BOOT_H" which prevents inclusion
    of boot.h in compressed/string.c. And compressed/string.c is forced to
    include misc.h just for that reason.
    
    So by removing inclusion of boot.h, we can also get rid of inclusion of
    misch.h in compressed/misc.c.
    
    This also enables including of boot/string.c in purgatory/ code relatively
    easily.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Link: http://lkml.kernel.org/r/1398447972-27896-2-git-send-email-vgoyal@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 5339040ef86e..aca52b83e31d 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -12,7 +12,8 @@
  * Very basic string functions
  */
 
-#include "boot.h"
+#include <linux/types.h>
+#include "ctype.h"
 
 /*
  * This file gets included in compressed/string.c which might pull in

commit fb4cac573ef6dce8d7543b68306566561c2e5725
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Tue Mar 18 15:26:39 2014 -0400

    x86, boot: Move memcmp() into string.h and string.c
    
    Try to treat memcmp() in same way as memcpy() and memset(). Provide a
    declaration in boot/string.h and by default user gets a memcmp() which
    maps to builtin function.
    
    Move optimized definition of memcmp() in boot/string.c. Now a user can
    do #undef memcmp and link against string.c to use optimzied memcmp().
    
    It also simplifies boot/compressed/string.c where we had to redefine
    memcmp(). That extra definition is gone now.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Link: http://lkml.kernel.org/r/1395170800-11059-5-git-send-email-vgoyal@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 574dedfe2890..5339040ef86e 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -14,6 +14,20 @@
 
 #include "boot.h"
 
+/*
+ * This file gets included in compressed/string.c which might pull in
+ * string_32.h and which in turn maps memcmp to __builtin_memcmp(). Undo
+ * that first.
+ */
+#undef memcmp
+int memcmp(const void *s1, const void *s2, size_t len)
+{
+	u8 diff;
+	asm("repe; cmpsb; setnz %0"
+	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	return diff;
+}
+
 int strcmp(const char *str1, const char *str2)
 {
 	const unsigned char *s1 = (const unsigned char *)str1;

commit 291f36325f9f252bd76ef5f603995f37e453fc60
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Mon Dec 12 21:27:52 2011 +0000

    x86, efi: EFI boot stub support
    
    There is currently a large divide between kernel development and the
    development of EFI boot loaders. The idea behind this patch is to give
    the kernel developers full control over the EFI boot process. As
    H. Peter Anvin put it,
    
    "The 'kernel carries its own stub' approach been very successful in
    dealing with BIOS, and would make a lot of sense to me for EFI as
    well."
    
    This patch introduces an EFI boot stub that allows an x86 bzImage to
    be loaded and executed by EFI firmware. The bzImage appears to the
    firmware as an EFI application. Luckily there are enough free bits
    within the bzImage header so that it can masquerade as an EFI
    application, thereby coercing the EFI firmware into loading it and
    jumping to its entry point. The beauty of this masquerading approach
    is that both BIOS and EFI boot loaders can still load and run the same
    bzImage, thereby allowing a single kernel image to work in any boot
    environment.
    
    The EFI boot stub supports multiple initrds, but they must exist on
    the same partition as the bzImage. Command-line arguments for the
    kernel can be appended after the bzImage name when run from the EFI
    shell, e.g.
    
    Shell> bzImage console=ttyS0 root=/dev/sdb initrd=initrd.img
    
    v7:
     - Fix checkpatch warnings.
    
    v6:
    
     - Try to allocate initrd memory just below hdr->inird_addr_max.
    
    v5:
    
     - load_options_size is UTF-16, which needs dividing by 2 to convert
       to the corresponding ASCII size.
    
    v4:
    
     - Don't read more than image->load_options_size
    
    v3:
    
     - Fix following warnings when compiling CONFIG_EFI_STUB=n
    
       arch/x86/boot/tools/build.c: In function ‘main’:
       arch/x86/boot/tools/build.c:138:24: warning: unused variable ‘pe_header’
       arch/x86/boot/tools/build.c:138:15: warning: unused variable ‘file_sz’
    
     - As reported by Matthew Garrett, some Apple machines have GOPs that
       don't have hardware attached. We need to weed these out by
       searching for ones that handle the PCIIO protocol.
    
     - Don't allocate memory if no initrds are on cmdline
     - Don't trust image->load_options_size
    
    Maarten Lankhorst noted:
     - Don't strip first argument when booted from efibootmgr
     - Don't allocate too much memory for cmdline
     - Don't update cmdline_size, the kernel considers it read-only
     - Don't accept '\n' for initrd names
    
    v2:
    
     - File alignment was too large, was 8192 should be 512. Reported by
       Maarten Lankhorst on LKML.
     - Added UGA support for graphics
     - Use VIDEO_TYPE_EFI instead of hard-coded number.
     - Move linelength assignment until after we've assigned depth
     - Dynamically fill out AddressOfEntryPoint in tools/build.c
     - Don't use magic number for GDT/TSS stuff. Requested by Andi Kleen
     - The bzImage may need to be relocated as it may have been loaded at
       a high address address by the firmware. This was required to get my
       macbook booting because the firmware loaded it at 0x7cxxxxxx, which
       triggers this error in decompress_kernel(),
    
            if (heap > ((-__PAGE_OFFSET-(128<<20)-1) & 0x7fffffff))
                    error("Destination address too large");
    
    Cc: Mike Waychison <mikew@google.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Tested-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1321383097.2657.9.camel@mfleming-mobl1.ger.corp.intel.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 3cbc4058dd26..574dedfe2890 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -111,3 +111,38 @@ unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int bas
 
 	return result;
 }
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char *s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+
+/**
+ * strstr - Find the first substring in a %NUL terminated string
+ * @s1: The string to be searched
+ * @s2: The string to search for
+ */
+char *strstr(const char *s1, const char *s2)
+{
+	size_t l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *)s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1, s2, l2))
+			return (char *)s1;
+		s1++;
+	}
+	return NULL;
+}

commit ce0aa5dd20e44372f9617dd67c984f41fcdbed88
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Jul 13 13:35:17 2010 -0700

    x86, setup: Make the setup code also accept console=uart8250
    
    Make the boot code also accept the console=uart8250,io,0x2f8,115200n
    form of early console.
    
    Also add back simple_guess_base(), otherwise those simple_strtoull(,,0)
    are not going to work.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <4C3CCE05.4090505@kernel.org>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index aba29df4a7bb..3cbc4058dd26 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -68,10 +68,32 @@ unsigned int atou(const char *s)
 /* Works only for digits and letters, but small and fast */
 #define TOLOWER(x) ((x) | 0x20)
 
+static unsigned int simple_guess_base(const char *cp)
+{
+	if (cp[0] == '0') {
+		if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
+			return 16;
+		else
+			return 8;
+	} else {
+		return 10;
+	}
+}
+
+/**
+ * simple_strtoull - convert a string to an unsigned long long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+
 unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
 {
 	unsigned long long result = 0;
 
+	if (!base)
+		base = simple_guess_base(cp);
+
 	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
 		cp += 2;
 

commit fa97bdf92709adaaf8b9a5164a895e262a4fcf60
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Sun Jul 11 11:06:57 2010 +0300

    x86, setup: Early-boot serial I/O support
    
    This patch adds serial I/O support to the real-mode setup (very early
    boot) printf(). It's useful for debugging boot code when running Linux
    under KVM, for example. The actual code was lifted from early printk.
    
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    LKML-Reference: <1278835617-11368-1-git-send-email-penberg@cs.helsinki.fi>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index f94b7a0c2abf..aba29df4a7bb 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -30,6 +30,22 @@ int strcmp(const char *str1, const char *str2)
 	return 0;
 }
 
+int strncmp(const char *cs, const char *ct, size_t count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		if (!c1)
+			break;
+		count--;
+	}
+	return 0;
+}
+
 size_t strnlen(const char *s, size_t maxlen)
 {
 	const char *es = s;
@@ -48,3 +64,28 @@ unsigned int atou(const char *s)
 		i = i * 10 + (*s++ - '0');
 	return i;
 }
+
+/* Works only for digits and letters, but small and fast */
+#define TOLOWER(x) ((x) | 0x20)
+
+unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0;
+
+	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
+		cp += 2;
+
+	while (isxdigit(*cp)) {
+		unsigned int value;
+
+		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
+		if (value >= base)
+			break;
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}

commit cf9b111c170733dde39139e8989b676ec8b81573
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Sat Mar 8 18:15:06 2008 +0800

    x86: remove pointless comments
    
    Remove old comments that include the old arch/i386 directory.
    
    Signed-off-by: WANG Cong <xiyou.wangcong@gmail.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
index 481a22097781..f94b7a0c2abf 100644
--- a/arch/x86/boot/string.c
+++ b/arch/x86/boot/string.c
@@ -9,8 +9,6 @@
  * ----------------------------------------------------------------------- */
 
 /*
- * arch/i386/boot/string.c
- *
  * Very basic string functions
  */
 

commit 96ae6ea0be1b902c28b3b463c27da42b41e2b63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 11 11:16:45 2007 +0200

    i386: move boot
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c
new file mode 100644
index 000000000000..481a22097781
--- /dev/null
+++ b/arch/x86/boot/string.c
@@ -0,0 +1,52 @@
+/* -*- linux-c -*- ------------------------------------------------------- *
+ *
+ *   Copyright (C) 1991, 1992 Linus Torvalds
+ *   Copyright 2007 rPath, Inc. - All Rights Reserved
+ *
+ *   This file is part of the Linux kernel, and is made available under
+ *   the terms of the GNU General Public License version 2.
+ *
+ * ----------------------------------------------------------------------- */
+
+/*
+ * arch/i386/boot/string.c
+ *
+ * Very basic string functions
+ */
+
+#include "boot.h"
+
+int strcmp(const char *str1, const char *str2)
+{
+	const unsigned char *s1 = (const unsigned char *)str1;
+	const unsigned char *s2 = (const unsigned char *)str2;
+	int delta = 0;
+
+	while (*s1 || *s2) {
+		delta = *s2 - *s1;
+		if (delta)
+			return delta;
+		s1++;
+		s2++;
+	}
+	return 0;
+}
+
+size_t strnlen(const char *s, size_t maxlen)
+{
+	const char *es = s;
+	while (*es && maxlen) {
+		es++;
+		maxlen--;
+	}
+
+	return (es - s);
+}
+
+unsigned int atou(const char *s)
+{
+	unsigned int i = 0;
+	while (isdigit(*s))
+		i = i * 10 + (*s++ - '0');
+	return i;
+}
