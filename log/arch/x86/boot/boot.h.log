commit d5a1baddf1585885868cbab55989401fb97118c6
Author: Rikard Falkeborn <rikard.falkeborn@gmail.com>
Date:   Sun Aug 11 20:49:36 2019 +0200

    x86/boot: Use common BUILD_BUG_ON
    
    Defining BUILD_BUG_ON causes redefinition warnings when adding includes of
    include/linux/build_bug.h in files unrelated to x86/boot.  For example,
    adding an include of build_bug.h to include/linux/bits.h shows the
    following warnings:
    
      CC      arch/x86/boot/cpucheck.o
      In file included from ./include/linux/bits.h:22,
                       from ./arch/x86/include/asm/msr-index.h:5,
                       from arch/x86/boot/cpucheck.c:28:
      ./include/linux/build_bug.h:49: warning: "BUILD_BUG_ON" redefined
         49 | #define BUILD_BUG_ON(condition) \
            |
      In file included from arch/x86/boot/cpucheck.c:22:
      arch/x86/boot/boot.h:31: note: this is the location of the previous definition
         31 | #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
            |
    
    The macro was added to boot.h in commit 62bd0337d0c4 ("Top header file for
    new x86 setup code"). At that time, BUILD_BUG_ON was defined in
    kernel.h. Presumably BUILD_BUG_ON was redefined to avoid pulling in
    kernel.h. Since then, BUILD_BUG_ON and similar macros have been split to a
    separate header file.
    
    Signed-off-by: Rikard Falkeborn <rikard.falkeborn@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Link: https://lkml.kernel.org/r/20190811184938.1796-2-rikard.falkeborn@gmail.com

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 19eca14b49a0..ca866f1cca2e 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -28,8 +28,6 @@
 #include "cpuflags.h"
 
 /* Useful macros */
-#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
-
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
 
 extern struct setup_header hdr;

commit 97873a3daf611594a7f92cc88bd8c5c8c526e1a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:30 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 497
    
    Based on 1 normalized pattern(s):
    
      this file is part of the linux kernel and is made available under
      the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 28 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.534229504@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 32a09eb5c101..19eca14b49a0 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -1,12 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /* -*- linux-c -*- ------------------------------------------------------- *
  *
  *   Copyright (C) 1991, 1992 Linus Torvalds
  *   Copyright 2007 rPath, Inc. - All Rights Reserved
  *   Copyright 2009 Intel Corporation; author H. Peter Anvin
  *
- *   This file is part of the Linux kernel, and is made available under
- *   the terms of the GNU General Public License version 2.
- *
  * ----------------------------------------------------------------------- */
 
 /*

commit e8eeb3c8aab044ee8faf5e0389db8518629a9324
Author: Jordan Borgner <mail@jordan-borgner.de>
Date:   Fri Nov 2 14:56:22 2018 +0000

    x86/boot: Simplify the detect_memory*() control flow
    
    The return values of these functions are not used - so simplify the functions.
    
    No change in functionality.
    
    [ mingo: Simplified the changelog. ]
    
    Suggested: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Jordan Borgner <mail@jordan-borgner.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20181102145622.zjx2t3mdu3rv6sgy@JordanDesktop
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index ef5a9cc66fb8..32a09eb5c101 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -309,7 +309,7 @@ void query_edd(void);
 void __attribute__((noreturn)) die(void);
 
 /* memory.c */
-int detect_memory(void);
+void detect_memory(void);
 
 /* pm.c */
 void __attribute__((noreturn)) go_to_protected_mode(void);

commit d594aa0277e541bb997aef0bc0a55172d8138340
Author: Ashish Kalra <ashish@bluestacks.com>
Date:   Wed Apr 19 20:50:15 2017 +0530

    x86/boot: Fix BSS corruption/overwrite bug in early x86 kernel startup
    
    The minimum size for a new stack (512 bytes) setup for arch/x86/boot components
    when the bootloader does not setup/provide a stack for the early boot components
    is not "enough".
    
    The setup code executing as part of early kernel startup code, uses the stack
    beyond 512 bytes and accidentally overwrites and corrupts part of the BSS
    section. This is exposed mostly in the early video setup code, where
    it was corrupting BSS variables like force_x, force_y, which in-turn affected
    kernel parameters such as screen_info (screen_info.orig_video_cols) and
    later caused an exception/panic in console_init().
    
    Most recent boot loaders setup the stack for early boot components, so this
    stack overwriting into BSS section issue has not been exposed.
    
    Signed-off-by: Ashish Kalra <ashish@bluestacks.com>
    Cc: <stable@vger.kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20170419152015.10011-1-ashishkalra@Ashishs-MacBook-Pro.local
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 9b42b6d1e902..ef5a9cc66fb8 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -16,7 +16,7 @@
 #ifndef BOOT_BOOT_H
 #define BOOT_BOOT_H
 
-#define STACK_SIZE	512	/* Minimum number of bytes for stack */
+#define STACK_SIZE	1024	/* Minimum number of bytes for stack */
 
 #ifndef __ASSEMBLY__
 

commit f28442497b5caf7bf573ade22a7f8d3559e3ef56
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jan 11 16:20:01 2017 -0700

    x86/boot: Fix KASLR and memmap= collision
    
    CONFIG_RANDOMIZE_BASE=y relocates the kernel to a random base address.
    
    However it does not take into account the memmap= parameter passed in from
    the kernel command line. This results in the kernel sometimes being put in
    the middle of memmap.
    
    Teach KASLR to not insert the kernel in memmap defined regions. We support
    up to 4 memmap regions: any additional regions will cause KASLR to disable.
    
    The mem_avoid set has been augmented to add up to 4 unusable regions of
    memmaps provided by the user to exclude those regions from the set of valid
    address range to insert the uncompressed kernel image.
    
    The nn@ss ranges will be skipped by the mem_avoid set since it indicates
    that memory is useable.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Baoquan He <bhe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: dan.j.williams@intel.com
    Cc: david@fromorbit.com
    Cc: linux-nvdimm@lists.01.org
    Link: http://lkml.kernel.org/r/148417664156.131935.2248592164852799738.stgit@djiang5-desk3.ch.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index e5612f3e3b57..9b42b6d1e902 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -333,6 +333,7 @@ size_t strnlen(const char *s, size_t maxlen);
 unsigned int atou(const char *s);
 unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
 size_t strlen(const char *s);
+char *strchr(const char *s, int c);
 
 /* tty.c */
 void puts(const char *);

commit 38452af2424dc99854c78523d74b260fa8a984f0
Merge: dcb32d9913b7 be8a18e2e98e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jul 15 10:26:04 2016 +0200

    Merge branch 'x86/asm' into x86/mm, to resolve conflicts
    
     Conflicts:
            tools/testing/selftests/x86/Makefile
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit e4a84be6f05eab4778732d799f63b3cd15427885
Author: Dave Hansen <dave.hansen@linux.intel.com>
Date:   Thu Jul 7 17:19:14 2016 -0700

    x86/mm: Disallow running with 32-bit PTEs to work around erratum
    
    The Intel(R) Xeon Phi(TM) Processor x200 Family (codename: Knights
    Landing) has an erratum where a processor thread setting the Accessed
    or Dirty bits may not do so atomically against its checks for the
    Present bit.  This may cause a thread (which is about to page fault)
    to set A and/or D, even though the Present bit had already been
    atomically cleared.
    
    These bits are truly "stray".  In the case of the Dirty bit, the
    thread associated with the stray set was *not* allowed to write to
    the page.  This means that we do not have to launder the bit(s); we
    can simply ignore them.
    
    If the PTE is used for storing a swap index or a NUMA migration index,
    the A bit could be misinterpreted as part of the swap type.  The stray
    bits being set cause a software-cleared PTE to be interpreted as a
    swap entry.  In some cases (like when the swap index ends up being
    for a non-existent swapfile), the kernel detects the stray value
    and WARN()s about it, but there is no guarantee that the kernel can
    always detect it.
    
    When we have 64-bit PTEs (64-bit mode or 32-bit PAE), we were able
    to move the swap PTE format around to avoid these troublesome bits.
    But, 32-bit non-PAE is tight on bits.  So, disallow it from running
    on this hardware.  I can't imagine anyone wanting to run 32-bit
    non-highmem kernels on this hardware, but disallowing them from
    running entirely is surely the safe thing to do.
    
    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave@sr71.net>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: dave.hansen@intel.com
    Cc: linux-mm@kvack.org
    Cc: mhocko@suse.com
    Link: http://lkml.kernel.org/r/20160708001914.D0B50110@viggo.jf.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 9011a88353de..a5ce666a2423 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -294,6 +294,7 @@ static inline int cmdline_find_option_bool(const char *option)
 
 /* cpu.c, cpucheck.c */
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
+int check_knl_erratum(void);
 int validate_cpu(void);
 
 /* early_serial_console.c */

commit 66928b4eb92dfb6d87c204238057b9278b36452b
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Wed Jun 8 12:38:45 2016 -0700

    x86, asm, boot: Use CC_SET()/CC_OUT() in arch/x86/boot/boot.h
    
    Remove open-coded uses of set instructions to use CC_SET()/CC_OUT() in
    arch/x86/boot/boot.h.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Link: http://lkml.kernel.org/r/1465414726-197858-10-git-send-email-hpa@linux.intel.com
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 2edb2d53c3a2..7c1495f2b799 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -24,6 +24,7 @@
 #include <linux/types.h>
 #include <linux/edd.h>
 #include <asm/setup.h>
+#include <asm/asm.h>
 #include "bitops.h"
 #include "ctype.h"
 #include "cpuflags.h"
@@ -179,15 +180,15 @@ static inline void wrgs32(u32 v, addr_t addr)
 static inline bool memcmp_fs(const void *s1, addr_t s2, size_t len)
 {
 	bool diff;
-	asm volatile("fs; repe; cmpsb; setnz %0"
-		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	asm volatile("fs; repe; cmpsb" CC_SET(nz)
+		     : CC_OUT(nz) (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
 static inline bool memcmp_gs(const void *s1, addr_t s2, size_t len)
 {
 	bool diff;
-	asm volatile("gs; repe; cmpsb; setnz %0"
-		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	asm volatile("gs; repe; cmpsb" CC_SET(nz)
+		     : CC_OUT(nz) (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
 

commit 117780eef7740729e803bdcc0d5f2f48137ea8e3
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Jun 8 12:38:38 2016 -0700

    x86, asm: use bool for bitops and other assembly outputs
    
    The gcc people have confirmed that using "bool" when combined with
    inline assembly always is treated as a byte-sized operand that can be
    assumed to be 0 or 1, which is exactly what the SET instruction
    emits.  Change the output types and intermediate variables of as many
    operations as practical to "bool".
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Link: http://lkml.kernel.org/r/1465414726-197858-3-git-send-email-hpa@linux.intel.com
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 9011a88353de..2edb2d53c3a2 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -176,16 +176,16 @@ static inline void wrgs32(u32 v, addr_t addr)
 }
 
 /* Note: these only return true/false, not a signed return value! */
-static inline int memcmp_fs(const void *s1, addr_t s2, size_t len)
+static inline bool memcmp_fs(const void *s1, addr_t s2, size_t len)
 {
-	u8 diff;
+	bool diff;
 	asm volatile("fs; repe; cmpsb; setnz %0"
 		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
-static inline int memcmp_gs(const void *s1, addr_t s2, size_t len)
+static inline bool memcmp_gs(const void *s1, addr_t s2, size_t len)
 {
-	u8 diff;
+	bool diff;
 	asm volatile("gs; repe; cmpsb; setnz %0"
 		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;

commit 70f1528747651b20c7769d3516ade369f9963237
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Mon Nov 30 11:10:33 2015 +0100

    x86/mm: Fix regression with huge pages on PAE
    
    Recent PAT patchset has caused issue on 32-bit PAE machines:
    
      page:eea45000 count:0 mapcount:-128 mapping:  (null) index:0x0 flags: 0x40000000()
      page dumped because: VM_BUG_ON_PAGE(page_mapcount(page) < 0)
      ------------[ cut here ]------------
      kernel BUG at /home/build/linux-boris/mm/huge_memory.c:1485!
      invalid opcode: 0000 [#1] SMP
      [...]
      Call Trace:
       unmap_single_vma
       ? __wake_up
       unmap_vmas
       unmap_region
       do_munmap
       vm_munmap
       SyS_munmap
       do_fast_syscall_32
       ? __do_page_fault
       sysenter_past_esp
      Code: ...
      EIP: [<c11bde80>] zap_huge_pmd+0x240/0x260 SS:ESP 0068:f6459d98
    
    The problem is in pmd_pfn_mask() and pmd_flags_mask(). These
    helpers use PMD_PAGE_MASK to calculate resulting mask.
    PMD_PAGE_MASK is 'unsigned long', not 'unsigned long long' as
    phys_addr_t is on 32-bit PAE (ARCH_PHYS_ADDR_T_64BIT). As a
    result, the upper bits of resulting mask get truncated.
    
    pud_pfn_mask() and pud_flags_mask() aren't problematic since we
    don't have PUD page table level on 32-bit systems, but it's
    reasonable to keep them consistent with PMD counterpart.
    
    Introduce PHYSICAL_PMD_PAGE_MASK and PHYSICAL_PUD_PAGE_MASK in
    addition to existing PHYSICAL_PAGE_MASK and reworks helpers to
    use them.
    
    Reported-and-Tested-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    [ Fix -Woverflow warnings from the realmode code. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: JÃ¼rgen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: elliott@hpe.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Fixes: f70abb0fc3da ("x86/asm: Fix pud/pmd interfaces to handle large PAT bit")
    Link: http://lkml.kernel.org/r/1448878233-11390-2-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 0033e96c3f09..9011a88353de 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -23,7 +23,6 @@
 #include <stdarg.h>
 #include <linux/types.h>
 #include <linux/edd.h>
-#include <asm/boot.h>
 #include <asm/setup.h>
 #include "bitops.h"
 #include "ctype.h"

commit 949163015ce6fdb76a5e846a3582d3c40c23c001
Author: Paolo Pisati <p.pisati@gmail.com>
Date:   Mon Jul 20 18:23:50 2015 +0200

    x86/boot: Obsolete the MCA sys_desc_table
    
    The kernel does not support the MCA bus anymroe, so mark sys_desc_table
    as obsolete: remove any reference from the code together with the remaining
    of MCA logic.
    
    bloat-o-meter output:
    
      add/remove: 0/0 grow/shrink: 0/2 up/down: 0/-55 (-55)
      function                                     old     new   delta
      i386_start_kernel                            128     119      -9
      setup_arch                                  1421    1375     -46
    
    Signed-off-by: Paolo Pisati <p.pisati@gmail.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1437409430-8491-1-git-send-email-p.pisati@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index bd49ec61255c..0033e96c3f09 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -307,9 +307,6 @@ void query_edd(void);
 /* header.S */
 void __attribute__((noreturn)) die(void);
 
-/* mca.c */
-int query_mca(void);
-
 /* memory.c */
 int detect_memory(void);
 

commit fb4cac573ef6dce8d7543b68306566561c2e5725
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Tue Mar 18 15:26:39 2014 -0400

    x86, boot: Move memcmp() into string.h and string.c
    
    Try to treat memcmp() in same way as memcpy() and memset(). Provide a
    declaration in boot/string.h and by default user gets a memcmp() which
    maps to builtin function.
    
    Move optimized definition of memcmp() in boot/string.c. Now a user can
    do #undef memcmp and link against string.c to use optimzied memcmp().
    
    It also simplifies boot/compressed/string.c where we had to redefine
    memcmp(). That extra definition is gone now.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Link: http://lkml.kernel.org/r/1395170800-11059-5-git-send-email-vgoyal@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index bed9665cc7e0..bd49ec61255c 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -177,14 +177,6 @@ static inline void wrgs32(u32 v, addr_t addr)
 }
 
 /* Note: these only return true/false, not a signed return value! */
-static inline int memcmp(const void *s1, const void *s2, size_t len)
-{
-	u8 diff;
-	asm("repe; cmpsb; setnz %0"
-	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
-	return diff;
-}
-
 static inline int memcmp_fs(const void *s1, addr_t s2, size_t len)
 {
 	u8 diff;

commit c041b5ad8640dd89ccf1411cd2636ef7c1cfee92
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Tue Mar 18 15:26:37 2014 -0400

    x86, boot: Create a separate string.h file to provide standard string functions
    
    Create a separate arch/x86/boot/string.h file to provide declaration of
    some of the common string functions.
    
    By default memcpy, memset and memcmp functions will default to gcc
    builtin functions. If code wants to use an optimized version of any
    of these functions, they need to #undef the respective macro and link
    against a local file providing definition of undefed function.
    
    For example, arch/x86/boot/* code links against copy.S to get memcpy()
    and memcmp() definitions. arch/86/boot/compressed/* links against
    compressed/string.c.
    
    There are quite a few places in arch/x86/ where these functions are
    used. Idea is to try to consilidate  their declaration and possibly
    definitions so that it can be reused.
    
    I am planning to reuse boot/string.h in arch/x86/purgatory/ and use
    gcc builtin functions for memcpy, memset and memcmp.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Link: http://lkml.kernel.org/r/1395170800-11059-3-git-send-email-vgoyal@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 50f8c5e0f37e..bed9665cc7e0 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -228,11 +228,6 @@ void copy_to_fs(addr_t dst, void *src, size_t len);
 void *copy_from_fs(void *dst, addr_t src, size_t len);
 void copy_to_gs(addr_t dst, void *src, size_t len);
 void *copy_from_gs(void *dst, addr_t src, size_t len);
-void *memcpy(void *dst, void *src, size_t len);
-void *memset(void *dst, int c, size_t len);
-
-#define memcpy(d,s,l) __builtin_memcpy(d,s,l)
-#define memset(d,c,l) __builtin_memset(d,c,l)
 
 /* a20.c */
 int enable_a20(void);

commit dd78b97367bd575918204cc89107c1479d3fc1a7
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Oct 10 17:18:13 2013 -0700

    x86, boot: Move CPU flags out of cpucheck
    
    Refactor the CPU flags handling out of the cpucheck routines so that
    they can be reused by the future ASLR routines (in order to detect CPU
    features like RDRAND and RDTSC).
    
    This reworks has_eflag() and has_fpu() to be used on both 32-bit and
    64-bit, and refactors the calls to cpuid to make them PIC-safe on 32-bit.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Link: http://lkml.kernel.org/r/1381450698-28710-2-git-send-email-keescook@chromium.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index ef72baeff484..50f8c5e0f37e 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -26,9 +26,8 @@
 #include <asm/boot.h>
 #include <asm/setup.h>
 #include "bitops.h"
-#include <asm/cpufeature.h>
-#include <asm/processor-flags.h>
 #include "ctype.h"
+#include "cpuflags.h"
 
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
@@ -307,14 +306,7 @@ static inline int cmdline_find_option_bool(const char *option)
 	return __cmdline_find_option_bool(cmd_line_ptr, option);
 }
 
-
 /* cpu.c, cpucheck.c */
-struct cpu_features {
-	int level;		/* Family, or 64 for x86-64 */
-	int model;
-	u32 flags[NCAPINTS];
-};
-extern struct cpu_features cpu;
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
 int validate_cpu(void);
 

commit 062fe8fe511e7f771ef1dc824eaf996ba50a694b
Author: Fred Chen <fchen@linux.vnet.ibm.com>
Date:   Tue Aug 13 11:13:00 2013 -0700

    x86, boot: Fix warning due to undeclared strlen()
    
    Below is a patch that fixes sparse error
    "arch/x86/boot/string.c:119:8: warning: symbol 'strlen' was not
    declared." by declaring it in arch/x86/boot/boot.h.
    
    Signed-off-by: Fred Chen <fchen@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1376417580-11554-1-git-send-email-fchen@linux.vnet.ibm.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 5b7531966b84..ef72baeff484 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -355,6 +355,7 @@ int strncmp(const char *cs, const char *ct, size_t count);
 size_t strnlen(const char *s, size_t maxlen);
 unsigned int atou(const char *s);
 unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
+size_t strlen(const char *s);
 
 /* tty.c */
 void puts(const char *);

commit 3db07e70f0b4742f8daeda5c4aa8fbe7aeb3799e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Jan 24 12:19:59 2013 -0800

    x86, boot: Pass cmd_line_ptr with unsigned long instead
    
    boot/compressed/misc.c is used for bzImage in 64bit and 32bit, and
    cmd_line_ptr could point to buffer that is above 4g, cmd_line_ptr
    should be 64bit otherwise high 32bit will be capped out.
    
    So need to change data type to unsigned long, that will be 64bit get
    correct address of command line buffer.
    
    And it is still ok with 32bit bzImage, because unsigned long on 32bit kernel
    is still 32bit.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/1359058816-7615-19-git-send-email-yinghai@kernel.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 7fadf806f7ca..5b7531966b84 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -285,11 +285,11 @@ struct biosregs {
 void intcall(u8 int_no, const struct biosregs *ireg, struct biosregs *oreg);
 
 /* cmdline.c */
-int __cmdline_find_option(u32 cmdline_ptr, const char *option, char *buffer, int bufsize);
-int __cmdline_find_option_bool(u32 cmdline_ptr, const char *option);
+int __cmdline_find_option(unsigned long cmdline_ptr, const char *option, char *buffer, int bufsize);
+int __cmdline_find_option_bool(unsigned long cmdline_ptr, const char *option);
 static inline int cmdline_find_option(const char *option, char *buffer, int bufsize)
 {
-	u32 cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
+	unsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
 
 	if (cmd_line_ptr >= 0x100000)
 		return -1;      /* inaccessible */
@@ -299,7 +299,7 @@ static inline int cmdline_find_option(const char *option, char *buffer, int bufs
 
 static inline int cmdline_find_option_bool(const char *option)
 {
-	u32 cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
+	unsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
 
 	if (cmd_line_ptr >= 0x100000)
 		return -1;      /* inaccessible */

commit 16a4baa642cf448742aaf150c4daa093f9dbebbb
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Jan 24 12:19:58 2013 -0800

    x86, boot: Move checking of cmd_line_ptr out of common path
    
    cmdline.c::__cmdline_find_option... are shared between 16-bit setup code
    and 32/64 bit decompressor code.
    
    for 32/64 only path via kexec, we should not check if ptr is less 1M.
    as those cmdline could be put above 1M, or even 4G.
    
    Move out accessible checking out of __cmdline_find_option()
    So decompressor in misc.c can parse cmdline correctly.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/1359058816-7615-18-git-send-email-yinghai@kernel.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 18997e5a1053..7fadf806f7ca 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -289,12 +289,22 @@ int __cmdline_find_option(u32 cmdline_ptr, const char *option, char *buffer, int
 int __cmdline_find_option_bool(u32 cmdline_ptr, const char *option);
 static inline int cmdline_find_option(const char *option, char *buffer, int bufsize)
 {
-	return __cmdline_find_option(boot_params.hdr.cmd_line_ptr, option, buffer, bufsize);
+	u32 cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
+
+	if (cmd_line_ptr >= 0x100000)
+		return -1;      /* inaccessible */
+
+	return __cmdline_find_option(cmd_line_ptr, option, buffer, bufsize);
 }
 
 static inline int cmdline_find_option_bool(const char *option)
 {
-	return __cmdline_find_option_bool(boot_params.hdr.cmd_line_ptr, option);
+	u32 cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
+
+	if (cmd_line_ptr >= 0x100000)
+		return -1;      /* inaccessible */
+
+	return __cmdline_find_option_bool(cmd_line_ptr, option);
 }
 
 

commit 35f1790e6c6a7e4cae57b616cf36444d27fa6b28
Author: He Chunhui <hchunhui@mail.ustc.edu.cn>
Date:   Wed Feb 1 00:48:28 2012 +0800

    x86, boot: Fix port argument to inl() function
    
    "u32 port" in inl() should be "u16 port".
    
    [ hpa: it's a bug, but it doesn't produce incorrect code, so no need
      to put this into urgent or stable. ]
    
    Signed-off-by: He Chunhui <hchunhui@mail.ustc.edu.cn>
    Link: http://lkml.kernel.org/r/32892299.2931391328028508117.JavaMail.coremail@mailweb
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index c7093bd9f2d3..18997e5a1053 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -67,7 +67,7 @@ static inline void outl(u32 v, u16 port)
 {
 	asm volatile("outl %0,%1" : : "a" (v), "dN" (port));
 }
-static inline u32 inl(u32 port)
+static inline u32 inl(u16 port)
 {
 	u32 v;
 	asm volatile("inl %1,%0" : "=a" (v) : "dN" (port));

commit 6238b47b58480cd9c092600c05338dbe261b71ce
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Mon Aug 2 21:03:46 2010 -0700

    x86, setup: move isdigit.h to ctype.h, header files on top.
    
    It is a subset of <ctype.h> functionality, so name it ctype.h.  Also,
    reorganize header files so #include statements are clustered near the
    top as they should be.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    LKML-Reference: <4C5752F2.8030206@kernel.org>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 00cf51cfc2e6..c7093bd9f2d3 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -28,6 +28,7 @@
 #include "bitops.h"
 #include <asm/cpufeature.h>
 #include <asm/processor-flags.h>
+#include "ctype.h"
 
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
@@ -200,8 +201,6 @@ static inline int memcmp_gs(const void *s1, addr_t s2, size_t len)
 	return diff;
 }
 
-#include "isdigit.h"
-
 /* Heap -- available for dynamic lists. */
 extern char _end[];
 extern char *HEAP;

commit f4ed2877b16e8146427306aea8819adac5c88374
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Aug 2 02:17:31 2010 -0700

    x86, setup: reorganize the early console setup
    
    Separate early_serial_console from tty.c
    
    This allows for reuse of
    early_serial_console.c/string.c/printf.c/cmdline.c in boot/compressed/.
    
    -v2: according to hpa, don't include string.c etc
    -v3: compressed/misc.c must have early_serial_base as static, so move it back to tty.c
         for setup code
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <4C568D2B.205@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 46c4c5c71af7..00cf51cfc2e6 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -200,21 +200,7 @@ static inline int memcmp_gs(const void *s1, addr_t s2, size_t len)
 	return diff;
 }
 
-static inline int isdigit(int ch)
-{
-	return (ch >= '0') && (ch <= '9');
-}
-
-static inline int isxdigit(int ch)
-{
-	if (isdigit(ch))
-		return true;
-
-	if ((ch >= 'a') && (ch <= 'f'))
-		return true;
-
-	return (ch >= 'A') && (ch <= 'F');
-}
+#include "isdigit.h"
 
 /* Heap -- available for dynamic lists. */
 extern char _end[];
@@ -300,8 +286,18 @@ struct biosregs {
 void intcall(u8 int_no, const struct biosregs *ireg, struct biosregs *oreg);
 
 /* cmdline.c */
-int cmdline_find_option(const char *option, char *buffer, int bufsize);
-int cmdline_find_option_bool(const char *option);
+int __cmdline_find_option(u32 cmdline_ptr, const char *option, char *buffer, int bufsize);
+int __cmdline_find_option_bool(u32 cmdline_ptr, const char *option);
+static inline int cmdline_find_option(const char *option, char *buffer, int bufsize)
+{
+	return __cmdline_find_option(boot_params.hdr.cmd_line_ptr, option, buffer, bufsize);
+}
+
+static inline int cmdline_find_option_bool(const char *option)
+{
+	return __cmdline_find_option_bool(boot_params.hdr.cmd_line_ptr, option);
+}
+
 
 /* cpu.c, cpucheck.c */
 struct cpu_features {
@@ -313,6 +309,10 @@ extern struct cpu_features cpu;
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
 int validate_cpu(void);
 
+/* early_serial_console.c */
+extern int early_serial_base;
+void console_init(void);
+
 /* edd.c */
 void query_edd(void);
 
@@ -348,7 +348,6 @@ unsigned int atou(const char *s);
 unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
 
 /* tty.c */
-void console_init(void);
 void puts(const char *);
 void putchar(int);
 int getchar(void);

commit fa97bdf92709adaaf8b9a5164a895e262a4fcf60
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Sun Jul 11 11:06:57 2010 +0300

    x86, setup: Early-boot serial I/O support
    
    This patch adds serial I/O support to the real-mode setup (very early
    boot) printf(). It's useful for debugging boot code when running Linux
    under KVM, for example. The actual code was lifted from early printk.
    
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    LKML-Reference: <1278835617-11368-1-git-send-email-penberg@cs.helsinki.fi>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 98239d2658f2..46c4c5c71af7 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -37,6 +37,8 @@
 extern struct setup_header hdr;
 extern struct boot_params boot_params;
 
+#define cpu_relax()	asm volatile("rep; nop")
+
 /* Basic port I/O */
 static inline void outb(u8 v, u16 port)
 {
@@ -203,6 +205,17 @@ static inline int isdigit(int ch)
 	return (ch >= '0') && (ch <= '9');
 }
 
+static inline int isxdigit(int ch)
+{
+	if (isdigit(ch))
+		return true;
+
+	if ((ch >= 'a') && (ch <= 'f'))
+		return true;
+
+	return (ch >= 'A') && (ch <= 'F');
+}
+
 /* Heap -- available for dynamic lists. */
 extern char _end[];
 extern char *HEAP;
@@ -329,10 +342,13 @@ void initregs(struct biosregs *regs);
 
 /* string.c */
 int strcmp(const char *str1, const char *str2);
+int strncmp(const char *cs, const char *ct, size_t count);
 size_t strnlen(const char *s, size_t maxlen);
 unsigned int atou(const char *s);
+unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
 
 /* tty.c */
+void console_init(void);
 void puts(const char *);
 void putchar(int);
 int getchar(void);

commit 7a734e7dd93b9aea08ed51036a9a0e2c9dfd8dac
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Wed Apr 1 18:08:28 2009 -0700

    x86, setup: "glove box" BIOS calls -- infrastructure
    
    Impact: new interfaces (not yet used)
    
    For all the platforms out there, there is an infinite number of buggy
    BIOSes.  This adds infrastructure to treat BIOS interrupts more like
    toxic waste and "glove box" them -- we switch out the register set,
    perform the BIOS interrupt, and then restore the previous state.
    
    LKML-Reference: <49DE7F79.4030106@zytor.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 7b2692e897e5..98239d2658f2 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -2,6 +2,7 @@
  *
  *   Copyright (C) 1991, 1992 Linus Torvalds
  *   Copyright 2007 rPath, Inc. - All Rights Reserved
+ *   Copyright 2009 Intel Corporation; author H. Peter Anvin
  *
  *   This file is part of the Linux kernel, and is made available under
  *   the terms of the GNU General Public License version 2.
@@ -26,6 +27,7 @@
 #include <asm/setup.h>
 #include "bitops.h"
 #include <asm/cpufeature.h>
+#include <asm/processor-flags.h>
 
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
@@ -241,6 +243,49 @@ int enable_a20(void);
 /* apm.c */
 int query_apm_bios(void);
 
+/* bioscall.c */
+struct biosregs {
+	union {
+		struct {
+			u32 edi;
+			u32 esi;
+			u32 ebp;
+			u32 _esp;
+			u32 ebx;
+			u32 edx;
+			u32 ecx;
+			u32 eax;
+			u32 _fsgs;
+			u32 _dses;
+			u32 eflags;
+		};
+		struct {
+			u16 di, hdi;
+			u16 si, hsi;
+			u16 bp, hbp;
+			u16 _sp, _hsp;
+			u16 bx, hbx;
+			u16 dx, hdx;
+			u16 cx, hcx;
+			u16 ax, hax;
+			u16 gs, fs;
+			u16 es, ds;
+			u16 flags, hflags;
+		};
+		struct {
+			u8 dil, dih, edi2, edi3;
+			u8 sil, sih, esi2, esi3;
+			u8 bpl, bph, ebp2, ebp3;
+			u8 _spl, _sph, _esp2, _esp3;
+			u8 bl, bh, ebx2, ebx3;
+			u8 dl, dh, edx2, edx3;
+			u8 cl, ch, ecx2, ecx3;
+			u8 al, ah, eax2, eax3;
+		};
+	};
+};
+void intcall(u8 int_no, const struct biosregs *ireg, struct biosregs *oreg);
+
 /* cmdline.c */
 int cmdline_find_option(const char *option, char *buffer, int bufsize);
 int cmdline_find_option_bool(const char *option);
@@ -279,6 +324,9 @@ int sprintf(char *buf, const char *fmt, ...);
 int vsprintf(char *buf, const char *fmt, va_list args);
 int printf(const char *fmt, ...);
 
+/* regs.c */
+void initregs(struct biosregs *regs);
+
 /* string.c */
 int strcmp(const char *str1, const char *str2);
 size_t strnlen(const char *s, size_t maxlen);

commit 965c7ecaf2e2b083d711a01ab33735a4bdeee1a4
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 23:19:12 2009 +0100

    x86: remove the Voyager 32-bit subarch
    
    Impact: remove unused/broken code
    
    The Voyager subarch last built successfully on the v2.6.26 kernel
    and has been stale since then and does not build on the v2.6.27,
    v2.6.28 and v2.6.29-rc5 kernels.
    
    No actual users beyond the maintainer reported this breakage.
    Patches were sent and most of the fixes were accepted but the
    discussion around how to do a few remaining issues cleanly
    fizzled out with no resolution and the code remained broken.
    
    In the v2.6.30 x86 tree development cycle 32-bit subarch support
    has been reworked and removed - and the Voyager code, beyond the
    build problems already known, needs serious and significant
    changes and probably a rewrite to support it.
    
    CONFIG_X86_VOYAGER has been marked BROKEN then. The maintainer has
    been notified but no patches have been sent so far to fix it.
    
    While all other subarchs have been converted to the new scheme,
    voyager is still broken. We'd prefer to receive patches which
    clean up the current situation in a constructive way, but even in
    case of removal there is no obstacle to add that support back
    after the issues have been sorted out in a mutually acceptable
    fashion.
    
    So remove this inactive code for now.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index cc0ef13fba7a..7b2692e897e5 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -302,9 +302,6 @@ void probe_cards(int unsafe);
 /* video-vesa.c */
 void vesa_store_edid(void);
 
-/* voyager.c */
-int query_voyager(void);
-
 #endif /* __ASSEMBLY__ */
 
 #endif /* BOOT_BOOT_H */

commit 1b72691ce35812ff865d778f303779e774d2b098
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Aug 18 09:06:01 2008 +0200

    x86: fix build warnings in real mode code
    
    This recent patch
    
    commit c3965bd15118742d72b4bc1a290d37b3f081eb98
    Author: Paul Jackson <pj@sgi.com>
    Date:   Wed May 14 08:15:34 2008 -0700
    
        x86 boot: proper use of ARRAY_SIZE instead of repeated E820MAX constant
    
    caused these new warnings during a normal build:
    
    In file included from linux-2.6/arch/x86/boot/memory.c:17:
    linux-2.6/include/linux/log2.h: In function '__ilog2_u32':
    linux-2.6/include/linux/log2.h:34: warning: implicit declaration of function 'fls'
    linux-2.6/include/linux/log2.h: In function '__ilog2_u64':
    linux-2.6/include/linux/log2.h:42: warning: implicit declaration of function 'fls64'
    linux-2.6/include/linux/log2.h: In function '__roundup_pow_of_two ':
    linux-2.6/include/linux/log2.h:63: warning: implicit declaration of function 'fls_long'
    
    I tried to fix them in log2.h, but it's difficult because the real mode
    environment is completely different from a normal kernel environment. Instead
    define an own ARRAY_SIZE macro in boot.h, similar to the other private
    macros there.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 616b804a2295..cc0ef13fba7a 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -30,6 +30,8 @@
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
+
 extern struct setup_header hdr;
 extern struct boot_params boot_params;
 

commit c2dcfde8274883e1f6050784dcbd34b01e824b91
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Aug 13 13:14:22 2008 -0700

    x86: cleanup for setup code crashes during IST probe
    
    Clean up the code for crashes during SpeedStep probing on older
    machines.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 9d4b4b43d97a..616b804a2295 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -24,8 +24,8 @@
 #include <linux/edd.h>
 #include <asm/boot.h>
 #include <asm/setup.h>
-
-#define NCAPINTS   8
+#include "bitops.h"
+#include <asm/cpufeature.h>
 
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))

commit 7b27718bdb1b70166383dec91391df5534d449ee
Author: Joerg Roedel <joro@8bytes.org>
Date:   Wed Aug 13 10:07:05 2008 +0200

    x86: fix setup code crashes on my old 486 box
    
    yesterday I tried to reactivate my old 486 box and wanted to install a
    current Linux with latest kernel on it. But it turned out that the
    latest kernel does not boot because the machine crashes early in the
    setup code.
    
    After some debugging it turned out that the problem is the query_ist()
    function. If this interrupt with that function is called the machine
    simply locks up. It looks like a BIOS bug. Looking for a workaround for
    this problem I wrote the attached patch. It checks for the CPUID
    instruction and if it is not implemented it does not call the speedstep
    BIOS function. As far as I know speedstep should be available since some
    Pentium earliest.
    
    Alan Cox observed that it's available since the Pentium II, so cpuid
    levels 4 and 5 can be excluded altogether.
    
    H. Peter Anvin cleaned up the code some more:
    
    > Right in concept, but I dislike the implementation (duplication of the
    > CPU detect code we already have).  Could you try this patch and see if
    > it works for you?
    
    which, with a small modification to fix a build error with it the
    resulting kernel boots on my machine.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: "H. Peter Anvin" <hpa@zytor.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index a34b9982c7cb..9d4b4b43d97a 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -25,6 +25,8 @@
 #include <asm/boot.h>
 #include <asm/setup.h>
 
+#define NCAPINTS   8
+
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 
@@ -242,6 +244,12 @@ int cmdline_find_option(const char *option, char *buffer, int bufsize);
 int cmdline_find_option_bool(const char *option);
 
 /* cpu.c, cpucheck.c */
+struct cpu_features {
+	int level;		/* Family, or 64 for x86-64 */
+	int model;
+	u32 flags[NCAPINTS];
+};
+extern struct cpu_features cpu;
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
 int validate_cpu(void);
 

commit cf9b111c170733dde39139e8989b676ec8b81573
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Sat Mar 8 18:15:06 2008 +0800

    x86: remove pointless comments
    
    Remove old comments that include the old arch/i386 directory.
    
    Signed-off-by: WANG Cong <xiyou.wangcong@gmail.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 09578070bfba..a34b9982c7cb 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -9,8 +9,6 @@
  * ----------------------------------------------------------------------- */
 
 /*
- * arch/i386/boot/boot.h
- *
  * Header file for the real-mode kernel code
  */
 

commit e44b7b7525ad9d43163ab5e60c784325419e0ea6
Author: Pavel Machek <pavel@suse.cz>
Date:   Thu Apr 10 23:28:10 2008 +0200

    x86: move suspend wakeup code to C
    
    Move wakeup code to .c, so that video mode setting code can be shared
    between boot and wakeup. Remove nasty assembly code in 64-bit case by
    re-using trampoline code. Stack setup was fixed to clear high 16bits
    of %esp, maybe that fixes some machines.
    
    .c code sharing and morse code was done H. Peter Anvin, Sam Ravnborg
    reviewed kbuild related stuff, and it seems okay to him. Rafael did
    some cleanups.
    
    [rjw:
    * Made the patch stop breaking compilation on x86-32
    * Added arch/x86/kernel/acpi/sleep.h
    * Got rid of compiler warnings in arch/x86/kernel/acpi/sleep.c
    * Fixed 32-bit compilation on x86-64 systems
    * Added include/asm-x86/trampoline.h and fixed the non-SMP
      compilation on 64-bit x86
    * Removed arch/x86/kernel/acpi/sleep_32.c which was not used
    * Fixed some breakage caused by the integration of smpboot.c done
      under us in the meantime]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 7822a4983da2..09578070bfba 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -286,6 +286,11 @@ int getchar_timeout(void);
 /* video.c */
 void set_video(void);
 
+/* video-mode.c */
+int set_mode(u16 mode);
+int mode_defined(u16 mode);
+void probe_cards(int unsafe);
+
 /* video-vesa.c */
 void vesa_store_edid(void);
 

commit 70d8abf5df857ca7befe02e5d61fde807420a54c
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Jan 30 13:33:03 2008 +0100

    x86 setup: add missing prototype; formatting fix
    
    Add prototype for cmdline_find_option_bool() missing from:
    
        x86 setup: early cmdline parser handle boolean options
    
    Also, fix up a minor formatting error in that patch.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 8ec575249aa9..7822a4983da2 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -241,6 +241,7 @@ int query_apm_bios(void);
 
 /* cmdline.c */
 int cmdline_find_option(const char *option, char *buffer, int bufsize);
+int cmdline_find_option_bool(const char *option);
 
 /* cpu.c, cpucheck.c */
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);

commit 811a0fff5d6e80e18e06be88e0fb685f3924bf8f
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Jan 30 13:33:02 2008 +0100

    x86 setup: fix constraints in segment accessor functions
    
    Fix the operand constraints for the segment accessor functions,
    {rd,wr}{fs,gs}*.  In particular, the 8-bit functions used "r"
    constraints instead of "q" constraints.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index d2b5adf46512..8ec575249aa9 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -109,7 +109,7 @@ typedef unsigned int addr_t;
 static inline u8 rdfs8(addr_t addr)
 {
 	u8 v;
-	asm volatile("movb %%fs:%1,%0" : "=r" (v) : "m" (*(u8 *)addr));
+	asm volatile("movb %%fs:%1,%0" : "=q" (v) : "m" (*(u8 *)addr));
 	return v;
 }
 static inline u16 rdfs16(addr_t addr)
@@ -127,21 +127,21 @@ static inline u32 rdfs32(addr_t addr)
 
 static inline void wrfs8(u8 v, addr_t addr)
 {
-	asm volatile("movb %1,%%fs:%0" : "+m" (*(u8 *)addr) : "r" (v));
+	asm volatile("movb %1,%%fs:%0" : "+m" (*(u8 *)addr) : "qi" (v));
 }
 static inline void wrfs16(u16 v, addr_t addr)
 {
-	asm volatile("movw %1,%%fs:%0" : "+m" (*(u16 *)addr) : "r" (v));
+	asm volatile("movw %1,%%fs:%0" : "+m" (*(u16 *)addr) : "ri" (v));
 }
 static inline void wrfs32(u32 v, addr_t addr)
 {
-	asm volatile("movl %1,%%fs:%0" : "+m" (*(u32 *)addr) : "r" (v));
+	asm volatile("movl %1,%%fs:%0" : "+m" (*(u32 *)addr) : "ri" (v));
 }
 
 static inline u8 rdgs8(addr_t addr)
 {
 	u8 v;
-	asm volatile("movb %%gs:%1,%0" : "=r" (v) : "m" (*(u8 *)addr));
+	asm volatile("movb %%gs:%1,%0" : "=q" (v) : "m" (*(u8 *)addr));
 	return v;
 }
 static inline u16 rdgs16(addr_t addr)
@@ -159,15 +159,15 @@ static inline u32 rdgs32(addr_t addr)
 
 static inline void wrgs8(u8 v, addr_t addr)
 {
-	asm volatile("movb %1,%%gs:%0" : "+m" (*(u8 *)addr) : "r" (v));
+	asm volatile("movb %1,%%gs:%0" : "+m" (*(u8 *)addr) : "qi" (v));
 }
 static inline void wrgs16(u16 v, addr_t addr)
 {
-	asm volatile("movw %1,%%gs:%0" : "+m" (*(u16 *)addr) : "r" (v));
+	asm volatile("movw %1,%%gs:%0" : "+m" (*(u16 *)addr) : "ri" (v));
 }
 static inline void wrgs32(u32 v, addr_t addr)
 {
-	asm volatile("movl %1,%%gs:%0" : "+m" (*(u32 *)addr) : "r" (v));
+	asm volatile("movl %1,%%gs:%0" : "+m" (*(u32 *)addr) : "ri" (v));
 }
 
 /* Note: these only return true/false, not a signed return value! */

commit e6e1ace9904b72478f0c5a5aa7bd174cb6f62561
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Thu Oct 25 16:09:38 2007 -0700

    x86 setup: sizeof() is unsigned, unbreak comparisons
    
    We use signed values for limit checking since the values can go
    negative under certain circumstances.  However, sizeof() is unsigned
    and forces the comparison to be unsigned, so move the comparison into
    the heap_free() macros so we can ensure it is a signed comparison.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 887874f4b49f..d2b5adf46512 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -216,9 +216,9 @@ static inline char *__get_heap(size_t s, size_t a, size_t n)
 #define GET_HEAP(type, n) \
 	((type *)__get_heap(sizeof(type),__alignof__(type),(n)))
 
-static inline int heap_free(void)
+static inline bool heap_free(size_t n)
 {
-	return heap_end-HEAP;
+	return (int)(heap_end-HEAP) >= (int)n;
 }
 
 /* copy.S */

commit 6b6815c6d5d1dc209701d1661a7a0e09a295db2f
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Thu Oct 25 16:11:33 2007 -0700

    x86 setup: handle boot loaders which set up the stack incorrectly
    
    Apparently some specific versions of LILO enter the kernel with a
    stack pointer that doesn't match the rest of the segments.  Make our
    best attempt at untangling the resulting mess.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 5f9a2e72a731..887874f4b49f 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -17,6 +17,8 @@
 #ifndef BOOT_BOOT_H
 #define BOOT_BOOT_H
 
+#define STACK_SIZE	512	/* Minimum number of bytes for stack */
+
 #ifndef __ASSEMBLY__
 
 #include <stdarg.h>
@@ -198,8 +200,6 @@ static inline int isdigit(int ch)
 }
 
 /* Heap -- available for dynamic lists. */
-#define STACK_SIZE	512	/* Minimum number of bytes for stack */
-
 extern char _end[];
 extern char *HEAP;
 extern char *heap_end;

commit fa76dab935b856871024530ec818bc0a8f88a016
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Oct 23 22:37:25 2007 +0200

    x86: clean up setup.h and the boot code
    
    Make <asm/setup.h> usable by the boot code.
    
    Clean up vestiges of the old command-line protocol from setup.h and
    head_32.S (it is still supported from the boot loader point of
    view, since it is converted to the new command-line protocol by the
    boot code.)
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index 20bab9431acb..5f9a2e72a731 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -23,7 +23,7 @@
 #include <linux/types.h>
 #include <linux/edd.h>
 #include <asm/boot.h>
-#include <asm/bootparam.h>
+#include <asm/setup.h>
 
 /* Useful macros */
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))

commit 96ae6ea0be1b902c28b3b463c27da42b41e2b63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 11 11:16:45 2007 +0200

    i386: move boot
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
new file mode 100644
index 000000000000..20bab9431acb
--- /dev/null
+++ b/arch/x86/boot/boot.h
@@ -0,0 +1,296 @@
+/* -*- linux-c -*- ------------------------------------------------------- *
+ *
+ *   Copyright (C) 1991, 1992 Linus Torvalds
+ *   Copyright 2007 rPath, Inc. - All Rights Reserved
+ *
+ *   This file is part of the Linux kernel, and is made available under
+ *   the terms of the GNU General Public License version 2.
+ *
+ * ----------------------------------------------------------------------- */
+
+/*
+ * arch/i386/boot/boot.h
+ *
+ * Header file for the real-mode kernel code
+ */
+
+#ifndef BOOT_BOOT_H
+#define BOOT_BOOT_H
+
+#ifndef __ASSEMBLY__
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <linux/edd.h>
+#include <asm/boot.h>
+#include <asm/bootparam.h>
+
+/* Useful macros */
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+
+extern struct setup_header hdr;
+extern struct boot_params boot_params;
+
+/* Basic port I/O */
+static inline void outb(u8 v, u16 port)
+{
+	asm volatile("outb %0,%1" : : "a" (v), "dN" (port));
+}
+static inline u8 inb(u16 port)
+{
+	u8 v;
+	asm volatile("inb %1,%0" : "=a" (v) : "dN" (port));
+	return v;
+}
+
+static inline void outw(u16 v, u16 port)
+{
+	asm volatile("outw %0,%1" : : "a" (v), "dN" (port));
+}
+static inline u16 inw(u16 port)
+{
+	u16 v;
+	asm volatile("inw %1,%0" : "=a" (v) : "dN" (port));
+	return v;
+}
+
+static inline void outl(u32 v, u16 port)
+{
+	asm volatile("outl %0,%1" : : "a" (v), "dN" (port));
+}
+static inline u32 inl(u32 port)
+{
+	u32 v;
+	asm volatile("inl %1,%0" : "=a" (v) : "dN" (port));
+	return v;
+}
+
+static inline void io_delay(void)
+{
+	const u16 DELAY_PORT = 0x80;
+	asm volatile("outb %%al,%0" : : "dN" (DELAY_PORT));
+}
+
+/* These functions are used to reference data in other segments. */
+
+static inline u16 ds(void)
+{
+	u16 seg;
+	asm("movw %%ds,%0" : "=rm" (seg));
+	return seg;
+}
+
+static inline void set_fs(u16 seg)
+{
+	asm volatile("movw %0,%%fs" : : "rm" (seg));
+}
+static inline u16 fs(void)
+{
+	u16 seg;
+	asm volatile("movw %%fs,%0" : "=rm" (seg));
+	return seg;
+}
+
+static inline void set_gs(u16 seg)
+{
+	asm volatile("movw %0,%%gs" : : "rm" (seg));
+}
+static inline u16 gs(void)
+{
+	u16 seg;
+	asm volatile("movw %%gs,%0" : "=rm" (seg));
+	return seg;
+}
+
+typedef unsigned int addr_t;
+
+static inline u8 rdfs8(addr_t addr)
+{
+	u8 v;
+	asm volatile("movb %%fs:%1,%0" : "=r" (v) : "m" (*(u8 *)addr));
+	return v;
+}
+static inline u16 rdfs16(addr_t addr)
+{
+	u16 v;
+	asm volatile("movw %%fs:%1,%0" : "=r" (v) : "m" (*(u16 *)addr));
+	return v;
+}
+static inline u32 rdfs32(addr_t addr)
+{
+	u32 v;
+	asm volatile("movl %%fs:%1,%0" : "=r" (v) : "m" (*(u32 *)addr));
+	return v;
+}
+
+static inline void wrfs8(u8 v, addr_t addr)
+{
+	asm volatile("movb %1,%%fs:%0" : "+m" (*(u8 *)addr) : "r" (v));
+}
+static inline void wrfs16(u16 v, addr_t addr)
+{
+	asm volatile("movw %1,%%fs:%0" : "+m" (*(u16 *)addr) : "r" (v));
+}
+static inline void wrfs32(u32 v, addr_t addr)
+{
+	asm volatile("movl %1,%%fs:%0" : "+m" (*(u32 *)addr) : "r" (v));
+}
+
+static inline u8 rdgs8(addr_t addr)
+{
+	u8 v;
+	asm volatile("movb %%gs:%1,%0" : "=r" (v) : "m" (*(u8 *)addr));
+	return v;
+}
+static inline u16 rdgs16(addr_t addr)
+{
+	u16 v;
+	asm volatile("movw %%gs:%1,%0" : "=r" (v) : "m" (*(u16 *)addr));
+	return v;
+}
+static inline u32 rdgs32(addr_t addr)
+{
+	u32 v;
+	asm volatile("movl %%gs:%1,%0" : "=r" (v) : "m" (*(u32 *)addr));
+	return v;
+}
+
+static inline void wrgs8(u8 v, addr_t addr)
+{
+	asm volatile("movb %1,%%gs:%0" : "+m" (*(u8 *)addr) : "r" (v));
+}
+static inline void wrgs16(u16 v, addr_t addr)
+{
+	asm volatile("movw %1,%%gs:%0" : "+m" (*(u16 *)addr) : "r" (v));
+}
+static inline void wrgs32(u32 v, addr_t addr)
+{
+	asm volatile("movl %1,%%gs:%0" : "+m" (*(u32 *)addr) : "r" (v));
+}
+
+/* Note: these only return true/false, not a signed return value! */
+static inline int memcmp(const void *s1, const void *s2, size_t len)
+{
+	u8 diff;
+	asm("repe; cmpsb; setnz %0"
+	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	return diff;
+}
+
+static inline int memcmp_fs(const void *s1, addr_t s2, size_t len)
+{
+	u8 diff;
+	asm volatile("fs; repe; cmpsb; setnz %0"
+		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	return diff;
+}
+static inline int memcmp_gs(const void *s1, addr_t s2, size_t len)
+{
+	u8 diff;
+	asm volatile("gs; repe; cmpsb; setnz %0"
+		     : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
+	return diff;
+}
+
+static inline int isdigit(int ch)
+{
+	return (ch >= '0') && (ch <= '9');
+}
+
+/* Heap -- available for dynamic lists. */
+#define STACK_SIZE	512	/* Minimum number of bytes for stack */
+
+extern char _end[];
+extern char *HEAP;
+extern char *heap_end;
+#define RESET_HEAP() ((void *)( HEAP = _end ))
+static inline char *__get_heap(size_t s, size_t a, size_t n)
+{
+	char *tmp;
+
+	HEAP = (char *)(((size_t)HEAP+(a-1)) & ~(a-1));
+	tmp = HEAP;
+	HEAP += s*n;
+	return tmp;
+}
+#define GET_HEAP(type, n) \
+	((type *)__get_heap(sizeof(type),__alignof__(type),(n)))
+
+static inline int heap_free(void)
+{
+	return heap_end-HEAP;
+}
+
+/* copy.S */
+
+void copy_to_fs(addr_t dst, void *src, size_t len);
+void *copy_from_fs(void *dst, addr_t src, size_t len);
+void copy_to_gs(addr_t dst, void *src, size_t len);
+void *copy_from_gs(void *dst, addr_t src, size_t len);
+void *memcpy(void *dst, void *src, size_t len);
+void *memset(void *dst, int c, size_t len);
+
+#define memcpy(d,s,l) __builtin_memcpy(d,s,l)
+#define memset(d,c,l) __builtin_memset(d,c,l)
+
+/* a20.c */
+int enable_a20(void);
+
+/* apm.c */
+int query_apm_bios(void);
+
+/* cmdline.c */
+int cmdline_find_option(const char *option, char *buffer, int bufsize);
+
+/* cpu.c, cpucheck.c */
+int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
+int validate_cpu(void);
+
+/* edd.c */
+void query_edd(void);
+
+/* header.S */
+void __attribute__((noreturn)) die(void);
+
+/* mca.c */
+int query_mca(void);
+
+/* memory.c */
+int detect_memory(void);
+
+/* pm.c */
+void __attribute__((noreturn)) go_to_protected_mode(void);
+
+/* pmjump.S */
+void __attribute__((noreturn))
+	protected_mode_jump(u32 entrypoint, u32 bootparams);
+
+/* printf.c */
+int sprintf(char *buf, const char *fmt, ...);
+int vsprintf(char *buf, const char *fmt, va_list args);
+int printf(const char *fmt, ...);
+
+/* string.c */
+int strcmp(const char *str1, const char *str2);
+size_t strnlen(const char *s, size_t maxlen);
+unsigned int atou(const char *s);
+
+/* tty.c */
+void puts(const char *);
+void putchar(int);
+int getchar(void);
+void kbd_flush(void);
+int getchar_timeout(void);
+
+/* video.c */
+void set_video(void);
+
+/* video-vesa.c */
+void vesa_store_edid(void);
+
+/* voyager.c */
+int query_voyager(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* BOOT_BOOT_H */
