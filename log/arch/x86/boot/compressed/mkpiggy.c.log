commit 04672fe6d69835f67ff6ffdbeb16db9fa21c10bb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:42 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 268
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 46 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141334.135501091@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index 72bad2c8debe..7e01248765b2 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -1,27 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* ----------------------------------------------------------------------- *
  *
  *  Copyright (C) 2009 Intel Corporation. All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License version
- *  2 as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- *  02110-1301, USA.
- *
  *  H. Peter Anvin <hpa@linux.intel.com>
  *
  * -----------------------------------------------------------------------
  *
  * Outputs a small assembly wrapper with the appropriate symbols defined.
- *
  */
 
 #include <stdlib.h>

commit 4d2d542482205d3df1a0852751f5b004cc6390cc
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 28 17:09:07 2016 -0700

    x86/KASLR: Clean up unused code from old 'run_size' and rename it to 'kernel_total_size'
    
    Since 'run_size' is now calculated in misc.c, the old script and associated
    argument passing is no longer needed. This patch removes them, and renames
    'run_size' to the more descriptive 'kernel_total_size'.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Baoquan He <bhe@redhat.com>
    [ Rewrote the changelog, renamed 'run_size' to 'kernel_total_size' ]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Junjie Mao <eternal.n08@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: lasse.collin@tukaani.org
    Link: http://lkml.kernel.org/r/1461888548-32439-6-git-send-email-keescook@chromium.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index f095ed9e7d3c..72bad2c8debe 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -34,13 +34,11 @@ int main(int argc, char *argv[])
 {
 	uint32_t olen;
 	long ilen;
-	unsigned long run_size;
 	FILE *f = NULL;
 	int retval = 1;
 
-	if (argc < 3) {
-		fprintf(stderr, "Usage: %s compressed_file run_size\n",
-				argv[0]);
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s compressed_file\n", argv[0]);
 		goto bail;
 	}
 
@@ -65,15 +63,11 @@ int main(int argc, char *argv[])
 	ilen = ftell(f);
 	olen = get_unaligned_le32(&olen);
 
-	run_size = atoi(argv[2]);
-
 	printf(".section \".rodata..compressed\",\"a\",@progbits\n");
 	printf(".globl z_input_len\n");
 	printf("z_input_len = %lu\n", ilen);
 	printf(".globl z_output_len\n");
 	printf("z_output_len = %lu\n", (unsigned long)olen);
-	printf(".globl z_run_size\n");
-	printf("z_run_size = %lu\n", run_size);
 
 	printf(".globl input_data, input_data_end\n");
 	printf("input_data:\n");

commit d607251ba9acc0b5faeaa08818f60d041dd19472
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 28 17:09:05 2016 -0700

    x86/boot: Calculate decompression size during boot not build
    
    Currently z_extract_offset is calculated in boot/compressed/mkpiggy.c.
    This doesn't work well because mkpiggy.c doesn't know the details of the
    decompressor in use. As a result, it can only make an estimation, which
    has risks:
    
     - output + output_len (VO) could be much bigger than input + input_len
       (ZO). In this case, the decompressed kernel plus relocs could overwrite
       the decompression code while it is running.
    
     - The head code of ZO could be bigger than z_extract_offset. In this case
       an overwrite could happen when the head code is running to move ZO to
       the end of buffer. Though currently the size of the head code is very
       small it's still a potential risk. Since there is no rule to limit the
       size of the head code of ZO, it runs the risk of suddenly becoming a
       (hard to find) bug.
    
    Instead, this moves the z_extract_offset calculation into header.S, and
    makes adjustments to be sure that the above two cases can never happen,
    and further corrects the comments describing the calculations.
    
    Since we have (in the previous patch) made ZO always be located against
    the end of decompression buffer, z_extract_offset is only used here to
    calculate an appropriate buffer size (INIT_SIZE), and is not longer used
    elsewhere. As such, it can be removed from voffset.h.
    
    Additionally clean up #if/#else #define to improve readability.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Baoquan He <bhe@redhat.com>
    [ Rewrote the changelog and comments. ]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: lasse.collin@tukaani.org
    Link: http://lkml.kernel.org/r/1461888548-32439-4-git-send-email-keescook@chromium.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index b980046c3329..f095ed9e7d3c 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -18,11 +18,10 @@
  *
  *  H. Peter Anvin <hpa@linux.intel.com>
  *
- * ----------------------------------------------------------------------- */
-
-/*
- * Compute the desired load offset from a compressed program; outputs
- * a small assembly wrapper with the appropriate symbols defined.
+ * -----------------------------------------------------------------------
+ *
+ * Outputs a small assembly wrapper with the appropriate symbols defined.
+ *
  */
 
 #include <stdlib.h>
@@ -35,7 +34,6 @@ int main(int argc, char *argv[])
 {
 	uint32_t olen;
 	long ilen;
-	unsigned long offs;
 	unsigned long run_size;
 	FILE *f = NULL;
 	int retval = 1;
@@ -67,15 +65,6 @@ int main(int argc, char *argv[])
 	ilen = ftell(f);
 	olen = get_unaligned_le32(&olen);
 
-	/*
-	 * Now we have the input (compressed) and output (uncompressed)
-	 * sizes, compute the necessary decompression offset...
-	 */
-
-	offs = (olen > ilen) ? olen - ilen : 0;
-	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
-	offs += 64*1024 + 128;	/* Add 64K + 128 bytes slack */
-	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
 	run_size = atoi(argv[2]);
 
 	printf(".section \".rodata..compressed\",\"a\",@progbits\n");
@@ -83,8 +72,6 @@ int main(int argc, char *argv[])
 	printf("z_input_len = %lu\n", ilen);
 	printf(".globl z_output_len\n");
 	printf("z_output_len = %lu\n", (unsigned long)olen);
-	printf(".globl z_extract_offset\n");
-	printf("z_extract_offset = 0x%lx\n", offs);
 	printf(".globl z_run_size\n");
 	printf("z_run_size = %lu\n", run_size);
 

commit 974f221c84b05b1dc2f5ea50dc16d2a9d1e95eda
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 28 17:09:04 2016 -0700

    x86/boot: Move compressed kernel to the end of the decompression buffer
    
    This change makes later calculations about where the kernel is located
    easier to reason about. To better understand this change, we must first
    clarify what 'VO' and 'ZO' are. These values were introduced in commits
    by hpa:
    
      77d1a4999502 ("x86, boot: make symbols from the main vmlinux available")
      37ba7ab5e33c ("x86, boot: make kernel_alignment adjustable; new bzImage fields")
    
    Specifically:
    
    All names prefixed with 'VO_':
    
     - relate to the uncompressed kernel image
    
     - the size of the VO image is: VO__end-VO__text ("VO_INIT_SIZE" define)
    
    All names prefixed with 'ZO_':
    
     - relate to the bootable compressed kernel image (boot/compressed/vmlinux),
       which is composed of the following memory areas:
         - head text
         - compressed kernel (VO image and relocs table)
         - decompressor code
    
     - the size of the ZO image is: ZO__end - ZO_startup_32 ("ZO_INIT_SIZE" define, though see below)
    
    The 'INIT_SIZE' value is used to find the larger of the two image sizes:
    
     #define ZO_INIT_SIZE    (ZO__end - ZO_startup_32 + ZO_z_extract_offset)
     #define VO_INIT_SIZE    (VO__end - VO__text)
    
     #if ZO_INIT_SIZE > VO_INIT_SIZE
     # define INIT_SIZE ZO_INIT_SIZE
     #else
     # define INIT_SIZE VO_INIT_SIZE
     #endif
    
    The current code uses extract_offset to decide where to position the
    copied ZO (i.e. ZO starts at extract_offset). (This is why ZO_INIT_SIZE
    currently includes the extract_offset.)
    
    Why does z_extract_offset exist? It's needed because we are trying to minimize
    the amount of RAM used for the whole act of creating an uncompressed, executable,
    properly relocation-linked kernel image in system memory. We do this so that
    kernels can be booted on even very small systems.
    
    To achieve the goal of minimal memory consumption we have implemented an in-place
    decompression strategy: instead of cleanly separating the VO and ZO images and
    also allocating some memory for the decompression code's runtime needs, we instead
    create this elaborate layout of memory buffers where the output (decompressed)
    stream, as it progresses, overlaps with and destroys the input (compressed)
    stream. This can only be done safely if the ZO image is placed to the end of the
    VO range, plus a certain amount of safety distance to make sure that when the last
    bytes of the VO range are decompressed, the compressed stream pointer is safely
    beyond the end of the VO range.
    
    z_extract_offset is calculated in arch/x86/boot/compressed/mkpiggy.c during
    the build process, at a point when we know the exact compressed and
    uncompressed size of the kernel images and can calculate this safe minimum
    offset value. (Note that the mkpiggy.c calculation is not perfect, because
    we don't know the decompressor used at that stage, so the z_extract_offset
    calculation is necessarily imprecise and is mostly based on gzip internals -
    we'll improve that in the next patch.)
    
    When INIT_SIZE is bigger than VO_INIT_SIZE (uncommon but possible),
    the copied ZO occupies the memory from extract_offset to the end of
    decompression buffer. It overlaps with the soon-to-be-uncompressed kernel
    like this:
    
                                |-----compressed kernel image------|
                                V                                  V
    0                       extract_offset                      +INIT_SIZE
    |-----------|---------------|-------------------------|--------|
                |               |                         |        |
              VO__text      startup_32 of ZO          VO__end    ZO__end
                ^                                         ^
                |-------uncompressed kernel image---------|
    
    When INIT_SIZE is equal to VO_INIT_SIZE (likely) there's still space
    left from end of ZO to the end of decompressing buffer, like below.
    
                                |-compressed kernel image-|
                                V                         V
    0                       extract_offset                      +INIT_SIZE
    |-----------|---------------|-------------------------|--------|
                |               |                         |        |
              VO__text      startup_32 of ZO          ZO__end    VO__end
                ^                                                  ^
                |------------uncompressed kernel image-------------|
    
    To simplify calculations and avoid special cases, it is cleaner to
    always place the compressed kernel image in memory so that ZO__end
    is at the end of the decompression buffer, instead of placing t at
    the start of extract_offset as is currently done.
    
    This patch adds BP_init_size (which is the INIT_SIZE as passed in from
    the boot_params) into asm-offsets.c to make it visible to the assembly
    code.
    
    Then when moving the ZO, it calculates the starting position of
    the copied ZO (via BP_init_size and the ZO run size) so that the VO__end
    will be at the end of the decompression buffer. To make the position
    calculation safe, the end of ZO is page aligned (and a comment is added
    to the existing VO alignment for good measure).
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    [ Rewrote changelog and comments. ]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: lasse.collin@tukaani.org
    Link: http://lkml.kernel.org/r/1461888548-32439-3-git-send-email-keescook@chromium.org
    [ Rewrote the changelog some more. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index d8222f213182..b980046c3329 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -85,9 +85,6 @@ int main(int argc, char *argv[])
 	printf("z_output_len = %lu\n", (unsigned long)olen);
 	printf(".globl z_extract_offset\n");
 	printf("z_extract_offset = 0x%lx\n", offs);
-	/* z_extract_offset_negative allows simplification of head_32.S */
-	printf(".globl z_extract_offset_negative\n");
-	printf("z_extract_offset_negative = -0x%lx\n", offs);
 	printf(".globl z_run_size\n");
 	printf("z_run_size = %lu\n", run_size);
 

commit e6023367d779060fddc9a52d1f474085b2b36298
Author: Junjie Mao <eternal.n08@gmail.com>
Date:   Fri Oct 31 21:40:38 2014 +0800

    x86, kaslr: Prevent .bss from overlaping initrd
    
    When choosing a random address, the current implementation does not take into
    account the reversed space for .bss and .brk sections. Thus the relocated kernel
    may overlap other components in memory. Here is an example of the overlap from a
    x86_64 kernel in qemu (the ranges of physical addresses are presented):
    
     Physical Address
    
        0x0fe00000                  --+--------------------+  <-- randomized base
                                   /  |  relocated kernel  |
                       vmlinux.bin    | (from vmlinux.bin) |
        0x1336d000    (an ELF file)   +--------------------+--
                                   \  |                    |  \
        0x1376d870                  --+--------------------+   |
                                      |    relocs table    |   |
        0x13c1c2a8                    +--------------------+   .bss and .brk
                                      |                    |   |
        0x13ce6000                    +--------------------+   |
                                      |                    |  /
        0x13f77000                    |       initrd       |--
                                      |                    |
        0x13fef374                    +--------------------+
    
    The initrd image will then be overwritten by the memset during early
    initialization:
    
    [    1.655204] Unpacking initramfs...
    [    1.662831] Initramfs unpacking failed: junk in compressed archive
    
    This patch prevents the above situation by requiring a larger space when looking
    for a random kernel base, so that existing logic can effectively avoids the
    overlap.
    
    [kees: switched to perl to avoid hex translation pain in mawk vs gawk]
    [kees: calculated overlap without relocs table]
    
    Fixes: 82fa9637a2 ("x86, kaslr: Select random position from e820 maps")
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Junjie Mao <eternal.n08@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1414762838-13067-1-git-send-email-eternal.n08@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index b669ab65bf6c..d8222f213182 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -36,11 +36,13 @@ int main(int argc, char *argv[])
 	uint32_t olen;
 	long ilen;
 	unsigned long offs;
+	unsigned long run_size;
 	FILE *f = NULL;
 	int retval = 1;
 
-	if (argc < 2) {
-		fprintf(stderr, "Usage: %s compressed_file\n", argv[0]);
+	if (argc < 3) {
+		fprintf(stderr, "Usage: %s compressed_file run_size\n",
+				argv[0]);
 		goto bail;
 	}
 
@@ -74,6 +76,7 @@ int main(int argc, char *argv[])
 	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
 	offs += 64*1024 + 128;	/* Add 64K + 128 bytes slack */
 	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
+	run_size = atoi(argv[2]);
 
 	printf(".section \".rodata..compressed\",\"a\",@progbits\n");
 	printf(".globl z_input_len\n");
@@ -85,6 +88,8 @@ int main(int argc, char *argv[])
 	/* z_extract_offset_negative allows simplification of head_32.S */
 	printf(".globl z_extract_offset_negative\n");
 	printf("z_extract_offset_negative = -0x%lx\n", offs);
+	printf(".globl z_run_size\n");
+	printf("z_run_size = %lu\n", run_size);
 
 	printf(".globl input_data, input_data_end\n");
 	printf("input_data:\n");

commit 49449c30c4d1514486364d1e0dbea6938914b86f
Author: Geyslan G. Bem <geyslan@gmail.com>
Date:   Mon Oct 7 19:16:59 2013 -0300

    x86: mkpiggy.c: Explicitly close the output file
    
    Even though the resource is released when the application is closed or
    when returned from main function, modify the code to make it obvious,
    and to keep static analysis tools from complaining.
    
    Signed-off-by: Geyslan G. Bem <geyslan@gmail.com>
    Link: http://lkml.kernel.org/r/1381184219-10985-1-git-send-email-geyslan@gmail.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index 958a641483dd..b669ab65bf6c 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -36,11 +36,12 @@ int main(int argc, char *argv[])
 	uint32_t olen;
 	long ilen;
 	unsigned long offs;
-	FILE *f;
+	FILE *f = NULL;
+	int retval = 1;
 
 	if (argc < 2) {
 		fprintf(stderr, "Usage: %s compressed_file\n", argv[0]);
-		return 1;
+		goto bail;
 	}
 
 	/* Get the information for the compressed kernel image first */
@@ -48,7 +49,7 @@ int main(int argc, char *argv[])
 	f = fopen(argv[1], "r");
 	if (!f) {
 		perror(argv[1]);
-		return 1;
+		goto bail;
 	}
 
 
@@ -58,12 +59,11 @@ int main(int argc, char *argv[])
 
 	if (fread(&olen, sizeof(olen), 1, f) != 1) {
 		perror(argv[1]);
-		return 1;
+		goto bail;
 	}
 
 	ilen = ftell(f);
 	olen = get_unaligned_le32(&olen);
-	fclose(f);
 
 	/*
 	 * Now we have the input (compressed) and output (uncompressed)
@@ -91,5 +91,9 @@ int main(int argc, char *argv[])
 	printf(".incbin \"%s\"\n", argv[1]);
 	printf("input_data_end:\n");
 
-	return 0;
+	retval = 0;
+bail:
+	if (f)
+		fclose(f);
+	return retval;
 }

commit 12871c568305a0b20f116315479a18cd46882e9b
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Feb 28 13:37:22 2012 +0000

    x86, mkpiggy: Don't open code put_unaligned_le32()
    
    Use the new headers in tools/include instead of rolling our own
    put_unaligned_le32() implementation.
    
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1330436245-24875-4-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index 46a823882437..958a641483dd 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -29,14 +29,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <inttypes.h>
-
-static uint32_t getle32(const void *p)
-{
-	const uint8_t *cp = p;
-
-	return (uint32_t)cp[0] + ((uint32_t)cp[1] << 8) +
-		((uint32_t)cp[2] << 16) + ((uint32_t)cp[3] << 24);
-}
+#include <tools/le_byteshift.h>
 
 int main(int argc, char *argv[])
 {
@@ -69,7 +62,7 @@ int main(int argc, char *argv[])
 	}
 
 	ilen = ftell(f);
-	olen = getle32(&olen);
+	olen = get_unaligned_le32(&olen);
 	fclose(f);
 
 	/*

commit 6670e9cdaf554290e26121aa72f0118f2fac52e5
Author: Daniel J Blueman <daniel.blueman@gmail.com>
Date:   Wed Feb 23 09:33:59 2011 +0800

    x86, build: Make sure mkpiggy fails on read error
    
    Ensure build doesn't silently continue despite read failure,
    addressing a warning due to the unchecked call.
    
    Signed-off-by: Daniel J Blueman <daniel.blueman@gmail.com>
    LKML-Reference: <AANLkTimxxTMU3=4ry-_zbY6v1xiDi+hW9y1RegTr8vLK@mail.gmail.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index 646aa78ba5fd..46a823882437 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -62,7 +62,12 @@ int main(int argc, char *argv[])
 	if (fseek(f, -4L, SEEK_END)) {
 		perror(argv[1]);
 	}
-	fread(&olen, sizeof olen, 1, f);
+
+	if (fread(&olen, sizeof(olen), 1, f) != 1) {
+		perror(argv[1]);
+		return 1;
+	}
+
 	ilen = ftell(f);
 	olen = getle32(&olen);
 	fclose(f);

commit 303148045aac34b70db722a54e5ad94a3a6625c6
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:24 2011 -0800

    x86: support XZ-compressed kernel
    
    This integrates the XZ decompression code to the x86 pre-boot code.
    
    mkpiggy.c is updated to reserve about 32 KiB more buffer safety margin for
    kernel decompression.  It is done unconditionally for all decompressors to
    keep the code simpler.
    
    The XZ decompressor needs around 30 KiB of heap, so the heap size is
    increased to 32 KiB on both x86-32 and x86-64.
    
    Documentation/x86/boot.txt is updated to list the XZ magic number.
    
    With the x86 BCJ filter in XZ, XZ-compressed x86 kernel tends to be a few
    percent smaller than the equivalent LZMA-compressed kernel.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index 5c228129d175..646aa78ba5fd 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -74,7 +74,7 @@ int main(int argc, char *argv[])
 
 	offs = (olen > ilen) ? olen - ilen : 0;
 	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
-	offs += 32*1024 + 18;	/* Add 32K + 18 bytes slack */
+	offs += 64*1024 + 128;	/* Add 64K + 128 bytes slack */
 	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
 
 	printf(".section \".rodata..compressed\",\"a\",@progbits\n");

commit 041d5f94c4d67444c40584db0d1cacf32a47a25b
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Sat Feb 20 01:03:46 2010 +0100

    Rename .rodata.compressed to .rodata..compressed.
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
index bcbd36c41432..5c228129d175 100644
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -77,7 +77,7 @@ int main(int argc, char *argv[])
 	offs += 32*1024 + 18;	/* Add 32K + 18 bytes slack */
 	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
 
-	printf(".section \".rodata.compressed\",\"a\",@progbits\n");
+	printf(".section \".rodata..compressed\",\"a\",@progbits\n");
 	printf(".globl z_input_len\n");
 	printf("z_input_len = %lu\n", ilen);
 	printf(".globl z_output_len\n");

commit 02a884c0fe7ec8459d00d34b7d4101af21fc4a86
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Fri May 8 17:42:16 2009 -0700

    x86, boot: determine compressed code offset at compile time
    
    Determine the compressed code offset (from the kernel runtime address)
    at compile time.  This allows some minor optimizations in
    arch/x86/boot/compressed/head_*.S, but more importantly it makes this
    value available to the build process, which will enable a future patch
    to export the necessary linear memory footprint into the bzImage
    header.
    
    [ Impact: cleanup, future patch enabling ]
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/x86/boot/compressed/mkpiggy.c b/arch/x86/boot/compressed/mkpiggy.c
new file mode 100644
index 000000000000..bcbd36c41432
--- /dev/null
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@ -0,0 +1,97 @@
+/* ----------------------------------------------------------------------- *
+ *
+ *  Copyright (C) 2009 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version
+ *  2 as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ *  02110-1301, USA.
+ *
+ *  H. Peter Anvin <hpa@linux.intel.com>
+ *
+ * ----------------------------------------------------------------------- */
+
+/*
+ * Compute the desired load offset from a compressed program; outputs
+ * a small assembly wrapper with the appropriate symbols defined.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+static uint32_t getle32(const void *p)
+{
+	const uint8_t *cp = p;
+
+	return (uint32_t)cp[0] + ((uint32_t)cp[1] << 8) +
+		((uint32_t)cp[2] << 16) + ((uint32_t)cp[3] << 24);
+}
+
+int main(int argc, char *argv[])
+{
+	uint32_t olen;
+	long ilen;
+	unsigned long offs;
+	FILE *f;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s compressed_file\n", argv[0]);
+		return 1;
+	}
+
+	/* Get the information for the compressed kernel image first */
+
+	f = fopen(argv[1], "r");
+	if (!f) {
+		perror(argv[1]);
+		return 1;
+	}
+
+
+	if (fseek(f, -4L, SEEK_END)) {
+		perror(argv[1]);
+	}
+	fread(&olen, sizeof olen, 1, f);
+	ilen = ftell(f);
+	olen = getle32(&olen);
+	fclose(f);
+
+	/*
+	 * Now we have the input (compressed) and output (uncompressed)
+	 * sizes, compute the necessary decompression offset...
+	 */
+
+	offs = (olen > ilen) ? olen - ilen : 0;
+	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
+	offs += 32*1024 + 18;	/* Add 32K + 18 bytes slack */
+	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
+
+	printf(".section \".rodata.compressed\",\"a\",@progbits\n");
+	printf(".globl z_input_len\n");
+	printf("z_input_len = %lu\n", ilen);
+	printf(".globl z_output_len\n");
+	printf("z_output_len = %lu\n", (unsigned long)olen);
+	printf(".globl z_extract_offset\n");
+	printf("z_extract_offset = 0x%lx\n", offs);
+	/* z_extract_offset_negative allows simplification of head_32.S */
+	printf(".globl z_extract_offset_negative\n");
+	printf("z_extract_offset_negative = -0x%lx\n", offs);
+
+	printf(".globl input_data, input_data_end\n");
+	printf("input_data:\n");
+	printf(".incbin \"%s\"\n", argv[1]);
+	printf("input_data_end:\n");
+
+	return 0;
+}
