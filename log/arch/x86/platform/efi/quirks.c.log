commit 9b82f05f869a823d43ea4186f5f732f2924d3693
Merge: 4b9fd8a829a1 629b3df7ecb0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 16:40:08 2020 -0700

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "The main changes in this cycle were:
    
      Kernel side changes:
    
       - A couple of x86/cpu cleanups and changes were grandfathered in due
         to patch dependencies. These clean up the set of CPU model/family
         matching macros with a consistent namespace and C99 initializer
         style.
    
       - A bunch of updates to various low level PMU drivers:
           * AMD Family 19h L3 uncore PMU
           * Intel Tiger Lake uncore support
           * misc fixes to LBR TOS sampling
    
       - optprobe fixes
    
       - perf/cgroup: optimize cgroup event sched-in processing
    
       - misc cleanups and fixes
    
      Tooling side changes are to:
    
       - perf {annotate,expr,record,report,stat,test}
    
       - perl scripting
    
       - libapi, libperf and libtraceevent
    
       - vendor events on Intel and S390, ARM cs-etm
    
       - Intel PT updates
    
       - Documentation changes and updates to core facilities
    
       - misc cleanups, fixes and other enhancements"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (89 commits)
      cpufreq/intel_pstate: Fix wrong macro conversion
      x86/cpu: Cleanup the now unused CPU match macros
      hwrng: via_rng: Convert to new X86 CPU match macros
      crypto: Convert to new CPU match macros
      ASoC: Intel: Convert to new X86 CPU match macros
      powercap/intel_rapl: Convert to new X86 CPU match macros
      PCI: intel-mid: Convert to new X86 CPU match macros
      mmc: sdhci-acpi: Convert to new X86 CPU match macros
      intel_idle: Convert to new X86 CPU match macros
      extcon: axp288: Convert to new X86 CPU match macros
      thermal: Convert to new X86 CPU match macros
      hwmon: Convert to new X86 CPU match macros
      platform/x86: Convert to new CPU match macros
      EDAC: Convert to new X86 CPU match macros
      cpufreq: Convert to new X86 CPU match macros
      ACPI: Convert to new X86 CPU match macros
      x86/platform: Convert to new CPU match macros
      x86/kernel: Convert to new CPU match macros
      x86/kvm: Convert to new CPU match macros
      x86/perf/events: Convert to new CPU match macros
      ...

commit 9595198f8dc4111f8cab39de2c0c4432787bc690
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 20 14:13:52 2020 +0100

    x86/platform: Convert to new CPU match macros
    
    The new macro set has a consistent namespace and uses C99 initializers
    instead of the grufty C89 ones.
    
    Get rid the of the local macro wrappers for consistency.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lkml.kernel.org/r/20200320131509.359448901@linutronix.de

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 88d32c06cffa..c000e03ecfe3 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -659,12 +659,9 @@ static int qrk_capsule_setup_info(struct capsule_info *cap_info, void **pkbuff,
 	return 1;
 }
 
-#define ICPU(family, model, quirk_handler) \
-	{ X86_VENDOR_INTEL, family, model, X86_FEATURE_ANY, \
-	  (unsigned long)&quirk_handler }
-
 static const struct x86_cpu_id efi_capsule_quirk_ids[] = {
-	ICPU(5, 9, qrk_capsule_setup_info),	/* Intel Quark X1000 */
+	X86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000,
+				   &qrk_capsule_setup_info),
 	{ }
 };
 

commit 3be5f0d286dc944dee65fdcbddfc4d314f7d4482
Merge: c98a76eabbb6 f0df68d5bae8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Mar 8 08:59:47 2020 +0100

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/efi/efi into efi/core
    
    More EFI updates for v5.7
    
     - Incorporate a stable branch with the EFI pieces of Hans's work on
       loading device firmware from EFI boot service memory regions
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0e72a6a3cfc3a32273f5e99bfaa4407f4917d343
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:45 2020 +0100

    efi: Export boot-services code and data as debugfs-blobs
    
    Sometimes it is useful to be able to dump the efi boot-services code and
    data. This commit adds these as debugfs-blobs to /sys/kernel/debug/efi,
    but only if efi=debug is passed on the kernel-commandline as this requires
    not freeing those memory-regions, which costs 20+ MB of RAM.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-2-hdegoede@redhat.com
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 88d32c06cffa..bada1037b711 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -410,6 +410,10 @@ void __init efi_free_boot_services(void)
 	int num_entries = 0;
 	void *new, *new_md;
 
+	/* Keep all regions for /sys/kernel/debug/efi */
+	if (efi_enabled(EFI_DBG))
+		return;
+
 	for_each_efi_memory_desc(md) {
 		unsigned long long start = md->phys_addr;
 		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;

commit 9cd437ac0ef4f324a92e2579784b03bb487ae7fb
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:23:21 2020 +0100

    efi/x86: Make fw_vendor, config_table and runtime sysfs nodes x86 specific
    
    There is some code that exposes physical addresses of certain parts of
    the EFI firmware implementation via sysfs nodes. These nodes are only
    used on x86, and are of dubious value to begin with, so let's move
    their handling into the x86 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 88d32c06cffa..b0e0161e2e8e 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -537,7 +537,7 @@ int __init efi_reuse_config(u64 tables, int nr_tables)
 		goto out_memremap;
 	}
 
-	for (i = 0; i < efi.systab->nr_tables; i++) {
+	for (i = 0; i < nr_tables; i++) {
 		efi_guid_t guid;
 
 		guid = ((efi_config_table_64_t *)p)->guid;

commit 634cd4b6afe15dca8df02bcba242b9b0c5e9b5a5
Merge: d99391ec2b42 ac6119e7f25b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 09:03:40 2020 -0800

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Cleanup of the GOP [graphics output] handling code in the EFI stub
    
       - Complete refactoring of the mixed mode handling in the x86 EFI stub
    
       - Overhaul of the x86 EFI boot/runtime code
    
       - Increase robustness for mixed mode code
    
       - Add the ability to disable DMA at the root port level in the EFI
         stub
    
       - Get rid of RWX mappings in the EFI memory map and page tables,
         where possible
    
       - Move the support code for the old EFI memory mapping style into its
         only user, the SGI UV1+ support code.
    
       - plus misc fixes, updates, smaller cleanups.
    
      ... and due to interactions with the RWX changes, another round of PAT
      cleanups make a guest appearance via the EFI tree - with no side
      effects intended"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (75 commits)
      efi/x86: Disable instrumentation in the EFI runtime handling code
      efi/libstub/x86: Fix EFI server boot failure
      efi/x86: Disallow efi=old_map in mixed mode
      x86/boot/compressed: Relax sed symbol type regex for LLVM ld.lld
      efi/x86: avoid KASAN false positives when accessing the 1: 1 mapping
      efi: Fix handling of multiple efi_fake_mem= entries
      efi: Fix efi_memmap_alloc() leaks
      efi: Add tracking for dynamically allocated memmaps
      efi: Add a flags parameter to efi_memory_map
      efi: Fix comment for efi_mem_type() wrt absent physical addresses
      efi/arm: Defer probe of PCIe backed efifb on DT systems
      efi/x86: Limit EFI old memory map to SGI UV machines
      efi/x86: Avoid RWX mappings for all of DRAM
      efi/x86: Don't map the entire kernel text RW for mixed mode
      x86/mm: Fix NX bit clearing issue in kernel_map_pages_in_pgd
      efi/libstub/x86: Fix unused-variable warning
      efi/libstub/x86: Use mandatory 16-byte stack alignment in mixed mode
      efi/libstub/x86: Use const attribute for efi_is_64bit()
      efi: Allow disabling PCI busmastering on bridges during boot
      efi/x86: Allow translating 64-bit arguments for mixed mode calls
      ...

commit 9f2a43019edc097347900daade277571834a3e2c
Merge: b0be0eff1a5a 960786422fe9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 08:20:54 2020 -0800

    Merge branch 'core-headers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull header cleanup from Ingo Molnar:
     "This is a treewide cleanup, mostly (but not exclusively) with x86
      impact, which breaks implicit dependencies on the asm/realtime.h
      header and finally removes it from asm/acpi.h"
    
    * 'core-headers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/ACPI/sleep: Move acpi_get_wakeup_address() into sleep.c, remove <asm/realmode.h> from <asm/acpi.h>
      ACPI/sleep: Convert acpi_wakeup_address into a function
      x86/ACPI/sleep: Remove an unnecessary include of asm/realmode.h
      ASoC: Intel: Skylake: Explicitly include linux/io.h for virt_to_phys()
      vmw_balloon: Explicitly include linux/io.h for virt_to_phys()
      virt: vbox: Explicitly include linux/io.h to pick up various defs
      efi/capsule-loader: Explicitly include linux/io.h for page_to_phys()
      perf/x86/intel: Explicitly include asm/io.h to use virt_to_phys()
      x86/kprobes: Explicitly include vmalloc.h for set_vm_flush_reset_perms()
      x86/ftrace: Explicitly include vmalloc.h for set_vm_flush_reset_perms()
      x86/boot: Explicitly include realmode.h to handle RM reservations
      x86/efi: Explicitly include realmode.h to handle RM trampoline quirk
      x86/platform/intel/quark: Explicitly include linux/io.h for virt_to_phys()
      x86/setup: Enhance the comments
      x86/setup: Clean up the header portion of setup.c

commit 1db91035d01aa8bfa2350c00ccb63d629b4041ad
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 13 18:22:43 2020 +0100

    efi: Add tracking for dynamically allocated memmaps
    
    In preparation for fixing efi_memmap_alloc() leaks, add support for
    recording whether the memmap was dynamically allocated from slab,
    memblock, or is the original physical memmap provided by the platform.
    
    Given this tracking is established in efi_memmap_alloc() and needs to be
    carried to efi_memmap_install(), use 'struct efi_memory_map_data' to
    convey the flags.
    
    Some small cleanups result from this reorganization, specifically the
    removal of local variables for 'phys' and 'size' that are already
    tracked in @data.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-12-ardb@kernel.org

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index fe46ddf6c761..46807b7606da 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -243,7 +243,7 @@ EXPORT_SYMBOL_GPL(efi_query_variable_store);
  */
 void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 {
-	phys_addr_t new_phys, new_size;
+	struct efi_memory_map_data data = { 0 };
 	struct efi_mem_range mr;
 	efi_memory_desc_t md;
 	int num_entries;
@@ -271,24 +271,21 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 	num_entries = efi_memmap_split_count(&md, &mr.range);
 	num_entries += efi.memmap.nr_map;
 
-	new_size = efi.memmap.desc_size * num_entries;
-
-	new_phys = efi_memmap_alloc(num_entries);
-	if (!new_phys) {
+	if (efi_memmap_alloc(num_entries, &data) != 0) {
 		pr_err("Could not allocate boot services memmap\n");
 		return;
 	}
 
-	new = early_memremap(new_phys, new_size);
+	new = early_memremap(data.phys_map, data.size);
 	if (!new) {
 		pr_err("Failed to map new boot services memmap\n");
 		return;
 	}
 
 	efi_memmap_insert(&efi.memmap, new, &mr);
-	early_memunmap(new, new_size);
+	early_memunmap(new, data.size);
 
-	efi_memmap_install(new_phys, num_entries);
+	efi_memmap_install(&data);
 	e820__range_update(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
 	e820__update_table(e820_table);
 }
@@ -407,7 +404,7 @@ static void __init efi_unmap_pages(efi_memory_desc_t *md)
 
 void __init efi_free_boot_services(void)
 {
-	phys_addr_t new_phys, new_size;
+	struct efi_memory_map_data data = { 0 };
 	efi_memory_desc_t *md;
 	int num_entries = 0;
 	void *new, *new_md;
@@ -462,14 +459,12 @@ void __init efi_free_boot_services(void)
 	if (!num_entries)
 		return;
 
-	new_size = efi.memmap.desc_size * num_entries;
-	new_phys = efi_memmap_alloc(num_entries);
-	if (!new_phys) {
+	if (efi_memmap_alloc(num_entries, &data) != 0) {
 		pr_err("Failed to allocate new EFI memmap\n");
 		return;
 	}
 
-	new = memremap(new_phys, new_size, MEMREMAP_WB);
+	new = memremap(data.phys_map, data.size, MEMREMAP_WB);
 	if (!new) {
 		pr_err("Failed to map new EFI memmap\n");
 		return;
@@ -493,7 +488,7 @@ void __init efi_free_boot_services(void)
 
 	memunmap(new);
 
-	if (efi_memmap_install(new_phys, num_entries)) {
+	if (efi_memmap_install(&data) != 0) {
 		pr_err("Could not install new EFI memmap\n");
 		return;
 	}

commit 1f299fad1e312947c974c6a1d8a3a484f27a6111
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 13 18:22:39 2020 +0100

    efi/x86: Limit EFI old memory map to SGI UV machines
    
    We carry a quirk in the x86 EFI code to switch back to an older
    method of mapping the EFI runtime services memory regions, because
    it was deemed risky at the time to implement a new method without
    providing a fallback to the old method in case problems arose.
    
    Such problems did arise, but they appear to be limited to SGI UV1
    machines, and so these are the only ones for which the fallback gets
    enabled automatically (via a DMI quirk). The fallback can be enabled
    manually as well, by passing efi=old_map, but there is very little
    evidence that suggests that this is something that is being relied
    upon in the field.
    
    Given that UV1 support is not enabled by default by the distros
    (Ubuntu, Fedora), there is no point in carrying this fallback code
    all the time if there are no other users. So let's move it into the
    UV support code, and document that efi=old_map now requires this
    support code to be enabled.
    
    Note that efi=old_map has been used in the past on other SGI UV
    machines to work around kernel regressions in production, so we
    keep the option to enable it by hand, but only if the kernel was
    built with UV support.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-8-ardb@kernel.org

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index eb421cb35108..fe46ddf6c761 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -384,10 +384,10 @@ static void __init efi_unmap_pages(efi_memory_desc_t *md)
 
 	/*
 	 * To Do: Remove this check after adding functionality to unmap EFI boot
-	 * services code/data regions from direct mapping area because
-	 * "efi=old_map" maps EFI regions in swapper_pg_dir.
+	 * services code/data regions from direct mapping area because the UV1
+	 * memory map maps EFI regions in swapper_pg_dir.
 	 */
-	if (efi_enabled(EFI_OLD_MEMMAP))
+	if (efi_have_uv1_memmap())
 		return;
 
 	/*
@@ -558,7 +558,7 @@ int __init efi_reuse_config(u64 tables, int nr_tables)
 	return ret;
 }
 
-static const struct dmi_system_id sgi_uv1_dmi[] = {
+static const struct dmi_system_id sgi_uv1_dmi[] __initconst = {
 	{ NULL, "SGI UV1",
 		{	DMI_MATCH(DMI_PRODUCT_NAME,	"Stoutland Platform"),
 			DMI_MATCH(DMI_PRODUCT_VERSION,	"1.0"),
@@ -581,8 +581,15 @@ void __init efi_apply_memmap_quirks(void)
 	}
 
 	/* UV2+ BIOS has a fix for this issue.  UV1 still needs the quirk. */
-	if (dmi_check_system(sgi_uv1_dmi))
-		set_bit(EFI_OLD_MEMMAP, &efi.flags);
+	if (dmi_check_system(sgi_uv1_dmi)) {
+		if (IS_ENABLED(CONFIG_X86_UV)) {
+			set_bit(EFI_UV1_MEMMAP, &efi.flags);
+		} else {
+			pr_warn("EFI runtime disabled, needs CONFIG_X86_UV=y on UV1\n");
+			clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+			efi_memmap_unmap();
+		}
+	}
 }
 
 /*
@@ -720,7 +727,7 @@ void efi_recover_from_page_fault(unsigned long phys_addr)
 	/*
 	 * Make sure that an efi runtime service caused the page fault.
 	 * "efi_mm" cannot be used to check if the page fault had occurred
-	 * in the firmware context because efi=old_map doesn't use efi_pgd.
+	 * in the firmware context because the UV1 memmap doesn't use efi_pgd.
 	 */
 	if (efi_rts_work.efi_rts_id == EFI_NONE)
 		return;

commit a8147dba75b188bff87d4ad072db84a0b70d716d
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:06 2019 +0100

    efi/x86: Rename efi_is_native() to efi_is_mixed()
    
    The ARM architecture does not permit combining 32-bit and 64-bit code
    at the same privilege level, and so EFI mixed mode is strictly a x86
    concept.
    
    In preparation of turning the 32/64 bit distinction in shared stub
    code to a native vs mixed one, refactor x86's current use of the
    helper function efi_is_native() into efi_is_mixed().
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-7-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index f8f0220b6a66..eb421cb35108 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -395,7 +395,7 @@ static void __init efi_unmap_pages(efi_memory_desc_t *md)
 	 * EFI runtime calls, hence don't unmap EFI boot services code/data
 	 * regions.
 	 */
-	if (!efi_is_native())
+	if (efi_is_mixed())
 		return;
 
 	if (kernel_unmap_pages_in_pgd(pgd, pa, md->num_pages))

commit e71b6f0b68de3296839a311355c5f590ac3446e5
Author: Sean Christopherson <sean.j.christopherson@intel.com>
Date:   Tue Nov 26 08:54:06 2019 -0800

    x86/efi: Explicitly include realmode.h to handle RM trampoline quirk
    
    Explicitly include asm/realmode.h, which is needed to handle a real mode
    trampoline quirk in efi_free_boot_services(), instead of picking it up
    by way of linux/acpi.h.  acpi.h will soon stop including realmode.h so
    that changing realmode.h doesn't require a full kernel rebuild.
    
    Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
    Link: https://lkml.kernel.org/r/20191126165417.22423-2-sean.j.christopherson@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 7675cf754d90..4de244683a7e 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -16,6 +16,7 @@
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
 #include <asm/cpu_device_id.h>
+#include <asm/realmode.h>
 #include <asm/reboot.h>
 
 #define EFI_MIN_RESERVE 5120

commit af164898482817a1d487964b68f3c21bae7a1beb
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Dec 4 15:52:33 2019 +0800

    x86/efi: Update e820 with reserved EFI boot services data to fix kexec breakage
    
    Michael Weiser reported that he got this error during a kexec rebooting:
    
      esrt: Unsupported ESRT version 2904149718861218184.
    
    The ESRT memory stays in EFI boot services data, and it was reserved
    in kernel via efi_mem_reserve().  The initial purpose of the reservation
    is to reuse the EFI boot services data across kexec reboot. For example
    the BGRT image data and some ESRT memory like Michael reported.
    
    But although the memory is reserved it is not updated in the X86 E820 table,
    and kexec_file_load() iterates system RAM in the IO resource list to find places
    for kernel, initramfs and other stuff. In Michael's case the kexec loaded
    initramfs overwrote the ESRT memory and then the failure happened.
    
    Since kexec_file_load() depends on the E820 table being updated, just fix this
    by updating the reserved EFI boot services memory as reserved type in E820.
    
    Originally any memory descriptors with EFI_MEMORY_RUNTIME attribute are
    bypassed in the reservation code path because they are assumed as reserved.
    
    But the reservation is still needed for multiple kexec reboots,
    and it is the only possible case we come here thus just drop the code
    chunk, then everything works without side effects.
    
    On my machine the ESRT memory sits in an EFI runtime data range, it does
    not trigger the problem, but I successfully tested with BGRT instead.
    both kexec_load() and kexec_file_load() work and kdump works as well.
    
    [ mingo: Edited the changelog. ]
    
    Reported-by: Michael Weiser <michael@weiser.dinsnail.net>
    Tested-by: Michael Weiser <michael@weiser.dinsnail.net>
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: kexec@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191204075233.GA10520@dhcp-128-65.nay.redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 7675cf754d90..f8f0220b6a66 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -260,10 +260,6 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 		return;
 	}
 
-	/* No need to reserve regions that will never be freed. */
-	if (md.attribute & EFI_MEMORY_RUNTIME)
-		return;
-
 	size += addr % EFI_PAGE_SIZE;
 	size = round_up(size, EFI_PAGE_SIZE);
 	addr = round_down(addr, EFI_PAGE_SIZE);
@@ -293,6 +289,8 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 	early_memunmap(new, new_size);
 
 	efi_memmap_install(new_phys, num_entries);
+	e820__range_update(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
+	e820__update_table(e820_table);
 }
 
 /*

commit 6950e31b35fdf4588cbbdec1813091bb02cf8871
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:05 2019 -0800

    x86/efi: Push EFI_MEMMAP check into leaf routines
    
    In preparation for adding another EFI_MEMMAP dependent call that needs
    to occur before e820__memblock_setup() fixup the existing efi calls to
    check for EFI_MEMMAP internally. This ends up being cleaner than the
    alternative of checking EFI_MEMMAP multiple times in setup_arch().
    
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 3b9fd679cea9..7675cf754d90 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -320,6 +320,9 @@ void __init efi_reserve_boot_services(void)
 {
 	efi_memory_desc_t *md;
 
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
 	for_each_efi_memory_desc(md) {
 		u64 start = md->phys_addr;
 		u64 size = md->num_pages << EFI_PAGE_SHIFT;

commit 919aef44d73d5d0c04213cb1bc31149cc074e65e
Author: Qian Cai <cai@lca.pw>
Date:   Wed Jun 19 13:47:44 2019 -0400

    x86/efi: fix a -Wtype-limits compilation warning
    
    Compiling a kernel with W=1 generates this warning,
    
    arch/x86/platform/efi/quirks.c:731:16: warning: comparison of unsigned
    expression >= 0 is always true [-Wtype-limits]
    
    Fixes: 3425d934fc03 ("efi/x86: Handle page faults occurring while running ...")
    Signed-off-by: Qian Cai <cai@lca.pw>
    Acked-by: "Prakhya, Sai Praneeth" <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 632b83885867..3b9fd679cea9 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -728,7 +728,7 @@ void efi_recover_from_page_fault(unsigned long phys_addr)
 	 * Address range 0x0000 - 0x0fff is always mapped in the efi_pgd, so
 	 * page faulting on these addresses isn't expected.
 	 */
-	if (phys_addr >= 0x0000 && phys_addr <= 0x0fff)
+	if (phys_addr <= 0x0fff)
 		return;
 
 	/*

commit 88447c5b93d98be847f428c39ba589779a59eb83
Author: Rob Bradford <robert.bradford@intel.com>
Date:   Sat May 25 13:25:59 2019 +0200

    efi: Allow the number of EFI configuration tables entries to be zero
    
    Only try and access the EFI configuration tables if there there are any
    reported. This allows EFI to be continued to used on systems where there
    are no configuration table entries.
    
    Signed-off-by: Rob Bradford <robert.bradford@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Gen Zhang <blackgod016574@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190525112559.7917-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index feb77777c8b8..632b83885867 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -513,6 +513,9 @@ int __init efi_reuse_config(u64 tables, int nr_tables)
 	void *p, *tablep;
 	struct efi_setup_data *data;
 
+	if (nr_tables == 0)
+		return 0;
+
 	if (!efi_setup)
 		return 0;
 

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index a25a9fd987a9..feb77777c8b8 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #define pr_fmt(fmt) "efi: " fmt
 
 #include <linux/init.h>

commit f560bd19d2fe0e54851d706b72acbc6f2eed3567
Author: Matteo Croce <mcroce@redhat.com>
Date:   Thu Mar 28 12:42:33 2019 +0100

    x86/realmode: Make set_real_mode_mem() static inline
    
    Remove the unused @size argument and move it into a header file, so it
    can be inlined.
    
     [ bp: Massage. ]
    
    Signed-off-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: linux-efi <linux-efi@vger.kernel.org>
    Cc: platform-driver-x86@vger.kernel.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20190328114233.27835-1-mcroce@redhat.com

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 458a0e2bcc57..a25a9fd987a9 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -449,7 +449,7 @@ void __init efi_free_boot_services(void)
 		 */
 		rm_size = real_mode_size_needed();
 		if (rm_size && (start + rm_size) < (1<<20) && size >= rm_size) {
-			set_real_mode_mem(start, rm_size);
+			set_real_mode_mem(start);
 			start += rm_size;
 			size -= rm_size;
 		}

commit 5c418dc789a3898717ebf2caa5716ba91a7150b2
Author: Anders Roxell <anders.roxell@linaro.org>
Date:   Fri Feb 15 17:55:51 2019 +0100

    efi: Fix build error due to enum collision between efi.h and ima.h
    
    The following commit:
    
      a893ea15d764 ("tpm: move tpm_chip definition to include/linux/tpm.h")
    
    introduced a build error when both IMA and EFI are enabled:
    
        In file included from ../security/integrity/ima/ima_fs.c:30:
        ../security/integrity/ima/ima.h:176:7: error: redeclaration of enumerator "NONE"
    
    What happens is that both headers (ima.h and efi.h) defines the same
    'NONE' constant, and it broke when they started getting included from
    the same file:
    
    Rework to prefix the EFI enum with 'EFI_*'.
    
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190215165551.12220-2-ard.biesheuvel@linaro.org
    [ Cleaned up the changelog a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 9ce85e605052..458a0e2bcc57 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -717,7 +717,7 @@ void efi_recover_from_page_fault(unsigned long phys_addr)
 	 * "efi_mm" cannot be used to check if the page fault had occurred
 	 * in the firmware context because efi=old_map doesn't use efi_pgd.
 	 */
-	if (efi_rts_work.efi_rts_id == NONE)
+	if (efi_rts_work.efi_rts_id == EFI_NONE)
 		return;
 
 	/*
@@ -742,7 +742,7 @@ void efi_recover_from_page_fault(unsigned long phys_addr)
 	 * because this case occurs *very* rarely and hence could be improved
 	 * on a need by basis.
 	 */
-	if (efi_rts_work.efi_rts_id == RESET_SYSTEM) {
+	if (efi_rts_work.efi_rts_id == EFI_RESET_SYSTEM) {
 		pr_info("efi_reset_system() buggy! Reboot through BIOS\n");
 		machine_real_restart(MRR_BIOS);
 		return;

commit 8fe55212aacfce9b7718de7964b3a3096ec30919
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Sat Feb 2 10:41:10 2019 +0100

    x86/efi: Mark can_free_region() as an __init function
    
    can_free_region() is called only once during boot, by
    efi_reserve_boot_services().
    
    Hence, mark it as an __init function.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Alexander Graf <agraf@suse.de>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 17456a1d3f04..9ce85e605052 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -304,7 +304,7 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
  * - Not within any part of the kernel
  * - Not the BIOS reserved area (E820_TYPE_RESERVED, E820_TYPE_NVS, etc)
  */
-static bool can_free_region(u64 start, u64 size)
+static __init bool can_free_region(u64 start, u64 size)
 {
 	if (start + size > __pa_symbol(_text) && start <= __pa_symbol(_end))
 		return false;

commit 1debf0958fa27b7c469dbf22754929ec59a7c0e7
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Fri Dec 21 18:22:34 2018 -0800

    x86/efi: Don't unmap EFI boot services code/data regions for EFI_OLD_MEMMAP and EFI_MIXED_MODE
    
    The following commit:
    
      d5052a7130a6 ("x86/efi: Unmap EFI boot services code/data regions from efi_pgd")
    
    forgets to take two EFI modes into consideration, namely EFI_OLD_MEMMAP and
    EFI_MIXED_MODE:
    
    - EFI_OLD_MEMMAP is a legacy way of mapping EFI regions into swapper_pg_dir
      using ioremap() and init_memory_mapping(). This feature can be enabled by
      passing "efi=old_map" as kernel command line argument. But,
      efi_unmap_pages() unmaps EFI boot services code/data regions *only* from
      efi_pgd and hence cannot be used for unmapping EFI boot services code/data
      regions from swapper_pg_dir.
    
    Introduce a temporary fix to not unmap EFI boot services code/data regions
    when EFI_OLD_MEMMAP is enabled while working on a real fix.
    
    - EFI_MIXED_MODE is another feature where a 64-bit kernel runs on a
      64-bit platform crippled by a 32-bit firmware. To support EFI_MIXED_MODE,
      all RAM (i.e. namely EFI regions like EFI_CONVENTIONAL_MEMORY,
      EFI_LOADER_<CODE/DATA>, EFI_BOOT_SERVICES_<CODE/DATA> and
      EFI_RUNTIME_CODE/DATA regions) is mapped into efi_pgd all the time to
      facilitate EFI runtime calls access it's arguments in 1:1 mode.
    
    Hence, don't unmap EFI boot services code/data regions when booted in mixed mode.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@surriel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181222022234.7573-1-sai.praneeth.prakhya@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 09e811b9da26..17456a1d3f04 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -380,6 +380,22 @@ static void __init efi_unmap_pages(efi_memory_desc_t *md)
 	u64 pa = md->phys_addr;
 	u64 va = md->virt_addr;
 
+	/*
+	 * To Do: Remove this check after adding functionality to unmap EFI boot
+	 * services code/data regions from direct mapping area because
+	 * "efi=old_map" maps EFI regions in swapper_pg_dir.
+	 */
+	if (efi_enabled(EFI_OLD_MEMMAP))
+		return;
+
+	/*
+	 * EFI mixed mode has all RAM mapped to access arguments while making
+	 * EFI runtime calls, hence don't unmap EFI boot services code/data
+	 * regions.
+	 */
+	if (!efi_is_native())
+		return;
+
 	if (kernel_unmap_pages_in_pgd(pgd, pa, md->num_pages))
 		pr_err("Failed to unmap 1:1 mapping for 0x%llx\n", pa);
 

commit 08cfb38f3ef49cfd1bba11a00401451606477d80
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Thu Nov 29 18:12:24 2018 +0100

    x86/efi: Unmap EFI boot services code/data regions from efi_pgd
    
    efi_free_boot_services(), as the name suggests, frees EFI boot services
    code/data regions but forgets to unmap these regions from efi_pgd. This
    means that any code that's running in efi_pgd address space (e.g:
    any EFI runtime service) would still be able to access these regions but
    the contents of these regions would have long been over written by
    someone else. So, it's important to unmap these regions. Hence,
    introduce efi_unmap_pages() to unmap these regions from efi_pgd.
    
    After unmapping EFI boot services code/data regions, any illegal access
    by buggy firmware to these regions would result in page fault which will
    be handled by EFI specific fault handler.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 95e77a667ba5..09e811b9da26 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -369,6 +369,24 @@ void __init efi_reserve_boot_services(void)
 	}
 }
 
+/*
+ * Apart from having VA mappings for EFI boot services code/data regions,
+ * (duplicate) 1:1 mappings were also created as a quirk for buggy firmware. So,
+ * unmap both 1:1 and VA mappings.
+ */
+static void __init efi_unmap_pages(efi_memory_desc_t *md)
+{
+	pgd_t *pgd = efi_mm.pgd;
+	u64 pa = md->phys_addr;
+	u64 va = md->virt_addr;
+
+	if (kernel_unmap_pages_in_pgd(pgd, pa, md->num_pages))
+		pr_err("Failed to unmap 1:1 mapping for 0x%llx\n", pa);
+
+	if (kernel_unmap_pages_in_pgd(pgd, va, md->num_pages))
+		pr_err("Failed to unmap VA mapping for 0x%llx\n", va);
+}
+
 void __init efi_free_boot_services(void)
 {
 	phys_addr_t new_phys, new_size;
@@ -393,6 +411,13 @@ void __init efi_free_boot_services(void)
 			continue;
 		}
 
+		/*
+		 * Before calling set_virtual_address_map(), EFI boot services
+		 * code/data regions were mapped as a quirk for buggy firmware.
+		 * Unmap them from efi_pgd before freeing them up.
+		 */
+		efi_unmap_pages(md);
+
 		/*
 		 * Nasty quirk: if all sub-1MB memory is used for boot
 		 * services, we can get here without having allocated the

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 4b70d0f5a803..95e77a667ba5 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -8,7 +8,6 @@
 #include <linux/efi.h>
 #include <linux/slab.h>
 #include <linux/memblock.h>
-#include <linux/bootmem.h>
 #include <linux/acpi.h>
 #include <linux/dmi.h>
 

commit 53ab85ebfd27cdf16c8ddc72781c072a63bef3cb
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:25 2018 -0700

    memblock: replace free_bootmem_late with memblock_free_late
    
    The free_bootmem_late and memblock_free_late do exactly the same thing:
    they iterate over a range and give pages to the page allocator.
    
    Replace calls to free_bootmem_late with calls to memblock_free_late and
    remove the bootmem variant.
    
    Link: http://lkml.kernel.org/r/1536927045-23536-25-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 669babcaf245..4b70d0f5a803 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -333,7 +333,7 @@ void __init efi_reserve_boot_services(void)
 
 		/*
 		 * Because the following memblock_reserve() is paired
-		 * with free_bootmem_late() for this region in
+		 * with memblock_free_late() for this region in
 		 * efi_free_boot_services(), we must be extremely
 		 * careful not to reserve, and subsequently free,
 		 * critical regions of memory (like the kernel image) or
@@ -364,7 +364,7 @@ void __init efi_reserve_boot_services(void)
 		 * doesn't make sense as far as the firmware is
 		 * concerned, but it does provide us with a way to tag
 		 * those regions that must not be paired with
-		 * free_bootmem_late().
+		 * memblock_free_late().
 		 */
 		md->attribute |= EFI_MEMORY_RUNTIME;
 	}
@@ -414,7 +414,7 @@ void __init efi_free_boot_services(void)
 			size -= rm_size;
 		}
 
-		free_bootmem_late(start, size);
+		memblock_free_late(start, size);
 	}
 
 	if (!num_entries)

commit 3425d934fc0312f62024163736a7afe4de20c10f
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Sep 11 12:15:22 2018 -0700

    efi/x86: Handle page faults occurring while running EFI runtime services
    
    Memory accesses performed by UEFI runtime services should be limited to:
    - reading/executing from EFI_RUNTIME_SERVICES_CODE memory regions
    - reading/writing from/to EFI_RUNTIME_SERVICES_DATA memory regions
    - reading/writing by-ref arguments
    - reading/writing from/to the stack.
    
    Accesses outside these regions may cause the kernel to hang because the
    memory region requested by the firmware isn't mapped in efi_pgd, which
    causes a page fault in ring 0 and the kernel fails to handle it, leading
    to die(). To save kernel from hanging, add an EFI specific page fault
    handler which recovers from such faults by
    1. If the efi runtime service is efi_reset_system(), reboot the machine
       through BIOS.
    2. If the efi runtime service is _not_ efi_reset_system(), then freeze
       efi_rts_wq and schedule a new process.
    
    The EFI page fault handler offers us two advantages:
    1. Avoid potential hangs caused by buggy firmware.
    2. Shout loud that the firmware is buggy and hence is not a kernel bug.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Suggested-by: Matt Fleming <matt@codeblueprint.co.uk>
    Based-on-code-from: Ricardo Neri <ricardo.neri@intel.com>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [ardb: clarify commit log]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 844d31cb8a0c..669babcaf245 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -16,6 +16,7 @@
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
 #include <asm/cpu_device_id.h>
+#include <asm/reboot.h>
 
 #define EFI_MIN_RESERVE 5120
 
@@ -654,3 +655,80 @@ int efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,
 }
 
 #endif
+
+/*
+ * If any access by any efi runtime service causes a page fault, then,
+ * 1. If it's efi_reset_system(), reboot through BIOS.
+ * 2. If any other efi runtime service, then
+ *    a. Return error status to the efi caller process.
+ *    b. Disable EFI Runtime Services forever and
+ *    c. Freeze efi_rts_wq and schedule new process.
+ *
+ * @return: Returns, if the page fault is not handled. This function
+ * will never return if the page fault is handled successfully.
+ */
+void efi_recover_from_page_fault(unsigned long phys_addr)
+{
+	if (!IS_ENABLED(CONFIG_X86_64))
+		return;
+
+	/*
+	 * Make sure that an efi runtime service caused the page fault.
+	 * "efi_mm" cannot be used to check if the page fault had occurred
+	 * in the firmware context because efi=old_map doesn't use efi_pgd.
+	 */
+	if (efi_rts_work.efi_rts_id == NONE)
+		return;
+
+	/*
+	 * Address range 0x0000 - 0x0fff is always mapped in the efi_pgd, so
+	 * page faulting on these addresses isn't expected.
+	 */
+	if (phys_addr >= 0x0000 && phys_addr <= 0x0fff)
+		return;
+
+	/*
+	 * Print stack trace as it might be useful to know which EFI Runtime
+	 * Service is buggy.
+	 */
+	WARN(1, FW_BUG "Page fault caused by firmware at PA: 0x%lx\n",
+	     phys_addr);
+
+	/*
+	 * Buggy efi_reset_system() is handled differently from other EFI
+	 * Runtime Services as it doesn't use efi_rts_wq. Although,
+	 * native_machine_emergency_restart() says that machine_real_restart()
+	 * could fail, it's better not to compilcate this fault handler
+	 * because this case occurs *very* rarely and hence could be improved
+	 * on a need by basis.
+	 */
+	if (efi_rts_work.efi_rts_id == RESET_SYSTEM) {
+		pr_info("efi_reset_system() buggy! Reboot through BIOS\n");
+		machine_real_restart(MRR_BIOS);
+		return;
+	}
+
+	/*
+	 * Before calling EFI Runtime Service, the kernel has switched the
+	 * calling process to efi_mm. Hence, switch back to task_mm.
+	 */
+	arch_efi_call_virt_teardown();
+
+	/* Signal error status to the efi caller process */
+	efi_rts_work.status = EFI_ABORTED;
+	complete(&efi_rts_work.efi_rts_comp);
+
+	clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+	pr_info("Froze efi_rts_wq and disabled EFI Runtime Services\n");
+
+	/*
+	 * Call schedule() in an infinite loop, so that any spurious wake ups
+	 * will never run efi_rts_wq again.
+	 */
+	for (;;) {
+		set_current_state(TASK_IDLE);
+		schedule();
+	}
+
+	return;
+}

commit 7e1550b8f2081cccdfa9f1cf1e54cbc4d720af7f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 11 11:40:39 2018 +0200

    efi: Drop type and attribute checks in efi_mem_desc_lookup()
    
    The current implementation of efi_mem_desc_lookup() includes the
    following check on the memory descriptor it returns:
    
        if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
            md->type != EFI_BOOT_SERVICES_DATA &&
            md->type != EFI_RUNTIME_SERVICES_DATA) {
                continue;
        }
    
    This means that only EfiBootServicesData or EfiRuntimeServicesData
    regions are considered, or any other region type provided that it
    has the EFI_MEMORY_RUNTIME attribute set.
    
    Given what the name of the function implies, and the fact that any
    physical address can be described in the UEFI memory map only a single
    time, it does not make sense to impose this condition in the body of the
    loop, but instead, should be imposed by the caller depending on the value
    that is returned to it.
    
    Two such callers exist at the moment:
    
    - The BGRT code when running on x86, via efi_mem_reserve() and
      efi_arch_mem_reserve(). In this case, the region is already known to
      be EfiBootServicesData, and so the check is redundant.
    
    - The ESRT handling code which introduced this function, which calls it
      both directly from efi_esrt_init() and again via efi_mem_reserve() and
      efi_arch_mem_reserve() [on x86].
    
    So let's move this check into the callers instead. This preserves the
    current behavior both for BGRT and ESRT handling, and allows the lookup
    routine to be reused by other [upcoming] users that don't have this
    limitation.
    
    In the ESRT case, keep the entire condition, so that platforms that
    deviate from the UEFI spec and use something other than
    EfiBootServicesData for the ESRT table will keep working as before.
    
    For x86's efi_arch_mem_reserve() implementation, limit the type to
    EfiBootServicesData, since it is the only type the reservation code
    expects to operate on in the first place.
    
    While we're at it, drop the __init annotation so that drivers can use it
    as well.
    
    Tested-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-8-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 6af39dc40325..844d31cb8a0c 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -248,7 +248,8 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 	int num_entries;
 	void *new;
 
-	if (efi_mem_desc_lookup(addr, &md)) {
+	if (efi_mem_desc_lookup(addr, &md) ||
+	    md.type != EFI_BOOT_SERVICES_DATA) {
 		pr_err("Failed to lookup EFI memory descriptor for %pa\n", &addr);
 		return;
 	}

commit 5a58bc1b1edc18a9edff606ec99e6f6b723975f4
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Jul 11 11:40:34 2018 +0200

    efi/x86: Use non-blocking SetVariable() for efi_delete_dummy_variable()
    
    Presently, efi_delete_dummy_variable() uses set_variable() which might
    block, which the scheduler is rightfully upset about when used from
    the idle thread, producing this splat:
    
      "bad: scheduling from the idle thread!"
    
    So, make efi_delete_dummy_variable() use set_variable_nonblocking(),
    which, as the name suggests, doesn't block.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 36c1f8b9f7e0..6af39dc40325 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -105,12 +105,11 @@ early_param("efi_no_storage_paranoia", setup_storage_paranoia);
 */
 void efi_delete_dummy_variable(void)
 {
-	efi.set_variable((efi_char16_t *)efi_dummy_name,
-			 &EFI_DUMMY_GUID,
-			 EFI_VARIABLE_NON_VOLATILE |
-			 EFI_VARIABLE_BOOTSERVICE_ACCESS |
-			 EFI_VARIABLE_RUNTIME_ACCESS,
-			 0, NULL);
+	efi.set_variable_nonblocking((efi_char16_t *)efi_dummy_name,
+				     &EFI_DUMMY_GUID,
+				     EFI_VARIABLE_NON_VOLATILE |
+				     EFI_VARIABLE_BOOTSERVICE_ACCESS |
+				     EFI_VARIABLE_RUNTIME_ACCESS, 0, NULL);
 }
 
 /*

commit 36b649760e94968e0495b73284aaf07eed0a328f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Mar 12 08:45:00 2018 +0000

    efi: Use string literals for efi_char16_t variable initializers
    
    Now that we unambiguously build the entire kernel with -fshort-wchar,
    it is no longer necessary to open code efi_char16_t[] initializers as
    arrays of characters, and we can move to the L"xxx" notation instead.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180312084500.10764-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 1ef11c26f79b..36c1f8b9f7e0 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -75,7 +75,7 @@ struct quark_security_header {
 	u32 rsvd[2];
 };
 
-static efi_char16_t efi_dummy_name[6] = { 'D', 'U', 'M', 'M', 'Y', 0 };
+static const efi_char16_t efi_dummy_name[] = L"DUMMY";
 
 static bool efi_no_storage_paranoia;
 
@@ -105,7 +105,8 @@ early_param("efi_no_storage_paranoia", setup_storage_paranoia);
 */
 void efi_delete_dummy_variable(void)
 {
-	efi.set_variable(efi_dummy_name, &EFI_DUMMY_GUID,
+	efi.set_variable((efi_char16_t *)efi_dummy_name,
+			 &EFI_DUMMY_GUID,
 			 EFI_VARIABLE_NON_VOLATILE |
 			 EFI_VARIABLE_BOOTSERVICE_ACCESS |
 			 EFI_VARIABLE_RUNTIME_ACCESS,
@@ -182,7 +183,8 @@ efi_status_t efi_query_variable_store(u32 attributes, unsigned long size,
 		if (!dummy)
 			return EFI_OUT_OF_RESOURCES;
 
-		status = efi.set_variable(efi_dummy_name, &EFI_DUMMY_GUID,
+		status = efi.set_variable((efi_char16_t *)efi_dummy_name,
+					  &EFI_DUMMY_GUID,
 					  EFI_VARIABLE_NON_VOLATILE |
 					  EFI_VARIABLE_BOOTSERVICE_ACCESS |
 					  EFI_VARIABLE_RUNTIME_ACCESS,

commit 9f66d8d73e654c5f867daa6aa186300ecaf49d3a
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Thu Mar 8 08:00:14 2018 +0000

    x86/efi: Replace GFP_ATOMIC with GFP_KERNEL in efi_query_variable_store()
    
    efi_query_variable_store() does an atomic kzalloc() unnecessarily,
    because we can never get this far when called in an atomic context,
    namely when nonblocking == 1.
    
    Replace it with GFP_KERNEL.
    
    This was found by the DCNS static analysis tool written by myself.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180308080020.22828-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 5b513ccffde4..1ef11c26f79b 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -177,7 +177,7 @@ efi_status_t efi_query_variable_store(u32 attributes, unsigned long size,
 		 * that by attempting to use more space than is available.
 		 */
 		unsigned long dummy_size = remaining_size + 1024;
-		void *dummy = kzalloc(dummy_size, GFP_ATOMIC);
+		void *dummy = kzalloc(dummy_size, GFP_KERNEL);
 
 		if (!dummy)
 			return EFI_OUT_OF_RESOURCES;

commit f24c4d478013d82bd1b943df566fff3561d52864
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jan 2 17:21:10 2018 +0000

    efi/capsule-loader: Reinstate virtual capsule mapping
    
    Commit:
    
      82c3768b8d68 ("efi/capsule-loader: Use a cached copy of the capsule header")
    
    ... refactored the capsule loading code that maps the capsule header,
    to avoid having to map it several times.
    
    However, as it turns out, the vmap() call we ended up removing did not
    just map the header, but the entire capsule image, and dropping this
    virtual mapping breaks capsules that are processed by the firmware
    immediately (i.e., without a reboot).
    
    Unfortunately, that change was part of a larger refactor that allowed
    a quirk to be implemented for Quark, which has a non-standard memory
    layout for capsules, and we have slightly painted ourselves into a
    corner by allowing quirk code to mangle the capsule header and memory
    layout.
    
    So we need to fix this without breaking Quark. Fortunately, Quark does
    not appear to care about the virtual mapping, and so we can simply
    do a partial revert of commit:
    
      2a457fb31df6 ("efi/capsule-loader: Use page addresses rather than struct page pointers")
    
    ... and create a vmap() mapping of the entire capsule (including header)
    based on the reinstated struct page array, unless running on Quark, in
    which case we pass the capsule header copy as before.
    
    Reported-by: Ge Song <ge.song@hxt-semitech.com>
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Tested-by: Ge Song <ge.song@hxt-semitech.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 82c3768b8d68 ("efi/capsule-loader: Use a cached copy of the capsule header")
    Link: http://lkml.kernel.org/r/20180102172110.17018-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 8a99a2e96537..5b513ccffde4 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -592,7 +592,18 @@ static int qrk_capsule_setup_info(struct capsule_info *cap_info, void **pkbuff,
 	/*
 	 * Update the first page pointer to skip over the CSH header.
 	 */
-	cap_info->pages[0] += csh->headersize;
+	cap_info->phys[0] += csh->headersize;
+
+	/*
+	 * cap_info->capsule should point at a virtual mapping of the entire
+	 * capsule, starting at the capsule header. Our image has the Quark
+	 * security header prepended, so we cannot rely on the default vmap()
+	 * mapping created by the generic capsule code.
+	 * Given that the Quark firmware does not appear to care about the
+	 * virtual mapping, let's just point cap_info->capsule at our copy
+	 * of the capsule header.
+	 */
+	cap_info->capsule = &cap_info->header;
 
 	return 1;
 }

commit 2959c95d510cc45b246ba727eb8fdf8b601c6eec
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Fri Jun 2 13:52:04 2017 +0000

    efi/capsule: Add support for Quark security header
    
    The firmware for Quark X102x prepends a security header to the capsule
    which is needed to support the mandatory secure boot on this processor.
    The header can be detected by checking for the "_CSH" signature and -
    to avoid any GUID conflict - validating its size field to contain the
    expected value. Then we need to look for the EFI header right after the
    security header and pass the real header to __efi_capsule_setup_info.
    
    To be minimal invasive and maximal safe, the quirk version of
    efi_capsule_setup_info() is only effective on Quark processors.
    
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170602135207.21708-11-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index e0cf95a83f3f..8a99a2e96537 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -15,12 +15,66 @@
 #include <asm/e820/api.h>
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
+#include <asm/cpu_device_id.h>
 
 #define EFI_MIN_RESERVE 5120
 
 #define EFI_DUMMY_GUID \
 	EFI_GUID(0x4424ac57, 0xbe4b, 0x47dd, 0x9e, 0x97, 0xed, 0x50, 0xf0, 0x9f, 0x92, 0xa9)
 
+#define QUARK_CSH_SIGNATURE		0x5f435348	/* _CSH */
+#define QUARK_SECURITY_HEADER_SIZE	0x400
+
+/*
+ * Header prepended to the standard EFI capsule on Quark systems the are based
+ * on Intel firmware BSP.
+ * @csh_signature:	Unique identifier to sanity check signed module
+ * 			presence ("_CSH").
+ * @version:		Current version of CSH used. Should be one for Quark A0.
+ * @modulesize:		Size of the entire module including the module header
+ * 			and payload.
+ * @security_version_number_index: Index of SVN to use for validation of signed
+ * 			module.
+ * @security_version_number: Used to prevent against roll back of modules.
+ * @rsvd_module_id:	Currently unused for Clanton (Quark).
+ * @rsvd_module_vendor:	Vendor Identifier. For Intel products value is
+ * 			0x00008086.
+ * @rsvd_date:		BCD representation of build date as yyyymmdd, where
+ * 			yyyy=4 digit year, mm=1-12, dd=1-31.
+ * @headersize:		Total length of the header including including any
+ * 			padding optionally added by the signing tool.
+ * @hash_algo:		What Hash is used in the module signing.
+ * @cryp_algo:		What Crypto is used in the module signing.
+ * @keysize:		Total length of the key data including including any
+ * 			padding optionally added by the signing tool.
+ * @signaturesize:	Total length of the signature including including any
+ * 			padding optionally added by the signing tool.
+ * @rsvd_next_header:	32-bit pointer to the next Secure Boot Module in the
+ * 			chain, if there is a next header.
+ * @rsvd:		Reserved, padding structure to required size.
+ *
+ * See also QuartSecurityHeader_t in
+ * Quark_EDKII_v1.2.1.1/QuarkPlatformPkg/Include/QuarkBootRom.h
+ * from https://downloadcenter.intel.com/download/23197/Intel-Quark-SoC-X1000-Board-Support-Package-BSP
+ */
+struct quark_security_header {
+	u32 csh_signature;
+	u32 version;
+	u32 modulesize;
+	u32 security_version_number_index;
+	u32 security_version_number;
+	u32 rsvd_module_id;
+	u32 rsvd_module_vendor;
+	u32 rsvd_date;
+	u32 headersize;
+	u32 hash_algo;
+	u32 cryp_algo;
+	u32 keysize;
+	u32 signaturesize;
+	u32 rsvd_next_header;
+	u32 rsvd[2];
+};
+
 static efi_char16_t efi_dummy_name[6] = { 'D', 'U', 'M', 'M', 'Y', 0 };
 
 static bool efi_no_storage_paranoia;
@@ -504,3 +558,86 @@ bool efi_poweroff_required(void)
 {
 	return acpi_gbl_reduced_hardware || acpi_no_s5;
 }
+
+#ifdef CONFIG_EFI_CAPSULE_QUIRK_QUARK_CSH
+
+static int qrk_capsule_setup_info(struct capsule_info *cap_info, void **pkbuff,
+				  size_t hdr_bytes)
+{
+	struct quark_security_header *csh = *pkbuff;
+
+	/* Only process data block that is larger than the security header */
+	if (hdr_bytes < sizeof(struct quark_security_header))
+		return 0;
+
+	if (csh->csh_signature != QUARK_CSH_SIGNATURE ||
+	    csh->headersize != QUARK_SECURITY_HEADER_SIZE)
+		return 1;
+
+	/* Only process data block if EFI header is included */
+	if (hdr_bytes < QUARK_SECURITY_HEADER_SIZE +
+			sizeof(efi_capsule_header_t))
+		return 0;
+
+	pr_debug("Quark security header detected\n");
+
+	if (csh->rsvd_next_header != 0) {
+		pr_err("multiple Quark security headers not supported\n");
+		return -EINVAL;
+	}
+
+	*pkbuff += csh->headersize;
+	cap_info->total_size = csh->headersize;
+
+	/*
+	 * Update the first page pointer to skip over the CSH header.
+	 */
+	cap_info->pages[0] += csh->headersize;
+
+	return 1;
+}
+
+#define ICPU(family, model, quirk_handler) \
+	{ X86_VENDOR_INTEL, family, model, X86_FEATURE_ANY, \
+	  (unsigned long)&quirk_handler }
+
+static const struct x86_cpu_id efi_capsule_quirk_ids[] = {
+	ICPU(5, 9, qrk_capsule_setup_info),	/* Intel Quark X1000 */
+	{ }
+};
+
+int efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,
+			   size_t hdr_bytes)
+{
+	int (*quirk_handler)(struct capsule_info *, void **, size_t);
+	const struct x86_cpu_id *id;
+	int ret;
+
+	if (hdr_bytes < sizeof(efi_capsule_header_t))
+		return 0;
+
+	cap_info->total_size = 0;
+
+	id = x86_match_cpu(efi_capsule_quirk_ids);
+	if (id) {
+		/*
+		 * The quirk handler is supposed to return
+		 *  - a value > 0 if the setup should continue, after advancing
+		 *    kbuff as needed
+		 *  - 0 if not enough hdr_bytes are available yet
+		 *  - a negative error code otherwise
+		 */
+		quirk_handler = (typeof(quirk_handler))id->driver_data;
+		ret = quirk_handler(cap_info, &kbuff, hdr_bytes);
+		if (ret <= 0)
+			return ret;
+	}
+
+	memcpy(&cap_info->header, kbuff, sizeof(cap_info->header));
+
+	cap_info->total_size += cap_info->header.imagesize;
+
+	return __efi_capsule_setup_info(cap_info);
+}
+
+#endif

commit 1ea34adb87c969b89dfd83f1905a79161e9ada26
Author: Juergen Gross <jgross@suse.com>
Date:   Fri May 26 12:36:47 2017 +0100

    efi: Don't issue error message when booted under Xen
    
    When booted as Xen dom0 there won't be an EFI memmap allocated. Avoid
    issuing an error message in this case:
    
      [    0.144079] efi: Failed to allocate new EFI memmap
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: <stable@vger.kernel.org> # v4.9+
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170526113652.21339-2-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 26615991d69c..e0cf95a83f3f 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -360,6 +360,9 @@ void __init efi_free_boot_services(void)
 		free_bootmem_late(start, size);
 	}
 
+	if (!num_entries)
+		return;
+
 	new_size = efi.memmap.desc_size * num_entries;
 	new_phys = efi_memmap_alloc(num_entries);
 	if (!new_phys) {

commit 16b76293c5c81e6345323d7aef41b26e8390f62d
Merge: 3dee9fb2a4ce da63b6b20077
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 20:51:12 2017 -0700

    Merge branch 'x86-boot-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 boot updates from Ingo Molnar:
     "The biggest changes in this cycle were:
    
       - reworking of the e820 code: separate in-kernel and boot-ABI data
         structures and apply a whole range of cleanups to the kernel side.
    
         No change in functionality.
    
       - enable KASLR by default: it's used by all major distros and it's
         out of the experimental stage as well.
    
       - ... misc fixes and cleanups"
    
    * 'x86-boot-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (63 commits)
      x86/KASLR: Fix kexec kernel boot crash when KASLR randomization fails
      x86/reboot: Turn off KVM when halting a CPU
      x86/boot: Fix BSS corruption/overwrite bug in early x86 kernel startup
      x86: Enable KASLR by default
      boot/param: Move next_arg() function to lib/cmdline.c for later reuse
      x86/boot: Fix Sparse warning by including required header file
      x86/boot/64: Rename start_cpu()
      x86/xen: Update e820 table handling to the new core x86 E820 code
      x86/boot: Fix pr_debug() API braindamage
      xen, x86/headers: Add <linux/device.h> dependency to <asm/xen/page.h>
      x86/boot/e820: Simplify e820__update_table()
      x86/boot/e820: Separate the E820 ABI structures from the in-kernel structures
      x86/boot/e820: Fix and clean up e820_type switch() statements
      x86/boot/e820: Rename the remaining E820 APIs to the e820__*() prefix
      x86/boot/e820: Remove unnecessary #include's
      x86/boot/e820: Rename e820_mark_nosave_regions() to e820__register_nosave_regions()
      x86/boot/e820: Rename e820_reserve_resources*() to e820__reserve_resources*()
      x86/boot/e820: Use bool in query APIs
      x86/boot/e820: Document e820__reserve_setup_data()
      x86/boot/e820: Clean up __e820__update_table() et al
      ...

commit 6f6266a561306e206e0e31a5038f029b6a7b1d89
Author: Omar Sandoval <osandov@fb.com>
Date:   Wed Apr 12 16:27:19 2017 +0100

    x86/efi: Don't try to reserve runtime regions
    
    Reserving a runtime region results in splitting the EFI memory
    descriptors for the runtime region. This results in runtime region
    descriptors with bogus memory mappings, leading to interesting crashes
    like the following during a kexec:
    
      general protection fault: 0000 [#1] SMP
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc1 #53
      Hardware name: Wiwynn Leopard-Orv2/Leopard-DDR BW, BIOS LBM05   09/30/2016
      RIP: 0010:virt_efi_set_variable()
      ...
      Call Trace:
       efi_delete_dummy_variable()
       efi_enter_virtual_mode()
       start_kernel()
       ? set_init_arg()
       x86_64_start_reservations()
       x86_64_start_kernel()
       start_cpu()
      ...
      Kernel panic - not syncing: Fatal exception
    
    Runtime regions will not be freed and do not need to be reserved, so
    skip the memmap modification in this case.
    
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: <stable@vger.kernel.org> # v4.9+
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 8e80632fb23f ("efi/esrt: Use efi_mem_reserve() and avoid a kmalloc()")
    Link: http://lkml.kernel.org/r/20170412152719.9779-2-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 30031d5293c4..cdfe8c628959 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -201,6 +201,10 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 		return;
 	}
 
+	/* No need to reserve regions that will never be freed. */
+	if (md.attribute & EFI_MEMORY_RUNTIME)
+		return;
+
 	size += addr % EFI_PAGE_SIZE;
 	size = round_up(size, EFI_PAGE_SIZE);
 	addr = round_down(addr, EFI_PAGE_SIZE);

commit 09821ff1d50a1ecade182c2a68a90f835e257eef
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 17:09:33 2017 +0100

    x86/boot/e820: Prefix the E820_* type names with "E820_TYPE_"
    
    So there's a number of constants that start with "E820" but which
    are not types - these create a confusing mixture when seen together
    with 'enum e820_type' values:
    
            E820MAP
            E820NR
            E820_X_MAX
            E820MAX
    
    To better differentiate the 'enum e820_type' values prefix them
    with E820_TYPE_.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index d4acd1668d36..3c8d8e511fd4 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -242,14 +242,14 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
  * else. We must only reserve (and then free) regions:
  *
  * - Not within any part of the kernel
- * - Not the BIOS reserved area (E820_RESERVED, E820_NVS, etc)
+ * - Not the BIOS reserved area (E820_TYPE_RESERVED, E820_TYPE_NVS, etc)
  */
 static bool can_free_region(u64 start, u64 size)
 {
 	if (start + size > __pa_symbol(_text) && start <= __pa_symbol(_end))
 		return false;
 
-	if (!e820__mapped_all(start, start+size, E820_RAM))
+	if (!e820__mapped_all(start, start+size, E820_TYPE_RAM))
 		return false;
 
 	return true;
@@ -282,7 +282,7 @@ void __init efi_reserve_boot_services(void)
 		 * A good example of a critical region that must not be
 		 * freed is page zero (first 4Kb of memory), which may
 		 * contain boot services code/data but is marked
-		 * E820_RESERVED by trim_bios_range().
+		 * E820_TYPE_RESERVED by trim_bios_range().
 		 */
 		if (!already_reserved) {
 			memblock_reserve(start, size);

commit 3bce64f019a801f526cc38523c77ffda4e846155
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:14:25 2017 +0100

    x86/boot/e820: Rename e820_any_mapped()/e820_all_mapped() to e820__mapped_any()/e820__mapped_all()
    
    The 'any' and 'all' are modified to the 'mapped' concept, so move them last in the name.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index c6a14b11f496..d4acd1668d36 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -249,7 +249,7 @@ static bool can_free_region(u64 start, u64 size)
 	if (start + size > __pa_symbol(_text) && start <= __pa_symbol(_end))
 		return false;
 
-	if (!e820_all_mapped(start, start+size, E820_RAM))
+	if (!e820__mapped_all(start, start+size, E820_RAM))
 		return false;
 
 	return true;

commit 5520b7e7d2d20ae2ab6e07b46c42cd43df9d2799
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Jan 27 11:59:46 2017 +0100

    x86/boot/e820: Remove spurious asm/e820/api.h inclusions
    
    A commonly used lowlevel x86 header, asm/pgtable.h, includes asm/e820/api.h
    spuriously, without making direct use of it.
    
    Removing it is not simple: over the years various .c code learned to rely
    on this indirect inclusion.
    
    Remove the unnecessary include - this should speed up the kernel build a bit,
    as a large header is not included anymore in totally unrelated code.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 30031d5293c4..c6a14b11f496 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -11,6 +11,8 @@
 #include <linux/bootmem.h>
 #include <linux/acpi.h>
 #include <linux/dmi.h>
+
+#include <asm/e820/api.h>
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
 

commit 20b1e22d01a4b0b11d3a1066e9feb04be38607ec
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Jan 5 13:51:29 2017 +0100

    x86/efi: Don't allocate memmap through memblock after mm_init()
    
    With the following commit:
    
      4bc9f92e64c8 ("x86/efi-bgrt: Use efi_mem_reserve() to avoid copying image data")
    
    ...  efi_bgrt_init() calls into the memblock allocator through
    efi_mem_reserve() => efi_arch_mem_reserve() *after* mm_init() has been called.
    
    Indeed, KASAN reports a bad read access later on in efi_free_boot_services():
    
      BUG: KASAN: use-after-free in efi_free_boot_services+0xae/0x24c
                at addr ffff88022de12740
      Read of size 4 by task swapper/0/0
      page:ffffea0008b78480 count:0 mapcount:-127
      mapping:          (null) index:0x1 flags: 0x5fff8000000000()
      [...]
      Call Trace:
       dump_stack+0x68/0x9f
       kasan_report_error+0x4c8/0x500
       kasan_report+0x58/0x60
       __asan_load4+0x61/0x80
       efi_free_boot_services+0xae/0x24c
       start_kernel+0x527/0x562
       x86_64_start_reservations+0x24/0x26
       x86_64_start_kernel+0x157/0x17a
       start_cpu+0x5/0x14
    
    The instruction at the given address is the first read from the memmap's
    memory, i.e. the read of md->type in efi_free_boot_services().
    
    Note that the writes earlier in efi_arch_mem_reserve() don't splat because
    they're done through early_memremap()ed addresses.
    
    So, after memblock is gone, allocations should be done through the "normal"
    page allocator. Introduce a helper, efi_memmap_alloc() for this. Use
    it from efi_arch_mem_reserve(), efi_free_boot_services() and, for the sake
    of consistency, from efi_fake_memmap() as well.
    
    Note that for the latter, the memmap allocations cease to be page aligned.
    This isn't needed though.
    
    Tested-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org> # v4.9
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Mika Penttilä <mika.penttila@nextfour.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 4bc9f92e64c8 ("x86/efi-bgrt: Use efi_mem_reserve() to avoid copying image data")
    Link: http://lkml.kernel.org/r/20170105125130.2815-1-nicstange@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 10aca63a50d7..30031d5293c4 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -214,7 +214,7 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 
 	new_size = efi.memmap.desc_size * num_entries;
 
-	new_phys = memblock_alloc(new_size, 0);
+	new_phys = efi_memmap_alloc(num_entries);
 	if (!new_phys) {
 		pr_err("Could not allocate boot services memmap\n");
 		return;
@@ -355,7 +355,7 @@ void __init efi_free_boot_services(void)
 	}
 
 	new_size = efi.memmap.desc_size * num_entries;
-	new_phys = memblock_alloc(new_size, 0);
+	new_phys = efi_memmap_alloc(num_entries);
 	if (!new_phys) {
 		pr_err("Failed to allocate new EFI memmap\n");
 		return;

commit 92dc33501bfba74655dbf3ec63ea82d040fd6d58
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Sep 16 15:12:47 2016 +0100

    x86/efi: Round EFI memmap reservations to EFI_PAGE_SIZE
    
    Mike Galbraith reported that his machine started rebooting during boot
    after,
    
      commit 8e80632fb23f ("efi/esrt: Use efi_mem_reserve() and avoid a kmalloc()")
    
    The ESRT table on his machine is 56 bytes and at no point in the
    efi_arch_mem_reserve() call path is that size rounded up to
    EFI_PAGE_SIZE, nor is the start address on an EFI_PAGE_SIZE boundary.
    
    Since the EFI memory map only deals with whole pages, inserting an EFI
    memory region with 56 bytes results in a new entry covering zero
    pages, and completely screws up the calculations for the old regions
    that were trimmed.
    
    Round all sizes upwards, and start addresses downwards, to the nearest
    EFI_PAGE_SIZE boundary.
    
    Additionally, efi_memmap_insert() expects the mem::range::end value to
    be one less than the end address for the region.
    
    Reported-by: Mike Galbraith <umgwanakikbuti@gmail.com>
    Reported-by: Mike Krinkin <krinkin.m.u@gmail.com>
    Tested-by: Mike Krinkin <krinkin.m.u@gmail.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index f14b7a9da24b..10aca63a50d7 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -201,8 +201,12 @@ void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
 		return;
 	}
 
+	size += addr % EFI_PAGE_SIZE;
+	size = round_up(size, EFI_PAGE_SIZE);
+	addr = round_down(addr, EFI_PAGE_SIZE);
+
 	mr.range.start = addr;
-	mr.range.end = addr + size;
+	mr.range.end = addr + size - 1;
 	mr.attribute = md.attribute | EFI_MEMORY_RUNTIME;
 
 	num_entries = efi_memmap_split_count(&md, &mr.range);

commit 816e76129ed5fadd28e526c43397c79775194b5c
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Feb 29 21:22:52 2016 +0000

    efi: Allow drivers to reserve boot services forever
    
    Today, it is not possible for drivers to reserve EFI boot services for
    access after efi_free_boot_services() has been called on x86. For
    ARM/arm64 it can be done simply by calling memblock_reserve().
    
    Having this ability for all three architectures is desirable for a
    couple of reasons,
    
      1) It saves drivers copying data out of those regions
      2) kexec reboot can now make use of things like ESRT
    
    Instead of using the standard memblock_reserve() which is insufficient
    to reserve the region on x86 (see efi_reserve_boot_services()), a new
    API is introduced in this patch; efi_mem_reserve().
    
    efi.memmap now always represents which EFI memory regions are
    available. On x86 the EFI boot services regions that have not been
    reserved via efi_mem_reserve() will be removed from efi.memmap during
    efi_free_boot_services().
    
    This has implications for kexec, since it is not possible for a newly
    kexec'd kernel to access the same boot services regions that the
    initial boot kernel had access to unless they are reserved by every
    kexec kernel in the chain.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 9faf18874692..f14b7a9da24b 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -163,6 +163,71 @@ efi_status_t efi_query_variable_store(u32 attributes, unsigned long size,
 }
 EXPORT_SYMBOL_GPL(efi_query_variable_store);
 
+/*
+ * The UEFI specification makes it clear that the operating system is
+ * free to do whatever it wants with boot services code after
+ * ExitBootServices() has been called. Ignoring this recommendation a
+ * significant bunch of EFI implementations continue calling into boot
+ * services code (SetVirtualAddressMap). In order to work around such
+ * buggy implementations we reserve boot services region during EFI
+ * init and make sure it stays executable. Then, after
+ * SetVirtualAddressMap(), it is discarded.
+ *
+ * However, some boot services regions contain data that is required
+ * by drivers, so we need to track which memory ranges can never be
+ * freed. This is done by tagging those regions with the
+ * EFI_MEMORY_RUNTIME attribute.
+ *
+ * Any driver that wants to mark a region as reserved must use
+ * efi_mem_reserve() which will insert a new EFI memory descriptor
+ * into efi.memmap (splitting existing regions if necessary) and tag
+ * it with EFI_MEMORY_RUNTIME.
+ */
+void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
+{
+	phys_addr_t new_phys, new_size;
+	struct efi_mem_range mr;
+	efi_memory_desc_t md;
+	int num_entries;
+	void *new;
+
+	if (efi_mem_desc_lookup(addr, &md)) {
+		pr_err("Failed to lookup EFI memory descriptor for %pa\n", &addr);
+		return;
+	}
+
+	if (addr + size > md.phys_addr + (md.num_pages << EFI_PAGE_SHIFT)) {
+		pr_err("Region spans EFI memory descriptors, %pa\n", &addr);
+		return;
+	}
+
+	mr.range.start = addr;
+	mr.range.end = addr + size;
+	mr.attribute = md.attribute | EFI_MEMORY_RUNTIME;
+
+	num_entries = efi_memmap_split_count(&md, &mr.range);
+	num_entries += efi.memmap.nr_map;
+
+	new_size = efi.memmap.desc_size * num_entries;
+
+	new_phys = memblock_alloc(new_size, 0);
+	if (!new_phys) {
+		pr_err("Could not allocate boot services memmap\n");
+		return;
+	}
+
+	new = early_memremap(new_phys, new_size);
+	if (!new) {
+		pr_err("Failed to map new boot services memmap\n");
+		return;
+	}
+
+	efi_memmap_insert(&efi.memmap, new, &mr);
+	early_memunmap(new, new_size);
+
+	efi_memmap_install(new_phys, num_entries);
+}
+
 /*
  * Helper function for efi_reserve_boot_services() to figure out if we
  * can free regions in efi_free_boot_services().
@@ -184,15 +249,6 @@ static bool can_free_region(u64 start, u64 size)
 	return true;
 }
 
-/*
- * The UEFI specification makes it clear that the operating system is free to do
- * whatever it wants with boot services code after ExitBootServices() has been
- * called. Ignoring this recommendation a significant bunch of EFI implementations 
- * continue calling into boot services code (SetVirtualAddressMap). In order to 
- * work around such buggy implementations we reserve boot services region during 
- * EFI init and make sure it stays executable. Then, after SetVirtualAddressMap(), it
-* is discarded.
-*/
 void __init efi_reserve_boot_services(void)
 {
 	efi_memory_desc_t *md;
@@ -249,7 +305,10 @@ void __init efi_reserve_boot_services(void)
 
 void __init efi_free_boot_services(void)
 {
+	phys_addr_t new_phys, new_size;
 	efi_memory_desc_t *md;
+	int num_entries = 0;
+	void *new, *new_md;
 
 	for_each_efi_memory_desc(md) {
 		unsigned long long start = md->phys_addr;
@@ -257,12 +316,16 @@ void __init efi_free_boot_services(void)
 		size_t rm_size;
 
 		if (md->type != EFI_BOOT_SERVICES_CODE &&
-		    md->type != EFI_BOOT_SERVICES_DATA)
+		    md->type != EFI_BOOT_SERVICES_DATA) {
+			num_entries++;
 			continue;
+		}
 
 		/* Do not free, someone else owns it: */
-		if (md->attribute & EFI_MEMORY_RUNTIME)
+		if (md->attribute & EFI_MEMORY_RUNTIME) {
+			num_entries++;
 			continue;
+		}
 
 		/*
 		 * Nasty quirk: if all sub-1MB memory is used for boot
@@ -286,6 +349,42 @@ void __init efi_free_boot_services(void)
 
 		free_bootmem_late(start, size);
 	}
+
+	new_size = efi.memmap.desc_size * num_entries;
+	new_phys = memblock_alloc(new_size, 0);
+	if (!new_phys) {
+		pr_err("Failed to allocate new EFI memmap\n");
+		return;
+	}
+
+	new = memremap(new_phys, new_size, MEMREMAP_WB);
+	if (!new) {
+		pr_err("Failed to map new EFI memmap\n");
+		return;
+	}
+
+	/*
+	 * Build a new EFI memmap that excludes any boot services
+	 * regions that are not tagged EFI_MEMORY_RUNTIME, since those
+	 * regions have now been freed.
+	 */
+	new_md = new;
+	for_each_efi_memory_desc(md) {
+		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
+		    (md->type == EFI_BOOT_SERVICES_CODE ||
+		     md->type == EFI_BOOT_SERVICES_DATA))
+			continue;
+
+		memcpy(new_md, md, efi.memmap.desc_size);
+		new_md += efi.memmap.desc_size;
+	}
+
+	memunmap(new);
+
+	if (efi_memmap_install(new_phys, num_entries)) {
+		pr_err("Could not install new EFI memmap\n");
+		return;
+	}
 }
 
 /*

commit dca0f971ea6fcf2f1bb78f7995adf80da9f4767f
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Sat Feb 27 15:52:50 2016 +0000

    efi: Add efi_memmap_init_late() for permanent EFI memmap
    
    Drivers need a way to access the EFI memory map at runtime. ARM and
    arm64 currently provide this by remapping the EFI memory map into the
    vmalloc space before setting up the EFI virtual mappings.
    
    x86 does not provide this functionality which has resulted in the code
    in efi_mem_desc_lookup() where it will manually map individual EFI
    memmap entries if the memmap has already been torn down on x86,
    
      /*
       * If a driver calls this after efi_free_boot_services,
       * ->map will be NULL, and the target may also not be mapped.
       * So just always get our own virtual map on the CPU.
       *
       */
      md = early_memremap(p, sizeof (*md));
    
    There isn't a good reason for not providing a permanent EFI memory map
    for runtime queries, especially since the EFI regions are not mapped
    into the standard kernel page tables.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 47b99108ff8e..9faf18874692 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -286,8 +286,6 @@ void __init efi_free_boot_services(void)
 
 		free_bootmem_late(start, size);
 	}
-
-	efi_memmap_unmap();
 }
 
 /*

commit 9479c7cebfb568f8b8b424be7f1cac120e9eea95
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Feb 26 21:22:05 2016 +0000

    efi: Refactor efi_memmap_init_early() into arch-neutral code
    
    Every EFI architecture apart from ia64 needs to setup the EFI memory
    map at efi.memmap, and the code for doing that is essentially the same
    across all implementations. Therefore, it makes sense to factor this
    out into the common code under drivers/firmware/efi/.
    
    The only slight variation is the data structure out of which we pull
    the initial memory map information, such as physical address, memory
    descriptor size and version, etc. We can address this by passing a
    generic data structure (struct efi_memory_map_data) as the argument to
    efi_memmap_init_early() which contains the minimum info required for
    initialising the memory map.
    
    In the process, this patch also fixes a few undesirable implementation
    differences:
    
     - ARM and arm64 were failing to clear the EFI_MEMMAP bit when
       unmapping the early EFI memory map. EFI_MEMMAP indicates whether
       the EFI memory map is mapped (not the regions contained within) and
       can be traversed.  It's more correct to set the bit as soon as we
       memremap() the passed in EFI memmap.
    
     - Rename efi_unmmap_memmap() to efi_memmap_unmap() to adhere to the
       regular naming scheme.
    
    This patch also uses a read-write mapping for the memory map instead
    of the read-only mapping currently used on ARM and arm64. x86 needs
    the ability to update the memory map in-place when assigning virtual
    addresses to regions (efi_map_region()) and tagging regions when
    reserving boot services (efi_reserve_boot_services()).
    
    There's no way for the generic fake_mem code to know which mapping to
    use without introducing some arch-specific constant/hook, so just use
    read-write since read-only is of dubious value for the EFI memory map.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 89d1146f5a6f..47b99108ff8e 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -287,7 +287,7 @@ void __init efi_free_boot_services(void)
 		free_bootmem_late(start, size);
 	}
 
-	efi_unmap_memmap();
+	efi_memmap_unmap();
 }
 
 /*
@@ -365,7 +365,7 @@ void __init efi_apply_memmap_quirks(void)
 	 */
 	if (!efi_runtime_supported()) {
 		pr_info("Setup done, disabling due to 32/64-bit mismatch\n");
-		efi_unmap_memmap();
+		efi_memmap_unmap();
 	}
 
 	/* UV2+ BIOS has a fix for this issue.  UV1 still needs the quirk. */

commit 5bc653b7318217c54244a14f248f1f07abe0a865
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Aug 10 02:29:17 2016 -0700

    x86/efi: Allocate a trampoline if needed in efi_free_boot_services()
    
    On my Dell XPS 13 9350 with firmware 1.4.4 and SGX on, if I boot
    Fedora 24's grub2-efi off a hard disk, my first 1MB of RAM looks
    like:
    
     efi: mem00: [Runtime Data       |RUN|  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000000000000-0x0000000000000fff] (0MB)
     efi: mem01: [Boot Data          |   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000000001000-0x0000000000027fff] (0MB)
     efi: mem02: [Loader Data        |   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000000028000-0x0000000000029fff] (0MB)
     efi: mem03: [Reserved           |   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x000000000002a000-0x000000000002bfff] (0MB)
     efi: mem04: [Runtime Data       |RUN|  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x000000000002c000-0x000000000002cfff] (0MB)
     efi: mem05: [Loader Data        |   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x000000000002d000-0x000000000002dfff] (0MB)
     efi: mem06: [Conventional Memory|   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x000000000002e000-0x0000000000057fff] (0MB)
     efi: mem07: [Reserved           |   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000000058000-0x0000000000058fff] (0MB)
     efi: mem08: [Conventional Memory|   |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000000059000-0x000000000009ffff] (0MB)
    
    My EBDA is at 0x2c000, which blocks off everything from 0x2c000 and
    up, and my trampoline is 0x6000 bytes (6 pages), so it doesn't fit
    in the loader data range at 0x28000.
    
    Without this patch, it panics due to a failure to allocate the
    trampoline.  With this patch, it works:
    
     [  +0.001744] Base memory trampoline at [ffff880000001000] 1000 size 24576
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mario Limonciello <mario_limonciello@dell.com>
    Cc: Matt Fleming <mfleming@suse.de>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/998c77b3bf709f3dfed85cb30701ed1a5d8a438b.1470821230.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 4480c06cade7..89d1146f5a6f 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -254,6 +254,7 @@ void __init efi_free_boot_services(void)
 	for_each_efi_memory_desc(md) {
 		unsigned long long start = md->phys_addr;
 		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
+		size_t rm_size;
 
 		if (md->type != EFI_BOOT_SERVICES_CODE &&
 		    md->type != EFI_BOOT_SERVICES_DATA)
@@ -263,6 +264,26 @@ void __init efi_free_boot_services(void)
 		if (md->attribute & EFI_MEMORY_RUNTIME)
 			continue;
 
+		/*
+		 * Nasty quirk: if all sub-1MB memory is used for boot
+		 * services, we can get here without having allocated the
+		 * real mode trampoline.  It's too late to hand boot services
+		 * memory back to the memblock allocator, so instead
+		 * try to manually allocate the trampoline if needed.
+		 *
+		 * I've seen this on a Dell XPS 13 9350 with firmware
+		 * 1.4.4 with SGX enabled booting Linux via Fedora 24's
+		 * grub2-efi on a hard disk.  (And no, I don't know why
+		 * this happened, but Linux should still try to boot rather
+		 * panicing early.)
+		 */
+		rm_size = real_mode_size_needed();
+		if (rm_size && (start + rm_size) < (1<<20) && size >= rm_size) {
+			set_real_mode_mem(start, rm_size);
+			start += rm_size;
+			size -= rm_size;
+		}
+
 		free_bootmem_late(start, size);
 	}
 

commit 46c13450624e36302547a2ac3695f2350fe7ffc3
Merge: d57d39431924 fc7239578014
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 16 19:41:41 2016 -0700

    Merge tag 'acpi-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "The new features here are ACPI 6.1 support (and some previously
      missing bits of ACPI 6.0 support) in ACPICA and two new drivers, a
      driver for the ACPI Generic Event Device (GED) feature introduced by
      ACPI 6.1 and the INT3406 thermal driver for display thermal
      management.  Also the value returned by the _HRV (hardware revision)
      ACPI object will be exported to user space via sysfs now.
    
      In addition to that, ACPI on ARM64 will not depend on EXPERT any more.
    
      The rest is mostly fixes and cleanups and some code reorganization.
    
      Specifics:
    
       - In-kernel ACPICA code update to the upstream release 20160422
         adding support for ACPI 6.1 along with some previously missing bits
         of ACPI 6.0 support, making a fair amount of fixes and cleanups and
         reducing divergences between the upstream ACPICA and the in-kernel
         code (Bob Moore, Lv Zheng, Al Stone, Aleksey Makarov, Will Miles)
    
       - ACPI Generic Event Device (GED) support and a fix for it (Sinan
         Kaya, Paul Gortmaker)
    
       - INT3406 thermal driver for display thermal management and ACPI
         backlight support code reorganization related to it (Aaron Lu, Arnd
         Bergmann)
    
       - Support for exporting the value returned by the _HRV (hardware
         revision) ACPI object via sysfs (Betty Dall)
    
       - Removal of the EXPERT dependency for ACPI on ARM64 (Mark Brown)
    
       - Rework of the handling of ACPI _OSI mechanism allowing the
         _OSI("Darwin") support to be overridden from the kernel command
         line among other things (Lv Zheng, Chen Yu)
    
       - Rework of the ACPI tables override mechanism to prepare it for the
         introduction of overlays support going forward (Lv Zheng, Rafael
         Wysocki)
    
       - Fixes related to the ECDT support and module-level execution of AML
         (Lv Zheng)
    
       - ACPI PCI interrupts management update to make it work better on
         ARM64 mostly (Sinan Kaya)
    
       - ACPI SRAT handling update to make the code process all entires in
         the table order regardless of the entry type (Lukasz Anaczkowski)
    
       - EFI power off support for full-hardware ACPI platforms that don't
         support ACPI S5 (Chen Yu)
    
       - Fixes and cleanups related to the ACPI core's sysfs interface (Dan
         Carpenter, Betty Dall)
    
       - acpi_dev_present() API rework to reduce possible confusion related
         to it (Lukas Wunner)
    
       - Removal of CLK_IS_ROOT from two ACPI drivers (Stephen Boyd)"
    
    * tag 'acpi-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (82 commits)
      ACPI / video: mark acpi_video_get_levels() inline
      Thermal / ACPI / video: add INT3406 thermal driver
      ACPI / GED: make evged.c explicitly non-modular
      ACPI / tables: Fix DSDT override mechanism
      ACPI / sysfs: fix error code in get_status()
      ACPICA: Update version to 20160422
      ACPICA: Move all ASCII utilities to a common file
      ACPICA: ACPI 2.0, Hardware: Add access_width/bit_offset support for acpi_hw_write()
      ACPICA: ACPI 2.0, Hardware: Add access_width/bit_offset support in acpi_hw_read()
      ACPICA: Executer: Introduce a set of macros to handle bit width mask generation
      ACPICA: Hardware: Add optimized access bit width support
      ACPICA: Utilities: Add ACPI_IS_ALIGNED() macro
      ACPICA: Renamed some #defined flag constants for clarity
      ACPICA: ACPI 6.0, tools/iasl: Add support for new resource descriptors
      ACPICA: ACPI 6.0: Update _BIX support for new package element
      ACPICA: ACPI 6.1: Support for new PCCT subtable
      ACPICA: Refactor evaluate_object to reduce nesting
      ACPICA: Divergence: remove unwanted spaces for typedef
      ACPI,PCI,IRQ: remove SCI penalize function
      ACPI,PCI,IRQ: remove redundant code in acpi_irq_penalty_init()
      ..

commit 78ce248faa3c46e24e9bd42db3ab3650659f16dd
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:38 2016 +0100

    efi: Iterate over efi.memmap in for_each_efi_memory_desc()
    
    Most of the users of for_each_efi_memory_desc() are equally happy
    iterating over the EFI memory map in efi.memmap instead of 'memmap',
    since the former is usually a pointer to the latter.
    
    For those users that want to specify an EFI memory map other than
    efi.memmap, that can be done using for_each_efi_memory_desc_in_map().
    One such example is in the libstub code where the firmware is queried
    directly for the memory map, it gets iterated over, and then freed.
    
    This change goes part of the way toward deleting the global 'memmap'
    variable, which is not universally available on all architectures
    (notably IA64) and is rather poorly named.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-7-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index ab50ada1d56e..097cb09d917b 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -195,10 +195,9 @@ static bool can_free_region(u64 start, u64 size)
 */
 void __init efi_reserve_boot_services(void)
 {
-	void *p;
+	efi_memory_desc_t *md;
 
-	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
-		efi_memory_desc_t *md = p;
+	for_each_efi_memory_desc(md) {
 		u64 start = md->phys_addr;
 		u64 size = md->num_pages << EFI_PAGE_SHIFT;
 		bool already_reserved;
@@ -250,10 +249,9 @@ void __init efi_reserve_boot_services(void)
 
 void __init efi_free_boot_services(void)
 {
-	void *p;
+	efi_memory_desc_t *md;
 
-	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
-		efi_memory_desc_t *md = p;
+	for_each_efi_memory_desc(md) {
 		unsigned long long start = md->phys_addr;
 		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
 

commit 1373718194ebebc43c00d8f117e03885749495b0
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Mar 22 08:51:10 2016 +0800

    ACPI / PM: Introduce efi poweroff for HW-full platforms without _S5
    
    The problem is Linux registers pm_power_off = efi_power_off only if
    we are in hardware reduced mode. Actually, what we also want is to do
    this when ACPI S5 is simply not supported on non-legacy platforms.
    Since some future Intel platforms are HW-full mode where the DSDT
    fails to supply an _S5 object(without SLP_TYP), we should let such
    kind of platform to leverage efi runtime service to poweroff.
    
    This patch uses efi power off as first choice when S5 is unavailable,
    even if there is a customized poweroff(driver provided, eg).
    Meanwhile, the legacy platforms will not be affected because there is
    no path for them to overwrite the pm_power_off to efi power off.
    
    Suggested-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index ab50ada1d56e..818d12ad7761 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -373,5 +373,5 @@ bool efi_reboot_required(void)
 
 bool efi_poweroff_required(void)
 {
-	return !!acpi_gbl_reduced_hardware;
+	return acpi_gbl_reduced_hardware || acpi_no_s5;
 }

commit 24b5e20f11a75866bbffc46c30a22fa50612a769
Merge: 26660a4046b1 d367cef0a7f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 20 18:58:18 2016 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes are:
    
       - Use separate EFI page tables when executing EFI firmware code.
         This isolates the EFI context from the rest of the kernel, which
         has security and general robustness advantages.  (Matt Fleming)
    
       - Run regular UEFI firmware with interrupts enabled.  This is already
         the status quo under other OSs.  (Ard Biesheuvel)
    
       - Various x86 EFI enhancements, such as the use of non-executable
         attributes for EFI memory mappings.  (Sai Praneeth Prakhya)
    
       - Various arm64 UEFI enhancements.  (Ard Biesheuvel)
    
       - ... various fixes and cleanups.
    
      The separate EFI page tables feature got delayed twice already,
      because it's an intrusive change and we didn't feel confident about
      it - third time's the charm we hope!"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU
      x86/efi: Only map kernel text for EFI mixed mode
      x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
      x86/mm/pat: Don't implicitly allow _PAGE_RW in kernel_map_pages_in_pgd()
      efi/arm*: Perform hardware compatibility check
      efi/arm64: Check for h/w support before booting a >4 KB granular kernel
      efi/arm: Check for LPAE support before booting a LPAE kernel
      efi/arm-init: Use read-only early mappings
      efi/efistub: Prevent __init annotations from being used
      arm64/vmlinux.lds.S: Handle .init.rodata.xxx and .init.bss sections
      efi/arm64: Drop __init annotation from handle_kernel_image()
      x86/mm/pat: Use _PAGE_GLOBAL bit for EFI page table mappings
      efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled
      efi: Reformat GUID tables to follow the format in UEFI spec
      efi: Add Persistent Memory type name
      efi: Add NV memory attribute
      x86/efi: Show actual ending addresses in efi_print_memmap
      x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0
      efivars: Use to_efivar_entry
      efi: Runtime-wrapper: Get rid of the rtc_lock spinlock
      ...

commit 452308de61056a539352a9306c46716d7af8a1f1
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Mar 11 11:19:23 2016 +0000

    x86/efi: Fix boot crash by always mapping boot service regions into new EFI page tables
    
    Some machines have EFI regions in page zero (physical address
    0x00000000) and historically that region has been added to the e820
    map via trim_bios_range(), and ultimately mapped into the kernel page
    tables. It was not mapped via efi_map_regions() as one would expect.
    
    Alexis reports that with the new separate EFI page tables some boot
    services regions, such as page zero, are not mapped. This triggers an
    oops during the SetVirtualAddressMap() runtime call.
    
    For the EFI boot services quirk on x86 we need to memblock_reserve()
    boot services regions until after SetVirtualAddressMap(). Doing that
    while respecting the ownership of regions that may have already been
    reserved by the kernel was the motivation behind this commit:
    
      7d68dc3f1003 ("x86, efi: Do not reserve boot services regions within reserved areas")
    
    That patch was merged at a time when the EFI runtime virtual mappings
    were inserted into the kernel page tables as described above, and the
    trick of setting ->numpages (and hence the region size) to zero to
    track regions that should not be freed in efi_free_boot_services()
    meant that we never mapped those regions in efi_map_regions(). Instead
    we were relying solely on the existing kernel mappings.
    
    Now that we have separate page tables we need to make sure the EFI
    boot services regions are mapped correctly, even if someone else has
    already called memblock_reserve(). Instead of stashing a tag in
    ->numpages, set the EFI_MEMORY_RUNTIME bit of ->attribute. Since it
    generally makes no sense to mark a boot services region as required at
    runtime, it's pretty much guaranteed the firmware will not have
    already set this bit.
    
    For the record, the specific circumstances under which Alexis
    triggered this bug was that an EFI runtime driver on his machine was
    responding to the EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE event during
    SetVirtualAddressMap().
    
    The event handler for this driver looks like this,
    
      sub rsp,0x28
      lea rdx,[rip+0x2445] # 0xaa948720
      mov ecx,0x4
      call func_aa9447c0  ; call to ConvertPointer(4, & 0xaa948720)
      mov r11,QWORD PTR [rip+0x2434] # 0xaa948720
      xor eax,eax
      mov BYTE PTR [r11+0x1],0x1
      add rsp,0x28
      ret
    
    Which is pretty typical code for an EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE
    handler. The "mov r11, QWORD PTR [rip+0x2424]" was the faulting
    instruction because ConvertPointer() was being called to convert the
    address 0x0000000000000000, which when converted is left unchanged and
    remains 0x0000000000000000.
    
    The output of the oops trace gave the impression of a standard NULL
    pointer dereference bug, but because we're accessing physical
    addresses during ConvertPointer(), it wasn't. EFI boot services code
    is stored at that address on Alexis' machine.
    
    Reported-by: Alexis Murzeau <amurzeau@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@canonical.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Raphael Hertzog <hertzog@debian.org>
    Cc: Roger Shimizu <rogershimizu@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1457695163-29632-2-git-send-email-matt@codeblueprint.co.uk
    Link: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=815125
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 2d66db8f80f9..ed30e79347e8 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -130,6 +130,27 @@ efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
 }
 EXPORT_SYMBOL_GPL(efi_query_variable_store);
 
+/*
+ * Helper function for efi_reserve_boot_services() to figure out if we
+ * can free regions in efi_free_boot_services().
+ *
+ * Use this function to ensure we do not free regions owned by somebody
+ * else. We must only reserve (and then free) regions:
+ *
+ * - Not within any part of the kernel
+ * - Not the BIOS reserved area (E820_RESERVED, E820_NVS, etc)
+ */
+static bool can_free_region(u64 start, u64 size)
+{
+	if (start + size > __pa_symbol(_text) && start <= __pa_symbol(_end))
+		return false;
+
+	if (!e820_all_mapped(start, start+size, E820_RAM))
+		return false;
+
+	return true;
+}
+
 /*
  * The UEFI specification makes it clear that the operating system is free to do
  * whatever it wants with boot services code after ExitBootServices() has been
@@ -147,26 +168,50 @@ void __init efi_reserve_boot_services(void)
 		efi_memory_desc_t *md = p;
 		u64 start = md->phys_addr;
 		u64 size = md->num_pages << EFI_PAGE_SHIFT;
+		bool already_reserved;
 
 		if (md->type != EFI_BOOT_SERVICES_CODE &&
 		    md->type != EFI_BOOT_SERVICES_DATA)
 			continue;
-		/* Only reserve where possible:
-		 * - Not within any already allocated areas
-		 * - Not over any memory area (really needed, if above?)
-		 * - Not within any part of the kernel
-		 * - Not the bios reserved area
-		*/
-		if ((start + size > __pa_symbol(_text)
-				&& start <= __pa_symbol(_end)) ||
-			!e820_all_mapped(start, start+size, E820_RAM) ||
-			memblock_is_region_reserved(start, size)) {
-			/* Could not reserve, skip it */
-			md->num_pages = 0;
-			memblock_dbg("Could not reserve boot range [0x%010llx-0x%010llx]\n",
-				     start, start+size-1);
-		} else
+
+		already_reserved = memblock_is_region_reserved(start, size);
+
+		/*
+		 * Because the following memblock_reserve() is paired
+		 * with free_bootmem_late() for this region in
+		 * efi_free_boot_services(), we must be extremely
+		 * careful not to reserve, and subsequently free,
+		 * critical regions of memory (like the kernel image) or
+		 * those regions that somebody else has already
+		 * reserved.
+		 *
+		 * A good example of a critical region that must not be
+		 * freed is page zero (first 4Kb of memory), which may
+		 * contain boot services code/data but is marked
+		 * E820_RESERVED by trim_bios_range().
+		 */
+		if (!already_reserved) {
 			memblock_reserve(start, size);
+
+			/*
+			 * If we are the first to reserve the region, no
+			 * one else cares about it. We own it and can
+			 * free it later.
+			 */
+			if (can_free_region(start, size))
+				continue;
+		}
+
+		/*
+		 * We don't own the region. We must not free it.
+		 *
+		 * Setting this bit for a boot services region really
+		 * doesn't make sense as far as the firmware is
+		 * concerned, but it does provide us with a way to tag
+		 * those regions that must not be paired with
+		 * free_bootmem_late().
+		 */
+		md->attribute |= EFI_MEMORY_RUNTIME;
 	}
 }
 
@@ -183,8 +228,8 @@ void __init efi_free_boot_services(void)
 		    md->type != EFI_BOOT_SERVICES_DATA)
 			continue;
 
-		/* Could not reserve boot area */
-		if (!size)
+		/* Do not free, someone else owns it: */
+		if (md->attribute & EFI_MEMORY_RUNTIME)
 			continue;
 
 		free_bootmem_late(start, size);

commit ca0e30dcaa53a3fcb2dfdf74252d30bc40603eea
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 1 22:06:58 2016 +0000

    efi: Add nonblocking option to efi_query_variable_store()
    
    The function efi_query_variable_store() may be invoked by
    efivar_entry_set_nonblocking(), which itself takes care to only
    call a non-blocking version of the SetVariable() runtime
    wrapper. However, efi_query_variable_store() may call the
    SetVariable() wrapper directly, as well as the wrapper for
    QueryVariableInfo(), both of which could deadlock in the same
    way we are trying to prevent by calling
    efivar_entry_set_nonblocking() in the first place.
    
    So instead, modify efi_query_variable_store() to use the
    non-blocking variants of QueryVariableInfo() (and give up rather
    than free up space if the available space is below
    EFI_MIN_RESERVE) if invoked with the 'nonblocking' argument set
    to true.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 453504662a33..2326bf51978f 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -56,6 +56,33 @@ void efi_delete_dummy_variable(void)
 			 0, NULL);
 }
 
+/*
+ * In the nonblocking case we do not attempt to perform garbage
+ * collection if we do not have enough free space. Rather, we do the
+ * bare minimum check and give up immediately if the available space
+ * is below EFI_MIN_RESERVE.
+ *
+ * This function is intended to be small and simple because it is
+ * invoked from crash handler paths.
+ */
+static efi_status_t
+query_variable_store_nonblocking(u32 attributes, unsigned long size)
+{
+	efi_status_t status;
+	u64 storage_size, remaining_size, max_size;
+
+	status = efi.query_variable_info_nonblocking(attributes, &storage_size,
+						     &remaining_size,
+						     &max_size);
+	if (status != EFI_SUCCESS)
+		return status;
+
+	if (remaining_size - size < EFI_MIN_RESERVE)
+		return EFI_OUT_OF_RESOURCES;
+
+	return EFI_SUCCESS;
+}
+
 /*
  * Some firmware implementations refuse to boot if there's insufficient space
  * in the variable store. Ensure that we never use more than a safe limit.
@@ -63,7 +90,8 @@ void efi_delete_dummy_variable(void)
  * Return EFI_SUCCESS if it is safe to write 'size' bytes to the variable
  * store.
  */
-efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
+efi_status_t efi_query_variable_store(u32 attributes, unsigned long size,
+				      bool nonblocking)
 {
 	efi_status_t status;
 	u64 storage_size, remaining_size, max_size;
@@ -71,6 +99,9 @@ efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
 	if (!(attributes & EFI_VARIABLE_NON_VOLATILE))
 		return 0;
 
+	if (nonblocking)
+		return query_variable_store_nonblocking(attributes, size);
+
 	status = efi.query_variable_info(attributes, &storage_size,
 					 &remaining_size, &max_size);
 	if (status != EFI_SUCCESS)

commit 03e075b38e6cd25267c8d6e2797fa4537ca3348d
Merge: 753b11ef8e92 34229b277480
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 3 11:30:36 2016 +0100

    Merge branch 'linus' into efi/core, to refresh the branch and to pick up recent fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit d394f2d9d8e1e7b4959819344baf67b5995da9b0
Author: Alex Thorlton <athorlton@sgi.com>
Date:   Fri Dec 11 14:59:45 2015 -0600

    x86/platform/UV: Remove EFI memmap quirk for UV2+
    
    Commit a5d90c923bcf ("x86/efi: Quirk out SGI UV") added a quirk
    to efi_apply_memmap_quirks to force SGI UV systems to fall back
    to the old EFI memmap mechanism.  We have a BIOS fix for this
    issue on all systems except for UV1.  This commit fixes up the
    EFI quirk/MMR mapping code so that we only apply the special
    case to UV1 hardware.
    
    Signed-off-by: Alex Thorlton <athorlton@sgi.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hedi Berriche <hedi@sgi.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Travis <travis@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1449867585-189233-2-git-send-email-athorlton@sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 1c7380da65ff..2d66db8f80f9 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -8,6 +8,7 @@
 #include <linux/memblock.h>
 #include <linux/bootmem.h>
 #include <linux/acpi.h>
+#include <linux/dmi.h>
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
 
@@ -248,6 +249,16 @@ int __init efi_reuse_config(u64 tables, int nr_tables)
 	return ret;
 }
 
+static const struct dmi_system_id sgi_uv1_dmi[] = {
+	{ NULL, "SGI UV1",
+		{	DMI_MATCH(DMI_PRODUCT_NAME,	"Stoutland Platform"),
+			DMI_MATCH(DMI_PRODUCT_VERSION,	"1.0"),
+			DMI_MATCH(DMI_BIOS_VENDOR,	"SGI.COM"),
+		}
+	},
+	{ } /* NULL entry stops DMI scanning */
+};
+
 void __init efi_apply_memmap_quirks(void)
 {
 	/*
@@ -260,10 +271,8 @@ void __init efi_apply_memmap_quirks(void)
 		efi_unmap_memmap();
 	}
 
-	/*
-	 * UV doesn't support the new EFI pagetable mapping yet.
-	 */
-	if (is_uv_system())
+	/* UV2+ BIOS has a fix for this issue.  UV1 still needs the quirk. */
+	if (dmi_check_system(sgi_uv1_dmi))
 		set_bit(EFI_OLD_MEMMAP, &efi.flags);
 }
 

commit 26d7f65fbd22168c33d2350f3e7e3021f5761256
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Sun Oct 25 10:26:35 2015 +0000

    x86/efi: Preface all print statements with efi* tag
    
    The pr_*() calls in the x86 EFI code may or may not include a
    subsystem tag, which makes it difficult to grep the kernel log for all
    relevant EFI messages and leads users to miss important information.
    
    Recently, a bug reporter provided all the EFI print messages from the
    kernel log when trying to diagnose an issue but missed the following
    statement because it wasn't prefixed with anything indicating it was
    related to EFI,
    
      pr_err("Error ident-mapping new memmap (0x%lx)!\n", pa_memmap);
    
    Cc: Borislav Petkov <bp@suse.de>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 1c7380da65ff..6452070f3025 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -1,3 +1,5 @@
+#define pr_fmt(fmt) "efi: " fmt
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -256,7 +258,7 @@ void __init efi_apply_memmap_quirks(void)
 	 * services.
 	 */
 	if (!efi_runtime_supported()) {
-		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
+		pr_info("Setup done, disabling due to 32/64-bit mismatch\n");
 		efi_unmap_memmap();
 	}
 

commit 44be28e9dd9880dca3e2cbf7a844f2114e67f2cb
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jun 13 12:39:55 2014 +0100

    x86/reboot: Add EFI reboot quirk for ACPI Hardware Reduced flag
    
    It appears that the BayTrail-T class of hardware requires EFI in order
    to powerdown and reboot and no other reliable method exists.
    
    This quirk is generally applicable to all hardware that has the ACPI
    Hardware Reduced bit set, since usually ACPI would be the preferred
    method.
    
    Cc: Len Brown <len.brown@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index b4cb9182f155..1c7380da65ff 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -7,6 +7,7 @@
 #include <linux/slab.h>
 #include <linux/memblock.h>
 #include <linux/bootmem.h>
+#include <linux/acpi.h>
 #include <asm/efi.h>
 #include <asm/uv/uv.h>
 
@@ -265,3 +266,25 @@ void __init efi_apply_memmap_quirks(void)
 	if (is_uv_system())
 		set_bit(EFI_OLD_MEMMAP, &efi.flags);
 }
+
+/*
+ * For most modern platforms the preferred method of powering off is via
+ * ACPI. However, there are some that are known to require the use of
+ * EFI runtime services and for which ACPI does not work at all.
+ *
+ * Using EFI is a last resort, to be used only if no other option
+ * exists.
+ */
+bool efi_reboot_required(void)
+{
+	if (!acpi_gbl_reduced_hardware)
+		return false;
+
+	efi_reboot_quirk_mode = EFI_RESET_WARM;
+	return true;
+}
+
+bool efi_poweroff_required(void)
+{
+	return !!acpi_gbl_reduced_hardware;
+}

commit 98a716b66cab993e15001c7ec06f637ca6f1079b
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Mon Jun 9 13:41:26 2014 +0100

    x86/efi: Use early_memunmap() to squelch sparse errors
    
    The kbuild reports the following sparse errors,
    
    >> arch/x86/platform/efi/quirks.c:242:23: sparse: incorrect type in >> argument 1 (different address spaces)
       arch/x86/platform/efi/quirks.c:242:23:    expected void [noderef] <asn:2>*addr
       arch/x86/platform/efi/quirks.c:242:23:    got void *[assigned] tablep
    >> arch/x86/platform/efi/quirks.c:245:23: sparse: incorrect type in >> argument 1 (different address spaces)
       arch/x86/platform/efi/quirks.c:245:23:    expected void [noderef] <asn:2>*addr
       arch/x86/platform/efi/quirks.c:245:23:    got struct efi_setup_data *[assigned] data
    
    Dave Young had made previous attempts to convert the early_iounmap()
    calls to early_memunmap() but ran into merge conflicts with commit
    9e5c33d7aeee ("mm: create generic early_ioremap() support").
    
    Now that we've got that commit in place we can switch to using
    early_memunmap() since we're already using early_memremap() in
    efi_reuse_config().
    
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Saurabh Tangri <saurabh.tangri@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 7e3099c610dd..b4cb9182f155 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -239,10 +239,10 @@ int __init efi_reuse_config(u64 tables, int nr_tables)
 			((efi_config_table_64_t *)p)->table = data->smbios;
 		p += sz;
 	}
-	early_iounmap(tablep, nr_tables * sz);
+	early_memunmap(tablep, nr_tables * sz);
 
 out_memremap:
-	early_iounmap(data, sizeof(*data));
+	early_memunmap(data, sizeof(*data));
 out:
 	return ret;
 }

commit eeb9db09f738993c63ecb5aedf950a1e4fe4bd3f
Author: Saurabh Tangri <saurabh.tangri@intel.com>
Date:   Mon Jun 2 05:18:35 2014 -0700

    x86/efi: Move all workarounds to a separate file quirks.c
    
    Currently, it's difficult to find all the workarounds that are
    applied when running on EFI, because they're littered throughout
    various code paths. This change moves all of them into a separate
    file with the hope that it will be come the single location for all
    our well documented quirks.
    
    Signed-off-by: Saurabh Tangri <saurabh.tangri@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
new file mode 100644
index 000000000000..7e3099c610dd
--- /dev/null
+++ b/arch/x86/platform/efi/quirks.c
@@ -0,0 +1,267 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/types.h>
+#include <linux/efi.h>
+#include <linux/slab.h>
+#include <linux/memblock.h>
+#include <linux/bootmem.h>
+#include <asm/efi.h>
+#include <asm/uv/uv.h>
+
+#define EFI_MIN_RESERVE 5120
+
+#define EFI_DUMMY_GUID \
+	EFI_GUID(0x4424ac57, 0xbe4b, 0x47dd, 0x9e, 0x97, 0xed, 0x50, 0xf0, 0x9f, 0x92, 0xa9)
+
+static efi_char16_t efi_dummy_name[6] = { 'D', 'U', 'M', 'M', 'Y', 0 };
+
+static bool efi_no_storage_paranoia;
+
+/*
+ * Some firmware implementations refuse to boot if there's insufficient
+ * space in the variable store. The implementation of garbage collection
+ * in some FW versions causes stale (deleted) variables to take up space
+ * longer than intended and space is only freed once the store becomes
+ * almost completely full.
+ *
+ * Enabling this option disables the space checks in
+ * efi_query_variable_store() and forces garbage collection.
+ *
+ * Only enable this option if deleting EFI variables does not free up
+ * space in your variable store, e.g. if despite deleting variables
+ * you're unable to create new ones.
+ */
+static int __init setup_storage_paranoia(char *arg)
+{
+	efi_no_storage_paranoia = true;
+	return 0;
+}
+early_param("efi_no_storage_paranoia", setup_storage_paranoia);
+
+/*
+ * Deleting the dummy variable which kicks off garbage collection
+*/
+void efi_delete_dummy_variable(void)
+{
+	efi.set_variable(efi_dummy_name, &EFI_DUMMY_GUID,
+			 EFI_VARIABLE_NON_VOLATILE |
+			 EFI_VARIABLE_BOOTSERVICE_ACCESS |
+			 EFI_VARIABLE_RUNTIME_ACCESS,
+			 0, NULL);
+}
+
+/*
+ * Some firmware implementations refuse to boot if there's insufficient space
+ * in the variable store. Ensure that we never use more than a safe limit.
+ *
+ * Return EFI_SUCCESS if it is safe to write 'size' bytes to the variable
+ * store.
+ */
+efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
+{
+	efi_status_t status;
+	u64 storage_size, remaining_size, max_size;
+
+	if (!(attributes & EFI_VARIABLE_NON_VOLATILE))
+		return 0;
+
+	status = efi.query_variable_info(attributes, &storage_size,
+					 &remaining_size, &max_size);
+	if (status != EFI_SUCCESS)
+		return status;
+
+	/*
+	 * We account for that by refusing the write if permitting it would
+	 * reduce the available space to under 5KB. This figure was provided by
+	 * Samsung, so should be safe.
+	 */
+	if ((remaining_size - size < EFI_MIN_RESERVE) &&
+		!efi_no_storage_paranoia) {
+
+		/*
+		 * Triggering garbage collection may require that the firmware
+		 * generate a real EFI_OUT_OF_RESOURCES error. We can force
+		 * that by attempting to use more space than is available.
+		 */
+		unsigned long dummy_size = remaining_size + 1024;
+		void *dummy = kzalloc(dummy_size, GFP_ATOMIC);
+
+		if (!dummy)
+			return EFI_OUT_OF_RESOURCES;
+
+		status = efi.set_variable(efi_dummy_name, &EFI_DUMMY_GUID,
+					  EFI_VARIABLE_NON_VOLATILE |
+					  EFI_VARIABLE_BOOTSERVICE_ACCESS |
+					  EFI_VARIABLE_RUNTIME_ACCESS,
+					  dummy_size, dummy);
+
+		if (status == EFI_SUCCESS) {
+			/*
+			 * This should have failed, so if it didn't make sure
+			 * that we delete it...
+			 */
+			efi_delete_dummy_variable();
+		}
+
+		kfree(dummy);
+
+		/*
+		 * The runtime code may now have triggered a garbage collection
+		 * run, so check the variable info again
+		 */
+		status = efi.query_variable_info(attributes, &storage_size,
+						 &remaining_size, &max_size);
+
+		if (status != EFI_SUCCESS)
+			return status;
+
+		/*
+		 * There still isn't enough room, so return an error
+		 */
+		if (remaining_size - size < EFI_MIN_RESERVE)
+			return EFI_OUT_OF_RESOURCES;
+	}
+
+	return EFI_SUCCESS;
+}
+EXPORT_SYMBOL_GPL(efi_query_variable_store);
+
+/*
+ * The UEFI specification makes it clear that the operating system is free to do
+ * whatever it wants with boot services code after ExitBootServices() has been
+ * called. Ignoring this recommendation a significant bunch of EFI implementations 
+ * continue calling into boot services code (SetVirtualAddressMap). In order to 
+ * work around such buggy implementations we reserve boot services region during 
+ * EFI init and make sure it stays executable. Then, after SetVirtualAddressMap(), it
+* is discarded.
+*/
+void __init efi_reserve_boot_services(void)
+{
+	void *p;
+
+	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+		efi_memory_desc_t *md = p;
+		u64 start = md->phys_addr;
+		u64 size = md->num_pages << EFI_PAGE_SHIFT;
+
+		if (md->type != EFI_BOOT_SERVICES_CODE &&
+		    md->type != EFI_BOOT_SERVICES_DATA)
+			continue;
+		/* Only reserve where possible:
+		 * - Not within any already allocated areas
+		 * - Not over any memory area (really needed, if above?)
+		 * - Not within any part of the kernel
+		 * - Not the bios reserved area
+		*/
+		if ((start + size > __pa_symbol(_text)
+				&& start <= __pa_symbol(_end)) ||
+			!e820_all_mapped(start, start+size, E820_RAM) ||
+			memblock_is_region_reserved(start, size)) {
+			/* Could not reserve, skip it */
+			md->num_pages = 0;
+			memblock_dbg("Could not reserve boot range [0x%010llx-0x%010llx]\n",
+				     start, start+size-1);
+		} else
+			memblock_reserve(start, size);
+	}
+}
+
+void __init efi_free_boot_services(void)
+{
+	void *p;
+
+	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+		efi_memory_desc_t *md = p;
+		unsigned long long start = md->phys_addr;
+		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
+
+		if (md->type != EFI_BOOT_SERVICES_CODE &&
+		    md->type != EFI_BOOT_SERVICES_DATA)
+			continue;
+
+		/* Could not reserve boot area */
+		if (!size)
+			continue;
+
+		free_bootmem_late(start, size);
+	}
+
+	efi_unmap_memmap();
+}
+
+/*
+ * A number of config table entries get remapped to virtual addresses
+ * after entering EFI virtual mode. However, the kexec kernel requires
+ * their physical addresses therefore we pass them via setup_data and
+ * correct those entries to their respective physical addresses here.
+ *
+ * Currently only handles smbios which is necessary for some firmware
+ * implementation.
+ */
+int __init efi_reuse_config(u64 tables, int nr_tables)
+{
+	int i, sz, ret = 0;
+	void *p, *tablep;
+	struct efi_setup_data *data;
+
+	if (!efi_setup)
+		return 0;
+
+	if (!efi_enabled(EFI_64BIT))
+		return 0;
+
+	data = early_memremap(efi_setup, sizeof(*data));
+	if (!data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (!data->smbios)
+		goto out_memremap;
+
+	sz = sizeof(efi_config_table_64_t);
+
+	p = tablep = early_memremap(tables, nr_tables * sz);
+	if (!p) {
+		pr_err("Could not map Configuration table!\n");
+		ret = -ENOMEM;
+		goto out_memremap;
+	}
+
+	for (i = 0; i < efi.systab->nr_tables; i++) {
+		efi_guid_t guid;
+
+		guid = ((efi_config_table_64_t *)p)->guid;
+
+		if (!efi_guidcmp(guid, SMBIOS_TABLE_GUID))
+			((efi_config_table_64_t *)p)->table = data->smbios;
+		p += sz;
+	}
+	early_iounmap(tablep, nr_tables * sz);
+
+out_memremap:
+	early_iounmap(data, sizeof(*data));
+out:
+	return ret;
+}
+
+void __init efi_apply_memmap_quirks(void)
+{
+	/*
+	 * Once setup is done earlier, unmap the EFI memory map on mismatched
+	 * firmware/kernel architectures since there is no support for runtime
+	 * services.
+	 */
+	if (!efi_runtime_supported()) {
+		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
+		efi_unmap_memmap();
+	}
+
+	/*
+	 * UV doesn't support the new EFI pagetable mapping yet.
+	 */
+	if (is_uv_system())
+		set_bit(EFI_OLD_MEMMAP, &efi.flags);
+}
