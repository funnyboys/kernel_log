commit dcfce4a095932e6e95d83ad982be3609947963bc
Author: Robert Richter <robert.richter@amd.com>
Date:   Tue Oct 11 17:11:08 2011 +0200

    oprofile, x86: Reimplement nmi timer mode using perf event
    
    The legacy x86 nmi watchdog code was removed with the implementation
    of the perf based nmi watchdog. This broke Oprofile's nmi timer
    mode. To run nmi timer mode we relied on a continuous ticking nmi
    source which the nmi watchdog provided. The nmi tick was no longer
    available and current watchdog can not be used anymore since it runs
    with very long periods in the range of seconds. This patch
    reimplements the nmi timer mode using a perf counter nmi source.
    
    V2:
    * removing pr_info()
    * fix undefined reference to `__udivdi3' for 32 bit build
    * fix section mismatch of .cpuinit.data:nmi_timer_cpu_nb
    * removed nmi timer setup in arch/x86
    * implemented function stubs for op_nmi_init/exit()
    * made code more readable in oprofile_init()
    
    V3:
    * fix architectural initialization in oprofile_init()
    * fix CONFIG_OPROFILE_NMI_TIMER dependencies
    
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/x86/oprofile/init.c b/arch/x86/oprofile/init.c
index f148cf652678..9e138d00ad36 100644
--- a/arch/x86/oprofile/init.c
+++ b/arch/x86/oprofile/init.c
@@ -16,37 +16,23 @@
  * with the NMI mode driver.
  */
 
+#ifdef CONFIG_X86_LOCAL_APIC
 extern int op_nmi_init(struct oprofile_operations *ops);
-extern int op_nmi_timer_init(struct oprofile_operations *ops);
 extern void op_nmi_exit(void);
-extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
+#else
+static int op_nmi_init(struct oprofile_operations *ops) { return -ENODEV; }
+static void op_nmi_exit(void) { }
+#endif
 
-static int nmi_timer;
+extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	int ret;
-
-	ret = -ENODEV;
-
-#ifdef CONFIG_X86_LOCAL_APIC
-	ret = op_nmi_init(ops);
-#endif
-	nmi_timer = (ret != 0);
-#ifdef CONFIG_X86_IO_APIC
-	if (nmi_timer)
-		ret = op_nmi_timer_init(ops);
-#endif
 	ops->backtrace = x86_backtrace;
-
-	return ret;
+	return op_nmi_init(ops);
 }
 
-
 void oprofile_arch_exit(void)
 {
-#ifdef CONFIG_X86_LOCAL_APIC
-	if (!nmi_timer)
-		op_nmi_exit();
-#endif
+	op_nmi_exit();
 }

commit 97f7f8189fe54e3cfe324ef9ad35064f3d2d3bff
Author: Robert Richter <robert.richter@amd.com>
Date:   Mon Oct 10 16:21:10 2011 +0200

    oprofile, x86: Fix crash when unloading module (nmi timer mode)
    
    If oprofile uses the nmi timer interrupt there is a crash while
    unloading the module. The bug can be triggered with oprofile build as
    module and kernel parameter nolapic set. This patch fixes this.
    
    oprofile: using NMI timer interrupt.
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000008
    IP: [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
    PGD 42dbca067 PUD 41da6a067 PMD 0
    Oops: 0002 [#1] PREEMPT SMP
    CPU 5
    Modules linked in: oprofile(-) [last unloaded: oprofile]
    
    Pid: 2518, comm: modprobe Not tainted 3.1.0-rc7-00019-gb2fb49d #19 Advanced Micro Device Anaheim/Anaheim
    RIP: 0010:[<ffffffff8123c226>]  [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
    RSP: 0018:ffff88041ef71e98  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: ffffffffa0017100 RCX: dead000000200200
    RDX: 0000000000000000 RSI: dead000000100100 RDI: ffffffff8178c620
    RBP: ffff88041ef71ea8 R08: 0000000000000001 R09: 0000000000000082
    R10: 0000000000000000 R11: ffff88041ef71de8 R12: 0000000000000080
    R13: fffffffffffffff5 R14: 0000000000000001 R15: 0000000000610210
    FS:  00007fc902f20700(0000) GS:ffff88042fd40000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000008 CR3: 000000041cdb6000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process modprobe (pid: 2518, threadinfo ffff88041ef70000, task ffff88041d348040)
    Stack:
     ffff88041ef71eb8 ffffffffa0017790 ffff88041ef71eb8 ffffffffa0013532
     ffff88041ef71ec8 ffffffffa00132d6 ffff88041ef71ed8 ffffffffa00159b2
     ffff88041ef71f78 ffffffff81073115 656c69666f72706f 0000000000610200
    Call Trace:
     [<ffffffffa0013532>] op_nmi_exit+0x15/0x17 [oprofile]
     [<ffffffffa00132d6>] oprofile_arch_exit+0xe/0x10 [oprofile]
     [<ffffffffa00159b2>] oprofile_exit+0x1e/0x20 [oprofile]
     [<ffffffff81073115>] sys_delete_module+0x1c3/0x22f
     [<ffffffff811bf09e>] ? trace_hardirqs_on_thunk+0x3a/0x3f
     [<ffffffff8148070b>] system_call_fastpath+0x16/0x1b
    Code: 20 c6 78 81 e8 c5 cc 23 00 48 8b 13 48 8b 43 08 48 be 00 01 10 00 00 00 ad de 48 b9 00 02 20 00 00 00 ad de 48 c7 c7 20 c6 78 81
     89 42 08 48 89 10 48 89 33 48 89 4b 08 e8 a6 c0 23 00 5a 5b
    RIP  [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
     RSP <ffff88041ef71e98>
    CR2: 0000000000000008
    ---[ end trace 43a541a52956b7b0 ]---
    
    CC: stable@kernel.org # 2.6.37+
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/x86/oprofile/init.c b/arch/x86/oprofile/init.c
index cdfe4c54deca..f148cf652678 100644
--- a/arch/x86/oprofile/init.c
+++ b/arch/x86/oprofile/init.c
@@ -21,6 +21,7 @@ extern int op_nmi_timer_init(struct oprofile_operations *ops);
 extern void op_nmi_exit(void);
 extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
 
+static int nmi_timer;
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
@@ -31,8 +32,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 #ifdef CONFIG_X86_LOCAL_APIC
 	ret = op_nmi_init(ops);
 #endif
+	nmi_timer = (ret != 0);
 #ifdef CONFIG_X86_IO_APIC
-	if (ret < 0)
+	if (nmi_timer)
 		ret = op_nmi_timer_init(ops);
 #endif
 	ops->backtrace = x86_backtrace;
@@ -44,6 +46,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 void oprofile_arch_exit(void)
 {
 #ifdef CONFIG_X86_LOCAL_APIC
-	op_nmi_exit();
+	if (!nmi_timer)
+		op_nmi_exit();
 #endif
 }

commit d717ca84c02f4b60a85502c23bca5698801dfaae
Author: Paolo Ciarrocchi <paolo.ciarrocchi@gmail.com>
Date:   Fri Feb 22 23:09:50 2008 +0100

    x86: coding style fixes to arch/x86/oprofile/init.c
    
    Before:
       total: 5 errors, 4 warnings, 48 lines checked
    After:
       total: 0 errors, 4 warnings, 49 lines checked
    
    No code changed:
    
    arch/x86/oprofile/init.o:
    
       text    data     bss     dec     hex filename
         42       0       0      42      2a init.o.before
         42       0       0      42      2a init.o.after
    
    md5:
       74c94c315cfbf245aeba36eceac57e66  init.o.before.asm
       74c94c315cfbf245aeba36eceac57e66  init.o.after.asm
    
    Signed-off-by: Paolo Ciarrocchi <paolo.ciarrocchi@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/oprofile/init.c b/arch/x86/oprofile/init.c
index 5341d481d92f..cdfe4c54deca 100644
--- a/arch/x86/oprofile/init.c
+++ b/arch/x86/oprofile/init.c
@@ -10,18 +10,19 @@
 #include <linux/oprofile.h>
 #include <linux/init.h>
 #include <linux/errno.h>
- 
-/* We support CPUs that have performance counters like the Pentium Pro
+
+/*
+ * We support CPUs that have performance counters like the Pentium Pro
  * with the NMI mode driver.
  */
- 
-extern int op_nmi_init(struct oprofile_operations * ops);
-extern int op_nmi_timer_init(struct oprofile_operations * ops);
+
+extern int op_nmi_init(struct oprofile_operations *ops);
+extern int op_nmi_timer_init(struct oprofile_operations *ops);
 extern void op_nmi_exit(void);
 extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
 
 
-int __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	int ret;
 

commit ff4395654dc6a3a5e35611940047114d4f3d0a7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 11 11:16:55 2007 +0200

    i386: move oprofile
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/x86/oprofile/init.c b/arch/x86/oprofile/init.c
new file mode 100644
index 000000000000..5341d481d92f
--- /dev/null
+++ b/arch/x86/oprofile/init.c
@@ -0,0 +1,48 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+ 
+/* We support CPUs that have performance counters like the Pentium Pro
+ * with the NMI mode driver.
+ */
+ 
+extern int op_nmi_init(struct oprofile_operations * ops);
+extern int op_nmi_timer_init(struct oprofile_operations * ops);
+extern void op_nmi_exit(void);
+extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
+
+
+int __init oprofile_arch_init(struct oprofile_operations * ops)
+{
+	int ret;
+
+	ret = -ENODEV;
+
+#ifdef CONFIG_X86_LOCAL_APIC
+	ret = op_nmi_init(ops);
+#endif
+#ifdef CONFIG_X86_IO_APIC
+	if (ret < 0)
+		ret = op_nmi_timer_init(ops);
+#endif
+	ops->backtrace = x86_backtrace;
+
+	return ret;
+}
+
+
+void oprofile_arch_exit(void)
+{
+#ifdef CONFIG_X86_LOCAL_APIC
+	op_nmi_exit();
+#endif
+}
