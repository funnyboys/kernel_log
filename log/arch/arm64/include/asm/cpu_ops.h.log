commit de58ed5e16e62f36c7ed05552f18b7f9c647dcaf
Author: Gavin Shan <gshan@redhat.com>
Date:   Thu Mar 19 10:01:44 2020 +1100

    arm64: Introduce get_cpu_ops() helper function
    
    This introduces get_cpu_ops() to return the CPU operations according to
    the given CPU index. For now, it simply returns the @cpu_ops[cpu] as
    before. Also, helper function __cpu_try_die() is introduced to be shared
    by cpu_die() and ipi_cpu_crash_stop(). So it shouldn't introduce any
    functional changes.
    
    Signed-off-by: Gavin Shan <gshan@redhat.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index baa13b5db2ca..d28e8f37d3b4 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -55,8 +55,8 @@ struct cpu_operations {
 #endif
 };
 
-extern const struct cpu_operations *cpu_ops[NR_CPUS];
 int __init init_cpu_ops(int cpu);
+extern const struct cpu_operations *get_cpu_ops(int cpu);
 
 static inline void __init init_bootcpu_ops(void)
 {

commit 6885fb129be30c627eb2f5b1498dba498ff6c037
Author: Gavin Shan <gshan@redhat.com>
Date:   Thu Mar 19 10:01:43 2020 +1100

    arm64: Rename cpu_read_ops() to init_cpu_ops()
    
    This renames cpu_read_ops() to init_cpu_ops() as the function is only
    called in initialization phase. Also, we will introduce get_cpu_ops() in
    the subsequent patches, to retireve the CPU operation by the given CPU
    index. The usage of cpu_read_ops() and get_cpu_ops() are difficult to be
    distinguished from their names.
    
    Signed-off-by: Gavin Shan <gshan@redhat.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 86aabf1e0199..baa13b5db2ca 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -56,11 +56,11 @@ struct cpu_operations {
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
-int __init cpu_read_ops(int cpu);
+int __init init_cpu_ops(int cpu);
 
-static inline void __init cpu_read_bootcpu_ops(void)
+static inline void __init init_bootcpu_ops(void)
 {
-	cpu_read_ops(0);
+	init_cpu_ops(0);
 }
 
 #endif /* ifndef __ASM_CPU_OPS_H */

commit d55c5f28afafb6b1f0a6978916b23338b383faab
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jun 12 13:51:37 2019 +0100

    arm64: smp: disable hotplug on trusted OS resident CPU
    
    The trusted OS may reject CPU_OFF calls to its resident CPU, so we must
    avoid issuing those. We never migrate a Trusted OS and we already take
    care to prevent CPU_OFF PSCI call. However, this is not reflected
    explicitly to the userspace. Any user can attempt to hotplug trusted OS
    resident CPU. The entire motion of going through the various state
    transitions in the CPU hotplug state machine gets executed and the
    PSCI layer finally refuses to make CPU_OFF call.
    
    This results is unnecessary unwinding of CPU hotplug state machine in
    the kernel. Instead we can mark the trusted OS resident CPU as not
    available for hotplug, so that the user attempt or request to do the
    same will get immediately rejected.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index c09d633c3109..86aabf1e0199 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -23,6 +23,8 @@
  * @cpu_boot:	Boots a cpu into the kernel.
  * @cpu_postboot: Optionally, perform any post-boot cleanup or necesary
  *		synchronisation. Called from the cpu being booted.
+ * @cpu_can_disable: Determines whether a CPU can be disabled based on
+ *		mechanism-specific information.
  * @cpu_disable: Prepares a cpu to die. May fail for some mechanism-specific
  * 		reason, which will cause the hot unplug to be aborted. Called
  * 		from the cpu to be killed.
@@ -42,6 +44,7 @@ struct cpu_operations {
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);
 #ifdef CONFIG_HOTPLUG_CPU
+	bool		(*cpu_can_disable)(unsigned int cpu);
 	int		(*cpu_disable)(unsigned int cpu);
 	void		(*cpu_die)(unsigned int cpu);
 	int		(*cpu_kill)(unsigned int cpu);

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 8f03446cf89f..c09d633c3109 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -1,17 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2013 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #ifndef __ASM_CPU_OPS_H
 #define __ASM_CPU_OPS_H

commit 0f0783365cbb7ec13a8f02198f6e1a146d94a5a9
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 13 14:12:47 2015 +0100

    ARM64: kernel: unify ACPI and DT cpus initialization
    
    The code that initializes cpus on arm64 is currently split in two
    different code paths that carry out DT and ACPI cpus initialization.
    
    Most of the code executing SMP initialization is common and should
    be merged to reduce discrepancies between ACPI and DT initialization
    and to have code initializing cpus in a single common place in the
    kernel.
    
    This patch refactors arm64 SMP cpus initialization code to merge
    ACPI and DT boot paths in a common file and to create sanity
    checks that can be reused by both boot methods.
    
    Current code assumes PSCI is the only available boot method
    when arm64 boots with ACPI; this can be easily extended if/when
    the ACPI parking protocol is merged into the kernel.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com> [DT]
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 7d8b999d1a2b..8f03446cf89f 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -65,7 +65,6 @@ struct cpu_operations {
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
 int __init cpu_read_ops(int cpu);
-const struct cpu_operations *cpu_get_ops(const char *name);
 
 static inline void __init cpu_read_bootcpu_ops(void)
 {

commit 819a88263d5dbe398edd59cc1cf725ed1fdcfd79
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 13 14:12:46 2015 +0100

    ARM64: kernel: make cpu_ops hooks DT agnostic
    
    ARM64 CPU operations such as cpu_init and cpu_init_idle take
    a struct device_node pointer as a parameter, which corresponds to
    the device tree node of the logical cpu on which the operation
    has to be applied.
    
    With the advent of ACPI on arm64, where MADT static table entries
    are used to initialize cpus, the device tree node parameter
    in cpu_ops hooks become useless when booting with ACPI, since
    in that case cpu device tree nodes are not present and can not be
    used for cpu initialization.
    
    The current cpu_init hook requires a struct device_node pointer
    parameter because it is called while parsing the device tree to
    initialize CPUs, when the cpu_logical_map (that is used to match
    a cpu node reg property to a device tree node) for a given logical
    cpu id is not set up yet. This means that the cpu_init hook cannot
    rely on the of_get_cpu_node function to retrieve the device tree
    node corresponding to the logical cpu id passed in as parameter,
    so the cpu device tree node must be passed in as a parameter to fix
    this catch-22 dependency cycle.
    
    This patch reshuffles the cpu_logical_map initialization code so
    that the cpu_init cpu_ops hook can safely use the of_get_cpu_node
    function to retrieve the cpu device tree node, removing the need for
    the device tree node pointer parameter.
    
    In the process, the patch removes device tree node parameters
    from all cpu_ops hooks, in preparation for SMP DT/ACPI cpus
    initialization consolidation.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com> [DT]
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 5a31d6716914..7d8b999d1a2b 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -19,15 +19,15 @@
 #include <linux/init.h>
 #include <linux/threads.h>
 
-struct device_node;
-
 /**
  * struct cpu_operations - Callback operations for hotplugging CPUs.
  *
  * @name:	Name of the property as appears in a devicetree cpu node's
- *		enable-method property.
- * @cpu_init:	Reads any data necessary for a specific enable-method from the
- *		devicetree, for a given cpu node and proposed logical id.
+ *		enable-method property. On systems booting with ACPI, @name
+ *		identifies the struct cpu_operations entry corresponding to
+ *		the boot protocol specified in the ACPI MADT table.
+ * @cpu_init:	Reads any data necessary for a specific enable-method for a
+ *		proposed logical id.
  * @cpu_prepare: Early one-time preparation step for a cpu. If there is a
  *		mechanism for doing so, tests whether it is possible to boot
  *		the given CPU.
@@ -40,15 +40,15 @@ struct device_node;
  * @cpu_die:	Makes a cpu leave the kernel. Must not fail. Called from the
  *		cpu being killed.
  * @cpu_kill:  Ensures a cpu has left the kernel. Called from another cpu.
- * @cpu_init_idle: Reads any data necessary to initialize CPU idle states from
- *		devicetree, for a given cpu node and proposed logical id.
+ * @cpu_init_idle: Reads any data necessary to initialize CPU idle states for
+ *		   a proposed logical id.
  * @cpu_suspend: Suspends a cpu and saves the required context. May fail owing
  *               to wrong parameters or error conditions. Called from the
  *               CPU being suspended. Must be called with IRQs disabled.
  */
 struct cpu_operations {
 	const char	*name;
-	int		(*cpu_init)(struct device_node *, unsigned int);
+	int		(*cpu_init)(unsigned int);
 	int		(*cpu_prepare)(unsigned int);
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);
@@ -58,14 +58,18 @@ struct cpu_operations {
 	int		(*cpu_kill)(unsigned int cpu);
 #endif
 #ifdef CONFIG_CPU_IDLE
-	int		(*cpu_init_idle)(struct device_node *, unsigned int);
+	int		(*cpu_init_idle)(unsigned int);
 	int		(*cpu_suspend)(unsigned long);
 #endif
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
-int __init cpu_read_ops(struct device_node *dn, int cpu);
-void __init cpu_read_bootcpu_ops(void);
+int __init cpu_read_ops(int cpu);
 const struct cpu_operations *cpu_get_ops(const char *name);
 
+static inline void __init cpu_read_bootcpu_ops(void)
+{
+	cpu_read_ops(0);
+}
+
 #endif /* ifndef __ASM_CPU_OPS_H */

commit fccb9a81fd08b61bed91ddef88341694f8ecbfd1
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 22:02:45 2015 +0800

    ARM64 / ACPI: Parse MADT for SMP initialization
    
    MADT contains the information for MPIDR which is essential for
    SMP initialization, parse the GIC cpu interface structures to
    get the MPIDR value and map it to cpu_logical_map(), and add
    enabled cpu with valid MPIDR into cpu_possible_map.
    
    ACPI 5.1 only has two explicit methods to boot up SMP, PSCI and
    Parking protocol, but the Parking protocol is only specified for
    ARMv7 now, so make PSCI as the only way for the SMP boot protocol
    before some updates for the ACPI spec or the Parking protocol spec.
    
    Parking protocol patches for SMP boot will be sent to upstream when
    the new version of Parking protocol is ready.
    
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index da301ee7395c..5a31d6716914 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -66,5 +66,6 @@ struct cpu_operations {
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
 int __init cpu_read_ops(struct device_node *dn, int cpu);
 void __init cpu_read_bootcpu_ops(void);
+const struct cpu_operations *cpu_get_ops(const char *name);
 
 #endif /* ifndef __ASM_CPU_OPS_H */

commit af3cfdbf56b91785650f54e7c9a899d814b4b9fb
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jan 26 18:33:44 2015 +0000

    arm64: kernel: remove ARM64_CPU_SUSPEND config option
    
    ARM64_CPU_SUSPEND config option was introduced to make code providing
    context save/restore selectable only on platforms requiring power
    management capabilities.
    
    Currently ARM64_CPU_SUSPEND depends on the PM_SLEEP config option which
    in turn is set by the SUSPEND config option.
    
    The introduction of CPU_IDLE for arm64 requires that code configured
    by ARM64_CPU_SUSPEND (context save/restore) should be compiled in
    in order to enable the CPU idle driver to rely on CPU operations
    carrying out context save/restore.
    
    The ARM64_CPUIDLE config option (ARM64 generic idle driver) is therefore
    forced to select ARM64_CPU_SUSPEND, even if there may be (ie PM_SLEEP)
    failed dependencies, which is not a clean way of handling the kernel
    configuration option.
    
    For these reasons, this patch removes the ARM64_CPU_SUSPEND config option
    and makes the context save/restore dependent on CPU_PM, which is selected
    whenever either SUSPEND or CPU_IDLE are configured, cleaning up dependencies
    in the process.
    
    This way, code previously configured through ARM64_CPU_SUSPEND is
    compiled in whenever a power management subsystem requires it to be
    present in the kernel (SUSPEND || CPU_IDLE), which is the behaviour
    expected on ARM64 kernels.
    
    The cpu_suspend and cpu_init_idle CPU operations are added only if
    CPU_IDLE is selected, since they are CPU_IDLE specific methods and
    should be grouped and defined accordingly.
    
    PSCI CPU operations are updated to reflect the introduced changes.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 6f8e2ef9094a..da301ee7395c 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -28,8 +28,6 @@ struct device_node;
  *		enable-method property.
  * @cpu_init:	Reads any data necessary for a specific enable-method from the
  *		devicetree, for a given cpu node and proposed logical id.
- * @cpu_init_idle: Reads any data necessary to initialize CPU idle states from
- *		devicetree, for a given cpu node and proposed logical id.
  * @cpu_prepare: Early one-time preparation step for a cpu. If there is a
  *		mechanism for doing so, tests whether it is possible to boot
  *		the given CPU.
@@ -42,6 +40,8 @@ struct device_node;
  * @cpu_die:	Makes a cpu leave the kernel. Must not fail. Called from the
  *		cpu being killed.
  * @cpu_kill:  Ensures a cpu has left the kernel. Called from another cpu.
+ * @cpu_init_idle: Reads any data necessary to initialize CPU idle states from
+ *		devicetree, for a given cpu node and proposed logical id.
  * @cpu_suspend: Suspends a cpu and saves the required context. May fail owing
  *               to wrong parameters or error conditions. Called from the
  *               CPU being suspended. Must be called with IRQs disabled.
@@ -49,7 +49,6 @@ struct device_node;
 struct cpu_operations {
 	const char	*name;
 	int		(*cpu_init)(struct device_node *, unsigned int);
-	int		(*cpu_init_idle)(struct device_node *, unsigned int);
 	int		(*cpu_prepare)(unsigned int);
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);
@@ -58,7 +57,8 @@ struct cpu_operations {
 	void		(*cpu_die)(unsigned int cpu);
 	int		(*cpu_kill)(unsigned int cpu);
 #endif
-#ifdef CONFIG_ARM64_CPU_SUSPEND
+#ifdef CONFIG_CPU_IDLE
+	int		(*cpu_init_idle)(struct device_node *, unsigned int);
 	int		(*cpu_suspend)(unsigned long);
 #endif
 };

commit 0a6479b0ffad8dd236915e271faaf2cbb4cac287
Author: Geoff Levand <geoff@infradead.org>
Date:   Fri Aug 22 20:49:16 2014 +0100

    arm64: Remove unneeded extern keyword
    
    Function prototypes are never definitions, so remove any 'extern' keyword
    from the funcion prototypes in cpu_ops.h. Fixes warnings emited by
    checkpatch.
    
    Signed-off-by: Geoff Levand <geoff@infradead.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 47dfa31ad71a..6f8e2ef9094a 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -64,7 +64,7 @@ struct cpu_operations {
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
-extern int __init cpu_read_ops(struct device_node *dn, int cpu);
-extern void __init cpu_read_bootcpu_ops(void);
+int __init cpu_read_ops(struct device_node *dn, int cpu);
+void __init cpu_read_bootcpu_ops(void);
 
 #endif /* ifndef __ASM_CPU_OPS_H */

commit d64f84f696463c58e1908510e45b0f5d450f737a
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 17 10:30:07 2014 +0100

    arm64: kernel: introduce cpu_init_idle CPU operation
    
    The CPUidle subsystem on ARM64 machines requires the idle states
    implementation back-end to initialize idle states parameter upon
    boot. This patch adds a hook in the CPU operations structure that
    should be initialized by the CPU operations back-end in order to
    provide a function that initializes cpu idle states.
    
    This patch also adds the infrastructure to arm64 kernel required
    to export the CPU operations based initialization interface, so
    that drivers (ie CPUidle) can use it when they are initialized
    at probe time.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index d7b4b38a8e86..47dfa31ad71a 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -28,6 +28,8 @@ struct device_node;
  *		enable-method property.
  * @cpu_init:	Reads any data necessary for a specific enable-method from the
  *		devicetree, for a given cpu node and proposed logical id.
+ * @cpu_init_idle: Reads any data necessary to initialize CPU idle states from
+ *		devicetree, for a given cpu node and proposed logical id.
  * @cpu_prepare: Early one-time preparation step for a cpu. If there is a
  *		mechanism for doing so, tests whether it is possible to boot
  *		the given CPU.
@@ -47,6 +49,7 @@ struct device_node;
 struct cpu_operations {
 	const char	*name;
 	int		(*cpu_init)(struct device_node *, unsigned int);
+	int		(*cpu_init_idle)(struct device_node *, unsigned int);
 	int		(*cpu_prepare)(unsigned int);
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);

commit c814ca029e1015bb0ecec312f4bb9751ba1a711a
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Wed May 7 10:18:36 2014 -0400

    ARM: Check if a CPU has gone offline
    
    PSCIv0.2 adds a new function called AFFINITY_INFO, which
    can be used to query if a specified CPU has actually gone
    offline. Calling this function via cpu_kill ensures that
    a CPU has quiesced after a call to cpu_die. This helps
    prevent the CPU from doing arbitrary bad things when data
    or instructions are clobbered (as happens with kexec)
    in the window between a CPU announcing that it is dead
    and said CPU leaving the kernel.
    
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 152413076503..d7b4b38a8e86 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -39,6 +39,7 @@ struct device_node;
  * 		from the cpu to be killed.
  * @cpu_die:	Makes a cpu leave the kernel. Must not fail. Called from the
  *		cpu being killed.
+ * @cpu_kill:  Ensures a cpu has left the kernel. Called from another cpu.
  * @cpu_suspend: Suspends a cpu and saves the required context. May fail owing
  *               to wrong parameters or error conditions. Called from the
  *               CPU being suspended. Must be called with IRQs disabled.
@@ -52,6 +53,7 @@ struct cpu_operations {
 #ifdef CONFIG_HOTPLUG_CPU
 	int		(*cpu_disable)(unsigned int cpu);
 	void		(*cpu_die)(unsigned int cpu);
+	int		(*cpu_kill)(unsigned int cpu);
 #endif
 #ifdef CONFIG_ARM64_CPU_SUSPEND
 	int		(*cpu_suspend)(unsigned long);

commit 95322526ef62b84adb469c27535ab0252a369a85
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jul 22 12:22:13 2013 +0100

    arm64: kernel: cpu_{suspend/resume} implementation
    
    Kernel subsystems like CPU idle and suspend to RAM require a generic
    mechanism to suspend a processor, save its context and put it into
    a quiescent state. The cpu_{suspend}/{resume} implementation provides
    such a framework through a kernel interface allowing to save/restore
    registers, flush the context to DRAM and suspend/resume to/from
    low-power states where processor context may be lost.
    
    The CPU suspend implementation relies on the suspend protocol registered
    in CPU operations to carry out a suspend request after context is
    saved and flushed to DRAM. The cpu_suspend interface:
    
    int cpu_suspend(unsigned long arg);
    
    allows to pass an opaque parameter that is handed over to the suspend CPU
    operations back-end so that it can take action according to the
    semantics attached to it. The arg parameter allows suspend to RAM and CPU
    idle drivers to communicate to suspend protocol back-ends; it requires
    standardization so that the interface can be reused seamlessly across
    systems, paving the way for generic drivers.
    
    Context memory is allocated on the stack, whose address is stashed in a
    per-cpu variable to keep track of it and passed to core functions that
    save/restore the registers required by the architecture.
    
    Even though, upon successful execution, the cpu_suspend function shuts
    down the suspending processor, the warm boot resume mechanism, based
    on the cpu_resume function, makes the resume path operate as a
    cpu_suspend function return, so that cpu_suspend can be treated as a C
    function by the caller, which simplifies coding the PM drivers that rely
    on the cpu_suspend API.
    
    Upon context save, the minimal amount of memory is flushed to DRAM so
    that it can be retrieved when the MMU is off and caches are not searched.
    
    The suspend CPU operation, depending on the required operations (eg CPU vs
    Cluster shutdown) is in charge of flushing the cache hierarchy either
    implicitly (by calling firmware implementations like PSCI) or explicitly
    by executing the required cache maintainance functions.
    
    Debug exceptions are disabled during cpu_{suspend}/{resume} operations
    so that debug registers can be saved and restored properly preventing
    preemption from debug agents enabled in the kernel.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index c4cdb5e5b73d..152413076503 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -39,6 +39,9 @@ struct device_node;
  * 		from the cpu to be killed.
  * @cpu_die:	Makes a cpu leave the kernel. Must not fail. Called from the
  *		cpu being killed.
+ * @cpu_suspend: Suspends a cpu and saves the required context. May fail owing
+ *               to wrong parameters or error conditions. Called from the
+ *               CPU being suspended. Must be called with IRQs disabled.
  */
 struct cpu_operations {
 	const char	*name;
@@ -50,6 +53,9 @@ struct cpu_operations {
 	int		(*cpu_disable)(unsigned int cpu);
 	void		(*cpu_die)(unsigned int cpu);
 #endif
+#ifdef CONFIG_ARM64_CPU_SUSPEND
+	int		(*cpu_suspend)(unsigned long);
+#endif
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];

commit 9327e2c6bb8cb0131b38a07847cd58c78dc095e9
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Oct 24 20:30:18 2013 +0100

    arm64: add CPU_HOTPLUG infrastructure
    
    This patch adds the basic infrastructure necessary to support
    CPU_HOTPLUG on arm64, based on the arm implementation. Actual hotplug
    support will depend on an implementation's cpu_operations (e.g. PSCI).
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 1a98dbfc4a5f..c4cdb5e5b73d 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -34,6 +34,11 @@ struct device_node;
  * @cpu_boot:	Boots a cpu into the kernel.
  * @cpu_postboot: Optionally, perform any post-boot cleanup or necesary
  *		synchronisation. Called from the cpu being booted.
+ * @cpu_disable: Prepares a cpu to die. May fail for some mechanism-specific
+ * 		reason, which will cause the hot unplug to be aborted. Called
+ * 		from the cpu to be killed.
+ * @cpu_die:	Makes a cpu leave the kernel. Must not fail. Called from the
+ *		cpu being killed.
  */
 struct cpu_operations {
 	const char	*name;
@@ -41,6 +46,10 @@ struct cpu_operations {
 	int		(*cpu_prepare)(unsigned int);
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);
+#ifdef CONFIG_HOTPLUG_CPU
+	int		(*cpu_disable)(unsigned int cpu);
+	void		(*cpu_die)(unsigned int cpu);
+#endif
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];

commit e8765b265a69c83504afc6901d6e137b1811d1f0
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Oct 24 20:30:17 2013 +0100

    arm64: read enable-method for CPU0
    
    With the advent of CPU_HOTPLUG, the enable-method property for CPU0 may
    tells us something useful (i.e. how to hotplug it back on), so we must
    read it along with all the enable-method for all the other CPUs.  Even
    on UP the enable-method may tell us useful information (e.g. if a core
    has some mechanism that might be usable for cpuidle), so we should
    always read it.
    
    This patch factors out the reading of the enable method, and ensures
    that CPU0's enable method is read regardless of whether the kernel is
    built with SMP support.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 67bc4fd83798..1a98dbfc4a5f 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -44,6 +44,7 @@ struct cpu_operations {
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];
-extern const struct cpu_operations * __init cpu_get_ops(const char *name);
+extern int __init cpu_read_ops(struct device_node *dn, int cpu);
+extern void __init cpu_read_bootcpu_ops(void);
 
 #endif /* ifndef __ASM_CPU_OPS_H */

commit 652af899799354049b273af897b798b8f03fdd88
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Oct 24 20:30:16 2013 +0100

    arm64: factor out spin-table boot method
    
    The arm64 kernel has an internal holding pen, which is necessary for
    some systems where we can't bring CPUs online individually and must hold
    multiple CPUs in a safe area until the kernel is able to handle them.
    The current SMP infrastructure for arm64 is closely coupled to this
    holding pen, and alternative boot methods must launch CPUs into the pen,
    where they sit before they are launched into the kernel proper.
    
    With PSCI (and possibly other future boot methods), we can bring CPUs
    online individually, and need not perform the secondary_holding_pen
    dance. Instead, this patch factors the holding pen management code out
    to the spin-table boot method code, as it is the only boot method
    requiring the pen.
    
    A new entry point for secondaries, secondary_entry is added for other
    boot methods to use, which bypasses the holding pen and its associated
    overhead when bringing CPUs online. The smp.pen.text section is also
    removed, as the pen can live in head.text without problem.
    
    The cpu_operations structure is extended with two new functions,
    cpu_boot and cpu_postboot, for bringing a cpu into the kernel and
    performing any post-boot cleanup required by a bootmethod (e.g.
    resetting the secondary_holding_pen_release to INVALID_HWID).
    Documentation is added for cpu_operations.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 3c60c8d1d928..67bc4fd83798 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -21,10 +21,26 @@
 
 struct device_node;
 
+/**
+ * struct cpu_operations - Callback operations for hotplugging CPUs.
+ *
+ * @name:	Name of the property as appears in a devicetree cpu node's
+ *		enable-method property.
+ * @cpu_init:	Reads any data necessary for a specific enable-method from the
+ *		devicetree, for a given cpu node and proposed logical id.
+ * @cpu_prepare: Early one-time preparation step for a cpu. If there is a
+ *		mechanism for doing so, tests whether it is possible to boot
+ *		the given CPU.
+ * @cpu_boot:	Boots a cpu into the kernel.
+ * @cpu_postboot: Optionally, perform any post-boot cleanup or necesary
+ *		synchronisation. Called from the cpu being booted.
+ */
 struct cpu_operations {
 	const char	*name;
 	int		(*cpu_init)(struct device_node *, unsigned int);
 	int		(*cpu_prepare)(unsigned int);
+	int		(*cpu_boot)(unsigned int);
+	void		(*cpu_postboot)(void);
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];

commit cd1aebf5277a3a154a9e4c0ea4b3acabb62e5cab
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Oct 24 20:30:15 2013 +0100

    arm64: reorganise smp_enable_ops
    
    For hotplug support, we're going to want a place to store operations
    that do more than bring CPUs online, and it makes sense to group these
    with our current smp_enable_ops. For cpuidle support, we'll want to
    group additional functions, and we may want them even for UP kernels.
    
    This patch renames smp_enable_ops to the more general cpu_operations,
    and pulls the definitions out of smp code such that they can be used in
    UP kernels. While we're at it, fix up instances of the cpu parameter to
    be an unsigned int, drop the init markings and rename the *_cpu
    functions to cpu_* to reduce future churn when cpu_operations is
    extended.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
new file mode 100644
index 000000000000..3c60c8d1d928
--- /dev/null
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __ASM_CPU_OPS_H
+#define __ASM_CPU_OPS_H
+
+#include <linux/init.h>
+#include <linux/threads.h>
+
+struct device_node;
+
+struct cpu_operations {
+	const char	*name;
+	int		(*cpu_init)(struct device_node *, unsigned int);
+	int		(*cpu_prepare)(unsigned int);
+};
+
+extern const struct cpu_operations *cpu_ops[NR_CPUS];
+extern const struct cpu_operations * __init cpu_get_ops(const char *name);
+
+#endif /* ifndef __ASM_CPU_OPS_H */
