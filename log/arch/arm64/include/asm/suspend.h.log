commit 6d37d81f449a103a8b43c5c972b5055b8936ef0e
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Mon Apr 27 09:00:12 2020 -0700

    arm64: Preserve register x18 when CPU is suspended
    
    Don't lose the current task's shadow stack when the CPU is suspended.
    
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Will Deacon <will@kernel.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 8939c87c4dce..0cde2f473971 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -2,7 +2,7 @@
 #ifndef __ASM_SUSPEND_H
 #define __ASM_SUSPEND_H
 
-#define NR_CTX_REGS 12
+#define NR_CTX_REGS 13
 #define NR_CALLEE_SAVED_REGS 12
 
 /*

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index de5600f40adf..8939c87c4dce 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ASM_SUSPEND_H
 #define __ASM_SUSPEND_H
 

commit 623b476fc815464a0241ea7483da7b3580b7d8ac
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Nov 3 20:23:09 2016 +0000

    arm64: move sp_el0 and tpidr_el1 into cpu_suspend_ctx
    
    When returning from idle, we rely on the fact that thread_info lives at
    the end of the kernel stack, and restore this by masking the saved stack
    pointer. Subsequent patches will sever the relationship between the
    stack and thread_info, and to cater for this we must save/restore sp_el0
    explicitly, storing it in cpu_suspend_ctx.
    
    As cpu_suspend_ctx must be doubleword aligned, this leaves us with an
    extra slot in cpu_suspend_ctx. We can use this to save/restore tpidr_el1
    in the same way, which simplifies the code, avoiding pointer chasing on
    the restore path (as we no longer need to load thread_info::cpu followed
    by the relevant slot in __per_cpu_offset based on this).
    
    This patch stashes both registers in cpu_suspend_ctx.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Laura Abbott <labbott@redhat.com>
    Cc: James Morse <james.morse@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index b8a313fd7a09..de5600f40adf 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -1,7 +1,7 @@
 #ifndef __ASM_SUSPEND_H
 #define __ASM_SUSPEND_H
 
-#define NR_CTX_REGS 10
+#define NR_CTX_REGS 12
 #define NR_CALLEE_SAVED_REGS 12
 
 /*

commit 8ec058fd2710da1df463c19a4e0ee55ac4530f09
Author: James Morse <james.morse@arm.com>
Date:   Wed Aug 17 13:50:26 2016 +0100

    arm64: hibernate: Resume when hibernate image created on non-boot CPU
    
    disable_nonboot_cpus() assumes that the lowest numbered online CPU is
    the boot CPU, and that this is the correct CPU to run any power
    management code on.
    
    On arm64 CPU0 can be taken offline. For hibernate/resume this means we
    may hibernate on a CPU other than CPU0. If the system is rebooted with
    kexec 'CPU0' will be assigned to a different CPU. This complicates
    hibernate/resume as now we can't trust the CPU numbers.
    
    We currently forbid hibernate if CPU0 has been hotplugged out to avoid
    this situation without kexec.
    
    Save the MPIDR of the CPU we hibernated on in the hibernate arch-header,
    use hibernate_resume_nonboot_cpu_disable() to direct which CPU we should
    resume on based on the MPIDR of the CPU we hibernated on. This allows us to
    hibernate/resume on any CPU, even if the logical numbers have been
    shuffled by kexec.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 024d623f662e..b8a313fd7a09 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -47,4 +47,7 @@ int swsusp_arch_resume(void);
 int arch_hibernation_header_save(void *addr, unsigned int max_size);
 int arch_hibernation_header_restore(void *addr);
 
+/* Used to resume on the CPU we hibernated on */
+int hibernate_resume_nonboot_cpu_disable(void);
+
 #endif

commit 82869ac57b5d3b550446932c918dbf2caf020c9e
Author: James Morse <james.morse@arm.com>
Date:   Wed Apr 27 17:47:12 2016 +0100

    arm64: kernel: Add support for hibernate/suspend-to-disk
    
    Add support for hibernate/suspend-to-disk.
    
    Suspend borrows code from cpu_suspend() to write cpu state onto the stack,
    before calling swsusp_save() to save the memory image.
    
    Restore creates a set of temporary page tables, covering only the
    linear map, copies the restore code to a 'safe' page, then uses the copy to
    restore the memory image. The copied code executes in the lower half of the
    address space, and once complete, restores the original kernel's page
    tables. It then calls into cpu_resume(), and follows the normal
    cpu_suspend() path back into the suspend code.
    
    To restore a kernel using KASLR, the address of the page tables, and
    cpu_resume() are stored in the hibernate arch-header and the el2
    vectors are pivotted via the 'safe' page in low memory.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Kevin Hilman <khilman@baylibre.com> # Tested on Juno R2
    Signed-off-by: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 29d3c71433e1..024d623f662e 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -40,4 +40,11 @@ extern int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
 int __cpu_suspend_enter(struct sleep_stack_data *state);
 void __cpu_suspend_exit(void);
+void _cpu_resume(void);
+
+int swsusp_arch_suspend(void);
+int swsusp_arch_resume(void);
+int arch_hibernation_header_save(void *addr, unsigned int max_size);
+int arch_hibernation_header_restore(void *addr);
+
 #endif

commit cabe1c81ea5be983425d117912d7883e252a3b09
Author: James Morse <james.morse@arm.com>
Date:   Wed Apr 27 17:47:07 2016 +0100

    arm64: Change cpu_resume() to enable mmu early then access sleep_sp by va
    
    By enabling the MMU early in cpu_resume(), the sleep_save_sp and stack can
    be accessed by VA, which avoids the need to convert-addresses and clean to
    PoC on the suspend path.
    
    MMU setup is shared with the boot path, meaning the swapper_pg_dir is
    restored directly: ttbr1_el1 is no longer saved/restored.
    
    struct sleep_save_sp is removed, replacing it with a single array of
    pointers.
    
    cpu_do_{suspend,resume} could be further reduced to not restore: cpacr_el1,
    mdscr_el1, tcr_el1, vbar_el1 and sctlr_el1, all of which are set by
    __cpu_setup(). However these values all contain res0 bits that may be used
    to enable future features.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 365d8cdd0073..29d3c71433e1 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -1,7 +1,7 @@
 #ifndef __ASM_SUSPEND_H
 #define __ASM_SUSPEND_H
 
-#define NR_CTX_REGS 11
+#define NR_CTX_REGS 10
 #define NR_CALLEE_SAVED_REGS 12
 
 /*
@@ -17,11 +17,6 @@ struct cpu_suspend_ctx {
 	u64 sp;
 } __aligned(16);
 
-struct sleep_save_sp {
-	phys_addr_t *save_ptr_stash;
-	phys_addr_t save_ptr_stash_phys;
-};
-
 /*
  * Memory to save the cpu state is allocated on the stack by
  * __cpu_suspend_enter()'s caller, and populated by __cpu_suspend_enter().
@@ -39,6 +34,8 @@ struct sleep_stack_data {
 	unsigned long		callee_saved_regs[NR_CALLEE_SAVED_REGS];
 };
 
+extern unsigned long *sleep_save_stash;
+
 extern int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
 int __cpu_suspend_enter(struct sleep_stack_data *state);

commit adc9b2dfd00924e9e9b98613f36a6cb8c51f0dc6
Author: James Morse <james.morse@arm.com>
Date:   Wed Apr 27 17:47:06 2016 +0100

    arm64: kernel: Rework finisher callback out of __cpu_suspend_enter()
    
    Hibernate could make use of the cpu_suspend() code to save/restore cpu
    state, however it needs to be able to return '0' from the 'finisher'.
    
    Rework cpu_suspend() so that the finisher is called from C code,
    independently from the save/restore of cpu state. Space to save the context
    in is allocated in the caller's stack frame, and passed into
    __cpu_suspend_enter().
    
    Hibernate's use of this API will look like a copy of the cpu_suspend()
    function.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 59a5b0f1e81c..365d8cdd0073 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -2,6 +2,7 @@
 #define __ASM_SUSPEND_H
 
 #define NR_CTX_REGS 11
+#define NR_CALLEE_SAVED_REGS 12
 
 /*
  * struct cpu_suspend_ctx must be 16-byte aligned since it is allocated on
@@ -21,6 +22,25 @@ struct sleep_save_sp {
 	phys_addr_t save_ptr_stash_phys;
 };
 
+/*
+ * Memory to save the cpu state is allocated on the stack by
+ * __cpu_suspend_enter()'s caller, and populated by __cpu_suspend_enter().
+ * This data must survive until cpu_resume() is called.
+ *
+ * This struct desribes the size and the layout of the saved cpu state.
+ * The layout of the callee_saved_regs is defined by the implementation
+ * of __cpu_suspend_enter(), and cpu_resume(). This struct must be passed
+ * in by the caller as __cpu_suspend_enter()'s stack-frame is gone once it
+ * returns, and the data would be subsequently corrupted by the call to the
+ * finisher.
+ */
+struct sleep_stack_data {
+	struct cpu_suspend_ctx	system_regs;
+	unsigned long		callee_saved_regs[NR_CALLEE_SAVED_REGS];
+};
+
 extern int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
+int __cpu_suspend_enter(struct sleep_stack_data *state);
+void __cpu_suspend_exit(void);
 #endif

commit af391b15f7b56ce19f52862d36595637dd42b575
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Jun 18 15:41:32 2015 +0100

    arm64: kernel: rename __cpu_suspend to keep it aligned with arm
    
    This patch renames __cpu_suspend to cpu_suspend so that it's aligned
    with ARM32. It also removes the redundant wrapper created.
    
    This is in preparation to implement generic PSCI system suspend using
    the cpu_{suspend,resume} which now has the same interface on both ARM
    and ARM64.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 003802f58963..59a5b0f1e81c 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -21,6 +21,6 @@ struct sleep_save_sp {
 	phys_addr_t save_ptr_stash_phys;
 };
 
-extern int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
+extern int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
 #endif

commit af3cfdbf56b91785650f54e7c9a899d814b4b9fb
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jan 26 18:33:44 2015 +0000

    arm64: kernel: remove ARM64_CPU_SUSPEND config option
    
    ARM64_CPU_SUSPEND config option was introduced to make code providing
    context save/restore selectable only on platforms requiring power
    management capabilities.
    
    Currently ARM64_CPU_SUSPEND depends on the PM_SLEEP config option which
    in turn is set by the SUSPEND config option.
    
    The introduction of CPU_IDLE for arm64 requires that code configured
    by ARM64_CPU_SUSPEND (context save/restore) should be compiled in
    in order to enable the CPU idle driver to rely on CPU operations
    carrying out context save/restore.
    
    The ARM64_CPUIDLE config option (ARM64 generic idle driver) is therefore
    forced to select ARM64_CPU_SUSPEND, even if there may be (ie PM_SLEEP)
    failed dependencies, which is not a clean way of handling the kernel
    configuration option.
    
    For these reasons, this patch removes the ARM64_CPU_SUSPEND config option
    and makes the context save/restore dependent on CPU_PM, which is selected
    whenever either SUSPEND or CPU_IDLE are configured, cleaning up dependencies
    in the process.
    
    This way, code previously configured through ARM64_CPU_SUSPEND is
    compiled in whenever a power management subsystem requires it to be
    present in the kernel (SUSPEND || CPU_IDLE), which is the behaviour
    expected on ARM64 kernels.
    
    The cpu_suspend and cpu_init_idle CPU operations are added only if
    CPU_IDLE is selected, since they are CPU_IDLE specific methods and
    should be grouped and defined accordingly.
    
    PSCI CPU operations are updated to reflect the introduced changes.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index 456d67c1f0fa..003802f58963 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -23,6 +23,4 @@ struct sleep_save_sp {
 
 extern int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
-extern int cpu_suspend(unsigned long);
-
 #endif

commit 714f59925595b9c2ea9c22b107b340d38e3b3bc9
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Aug 7 14:54:50 2014 +0100

    arm64: kernel: refactor the CPU suspend API for retention states
    
    CPU suspend is the standard kernel interface to be used to enter
    low-power states on ARM64 systems. Current cpu_suspend implementation
    by default assumes that all low power states are losing the CPU context,
    so the CPU registers must be saved and cleaned to DRAM upon state
    entry. Furthermore, the current cpu_suspend() implementation assumes
    that if the CPU suspend back-end method returns when called, this has
    to be considered an error regardless of the return code (which can be
    successful) since the CPU was not expected to return from a code path that
    is different from cpu_resume code path - eg returning from the reset vector.
    
    All in all this means that the current API does not cope well with low-power
    states that preserve the CPU context when entered (ie retention states),
    since first of all the context is saved for nothing on state entry for
    those states and a successful state entry can return as a normal function
    return, which is considered an error by the current CPU suspend
    implementation.
    
    This patch refactors the cpu_suspend() API so that it can be split in
    two separate functionalities. The arm64 cpu_suspend API just provides
    a wrapper around CPU suspend operation hook. A new function is
    introduced (for architecture code use only) for states that require
    context saving upon entry:
    
    __cpu_suspend(unsigned long arg, int (*fn)(unsigned long))
    
    __cpu_suspend() saves the context on function entry and calls the
    so called suspend finisher (ie fn) to complete the suspend operation.
    The finisher is not expected to return, unless it fails in which case
    the error is propagated back to the __cpu_suspend caller.
    
    The API refactoring results in the following pseudo code call sequence for a
    suspending CPU, when triggered from a kernel subsystem:
    
    /*
     * int cpu_suspend(unsigned long idx)
     * @idx: idle state index
     */
    {
    -> cpu_suspend(idx)
            |---> CPU operations suspend hook called, if present
                    |--> if (retention_state)
                            |--> direct suspend back-end call (eg PSCI suspend)
                         else
                            |--> __cpu_suspend(idx, &back_end_finisher);
    }
    
    By refactoring the cpu_suspend API this way, the CPU operations back-end
    has a chance to detect whether idle states require state saving or not
    and can call the required suspend operations accordingly either through
    simple function call or indirectly through __cpu_suspend() which carries out
    state saving and suspend finisher dispatching to complete idle state entry.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index e9c149c042e0..456d67c1f0fa 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -21,6 +21,7 @@ struct sleep_save_sp {
 	phys_addr_t save_ptr_stash_phys;
 };
 
+extern int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
 extern void cpu_resume(void);
 extern int cpu_suspend(unsigned long);
 

commit 95322526ef62b84adb469c27535ab0252a369a85
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jul 22 12:22:13 2013 +0100

    arm64: kernel: cpu_{suspend/resume} implementation
    
    Kernel subsystems like CPU idle and suspend to RAM require a generic
    mechanism to suspend a processor, save its context and put it into
    a quiescent state. The cpu_{suspend}/{resume} implementation provides
    such a framework through a kernel interface allowing to save/restore
    registers, flush the context to DRAM and suspend/resume to/from
    low-power states where processor context may be lost.
    
    The CPU suspend implementation relies on the suspend protocol registered
    in CPU operations to carry out a suspend request after context is
    saved and flushed to DRAM. The cpu_suspend interface:
    
    int cpu_suspend(unsigned long arg);
    
    allows to pass an opaque parameter that is handed over to the suspend CPU
    operations back-end so that it can take action according to the
    semantics attached to it. The arg parameter allows suspend to RAM and CPU
    idle drivers to communicate to suspend protocol back-ends; it requires
    standardization so that the interface can be reused seamlessly across
    systems, paving the way for generic drivers.
    
    Context memory is allocated on the stack, whose address is stashed in a
    per-cpu variable to keep track of it and passed to core functions that
    save/restore the registers required by the architecture.
    
    Even though, upon successful execution, the cpu_suspend function shuts
    down the suspending processor, the warm boot resume mechanism, based
    on the cpu_resume function, makes the resume path operate as a
    cpu_suspend function return, so that cpu_suspend can be treated as a C
    function by the caller, which simplifies coding the PM drivers that rely
    on the cpu_suspend API.
    
    Upon context save, the minimal amount of memory is flushed to DRAM so
    that it can be retrieved when the MMU is off and caches are not searched.
    
    The suspend CPU operation, depending on the required operations (eg CPU vs
    Cluster shutdown) is in charge of flushing the cache hierarchy either
    implicitly (by calling firmware implementations like PSCI) or explicitly
    by executing the required cache maintainance functions.
    
    Debug exceptions are disabled during cpu_{suspend}/{resume} operations
    so that debug registers can be saved and restored properly preventing
    preemption from debug agents enabled in the kernel.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
index a88558e223da..e9c149c042e0 100644
--- a/arch/arm64/include/asm/suspend.h
+++ b/arch/arm64/include/asm/suspend.h
@@ -15,4 +15,13 @@ struct cpu_suspend_ctx {
 	u64 ctx_regs[NR_CTX_REGS];
 	u64 sp;
 } __aligned(16);
+
+struct sleep_save_sp {
+	phys_addr_t *save_ptr_stash;
+	phys_addr_t save_ptr_stash_phys;
+};
+
+extern void cpu_resume(void);
+extern int cpu_suspend(unsigned long);
+
 #endif

commit 6732bc65c277b697f6d8b645b15f63d1558c0cc4
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jul 17 10:14:45 2013 +0100

    arm64: kernel: suspend/resume registers save/restore
    
    Power management software requires the kernel to save and restore
    CPU registers while going through suspend and resume operations
    triggered by kernel subsystems like CPU idle and suspend to RAM.
    
    This patch implements code that provides save and restore mechanism
    for the arm v8 implementation. Memory for the context is passed as
    parameter to both cpu_do_suspend and cpu_do_resume functions, and allows
    the callers to implement context allocation as they deem fit.
    
    The registers that are saved and restored correspond to the registers set
    actually required by the kernel to be up and running which represents a
    subset of v8 ISA.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/include/asm/suspend.h b/arch/arm64/include/asm/suspend.h
new file mode 100644
index 000000000000..a88558e223da
--- /dev/null
+++ b/arch/arm64/include/asm/suspend.h
@@ -0,0 +1,18 @@
+#ifndef __ASM_SUSPEND_H
+#define __ASM_SUSPEND_H
+
+#define NR_CTX_REGS 11
+
+/*
+ * struct cpu_suspend_ctx must be 16-byte aligned since it is allocated on
+ * the stack, which must be 16-byte aligned on v8
+ */
+struct cpu_suspend_ctx {
+	/*
+	 * This struct must be kept in sync with
+	 * cpu_do_{suspend/resume} in mm/proc.S
+	 */
+	u64 ctx_regs[NR_CTX_REGS];
+	u64 sp;
+} __aligned(16);
+#endif
