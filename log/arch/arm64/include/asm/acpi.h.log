commit a194c33f45f83068ef13bf1d16e26d4ca3ecc098
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Mon Jun 8 13:38:17 2020 -0700

    arm64: acpi: fix UBSAN warning
    
    Will reported a UBSAN warning:
    
    UBSAN: null-ptr-deref in arch/arm64/kernel/smp.c:596:6
    member access within null pointer of type 'struct acpi_madt_generic_interrupt'
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.7.0-rc6-00124-g96bc42ff0a82 #1
    Call trace:
     dump_backtrace+0x0/0x384
     show_stack+0x28/0x38
     dump_stack+0xec/0x174
     handle_null_ptr_deref+0x134/0x174
     __ubsan_handle_type_mismatch_v1+0x84/0xa4
     acpi_parse_gic_cpu_interface+0x60/0xe8
     acpi_parse_entries_array+0x288/0x498
     acpi_table_parse_entries_array+0x178/0x1b4
     acpi_table_parse_madt+0xa4/0x110
     acpi_parse_and_init_cpus+0x38/0x100
     smp_init_cpus+0x74/0x258
     setup_arch+0x350/0x3ec
     start_kernel+0x98/0x6f4
    
    This is from the use of the ACPI_OFFSET in
    arch/arm64/include/asm/acpi.h. Replace its use with offsetof from
    include/linux/stddef.h which should implement the same logic using
    __builtin_offsetof, so that UBSAN wont warn.
    
    Reported-by: Will Deacon <will@kernel.org>
    Suggested-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Jeremy Linton <jeremy.linton@arm.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/lkml/20200521100952.GA5360@willie-the-truck/
    Link: https://lore.kernel.org/r/20200608203818.189423-1-ndesaulniers@google.com
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index b263e239cb59..a45366c3909b 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,6 +12,7 @@
 #include <linux/efi.h>
 #include <linux/memblock.h>
 #include <linux/psci.h>
+#include <linux/stddef.h>
 
 #include <asm/cputype.h>
 #include <asm/io.h>
@@ -31,14 +32,14 @@
  * is therefore used to delimit the MADT GICC structure minimum length
  * appropriately.
  */
-#define ACPI_MADT_GICC_MIN_LENGTH   ACPI_OFFSET(  \
+#define ACPI_MADT_GICC_MIN_LENGTH   offsetof(  \
 	struct acpi_madt_generic_interrupt, efficiency_class)
 
 #define BAD_MADT_GICC_ENTRY(entry, end)					\
 	(!(entry) || (entry)->header.length < ACPI_MADT_GICC_MIN_LENGTH || \
 	(unsigned long)(entry) + (entry)->header.length > (end))
 
-#define ACPI_MADT_GICC_SPE  (ACPI_OFFSET(struct acpi_madt_generic_interrupt, \
+#define ACPI_MADT_GICC_SPE  (offsetof(struct acpi_madt_generic_interrupt, \
 	spe_interrupt) + sizeof(u16))
 
 /* Basic configuration for ACPI */

commit dfd437a257924484b144ee750e60affc95562c6d
Merge: 0ecfebd2b524 0c61efd322b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 09:54:55 2019 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - arm64 support for syscall emulation via PTRACE_SYSEMU{,_SINGLESTEP}
    
     - Wire up VM_FLUSH_RESET_PERMS for arm64, allowing the core code to
       manage the permissions of executable vmalloc regions more strictly
    
     - Slight performance improvement by keeping softirqs enabled while
       touching the FPSIMD/SVE state (kernel_neon_begin/end)
    
     - Expose a couple of ARMv8.5 features to user (HWCAP): CondM (new
       XAFLAG and AXFLAG instructions for floating point comparison flags
       manipulation) and FRINT (rounding floating point numbers to integers)
    
     - Re-instate ARM64_PSEUDO_NMI support which was previously marked as
       BROKEN due to some bugs (now fixed)
    
     - Improve parking of stopped CPUs and implement an arm64-specific
       panic_smp_self_stop() to avoid warning on not being able to stop
       secondary CPUs during panic
    
     - perf: enable the ARM Statistical Profiling Extensions (SPE) on ACPI
       platforms
    
     - perf: DDR performance monitor support for iMX8QXP
    
     - cache_line_size() can now be set from DT or ACPI/PPTT if provided to
       cope with a system cache info not exposed via the CPUID registers
    
     - Avoid warning on hardware cache line size greater than
       ARCH_DMA_MINALIGN if the system is fully coherent
    
     - arm64 do_page_fault() and hugetlb cleanups
    
     - Refactor set_pte_at() to avoid redundant READ_ONCE(*ptep)
    
     - Ignore ACPI 5.1 FADTs reported as 5.0 (infer from the
       'arm_boot_flags' introduced in 5.1)
    
     - CONFIG_RANDOMIZE_BASE now enabled in defconfig
    
     - Allow the selection of ARM64_MODULE_PLTS, currently only done via
       RANDOMIZE_BASE (and an erratum workaround), allowing modules to spill
       over into the vmalloc area
    
     - Make ZONE_DMA32 configurable
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (54 commits)
      perf: arm_spe: Enable ACPI/Platform automatic module loading
      arm_pmu: acpi: spe: Add initial MADT/SPE probing
      ACPI/PPTT: Add function to return ACPI 6.3 Identical tokens
      ACPI/PPTT: Modify node flag detection to find last IDENTICAL
      x86/entry: Simplify _TIF_SYSCALL_EMU handling
      arm64: rename dump_instr as dump_kernel_instr
      arm64/mm: Drop [PTE|PMD]_TYPE_FAULT
      arm64: Implement panic_smp_self_stop()
      arm64: Improve parking of stopped CPUs
      arm64: Expose FRINT capabilities to userspace
      arm64: Expose ARMv8.5 CondM capability to userspace
      arm64: defconfig: enable CONFIG_RANDOMIZE_BASE
      arm64: ARM64_MODULES_PLTS must depend on MODULES
      arm64: bpf: do not allocate executable memory
      arm64/kprobes: set VM_FLUSH_RESET_PERMS on kprobe instruction pages
      arm64/mm: wire up CONFIG_ARCH_HAS_SET_DIRECT_MAP
      arm64: module: create module allocations without exec permissions
      arm64: Allow user selection of ARM64_MODULE_PLTS
      acpi/arm64: ignore 5.1 FADTs that are reported as 5.0
      arm64: Allow selecting Pseudo-NMI again
      ...

commit d24a0c7099b32b6981d7f126c45348e381718350
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Wed Jun 26 16:37:17 2019 -0500

    arm_pmu: acpi: spe: Add initial MADT/SPE probing
    
    ACPI 6.3 adds additional fields to the MADT GICC
    structure to describe SPE PPI's. We pick these out
    of the cached reference to the madt_gicc structure
    similarly to the core PMU code. We then create a platform
    device referring to the IRQ and let the user/module loader
    decide whether to load the SPE driver.
    
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 7628efbe6c12..d10399b9f998 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -41,6 +41,9 @@
 	(!(entry) || (entry)->header.length < ACPI_MADT_GICC_MIN_LENGTH || \
 	(unsigned long)(entry) + (entry)->header.length > (end))
 
+#define ACPI_MADT_GICC_SPE  (ACPI_OFFSET(struct acpi_madt_generic_interrupt, \
+	spe_interrupt) + sizeof(u16))
+
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
 pgprot_t __acpi_get_mem_attribute(phys_addr_t addr);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 7628efbe6c12..ada0bc480a1b 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  Copyright (C) 2013-2014, Linaro Ltd.
  *	Author: Al Stone <al.stone@linaro.org>
  *	Author: Graeme Gregory <graeme.gregory@linaro.org>
  *	Author: Hanjun Guo <hanjun.guo@linaro.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
  */
 
 #ifndef _ASM_ACPI_H

commit d44f1b8dd7e66d80cc4205809e5ace866bd851da
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:50 2019 +0000

    arm64: KVM/mm: Move SEA handling behind a single 'claim' interface
    
    To split up APEIs in_nmi() path, the caller needs to always be
    in_nmi(). Add a helper to do the work and claim the notification.
    
    When KVM or the arch code takes an exception that might be a RAS
    notification, it asks the APEI firmware-first code whether it wants
    to claim the exception. A future kernel-first mechanism may be queried
    afterwards, and claim the notification, otherwise we fall through
    to the existing default behaviour.
    
    The NOTIFY_SEA code was merged before considering multiple, possibly
    interacting, NMI-like notifications and the need to consider kernel
    first in the future. Make the 'claiming' behaviour explicit.
    
    Restructuring the APEI code to allow multiple NMI-like notifications
    means any notification that might interrupt interrupts-masked
    code must always be wrapped in nmi_enter()/nmi_exit(). This will
    allow APEI to use in_nmi() to use the right fixmap entries.
    
    Mask SError over this window to prevent an asynchronous RAS error
    arriving and tripping 'nmi_enter()'s BUG_ON(in_nmi()).
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 2def77ec14be..7628efbe6c12 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -18,6 +18,7 @@
 
 #include <asm/cputype.h>
 #include <asm/io.h>
+#include <asm/ptrace.h>
 #include <asm/smp_plat.h>
 #include <asm/tlbflush.h>
 
@@ -110,9 +111,10 @@ static inline u32 get_acpi_id_for_cpu(unsigned int cpu)
 
 static inline void arch_fix_phys_package_id(int num, u32 slot) { }
 void __init acpi_init_cpus(void);
-
+int apei_claim_sea(struct pt_regs *regs);
 #else
 static inline void acpi_init_cpus(void) { }
+static inline int apei_claim_sea(struct pt_regs *regs) { return -ENOENT; }
 #endif /* CONFIG_ACPI */
 
 #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL

commit 9eb1c92b47c73249465d388eaa394fe436a3b489
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Tue Nov 27 17:59:12 2018 +0000

    arm64: acpi: Prepare for longer MADTs
    
    The BAD_MADT_GICC_ENTRY check is a little too strict because
    it rejects MADT entries that don't match the currently known
    lengths. We should remove this restriction to avoid problems
    if the table length changes. Future code which might depend on
    additional fields should be written to validate those fields
    before using them, rather than trying to globally check
    known MADT version lengths.
    
    Link: https://lkml.kernel.org/r/20181012192937.3819951-1-jeremy.linton@arm.com
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    [lorenzo.pieralisi@arm.com: added MADT macro comments]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Al Stone <ahs3@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 709208dfdc8b..2def77ec14be 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -22,12 +22,23 @@
 #include <asm/tlbflush.h>
 
 /* Macros for consistency checks of the GICC subtable of MADT */
-#define ACPI_MADT_GICC_LENGTH	\
-	(acpi_gbl_FADT.header.revision < 6 ? 76 : 80)
+
+/*
+ * MADT GICC minimum length refers to the MADT GICC structure table length as
+ * defined in the earliest ACPI version supported on arm64, ie ACPI 5.1.
+ *
+ * The efficiency_class member was added to the
+ * struct acpi_madt_generic_interrupt to represent the MADT GICC structure
+ * "Processor Power Efficiency Class" field, added in ACPI 6.0 whose offset
+ * is therefore used to delimit the MADT GICC structure minimum length
+ * appropriately.
+ */
+#define ACPI_MADT_GICC_MIN_LENGTH   ACPI_OFFSET(  \
+	struct acpi_madt_generic_interrupt, efficiency_class)
 
 #define BAD_MADT_GICC_ENTRY(entry, end)					\
-	(!(entry) || (entry)->header.length != ACPI_MADT_GICC_LENGTH ||	\
-	(unsigned long)(entry) + ACPI_MADT_GICC_LENGTH > (end))
+	(!(entry) || (entry)->header.length < ACPI_MADT_GICC_MIN_LENGTH || \
+	(unsigned long)(entry) + (entry)->header.length > (end))
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI

commit 09ffcb0d718a0b100f0bed029b830987ecf53fab
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Mon Jul 23 10:57:32 2018 +0900

    arm64: acpi: fix alignment fault in accessing ACPI
    
    This is a fix against the issue that crash dump kernel may hang up
    during booting, which can happen on any ACPI-based system with "ACPI
    Reclaim Memory."
    
    (kernel messages after panic kicked off kdump)
               (snip...)
            Bye!
               (snip...)
            ACPI: Core revision 20170728
            pud=000000002e7d0003, *pmd=000000002e7c0003, *pte=00e8000039710707
            Internal error: Oops: 96000021 [#1] SMP
            Modules linked in:
            CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.14.0-rc6 #1
            task: ffff000008d05180 task.stack: ffff000008cc0000
            PC is at acpi_ns_lookup+0x25c/0x3c0
            LR is at acpi_ds_load1_begin_op+0xa4/0x294
               (snip...)
            Process swapper/0 (pid: 0, stack limit = 0xffff000008cc0000)
            Call trace:
               (snip...)
            [<ffff0000084a6764>] acpi_ns_lookup+0x25c/0x3c0
            [<ffff00000849b4f8>] acpi_ds_load1_begin_op+0xa4/0x294
            [<ffff0000084ad4ac>] acpi_ps_build_named_op+0xc4/0x198
            [<ffff0000084ad6cc>] acpi_ps_create_op+0x14c/0x270
            [<ffff0000084acfa8>] acpi_ps_parse_loop+0x188/0x5c8
            [<ffff0000084ae048>] acpi_ps_parse_aml+0xb0/0x2b8
            [<ffff0000084a8e10>] acpi_ns_one_complete_parse+0x144/0x184
            [<ffff0000084a8e98>] acpi_ns_parse_table+0x48/0x68
            [<ffff0000084a82cc>] acpi_ns_load_table+0x4c/0xdc
            [<ffff0000084b32f8>] acpi_tb_load_namespace+0xe4/0x264
            [<ffff000008baf9b4>] acpi_load_tables+0x48/0xc0
            [<ffff000008badc20>] acpi_early_init+0x9c/0xd0
            [<ffff000008b70d50>] start_kernel+0x3b4/0x43c
            Code: b9008fb9 2a000318 36380054 32190318 (b94002c0)
            ---[ end trace c46ed37f9651c58e ]---
            Kernel panic - not syncing: Fatal exception
            Rebooting in 10 seconds..
    
    (diagnosis)
    * This fault is a data abort, alignment fault (ESR=0x96000021)
      during reading out ACPI table.
    * Initial ACPI tables are normally stored in system ram and marked as
      "ACPI Reclaim memory" by the firmware.
    * After the commit f56ab9a5b73c ("efi/arm: Don't mark ACPI reclaim
      memory as MEMBLOCK_NOMAP"), those regions are differently handled
      as they are "memblock-reserved", without NOMAP bit.
    * So they are now excluded from device tree's "usable-memory-range"
      which kexec-tools determines based on a current view of /proc/iomem.
    * When crash dump kernel boots up, it tries to accesses ACPI tables by
      mapping them with ioremap(), not ioremap_cache(), in acpi_os_ioremap()
      since they are no longer part of mapped system ram.
    * Given that ACPI accessor/helper functions are compiled in without
      unaligned access support (ACPI_MISALIGNMENT_NOT_SUPPORTED),
      any unaligned access to ACPI tables can cause a fatal panic.
    
    With this patch, acpi_os_ioremap() always honors memory attribute
    information provided by the firmware (EFI) and retaining cacheability
    allows the kernel safe access to ACPI tables.
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Reviewed-by: James Morse <james.morse@arm.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reported-by and Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index d1c290f29b6f..709208dfdc8b 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,10 +12,12 @@
 #ifndef _ASM_ACPI_H
 #define _ASM_ACPI_H
 
+#include <linux/efi.h>
 #include <linux/memblock.h>
 #include <linux/psci.h>
 
 #include <asm/cputype.h>
+#include <asm/io.h>
 #include <asm/smp_plat.h>
 #include <asm/tlbflush.h>
 
@@ -29,18 +31,22 @@
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
+pgprot_t __acpi_get_mem_attribute(phys_addr_t addr);
+
 /* ACPI table mapping after acpi_permanent_mmap is set */
 static inline void __iomem *acpi_os_ioremap(acpi_physical_address phys,
 					    acpi_size size)
 {
+	/* For normal memory we already have a cacheable mapping. */
+	if (memblock_is_map_memory(phys))
+		return (void __iomem *)__phys_to_virt(phys);
+
 	/*
-	 * EFI's reserve_regions() call adds memory with the WB attribute
-	 * to memblock via early_init_dt_add_memory_arch().
+	 * We should still honor the memory's attribute here because
+	 * crash dump kernel possibly excludes some ACPI (reclaim)
+	 * regions from memblock list.
 	 */
-	if (!memblock_is_memory(phys))
-		return ioremap(phys, size);
-
-	return ioremap_cache(phys, size);
+	return __ioremap(phys, size, __acpi_get_mem_attribute(phys));
 }
 #define acpi_os_ioremap acpi_os_ioremap
 
@@ -129,7 +135,10 @@ static inline const char *acpi_get_enable_method(int cpu)
  * for compatibility.
  */
 #define acpi_disable_cmcff 1
-pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
+static inline pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)
+{
+	return __acpi_get_mem_attribute(addr);
+}
 #endif /* CONFIG_ACPI_APEI */
 
 #ifdef CONFIG_ACPI_NUMA

commit e189624916961c735c18e3c75acc478661403830
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jun 25 14:05:52 2018 +0100

    arm64: numa: rework ACPI NUMA initialization
    
    Current ACPI ARM64 NUMA initialization code in
    
    acpi_numa_gicc_affinity_init()
    
    carries out NUMA nodes creation and cpu<->node mappings at the same time
    in the arch backend so that a single SRAT walk is needed to parse both
    pieces of information.  This implies that the cpu<->node mappings must
    be stashed in an array (sized NR_CPUS) so that SMP code can later use
    the stashed values to avoid another SRAT table walk to set-up the early
    cpu<->node mappings.
    
    If the kernel is configured with a NR_CPUS value less than the actual
    processor entries in the SRAT (and MADT), the logic in
    acpi_numa_gicc_affinity_init() is broken in that the cpu<->node mapping
    is only carried out (and stashed for future use) only for a number of
    SRAT entries up to NR_CPUS, which do not necessarily correspond to the
    possible cpus detected at SMP initialization in
    acpi_map_gic_cpu_interface() (ie MADT and SRAT processor entries order
    is not enforced), which leaves the kernel with broken cpu<->node
    mappings.
    
    Furthermore, given the current ACPI NUMA code parsing logic in
    acpi_numa_gicc_affinity_init(), PXM domains for CPUs that are not parsed
    because they exceed NR_CPUS entries are not mapped to NUMA nodes (ie the
    PXM corresponding node is not created in the kernel) leaving the system
    with a broken NUMA topology.
    
    Rework the ACPI ARM64 NUMA initialization process so that the NUMA
    nodes creation and cpu<->node mappings are decoupled. cpu<->node
    mappings are moved to SMP initialization code (where they are needed),
    at the cost of an extra SRAT walk so that ACPI NUMA mappings can be
    batched before being applied, fixing current parsing pitfalls.
    
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: John Garry <john.garry@huawei.com>
    Fixes: d8b47fca8c23 ("arm64, ACPI, NUMA: NUMA support based on SRAT and
    SLIT")
    Link: http://lkml.kernel.org/r/1527768879-88161-2-git-send-email-xiexiuqi@huawei.com
    Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Punit Agrawal <punit.agrawal@arm.com>
    Cc: Jonathan Cameron <jonathan.cameron@huawei.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <guohanjun@huawei.com>
    Cc: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
    Cc: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Xie XiuQi <xiexiuqi@huawei.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 0db62a4cbce2..d1c290f29b6f 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -134,10 +134,12 @@ pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
 
 #ifdef CONFIG_ACPI_NUMA
 int arm64_acpi_numa_init(void);
-int acpi_numa_get_nid(unsigned int cpu, u64 hwid);
+int acpi_numa_get_nid(unsigned int cpu);
+void acpi_map_cpus_to_nodes(void);
 #else
 static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }
-static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }
+static inline int acpi_numa_get_nid(unsigned int cpu) { return NUMA_NO_NODE; }
+static inline void acpi_map_cpus_to_nodes(void) { }
 #endif /* CONFIG_ACPI_NUMA */
 
 #define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE

commit 30d87bfacbee396646975a00959764a7c49510ec
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Fri May 11 18:57:59 2018 -0500

    arm64/acpi: Create arch specific cpu to acpi id helper
    
    Its helpful to be able to lookup the acpi_processor_id associated
    with a logical cpu. Provide an arm64 helper to do this.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Vijaya Kumar K <vkilari@codeaurora.org>
    Tested-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Tested-by: Tomasz Nowicki <Tomasz.Nowicki@cavium.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 32f465a80e4e..0db62a4cbce2 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -86,6 +86,10 @@ static inline bool acpi_has_cpu_in_madt(void)
 }
 
 struct acpi_madt_generic_interrupt *acpi_cpu_get_madt_gicc(int cpu);
+static inline u32 get_acpi_id_for_cpu(unsigned int cpu)
+{
+	return	acpi_cpu_get_madt_gicc(cpu)->uid;
+}
 
 static inline void arch_fix_phys_package_id(int num, u32 slot) { }
 void __init acpi_init_cpus(void);

commit 18b4b276b490a8b9f86c512de8a6054c27bb87c2
Author: James Morse <james.morse@arm.com>
Date:   Mon Nov 6 18:44:26 2017 +0000

    arm64: mm: Remove arch_apei_flush_tlb_one()
    
    Nothing calls arch_apei_flush_tlb_one() anymore, instead relying on
    __set_fixmap() to do the invalidation. Remove it.
    
    Move the IPI-considered-harmful comment to __set_fixmap().
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 59cca1d6ec54..32f465a80e4e 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -126,18 +126,6 @@ static inline const char *acpi_get_enable_method(int cpu)
  */
 #define acpi_disable_cmcff 1
 pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
-
-/*
- * Despite its name, this function must still broadcast the TLB
- * invalidation in order to ensure other CPUs don't end up with junk
- * entries as a result of speculation. Unusually, its also called in
- * IRQ context (ghes_iounmap_irq) so if we ever need to use IPIs for
- * TLB broadcasting, then we're in trouble here.
- */
-static inline void arch_apei_flush_tlb_one(unsigned long addr)
-{
-	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);
-}
 #endif /* CONFIG_ACPI_APEI */
 
 #ifdef CONFIG_ACPI_NUMA

commit cb7cf772d83d2d4e6995c5bb9e0fb59aea8f7080
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri May 26 17:40:02 2017 +0100

    ARM64/ACPI: Fix BAD_MADT_GICC_ENTRY() macro implementation
    
    The BAD_MADT_GICC_ENTRY() macro checks if a GICC MADT entry passes
    muster from an ACPI specification standpoint. Current macro detects the
    MADT GICC entry length through ACPI firmware version (it changed from 76
    to 80 bytes in the transition from ACPI 5.1 to ACPI 6.0 specification)
    but always uses (erroneously) the ACPICA (latest) struct (ie struct
    acpi_madt_generic_interrupt - that is 80-bytes long) length to check if
    the current GICC entry memory record exceeds the MADT table end in
    memory as defined by the MADT table header itself, which may result in
    false negatives depending on the ACPI firmware version and how the MADT
    entries are laid out in memory (ie on ACPI 5.1 firmware MADT GICC
    entries are 76 bytes long, so by adding 80 to a GICC entry start address
    in memory the resulting address may well be past the actual MADT end,
    triggering a false negative).
    
    Fix the BAD_MADT_GICC_ENTRY() macro by reshuffling the condition checks
    and update them to always use the firmware version specific MADT GICC
    entry length in order to carry out boundary checks.
    
    Fixes: b6cfb277378e ("ACPI / ARM64: add BAD_MADT_GICC_ENTRY() macro")
    Reported-by: Julien Grall <julien.grall@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Julien Grall <julien.grall@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Al Stone <ahs3@redhat.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 0e99978da3f0..59cca1d6ec54 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -23,9 +23,9 @@
 #define ACPI_MADT_GICC_LENGTH	\
 	(acpi_gbl_FADT.header.revision < 6 ? 76 : 80)
 
-#define BAD_MADT_GICC_ENTRY(entry, end)						\
-	(!(entry) || (unsigned long)(entry) + sizeof(*(entry)) > (end) ||	\
-	 (entry)->header.length != ACPI_MADT_GICC_LENGTH)
+#define BAD_MADT_GICC_ENTRY(entry, end)					\
+	(!(entry) || (entry)->header.length != ACPI_MADT_GICC_LENGTH ||	\
+	(unsigned long)(entry) + ACPI_MADT_GICC_LENGTH > (end))
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI

commit e0013aed489e7ebbba59d7ada2ff5551ac4b61c6
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Apr 11 09:39:54 2017 +0100

    arm64: add function to get a cpu's MADT GICC table
    
    Currently the ACPI parking protocol code needs to parse each CPU's MADT
    GICC table to extract the mailbox address and so on. Each time we parse
    a GICC table, we call back to the parking protocol code to parse it.
    
    This has been fine so far, but we're about to have more code that needs
    to extract data from the GICC tables, and adding a callback for each
    user is going to get unwieldy.
    
    Instead, this patch ensures that we stash a copy of each CPU's GICC
    table at boot time, such that anything needing to parse it can later
    request it. This will allow for other parsers of GICC, and for
    simplification to the ACPI parking protocol code. Note that we must
    store a copy, rather than a pointer, since the core ACPI code
    temporarily maps/unmaps tables while iterating over them.
    
    Since we parse the MADT before we know how many CPUs we have (and hence
    before we setup the percpu areas), we must use an NR_CPUS sized array.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index c1976c0adca7..0e99978da3f0 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -85,6 +85,8 @@ static inline bool acpi_has_cpu_in_madt(void)
 	return true;
 }
 
+struct acpi_madt_generic_interrupt *acpi_cpu_get_madt_gicc(int cpu);
+
 static inline void arch_fix_phys_package_id(int num, u32 slot) { }
 void __init acpi_init_cpus(void);
 

commit c8e008e2a6f9ec007a0e22e18eeb5bace5bf16c8
Merge: 7ae123edd37a 8d3523fb3b72 7020bcb82838
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 22 14:34:24 2016 +0100

    Merge branches 'acpica' and 'acpi-scan'
    
    * acpica:
      ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
      ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
      ACPICA: Tables: Allow FADT to be customized with virtual address
      ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel
    
    * acpi-scan:
      ACPI: do not warn if _BQC does not exist

commit 8d3523fb3b727478ac528b307cb84460faa1c39e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:46 2016 +0800

    ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
    
    Since all users are cleaned up, remove the 2 deprecated APIs due to no
    users.
    As a Linux variable rather than an ACPICA variable, acpi_gbl_permanent_mmap
    is renamed to acpi_permanent_mmap to have a consistent coding style across
    entire Linux ACPI subsystem.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index e517088d635f..8957ff8b3dd4 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -28,7 +28,7 @@
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
-/* ACPI table mapping after acpi_gbl_permanent_mmap is set */
+/* ACPI table mapping after acpi_permanent_mmap is set */
 static inline void __iomem *acpi_os_ioremap(acpi_physical_address phys,
 					    acpi_size size)
 {

commit 9f9a35a7b654e006250530425eb1fb527f0d32e9
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Thu Dec 1 21:51:12 2016 +0800

    ACPI / APEI / ARM64: APEI initial support for ARM64
    
    This patch provides APEI arch-specific bits for ARM64
    
    Meanwhile,
     (1) Move HEST type (ACPI_HEST_TYPE_IA32_CORRECTED_CHECK) checking to
         a generic place.
     (2) Select HAVE_ACPI_APEI when EFI and ACPI is set on ARM64, because
         arch_apei_get_mem_attribute is using efi_mem_attributes() on
         ARM64.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Tested-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Fu Wei <fu.wei@linaro.org>
    [ Fu Wei: improve && upstream ]
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index e517088d635f..d0de0e032bc2 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -17,6 +17,7 @@
 
 #include <asm/cputype.h>
 #include <asm/smp_plat.h>
+#include <asm/tlbflush.h>
 
 /* Macros for consistency checks of the GICC subtable of MADT */
 #define ACPI_MADT_GICC_LENGTH	\
@@ -114,8 +115,28 @@ static inline const char *acpi_get_enable_method(int cpu)
 }
 
 #ifdef	CONFIG_ACPI_APEI
+/*
+ * acpi_disable_cmcff is used in drivers/acpi/apei/hest.c for disabling
+ * IA-32 Architecture Corrected Machine Check (CMC) Firmware-First mode
+ * with a kernel command line parameter "acpi=nocmcoff". But we don't
+ * have this IA-32 specific feature on ARM64, this definition is only
+ * for compatibility.
+ */
+#define acpi_disable_cmcff 1
 pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
-#endif
+
+/*
+ * Despite its name, this function must still broadcast the TLB
+ * invalidation in order to ensure other CPUs don't end up with junk
+ * entries as a result of speculation. Unusually, its also called in
+ * IRQ context (ghes_iounmap_irq) so if we ever need to use IPIs for
+ * TLB broadcasting, then we're in trouble here.
+ */
+static inline void arch_apei_flush_tlb_one(unsigned long addr)
+{
+	flush_tlb_kernel_range(addr, addr + PAGE_SIZE);
+}
+#endif /* CONFIG_ACPI_APEI */
 
 #ifdef CONFIG_ACPI_NUMA
 int arm64_acpi_numa_init(void);

commit e7cd190385d17790cc3eb3821b1094b00aacf325
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Mon Aug 22 15:55:24 2016 +0900

    arm64: mark reserved memblock regions explicitly in iomem
    
    Kdump(kexec-tools) parses /proc/iomem to identify all the memory regions
    on the system. Since the current kernel names "nomap" regions, like UEFI
    runtime services code/data, as "System RAM," kexec-tools sets up elf core
    header to include them in a crash dump file (/proc/vmcore).
    
    Then crash dump kernel parses UEFI memory map again, re-marks those regions
    as "nomap" and does not create a memory mapping for them unlike the other
    areas of System RAM. In this case, copying /proc/vmcore through
    copy_oldmem_page() on crash dump kernel will end up with a kernel abort,
    as reported in [1].
    
    This patch names all the "nomap" regions explicitly as "reserved" so that
    we can exclude them from a crash dump file. acpi_os_ioremap() must also
    be modified because those regions have WB attributes [2].
    
    Apart from kdump, this change also matches x86's use of acpi (and
    /proc/iomem).
    
    [1] http://lists.infradead.org/pipermail/linux-arm-kernel/2016-August/448186.html
    [2] http://lists.infradead.org/pipermail/linux-arm-kernel/2016-August/450089.html
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: James Morse <james.morse@arm.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 5420cb0fcb3e..e517088d635f 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,7 +12,7 @@
 #ifndef _ASM_ACPI_H
 #define _ASM_ACPI_H
 
-#include <linux/mm.h>
+#include <linux/memblock.h>
 #include <linux/psci.h>
 
 #include <asm/cputype.h>
@@ -32,7 +32,11 @@
 static inline void __iomem *acpi_os_ioremap(acpi_physical_address phys,
 					    acpi_size size)
 {
-	if (!page_is_ram(phys >> PAGE_SHIFT))
+	/*
+	 * EFI's reserve_regions() call adds memory with the WB attribute
+	 * to memblock via early_init_dt_add_memory_arch().
+	 */
+	if (!memblock_is_memory(phys))
 		return ioremap(phys, size);
 
 	return ioremap_cache(phys, size);

commit d5f017b796611c03d8b808d90eec0559c9049207
Merge: d85f4eb6993d fafe5306f201
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 25 13:41:01 2016 +0200

    Merge branch 'acpi-tables'
    
    * acpi-tables:
      ACPI: Rename configfs.c to acpi_configfs.c to prevent link error
      ACPI: add support for loading SSDTs via configfs
      ACPI: add support for configfs
      efi / ACPI: load SSTDs from EFI variables
      spi / ACPI: add support for ACPI reconfigure notifications
      i2c / ACPI: add support for ACPI reconfigure notifications
      ACPI: add support for ACPI reconfiguration notifiers
      ACPI / scan: fix enumeration (visited) flags for bus rescans
      ACPI / documentation: add SSDT overlays documentation
      ACPI: ARM64: support for ACPI_TABLE_UPGRADE
      ACPI / tables: introduce ARCH_HAS_ACPI_TABLE_UPGRADE
      ACPI / tables: move arch-specific symbol to asm/acpi.h
      ACPI / tables: table upgrade: refactor function definitions
      ACPI / tables: table upgrade: use cacheable map for tables
    
    Conflicts:
            arch/arm64/include/asm/acpi.h

commit 38b04a74c58749231ee706752f81f7dc7c281a15
Author: Jon Masters <jcm@redhat.com>
Date:   Mon Jun 20 13:56:13 2016 +0300

    ACPI: ARM64: support for ACPI_TABLE_UPGRADE
    
    This patch adds support for ACPI_TABLE_UPGRADE for ARM64
    
    To access initrd image we need to move initialization
    of linear mapping a bit earlier.
    
    The implementation of the feature acpi_table_upgrade()
    (drivers/acpi/tables.c) works with initrd data represented as an array
    in virtual memory.  It uses some library utility to find the redefined
    tables in that array and iterates over it to copy the data to new
    allocated memory.  So to access the initrd data via fixmap
    we need to rewrite it considerably.
    
    In x86 arch, kernel memory is already mapped by the time when
    acpi_table_upgrade() and acpi_boot_table_init() are called so I
    think that we can just move this mapping one function earlier too.
    
    Signed-off-by: Jon Masters <jcm@redhat.com>
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index aee323b13802..c7aefc56dfdd 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -113,4 +113,6 @@ static inline const char *acpi_get_enable_method(int cpu)
 pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
 #endif
 
+#define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE
+
 #endif /*_ASM_ACPI_H*/

commit d8b47fca8c233642d1a20fa4025579ebc8be6f1e
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue May 24 15:35:44 2016 -0700

    arm64, ACPI, NUMA: NUMA support based on SRAT and SLIT
    
    Introduce a new file to hold ACPI based NUMA information parsing from
    SRAT and SLIT.
    
    SRAT includes the CPU ACPI ID to Proximity Domain mappings and memory
    ranges to Proximity Domain mapping.  SLIT has the information of inter
    node distances(relative number for access latency).
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
    [rrichter@cavium.com Reworked for numa v10 series ]
    Signed-off-by: Robert Richter <rrichter@cavium.com>
    [david.daney@cavium.com reorderd and combinded with other patches in
    Hanjun Guo's original set, removed get_mpidr_in_madt() and use
    acpi_map_madt_entry() instead.]
    Signed-off-by: David Daney <david.daney@cavium.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Dennis Chen <dennis.chen@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index aee323b13802..4b13ecd3977a 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -113,4 +113,12 @@ static inline const char *acpi_get_enable_method(int cpu)
 pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
 #endif
 
+#ifdef CONFIG_ACPI_NUMA
+int arm64_acpi_numa_init(void);
+int acpi_numa_get_nid(unsigned int cpu, u64 hwid);
+#else
+static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }
+static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }
+#endif /* CONFIG_ACPI_NUMA */
+
 #endif /*_ASM_ACPI_H*/

commit 5e89c55e4ed81d7abb1ce8828db35fa389dc0e90
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Jan 26 11:10:38 2016 +0000

    arm64: kernel: implement ACPI parking protocol
    
    The SBBR and ACPI specifications allow ACPI based systems that do not
    implement PSCI (eg systems with no EL3) to boot through the ACPI parking
    protocol specification[1].
    
    This patch implements the ACPI parking protocol CPU operations, and adds
    code that eases parsing the parking protocol data structures to the
    ARM64 SMP initializion carried out at the same time as cpus enumeration.
    
    To wake-up the CPUs from the parked state, this patch implements a
    wakeup IPI for ARM64 (ie arch_send_wakeup_ipi_mask()) that mirrors the
    ARM one, so that a specific IPI is sent for wake-up purpose in order
    to distinguish it from other IPI sources.
    
    Given the current ACPI MADT parsing API, the patch implements a glue
    layer that helps passing MADT GICC data structure from SMP initialization
    code to the parking protocol implementation somewhat overriding the CPU
    operations interfaces. This to avoid creating a completely trasparent
    DT/ACPI CPU operations layer that would require creating opaque
    structure handling for CPUs data (DT represents CPU through DT nodes, ACPI
    through static MADT table entries), which seems overkill given that ACPI
    on ARM64 mandates only two booting protocols (PSCI and parking protocol),
    so there is no need for further protocol additions.
    
    Based on the original work by Mark Salter <msalter@redhat.com>
    
    [1] https://acpica.org/sites/acpica/files/MP%20Startup%20for%20ARM%20platforms.docx
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Loc Ho <lho@apm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Al Stone <ahs3@redhat.com>
    [catalin.marinas@arm.com: Added WARN_ONCE(!acpi_parking_protocol_valid() on the IPI]
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index caafd63b8092..aee323b13802 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -87,9 +87,26 @@ void __init acpi_init_cpus(void);
 static inline void acpi_init_cpus(void) { }
 #endif /* CONFIG_ACPI */
 
+#ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
+bool acpi_parking_protocol_valid(int cpu);
+void __init
+acpi_set_mailbox_entry(int cpu, struct acpi_madt_generic_interrupt *processor);
+#else
+static inline bool acpi_parking_protocol_valid(int cpu) { return false; }
+static inline void
+acpi_set_mailbox_entry(int cpu, struct acpi_madt_generic_interrupt *processor)
+{}
+#endif
+
 static inline const char *acpi_get_enable_method(int cpu)
 {
-	return acpi_psci_present() ? "psci" : NULL;
+	if (acpi_psci_present())
+		return "psci";
+
+	if (acpi_parking_protocol_valid(cpu))
+		return "parking-protocol";
+
+	return NULL;
 }
 
 #ifdef	CONFIG_ACPI_APEI

commit 0d51ce9ca1116e8f4dc87cb51db8dd250327e9bb
Merge: 41ecf1404b34 1ab68460b1d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 18:10:13 2015 -0800

    Merge tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "Quite a new features are included this time.
    
      First off, the Collaborative Processor Performance Control interface
      (version 2) defined by ACPI will now be supported on ARM64 along with
      a cpufreq frontend for CPU performance scaling.
    
      Second, ACPI gets a new infrastructure for the early probing of IRQ
      chips and clock sources (along the lines of the existing similar
      mechanism for DT).
    
      Next, the ACPI core and the generic device properties API will now
      support a recently introduced hierarchical properties extension of the
      _DSD (Device Specific Data) ACPI device configuration object.  If the
      ACPI platform firmware uses that extension to organize device
      properties in a hierarchical way, the kernel will automatically handle
      it and make those properties available to device drivers via the
      generic device properties API.
    
      It also will be possible to build the ACPICA's AML interpreter
      debugger into the kernel now and use that to diagnose AML-related
      problems more efficiently.  In the future, this should make it
      possible to single-step AML execution and do similar things.
      Interesting stuff, although somewhat experimental at this point.
    
      Finally, the PM core gets a new mechanism that can be used by device
      drivers to distinguish between suspend-to-RAM (based on platform
      firmware support) and suspend-to-idle (or other variants of system
      suspend the platform firmware is not involved in) and possibly
      optimize their device suspend/resume handling accordingly.
    
      In addition to that, some existing features are re-organized quite
      substantially.
    
      First, the ACPI-based handling of PCI host bridges on x86 and ia64 is
      unified and the common code goes into the ACPI core (so as to reduce
      code duplication and eliminate non-essential differences between the
      two architectures in that area).
    
      Second, the Operating Performance Points (OPP) framework is
      reorganized to make the code easier to find and follow.
    
      Next, the cpufreq core's sysfs interface is reorganized to get rid of
      the "primary CPU" concept for configurations in which the same
      performance scaling settings are shared between multiple CPUs.
    
      Finally, some interfaces that aren't necessary any more are dropped
      from the generic power domains framework.
    
      On top of the above we have some minor extensions, cleanups and bug
      fixes in multiple places, as usual.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150930 (Bob Moore, Lv Zheng).
    
         The most significant change is to allow the AML debugger to be
         built into the kernel.  On top of that there is an update related
         to the NFIT table (the ACPI persistent memory interface) and a few
         fixes and cleanups.
    
       - ACPI CPPC2 (Collaborative Processor Performance Control v2) support
         along with a cpufreq frontend (Ashwin Chaugule).
    
         This can only be enabled on ARM64 at this point.
    
       - New ACPI infrastructure for the early probing of IRQ chips and
         clock sources (Marc Zyngier).
    
       - Support for a new hierarchical properties extension of the ACPI
         _DSD (Device Specific Data) device configuration object allowing
         the kernel to handle hierarchical properties (provided by the
         platform firmware this way) automatically and make them available
         to device drivers via the generic device properties interface
         (Rafael Wysocki).
    
       - Generic device properties API extension to obtain an index of
         certain string value in an array of strings, along the lines of
         of_property_match_string(), but working for all of the supported
         firmware node types, and support for the "dma-names" device
         property based on it (Mika Westerberg).
    
       - ACPI core fix to parse the MADT (Multiple APIC Description Table)
         entries in the order expected by platform firmware (and mandated by
         the specification) to avoid confusion on systems with more than 255
         logical CPUs (Lukasz Anaczkowski).
    
       - Consolidation of the ACPI-based handling of PCI host bridges on x86
         and ia64 (Jiang Liu).
    
       - ACPI core fixes to ensure that the correct IRQ number is used to
         represent the SCI (System Control Interrupt) in the cases when it
         has been re-mapped (Chen Yu).
    
       - New ACPI backlight quirk for Lenovo IdeaPad S405 (Hans de Goede).
    
       - ACPI EC driver fixes (Lv Zheng).
    
       - Assorted ACPI fixes and cleanups (Dan Carpenter, Insu Yun, Jiri
         Kosina, Rami Rosen, Rasmus Villemoes).
    
       - New mechanism in the PM core allowing drivers to check if the
         platform firmware is going to be involved in the upcoming system
         suspend or if it has been involved in the suspend the system is
         resuming from at the moment (Rafael Wysocki).
    
         This should allow drivers to optimize their suspend/resume handling
         in some cases and the changes include a couple of users of it (the
         i8042 input driver, PCI PM).
    
       - PCI PM fix to prevent runtime-suspended devices with PME enabled
         from being resumed during system suspend even if they aren't
         configured to wake up the system from sleep (Rafael Wysocki).
    
       - New mechanism to report the number of a wakeup IRQ that woke up the
         system from sleep last time (Alexandra Yates).
    
       - Removal of unused interfaces from the generic power domains
         framework and fixes related to latency measurements in that code
         (Ulf Hansson, Daniel Lezcano).
    
       - cpufreq core sysfs interface rework to make it handle CPUs that
         share performance scaling settings (represented by a common cpufreq
         policy object) more symmetrically (Viresh Kumar).
    
         This should help to simplify the CPU offline/online handling among
         other things.
    
       - cpufreq core fixes and cleanups (Viresh Kumar).
    
       - intel_pstate fixes related to the Turbo Activation Ratio (TAR)
         mechanism on client platforms which causes the turbo P-states range
         to vary depending on platform firmware settings (Srinivas
         Pandruvada).
    
       - intel_pstate sysfs interface fix (Prarit Bhargava).
    
       - Assorted cpufreq driver (imx, tegra20, powernv, integrator) fixes
         and cleanups (Bai Ping, Bartlomiej Zolnierkiewicz, Shilpasri G
         Bhat, Luis de Bethencourt).
    
       - cpuidle mvebu driver cleanups (Russell King).
    
       - OPP (Operating Performance Points) framework code reorganization to
         make it more maintainable (Viresh Kumar).
    
       - Intel Broxton support for the RAPL (Running Average Power Limits)
         power capping driver (Amy Wiles).
    
       - Assorted power management code fixes and cleanups (Dan Carpenter,
         Geert Uytterhoeven, Geliang Tang, Luis de Bethencourt, Rasmus
         Villemoes)"
    
    * tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (108 commits)
      cpufreq: postfix policy directory with the first CPU in related_cpus
      cpufreq: create cpu/cpufreq/policyX directories
      cpufreq: remove cpufreq_sysfs_{create|remove}_file()
      cpufreq: create cpu/cpufreq at boot time
      cpufreq: Use cpumask_copy instead of cpumask_or to copy a mask
      cpufreq: ondemand: Drop unnecessary locks from update_sampling_rate()
      PM / Domains: Merge measurements for PM QoS device latencies
      PM / Domains: Don't measure ->start|stop() latency in system PM callbacks
      PM / clk: Fix broken build due to non-matching code and header #ifdefs
      ACPI / Documentation: add copy_dsdt to ACPI format options
      ACPI / sysfs: correctly check failing memory allocation
      ACPI / video: Add a quirk to force native backlight on Lenovo IdeaPad S405
      ACPI / CPPC: Fix potential memory leak
      ACPI / CPPC: signedness bug in register_pcc_channel()
      ACPI / PAD: power_saving_thread() is not freezable
      ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
      ACPI: Using correct irq when waiting for events
      ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
      cpuidle: mvebu: disable the bind/unbind attributes and use builtin_platform_driver
      cpuidle: mvebu: clean up multiple platform drivers
      ...

commit c7d77a7980e434c3af17de19e3348157f9b9ccce
Merge: 0ce423b6492a 8a53554e12e9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Oct 14 16:05:18 2015 +0200

    Merge branch 'x86/urgent' into core/efi, to pick up a pending EFI fix
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f26527b1428f379fbd7edf779854c3b41bc0b3e5
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:14 2015 +0100

    irqchip / GIC: Convert the GIC driver to ACPI probing
    
    Now that we have a basic infrastructure to register irqchips and
    call them on discovery of a matching entry in MADT, convert the
    GIC driver to this new probing method.
    
    It ends up being a code deletion party, which is a rather good thing.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 208cec08a74f..6894205797a3 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,7 +12,6 @@
 #ifndef _ASM_ACPI_H
 #define _ASM_ACPI_H
 
-#include <linux/irqchip/arm-gic-acpi.h>
 #include <linux/mm.h>
 #include <linux/psci.h>
 

commit 89e44b51cc0db50ea4b5bbb5d582c4db88bbaed8
Author: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
Date:   Fri Sep 4 14:11:41 2015 +0100

    arm64, acpi/apei: Implement arch_apei_get_mem_attributes()
    
    Table 8 of UEFI 2.5 section 2.3.6.1 defines mappings from EFI
    memory types to MAIR attribute encodings for arm64.
    
    If the physical address has memory attributes defined by EFI
    memmap as EFI_MEMORY_[UC|WC|WT], return approprate page
    protection type according to the UEFI spec. Otherwise, return
    PAGE_KERNEL.
    
    Signed-off-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    [ Small stylistic tweaks. ]
    Reviewed-by: Matt Fleming <matt.fleming@intel.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Link: http://lkml.kernel.org/r/1441372302-23242-2-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 406485ed110a..5aa892a12a0d 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -92,4 +92,9 @@ static inline const char *acpi_get_enable_method(int cpu)
 {
 	return acpi_psci_present() ? "psci" : NULL;
 }
+
+#ifdef	CONFIG_ACPI_APEI
+pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr);
+#endif
+
 #endif /*_ASM_ACPI_H*/

commit bff60792f994a87324ab57e89e945b4572b1ef77
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Jul 31 15:46:16 2015 +0100

    arm64: psci: factor invocation code to drivers
    
    To enable sharing with arm, move the core PSCI framework code to
    drivers/firmware. This results in a minor gain in lines of code, but
    this will quickly be amortised by the removal of code currently
    duplicated in arch/arm.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 406485ed110a..208cec08a74f 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,11 +12,11 @@
 #ifndef _ASM_ACPI_H
 #define _ASM_ACPI_H
 
-#include <linux/mm.h>
 #include <linux/irqchip/arm-gic-acpi.h>
+#include <linux/mm.h>
+#include <linux/psci.h>
 
 #include <asm/cputype.h>
-#include <asm/psci.h>
 #include <asm/smp_plat.h>
 
 /* Macros for consistency checks of the GICC subtable of MADT */

commit b6cfb277378ef831c0fa84bcff5049307294adc6
Author: Al Stone <al.stone@.linaro.org>
Date:   Mon Jul 6 17:16:47 2015 -0600

    ACPI / ARM64: add BAD_MADT_GICC_ENTRY() macro
    
    The BAD_MADT_ENTRY() macro is designed to work for all of the subtables
    of the MADT.  In the ACPI 5.1 version of the spec, the struct for the
    GICC subtable (struct acpi_madt_generic_interrupt) is 76 bytes long; in
    ACPI 6.0, the struct is 80 bytes long.  But, there is only one definition
    in ACPICA for this struct -- and that is the 6.0 version.  Hence, when
    BAD_MADT_ENTRY() compares the struct size to the length in the GICC
    subtable, it fails if 5.1 structs are in use, and there are systems in
    the wild that have them.
    
    This patch adds the BAD_MADT_GICC_ENTRY() that checks the GICC subtable
    only, accounting for the difference in specification versions that are
    possible.  The BAD_MADT_ENTRY() will continue to work as is for all other
    MADT subtables.
    
    This code is being added to an arm64 header file since that is currently
    the only architecture using the GICC subtable of the MADT.  As a GIC is
    specific to ARM, it is also unlikely the subtable will be used elsewhere.
    
    Fixes: aeb823bbacc2 ("ACPICA: ACPI 6.0: Add changes for FADT table.")
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    [catalin.marinas@arm.com: extra brackets around macro arguments]
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 39248d3adf5d..406485ed110a 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -19,6 +19,14 @@
 #include <asm/psci.h>
 #include <asm/smp_plat.h>
 
+/* Macros for consistency checks of the GICC subtable of MADT */
+#define ACPI_MADT_GICC_LENGTH	\
+	(acpi_gbl_FADT.header.revision < 6 ? 76 : 80)
+
+#define BAD_MADT_GICC_ENTRY(entry, end)						\
+	(!(entry) || (unsigned long)(entry) + sizeof(*(entry)) > (end) ||	\
+	 (entry)->header.length != ACPI_MADT_GICC_LENGTH)
+
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
 /* ACPI table mapping after acpi_gbl_permanent_mmap is set */

commit c5a1330573c1748179898f4799f130e416ce4738
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Apr 30 14:22:04 2015 +0100

    arm64: psci: remove ACPI coupling
    
    The 32-bit ARM port doesn't have ACPI headers, and conditionally
    including them is going to look horrendous. In preparation for sharing
    the PSCI invocation code with 32-bit, move the acpi_psci_* function
    declarations and definitions such that the PSCI client code need not
    include ACPI headers.
    
    While it would seem like we could simply hide the ACPI includes in
    psci.h, the ACPI headers have hilarious circular dependencies which make
    this infeasible without reorganising most of ACPICA. So rather than
    doing that, move the acpi_psci_* prototypes into psci.h.
    
    The psci_acpi_init function is made dependent on CONFIG_ACPI (with a
    stub implementation in asm/psci.h) such that it need not be built for
    32-bit ARM or kernels without ACPI support. The currently missing __init
    annotations are added to the prototypes in the header.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Al Stone <al.stone@linaro.org>
    Reviewed-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 1240b867d4a2..39248d3adf5d 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -16,6 +16,7 @@
 #include <linux/irqchip/arm-gic-acpi.h>
 
 #include <asm/cputype.h>
+#include <asm/psci.h>
 #include <asm/smp_plat.h>
 
 /* Basic configuration for ACPI */
@@ -39,18 +40,6 @@ extern int acpi_disabled;
 extern int acpi_noirq;
 extern int acpi_pci_disabled;
 
-/* 1 to indicate PSCI 0.2+ is implemented */
-static inline bool acpi_psci_present(void)
-{
-	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_COMPLIANT;
-}
-
-/* 1 to indicate HVC must be used instead of SMC as the PSCI conduit */
-static inline bool acpi_psci_use_hvc(void)
-{
-	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_USE_HVC;
-}
-
 static inline void disable_acpi(void)
 {
 	acpi_disabled = 1;
@@ -88,8 +77,6 @@ static inline void arch_fix_phys_package_id(int num, u32 slot) { }
 void __init acpi_init_cpus(void);
 
 #else
-static inline bool acpi_psci_present(void) { return false; }
-static inline bool acpi_psci_use_hvc(void) { return false; }
 static inline void acpi_init_cpus(void) { }
 #endif /* CONFIG_ACPI */
 

commit 0f0783365cbb7ec13a8f02198f6e1a146d94a5a9
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 13 14:12:47 2015 +0100

    ARM64: kernel: unify ACPI and DT cpus initialization
    
    The code that initializes cpus on arm64 is currently split in two
    different code paths that carry out DT and ACPI cpus initialization.
    
    Most of the code executing SMP initialization is common and should
    be merged to reduce discrepancies between ACPI and DT initialization
    and to have code initializing cpus in a single common place in the
    kernel.
    
    This patch refactors arm64 SMP cpus initialization code to merge
    ACPI and DT boot paths in a common file and to create sanity
    checks that can be reused by both boot methods.
    
    Current code assumes PSCI is the only available boot method
    when arm64 boots with ACPI; this can be easily extended if/when
    the ACPI parking protocol is merged into the kernel.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com> [DT]
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 59c05d8ea4a0..1240b867d4a2 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -93,4 +93,8 @@ static inline bool acpi_psci_use_hvc(void) { return false; }
 static inline void acpi_init_cpus(void) { }
 #endif /* CONFIG_ACPI */
 
+static inline const char *acpi_get_enable_method(int cpu)
+{
+	return acpi_psci_present() ? "psci" : NULL;
+}
 #endif /*_ASM_ACPI_H*/

commit fb094eb19900937322848beaf1a622c6afb6250b
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Mar 25 15:22:13 2015 +0000

    ARM64: kernel: acpi: honour acpi=force command line parameter
    
    If acpi=force is passed on the command line, it forces ACPI to be
    the only available boot method, hence it must be left enabled even
    if the initialization and sanity checks on ACPI tables fails.
    
    This patch refactors ACPI initialization to prevent disabling ACPI
    if acpi=force is passed on the command line.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index e1a89656f17e..59c05d8ea4a0 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -38,7 +38,6 @@ typedef u64 phys_cpuid_t;
 extern int acpi_disabled;
 extern int acpi_noirq;
 extern int acpi_pci_disabled;
-extern bool param_acpi_force;
 
 /* 1 to indicate PSCI 0.2+ is implemented */
 static inline bool acpi_psci_present(void)
@@ -92,8 +91,6 @@ void __init acpi_init_cpus(void);
 static inline bool acpi_psci_present(void) { return false; }
 static inline bool acpi_psci_use_hvc(void) { return false; }
 static inline void acpi_init_cpus(void) { }
-
-#define param_acpi_force false
 #endif /* CONFIG_ACPI */
 
 #endif /*_ASM_ACPI_H*/

commit 33757ded074918eb49243968a82e7c9ec2d71720
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:56 2015 +0000

    ARM64 / ACPI: Don't unflatten device tree if acpi=force is passed
    
    Since the policy is that once we pass acpi=force in the early
    param, we will not unflatten device tree even if ACPI is disabled
    in ACPI table init fails, so fix the code by comparinging both
    acpi_disabled and param_acpi_force before the device tree is
    unflattened.
    
    CC: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 59c05d8ea4a0..e1a89656f17e 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -38,6 +38,7 @@ typedef u64 phys_cpuid_t;
 extern int acpi_disabled;
 extern int acpi_noirq;
 extern int acpi_pci_disabled;
+extern bool param_acpi_force;
 
 /* 1 to indicate PSCI 0.2+ is implemented */
 static inline bool acpi_psci_present(void)
@@ -91,6 +92,8 @@ void __init acpi_init_cpus(void);
 static inline bool acpi_psci_present(void) { return false; }
 static inline bool acpi_psci_use_hvc(void) { return false; }
 static inline void acpi_init_cpus(void) { }
+
+#define param_acpi_force false
 #endif /* CONFIG_ACPI */
 
 #endif /*_ASM_ACPI_H*/

commit d60fc3892c4de4a25658786f941690462c5a5bab
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Tue Mar 24 14:02:49 2015 +0000

    irqchip: Add GICv2 specific ACPI boot support
    
    ACPI kernel uses MADT table for proper GIC initialization. It needs to
    parse GIC related subtables, collect CPU interface and distributor
    addresses and call driver initialization function (which is hardware
    abstraction agnostic). In a similar way, FDT initialize GICv1/2.
    
    NOTE: This commit allow to initialize GICv1/2 basic functionality.
    While now simple GICv2 init call is used, any further GIC features
    require generic infrastructure for proper ACPI irqchip initialization.
    That mechanism and stacked irqdomains to support GICv2 MSI/virtualization
    extension, GICv3/4 and its ITS are considered as next steps.
    
    CC: Jason Cooper <jason@lakedaemon.net>
    CC: Marc Zyngier <marc.zyngier@arm.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index eea0bc3b09d5..59c05d8ea4a0 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -13,6 +13,8 @@
 #define _ASM_ACPI_H
 
 #include <linux/mm.h>
+#include <linux/irqchip/arm-gic-acpi.h>
+
 #include <asm/cputype.h>
 #include <asm/smp_plat.h>
 

commit 020295b4cb5b7d510ea1f4531a502c3f8a2380c5
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:47 2015 +0000

    ACPI / processor: Make it possible to get CPU hardware ID via GICC
    
    Introduce a new function map_gicc_mpidr() to allow MPIDRs to be obtained
    from the GICC Structure introduced by ACPI 5.1, since MPIDR for ARM64 is
    64-bit, so typedef u64 for phys_cpuid_t.
    
    The ARM architecture defines the MPIDR register as the CPU hardware
    identifier. This patch adds the code infrastructure to retrieve the MPIDR
    values from the ARM ACPI GICC structure in order to look-up the kernel CPU
    hardware ids required by the ACPI core code to identify CPUs.
    
    CC: Rafael J. Wysocki <rjw@rjwysocki.net>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 9719921aedb1..eea0bc3b09d5 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -13,6 +13,8 @@
 #define _ASM_ACPI_H
 
 #include <linux/mm.h>
+#include <asm/cputype.h>
+#include <asm/smp_plat.h>
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
@@ -27,6 +29,9 @@ static inline void __iomem *acpi_os_ioremap(acpi_physical_address phys,
 }
 #define acpi_os_ioremap acpi_os_ioremap
 
+typedef u64 phys_cpuid_t;
+#define PHYS_CPUID_INVALID INVALID_HWID
+
 #define acpi_strict 1	/* No out-of-spec workarounds on ARM64 */
 extern int acpi_disabled;
 extern int acpi_noirq;
@@ -58,6 +63,13 @@ static inline void enable_acpi(void)
 	acpi_noirq = 0;
 }
 
+/*
+ * The ACPI processor driver for ACPI core code needs this macro
+ * to find out this cpu was already mapped (mapping from CPU hardware
+ * ID to CPU logical ID) or not.
+ */
+#define cpu_physical_id(cpu) cpu_logical_map(cpu)
+
 /*
  * It's used from ACPI core in kdump to boot UP system with SMP kernel,
  * with this check the ACPI core will not override the CPU index

commit fccb9a81fd08b61bed91ddef88341694f8ecbfd1
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 22:02:45 2015 +0800

    ARM64 / ACPI: Parse MADT for SMP initialization
    
    MADT contains the information for MPIDR which is essential for
    SMP initialization, parse the GIC cpu interface structures to
    get the MPIDR value and map it to cpu_logical_map(), and add
    enabled cpu with valid MPIDR into cpu_possible_map.
    
    ACPI 5.1 only has two explicit methods to boot up SMP, PSCI and
    Parking protocol, but the Parking protocol is only specified for
    ARMv7 now, so make PSCI as the only way for the SMP boot protocol
    before some updates for the ACPI spec or the Parking protocol spec.
    
    Parking protocol patches for SMP boot will be sent to upstream when
    the new version of Parking protocol is ready.
    
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 9ea650c991c9..9719921aedb1 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -71,10 +71,12 @@ static inline bool acpi_has_cpu_in_madt(void)
 }
 
 static inline void arch_fix_phys_package_id(int num, u32 slot) { }
+void __init acpi_init_cpus(void);
 
 #else
 static inline bool acpi_psci_present(void) { return false; }
 static inline bool acpi_psci_use_hvc(void) { return false; }
+static inline void acpi_init_cpus(void) { }
 #endif /* CONFIG_ACPI */
 
 #endif /*_ASM_ACPI_H*/

commit 7c59a3df15df29c8402a05b92385e83e55355778
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Tue Mar 24 14:02:43 2015 +0000

    ARM64 / ACPI: Get PSCI flags in FADT for PSCI init
    
    There are two flags: PSCI_COMPLIANT and PSCI_USE_HVC. When set,
    the former signals to the OS that the firmware is PSCI compliant.
    The latter selects the appropriate conduit for PSCI calls by
    toggling between Hypervisor Calls (HVC) and Secure Monitor Calls
    (SMC).
    
    FADT table contains such information in ACPI 5.1, FADT table was
    parsed in ACPI table init and copy to struct acpi_gbl_FADT, so
    use the flags in struct acpi_gbl_FADT for PSCI init.
    
    Since ACPI 5.1 doesn't support self defined PSCI function IDs,
    which means that only PSCI 0.2+ is supported in ACPI.
    
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index c5a9b9741635..9ea650c991c9 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -32,6 +32,18 @@ extern int acpi_disabled;
 extern int acpi_noirq;
 extern int acpi_pci_disabled;
 
+/* 1 to indicate PSCI 0.2+ is implemented */
+static inline bool acpi_psci_present(void)
+{
+	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_COMPLIANT;
+}
+
+/* 1 to indicate HVC must be used instead of SMC as the PSCI conduit */
+static inline bool acpi_psci_use_hvc(void)
+{
+	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_USE_HVC;
+}
+
 static inline void disable_acpi(void)
 {
 	acpi_disabled = 1;
@@ -60,6 +72,9 @@ static inline bool acpi_has_cpu_in_madt(void)
 
 static inline void arch_fix_phys_package_id(int num, u32 slot) { }
 
+#else
+static inline bool acpi_psci_present(void) { return false; }
+static inline bool acpi_psci_use_hvc(void) { return false; }
 #endif /* CONFIG_ACPI */
 
 #endif /*_ASM_ACPI_H*/

commit b10d79f76085b577673395daf92d6208ae09196f
Author: Al Stone <al.stone@linaro.org>
Date:   Tue Mar 24 14:02:41 2015 +0000

    ARM64 / ACPI: Introduce early_param "acpi=" to enable/disable ACPI
    
    This implements the following policy to decide whether ACPI should
    be used to boot the system:
    - acpi=off: ACPI will not be used to boot the system, even if there is
      no alternative available (e.g., device tree is empty)
    - acpi=force: only ACPI will be used to boot the system; if that fails,
      there will be no fallback to alternative methods (such as device tree)
    - otherwise, ACPI will be used as a fallback if the device tree turns out
      to lack a platform description; the heuristic to decide this is whether
      /chosen is the only node present at depth 1
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 40e092483e96..c5a9b9741635 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -39,6 +39,13 @@ static inline void disable_acpi(void)
 	acpi_noirq = 1;
 }
 
+static inline void enable_acpi(void)
+{
+	acpi_disabled = 0;
+	acpi_pci_disabled = 0;
+	acpi_noirq = 0;
+}
+
 /*
  * It's used from ACPI core in kdump to boot UP system with SMP kernel,
  * with this check the ACPI core will not override the CPU index

commit 652261a7a86c884147930fa1e5ddd82a8a5748da
Author: Mark Salter <msalter@redhat.com>
Date:   Tue Mar 24 14:02:38 2015 +0000

    ACPI: fix acpi_os_ioremap for arm64
    
    The acpi_os_ioremap() function may be used to map normal RAM or IO
    regions. The current implementation simply uses ioremap_cache(). This
    will work for some architectures, but arm64 ioremap_cache() cannot be
    used to map IO regions which don't support caching. So for arm64, use
    ioremap() for non-RAM regions.
    
    CC: Rafael J Wysocki <rjw@rjwysocki.net>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index 8b837ab59988..40e092483e96 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -12,8 +12,21 @@
 #ifndef _ASM_ACPI_H
 #define _ASM_ACPI_H
 
+#include <linux/mm.h>
+
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
+/* ACPI table mapping after acpi_gbl_permanent_mmap is set */
+static inline void __iomem *acpi_os_ioremap(acpi_physical_address phys,
+					    acpi_size size)
+{
+	if (!page_is_ram(phys >> PAGE_SHIFT))
+		return ioremap(phys, size);
+
+	return ioremap_cache(phys, size);
+}
+#define acpi_os_ioremap acpi_os_ioremap
+
 #define acpi_strict 1	/* No out-of-spec workarounds on ARM64 */
 extern int acpi_disabled;
 extern int acpi_noirq;

commit 37655163ce1a3ef2635a9bba0ad614f25e01484e
Author: Al Stone <al.stone@linaro.org>
Date:   Tue Mar 24 14:02:37 2015 +0000

    ARM64 / ACPI: Get RSDP and ACPI boot-time tables
    
    As we want to get ACPI tables to parse and then use the information
    for system initialization, we should get the RSDP (Root System
    Description Pointer) first, it then locates Extended Root Description
    Table (XSDT) which contains all the 64-bit physical address that
    pointer to other boot-time tables.
    
    Introduce acpi.c and its related head file in this patch to provide
    fundamental needs of extern variables and functions for ACPI core,
    and then get boot-time tables as needed.
      - asm/acenv.h for arch specific ACPICA environments and
        implementation, It is needed unconditionally by ACPI core;
      - asm/acpi.h for arch specific variables and functions needed by
        ACPI driver core;
      - acpi.c for ARM64 related ACPI implementation for ACPI driver
        core;
    
    acpi_boot_table_init() is introduced to get RSDP and boot-time tables,
    it will be called in setup_arch() before paging_init(), so we should
    use eary_memremap() mechanism here to get the RSDP and all the table
    pointers.
    
    FADT Major.Minor version was introduced in ACPI 5.1, it is the same
    as ACPI version.
    
    In ACPI 5.1, some major gaps are fixed for ARM, such as updates in
    MADT table for GIC and SMP init, without those updates, we can not
    get the MPIDR for SMP init, and GICv2/3 related init information, so
    we can't boot arm64 ACPI properly with table versions predating 5.1.
    
    If firmware provides ACPI tables with ACPI version less than 5.1,
    OS has no way to retrieve the configuration data that is necessary
    to init SMP boot protocol and the GIC properly, so disable ACPI if
    we get an FADT table with version less that 5.1 when acpi_boot_table_init()
    called.
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
new file mode 100644
index 000000000000..8b837ab59988
--- /dev/null
+++ b/arch/arm64/include/asm/acpi.h
@@ -0,0 +1,45 @@
+/*
+ *  Copyright (C) 2013-2014, Linaro Ltd.
+ *	Author: Al Stone <al.stone@linaro.org>
+ *	Author: Graeme Gregory <graeme.gregory@linaro.org>
+ *	Author: Hanjun Guo <hanjun.guo@linaro.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ */
+
+#ifndef _ASM_ACPI_H
+#define _ASM_ACPI_H
+
+/* Basic configuration for ACPI */
+#ifdef	CONFIG_ACPI
+#define acpi_strict 1	/* No out-of-spec workarounds on ARM64 */
+extern int acpi_disabled;
+extern int acpi_noirq;
+extern int acpi_pci_disabled;
+
+static inline void disable_acpi(void)
+{
+	acpi_disabled = 1;
+	acpi_pci_disabled = 1;
+	acpi_noirq = 1;
+}
+
+/*
+ * It's used from ACPI core in kdump to boot UP system with SMP kernel,
+ * with this check the ACPI core will not override the CPU index
+ * obtained from GICC with 0 and not print some error message as well.
+ * Since MADT must provide at least one GICC structure for GIC
+ * initialization, CPU will be always available in MADT on ARM64.
+ */
+static inline bool acpi_has_cpu_in_madt(void)
+{
+	return true;
+}
+
+static inline void arch_fix_phys_package_id(int num, u32 slot) { }
+
+#endif /* CONFIG_ACPI */
+
+#endif /*_ASM_ACPI_H*/
