commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 1dbffe92739a..ff50dd731852 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -9,11 +9,11 @@
 #define __ASM_IO_H
 
 #include <linux/types.h>
+#include <linux/pgtable.h>
 
 #include <asm/byteorder.h>
 #include <asm/barrier.h>
 #include <asm/memory.h>
-#include <linux/pgtable.h>
 #include <asm/early_ioremap.h>
 #include <asm/alternative.h>
 #include <asm/cpufeature.h>

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 6facd1308e7c..1dbffe92739a 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -13,7 +13,7 @@
 #include <asm/byteorder.h>
 #include <asm/barrier.h>
 #include <asm/memory.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/early_ioremap.h>
 #include <asm/alternative.h>
 #include <asm/cpufeature.h>

commit e43f1331e2ef913b8c566920c9af75e0ccdd1d3f
Author: James Morse <james.morse@arm.com>
Date:   Thu Feb 20 16:58:39 2020 +0000

    arm64: Ask the compiler to __always_inline functions used by KVM at HYP
    
    KVM uses some of the static-inline helpers like icache_is_vipt() from
    its HYP code. This assumes the function is inlined so that the code is
    mapped to EL2. The compiler may decide not to inline these, and the
    out-of-line version may not be in the __hyp_text section.
    
    Add the additional __always_ hint to these static-inlines that are used
    by KVM.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Will Deacon <will@kernel.org>
    Link: https://lore.kernel.org/r/20200220165839.256881-4-james.morse@arm.com

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 4e531f57147d..6facd1308e7c 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -34,7 +34,7 @@ static inline void __raw_writew(u16 val, volatile void __iomem *addr)
 }
 
 #define __raw_writel __raw_writel
-static inline void __raw_writel(u32 val, volatile void __iomem *addr)
+static __always_inline void __raw_writel(u32 val, volatile void __iomem *addr)
 {
 	asm volatile("str %w0, [%1]" : : "rZ" (val), "r" (addr));
 }
@@ -69,7 +69,7 @@ static inline u16 __raw_readw(const volatile void __iomem *addr)
 }
 
 #define __raw_readl __raw_readl
-static inline u32 __raw_readl(const volatile void __iomem *addr)
+static __always_inline u32 __raw_readl(const volatile void __iomem *addr)
 {
 	u32 val;
 	asm volatile(ALTERNATIVE("ldr %w0, [%1]",

commit d092a87073269677b7ff09e71a8d91912b7f969a
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 16 08:09:38 2019 +0200

    arch: rely on asm-generic/io.h for default ioremap_* definitions
    
    Various architectures that use asm-generic/io.h still defined their
    own default versions of ioremap_nocache, ioremap_wt and ioremap_wc
    that point back to plain ioremap directly or indirectly.  Remove these
    definitions and rely on asm-generic/io.h instead.  For this to work
    the backup ioremap_* defintions needs to be changed to purely cpp
    macros instea of inlines to cover for architectures like openrisc
    that only define ioremap after including <asm-generic/io.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 323cb306bd28..4e531f57147d 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -167,9 +167,7 @@ extern void iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
-#define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
-#define ioremap_wt(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 
 /*
  * PCI configuration space mapping function.

commit e376897f424a1c807779a2635f62eb02d7e382f9
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 2 10:06:23 2019 +0200

    arm64: remove __iounmap
    
    No need to indirect iounmap for arm64.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index e9763831186a..323cb306bd28 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -163,14 +163,13 @@ extern void __memset_io(volatile void __iomem *, int, size_t);
  * I/O memory mapping functions.
  */
 extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot);
-extern void __iounmap(volatile void __iomem *addr);
+extern void iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
 #define ioremap_wt(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
-#define iounmap				__iounmap
 
 /*
  * PCI configuration space mapping function.

commit 22ec71615d824f4f11d38d0e55a88d8956b7e45f
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jun 7 15:48:58 2019 +0100

    arm64: io: Relax implicit barriers in default I/O accessors
    
    The arm64 implementation of the default I/O accessors requires barrier
    instructions to satisfy the memory ordering requirements documented in
    memory-barriers.txt [1], which are largely derived from the behaviour of
    I/O accesses on x86.
    
    Of particular interest are the requirements that a write to a device
    must be ordered against prior writes to memory, and a read from a device
    must be ordered against subsequent reads from memory. We satisfy these
    requirements using various flavours of DSB: the most expensive barrier
    we have, since it implies completion of prior accesses. This was deemed
    necessary when we first implemented the accessors, since accesses to
    different endpoints could propagate independently and therefore the only
    way to enforce order is to rely on completion guarantees [2].
    
    Since then, the Armv8 memory model has been retrospectively strengthened
    to require "other-multi-copy atomicity", a property that requires memory
    accesses from an observer to become visible to all other observers
    simultaneously [3]. In other words, propagation of accesses is limited
    to transitioning from locally observed to globally observed. It recently
    became apparent that this change also has a subtle impact on our I/O
    accessors for shared peripherals, allowing us to use the cheaper DMB
    instruction instead.
    
    As a concrete example, consider the following:
    
            memcpy(dma_buffer, data, bufsz);
            writel(DMA_START, dev->ctrl_reg);
    
    A DMB ST instruction between the final write to the DMA buffer and the
    write to the control register will ensure that the writes to the DMA
    buffer are observed before the write to the control register by all
    observers. Put another way, if an observer can see the write to the
    control register, it can also see the writes to memory. This has always
    been the case and is not sufficient to provide the ordering required by
    Linux, since there is no guarantee that the master interface of the
    DMA-capable device has observed either of the accesses. However, in an
    other-multi-copy atomic world, we can infer two things:
    
      1. A write arriving at an endpoint shared between multiple CPUs is
         visible to all CPUs
    
      2. A write that is visible to all CPUs is also visible to all other
         observers in the shareability domain
    
    Pieced together, this allows us to use DMB OSHST for our default I/O
    write accessors and DMB OSHLD for our default I/O read accessors (the
    outer-shareability is for handling non-cacheable mappings) for shared
    devices. Memory-mapped, DMA-capable peripherals that are private to a
    CPU (i.e. inaccessible to other CPUs) still require the DSB, however
    these are few and far between and typically require special treatment
    anyway which is outside of the scope of the portable driver API (e.g.
    GIC, page-table walker, SPE profiler).
    
    Note that our mandatory barriers remain as DSBs, since there are cases
    where they are used to flush the store buffer of the CPU, e.g. when
    publishing page table updates to the SMMU.
    
    [1] https://git.kernel.org/linus/4614bbdee357
    [2] https://www.youtube.com/watch?v=i6DayghhA8Q
    [3] https://www.cl.cam.ac.uk/~pes20/armv8-mca/
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 179a4c65c0d4..e9763831186a 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -95,7 +95,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 ({									\
 	unsigned long tmp;						\
 									\
-	rmb();								\
+	dma_rmb();								\
 									\
 	/*								\
 	 * Create a dummy control dependency from the IO read to any	\
@@ -109,7 +109,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 })
 
 #define __io_par(v)		__iormb(v)
-#define __iowmb()		wmb()
+#define __iowmb()		dma_wmb()
 
 /*
  * Relaxed I/O memory access primitives. These follow the Device memory

commit b907b80d7ae7b2b65ef9f534f3e9a32ce6a4b539
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jul 8 17:36:40 2019 +0100

    arm64: remove pointless __KERNEL__ guards
    
    For a number of years, UAPI headers have been split from kernel-internal
    headers. The latter are never exposed to userspace, and always built
    with __KERNEL__ defined.
    
    Most headers under arch/arm64 don't have __KERNEL__ guards, but there
    are a few stragglers lying around. To make things more consistent, and
    to set a good example going forward, let's remove these redundant
    __KERNEL__ guards.
    
    In a couple of cases, a trailing #endif lacked a comment describing its
    corresponding #if or #ifdef, so these are fixes up at the same time.
    
    Guards in auto-generated crypto code are left as-is, as these guards are
    generated by scripting imported from the upstream openssl project
    scripts. Guards in UAPI headers are left as-is, as these can be included
    by userspace or the kernel.
    
    There should be no functional change as a result of this patch.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 7ed92626949d..179a4c65c0d4 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -8,8 +8,6 @@
 #ifndef __ASM_IO_H
 #define __ASM_IO_H
 
-#ifdef __KERNEL__
-
 #include <linux/types.h>
 
 #include <asm/byteorder.h>
@@ -207,5 +205,4 @@ extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 extern int devmem_is_allowed(unsigned long pfn);
 
-#endif	/* __KERNEL__ */
 #endif	/* __ASM_IO_H */

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index b807cb9b517d..7ed92626949d 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -1,20 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Based on arch/arm/include/asm/io.h
  *
  * Copyright (C) 1996-2000 Russell King
  * Copyright (C) 2012 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #ifndef __ASM_IO_H
 #define __ASM_IO_H

commit d51575621f0fd6c6dd62f7b29a0309425681b813
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 13:03:18 2019 +0000

    arm64/io: Remove useless definition of mmiowb()
    
    arm64 includes asm-generic/io.h, which provides a dummy definition of
    mmiowb() if one isn't already provided by the architecture.
    
    Remove the useless definition.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 8bb7210ac286..b807cb9b517d 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -124,8 +124,6 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 #define __io_par(v)		__iormb(v)
 #define __iowmb()		wmb()
 
-#define mmiowb()		do { } while (0)
-
 /*
  * Relaxed I/O memory access primitives. These follow the Device memory
  * ordering rules but do not guarantee any ordering relative to Normal memory

commit 2c97a9cc35a7a73a7580a8e2632419ff3c0b0fe5
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 18:04:54 2019 +0000

    arm64: io: Hook up __io_par() for inX() ordering
    
    Ensure that inX() provides the same ordering guarantees as readX()
    by hooking up __io_par() so that it maps directly to __iormb().
    
    Reported-by: Andrew Murray <andrew.murray@arm.com>
    Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index ee723835c1f4..8bb7210ac286 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -121,6 +121,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 		     : "memory");					\
 })
 
+#define __io_par(v)		__iormb(v)
 #define __iowmb()		wmb()
 
 #define mmiowb()		do { } while (0)

commit 1b57ec8c75279b873639eb44a215479236f93481
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Nov 29 16:31:04 2018 +0000

    arm64: io: Ensure value passed to __iormb() is held in a 64-bit register
    
    As of commit 6460d3201471 ("arm64: io: Ensure calls to delay routines
    are ordered against prior readX()"), MMIO reads smaller than 64 bits
    fail to compile under clang because we end up mixing 32-bit and 64-bit
    register operands for the same data processing instruction:
    
    ./include/asm-generic/io.h:695:9: warning: value size does not match register size specified by the constraint and modifier [-Wasm-operand-widths]
            return readb(addr);
                   ^
    ./arch/arm64/include/asm/io.h:147:58: note: expanded from macro 'readb'
                                                                           ^
    ./include/asm-generic/io.h:695:9: note: use constraint modifier "w"
    ./arch/arm64/include/asm/io.h:147:50: note: expanded from macro 'readb'
                                                                   ^
    ./arch/arm64/include/asm/io.h:118:24: note: expanded from macro '__iormb'
            asm volatile("eor       %0, %1, %1\n"                           \
                                        ^
    
    Fix the build by casting the macro argument to 'unsigned long' when used
    as an input to the inline asm.
    
    Reported-by: Nick Desaulniers <nick.desaulniers@gmail.com>
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index d42d00d8d5b6..ee723835c1f4 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -117,7 +117,8 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 	 */								\
 	asm volatile("eor	%0, %1, %1\n"				\
 		     "cbnz	%0, ."					\
-		     : "=r" (tmp) : "r" (v) : "memory");		\
+		     : "=r" (tmp) : "r" ((unsigned long)(v))		\
+		     : "memory");					\
 })
 
 #define __iowmb()		wmb()

commit 6460d32014717686d3b7963595950ba2c6d1bb5e
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Nov 7 23:06:15 2018 +0000

    arm64: io: Ensure calls to delay routines are ordered against prior readX()
    
    A relatively standard idiom for ensuring that a pair of MMIO writes to a
    device arrive at that device with a specified minimum delay between them
    is as follows:
    
            writel_relaxed(42, dev_base + CTL1);
            readl(dev_base + CTL1);
            udelay(10);
            writel_relaxed(42, dev_base + CTL2);
    
    the intention being that the read-back from the device will push the
    prior write to CTL1, and the udelay will hold up the write to CTL1 until
    at least 10us have elapsed.
    
    Unfortunately, on arm64 where the underlying delay loop is implemented
    as a read of the architected counter, the CPU does not guarantee
    ordering from the readl() to the delay loop and therefore the delay loop
    could in theory be speculated and not provide the desired interval
    between the two writes.
    
    Fix this in a similar manner to PowerPC by introducing a dummy control
    dependency on the output of readX() which, combined with the ISB in the
    read of the architected counter, guarantees that a subsequent delay loop
    can not be executed until the readX() has returned its result.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 9f8b915af3a7..d42d00d8d5b6 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -104,7 +104,22 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 }
 
 /* IO barriers */
-#define __iormb()		rmb()
+#define __iormb(v)							\
+({									\
+	unsigned long tmp;						\
+									\
+	rmb();								\
+									\
+	/*								\
+	 * Create a dummy control dependency from the IO read to any	\
+	 * later instructions. This ensures that a subsequent call to	\
+	 * udelay() will be ordered due to the ISB in get_cycles().	\
+	 */								\
+	asm volatile("eor	%0, %1, %1\n"				\
+		     "cbnz	%0, ."					\
+		     : "=r" (tmp) : "r" (v) : "memory");		\
+})
+
 #define __iowmb()		wmb()
 
 #define mmiowb()		do { } while (0)
@@ -129,10 +144,10 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
  * following Normal memory access. Writes are ordered relative to any prior
  * Normal memory access.
  */
-#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
-#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
-#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
-#define readq(c)		({ u64 __v = readq_relaxed(c); __iormb(); __v; })
+#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(__v); __v; })
+#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(__v); __v; })
+#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(__v); __v; })
+#define readq(c)		({ u64 __v = readq_relaxed(c); __iormb(__v); __v; })
 
 #define writeb(v,c)		({ __iowmb(); writeb_relaxed((v),(c)); })
 #define writew(v,c)		({ __iowmb(); writew_relaxed((v),(c)); })
@@ -183,9 +198,9 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 /*
  * io{read,write}{16,32,64}be() macros
  */
-#define ioread16be(p)		({ __u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })
-#define ioread32be(p)		({ __u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })
-#define ioread64be(p)		({ __u64 __v = be64_to_cpu((__force __be64)__raw_readq(p)); __iormb(); __v; })
+#define ioread16be(p)		({ __u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(__v); __v; })
+#define ioread32be(p)		({ __u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(__v); __v; })
+#define ioread64be(p)		({ __u64 __v = be64_to_cpu((__force __be64)__raw_readq(p)); __iormb(__v); __v; })
 
 #define iowrite16be(v,p)	({ __iowmb(); __raw_writew((__force __u16)cpu_to_be16(v), p); })
 #define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })

commit 3cfa210bf3fe0803cca17f3775d8cf2360d5f443
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 25 13:30:09 2018 -0700

    xen: don't include <xen/xen.h> from <asm/io.h> and <asm/dma-mapping.h>
    
    Nothing Xen specific in these headers, which get included from a lot
    of code in the kernel.  So prune the includes and move them to the
    Xen-specific files that actually use them instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 18f6ae6a43f1..9f8b915af3a7 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -31,8 +31,6 @@
 #include <asm/alternative.h>
 #include <asm/cpufeature.h>
 
-#include <xen/xen.h>
-
 /*
  * Generic IO read/write.  These perform native-endian accesses.
  */

commit c39ae60dfbda66922f644193b91850abcd4d588c
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 25 13:30:08 2018 -0700

    block: remove ARCH_BIOVEC_PHYS_MERGEABLE
    
    Take the Xen check into the core code instead of delegating it to
    the architectures.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 06119ee511cd..18f6ae6a43f1 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -205,8 +205,5 @@ extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 extern int devmem_is_allowed(unsigned long pfn);
 
-#define ARCH_BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\
-	 (!xen_domain() || xen_biovec_phys_mergeable(vec1, vec2))
-
 #endif	/* __KERNEL__ */
 #endif	/* __ASM_IO_H */

commit 20e3267601f95ff62d7a3116a17a680e9f5cbcc9
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 25 13:30:07 2018 -0700

    xen: provide a prototype for xen_biovec_phys_mergeable in xen.h
    
    Having multiple externs in arch headers is not a good way to provide
    a common interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 774e03ea1bb0..06119ee511cd 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -205,9 +205,6 @@ extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 extern int devmem_is_allowed(unsigned long pfn);
 
-struct bio_vec;
-extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
-				      const struct bio_vec *vec2);
 #define ARCH_BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\
 	 (!xen_domain() || xen_biovec_phys_mergeable(vec1, vec2))
 

commit 6a9f5f240adfdced863a098d34f8f05ca6ab9d5f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 24 09:43:50 2018 +0200

    block: simplify BIOVEC_PHYS_MERGEABLE
    
    Turn the macro into an inline, move it to blk.h and simplify the
    arch hooks a bit.
    
    Also rename the function to biovec_phys_mergeable as there is no need
    to shout.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 35b2e50f17fb..774e03ea1bb0 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -208,9 +208,8 @@ extern int devmem_is_allowed(unsigned long pfn);
 struct bio_vec;
 extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
 				      const struct bio_vec *vec2);
-#define BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\
-	(__BIOVEC_PHYS_MERGEABLE(vec1, vec2) &&				\
-	 (!xen_domain() || xen_biovec_phys_mergeable(vec1, vec2)))
+#define ARCH_BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\
+	 (!xen_domain() || xen_biovec_phys_mergeable(vec1, vec2))
 
 #endif	/* __KERNEL__ */
 #endif	/* __ASM_IO_H */

commit f1e209b7f80288a711268af9054a04d3f6900a6b
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Apr 19 17:48:52 2017 +0100

    ARM64: Implement pci_remap_cfgspace() interface
    
    The PCI bus specification (rev 3.0, 3.2.5 "Transaction Ordering and
    Posting") defines rules for PCI configuration space transactions ordering
    and posting, that state that configuration writes are non-posted
    transactions.
    
    This rule is reinforced by the ARM v8 architecture reference manual (issue
    A.k, Early Write Acknowledgment) that explicitly recommends that No Early
    Write Acknowledgment attribute should be used to map PCI configuration
    (write) transactions.
    
    Current ioremap interface on ARM64 implements mapping functions where the
    Early Write Acknowledgment hint is enabled, so they cannot be used to map
    PCI configuration space in a PCI specs compliant way.
    
    Implement an ARM64 specific pci_remap_cfgspace() interface that allows to
    map PCI config region with nGnRnE attributes, providing a remap function
    that complies with PCI specifications and the ARMv8 architecture reference
    manual recommendations.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 0c00c87bb9dd..35b2e50f17fb 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -172,6 +172,16 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 #define ioremap_wt(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define iounmap				__iounmap
 
+/*
+ * PCI configuration space mapping function.
+ *
+ * The PCI specification disallows posted write configuration transactions.
+ * Add an arch specific pci_remap_cfgspace() definition that is implemented
+ * through nGnRnE device memory attribute as recommended by the ARM v8
+ * Architecture reference manual Issue A.k B2.8.2 "Device memory".
+ */
+#define pci_remap_cfgspace(addr, size) __ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRnE))
+
 /*
  * io{read,write}{16,32,64}be() macros
  */

commit fe8ecc86fa83e6dca25b055651811dff8d80bfed
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:14 2016 -0600

    arm, arm64: don't include blk_types.h in <asm/io.h>
    
    No need for it - we only use struct bio_vec in prototypes and already have
    forward declarations for it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 0bba427bb4c2..0c00c87bb9dd 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -22,7 +22,6 @@
 #ifdef __KERNEL__
 
 #include <linux/types.h>
-#include <linux/blk_types.h>
 
 #include <asm/byteorder.h>
 #include <asm/barrier.h>

commit ee5e41b5f21a5438664effce1ba5bdd11e03ee24
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Sep 8 11:02:20 2016 +0100

    arm64/io: Allow I/O writes to use {W,X}ZR
    
    When zeroing an I/O location, the current accessors are forced to
    allocate a temporary register to store the zero for the write. By
    tweaking the assembly constraints, we can allow the compiler to use
    the zero register directly in such cases, and save some juggling.
    Compiling a representative kernel configuration with GCC 6 shows
    that 2.3KB worth of code can be wasted just on that!
    
      text     data    bss      dec      hex     filename
     13316776 3248256 18176769 34741801 2121e29 vmlinux.o.new
     13319140 3248256 18176769 34744165 2122765 vmlinux.o.old
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index ce20741b2cb5..0bba427bb4c2 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -40,25 +40,25 @@
 #define __raw_writeb __raw_writeb
 static inline void __raw_writeb(u8 val, volatile void __iomem *addr)
 {
-	asm volatile("strb %w0, [%1]" : : "r" (val), "r" (addr));
+	asm volatile("strb %w0, [%1]" : : "rZ" (val), "r" (addr));
 }
 
 #define __raw_writew __raw_writew
 static inline void __raw_writew(u16 val, volatile void __iomem *addr)
 {
-	asm volatile("strh %w0, [%1]" : : "r" (val), "r" (addr));
+	asm volatile("strh %w0, [%1]" : : "rZ" (val), "r" (addr));
 }
 
 #define __raw_writel __raw_writel
 static inline void __raw_writel(u32 val, volatile void __iomem *addr)
 {
-	asm volatile("str %w0, [%1]" : : "r" (val), "r" (addr));
+	asm volatile("str %w0, [%1]" : : "rZ" (val), "r" (addr));
 }
 
 #define __raw_writeq __raw_writeq
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
-	asm volatile("str %0, [%1]" : : "r" (val), "r" (addr));
+	asm volatile("str %x0, [%1]" : : "rZ" (val), "r" (addr));
 }
 
 #define __raw_readb __raw_readb

commit f928c16dbfaff447c637d8c22c29a642be0044f1
Author: James Morse <james.morse@arm.com>
Date:   Mon Sep 5 09:43:04 2016 +0100

    arm64: Drop generic xlate_dev_mem_{k,}ptr()
    
    The code that provides /dev/mem uses xlate_dev_mem_{k,}ptr() to
    avoid making a cachable mapping of a non-cachable area on ia64.
    On arm64 we do this via phys_mem_access_prot() instead, but provide
    dummy versions of xlate_dev_mem_{k,}ptr().
    
    These are the same as those in asm-generic/io.h, which we include from
    asm/io.h
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 9b6e408cfa51..ce20741b2cb5 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -184,17 +184,6 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 #define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })
 #define iowrite64be(v,p)	({ __iowmb(); __raw_writeq((__force __u64)cpu_to_be64(v), p); })
 
-/*
- * Convert a physical pointer to a virtual kernel pointer for /dev/mem
- * access
- */
-#define xlate_dev_mem_ptr(p)	__va(p)
-
-/*
- * Convert a virtual cached pointer to an uncached pointer
- */
-#define xlate_dev_kmem_ptr(p)	p
-
 #include <asm-generic/io.h>
 
 /*

commit 2a41bfbc0393e6f2db419b80a7000708d90c2eeb
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Thu May 19 18:11:04 2016 +0300

    arm64: add io{read,write}64be accessors
    
    This will allow device drivers to consistently use io{read,write}XXbe
    also for 64-bit accesses.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Alex Porosanu <alexandru.porosanu@nxp.com>
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 44be1e03ed65..9b6e408cfa51 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -174,13 +174,15 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 #define iounmap				__iounmap
 
 /*
- * io{read,write}{16,32}be() macros
+ * io{read,write}{16,32,64}be() macros
  */
 #define ioread16be(p)		({ __u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })
 #define ioread32be(p)		({ __u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })
+#define ioread64be(p)		({ __u64 __v = be64_to_cpu((__force __be64)__raw_readq(p)); __iormb(); __v; })
 
 #define iowrite16be(v,p)	({ __iowmb(); __raw_writew((__force __u16)cpu_to_be16(v), p); })
 #define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })
+#define iowrite64be(v,p)	({ __iowmb(); __raw_writeq((__force __u64)cpu_to_be64(v), p); })
 
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem

commit e3d8238d7f5c3f539a29f5ac596cd342d847e099
Merge: 4e241557fc1c 86dca36e6ba0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 24 10:02:15 2015 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "Mostly refactoring/clean-up:
    
       - CPU ops and PSCI (Power State Coordination Interface) refactoring
         following the merging of the arm64 ACPI support, together with
         handling of Trusted (secure) OS instances
    
       - Using fixmap for permanent FDT mapping, removing the initial dtb
         placement requirements (within 512MB from the start of the kernel
         image).  This required moving the FDT self reservation out of the
         memreserve processing
    
       - Idmap (1:1 mapping used for MMU on/off) handling clean-up
    
       - Removing flush_cache_all() - not safe on ARM unless the MMU is off.
         Last stages of CPU power down/up are handled by firmware already
    
       - "Alternatives" (run-time code patching) refactoring and support for
         immediate branch patching, GICv3 CPU interface access
    
       - User faults handling clean-up
    
      And some fixes:
    
       - Fix for VDSO building with broken ELF toolchains
    
       - Fix another case of init_mm.pgd usage for user mappings (during
         ASID roll-over broadcasting)
    
       - Fix for FPSIMD reloading after CPU hotplug
    
       - Fix for missing syscall trace exit
    
       - Workaround for .inst asm bug
    
       - Compat fix for switching the user tls tpidr_el0 register"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (42 commits)
      arm64: use private ratelimit state along with show_unhandled_signals
      arm64: show unhandled SP/PC alignment faults
      arm64: vdso: work-around broken ELF toolchains in Makefile
      arm64: kernel: rename __cpu_suspend to keep it aligned with arm
      arm64: compat: print compat_sp instead of sp
      arm64: mm: Fix freeing of the wrong memmap entries with !SPARSEMEM_VMEMMAP
      arm64: entry: fix context tracking for el0_sp_pc
      arm64: defconfig: enable memtest
      arm64: mm: remove reference to tlb.S from comment block
      arm64: Do not attempt to use init_mm in reset_context()
      arm64: KVM: Switch vgic save/restore to alternative_insn
      arm64: alternative: Introduce feature for GICv3 CPU interface
      arm64: psci: fix !CONFIG_HOTPLUG_CPU build warning
      arm64: fix bug for reloading FPSIMD state after CPU hotplug.
      arm64: kernel thread don't need to save fpsimd context.
      arm64: fix missing syscall trace exit
      arm64: alternative: Work around .inst assembler bugs
      arm64: alternative: Merge alternative-asm.h into alternative.h
      arm64: alternative: Allow immediate branch as alternative instruction
      arm64: Rework alternate sequence for ARM erratum 845719
      ...

commit 556269c138a8b2d3f5714b8105fa6119ecc505f2
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Jun 4 18:55:16 2015 +0200

    arch/*/io.h: Add ioremap_wt() to all architectures
    
    Add ioremap_wt() to all arch-specific asm/io.h headers which
    define ioremap_wc() locally. These headers do not include
    <asm-generic/iomap.h>. Some of them include <asm-generic/io.h>,
    but ioremap_wt() is defined for consistency since they define
    all ioremap_xxx locally.
    
    In all architectures without Write-Through support, ioremap_wt()
    is defined indentical to ioremap_nocache().
    
    frv and m68k already have ioremap_writethrough(). On those we
    add ioremap_wt() indetical to ioremap_writethrough() and defines
    ARCH_HAS_IOREMAP_WT in both architectures.
    
    The ioremap_wt() interface is exported to drivers.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Elliott@hp.com
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: hch@lst.de
    Cc: hmh@hmh.eng.br
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-nvdimm@lists.01.org
    Cc: stefan.bader@canonical.com
    Cc: yigal@plexistor.com
    Link: http://lkml.kernel.org/r/1433436928-31903-9-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 540f7c0aea82..7116d3973058 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -170,6 +170,7 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
+#define ioremap_wt(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define iounmap				__iounmap
 
 /*

commit e985ad17cbbb55e10e2139eb25c087ef92fcdd48
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Mon May 18 13:10:48 2015 +0200

    arm64: Rename temp variable in read*_relaxed()
    
    This resolves the following sparse warning from readl() and other
    macros, which ends up embedding readl_relaxed() using the same
    variable.
    
    Warning log:
    include/asm-generic/io.h:364:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:364:16: originally declared here
    include/asm-generic/io.h:372:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:372:16: originally declared here
    include/asm-generic/io.h:380:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:380:16: originally declared here
    include/asm-generic/io.h:568:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:568:16: originally declared here
    include/asm-generic/io.h:576:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:576:16: originally declared here
    include/asm-generic/io.h:584:16: warning: symbol '__v' shadows an
    earlier one
    include/asm-generic/io.h:584:16: originally declared here
    
    The same patch was already applied to arm32 as
    "ARM: 7118/1: rename temp variable in read*_relaxed()"
    (sha1: b0c1264f534a1cb3c52036a23a04d238434a0df6)
    
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 540f7c0aea82..cb18715cc60f 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -117,10 +117,10 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
  * ordering rules but do not guarantee any ordering relative to Normal memory
  * accesses.
  */
-#define readb_relaxed(c)	({ u8  __v = __raw_readb(c); __v; })
-#define readw_relaxed(c)	({ u16 __v = le16_to_cpu((__force __le16)__raw_readw(c)); __v; })
-#define readl_relaxed(c)	({ u32 __v = le32_to_cpu((__force __le32)__raw_readl(c)); __v; })
-#define readq_relaxed(c)	({ u64 __v = le64_to_cpu((__force __le64)__raw_readq(c)); __v; })
+#define readb_relaxed(c)	({ u8  __r = __raw_readb(c); __r; })
+#define readw_relaxed(c)	({ u16 __r = le16_to_cpu((__force __le16)__raw_readw(c)); __r; })
+#define readl_relaxed(c)	({ u32 __r = le32_to_cpu((__force __le32)__raw_readl(c)); __r; })
+#define readq_relaxed(c)	({ u64 __r = le64_to_cpu((__force __le64)__raw_readq(c)); __r; })
 
 #define writeb_relaxed(v,c)	((void)__raw_writeb((v),(c)))
 #define writew_relaxed(v,c)	((void)__raw_writew((__force u16)cpu_to_le16(v),(c)))

commit aa03c428e67881795f4190f9ffdb62fc14978608
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Jan 22 18:20:35 2015 +0000

    arm64: Fix overlapping VA allocations
    
    PCI IO space was intended to be 16MiB, at 32MiB below MODULES_VADDR, but
    commit d1e6dc91b532d3d3 ("arm64: Add architectural support for PCI")
    extended this to cover the full 32MiB. The final 8KiB of this 32MiB is
    also allocated for the fixmap, allowing for potential clashes between
    the two.
    
    This change was masked by assumptions in mem_init and the page table
    dumping code, which assumed the I/O space to be 16MiB long through
    seaparte hard-coded definitions.
    
    This patch changes the definition of the PCI I/O space allocation to
    live in asm/memory.h, along with the other VA space allocations. As the
    fixmap allocation depends on the number of fixmap entries, this is moved
    below the PCI I/O space allocation. Both the fixmap and PCI I/O space
    are guarded with 2MB of padding. Sites assuming the I/O space was 16MiB
    are moved over use new PCI_IO_{START,END} definitions, which will keep
    in sync with the size of the IO space (now restored to 16MiB).
    
    As a useful side effect, the use of the new PCI_IO_{START,END}
    definitions prevents a build issue in the dumping code due to a (now
    redundant) missing include of io.h for PCI_IOBASE.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Laura Abbott <lauraa@codeaurora.org>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Steve Capper <steve.capper@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    [catalin.marinas@arm.com: reorder FIXADDR and PCI_IO address_markers_idx enum]
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 949c406d4df4..540f7c0aea82 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -26,6 +26,7 @@
 
 #include <asm/byteorder.h>
 #include <asm/barrier.h>
+#include <asm/memory.h>
 #include <asm/pgtable.h>
 #include <asm/early_ioremap.h>
 #include <asm/alternative.h>
@@ -145,8 +146,8 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
  *  I/O port access primitives.
  */
 #define arch_has_dev_port()	(1)
-#define IO_SPACE_LIMIT		(SZ_32M - 1)
-#define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_32M))
+#define IO_SPACE_LIMIT		(PCI_IO_SIZE - 1)
+#define PCI_IOBASE		((void __iomem *)PCI_IO_START)
 
 /*
  * String version of I/O memory access operations.

commit a0e4467726cd26bacb16f13d207ffcfa82ffc07d
Merge: ed8efd2de754 cb61f6769b88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 9 17:25:00 2014 -0800

    Merge tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic asm/io.h rewrite from Arnd Bergmann:
     "While there normally is no reason to have a pull request for
      asm-generic but have all changes get merged through whichever tree
      needs them, I do have a series for 3.19.
    
      There are two sets of patches that change significant portions of
      asm/io.h, and this branch contains both in order to resolve the
      conflicts:
    
       - Will Deacon has done a set of patches to ensure that all
         architectures define {read,write}{b,w,l,q}_relaxed() functions or
         get them by including asm-generic/io.h.
    
         These functions are commonly used on ARM specific drivers to avoid
         expensive L2 cache synchronization implied by the normal
         {read,write}{b,w,l,q}, but we need to define them on all
         architectures in order to share the drivers across architectures
         and to enable CONFIG_COMPILE_TEST configurations for them
    
       - Thierry Reding has done an unrelated set of patches that extends
         the asm-generic/io.h file to the degree necessary to make it useful
         on ARM64 and potentially other architectures"
    
    * tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic: (29 commits)
      ARM64: use GENERIC_PCI_IOMAP
      sparc: io: remove duplicate relaxed accessors on sparc32
      ARM: sa11x0: Use void __iomem * in MMIO accessors
      arm64: Use include/asm-generic/io.h
      ARM: Use include/asm-generic/io.h
      asm-generic/io.h: Implement generic {read,write}s*()
      asm-generic/io.h: Reconcile I/O accessor overrides
      /dev/mem: Use more consistent data types
      Change xlate_dev_{kmem,mem}_ptr() prototypes
      ARM: ixp4xx: Properly override I/O accessors
      ARM: ixp4xx: Fix build with IXP4XX_INDIRECT_PCI
      ARM: ebsa110: Properly override I/O accessors
      ARC: Remove redundant PCI_IOBASE declaration
      documentation: memory-barriers: clarify relaxed io accessor semantics
      x86: io: implement dummy relaxed accessor macros for writes
      tile: io: implement dummy relaxed accessor macros for writes
      sparc: io: implement dummy relaxed accessor macros for writes
      powerpc: io: implement dummy relaxed accessor macros for writes
      parisc: io: implement dummy relaxed accessor macros for writes
      mn10300: io: implement dummy relaxed accessor macros for writes
      ...

commit 5afaa1fc1b320cec48affa7e6949f2493f875c12
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Nov 14 15:54:11 2014 +0000

    arm64: add Cortex-A57 erratum 832075 workaround
    
    The ARM erratum 832075 applies to certain revisions of Cortex-A57,
    one of the workarounds is to change device loads into using
    load-aquire semantics.
    This is achieved using the alternatives framework.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 79f1d519221f..75825b63464d 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -28,6 +28,8 @@
 #include <asm/barrier.h>
 #include <asm/pgtable.h>
 #include <asm/early_ioremap.h>
+#include <asm/alternative.h>
+#include <asm/cpufeature.h>
 
 #include <xen/xen.h>
 
@@ -57,28 +59,41 @@ static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 static inline u8 __raw_readb(const volatile void __iomem *addr)
 {
 	u8 val;
-	asm volatile("ldrb %w0, [%1]" : "=r" (val) : "r" (addr));
+	asm volatile(ALTERNATIVE("ldrb %w0, [%1]",
+				 "ldarb %w0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (val) : "r" (addr));
 	return val;
 }
 
 static inline u16 __raw_readw(const volatile void __iomem *addr)
 {
 	u16 val;
-	asm volatile("ldrh %w0, [%1]" : "=r" (val) : "r" (addr));
+
+	asm volatile(ALTERNATIVE("ldrh %w0, [%1]",
+				 "ldarh %w0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (val) : "r" (addr));
 	return val;
 }
 
 static inline u32 __raw_readl(const volatile void __iomem *addr)
 {
 	u32 val;
-	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
+	asm volatile(ALTERNATIVE("ldr %w0, [%1]",
+				 "ldar %w0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (val) : "r" (addr));
 	return val;
 }
 
 static inline u64 __raw_readq(const volatile void __iomem *addr)
 {
 	u64 val;
-	asm volatile("ldr %0, [%1]" : "=r" (val) : "r" (addr));
+	asm volatile(ALTERNATIVE("ldr %0, [%1]",
+				 "ldar %0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (val) : "r" (addr));
 	return val;
 }
 

commit 09a5723983e383e7d627fe3191366761722695bc
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 28 17:25:48 2014 +0200

    arm64: Use include/asm-generic/io.h
    
    Include the generic I/O header file so that duplicate implementations
    can be removed. This will also help to establish consistency across more
    architectures regarding which accessors they support.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 79f1d519221f..deb6d2b6df0b 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -34,26 +34,31 @@
 /*
  * Generic IO read/write.  These perform native-endian accesses.
  */
+#define __raw_writeb __raw_writeb
 static inline void __raw_writeb(u8 val, volatile void __iomem *addr)
 {
 	asm volatile("strb %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writew __raw_writew
 static inline void __raw_writew(u16 val, volatile void __iomem *addr)
 {
 	asm volatile("strh %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writel __raw_writel
 static inline void __raw_writel(u32 val, volatile void __iomem *addr)
 {
 	asm volatile("str %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writeq __raw_writeq
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
 	asm volatile("str %0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_readb __raw_readb
 static inline u8 __raw_readb(const volatile void __iomem *addr)
 {
 	u8 val;
@@ -61,6 +66,7 @@ static inline u8 __raw_readb(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readw __raw_readw
 static inline u16 __raw_readw(const volatile void __iomem *addr)
 {
 	u16 val;
@@ -68,6 +74,7 @@ static inline u16 __raw_readw(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readl __raw_readl
 static inline u32 __raw_readl(const volatile void __iomem *addr)
 {
 	u32 val;
@@ -75,6 +82,7 @@ static inline u32 __raw_readl(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readq __raw_readq
 static inline u64 __raw_readq(const volatile void __iomem *addr)
 {
 	u64 val;
@@ -125,94 +133,6 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 #define IO_SPACE_LIMIT		(SZ_32M - 1)
 #define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_32M))
 
-static inline u8 inb(unsigned long addr)
-{
-	return readb(addr + PCI_IOBASE);
-}
-
-static inline u16 inw(unsigned long addr)
-{
-	return readw(addr + PCI_IOBASE);
-}
-
-static inline u32 inl(unsigned long addr)
-{
-	return readl(addr + PCI_IOBASE);
-}
-
-static inline void outb(u8 b, unsigned long addr)
-{
-	writeb(b, addr + PCI_IOBASE);
-}
-
-static inline void outw(u16 b, unsigned long addr)
-{
-	writew(b, addr + PCI_IOBASE);
-}
-
-static inline void outl(u32 b, unsigned long addr)
-{
-	writel(b, addr + PCI_IOBASE);
-}
-
-#define inb_p(addr)	inb(addr)
-#define inw_p(addr)	inw(addr)
-#define inl_p(addr)	inl(addr)
-
-#define outb_p(x, addr)	outb((x), (addr))
-#define outw_p(x, addr)	outw((x), (addr))
-#define outl_p(x, addr)	outl((x), (addr))
-
-static inline void insb(unsigned long addr, void *buffer, int count)
-{
-	u8 *buf = buffer;
-	while (count--)
-		*buf++ = __raw_readb(addr + PCI_IOBASE);
-}
-
-static inline void insw(unsigned long addr, void *buffer, int count)
-{
-	u16 *buf = buffer;
-	while (count--)
-		*buf++ = __raw_readw(addr + PCI_IOBASE);
-}
-
-static inline void insl(unsigned long addr, void *buffer, int count)
-{
-	u32 *buf = buffer;
-	while (count--)
-		*buf++ = __raw_readl(addr + PCI_IOBASE);
-}
-
-static inline void outsb(unsigned long addr, const void *buffer, int count)
-{
-	const u8 *buf = buffer;
-	while (count--)
-		__raw_writeb(*buf++, addr + PCI_IOBASE);
-}
-
-static inline void outsw(unsigned long addr, const void *buffer, int count)
-{
-	const u16 *buf = buffer;
-	while (count--)
-		__raw_writew(*buf++, addr + PCI_IOBASE);
-}
-
-static inline void outsl(unsigned long addr, const void *buffer, int count)
-{
-	const u32 *buf = buffer;
-	while (count--)
-		__raw_writel(*buf++, addr + PCI_IOBASE);
-}
-
-#define insb_p(port,to,len)	insb(port,to,len)
-#define insw_p(port,to,len)	insw(port,to,len)
-#define insl_p(port,to,len)	insl(port,to,len)
-
-#define outsb_p(port,from,len)	outsb(port,from,len)
-#define outsw_p(port,from,len)	outsw(port,from,len)
-#define outsl_p(port,from,len)	outsl(port,from,len)
-
 /*
  * String version of I/O memory access operations.
  */
@@ -236,18 +156,14 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
 #define iounmap				__iounmap
 
-#define ARCH_HAS_IOREMAP_WC
-#include <asm-generic/iomap.h>
-
 /*
- * More restrictive address range checking than the default implementation
- * (PHYS_OFFSET and PHYS_MASK taken into account).
+ * io{read,write}{16,32}be() macros
  */
-#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-extern int valid_phys_addr_range(phys_addr_t addr, size_t size);
-extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+#define ioread16be(p)		({ __u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })
+#define ioread32be(p)		({ __u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })
 
-extern int devmem_is_allowed(unsigned long pfn);
+#define iowrite16be(v,p)	({ __iowmb(); __raw_writew((__force __u16)cpu_to_be16(v), p); })
+#define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })
 
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
@@ -260,6 +176,18 @@ extern int devmem_is_allowed(unsigned long pfn);
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+#include <asm-generic/io.h>
+
+/*
+ * More restrictive address range checking than the default implementation
+ * (PHYS_OFFSET and PHYS_MASK taken into account).
+ */
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+extern int valid_phys_addr_range(phys_addr_t addr, size_t size);
+extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+
+extern int devmem_is_allowed(unsigned long pfn);
+
 struct bio_vec;
 extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
 				      const struct bio_vec *vec2);

commit 80213c03c4151d900cf293ef0fc51f8d88495e14
Merge: ea584595fc85 f92d9ee3ab39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 15:03:49 2014 -0400

    Merge tag 'pci-v3.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "The interesting things here are:
    
       - Turn on Config Request Retry Status Software Visibility.  This
         caused hangs last time, but we included a fix this time.
       - Rework PCI device configuration to use _HPP/_HPX more aggressively
       - Allow PCI devices to be put into D3cold during system suspend
       - Add arm64 PCI support
       - Add APM X-Gene host bridge driver
       - Add TI Keystone host bridge driver
       - Add Xilinx AXI host bridge driver
    
      More detailed summary:
    
      Enumeration
        - Check Vendor ID only for Config Request Retry Status (Rajat Jain)
        - Enable Config Request Retry Status when supported (Rajat Jain)
        - Add generic domain handling (Catalin Marinas)
        - Generate uppercase hex for modalias interface class (Ricardo Ribalda Delgado)
    
      Resource management
        - Add missing MEM_64 mask in pci_assign_unassigned_bridge_resources() (Yinghai Lu)
        - Increase IBM ipr SAS Crocodile BARs to at least system page size (Douglas Lehr)
    
      PCI device hotplug
        - Prevent NULL dereference during pciehp probe (Andreas Noever)
        - Move _HPP & _HPX handling into core (Bjorn Helgaas)
        - Apply _HPP to PCIe devices as well as PCI (Bjorn Helgaas)
        - Apply _HPP/_HPX to display devices (Bjorn Helgaas)
        - Preserve SERR & PARITY settings when applying _HPP/_HPX (Bjorn Helgaas)
        - Preserve MPS and MRRS settings when applying _HPP/_HPX (Bjorn Helgaas)
        - Apply _HPP/_HPX to all devices, not just hot-added ones (Bjorn Helgaas)
        - Fix wait time in pciehp timeout message (Yinghai Lu)
        - Add more pciehp Slot Control debug output (Yinghai Lu)
        - Stop disabling pciehp notifications during init (Yinghai Lu)
    
      MSI
        - Remove arch_msi_check_device() (Alexander Gordeev)
        - Rename pci_msi_check_device() to pci_msi_supported() (Alexander Gordeev)
        - Move D0 check into pci_msi_check_device() (Alexander Gordeev)
        - Remove unused kobject from struct msi_desc (Yijing Wang)
        - Remove "pos" from the struct msi_desc msi_attrib (Yijing Wang)
        - Add "msi_bus" sysfs MSI/MSI-X control for endpoints (Yijing Wang)
        - Use __get_cached_msi_msg() instead of get_cached_msi_msg() (Yijing Wang)
        - Use __read_msi_msg() instead of read_msi_msg() (Yijing Wang)
        - Use __write_msi_msg() instead of write_msi_msg() (Yijing Wang)
    
      Power management
        - Drop unused runtime PM support code for PCIe ports (Rafael J.  Wysocki)
        - Allow PCI devices to be put into D3cold during system suspend (Rafael J. Wysocki)
    
      AER
        - Add additional AER error strings (Gong Chen)
        - Make <linux/aer.h> standalone includable (Thierry Reding)
    
      Virtualization
        - Add ACS quirk for Solarflare SFC9120 & SFC9140 (Alex Williamson)
        - Add ACS quirk for Intel 10G NICs (Alex Williamson)
        - Add ACS quirk for AMD A88X southbridge (Marti Raudsepp)
        - Remove unused pci_find_upstream_pcie_bridge(), pci_get_dma_source() (Alex Williamson)
        - Add device flag helpers (Ethan Zhao)
        - Assume all Mellanox devices have broken INTx masking (Gavin Shan)
    
      Generic host bridge driver
        - Fix ioport_map() for !CONFIG_GENERIC_IOMAP (Liviu Dudau)
        - Add pci_register_io_range() and pci_pio_to_address() (Liviu Dudau)
        - Define PCI_IOBASE as the base of virtual PCI IO space (Liviu Dudau)
        - Fix the conversion of IO ranges into IO resources (Liviu Dudau)
        - Add pci_get_new_domain_nr() and of_get_pci_domain_nr() (Liviu Dudau)
        - Add support for parsing PCI host bridge resources from DT (Liviu Dudau)
        - Add pci_remap_iospace() to map bus I/O resources (Liviu Dudau)
        - Add arm64 architectural support for PCI (Liviu Dudau)
    
      APM X-Gene
        - Add APM X-Gene PCIe driver (Tanmay Inamdar)
        - Add arm64 DT APM X-Gene PCIe device tree nodes (Tanmay Inamdar)
    
      Freescale i.MX6
        - Probe in module_init(), not fs_initcall() (Lucas Stach)
        - Delay enabling reference clock for SS until it stabilizes (Tim Harvey)
    
      Marvell MVEBU
        - Fix uninitialized variable in mvebu_get_tgt_attr() (Thomas Petazzoni)
    
      NVIDIA Tegra
        - Make sure the PCIe PLL is really reset (Eric Yuen)
        - Add error path tegra_msi_teardown_irq() cleanup (Jisheng Zhang)
        - Fix extended configuration space mapping (Peter Daifuku)
        - Implement resource hierarchy (Thierry Reding)
        - Clear CLKREQ# enable on port disable (Thierry Reding)
        - Add Tegra124 support (Thierry Reding)
    
      ST Microelectronics SPEAr13xx
        - Pass config resource through reg property (Pratyush Anand)
    
      Synopsys DesignWare
        - Use NULL instead of false (Fabio Estevam)
        - Parse bus-range property from devicetree (Lucas Stach)
        - Use pci_create_root_bus() instead of pci_scan_root_bus() (Lucas Stach)
        - Remove pci_assign_unassigned_resources() (Lucas Stach)
        - Check private_data validity in single place (Lucas Stach)
        - Setup and clear exactly one MSI at a time (Lucas Stach)
        - Remove open-coded bitmap operations (Lucas Stach)
        - Fix configuration base address when using 'reg' (Minghuan Lian)
        - Fix IO resource end address calculation (Minghuan Lian)
        - Rename get_msi_data() to get_msi_addr() (Minghuan Lian)
        - Add get_msi_data() to pcie_host_ops (Minghuan Lian)
        - Add support for v3.65 hardware (Murali Karicheri)
        - Fold struct pcie_port_info into struct pcie_port (Pratyush Anand)
    
      TI Keystone
        - Add TI Keystone PCIe driver (Murali Karicheri)
        - Limit MRSS for all downstream devices (Murali Karicheri)
        - Assume controller is already in RC mode (Murali Karicheri)
        - Set device ID based on SoC to support multiple ports (Murali Karicheri)
    
      Xilinx AXI
        - Add Xilinx AXI PCIe driver (Srikanth Thokala)
        - Fix xilinx_pcie_assign_msi() return value test (Dan Carpenter)
    
      Miscellaneous
        - Clean up whitespace (Quentin Lambert)
        - Remove assignments from "if" conditions (Quentin Lambert)
        - Move PCI_VENDOR_ID_VMWARE to pci_ids.h (Francesco Ruggeri)
        - x86: Mark DMI tables as initialization data (Mathias Krause)
        - x86: Move __init annotation to the correct place (Mathias Krause)
        - x86: Mark constants of pci_mmcfg_nvidia_mcp55() as __initconst (Mathias Krause)
        - x86: Constify pci_mmcfg_probes[] array (Mathias Krause)
        - x86: Mark PCI BIOS initialization code as such (Mathias Krause)
        - Parenthesize PCI_DEVID and PCI_VPD_LRDT_ID parameters (Megan Kamiya)
        - Remove unnecessary variable in pci_add_dynid() (Tobias Klauser)"
    
    * tag 'pci-v3.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (109 commits)
      arm64: dts: Add APM X-Gene PCIe device tree nodes
      PCI: Add ACS quirk for AMD A88X southbridge devices
      PCI: xgene: Add APM X-Gene PCIe driver
      PCI: designware: Remove open-coded bitmap operations
      PCI/MSI: Remove unnecessary temporary variable
      PCI/MSI: Use __write_msi_msg() instead of write_msi_msg()
      MSI/powerpc: Use __read_msi_msg() instead of read_msi_msg()
      PCI/MSI: Use __get_cached_msi_msg() instead of get_cached_msi_msg()
      PCI/MSI: Add "msi_bus" sysfs MSI/MSI-X control for endpoints
      PCI/MSI: Remove "pos" from the struct msi_desc msi_attrib
      PCI/MSI: Remove unused kobject from struct msi_desc
      PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported()
      PCI/MSI: Move D0 check into pci_msi_check_device()
      PCI/MSI: Remove arch_msi_check_device()
      irqchip: armada-370-xp: Remove arch_msi_check_device()
      PCI/MSI/PPC: Remove arch_msi_check_device()
      arm64: Add architectural support for PCI
      PCI: Add pci_remap_iospace() to map bus I/O resources
      of/pci: Add support for parsing PCI host bridge resources from DT
      of/pci: Add pci_get_new_domain_nr() and of_get_pci_domain_nr()
      ...
    
    Conflicts:
            arch/arm64/boot/dts/apm-storm.dtsi

commit 097cbd8d261ccc602c963ddf823d5023be439e04
Author: Min-Hua Chen <orca.chen@gmail.com>
Date:   Thu Oct 2 15:56:59 2014 +0100

    arm64: Use phys_addr_t type for physical address
    
    Change the type of physical address from unsigned long to phys_addr_t,
    make valid_phys_addr_range more readable.
    
    Signed-off-by: Min-Hua Chen <orca.chen@gmail.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index e0ecdcf6632d..f771e8bcad4a 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -243,7 +243,7 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
  * (PHYS_OFFSET and PHYS_MASK taken into account).
  */
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-extern int valid_phys_addr_range(unsigned long addr, size_t size);
+extern int valid_phys_addr_range(phys_addr_t addr, size_t size);
 extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 extern int devmem_is_allowed(unsigned long pfn);

commit d1e6dc91b532d3d3dbbd0fa356b775ca320dc2c2
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Sep 29 15:29:31 2014 +0100

    arm64: Add architectural support for PCI
    
    Use the generic PCI domain and OF functions to provide support for PCI
    on arm64.
    
    [bhelgaas: Change comments to use generic PCI, not just PCIe.  Nothing at
    this level is PCIe-specific.]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index e0ecdcf6632d..f998d90bc389 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -121,7 +121,8 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 /*
  *  I/O port access primitives.
  */
-#define IO_SPACE_LIMIT		0xffff
+#define arch_has_dev_port()	(1)
+#define IO_SPACE_LIMIT		(SZ_32M - 1)
 #define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_32M))
 
 static inline u8 inb(unsigned long addr)

commit a501e32430d4232012ab708b8f0ce841f29e0f02
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Apr 3 15:57:15 2014 +0100

    arm64: Clean up the default pgprot setting
    
    The primary aim of this patchset is to remove the pgprot_default and
    prot_sect_default global variables and rely strictly on predefined
    values. The original goal was to be able to run SMP kernels on UP
    hardware by not setting the Shareability bit. However, it is unlikely to
    see UP ARMv8 hardware and even if we do, the Shareability bit is no
    longer assumed to disable cacheable accesses.
    
    A side effect is that the device mappings now have the Shareability
    attribute set. The hardware, however, should ignore it since Device
    accesses are always Outer Shareable.
    
    Following the removal of the two global variables, there is some PROT_*
    macro reshuffling and cleanup, including the __PAGE_* macros (replaced
    by PAGE_*).
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index a1bef78f0303..e0ecdcf6632d 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -230,19 +230,11 @@ extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot
 extern void __iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
-#define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
-#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
-#define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
-#define PROT_NORMAL		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))
-
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
 #define iounmap				__iounmap
 
-#define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF)
-#define PROT_SECT_DEVICE_nGnRE	(PROT_SECT_DEFAULT | PTE_PXN | PTE_UXN | PMD_ATTRINDX(MT_DEVICE_nGnRE))
-
 #define ARCH_HAS_IOREMAP_WC
 #include <asm-generic/iomap.h>
 

commit bf4b558eba920a38f91beb5ee62a8ce2628c92f7
Author: Mark Salter <msalter@redhat.com>
Date:   Mon Apr 7 15:39:52 2014 -0700

    arm64: add early_ioremap support
    
    Add support for early IO or memory mappings which are needed before the
    normal ioremap() is usable.  This also adds fixmap support for permanent
    fixed mappings such as that used by the earlyprintk device register
    region.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 7846a6bb0833..a1bef78f0303 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -27,6 +27,7 @@
 #include <asm/byteorder.h>
 #include <asm/barrier.h>
 #include <asm/pgtable.h>
+#include <asm/early_ioremap.h>
 
 #include <xen/xen.h>
 

commit 22bd1c91fe13d59cff734b69b6757adcfbd8dee9
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Feb 4 16:37:59 2014 +0000

    arm64: Extend the PCI I/O space to 16MB
    
    The patch moves the PCI I/O space (currently at 64K) before the
    earlyprintk mapping and extends it to 16MB.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 4cc813eddacb..7846a6bb0833 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -121,7 +121,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
  *  I/O port access primitives.
  */
 #define IO_SPACE_LIMIT		0xffff
-#define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_2M))
+#define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_32M))
 
 static inline u8 inb(unsigned long addr)
 {

commit 4ce00dfcf19c473f3dbf23d5b1372639f0c334f6
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Jan 16 18:32:25 2014 +0000

    Revert "arm64: Fix memory shareability attribute for ioremap_wc/cache"
    
    This reverts commit 2f7dc6027522499582a520807cb9ffda589de47e.
    
    The above commit breaks the mapping type for Device memory because
    pgprot_default already contains a Normal memory type. pgprot_default is
    also not initialised early enough for earlyprintk resulting in an
    inconsistent memory mapping with 64K PAGE_SIZE configuration.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Reported-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 572769727227..4cc813eddacb 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -229,7 +229,7 @@ extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot
 extern void __iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
-#define PROT_DEFAULT		(pgprot_default | PTE_DIRTY)
+#define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
 #define PROT_NORMAL		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))

commit 2f7dc6027522499582a520807cb9ffda589de47e
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Dec 5 16:56:50 2013 +0000

    arm64: Fix memory shareability attribute for ioremap_wc/cache
    
    Write-combine and cacheable mappings use Normal memory on arm64. On SMP
    systems, the pte needs the shareability bit which is set in
    pgprot_default. Use this for defining PROT_DEFAULT used by ioremap_wc
    and ioremap_cache (Device memory is shareable by default, does not need
    additional attributes).
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 4cc813eddacb..572769727227 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -229,7 +229,7 @@ extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot
 extern void __iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
-#define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
+#define PROT_DEFAULT		(pgprot_default | PTE_DIRTY)
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
 #define PROT_NORMAL		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))

commit eda670c626a4f53eb8ac5f20d8c10d3f0b54c583
Merge: b746f9c7941f 18c51e1a3fab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 13:34:37 2013 +0900

    Merge tag 'stable/for-linus-3.13-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull Xen updates from Konrad Rzeszutek Wilk:
     "This has tons of fixes and two major features which are concentrated
      around the Xen SWIOTLB library.
    
      The short <blurb> is that the tracing facility (just one function) has
      been added to SWIOTLB to make it easier to track I/O progress.
      Additionally under Xen and ARM (32 & 64) the Xen-SWIOTLB driver
      "is used to translate physical to machine and machine to physical
      addresses of foreign[guest] pages for DMA operations" (Stefano) when
      booting under hardware without proper IOMMU.
    
      There are also bug-fixes, cleanups, compile warning fixes, etc.
    
      The commit times for some of the commits is a bit fresh - that is b/c
      we wanted to make sure we have the Ack's from the ARM folks - which
      with the string of back-to-back conferences took a bit of time.  Rest
      assured - the code has been stewing in #linux-next for some time.
    
      Features:
       - SWIOTLB has tracing added when doing bounce buffer.
       - Xen ARM/ARM64 can use Xen-SWIOTLB.  This work allows Linux to
         safely program real devices for DMA operations when running as a
         guest on Xen on ARM, without IOMMU support. [*1]
       - xen_raw_printk works with PVHVM guests if needed.
    
      Bug-fixes:
       - Make memory ballooning work under HVM with large MMIO region.
       - Inform hypervisor of MCFG regions found in ACPI DSDT.
       - Remove deprecated IRQF_DISABLED.
       - Remove deprecated __cpuinit.
    
      [*1]:
      "On arm and arm64 all Xen guests, including dom0, run with second
       stage translation enabled.  As a consequence when dom0 programs a
       device for a DMA operation is going to use (pseudo) physical
       addresses instead machine addresses.  This work introduces two trees
       to track physical to machine and machine to physical mappings of
       foreign pages.  Local pages are assumed mapped 1:1 (physical address
       == machine address).  It enables the SWIOTLB-Xen driver on ARM and
       ARM64, so that Linux can translate physical addresses to machine
       addresses for dma operations when necessary.  " (Stefano)"
    
    * tag 'stable/for-linus-3.13-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip: (32 commits)
      xen/arm: pfn_to_mfn and mfn_to_pfn return the argument if nothing is in the p2m
      arm,arm64/include/asm/io.h: define struct bio_vec
      swiotlb-xen: missing include dma-direction.h
      pci-swiotlb-xen: call pci_request_acs only ifdef CONFIG_PCI
      arm: make SWIOTLB available
      xen: delete new instances of added __cpuinit
      xen/balloon: Set balloon's initial state to number of existing RAM pages
      xen/mcfg: Call PHYSDEVOP_pci_mmcfg_reserved for MCFG areas.
      xen: remove deprecated IRQF_DISABLED
      x86/xen: remove deprecated IRQF_DISABLED
      swiotlb-xen: fix error code returned by xen_swiotlb_map_sg_attrs
      swiotlb-xen: static inline xen_phys_to_bus, xen_bus_to_phys, xen_virt_to_bus and range_straddles_page_boundary
      grant-table: call set_phys_to_machine after mapping grant refs
      arm,arm64: do not always merge biovec if we are running on Xen
      swiotlb: print a warning when the swiotlb is full
      swiotlb-xen: use xen_dma_map/unmap_page, xen_dma_sync_single_for_cpu/device
      xen: introduce xen_dma_map/unmap_page and xen_dma_sync_single_for_cpu/device
      tracing/events: Fix swiotlb tracepoint creation
      swiotlb-xen: use xen_alloc/free_coherent_pages
      xen: introduce xen_alloc/free_coherent_pages
      ...

commit ffc555be09bd2603abdbc6f8b64c6a7477facc48
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Wed Nov 6 12:38:28 2013 +0000

    arm,arm64/include/asm/io.h: define struct bio_vec
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index c163287b9871..757c87a04531 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -266,6 +266,7 @@ extern int devmem_is_allowed(unsigned long pfn);
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+struct bio_vec;
 extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
 				      const struct bio_vec *vec2);
 #define BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\

commit c04e8e2fe5e0163fd37ccec7f538be8fa63be40e
Author: Mark Salter <msalter@redhat.com>
Date:   Thu Oct 24 15:54:17 2013 +0100

    arm64: allow ioremap_cache() to use existing RAM mappings
    
    Some drivers (ACPI notably) use ioremap_cache() to map an area which could
    either be outside of kernel RAM or in an already mapped reserved area of
    RAM. To avoid aliases with different caching attributes, ioremap() does
    not allow RAM to be remapped. But for ioremap_cache(), the existing kernel
    mapping may be used.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 1d12f89140ba..b56e5b5df881 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -224,6 +224,7 @@ extern void __memset_io(volatile void __iomem *, int, size_t);
  */
 extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot);
 extern void __iounmap(volatile void __iomem *addr);
+extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 
 #define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
@@ -233,7 +234,6 @@ extern void __iounmap(volatile void __iomem *addr);
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
-#define ioremap_cached(addr, size)	__ioremap((addr), (size), __pgprot(PROT_NORMAL))
 #define iounmap				__iounmap
 
 #define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF)

commit 3d1975b57097820c131c692d2e0d075641370369
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Fri Oct 25 10:33:26 2013 +0000

    arm,arm64: do not always merge biovec if we are running on Xen
    
    This is similar to what it is done on X86: biovecs are prevented from merging
    otherwise every dma requests would be forced to bounce on the swiotlb buffer.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    
    
    Changes in v7:
    - remove the extra autotranslate check in biomerge.c.

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 1d12f89140ba..c163287b9871 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -22,11 +22,14 @@
 #ifdef __KERNEL__
 
 #include <linux/types.h>
+#include <linux/blk_types.h>
 
 #include <asm/byteorder.h>
 #include <asm/barrier.h>
 #include <asm/pgtable.h>
 
+#include <xen/xen.h>
+
 /*
  * Generic IO read/write.  These perform native-endian accesses.
  */
@@ -263,5 +266,11 @@ extern int devmem_is_allowed(unsigned long pfn);
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
+				      const struct bio_vec *vec2);
+#define BIOVEC_PHYS_MERGEABLE(vec1, vec2)				\
+	(__BIOVEC_PHYS_MERGEABLE(vec1, vec2) &&				\
+	 (!xen_domain() || xen_biovec_phys_mergeable(vec1, vec2)))
+
 #endif	/* __KERNEL__ */
 #endif	/* __ASM_IO_H */

commit 22d4102f778df9cab47e871b8de3400f6e685378
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Fri May 31 15:22:25 2013 +0000

    arm64/xen: implement ioremap_cached on arm64
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 2e12258aa7e4..1d12f89140ba 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -228,10 +228,12 @@ extern void __iounmap(volatile void __iomem *addr);
 #define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
+#define PROT_NORMAL		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))
 
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
+#define ioremap_cached(addr, size)	__ioremap((addr), (size), __pgprot(PROT_NORMAL))
 #define iounmap				__iounmap
 
 #define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF)

commit 12f883989cf91afa8509c547feebbc3acbc04497
Author: Chen Gang <gang.chen@asianux.com>
Date:   Fri Apr 19 12:24:37 2013 +0100

    arm64: Define readq and writeq for driver module using
    
    when compiling with allmodconfig, CONFIG_64BIT=y the file
    drivers/base/regmap/regmap-mmio.c will use readq and writeq so we need
    implement these functions.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 57f12c991de2..2e12258aa7e4 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -92,10 +92,12 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 #define readb_relaxed(c)	({ u8  __v = __raw_readb(c); __v; })
 #define readw_relaxed(c)	({ u16 __v = le16_to_cpu((__force __le16)__raw_readw(c)); __v; })
 #define readl_relaxed(c)	({ u32 __v = le32_to_cpu((__force __le32)__raw_readl(c)); __v; })
+#define readq_relaxed(c)	({ u64 __v = le64_to_cpu((__force __le64)__raw_readq(c)); __v; })
 
 #define writeb_relaxed(v,c)	((void)__raw_writeb((v),(c)))
 #define writew_relaxed(v,c)	((void)__raw_writew((__force u16)cpu_to_le16(v),(c)))
 #define writel_relaxed(v,c)	((void)__raw_writel((__force u32)cpu_to_le32(v),(c)))
+#define writeq_relaxed(v,c)	((void)__raw_writeq((__force u64)cpu_to_le64(v),(c)))
 
 /*
  * I/O memory access primitives. Reads are ordered relative to any
@@ -105,10 +107,12 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 #define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
 #define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
 #define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+#define readq(c)		({ u64 __v = readq_relaxed(c); __iormb(); __v; })
 
 #define writeb(v,c)		({ __iowmb(); writeb_relaxed((v),(c)); })
 #define writew(v,c)		({ __iowmb(); writew_relaxed((v),(c)); })
 #define writel(v,c)		({ __iowmb(); writel_relaxed((v),(c)); })
+#define writeq(v,c)		({ __iowmb(); writeq_relaxed((v),(c)); })
 
 /*
  *  I/O port access primitives.

commit 2475ff9d2c6ea3bbfed55c4635426c371f9ad327
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Oct 23 14:55:08 2012 +0100

    arm64: Add simple earlyprintk support
    
    This patch adds support for "earlyprintk=" parameter on the kernel
    command line. The format is:
    
      earlyprintk=<name>[,<addr>][,<options>]
    
    where <name> is the name of the (UART) device, e.g. "pl011", <addr> is
    the I/O address. The <options> aren't currently used.
    
    The mapping of the earlyprintk device is done very early during kernel
    boot and there are restrictions on which functions it can call. A
    special early_io_map() function is added which creates the mapping from
    the pre-defined EARLY_IOBASE to the device I/O address passed via the
    kernel parameter. The pgd entry corresponding to EARLY_IOBASE is
    pre-populated in head.S during kernel boot.
    
    Only PL011 is currently supported and it is assumed that the interface
    is already initialised by the boot loader before the kernel is started.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index d2f05a608274..57f12c991de2 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -230,6 +230,9 @@ extern void __iounmap(volatile void __iomem *addr);
 #define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
 #define iounmap				__iounmap
 
+#define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF)
+#define PROT_SECT_DEVICE_nGnRE	(PROT_SECT_DEFAULT | PTE_PXN | PTE_UXN | PMD_ATTRINDX(MT_DEVICE_nGnRE))
+
 #define ARCH_HAS_IOREMAP_WC
 #include <asm-generic/iomap.h>
 

commit 8e620b0476696e9428442d3551f3dad47df0e28f
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Nov 15 17:21:16 2012 +0000

    arm64: Distinguish between user and kernel XN bits
    
    On AArch64, the meaning of the XN bit has changed to UXN (user). The PXN
    (privileged) bit must be set to prevent kernel execution. Without the
    PXN bit set, the CPU may speculatively access device memory. This patch
    ensures that all the mappings that the kernel must not execute from
    (including user mappings) have the PXN bit set.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 54f6116697f7..d2f05a608274 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -222,7 +222,7 @@ extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot
 extern void __iounmap(volatile void __iomem *addr);
 
 #define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
-#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_XN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
+#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
 
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))

commit e3978cded41dc7b364e74037f56d6bc558c11fd7
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Oct 23 14:51:16 2012 +0100

    arm64: Move PCI_IOBASE closer to MODULES_VADDR
    
    This is to reuse the same pmd table that is sparsely populated with
    the modules space.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index d10778fe91e5..54f6116697f7 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -114,7 +114,7 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
  *  I/O port access primitives.
  */
 #define IO_SPACE_LIMIT		0xffff
-#define PCI_IOBASE		((void __iomem *)0xffffffbbfffe0000UL)
+#define PCI_IOBASE		((void __iomem *)(MODULES_VADDR - SZ_2M))
 
 static inline u8 inb(unsigned long addr)
 {

commit 489f781a5936f4b90cd5c9838e0102933f6eb2b5
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Oct 23 14:24:21 2012 +0100

    arm64: Use pgprot_t as the last argument when invoking __ioremap()
    
    Even if it works with since the types have the same size, the correct
    type of the last __ioremap() argument is pgprot_t rather than pteval_t.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 74a2a7d304a9..d10778fe91e5 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -225,9 +225,9 @@ extern void __iounmap(volatile void __iomem *addr);
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_XN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
 
-#define ioremap(addr, size)		__ioremap((addr), (size), PROT_DEVICE_nGnRE)
-#define ioremap_nocache(addr, size)	__ioremap((addr), (size), PROT_DEVICE_nGnRE)
-#define ioremap_wc(addr, size)		__ioremap((addr), (size), PROT_NORMAL_NC)
+#define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
+#define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
+#define ioremap_wc(addr, size)		__ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))
 #define iounmap				__iounmap
 
 #define ARCH_HAS_IOREMAP_WC

commit fc47897d2c65bc94b6868a5c914afbd33216e26f
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Mar 5 11:49:29 2012 +0000

    arm64: Device specific operations
    
    This patch adds several definitions for device communication, including
    I/O accessors and ioremap(). The __raw_* accessors are implemented as
    inline asm to avoid compiler generation of post-indexed accesses (less
    efficient to emulate in a virtualised environment).
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
new file mode 100644
index 000000000000..74a2a7d304a9
--- /dev/null
+++ b/arch/arm64/include/asm/io.h
@@ -0,0 +1,258 @@
+/*
+ * Based on arch/arm/include/asm/io.h
+ *
+ * Copyright (C) 1996-2000 Russell King
+ * Copyright (C) 2012 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __ASM_IO_H
+#define __ASM_IO_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+
+#include <asm/byteorder.h>
+#include <asm/barrier.h>
+#include <asm/pgtable.h>
+
+/*
+ * Generic IO read/write.  These perform native-endian accesses.
+ */
+static inline void __raw_writeb(u8 val, volatile void __iomem *addr)
+{
+	asm volatile("strb %w0, [%1]" : : "r" (val), "r" (addr));
+}
+
+static inline void __raw_writew(u16 val, volatile void __iomem *addr)
+{
+	asm volatile("strh %w0, [%1]" : : "r" (val), "r" (addr));
+}
+
+static inline void __raw_writel(u32 val, volatile void __iomem *addr)
+{
+	asm volatile("str %w0, [%1]" : : "r" (val), "r" (addr));
+}
+
+static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
+{
+	asm volatile("str %0, [%1]" : : "r" (val), "r" (addr));
+}
+
+static inline u8 __raw_readb(const volatile void __iomem *addr)
+{
+	u8 val;
+	asm volatile("ldrb %w0, [%1]" : "=r" (val) : "r" (addr));
+	return val;
+}
+
+static inline u16 __raw_readw(const volatile void __iomem *addr)
+{
+	u16 val;
+	asm volatile("ldrh %w0, [%1]" : "=r" (val) : "r" (addr));
+	return val;
+}
+
+static inline u32 __raw_readl(const volatile void __iomem *addr)
+{
+	u32 val;
+	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
+	return val;
+}
+
+static inline u64 __raw_readq(const volatile void __iomem *addr)
+{
+	u64 val;
+	asm volatile("ldr %0, [%1]" : "=r" (val) : "r" (addr));
+	return val;
+}
+
+/* IO barriers */
+#define __iormb()		rmb()
+#define __iowmb()		wmb()
+
+#define mmiowb()		do { } while (0)
+
+/*
+ * Relaxed I/O memory access primitives. These follow the Device memory
+ * ordering rules but do not guarantee any ordering relative to Normal memory
+ * accesses.
+ */
+#define readb_relaxed(c)	({ u8  __v = __raw_readb(c); __v; })
+#define readw_relaxed(c)	({ u16 __v = le16_to_cpu((__force __le16)__raw_readw(c)); __v; })
+#define readl_relaxed(c)	({ u32 __v = le32_to_cpu((__force __le32)__raw_readl(c)); __v; })
+
+#define writeb_relaxed(v,c)	((void)__raw_writeb((v),(c)))
+#define writew_relaxed(v,c)	((void)__raw_writew((__force u16)cpu_to_le16(v),(c)))
+#define writel_relaxed(v,c)	((void)__raw_writel((__force u32)cpu_to_le32(v),(c)))
+
+/*
+ * I/O memory access primitives. Reads are ordered relative to any
+ * following Normal memory access. Writes are ordered relative to any prior
+ * Normal memory access.
+ */
+#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
+#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
+#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+
+#define writeb(v,c)		({ __iowmb(); writeb_relaxed((v),(c)); })
+#define writew(v,c)		({ __iowmb(); writew_relaxed((v),(c)); })
+#define writel(v,c)		({ __iowmb(); writel_relaxed((v),(c)); })
+
+/*
+ *  I/O port access primitives.
+ */
+#define IO_SPACE_LIMIT		0xffff
+#define PCI_IOBASE		((void __iomem *)0xffffffbbfffe0000UL)
+
+static inline u8 inb(unsigned long addr)
+{
+	return readb(addr + PCI_IOBASE);
+}
+
+static inline u16 inw(unsigned long addr)
+{
+	return readw(addr + PCI_IOBASE);
+}
+
+static inline u32 inl(unsigned long addr)
+{
+	return readl(addr + PCI_IOBASE);
+}
+
+static inline void outb(u8 b, unsigned long addr)
+{
+	writeb(b, addr + PCI_IOBASE);
+}
+
+static inline void outw(u16 b, unsigned long addr)
+{
+	writew(b, addr + PCI_IOBASE);
+}
+
+static inline void outl(u32 b, unsigned long addr)
+{
+	writel(b, addr + PCI_IOBASE);
+}
+
+#define inb_p(addr)	inb(addr)
+#define inw_p(addr)	inw(addr)
+#define inl_p(addr)	inl(addr)
+
+#define outb_p(x, addr)	outb((x), (addr))
+#define outw_p(x, addr)	outw((x), (addr))
+#define outl_p(x, addr)	outl((x), (addr))
+
+static inline void insb(unsigned long addr, void *buffer, int count)
+{
+	u8 *buf = buffer;
+	while (count--)
+		*buf++ = __raw_readb(addr + PCI_IOBASE);
+}
+
+static inline void insw(unsigned long addr, void *buffer, int count)
+{
+	u16 *buf = buffer;
+	while (count--)
+		*buf++ = __raw_readw(addr + PCI_IOBASE);
+}
+
+static inline void insl(unsigned long addr, void *buffer, int count)
+{
+	u32 *buf = buffer;
+	while (count--)
+		*buf++ = __raw_readl(addr + PCI_IOBASE);
+}
+
+static inline void outsb(unsigned long addr, const void *buffer, int count)
+{
+	const u8 *buf = buffer;
+	while (count--)
+		__raw_writeb(*buf++, addr + PCI_IOBASE);
+}
+
+static inline void outsw(unsigned long addr, const void *buffer, int count)
+{
+	const u16 *buf = buffer;
+	while (count--)
+		__raw_writew(*buf++, addr + PCI_IOBASE);
+}
+
+static inline void outsl(unsigned long addr, const void *buffer, int count)
+{
+	const u32 *buf = buffer;
+	while (count--)
+		__raw_writel(*buf++, addr + PCI_IOBASE);
+}
+
+#define insb_p(port,to,len)	insb(port,to,len)
+#define insw_p(port,to,len)	insw(port,to,len)
+#define insl_p(port,to,len)	insl(port,to,len)
+
+#define outsb_p(port,from,len)	outsb(port,from,len)
+#define outsw_p(port,from,len)	outsw(port,from,len)
+#define outsl_p(port,from,len)	outsl(port,from,len)
+
+/*
+ * String version of I/O memory access operations.
+ */
+extern void __memcpy_fromio(void *, const volatile void __iomem *, size_t);
+extern void __memcpy_toio(volatile void __iomem *, const void *, size_t);
+extern void __memset_io(volatile void __iomem *, int, size_t);
+
+#define memset_io(c,v,l)	__memset_io((c),(v),(l))
+#define memcpy_fromio(a,c,l)	__memcpy_fromio((a),(c),(l))
+#define memcpy_toio(c,a,l)	__memcpy_toio((c),(a),(l))
+
+/*
+ * I/O memory mapping functions.
+ */
+extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot);
+extern void __iounmap(volatile void __iomem *addr);
+
+#define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_DIRTY)
+#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_XN | PTE_ATTRINDX(MT_DEVICE_nGnRE))
+#define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL_NC))
+
+#define ioremap(addr, size)		__ioremap((addr), (size), PROT_DEVICE_nGnRE)
+#define ioremap_nocache(addr, size)	__ioremap((addr), (size), PROT_DEVICE_nGnRE)
+#define ioremap_wc(addr, size)		__ioremap((addr), (size), PROT_NORMAL_NC)
+#define iounmap				__iounmap
+
+#define ARCH_HAS_IOREMAP_WC
+#include <asm-generic/iomap.h>
+
+/*
+ * More restrictive address range checking than the default implementation
+ * (PHYS_OFFSET and PHYS_MASK taken into account).
+ */
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+extern int valid_phys_addr_range(unsigned long addr, size_t size);
+extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+
+extern int devmem_is_allowed(unsigned long pfn);
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif	/* __KERNEL__ */
+#endif	/* __ASM_IO_H */
