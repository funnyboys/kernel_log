commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index d1271a644797..a7586a4db142 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -24,12 +24,12 @@
 #include <linux/of_fdt.h>
 #include <linux/smp.h>
 #include <linux/serial_core.h>
+#include <linux/pgtable.h>
 
 #include <acpi/ghes.h>
 #include <asm/cputype.h>
 #include <asm/cpu_ops.h>
 #include <asm/daifflags.h>
-#include <linux/pgtable.h>
 #include <asm/smp_plat.h>
 
 int acpi_noirq = 1;		/* skip ACPI IRQ initialization */

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 46ec402e97ed..d1271a644797 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -29,7 +29,7 @@
 #include <asm/cputype.h>
 #include <asm/cpu_ops.h>
 #include <asm/daifflags.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/smp_plat.h>
 
 int acpi_noirq = 1;		/* skip ACPI IRQ initialization */

commit 8fcc4ae6faf8b455eeef00bc9ae70744e3b0f462
Author: James Morse <james.morse@arm.com>
Date:   Fri May 1 17:45:43 2020 +0100

    arm64: acpi: Make apei_claim_sea() synchronise with APEI's irq work
    
    APEI is unable to do all of its error handling work in nmi-context, so
    it defers non-fatal work onto the irq_work queue. arch_irq_work_raise()
    sends an IPI to the calling cpu, but this is not guaranteed to be taken
    before returning to user-space.
    
    Unless the exception interrupted a context with irqs-masked,
    irq_work_run() can run immediately. Otherwise return -EINPROGRESS to
    indicate ghes_notify_sea() found some work to do, but it hasn't
    finished yet.
    
    With this apei_claim_sea() returning '0' means this external-abort was
    also notification of a firmware-first RAS error, and that APEI has
    processed the CPER records.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Tested-by: Tyler Baicar <baicar@os.amperecomputing.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index a100483b47c4..46ec402e97ed 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -19,6 +19,7 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
+#include <linux/irq_work.h>
 #include <linux/memblock.h>
 #include <linux/of_fdt.h>
 #include <linux/smp.h>
@@ -269,6 +270,7 @@ pgprot_t __acpi_get_mem_attribute(phys_addr_t addr)
 int apei_claim_sea(struct pt_regs *regs)
 {
 	int err = -ENOENT;
+	bool return_to_irqs_enabled;
 	unsigned long current_flags;
 
 	if (!IS_ENABLED(CONFIG_ACPI_APEI_GHES))
@@ -276,6 +278,12 @@ int apei_claim_sea(struct pt_regs *regs)
 
 	current_flags = local_daif_save_flags();
 
+	/* current_flags isn't useful here as daif doesn't tell us about pNMI */
+	return_to_irqs_enabled = !irqs_disabled_flags(arch_local_save_flags());
+
+	if (regs)
+		return_to_irqs_enabled = interrupts_enabled(regs);
+
 	/*
 	 * SEA can interrupt SError, mask it and describe this as an NMI so
 	 * that APEI defers the handling.
@@ -284,6 +292,23 @@ int apei_claim_sea(struct pt_regs *regs)
 	nmi_enter();
 	err = ghes_notify_sea();
 	nmi_exit();
+
+	/*
+	 * APEI NMI-like notifications are deferred to irq_work. Unless
+	 * we interrupted irqs-masked code, we can do that now.
+	 */
+	if (!err) {
+		if (return_to_irqs_enabled) {
+			local_daif_restore(DAIF_PROCCTX_NOIRQ);
+			__irq_enter();
+			irq_work_run();
+			__irq_exit();
+		} else {
+			pr_warn_ratelimited("APEI work queued but not completed");
+			err = -EINPROGRESS;
+		}
+	}
+
 	local_daif_restore(current_flags);
 
 	return err;

commit e533dbe9dcb199bb637a2c465f3a6e70564994fe
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jan 22 12:45:46 2020 +0000

    arm64: acpi: fix DAIF manipulation with pNMI
    
    Since commit:
    
      d44f1b8dd7e66d80 ("arm64: KVM/mm: Move SEA handling behind a single 'claim' interface")
    
    ... the top-level APEI SEA handler has the shape:
    
    1. current_flags = arch_local_save_flags()
    2. local_daif_restore(DAIF_ERRCTX)
    3. <GHES handler>
    4. local_daif_restore(current_flags)
    
    However, since commit:
    
      4a503217ce37e1f4 ("arm64: irqflags: Use ICC_PMR_EL1 for interrupt masking")
    
    ... when pseudo-NMIs (pNMIs) are in use, arch_local_save_flags() will save
    the PMR value rather than the DAIF flags.
    
    The combination of these two commits means that the APEI SEA handler will
    erroneously attempt to restore the PMR value into DAIF. Fix this by
    factoring local_daif_save_flags() out of local_daif_save(), so that we
    can consistently save DAIF in step #1, regardless of whether pNMIs are in
    use.
    
    Both commits were introduced concurrently in v5.0.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 4a503217ce37e1f4 ("arm64: irqflags: Use ICC_PMR_EL1 for interrupt masking")
    Fixes: d44f1b8dd7e66d80 ("arm64: KVM/mm: Move SEA handling behind a single 'claim' interface")
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morse <james.morse@arm.com>
    Cc: Julien Thierry <julien.thierry.kdev@gmail.com>
    Cc: Will Deacon <will@kernel.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 3a58e9db5cfe..a100483b47c4 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -274,7 +274,7 @@ int apei_claim_sea(struct pt_regs *regs)
 	if (!IS_ENABLED(CONFIG_ACPI_APEI_GHES))
 		return err;
 
-	current_flags = arch_local_save_flags();
+	current_flags = local_daif_save_flags();
 
 	/*
 	 * SEA can interrupt SError, mask it and describe this as an NMI so

commit dfd437a257924484b144ee750e60affc95562c6d
Merge: 0ecfebd2b524 0c61efd322b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 09:54:55 2019 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - arm64 support for syscall emulation via PTRACE_SYSEMU{,_SINGLESTEP}
    
     - Wire up VM_FLUSH_RESET_PERMS for arm64, allowing the core code to
       manage the permissions of executable vmalloc regions more strictly
    
     - Slight performance improvement by keeping softirqs enabled while
       touching the FPSIMD/SVE state (kernel_neon_begin/end)
    
     - Expose a couple of ARMv8.5 features to user (HWCAP): CondM (new
       XAFLAG and AXFLAG instructions for floating point comparison flags
       manipulation) and FRINT (rounding floating point numbers to integers)
    
     - Re-instate ARM64_PSEUDO_NMI support which was previously marked as
       BROKEN due to some bugs (now fixed)
    
     - Improve parking of stopped CPUs and implement an arm64-specific
       panic_smp_self_stop() to avoid warning on not being able to stop
       secondary CPUs during panic
    
     - perf: enable the ARM Statistical Profiling Extensions (SPE) on ACPI
       platforms
    
     - perf: DDR performance monitor support for iMX8QXP
    
     - cache_line_size() can now be set from DT or ACPI/PPTT if provided to
       cope with a system cache info not exposed via the CPUID registers
    
     - Avoid warning on hardware cache line size greater than
       ARCH_DMA_MINALIGN if the system is fully coherent
    
     - arm64 do_page_fault() and hugetlb cleanups
    
     - Refactor set_pte_at() to avoid redundant READ_ONCE(*ptep)
    
     - Ignore ACPI 5.1 FADTs reported as 5.0 (infer from the
       'arm_boot_flags' introduced in 5.1)
    
     - CONFIG_RANDOMIZE_BASE now enabled in defconfig
    
     - Allow the selection of ARM64_MODULE_PLTS, currently only done via
       RANDOMIZE_BASE (and an erratum workaround), allowing modules to spill
       over into the vmalloc area
    
     - Make ZONE_DMA32 configurable
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (54 commits)
      perf: arm_spe: Enable ACPI/Platform automatic module loading
      arm_pmu: acpi: spe: Add initial MADT/SPE probing
      ACPI/PPTT: Add function to return ACPI 6.3 Identical tokens
      ACPI/PPTT: Modify node flag detection to find last IDENTICAL
      x86/entry: Simplify _TIF_SYSCALL_EMU handling
      arm64: rename dump_instr as dump_kernel_instr
      arm64/mm: Drop [PTE|PMD]_TYPE_FAULT
      arm64: Implement panic_smp_self_stop()
      arm64: Improve parking of stopped CPUs
      arm64: Expose FRINT capabilities to userspace
      arm64: Expose ARMv8.5 CondM capability to userspace
      arm64: defconfig: enable CONFIG_RANDOMIZE_BASE
      arm64: ARM64_MODULES_PLTS must depend on MODULES
      arm64: bpf: do not allocate executable memory
      arm64/kprobes: set VM_FLUSH_RESET_PERMS on kprobe instruction pages
      arm64/mm: wire up CONFIG_ARCH_HAS_SET_DIRECT_MAP
      arm64: module: create module allocations without exec permissions
      arm64: Allow user selection of ARM64_MODULE_PLTS
      acpi/arm64: ignore 5.1 FADTs that are reported as 5.0
      arm64: Allow selecting Pseudo-NMI again
      ...

commit 2af22f3ec3ca452f1e79b967f634708ff01ced8a
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jun 19 14:18:31 2019 +0200

    acpi/arm64: ignore 5.1 FADTs that are reported as 5.0
    
    Some Qualcomm Snapdragon based laptops built to run Microsoft Windows
    are clearly ACPI 5.1 based, given that that is the first ACPI revision
    that supports ARM, and introduced the FADT 'arm_boot_flags' field,
    which has a non-zero field on those systems.
    
    So in these cases, infer from the ARM boot flags that the FADT must be
    5.1 or later, and treat it as 5.1.
    
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Lee Jones <lee.jones@linaro.org>
    Reviewed-by: Graeme Gregory <graeme.gregory@linaro.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 803f0494dd3e..7722e85fb69c 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -155,10 +155,14 @@ static int __init acpi_fadt_sanity_check(void)
 	 */
 	if (table->revision < 5 ||
 	   (table->revision == 5 && fadt->minor_revision < 1)) {
-		pr_err("Unsupported FADT revision %d.%d, should be 5.1+\n",
+		pr_err(FW_BUG "Unsupported FADT revision %d.%d, should be 5.1+\n",
 		       table->revision, fadt->minor_revision);
-		ret = -EINVAL;
-		goto out;
+
+		if (!fadt->arm_boot_flags) {
+			ret = -EINVAL;
+			goto out;
+		}
+		pr_err("FADT has ARM boot flags set, assuming 5.1\n");
 	}
 
 	if (!(fadt->flags & ACPI_FADT_HW_REDUCED)) {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 803f0494dd3e..2804330c95dc 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  ARM64 Specific Low-Level ACPI Boot Support
  *
@@ -7,10 +8,6 @@
  *	Author: Hanjun Guo <hanjun.guo@linaro.org>
  *	Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
  *	Author: Naresh Bhat <naresh.bhat@linaro.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
  */
 
 #define pr_fmt(fmt) "ACPI: " fmt

commit d44f1b8dd7e66d80cc4205809e5ace866bd851da
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:50 2019 +0000

    arm64: KVM/mm: Move SEA handling behind a single 'claim' interface
    
    To split up APEIs in_nmi() path, the caller needs to always be
    in_nmi(). Add a helper to do the work and claim the notification.
    
    When KVM or the arch code takes an exception that might be a RAS
    notification, it asks the APEI firmware-first code whether it wants
    to claim the exception. A future kernel-first mechanism may be queried
    afterwards, and claim the notification, otherwise we fall through
    to the existing default behaviour.
    
    The NOTIFY_SEA code was merged before considering multiple, possibly
    interacting, NMI-like notifications and the need to consider kernel
    first in the future. Make the 'claiming' behaviour explicit.
    
    Restructuring the APEI code to allow multiple NMI-like notifications
    means any notification that might interrupt interrupts-masked
    code must always be wrapped in nmi_enter()/nmi_exit(). This will
    allow APEI to use in_nmi() to use the right fixmap entries.
    
    Mask SError over this window to prevent an asynchronous RAS error
    arriving and tripping 'nmi_enter()'s BUG_ON(in_nmi()).
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 44e3c351e1ea..803f0494dd3e 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -27,8 +27,10 @@
 #include <linux/smp.h>
 #include <linux/serial_core.h>
 
+#include <acpi/ghes.h>
 #include <asm/cputype.h>
 #include <asm/cpu_ops.h>
+#include <asm/daifflags.h>
 #include <asm/pgtable.h>
 #include <asm/smp_plat.h>
 
@@ -256,3 +258,32 @@ pgprot_t __acpi_get_mem_attribute(phys_addr_t addr)
 		return __pgprot(PROT_NORMAL_NC);
 	return __pgprot(PROT_DEVICE_nGnRnE);
 }
+
+/*
+ * Claim Synchronous External Aborts as a firmware first notification.
+ *
+ * Used by KVM and the arch do_sea handler.
+ * @regs may be NULL when called from process context.
+ */
+int apei_claim_sea(struct pt_regs *regs)
+{
+	int err = -ENOENT;
+	unsigned long current_flags;
+
+	if (!IS_ENABLED(CONFIG_ACPI_APEI_GHES))
+		return err;
+
+	current_flags = arch_local_save_flags();
+
+	/*
+	 * SEA can interrupt SError, mask it and describe this as an NMI so
+	 * that APEI defers the handling.
+	 */
+	local_daif_restore(DAIF_ERRCTX);
+	nmi_enter();
+	err = ghes_notify_sea();
+	nmi_exit();
+	local_daif_restore(current_flags);
+
+	return err;
+}

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index ed46dc188b22..44e3c351e1ea 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -16,7 +16,6 @@
 #define pr_fmt(fmt) "ACPI: " fmt
 
 #include <linux/acpi.h>
-#include <linux/bootmem.h>
 #include <linux/cpumask.h>
 #include <linux/efi.h>
 #include <linux/efi-bgrt.h>

commit 09ffcb0d718a0b100f0bed029b830987ecf53fab
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Mon Jul 23 10:57:32 2018 +0900

    arm64: acpi: fix alignment fault in accessing ACPI
    
    This is a fix against the issue that crash dump kernel may hang up
    during booting, which can happen on any ACPI-based system with "ACPI
    Reclaim Memory."
    
    (kernel messages after panic kicked off kdump)
               (snip...)
            Bye!
               (snip...)
            ACPI: Core revision 20170728
            pud=000000002e7d0003, *pmd=000000002e7c0003, *pte=00e8000039710707
            Internal error: Oops: 96000021 [#1] SMP
            Modules linked in:
            CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.14.0-rc6 #1
            task: ffff000008d05180 task.stack: ffff000008cc0000
            PC is at acpi_ns_lookup+0x25c/0x3c0
            LR is at acpi_ds_load1_begin_op+0xa4/0x294
               (snip...)
            Process swapper/0 (pid: 0, stack limit = 0xffff000008cc0000)
            Call trace:
               (snip...)
            [<ffff0000084a6764>] acpi_ns_lookup+0x25c/0x3c0
            [<ffff00000849b4f8>] acpi_ds_load1_begin_op+0xa4/0x294
            [<ffff0000084ad4ac>] acpi_ps_build_named_op+0xc4/0x198
            [<ffff0000084ad6cc>] acpi_ps_create_op+0x14c/0x270
            [<ffff0000084acfa8>] acpi_ps_parse_loop+0x188/0x5c8
            [<ffff0000084ae048>] acpi_ps_parse_aml+0xb0/0x2b8
            [<ffff0000084a8e10>] acpi_ns_one_complete_parse+0x144/0x184
            [<ffff0000084a8e98>] acpi_ns_parse_table+0x48/0x68
            [<ffff0000084a82cc>] acpi_ns_load_table+0x4c/0xdc
            [<ffff0000084b32f8>] acpi_tb_load_namespace+0xe4/0x264
            [<ffff000008baf9b4>] acpi_load_tables+0x48/0xc0
            [<ffff000008badc20>] acpi_early_init+0x9c/0xd0
            [<ffff000008b70d50>] start_kernel+0x3b4/0x43c
            Code: b9008fb9 2a000318 36380054 32190318 (b94002c0)
            ---[ end trace c46ed37f9651c58e ]---
            Kernel panic - not syncing: Fatal exception
            Rebooting in 10 seconds..
    
    (diagnosis)
    * This fault is a data abort, alignment fault (ESR=0x96000021)
      during reading out ACPI table.
    * Initial ACPI tables are normally stored in system ram and marked as
      "ACPI Reclaim memory" by the firmware.
    * After the commit f56ab9a5b73c ("efi/arm: Don't mark ACPI reclaim
      memory as MEMBLOCK_NOMAP"), those regions are differently handled
      as they are "memblock-reserved", without NOMAP bit.
    * So they are now excluded from device tree's "usable-memory-range"
      which kexec-tools determines based on a current view of /proc/iomem.
    * When crash dump kernel boots up, it tries to accesses ACPI tables by
      mapping them with ioremap(), not ioremap_cache(), in acpi_os_ioremap()
      since they are no longer part of mapped system ram.
    * Given that ACPI accessor/helper functions are compiled in without
      unaligned access support (ACPI_MISALIGNMENT_NOT_SUPPORTED),
      any unaligned access to ACPI tables can cause a fatal panic.
    
    With this patch, acpi_os_ioremap() always honors memory attribute
    information provided by the firmware (EFI) and retaining cacheability
    allows the kernel safe access to ACPI tables.
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Reviewed-by: James Morse <james.morse@arm.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reported-by and Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 7b09487ff8fb..ed46dc188b22 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -18,6 +18,7 @@
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
 #include <linux/cpumask.h>
+#include <linux/efi.h>
 #include <linux/efi-bgrt.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -29,13 +30,9 @@
 
 #include <asm/cputype.h>
 #include <asm/cpu_ops.h>
+#include <asm/pgtable.h>
 #include <asm/smp_plat.h>
 
-#ifdef CONFIG_ACPI_APEI
-# include <linux/efi.h>
-# include <asm/pgtable.h>
-#endif
-
 int acpi_noirq = 1;		/* skip ACPI IRQ initialization */
 int acpi_disabled = 1;
 EXPORT_SYMBOL(acpi_disabled);
@@ -239,8 +236,7 @@ void __init acpi_boot_table_init(void)
 	}
 }
 
-#ifdef CONFIG_ACPI_APEI
-pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)
+pgprot_t __acpi_get_mem_attribute(phys_addr_t addr)
 {
 	/*
 	 * According to "Table 8 Map: EFI memory types to AArch64 memory
@@ -261,4 +257,3 @@ pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)
 		return __pgprot(PROT_NORMAL_NC);
 	return __pgprot(PROT_DEVICE_nGnRnE);
 }
-#endif

commit 54ce685cae30c106f062d714c11e644ab1b93b51
Merge: a051c14b8db3 d4abd46b7e72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 9 09:44:25 2018 -0800

    Merge tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups, a few new quirks, a couple of
      updates related to the handling of ACPI tables and ACPICA copyrights
      refreshment.
    
      Specifics:
    
       - Update the ACPICA kernel code to upstream revision 20180105
         including:
           * Assorted fixes (Jung-uk Kim)
           * Support for X32 ABI compilation (Anuj Mittal)
           * Update of ACPICA copyrights to 2018 (Bob Moore)
    
       - Prepare for future modifications to avoid executing the _STA
         control method too early (Hans de Goede)
    
       - Make the processor performance control library code ignore _PPC
         notifications if they cannot be handled and fix up the C1 idle
         state definition when it is used as a fallback state (Chen Yu,
         Yazen Ghannam)
    
       - Make it possible to use the SPCR table on x86 and to replace the
         original IORT table with a new one from initrd (Prarit Bhargava,
         Shunyong Yang)
    
       - Add battery-related quirks for Asus UX360UA and UX410UAK and add
         quirks for table parsing on Dell XPS 9570 and Precision M5530 (Kai
         Heng Feng)
    
       - Address static checker warnings in the CPPC code (Gustavo Silva)
    
       - Avoid printing a raw pointer to the kernel log in the smart battery
         driver (Greg Kroah-Hartman)"
    
    * tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: sbshc: remove raw pointer from printk() message
      ACPI: SPCR: Make SPCR available to x86
      ACPI / CPPC: Use 64-bit arithmetic instead of 32-bit
      ACPI / tables: Add IORT to injectable table list
      ACPI / bus: Parse tables as term_list for Dell XPS 9570 and Precision M5530
      ACPICA: Update version to 20180105
      ACPICA: All acpica: Update copyrights to 2018
      ACPI / processor: Set default C1 idle state description
      ACPI / battery: Add quirk for Asus UX360UA and UX410UAK
      ACPI: processor_perflib: Do not send _PPC change notification if not ready
      ACPI / scan: Use acpi_bus_get_status() to initialize ACPI_TYPE_DEVICE devs
      ACPI / bus: Do not call _STA on battery devices with unmet dependencies
      PCI: acpiphp_ibm: prepare for acpi_get_object_info() no longer returning status
      ACPI: export acpi_bus_get_status_handle()
      ACPICA: Add a missing pair of parentheses
      ACPICA: Prefer ACPI_TO_POINTER() over ACPI_ADD_PTR()
      ACPICA: Avoid NULL pointer arithmetic
      ACPICA: Linux: add support for X32 ABI compilation
      ACPI / video: Use true for boolean value

commit 0231d00082f61cfe03f2b7c27e5356f8cdf0312c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Jan 18 10:09:51 2018 -0500

    ACPI: SPCR: Make SPCR available to x86
    
    SPCR is currently only enabled or ARM64 and x86 can use SPCR to setup
    an early console.
    
    General fixes include updating Documentation & Kconfig (for x86),
    updating comments, and changing parse_spcr() to acpi_parse_spcr(),
    and earlycon_init_is_deferred to earlycon_acpi_spcr_enable to be
    more descriptive.
    
    On x86, many systems have a valid SPCR table but the table version is
    not 2 so the table version check must be a warning.
    
    On ARM64 when the kernel parameter earlycon is used both the early console
    and console are enabled.  On x86, only the earlycon should be enabled by
    by default.  Modify acpi_parse_spcr() to allow options for initializing
    the early console and console separately.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Mark Salter <msalter@redhat.com>
    Tested-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index b3162715ed78..2aa5609def27 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -230,10 +230,10 @@ void __init acpi_boot_table_init(void)
 
 done:
 	if (acpi_disabled) {
-		if (earlycon_init_is_deferred)
+		if (earlycon_acpi_spcr_enable)
 			early_init_dt_scan_chosen_stdout();
 	} else {
-		parse_spcr(earlycon_init_is_deferred);
+		acpi_parse_spcr(earlycon_acpi_spcr_enable, true);
 		if (IS_ENABLED(CONFIG_ACPI_BGRT))
 			acpi_table_parse(ACPI_SIG_BGRT, acpi_parse_bgrt);
 	}

commit fa31ab77ced9fbab87fbac4fca3682009b7f9be2
Author: James Morse <james.morse@arm.com>
Date:   Mon Jan 8 15:38:15 2018 +0000

    arm64: acpi: Remove __init from acpi_psci_use_hvc() for use by SDEI
    
    SDEI inherits the 'use hvc' bit that is also used by PSCI. PSCI does all
    its initialisation early, SDEI does its late.
    
    Remove the __init annotation from acpi_psci_use_hvc().
    
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: James Morse <james.morse@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index b3162715ed78..252396a96c78 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -117,7 +117,7 @@ bool __init acpi_psci_present(void)
 }
 
 /* Whether HVC must be used instead of SMC as the PSCI conduit */
-bool __init acpi_psci_use_hvc(void)
+bool acpi_psci_use_hvc(void)
 {
 	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_USE_HVC;
 }

commit 6c9a58e84e59a2fc937798b623f72ae4b436547d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 18 18:04:17 2017 +0300

    ACPI / boot: Correct address space of __acpi_map_table()
    
    Sparse complains about wrong address space used in __acpi_map_table()
    and in __acpi_unmap_table().
    
    arch/x86/kernel/acpi/boot.c:127:29: warning: incorrect type in return expression (different address spaces)
    arch/x86/kernel/acpi/boot.c:127:29:    expected char *
    arch/x86/kernel/acpi/boot.c:127:29:    got void [noderef] <asn:2>*
    arch/x86/kernel/acpi/boot.c:135:23: warning: incorrect type in argument 1 (different address spaces)
    arch/x86/kernel/acpi/boot.c:135:23:    expected void [noderef] <asn:2>*addr
    arch/x86/kernel/acpi/boot.c:135:23:    got char *map
    
    Correct address space to be in align of type of returned and passed
    parameter.
    
    Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index e25c11e727fe..b3162715ed78 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -95,7 +95,7 @@ static int __init dt_scan_depth1_nodes(unsigned long node,
  * __acpi_map_table() will be called before page_init(), so early_ioremap()
  * or early_memremap() should be called here to for ACPI table mapping.
  */
-char *__init __acpi_map_table(unsigned long phys, unsigned long size)
+void __init __iomem *__acpi_map_table(unsigned long phys, unsigned long size)
 {
 	if (!size)
 		return NULL;
@@ -103,7 +103,7 @@ char *__init __acpi_map_table(unsigned long phys, unsigned long size)
 	return early_memremap(phys, size);
 }
 
-void __init __acpi_unmap_table(char *map, unsigned long size)
+void __init __acpi_unmap_table(void __iomem *map, unsigned long size)
 {
 	if (!map || !size)
 		return;

commit 6e7300cff1c410dde7ac4354b6a0a8cb0a561e54
Author: Bhupesh Sharma <bhsharma@redhat.com>
Date:   Tue Apr 4 17:02:41 2017 +0100

    efi/bgrt: Enable ACPI BGRT handling on arm64
    
    Now that the ACPI BGRT handling code has been made generic, we can
    enable it for arm64.
    
    Signed-off-by: Bhupesh Sharma <bhsharma@redhat.com>
    [ Updated commit log to reflect that BGRT is only enabled for arm64, and added
      missing 'return' statement to the dummy acpi_parse_bgrt() function. ]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170404160245.27812-8-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 64d9cbd61678..e25c11e727fe 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -18,6 +18,7 @@
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
 #include <linux/cpumask.h>
+#include <linux/efi-bgrt.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
@@ -233,6 +234,8 @@ void __init acpi_boot_table_init(void)
 			early_init_dt_scan_chosen_stdout();
 	} else {
 		parse_spcr(earlycon_init_is_deferred);
+		if (IS_ENABLED(CONFIG_ACPI_BGRT))
+			acpi_table_parse(ACPI_SIG_BGRT, acpi_parse_bgrt);
 	}
 }
 

commit 6b11d1d677132816252004426ef220ccd3c92d2f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:39 2016 +0800

    ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
    
    This patch removes the users of the deprectated APIs:
     acpi_get_table_with_size()
     early_acpi_os_unmap_memory()
    The following APIs should be used instead of:
     acpi_get_table()
     acpi_put_table()
    
    The deprecated APIs are invented to be a replacement of acpi_get_table()
    during the early stage so that the early mapped pointer will not be stored
    in ACPICA core and thus the late stage acpi_get_table() won't return a
    wrong pointer. The mapping size is returned just because it is required by
    early_acpi_os_unmap_memory() to unmap the pointer during early stage.
    
    But as the mapping size equals to the acpi_table_header.length
    (see acpi_tb_init_table_descriptor() and acpi_tb_validate_table()), when
    such a convenient result is returned, driver code will start to use it
    instead of accessing acpi_table_header to obtain the length.
    
    Thus this patch cleans up the drivers by replacing returned table size with
    acpi_table_header.length, and should be a no-op.
    
    Reported-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 252a6d9c1da5..64d9cbd61678 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -132,14 +132,13 @@ static int __init acpi_fadt_sanity_check(void)
 	struct acpi_table_header *table;
 	struct acpi_table_fadt *fadt;
 	acpi_status status;
-	acpi_size tbl_size;
 	int ret = 0;
 
 	/*
 	 * FADT is required on arm64; retrieve it to check its presence
 	 * and carry out revision and ACPI HW reduced compliancy tests
 	 */
-	status = acpi_get_table_with_size(ACPI_SIG_FADT, 0, &table, &tbl_size);
+	status = acpi_get_table(ACPI_SIG_FADT, 0, &table);
 	if (ACPI_FAILURE(status)) {
 		const char *msg = acpi_format_exception(status);
 
@@ -170,10 +169,10 @@ static int __init acpi_fadt_sanity_check(void)
 
 out:
 	/*
-	 * acpi_get_table_with_size() creates FADT table mapping that
+	 * acpi_get_table() creates FADT table mapping that
 	 * should be released after parsing and before resuming boot
 	 */
-	early_acpi_os_unmap_memory(table, tbl_size);
+	acpi_put_table(table);
 	return ret;
 }
 

commit 888125a712986fd0fab99d09f42b307de32d740c
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Tue Sep 27 23:54:14 2016 +0300

    ARM64: ACPI: enable ACPI_SPCR_TABLE
    
    SBBR mentions SPCR as a mandatory ACPI table.  So enable it for ARM64
    
    Earlycon should be set up as early as possible.  ACPI boot tables are
    mapped in arch/arm64/kernel/acpi.c:acpi_boot_table_init() that
    is called from setup_arch() and that's where we parse SPCR.
    So it has to be opted-in per-arch.
    
    When ACPI_SPCR_TABLE is defined initialization of DT earlycon is
    deferred until the DT/ACPI decision is done.  Initialize DT earlycon
    if ACPI is disabled.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 3e4f1a45b125..252a6d9c1da5 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -24,6 +24,7 @@
 #include <linux/memblock.h>
 #include <linux/of_fdt.h>
 #include <linux/smp.h>
+#include <linux/serial_core.h>
 
 #include <asm/cputype.h>
 #include <asm/cpu_ops.h>
@@ -206,7 +207,7 @@ void __init acpi_boot_table_init(void)
 	if (param_acpi_off ||
 	    (!param_acpi_on && !param_acpi_force &&
 	     of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
-		return;
+		goto done;
 
 	/*
 	 * ACPI is disabled at this point. Enable it in order to parse
@@ -226,6 +227,14 @@ void __init acpi_boot_table_init(void)
 		if (!param_acpi_force)
 			disable_acpi();
 	}
+
+done:
+	if (acpi_disabled) {
+		if (earlycon_init_is_deferred)
+			early_init_dt_scan_chosen_stdout();
+	} else {
+		parse_spcr(earlycon_init_is_deferred);
+	}
 }
 
 #ifdef CONFIG_ACPI_APEI

commit 6a1f5471144754f165427a93f35c897f85680594
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 12 16:09:11 2016 +0200

    arm64: acpi: add acpi=on cmdline option to prefer ACPI boot over DT
    
    If both ACPI and DT platform descriptions are available, and the
    kernel was configured at build time to support both flavours, the
    default policy is to prefer DT over ACPI, and preferring ACPI over
    DT while still allowing DT as a fallback is not possible.
    
    Since some enterprise features (such as RAS) depend on ACPI, it may
    be desirable for, e.g., distro installers to prefer ACPI boot but
    fall back to DT rather than failing completely if no ACPI tables are
    available.
    
    So introduce the 'acpi=on' kernel command line parameter for arm64,
    which signifies that ACPI should be used if available, and DT should
    only be used as a fallback.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 6884c7678453..3e4f1a45b125 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -42,6 +42,7 @@ int acpi_pci_disabled = 1;	/* skip ACPI PCI scan and IRQ initialization */
 EXPORT_SYMBOL(acpi_pci_disabled);
 
 static bool param_acpi_off __initdata;
+static bool param_acpi_on __initdata;
 static bool param_acpi_force __initdata;
 
 static int __init parse_acpi(char *arg)
@@ -52,6 +53,8 @@ static int __init parse_acpi(char *arg)
 	/* "acpi=off" disables both ACPI table parsing and interpreter */
 	if (strcmp(arg, "off") == 0)
 		param_acpi_off = true;
+	else if (strcmp(arg, "on") == 0) /* prefer ACPI over DT */
+		param_acpi_on = true;
 	else if (strcmp(arg, "force") == 0) /* force ACPI to be enabled */
 		param_acpi_force = true;
 	else
@@ -198,10 +201,11 @@ void __init acpi_boot_table_init(void)
 	 * - ACPI has been disabled explicitly (acpi=off), or
 	 * - the device tree is not empty (it has more than just a /chosen node,
 	 *   and a /hypervisor node when running on Xen)
-	 *   and ACPI has not been force enabled (acpi=force)
+	 *   and ACPI has not been [force] enabled (acpi=on|force)
 	 */
 	if (param_acpi_off ||
-	    (!param_acpi_force && of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
+	    (!param_acpi_on && !param_acpi_force &&
+	     of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
 		return;
 
 	/*

commit 9981293fb0f02e6127d6ab00218bf091f9f6c89b
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Apr 25 11:25:11 2016 +0100

    arm64: make dt_scan_depth1_nodes more readable
    
    Improve the readability of dt_scan_depth1_nodes by removing the nested
    conditionals.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Stefano Stabellini <sstabellini@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 57ee31745af5..6884c7678453 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -66,17 +66,24 @@ static int __init dt_scan_depth1_nodes(unsigned long node,
 				       void *data)
 {
 	/*
-	 * Return 1 as soon as we encounter a node at depth 1 that is
-	 * not the /chosen node, or /hypervisor node with compatible
-	 * string "xen,xen".
+	 * Ignore anything not directly under the root node; we'll
+	 * catch its parent instead.
 	 */
-	if (depth == 1 && (strcmp(uname, "chosen") != 0)) {
-		if (strcmp(uname, "hypervisor") != 0 ||
-		    !of_flat_dt_is_compatible(node, "xen,xen"))
-			return 1;
-	}
+	if (depth != 1)
+		return 0;
 
-	return 0;
+	if (strcmp(uname, "chosen") == 0)
+		return 0;
+
+	if (strcmp(uname, "hypervisor") == 0 &&
+	    of_flat_dt_is_compatible(node, "xen,xen"))
+		return 0;
+
+	/*
+	 * This node at depth 1 is neither a chosen node nor a xen node,
+	 * which we do not expect.
+	 */
+	return 1;
 }
 
 /*

commit 2366c7fdb59812bbd1382afed69e250582c64187
Author: Shannon Zhao <shannon.zhao@linaro.org>
Date:   Thu Apr 7 20:03:29 2016 +0800

    ARM64: ACPI: Check if it runs on Xen to enable or disable ACPI
    
    When it's a Xen domain0 booting with ACPI, it will supply a /chosen and
    a /hypervisor node in DT. So check if it needs to enable ACPI.
    
    Signed-off-by: Shannon Zhao <shannon.zhao@linaro.org>
    Reviewed-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Julien Grall <julien.grall@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index d1ce8e2f98b9..57ee31745af5 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -67,10 +67,15 @@ static int __init dt_scan_depth1_nodes(unsigned long node,
 {
 	/*
 	 * Return 1 as soon as we encounter a node at depth 1 that is
-	 * not the /chosen node.
+	 * not the /chosen node, or /hypervisor node with compatible
+	 * string "xen,xen".
 	 */
-	if (depth == 1 && (strcmp(uname, "chosen") != 0))
-		return 1;
+	if (depth == 1 && (strcmp(uname, "chosen") != 0)) {
+		if (strcmp(uname, "hypervisor") != 0 ||
+		    !of_flat_dt_is_compatible(node, "xen,xen"))
+			return 1;
+	}
+
 	return 0;
 }
 
@@ -184,7 +189,8 @@ void __init acpi_boot_table_init(void)
 	/*
 	 * Enable ACPI instead of device tree unless
 	 * - ACPI has been disabled explicitly (acpi=off), or
-	 * - the device tree is not empty (it has more than just a /chosen node)
+	 * - the device tree is not empty (it has more than just a /chosen node,
+	 *   and a /hypervisor node when running on Xen)
 	 *   and ACPI has not been force enabled (acpi=force)
 	 */
 	if (param_acpi_off ||

commit 0d51ce9ca1116e8f4dc87cb51db8dd250327e9bb
Merge: 41ecf1404b34 1ab68460b1d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 18:10:13 2015 -0800

    Merge tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "Quite a new features are included this time.
    
      First off, the Collaborative Processor Performance Control interface
      (version 2) defined by ACPI will now be supported on ARM64 along with
      a cpufreq frontend for CPU performance scaling.
    
      Second, ACPI gets a new infrastructure for the early probing of IRQ
      chips and clock sources (along the lines of the existing similar
      mechanism for DT).
    
      Next, the ACPI core and the generic device properties API will now
      support a recently introduced hierarchical properties extension of the
      _DSD (Device Specific Data) ACPI device configuration object.  If the
      ACPI platform firmware uses that extension to organize device
      properties in a hierarchical way, the kernel will automatically handle
      it and make those properties available to device drivers via the
      generic device properties API.
    
      It also will be possible to build the ACPICA's AML interpreter
      debugger into the kernel now and use that to diagnose AML-related
      problems more efficiently.  In the future, this should make it
      possible to single-step AML execution and do similar things.
      Interesting stuff, although somewhat experimental at this point.
    
      Finally, the PM core gets a new mechanism that can be used by device
      drivers to distinguish between suspend-to-RAM (based on platform
      firmware support) and suspend-to-idle (or other variants of system
      suspend the platform firmware is not involved in) and possibly
      optimize their device suspend/resume handling accordingly.
    
      In addition to that, some existing features are re-organized quite
      substantially.
    
      First, the ACPI-based handling of PCI host bridges on x86 and ia64 is
      unified and the common code goes into the ACPI core (so as to reduce
      code duplication and eliminate non-essential differences between the
      two architectures in that area).
    
      Second, the Operating Performance Points (OPP) framework is
      reorganized to make the code easier to find and follow.
    
      Next, the cpufreq core's sysfs interface is reorganized to get rid of
      the "primary CPU" concept for configurations in which the same
      performance scaling settings are shared between multiple CPUs.
    
      Finally, some interfaces that aren't necessary any more are dropped
      from the generic power domains framework.
    
      On top of the above we have some minor extensions, cleanups and bug
      fixes in multiple places, as usual.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150930 (Bob Moore, Lv Zheng).
    
         The most significant change is to allow the AML debugger to be
         built into the kernel.  On top of that there is an update related
         to the NFIT table (the ACPI persistent memory interface) and a few
         fixes and cleanups.
    
       - ACPI CPPC2 (Collaborative Processor Performance Control v2) support
         along with a cpufreq frontend (Ashwin Chaugule).
    
         This can only be enabled on ARM64 at this point.
    
       - New ACPI infrastructure for the early probing of IRQ chips and
         clock sources (Marc Zyngier).
    
       - Support for a new hierarchical properties extension of the ACPI
         _DSD (Device Specific Data) device configuration object allowing
         the kernel to handle hierarchical properties (provided by the
         platform firmware this way) automatically and make them available
         to device drivers via the generic device properties interface
         (Rafael Wysocki).
    
       - Generic device properties API extension to obtain an index of
         certain string value in an array of strings, along the lines of
         of_property_match_string(), but working for all of the supported
         firmware node types, and support for the "dma-names" device
         property based on it (Mika Westerberg).
    
       - ACPI core fix to parse the MADT (Multiple APIC Description Table)
         entries in the order expected by platform firmware (and mandated by
         the specification) to avoid confusion on systems with more than 255
         logical CPUs (Lukasz Anaczkowski).
    
       - Consolidation of the ACPI-based handling of PCI host bridges on x86
         and ia64 (Jiang Liu).
    
       - ACPI core fixes to ensure that the correct IRQ number is used to
         represent the SCI (System Control Interrupt) in the cases when it
         has been re-mapped (Chen Yu).
    
       - New ACPI backlight quirk for Lenovo IdeaPad S405 (Hans de Goede).
    
       - ACPI EC driver fixes (Lv Zheng).
    
       - Assorted ACPI fixes and cleanups (Dan Carpenter, Insu Yun, Jiri
         Kosina, Rami Rosen, Rasmus Villemoes).
    
       - New mechanism in the PM core allowing drivers to check if the
         platform firmware is going to be involved in the upcoming system
         suspend or if it has been involved in the suspend the system is
         resuming from at the moment (Rafael Wysocki).
    
         This should allow drivers to optimize their suspend/resume handling
         in some cases and the changes include a couple of users of it (the
         i8042 input driver, PCI PM).
    
       - PCI PM fix to prevent runtime-suspended devices with PME enabled
         from being resumed during system suspend even if they aren't
         configured to wake up the system from sleep (Rafael Wysocki).
    
       - New mechanism to report the number of a wakeup IRQ that woke up the
         system from sleep last time (Alexandra Yates).
    
       - Removal of unused interfaces from the generic power domains
         framework and fixes related to latency measurements in that code
         (Ulf Hansson, Daniel Lezcano).
    
       - cpufreq core sysfs interface rework to make it handle CPUs that
         share performance scaling settings (represented by a common cpufreq
         policy object) more symmetrically (Viresh Kumar).
    
         This should help to simplify the CPU offline/online handling among
         other things.
    
       - cpufreq core fixes and cleanups (Viresh Kumar).
    
       - intel_pstate fixes related to the Turbo Activation Ratio (TAR)
         mechanism on client platforms which causes the turbo P-states range
         to vary depending on platform firmware settings (Srinivas
         Pandruvada).
    
       - intel_pstate sysfs interface fix (Prarit Bhargava).
    
       - Assorted cpufreq driver (imx, tegra20, powernv, integrator) fixes
         and cleanups (Bai Ping, Bartlomiej Zolnierkiewicz, Shilpasri G
         Bhat, Luis de Bethencourt).
    
       - cpuidle mvebu driver cleanups (Russell King).
    
       - OPP (Operating Performance Points) framework code reorganization to
         make it more maintainable (Viresh Kumar).
    
       - Intel Broxton support for the RAPL (Running Average Power Limits)
         power capping driver (Amy Wiles).
    
       - Assorted power management code fixes and cleanups (Dan Carpenter,
         Geert Uytterhoeven, Geliang Tang, Luis de Bethencourt, Rasmus
         Villemoes)"
    
    * tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (108 commits)
      cpufreq: postfix policy directory with the first CPU in related_cpus
      cpufreq: create cpu/cpufreq/policyX directories
      cpufreq: remove cpufreq_sysfs_{create|remove}_file()
      cpufreq: create cpu/cpufreq at boot time
      cpufreq: Use cpumask_copy instead of cpumask_or to copy a mask
      cpufreq: ondemand: Drop unnecessary locks from update_sampling_rate()
      PM / Domains: Merge measurements for PM QoS device latencies
      PM / Domains: Don't measure ->start|stop() latency in system PM callbacks
      PM / clk: Fix broken build due to non-matching code and header #ifdefs
      ACPI / Documentation: add copy_dsdt to ACPI format options
      ACPI / sysfs: correctly check failing memory allocation
      ACPI / video: Add a quirk to force native backlight on Lenovo IdeaPad S405
      ACPI / CPPC: Fix potential memory leak
      ACPI / CPPC: signedness bug in register_pcc_channel()
      ACPI / PAD: power_saving_thread() is not freezable
      ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
      ACPI: Using correct irq when waiting for events
      ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
      cpuidle: mvebu: disable the bind/unbind attributes and use builtin_platform_driver
      cpuidle: mvebu: clean up multiple platform drivers
      ...

commit f26527b1428f379fbd7edf779854c3b41bc0b3e5
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:14 2015 +0100

    irqchip / GIC: Convert the GIC driver to ACPI probing
    
    Now that we have a basic infrastructure to register irqchips and
    call them on discovery of a matching entry in MADT, convert the
    GIC driver to this new probing method.
    
    It ends up being a code deletion party, which is a rather good thing.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 19de7537e7d3..d6463bba2360 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -205,28 +205,3 @@ void __init acpi_boot_table_init(void)
 			disable_acpi();
 	}
 }
-
-void __init acpi_gic_init(void)
-{
-	struct acpi_table_header *table;
-	acpi_status status;
-	acpi_size tbl_size;
-	int err;
-
-	if (acpi_disabled)
-		return;
-
-	status = acpi_get_table_with_size(ACPI_SIG_MADT, 0, &table, &tbl_size);
-	if (ACPI_FAILURE(status)) {
-		const char *msg = acpi_format_exception(status);
-
-		pr_err("Failed to get MADT table, %s\n", msg);
-		return;
-	}
-
-	err = gic_v2_acpi_init(table);
-	if (err)
-		pr_err("Failed to initialize GIC IRQ controller");
-
-	early_acpi_os_unmap_memory((char *)table, tbl_size);
-}

commit 89e44b51cc0db50ea4b5bbb5d582c4db88bbaed8
Author: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
Date:   Fri Sep 4 14:11:41 2015 +0100

    arm64, acpi/apei: Implement arch_apei_get_mem_attributes()
    
    Table 8 of UEFI 2.5 section 2.3.6.1 defines mappings from EFI
    memory types to MAIR attribute encodings for arm64.
    
    If the physical address has memory attributes defined by EFI
    memmap as EFI_MEMORY_[UC|WC|WT], return approprate page
    protection type according to the UEFI spec. Otherwise, return
    PAGE_KERNEL.
    
    Signed-off-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    [ Small stylistic tweaks. ]
    Reviewed-by: Matt Fleming <matt.fleming@intel.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Link: http://lkml.kernel.org/r/1441372302-23242-2-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 19de7537e7d3..137d537ddceb 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -29,6 +29,11 @@
 #include <asm/cpu_ops.h>
 #include <asm/smp_plat.h>
 
+#ifdef CONFIG_ACPI_APEI
+# include <linux/efi.h>
+# include <asm/pgtable.h>
+#endif
+
 int acpi_noirq = 1;		/* skip ACPI IRQ initialization */
 int acpi_disabled = 1;
 EXPORT_SYMBOL(acpi_disabled);
@@ -230,3 +235,27 @@ void __init acpi_gic_init(void)
 
 	early_acpi_os_unmap_memory((char *)table, tbl_size);
 }
+
+#ifdef CONFIG_ACPI_APEI
+pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)
+{
+	/*
+	 * According to "Table 8 Map: EFI memory types to AArch64 memory
+	 * types" of UEFI 2.5 section 2.3.6.1, each EFI memory type is
+	 * mapped to a corresponding MAIR attribute encoding.
+	 * The EFI memory attribute advises all possible capabilities
+	 * of a memory region. We use the most efficient capability.
+	 */
+
+	u64 attr;
+
+	attr = efi_mem_attributes(addr);
+	if (attr & EFI_MEMORY_WB)
+		return PAGE_KERNEL;
+	if (attr & EFI_MEMORY_WT)
+		return __pgprot(PROT_NORMAL_WT);
+	if (attr & EFI_MEMORY_WC)
+		return __pgprot(PROT_NORMAL_NC);
+	return __pgprot(PROT_DEVICE_nGnRnE);
+}
+#endif

commit c5a1330573c1748179898f4799f130e416ce4738
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Apr 30 14:22:04 2015 +0100

    arm64: psci: remove ACPI coupling
    
    The 32-bit ARM port doesn't have ACPI headers, and conditionally
    including them is going to look horrendous. In preparation for sharing
    the PSCI invocation code with 32-bit, move the acpi_psci_* function
    declarations and definitions such that the PSCI client code need not
    include ACPI headers.
    
    While it would seem like we could simply hide the ACPI includes in
    psci.h, the ACPI headers have hilarious circular dependencies which make
    this infeasible without reorganising most of ACPICA. So rather than
    doing that, move the acpi_psci_* prototypes into psci.h.
    
    The psci_acpi_init function is made dependent on CONFIG_ACPI (with a
    stub implementation in asm/psci.h) such that it need not be built for
    32-bit ARM or kernels without ACPI support. The currently missing __init
    annotations are added to the prototypes in the header.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Al Stone <al.stone@linaro.org>
    Reviewed-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 732f57b8731b..19de7537e7d3 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -89,6 +89,17 @@ void __init __acpi_unmap_table(char *map, unsigned long size)
 	early_memunmap(map, size);
 }
 
+bool __init acpi_psci_present(void)
+{
+	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_COMPLIANT;
+}
+
+/* Whether HVC must be used instead of SMC as the PSCI conduit */
+bool __init acpi_psci_use_hvc(void)
+{
+	return acpi_gbl_FADT.arm_boot_flags & ACPI_FADT_PSCI_USE_HVC;
+}
+
 /*
  * acpi_fadt_sanity_check() - Check FADT presence and carry out sanity
  *			      checks on it

commit 0f0783365cbb7ec13a8f02198f6e1a146d94a5a9
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 13 14:12:47 2015 +0100

    ARM64: kernel: unify ACPI and DT cpus initialization
    
    The code that initializes cpus on arm64 is currently split in two
    different code paths that carry out DT and ACPI cpus initialization.
    
    Most of the code executing SMP initialization is common and should
    be merged to reduce discrepancies between ACPI and DT initialization
    and to have code initializing cpus in a single common place in the
    kernel.
    
    This patch refactors arm64 SMP cpus initialization code to merge
    ACPI and DT boot paths in a common file and to create sanity
    checks that can be reused by both boot methods.
    
    Current code assumes PSCI is the only available boot method
    when arm64 boots with ACPI; this can be easily extended if/when
    the ACPI parking protocol is merged into the kernel.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com> [DT]
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 945cc1fb3c78..732f57b8731b 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -36,12 +36,6 @@ EXPORT_SYMBOL(acpi_disabled);
 int acpi_pci_disabled = 1;	/* skip ACPI PCI scan and IRQ initialization */
 EXPORT_SYMBOL(acpi_pci_disabled);
 
-/* Processors with enabled flag and sane MPIDR */
-static int enabled_cpus;
-
-/* Boot CPU is valid or not in MADT */
-static bool bootcpu_valid  __initdata;
-
 static bool param_acpi_off __initdata;
 static bool param_acpi_force __initdata;
 
@@ -95,124 +89,6 @@ void __init __acpi_unmap_table(char *map, unsigned long size)
 	early_memunmap(map, size);
 }
 
-/**
- * acpi_map_gic_cpu_interface - generates a logical cpu number
- * and map to MPIDR represented by GICC structure
- */
-static void __init
-acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
-{
-	int i;
-	u64 mpidr = processor->arm_mpidr & MPIDR_HWID_BITMASK;
-	bool enabled = !!(processor->flags & ACPI_MADT_ENABLED);
-
-	if (mpidr == INVALID_HWID) {
-		pr_info("Skip MADT cpu entry with invalid MPIDR\n");
-		return;
-	}
-
-	total_cpus++;
-	if (!enabled)
-		return;
-
-	if (enabled_cpus >=  NR_CPUS) {
-		pr_warn("NR_CPUS limit of %d reached, Processor %d/0x%llx ignored.\n",
-			NR_CPUS, total_cpus, mpidr);
-		return;
-	}
-
-	/* Check if GICC structure of boot CPU is available in the MADT */
-	if (cpu_logical_map(0) == mpidr) {
-		if (bootcpu_valid) {
-			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
-			       mpidr);
-			return;
-		}
-
-		bootcpu_valid = true;
-	}
-
-	/*
-	 * Duplicate MPIDRs are a recipe for disaster. Scan
-	 * all initialized entries and check for
-	 * duplicates. If any is found just ignore the CPU.
-	 */
-	for (i = 1; i < enabled_cpus; i++) {
-		if (cpu_logical_map(i) == mpidr) {
-			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
-			       mpidr);
-			return;
-		}
-	}
-
-	if (!acpi_psci_present())
-		return;
-
-	cpu_ops[enabled_cpus] = cpu_get_ops("psci");
-	/* CPU 0 was already initialized */
-	if (enabled_cpus) {
-		if (!cpu_ops[enabled_cpus])
-			return;
-
-		if (cpu_ops[enabled_cpus]->cpu_init(enabled_cpus))
-			return;
-
-		/* map the logical cpu id to cpu MPIDR */
-		cpu_logical_map(enabled_cpus) = mpidr;
-	}
-
-	enabled_cpus++;
-}
-
-static int __init
-acpi_parse_gic_cpu_interface(struct acpi_subtable_header *header,
-				const unsigned long end)
-{
-	struct acpi_madt_generic_interrupt *processor;
-
-	processor = (struct acpi_madt_generic_interrupt *)header;
-
-	if (BAD_MADT_ENTRY(processor, end))
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-	acpi_map_gic_cpu_interface(processor);
-	return 0;
-}
-
-/* Parse GIC cpu interface entries in MADT for SMP init */
-void __init acpi_init_cpus(void)
-{
-	int count, i;
-
-	/*
-	 * do a partial walk of MADT to determine how many CPUs
-	 * we have including disabled CPUs, and get information
-	 * we need for SMP init
-	 */
-	count = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_INTERRUPT,
-			acpi_parse_gic_cpu_interface, 0);
-
-	if (!count) {
-		pr_err("No GIC CPU interface entries present\n");
-		return;
-	} else if (count < 0) {
-		pr_err("Error parsing GIC CPU interface entry\n");
-		return;
-	}
-
-	if (!bootcpu_valid) {
-		pr_err("MADT missing boot CPU MPIDR, not enabling secondaries\n");
-		return;
-	}
-
-	for (i = 0; i < enabled_cpus; i++)
-		set_cpu_possible(i, true);
-
-	/* Make boot-up look pretty */
-	pr_info("%d CPUs enabled, %d CPUs total\n", enabled_cpus, total_cpus);
-}
-
 /*
  * acpi_fadt_sanity_check() - Check FADT presence and carry out sanity
  *			      checks on it

commit 819a88263d5dbe398edd59cc1cf725ed1fdcfd79
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 13 14:12:46 2015 +0100

    ARM64: kernel: make cpu_ops hooks DT agnostic
    
    ARM64 CPU operations such as cpu_init and cpu_init_idle take
    a struct device_node pointer as a parameter, which corresponds to
    the device tree node of the logical cpu on which the operation
    has to be applied.
    
    With the advent of ACPI on arm64, where MADT static table entries
    are used to initialize cpus, the device tree node parameter
    in cpu_ops hooks become useless when booting with ACPI, since
    in that case cpu device tree nodes are not present and can not be
    used for cpu initialization.
    
    The current cpu_init hook requires a struct device_node pointer
    parameter because it is called while parsing the device tree to
    initialize CPUs, when the cpu_logical_map (that is used to match
    a cpu node reg property to a device tree node) for a given logical
    cpu id is not set up yet. This means that the cpu_init hook cannot
    rely on the of_get_cpu_node function to retrieve the device tree
    node corresponding to the logical cpu id passed in as parameter,
    so the cpu device tree node must be passed in as a parameter to fix
    this catch-22 dependency cycle.
    
    This patch reshuffles the cpu_logical_map initialization code so
    that the cpu_init cpu_ops hook can safely use the of_get_cpu_node
    function to retrieve the cpu device tree node, removing the need for
    the device tree node pointer parameter.
    
    In the process, the patch removes device tree node parameters
    from all cpu_ops hooks, in preparation for SMP DT/ACPI cpus
    initialization consolidation.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com> [DT]
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 8b839558838e..945cc1fb3c78 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -154,7 +154,7 @@ acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 		if (!cpu_ops[enabled_cpus])
 			return;
 
-		if (cpu_ops[enabled_cpus]->cpu_init(NULL, enabled_cpus))
+		if (cpu_ops[enabled_cpus]->cpu_init(enabled_cpus))
 			return;
 
 		/* map the logical cpu id to cpu MPIDR */

commit 7676fa70feb2f3bcdd4b854a553a57d8ef8505aa
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Fri Mar 27 12:14:36 2015 +0000

    ARM64 / ACPI: make acpi_map_gic_cpu_interface() as void function
    
    Since the only caller of acpi_parse_gic_cpu_interface() doesn't
    need the return value, make it have a void return type to avoid
    introducing subtle bugs, and update the comments of the function
    accordingly.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index c263cbaa6484..8b839558838e 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -98,12 +98,8 @@ void __init __acpi_unmap_table(char *map, unsigned long size)
 /**
  * acpi_map_gic_cpu_interface - generates a logical cpu number
  * and map to MPIDR represented by GICC structure
- * @mpidr: CPU's hardware id to register, MPIDR represented in MADT
- * @enabled: this cpu is enabled or not
- *
- * Returns the logical cpu number which maps to MPIDR
  */
-static int __init
+static void __init
 acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 {
 	int i;
@@ -112,17 +108,17 @@ acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 
 	if (mpidr == INVALID_HWID) {
 		pr_info("Skip MADT cpu entry with invalid MPIDR\n");
-		return -EINVAL;
+		return;
 	}
 
 	total_cpus++;
 	if (!enabled)
-		return -EINVAL;
+		return;
 
 	if (enabled_cpus >=  NR_CPUS) {
 		pr_warn("NR_CPUS limit of %d reached, Processor %d/0x%llx ignored.\n",
 			NR_CPUS, total_cpus, mpidr);
-		return -EINVAL;
+		return;
 	}
 
 	/* Check if GICC structure of boot CPU is available in the MADT */
@@ -130,7 +126,7 @@ acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 		if (bootcpu_valid) {
 			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
 			       mpidr);
-			return -EINVAL;
+			return;
 		}
 
 		bootcpu_valid = true;
@@ -145,28 +141,27 @@ acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 		if (cpu_logical_map(i) == mpidr) {
 			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
 			       mpidr);
-			return -EINVAL;
+			return;
 		}
 	}
 
 	if (!acpi_psci_present())
-		return -EOPNOTSUPP;
+		return;
 
 	cpu_ops[enabled_cpus] = cpu_get_ops("psci");
 	/* CPU 0 was already initialized */
 	if (enabled_cpus) {
 		if (!cpu_ops[enabled_cpus])
-			return -EINVAL;
+			return;
 
 		if (cpu_ops[enabled_cpus]->cpu_init(NULL, enabled_cpus))
-			return -EOPNOTSUPP;
+			return;
 
 		/* map the logical cpu id to cpu MPIDR */
 		cpu_logical_map(enabled_cpus) = mpidr;
 	}
 
 	enabled_cpus++;
-	return enabled_cpus;
 }
 
 static int __init

commit ec81ad4eca9736bb73d4458fb7d8a5ccaf3e908e
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Fri Mar 27 12:14:35 2015 +0000

    ARM64 / ACPI: Ignore the return error value of acpi_map_gic_cpu_interface()
    
    MADT scanning will stop when it gets an error from the handler,
    acpi_map_gic_cpu_interface(), on arm64.  However, we need to
    find all of the enabled CPUs so that SMP initialization can work
    properly.  So, if an error occurs in this case, ignore it for
    now so that we can find all of the enabled CPUs.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 07649e413244..c263cbaa6484 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -181,7 +181,8 @@ acpi_parse_gic_cpu_interface(struct acpi_subtable_header *header,
 		return -EINVAL;
 
 	acpi_table_print_madt_entry(header);
-	return acpi_map_gic_cpu_interface(processor);
+	acpi_map_gic_cpu_interface(processor);
+	return 0;
 }
 
 /* Parse GIC cpu interface entries in MADT for SMP init */

commit 8ef320319592693f4a6286d80df210fd47b3e356
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Mar 26 15:09:20 2015 +0000

    ARM64 / ACPI: fix usage of acpi_map_gic_cpu_interface
    
    acpi_parse_gic_cpu_interface calls acpi_map_gic_cpu_interface by both
    passing a 32-bit value in the u8 enabled parameter and then subsequently
    ignoring its return value.
    
    Sort it out.
    
    Reported-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index cd60329da8c4..07649e413244 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -103,9 +103,12 @@ void __init __acpi_unmap_table(char *map, unsigned long size)
  *
  * Returns the logical cpu number which maps to MPIDR
  */
-static int __init acpi_map_gic_cpu_interface(u64 mpidr, u8 enabled)
+static int __init
+acpi_map_gic_cpu_interface(struct acpi_madt_generic_interrupt *processor)
 {
 	int i;
+	u64 mpidr = processor->arm_mpidr & MPIDR_HWID_BITMASK;
+	bool enabled = !!(processor->flags & ACPI_MADT_ENABLED);
 
 	if (mpidr == INVALID_HWID) {
 		pr_info("Skip MADT cpu entry with invalid MPIDR\n");
@@ -178,11 +181,7 @@ acpi_parse_gic_cpu_interface(struct acpi_subtable_header *header,
 		return -EINVAL;
 
 	acpi_table_print_madt_entry(header);
-
-	acpi_map_gic_cpu_interface(processor->arm_mpidr & MPIDR_HWID_BITMASK,
-		processor->flags & ACPI_MADT_ENABLED);
-
-	return 0;
+	return acpi_map_gic_cpu_interface(processor);
 }
 
 /* Parse GIC cpu interface entries in MADT for SMP init */

commit fb094eb19900937322848beaf1a622c6afb6250b
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Mar 25 15:22:13 2015 +0000

    ARM64: kernel: acpi: honour acpi=force command line parameter
    
    If acpi=force is passed on the command line, it forces ACPI to be
    the only available boot method, hence it must be left enabled even
    if the initialization and sanity checks on ACPI tables fails.
    
    This patch refactors ACPI initialization to prevent disabling ACPI
    if acpi=force is passed on the command line.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 172b7c9f6881..cd60329da8c4 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -43,7 +43,7 @@ static int enabled_cpus;
 static bool bootcpu_valid  __initdata;
 
 static bool param_acpi_off __initdata;
-bool param_acpi_force __initdata;
+static bool param_acpi_force __initdata;
 
 static int __init parse_acpi(char *arg)
 {
@@ -284,8 +284,13 @@ static int __init acpi_fadt_sanity_check(void)
  * We can parse ACPI boot-time tables such as MADT after
  * this function is called.
  *
- * ACPI is enabled on return if ACPI tables initialized and sanity checks
- * passed, disabled otherwise
+ * On return ACPI is enabled if either:
+ *
+ * - ACPI tables are initialized and sanity checks passed
+ * - acpi=force was passed in the command line and ACPI was not disabled
+ *   explicitly through acpi=off command line parameter
+ *
+ * ACPI is disabled on function return otherwise
  */
 void __init acpi_boot_table_init(void)
 {
@@ -309,10 +314,13 @@ void __init acpi_boot_table_init(void)
 	 * If ACPI tables are initialized and FADT sanity checks passed,
 	 * leave ACPI enabled and carry on booting; otherwise disable ACPI
 	 * on initialization error.
+	 * If acpi=force was passed on the command line it forces ACPI
+	 * to be enabled even if its initialization failed.
 	 */
 	if (acpi_table_init() || acpi_fadt_sanity_check()) {
 		pr_err("Failed to init ACPI tables\n");
-		disable_acpi();
+		if (!param_acpi_force)
+			disable_acpi();
 	}
 }
 

commit 54971e43b9d6cb37366d2da64cc5a2d8f8102bc4
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Mar 25 15:13:56 2015 +0000

    ARM64: kernel: acpi: refactor ACPI tables init and checks
    
    Current ACPI init code on ARM64 relies on acpi_table_parse() API to
    check if the FADT is present and to carry out sanity checks on that.
    
    The handler passed to the acpi_table_parse() function and used to
    carry out the parsing on the requested table returns a value that is
    ignored by the acpi_table_parse() function, so it is not possible
    to propagate errors back to the acpi_table_parse() caller through
    the handler.
    
    This forces ARM64 ACPI init code to have disable_acpi() calls scattered
    all over the place that makes code unwieldy and not easy to follow.
    
    This patch refactors the ARM64 ACPI init code, by creating a
    self-contained function (ie acpi_fadt_sanity_check()) that carries
    out the required checks on FADT and returns an adequate return value
    to the caller. This allows creating a common error path that disables
    ACPI and makes code more readable and easy to parse and change were
    further checks FADT to be added in the future.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index a70f7141c0f6..172b7c9f6881 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -218,43 +218,60 @@ void __init acpi_init_cpus(void)
 	pr_info("%d CPUs enabled, %d CPUs total\n", enabled_cpus, total_cpus);
 }
 
-static int __init acpi_parse_fadt(struct acpi_table_header *table)
+/*
+ * acpi_fadt_sanity_check() - Check FADT presence and carry out sanity
+ *			      checks on it
+ *
+ * Return 0 on success,  <0 on failure
+ */
+static int __init acpi_fadt_sanity_check(void)
 {
-	struct acpi_table_fadt *fadt = (struct acpi_table_fadt *)table;
+	struct acpi_table_header *table;
+	struct acpi_table_fadt *fadt;
+	acpi_status status;
+	acpi_size tbl_size;
+	int ret = 0;
+
+	/*
+	 * FADT is required on arm64; retrieve it to check its presence
+	 * and carry out revision and ACPI HW reduced compliancy tests
+	 */
+	status = acpi_get_table_with_size(ACPI_SIG_FADT, 0, &table, &tbl_size);
+	if (ACPI_FAILURE(status)) {
+		const char *msg = acpi_format_exception(status);
+
+		pr_err("Failed to get FADT table, %s\n", msg);
+		return -ENODEV;
+	}
+
+	fadt = (struct acpi_table_fadt *)table;
 
 	/*
 	 * Revision in table header is the FADT Major revision, and there
 	 * is a minor revision of FADT which was introduced by ACPI 5.1,
 	 * we only deal with ACPI 5.1 or newer revision to get GIC and SMP
-	 * boot protocol configuration data, or we will disable ACPI.
+	 * boot protocol configuration data.
 	 */
-	if (table->revision > 5 ||
-	    (table->revision == 5 && fadt->minor_revision >= 1)) {
-		if (!acpi_gbl_reduced_hardware) {
-			pr_err("Not hardware reduced ACPI mode, will not be supported\n");
-			goto disable_acpi;
-		}
-
-		/*
-		 * ACPI 5.1 only has two explicit methods to boot up SMP,
-		 * PSCI and Parking protocol, but the Parking protocol is
-		 * only specified for ARMv7 now, so make PSCI as the only
-		 * way for the SMP boot protocol before some updates for
-		 * the Parking protocol spec.
-		 */
-		if (acpi_psci_present())
-			return 0;
-
-		pr_warn("No PSCI support, will not bring up secondary CPUs\n");
-		return -EOPNOTSUPP;
+	if (table->revision < 5 ||
+	   (table->revision == 5 && fadt->minor_revision < 1)) {
+		pr_err("Unsupported FADT revision %d.%d, should be 5.1+\n",
+		       table->revision, fadt->minor_revision);
+		ret = -EINVAL;
+		goto out;
 	}
 
-	pr_warn("Unsupported FADT revision %d.%d, should be 5.1+, will disable ACPI\n",
-		table->revision, fadt->minor_revision);
+	if (!(fadt->flags & ACPI_FADT_HW_REDUCED)) {
+		pr_err("FADT not ACPI hardware reduced compliant\n");
+		ret = -EINVAL;
+	}
 
-disable_acpi:
-	disable_acpi();
-	return -EINVAL;
+out:
+	/*
+	 * acpi_get_table_with_size() creates FADT table mapping that
+	 * should be released after parsing and before resuming boot
+	 */
+	early_acpi_os_unmap_memory(table, tbl_size);
+	return ret;
 }
 
 /*
@@ -262,9 +279,13 @@ static int __init acpi_parse_fadt(struct acpi_table_header *table)
  *	1. find RSDP and get its address, and then find XSDT
  *	2. extract all tables and checksums them all
  *	3. check ACPI FADT revision
+ *	4. check ACPI FADT HW reduced flag
  *
  * We can parse ACPI boot-time tables such as MADT after
  * this function is called.
+ *
+ * ACPI is enabled on return if ACPI tables initialized and sanity checks
+ * passed, disabled otherwise
  */
 void __init acpi_boot_table_init(void)
 {
@@ -278,18 +299,20 @@ void __init acpi_boot_table_init(void)
 	    (!param_acpi_force && of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
 		return;
 
+	/*
+	 * ACPI is disabled at this point. Enable it in order to parse
+	 * the ACPI tables and carry out sanity checks
+	 */
 	enable_acpi();
 
-	/* Initialize the ACPI boot-time table parser. */
-	if (acpi_table_init()) {
-		disable_acpi();
-		return;
-	}
-
-	if (acpi_table_parse(ACPI_SIG_FADT, acpi_parse_fadt)) {
-		/* disable ACPI if no FADT is found */
+	/*
+	 * If ACPI tables are initialized and FADT sanity checks passed,
+	 * leave ACPI enabled and carry on booting; otherwise disable ACPI
+	 * on initialization error.
+	 */
+	if (acpi_table_init() || acpi_fadt_sanity_check()) {
+		pr_err("Failed to init ACPI tables\n");
 		disable_acpi();
-		pr_err("Can't find FADT\n");
 	}
 }
 

commit d8f4f161e31f3ee9768467344e6cc31a0b9d9249
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Mar 24 17:58:51 2015 +0000

    ACPI: move arm64 GSI IRQ model to generic GSI IRQ layer
    
    The code deployed to implement GSI linux IRQ numbers mapping on arm64 turns
    out to be generic enough so that it can be moved to ACPI core code along
    with its respective config option ACPI_GENERIC_GSI selectable on
    architectures that can reuse the same code.
    
    Current ACPI IRQ mapping code is not integrated in the kernel IRQ domain
    infrastructure, in particular there is no way to look-up the
    IRQ domain associated with a particular interrupt controller, so this
    first version of GSI generic code carries out the GSI<->IRQ mapping relying
    on the IRQ default domain which is supposed to be always set on a
    specific architecture in case the domain structure passed to
    irq_create/find_mapping() functions is missing.
    
    This patch moves the arm64 acpi functions that implement the gsi mappings:
    
    acpi_gsi_to_irq()
    acpi_register_gsi()
    acpi_unregister_gsi()
    
    to ACPI core code. Since the generic GSI<->domain mapping is based on IRQ
    domains, it can be extended as soon as a way to map an interrupt
    controller to an IRQ domain is implemented for ACPI in the IRQ domain
    layer.
    
    x86 and ia64 code for GSI mappings cannot rely on the generic GSI
    layer at present for legacy reasons, so they do not select the
    ACPI_GENERIC_GSI config options and keep relying on their arch
    specific GSI mapping layer.
    
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index fe9d8f0df4a3..a70f7141c0f6 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -75,12 +75,6 @@ static int __init dt_scan_depth1_nodes(unsigned long node,
 	return 0;
 }
 
-/*
- * Since we're on ARM, the default interrupt routing model
- * clearly has to be GIC.
- */
-enum acpi_irq_model_id acpi_irq_model = ACPI_IRQ_MODEL_GIC;
-
 /*
  * __acpi_map_table() will be called before page_init(), so early_ioremap()
  * or early_memremap() should be called here to for ACPI table mapping.
@@ -224,73 +218,6 @@ void __init acpi_init_cpus(void)
 	pr_info("%d CPUs enabled, %d CPUs total\n", enabled_cpus, total_cpus);
 }
 
-int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
-{
-	*irq = irq_find_mapping(NULL, gsi);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(acpi_gsi_to_irq);
-
-/*
- * success: return IRQ number (>0)
- * failure: return =< 0
- */
-int acpi_register_gsi(struct device *dev, u32 gsi, int trigger, int polarity)
-{
-	unsigned int irq;
-	unsigned int irq_type;
-
-	/*
-	 * ACPI have no bindings to indicate SPI or PPI, so we
-	 * use different mappings from DT in ACPI.
-	 *
-	 * For FDT
-	 * PPI interrupt: in the range [0, 15];
-	 * SPI interrupt: in the range [0, 987];
-	 *
-	 * For ACPI, GSI should be unique so using
-	 * the hwirq directly for the mapping:
-	 * PPI interrupt: in the range [16, 31];
-	 * SPI interrupt: in the range [32, 1019];
-	 */
-
-	if (trigger == ACPI_EDGE_SENSITIVE &&
-				polarity == ACPI_ACTIVE_LOW)
-		irq_type = IRQ_TYPE_EDGE_FALLING;
-	else if (trigger == ACPI_EDGE_SENSITIVE &&
-				polarity == ACPI_ACTIVE_HIGH)
-		irq_type = IRQ_TYPE_EDGE_RISING;
-	else if (trigger == ACPI_LEVEL_SENSITIVE &&
-				polarity == ACPI_ACTIVE_LOW)
-		irq_type = IRQ_TYPE_LEVEL_LOW;
-	else if (trigger == ACPI_LEVEL_SENSITIVE &&
-				polarity == ACPI_ACTIVE_HIGH)
-		irq_type = IRQ_TYPE_LEVEL_HIGH;
-	else
-		irq_type = IRQ_TYPE_NONE;
-
-	/*
-	 * Since only one GIC is supported in ACPI 5.0, we can
-	 * create mapping refer to the default domain
-	 */
-	irq = irq_create_mapping(NULL, gsi);
-	if (!irq)
-		return irq;
-
-	/* Set irq type if specified and different than the current one */
-	if (irq_type != IRQ_TYPE_NONE &&
-		irq_type != irq_get_trigger_type(irq))
-		irq_set_irq_type(irq, irq_type);
-	return irq;
-}
-EXPORT_SYMBOL_GPL(acpi_register_gsi);
-
-void acpi_unregister_gsi(u32 gsi)
-{
-}
-EXPORT_SYMBOL_GPL(acpi_unregister_gsi);
-
 static int __init acpi_parse_fadt(struct acpi_table_header *table)
 {
 	struct acpi_table_fadt *fadt = (struct acpi_table_fadt *)table;

commit 33757ded074918eb49243968a82e7c9ec2d71720
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:56 2015 +0000

    ARM64 / ACPI: Don't unflatten device tree if acpi=force is passed
    
    Since the policy is that once we pass acpi=force in the early
    param, we will not unflatten device tree even if ACPI is disabled
    in ACPI table init fails, so fix the code by comparinging both
    acpi_disabled and param_acpi_force before the device tree is
    unflattened.
    
    CC: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 5819ef7aa2c3..fe9d8f0df4a3 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -43,7 +43,7 @@ static int enabled_cpus;
 static bool bootcpu_valid  __initdata;
 
 static bool param_acpi_off __initdata;
-static bool param_acpi_force __initdata;
+bool param_acpi_force __initdata;
 
 static int __init parse_acpi(char *arg)
 {

commit 6933de0ca0b7656db94f67731c8c53c7dcacae3a
Author: Al Stone <al.stone@linaro.org>
Date:   Tue Mar 24 14:02:51 2015 +0000

    ARM64 / ACPI: Select ACPI_REDUCED_HARDWARE_ONLY if ACPI is enabled on ARM64
    
    ACPI reduced hardware mode is disabled by default, but ARM64
    can only run properly in ACPI hardware reduced mode, so select
    ACPI_REDUCED_HARDWARE_ONLY if ACPI is enabled on ARM64.
    
    If the firmware is not using hardware reduced ACPI mode, we
    will disable ACPI to avoid nightmare such as accessing some
    registers which are not available on ARM64.
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 6468f8898530..5819ef7aa2c3 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -303,6 +303,11 @@ static int __init acpi_parse_fadt(struct acpi_table_header *table)
 	 */
 	if (table->revision > 5 ||
 	    (table->revision == 5 && fadt->minor_revision >= 1)) {
+		if (!acpi_gbl_reduced_hardware) {
+			pr_err("Not hardware reduced ACPI mode, will not be supported\n");
+			goto disable_acpi;
+		}
+
 		/*
 		 * ACPI 5.1 only has two explicit methods to boot up SMP,
 		 * PSCI and Parking protocol, but the Parking protocol is
@@ -319,8 +324,9 @@ static int __init acpi_parse_fadt(struct acpi_table_header *table)
 
 	pr_warn("Unsupported FADT revision %d.%d, should be 5.1+, will disable ACPI\n",
 		table->revision, fadt->minor_revision);
-	disable_acpi();
 
+disable_acpi:
+	disable_acpi();
 	return -EINVAL;
 }
 

commit d60fc3892c4de4a25658786f941690462c5a5bab
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Tue Mar 24 14:02:49 2015 +0000

    irqchip: Add GICv2 specific ACPI boot support
    
    ACPI kernel uses MADT table for proper GIC initialization. It needs to
    parse GIC related subtables, collect CPU interface and distributor
    addresses and call driver initialization function (which is hardware
    abstraction agnostic). In a similar way, FDT initialize GICv1/2.
    
    NOTE: This commit allow to initialize GICv1/2 basic functionality.
    While now simple GICv2 init call is used, any further GIC features
    require generic infrastructure for proper ACPI irqchip initialization.
    That mechanism and stacked irqdomains to support GICv2 MSI/virtualization
    extension, GICv3/4 and its ITS are considered as next steps.
    
    CC: Jason Cooper <jason@lakedaemon.net>
    CC: Marc Zyngier <marc.zyngier@arm.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index dec6f8aed3dc..6468f8898530 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -359,3 +359,28 @@ void __init acpi_boot_table_init(void)
 		pr_err("Can't find FADT\n");
 	}
 }
+
+void __init acpi_gic_init(void)
+{
+	struct acpi_table_header *table;
+	acpi_status status;
+	acpi_size tbl_size;
+	int err;
+
+	if (acpi_disabled)
+		return;
+
+	status = acpi_get_table_with_size(ACPI_SIG_MADT, 0, &table, &tbl_size);
+	if (ACPI_FAILURE(status)) {
+		const char *msg = acpi_format_exception(status);
+
+		pr_err("Failed to get MADT table, %s\n", msg);
+		return;
+	}
+
+	err = gic_v2_acpi_init(table);
+	if (err)
+		pr_err("Failed to initialize GIC IRQ controller");
+
+	early_acpi_os_unmap_memory((char *)table, tbl_size);
+}

commit fbe61ec71ac975279cd47b6c299d5e33f63aac4e
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:48 2015 +0000

    ARM64 / ACPI: Introduce ACPI_IRQ_MODEL_GIC and register device's gsi
    
    Introduce ACPI_IRQ_MODEL_GIC which is needed for ARM64 as GIC is
    used, and then register device's gsi with the core IRQ subsystem.
    
    acpi_register_gsi() is similar to DT based irq_of_parse_and_map(),
    since gsi is unique in the system, so use hwirq number directly
    for the mapping.
    
    We are going to implement stacked domains when GICv2m, GICv3, ITS
    support are added.
    
    CC: Marc Zyngier <marc.zyngier@arm.com>
    Originally-by: Amit Daniel Kachhap <amit.daniel@samsung.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index c9203c0a1179..dec6f8aed3dc 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -75,6 +75,12 @@ static int __init dt_scan_depth1_nodes(unsigned long node,
 	return 0;
 }
 
+/*
+ * Since we're on ARM, the default interrupt routing model
+ * clearly has to be GIC.
+ */
+enum acpi_irq_model_id acpi_irq_model = ACPI_IRQ_MODEL_GIC;
+
 /*
  * __acpi_map_table() will be called before page_init(), so early_ioremap()
  * or early_memremap() should be called here to for ACPI table mapping.
@@ -218,6 +224,73 @@ void __init acpi_init_cpus(void)
 	pr_info("%d CPUs enabled, %d CPUs total\n", enabled_cpus, total_cpus);
 }
 
+int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
+{
+	*irq = irq_find_mapping(NULL, gsi);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_gsi_to_irq);
+
+/*
+ * success: return IRQ number (>0)
+ * failure: return =< 0
+ */
+int acpi_register_gsi(struct device *dev, u32 gsi, int trigger, int polarity)
+{
+	unsigned int irq;
+	unsigned int irq_type;
+
+	/*
+	 * ACPI have no bindings to indicate SPI or PPI, so we
+	 * use different mappings from DT in ACPI.
+	 *
+	 * For FDT
+	 * PPI interrupt: in the range [0, 15];
+	 * SPI interrupt: in the range [0, 987];
+	 *
+	 * For ACPI, GSI should be unique so using
+	 * the hwirq directly for the mapping:
+	 * PPI interrupt: in the range [16, 31];
+	 * SPI interrupt: in the range [32, 1019];
+	 */
+
+	if (trigger == ACPI_EDGE_SENSITIVE &&
+				polarity == ACPI_ACTIVE_LOW)
+		irq_type = IRQ_TYPE_EDGE_FALLING;
+	else if (trigger == ACPI_EDGE_SENSITIVE &&
+				polarity == ACPI_ACTIVE_HIGH)
+		irq_type = IRQ_TYPE_EDGE_RISING;
+	else if (trigger == ACPI_LEVEL_SENSITIVE &&
+				polarity == ACPI_ACTIVE_LOW)
+		irq_type = IRQ_TYPE_LEVEL_LOW;
+	else if (trigger == ACPI_LEVEL_SENSITIVE &&
+				polarity == ACPI_ACTIVE_HIGH)
+		irq_type = IRQ_TYPE_LEVEL_HIGH;
+	else
+		irq_type = IRQ_TYPE_NONE;
+
+	/*
+	 * Since only one GIC is supported in ACPI 5.0, we can
+	 * create mapping refer to the default domain
+	 */
+	irq = irq_create_mapping(NULL, gsi);
+	if (!irq)
+		return irq;
+
+	/* Set irq type if specified and different than the current one */
+	if (irq_type != IRQ_TYPE_NONE &&
+		irq_type != irq_get_trigger_type(irq))
+		irq_set_irq_type(irq, irq_type);
+	return irq;
+}
+EXPORT_SYMBOL_GPL(acpi_register_gsi);
+
+void acpi_unregister_gsi(u32 gsi)
+{
+}
+EXPORT_SYMBOL_GPL(acpi_unregister_gsi);
+
 static int __init acpi_parse_fadt(struct acpi_table_header *table)
 {
 	struct acpi_table_fadt *fadt = (struct acpi_table_fadt *)table;

commit fccb9a81fd08b61bed91ddef88341694f8ecbfd1
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 22:02:45 2015 +0800

    ARM64 / ACPI: Parse MADT for SMP initialization
    
    MADT contains the information for MPIDR which is essential for
    SMP initialization, parse the GIC cpu interface structures to
    get the MPIDR value and map it to cpu_logical_map(), and add
    enabled cpu with valid MPIDR into cpu_possible_map.
    
    ACPI 5.1 only has two explicit methods to boot up SMP, PSCI and
    Parking protocol, but the Parking protocol is only specified for
    ARMv7 now, so make PSCI as the only way for the SMP boot protocol
    before some updates for the ACPI spec or the Parking protocol spec.
    
    Parking protocol patches for SMP boot will be sent to upstream when
    the new version of Parking protocol is ready.
    
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 2269e3032c07..c9203c0a1179 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -25,6 +25,10 @@
 #include <linux/of_fdt.h>
 #include <linux/smp.h>
 
+#include <asm/cputype.h>
+#include <asm/cpu_ops.h>
+#include <asm/smp_plat.h>
+
 int acpi_noirq = 1;		/* skip ACPI IRQ initialization */
 int acpi_disabled = 1;
 EXPORT_SYMBOL(acpi_disabled);
@@ -32,6 +36,12 @@ EXPORT_SYMBOL(acpi_disabled);
 int acpi_pci_disabled = 1;	/* skip ACPI PCI scan and IRQ initialization */
 EXPORT_SYMBOL(acpi_pci_disabled);
 
+/* Processors with enabled flag and sane MPIDR */
+static int enabled_cpus;
+
+/* Boot CPU is valid or not in MADT */
+static bool bootcpu_valid  __initdata;
+
 static bool param_acpi_off __initdata;
 static bool param_acpi_force __initdata;
 
@@ -85,6 +95,129 @@ void __init __acpi_unmap_table(char *map, unsigned long size)
 	early_memunmap(map, size);
 }
 
+/**
+ * acpi_map_gic_cpu_interface - generates a logical cpu number
+ * and map to MPIDR represented by GICC structure
+ * @mpidr: CPU's hardware id to register, MPIDR represented in MADT
+ * @enabled: this cpu is enabled or not
+ *
+ * Returns the logical cpu number which maps to MPIDR
+ */
+static int __init acpi_map_gic_cpu_interface(u64 mpidr, u8 enabled)
+{
+	int i;
+
+	if (mpidr == INVALID_HWID) {
+		pr_info("Skip MADT cpu entry with invalid MPIDR\n");
+		return -EINVAL;
+	}
+
+	total_cpus++;
+	if (!enabled)
+		return -EINVAL;
+
+	if (enabled_cpus >=  NR_CPUS) {
+		pr_warn("NR_CPUS limit of %d reached, Processor %d/0x%llx ignored.\n",
+			NR_CPUS, total_cpus, mpidr);
+		return -EINVAL;
+	}
+
+	/* Check if GICC structure of boot CPU is available in the MADT */
+	if (cpu_logical_map(0) == mpidr) {
+		if (bootcpu_valid) {
+			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
+			       mpidr);
+			return -EINVAL;
+		}
+
+		bootcpu_valid = true;
+	}
+
+	/*
+	 * Duplicate MPIDRs are a recipe for disaster. Scan
+	 * all initialized entries and check for
+	 * duplicates. If any is found just ignore the CPU.
+	 */
+	for (i = 1; i < enabled_cpus; i++) {
+		if (cpu_logical_map(i) == mpidr) {
+			pr_err("Firmware bug, duplicate CPU MPIDR: 0x%llx in MADT\n",
+			       mpidr);
+			return -EINVAL;
+		}
+	}
+
+	if (!acpi_psci_present())
+		return -EOPNOTSUPP;
+
+	cpu_ops[enabled_cpus] = cpu_get_ops("psci");
+	/* CPU 0 was already initialized */
+	if (enabled_cpus) {
+		if (!cpu_ops[enabled_cpus])
+			return -EINVAL;
+
+		if (cpu_ops[enabled_cpus]->cpu_init(NULL, enabled_cpus))
+			return -EOPNOTSUPP;
+
+		/* map the logical cpu id to cpu MPIDR */
+		cpu_logical_map(enabled_cpus) = mpidr;
+	}
+
+	enabled_cpus++;
+	return enabled_cpus;
+}
+
+static int __init
+acpi_parse_gic_cpu_interface(struct acpi_subtable_header *header,
+				const unsigned long end)
+{
+	struct acpi_madt_generic_interrupt *processor;
+
+	processor = (struct acpi_madt_generic_interrupt *)header;
+
+	if (BAD_MADT_ENTRY(processor, end))
+		return -EINVAL;
+
+	acpi_table_print_madt_entry(header);
+
+	acpi_map_gic_cpu_interface(processor->arm_mpidr & MPIDR_HWID_BITMASK,
+		processor->flags & ACPI_MADT_ENABLED);
+
+	return 0;
+}
+
+/* Parse GIC cpu interface entries in MADT for SMP init */
+void __init acpi_init_cpus(void)
+{
+	int count, i;
+
+	/*
+	 * do a partial walk of MADT to determine how many CPUs
+	 * we have including disabled CPUs, and get information
+	 * we need for SMP init
+	 */
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_INTERRUPT,
+			acpi_parse_gic_cpu_interface, 0);
+
+	if (!count) {
+		pr_err("No GIC CPU interface entries present\n");
+		return;
+	} else if (count < 0) {
+		pr_err("Error parsing GIC CPU interface entry\n");
+		return;
+	}
+
+	if (!bootcpu_valid) {
+		pr_err("MADT missing boot CPU MPIDR, not enabling secondaries\n");
+		return;
+	}
+
+	for (i = 0; i < enabled_cpus; i++)
+		set_cpu_possible(i, true);
+
+	/* Make boot-up look pretty */
+	pr_info("%d CPUs enabled, %d CPUs total\n", enabled_cpus, total_cpus);
+}
+
 static int __init acpi_parse_fadt(struct acpi_table_header *table)
 {
 	struct acpi_table_fadt *fadt = (struct acpi_table_fadt *)table;
@@ -96,8 +229,20 @@ static int __init acpi_parse_fadt(struct acpi_table_header *table)
 	 * boot protocol configuration data, or we will disable ACPI.
 	 */
 	if (table->revision > 5 ||
-	    (table->revision == 5 && fadt->minor_revision >= 1))
-		return 0;
+	    (table->revision == 5 && fadt->minor_revision >= 1)) {
+		/*
+		 * ACPI 5.1 only has two explicit methods to boot up SMP,
+		 * PSCI and Parking protocol, but the Parking protocol is
+		 * only specified for ARMv7 now, so make PSCI as the only
+		 * way for the SMP boot protocol before some updates for
+		 * the Parking protocol spec.
+		 */
+		if (acpi_psci_present())
+			return 0;
+
+		pr_warn("No PSCI support, will not bring up secondary CPUs\n");
+		return -EOPNOTSUPP;
+	}
 
 	pr_warn("Unsupported FADT revision %d.%d, should be 5.1+, will disable ACPI\n",
 		table->revision, fadt->minor_revision);

commit b10d79f76085b577673395daf92d6208ae09196f
Author: Al Stone <al.stone@linaro.org>
Date:   Tue Mar 24 14:02:41 2015 +0000

    ARM64 / ACPI: Introduce early_param "acpi=" to enable/disable ACPI
    
    This implements the following policy to decide whether ACPI should
    be used to boot the system:
    - acpi=off: ACPI will not be used to boot the system, even if there is
      no alternative available (e.g., device tree is empty)
    - acpi=force: only ACPI will be used to boot the system; if that fails,
      there will be no fallback to alternative methods (such as device tree)
    - otherwise, ACPI will be used as a fallback if the device tree turns out
      to lack a platform description; the heuristic to decide this is whether
      /chosen is the only node present at depth 1
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
index 7abac24d5584..2269e3032c07 100644
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@ -22,15 +22,49 @@
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
 #include <linux/memblock.h>
+#include <linux/of_fdt.h>
 #include <linux/smp.h>
 
-int acpi_noirq;			/* skip ACPI IRQ initialization */
-int acpi_disabled;
+int acpi_noirq = 1;		/* skip ACPI IRQ initialization */
+int acpi_disabled = 1;
 EXPORT_SYMBOL(acpi_disabled);
 
-int acpi_pci_disabled;		/* skip ACPI PCI scan and IRQ initialization */
+int acpi_pci_disabled = 1;	/* skip ACPI PCI scan and IRQ initialization */
 EXPORT_SYMBOL(acpi_pci_disabled);
 
+static bool param_acpi_off __initdata;
+static bool param_acpi_force __initdata;
+
+static int __init parse_acpi(char *arg)
+{
+	if (!arg)
+		return -EINVAL;
+
+	/* "acpi=off" disables both ACPI table parsing and interpreter */
+	if (strcmp(arg, "off") == 0)
+		param_acpi_off = true;
+	else if (strcmp(arg, "force") == 0) /* force ACPI to be enabled */
+		param_acpi_force = true;
+	else
+		return -EINVAL;	/* Core will print when we return error */
+
+	return 0;
+}
+early_param("acpi", parse_acpi);
+
+static int __init dt_scan_depth1_nodes(unsigned long node,
+				       const char *uname, int depth,
+				       void *data)
+{
+	/*
+	 * Return 1 as soon as we encounter a node at depth 1 that is
+	 * not the /chosen node.
+	 */
+	if (depth == 1 && (strcmp(uname, "chosen") != 0))
+		return 1;
+	return 0;
+}
+
 /*
  * __acpi_map_table() will be called before page_init(), so early_ioremap()
  * or early_memremap() should be called here to for ACPI table mapping.
@@ -83,10 +117,18 @@ static int __init acpi_parse_fadt(struct acpi_table_header *table)
  */
 void __init acpi_boot_table_init(void)
 {
-	/* If acpi_disabled, bail out */
-	if (acpi_disabled)
+	/*
+	 * Enable ACPI instead of device tree unless
+	 * - ACPI has been disabled explicitly (acpi=off), or
+	 * - the device tree is not empty (it has more than just a /chosen node)
+	 *   and ACPI has not been force enabled (acpi=force)
+	 */
+	if (param_acpi_off ||
+	    (!param_acpi_force && of_scan_flat_dt(dt_scan_depth1_nodes, NULL)))
 		return;
 
+	enable_acpi();
+
 	/* Initialize the ACPI boot-time table parser. */
 	if (acpi_table_init()) {
 		disable_acpi();

commit 37655163ce1a3ef2635a9bba0ad614f25e01484e
Author: Al Stone <al.stone@linaro.org>
Date:   Tue Mar 24 14:02:37 2015 +0000

    ARM64 / ACPI: Get RSDP and ACPI boot-time tables
    
    As we want to get ACPI tables to parse and then use the information
    for system initialization, we should get the RSDP (Root System
    Description Pointer) first, it then locates Extended Root Description
    Table (XSDT) which contains all the 64-bit physical address that
    pointer to other boot-time tables.
    
    Introduce acpi.c and its related head file in this patch to provide
    fundamental needs of extern variables and functions for ACPI core,
    and then get boot-time tables as needed.
      - asm/acenv.h for arch specific ACPICA environments and
        implementation, It is needed unconditionally by ACPI core;
      - asm/acpi.h for arch specific variables and functions needed by
        ACPI driver core;
      - acpi.c for ARM64 related ACPI implementation for ACPI driver
        core;
    
    acpi_boot_table_init() is introduced to get RSDP and boot-time tables,
    it will be called in setup_arch() before paging_init(), so we should
    use eary_memremap() mechanism here to get the RSDP and all the table
    pointers.
    
    FADT Major.Minor version was introduced in ACPI 5.1, it is the same
    as ACPI version.
    
    In ACPI 5.1, some major gaps are fixed for ARM, such as updates in
    MADT table for GIC and SMP init, without those updates, we can not
    get the MPIDR for SMP init, and GICv2/3 related init information, so
    we can't boot arm64 ACPI properly with table versions predating 5.1.
    
    If firmware provides ACPI tables with ACPI version less than 5.1,
    OS has no way to retrieve the configuration data that is necessary
    to init SMP boot protocol and the GIC properly, so disable ACPI if
    we get an FADT table with version less that 5.1 when acpi_boot_table_init()
    called.
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/acpi.c b/arch/arm64/kernel/acpi.c
new file mode 100644
index 000000000000..7abac24d5584
--- /dev/null
+++ b/arch/arm64/kernel/acpi.c
@@ -0,0 +1,101 @@
+/*
+ *  ARM64 Specific Low-Level ACPI Boot Support
+ *
+ *  Copyright (C) 2013-2014, Linaro Ltd.
+ *	Author: Al Stone <al.stone@linaro.org>
+ *	Author: Graeme Gregory <graeme.gregory@linaro.org>
+ *	Author: Hanjun Guo <hanjun.guo@linaro.org>
+ *	Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
+ *	Author: Naresh Bhat <naresh.bhat@linaro.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "ACPI: " fmt
+
+#include <linux/acpi.h>
+#include <linux/bootmem.h>
+#include <linux/cpumask.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/memblock.h>
+#include <linux/smp.h>
+
+int acpi_noirq;			/* skip ACPI IRQ initialization */
+int acpi_disabled;
+EXPORT_SYMBOL(acpi_disabled);
+
+int acpi_pci_disabled;		/* skip ACPI PCI scan and IRQ initialization */
+EXPORT_SYMBOL(acpi_pci_disabled);
+
+/*
+ * __acpi_map_table() will be called before page_init(), so early_ioremap()
+ * or early_memremap() should be called here to for ACPI table mapping.
+ */
+char *__init __acpi_map_table(unsigned long phys, unsigned long size)
+{
+	if (!size)
+		return NULL;
+
+	return early_memremap(phys, size);
+}
+
+void __init __acpi_unmap_table(char *map, unsigned long size)
+{
+	if (!map || !size)
+		return;
+
+	early_memunmap(map, size);
+}
+
+static int __init acpi_parse_fadt(struct acpi_table_header *table)
+{
+	struct acpi_table_fadt *fadt = (struct acpi_table_fadt *)table;
+
+	/*
+	 * Revision in table header is the FADT Major revision, and there
+	 * is a minor revision of FADT which was introduced by ACPI 5.1,
+	 * we only deal with ACPI 5.1 or newer revision to get GIC and SMP
+	 * boot protocol configuration data, or we will disable ACPI.
+	 */
+	if (table->revision > 5 ||
+	    (table->revision == 5 && fadt->minor_revision >= 1))
+		return 0;
+
+	pr_warn("Unsupported FADT revision %d.%d, should be 5.1+, will disable ACPI\n",
+		table->revision, fadt->minor_revision);
+	disable_acpi();
+
+	return -EINVAL;
+}
+
+/*
+ * acpi_boot_table_init() called from setup_arch(), always.
+ *	1. find RSDP and get its address, and then find XSDT
+ *	2. extract all tables and checksums them all
+ *	3. check ACPI FADT revision
+ *
+ * We can parse ACPI boot-time tables such as MADT after
+ * this function is called.
+ */
+void __init acpi_boot_table_init(void)
+{
+	/* If acpi_disabled, bail out */
+	if (acpi_disabled)
+		return;
+
+	/* Initialize the ACPI boot-time table parser. */
+	if (acpi_table_init()) {
+		disable_acpi();
+		return;
+	}
+
+	if (acpi_table_parse(ACPI_SIG_FADT, acpi_parse_fadt)) {
+		/* disable ACPI if no FADT is found */
+		disable_acpi();
+		pr_err("Can't find FADT\n");
+	}
+}
