commit d690ec537163a384aa1ff25b2be37df6a582412c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:10:46 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 452
    
    Based on 1 normalized pattern(s):
    
      this program is free software void you can redistribute it and or
      modify it under the terms of the gnu general public license version
      2 as published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http void www gnu
      org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081201.003433009@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index 3c80a40c1c9d..fc40386afb1b 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * arch/arm64/kernel/sys32.c
  *
  * Copyright (C) 2015 ARM Ltd.
- *
- * This program is free software(void); you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http(void);//www.gnu.org/licenses/>.
  */
 
 /*

commit 1e29ab3186e33c77dbb2d7566172a205b59fa390
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Fri May 24 15:11:18 2019 -0700

    arm64: use the correct function type for __arm64_sys_ni_syscall
    
    Calling sys_ni_syscall through a syscall_fn_t pointer trips indirect
    call Control-Flow Integrity checking due to a function type
    mismatch. Use SYSCALL_DEFINE0 for __arm64_sys_ni_syscall instead and
    remove the now unnecessary casts.
    
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index 0f8bcb7de700..3c80a40c1c9d 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -133,17 +133,14 @@ COMPAT_SYSCALL_DEFINE6(aarch32_fallocate, int, fd, int, mode,
 	return ksys_fallocate(fd, mode, arg_u64(offset), arg_u64(len));
 }
 
-asmlinkage long sys_ni_syscall(const struct pt_regs *);
-#define __arm64_sys_ni_syscall	sys_ni_syscall
-
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	asmlinkage long __arm64_##sym(const struct pt_regs *);
 #include <asm/unistd32.h>
 
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)__arm64_##sym,
+#define __SYSCALL(nr, sym)	[nr] = __arm64_##sym,
 
 const syscall_fn_t compat_sys_call_table[__NR_compat_syscalls] = {
-	[0 ... __NR_compat_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
+	[0 ... __NR_compat_syscalls - 1] = __arm64_sys_ni_syscall,
 #include <asm/unistd32.h>
 };

commit 4378a7d4be30ec6994702b19936f7d1465193541
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:56 2018 +0100

    arm64: implement syscall wrappers
    
    To minimize the risk of userspace-controlled values being used under
    speculation, this patch adds pt_regs based syscall wrappers for arm64,
    which pass the minimum set of required userspace values to syscall
    implementations. For each syscall, a wrapper which takes a pt_regs
    argument is automatically generated, and this extracts the arguments
    before calling the "real" syscall implementation.
    
    Each syscall has three functions generated:
    
    * __do_<compat_>sys_<name> is the "real" syscall implementation, with
      the expected prototype.
    
    * __se_<compat_>sys_<name> is the sign-extension/narrowing wrapper,
      inherited from common code. This takes a series of long parameters,
      casting each to the requisite types required by the "real" syscall
      implementation in __do_<compat_>sys_<name>.
    
      This wrapper *may* not be necessary on arm64 given the AAPCS rules on
      unused register bits, but it seemed safer to keep the wrapper for now.
    
    * __arm64_<compat_>_sys_<name> takes a struct pt_regs pointer, and
      extracts *only* the relevant register values, passing these on to the
      __se_<compat_>sys_<name> wrapper.
    
    The syscall invocation code is updated to handle the calling convention
    required by __arm64_<compat_>_sys_<name>, and passes a single struct
    pt_regs pointer.
    
    The compiler can fold the syscall implementation and its wrappers, such
    that the overhead of this approach is minimized.
    
    Note that we play games with sys_ni_syscall(). It can't be defined with
    SYSCALL_DEFINE0() because we must avoid the possibility of error
    injection. Additionally, there are a couple of locations where we need
    to call it from C code, and we don't (currently) have a
    ksys_ni_syscall().  While it has no wrapper, passing in a redundant
    pt_regs pointer is benign per the AAPCS.
    
    When ARCH_HAS_SYSCALL_WRAPPER is selected, no prototype is defines for
    sys_ni_syscall(). Since we need to treat it differently for in-kernel
    calls and the syscall tables, the prototype is defined as-required.
    
    The wrappers are largely the same as their x86 counterparts, but
    simplified as we don't have a variety of compat calling conventions that
    require separate stubs. Unlike x86, we have some zero-argument compat
    syscalls, and must define COMPAT_SYSCALL_DEFINE0() to ensure that these
    are also given an __arm64_compat_sys_ prefix.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index a205d4ff4776..0f8bcb7de700 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -133,8 +133,15 @@ COMPAT_SYSCALL_DEFINE6(aarch32_fallocate, int, fd, int, mode,
 	return ksys_fallocate(fd, mode, arg_u64(offset), arg_u64(len));
 }
 
+asmlinkage long sys_ni_syscall(const struct pt_regs *);
+#define __arm64_sys_ni_syscall	sys_ni_syscall
+
+#undef __SYSCALL
+#define __SYSCALL(nr, sym)	asmlinkage long __arm64_##sym(const struct pt_regs *);
+#include <asm/unistd32.h>
+
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
+#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)__arm64_##sym,
 
 const syscall_fn_t compat_sys_call_table[__NR_compat_syscalls] = {
 	[0 ... __NR_compat_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,

commit 55f849265af886aaf404cbf8a659b2c8d411fc3a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:55 2018 +0100

    arm64: convert compat wrappers to C
    
    In preparation for converting to pt_regs syscall wrappers, convert our
    existing compat wrappers to C. This will allow the pt_regs wrappers to
    be automatically generated, and will allow for the compat register
    manipulation to be folded in with the pt_regs accesses.
    
    To avoid confusion with the upcoming pt_regs wrappers and existing
    compat wrappers provided by core code, the C wrappers are renamed to
    compat_sys_aarch32_<syscall>.
    
    With the assembly wrappers gone, we can get rid of entry32.S and the
    associated boilerplate.
    
    Note that these must call the ksys_* syscall entry points, as the usual
    sys_* entry points will be modified to take a single pt_regs pointer
    argument.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index 4ddeaae90128..a205d4ff4776 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -22,6 +22,7 @@
  */
 #define __COMPAT_SYSCALL_NR
 
+#include <linux/compat.h>
 #include <linux/compiler.h>
 #include <linux/syscalls.h>
 
@@ -29,17 +30,108 @@
 
 asmlinkage long compat_sys_sigreturn(void);
 asmlinkage long compat_sys_rt_sigreturn(void);
-asmlinkage long compat_sys_statfs64_wrapper(void);
-asmlinkage long compat_sys_fstatfs64_wrapper(void);
-asmlinkage long compat_sys_pread64_wrapper(void);
-asmlinkage long compat_sys_pwrite64_wrapper(void);
-asmlinkage long compat_sys_truncate64_wrapper(void);
-asmlinkage long compat_sys_ftruncate64_wrapper(void);
-asmlinkage long compat_sys_readahead_wrapper(void);
-asmlinkage long compat_sys_fadvise64_64_wrapper(void);
-asmlinkage long compat_sys_sync_file_range2_wrapper(void);
-asmlinkage long compat_sys_fallocate_wrapper(void);
-asmlinkage long compat_sys_mmap2_wrapper(void);
+
+COMPAT_SYSCALL_DEFINE3(aarch32_statfs64, const char __user *, pathname,
+		       compat_size_t, sz, struct compat_statfs64 __user *, buf)
+{
+	/*
+	 * 32-bit ARM applies an OABI compatibility fixup to statfs64 and
+	 * fstatfs64 regardless of whether OABI is in use, and therefore
+	 * arbitrary binaries may rely upon it, so we must do the same.
+	 * For more details, see commit:
+	 *
+	 * 713c481519f19df9 ("[ARM] 3108/2: old ABI compat: statfs64 and
+	 * fstatfs64")
+	 */
+	if (sz == 88)
+		sz = 84;
+
+	return kcompat_sys_statfs64(pathname, sz, buf);
+}
+
+COMPAT_SYSCALL_DEFINE3(aarch32_fstatfs64, unsigned int, fd, compat_size_t, sz,
+		       struct compat_statfs64 __user *, buf)
+{
+	/* see aarch32_statfs64 */
+	if (sz == 88)
+		sz = 84;
+
+	return kcompat_sys_fstatfs64(fd, sz, buf);
+}
+
+/*
+ * Note: off_4k is always in units of 4K. If we can't do the
+ * requested offset because it is not page-aligned, we return -EINVAL.
+ */
+COMPAT_SYSCALL_DEFINE6(aarch32_mmap2, unsigned long, addr, unsigned long, len,
+		       unsigned long, prot, unsigned long, flags,
+		       unsigned long, fd, unsigned long, off_4k)
+{
+	if (off_4k & (~PAGE_MASK >> 12))
+		return -EINVAL;
+
+	off_4k >>= (PAGE_SHIFT - 12);
+
+	return ksys_mmap_pgoff(addr, len, prot, flags, fd, off_4k);
+}
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define arg_u32p(name)	u32, name##_hi, u32, name##_lo
+#else
+#define arg_u32p(name)	u32, name##_lo, u32, name##_hi
+#endif
+
+#define arg_u64(name)	(((u64)name##_hi << 32) | name##_lo)
+
+COMPAT_SYSCALL_DEFINE6(aarch32_pread64, unsigned int, fd, char __user *, buf,
+		       size_t, count, u32, __pad, arg_u32p(pos))
+{
+	return ksys_pread64(fd, buf, count, arg_u64(pos));
+}
+
+COMPAT_SYSCALL_DEFINE6(aarch32_pwrite64, unsigned int, fd,
+		       const char __user *, buf, size_t, count, u32, __pad,
+		       arg_u32p(pos))
+{
+	return ksys_pwrite64(fd, buf, count, arg_u64(pos));
+}
+
+COMPAT_SYSCALL_DEFINE4(aarch32_truncate64, const char __user *, pathname,
+		       u32, __pad, arg_u32p(length))
+{
+	return ksys_truncate(pathname, arg_u64(length));
+}
+
+COMPAT_SYSCALL_DEFINE4(aarch32_ftruncate64, unsigned int, fd, u32, __pad,
+		       arg_u32p(length))
+{
+	return ksys_ftruncate(fd, arg_u64(length));
+}
+
+COMPAT_SYSCALL_DEFINE5(aarch32_readahead, int, fd, u32, __pad,
+		       arg_u32p(offset), size_t, count)
+{
+	return ksys_readahead(fd, arg_u64(offset), count);
+}
+
+COMPAT_SYSCALL_DEFINE6(aarch32_fadvise64_64, int, fd, int, advice,
+		       arg_u32p(offset), arg_u32p(len))
+{
+	return ksys_fadvise64_64(fd, arg_u64(offset), arg_u64(len), advice);
+}
+
+COMPAT_SYSCALL_DEFINE6(aarch32_sync_file_range2, int, fd, unsigned int, flags,
+		       arg_u32p(offset), arg_u32p(nbytes))
+{
+	return ksys_sync_file_range(fd, arg_u64(offset), arg_u64(nbytes),
+				    flags);
+}
+
+COMPAT_SYSCALL_DEFINE6(aarch32_fallocate, int, fd, int, mode,
+		       arg_u32p(offset), arg_u32p(len))
+{
+	return ksys_fallocate(fd, mode, arg_u64(offset), arg_u64(len));
+}
 
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,

commit 80d63bc39f9ace9c1d2bef7f921d2f3ef2037d4b
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:49 2018 +0100

    arm64: drop alignment from syscall tables
    
    Our syscall tables are aligned to 4096 bytes, which allowed their
    addresses to be generated with a single adrp in entry.S. This has the
    unfortunate property of wasting space in .rodata for the necessary
    padding.
    
    Now that the address is generated by C code, we can rely on the compiler
    to do the right thing, and drop the alignemnt.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index d993214118aa..4ddeaae90128 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -44,11 +44,7 @@ asmlinkage long compat_sys_mmap2_wrapper(void);
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
 
-/*
- * The sys_call_table array must be 4K aligned to be accessible from
- * kernel/entry.S.
- */
-const syscall_fn_t compat_sys_call_table[__NR_compat_syscalls] __aligned(4096) = {
+const syscall_fn_t compat_sys_call_table[__NR_compat_syscalls] = {
 	[0 ... __NR_compat_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
 #include <asm/unistd32.h>
 };

commit 27d83e68f307ee55b70fdfdc7a9ba3f25f276189
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:42 2018 +0100

    arm64: introduce syscall_fn_t
    
    In preparation for invoking arbitrary syscalls from C code, let's define
    a type for an arbitrary syscall, matching the parameter passing rules of
    the AAPCS.
    
    There should be no functional change as a result of this patch.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index 1ef103c95410..d993214118aa 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -25,6 +25,8 @@
 #include <linux/compiler.h>
 #include <linux/syscalls.h>
 
+#include <asm/syscall.h>
+
 asmlinkage long compat_sys_sigreturn(void);
 asmlinkage long compat_sys_rt_sigreturn(void);
 asmlinkage long compat_sys_statfs64_wrapper(void);
@@ -40,13 +42,13 @@ asmlinkage long compat_sys_fallocate_wrapper(void);
 asmlinkage long compat_sys_mmap2_wrapper(void);
 
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = sym,
+#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
 
 /*
  * The sys_call_table array must be 4K aligned to be accessible from
  * kernel/entry.S.
  */
-void * const compat_sys_call_table[__NR_compat_syscalls] __aligned(4096) = {
-	[0 ... __NR_compat_syscalls - 1] = sys_ni_syscall,
+const syscall_fn_t compat_sys_call_table[__NR_compat_syscalls] __aligned(4096) = {
+	[0 ... __NR_compat_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
 #include <asm/unistd32.h>
 };

commit 3085e1645e23888125224f66a710077cdb03106a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:41 2018 +0100

    arm64: remove sigreturn wrappers
    
    The arm64 sigreturn* syscall handlers are non-standard. Rather than
    taking a number of user parameters in registers as per the AAPCS,
    they expect the pt_regs as their sole argument.
    
    To make this work, we override the syscall definitions to invoke
    wrappers written in assembly, which mov the SP into x0, and branch to
    their respective C functions.
    
    On other architectures (such as x86), the sigreturn* functions take no
    argument and instead use current_pt_regs() to acquire the user
    registers. This requires less boilerplate code, and allows for other
    features such as interposing C code in this path.
    
    This patch takes the same approach for arm64.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tentatively-reviewed-by: Dave Martin <dave.martin@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index a40b1343b819..1ef103c95410 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -25,8 +25,8 @@
 #include <linux/compiler.h>
 #include <linux/syscalls.h>
 
-asmlinkage long compat_sys_sigreturn_wrapper(void);
-asmlinkage long compat_sys_rt_sigreturn_wrapper(void);
+asmlinkage long compat_sys_sigreturn(void);
+asmlinkage long compat_sys_rt_sigreturn(void);
 asmlinkage long compat_sys_statfs64_wrapper(void);
 asmlinkage long compat_sys_fstatfs64_wrapper(void);
 asmlinkage long compat_sys_pread64_wrapper(void);

commit 18ccb0cab49ef7868eaf9504f257e1a84683dbbd
Author: Andreas Schwab <schwab@suse.de>
Date:   Mon Mar 16 16:32:22 2015 +0000

    arm64: fix implementation of mmap2 compat syscall
    
    The arm mmap2 syscall takes the offset in units of 4K, thus with 64K pages
    the offset needs to be scaled to units of pages.
    
    Signed-off-by: Andreas Schwab <schwab@suse.de>
    Signed-off-by: Alexander Graf <agraf@suse.de>
    [will: removed redundant lr parameter, localised PAGE_SHIFT #if check]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
index 2d5ab3c90b82..a40b1343b819 100644
--- a/arch/arm64/kernel/sys32.c
+++ b/arch/arm64/kernel/sys32.c
@@ -37,6 +37,7 @@ asmlinkage long compat_sys_readahead_wrapper(void);
 asmlinkage long compat_sys_fadvise64_64_wrapper(void);
 asmlinkage long compat_sys_sync_file_range2_wrapper(void);
 asmlinkage long compat_sys_fallocate_wrapper(void);
+asmlinkage long compat_sys_mmap2_wrapper(void);
 
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = sym,

commit 0156411b1828771c09c92f034e7b81f702b84f07
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jan 6 16:42:32 2015 +0000

    arm64: Implement the compat_sys_call_table in C
    
    Unlike the sys_call_table[], the compat one was implemented in sys32.S
    making it impossible to notice discrepancies between the number of
    compat syscalls and the __NR_compat_syscalls macro, the latter having to
    be defined in asm/unistd.h as including asm/unistd32.h would cause
    conflicts on __NR_* definitions. With this patch, incorrect
    __NR_compat_syscalls values will result in a build-time error.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Suggested-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>

diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
new file mode 100644
index 000000000000..2d5ab3c90b82
--- /dev/null
+++ b/arch/arm64/kernel/sys32.c
@@ -0,0 +1,51 @@
+/*
+ * arch/arm64/kernel/sys32.c
+ *
+ * Copyright (C) 2015 ARM Ltd.
+ *
+ * This program is free software(void); you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http(void);//www.gnu.org/licenses/>.
+ */
+
+/*
+ * Needed to avoid conflicting __NR_* macros between uapi/asm/unistd.h and
+ * asm/unistd32.h.
+ */
+#define __COMPAT_SYSCALL_NR
+
+#include <linux/compiler.h>
+#include <linux/syscalls.h>
+
+asmlinkage long compat_sys_sigreturn_wrapper(void);
+asmlinkage long compat_sys_rt_sigreturn_wrapper(void);
+asmlinkage long compat_sys_statfs64_wrapper(void);
+asmlinkage long compat_sys_fstatfs64_wrapper(void);
+asmlinkage long compat_sys_pread64_wrapper(void);
+asmlinkage long compat_sys_pwrite64_wrapper(void);
+asmlinkage long compat_sys_truncate64_wrapper(void);
+asmlinkage long compat_sys_ftruncate64_wrapper(void);
+asmlinkage long compat_sys_readahead_wrapper(void);
+asmlinkage long compat_sys_fadvise64_64_wrapper(void);
+asmlinkage long compat_sys_sync_file_range2_wrapper(void);
+asmlinkage long compat_sys_fallocate_wrapper(void);
+
+#undef __SYSCALL
+#define __SYSCALL(nr, sym)	[nr] = sym,
+
+/*
+ * The sys_call_table array must be 4K aligned to be accessible from
+ * kernel/entry.S.
+ */
+void * const compat_sys_call_table[__NR_compat_syscalls] __aligned(4096) = {
+	[0 ... __NR_compat_syscalls - 1] = sys_ni_syscall,
+#include <asm/unistd32.h>
+};
