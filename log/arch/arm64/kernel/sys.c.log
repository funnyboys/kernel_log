commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index fe20c461582a..d5ffaaab31a7 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AArch64-specific system calls implementation
  *
  * Copyright (C) 2012 ARM Ltd.
  * Author: Catalin Marinas <catalin.marinas@arm.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/compiler.h>

commit 1e29ab3186e33c77dbb2d7566172a205b59fa390
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Fri May 24 15:11:18 2019 -0700

    arm64: use the correct function type for __arm64_sys_ni_syscall
    
    Calling sys_ni_syscall through a syscall_fn_t pointer trips indirect
    call Control-Flow Integrity checking due to a function type
    mismatch. Use SYSCALL_DEFINE0 for __arm64_sys_ni_syscall instead and
    remove the now unnecessary casts.
    
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 162a95ed0881..fe20c461582a 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -47,22 +47,26 @@ SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
 	return ksys_personality(personality);
 }
 
+asmlinkage long sys_ni_syscall(void);
+
+asmlinkage long __arm64_sys_ni_syscall(const struct pt_regs *__unused)
+{
+	return sys_ni_syscall();
+}
+
 /*
  * Wrappers to pass the pt_regs argument.
  */
 #define __arm64_sys_personality		__arm64_sys_arm64_personality
 
-asmlinkage long sys_ni_syscall(const struct pt_regs *);
-#define __arm64_sys_ni_syscall	sys_ni_syscall
-
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	asmlinkage long __arm64_##sym(const struct pt_regs *);
 #include <asm/unistd.h>
 
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)__arm64_##sym,
+#define __SYSCALL(nr, sym)	[nr] = __arm64_##sym,
 
 const syscall_fn_t sys_call_table[__NR_syscalls] = {
-	[0 ... __NR_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
+	[0 ... __NR_syscalls - 1] = __arm64_sys_ni_syscall,
 #include <asm/unistd.h>
 };

commit 00377277166bac6939d8f72b429301369acaf2d8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue May 28 12:39:34 2019 +0100

    arm64: Fix the arm64_personality() syscall wrapper redirection
    
    Following commit 4378a7d4be30 ("arm64: implement syscall wrappers"), the
    syscall function names gained the '__arm64_' prefix. Ensure that we
    have the correct #define for redirecting a default syscall through a
    wrapper.
    
    Fixes: 4378a7d4be30 ("arm64: implement syscall wrappers")
    Cc: <stable@vger.kernel.org> # 4.19.x-
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 6f91e8116514..162a95ed0881 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -50,7 +50,7 @@ SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
 /*
  * Wrappers to pass the pt_regs argument.
  */
-#define sys_personality		sys_arm64_personality
+#define __arm64_sys_personality		__arm64_sys_arm64_personality
 
 asmlinkage long sys_ni_syscall(const struct pt_regs *);
 #define __arm64_sys_ni_syscall	sys_ni_syscall

commit f08cae2f28db24d95be5204046b60618d8de4ddc
Author: Boyang Zhou <zhouby_cn@126.com>
Date:   Mon Apr 29 15:27:19 2019 +0100

    arm64: mmap: Ensure file offset is treated as unsigned
    
    The file offset argument to the arm64 sys_mmap() implementation is
    scaled from bytes to pages by shifting right by PAGE_SHIFT.
    Unfortunately, the offset is passed in as a signed 'off_t' type and
    therefore large offsets (i.e. with the top bit set) are incorrectly
    sign-extended by the shift. This has been observed to cause false mmap()
    failures when mapping GPU doorbells on an arm64 server part.
    
    Change the type of the file offset argument to sys_mmap() from 'off_t'
    to 'unsigned long' so that the shifting scales the value as expected.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Boyang Zhou <zhouby_cn@126.com>
    [will: rewrote commit message]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index b44065fb1616..6f91e8116514 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -31,7 +31,7 @@
 
 SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,
 		unsigned long, prot, unsigned long, flags,
-		unsigned long, fd, off_t, off)
+		unsigned long, fd, unsigned long, off)
 {
 	if (offset_in_page(off) != 0)
 		return -EINVAL;

commit 4378a7d4be30ec6994702b19936f7d1465193541
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:56 2018 +0100

    arm64: implement syscall wrappers
    
    To minimize the risk of userspace-controlled values being used under
    speculation, this patch adds pt_regs based syscall wrappers for arm64,
    which pass the minimum set of required userspace values to syscall
    implementations. For each syscall, a wrapper which takes a pt_regs
    argument is automatically generated, and this extracts the arguments
    before calling the "real" syscall implementation.
    
    Each syscall has three functions generated:
    
    * __do_<compat_>sys_<name> is the "real" syscall implementation, with
      the expected prototype.
    
    * __se_<compat_>sys_<name> is the sign-extension/narrowing wrapper,
      inherited from common code. This takes a series of long parameters,
      casting each to the requisite types required by the "real" syscall
      implementation in __do_<compat_>sys_<name>.
    
      This wrapper *may* not be necessary on arm64 given the AAPCS rules on
      unused register bits, but it seemed safer to keep the wrapper for now.
    
    * __arm64_<compat_>_sys_<name> takes a struct pt_regs pointer, and
      extracts *only* the relevant register values, passing these on to the
      __se_<compat_>sys_<name> wrapper.
    
    The syscall invocation code is updated to handle the calling convention
    required by __arm64_<compat_>_sys_<name>, and passes a single struct
    pt_regs pointer.
    
    The compiler can fold the syscall implementation and its wrappers, such
    that the overhead of this approach is minimized.
    
    Note that we play games with sys_ni_syscall(). It can't be defined with
    SYSCALL_DEFINE0() because we must avoid the possibility of error
    injection. Additionally, there are a couple of locations where we need
    to call it from C code, and we don't (currently) have a
    ksys_ni_syscall().  While it has no wrapper, passing in a redundant
    pt_regs pointer is benign per the AAPCS.
    
    When ARCH_HAS_SYSCALL_WRAPPER is selected, no prototype is defines for
    sys_ni_syscall(). Since we need to treat it differently for in-kernel
    calls and the syscall tables, the prototype is defined as-required.
    
    The wrappers are largely the same as their x86 counterparts, but
    simplified as we don't have a variety of compat calling conventions that
    require separate stubs. Unlike x86, we have some zero-argument compat
    syscalls, and must define COMPAT_SYSCALL_DEFINE0() to ensure that these
    are also given an __arm64_compat_sys_ prefix.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index f249d9735f4c..b44065fb1616 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -50,11 +50,17 @@ SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
 /*
  * Wrappers to pass the pt_regs argument.
  */
-asmlinkage long sys_rt_sigreturn(void);
 #define sys_personality		sys_arm64_personality
 
+asmlinkage long sys_ni_syscall(const struct pt_regs *);
+#define __arm64_sys_ni_syscall	sys_ni_syscall
+
+#undef __SYSCALL
+#define __SYSCALL(nr, sym)	asmlinkage long __arm64_##sym(const struct pt_regs *);
+#include <asm/unistd.h>
+
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
+#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)__arm64_##sym,
 
 const syscall_fn_t sys_call_table[__NR_syscalls] = {
 	[0 ... __NR_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,

commit d3516c9073b4b81410195489dc169891cd64e4cd
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:54 2018 +0100

    arm64: use SYSCALL_DEFINE6() for mmap
    
    We don't currently annotate our mmap implementation as a syscall, as we
    need to do to use pt_regs syscall wrappers.
    
    Let's mark it as a real syscall.
    
    There should be no functional change as a result of this patch.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index f4e02f6aceb8..f249d9735f4c 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -29,9 +29,9 @@
 #include <asm/cpufeature.h>
 #include <asm/syscall.h>
 
-asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
-			 unsigned long prot, unsigned long flags,
-			 unsigned long fd, off_t off)
+SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,
+		unsigned long, prot, unsigned long, flags,
+		unsigned long, fd, off_t, off)
 {
 	if (offset_in_page(off) != 0)
 		return -EINVAL;

commit 3f7deccb037cc2bd2f848576439c033f81daeb6a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:52 2018 +0100

    arm64: remove in-kernel call to sys_personality()
    
    With pt_regs syscall wrappers, the calling convention for
    sys_personality() will change. Use ksys_personality(), which is
    functionally equivalent.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index df8180175515..f4e02f6aceb8 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -44,7 +44,7 @@ SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
 	if (personality(personality) == PER_LINUX32 &&
 		!system_supports_32bit_el0())
 		return -EINVAL;
-	return sys_personality(personality);
+	return ksys_personality(personality);
 }
 
 /*

commit 80d63bc39f9ace9c1d2bef7f921d2f3ef2037d4b
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:49 2018 +0100

    arm64: drop alignment from syscall tables
    
    Our syscall tables are aligned to 4096 bytes, which allowed their
    addresses to be generated with a single adrp in entry.S. This has the
    unfortunate property of wasting space in .rodata for the necessary
    padding.
    
    Now that the address is generated by C code, we can rely on the compiler
    to do the right thing, and drop the alignemnt.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 7f0907261269..df8180175515 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -56,11 +56,7 @@ asmlinkage long sys_rt_sigreturn(void);
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
 
-/*
- * The sys_call_table array must be 4K aligned to be accessible from
- * kernel/entry.S.
- */
-const syscall_fn_t sys_call_table[__NR_syscalls] __aligned(4096) = {
+const syscall_fn_t sys_call_table[__NR_syscalls] = {
 	[0 ... __NR_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
 #include <asm/unistd.h>
 };

commit 27d83e68f307ee55b70fdfdc7a9ba3f25f276189
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:42 2018 +0100

    arm64: introduce syscall_fn_t
    
    In preparation for invoking arbitrary syscalls from C code, let's define
    a type for an arbitrary syscall, matching the parameter passing rules of
    the AAPCS.
    
    There should be no functional change as a result of this patch.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 31045f3fed92..7f0907261269 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -25,7 +25,9 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/syscalls.h>
+
 #include <asm/cpufeature.h>
+#include <asm/syscall.h>
 
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
@@ -52,13 +54,13 @@ asmlinkage long sys_rt_sigreturn(void);
 #define sys_personality		sys_arm64_personality
 
 #undef __SYSCALL
-#define __SYSCALL(nr, sym)	[nr] = sym,
+#define __SYSCALL(nr, sym)	[nr] = (syscall_fn_t)sym,
 
 /*
  * The sys_call_table array must be 4K aligned to be accessible from
  * kernel/entry.S.
  */
-void * const sys_call_table[__NR_syscalls] __aligned(4096) = {
-	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
+const syscall_fn_t sys_call_table[__NR_syscalls] __aligned(4096) = {
+	[0 ... __NR_syscalls - 1] = (syscall_fn_t)sys_ni_syscall,
 #include <asm/unistd.h>
 };

commit 3085e1645e23888125224f66a710077cdb03106a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Jul 11 14:56:41 2018 +0100

    arm64: remove sigreturn wrappers
    
    The arm64 sigreturn* syscall handlers are non-standard. Rather than
    taking a number of user parameters in registers as per the AAPCS,
    they expect the pt_regs as their sole argument.
    
    To make this work, we override the syscall definitions to invoke
    wrappers written in assembly, which mov the SP into x0, and branch to
    their respective C functions.
    
    On other architectures (such as x86), the sigreturn* functions take no
    argument and instead use current_pt_regs() to acquire the user
    registers. This requires less boilerplate code, and allows for other
    features such as interposing C code in this path.
    
    This patch takes the same approach for arm64.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tentatively-reviewed-by: Dave Martin <dave.martin@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 72981bae10eb..31045f3fed92 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -48,8 +48,7 @@ SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
 /*
  * Wrappers to pass the pt_regs argument.
  */
-asmlinkage long sys_rt_sigreturn_wrapper(void);
-#define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
+asmlinkage long sys_rt_sigreturn(void);
 #define sys_personality		sys_arm64_personality
 
 #undef __SYSCALL

commit a90f590a1bee36fc2129cfb38ceec24a555bb12d
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:46 2018 +0100

    mm: add ksys_mmap_pgoff() helper; remove in-kernel calls to sys_mmap_pgoff()
    
    Using this helper allows us to avoid the in-kernel calls to the
    sys_mmap_pgoff() syscall. The ksys_ prefix denotes that this function is
    meant as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_mmap_pgoff().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-mm@kvack.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 26fe8ea93ea2..72981bae10eb 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -34,7 +34,7 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 	if (offset_in_page(off) != 0)
 		return -EINVAL;
 
-	return sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
+	return ksys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 }
 
 SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)

commit 643d703d2d2dbf8e2f16efa0a6a32b1eca101d02
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Mon Apr 18 10:28:37 2016 +0100

    arm64: compat: Check for AArch32 state
    
    Make sure we have AArch32 state available for running COMPAT
    binaries and also for switching the personality to PER_LINUX32.
    
    Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
    [ Added cap bit, checks for HWCAP, personality ]
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Tested-by: Yury Norov <ynorov@caviumnetworks.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 75151aaf1a52..26fe8ea93ea2 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -25,6 +25,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/syscalls.h>
+#include <asm/cpufeature.h>
 
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
@@ -36,11 +37,20 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 	return sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 }
 
+SYSCALL_DEFINE1(arm64_personality, unsigned int, personality)
+{
+	if (personality(personality) == PER_LINUX32 &&
+		!system_supports_32bit_el0())
+		return -EINVAL;
+	return sys_personality(personality);
+}
+
 /*
  * Wrappers to pass the pt_regs argument.
  */
 asmlinkage long sys_rt_sigreturn_wrapper(void);
 #define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
+#define sys_personality		sys_arm64_personality
 
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = sym,

commit c623b33b4e9599c6ac5076f7db7369eb9869aa04
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Jan 8 11:42:59 2015 +0000

    arm64: make sys_call_table const
    
    As with x86, mark the sys_call_table const such that it will be placed
    in the .rodata section. This will cause attempts to modify the table
    (accidental or deliberate) to fail when strict page permissions are in
    place. In the absence of strict page permissions, there should be no
    functional change.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index dec351a9f3d6..75151aaf1a52 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -49,7 +49,7 @@ asmlinkage long sys_rt_sigreturn_wrapper(void);
  * The sys_call_table array must be 4K aligned to be accessible from
  * kernel/entry.S.
  */
-void *sys_call_table[__NR_syscalls] __aligned(4096) = {
+void * const sys_call_table[__NR_syscalls] __aligned(4096) = {
 	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
 #include <asm/unistd.h>
 };

commit 9648606946b3b0c608846dddb30482b48a6f5c68
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jan 6 17:01:56 2015 +0000

    arm64: Remove asm/syscalls.h
    
    This patch moves the sys_rt_sigreturn_wrapper prototype to
    arch/arm64/kernel/sys.c and removes the asm/syscalls.h header.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 3fa98ff14f0e..dec351a9f3d6 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -39,10 +39,9 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 /*
  * Wrappers to pass the pt_regs argument.
  */
+asmlinkage long sys_rt_sigreturn_wrapper(void);
 #define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
 
-#include <asm/syscalls.h>
-
 #undef __SYSCALL
 #define __SYSCALL(nr, sym)	[nr] = sym,
 

commit 207bdae452e6d3eeba19cc3912e5dfb088adc376
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 23 01:56:45 2012 -0500

    arm64: switch to generic sigaltstack
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 8292a9b090f8..3fa98ff14f0e 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -40,7 +40,6 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
  * Wrappers to pass the pt_regs argument.
  */
 #define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
-#define sys_sigaltstack		sys_sigaltstack_wrapper
 
 #include <asm/syscalls.h>
 

commit 9ac08002130b591d0f2ee035aa9062f84f2f15cb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 21 15:56:52 2012 -0400

    arm64: sanitize copy_thread(), switch to generic fork/vfork/clone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 4364df85050e..8292a9b090f8 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -26,17 +26,6 @@
 #include <linux/slab.h>
 #include <linux/syscalls.h>
 
-/*
- * Clone a task - this clones the calling program thread.
- */
-asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp,
-			  int __user *parent_tidptr, unsigned long tls_val,
-			  int __user *child_tidptr)
-{
-	return do_fork(clone_flags, newsp, current_pt_regs(), 0,
-			parent_tidptr, child_tidptr);
-}
-
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
 			 unsigned long fd, off_t off)

commit e0fd18ce1169595df929373cad2ae9b00b2289c2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 18 00:55:54 2012 -0400

    arm64: get rid of fork/vfork/clone wrappers
    
    [fixes from Catalin Marinas folded]
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 9c77c0bacc1d..4364df85050e 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -31,14 +31,10 @@
  */
 asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp,
 			  int __user *parent_tidptr, unsigned long tls_val,
-			  int __user *child_tidptr, struct pt_regs *regs)
+			  int __user *child_tidptr)
 {
-	if (!newsp)
-		newsp = regs->sp;
-	/* 16-byte aligned stack mandatory on AArch64 */
-	if (newsp & 15)
-		return -EINVAL;
-	return do_fork(clone_flags, newsp, regs, 0, parent_tidptr, child_tidptr);
+	return do_fork(clone_flags, newsp, current_pt_regs(), 0,
+			parent_tidptr, child_tidptr);
 }
 
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
@@ -54,7 +50,6 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 /*
  * Wrappers to pass the pt_regs argument.
  */
-#define sys_clone		sys_clone_wrapper
 #define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
 #define sys_sigaltstack		sys_sigaltstack_wrapper
 

commit 6a872777ffff6184f4ac10bd71d926d5e6f2491e
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Sep 10 16:11:46 2012 +0100

    arm64: Use generic sys_execve() implementation
    
    This patch converts the arm64 port to use the generic sys_execve()
    implementation removing the arm64-specific (compat_)sys_execve_wrapper()
    functions.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 4deb0d0093cd..9c77c0bacc1d 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -41,27 +41,6 @@ asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp,
 	return do_fork(clone_flags, newsp, regs, 0, parent_tidptr, child_tidptr);
 }
 
-/*
- * sys_execve() executes a new program.
- */
-asmlinkage long sys_execve(const char __user *filenamei,
-			   const char __user *const __user *argv,
-			   const char __user *const __user *envp,
-			   struct pt_regs *regs)
-{
-	long error;
-	struct filename *filename;
-
-	filename = getname(filenamei);
-	error = PTR_ERR(filename);
-	if (IS_ERR(filename))
-		goto out;
-	error = do_execve(filename->name, argv, envp, regs);
-	putname(filename);
-out:
-	return error;
-}
-
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
 			 unsigned long fd, off_t off)
@@ -75,7 +54,6 @@ asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 /*
  * Wrappers to pass the pt_regs argument.
  */
-#define sys_execve		sys_execve_wrapper
 #define sys_clone		sys_clone_wrapper
 #define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
 #define sys_sigaltstack		sys_sigaltstack_wrapper

commit 59dc67b0cc35cd93c3f4869fdd0d6cfb2a26ecbc
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Sep 10 16:11:46 2012 +0100

    arm64: Use generic kernel_execve() implementation
    
    This patch enables CONFIG_GENERIC_KERNEL_EXECVE on arm64 and removes the
    arm64-specific implementation of kernel_execve().
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index b120df37de35..4deb0d0093cd 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -62,49 +62,6 @@ asmlinkage long sys_execve(const char __user *filenamei,
 	return error;
 }
 
-int kernel_execve(const char *filename,
-		  const char *const argv[],
-		  const char *const envp[])
-{
-	struct pt_regs regs;
-	int ret;
-
-	memset(&regs, 0, sizeof(struct pt_regs));
-	ret = do_execve(filename,
-			(const char __user *const __user *)argv,
-			(const char __user *const __user *)envp, &regs);
-	if (ret < 0)
-		goto out;
-
-	/*
-	 * Save argc to the register structure for userspace.
-	 */
-	regs.regs[0] = ret;
-
-	/*
-	 * We were successful.  We won't be returning to our caller, but
-	 * instead to user space by manipulating the kernel stack.
-	 */
-	asm(	"add	x0, %0, %1\n\t"
-		"mov	x1, %2\n\t"
-		"mov	x2, %3\n\t"
-		"bl	memmove\n\t"	/* copy regs to top of stack */
-		"mov	x27, #0\n\t"	/* not a syscall */
-		"mov	x28, %0\n\t"	/* thread structure */
-		"mov	sp, x0\n\t"	/* reposition stack pointer */
-		"b	ret_to_user"
-		:
-		: "r" (current_thread_info()),
-		  "Ir" (THREAD_START_SP - sizeof(regs)),
-		  "r" (&regs),
-		  "Ir" (sizeof(regs))
-		: "x0", "x1", "x2", "x27", "x28", "x30", "memory");
-
- out:
-	return ret;
-}
-EXPORT_SYMBOL(kernel_execve);
-
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
 			 unsigned long fd, off_t off)

commit 91a27b2a756784714e924e5e854b919273082d26
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:28 2012 -0400

    vfs: define struct filename and have getname() return it
    
    getname() is intended to copy pathname strings from userspace into a
    kernel buffer. The result is just a string in kernel space. It would
    however be quite helpful to be able to attach some ancillary info to
    the string.
    
    For instance, we could attach some audit-related info to reduce the
    amount of audit-related processing needed. When auditing is enabled,
    we could also call getname() on the string more than once and not
    need to recopy it from userspace.
    
    This patchset converts the getname()/putname() interfaces to return
    a struct instead of a string. For now, the struct just tracks the
    string in kernel space and the original userland pointer for it.
    
    Later, we'll add other information to the struct as it becomes
    convenient.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 905fcfb0ddd0..b120df37de35 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -50,13 +50,13 @@ asmlinkage long sys_execve(const char __user *filenamei,
 			   struct pt_regs *regs)
 {
 	long error;
-	char * filename;
+	struct filename *filename;
 
 	filename = getname(filenamei);
 	error = PTR_ERR(filename);
 	if (IS_ERR(filename))
 		goto out;
-	error = do_execve(filename, argv, envp, regs);
+	error = do_execve(filename->name, argv, envp, regs);
 	putname(filename);
 out:
 	return error;

commit 7992d60dc46576bc6f6429d87f313462141db6d2
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Mar 5 11:49:31 2012 +0000

    arm64: System calls handling
    
    This patch adds support for system calls coming from 64-bit
    applications. It uses the asm-generic/unistd.h definitions with the
    canonical set of system calls. The private system calls are only used
    for 32-bit (compat) applications as 64-bit ones can set the TLS and
    flush the caches entirely from user space.
    
    The sys_call_table is just an array defined in a C file and it contains
    pointers to the syscall functions. The array is 4KB aligned to allow the
    use of the ADRP instruction (longer range ADR) in entry.S.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
new file mode 100644
index 000000000000..905fcfb0ddd0
--- /dev/null
+++ b/arch/arm64/kernel/sys.c
@@ -0,0 +1,138 @@
+/*
+ * AArch64-specific system calls implementation
+ *
+ * Copyright (C) 2012 ARM Ltd.
+ * Author: Catalin Marinas <catalin.marinas@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/compiler.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/export.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+
+/*
+ * Clone a task - this clones the calling program thread.
+ */
+asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp,
+			  int __user *parent_tidptr, unsigned long tls_val,
+			  int __user *child_tidptr, struct pt_regs *regs)
+{
+	if (!newsp)
+		newsp = regs->sp;
+	/* 16-byte aligned stack mandatory on AArch64 */
+	if (newsp & 15)
+		return -EINVAL;
+	return do_fork(clone_flags, newsp, regs, 0, parent_tidptr, child_tidptr);
+}
+
+/*
+ * sys_execve() executes a new program.
+ */
+asmlinkage long sys_execve(const char __user *filenamei,
+			   const char __user *const __user *argv,
+			   const char __user *const __user *envp,
+			   struct pt_regs *regs)
+{
+	long error;
+	char * filename;
+
+	filename = getname(filenamei);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	error = do_execve(filename, argv, envp, regs);
+	putname(filename);
+out:
+	return error;
+}
+
+int kernel_execve(const char *filename,
+		  const char *const argv[],
+		  const char *const envp[])
+{
+	struct pt_regs regs;
+	int ret;
+
+	memset(&regs, 0, sizeof(struct pt_regs));
+	ret = do_execve(filename,
+			(const char __user *const __user *)argv,
+			(const char __user *const __user *)envp, &regs);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * Save argc to the register structure for userspace.
+	 */
+	regs.regs[0] = ret;
+
+	/*
+	 * We were successful.  We won't be returning to our caller, but
+	 * instead to user space by manipulating the kernel stack.
+	 */
+	asm(	"add	x0, %0, %1\n\t"
+		"mov	x1, %2\n\t"
+		"mov	x2, %3\n\t"
+		"bl	memmove\n\t"	/* copy regs to top of stack */
+		"mov	x27, #0\n\t"	/* not a syscall */
+		"mov	x28, %0\n\t"	/* thread structure */
+		"mov	sp, x0\n\t"	/* reposition stack pointer */
+		"b	ret_to_user"
+		:
+		: "r" (current_thread_info()),
+		  "Ir" (THREAD_START_SP - sizeof(regs)),
+		  "r" (&regs),
+		  "Ir" (sizeof(regs))
+		: "x0", "x1", "x2", "x27", "x28", "x30", "memory");
+
+ out:
+	return ret;
+}
+EXPORT_SYMBOL(kernel_execve);
+
+asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
+			 unsigned long prot, unsigned long flags,
+			 unsigned long fd, off_t off)
+{
+	if (offset_in_page(off) != 0)
+		return -EINVAL;
+
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
+}
+
+/*
+ * Wrappers to pass the pt_regs argument.
+ */
+#define sys_execve		sys_execve_wrapper
+#define sys_clone		sys_clone_wrapper
+#define sys_rt_sigreturn	sys_rt_sigreturn_wrapper
+#define sys_sigaltstack		sys_sigaltstack_wrapper
+
+#include <asm/syscalls.h>
+
+#undef __SYSCALL
+#define __SYSCALL(nr, sym)	[nr] = sym,
+
+/*
+ * The sys_call_table array must be 4K aligned to be accessible from
+ * kernel/entry.S.
+ */
+void *sys_call_table[__NR_syscalls] __aligned(4096) = {
+	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
+#include <asm/unistd.h>
+};
