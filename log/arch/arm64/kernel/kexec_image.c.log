commit 3751e728cef2908c15974a5ae44627fd41ef3362
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Mon Dec 16 11:12:47 2019 +0900

    arm64: kexec_file: add crash dump support
    
    Enabling crash dump (kdump) includes
    * prepare contents of ELF header of a core dump file, /proc/vmcore,
      using crash_prepare_elf64_headers(), and
    * add two device tree properties, "linux,usable-memory-range" and
      "linux,elfcorehdr", which represent respectively a memory range
      to be used by crash dump kernel and the header's location
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    Tested-and-reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 29a9428486a5..af9987c154ca 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -47,10 +47,6 @@ static void *image_load(struct kimage *image,
 	struct kexec_segment *kernel_segment;
 	int ret;
 
-	/* We don't support crash kernels yet. */
-	if (image->type == KEXEC_TYPE_CRASH)
-		return ERR_PTR(-EOPNOTSUPP);
-
 	/*
 	 * We require a kernel with an unambiguous Image header. Per
 	 * Documentation/arm64/booting.rst, this is the case when image_size

commit c19d050f80881296aab3ba90fe5b2c107a238dcb
Author: Bhupesh Sharma <bhsharma@redhat.com>
Date:   Thu Jul 11 17:27:32 2019 +0530

    arm64/kexec: Use consistent convention of initializing 'kxec_buf.mem' with KEXEC_BUF_MEM_UNKNOWN
    
    With commit b6664ba42f14 ("s390, kexec_file: drop arch_kexec_mem_walk()"),
    we introduced the KEXEC_BUF_MEM_UNKNOWN macro. If kexec_buf.mem is set
    to this value, kexec_locate_mem_hole() will try to allocate free memory.
    
    While other arch(s) like s390 and x86_64 already use this macro to
    initialize kexec_buf.mem with, arm64 uses an equivalent value of 0.
    Replace it with KEXEC_BUF_MEM_UNKNOWN, to keep the convention of
    initializing 'kxec_buf.mem' consistent across various archs.
    
    Cc: takahiro.akashi@linaro.org
    Cc: james.morse@arm.com
    Reviewed-by: Matthias Brugger <mbrugger@suse.com>
    Signed-off-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 2514fd6f12cb..29a9428486a5 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -84,7 +84,7 @@ static void *image_load(struct kimage *image,
 
 	kbuf.buffer = kernel;
 	kbuf.bufsz = kernel_len;
-	kbuf.mem = 0;
+	kbuf.mem = KEXEC_BUF_MEM_UNKNOWN;
 	kbuf.memsz = le64_to_cpu(h->image_size);
 	text_offset = le64_to_cpu(h->text_offset);
 	kbuf.buf_align = MIN_KIMG_ALIGN;

commit b693d0b372afb39432e1c49ad7b3454855bc6bed
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Wed Jun 12 14:52:38 2019 -0300

    docs: arm64: convert docs to ReST and rename to .rst
    
    The documentation is in a format that is very close to ReST format.
    
    The conversion is actually:
      - add blank lines in order to identify paragraphs;
      - fixing tables markups;
      - adding some lists markups;
      - marking literal blocks;
      - adjust some title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 31cc2f423aa8..2514fd6f12cb 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -53,7 +53,7 @@ static void *image_load(struct kimage *image,
 
 	/*
 	 * We require a kernel with an unambiguous Image header. Per
-	 * Documentation/arm64/booting.txt, this is the case when image_size
+	 * Documentation/arm64/booting.rst, this is the case when image_size
 	 * is non-zero (practically speaking, since v3.17).
 	 */
 	h = (struct arm64_image_header *)kernel;

commit cb1aaebea8d79860181559d7b5d482aea63db113
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jun 7 15:54:32 2019 -0300

    docs: fix broken documentation links
    
    Mostly due to x86 and acpi conversion, several documentation
    links are still pointing to the old file. Fix them.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Reviewed-by: Sven Van Asbroeck <TheSven73@gmail.com>
    Reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 07bf740bea91..31cc2f423aa8 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -53,7 +53,7 @@ static void *image_load(struct kimage *image,
 
 	/*
 	 * We require a kernel with an unambiguous Image header. Per
-	 * Documentation/booting.txt, this is the case when image_size
+	 * Documentation/arm64/booting.txt, this is the case when image_size
 	 * is non-zero (practically speaking, since v3.17).
 	 */
 	h = (struct arm64_image_header *)kernel;

commit 394135c1ff13ec9b5a38a36bbdb5811f2f595e94
Author: James Morse <james.morse@arm.com>
Date:   Fri Dec 7 10:14:39 2018 +0000

    arm64: kexec_file: forbid kdump via kexec_file_load()
    
    Now that kexec_walk_memblock() can do the crash-kernel placement itself
    architectures that don't support kdump via kexe_file_load() need to
    explicitly forbid it.
    
    We don't support this on arm64 until the kernel can add the elfcorehdr
    and usable-memory-range fields to the DT. Without these the crash-kernel
    overwrites the previous kernel's memory during startup.
    
    Add a check to refuse crash image loading.
    
    Reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 1ad1d5f8f024..07bf740bea91 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -47,6 +47,10 @@ static void *image_load(struct kimage *image,
 	struct kexec_segment *kernel_segment;
 	int ret;
 
+	/* We don't support crash kernels yet. */
+	if (image->type == KEXEC_TYPE_CRASH)
+		return ERR_PTR(-EOPNOTSUPP);
+
 	/*
 	 * We require a kernel with an unambiguous Image header. Per
 	 * Documentation/booting.txt, this is the case when image_size

commit 732b7b93d849f8a44886ead563dfb6adec7f4419
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Thu Nov 15 14:52:54 2018 +0900

    arm64: kexec_file: add kernel signature verification support
    
    With this patch, kernel verification can be done without IMA security
    subsystem enabled. Turn on CONFIG_KEXEC_VERIFY_SIG instead.
    
    On x86, a signature is embedded into a PE file (Microsoft's format) header
    of binary. Since arm64's "Image" can also be seen as a PE file as far as
    CONFIG_EFI is enabled, we adopt this format for kernel signing.
    
    You can create a signed kernel image with:
        $ sbsign --key ${KEY} --cert ${CERT} Image
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    [will: removed useless pr_debug()]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
index 9f0d8b5d62d3..1ad1d5f8f024 100644
--- a/arch/arm64/kernel/kexec_image.c
+++ b/arch/arm64/kernel/kexec_image.c
@@ -12,7 +12,9 @@
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/kexec.h>
+#include <linux/pe.h>
 #include <linux/string.h>
+#include <linux/verification.h>
 #include <asm/byteorder.h>
 #include <asm/cpufeature.h>
 #include <asm/image.h>
@@ -20,13 +22,13 @@
 
 static int image_probe(const char *kernel_buf, unsigned long kernel_len)
 {
-	const struct arm64_image_header *h;
+	const struct arm64_image_header *h =
+		(const struct arm64_image_header *)(kernel_buf);
 
-	h = (const struct arm64_image_header *)(kernel_buf);
+	if (!h || (kernel_len < sizeof(*h)))
+		return -EINVAL;
 
-	if (!h || (kernel_len < sizeof(*h)) ||
-			memcmp(&h->magic, ARM64_IMAGE_MAGIC,
-				sizeof(h->magic)))
+	if (memcmp(&h->magic, ARM64_IMAGE_MAGIC, sizeof(h->magic)))
 		return -EINVAL;
 
 	return 0;
@@ -107,7 +109,18 @@ static void *image_load(struct kimage *image,
 	return ERR_PTR(ret);
 }
 
+#ifdef CONFIG_KEXEC_IMAGE_VERIFY_SIG
+static int image_verify_sig(const char *kernel, unsigned long kernel_len)
+{
+	return verify_pefile_signature(kernel, kernel_len, NULL,
+				       VERIFYING_KEXEC_PE_SIGNATURE);
+}
+#endif
+
 const struct kexec_file_ops kexec_image_ops = {
 	.probe = image_probe,
 	.load = image_load,
+#ifdef CONFIG_KEXEC_IMAGE_VERIFY_SIG
+	.verify_sig = image_verify_sig,
+#endif
 };

commit f3b70e50942960ecc691367bb937e35cdc5e28d3
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Thu Nov 15 14:52:50 2018 +0900

    arm64: kexec_file: allow for loading Image-format kernel
    
    This patch provides kexec_file_ops for "Image"-format kernel. In this
    implementation, a binary is always loaded with a fixed offset identified
    in text_offset field of its header.
    
    Regarding signature verification for trusted boot, this patch doesn't
    contains CONFIG_KEXEC_VERIFY_SIG support, which is to be added later
    in this series, but file-attribute-based verification is still a viable
    option by enabling IMA security subsystem.
    
    You can sign(label) a to-be-kexec'ed kernel image on target file system
    with:
        $ evmctl ima_sign --key /path/to/private_key.pem Image
    
    On live system, you must have IMA enforced with, at least, the following
    security policy:
        "appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig"
    
    See more details about IMA here:
        https://sourceforge.net/p/linux-ima/wiki/Home/
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/kexec_image.c b/arch/arm64/kernel/kexec_image.c
new file mode 100644
index 000000000000..9f0d8b5d62d3
--- /dev/null
+++ b/arch/arm64/kernel/kexec_image.c
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Kexec image loader
+
+ * Copyright (C) 2018 Linaro Limited
+ * Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
+ */
+
+#define pr_fmt(fmt)	"kexec_file(Image): " fmt
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/kexec.h>
+#include <linux/string.h>
+#include <asm/byteorder.h>
+#include <asm/cpufeature.h>
+#include <asm/image.h>
+#include <asm/memory.h>
+
+static int image_probe(const char *kernel_buf, unsigned long kernel_len)
+{
+	const struct arm64_image_header *h;
+
+	h = (const struct arm64_image_header *)(kernel_buf);
+
+	if (!h || (kernel_len < sizeof(*h)) ||
+			memcmp(&h->magic, ARM64_IMAGE_MAGIC,
+				sizeof(h->magic)))
+		return -EINVAL;
+
+	return 0;
+}
+
+static void *image_load(struct kimage *image,
+				char *kernel, unsigned long kernel_len,
+				char *initrd, unsigned long initrd_len,
+				char *cmdline, unsigned long cmdline_len)
+{
+	struct arm64_image_header *h;
+	u64 flags, value;
+	bool be_image, be_kernel;
+	struct kexec_buf kbuf;
+	unsigned long text_offset;
+	struct kexec_segment *kernel_segment;
+	int ret;
+
+	/*
+	 * We require a kernel with an unambiguous Image header. Per
+	 * Documentation/booting.txt, this is the case when image_size
+	 * is non-zero (practically speaking, since v3.17).
+	 */
+	h = (struct arm64_image_header *)kernel;
+	if (!h->image_size)
+		return ERR_PTR(-EINVAL);
+
+	/* Check cpu features */
+	flags = le64_to_cpu(h->flags);
+	be_image = arm64_image_flag_field(flags, ARM64_IMAGE_FLAG_BE);
+	be_kernel = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN);
+	if ((be_image != be_kernel) && !system_supports_mixed_endian())
+		return ERR_PTR(-EINVAL);
+
+	value = arm64_image_flag_field(flags, ARM64_IMAGE_FLAG_PAGE_SIZE);
+	if (((value == ARM64_IMAGE_FLAG_PAGE_SIZE_4K) &&
+			!system_supports_4kb_granule()) ||
+	    ((value == ARM64_IMAGE_FLAG_PAGE_SIZE_64K) &&
+			!system_supports_64kb_granule()) ||
+	    ((value == ARM64_IMAGE_FLAG_PAGE_SIZE_16K) &&
+			!system_supports_16kb_granule()))
+		return ERR_PTR(-EINVAL);
+
+	/* Load the kernel */
+	kbuf.image = image;
+	kbuf.buf_min = 0;
+	kbuf.buf_max = ULONG_MAX;
+	kbuf.top_down = false;
+
+	kbuf.buffer = kernel;
+	kbuf.bufsz = kernel_len;
+	kbuf.mem = 0;
+	kbuf.memsz = le64_to_cpu(h->image_size);
+	text_offset = le64_to_cpu(h->text_offset);
+	kbuf.buf_align = MIN_KIMG_ALIGN;
+
+	/* Adjust kernel segment with TEXT_OFFSET */
+	kbuf.memsz += text_offset;
+
+	ret = kexec_add_buffer(&kbuf);
+	if (ret)
+		return ERR_PTR(ret);
+
+	kernel_segment = &image->segment[image->nr_segments - 1];
+	kernel_segment->mem += text_offset;
+	kernel_segment->memsz -= text_offset;
+	image->start = kernel_segment->mem;
+
+	pr_debug("Loaded kernel at 0x%lx bufsz=0x%lx memsz=0x%lx\n",
+				kernel_segment->mem, kbuf.bufsz,
+				kernel_segment->memsz);
+
+	/* Load additional data */
+	ret = load_other_segments(image,
+				kernel_segment->mem, kernel_segment->memsz,
+				initrd, initrd_len, cmdline);
+
+	return ERR_PTR(ret);
+}
+
+const struct kexec_file_ops kexec_image_ops = {
+	.probe = image_probe,
+	.load = image_load,
+};
