commit 348a625deef13d7f8537b9704d29d05cafdd8e72
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Mar 26 18:14:23 2020 +0100

    arm64: rename stext to primary_entry
    
    For historical reasons, the primary entry routine living somewhere in
    the inittext section is called stext(), which is confusing, given that
    there is also a section marker called _stext which lives at a fixed
    offset in the image (either 64 or 4096 bytes, depending on whether
    CONFIG_EFI is enabled)
    
    Let's rename stext to primary_entry(), which is a better description
    and reflects the secondary_entry() routine that already exists for
    SMP boot.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Link: https://lore.kernel.org/r/20200326171423.3080-1-ardb@kernel.org
    Reviwed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index 7f06ad93fc95..be0a63ffed23 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -13,7 +13,7 @@
 #ifdef CONFIG_EFI
 
 __efistub_kernel_size		= _edata - _text;
-__efistub_stext_offset		= stext - _text;
+__efistub_primary_entry_offset	= primary_entry - _text;
 
 
 /*

commit b9676962cd5350a36579ad12dc0760a3f08bcd4a
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Feb 28 13:14:07 2020 +0100

    efi/arm64: Clean EFI stub exit code from cache instead of avoiding it
    
    Commit 9f9223778 ("efi/libstub/arm: Make efi_entry() an ordinary PE/COFF
    entrypoint") modified the handover code written in assembler, and for
    maintainability, aligned the logic with the logic used in the 32-bit ARM
    version, which is to avoid cache maintenance on the remaining instructions
    in the subroutine that will be executed with the MMU and caches off, and
    instead, branch into the relocated copy of the kernel image.
    
    However, this assumes that this copy is executable, and this means we
    expect EFI_LOADER_DATA regions to be executable as well, which is not
    a reasonable assumption to make, even if this is true for most UEFI
    implementations today.
    
    So change this back, and add a __clean_dcache_area_poc() call to cover
    the remaining code in the subroutine. While at it, switch the other
    call site over to __clean_dcache_area_poc() as well, and clean up the
    terminology in comments to avoid using 'flush' in the context of cache
    maintenance. Also, let's switch to the new style asm annotations.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Link: https://lore.kernel.org/r/20200228121408.9075-6-ardb@kernel.org

diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index 9a7aef0d6f70..7f06ad93fc95 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -13,6 +13,7 @@
 #ifdef CONFIG_EFI
 
 __efistub_kernel_size		= _edata - _text;
+__efistub_stext_offset		= stext - _text;
 
 
 /*
@@ -34,7 +35,7 @@ __efistub_strnlen		= __pi_strnlen;
 __efistub_strcmp		= __pi_strcmp;
 __efistub_strncmp		= __pi_strncmp;
 __efistub_strrchr		= __pi_strrchr;
-__efistub___flush_dcache_area	= __pi___flush_dcache_area;
+__efistub___clean_dcache_area_poc = __pi___clean_dcache_area_poc;
 
 #ifdef CONFIG_KASAN
 __efistub___memcpy		= __pi_memcpy;
@@ -43,7 +44,6 @@ __efistub___memset		= __pi_memset;
 #endif
 
 __efistub__text			= _text;
-__efistub_stext			= stext;
 __efistub__end			= _end;
 __efistub__edata		= _edata;
 __efistub_screen_info		= screen_info;

commit 91d150c0cc637b9d9d6394936add7cd2b7ccc410
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:46 2020 +0100

    efi/libstub: Clean up command line parsing routine
    
    We currently parse the command non-destructively, to avoid having to
    allocate memory for a copy before passing it to the standard parsing
    routines that are used by the core kernel, and which modify the input
    to delineate the parsed tokens with NUL characters.
    
    Instead, we call strstr() and strncmp() to go over the input multiple
    times, and match prefixes rather than tokens, which implies that we
    would match, e.g., 'nokaslrfoo' in the stub and disable KASLR, while
    the kernel would disregard the option and run with KASLR enabled.
    
    In order to avoid having to reason about whether and how this behavior
    may be abused, let's clean up the parsing routines, and rebuild them
    on top of the existing helpers.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index 87cb3d45b4bd..9a7aef0d6f70 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -47,6 +47,7 @@ __efistub_stext			= stext;
 __efistub__end			= _end;
 __efistub__edata		= _edata;
 __efistub_screen_info		= screen_info;
+__efistub__ctype		= _ctype;
 
 #endif
 

commit 9f9223778ef385e79dc67f5ee48ee4c1fb757f6b
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 17 12:44:37 2020 +0100

    efi/libstub/arm: Make efi_entry() an ordinary PE/COFF entrypoint
    
    Expose efi_entry() as the PE/COFF entrypoint directly, instead of
    jumping into a wrapper that fiddles with stack buffers and other
    stuff that the compiler is much better at. The only reason this
    code exists is to obtain a pointer to the base of the image, but
    we can get the same value from the loaded_image protocol, which
    we already need for other reasons anyway.
    
    Update the return type as well, to make it consistent with what
    is required for a PE/COFF executable entrypoint.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index 25a2a9b479c2..87cb3d45b4bd 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -12,7 +12,8 @@
 
 #ifdef CONFIG_EFI
 
-__efistub_stext_offset = stext - _text;
+__efistub_kernel_size		= _edata - _text;
+
 
 /*
  * The EFI stub has its own symbol namespace prefixed by __efistub_, to
@@ -42,6 +43,7 @@ __efistub___memset		= __pi_memset;
 #endif
 
 __efistub__text			= _text;
+__efistub_stext			= stext;
 __efistub__end			= _end;
 __efistub__edata		= _edata;
 __efistub_screen_info		= screen_info;

commit 90776dd1c427cbb4d381aa4b13338f1fb1d20f5e
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Aug 13 16:04:50 2019 -0700

    arm64/efi: Move variable assignments after SECTIONS
    
    It seems that LLVM's linker does not correctly handle variable assignments
    involving section positions that are updated during the SECTIONS
    parsing. Commit aa69fb62bea1 ("arm64/efi: Mark __efistub_stext_offset as
    an absolute symbol explicitly") ran into this too, but found a different
    workaround.
    
    However, this was not enough, as other variables were also miscalculated
    which manifested as boot failures under UEFI where __efistub__end was
    not taking the correct _end value (they should be the same):
    
    $ ld.lld -EL -maarch64elf --no-undefined -X -shared \
            -Bsymbolic -z notext -z norelro --no-apply-dynamic-relocs \
            -o vmlinux.lld -T poc.lds --whole-archive vmlinux.o && \
      readelf -Ws vmlinux.lld | egrep '\b(__efistub_|)_end\b'
    368272: ffff000002218000     0 NOTYPE  LOCAL  HIDDEN    38 __efistub__end
    368322: ffff000012318000     0 NOTYPE  GLOBAL DEFAULT   38 _end
    
    $ aarch64-linux-gnu-ld.bfd -EL -maarch64elf --no-undefined -X -shared \
            -Bsymbolic -z notext -z norelro --no-apply-dynamic-relocs \
            -o vmlinux.bfd -T poc.lds --whole-archive vmlinux.o && \
      readelf -Ws vmlinux.bfd | egrep '\b(__efistub_|)_end\b'
    338124: ffff000012318000     0 NOTYPE  LOCAL  DEFAULT  ABS __efistub__end
    383812: ffff000012318000     0 NOTYPE  GLOBAL DEFAULT 15325 _end
    
    To work around this, all of the __efistub_-prefixed variable assignments
    need to be moved after the linker script's SECTIONS entry. As it turns
    out, this also solves the problem fixed in commit aa69fb62bea1, so those
    changes are reverted here.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/634
    Link: https://bugs.llvm.org/show_bug.cgi?id=42990
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
new file mode 100644
index 000000000000..25a2a9b479c2
--- /dev/null
+++ b/arch/arm64/kernel/image-vars.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Linker script variables to be set after section resolution, as
+ * ld.lld does not like variables assigned before SECTIONS is processed.
+ */
+#ifndef __ARM64_KERNEL_IMAGE_VARS_H
+#define __ARM64_KERNEL_IMAGE_VARS_H
+
+#ifndef LINKER_SCRIPT
+#error This file should only be included in vmlinux.lds.S
+#endif
+
+#ifdef CONFIG_EFI
+
+__efistub_stext_offset = stext - _text;
+
+/*
+ * The EFI stub has its own symbol namespace prefixed by __efistub_, to
+ * isolate it from the kernel proper. The following symbols are legally
+ * accessed by the stub, so provide some aliases to make them accessible.
+ * Only include data symbols here, or text symbols of functions that are
+ * guaranteed to be safe when executed at another offset than they were
+ * linked at. The routines below are all implemented in assembler in a
+ * position independent manner
+ */
+__efistub_memcmp		= __pi_memcmp;
+__efistub_memchr		= __pi_memchr;
+__efistub_memcpy		= __pi_memcpy;
+__efistub_memmove		= __pi_memmove;
+__efistub_memset		= __pi_memset;
+__efistub_strlen		= __pi_strlen;
+__efistub_strnlen		= __pi_strnlen;
+__efistub_strcmp		= __pi_strcmp;
+__efistub_strncmp		= __pi_strncmp;
+__efistub_strrchr		= __pi_strrchr;
+__efistub___flush_dcache_area	= __pi___flush_dcache_area;
+
+#ifdef CONFIG_KASAN
+__efistub___memcpy		= __pi_memcpy;
+__efistub___memmove		= __pi_memmove;
+__efistub___memset		= __pi_memset;
+#endif
+
+__efistub__text			= _text;
+__efistub__end			= _end;
+__efistub__edata		= _edata;
+__efistub_screen_info		= screen_info;
+
+#endif
+
+#endif /* __ARM64_KERNEL_IMAGE_VARS_H */
