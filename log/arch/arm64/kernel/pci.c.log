commit 0b104773b4f72ccd8af98a2f1efe69b174c344d3
Author: Rob Herring <robh@kernel.org>
Date:   Thu Apr 9 17:49:21 2020 -0600

    PCI: Constify struct pci_ecam_ops
    
    struct pci_ecam_ops is typically DT match table data which is defined to
    be const. It's also best practice for ops structs to be const. Ideally,
    we'd make struct pci_ops const as well, but that becomes pretty
    invasive, so for now we just cast it where needed.
    
    Link: https://lore.kernel.org/r/20200409234923.21598-2-robh@kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andrew Murray <amurray@thegoodpenguin.co.uk>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jonathan Chocron <jonnyc@amazon.com>
    Cc: Zhou Wang <wangzhou1@hisilicon.com>
    Cc: Robert Richter <rrichter@marvell.com>
    Cc: Toan Le <toan@os.amperecomputing.com>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Mans Rullgard <mans@mansr.com>
    Cc: linux-acpi@vger.kernel.org

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 570988c7a7ff..1006ed2d7c60 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -117,7 +117,7 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 	struct device *dev = &root->device->dev;
 	struct resource *bus_res = &root->secondary;
 	u16 seg = root->segment;
-	struct pci_ecam_ops *ecam_ops;
+	const struct pci_ecam_ops *ecam_ops;
 	struct resource cfgres;
 	struct acpi_device *adev;
 	struct pci_config_window *cfg;
@@ -185,7 +185,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 
 	root_ops->release_info = pci_acpi_generic_release_info;
 	root_ops->prepare_resources = pci_acpi_root_prepare_resources;
-	root_ops->pci_ops = &ri->cfg->ops->pci_ops;
+	root_ops->pci_ops = (struct pci_ops *)&ri->cfg->ops->pci_ops;
 	bus = acpi_pci_root_create(root, root_ops, &ri->common, ri->cfg);
 	if (!bus)
 		return NULL;

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 85dc04136e86680378546afb808357a58c06061c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Jun 15 10:23:59 2019 +1000

    arm64: PCI: Preserve firmware configuration when desired
    
    If we must preserve the firmware resource assignments, claim the existing
    resources rather than reassigning everything.
    
    Link: https://lore.kernel.org/r/20190615002359.29577-4-benh@kernel.crashing.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 1419b1b4e9b9..16fcb8d72553 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -168,6 +168,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	struct acpi_pci_generic_root_info *ri;
 	struct pci_bus *bus, *child;
 	struct acpi_pci_root_ops *root_ops;
+	struct pci_host_bridge *host;
 
 	ri = kzalloc(sizeof(*ri), GFP_KERNEL);
 	if (!ri)
@@ -193,6 +194,15 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	if (!bus)
 		return NULL;
 
+	/* If we must preserve the resource configuration, claim now */
+	host = pci_find_host_bridge(bus);
+	if (host->preserve_config)
+		pci_bus_claim_resources(bus);
+
+	/*
+	 * Assign whatever was left unassigned. If we didn't claim above,
+	 * this will reassign everything.
+	 */
 	pci_assign_unassigned_root_bus_resources(bus);
 
 	list_for_each_entry(child, &bus->children, node)

commit 3e8ba9686600e5f77e692126bf0293edf162989a
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Jun 15 10:23:56 2019 +1000

    arm64: PCI: Allow resource reallocation if necessary
    
    Call pci_assign_unassigned_root_bus_resources() instead of the simpler:
    
      pci_bus_size_bridges(bus);
      pci_bus_assign_resources(bus);
    
    pci_assign_unassigned_root_bus_resources() calls:
    
      __pci_bus_size_bridges(bus, add_list);
      __pci_bus_assign_resources(bus, add_list, &fail_head);
    
    so this should be equivalent as long as we're able to assign everything.
    If we were unable to assign something, previously we did nothing and left
    it unassigned, but after this patch, we will attempt to do some
    reallocation.
    
    Once we start honoring FW resource allocations, this will bring up the
    "reallocation" feature which can help making room for SR-IOV when
    necessary.
    
    Link: https://lore.kernel.org/r/20190615002359.29577-1-benh@kernel.crashing.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index bb85e2f4603f..1419b1b4e9b9 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -193,8 +193,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	if (!bus)
 		return NULL;
 
-	pci_bus_size_bridges(bus);
-	pci_bus_assign_resources(bus);
+	pci_assign_unassigned_root_bus_resources(bus);
 
 	list_for_each_entry(child, &bus->children, node)
 		pcie_bus_configure_settings(child);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index bb85e2f4603f..575bd5517d21 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Code borrowed from powerpc/kernel/pci-common.c
  *
  * Copyright (C) 2003 Anton Blanchard <anton@au.ibm.com>, IBM
  * Copyright (C) 2014 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
  */
 
 #include <linux/acpi.h>

commit 9c314a48aeab0562bf5418f707ee060171d52ac2
Author: Punit Agrawal <punit.agrawal@arm.com>
Date:   Tue Aug 28 16:05:12 2018 +0100

    arm64: PCI: Remove node-local allocations when initialising host controller
    
    Memory for host controller data structures is allocated local to the node
    to which the controller is associated with.  This has been the behaviour
    since support for ACPI was added in commit 0cb0786bac15 ("ARM64: PCI:
    Support ACPI-based PCI host controller").
    
    Drop the node local allocation as there is no benefit from doing so - the
    usage of these structures is independent from where the controller is
    located.
    
    Signed-off-by: Punit Agrawal <punit.agrawal@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 0e2ea1c78542..bb85e2f4603f 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -165,16 +165,15 @@ static void pci_acpi_generic_release_info(struct acpi_pci_root_info *ci)
 /* Interface called from ACPI code to setup PCI host controller */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
-	int node = acpi_get_node(root->device->handle);
 	struct acpi_pci_generic_root_info *ri;
 	struct pci_bus *bus, *child;
 	struct acpi_pci_root_ops *root_ops;
 
-	ri = kzalloc_node(sizeof(*ri), GFP_KERNEL, node);
+	ri = kzalloc(sizeof(*ri), GFP_KERNEL);
 	if (!ri)
 		return NULL;
 
-	root_ops = kzalloc_node(sizeof(*root_ops), GFP_KERNEL, node);
+	root_ops = kzalloc(sizeof(*root_ops), GFP_KERNEL);
 	if (!root_ops) {
 		kfree(ri);
 		return NULL;

commit ecf677c8dcaa7bf13eee31b4d9e4639d559984ad
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Wed Aug 2 14:44:50 2017 -0500

    PCI: Add a generic weak pcibios_align_resource()
    
    Multiple architectures define this as a trivial function, and I'm adding
    another one as part of the RISC-V port.  Add a __weak version of
    pcibios_align_resource() and delete the now-obselete ones in a handful of
    ports.
    
    The only functional change should be that a handful of ports used to export
    pcibios_fixup_bus().  Only some architectures export this, so I just
    dropped it.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index d91051259bb2..0e2ea1c78542 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -22,15 +22,6 @@
 #include <linux/pci-ecam.h>
 #include <linux/slab.h>
 
-/*
- * We don't have to worry about legacy ISA devices, so nothing to do here
- */
-resource_size_t pcibios_align_resource(void *data, const struct resource *res,
-				resource_size_t size, resource_size_t align)
-{
-	return res->start;
-}
-
 #ifdef CONFIG_ACPI
 /*
  * Try to assign the IRQ number when probing a new device

commit bccf90d6e063d278b9ddc78dd266d0adef29886c
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Fri Jun 23 18:50:42 2017 -0700

    PCI: Add a generic weak pcibios_fixup_bus()
    
    Multiple architectures define this as an empty function, and I'm adding
    another one as part of the RISC-V port.  Add a __weak version of
    pcibios_fixup_bus() and delete the now-obselete ones in a handful of
    ports.
    
    The only functional change should be that microblaze used to export
    pcibios_fixup_bus().  None of the other architectures exports this, so I
    just dropped it.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index e2b7e4f9cc31..d91051259bb2 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -22,14 +22,6 @@
 #include <linux/pci-ecam.h>
 #include <linux/slab.h>
 
-/*
- * Called after each bus is probed, but before its children are examined
- */
-void pcibios_fixup_bus(struct pci_bus *bus)
-{
-	/* nothing to do, expected to be removed in the future */
-}
-
 /*
  * We don't have to worry about legacy ISA devices, so nothing to do here
  */

commit f263fbb8d60824993c1b64385056a3cfdbb21d45
Merge: 026d15f6b987 6aed468480e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 8 15:51:57 2017 -0700

    Merge tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - add sysfs max_link_speed/width, current_link_speed/width (Wong Vee
        Khee)
    
      - make host bridge IRQ mapping much more generic (Matthew Minter,
        Lorenzo Pieralisi)
    
      - convert most drivers to pci_scan_root_bus_bridge() (Lorenzo
        Pieralisi)
    
      - mutex sriov_configure() (Jakub Kicinski)
    
      - mutex pci_error_handlers callbacks (Christoph Hellwig)
    
      - split ->reset_notify() into ->reset_prepare()/reset_done()
        (Christoph Hellwig)
    
      - support multiple PCIe portdrv interrupts for MSI as well as MSI-X
        (Gabriele Paoloni)
    
      - allocate MSI/MSI-X vector for Downstream Port Containment (Gabriele
        Paoloni)
    
      - fix MSI IRQ affinity pre/post/min_vecs issue (Michael Hernandez)
    
      - test INTx masking during enumeration, not at run-time (Piotr Gregor)
    
      - avoid using device_may_wakeup() for runtime PM (Rafael J. Wysocki)
    
      - restore the status of PCI devices across hibernation (Chen Yu)
    
      - keep parent resources that start at 0x0 (Ard Biesheuvel)
    
      - enable ECRC only if device supports it (Bjorn Helgaas)
    
      - restore PRI and PASID state after Function-Level Reset (CQ Tang)
    
      - skip DPC event if device is not present (Keith Busch)
    
      - check domain when matching SMBIOS info (Sujith Pandel)
    
      - mark Intel XXV710 NIC INTx masking as broken (Alex Williamson)
    
      - avoid AMD SB7xx EHCI USB wakeup defect (Kai-Heng Feng)
    
      - work around long-standing Macbook Pro poweroff issue (Bjorn Helgaas)
    
      - add Switchtec "running" status flag (Logan Gunthorpe)
    
      - fix dra7xx incorrect RW1C IRQ register usage (Arvind Yadav)
    
      - modify xilinx-nwl IRQ chip for legacy interrupts (Bharat Kumar
        Gogada)
    
      - move VMD SRCU cleanup after bus, child device removal (Jon Derrick)
    
      - add Faraday clock handling (Linus Walleij)
    
      - configure Rockchip MPS and reorganize (Shawn Lin)
    
      - limit Qualcomm TLP size to 2K (hardware issue) (Srinivas Kandagatla)
    
      - support Tegra MSI 64-bit addressing (Thierry Reding)
    
      - use Rockchip normal (not privileged) register bank (Shawn Lin)
    
      - add HiSilicon Kirin SoC PCIe controller driver (Xiaowei Song)
    
      - add Sigma Designs Tango SMP8759 PCIe controller driver (Marc
        Gonzalez)
    
      - add MediaTek PCIe host controller support (Ryder Lee)
    
      - add Qualcomm IPQ4019 support (John Crispin)
    
      - add HyperV vPCI protocol v1.2 support (Jork Loeser)
    
      - add i.MX6 regulator support (Quentin Schulz)
    
    * tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (113 commits)
      PCI: tango: Add Sigma Designs Tango SMP8759 PCIe host bridge support
      PCI: Add DT binding for Sigma Designs Tango PCIe controller
      PCI: rockchip: Use normal register bank for config accessors
      dt-bindings: PCI: Add documentation for MediaTek PCIe
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: xilinx: Make of_device_ids const
      PCI: xilinx-nwl: Modify IRQ chip for legacy interrupts
      PCI: vmd: Move SRCU cleanup after bus, child device removal
      PCI: vmd: Correct comment: VMD domains start at 0x10000, not 0x1000
      PCI: versatile: Add local struct device pointers
      PCI: tegra: Do not allocate MSI target memory
      PCI: tegra: Support MSI 64-bit addressing
      PCI: rockchip: Use local struct device pointer consistently
      PCI: rockchip: Check for clk_prepare_enable() errors during resume
      MAINTAINERS: Remove Wenrui Li as Rockchip PCIe driver maintainer
      PCI: rockchip: Configure RC's MPS setting
      PCI: rockchip: Reconfigure configuration space header type
      PCI: rockchip: Split out rockchip_pcie_cfg_configuration_accesses()
      PCI: rockchip: Move configuration accesses into rockchip_pcie_cfg_atu()
      ...

commit 769b461fc0c0451bacf75826d5830fc07c5a57e4
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:14:12 2017 -0500

    arm64: PCI: Drop DT IRQ allocation from pcibios_alloc_irq()
    
    With the introduction of struct pci_host_bridge.map_irq pointer it is
    possible to assign IRQs for all devices originating from a PCI host bridge
    at probe time; this is implemented through pci_assign_irq() that relies on
    the struct pci_host_bridge.map_irq pointer to map IRQ for a given device.
    
    The benefits this brings are twofold:
    
      - the IRQ for a device is assigned once at probe time
      - the IRQ assignment works also for hotplugged devices
    
    With all DT based PCI host bridges converted to the struct
    pci_host_bridge.{map/swizzle}_irq hooks mechanism the DT IRQ allocation in
    ARM64 pcibios_alloc_irq() is now redundant and can be removed.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 4f0e3ebfea4b..efcc351c518f 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -39,20 +39,18 @@ resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 	return res->start;
 }
 
+#ifdef CONFIG_ACPI
 /*
  * Try to assign the IRQ number when probing a new device
  */
 int pcibios_alloc_irq(struct pci_dev *dev)
 {
-	if (acpi_disabled)
-		dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
-#ifdef CONFIG_ACPI
-	else
-		return acpi_pci_irq_enable(dev);
-#endif
+	if (!acpi_disabled)
+		acpi_pci_irq_enable(dev);
 
 	return 0;
 }
+#endif
 
 /*
  * raw_pci_read/write - Platform-specific PCI config space access.

commit 3edb1dd13ce6f6480c1f2bffc47a49cf959fa9cb
Merge: 9ad95c46c18b 77b246b32b2c
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Jun 26 10:54:27 2017 +0100

    Merge branch 'aarch64/for-next/ras-apei' into aarch64/for-next/core
    
    Merge in arm64 ACPI RAS support (APEI/GHES) from Tyler Baicar.

commit db46a72b9713fd20c405e796d7ef841f6d9bd15f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed May 24 18:22:19 2017 +0100

    ARM64/PCI: Set root bus NUMA node on ACPI systems
    
    PCI core requires the NUMA node for the struct pci_host_bridge.dev to
    be set by using the pcibus_to_node(struct pci_bus*) API, that on ARM64
    systems relies on the struct pci_host_bridge->bus.dev NUMA node.
    
    The struct pci_host_bridge.dev NUMA node is then propagated through
    the PCI device hierarchy as PCI devices (and bridges) are enumerated
    under it.
    
    Therefore, in order to set-up the PCI NUMA hierarchy appropriately, the
    struct pci_host_bridge->bus.dev NUMA node must be set before core
    code calls pcibus_to_node(struct pci_bus*) on it so that PCI core can
    retrieve the NUMA node for the struct pci_host_bridge.dev device and can
    propagate it through the PCI bus tree.
    
    On ARM64 ACPI based systems the struct pci_host_bridge->bus.dev NUMA
    node can be set-up in pcibios_root_bridge_prepare() by parsing the root
    bridge ACPI device firmware binding.
    
    Add code to the pcibios_root_bridge_prepare() that, when booting with
    ACPI, parse the root bridge ACPI device companion NUMA binding and set
    the corresponding struct pci_host_bridge->bus.dev NUMA node
    appropriately.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Robert Richter <rrichter@cavium.com>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 4f0e3ebfea4b..108283443336 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -108,7 +108,10 @@ int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 	if (!acpi_disabled) {
 		struct pci_config_window *cfg = bridge->bus->sysdata;
 		struct acpi_device *adev = to_acpi_device(cfg->parent);
+		struct device *bus_dev = &bridge->bus->dev;
+
 		ACPI_COMPANION_SET(&bridge->dev, adev);
+		set_dev_node(bus_dev, acpi_get_node(acpi_device_handle(adev)));
 	}
 
 	return 0;

commit 717902cc93118119a6fce7765da6cf2786987418
Author: Timmy Li <lixiaoping3@huawei.com>
Date:   Mon May 22 16:48:28 2017 +0100

    ARM64: PCI: Fix struct acpi_pci_root_ops allocation failure path
    
    Commit 093d24a20442 ("arm64: PCI: Manage controller-specific data on
    per-controller basis") added code to allocate ACPI PCI root_ops
    dynamically on a per host bridge basis but failed to update the
    corresponding memory allocation failure path in pci_acpi_scan_root()
    leading to a potential memory leakage.
    
    Fix it by adding the required kfree call.
    
    Fixes: 093d24a20442 ("arm64: PCI: Manage controller-specific data on per-controller basis")
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
    [lorenzo.pieralisi@arm.com: refactored code, rewrote commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 4f0e3ebfea4b..c7e3e6387a49 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -191,8 +191,10 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 		return NULL;
 
 	root_ops = kzalloc_node(sizeof(*root_ops), GFP_KERNEL, node);
-	if (!root_ops)
+	if (!root_ops) {
+		kfree(ri);
 		return NULL;
+	}
 
 	ri->cfg = pci_acpi_setup_ecam_mapping(root);
 	if (!ri->cfg) {

commit 13983eb89d5afaa65acd4479fad151cbd4de5509
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Sep 9 21:24:03 2016 +0200

    PCI/ACPI: Extend pci_mcfg_lookup() to return ECAM config accessors
    
    pci_mcfg_lookup() is the external interface to the generic MCFG code.
    Previously it merely looked up the ECAM base address for a given domain and
    bus range.  We want a way to add MCFG quirks, some of which may require
    special config accessors and adjustments to the ECAM address range.
    
    Extend pci_mcfg_lookup() so it can return a pointer to a pci_ecam_ops
    structure and a struct resource for the ECAM address space.  For now, it
    always returns &pci_generic_ecam_ops (the standard accessor) and the
    resource described by the MCFG.
    
    No functional changes intended.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 266a7b2d4184..4f0e3ebfea4b 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -137,25 +137,18 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 	struct device *dev = &root->device->dev;
 	struct resource *bus_res = &root->secondary;
 	u16 seg = root->segment;
+	struct pci_ecam_ops *ecam_ops;
 	struct resource cfgres;
 	struct acpi_device *adev;
 	struct pci_config_window *cfg;
-	unsigned int bsz;
+	int ret;
 
-	/* Use address from _CBA if present, otherwise lookup MCFG */
-	if (!root->mcfg_addr)
-		root->mcfg_addr = pci_mcfg_lookup(seg, bus_res);
-
-	if (!root->mcfg_addr) {
+	ret = pci_mcfg_lookup(root, &cfgres, &ecam_ops);
+	if (ret) {
 		dev_err(dev, "%04x:%pR ECAM region not found\n", seg, bus_res);
 		return NULL;
 	}
 
-	bsz = 1 << pci_generic_ecam_ops.bus_shift;
-	cfgres.start = root->mcfg_addr + bus_res->start * bsz;
-	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
-	cfgres.flags = IORESOURCE_MEM;
-
 	adev = acpi_resource_consumer(&cfgres);
 	if (adev)
 		dev_info(dev, "ECAM area %pR reserved by %s\n", &cfgres,
@@ -164,7 +157,7 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 		dev_warn(dev, FW_BUG "ECAM area %pR not reserved in ACPI namespace\n",
 			 &cfgres);
 
-	cfg = pci_ecam_create(dev, &cfgres, bus_res, &pci_generic_ecam_ops);
+	cfg = pci_ecam_create(dev, &cfgres, bus_res, ecam_ops);
 	if (IS_ERR(cfg)) {
 		dev_err(dev, "%04x:%pR error %ld mapping ECAM\n", seg, bus_res,
 			PTR_ERR(cfg));

commit 8fd4391ee717569d60fa283da778f7497630c9b7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Dec 2 17:25:54 2016 -0600

    arm64: PCI: Exclude ACPI "consumer" resources from host bridge windows
    
    On x86 and ia64, we have treated all ACPI _CRS resources of PNP0A03 host
    bridge devices as "producers", i.e., as host bridge windows.  That's partly
    because some x86 BIOSes improperly used "consumer" descriptors to describe
    windows and partly because Linux didn't have good support for handling
    consumer and producer descriptors differently.
    
    One result is that x86 BIOSes describe host bridge "consumer" resources in
    the _CRS of a PNP0C02 device, not the PNP0A03 device itself.  On arm64 we
    don't have a legacy of firmware that has this consumer/producer confusion,
    so we can handle PNP0A03 "consumer" descriptors as host bridge registers
    instead of windows.
    
    Exclude non-window ("consumer") resources from the list of host bridge
    windows.  This allows the use of "consumer" PNP0A03 descriptors for bridge
    register space.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index ac4509d2668a..266a7b2d4184 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -114,6 +114,19 @@ int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 	return 0;
 }
 
+static int pci_acpi_root_prepare_resources(struct acpi_pci_root_info *ci)
+{
+	struct resource_entry *entry, *tmp;
+	int status;
+
+	status = acpi_pci_probe_root_resources(ci);
+	resource_list_for_each_entry_safe(entry, tmp, &ci->resources) {
+		if (!(entry->res->flags & IORESOURCE_WINDOW))
+			resource_list_destroy_entry(entry);
+	}
+	return status;
+}
+
 /*
  * Lookup the bus range for the domain in MCFG, and set up config space
  * mapping.
@@ -196,6 +209,7 @@ struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 	}
 
 	root_ops->release_info = pci_acpi_generic_release_info;
+	root_ops->prepare_resources = pci_acpi_root_prepare_resources;
 	root_ops->pci_ops = &ri->cfg->ops->pci_ops;
 	bus = acpi_pci_root_create(root, root_ops, &ri->common, ri->cfg);
 	if (!bus)

commit 093d24a204425f71f4f106b7e62c8df4b456e1cc
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Thu Nov 24 12:05:23 2016 +0100

    arm64: PCI: Manage controller-specific data on per-controller basis
    
    Currently we use one shared global acpi_pci_root_ops structure to keep
    controller-specific ops. We pass its pointer to acpi_pci_root_create() and
    associate it with a host bridge instance for good.  Such a design implies
    serious drawback. Any potential manipulation on the single system-wide
    acpi_pci_root_ops leads to kernel crash. The structure content is not
    really changing even across multiple host bridges creation; thus it was not
    an issue so far.
    
    In preparation for adding ECAM quirks mechanism (where controller-specific
    PCI ops may be different for each host bridge) allocate new
    acpi_pci_root_ops and fill in with data for each bridge. Now it is safe to
    have different controller-specific info. As a consequence free
    acpi_pci_root_ops when host bridge is released.
    
    No functional changes in this patch.
    
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 216dff6c5877..ac4509d2668a 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -168,33 +168,36 @@ static void pci_acpi_generic_release_info(struct acpi_pci_root_info *ci)
 
 	ri = container_of(ci, struct acpi_pci_generic_root_info, common);
 	pci_ecam_free(ri->cfg);
+	kfree(ci->ops);
 	kfree(ri);
 }
 
-static struct acpi_pci_root_ops acpi_pci_root_ops = {
-	.release_info = pci_acpi_generic_release_info,
-};
-
 /* Interface called from ACPI code to setup PCI host controller */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
 	int node = acpi_get_node(root->device->handle);
 	struct acpi_pci_generic_root_info *ri;
 	struct pci_bus *bus, *child;
+	struct acpi_pci_root_ops *root_ops;
 
 	ri = kzalloc_node(sizeof(*ri), GFP_KERNEL, node);
 	if (!ri)
 		return NULL;
 
+	root_ops = kzalloc_node(sizeof(*root_ops), GFP_KERNEL, node);
+	if (!root_ops)
+		return NULL;
+
 	ri->cfg = pci_acpi_setup_ecam_mapping(root);
 	if (!ri->cfg) {
 		kfree(ri);
+		kfree(root_ops);
 		return NULL;
 	}
 
-	acpi_pci_root_ops.pci_ops = &ri->cfg->ops->pci_ops;
-	bus = acpi_pci_root_create(root, &acpi_pci_root_ops, &ri->common,
-				   ri->cfg);
+	root_ops->release_info = pci_acpi_generic_release_info;
+	root_ops->pci_ops = &ri->cfg->ops->pci_ops;
+	bus = acpi_pci_root_create(root, root_ops, &ri->common, ri->cfg);
 	if (!bus)
 		return NULL;
 

commit 08b1c19606b5fc7f895dae4d43d507b4da4a83bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 30 14:48:33 2016 -0600

    arm64: PCI: Search ACPI namespace to ensure ECAM space is reserved
    
    The static MCFG table tells us the base of ECAM space, but it does not
    reserve the space -- the reservation should be done via a device in the
    ACPI namespace whose _CRS includes the ECAM region.
    
    Use acpi_resource_consumer() to check whether the ECAM space is reserved by
    an ACPI namespace device.  If it is, emit a message showing which device
    reserves it.  If not, emit a "[Firmware Bug]" warning.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 8183c9803206..216dff6c5877 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -124,8 +124,9 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 	struct device *dev = &root->device->dev;
 	struct resource *bus_res = &root->secondary;
 	u16 seg = root->segment;
-	struct pci_config_window *cfg;
 	struct resource cfgres;
+	struct acpi_device *adev;
+	struct pci_config_window *cfg;
 	unsigned int bsz;
 
 	/* Use address from _CBA if present, otherwise lookup MCFG */
@@ -141,6 +142,15 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 	cfgres.start = root->mcfg_addr + bus_res->start * bsz;
 	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
 	cfgres.flags = IORESOURCE_MEM;
+
+	adev = acpi_resource_consumer(&cfgres);
+	if (adev)
+		dev_info(dev, "ECAM area %pR reserved by %s\n", &cfgres,
+			 dev_name(&adev->dev));
+	else
+		dev_warn(dev, FW_BUG "ECAM area %pR not reserved in ACPI namespace\n",
+			 &cfgres);
+
 	cfg = pci_ecam_create(dev, &cfgres, bus_res, &pci_generic_ecam_ops);
 	if (IS_ERR(cfg)) {
 		dev_err(dev, "%04x:%pR error %ld mapping ECAM\n", seg, bus_res,

commit dfd1972c2b464c10fb585c4c60b594e09d181a01
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 1 11:33:57 2016 -0600

    arm64: PCI: Add local struct device pointers
    
    Use a local "struct device *dev" for brevity.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index acf38722457b..8183c9803206 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -121,6 +121,7 @@ int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 static struct pci_config_window *
 pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 {
+	struct device *dev = &root->device->dev;
 	struct resource *bus_res = &root->secondary;
 	u16 seg = root->segment;
 	struct pci_config_window *cfg;
@@ -132,8 +133,7 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 		root->mcfg_addr = pci_mcfg_lookup(seg, bus_res);
 
 	if (!root->mcfg_addr) {
-		dev_err(&root->device->dev, "%04x:%pR ECAM region not found\n",
-			seg, bus_res);
+		dev_err(dev, "%04x:%pR ECAM region not found\n", seg, bus_res);
 		return NULL;
 	}
 
@@ -141,11 +141,10 @@ pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
 	cfgres.start = root->mcfg_addr + bus_res->start * bsz;
 	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
 	cfgres.flags = IORESOURCE_MEM;
-	cfg = pci_ecam_create(&root->device->dev, &cfgres, bus_res,
-			      &pci_generic_ecam_ops);
+	cfg = pci_ecam_create(dev, &cfgres, bus_res, &pci_generic_ecam_ops);
 	if (IS_ERR(cfg)) {
-		dev_err(&root->device->dev, "%04x:%pR error %ld mapping ECAM\n",
-			seg, bus_res, PTR_ERR(cfg));
+		dev_err(dev, "%04x:%pR error %ld mapping ECAM\n", seg, bus_res,
+			PTR_ERR(cfg));
 		return NULL;
 	}
 

commit 3efc7023787f8a6ddc50fa96707614677a568466
Merge: a00c74c1664e ab2b750cad02
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:23:44 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      unicore32/PCI: Remove pci=firmware command line parameter handling
      ARM/PCI: Remove arch-specific pcibios_enable_device()
      ARM64/PCI: Remove arch-specific pcibios_enable_device()
      MIPS/PCI: Claim bus resources on PCI_PROBE_ONLY set-ups
      ARM/PCI: Claim bus resources on PCI_PROBE_ONLY set-ups
      PCI: generic: Claim bus resources on PCI_PROBE_ONLY set-ups
      PCI: Add generic pci_bus_claim_resources()
      alx: Use pci_(request|release)_mem_regions
      ethernet/intel: Use pci_(request|release)_mem_regions
      GenWQE: Use pci_(request|release)_mem_regions
      lpfc: Use pci_(request|release)_mem_regions
      NVMe: Use pci_(request|release)_mem_regions
      PCI: Add helpers to request/release memory and I/O regions
      PCI: Extending pci=resource_alignment to specify device/vendor IDs
      sparc/PCI: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      powerpc/pci: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      microblaze/PCI: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      PCI: Unify pci_resource_to_user() declarations
      microblaze/PCI: Remove useless __pci_mmap_set_pgprot()
      powerpc/pci: Remove __pci_mmap_set_pgprot()
      PCI: Ignore write combining when mapping I/O port space

commit f615bca4ccb9a91b33f0d378503b070fad97e181
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 8 12:04:49 2016 +0100

    ARM64/PCI: Remove arch-specific pcibios_enable_device()
    
    On systems with PCI_PROBE_ONLY set, we rely on BAR assignments from
    firmware.  Previously we did not insert those resources into the resource
    tree, so we had to skip pci_enable_resources() because it fails if
    resources are not in the resource tree.
    
    Now that we *do* insert resources even when PCI_PROBE_ONLY is set, we no
    longer need the ARM64-specific pcibios_enable_device().  Remove it so we
    use the generic version.
    
    [bhelgaas: changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    CC: Arnd Bergmann <arnd@arndb.de>
    CC: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 3c4e308b40a0..39cfa032ffa7 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -36,19 +36,6 @@ resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 	return res->start;
 }
 
-/**
- * pcibios_enable_device - Enable I/O and memory.
- * @dev: PCI device to be enabled
- * @mask: bitmask of BARs to enable
- */
-int pcibios_enable_device(struct pci_dev *dev, int mask)
-{
-	if (pci_has_flag(PCI_PROBE_ONLY))
-		return 0;
-
-	return pci_enable_resources(dev, mask);
-}
-
 /*
  * Try to assign the IRQ number from DT when adding a new device
  */

commit 0cb0786bac159ee4c983abab51093ef623849afa
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:19 2016 +0200

    ARM64: PCI: Support ACPI-based PCI host controller
    
    Implement pci_acpi_scan_root() and other arch-specific calls so ARM64 can
    use ACPI to setup and enumerate PCI buses.
    
    Use memory-mapped configuration space information from either the ACPI
    _CBA method or the MCFG table and the ECAM library and generic ECAM config
    accessor ops.
    
    Implement acpi_pci_bus_find_domain_nr() to retrieve the domain number from
    the acpi_pci_root structure.
    
    Implement pcibios_add_bus() and pcibios_remove_bus() to call
    acpi_pci_add_bus() and acpi_pci_remove_bus() for ACPI slot management and
    other configuration.
    
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 328f85727d35..94cd43c20130 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -18,6 +18,8 @@
 #include <linux/of_pci.h>
 #include <linux/of_platform.h>
 #include <linux/pci.h>
+#include <linux/pci-acpi.h>
+#include <linux/pci-ecam.h>
 #include <linux/slab.h>
 
 /*
@@ -100,15 +102,123 @@ EXPORT_SYMBOL(pcibus_to_node);
 
 #ifdef CONFIG_ACPI
 
+struct acpi_pci_generic_root_info {
+	struct acpi_pci_root_info	common;
+	struct pci_config_window	*cfg;	/* config space mapping */
+};
+
 int acpi_pci_bus_find_domain_nr(struct pci_bus *bus)
 {
+	struct pci_config_window *cfg = bus->sysdata;
+	struct acpi_device *adev = to_acpi_device(cfg->parent);
+	struct acpi_pci_root *root = acpi_driver_data(adev);
+
+	return root->segment;
+}
+
+int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
+{
+	if (!acpi_disabled) {
+		struct pci_config_window *cfg = bridge->bus->sysdata;
+		struct acpi_device *adev = to_acpi_device(cfg->parent);
+		ACPI_COMPANION_SET(&bridge->dev, adev);
+	}
+
 	return 0;
 }
 
-/* Root bridge scanning */
+/*
+ * Lookup the bus range for the domain in MCFG, and set up config space
+ * mapping.
+ */
+static struct pci_config_window *
+pci_acpi_setup_ecam_mapping(struct acpi_pci_root *root)
+{
+	struct resource *bus_res = &root->secondary;
+	u16 seg = root->segment;
+	struct pci_config_window *cfg;
+	struct resource cfgres;
+	unsigned int bsz;
+
+	/* Use address from _CBA if present, otherwise lookup MCFG */
+	if (!root->mcfg_addr)
+		root->mcfg_addr = pci_mcfg_lookup(seg, bus_res);
+
+	if (!root->mcfg_addr) {
+		dev_err(&root->device->dev, "%04x:%pR ECAM region not found\n",
+			seg, bus_res);
+		return NULL;
+	}
+
+	bsz = 1 << pci_generic_ecam_ops.bus_shift;
+	cfgres.start = root->mcfg_addr + bus_res->start * bsz;
+	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
+	cfgres.flags = IORESOURCE_MEM;
+	cfg = pci_ecam_create(&root->device->dev, &cfgres, bus_res,
+			      &pci_generic_ecam_ops);
+	if (IS_ERR(cfg)) {
+		dev_err(&root->device->dev, "%04x:%pR error %ld mapping ECAM\n",
+			seg, bus_res, PTR_ERR(cfg));
+		return NULL;
+	}
+
+	return cfg;
+}
+
+/* release_info: free resources allocated by init_info */
+static void pci_acpi_generic_release_info(struct acpi_pci_root_info *ci)
+{
+	struct acpi_pci_generic_root_info *ri;
+
+	ri = container_of(ci, struct acpi_pci_generic_root_info, common);
+	pci_ecam_free(ri->cfg);
+	kfree(ri);
+}
+
+static struct acpi_pci_root_ops acpi_pci_root_ops = {
+	.release_info = pci_acpi_generic_release_info,
+};
+
+/* Interface called from ACPI code to setup PCI host controller */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {
-	/* TODO: Should be revisited when implementing PCI on ACPI */
-	return NULL;
+	int node = acpi_get_node(root->device->handle);
+	struct acpi_pci_generic_root_info *ri;
+	struct pci_bus *bus, *child;
+
+	ri = kzalloc_node(sizeof(*ri), GFP_KERNEL, node);
+	if (!ri)
+		return NULL;
+
+	ri->cfg = pci_acpi_setup_ecam_mapping(root);
+	if (!ri->cfg) {
+		kfree(ri);
+		return NULL;
+	}
+
+	acpi_pci_root_ops.pci_ops = &ri->cfg->ops->pci_ops;
+	bus = acpi_pci_root_create(root, &acpi_pci_root_ops, &ri->common,
+				   ri->cfg);
+	if (!bus)
+		return NULL;
+
+	pci_bus_size_bridges(bus);
+	pci_bus_assign_resources(bus);
+
+	list_for_each_entry(child, &bus->children, node)
+		pcie_bus_configure_settings(child);
+
+	return bus;
+}
+
+void pcibios_add_bus(struct pci_bus *bus)
+{
+	acpi_pci_add_bus(bus);
 }
+
+void pcibios_remove_bus(struct pci_bus *bus)
+{
+	acpi_pci_remove_bus(bus);
+}
+
 #endif

commit f058f4fbd64028c9e9d433472cf6bcff8efdce7c
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:18 2016 +0200

    ARM64: PCI: Implement AML accessors for PCI_Config region
    
    On ACPI systems, the PCI_Config OperationRegion allows AML to access PCI
    configuration space.  The ACPI CA AML interpreter uses performs config
    space accesses with acpi_os_read_pci_configuration() and
    acpi_os_write_pci_configuration(), which are OS-dependent functions
    supplied by acpi/osl.c.
    
    Implement the arch-specific raw_pci_read() and raw_pci_write() interfaces
    used by acpi/osl.c for PCI_Config accesses.
    
    N.B. PCI_Config accesses are not supported before PCI bus enumeration.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index b3b8a2c68510..328f85727d35 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -71,13 +71,21 @@ int pcibios_alloc_irq(struct pci_dev *dev)
 int raw_pci_read(unsigned int domain, unsigned int bus,
 		  unsigned int devfn, int reg, int len, u32 *val)
 {
-	return -ENXIO;
+	struct pci_bus *b = pci_find_bus(domain, bus);
+
+	if (!b)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	return b->ops->read(b, devfn, reg, len, val);
 }
 
 int raw_pci_write(unsigned int domain, unsigned int bus,
 		unsigned int devfn, int reg, int len, u32 val)
 {
-	return -ENXIO;
+	struct pci_bus *b = pci_find_bus(domain, bus);
+
+	if (!b)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	return b->ops->write(b, devfn, reg, len, val);
 }
 
 #ifdef CONFIG_NUMA

commit d8ed75d593321c80ccd92f9dba218e90286bde16
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:17 2016 +0200

    ARM64: PCI: ACPI support for legacy IRQs parsing and consolidation with DT code
    
    To enable PCI legacy IRQs on platforms booting with ACPI, arch code should
    include ACPI-specific callbacks that parse and set-up the device IRQ
    number, equivalent to the DT boot path. Owing to the current ACPI core scan
    handlers implementation, ACPI PCI legacy IRQs bindings cannot be parsed at
    device add time, since that would trigger ACPI scan handlers ordering
    issues depending on how the ACPI tables are defined.
    
    To solve this problem and consolidate FW PCI legacy IRQs parsing in one
    single pcibios callback (pending final removal), this patch moves DT PCI
    IRQ parsing to the pcibios_alloc_irq() callback (called by PCI core code at
    driver probe time) and adds ACPI PCI legacy IRQs parsing to the same
    callback too, so that FW PCI legacy IRQs parsing is confined in one single
    arch callback that can be easily removed when code parsing PCI legacy IRQs
    is consolidated and moved to core PCI code.
    
    Suggested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index d5d3d26834cf..b3b8a2c68510 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -51,11 +51,16 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 }
 
 /*
- * Try to assign the IRQ number from DT when adding a new device
+ * Try to assign the IRQ number when probing a new device
  */
-int pcibios_add_device(struct pci_dev *dev)
+int pcibios_alloc_irq(struct pci_dev *dev)
 {
-	dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
+	if (acpi_disabled)
+		dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
+#ifdef CONFIG_ACPI
+	else
+		return acpi_pci_irq_enable(dev);
+#endif
 
 	return 0;
 }

commit 2ab51ddeca2fc32a7040d8560415be3366fa9ba7
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 15:36:26 2016 -0500

    ARM64: PCI: Add acpi_pci_bus_find_domain_nr()
    
    Extend pci_bus_find_domain_nr() so it can find the domain from either:
    
      - ACPI, via the new acpi_pci_bus_find_domain_nr() interface, or
      - DT, via of_pci_bus_find_domain_nr()
    
    Note that this is only used for CONFIG_PCI_DOMAINS_GENERIC=y, so it does
    not affect x86 or ia64.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 3c4e308b40a0..d5d3d26834cf 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/of_pci.h>
 #include <linux/of_platform.h>
+#include <linux/pci.h>
 #include <linux/slab.h>
 
 /*
@@ -85,6 +86,12 @@ EXPORT_SYMBOL(pcibus_to_node);
 #endif
 
 #ifdef CONFIG_ACPI
+
+int acpi_pci_bus_find_domain_nr(struct pci_bus *bus)
+{
+	return 0;
+}
+
 /* Root bridge scanning */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
 {

commit 1a2db300348b799479d2d22b84d51b27ad0458c7
Author: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
Date:   Fri Apr 8 15:50:27 2016 -0700

    arm64, numa: Add NUMA support for arm64 platforms.
    
    Attempt to get the memory and CPU NUMA node via of_numa.  If that
    fails, default the dummy NUMA node and map all memory and CPUs to node
    0.
    
    Tested-by: Shannon Zhao <shannon.zhao@linaro.org>
    Reviewed-by: Robert Richter <rrichter@cavium.com>
    Signed-off-by: Ganapatrao Kulkarni <gkulkarni@caviumnetworks.com>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index c72de668e1d4..3c4e308b40a0 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -74,6 +74,16 @@ int raw_pci_write(unsigned int domain, unsigned int bus,
 	return -ENXIO;
 }
 
+#ifdef CONFIG_NUMA
+
+int pcibus_to_node(struct pci_bus *bus)
+{
+	return dev_to_node(&bus->dev);
+}
+EXPORT_SYMBOL(pcibus_to_node);
+
+#endif
+
 #ifdef CONFIG_ACPI
 /* Root bridge scanning */
 struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)

commit 234234c2e12e1b302beefbd11e9c5b26f9234cb1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:58:02 2016 -0600

    ARM64: PCI: Remove generated include of asm-generic/pci-bridge.h
    
    arm64 generates asm/pci-bridge.h, which merely includes the now-empty
    asm-generic/pci-bridge.h.  Stop generating asm/pci-bridge.h, and stop
    including it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index b3d098bd34aa..c72de668e1d4 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -19,8 +19,6 @@
 #include <linux/of_platform.h>
 #include <linux/slab.h>
 
-#include <asm/pci-bridge.h>
-
 /*
  * Called after each bus is probed, but before its children are examined
  */

commit 72407514c92c4e4b3584cba5961e63fb10c1a04e
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 30 14:13:59 2015 +0100

    ARM64: PCI: do not enable resources on PROBE_ONLY systems
    
    On ARM64 PROBE_ONLY PCI systems resources are not currently claimed,
    therefore they can't be enabled since they do not have a valid
    parent pointer; this in turn prevents enabling PCI devices on
    ARM64 PROBE_ONLY systems, causing PCI devices initialization to
    fail.
    
    To solve this issue, resources must be claimed when devices are
    added on PROBE_ONLY systems, which ensures that the resource hierarchy
    is validated and the resource tree is sane, but this requires changes
    in the ARM64 resource management that can affect adversely existing
    PCI set-ups (claiming resources on !PROBE_ONLY systems might break
    existing ARM64 PCI platform implementations).
    
    As a temporary solution in preparation for a proper resources claiming
    implementation in ARM64 core, to enable PCI PROBE_ONLY systems on ARM64,
    this patch adds a pcibios_enable_device() arch implementation that
    simply prevents enabling resources on PROBE_ONLY systems (mirroring ARM
    behaviour).
    
    This is always a safe thing to do because on PROBE_ONLY systems the
    configuration space set-up can be considered immutable, and it is in
    preparation of proper resource claiming that would finally validate
    the PCI resources tree in the ARM64 arch implementation on PROBE_ONLY
    systems.
    
    For !PROBE_ONLY systems resources enablement in pcibios_enable_device()
    on ARM64 is implemented as in current PCI core, leaving the behaviour
    unchanged.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 4095379dc069..b3d098bd34aa 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -38,6 +38,19 @@ resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 	return res->start;
 }
 
+/**
+ * pcibios_enable_device - Enable I/O and memory.
+ * @dev: PCI device to be enabled
+ * @mask: bitmask of BARs to enable
+ */
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	if (pci_has_flag(PCI_PROBE_ONLY))
+		return 0;
+
+	return pci_enable_resources(dev, mask);
+}
+
 /*
  * Try to assign the IRQ number from DT when adding a new device
  */

commit a9cb97fe71d84df103994861f00112fe2cba91be
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:40 2015 +0000

    ARM64 / ACPI: Introduce PCI stub functions for ACPI
    
    CONFIG_ACPI depends CONFIG_PCI on x86 and ia64, in ARM64 server
    world we will have PCIe in most cases, but some of them may not,
    make CONFIG_ACPI depend CONFIG_PCI on ARM64 will satisfy both.
    
    With that case, we need some arch dependent PCI functions to
    access the config space before the PCI root bridge is created, and
    pci_acpi_scan_root() to create the PCI root bus. So introduce
    some stub function here to make ACPI core compile and revisit
    them later when implemented on ARM64.
    
    CC: Liviu Dudau <Liviu.Dudau@arm.com>
    CC: Catalin Marinas <catalin.marinas@arm.com>
    CC: Will Deacon <will.deacon@arm.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index 6f93c24ca801..4095379dc069 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -10,6 +10,7 @@
  *
  */
 
+#include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
@@ -46,3 +47,27 @@ int pcibios_add_device(struct pci_dev *dev)
 
 	return 0;
 }
+
+/*
+ * raw_pci_read/write - Platform-specific PCI config space access.
+ */
+int raw_pci_read(unsigned int domain, unsigned int bus,
+		  unsigned int devfn, int reg, int len, u32 *val)
+{
+	return -ENXIO;
+}
+
+int raw_pci_write(unsigned int domain, unsigned int bus,
+		unsigned int devfn, int reg, int len, u32 val)
+{
+	return -ENXIO;
+}
+
+#ifdef CONFIG_ACPI
+/* Root bridge scanning */
+struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)
+{
+	/* TODO: Should be revisited when implementing PCI on ACPI */
+	return NULL;
+}
+#endif

commit 7c674700098c87b305b99652e3c694c4ef195866
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Sat Dec 27 18:19:12 2014 -0700

    PCI: Move domain assignment from arm64 to generic code
    
    The current logic in arm64 pci_bus_assign_domain_nr() is flawed in that
    depending on the host controller configuration for a platform and the
    initialization sequence, core code may end up allocating PCI domain numbers
    from both DT and the generic domain counter, which would result in PCI
    domain allocation aliases/errors.
    
    Fix the logic behind the PCI domain number assignment and move the
    resulting code to the PCI core so the same domain allocation logic is used
    on all platforms that select CONFIG_PCI_DOMAINS_GENERIC.
    
    [bhelgaas: tidy changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
index ce5836c14ec1..6f93c24ca801 100644
--- a/arch/arm64/kernel/pci.c
+++ b/arch/arm64/kernel/pci.c
@@ -46,25 +46,3 @@ int pcibios_add_device(struct pci_dev *dev)
 
 	return 0;
 }
-
-
-#ifdef CONFIG_PCI_DOMAINS_GENERIC
-static bool dt_domain_found = false;
-
-void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
-{
-	int domain = of_get_pci_domain_nr(parent->of_node);
-
-	if (domain >= 0) {
-		dt_domain_found = true;
-	} else if (dt_domain_found == true) {
-		dev_err(parent, "Node %s is missing \"linux,pci-domain\" property in DT\n",
-			parent->of_node->full_name);
-		return;
-	} else {
-		domain = pci_get_new_domain_nr();
-	}
-
-	bus->domain_nr = domain;
-}
-#endif

commit d1e6dc91b532d3d3dbbd0fa356b775ca320dc2c2
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Sep 29 15:29:31 2014 +0100

    arm64: Add architectural support for PCI
    
    Use the generic PCI domain and OF functions to provide support for PCI
    on arm64.
    
    [bhelgaas: Change comments to use generic PCI, not just PCIe.  Nothing at
    this level is PCIe-specific.]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c
new file mode 100644
index 000000000000..ce5836c14ec1
--- /dev/null
+++ b/arch/arm64/kernel/pci.c
@@ -0,0 +1,70 @@
+/*
+ * Code borrowed from powerpc/kernel/pci-common.c
+ *
+ * Copyright (C) 2003 Anton Blanchard <anton@au.ibm.com>, IBM
+ * Copyright (C) 2014 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+
+#include <asm/pci-bridge.h>
+
+/*
+ * Called after each bus is probed, but before its children are examined
+ */
+void pcibios_fixup_bus(struct pci_bus *bus)
+{
+	/* nothing to do, expected to be removed in the future */
+}
+
+/*
+ * We don't have to worry about legacy ISA devices, so nothing to do here
+ */
+resource_size_t pcibios_align_resource(void *data, const struct resource *res,
+				resource_size_t size, resource_size_t align)
+{
+	return res->start;
+}
+
+/*
+ * Try to assign the IRQ number from DT when adding a new device
+ */
+int pcibios_add_device(struct pci_dev *dev)
+{
+	dev->irq = of_irq_parse_and_map_pci(dev, 0, 0);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
+static bool dt_domain_found = false;
+
+void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
+{
+	int domain = of_get_pci_domain_nr(parent->of_node);
+
+	if (domain >= 0) {
+		dt_domain_found = true;
+	} else if (dt_domain_found == true) {
+		dev_err(parent, "Node %s is missing \"linux,pci-domain\" property in DT\n",
+			parent->of_node->full_name);
+		return;
+	} else {
+		domain = pci_get_new_domain_nr();
+	}
+
+	bus->domain_nr = domain;
+}
+#endif
