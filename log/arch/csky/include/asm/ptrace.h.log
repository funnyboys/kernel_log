commit 18c07d23da5a48525b2955aa269b8bb108c19300
Author: Guo Ren <guoren@linux.alibaba.com>
Date:   Wed May 13 15:15:25 2020 +0800

    csky: Fixup calltrace panic
    
    The implementation of show_stack will panic with wrong fp:
    
    addr    = *fp++;
    
    because the fp isn't checked properly.
    
    The current implementations of show_stack, wchan and stack_trace
    haven't been designed properly, so just deprecate them.
    
    This patch is a reference to riscv's way, all codes are modified from
    arm's. The patch is passed with:
    
     - cat /proc/<pid>/stack
     - cat /proc/<pid>/wchan
     - echo c > /proc/sysrq-trigger
    
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>

diff --git a/arch/csky/include/asm/ptrace.h b/arch/csky/include/asm/ptrace.h
index aae5aa96cf54..bcfb7070e48d 100644
--- a/arch/csky/include/asm/ptrace.h
+++ b/arch/csky/include/asm/ptrace.h
@@ -58,6 +58,16 @@ static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
 	return regs->usp;
 }
 
+static inline unsigned long frame_pointer(struct pt_regs *regs)
+{
+	return regs->regs[4];
+}
+static inline void frame_pointer_set(struct pt_regs *regs,
+				     unsigned long val)
+{
+	regs->regs[4] = val;
+}
+
 extern int regs_query_register_offset(const char *name);
 extern unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
 						unsigned int n);

commit 33e53ae1ce413a081254e686d9b27cc1b3585e2f
Author: Guo Ren <guoren@linux.alibaba.com>
Date:   Wed Apr 1 09:17:02 2020 +0800

    csky: Add kprobes supported
    
    This patch enable kprobes, kretprobes, ftrace interface. It utilized
    software breakpoint and single step debug exceptions, instructions
    simulation on csky.
    
    We use USR_BKPT replace origin instruction, and the kprobe handler
    prepares an excutable memory slot for out-of-line execution with a
    copy of the original instruction being probed. Most of instructions
    could be executed by single-step, but some instructions need origin
    pc value to execute and we need software simulate these instructions.
    
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/arch/csky/include/asm/ptrace.h b/arch/csky/include/asm/ptrace.h
index f16ca256e007..aae5aa96cf54 100644
--- a/arch/csky/include/asm/ptrace.h
+++ b/arch/csky/include/asm/ptrace.h
@@ -13,6 +13,8 @@
 
 #define PS_S	0x80000000 /* Supervisor Mode */
 
+#define USR_BKPT	0x1464
+
 #define arch_has_single_step() (1)
 #define current_pt_regs() \
 ({ (struct pt_regs *)((char *)current_thread_info() + THREAD_SIZE) - 1; })

commit bfe47f358ad298a1efb9b8f8299a81541d90df87
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Tue Dec 17 14:57:22 2019 +0800

    csky: Implement ptrace regs and stack API
    
    Needed for kprobes support. Copied and adapted from Patrick's patch,
    but it has been modified for csky's pt_regs.
    
    ref:
    https://lore.kernel.org/linux-riscv/1572919114-3886-2-git-send-email-vincent.chen@sifive.com/raw
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Cc: Patrick Staehlin <me@packi.ch>

diff --git a/arch/csky/include/asm/ptrace.h b/arch/csky/include/asm/ptrace.h
index d0aba7b32417..f16ca256e007 100644
--- a/arch/csky/include/asm/ptrace.h
+++ b/arch/csky/include/asm/ptrace.h
@@ -7,6 +7,7 @@
 #include <uapi/asm/ptrace.h>
 #include <asm/traps.h>
 #include <linux/types.h>
+#include <linux/compiler.h>
 
 #ifndef __ASSEMBLY__
 
@@ -22,6 +23,18 @@
 #define instruction_pointer(regs) ((regs)->pc)
 #define profile_pc(regs) instruction_pointer(regs)
 
+static inline void instruction_pointer_set(struct pt_regs *regs,
+					   unsigned long val)
+{
+	regs->pc = val;
+}
+
+#if defined(__CSKYABIV2__)
+#define MAX_REG_OFFSET offsetof(struct pt_regs, dcsr)
+#else
+#define MAX_REG_OFFSET offsetof(struct pt_regs, regs[9])
+#endif
+
 static inline bool in_syscall(struct pt_regs const *regs)
 {
 	return ((regs->sr >> 16) & 0xff) == VEC_TRAP0;
@@ -37,5 +50,33 @@ static inline unsigned long regs_return_value(struct pt_regs *regs)
 	return regs->a0;
 }
 
+/* Valid only for Kernel mode traps. */
+static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
+{
+	return regs->usp;
+}
+
+extern int regs_query_register_offset(const char *name);
+extern unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
+						unsigned int n);
+
+/*
+ * regs_get_register() - get register value from its offset
+ * @regs:      pt_regs from which register value is gotten
+ * @offset:    offset of the register.
+ *
+ * regs_get_register returns the value of a register whose offset from @regs.
+ * The @offset is the offset of the register in struct pt_regs.
+ * If @offset is bigger than MAX_REG_OFFSET, this returns 0.
+ */
+static inline unsigned long regs_get_register(struct pt_regs *regs,
+						unsigned int offset)
+{
+	if (unlikely(offset > MAX_REG_OFFSET))
+		return 0;
+
+	return *(unsigned long *)((unsigned long)regs + offset);
+}
+
 #endif /* __ASSEMBLY__ */
 #endif /* __ASM_CSKY_PTRACE_H */

commit f4625ee0e40a5c724bb3f3eb7fd89e491bfd7646
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Sat Mar 30 23:44:34 2019 +0800

    csky: Use in_syscall & forget_syscall instead of r11_sig
    
    We could use regs->sr 16-24 bits to detect syscall: VEC_TRAP0 and
    r11_sig is no necessary for current implementation.
    
    In this patch, we implement the in_syscall and forget_syscall which are
    inspired from arm & nds32, but csky pt_regs has no syscall_num element
    and we just set zero to regs->sr's vector-bits-field instead.
    
    For ret_from_fork, current task was forked from parent which is in syscall
    progress and its regs->sr has been already setted with VEC_TRAP0. See:
    arch/csky/kernel/process.c: copy_thread()
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>

diff --git a/arch/csky/include/asm/ptrace.h b/arch/csky/include/asm/ptrace.h
index 1e00578166f0..d0aba7b32417 100644
--- a/arch/csky/include/asm/ptrace.h
+++ b/arch/csky/include/asm/ptrace.h
@@ -5,6 +5,8 @@
 #define __ASM_CSKY_PTRACE_H
 
 #include <uapi/asm/ptrace.h>
+#include <asm/traps.h>
+#include <linux/types.h>
 
 #ifndef __ASSEMBLY__
 
@@ -20,6 +22,16 @@
 #define instruction_pointer(regs) ((regs)->pc)
 #define profile_pc(regs) instruction_pointer(regs)
 
+static inline bool in_syscall(struct pt_regs const *regs)
+{
+	return ((regs->sr >> 16) & 0xff) == VEC_TRAP0;
+}
+
+static inline void forget_syscall(struct pt_regs *regs)
+{
+	regs->sr &= ~(0xff << 16);
+}
+
 static inline unsigned long regs_return_value(struct pt_regs *regs)
 {
 	return regs->a0;

commit f335b10f3b6ca2d11adef95092fff65152c31b48
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Tue Mar 26 15:56:33 2019 +0800

    csky: Add non-uapi asm/ptrace.h namespace
    
    Move #ifdef __KERNEL__ code in the uapi namespace to non-uapi
    include/asm/ptrace.h namespace and remove #ifdef __KERNEL__ in
    include/asm/ptrace.h. Seperate ptrace.h in uapi and non-uapi is more
    common and clear.
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Cc: Dmitry V. Levin <ldv@altlinux.org>

diff --git a/arch/csky/include/asm/ptrace.h b/arch/csky/include/asm/ptrace.h
new file mode 100644
index 000000000000..1e00578166f0
--- /dev/null
+++ b/arch/csky/include/asm/ptrace.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+// Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd.
+
+#ifndef __ASM_CSKY_PTRACE_H
+#define __ASM_CSKY_PTRACE_H
+
+#include <uapi/asm/ptrace.h>
+
+#ifndef __ASSEMBLY__
+
+#define PS_S	0x80000000 /* Supervisor Mode */
+
+#define arch_has_single_step() (1)
+#define current_pt_regs() \
+({ (struct pt_regs *)((char *)current_thread_info() + THREAD_SIZE) - 1; })
+
+#define user_stack_pointer(regs) ((regs)->usp)
+
+#define user_mode(regs) (!((regs)->sr & PS_S))
+#define instruction_pointer(regs) ((regs)->pc)
+#define profile_pc(regs) instruction_pointer(regs)
+
+static inline unsigned long regs_return_value(struct pt_regs *regs)
+{
+	return regs->a0;
+}
+
+#endif /* __ASSEMBLY__ */
+#endif /* __ASM_CSKY_PTRACE_H */
