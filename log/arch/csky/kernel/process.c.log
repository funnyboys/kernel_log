commit 67002814cf3b7265900003f6a49657847eeeb57d
Author: Guo Ren <guoren@linux.alibaba.com>
Date:   Thu May 14 16:04:31 2020 +0800

    csky: Fixup gdbmacros.txt with name sp in thread_struct
    
    The gdbmacros.txt use sp in thread_struct, but csky use ksp. This
    cause bttnobp fail to excute.
    
    TODO:
     - Still couldn't display the contents of stack.
    
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index 4ad6db56c3cd..8b3fad062ab2 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -35,7 +35,7 @@ void flush_thread(void){}
  */
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
-	struct switch_stack *sw = (struct switch_stack *)tsk->thread.ksp;
+	struct switch_stack *sw = (struct switch_stack *)tsk->thread.sp;
 
 	return sw->r15;
 }
@@ -56,8 +56,8 @@ int copy_thread_tls(unsigned long clone_flags,
 	childstack = ((struct switch_stack *) childregs) - 1;
 	memset(childstack, 0, sizeof(struct switch_stack));
 
-	/* setup ksp for switch_to !!! */
-	p->thread.ksp = (unsigned long)childstack;
+	/* setup thread.sp for switch_to !!! */
+	p->thread.sp = (unsigned long)childstack;
 
 	if (unlikely(p->flags & PF_KTHREAD)) {
 		memset(childregs, 0, sizeof(struct pt_regs));

commit 18c07d23da5a48525b2955aa269b8bb108c19300
Author: Guo Ren <guoren@linux.alibaba.com>
Date:   Wed May 13 15:15:25 2020 +0800

    csky: Fixup calltrace panic
    
    The implementation of show_stack will panic with wrong fp:
    
    addr    = *fp++;
    
    because the fp isn't checked properly.
    
    The current implementations of show_stack, wchan and stack_trace
    haven't been designed properly, so just deprecate them.
    
    This patch is a reference to riscv's way, all codes are modified from
    arm's. The patch is passed with:
    
     - cat /proc/<pid>/stack
     - cat /proc/<pid>/wchan
     - echo c > /proc/sysrq-trigger
    
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index f7b231ca269a..4ad6db56c3cd 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -98,37 +98,6 @@ int dump_task_regs(struct task_struct *tsk, elf_gregset_t *pr_regs)
 	return 1;
 }
 
-unsigned long get_wchan(struct task_struct *p)
-{
-	unsigned long lr;
-	unsigned long *fp, *stack_start, *stack_end;
-	int count = 0;
-
-	if (!p || p == current || p->state == TASK_RUNNING)
-		return 0;
-
-	stack_start = (unsigned long *)end_of_stack(p);
-	stack_end = (unsigned long *)(task_stack_page(p) + THREAD_SIZE);
-
-	fp = (unsigned long *) thread_saved_fp(p);
-	do {
-		if (fp < stack_start || fp > stack_end)
-			return 0;
-#ifdef CONFIG_STACKTRACE
-		lr = fp[1];
-		fp = (unsigned long *)fp[0];
-#else
-		lr = *fp++;
-#endif
-		if (!in_sched_functions(lr) &&
-		    __kernel_text_address(lr))
-			return lr;
-	} while (count++ < 16);
-
-	return 0;
-}
-EXPORT_SYMBOL(get_wchan);
-
 #ifndef CONFIG_CPU_PM_NONE
 void arch_cpu_idle(void)
 {

commit 0b9f386c4be6493d282aab0af6f9b70c62142777
Author: Guo Ren <guoren@linux.alibaba.com>
Date:   Wed Feb 12 10:24:52 2020 +0800

    csky: Implement copy_thread_tls
    
    This is required for clone3 which passes the TLS value through a
    struct rather than a register.
    
    Cc: Amanieu d'Antras <amanieu@gmail.com>
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index 5349cd8c0f30..f7b231ca269a 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -40,10 +40,11 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 	return sw->r15;
 }
 
-int copy_thread(unsigned long clone_flags,
+int copy_thread_tls(unsigned long clone_flags,
 		unsigned long usp,
 		unsigned long kthread_arg,
-		struct task_struct *p)
+		struct task_struct *p,
+		unsigned long tls)
 {
 	struct switch_stack *childstack;
 	struct pt_regs *childregs = task_pt_regs(p);
@@ -70,7 +71,7 @@ int copy_thread(unsigned long clone_flags,
 			childregs->usp = usp;
 		if (clone_flags & CLONE_SETTLS)
 			task_thread_info(p)->tp_value = childregs->tls
-						      = childregs->regs[0];
+						      = tls;
 
 		childregs->a0 = 0;
 		childstack->r15 = (unsigned long) ret_from_fork;

commit 2f78c73f78c39dabc5c44ad8dd61fd6ec65636d6
Author: Mao Han <han_mao@c-sky.com>
Date:   Fri Oct 11 10:56:55 2019 +0800

    csky: Initial stack protector support
    
    This is a basic -fstack-protector support without per-task canary
    switching. The protector will report something like when stack
    corruption is detected:
    
    It's tested with strcpy local array overflow in sys_kill and get:
    stack-protector: Kernel stack is corrupted in: sys_kill+0x23c/0x23c
    
    TODO:
     - Support task switch for different cannary
    
    Signed-off-by: Mao Han <han_mao@c-sky.com>
    Signed-off-by: Guo Ren <guoren@linux.alibaba.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index f320d9248a22..5349cd8c0f30 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -16,6 +16,12 @@
 
 struct cpuinfo_csky cpu_data[NR_CPUS];
 
+#ifdef CONFIG_STACKPROTECTOR
+#include <linux/stackprotector.h>
+unsigned long __stack_chk_guard __read_mostly;
+EXPORT_SYMBOL(__stack_chk_guard);
+#endif
+
 asmlinkage void ret_from_fork(void);
 asmlinkage void ret_from_kernel_thread(void);
 

commit 48ede51fd94fe9251058fc85626b2aeb5cbb5884
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Wed Sep 25 19:56:16 2019 +0800

    csky: Fixup add zero_fp fixup perf backtrace panic
    
    We need set fp zero to let backtrace know the end. The patch fixup perf
    callchain panic problem, because backtrace didn't know what is the end
    of fp.
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Reported-by: Mao Han <han_mao@c-sky.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index e555740c0be5..f320d9248a22 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -55,7 +55,7 @@ int copy_thread(unsigned long clone_flags,
 	if (unlikely(p->flags & PF_KTHREAD)) {
 		memset(childregs, 0, sizeof(struct pt_regs));
 		childstack->r15 = (unsigned long) ret_from_kernel_thread;
-		childstack->r8 = kthread_arg;
+		childstack->r10 = kthread_arg;
 		childstack->r9 = usp;
 		childregs->sr = mfcr("psr");
 	} else {

commit 0ea2dc7cd668be5475babecaf6fdeaa464e2847b
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Sun Dec 9 14:18:05 2018 +0800

    csky: stacktrace supported.
    
    The gcc option "-mbacktrace" will push fp(r8),lr into stack and we could
    unwind the stack with:
            fp = *fp
            lr = (unsigned int *)fp[1]
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
index 8ed20028b160..e555740c0be5 100644
--- a/arch/csky/kernel/process.c
+++ b/arch/csky/kernel/process.c
@@ -93,26 +93,31 @@ int dump_task_regs(struct task_struct *tsk, elf_gregset_t *pr_regs)
 
 unsigned long get_wchan(struct task_struct *p)
 {
-	unsigned long esp, pc;
-	unsigned long stack_page;
+	unsigned long lr;
+	unsigned long *fp, *stack_start, *stack_end;
 	int count = 0;
 
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_page = (unsigned long)p;
-	esp = p->thread.esp0;
+	stack_start = (unsigned long *)end_of_stack(p);
+	stack_end = (unsigned long *)(task_stack_page(p) + THREAD_SIZE);
+
+	fp = (unsigned long *) thread_saved_fp(p);
 	do {
-		if (esp < stack_page+sizeof(struct task_struct) ||
-		    esp >= 8184+stack_page)
+		if (fp < stack_start || fp > stack_end)
 			return 0;
-		/*FIXME: There's may be error here!*/
-		pc = ((unsigned long *)esp)[1];
-		/* FIXME: This depends on the order of these functions. */
-		if (!in_sched_functions(pc))
-			return pc;
-		esp = *(unsigned long *) esp;
+#ifdef CONFIG_STACKTRACE
+		lr = fp[1];
+		fp = (unsigned long *)fp[0];
+#else
+		lr = *fp++;
+#endif
+		if (!in_sched_functions(lr) &&
+		    __kernel_text_address(lr))
+			return lr;
 	} while (count++ < 16);
+
 	return 0;
 }
 EXPORT_SYMBOL(get_wchan);

commit e9564df753fd547fcbcd4fd10015c3b1213ef452
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Wed Sep 5 14:25:14 2018 +0800

    csky: Process management and Signal
    
    This patch adds files related to task_switch, sigcontext, signal,
    fpu context switch.
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/arch/csky/kernel/process.c b/arch/csky/kernel/process.c
new file mode 100644
index 000000000000..8ed20028b160
--- /dev/null
+++ b/arch/csky/kernel/process.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd.
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/sched/task_stack.h>
+#include <linux/sched/debug.h>
+#include <linux/delay.h>
+#include <linux/kallsyms.h>
+#include <linux/uaccess.h>
+#include <linux/ptrace.h>
+
+#include <asm/elf.h>
+#include <abi/reg_ops.h>
+
+struct cpuinfo_csky cpu_data[NR_CPUS];
+
+asmlinkage void ret_from_fork(void);
+asmlinkage void ret_from_kernel_thread(void);
+
+/*
+ * Some archs flush debug and FPU info here
+ */
+void flush_thread(void){}
+
+/*
+ * Return saved PC from a blocked thread
+ */
+unsigned long thread_saved_pc(struct task_struct *tsk)
+{
+	struct switch_stack *sw = (struct switch_stack *)tsk->thread.ksp;
+
+	return sw->r15;
+}
+
+int copy_thread(unsigned long clone_flags,
+		unsigned long usp,
+		unsigned long kthread_arg,
+		struct task_struct *p)
+{
+	struct switch_stack *childstack;
+	struct pt_regs *childregs = task_pt_regs(p);
+
+#ifdef CONFIG_CPU_HAS_FPU
+	save_to_user_fp(&p->thread.user_fp);
+#endif
+
+	childstack = ((struct switch_stack *) childregs) - 1;
+	memset(childstack, 0, sizeof(struct switch_stack));
+
+	/* setup ksp for switch_to !!! */
+	p->thread.ksp = (unsigned long)childstack;
+
+	if (unlikely(p->flags & PF_KTHREAD)) {
+		memset(childregs, 0, sizeof(struct pt_regs));
+		childstack->r15 = (unsigned long) ret_from_kernel_thread;
+		childstack->r8 = kthread_arg;
+		childstack->r9 = usp;
+		childregs->sr = mfcr("psr");
+	} else {
+		*childregs = *(current_pt_regs());
+		if (usp)
+			childregs->usp = usp;
+		if (clone_flags & CLONE_SETTLS)
+			task_thread_info(p)->tp_value = childregs->tls
+						      = childregs->regs[0];
+
+		childregs->a0 = 0;
+		childstack->r15 = (unsigned long) ret_from_fork;
+	}
+
+	return 0;
+}
+
+/* Fill in the fpu structure for a core dump.  */
+int dump_fpu(struct pt_regs *regs, struct user_fp *fpu)
+{
+	memcpy(fpu, &current->thread.user_fp, sizeof(*fpu));
+	return 1;
+}
+EXPORT_SYMBOL(dump_fpu);
+
+int dump_task_regs(struct task_struct *tsk, elf_gregset_t *pr_regs)
+{
+	struct pt_regs *regs = task_pt_regs(tsk);
+
+	/* NOTE: usp is error value. */
+	ELF_CORE_COPY_REGS((*pr_regs), regs)
+
+	return 1;
+}
+
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long esp, pc;
+	unsigned long stack_page;
+	int count = 0;
+
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
+	stack_page = (unsigned long)p;
+	esp = p->thread.esp0;
+	do {
+		if (esp < stack_page+sizeof(struct task_struct) ||
+		    esp >= 8184+stack_page)
+			return 0;
+		/*FIXME: There's may be error here!*/
+		pc = ((unsigned long *)esp)[1];
+		/* FIXME: This depends on the order of these functions. */
+		if (!in_sched_functions(pc))
+			return pc;
+		esp = *(unsigned long *) esp;
+	} while (count++ < 16);
+	return 0;
+}
+EXPORT_SYMBOL(get_wchan);
+
+#ifndef CONFIG_CPU_PM_NONE
+void arch_cpu_idle(void)
+{
+#ifdef CONFIG_CPU_PM_WAIT
+	asm volatile("wait\n");
+#endif
+
+#ifdef CONFIG_CPU_PM_DOZE
+	asm volatile("doze\n");
+#endif
+
+#ifdef CONFIG_CPU_PM_STOP
+	asm volatile("stop\n");
+#endif
+	local_irq_enable();
+}
+#endif
