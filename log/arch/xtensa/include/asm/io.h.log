commit d092a87073269677b7ff09e71a8d91912b7f969a
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 16 08:09:38 2019 +0200

    arch: rely on asm-generic/io.h for default ioremap_* definitions
    
    Various architectures that use asm-generic/io.h still defined their
    own default versions of ioremap_nocache, ioremap_wt and ioremap_wc
    that point back to plain ioremap directly or indirectly.  Remove these
    definitions and rely on asm-generic/io.h instead.  For this to work
    the backup ioremap_* defintions needs to be changed to purely cpp
    macros instea of inlines to cover for architectures like openrisc
    that only define ioremap after including <asm-generic/io.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 441fb56926a7..54188e69b988 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -52,10 +52,6 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 }
 #define ioremap_cache ioremap_cache
 
-#define ioremap_nocache ioremap
-#define ioremap_wc ioremap
-#define ioremap_wt ioremap
-
 static inline void iounmap(volatile void __iomem *addr)
 {
 	unsigned long va = (unsigned long) addr;

commit ab53cea4186162cdc5e1f038dd656d4c983a2647
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Aug 12 23:39:23 2019 +0200

    xtensa: clean up ioremap
    
    Use ioremap as the main implemented function, and defined
    ioremap_nocache to it as a deprecated alias.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 988e08530a5c..441fb56926a7 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -32,8 +32,7 @@ void xtensa_iounmap(volatile void __iomem *addr);
 /*
  * Return the virtual address for the specified bus memory.
  */
-static inline void __iomem *ioremap_nocache(unsigned long offset,
-		unsigned long size)
+static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
 {
 	if (offset >= XCHAL_KIO_PADDR
 	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
@@ -52,15 +51,10 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 		return xtensa_ioremap_cache(offset, size);
 }
 #define ioremap_cache ioremap_cache
-#define ioremap_nocache ioremap_nocache
-
-#define ioremap_wc ioremap_nocache
-#define ioremap_wt ioremap_nocache
 
-static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
-{
-	return ioremap_nocache(offset, size);
-}
+#define ioremap_nocache ioremap
+#define ioremap_wc ioremap
+#define ioremap_wt ioremap
 
 static inline void iounmap(volatile void __iomem *addr)
 {

commit 982792f45894878b9ec13df81e6e02209b34cb11
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Sun Sep 1 23:55:49 2019 -0700

    xtensa: virt: move PCI root complex to KIO range
    
    Move PCI configuration space, MMIO and memory to the KIO range to free
    vmalloc area and use static TLB to access them. Move MMIO to the
    beginning of KIO and define PCI_IOBASE as XCHAL_KIO_BYPASS_VADDR to
    match it. Reduce number of supported PCI buses to 0x3f so that ECAM
    window fits into first 64MB of the KIO. Reduce size of the PCI memory
    window to 128MB so that it fits into KIO.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index da3e783f896b..988e08530a5c 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -21,6 +21,7 @@
 
 #define IOADDR(x)		(XCHAL_KIO_BYPASS_VADDR + (x))
 #define IO_SPACE_LIMIT ~0
+#define PCI_IOBASE		((void __iomem *)XCHAL_KIO_BYPASS_VADDR)
 
 #ifdef CONFIG_MMU
 

commit 8e65986dcae8c49501c1920064dc192e704248bb
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon May 6 13:07:26 2019 -0700

    xtensa: drop ifdef __KERNEL__ from kernel-only headers
    
    These headers are not exported to userspace, so they're never used
    without __KERNEL__ defined. Drop these ifdef statements.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index acc5bb2cf1c7..da3e783f896b 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -11,7 +11,6 @@
 #ifndef _XTENSA_IO_H
 #define _XTENSA_IO_H
 
-#ifdef __KERNEL__
 #include <asm/byteorder.h>
 #include <asm/page.h>
 #include <asm/vectors.h>
@@ -78,8 +77,6 @@ static inline void iounmap(volatile void __iomem *addr)
 
 #endif /* CONFIG_MMU */
 
-#endif	/* __KERNEL__ */
-
 #include <asm-generic/io.h>
 
 #endif	/* _XTENSA_IO_H */

commit 94bc61ead46c3d9943bd35a4536e61d4ea9f1e66
Author: Greentime Hu <greentime@andestech.com>
Date:   Wed Feb 21 14:21:23 2018 +0800

    xtensa: add ioremap_nocache declaration before include asm-generic/io.h.
    
    A future commit for the nds32 architecture bootstrap("asm-generic/io.h:
    move ioremap_nocache/ioremap_uc/ioremap_wc/ioremap_wt out of ifndef
    CONFIG_MMU") will move the ioremap_nocache out of the CONFIG_MMU ifdef.
    This means that in order to suppress re-definition errors we need to
    setup #define's before importing asm-generic/io.h.
    
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index c38e5a732d86..acc5bb2cf1c7 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -52,6 +52,7 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 		return xtensa_ioremap_cache(offset, size);
 }
 #define ioremap_cache ioremap_cache
+#define ioremap_nocache ioremap_nocache
 
 #define ioremap_wc ioremap_nocache
 #define ioremap_wt ioremap_nocache

commit 5bb8def55dc562d81ec582368b4f27c8d432fbd5
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Thu Dec 10 17:05:27 2015 -0800

    xtensa: support ioremap for memory outside KIO region
    
    Map physical memory outside KIO region into the vmalloc area.
    Unmap it with vunmap.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 74fed0b4e2c2..c38e5a732d86 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -25,9 +25,12 @@
 
 #ifdef CONFIG_MMU
 
+void __iomem *xtensa_ioremap_nocache(unsigned long addr, unsigned long size);
+void __iomem *xtensa_ioremap_cache(unsigned long addr, unsigned long size);
+void xtensa_iounmap(volatile void __iomem *addr);
+
 /*
  * Return the virtual address for the specified bus memory.
- * Note that we currently don't support any address outside the KIO segment.
  */
 static inline void __iomem *ioremap_nocache(unsigned long offset,
 		unsigned long size)
@@ -36,7 +39,7 @@ static inline void __iomem *ioremap_nocache(unsigned long offset,
 	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
 	else
-		BUG();
+		return xtensa_ioremap_nocache(offset, size);
 }
 
 static inline void __iomem *ioremap_cache(unsigned long offset,
@@ -46,7 +49,7 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
 	else
-		BUG();
+		return xtensa_ioremap_cache(offset, size);
 }
 #define ioremap_cache ioremap_cache
 
@@ -60,6 +63,13 @@ static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
 
 static inline void iounmap(volatile void __iomem *addr)
 {
+	unsigned long va = (unsigned long) addr;
+
+	if (!(va >= XCHAL_KIO_CACHED_VADDR &&
+	      va - XCHAL_KIO_CACHED_VADDR < XCHAL_KIO_SIZE) &&
+	    !(va >= XCHAL_KIO_BYPASS_VADDR &&
+	      va - XCHAL_KIO_BYPASS_VADDR < XCHAL_KIO_SIZE))
+		xtensa_iounmap(addr);
 }
 
 #define virt_to_bus     virt_to_phys

commit 260c64bbabdb8da7248c87e0cdd92023bd7b76c6
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Thu Sep 24 23:36:45 2015 +0300

    xtensa: nommu: provide correct KIO addresses
    
    KIO region location is different for noMMU cores. Provide different
    default physical address and make KIO virtual address equal to physical.
    
    Move xtensa_get_kio_paddr function close to XCHAL_KIO_PADDR definition
    and define it not only for MMUv3, but for all MMU options except MMUv2.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 867840f5400f..74fed0b4e2c2 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -25,15 +25,6 @@
 
 #ifdef CONFIG_MMU
 
-#if XCHAL_HAVE_PTP_MMU && XCHAL_HAVE_SPANNING_WAY && defined(CONFIG_OF)
-extern unsigned long xtensa_kio_paddr;
-
-static inline unsigned long xtensa_get_kio_paddr(void)
-{
-	return xtensa_kio_paddr;
-}
-#endif
-
 /*
  * Return the virtual address for the specified bus memory.
  * Note that we currently don't support any address outside the KIO segment.

commit 92281dee825f6d2eb07c441437e4196a44b0861c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 10 23:07:06 2015 -0400

    arch: introduce memremap()
    
    Existing users of ioremap_cache() are mapping memory that is known in
    advance to not have i/o side effects.  These users are forced to cast
    away the __iomem annotation, or otherwise neglect to fix the sparse
    errors thrown when dereferencing pointers to this memory.  Provide
    memremap() as a non __iomem annotated ioremap_*() in the case when
    ioremap is otherwise a pointer to cacheable memory. Empirically,
    ioremap_<cacheable-type>() call sites are seeking memory-like semantics
    (e.g.  speculative reads, and prefetching permitted).
    
    memremap() is a break from the ioremap implementation pattern of adding
    a new memremap_<type>() for each mapping type and having silent
    compatibility fall backs.  Instead, the implementation defines flags
    that are passed to the central memremap() and if a mapping type is not
    supported by an arch memremap returns NULL.
    
    We introduce a memremap prototype as a trivial wrapper of
    ioremap_cache() and ioremap_wt().  Later, once all ioremap_cache() and
    ioremap_wt() usage has been removed from drivers we teach archs to
    implement arch_memremap() with the ability to strictly enforce the
    mapping type.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index c39bb6e61911..867840f5400f 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -57,6 +57,7 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 	else
 		BUG();
 }
+#define ioremap_cache ioremap_cache
 
 #define ioremap_wc ioremap_nocache
 #define ioremap_wt ioremap_nocache

commit 556269c138a8b2d3f5714b8105fa6119ecc505f2
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Jun 4 18:55:16 2015 +0200

    arch/*/io.h: Add ioremap_wt() to all architectures
    
    Add ioremap_wt() to all arch-specific asm/io.h headers which
    define ioremap_wc() locally. These headers do not include
    <asm-generic/iomap.h>. Some of them include <asm-generic/io.h>,
    but ioremap_wt() is defined for consistency since they define
    all ioremap_xxx locally.
    
    In all architectures without Write-Through support, ioremap_wt()
    is defined indentical to ioremap_nocache().
    
    frv and m68k already have ioremap_writethrough(). On those we
    add ioremap_wt() indetical to ioremap_writethrough() and defines
    ARCH_HAS_IOREMAP_WT in both architectures.
    
    The ioremap_wt() interface is exported to drivers.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Elliott@hp.com
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: hch@lst.de
    Cc: hmh@hmh.eng.br
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-nvdimm@lists.01.org
    Cc: stefan.bader@canonical.com
    Cc: yigal@plexistor.com
    Link: http://lkml.kernel.org/r/1433436928-31903-9-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index fe1600a09438..c39bb6e61911 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -59,6 +59,7 @@ static inline void __iomem *ioremap_cache(unsigned long offset,
 }
 
 #define ioremap_wc ioremap_nocache
+#define ioremap_wt ioremap_nocache
 
 static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
 {

commit affd2ae5de035e3edc212985299bd3da2660ce1d
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Sep 4 11:37:53 2013 +0100

    xtensa: io: remove dummy relaxed accessor macros for reads
    
    These are now defined by asm-generic/io.h, so we don't need the private
    definitions anymore.
    
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 74944207167e..fe1600a09438 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -74,13 +74,6 @@ static inline void iounmap(volatile void __iomem *addr)
 
 #endif /* CONFIG_MMU */
 
-/*
- * Generic I/O
- */
-#define readb_relaxed readb
-#define readw_relaxed readw
-#define readl_relaxed readl
-
 #endif	/* __KERNEL__ */
 
 #include <asm-generic/io.h>

commit 9848e49a9a9aab075d79c5d2856abb879495f97f
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Thu Jan 16 03:38:58 2014 +0400

    xtensa: fix warning '"CONFIG_OF" is not defined'
    
    The warning only shows up when building MMUv3 configuration with OF
    support disabled.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 2a042d430c25..74944207167e 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -25,7 +25,7 @@
 
 #ifdef CONFIG_MMU
 
-#if XCHAL_HAVE_PTP_MMU && XCHAL_HAVE_SPANNING_WAY && CONFIG_OF
+#if XCHAL_HAVE_PTP_MMU && XCHAL_HAVE_SPANNING_WAY && defined(CONFIG_OF)
 extern unsigned long xtensa_kio_paddr;
 
 static inline unsigned long xtensa_get_kio_paddr(void)

commit 6cb971114f633a0bf240c20b681d989b45e3ec56
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Sun Dec 29 11:03:30 2013 +0200

    xtensa: remap io area defined in device tree
    
    Use the simple-bus node to discover the io area, and remap the cached and
    bypass io ranges. The parent-bus-address value of the first triplet in the
    "ranges" property is used. This value is rounded down to the nearest 256MB
    boundary. The length of the io area is fixed at 256MB; the "ranges" property
    length value is ignored.
    
    Other limitations: (1) only the first simple-bus node is considered, and (2)
    only the first triplet of the "ranges" property is considered.
    
    See ePAPR 1.1 §6.5 for the simple-bus node description, and §2.3.8 for the
    "ranges" property description.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 1482a3636381..2a042d430c25 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -24,6 +24,16 @@
 #define IO_SPACE_LIMIT ~0
 
 #ifdef CONFIG_MMU
+
+#if XCHAL_HAVE_PTP_MMU && XCHAL_HAVE_SPANNING_WAY && CONFIG_OF
+extern unsigned long xtensa_kio_paddr;
+
+static inline unsigned long xtensa_get_kio_paddr(void)
+{
+	return xtensa_kio_paddr;
+}
+#endif
+
 /*
  * Return the virtual address for the specified bus memory.
  * Note that we currently don't support any address outside the KIO segment.

commit 4809bb468f140d561dfbb785e8dcdda5bae8c1f2
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Sun Nov 17 08:14:54 2013 +0200

    xtensa: avoid duplicate of IO range definitions
    
    Define IO addresses in a single place, to make it easier to change for
    non-standard memory maps.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 700c2e6f2d25..1482a3636381 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -14,16 +14,12 @@
 #ifdef __KERNEL__
 #include <asm/byteorder.h>
 #include <asm/page.h>
+#include <asm/vectors.h>
 #include <linux/bug.h>
 #include <linux/kernel.h>
 
 #include <linux/types.h>
 
-#define XCHAL_KIO_CACHED_VADDR	0xe0000000
-#define XCHAL_KIO_BYPASS_VADDR	0xf0000000
-#define XCHAL_KIO_PADDR		0xf0000000
-#define XCHAL_KIO_SIZE		0x10000000
-
 #define IOADDR(x)		(XCHAL_KIO_BYPASS_VADDR + (x))
 #define IO_SPACE_LIMIT ~0
 

commit cddfcbcd05851a3b720055d40fc61c63ea1c2bd1
Author: Chris Zankel <chris@zankel.net>
Date:   Tue Oct 23 20:25:37 2012 -0700

    xtensa: use physical addresses for bus addresses
    
    Define virt_to_bus and bus_to_virt as virt_to_phys, and phys_to_virt,
           respectively.
    
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index e6be5b9091c2..700c2e6f2d25 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -62,6 +62,10 @@ static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
 static inline void iounmap(volatile void __iomem *addr)
 {
 }
+
+#define virt_to_bus     virt_to_phys
+#define bus_to_virt     phys_to_virt
+
 #endif /* CONFIG_MMU */
 
 /*

commit d38efc1f150f38b7f593ac7e26789c550d4bc183
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Sep 17 05:44:40 2012 +0400

    xtensa: adopt generic io routines
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 4f66dfc103a5..e6be5b9091c2 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -25,74 +25,31 @@
 #define XCHAL_KIO_SIZE		0x10000000
 
 #define IOADDR(x)		(XCHAL_KIO_BYPASS_VADDR + (x))
+#define IO_SPACE_LIMIT ~0
 
+#ifdef CONFIG_MMU
 /*
- * swap functions to change byte order from little-endian to big-endian and
- * vice versa.
- */
-
-static inline unsigned short _swapw (unsigned short v)
-{
-	return (v << 8) | (v >> 8);
-}
-
-static inline unsigned int _swapl (unsigned int v)
-{
-	return (v << 24) | ((v & 0xff00) << 8) | ((v >> 8) & 0xff00) | (v >> 24);
-}
-
-/*
- * Change virtual addresses to physical addresses and vv.
- * These are trivial on the 1:1 Linux/Xtensa mapping
- */
-
-static inline unsigned long virt_to_phys(volatile void * address)
-{
-	return __pa(address);
-}
-
-static inline void * phys_to_virt(unsigned long address)
-{
-	return __va(address);
-}
-
-/*
- * virt_to_bus and bus_to_virt are deprecated.
- */
-
-#define virt_to_bus(x)	virt_to_phys(x)
-#define bus_to_virt(x)	phys_to_virt(x)
-
-/*
- * Return the virtual (cached) address for the specified bus memory.
+ * Return the virtual address for the specified bus memory.
  * Note that we currently don't support any address outside the KIO segment.
  */
 static inline void __iomem *ioremap_nocache(unsigned long offset,
 		unsigned long size)
 {
-#ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
 	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
 	else
 		BUG();
-#else
-	return (void *)offset;
-#endif
 }
 
 static inline void __iomem *ioremap_cache(unsigned long offset,
 		unsigned long size)
 {
-#ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
 	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
 	else
 		BUG();
-#else
-	return (void *)offset;
-#endif
 }
 
 #define ioremap_wc ioremap_nocache
@@ -105,112 +62,17 @@ static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
 static inline void iounmap(volatile void __iomem *addr)
 {
 }
+#endif /* CONFIG_MMU */
 
 /*
  * Generic I/O
  */
-
-#define readb(addr) \
-	({ unsigned char __v = (*(volatile unsigned char *)(addr)); __v; })
-#define readw(addr) \
-	({ unsigned short __v = (*(volatile unsigned short *)(addr)); __v; })
-#define readl(addr) \
-	({ unsigned int __v = (*(volatile unsigned int *)(addr)); __v; })
-#define writeb(b, addr) (void)((*(volatile unsigned char *)(addr)) = (b))
-#define writew(b, addr) (void)((*(volatile unsigned short *)(addr)) = (b))
-#define writel(b, addr) (void)((*(volatile unsigned int *)(addr)) = (b))
-
-static inline __u8 __raw_readb(const volatile void __iomem *addr)
-{
-          return *(__force volatile __u8 *)(addr);
-}
-static inline __u16 __raw_readw(const volatile void __iomem *addr)
-{
-          return *(__force volatile __u16 *)(addr);
-}
-static inline __u32 __raw_readl(const volatile void __iomem *addr)
-{
-          return *(__force volatile __u32 *)(addr);
-}
-static inline void __raw_writeb(__u8 b, volatile void __iomem *addr)
-{
-          *(__force volatile __u8 *)(addr) = b;
-}
-static inline void __raw_writew(__u16 b, volatile void __iomem *addr)
-{
-          *(__force volatile __u16 *)(addr) = b;
-}
-static inline void __raw_writel(__u32 b, volatile void __iomem *addr)
-{
-          *(__force volatile __u32 *)(addr) = b;
-}
-
-/* These are the definitions for the x86 IO instructions
- * inb/inw/inl/outb/outw/outl, the "string" versions
- * insb/insw/insl/outsb/outsw/outsl, and the "pausing" versions
- * inb_p/inw_p/...
- * The macros don't do byte-swapping.
- */
-
-#define inb(port)		readb((u8 *)((port)))
-#define outb(val, port)		writeb((val),(u8 *)((unsigned long)(port)))
-#define inw(port)		readw((u16 *)((port)))
-#define outw(val, port)		writew((val),(u16 *)((unsigned long)(port)))
-#define inl(port)		readl((u32 *)((port)))
-#define outl(val, port)		writel((val),(u32 *)((unsigned long)(port)))
-
-#define inb_p(port)		inb((port))
-#define outb_p(val, port)	outb((val), (port))
-#define inw_p(port)		inw((port))
-#define outw_p(val, port)	outw((val), (port))
-#define inl_p(port)		inl((port))
-#define outl_p(val, port)	outl((val), (port))
-
-extern void insb (unsigned long port, void *dst, unsigned long count);
-extern void insw (unsigned long port, void *dst, unsigned long count);
-extern void insl (unsigned long port, void *dst, unsigned long count);
-extern void outsb (unsigned long port, const void *src, unsigned long count);
-extern void outsw (unsigned long port, const void *src, unsigned long count);
-extern void outsl (unsigned long port, const void *src, unsigned long count);
-
-#define IO_SPACE_LIMIT ~0
-
-#define memset_io(a,b,c)       memset((void *)(a),(b),(c))
-#define memcpy_fromio(a,b,c)   memcpy((a),(void *)(b),(c))
-#define memcpy_toio(a,b,c)      memcpy((void *)(a),(b),(c))
-
-/* At this point the Xtensa doesn't provide byte swap instructions */
-
-#ifdef __XTENSA_EB__
-# define in_8(addr) (*(u8*)(addr))
-# define in_le16(addr) _swapw(*(u16*)(addr))
-# define in_le32(addr) _swapl(*(u32*)(addr))
-# define out_8(b, addr) *(u8*)(addr) = (b)
-# define out_le16(b, addr) *(u16*)(addr) = _swapw(b)
-# define out_le32(b, addr) *(u32*)(addr) = _swapl(b)
-#elif defined(__XTENSA_EL__)
-# define in_8(addr)  (*(u8*)(addr))
-# define in_le16(addr) (*(u16*)(addr))
-# define in_le32(addr) (*(u32*)(addr))
-# define out_8(b, addr) *(u8*)(addr) = (b)
-# define out_le16(b, addr) *(u16*)(addr) = (b)
-# define out_le32(b, addr) *(u32*)(addr) = (b)
-#else
-# error processor byte order undefined!
-#endif
-
-
-/*
- * Convert a physical pointer to a virtual kernel pointer for /dev/mem access
- */
-#define xlate_dev_mem_ptr(p)    __va(p)
-
-/*
- * Convert a virtual cached pointer to an uncached pointer
- */
-#define xlate_dev_kmem_ptr(p)   p
-
+#define readb_relaxed readb
+#define readw_relaxed readw
+#define readl_relaxed readl
 
 #endif	/* __KERNEL__ */
 
+#include <asm-generic/io.h>
+
 #endif	/* _XTENSA_IO_H */

commit 02f3774877382bac52972a677c2c5fbd3532a1a1
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Sep 17 05:44:39 2012 +0400

    xtensa: fix ioremap
    
    - fix ioremap_nocache to actually return non-cacheable address
    - add explicit ioremap_cache
    - fix KIO aperture checking arithmetic
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 4beb43c087d3..4f66dfc103a5 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -67,12 +67,12 @@ static inline void * phys_to_virt(unsigned long address)
  * Return the virtual (cached) address for the specified bus memory.
  * Note that we currently don't support any address outside the KIO segment.
  */
-
-static inline void *ioremap(unsigned long offset, unsigned long size)
+static inline void __iomem *ioremap_nocache(unsigned long offset,
+		unsigned long size)
 {
 #ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
-	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
 	else
 		BUG();
@@ -81,11 +81,12 @@ static inline void *ioremap(unsigned long offset, unsigned long size)
 #endif
 }
 
-static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
+static inline void __iomem *ioremap_cache(unsigned long offset,
+		unsigned long size)
 {
 #ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
-	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+	    && offset - XCHAL_KIO_PADDR < XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
 	else
 		BUG();
@@ -94,7 +95,14 @@ static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
 #endif
 }
 
-static inline void iounmap(void *addr)
+#define ioremap_wc ioremap_nocache
+
+static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
+{
+	return ioremap_nocache(offset, size);
+}
+
+static inline void iounmap(volatile void __iomem *addr)
 {
 }
 

commit bfae8ee8d28e6a4ac1d63e8077cb09928d8a557a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Apr 18 16:20:38 2012 -0400

    xtensa: fix build error in xtensa/include/asm/io.h
    
    Caused by commit 6c03438edeb5c359af35f060ea016ca65671c269
    
        kernel.h: doesn't explicitly use bug.h, so don't include it.
    
    This header uses bug.h so explicitly include it now that the
    implicit presence was removed by 6c03438ed.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index d04cd3a625fa..4beb43c087d3 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -14,6 +14,7 @@
 #ifdef __KERNEL__
 #include <asm/byteorder.h>
 #include <asm/page.h>
+#include <linux/bug.h>
 #include <linux/kernel.h>
 
 #include <linux/types.h>

commit e5083a63b6a8546c5fe1e571fe529e3939787ec2
Author: Johannes Weiner <jw@emlix.com>
Date:   Wed Mar 4 16:21:31 2009 +0100

    xtensa: nommu support
    
    Add support for !CONFIG_MMU setups.
    
    Signed-off-by: Johannes Weiner <jw@emlix.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
index 07b7299dab20..d04cd3a625fa 100644
--- a/arch/xtensa/include/asm/io.h
+++ b/arch/xtensa/include/asm/io.h
@@ -69,21 +69,28 @@ static inline void * phys_to_virt(unsigned long address)
 
 static inline void *ioremap(unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
 	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
-
 	else
 		BUG();
+#else
+	return (void *)offset;
+#endif
 }
 
 static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
 {
+#ifdef CONFIG_MMU
 	if (offset >= XCHAL_KIO_PADDR
 	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
 		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
 	else
 		BUG();
+#else
+	return (void *)offset;
+#endif
 }
 
 static inline void iounmap(void *addr)

commit 367b8112fe2ea5c39a7bb4d263dcdd9b612fae18
Author: Chris Zankel <chris@zankel.net>
Date:   Thu Nov 6 06:40:46 2008 -0800

    xtensa: move headers files to arch/xtensa/include
    
    Move all header files for xtensa to arch/xtensa/include and platform and
    variant header files to the appropriate arch/xtensa/platforms/ and
    arch/xtensa/variants/ directories.
    
    Moving the files gets also rid of all uses of symlinks in the Makefile.
    
    This has been completed already for the majority of the architectures
    and xtensa is one out of six missing.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/include/asm/io.h b/arch/xtensa/include/asm/io.h
new file mode 100644
index 000000000000..07b7299dab20
--- /dev/null
+++ b/arch/xtensa/include/asm/io.h
@@ -0,0 +1,200 @@
+/*
+ * include/asm-xtensa/io.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 - 2005 Tensilica Inc.
+ */
+
+#ifndef _XTENSA_IO_H
+#define _XTENSA_IO_H
+
+#ifdef __KERNEL__
+#include <asm/byteorder.h>
+#include <asm/page.h>
+#include <linux/kernel.h>
+
+#include <linux/types.h>
+
+#define XCHAL_KIO_CACHED_VADDR	0xe0000000
+#define XCHAL_KIO_BYPASS_VADDR	0xf0000000
+#define XCHAL_KIO_PADDR		0xf0000000
+#define XCHAL_KIO_SIZE		0x10000000
+
+#define IOADDR(x)		(XCHAL_KIO_BYPASS_VADDR + (x))
+
+/*
+ * swap functions to change byte order from little-endian to big-endian and
+ * vice versa.
+ */
+
+static inline unsigned short _swapw (unsigned short v)
+{
+	return (v << 8) | (v >> 8);
+}
+
+static inline unsigned int _swapl (unsigned int v)
+{
+	return (v << 24) | ((v & 0xff00) << 8) | ((v >> 8) & 0xff00) | (v >> 24);
+}
+
+/*
+ * Change virtual addresses to physical addresses and vv.
+ * These are trivial on the 1:1 Linux/Xtensa mapping
+ */
+
+static inline unsigned long virt_to_phys(volatile void * address)
+{
+	return __pa(address);
+}
+
+static inline void * phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+
+/*
+ * virt_to_bus and bus_to_virt are deprecated.
+ */
+
+#define virt_to_bus(x)	virt_to_phys(x)
+#define bus_to_virt(x)	phys_to_virt(x)
+
+/*
+ * Return the virtual (cached) address for the specified bus memory.
+ * Note that we currently don't support any address outside the KIO segment.
+ */
+
+static inline void *ioremap(unsigned long offset, unsigned long size)
+{
+	if (offset >= XCHAL_KIO_PADDR
+	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
+
+	else
+		BUG();
+}
+
+static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
+{
+	if (offset >= XCHAL_KIO_PADDR
+	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
+	else
+		BUG();
+}
+
+static inline void iounmap(void *addr)
+{
+}
+
+/*
+ * Generic I/O
+ */
+
+#define readb(addr) \
+	({ unsigned char __v = (*(volatile unsigned char *)(addr)); __v; })
+#define readw(addr) \
+	({ unsigned short __v = (*(volatile unsigned short *)(addr)); __v; })
+#define readl(addr) \
+	({ unsigned int __v = (*(volatile unsigned int *)(addr)); __v; })
+#define writeb(b, addr) (void)((*(volatile unsigned char *)(addr)) = (b))
+#define writew(b, addr) (void)((*(volatile unsigned short *)(addr)) = (b))
+#define writel(b, addr) (void)((*(volatile unsigned int *)(addr)) = (b))
+
+static inline __u8 __raw_readb(const volatile void __iomem *addr)
+{
+          return *(__force volatile __u8 *)(addr);
+}
+static inline __u16 __raw_readw(const volatile void __iomem *addr)
+{
+          return *(__force volatile __u16 *)(addr);
+}
+static inline __u32 __raw_readl(const volatile void __iomem *addr)
+{
+          return *(__force volatile __u32 *)(addr);
+}
+static inline void __raw_writeb(__u8 b, volatile void __iomem *addr)
+{
+          *(__force volatile __u8 *)(addr) = b;
+}
+static inline void __raw_writew(__u16 b, volatile void __iomem *addr)
+{
+          *(__force volatile __u16 *)(addr) = b;
+}
+static inline void __raw_writel(__u32 b, volatile void __iomem *addr)
+{
+          *(__force volatile __u32 *)(addr) = b;
+}
+
+/* These are the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl, the "string" versions
+ * insb/insw/insl/outsb/outsw/outsl, and the "pausing" versions
+ * inb_p/inw_p/...
+ * The macros don't do byte-swapping.
+ */
+
+#define inb(port)		readb((u8 *)((port)))
+#define outb(val, port)		writeb((val),(u8 *)((unsigned long)(port)))
+#define inw(port)		readw((u16 *)((port)))
+#define outw(val, port)		writew((val),(u16 *)((unsigned long)(port)))
+#define inl(port)		readl((u32 *)((port)))
+#define outl(val, port)		writel((val),(u32 *)((unsigned long)(port)))
+
+#define inb_p(port)		inb((port))
+#define outb_p(val, port)	outb((val), (port))
+#define inw_p(port)		inw((port))
+#define outw_p(val, port)	outw((val), (port))
+#define inl_p(port)		inl((port))
+#define outl_p(val, port)	outl((val), (port))
+
+extern void insb (unsigned long port, void *dst, unsigned long count);
+extern void insw (unsigned long port, void *dst, unsigned long count);
+extern void insl (unsigned long port, void *dst, unsigned long count);
+extern void outsb (unsigned long port, const void *src, unsigned long count);
+extern void outsw (unsigned long port, const void *src, unsigned long count);
+extern void outsl (unsigned long port, const void *src, unsigned long count);
+
+#define IO_SPACE_LIMIT ~0
+
+#define memset_io(a,b,c)       memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)   memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)      memcpy((void *)(a),(b),(c))
+
+/* At this point the Xtensa doesn't provide byte swap instructions */
+
+#ifdef __XTENSA_EB__
+# define in_8(addr) (*(u8*)(addr))
+# define in_le16(addr) _swapw(*(u16*)(addr))
+# define in_le32(addr) _swapl(*(u32*)(addr))
+# define out_8(b, addr) *(u8*)(addr) = (b)
+# define out_le16(b, addr) *(u16*)(addr) = _swapw(b)
+# define out_le32(b, addr) *(u32*)(addr) = _swapl(b)
+#elif defined(__XTENSA_EL__)
+# define in_8(addr)  (*(u8*)(addr))
+# define in_le16(addr) (*(u16*)(addr))
+# define in_le32(addr) (*(u32*)(addr))
+# define out_8(b, addr) *(u8*)(addr) = (b)
+# define out_le16(b, addr) *(u16*)(addr) = (b)
+# define out_le32(b, addr) *(u32*)(addr) = (b)
+#else
+# error processor byte order undefined!
+#endif
+
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem access
+ */
+#define xlate_dev_mem_ptr(p)    __va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)   p
+
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _XTENSA_IO_H */
