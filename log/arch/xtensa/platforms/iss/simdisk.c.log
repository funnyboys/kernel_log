commit 3d745ea5b095a3985129e162900b7e6c22518a9d
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Mar 27 09:30:11 2020 +0100

    block: simplify queue allocation
    
    Current make_request based drivers use either blk_alloc_queue_node or
    blk_alloc_queue to allocate a queue, and then set up the make_request_fn
    function pointer and a few parameters using the blk_queue_make_request
    helper.  Simplify this by passing the make_request pointer to
    blk_alloc_queue, and while at it merge the _node variant into the main
    helper by always passing a node_id, and remove the superfluous gfp_mask
    parameter.  A lower-level __blk_alloc_queue is kept for the blk-mq case.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 833109880165..49322b66cda9 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -267,13 +267,12 @@ static int __init simdisk_setup(struct simdisk *dev, int which,
 	spin_lock_init(&dev->lock);
 	dev->users = 0;
 
-	dev->queue = blk_alloc_queue(GFP_KERNEL);
+	dev->queue = blk_alloc_queue(simdisk_make_request, NUMA_NO_NODE);
 	if (dev->queue == NULL) {
 		pr_err("blk_alloc_queue failed\n");
 		goto out_alloc_queue;
 	}
 
-	blk_queue_make_request(dev->queue, simdisk_make_request);
 	dev->queue->queuedata = dev;
 
 	dev->gd = alloc_disk(SIMDISK_MINORS);

commit 97a32539b9568bb653683349e5a76d02ff3c3e2c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 3 17:37:17 2020 -0800

    proc: convert everything to "struct proc_ops"
    
    The most notable change is DEFINE_SHOW_ATTRIBUTE macro split in
    seq_file.h.
    
    Conversion rule is:
    
            llseek          => proc_lseek
            unlocked_ioctl  => proc_ioctl
    
            xxx             => proc_xxx
    
            delete ".owner = THIS_MODULE" line
    
    [akpm@linux-foundation.org: fix drivers/isdn/capi/kcapi_proc.c]
    [sfr@canb.auug.org.au: fix kernel/sched/psi.c]
      Link: http://lkml.kernel.org/r/20200122180545.36222f50@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20191225172546.GB13378@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index f9cd45860bee..833109880165 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -251,10 +251,10 @@ static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
 	return err;
 }
 
-static const struct file_operations fops = {
-	.read = proc_read_simdisk,
-	.write = proc_write_simdisk,
-	.llseek = default_llseek,
+static const struct proc_ops simdisk_proc_ops = {
+	.proc_read	= proc_read_simdisk,
+	.proc_write	= proc_write_simdisk,
+	.proc_lseek	= default_llseek,
 };
 
 static int __init simdisk_setup(struct simdisk *dev, int which,
@@ -290,7 +290,7 @@ static int __init simdisk_setup(struct simdisk *dev, int which,
 	set_capacity(dev->gd, 0);
 	add_disk(dev->gd);
 
-	dev->procfile = proc_create_data(tmp, 0644, procdir, &fops, dev);
+	dev->procfile = proc_create_data(tmp, 0644, procdir, &simdisk_proc_ops, dev);
 	return 0;
 
 out_alloc_disk:

commit fd58015ca9fed04fd52009e2dbcb7aef6940f734
Author: Chengguang Xu <cgxu519@gmail.com>
Date:   Sun May 5 22:26:07 2019 +0800

    xtensa: set proper error code for simdisk_setup()
    
    Change error code to -ENOMEM from -EIO because
    the error is related to memory allocating.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmail.com>
    Message-Id: <1557066367-4783-2-git-send-email-cgxu519@gmail.com>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 5fac8b781453..f9cd45860bee 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -297,7 +297,7 @@ static int __init simdisk_setup(struct simdisk *dev, int which,
 	blk_cleanup_queue(dev->queue);
 	dev->queue = NULL;
 out_alloc_queue:
-	return -EIO;
+	return -ENOMEM;
 }
 
 static int __init simdisk_init(void)

commit fb1b79d88b88370a8177aefcd446b1b3d323e4c8
Author: Chengguang Xu <cgxu519@gmail.com>
Date:   Sun May 5 22:26:06 2019 +0800

    xtensa: fix incorrect fd close in error case of simdisk_setup()
    
    dev->fd is opened in attach operation, so should not
    close dev->fd in error case of simdisk_setup().
    
    Signed-off-by: Chengguang Xu <cgxu519@gmail.com>
    Message-Id: <1557066367-4783-1-git-send-email-cgxu519@gmail.com>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 026211e7ab09..5fac8b781453 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -297,7 +297,6 @@ static int __init simdisk_setup(struct simdisk *dev, int which,
 	blk_cleanup_queue(dev->queue);
 	dev->queue = NULL;
 out_alloc_queue:
-	simc_close(dev->fd);
 	return -EIO;
 }
 

commit 233bde21aa43516baa013ef7ac33f3427056db3e
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Mar 14 15:48:06 2018 -0700

    block: Move SECTOR_SIZE and SECTOR_SHIFT definitions into <linux/blkdev.h>
    
    It happens often while I'm preparing a patch for a block driver that
    I'm wondering: is a definition of SECTOR_SIZE and/or SECTOR_SHIFT
    available for this driver? Do I have to introduce definitions of these
    constants before I can use these constants? To avoid this confusion,
    move the existing definitions of SECTOR_SIZE and SECTOR_SHIFT into the
    <linux/blkdev.h> header file such that these become available for all
    block drivers. Make the SECTOR_SIZE definition in the uapi msdos_fs.h
    header file conditional to avoid that including that header file after
    <linux/blkdev.h> causes the compiler to complain about a SECTOR_SIZE
    redefinition.
    
    Note: the SECTOR_SIZE / SECTOR_SHIFT / SECTOR_BITS definitions have
    not been removed from uapi header files nor from NAND drivers in
    which these constants are used for another purpose than converting
    block layer offsets and sizes into a number of sectors.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Nitin Gupta <ngupta@vflare.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 1b6418407467..026211e7ab09 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -21,7 +21,6 @@
 #include <platform/simcall.h>
 
 #define SIMDISK_MAJOR 240
-#define SECTOR_SHIFT 9
 #define SIMDISK_MINORS 1
 #define MAX_SIMDISK_COUNT 10
 

commit 0e78eccc552b6a9e9ce158aee72e95ae41e0e171
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 10 09:17:50 2017 +0100

    xtensa/simdisk: fix compile error
    
    Fixes: d004a5e7d4dd ("block: remove __bio_kmap_atomic")
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index eacf1e433518..1b6418407467 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -116,7 +116,7 @@ static blk_qc_t simdisk_make_request(struct request_queue *q, struct bio *bio)
 		simdisk_transfer(dev, sector, len, buffer,
 				bio_data_dir(bio) == WRITE);
 		sector += len;
-		kunmap_atomic(buffer)
+		kunmap_atomic(buffer);
 	}
 
 	bio_endio(bio);

commit d004a5e7d4dd6335ce6e2044af42f5e0fbebb51d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 8 19:13:48 2017 +0100

    block: remove __bio_kmap_atomic
    
    This helper doesn't buy us much over calling kmap_atomic directly.
    In fact in the only caller it does a bit of useless work as the
    caller already has the bvec at hand, and said caller would even
    buggy for a multi-segment bio due to the use of this helper.
    
    So just remove it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index c45b90bb9339..eacf1e433518 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -110,13 +110,13 @@ static blk_qc_t simdisk_make_request(struct request_queue *q, struct bio *bio)
 	sector_t sector = bio->bi_iter.bi_sector;
 
 	bio_for_each_segment(bvec, bio, iter) {
-		char *buffer = __bio_kmap_atomic(bio, iter);
+		char *buffer = kmap_atomic(bvec.bv_page) + bvec.bv_offset;
 		unsigned len = bvec.bv_len >> SECTOR_SHIFT;
 
 		simdisk_transfer(dev, sector, len, buffer,
 				bio_data_dir(bio) == WRITE);
 		sector += len;
-		__bio_kunmap_atomic(buffer);
+		kunmap_atomic(buffer)
 	}
 
 	bio_endio(bio);

commit 5e78e465abcba4a21e5cc52bef41aa4b3361957d
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 25 14:28:09 2016 +0200

    xtensa: ISS: Use kmalloc_array() in simdisk_init()
    
    * A multiplication for the size determination of a memory allocation
      indicated that an array data structure should be processed.
      Thus use the corresponding function "kmalloc_array".
    
      This issue was detected by using the Coccinelle software.
    
    * Replace the specification of a data type by a pointer dereference
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 02e94bb3ad3e..c45b90bb9339 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -317,8 +317,7 @@ static int __init simdisk_init(void)
 	if (simdisk_count > MAX_SIMDISK_COUNT)
 		simdisk_count = MAX_SIMDISK_COUNT;
 
-	sddev = kmalloc(simdisk_count * sizeof(struct simdisk),
-			GFP_KERNEL);
+	sddev = kmalloc_array(simdisk_count, sizeof(*sddev), GFP_KERNEL);
 	if (sddev == NULL)
 		goto out_unregister;
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index ede04cca30dd..02e94bb3ad3e 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -17,7 +17,7 @@
 #include <linux/blkdev.h>
 #include <linux/bio.h>
 #include <linux/proc_fs.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <platform/simcall.h>
 
 #define SIMDISK_MAJOR 240

commit 549409b4b584604f8eb225ebbb19be74204fe789
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Tue Sep 20 17:58:20 2016 -0700

    xtensa: ISS: allow simdisk to use high memory buffers
    
    ISS kernel by default has only low memory. But it may be configured to
    support high memory and started in a simulator with more than 128M of
    RAM. Simdisk driver in such configuration can get IO request with a
    high memory page. There may be no TLB entry for that page, only page
    table entry. However simulators don't do pagewalking, so such IO request
    will fail. Touch IO buffer in the buffer read/write loop so that a TLB
    entry is likely there when read or write simcall is invoked.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index f58a4e6472cb..ede04cca30dd 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -86,6 +86,7 @@ static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
 		unsigned long io;
 
 		simc_lseek(dev->fd, offset, SEEK_SET);
+		READ_ONCE(*buffer);
 		if (write)
 			io = simc_write(dev->fd, buffer, nbytes);
 		else

commit 16e5c1fc36040e592128a164499bc25eb138a80f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 24 00:06:05 2015 -0500

    convert a bunch of open-coded instances of memdup_user_nul()
    
    A _lot_ of ->write() instances were open-coding it; some are
    converted to memdup_user_nul(), a lot more remain...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 3c3ace2c46b6..f58a4e6472cb 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -227,16 +227,12 @@ static ssize_t proc_read_simdisk(struct file *file, char __user *buf,
 static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	char *tmp = kmalloc(count + 1, GFP_KERNEL);
+	char *tmp = memdup_user_nul(buf, count);
 	struct simdisk *dev = PDE_DATA(file_inode(file));
 	int err;
 
-	if (tmp == NULL)
-		return -ENOMEM;
-	if (copy_from_user(tmp, buf, count)) {
-		err = -EFAULT;
-		goto out_free;
-	}
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
 
 	err = simdisk_detach(dev);
 	if (err != 0)
@@ -244,8 +240,6 @@ static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
 
 	if (count > 0 && tmp[count - 1] == '\n')
 		tmp[count - 1] = 0;
-	else
-		tmp[count] = 0;
 
 	if (tmp[0])
 		err = simdisk_attach(dev, tmp);

commit dece16353ef47d8d33f5302bc158072a9d65e26f
Author: Jens Axboe <axboe@fb.com>
Date:   Thu Nov 5 10:41:16 2015 -0700

    block: change ->make_request_fn() and users to return a queue cookie
    
    No functional changes in this patch, but it prepares us for returning
    a more useful cookie related to the IO that was queued up.
    
    Signed-off-by: Jens Axboe <axboe@fb.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Keith Busch <keith.busch@intel.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index fa84ca990caa..3c3ace2c46b6 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -101,7 +101,7 @@ static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
 	spin_unlock(&dev->lock);
 }
 
-static void simdisk_make_request(struct request_queue *q, struct bio *bio)
+static blk_qc_t simdisk_make_request(struct request_queue *q, struct bio *bio)
 {
 	struct simdisk *dev = q->queuedata;
 	struct bio_vec bvec;
@@ -119,6 +119,7 @@ static void simdisk_make_request(struct request_queue *q, struct bio *bio)
 	}
 
 	bio_endio(bio);
+	return BLK_QC_T_NONE;
 }
 
 static int simdisk_open(struct block_device *bdev, fmode_t mode)

commit 4246a0b63bd8f56a1469b12eafeb875b1041a451
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 20 15:29:37 2015 +0200

    block: add a bi_error field to struct bio
    
    Currently we have two different ways to signal an I/O error on a BIO:
    
     (1) by clearing the BIO_UPTODATE flag
     (2) by returning a Linux errno value to the bi_end_io callback
    
    The first one has the drawback of only communicating a single possible
    error (-EIO), and the second one has the drawback of not beeing persistent
    when bios are queued up, and are not passed along from child to parent
    bio in the ever more popular chaining scenario.  Having both mechanisms
    available has the additional drawback of utterly confusing driver authors
    and introducing bugs where various I/O submitters only deal with one of
    them, and the others have to add boilerplate code to deal with both kinds
    of error returns.
    
    So add a new bi_error field to store an errno value directly in struct
    bio and remove the existing mechanisms to clean all this up.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 48eebacdf5fe..fa84ca990caa 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -101,8 +101,9 @@ static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
 	spin_unlock(&dev->lock);
 }
 
-static int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)
+static void simdisk_make_request(struct request_queue *q, struct bio *bio)
 {
+	struct simdisk *dev = q->queuedata;
 	struct bio_vec bvec;
 	struct bvec_iter iter;
 	sector_t sector = bio->bi_iter.bi_sector;
@@ -116,17 +117,10 @@ static int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)
 		sector += len;
 		__bio_kunmap_atomic(buffer);
 	}
-	return 0;
-}
 
-static void simdisk_make_request(struct request_queue *q, struct bio *bio)
-{
-	struct simdisk *dev = q->queuedata;
-	int status = simdisk_xfer_bio(dev, bio);
-	bio_endio(bio, status);
+	bio_endio(bio);
 }
 
-
 static int simdisk_open(struct block_device *bdev, fmode_t mode)
 {
 	struct simdisk *dev = bdev->bd_disk->private_data;

commit 675675ada486dde5bf9aa51665e90706bff11a35
Author: Jens Axboe <axboe@kernel.dk>
Date:   Wed Jan 29 08:37:32 2014 -0700

    xtensa: fixup simdisk driver to work with immutable bio_vecs
    
    Geert reported:
    
    arch/xtensa/platforms/iss/simdisk.c:108:23: error: 'struct bio' has no member named 'bi_sector'
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: incompatible types when assigning to type 'int' from type 'struct bvec_iter'
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:110:2: error: request for member 'bv_len' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_size' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_idx' in something not a structure or union
    arch/xtensa/platforms/iss/simdisk.c:111:18: error: request for member 'bi_bvec_done' in something not a structure or union
    make[2]: *** [arch/xtensa/platforms/iss/simdisk.o] Error 1
    
    Fixup the usage of bio_for_each_segment(). Also fix wrong use
    of __bio_kunmap_atomic() - it needs the mapped buffer passed in,
    not the originally mapped page.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 8c6e819cd8ed..48eebacdf5fe 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -103,18 +103,18 @@ static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
 
 static int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)
 {
-	int i;
-	struct bio_vec *bvec;
-	sector_t sector = bio->bi_sector;
+	struct bio_vec bvec;
+	struct bvec_iter iter;
+	sector_t sector = bio->bi_iter.bi_sector;
 
-	bio_for_each_segment(bvec, bio, i) {
-		char *buffer = __bio_kmap_atomic(bio, i);
-		unsigned len = bvec->bv_len >> SECTOR_SHIFT;
+	bio_for_each_segment(bvec, bio, iter) {
+		char *buffer = __bio_kmap_atomic(bio, iter);
+		unsigned len = bvec.bv_len >> SECTOR_SHIFT;
 
 		simdisk_transfer(dev, sector, len, buffer,
 				bio_data_dir(bio) == WRITE);
 		sector += len;
-		__bio_kunmap_atomic(bio);
+		__bio_kunmap_atomic(buffer);
 	}
 	return 0;
 }

commit 0eb5afb3bae69a18bb4a8dbcbd361c4403fb54cd
Author: Zhao Hongjiang <zhaohongjiang@huawei.com>
Date:   Mon Jul 8 15:22:50 2013 +0800

    xtensa: remove the second argument of __bio_kmap_atomic()
    
    kmap_atomic allows only one argument now, just remove the unused 'kmtype'.
    
    Signed-off-by: Zhao Hongjiang <zhaohongjiang@huawei.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index c0edb35424ce..8c6e819cd8ed 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -108,13 +108,13 @@ static int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)
 	sector_t sector = bio->bi_sector;
 
 	bio_for_each_segment(bvec, bio, i) {
-		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
+		char *buffer = __bio_kmap_atomic(bio, i);
 		unsigned len = bvec->bv_len >> SECTOR_SHIFT;
 
 		simdisk_transfer(dev, sector, len, buffer,
 				bio_data_dir(bio) == WRITE);
 		sector += len;
-		__bio_kunmap_atomic(bio, KM_USER0);
+		__bio_kunmap_atomic(bio);
 	}
 	return 0;
 }

commit c61c48dfe00907007df3b87e4ed271a5c143bdda
Merge: e30f41924569 b341d84c8ac5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 14:38:16 2013 -0700

    Merge tag 'xtensa-next-20130508' of git://github.com/czankel/xtensa-linux
    
    Pull xtensa updates from Chris Zankel:
     "Support for the latest MMU architecture that allows for a larger
      accessible memory region, and various bug-fixes"
    
    * tag 'xtensa-next-20130508' of git://github.com/czankel/xtensa-linux:
      xtensa: Switch to asm-generic/linkage.h
      xtensa: fix redboot load address
      xtensa: ISS: fix timer_lock usage in rs_open
      xtensa: disable IRQs while IRQ handler is running
      xtensa: enable lockdep support
      xtensa: fix arch_irqs_disabled_flags implementation
      xtensa: add irq flags trace support
      xtensa: provide custom CALLER_ADDR* implementations
      xtensa: add stacktrace support
      xtensa: clean up stpill_registers
      xtensa: don't use a7 in simcalls
      xtensa: don't attempt to use unconfigured timers
      xtensa: provide default platform_pcibios_init implementation
      xtensa: remove KCORE_ELF again
      xtensa: document MMUv3 setup sequence
      xtensa: add MMU v3 support
      xtensa: fix ibreakenable register update
      xtensa: fix oprofile building as module

commit 0757f6159f13dcd9fe499befd4be57c5ee8afde8
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu May 9 14:08:31 2013 +0200

    xtensa simdisk: Fix proc_create_data() conversion fallout
    
    arch/xtensa/platforms/iss/simdisk.c: In function 'proc_read_simdisk':
    arch/xtensa/platforms/iss/simdisk.c:220:12: warning: initialization discards 'const' qualifier from pointer target type [enabled by default]
    arch/xtensa/platforms/iss/simdisk.c: In function 'proc_write_simdisk':
    arch/xtensa/platforms/iss/simdisk.c:241:38: error: 'buffer' undeclared (first use in this function)
    arch/xtensa/platforms/iss/simdisk.c:241:38: note: each undeclared identifier is reported only once for each function it appears in
    
    Introduced by commit a69755b187749e7cc020e17127a54f395aea4eaa ("xtensa
    simdisk: switch to proc_create_data()")
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 0345f43d34f3..fc3c91fd20f7 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -217,7 +217,7 @@ static ssize_t proc_read_simdisk(struct file *file, char __user *buf,
 			size_t size, loff_t *ppos)
 {
 	struct simdisk *dev = PDE_DATA(file_inode(file));
-	char *s = dev->filename;
+	const char *s = dev->filename;
 	if (s) {
 		ssize_t n = simple_read_from_buffer(buf, size, ppos,
 							s, strlen(s));
@@ -238,7 +238,7 @@ static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
 
 	if (tmp == NULL)
 		return -ENOMEM;
-	if (copy_from_user(tmp, buffer, count)) {
+	if (copy_from_user(tmp, buf, count)) {
 		err = -EFAULT;
 		goto out_free;
 	}

commit f4b93ba93184c23f7a903cc790b573195fb41c37
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Apr 15 08:39:41 2013 +0400

    xtensa: don't use a7 in simcalls
    
    To support FRAME_POINTER avoid using a7 in __simc (none of the existing
    simcalls needs it). Replace calls to __simc with more specific
    simc_read, simc_write and simc_lseek calls.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index f58ffc3b68a8..74f86fbab742 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -85,7 +85,7 @@ static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
 	while (nbytes > 0) {
 		unsigned long io;
 
-		__simc(SYS_lseek, dev->fd, offset, SEEK_SET, 0, 0);
+		simc_lseek(dev->fd, offset, SEEK_SET);
 		if (write)
 			io = simc_write(dev->fd, buffer, nbytes);
 		else
@@ -177,7 +177,7 @@ static int simdisk_attach(struct simdisk *dev, const char *filename)
 		err = -ENODEV;
 		goto out;
 	}
-	dev->size = __simc(SYS_lseek, dev->fd, 0, SEEK_END, 0, 0);
+	dev->size = simc_lseek(dev->fd, 0, SEEK_END);
 	set_capacity(dev->gd, dev->size >> SECTOR_SHIFT);
 	dev->filename = filename;
 	pr_info("SIMDISK: %s=%s\n", dev->gd->disk_name, dev->filename);

commit db2a144bedd58b3dcf19950c2f476c58c9f39d18
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 5 21:52:57 2013 -0400

    block_device_operations->release() should return void
    
    The value passed is 0 in all but "it can never happen" cases (and those
    only in a couple of drivers) *and* it would've been lost on the way
    out anyway, even if something tried to pass something meaningful.
    Just don't bother.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 88608cc11b8c..0345f43d34f3 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -139,13 +139,12 @@ static int simdisk_open(struct block_device *bdev, fmode_t mode)
 	return 0;
 }
 
-static int simdisk_release(struct gendisk *disk, fmode_t mode)
+static void simdisk_release(struct gendisk *disk, fmode_t mode)
 {
 	struct simdisk *dev = disk->private_data;
 	spin_lock(&dev->lock);
 	--dev->users;
 	spin_unlock(&dev->lock);
-	return 0;
 }
 
 static const struct block_device_operations simdisk_ops = {

commit 4fe56e80825b47083100b2a98843df98fc7d4f07
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 4 16:00:50 2013 -0400

    xtensa simdisk: fix braino in "xtensa simdisk: switch to proc_create_data()"
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 4a06d70ddf5e..88608cc11b8c 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -231,7 +231,7 @@ static ssize_t proc_read_simdisk(struct file *file, char __user *buf,
 }
 
 static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
-			size_t size, loff_t *ppos)
+			size_t count, loff_t *ppos)
 {
 	char *tmp = kmalloc(count + 1, GFP_KERNEL);
 	struct simdisk *dev = PDE_DATA(file_inode(file));

commit d9dda78bad879595d8c4220a067fc029d6484a16
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 18:16:14 2013 -0400

    procfs: new helper - PDE_DATA(inode)
    
    The only part of proc_dir_entry the code outside of fs/proc
    really cares about is PDE(inode)->data.  Provide a helper
    for that; static inline for now, eventually will be moved
    to fs/proc, along with the knowledge of struct proc_dir_entry
    layout.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index 47ccef7839c9..4a06d70ddf5e 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -217,7 +217,7 @@ static int simdisk_detach(struct simdisk *dev)
 static ssize_t proc_read_simdisk(struct file *file, char __user *buf,
 			size_t size, loff_t *ppos)
 {
-	struct simdisk *dev = PDE(file_inode(file))->data;
+	struct simdisk *dev = PDE_DATA(file_inode(file));
 	char *s = dev->filename;
 	if (s) {
 		ssize_t n = simple_read_from_buffer(buf, size, ppos,
@@ -234,7 +234,7 @@ static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
 			size_t size, loff_t *ppos)
 {
 	char *tmp = kmalloc(count + 1, GFP_KERNEL);
-	struct simdisk *dev = PDE(file_inode(file))->data;
+	struct simdisk *dev = PDE_DATA(file_inode(file));
 	int err;
 
 	if (tmp == NULL)

commit a69755b187749e7cc020e17127a54f395aea4eaa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 15:18:19 2013 -0400

    xtensa simdisk: switch to proc_create_data()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
index f58ffc3b68a8..47ccef7839c9 100644
--- a/arch/xtensa/platforms/iss/simdisk.c
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -214,20 +214,27 @@ static int simdisk_detach(struct simdisk *dev)
 	return err;
 }
 
-static int proc_read_simdisk(char *page, char **start, off_t off,
-		int count, int *eof, void *data)
+static ssize_t proc_read_simdisk(struct file *file, char __user *buf,
+			size_t size, loff_t *ppos)
 {
-	int len;
-	struct simdisk *dev = (struct simdisk *) data;
-	len = sprintf(page, "%s\n", dev->filename ? dev->filename : "");
-	return len;
+	struct simdisk *dev = PDE(file_inode(file))->data;
+	char *s = dev->filename;
+	if (s) {
+		ssize_t n = simple_read_from_buffer(buf, size, ppos,
+							s, strlen(s));
+		if (n < 0)
+			return n;
+		buf += n;
+		size -= n;
+	}
+	return simple_read_from_buffer(buf, size, ppos, "\n", 1);
 }
 
-static int proc_write_simdisk(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+static ssize_t proc_write_simdisk(struct file *file, const char __user *buf,
+			size_t size, loff_t *ppos)
 {
 	char *tmp = kmalloc(count + 1, GFP_KERNEL);
-	struct simdisk *dev = (struct simdisk *) data;
+	struct simdisk *dev = PDE(file_inode(file))->data;
 	int err;
 
 	if (tmp == NULL)
@@ -256,6 +263,12 @@ static int proc_write_simdisk(struct file *file, const char *buffer,
 	return err;
 }
 
+static const struct file_operations fops = {
+	.read = proc_read_simdisk,
+	.write = proc_write_simdisk,
+	.llseek = default_llseek,
+};
+
 static int __init simdisk_setup(struct simdisk *dev, int which,
 		struct proc_dir_entry *procdir)
 {
@@ -289,10 +302,7 @@ static int __init simdisk_setup(struct simdisk *dev, int which,
 	set_capacity(dev->gd, 0);
 	add_disk(dev->gd);
 
-	dev->procfile = create_proc_entry(tmp, 0644, procdir);
-	dev->procfile->data = dev;
-	dev->procfile->read_proc = proc_read_simdisk;
-	dev->procfile->write_proc = proc_write_simdisk;
+	dev->procfile = proc_create_data(tmp, 0644, procdir, &fops, dev);
 	return 0;
 
 out_alloc_disk:

commit b6c7e873daf765e41233b9752083b66442703b7a
Author: Victor Prupis <vnp@vnp_fc3.hq.tensilica.com>
Date:   Mon May 19 14:50:38 2008 -0700

    xtensa: ISS: add host file-based simulated disk
    
    Simdisk is a block device that maps to a file in the host file system.
    It is usable for testing in the simulated environment, like xt-sim or
    QEMU. Device binding to host file may be changed at runtime via proc
    interface provided the device is not in use. Number of block devices
    and initial binding to host files is controlled via kernel/module
    parameters, with defaults specified in the kernel configuration.
    
    Signed-off-by: Victor Prupis <vnp@tensilica.com>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/arch/xtensa/platforms/iss/simdisk.c b/arch/xtensa/platforms/iss/simdisk.c
new file mode 100644
index 000000000000..f58ffc3b68a8
--- /dev/null
+++ b/arch/xtensa/platforms/iss/simdisk.c
@@ -0,0 +1,375 @@
+/*
+ * arch/xtensa/platforms/iss/simdisk.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001-2013 Tensilica Inc.
+ *   Authors	Victor Prupis
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <platform/simcall.h>
+
+#define SIMDISK_MAJOR 240
+#define SECTOR_SHIFT 9
+#define SIMDISK_MINORS 1
+#define MAX_SIMDISK_COUNT 10
+
+struct simdisk {
+	const char *filename;
+	spinlock_t lock;
+	struct request_queue *queue;
+	struct gendisk *gd;
+	struct proc_dir_entry *procfile;
+	int users;
+	unsigned long size;
+	int fd;
+};
+
+
+static int simdisk_count = CONFIG_BLK_DEV_SIMDISK_COUNT;
+module_param(simdisk_count, int, S_IRUGO);
+MODULE_PARM_DESC(simdisk_count, "Number of simdisk units.");
+
+static int n_files;
+static const char *filename[MAX_SIMDISK_COUNT] = {
+#ifdef CONFIG_SIMDISK0_FILENAME
+	CONFIG_SIMDISK0_FILENAME,
+#ifdef CONFIG_SIMDISK1_FILENAME
+	CONFIG_SIMDISK1_FILENAME,
+#endif
+#endif
+};
+
+static int simdisk_param_set_filename(const char *val,
+		const struct kernel_param *kp)
+{
+	if (n_files < ARRAY_SIZE(filename))
+		filename[n_files++] = val;
+	else
+		return -EINVAL;
+	return 0;
+}
+
+static const struct kernel_param_ops simdisk_param_ops_filename = {
+	.set = simdisk_param_set_filename,
+};
+module_param_cb(filename, &simdisk_param_ops_filename, &n_files, 0);
+MODULE_PARM_DESC(filename, "Backing storage filename.");
+
+static int simdisk_major = SIMDISK_MAJOR;
+
+static void simdisk_transfer(struct simdisk *dev, unsigned long sector,
+		unsigned long nsect, char *buffer, int write)
+{
+	unsigned long offset = sector << SECTOR_SHIFT;
+	unsigned long nbytes = nsect << SECTOR_SHIFT;
+
+	if (offset > dev->size || dev->size - offset < nbytes) {
+		pr_notice("Beyond-end %s (%ld %ld)\n",
+				write ? "write" : "read", offset, nbytes);
+		return;
+	}
+
+	spin_lock(&dev->lock);
+	while (nbytes > 0) {
+		unsigned long io;
+
+		__simc(SYS_lseek, dev->fd, offset, SEEK_SET, 0, 0);
+		if (write)
+			io = simc_write(dev->fd, buffer, nbytes);
+		else
+			io = simc_read(dev->fd, buffer, nbytes);
+		if (io == -1) {
+			pr_err("SIMDISK: IO error %d\n", errno);
+			break;
+		}
+		buffer += io;
+		offset += io;
+		nbytes -= io;
+	}
+	spin_unlock(&dev->lock);
+}
+
+static int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)
+{
+	int i;
+	struct bio_vec *bvec;
+	sector_t sector = bio->bi_sector;
+
+	bio_for_each_segment(bvec, bio, i) {
+		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
+		unsigned len = bvec->bv_len >> SECTOR_SHIFT;
+
+		simdisk_transfer(dev, sector, len, buffer,
+				bio_data_dir(bio) == WRITE);
+		sector += len;
+		__bio_kunmap_atomic(bio, KM_USER0);
+	}
+	return 0;
+}
+
+static void simdisk_make_request(struct request_queue *q, struct bio *bio)
+{
+	struct simdisk *dev = q->queuedata;
+	int status = simdisk_xfer_bio(dev, bio);
+	bio_endio(bio, status);
+}
+
+
+static int simdisk_open(struct block_device *bdev, fmode_t mode)
+{
+	struct simdisk *dev = bdev->bd_disk->private_data;
+
+	spin_lock(&dev->lock);
+	if (!dev->users)
+		check_disk_change(bdev);
+	++dev->users;
+	spin_unlock(&dev->lock);
+	return 0;
+}
+
+static int simdisk_release(struct gendisk *disk, fmode_t mode)
+{
+	struct simdisk *dev = disk->private_data;
+	spin_lock(&dev->lock);
+	--dev->users;
+	spin_unlock(&dev->lock);
+	return 0;
+}
+
+static const struct block_device_operations simdisk_ops = {
+	.owner		= THIS_MODULE,
+	.open		= simdisk_open,
+	.release	= simdisk_release,
+};
+
+static struct simdisk *sddev;
+static struct proc_dir_entry *simdisk_procdir;
+
+static int simdisk_attach(struct simdisk *dev, const char *filename)
+{
+	int err = 0;
+
+	filename = kstrdup(filename, GFP_KERNEL);
+	if (filename == NULL)
+		return -ENOMEM;
+
+	spin_lock(&dev->lock);
+
+	if (dev->fd != -1) {
+		err = -EBUSY;
+		goto out;
+	}
+	dev->fd = simc_open(filename, O_RDWR, 0);
+	if (dev->fd == -1) {
+		pr_err("SIMDISK: Can't open %s: %d\n", filename, errno);
+		err = -ENODEV;
+		goto out;
+	}
+	dev->size = __simc(SYS_lseek, dev->fd, 0, SEEK_END, 0, 0);
+	set_capacity(dev->gd, dev->size >> SECTOR_SHIFT);
+	dev->filename = filename;
+	pr_info("SIMDISK: %s=%s\n", dev->gd->disk_name, dev->filename);
+out:
+	if (err)
+		kfree(filename);
+	spin_unlock(&dev->lock);
+
+	return err;
+}
+
+static int simdisk_detach(struct simdisk *dev)
+{
+	int err = 0;
+
+	spin_lock(&dev->lock);
+
+	if (dev->users != 0) {
+		err = -EBUSY;
+	} else if (dev->fd != -1) {
+		if (simc_close(dev->fd)) {
+			pr_err("SIMDISK: error closing %s: %d\n",
+					dev->filename, errno);
+			err = -EIO;
+		} else {
+			pr_info("SIMDISK: %s detached from %s\n",
+					dev->gd->disk_name, dev->filename);
+			dev->fd = -1;
+			kfree(dev->filename);
+			dev->filename = NULL;
+		}
+	}
+	spin_unlock(&dev->lock);
+	return err;
+}
+
+static int proc_read_simdisk(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len;
+	struct simdisk *dev = (struct simdisk *) data;
+	len = sprintf(page, "%s\n", dev->filename ? dev->filename : "");
+	return len;
+}
+
+static int proc_write_simdisk(struct file *file, const char *buffer,
+		unsigned long count, void *data)
+{
+	char *tmp = kmalloc(count + 1, GFP_KERNEL);
+	struct simdisk *dev = (struct simdisk *) data;
+	int err;
+
+	if (tmp == NULL)
+		return -ENOMEM;
+	if (copy_from_user(tmp, buffer, count)) {
+		err = -EFAULT;
+		goto out_free;
+	}
+
+	err = simdisk_detach(dev);
+	if (err != 0)
+		goto out_free;
+
+	if (count > 0 && tmp[count - 1] == '\n')
+		tmp[count - 1] = 0;
+	else
+		tmp[count] = 0;
+
+	if (tmp[0])
+		err = simdisk_attach(dev, tmp);
+
+	if (err == 0)
+		err = count;
+out_free:
+	kfree(tmp);
+	return err;
+}
+
+static int __init simdisk_setup(struct simdisk *dev, int which,
+		struct proc_dir_entry *procdir)
+{
+	char tmp[2] = { '0' + which, 0 };
+
+	dev->fd = -1;
+	dev->filename = NULL;
+	spin_lock_init(&dev->lock);
+	dev->users = 0;
+
+	dev->queue = blk_alloc_queue(GFP_KERNEL);
+	if (dev->queue == NULL) {
+		pr_err("blk_alloc_queue failed\n");
+		goto out_alloc_queue;
+	}
+
+	blk_queue_make_request(dev->queue, simdisk_make_request);
+	dev->queue->queuedata = dev;
+
+	dev->gd = alloc_disk(SIMDISK_MINORS);
+	if (dev->gd == NULL) {
+		pr_err("alloc_disk failed\n");
+		goto out_alloc_disk;
+	}
+	dev->gd->major = simdisk_major;
+	dev->gd->first_minor = which;
+	dev->gd->fops = &simdisk_ops;
+	dev->gd->queue = dev->queue;
+	dev->gd->private_data = dev;
+	snprintf(dev->gd->disk_name, 32, "simdisk%d", which);
+	set_capacity(dev->gd, 0);
+	add_disk(dev->gd);
+
+	dev->procfile = create_proc_entry(tmp, 0644, procdir);
+	dev->procfile->data = dev;
+	dev->procfile->read_proc = proc_read_simdisk;
+	dev->procfile->write_proc = proc_write_simdisk;
+	return 0;
+
+out_alloc_disk:
+	blk_cleanup_queue(dev->queue);
+	dev->queue = NULL;
+out_alloc_queue:
+	simc_close(dev->fd);
+	return -EIO;
+}
+
+static int __init simdisk_init(void)
+{
+	int i;
+
+	if (register_blkdev(simdisk_major, "simdisk") < 0) {
+		pr_err("SIMDISK: register_blkdev: %d\n", simdisk_major);
+		return -EIO;
+	}
+	pr_info("SIMDISK: major: %d\n", simdisk_major);
+
+	if (n_files > simdisk_count)
+		simdisk_count = n_files;
+	if (simdisk_count > MAX_SIMDISK_COUNT)
+		simdisk_count = MAX_SIMDISK_COUNT;
+
+	sddev = kmalloc(simdisk_count * sizeof(struct simdisk),
+			GFP_KERNEL);
+	if (sddev == NULL)
+		goto out_unregister;
+
+	simdisk_procdir = proc_mkdir("simdisk", 0);
+	if (simdisk_procdir == NULL)
+		goto out_free_unregister;
+
+	for (i = 0; i < simdisk_count; ++i) {
+		if (simdisk_setup(sddev + i, i, simdisk_procdir) == 0) {
+			if (filename[i] != NULL && filename[i][0] != 0 &&
+					(n_files == 0 || i < n_files))
+				simdisk_attach(sddev + i, filename[i]);
+		}
+	}
+
+	return 0;
+
+out_free_unregister:
+	kfree(sddev);
+out_unregister:
+	unregister_blkdev(simdisk_major, "simdisk");
+	return -ENOMEM;
+}
+module_init(simdisk_init);
+
+static void simdisk_teardown(struct simdisk *dev, int which,
+		struct proc_dir_entry *procdir)
+{
+	char tmp[2] = { '0' + which, 0 };
+
+	simdisk_detach(dev);
+	if (dev->gd)
+		del_gendisk(dev->gd);
+	if (dev->queue)
+		blk_cleanup_queue(dev->queue);
+	remove_proc_entry(tmp, procdir);
+}
+
+static void __exit simdisk_exit(void)
+{
+	int i;
+
+	for (i = 0; i < simdisk_count; ++i)
+		simdisk_teardown(sddev + i, i, simdisk_procdir);
+	remove_proc_entry("simdisk", 0);
+	kfree(sddev);
+	unregister_blkdev(simdisk_major, "simdisk");
+}
+module_exit(simdisk_exit);
+
+MODULE_ALIAS_BLOCKDEV_MAJOR(SIMDISK_MAJOR);
+
+MODULE_LICENSE("GPL");
