commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index e9d6824ae94d..8ef35131f999 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Port on Texas Instruments TMS320C6x architecture
  *
  *  Copyright (C) 2004, 2006, 2009, 2010, 2011 Texas Instruments Incorporated
  *  Author: Aurelien Jacquiot (aurelien.jacquiot@jaluna.com)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
  */
 #include <linux/dma-mapping.h>
 #include <linux/memblock.h>

commit adb6b2b2b59f7872322f255206583b4c3ce661a3
Merge: 9b5cf826ef8b 4d8106f0299c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 31 15:39:25 2018 -0700

    Merge tag 'for-linus' of git://linux-c6x.org/git/projects/linux-c6x-upstreaming
    
    Pull c6x update from Mark Salter.
    
    * tag 'for-linus' of git://linux-c6x.org/git/projects/linux-c6x-upstreaming:
      c6x: switch to NO_BOOTMEM

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 05d96a9541b5..2e1c0ea22eb0 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -11,7 +11,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/memblock.h>
 #include <linux/seq_file.h>
-#include <linux/bootmem.h>
 #include <linux/clkdev.h>
 #include <linux/initrd.h>
 #include <linux/kernel.h>

commit 4d8106f0299c7942c5f13a22da6d553d28127ef5
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Mon Jun 25 12:02:34 2018 +0300

    c6x: switch to NO_BOOTMEM
    
    The c6x is already using memblock and does most of early memory
    reservations with it, so it was only a matter of removing the bootmem
    initialization and handover of the memory from memblock to bootmem.
    
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 05d96a9541b5..2cfca640acfe 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -291,7 +291,6 @@ notrace void __init machine_init(unsigned long dt_ptr)
 
 void __init setup_arch(char **cmdline_p)
 {
-	int bootmap_size;
 	struct memblock_region *reg;
 
 	printk(KERN_INFO "Initializing kernel\n");
@@ -348,16 +347,6 @@ void __init setup_arch(char **cmdline_p)
 	init_mm.end_data   = memory_start;
 	init_mm.brk        = memory_start;
 
-	/*
-	 * Give all the memory to the bootmap allocator,  tell it to put the
-	 * boot mem_map at the start of memory
-	 */
-	bootmap_size = init_bootmem_node(NODE_DATA(0),
-					 memory_start >> PAGE_SHIFT,
-					 PAGE_OFFSET >> PAGE_SHIFT,
-					 memory_end >> PAGE_SHIFT);
-	memblock_reserve(memory_start, bootmap_size);
-
 	unflatten_and_copy_device_tree();
 
 	c6x_cache_init();
@@ -392,22 +381,9 @@ void __init setup_arch(char **cmdline_p)
 	/* Initialize the coherent memory allocator */
 	coherent_mem_init(dma_start, dma_size);
 
-	/*
-	 * Free all memory as a starting point.
-	 */
-	free_bootmem(PAGE_OFFSET, memory_end - PAGE_OFFSET);
-
-	/*
-	 * Then reserve memory which is already being used.
-	 */
-	for_each_memblock(reserved, reg) {
-		pr_debug("reserved - 0x%08x-0x%08x\n",
-			 (u32) reg->base, (u32) reg->size);
-		reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
-	}
-
 	max_low_pfn = PFN_DOWN(memory_end);
 	min_low_pfn = PFN_UP(memory_start);
+	max_pfn = max_low_pfn;
 	max_mapnr = max_low_pfn - min_low_pfn;
 
 	/* Get kmalloc into gear */

commit 4355151de47c2b4bc72c026ee743bd9ed7f71ba3
Merge: 5d5a0ab1a791 92f687f40ee5
Author: Rob Herring <robh@kernel.org>
Date:   Thu Oct 4 14:16:15 2018 -0500

    Merge branch 'all-dtbs' into dt/next

commit be7cd2df1d22d29e5f23ce8744fc465cc07cc2bc
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 1 15:00:12 2018 -0600

    c6x: use common built-in dtb support
    
    Using the common build support for built-in dtb files just requires
    adding a .dtb.o target to obj-y.
    
    The dtb now needs to be copied when unflattened because an init section
    is used now.
    
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <jacquiot.aurelien@gmail.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 786e36e2f61d..509c5f086496 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -270,7 +270,7 @@ int __init c6x_add_memory(phys_addr_t start, unsigned long size)
 notrace void __init machine_init(unsigned long dt_ptr)
 {
 	void *dtb = __va(dt_ptr);
-	void *fdt = _fdt_start;
+	void *fdt = __dtb_start;
 
 	/* interrupts must be masked */
 	set_creg(IER, 2);
@@ -363,7 +363,7 @@ void __init setup_arch(char **cmdline_p)
 					 memory_end >> PAGE_SHIFT);
 	memblock_reserve(memory_start, bootmap_size);
 
-	unflatten_device_tree();
+	unflatten_and_copy_device_tree();
 
 	c6x_cache_init();
 

commit 5a931a3c80b5fb0ad0004f016410a75ca1205959
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 07:53:30 2018 -0500

    c6x: use for_each_of_cpu_node iterator
    
    Use the for_each_of_cpu_node iterator to iterate over cpu nodes. This
    has the side effect of defaulting to iterating using "cpu" node names
    in preference to the deprecated (for FDT) device_type == "cpu".
    
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <jacquiot.aurelien@gmail.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 786e36e2f61d..2e97455ca0b7 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -96,7 +96,7 @@ static void __init get_cpuinfo(void)
 	unsigned long core_khz;
 	u64 tmp;
 	struct cpuinfo_c6x *p;
-	struct device_node *node, *np;
+	struct device_node *node;
 
 	p = &per_cpu(cpu_data, smp_processor_id());
 
@@ -190,13 +190,8 @@ static void __init get_cpuinfo(void)
 
 	p->core_id = get_coreid();
 
-	node = of_find_node_by_name(NULL, "cpus");
-	if (node) {
-		for_each_child_of_node(node, np)
-			if (!strcmp("cpu", np->name))
-				++c6x_num_cores;
-		of_node_put(node);
-	}
+	for_each_of_cpu_node(node)
+		++c6x_num_cores;
 
 	node = of_find_node_by_name(NULL, "soc");
 	if (node) {

commit 06bea3dbfe6a4c333c4333362c46bdf4d9e43504
Author: Andrey Ryabinin <aryabinin@virtuozzo.com>
Date:   Thu Feb 4 11:29:36 2016 -0800

    locking/lockdep: Eliminate lockdep_init()
    
    Lockdep is initialized at compile time now.  Get rid of lockdep_init().
    
    Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Krinkin <krinkin.m.u@gmail.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Cc: mm-commits@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 72e17f7ebd6f..786e36e2f61d 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -281,8 +281,6 @@ notrace void __init machine_init(unsigned long dt_ptr)
 	 */
 	set_ist(_vectors_start);
 
-	lockdep_init();
-
 	/*
 	 * dtb is passed in from bootloader.
 	 * fdt is linked in blob.

commit 2135115c938dcaba689a3780c0bffb6db1d05601
Author: Chen Gang <xili_gchen_5257@hotmail.com>
Date:   Wed Mar 4 14:44:54 2015 +0800

    c6x: kernel: setup: Export symbol memory_end
    
    It is needed by several modules, the related error with allmodconfig:
    
        MODPOST 3327 modules
      ERROR: "memory_end" [net/wireless/lib80211_crypt_tkip.ko] undefined!
      ERROR: "memory_end" [net/sunrpc/sunrpc.ko] undefined!
      ERROR: "memory_end" [net/sunrpc/auth_gss/rpcsec_gss_krb5.ko] undefined!
      ERROR: "memory_end" [net/rxrpc/rxkad.ko] undefined!
      ERROR: "memory_end" [net/mac802154/mac802154.ko] undefined!
      ERROR: "memory_end" [net/mac80211/mac80211.ko] undefined!
      ERROR: "memory_end" [net/ipv6/esp6.ko] undefined!
      ERROR: "memory_end" [net/ipv6/ah6.ko] undefined!
      ERROR: "memory_end" [net/ipv4/esp4.ko] undefined!
      ERROR: "memory_end" [net/ipv4/ah4.ko] undefined!
      ERROR: "memory_end" [net/ceph/libceph.ko] undefined!
      ERROR: "memory_end" [net/9p/9pnet_virtio.ko] undefined!
      ERROR: "memory_end" [drivers/usb/wusbcore/wusbcore.ko] undefined!
      ERROR: "memory_end" [drivers/usb/misc/usbtest.ko] undefined!
      ERROR: "memory_end" [drivers/usb/core/usbcore.ko] undefined!
      ERROR: "memory_end" [drivers/target/target_core_file.ko] undefined!
      ERROR: "memory_end" [drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko] undefined!
      ERROR: "memory_end" [drivers/net/wireless/ath/ath6kl/ath6kl_sdio.ko] undefined!
      ERROR: "memory_end" [drivers/net/virtio_net.ko] undefined!
      ERROR: "memory_end" [drivers/net/usb/usbnet.ko] undefined!
      ERROR: "memory_end" [drivers/net/ppp/ppp_mppe.ko] undefined!
      ERROR: "memory_end" [drivers/mtd/nand/nand.ko] undefined!
      ERROR: "memory_end" [drivers/mmc/card/mmc_block.ko] undefined!
      ERROR: "memory_end" [drivers/crypto/qce/qcrypto.ko] undefined!
      ERROR: "memory_end" [drivers/block/drbd/drbd.ko] undefined!
      ERROR: "memory_end" [drivers/block/aoe/aoe.ko] undefined!
      ERROR: "memory_end" [crypto/tcrypt.ko] undefined!
      ERROR: "memory_end" [crypto/gcm.ko] undefined!
      ERROR: "memory_end" [crypto/cts.ko] undefined!
      ERROR: "memory_end" [crypto/ccm.ko] undefined!
      ERROR: "memory_end" [crypto/authencesn.ko] undefined!
      ERROR: "memory_end" [crypto/authenc.ko] undefined!
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 165bbd9ef006..72e17f7ebd6f 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -63,6 +63,7 @@ unsigned char c6x_fuse_mac[6];
 
 unsigned long memory_start;
 unsigned long memory_end;
+EXPORT_SYMBOL(memory_end);
 
 unsigned long ram_start;
 unsigned long ram_end;

commit d0f73520b3782a5447e9602f181daba6671e5cc7
Author: Chen Gang <xili_gchen_5257@hotmail.com>
Date:   Wed Mar 4 14:12:52 2015 +0800

    c6x: kernel: setup: Add screen_info global variable
    
    Or can not pass building with allmodconfig:
    
        LD      init/built-in.o
      drivers/built-in.o: In function `vgacon_switch':
      vgacon.c:(.text+0x47f8): undefined reference to `screen_info'
      vgacon.c:(.text+0x4810): undefined reference to `screen_info'
      drivers/built-in.o: In function `vgacon_resize':
      vgacon.c:(.text+0x4ac8): undefined reference to `screen_info'
      vgacon.c:(.text+0x4acc): undefined reference to `screen_info'
      drivers/built-in.o: In function `vgacon_save_screen':
      vgacon.c:(.text+0x4cc8): undefined reference to `screen_info'
      drivers/built-in.o:vgacon.c:(.text+0x4cd0): more undefined references to `screen_info' follow
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 1d9f39920a67..165bbd9ef006 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -27,6 +27,7 @@
 #include <linux/fs.h>
 #include <linux/of.h>
 #include <linux/console.h>
+#include <linux/screen_info.h>
 
 #include <asm/sections.h>
 #include <asm/div64.h>
@@ -38,6 +39,8 @@
 
 static const char *c6x_soc_name;
 
+struct screen_info screen_info;
+
 int c6x_num_cores;
 EXPORT_SYMBOL_GPL(c6x_num_cores);
 

commit 1a394e1a36aa9f47b411a8e4cb53dfca6f134401
Author: Chen Gang <xili_gchen_5257@hotmail.com>
Date:   Wed Mar 4 04:55:06 2015 +0800

    c6x: kernel: setup: Remove 'const' for local variables in machine_init
    
    early_init_dt_scan() accepts "void *", the related warning:
    
        CC      arch/c6x/kernel/setup.o
      arch/c6x/kernel/setup.c: In function 'machine_init':
      arch/c6x/kernel/setup.c:290:21: warning: passing argument 1 of 'early_init_dt_scan' discards 'const' qualifier from pointer target type [-Wdiscarded-qualifiers]
        early_init_dt_scan(fdt);
                           ^
      In file included from arch/c6x/kernel/setup.c:19:0:
      include/linux/of_fdt.h:75:13: note: expected 'void *' but argument is of type 'const void *'
       extern bool early_init_dt_scan(void *params);
                   ^
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index f016128ece13..1d9f39920a67 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -265,8 +265,8 @@ int __init c6x_add_memory(phys_addr_t start, unsigned long size)
  */
 notrace void __init machine_init(unsigned long dt_ptr)
 {
-	const void *dtb = __va(dt_ptr);
-	const void *fdt = _fdt_start;
+	void *dtb = __va(dt_ptr);
+	void *fdt = _fdt_start;
 
 	/* interrupts must be masked */
 	set_creg(IER, 2);

commit 3591276d16f8e568449e4b6c719165ad2decf222
Author: Chen Gang <gang.chen.5i5j@gmail.com>
Date:   Tue Mar 3 11:33:15 2015 -0500

    c6x: kernel: setup: Include "linux/console.h"
    
    Or c6x will cause building break for allmodconfig, the related error:
    
        CC      arch/c6x/kernel/setup.o
      arch/c6x/kernel/setup.c: In function 'setup_arch':
      arch/c6x/kernel/setup.c:433:2: error: 'conswitchp' undeclared (first use in this function)
        conswitchp = &dummy_con;
        ^
      arch/c6x/kernel/setup.c:433:2: note: each undeclared identifier is reported only once for each function it appears in
      arch/c6x/kernel/setup.c:433:16: error: 'dummy_con' undeclared (first use in this function)
        conswitchp = &dummy_con;
                      ^
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    [removed unnecessary #ifdef around include]
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 757128868d43..f016128ece13 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -26,7 +26,7 @@
 #include <linux/cpu.h>
 #include <linux/fs.h>
 #include <linux/of.h>
-
+#include <linux/console.h>
 
 #include <asm/sections.h>
 #include <asm/div64.h>

commit 01984a6f99cf1463a89592eff6e57af898743022
Author: Rob Herring <robh@kernel.org>
Date:   Mon Mar 31 15:09:34 2014 -0500

    c6x: convert fdt pointers to opaque pointers
    
    The architecture code does not need to access the internals of the FDT
    blob, so make the pointer to it void *.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Tested-by: Grant Likely <grant.likely@linaro.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 731db4b9014d..757128868d43 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -265,8 +265,8 @@ int __init c6x_add_memory(phys_addr_t start, unsigned long size)
  */
 notrace void __init machine_init(unsigned long dt_ptr)
 {
-	struct boot_param_header *dtb = __va(dt_ptr);
-	struct boot_param_header *fdt = (struct boot_param_header *)_fdt_start;
+	const void *dtb = __va(dt_ptr);
+	const void *fdt = _fdt_start;
 
 	/* interrupts must be masked */
 	set_creg(IER, 2);

commit a8e44636c66d90d177fcdf8e8cfc36747074a4ed
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Aug 26 10:18:20 2013 -0500

    c6x: use early_init_dt_scan
    
    Convert c6x to use new early_init_dt_scan function.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: linux-c6x-dev@linux-c6x.org

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 0e5a812907d9..731db4b9014d 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -287,7 +287,7 @@ notrace void __init machine_init(unsigned long dt_ptr)
 		fdt = dtb;
 
 	/* Do some early initialization based on the flat device tree */
-	early_init_devtree(fdt);
+	early_init_dt_scan(fdt);
 
 	parse_early_param();
 }

commit 312717f15ac7095c3ea98d487276781535ca7c0b
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sun Aug 25 18:29:51 2013 -0500

    c6x: use boot_command_line instead of private c6x_command_line
    
    Save some pointless copying of the kernel command line and just use
    boot_command_line instead.
    
    Also remove default_command_line as it is not referenced anywhere, and
    the DT code already handles the default command line.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Tested-by: Mark Salter <msalter@redhat.com>
    Acked-by: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Reviewed-by: Grant Likely <grant.likely@linaro.org>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index f4e72bd8c103..0e5a812907d9 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -68,13 +68,6 @@ unsigned long ram_end;
 static unsigned long dma_start __initdata;
 static unsigned long dma_size __initdata;
 
-char c6x_command_line[COMMAND_LINE_SIZE];
-
-#if defined(CONFIG_CMDLINE_BOOL)
-static const char default_command_line[COMMAND_LINE_SIZE] __section(.cmdline) =
-	CONFIG_CMDLINE;
-#endif
-
 struct cpuinfo_c6x {
 	const char *cpu_name;
 	const char *cpu_voltage;
@@ -296,8 +289,6 @@ notrace void __init machine_init(unsigned long dt_ptr)
 	/* Do some early initialization based on the flat device tree */
 	early_init_devtree(fdt);
 
-	/* parse_early_param needs a boot_command_line */
-	strlcpy(boot_command_line, c6x_command_line, COMMAND_LINE_SIZE);
 	parse_early_param();
 }
 
@@ -309,7 +300,7 @@ void __init setup_arch(char **cmdline_p)
 	printk(KERN_INFO "Initializing kernel\n");
 
 	/* Initialize command line */
-	*cmdline_p = c6x_command_line;
+	*cmdline_p = boot_command_line;
 
 	memory_end = ram_end;
 	memory_end &= ~(PAGE_SIZE - 1);

commit dbe91a2e6e53aa85efa0aac86e3a22ba95f8b85f
Author: Ken Cox <jkc@redhat.com>
Date:   Wed Jul 18 23:19:10 2012 -0400

    C6X: add basic support for TMS320C6678 SoC
    
    This patch adds support for the TMS320C6678 SoC on an EVMC6678LE
    evaluation board. The 6678 is a C66x family CPU which is very similar
    to the already supported C64x CPUs with the addition of floating point
    instructions.
    
    Signed-off-by: Ken Cox <jkc@redhat.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>
    CC: Aurelien Jacquiot <a-jacquiot@ti.com>
    CC: linux-c6x-dev@linux-c6x.org

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index ce46186600c5..f4e72bd8c103 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -143,6 +143,10 @@ static void __init get_cpuinfo(void)
 		p->cpu_name = "C64x+";
 		p->cpu_voltage = "1.2";
 		break;
+	case 21:
+		p->cpu_name = "C66X";
+		p->cpu_voltage = "1.2";
+		break;
 	default:
 		p->cpu_name = "unknown";
 		break;

commit 6a846f3f821a252762897751fa0aeb68dda635f5
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for C6X
    
    Disintegrate asm/system.h for C6X.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>
    cc: linux-c6x-dev@linux-c6x.org

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 0c07921747f4..ce46186600c5 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -34,6 +34,7 @@
 #include <asm/dscr.h>
 #include <asm/clock.h>
 #include <asm/soc.h>
+#include <asm/special_insns.h>
 
 static const char *c6x_soc_name;
 

commit 7123a6cab02ebc5dca61d0e341267578b245f2f3
Author: Mark Salter <msalter@redhat.com>
Date:   Sun Jan 8 13:19:38 2012 -0500

    C6X: add register_cpu call
    
    Commit ccbc60d3e19a1b6ae66ca0d89b3da02dde62088b requires CPU
    topology information even in !SMP cases. This requires C6X to
    add a call tp register_cpu() in order to avoid a panic at
    boot time.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index c126f0414be5..0c07921747f4 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/delay.h>
 #include <linux/sched.h>
 #include <linux/clk.h>
+#include <linux/cpu.h>
 #include <linux/fs.h>
 #include <linux/of.h>
 
@@ -493,3 +494,17 @@ const struct seq_operations cpuinfo_op = {
 	c_next,
 	show_cpuinfo
 };
+
+static struct cpu cpu_devices[NR_CPUS];
+
+static int __init topology_init(void)
+{
+	int i;
+
+	for_each_present_cpu(i)
+		register_cpu(&cpu_devices[i], i);
+
+	return 0;
+}
+
+subsys_initcall(topology_init);

commit d5981a5f16ed8d648b7f44e4aa19cd25733518a3
Author: Mark Salter <msalter@redhat.com>
Date:   Sun Jan 8 12:31:28 2012 -0500

    C6X: deal with memblock API changes
    
    Recent memblock related commits require the following C6X changes:
    
      * commit 24aa07882b672fff2da2f5c955759f0bd13d32d5
        asm/memblock.h no longer required
    
      * commit 1440c4e2c918532f39131c3330fe2226e16be7b6
        memblock_analyze() no longer needed to update total size
    
      * commit fe091c208a40299fba40e62292a610fb91e44b4e
        memblock_init() no longer needed
    
    Signed-off-by: Mark Salter <msalter@redhat.com>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
index 3c2858f0d91e..c126f0414be5 100644
--- a/arch/c6x/kernel/setup.c
+++ b/arch/c6x/kernel/setup.c
@@ -305,8 +305,6 @@ void __init setup_arch(char **cmdline_p)
 	/* Initialize command line */
 	*cmdline_p = c6x_command_line;
 
-	memblock_init();
-
 	memory_end = ram_end;
 	memory_end &= ~(PAGE_SIZE - 1);
 
@@ -366,7 +364,6 @@ void __init setup_arch(char **cmdline_p)
 					 memory_end >> PAGE_SHIFT);
 	memblock_reserve(memory_start, bootmap_size);
 
-	memblock_analyze();
 	unflatten_device_tree();
 
 	c6x_cache_init();

commit c1a144d77a6ca3a14ba3c0fec30bc4fd20b3d817
Author: Aurelien Jacquiot <a-jacquiot@ti.com>
Date:   Tue Oct 4 11:00:02 2011 -0400

    C6X: early boot code
    
    Original port to early 2.6 kernel using TI COFF toolchain.
    Brought up to date by Mark Salter <msalter@redhat.com>
    
    This patch provides the early boot code for C6X architecture. There is a
    16 entry vector table which is used to direct reset and interrupt events. The
    vector table entries contain a small amount of code (maximum of 8 opcodes)
    which simply branches to the actual event handling code.
    
    The head.S code simply clears BSS, setups up a few control registers, and calls
    machine_init followed by start_kernel. The machine_init code in setup.c does
    the early flat tree parsing (memory, commandline, etc). At setup_arch time, the
    code does the usual memory setup and minimally scans the devicetree for any
    needed information.
    
    Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com>
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/c6x/kernel/setup.c b/arch/c6x/kernel/setup.c
new file mode 100644
index 000000000000..3c2858f0d91e
--- /dev/null
+++ b/arch/c6x/kernel/setup.c
@@ -0,0 +1,498 @@
+/*
+ *  Port on Texas Instruments TMS320C6x architecture
+ *
+ *  Copyright (C) 2004, 2006, 2009, 2010, 2011 Texas Instruments Incorporated
+ *  Author: Aurelien Jacquiot (aurelien.jacquiot@jaluna.com)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#include <linux/dma-mapping.h>
+#include <linux/memblock.h>
+#include <linux/seq_file.h>
+#include <linux/bootmem.h>
+#include <linux/clkdev.h>
+#include <linux/initrd.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_fdt.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/cache.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/of.h>
+
+
+#include <asm/sections.h>
+#include <asm/div64.h>
+#include <asm/setup.h>
+#include <asm/dscr.h>
+#include <asm/clock.h>
+#include <asm/soc.h>
+
+static const char *c6x_soc_name;
+
+int c6x_num_cores;
+EXPORT_SYMBOL_GPL(c6x_num_cores);
+
+unsigned int c6x_silicon_rev;
+EXPORT_SYMBOL_GPL(c6x_silicon_rev);
+
+/*
+ * Device status register. This holds information
+ * about device configuration needed by some drivers.
+ */
+unsigned int c6x_devstat;
+EXPORT_SYMBOL_GPL(c6x_devstat);
+
+/*
+ * Some SoCs have fuse registers holding a unique MAC
+ * address. This is parsed out of the device tree with
+ * the resulting MAC being held here.
+ */
+unsigned char c6x_fuse_mac[6];
+
+unsigned long memory_start;
+unsigned long memory_end;
+
+unsigned long ram_start;
+unsigned long ram_end;
+
+/* Uncached memory for DMA consistent use (memdma=) */
+static unsigned long dma_start __initdata;
+static unsigned long dma_size __initdata;
+
+char c6x_command_line[COMMAND_LINE_SIZE];
+
+#if defined(CONFIG_CMDLINE_BOOL)
+static const char default_command_line[COMMAND_LINE_SIZE] __section(.cmdline) =
+	CONFIG_CMDLINE;
+#endif
+
+struct cpuinfo_c6x {
+	const char *cpu_name;
+	const char *cpu_voltage;
+	const char *mmu;
+	const char *fpu;
+	char *cpu_rev;
+	unsigned int core_id;
+	char __cpu_rev[5];
+};
+
+static DEFINE_PER_CPU(struct cpuinfo_c6x, cpu_data);
+
+unsigned int ticks_per_ns_scaled;
+EXPORT_SYMBOL(ticks_per_ns_scaled);
+
+unsigned int c6x_core_freq;
+
+static void __init get_cpuinfo(void)
+{
+	unsigned cpu_id, rev_id, csr;
+	struct clk *coreclk = clk_get_sys(NULL, "core");
+	unsigned long core_khz;
+	u64 tmp;
+	struct cpuinfo_c6x *p;
+	struct device_node *node, *np;
+
+	p = &per_cpu(cpu_data, smp_processor_id());
+
+	if (!IS_ERR(coreclk))
+		c6x_core_freq = clk_get_rate(coreclk);
+	else {
+		printk(KERN_WARNING
+		       "Cannot find core clock frequency. Using 700MHz\n");
+		c6x_core_freq = 700000000;
+	}
+
+	core_khz = c6x_core_freq / 1000;
+
+	tmp = (uint64_t)core_khz << C6X_NDELAY_SCALE;
+	do_div(tmp, 1000000);
+	ticks_per_ns_scaled = tmp;
+
+	csr = get_creg(CSR);
+	cpu_id = csr >> 24;
+	rev_id = (csr >> 16) & 0xff;
+
+	p->mmu = "none";
+	p->fpu = "none";
+	p->cpu_voltage = "unknown";
+
+	switch (cpu_id) {
+	case 0:
+		p->cpu_name = "C67x";
+		p->fpu = "yes";
+		break;
+	case 2:
+		p->cpu_name = "C62x";
+		break;
+	case 8:
+		p->cpu_name = "C64x";
+		break;
+	case 12:
+		p->cpu_name = "C64x";
+		break;
+	case 16:
+		p->cpu_name = "C64x+";
+		p->cpu_voltage = "1.2";
+		break;
+	default:
+		p->cpu_name = "unknown";
+		break;
+	}
+
+	if (cpu_id < 16) {
+		switch (rev_id) {
+		case 0x1:
+			if (cpu_id > 8) {
+				p->cpu_rev = "DM640/DM641/DM642/DM643";
+				p->cpu_voltage = "1.2 - 1.4";
+			} else {
+				p->cpu_rev = "C6201";
+				p->cpu_voltage = "2.5";
+			}
+			break;
+		case 0x2:
+			p->cpu_rev = "C6201B/C6202/C6211";
+			p->cpu_voltage = "1.8";
+			break;
+		case 0x3:
+			p->cpu_rev = "C6202B/C6203/C6204/C6205";
+			p->cpu_voltage = "1.5";
+			break;
+		case 0x201:
+			p->cpu_rev = "C6701 revision 0 (early CPU)";
+			p->cpu_voltage = "1.8";
+			break;
+		case 0x202:
+			p->cpu_rev = "C6701/C6711/C6712";
+			p->cpu_voltage = "1.8";
+			break;
+		case 0x801:
+			p->cpu_rev = "C64x";
+			p->cpu_voltage = "1.5";
+			break;
+		default:
+			p->cpu_rev = "unknown";
+		}
+	} else {
+		p->cpu_rev = p->__cpu_rev;
+		snprintf(p->__cpu_rev, sizeof(p->__cpu_rev), "0x%x", cpu_id);
+	}
+
+	p->core_id = get_coreid();
+
+	node = of_find_node_by_name(NULL, "cpus");
+	if (node) {
+		for_each_child_of_node(node, np)
+			if (!strcmp("cpu", np->name))
+				++c6x_num_cores;
+		of_node_put(node);
+	}
+
+	node = of_find_node_by_name(NULL, "soc");
+	if (node) {
+		if (of_property_read_string(node, "model", &c6x_soc_name))
+			c6x_soc_name = "unknown";
+		of_node_put(node);
+	} else
+		c6x_soc_name = "unknown";
+
+	printk(KERN_INFO "CPU%d: %s rev %s, %s volts, %uMHz\n",
+	       p->core_id, p->cpu_name, p->cpu_rev,
+	       p->cpu_voltage, c6x_core_freq / 1000000);
+}
+
+/*
+ * Early parsing of the command line
+ */
+static u32 mem_size __initdata;
+
+/* "mem=" parsing. */
+static int __init early_mem(char *p)
+{
+	if (!p)
+		return -EINVAL;
+
+	mem_size = memparse(p, &p);
+	/* don't remove all of memory when handling "mem={invalid}" */
+	if (mem_size == 0)
+		return -EINVAL;
+
+	return 0;
+}
+early_param("mem", early_mem);
+
+/* "memdma=<size>[@<address>]" parsing. */
+static int __init early_memdma(char *p)
+{
+	if (!p)
+		return -EINVAL;
+
+	dma_size = memparse(p, &p);
+	if (*p == '@')
+		dma_start = memparse(p, &p);
+
+	return 0;
+}
+early_param("memdma", early_memdma);
+
+int __init c6x_add_memory(phys_addr_t start, unsigned long size)
+{
+	static int ram_found __initdata;
+
+	/* We only handle one bank (the one with PAGE_OFFSET) for now */
+	if (ram_found)
+		return -EINVAL;
+
+	if (start > PAGE_OFFSET || PAGE_OFFSET >= (start + size))
+		return 0;
+
+	ram_start = start;
+	ram_end = start + size;
+
+	ram_found = 1;
+	return 0;
+}
+
+/*
+ * Do early machine setup and device tree parsing. This is called very
+ * early on the boot process.
+ */
+notrace void __init machine_init(unsigned long dt_ptr)
+{
+	struct boot_param_header *dtb = __va(dt_ptr);
+	struct boot_param_header *fdt = (struct boot_param_header *)_fdt_start;
+
+	/* interrupts must be masked */
+	set_creg(IER, 2);
+
+	/*
+	 * Set the Interrupt Service Table (IST) to the beginning of the
+	 * vector table.
+	 */
+	set_ist(_vectors_start);
+
+	lockdep_init();
+
+	/*
+	 * dtb is passed in from bootloader.
+	 * fdt is linked in blob.
+	 */
+	if (dtb && dtb != fdt)
+		fdt = dtb;
+
+	/* Do some early initialization based on the flat device tree */
+	early_init_devtree(fdt);
+
+	/* parse_early_param needs a boot_command_line */
+	strlcpy(boot_command_line, c6x_command_line, COMMAND_LINE_SIZE);
+	parse_early_param();
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	int bootmap_size;
+	struct memblock_region *reg;
+
+	printk(KERN_INFO "Initializing kernel\n");
+
+	/* Initialize command line */
+	*cmdline_p = c6x_command_line;
+
+	memblock_init();
+
+	memory_end = ram_end;
+	memory_end &= ~(PAGE_SIZE - 1);
+
+	if (mem_size && (PAGE_OFFSET + PAGE_ALIGN(mem_size)) < memory_end)
+		memory_end = PAGE_OFFSET + PAGE_ALIGN(mem_size);
+
+	/* add block that this kernel can use */
+	memblock_add(PAGE_OFFSET, memory_end - PAGE_OFFSET);
+
+	/* reserve kernel text/data/bss */
+	memblock_reserve(PAGE_OFFSET,
+			 PAGE_ALIGN((unsigned long)&_end - PAGE_OFFSET));
+
+	if (dma_size) {
+		/* align to cacheability granularity */
+		dma_size = CACHE_REGION_END(dma_size);
+
+		if (!dma_start)
+			dma_start = memory_end - dma_size;
+
+		/* align to cacheability granularity */
+		dma_start = CACHE_REGION_START(dma_start);
+
+		/* reserve DMA memory taken from kernel memory */
+		if (memblock_is_region_memory(dma_start, dma_size))
+			memblock_reserve(dma_start, dma_size);
+	}
+
+	memory_start = PAGE_ALIGN((unsigned int) &_end);
+
+	printk(KERN_INFO "Memory Start=%08lx, Memory End=%08lx\n",
+	       memory_start, memory_end);
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	/*
+	 * Reserve initrd memory if in kernel memory.
+	 */
+	if (initrd_start < initrd_end)
+		if (memblock_is_region_memory(initrd_start,
+					      initrd_end - initrd_start))
+			memblock_reserve(initrd_start,
+					 initrd_end - initrd_start);
+#endif
+
+	init_mm.start_code = (unsigned long) &_stext;
+	init_mm.end_code   = (unsigned long) &_etext;
+	init_mm.end_data   = memory_start;
+	init_mm.brk        = memory_start;
+
+	/*
+	 * Give all the memory to the bootmap allocator,  tell it to put the
+	 * boot mem_map at the start of memory
+	 */
+	bootmap_size = init_bootmem_node(NODE_DATA(0),
+					 memory_start >> PAGE_SHIFT,
+					 PAGE_OFFSET >> PAGE_SHIFT,
+					 memory_end >> PAGE_SHIFT);
+	memblock_reserve(memory_start, bootmap_size);
+
+	memblock_analyze();
+	unflatten_device_tree();
+
+	c6x_cache_init();
+
+	/* Set the whole external memory as non-cacheable */
+	disable_caching(ram_start, ram_end - 1);
+
+	/* Set caching of external RAM used by Linux */
+	for_each_memblock(memory, reg)
+		enable_caching(CACHE_REGION_START(reg->base),
+			       CACHE_REGION_START(reg->base + reg->size - 1));
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	/*
+	 * Enable caching for initrd which falls outside kernel memory.
+	 */
+	if (initrd_start < initrd_end) {
+		if (!memblock_is_region_memory(initrd_start,
+					       initrd_end - initrd_start))
+			enable_caching(CACHE_REGION_START(initrd_start),
+				       CACHE_REGION_START(initrd_end - 1));
+	}
+#endif
+
+	/*
+	 * Disable caching for dma coherent memory taken from kernel memory.
+	 */
+	if (dma_size && memblock_is_region_memory(dma_start, dma_size))
+		disable_caching(dma_start,
+				CACHE_REGION_START(dma_start + dma_size - 1));
+
+	/* Initialize the coherent memory allocator */
+	coherent_mem_init(dma_start, dma_size);
+
+	/*
+	 * Free all memory as a starting point.
+	 */
+	free_bootmem(PAGE_OFFSET, memory_end - PAGE_OFFSET);
+
+	/*
+	 * Then reserve memory which is already being used.
+	 */
+	for_each_memblock(reserved, reg) {
+		pr_debug("reserved - 0x%08x-0x%08x\n",
+			 (u32) reg->base, (u32) reg->size);
+		reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
+	}
+
+	max_low_pfn = PFN_DOWN(memory_end);
+	min_low_pfn = PFN_UP(memory_start);
+	max_mapnr = max_low_pfn - min_low_pfn;
+
+	/* Get kmalloc into gear */
+	paging_init();
+
+	/*
+	 * Probe for Device State Configuration Registers.
+	 * We have to do this early in case timer needs to be enabled
+	 * through DSCR.
+	 */
+	dscr_probe();
+
+	/* We do this early for timer and core clock frequency */
+	c64x_setup_clocks();
+
+	/* Get CPU info */
+	get_cpuinfo();
+
+#if defined(CONFIG_VT) && defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+}
+
+#define cpu_to_ptr(n) ((void *)((long)(n)+1))
+#define ptr_to_cpu(p) ((long)(p) - 1)
+
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+	int n = ptr_to_cpu(v);
+	struct cpuinfo_c6x *p = &per_cpu(cpu_data, n);
+
+	if (n == 0) {
+		seq_printf(m,
+			   "soc\t\t: %s\n"
+			   "soc revision\t: 0x%x\n"
+			   "soc cores\t: %d\n",
+			   c6x_soc_name, c6x_silicon_rev, c6x_num_cores);
+	}
+
+	seq_printf(m,
+		   "\n"
+		   "processor\t: %d\n"
+		   "cpu\t\t: %s\n"
+		   "core revision\t: %s\n"
+		   "core voltage\t: %s\n"
+		   "core id\t\t: %d\n"
+		   "mmu\t\t: %s\n"
+		   "fpu\t\t: %s\n"
+		   "cpu MHz\t\t: %u\n"
+		   "bogomips\t: %lu.%02lu\n\n",
+		   n,
+		   p->cpu_name, p->cpu_rev, p->cpu_voltage,
+		   p->core_id, p->mmu, p->fpu,
+		   (c6x_core_freq + 500000) / 1000000,
+		   (loops_per_jiffy/(500000/HZ)),
+		   (loops_per_jiffy/(5000/HZ))%100);
+
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < nr_cpu_ids ? cpu_to_ptr(*pos) : NULL;
+}
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+const struct seq_operations cpuinfo_op = {
+	c_start,
+	c_stop,
+	c_next,
+	show_cpuinfo
+};
