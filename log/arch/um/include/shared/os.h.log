commit 88ce642492339f49a0b391af40e5798c08948e49
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 13 14:26:47 2020 +0100

    um: Implement time-travel=ext
    
    This implements synchronized time-travel mode which - using a special
    application on a unix socket - lets multiple machines take part in a
    time-travelling simulation together.
    
    The protocol for the unix domain socket is defined in the new file
    include/uapi/linux/um_timetravel.h.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 0f30204b6afa..f467d28fc0b4 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -181,6 +181,7 @@ extern int os_falloc_punch(int fd, unsigned long long offset, int count);
 extern int os_eventfd(unsigned int initval, int flags);
 extern int os_sendmsg_fds(int fd, const void *buf, unsigned int len,
 			  const int *fds, unsigned int fds_num);
+int os_poll(unsigned int n, const int *fds);
 
 /* start_up.c */
 extern void os_early_checks(void);

commit 853bc0ab341b0c99619f83f4060dedcccad77b2a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 5 09:39:51 2019 +0100

    um: ubd: use 64-bit time_t where possible
    
    The ubd code suffers from a possible y2038 overflow on 32-bit
    architectures, both for the cow header and the os_file_modtime()
    function.
    
    Replace time_t with time64_t to extend the ubd_kern side as much
    as possible.
    
    Whether this makes a difference for the user side depends on
    the host libc implementation that may use either 32-bit or 64-bit
    time_t.
    
    For the cow file format, the header contains an unsigned 32-bit
    timestamp, which is good until y2106, passing this through a
    'long long' gives us a consistent interpretation between 32-bit
    and 64-bit um kernels.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 506bcd1bca68..0f30204b6afa 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -150,7 +150,7 @@ extern int os_sync_file(int fd);
 extern int os_file_size(const char *file, unsigned long long *size_out);
 extern int os_pread_file(int fd, void *buf, int len, unsigned long long offset);
 extern int os_pwrite_file(int fd, const void *buf, int count, unsigned long long offset);
-extern int os_file_modtime(const char *file, unsigned long *modtime);
+extern int os_file_modtime(const char *file, long long *modtime);
 extern int os_pipe(int *fd, int stream, int close_on_exec);
 extern int os_set_fd_async(int fd);
 extern int os_clear_fd_async(int fd);

commit f2f4bf5aabadd6575f5daabcb0a2f506e3f5f68c
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:19 2019 +0100

    um: Add SPDX headers for files in arch/um/include
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index d542dadcf22e..506bcd1bca68 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -1,8 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2015 Anton Ivanov (aivanov@{brocade.com,kot-begemot.co.uk})
  * Copyright (C) 2015 Thomas Meyer (thomas@m3y3r.de)
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #ifndef __OS_H__

commit 5d38f324993f49d1226ec81efe045834b46cd85a
Author: Erel Geron <erelx.geron@intel.com>
Date:   Wed Sep 11 14:51:20 2019 +0200

    um: drivers: Add virtio vhost-user driver
    
    This module allows virtio devices to be used over a vhost-user socket.
    
    Signed-off-by: Erel Geron <erelx.geron@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index fa1909365666..d542dadcf22e 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -36,6 +36,8 @@
 #define OS_LIB_PATH	"/usr/lib/"
 #endif
 
+#define OS_SENDMSG_MAX_FDS 8
+
 /*
  * types taken from stat_file() in hostfs_user.c
  * (if they are wrong here, they are wrong there...).
@@ -176,6 +178,9 @@ extern unsigned os_major(unsigned long long dev);
 extern unsigned os_minor(unsigned long long dev);
 extern unsigned long long os_makedev(unsigned major, unsigned minor);
 extern int os_falloc_punch(int fd, unsigned long long offset, int count);
+extern int os_eventfd(unsigned int initval, int flags);
+extern int os_sendmsg_fds(int fd, const void *buf, unsigned int len,
+			  const int *fds, unsigned int fds_num);
 
 /* start_up.c */
 extern void os_early_checks(void);

commit 0dafcbe128d2af48919619f79332ef219b5e5514
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Aug 23 13:16:23 2019 +0200

    um: Implement TRACE_IRQFLAGS_SUPPORT
    
    UML enables TRACE_IRQFLAGS_SUPPORT but doesn't actually implement
    it. It seems to have been added for lockdep support, but that can't
    actually really work well without IRQ flags tracing, as is also
    very noisily reported when enabling CONFIG_DEBUG_LOCKDEP.
    
    Implement it now.
    
    Fixes: 711553efa5b8 ("[PATCH] uml: declare in Kconfig our partial LOCKDEP support")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 4a62ac4251a5..fa1909365666 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -232,6 +232,7 @@ extern void block_signals(void);
 extern void unblock_signals(void);
 extern int get_signals(void);
 extern int set_signals(int enable);
+extern int set_signals_trace(int enable);
 extern int os_is_signal_stack(void);
 extern void deliver_alarm(void);
 
@@ -317,4 +318,10 @@ extern unsigned long os_get_top_address(void);
 
 long syscall(long number, ...);
 
+/* irqflags tracing */
+extern void block_signals_trace(void);
+extern void unblock_signals_trace(void);
+extern void um_trace_signals_on(void);
+extern void um_trace_signals_off(void);
+
 #endif

commit c7c6f3b95303c7de5d52af56c902fcb5abe827df
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon May 27 10:34:26 2019 +0200

    um: Pass nsecs to os timer functions
    
    This makes the code clearer and lets the time travel patch have
    the actual time used for these functions in just one place.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 449e71edefaa..4a62ac4251a5 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -251,8 +251,8 @@ extern void os_warn(const char *fmt, ...)
 /* time.c */
 extern void os_idle_sleep(unsigned long long nsecs);
 extern int os_timer_create(void);
-extern int os_timer_set_interval(void);
-extern int os_timer_one_shot(unsigned long ticks);
+extern int os_timer_set_interval(unsigned long long nsecs);
+extern int os_timer_one_shot(unsigned long long nsecs);
 extern void os_timer_disable(void);
 extern void uml_idle_timer(void);
 extern long long os_persistent_clock_emulation(void);

commit 56fc187065451ebca74edb30d50de5f10a88339b
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon May 6 14:39:38 2019 +0200

    um: Timer code cleanup
    
    There are some unused functions, and some others that have
    unused arguments; clean up the timer code a bit.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index d579adcb2690..449e71edefaa 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -250,15 +250,13 @@ extern void os_warn(const char *fmt, ...)
 
 /* time.c */
 extern void os_idle_sleep(unsigned long long nsecs);
-extern int os_timer_create(void* timer);
-extern int os_timer_set_interval(void* timer, void* its);
+extern int os_timer_create(void);
+extern int os_timer_set_interval(void);
 extern int os_timer_one_shot(unsigned long ticks);
-extern long long os_timer_disable(void);
-extern long os_timer_remain(void* timer);
+extern void os_timer_disable(void);
 extern void uml_idle_timer(void);
 extern long long os_persistent_clock_emulation(void);
 extern long long os_nsecs(void);
-extern long long os_vnsecs(void);
 
 /* skas/mem.c */
 extern long run_syscall_stub(struct mm_id * mm_idp,

commit fcd242c6c835dff4b5334b4db870f9fc23a8e7b7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon May 6 14:39:37 2019 +0200

    um: fix os_timer_one_shot()
    
    os_timer_one_shot() gets passed a value "unsigned long delta",
    so must not have an "int ticks" as that actually ends up being
    -1, and thus triggering a timer over and over again.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index ebf23012a59b..d579adcb2690 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -252,7 +252,7 @@ extern void os_warn(const char *fmt, ...)
 extern void os_idle_sleep(unsigned long long nsecs);
 extern int os_timer_create(void* timer);
 extern int os_timer_set_interval(void* timer, void* its);
-extern int os_timer_one_shot(int ticks);
+extern int os_timer_one_shot(unsigned long ticks);
 extern long long os_timer_disable(void);
 extern long os_timer_remain(void* timer);
 extern void uml_idle_timer(void);

commit 50109b5a03b4024eb6b8df3ab8f427625f54fe92
Author: Anton Ivanov <anton.ivanov@cambridgegreys.com>
Date:   Wed Nov 14 18:41:09 2018 +0000

    um: Add support for DISCARD in the UBD Driver
    
    Support for DISCARD and WRITE_ZEROES in the ubd driver using
    fallocate.
    
    DISCARD is enabled by default and can be disabled using a new
    UBD command line flag.
    
    If the underlying fs on which the UBD image is stored does not
    support DISCARD the support for both DISCARD and WRITE_ZEROES
    is turned off.
    
    Signed-off-by: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 048ae37eb5aa..ebf23012a59b 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -175,6 +175,7 @@ extern int os_fchange_dir(int fd);
 extern unsigned os_major(unsigned long long dev);
 extern unsigned os_minor(unsigned long long dev);
 extern unsigned long long os_makedev(unsigned major, unsigned minor);
+extern int os_falloc_punch(int fd, unsigned long long offset, int count);
 
 /* start_up.c */
 extern void os_early_checks(void);

commit ff6a17989c08b0bb0fd490cc500b084581b3a9b9
Author: Anton Ivanov <anton.ivanov@cambridgegreys.com>
Date:   Mon Nov 20 21:17:58 2017 +0000

    Epoll based IRQ controller
    
    1. Removes the need to walk the IRQ/Device list to determine
    who triggered the IRQ.
    2. Improves scalability (up to several times performance
    improvement for cases with 10s of devices).
    3. Improves UML baseline IO performance for one disk + one NIC
    use case by up to 10%.
    4. Introduces write poll triggered IRQs.
    5. Prerequisite for introducing high performance mmesg family
    of functions in network IO.
    6. Fixes RNG shutdown which was leaking a file descriptor
    
    Signed-off-by: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index d8ddaf9790d2..048ae37eb5aa 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -290,15 +290,16 @@ extern void halt_skas(void);
 extern void reboot_skas(void);
 
 /* irq.c */
-extern int os_waiting_for_events(struct irq_fd *active_fds);
-extern int os_create_pollfd(int fd, int events, void *tmp_pfd, int size_tmpfds);
-extern void os_free_irq_by_cb(int (*test)(struct irq_fd *, void *), void *arg,
-		struct irq_fd *active_fds, struct irq_fd ***last_irq_ptr2);
-extern void os_free_irq_later(struct irq_fd *active_fds,
-		int irq, void *dev_id);
-extern int os_get_pollfd(int i);
-extern void os_set_pollfd(int i, int fd);
+extern int os_waiting_for_events_epoll(void);
+extern void *os_epoll_get_data_pointer(int index);
+extern int os_epoll_triggered(int index, int events);
+extern int os_event_mask(int irq_type);
+extern int os_setup_epoll(void);
+extern int os_add_epoll_fd(int events, int fd, void *data);
+extern int os_mod_epoll_fd(int events, int fd, void *data);
+extern int os_del_epoll_fd(int fd);
 extern void os_set_ioignore(void);
+extern void os_close_epoll_fd(void);
 
 /* sigio.c */
 extern int add_sigio_fd(int fd);

commit 6f602afda7275c24c20ba38b5b6cd4ed08561fff
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Sat Jul 29 17:03:23 2017 +0200

    um: Fix FP register size for XSTATE/XSAVE
    
    Hard code max size. Taken from
    https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=gdb/common/x86-xstate.h
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 574e03fc7ba2..d8ddaf9790d2 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -278,7 +278,7 @@ extern int protect(struct mm_id * mm_idp, unsigned long addr,
 extern int is_skas_winch(int pid, int fd, void *data);
 extern int start_userspace(unsigned long stub_stack);
 extern int copy_context_skas0(unsigned long stack, int pid);
-extern void userspace(struct uml_pt_regs *regs);
+extern void userspace(struct uml_pt_regs *regs, unsigned long *aux_fp_regs);
 extern int map_stub_pages(int fd, unsigned long code, unsigned long data,
 			  unsigned long stack);
 extern void new_thread(void *stack, jmp_buf *buf, void (*handler)(void));

commit 721ccae88d04f7e9334fde4cbb3eecfaa70a31ac
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu May 18 02:18:22 2017 +0900

    um: Add os_warn() for pre-boot warning/error messages
    
    Add os_warn() for printing out pre-boot warning/error
    messages in stderr. The messages via os_warn() are not
    suppressed by quiet option.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 9e95bcebaf9b..574e03fc7ba2 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -244,6 +244,8 @@ extern void um_early_printk(const char *s, unsigned int n);
 extern void os_fix_helper_signals(void);
 extern void os_info(const char *fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
+extern void os_warn(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
 
 /* time.c */
 extern void os_idle_sleep(unsigned long long nsecs);

commit f7887ee11082b468517f31ae315b474eaa48b843
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu May 18 02:16:05 2017 +0900

    um: Add os_info() for pre-boot information messages
    
    Add os_info() for printing out pre-boot information
    level messages in stderr. The messages via os_info()
    are suppressed by "quiet" kernel command line.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index cd1fa97776c3..9e95bcebaf9b 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -242,6 +242,8 @@ extern void setup_hostinfo(char *buf, int len);
 extern void os_dump_core(void) __attribute__ ((noreturn));
 extern void um_early_printk(const char *s, unsigned int n);
 extern void os_fix_helper_signals(void);
+extern void os_info(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
 
 /* time.c */
 extern void os_idle_sleep(unsigned long long nsecs);

commit 17a6e1b8e8e8539f89156643f8c3073f09ec446a
Author: Kyle Huey <me@kylehuey.com>
Date:   Mon Mar 20 01:16:22 2017 -0700

    x86/arch_prctl/64: Rename do_arch_prctl() to do_arch_prctl_64()
    
    In order to introduce new arch_prctls that are not 64 bit only, rename the
    existing 64 bit implementation to do_arch_prctl_64(). Also rename the
    second argument of that function from 'addr' to 'arg2', because it will no
    longer always be an address.
    
    Signed-off-by: Kyle Huey <khuey@kylehuey.com>
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Cc: Grzegorz Andrejczuk <grzegorz.andrejczuk@intel.com>
    Cc: kvm@vger.kernel.org
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: linux-kselftest@vger.kernel.org
    Cc: Nadav Amit <nadav.amit@gmail.com>
    Cc: Robert O'Callahan <robert@ocallahan.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: user-mode-linux-user@lists.sourceforge.net
    Cc: David Matlack <dmatlack@google.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Dmitry Safonov <dsafonov@virtuozzo.com>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Link: http://lkml.kernel.org/r/20170320081628.18952-5-khuey@kylehuey.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 32e41c4ef6d3..cd1fa97776c3 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -303,7 +303,7 @@ extern void maybe_sigio_broken(int fd, int read);
 extern void sigio_broken(int fd, int read);
 
 /* prctl.c */
-extern int os_arch_prctl(int pid, int option, unsigned long *addr);
+extern int os_arch_prctl(int pid, int option, unsigned long *arg2);
 
 /* tty.c */
 extern int get_pty(void);

commit dd93938a92dc067aba70c401bdf2e50ed58083db
Author: Kyle Huey <me@kylehuey.com>
Date:   Mon Mar 20 01:16:20 2017 -0700

    x86/arch_prctl: Rename 'code' argument to 'option'
    
    The x86 specific arch_prctl() arbitrarily changed prctl's 'option' to
    'code'. Before adding new options, rename it.
    
    Signed-off-by: Kyle Huey <khuey@kylehuey.com>
    Cc: Grzegorz Andrejczuk <grzegorz.andrejczuk@intel.com>
    Cc: kvm@vger.kernel.org
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: linux-kselftest@vger.kernel.org
    Cc: Nadav Amit <nadav.amit@gmail.com>
    Cc: Robert O'Callahan <robert@ocallahan.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: user-mode-linux-user@lists.sourceforge.net
    Cc: David Matlack <dmatlack@google.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Dmitry Safonov <dsafonov@virtuozzo.com>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Link: http://lkml.kernel.org/r/20170320081628.18952-3-khuey@kylehuey.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index de5d572225f3..32e41c4ef6d3 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -302,8 +302,8 @@ extern int ignore_sigio_fd(int fd);
 extern void maybe_sigio_broken(int fd, int read);
 extern void sigio_broken(int fd, int read);
 
-/* sys-x86_64/prctl.c */
-extern int os_arch_prctl(int pid, int code, unsigned long *addr);
+/* prctl.c */
+extern int os_arch_prctl(int pid, int option, unsigned long *addr);
 
 /* tty.c */
 extern int get_pty(void);

commit e04c989eb785af61d2895d76d38c09166296f9c5
Author: Mickaël Salaün <mic@digikod.net>
Date:   Tue Dec 29 21:35:44 2015 +0100

    um: Fix ptrace GETREGS/SETREGS bugs
    
    This fix two related bugs:
    * PTRACE_GETREGS doesn't get the right orig_ax (syscall) value
    * PTRACE_SETREGS can't set the orig_ax value (erased by initial value)
    
    Get rid of the now useless and error-prone get_syscall().
    
    Fix inconsistent behavior in the ptrace implementation for i386 when
    updating orig_eax automatically update the syscall number as well. This
    is now updated in handle_syscall().
    
    Signed-off-by: Mickaël Salaün <mic@digikod.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Thomas Meyer <thomas@m3y3r.de>
    Cc: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Cc: Anton Ivanov <aivanov@brocade.com>
    Cc: Meredydd Luff <meredydd@senatehouse.org>
    Cc: David Drysdale <drysdale@google.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Acked-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 7a04ddd85334..de5d572225f3 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -284,7 +284,6 @@ extern void initial_thread_cb_skas(void (*proc)(void *),
 				 void *arg);
 extern void halt_skas(void);
 extern void reboot_skas(void);
-extern int get_syscall(struct uml_pt_regs *regs);
 
 /* irq.c */
 extern int os_waiting_for_events(struct irq_fd *active_fds);

commit 8c6157b6b30a765ec233a1be5f9446f24a5283de
Author: Anton Ivanov <aivanov@brocade.com>
Date:   Mon Dec 21 18:54:00 2015 +0000

    um: Update UBD to use pread/pwrite family of functions
    
    This decreases the number of syscalls per read/write by half.
    
    Signed-off-by: Anton Ivanov <aivanov@brocade.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 868e6c3f83dd..7a04ddd85334 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -146,6 +146,8 @@ extern int os_read_file(int fd, void *buf, int len);
 extern int os_write_file(int fd, const void *buf, int count);
 extern int os_sync_file(int fd);
 extern int os_file_size(const char *file, unsigned long long *size_out);
+extern int os_pread_file(int fd, void *buf, int len, unsigned long long offset);
+extern int os_pwrite_file(int fd, const void *buf, int count, unsigned long long offset);
 extern int os_file_modtime(const char *file, unsigned long *modtime);
 extern int os_pipe(int *fd, int stream, int close_on_exec);
 extern int os_set_fd_async(int fd);

commit 2eb5f31bc4ea24bb293e82934cfa1cce9573304b
Author: Anton Ivanov <aivanov@brocade.com>
Date:   Mon Nov 2 16:16:37 2015 +0000

    um: Switch clocksource to hrtimers
    
    UML is using an obsolete itimer call for
    all timers and "polls" for kernel space timer firing
    in its userspace portion resulting in a long list
    of bugs and incorrect behaviour(s). It also uses
    ITIMER_VIRTUAL for its timer which results in the
    timer being dependent on it running and the cpu
    load.
    
    This patch fixes this by moving to posix high resolution
    timers firing off CLOCK_MONOTONIC and relaying the timer
    correctly to the UML userspace.
    
    Fixes:
     - crashes when hosts suspends/resumes
     - broken userspace timers - effecive ~40Hz instead
       of what they should be. Note - this modifies skas behavior
       by no longer setting an itimer per clone(). Timer events
       are relayed instead.
     - kernel network packet scheduling disciplines
     - tcp behaviour especially under load
     - various timer related corner cases
    
    Finally, overall responsiveness of userspace is better.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Anton Ivanov <aivanov@brocade.com>
    [rw: massaged commit message]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index f3cbaef20e04..868e6c3f83dd 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2015 Anton Ivanov (aivanov@{brocade.com,kot-begemot.co.uk})
+ * Copyright (C) 2015 Thomas Meyer (thomas@m3y3r.de)
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
@@ -183,6 +185,7 @@ extern int create_mem_file(unsigned long long len);
 /* process.c */
 extern unsigned long os_process_pc(int pid);
 extern int os_process_parent(int pid);
+extern void os_alarm_process(int pid);
 extern void os_stop_process(int pid);
 extern void os_kill_process(int pid, int reap_child);
 extern void os_kill_ptraced_process(int pid, int reap_child);
@@ -217,7 +220,7 @@ extern int set_umid(char *name);
 extern char *get_umid(void);
 
 /* signal.c */
-extern void timer_init(void);
+extern void timer_set_signal_handler(void);
 extern void set_sigstack(void *sig_stack, int size);
 extern void remove_sigstack(void);
 extern void set_handler(int sig);
@@ -227,6 +230,7 @@ extern void unblock_signals(void);
 extern int get_signals(void);
 extern int set_signals(int enable);
 extern int os_is_signal_stack(void);
+extern void deliver_alarm(void);
 
 /* util.c */
 extern void stack_protections(unsigned long address);
@@ -238,12 +242,16 @@ extern void um_early_printk(const char *s, unsigned int n);
 extern void os_fix_helper_signals(void);
 
 /* time.c */
-extern void idle_sleep(unsigned long long nsecs);
-extern int set_interval(void);
-extern int timer_one_shot(int ticks);
-extern long long disable_timer(void);
+extern void os_idle_sleep(unsigned long long nsecs);
+extern int os_timer_create(void* timer);
+extern int os_timer_set_interval(void* timer, void* its);
+extern int os_timer_one_shot(int ticks);
+extern long long os_timer_disable(void);
+extern long os_timer_remain(void* timer);
 extern void uml_idle_timer(void);
+extern long long os_persistent_clock_emulation(void);
 extern long long os_nsecs(void);
+extern long long os_vnsecs(void);
 
 /* skas/mem.c */
 extern long run_syscall_stub(struct mm_id * mm_idp,

commit 1d80f0cda10118d7505bd0a09a5c1c72f3a5f6c8
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Oct 25 19:54:33 2015 +0100

    um: Store syscall number after syscall_trace_enter()
    
    To support changing syscall numbers we have to store
    it after syscall_trace_enter().
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index ad3fa3ae6d34..f3cbaef20e04 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -274,6 +274,7 @@ extern void initial_thread_cb_skas(void (*proc)(void *),
 				 void *arg);
 extern void halt_skas(void);
 extern void reboot_skas(void);
+extern int get_syscall(struct uml_pt_regs *regs);
 
 /* irq.c */
 extern int os_waiting_for_events(struct irq_fd *active_fds);

commit 89520d999683cb945d7540efd0944b3af2db9a54
Author: Richard Weinberger <richard@nod.at>
Date:   Sun May 31 13:11:19 2015 +0200

    um: Move syscall() declaration into os.h
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index d824528f6f62..ad3fa3ae6d34 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -301,4 +301,6 @@ extern int get_pty(void);
 /* sys-$ARCH/task_size.c */
 extern unsigned long os_get_top_address(void);
 
+long syscall(long number, ...);
+
 #endif

commit d0b5e15f0c0fdd759dd3dd48dc2dc2e7199e0da0
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Mar 18 21:31:27 2015 +0100

    um: Remove SKAS3/4 support
    
    Before we had SKAS0 UML had two modes of operation
    TT (tracing thread) and SKAS3/4 (separated kernel address space).
    TT was known to be insecure and got removed a long time ago.
    SKAS3/4 required a few (3 or 4) patches on the host side which never went
    mainline. The last host patch is 10 years old.
    
    With SKAS0 mode (separated kernel address space using 0 host patches),
    default since 2005, SKAS3/4 is obsolete and can be removed.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 08eec0b691b0..d824528f6f62 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -174,7 +174,6 @@ extern unsigned long long os_makedev(unsigned major, unsigned minor);
 
 /* start_up.c */
 extern void os_early_checks(void);
-extern void can_do_skas(void);
 extern void os_check_bugs(void);
 extern void check_host_supports_tls(int *supports_tls, int *tls_min);
 
@@ -187,7 +186,6 @@ extern int os_process_parent(int pid);
 extern void os_stop_process(int pid);
 extern void os_kill_process(int pid, int reap_child);
 extern void os_kill_ptraced_process(int pid, int reap_child);
-extern long os_ptrace_ldt(long pid, long addr, long data);
 
 extern int os_getpid(void);
 extern int os_getpgrp(void);

commit 0565103d1adbd765ca45248d04c327c076dd1571
Author: Anton Ivanov <antivano@cisco.com>
Date:   Fri Mar 7 18:37:47 2014 +0000

    um: Memory corruption on startup
    
    The reverse case of this race (you must msync before read) is
    well known. This is the not so common one.
    
    It can be triggered only on systems which do a lot of task
    switching and only at UML startup. If you are starting 200+ UMLs
    ~ 0.5% will always die without this fix.
    
    Signed-off-by: Anton Ivanov <antivano@cisco.com>
    [rw: minor whitespace fixes]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 75298d3358e7..08eec0b691b0 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -136,6 +136,7 @@ extern int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg);
 extern int os_get_ifname(int fd, char *namebuf);
 extern int os_set_slip(int fd);
 extern int os_mode_fd(int fd, int mode);
+extern int os_fsync_file(int fd);
 
 extern int os_seek_file(int fd, unsigned long long offset);
 extern int os_open_file(const char *file, struct openflags flags, int mode);

commit f72c22e45e8f8fe78c7f793d983bee5bed63497e
Author: Richard Weinberger <richard@nod.at>
Date:   Mon Sep 23 17:38:02 2013 +0200

    um: Make stack trace reliable against kernel mode faults
    
    As UML uses an alternative signal stack we cannot use
    the current stack pointer for stack dumping if UML itself
    dies by SIGSEGV. To bypass this issue we save regs taken
    from mcontext in our segv handler into thread_struct and
    use these regs to obtain the stack pointer in show_stack().
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 021104d98cb3..75298d3358e7 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -227,6 +227,7 @@ extern void block_signals(void);
 extern void unblock_signals(void);
 extern int get_signals(void);
 extern int set_signals(int enable);
+extern int os_is_signal_stack(void);
 
 /* util.c */
 extern void stack_protections(unsigned long address);

commit 91d44ff860a9e9c0db81a89cbc24fa31fbd8e6d3
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Aug 18 13:30:08 2013 +0200

    um: Cleanup SIGTERM handling
    
    Richard reported that some UML processes survive if the UML
    main process receives a SIGTERM.
    This issue was caused by a wrongly placed signal(SIGTERM, SIG_DFL)
    in init_new_thread_signals().
    It disabled the UML exit handler accidently for some processes.
    The correct solution is to disable the fatal handler for all
    UML helper threads/processes.
    Such that last_ditch_exit() does not get called multiple times
    and all processes can exit due to SIGTERM.
    
    Reported-and-tested-by: Richard W.M. Jones <rjones@redhat.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index e98303925cc5..021104d98cb3 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -235,6 +235,7 @@ extern void setup_machinename(char *machine_out);
 extern void setup_hostinfo(char *buf, int len);
 extern void os_dump_core(void) __attribute__ ((noreturn));
 extern void um_early_printk(const char *s, unsigned int n);
+extern void os_fix_helper_signals(void);
 
 /* time.c */
 extern void idle_sleep(unsigned long long nsecs);

commit 805f11a0d515658106bfbfadceff0eb30bd90ad2
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Aug 18 13:30:06 2013 +0200

    um: ubd: Add REQ_FLUSH suppport
    
    UML's block device driver does not support write barriers,
    to support this this patch adds REQ_FLUSH suppport.
    Every time the block layer sends a REQ_FLUSH we fsync() now
    our backing file to guarantee data consistency.
    
    Reported-and-tested-by: Richard W.M. Jones <rjones@redhat.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index c70a234a3f8c..e98303925cc5 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -141,6 +141,7 @@ extern int os_seek_file(int fd, unsigned long long offset);
 extern int os_open_file(const char *file, struct openflags flags, int mode);
 extern int os_read_file(int fd, void *buf, int len);
 extern int os_write_file(int fd, const void *buf, int count);
+extern int os_sync_file(int fd);
 extern int os_file_size(const char *file, unsigned long long *size_out);
 extern int os_file_modtime(const char *file, unsigned long *modtime);
 extern int os_pipe(int *fd, int stream, int close_on_exec);

commit f75b1b1bedfb498cc43a992ce4d7ed8df3b1e770
Author: Richard Weinberger <richard@nod.at>
Date:   Sat Aug 17 18:46:00 2013 +0200

    um: Implement probe_kernel_read()
    
    UML needs it's own probe_kernel_read() to handle kernel
    mode faults correctly.
    The implementation uses mincore() on the host side to detect
    whether a page is owned by the UML kernel process.
    
    This fixes also a possible crash when sysrq-t is used.
    Starting with 3.10 sysrq-t calls probe_kernel_read() to
    read details from the kernel workers. As kernel worker are
    completely async pointers may turn NULL while reading them.
    
    Cc: <stian@nixia.no>
    Cc: <tj@kernel.org>
    Cc: <stable@vger.kernel.org> # 3.10.x
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 95feaa47a2fb..c70a234a3f8c 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -200,6 +200,7 @@ extern int os_unmap_memory(void *addr, int len);
 extern int os_drop_memory(void *addr, int length);
 extern int can_drop_memory(void);
 extern void os_flush_stdout(void);
+extern int os_mincore(void *addr, unsigned long len);
 
 /* execvp.c */
 extern int execvp_noalloc(char *buf, const char *file, char *const argv[]);

commit 4e21fc138bfd7fe625ff5dc81541399aaf9d429b
Merge: 8418263e3547 5522be6a4624
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 13 10:05:52 2012 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal
    
    Pull third pile of kernel_execve() patches from Al Viro:
     "The last bits of infrastructure for kernel_thread() et.al., with
      alpha/arm/x86 use of those.  Plus sanitizing the asm glue and
      do_notify_resume() on alpha, fixing the "disabled irq while running
      task_work stuff" breakage there.
    
      At that point the rest of kernel_thread/kernel_execve/sys_execve work
      can be done independently for different architectures.  The only
      pending bits that do depend on having all architectures converted are
      restrictred to fs/* and kernel/* - that'll obviously have to wait for
      the next cycle.
    
      I thought we'd have to wait for all of them done before we start
      eliminating the longjump-style insanity in kernel_execve(), but it
      turned out there's a very simple way to do that without flagday-style
      changes."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal:
      alpha: switch to saner kernel_execve() semantics
      arm: switch to saner kernel_execve() semantics
      x86, um: convert to saner kernel_execve() semantics
      infrastructure for saner ret_from_kernel_thread semantics
      make sure that kernel_thread() callbacks call do_exit() themselves
      make sure that we always have a return path from kernel_execve()
      ppc: eeh_event should just use kthread_run()
      don't bother with kernel_thread/kernel_execve for launching linuxrc
      alpha: get rid of switch_stack argument of do_work_pending()
      alpha: don't bother passing switch_stack separately from regs
      alpha: take SIGPENDING/NOTIFY_RESUME loop into signal.c
      alpha: simplify TIF_NEED_RESCHED handling

commit 22e2430d60dbdfcdd732a086e9ef2dbd74c266d1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 10 21:35:42 2012 -0400

    x86, um: convert to saner kernel_execve() semantics
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 89b686c1a3ea..25dbd372d322 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -191,7 +191,6 @@ extern int os_getpid(void);
 extern int os_getpgrp(void);
 
 extern void init_new_thread_signals(void);
-extern int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr);
 
 extern int os_map_memory(void *virt, int fd, unsigned long long off,
 			 unsigned long len, int r, int w, int x);

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 89b686c1a3ea..44883049c11d 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -7,9 +7,9 @@
 #define __OS_H__
 
 #include <stdarg.h>
-#include "irq_user.h"
-#include "longjmp.h"
-#include "mm_id.h"
+#include <irq_user.h>
+#include <longjmp.h>
+#include <mm_id.h>
 
 #define CATCH_EINTR(expr) while ((errno = 0, ((expr) < 0)) && (errno == EINTR))
 

commit 1bbd5f21f426d99660ea8120b79595a282e5ff8a
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:09:49 2011 +0100

    um: merge os-Linux/tls.c into arch/x86/um/os-Linux/tls.c
    
    it's i386-specific; moreover, analogs on other targets have
    incompatible interface - PTRACE_GET_THREAD_AREA does exist
    elsewhere, but struct user_desc does *not*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index caa66619a9b4..89b686c1a3ea 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -10,7 +10,6 @@
 #include "irq_user.h"
 #include "longjmp.h"
 #include "mm_id.h"
-#include "sysdep/tls.h"
 
 #define CATCH_EINTR(expr) while ((errno = 0, ((expr) < 0)) && (errno == EINTR))
 
@@ -212,10 +211,6 @@ extern int run_helper_thread(int (*proc)(void *), void *arg,
 extern int helper_wait(int pid);
 
 
-/* tls.c */
-extern int os_set_thread_area(user_desc_t *info, int pid);
-extern int os_get_thread_area(user_desc_t *info, int pid);
-
 /* umid.c */
 extern int umid_file_name(char *name, char *buf, int len);
 extern int set_umid(char *name);

commit 00361683ce562402a189362f43370a459b166645
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:04:39 2011 +0100

    um: fill the handlers array at build time
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 598ca825ea9f..caa66619a9b4 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -225,7 +225,7 @@ extern char *get_umid(void);
 extern void timer_init(void);
 extern void set_sigstack(void *sig_stack, int size);
 extern void remove_sigstack(void);
-extern void set_handler(int sig, void (*handler)(int));
+extern void set_handler(int sig);
 extern int change_sig(int signal, int on);
 extern void block_signals(void);
 extern void unblock_signals(void);

commit e87df986ed053d25dbd57b8b137edec5022874f8
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:04:29 2011 +0100

    um: simplify set_handler()
    
    For one thing, we always block the same signals (IRQ ones - IO, WINCH, VTALRM),
    so there's no need to pass sa_mask elements in arguments.  For another, the
    flags depend only on whether it's an IRQ signal or not (we add SA_RESTART
    for them).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 2e2663a8e910..598ca825ea9f 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -225,7 +225,7 @@ extern char *get_umid(void);
 extern void timer_init(void);
 extern void set_sigstack(void *sig_stack, int size);
 extern void remove_sigstack(void);
-extern void set_handler(int sig, void (*handler)(int), int flags, ...);
+extern void set_handler(int sig, void (*handler)(int));
 extern int change_sig(int signal, int on);
 extern void block_signals(void);
 extern void unblock_signals(void);

commit 5d40de0f6e726dc9c48fb35815e0a6153e59e1dc
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:03:29 2011 +0100

    um: kill dead code around uaccess
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 83c7c2ecd614..2e2663a8e910 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -203,12 +203,6 @@ extern int os_drop_memory(void *addr, int length);
 extern int can_drop_memory(void);
 extern void os_flush_stdout(void);
 
-/* uaccess.c */
-extern unsigned long __do_user_copy(void *to, const void *from, int n,
-				    void **fault_addr, jmp_buf **fault_catcher,
-				    void (*op)(void *to, const void *from,
-					       int n), int *faulted_out);
-
 /* execvp.c */
 extern int execvp_noalloc(char *buf, const char *file, char *const argv[]);
 /* helper.c */

commit d634f194d4e2e58d57927c812aca097e67a2287d
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 24 17:13:01 2011 -0700

    um: add earlyprintk support
    
    User Mode Linux can also benefit from earlyprintk.  UML's earlyprintk
    writes kernel messages directly to stdout.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index f06a5da71a8f..83c7c2ecd614 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -244,6 +244,7 @@ extern int raw(int fd);
 extern void setup_machinename(char *machine_out);
 extern void setup_hostinfo(char *buf, int len);
 extern void os_dump_core(void) __attribute__ ((noreturn));
+extern void um_early_printk(const char *s, unsigned int n);
 
 /* time.c */
 extern void idle_sleep(unsigned long long nsecs);

commit 0ce451acb1872eab0fcf22753f93f51567e812fa
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 24 17:13:00 2011 -0700

    um: fix UML_LIB_PATH
    
    UML_LIB_PATH is hardcoded to /usr/lib/uml/, on 64bit systems UML_LIB_PATH
    needs to be /usr/lib64/uml/.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index c4617baaa4f2..f06a5da71a8f 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -29,6 +29,12 @@
 #define OS_ACC_R_OK    4       /* Test for read permission.  */
 #define OS_ACC_RW_OK   (OS_ACC_W_OK | OS_ACC_R_OK) /* Test for RW permission */
 
+#ifdef CONFIG_64BIT
+#define OS_LIB_PATH	"/usr/lib64/"
+#else
+#define OS_LIB_PATH	"/usr/lib/"
+#endif
+
 /*
  * types taken from stat_file() in hostfs_user.c
  * (if they are wrong here, they are wrong there...).

commit 005a59ec745d23f60222f7712adde48f64d7d3c8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 21 01:27:08 2009 -0400

    Deal with missing exports for hostfs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index cd40fddcf99d..c4617baaa4f2 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -161,6 +161,9 @@ extern int os_stat_filesystem(char *path, long *bsize_out,
 			      long *spare_out);
 extern int os_change_dir(char *dir);
 extern int os_fchange_dir(int fd);
+extern unsigned os_major(unsigned long long dev);
+extern unsigned os_minor(unsigned long long dev);
+extern unsigned long long os_makedev(unsigned major, unsigned minor);
 
 /* start_up.c */
 extern void os_early_checks(void);

commit ec82c32d45644998a28abad0a6a9ccdd721a054e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Aug 25 04:14:29 2008 -0400

    x86, um: get rid of arch/um/os symlink
    
    we can get DEV_NULL defined for arch/um/drivers/null.c in less
    convoluted ways, TYVM...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
index 2aaffa04fc8f..cd40fddcf99d 100644
--- a/arch/um/include/shared/os.h
+++ b/arch/um/include/shared/os.h
@@ -11,7 +11,6 @@
 #include "longjmp.h"
 #include "mm_id.h"
 #include "sysdep/tls.h"
-#include "../../os/include/file.h"
 
 #define CATCH_EINTR(expr) while ((errno = 0, ((expr) < 0)) && (errno == EINTR))
 

commit 8569c9140bd41089f9b6be8837ca421102714a90
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 17 13:48:37 2008 -0400

    x86, um: take arch/um/include/* out of the way
    
    We can't just plop asm/* into it - userland helpers are built with it
    in search path and seeing asm/* show up there suddenly would be a bad
    idea.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/arch/um/include/shared/os.h b/arch/um/include/shared/os.h
new file mode 100644
index 000000000000..2aaffa04fc8f
--- /dev/null
+++ b/arch/um/include/shared/os.h
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
+ * Licensed under the GPL
+ */
+
+#ifndef __OS_H__
+#define __OS_H__
+
+#include <stdarg.h>
+#include "irq_user.h"
+#include "longjmp.h"
+#include "mm_id.h"
+#include "sysdep/tls.h"
+#include "../../os/include/file.h"
+
+#define CATCH_EINTR(expr) while ((errno = 0, ((expr) < 0)) && (errno == EINTR))
+
+#define OS_TYPE_FILE 1
+#define OS_TYPE_DIR 2
+#define OS_TYPE_SYMLINK 3
+#define OS_TYPE_CHARDEV 4
+#define OS_TYPE_BLOCKDEV 5
+#define OS_TYPE_FIFO 6
+#define OS_TYPE_SOCK 7
+
+/* os_access() flags */
+#define OS_ACC_F_OK    0       /* Test for existence.  */
+#define OS_ACC_X_OK    1       /* Test for execute permission.  */
+#define OS_ACC_W_OK    2       /* Test for write permission.  */
+#define OS_ACC_R_OK    4       /* Test for read permission.  */
+#define OS_ACC_RW_OK   (OS_ACC_W_OK | OS_ACC_R_OK) /* Test for RW permission */
+
+/*
+ * types taken from stat_file() in hostfs_user.c
+ * (if they are wrong here, they are wrong there...).
+ */
+struct uml_stat {
+	int                ust_dev;        /* device */
+	unsigned long long ust_ino;        /* inode */
+	int                ust_mode;       /* protection */
+	int                ust_nlink;      /* number of hard links */
+	int                ust_uid;        /* user ID of owner */
+	int                ust_gid;        /* group ID of owner */
+	unsigned long long ust_size;       /* total size, in bytes */
+	int                ust_blksize;    /* blocksize for filesystem I/O */
+	unsigned long long ust_blocks;     /* number of blocks allocated */
+	unsigned long      ust_atime;      /* time of last access */
+	unsigned long      ust_mtime;      /* time of last modification */
+	unsigned long      ust_ctime;      /* time of last change */
+};
+
+struct openflags {
+	unsigned int r : 1;
+	unsigned int w : 1;
+	unsigned int s : 1;	/* O_SYNC */
+	unsigned int c : 1;	/* O_CREAT */
+	unsigned int t : 1;	/* O_TRUNC */
+	unsigned int a : 1;	/* O_APPEND */
+	unsigned int e : 1;	/* O_EXCL */
+	unsigned int cl : 1;    /* FD_CLOEXEC */
+};
+
+#define OPENFLAGS() ((struct openflags) { .r = 0, .w = 0, .s = 0, .c = 0, \
+					  .t = 0, .a = 0, .e = 0, .cl = 0 })
+
+static inline struct openflags of_read(struct openflags flags)
+{
+	flags.r = 1;
+	return flags;
+}
+
+static inline struct openflags of_write(struct openflags flags)
+{
+	flags.w = 1;
+	return flags;
+}
+
+static inline struct openflags of_rdwr(struct openflags flags)
+{
+	return of_read(of_write(flags));
+}
+
+static inline struct openflags of_set_rw(struct openflags flags, int r, int w)
+{
+	flags.r = r;
+	flags.w = w;
+	return flags;
+}
+
+static inline struct openflags of_sync(struct openflags flags)
+{
+	flags.s = 1;
+	return flags;
+}
+
+static inline struct openflags of_create(struct openflags flags)
+{
+	flags.c = 1;
+	return flags;
+}
+
+static inline struct openflags of_trunc(struct openflags flags)
+{
+	flags.t = 1;
+	return flags;
+}
+
+static inline struct openflags of_append(struct openflags flags)
+{
+	flags.a = 1;
+	return flags;
+}
+
+static inline struct openflags of_excl(struct openflags flags)
+{
+	flags.e = 1;
+	return flags;
+}
+
+static inline struct openflags of_cloexec(struct openflags flags)
+{
+	flags.cl = 1;
+	return flags;
+}
+
+/* file.c */
+extern int os_stat_file(const char *file_name, struct uml_stat *buf);
+extern int os_stat_fd(const int fd, struct uml_stat *buf);
+extern int os_access(const char *file, int mode);
+extern int os_set_exec_close(int fd);
+extern int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg);
+extern int os_get_ifname(int fd, char *namebuf);
+extern int os_set_slip(int fd);
+extern int os_mode_fd(int fd, int mode);
+
+extern int os_seek_file(int fd, unsigned long long offset);
+extern int os_open_file(const char *file, struct openflags flags, int mode);
+extern int os_read_file(int fd, void *buf, int len);
+extern int os_write_file(int fd, const void *buf, int count);
+extern int os_file_size(const char *file, unsigned long long *size_out);
+extern int os_file_modtime(const char *file, unsigned long *modtime);
+extern int os_pipe(int *fd, int stream, int close_on_exec);
+extern int os_set_fd_async(int fd);
+extern int os_clear_fd_async(int fd);
+extern int os_set_fd_block(int fd, int blocking);
+extern int os_accept_connection(int fd);
+extern int os_create_unix_socket(const char *file, int len, int close_on_exec);
+extern int os_shutdown_socket(int fd, int r, int w);
+extern void os_close_file(int fd);
+extern int os_rcv_fd(int fd, int *helper_pid_out);
+extern int create_unix_socket(char *file, int len, int close_on_exec);
+extern int os_connect_socket(const char *name);
+extern int os_file_type(char *file);
+extern int os_file_mode(const char *file, struct openflags *mode_out);
+extern int os_lock_file(int fd, int excl);
+extern void os_flush_stdout(void);
+extern int os_stat_filesystem(char *path, long *bsize_out,
+			      long long *blocks_out, long long *bfree_out,
+			      long long *bavail_out, long long *files_out,
+			      long long *ffree_out, void *fsid_out,
+			      int fsid_size, long *namelen_out,
+			      long *spare_out);
+extern int os_change_dir(char *dir);
+extern int os_fchange_dir(int fd);
+
+/* start_up.c */
+extern void os_early_checks(void);
+extern void can_do_skas(void);
+extern void os_check_bugs(void);
+extern void check_host_supports_tls(int *supports_tls, int *tls_min);
+
+/* mem.c */
+extern int create_mem_file(unsigned long long len);
+
+/* process.c */
+extern unsigned long os_process_pc(int pid);
+extern int os_process_parent(int pid);
+extern void os_stop_process(int pid);
+extern void os_kill_process(int pid, int reap_child);
+extern void os_kill_ptraced_process(int pid, int reap_child);
+extern long os_ptrace_ldt(long pid, long addr, long data);
+
+extern int os_getpid(void);
+extern int os_getpgrp(void);
+
+extern void init_new_thread_signals(void);
+extern int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr);
+
+extern int os_map_memory(void *virt, int fd, unsigned long long off,
+			 unsigned long len, int r, int w, int x);
+extern int os_protect_memory(void *addr, unsigned long len,
+			     int r, int w, int x);
+extern int os_unmap_memory(void *addr, int len);
+extern int os_drop_memory(void *addr, int length);
+extern int can_drop_memory(void);
+extern void os_flush_stdout(void);
+
+/* uaccess.c */
+extern unsigned long __do_user_copy(void *to, const void *from, int n,
+				    void **fault_addr, jmp_buf **fault_catcher,
+				    void (*op)(void *to, const void *from,
+					       int n), int *faulted_out);
+
+/* execvp.c */
+extern int execvp_noalloc(char *buf, const char *file, char *const argv[]);
+/* helper.c */
+extern int run_helper(void (*pre_exec)(void *), void *pre_data, char **argv);
+extern int run_helper_thread(int (*proc)(void *), void *arg,
+			     unsigned int flags, unsigned long *stack_out);
+extern int helper_wait(int pid);
+
+
+/* tls.c */
+extern int os_set_thread_area(user_desc_t *info, int pid);
+extern int os_get_thread_area(user_desc_t *info, int pid);
+
+/* umid.c */
+extern int umid_file_name(char *name, char *buf, int len);
+extern int set_umid(char *name);
+extern char *get_umid(void);
+
+/* signal.c */
+extern void timer_init(void);
+extern void set_sigstack(void *sig_stack, int size);
+extern void remove_sigstack(void);
+extern void set_handler(int sig, void (*handler)(int), int flags, ...);
+extern int change_sig(int signal, int on);
+extern void block_signals(void);
+extern void unblock_signals(void);
+extern int get_signals(void);
+extern int set_signals(int enable);
+
+/* util.c */
+extern void stack_protections(unsigned long address);
+extern int raw(int fd);
+extern void setup_machinename(char *machine_out);
+extern void setup_hostinfo(char *buf, int len);
+extern void os_dump_core(void) __attribute__ ((noreturn));
+
+/* time.c */
+extern void idle_sleep(unsigned long long nsecs);
+extern int set_interval(void);
+extern int timer_one_shot(int ticks);
+extern long long disable_timer(void);
+extern void uml_idle_timer(void);
+extern long long os_nsecs(void);
+
+/* skas/mem.c */
+extern long run_syscall_stub(struct mm_id * mm_idp,
+			     int syscall, unsigned long *args, long expected,
+			     void **addr, int done);
+extern long syscall_stub_data(struct mm_id * mm_idp,
+			      unsigned long *data, int data_count,
+			      void **addr, void **stub_addr);
+extern int map(struct mm_id * mm_idp, unsigned long virt,
+	       unsigned long len, int prot, int phys_fd,
+	       unsigned long long offset, int done, void **data);
+extern int unmap(struct mm_id * mm_idp, unsigned long addr, unsigned long len,
+		 int done, void **data);
+extern int protect(struct mm_id * mm_idp, unsigned long addr,
+		   unsigned long len, unsigned int prot, int done, void **data);
+
+/* skas/process.c */
+extern int is_skas_winch(int pid, int fd, void *data);
+extern int start_userspace(unsigned long stub_stack);
+extern int copy_context_skas0(unsigned long stack, int pid);
+extern void userspace(struct uml_pt_regs *regs);
+extern int map_stub_pages(int fd, unsigned long code, unsigned long data,
+			  unsigned long stack);
+extern void new_thread(void *stack, jmp_buf *buf, void (*handler)(void));
+extern void switch_threads(jmp_buf *me, jmp_buf *you);
+extern int start_idle_thread(void *stack, jmp_buf *switch_buf);
+extern void initial_thread_cb_skas(void (*proc)(void *),
+				 void *arg);
+extern void halt_skas(void);
+extern void reboot_skas(void);
+
+/* irq.c */
+extern int os_waiting_for_events(struct irq_fd *active_fds);
+extern int os_create_pollfd(int fd, int events, void *tmp_pfd, int size_tmpfds);
+extern void os_free_irq_by_cb(int (*test)(struct irq_fd *, void *), void *arg,
+		struct irq_fd *active_fds, struct irq_fd ***last_irq_ptr2);
+extern void os_free_irq_later(struct irq_fd *active_fds,
+		int irq, void *dev_id);
+extern int os_get_pollfd(int i);
+extern void os_set_pollfd(int i, int fd);
+extern void os_set_ioignore(void);
+
+/* sigio.c */
+extern int add_sigio_fd(int fd);
+extern int ignore_sigio_fd(int fd);
+extern void maybe_sigio_broken(int fd, int read);
+extern void sigio_broken(int fd, int read);
+
+/* sys-x86_64/prctl.c */
+extern int os_arch_prctl(int pid, int code, unsigned long *addr);
+
+/* tty.c */
+extern int get_pty(void);
+
+/* sys-$ARCH/task_size.c */
+extern unsigned long os_get_top_address(void);
+
+#endif
