commit 97870c34b453251cda9c2341f8534b78003a74dc
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:18 2019 +0100

    um: Add SPDX headers for files in arch/um/os-Linux
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index b3e0d40932e1..e52dd37ddadc 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2015 Thomas Meyer (thomas@m3y3r.de)
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <stdio.h>

commit 2eb5f31bc4ea24bb293e82934cfa1cce9573304b
Author: Anton Ivanov <aivanov@brocade.com>
Date:   Mon Nov 2 16:16:37 2015 +0000

    um: Switch clocksource to hrtimers
    
    UML is using an obsolete itimer call for
    all timers and "polls" for kernel space timer firing
    in its userspace portion resulting in a long list
    of bugs and incorrect behaviour(s). It also uses
    ITIMER_VIRTUAL for its timer which results in the
    timer being dependent on it running and the cpu
    load.
    
    This patch fixes this by moving to posix high resolution
    timers firing off CLOCK_MONOTONIC and relaying the timer
    correctly to the UML userspace.
    
    Fixes:
     - crashes when hosts suspends/resumes
     - broken userspace timers - effecive ~40Hz instead
       of what they should be. Note - this modifies skas behavior
       by no longer setting an itimer per clone(). Timer events
       are relayed instead.
     - kernel network packet scheduling disciplines
     - tcp behaviour especially under load
     - various timer related corner cases
    
    Finally, overall responsiveness of userspace is better.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Anton Ivanov <aivanov@brocade.com>
    [rw: massaged commit message]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 8408aba915b2..b3e0d40932e1 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2015 Thomas Meyer (thomas@m3y3r.de)
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
@@ -89,6 +90,11 @@ int os_process_parent(int pid)
 	return parent;
 }
 
+void os_alarm_process(int pid)
+{
+	kill(pid, SIGALRM);
+}
+
 void os_stop_process(int pid)
 {
 	kill(pid, SIGSTOP);

commit d0b5e15f0c0fdd759dd3dd48dc2dc2e7199e0da0
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Mar 18 21:31:27 2015 +0100

    um: Remove SKAS3/4 support
    
    Before we had SKAS0 UML had two modes of operation
    TT (tracing thread) and SKAS3/4 (separated kernel address space).
    TT was known to be insecure and got removed a long time ago.
    SKAS3/4 required a few (3 or 4) patches on the host side which never went
    mainline. The last host patch is 10 years old.
    
    With SKAS0 mode (separated kernel address space using 0 host patches),
    default since 2005, SKAS3/4 is obsolete and can be removed.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 33496fe2bb52..8408aba915b2 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -16,7 +16,6 @@
 #include <init.h>
 #include <longjmp.h>
 #include <os.h>
-#include <skas_ptrace.h>
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -102,21 +101,6 @@ void os_kill_process(int pid, int reap_child)
 		CATCH_EINTR(waitpid(pid, NULL, __WALL));
 }
 
-/* This is here uniquely to have access to the userspace errno, i.e. the one
- * used by ptrace in case of error.
- */
-
-long os_ptrace_ldt(long pid, long addr, long data)
-{
-	int ret;
-
-	ret = ptrace(PTRACE_LDT, pid, addr, data);
-
-	if (ret < 0)
-		return -errno;
-	return ret;
-}
-
 /* Kill off a ptraced child by all means available.  kill it normally first,
  * then PTRACE_KILL it, then PTRACE_CONT it in case it's in a run state from
  * which it can't exit directly.

commit 91d44ff860a9e9c0db81a89cbc24fa31fbd8e6d3
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Aug 18 13:30:08 2013 +0200

    um: Cleanup SIGTERM handling
    
    Richard reported that some UML processes survive if the UML
    main process receives a SIGTERM.
    This issue was caused by a wrongly placed signal(SIGTERM, SIG_DFL)
    in init_new_thread_signals().
    It disabled the UML exit handler accidently for some processes.
    The correct solution is to disable the fatal handler for all
    UML helper threads/processes.
    Such that last_ditch_exit() does not get called multiple times
    and all processes can exit due to SIGTERM.
    
    Reported-and-tested-by: Richard W.M. Jones <rjones@redhat.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 67b9c8f5a89e..33496fe2bb52 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -294,5 +294,4 @@ void init_new_thread_signals(void)
 	signal(SIGHUP, SIG_IGN);
 	set_handler(SIGIO);
 	signal(SIGWINCH, SIG_IGN);
-	signal(SIGTERM, SIG_DFL);
 }

commit f75b1b1bedfb498cc43a992ce4d7ed8df3b1e770
Author: Richard Weinberger <richard@nod.at>
Date:   Sat Aug 17 18:46:00 2013 +0200

    um: Implement probe_kernel_read()
    
    UML needs it's own probe_kernel_read() to handle kernel
    mode faults correctly.
    The implementation uses mincore() on the host side to detect
    whether a page is owned by the UML kernel process.
    
    This fixes also a possible crash when sysrq-t is used.
    Starting with 3.10 sysrq-t calls probe_kernel_read() to
    read details from the kernel workers. As kernel worker are
    completely async pointers may turn NULL while reading them.
    
    Cc: <stian@nixia.no>
    Cc: <tj@kernel.org>
    Cc: <stable@vger.kernel.org> # 3.10.x
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index b8f34c9e53ae..67b9c8f5a89e 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -4,6 +4,7 @@
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
 #include <signal.h>
@@ -232,6 +233,57 @@ int __init can_drop_memory(void)
 	return ok;
 }
 
+static int os_page_mincore(void *addr)
+{
+	char vec[2];
+	int ret;
+
+	ret = mincore(addr, UM_KERN_PAGE_SIZE, vec);
+	if (ret < 0) {
+		if (errno == ENOMEM || errno == EINVAL)
+			return 0;
+		else
+			return -errno;
+	}
+
+	return vec[0] & 1;
+}
+
+int os_mincore(void *addr, unsigned long len)
+{
+	char *vec;
+	int ret, i;
+
+	if (len <= UM_KERN_PAGE_SIZE)
+		return os_page_mincore(addr);
+
+	vec = calloc(1, (len + UM_KERN_PAGE_SIZE - 1) / UM_KERN_PAGE_SIZE);
+	if (!vec)
+		return -ENOMEM;
+
+	ret = mincore(addr, UM_KERN_PAGE_SIZE, vec);
+	if (ret < 0) {
+		if (errno == ENOMEM || errno == EINVAL)
+			ret = 0;
+		else
+			ret = -errno;
+
+		goto out;
+	}
+
+	for (i = 0; i < ((len + UM_KERN_PAGE_SIZE - 1) / UM_KERN_PAGE_SIZE); i++) {
+		if (!(vec[i] & 1)) {
+			ret = 0;
+			goto out;
+		}
+	}
+
+	ret = 1;
+out:
+	free(vec);
+	return ret;
+}
+
 void init_new_thread_signals(void)
 {
 	set_handler(SIGSEGV);

commit 4e21fc138bfd7fe625ff5dc81541399aaf9d429b
Merge: 8418263e3547 5522be6a4624
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 13 10:05:52 2012 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal
    
    Pull third pile of kernel_execve() patches from Al Viro:
     "The last bits of infrastructure for kernel_thread() et.al., with
      alpha/arm/x86 use of those.  Plus sanitizing the asm glue and
      do_notify_resume() on alpha, fixing the "disabled irq while running
      task_work stuff" breakage there.
    
      At that point the rest of kernel_thread/kernel_execve/sys_execve work
      can be done independently for different architectures.  The only
      pending bits that do depend on having all architectures converted are
      restrictred to fs/* and kernel/* - that'll obviously have to wait for
      the next cycle.
    
      I thought we'd have to wait for all of them done before we start
      eliminating the longjump-style insanity in kernel_execve(), but it
      turned out there's a very simple way to do that without flagday-style
      changes."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal:
      alpha: switch to saner kernel_execve() semantics
      arm: switch to saner kernel_execve() semantics
      x86, um: convert to saner kernel_execve() semantics
      infrastructure for saner ret_from_kernel_thread semantics
      make sure that kernel_thread() callbacks call do_exit() themselves
      make sure that we always have a return path from kernel_execve()
      ppc: eeh_event should just use kthread_run()
      don't bother with kernel_thread/kernel_execve for launching linuxrc
      alpha: get rid of switch_stack argument of do_work_pending()
      alpha: don't bother passing switch_stack separately from regs
      alpha: take SIGPENDING/NOTIFY_RESUME loop into signal.c
      alpha: simplify TIF_NEED_RESCHED handling

commit 22e2430d60dbdfcdd732a086e9ef2dbd74c266d1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 10 21:35:42 2012 -0400

    x86, um: convert to saner kernel_execve() semantics
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 307f173e7f82..a04ec167a9c3 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -244,16 +244,3 @@ void init_new_thread_signals(void)
 	signal(SIGWINCH, SIG_IGN);
 	signal(SIGTERM, SIG_DFL);
 }
-
-int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr)
-{
-	jmp_buf buf;
-	int n;
-
-	*jmp_ptr = &buf;
-	n = UML_SETJMP(&buf);
-	if (n != 0)
-		return n;
-	(*fn)(arg);
-	return 0;
-}

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 307f173e7f82..162bea3d91b2 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -12,10 +12,10 @@
 #include <sys/ptrace.h>
 #include <sys/wait.h>
 #include <asm/unistd.h>
-#include "init.h"
-#include "longjmp.h"
-#include "os.h"
-#include "skas_ptrace.h"
+#include <init.h>
+#include <longjmp.h>
+#include <os.h>
+#include <skas_ptrace.h>
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1

commit 0de021f797e7bd785796071aab8e14827c87d6bf
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:05:29 2011 +0100

    um: shared/process.h is empty now; kill it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index e08fe305beb1..307f173e7f82 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -15,7 +15,6 @@
 #include "init.h"
 #include "longjmp.h"
 #include "os.h"
-#include "process.h"
 #include "skas_ptrace.h"
 
 #define ARBITRARY_ADDR -1

commit 00361683ce562402a189362f43370a459b166645
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:04:39 2011 +0100

    um: fill the handlers array at build time
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 075ae920143d..e08fe305beb1 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -235,13 +235,13 @@ int __init can_drop_memory(void)
 
 void init_new_thread_signals(void)
 {
-	set_handler(SIGSEGV, (__sighandler_t) sig_handler);
-	set_handler(SIGTRAP, (__sighandler_t) sig_handler);
-	set_handler(SIGFPE, (__sighandler_t) sig_handler);
-	set_handler(SIGILL, (__sighandler_t) sig_handler);
-	set_handler(SIGBUS, (__sighandler_t) sig_handler);
+	set_handler(SIGSEGV);
+	set_handler(SIGTRAP);
+	set_handler(SIGFPE);
+	set_handler(SIGILL);
+	set_handler(SIGBUS);
 	signal(SIGHUP, SIG_IGN);
-	set_handler(SIGIO, (__sighandler_t) sig_handler);
+	set_handler(SIGIO);
 	signal(SIGWINCH, SIG_IGN);
 	signal(SIGTERM, SIG_DFL);
 }

commit e87df986ed053d25dbd57b8b137edec5022874f8
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:04:29 2011 +0100

    um: simplify set_handler()
    
    For one thing, we always block the same signals (IRQ ones - IO, WINCH, VTALRM),
    so there's no need to pass sa_mask elements in arguments.  For another, the
    flags depend only on whether it's an IRQ signal or not (we add SA_RESTART
    for them).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index c1a8fa74ebb9..075ae920143d 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -235,20 +235,13 @@ int __init can_drop_memory(void)
 
 void init_new_thread_signals(void)
 {
-	set_handler(SIGSEGV, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGIO, SIGWINCH, SIGVTALRM, -1);
-	set_handler(SIGTRAP, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGIO, SIGWINCH, SIGVTALRM, -1);
-	set_handler(SIGFPE, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGIO, SIGWINCH, SIGVTALRM, -1);
-	set_handler(SIGILL, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGIO, SIGWINCH, SIGVTALRM, -1);
-	set_handler(SIGBUS, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGIO, SIGWINCH, SIGVTALRM, -1);
+	set_handler(SIGSEGV, (__sighandler_t) sig_handler);
+	set_handler(SIGTRAP, (__sighandler_t) sig_handler);
+	set_handler(SIGFPE, (__sighandler_t) sig_handler);
+	set_handler(SIGILL, (__sighandler_t) sig_handler);
+	set_handler(SIGBUS, (__sighandler_t) sig_handler);
 	signal(SIGHUP, SIG_IGN);
-
-	set_handler(SIGIO, (__sighandler_t) sig_handler,
-		    SA_ONSTACK | SA_RESTART, SIGIO, SIGWINCH, SIGVTALRM, -1);
+	set_handler(SIGIO, (__sighandler_t) sig_handler);
 	signal(SIGWINCH, SIG_IGN);
 	signal(SIGTERM, SIG_DFL);
 }

commit d5c7e8b4ec4795ed0b8943cad8f87801fde371d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:04:19 2011 +0100

    um: don't bother blocking SIGARLM and SIGUSR1
    
    We used to generate those, but we hadn't done that for a long
    time.  No need to bother blocking them for signal handlers.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 0ced30cd4ab8..c1a8fa74ebb9 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -236,20 +236,19 @@ int __init can_drop_memory(void)
 void init_new_thread_signals(void)
 {
 	set_handler(SIGSEGV, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
+		    SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGTRAP, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
+		    SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGFPE, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
+		    SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGILL, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
+		    SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGBUS, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
+		    SIGIO, SIGWINCH, SIGVTALRM, -1);
 	signal(SIGHUP, SIG_IGN);
 
 	set_handler(SIGIO, (__sighandler_t) sig_handler,
-		    SA_ONSTACK | SA_RESTART, SIGUSR1, SIGIO, SIGWINCH, SIGALRM,
-		    SIGVTALRM, -1);
+		    SA_ONSTACK | SA_RESTART, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	signal(SIGWINCH, SIG_IGN);
 	signal(SIGTERM, SIG_DFL);
 }

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 0c45dc8efb05..0ced30cd4ab8 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -13,12 +13,10 @@
 #include <sys/wait.h>
 #include <asm/unistd.h>
 #include "init.h"
-#include "kern_constants.h"
 #include "longjmp.h"
 #include "os.h"
 #include "process.h"
 #include "skas_ptrace.h"
-#include "user.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1

commit db271cf03f5fe39feab8e1b1818c0880c7290c5c
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 24 17:13:04 2011 -0700

    um: fix crash while os_dump_core()
    
    os_dump_core() emits SIGTERM to terminate all UML processes.  Kernel
    threads have to exit on SIGTERM instead of calling last_ditch_exit().
    Multiple calls to last_ditch_exit() can cause a crash.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index e0477c3ee894..0c45dc8efb05 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -253,6 +253,7 @@ void init_new_thread_signals(void)
 		    SA_ONSTACK | SA_RESTART, SIGUSR1, SIGIO, SIGWINCH, SIGALRM,
 		    SIGVTALRM, -1);
 	signal(SIGWINCH, SIG_IGN);
+	signal(SIGTERM, SIG_DFL);
 }
 
 int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr)

commit 5134d8fea06ab51459fd095d091d1e6f73a44553
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Feb 8 04:22:08 2008 -0800

    uml: style fixes in arch/um/os-Linux
    
    Style changes under arch/um/os-Linux:
            include trimming
            CodingStyle fixes
            some printks needed severity indicators
    
    make_tempfile turns out not to be used outside of mem.c, so it is now static.
    Its declaration in tempfile.h is no longer needed, and tempfile.h itself is no
    longer needed.
    
    create_tmp_file was also made static.
    
    checkpatch moans about an EXPORT_SYMBOL in user_syms.c which is part of a
    macro definition - this is copying a bit of kernel infrastructure into the
    libc side of UML because the kernel headers can't be included there.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index abf6beae3df1..e0477c3ee894 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -224,7 +224,7 @@ int __init can_drop_memory(void)
 		goto out_unmap;
 	}
 
-	printk("OK\n");
+	printk(UM_KERN_CONT "OK\n");
 	ok = 1;
 
 out_unmap:

commit 3a24ebf0cb2ca44fdcdb5cae9ed2e778e5170f97
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:16 2008 -0800

    uml: remove init_irq_signals
    
    init_irq_signals doesn't need to be called from the context of a new process.
    It initializes handlers, which are useless in process context.  With that call
    gone, init_irq_signals has only one caller, so it can be inlined into
    init_new_thread_signals.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index bda5c3150d6c..abf6beae3df1 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -249,7 +249,10 @@ void init_new_thread_signals(void)
 		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	signal(SIGHUP, SIG_IGN);
 
-	init_irq_signals(1);
+	set_handler(SIGIO, (__sighandler_t) sig_handler,
+		    SA_ONSTACK | SA_RESTART, SIGUSR1, SIGIO, SIGWINCH, SIGALRM,
+		    SIGVTALRM, -1);
+	signal(SIGWINCH, SIG_IGN);
 }
 
 int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr)

commit 4dbed85a35ed37d9608f4f32e5d69efa775d6223
Author: Stanislaw Gruszka <stf_xl@wp.pl>
Date:   Mon Dec 17 16:19:46 2007 -0800

    uml: stop gdb from deleting breakpoints when running UML
    
    Sometimes when UML is debugged gdb miss breakpoints.
    
    When process traced by gdb do fork, debugger remove breakpoints from
    child address space. There is possibility to trace more than one fork,
    but this not work with UML, I guess (only guess) there is a deadlock -
    gdb waits for UML and UML waits for gdb.
    
    When clone() is called with SIGCHLD and CLONE_VM flags, gdb see this
    as PTRACE_EVENT_FORK not as PTRACE_EVENT_CLONE and remove breakpoints
    from child and at the same time from traced process, because either
    have the same address space.
    
    Maybe it is possible to do fix in gdb, but I'm not sure if there is
    easy way to find out if traced and child processes share memory. So I
    do fix for UML, it simply do not call clone() with both SIGCHLD and
    CLONE_VM flags together.  Additionally __WALL flag is used for
    waitpid() to assure not miss clone and normal process events.
    
    [ jdike - checkpatch fixes ]
    
    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 37781db4ceca..bda5c3150d6c 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -101,7 +101,7 @@ void os_kill_process(int pid, int reap_child)
 {
 	kill(pid, SIGKILL);
 	if (reap_child)
-		CATCH_EINTR(waitpid(pid, NULL, 0));
+		CATCH_EINTR(waitpid(pid, NULL, __WALL));
 }
 
 /* This is here uniquely to have access to the userspace errno, i.e. the one
@@ -130,7 +130,7 @@ void os_kill_ptraced_process(int pid, int reap_child)
 	ptrace(PTRACE_KILL, pid);
 	ptrace(PTRACE_CONT, pid);
 	if (reap_child)
-		CATCH_EINTR(waitpid(pid, NULL, 0));
+		CATCH_EINTR(waitpid(pid, NULL, __WALL));
 }
 
 /* Don't use the glibc version, which caches the result in TLS. It misses some

commit 61b63c556c0877ee6d3832ee641bc427ff4d94d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:27 2007 -0700

    uml: eliminate SIGALRM
    
    Now that ITIMER_REAL is no longer used, there is no need for any use of
    SIGALRM whatsoever.  This patch removes all mention of it.
    
    In addition, real_alarm_handler took a signal argument which is now always
    SIGVTALRM.  So, that is gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 90b480cf78f4..37781db4ceca 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -238,15 +238,15 @@ int __init can_drop_memory(void)
 void init_new_thread_signals(void)
 {
 	set_handler(SIGSEGV, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGTRAP, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGFPE, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGILL, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	set_handler(SIGBUS, (__sighandler_t) sig_handler, SA_ONSTACK,
-		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SIGUSR1, SIGIO, SIGWINCH, SIGVTALRM, -1);
 	signal(SIGHUP, SIG_IGN);
 
 	init_irq_signals(1);

commit 512b6fb1c14d4c34f23a3419b0789ad01914a899
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:11 2007 -0700

    uml: userspace files should call libc directly
    
    A number of files that were changed in the recent removal of tt mode
    are userspace files which call the os_* wrappers instead of calling
    libc directly.  A few other files were affected by this, through
    
    This patch makes these call glibc directly.
    
    There are also style fixes in the affected areas.
    
    os_print_error has no remaining callers, so it is deleted.
    
    There is a interface change to os_set_exec_close, eliminating a
    parameter which was always the same.  The callers are fixed as well.
    
    os_process_pc got its error path cleaned up.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 8b57eb3647f5..90b480cf78f4 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -7,6 +7,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <signal.h>
+#include <fcntl.h>
 #include <sys/mman.h>
 #include <sys/ptrace.h>
 #include <sys/wait.h>
@@ -28,31 +29,32 @@
 unsigned long os_process_pc(int pid)
 {
 	char proc_stat[STAT_PATH_LEN], buf[256];
-	unsigned long pc;
+	unsigned long pc = ARBITRARY_ADDR;
 	int fd, err;
 
 	sprintf(proc_stat, "/proc/%d/stat", pid);
-	fd = os_open_file(proc_stat, of_read(OPENFLAGS()), 0);
+	fd = open(proc_stat, O_RDONLY, 0);
 	if (fd < 0) {
 		printk(UM_KERN_ERR "os_process_pc - couldn't open '%s', "
-		       "err = %d\n", proc_stat, -fd);
-		return ARBITRARY_ADDR;
+		       "errno = %d\n", proc_stat, errno);
+		goto out;
 	}
 	CATCH_EINTR(err = read(fd, buf, sizeof(buf)));
 	if (err < 0) {
 		printk(UM_KERN_ERR "os_process_pc - couldn't read '%s', "
 		       "err = %d\n", proc_stat, errno);
-		os_close_file(fd);
-		return ARBITRARY_ADDR;
+		goto out_close;
 	}
 	os_close_file(fd);
 	pc = ARBITRARY_ADDR;
 	if (sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d "
-		  "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
-		  "%*d %*d %*d %*d %*d %lu", &pc) != 1) {
+		   "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
+		   "%*d %*d %*d %*d %*d %lu", &pc) != 1)
 		printk(UM_KERN_ERR "os_process_pc - couldn't find pc in '%s'\n",
 		       buf);
-	}
+ out_close:
+	close(fd);
+ out:
 	return pc;
 }
 
@@ -60,25 +62,26 @@ int os_process_parent(int pid)
 {
 	char stat[STAT_PATH_LEN];
 	char data[256];
-	int parent, n, fd;
+	int parent = FAILURE_PID, n, fd;
 
 	if (pid == -1)
-		return -1;
+		return parent;
 
 	snprintf(stat, sizeof(stat), "/proc/%d/stat", pid);
-	fd = os_open_file(stat, of_read(OPENFLAGS()), 0);
+	fd = open(stat, O_RDONLY, 0);
 	if (fd < 0) {
-		printk(UM_KERN_ERR "Couldn't open '%s', err = %d\n", stat, -fd);
-		return FAILURE_PID;
+		printk(UM_KERN_ERR "Couldn't open '%s', errno = %d\n", stat,
+		       errno);
+		return parent;
 	}
 
 	CATCH_EINTR(n = read(fd, data, sizeof(data)));
-	os_close_file(fd);
+	close(fd);
 
 	if (n < 0) {
-		printk(UM_KERN_ERR "Couldn't read '%s', err = %d\n", stat,
+		printk(UM_KERN_ERR "Couldn't read '%s', errno = %d\n", stat,
 		       errno);
-		return FAILURE_PID;
+		return parent;
 	}
 
 	parent = FAILURE_PID;

commit fab95c55e3b94e219044dc7a558632d08c198771
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:05 2007 -0700

    uml: get rid of do_longjmp
    
    do_longjmp used to be needed when UML didn't have its own implementation of
    setjmp and longjmp.  They came from libc, and couldn't be called directly from
    kernel code, as the libc jmp_buf couldn't be imported there.  do_longjmp was a
    userspace function which served to provide longjmp access to kernel code.
    
    This is gone, and a number of void * pointers can now be jmp_buf *.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index b2e0d8c4258c..8b57eb3647f5 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -249,7 +249,7 @@ void init_new_thread_signals(void)
 	init_irq_signals(1);
 }
 
-int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
+int run_kernel_thread(int (*fn)(void *), void *arg, jmp_buf **jmp_ptr)
 {
 	jmp_buf buf;
 	int n;

commit ba180fd437156f7fd8cfb2fdd021d949eeef08d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:00 2007 -0700

    uml: style fixes pass 3
    
    Formatting changes in the files which have been changed in the course
    of folding foo_skas functions into their callers.  These include:
            copyright updates
            header file trimming
            style fixes
            adding severity to printks
    
    These changes should be entirely non-functional.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index a955e9bcd04d..b2e0d8c4258c 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -1,27 +1,23 @@
-/* 
- * Copyright (C) 2002 Jeff Dike (jdike@addtoit.com)
+/*
+ * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
-#include <unistd.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <errno.h>
 #include <signal.h>
 #include <sys/mman.h>
+#include <sys/ptrace.h>
 #include <sys/wait.h>
-#include <sys/mman.h>
-#include <sys/syscall.h>
-#include "ptrace_user.h"
+#include <asm/unistd.h>
+#include "init.h"
+#include "kern_constants.h"
+#include "longjmp.h"
 #include "os.h"
-#include "user.h"
 #include "process.h"
-#include "irq_user.h"
-#include "kern_util.h"
-#include "longjmp.h"
 #include "skas_ptrace.h"
-#include "kern_constants.h"
-#include "uml-config.h"
-#include "init.h"
+#include "user.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -37,24 +33,25 @@ unsigned long os_process_pc(int pid)
 
 	sprintf(proc_stat, "/proc/%d/stat", pid);
 	fd = os_open_file(proc_stat, of_read(OPENFLAGS()), 0);
-	if(fd < 0){
-		printk("os_process_pc - couldn't open '%s', err = %d\n",
-		       proc_stat, -fd);
+	if (fd < 0) {
+		printk(UM_KERN_ERR "os_process_pc - couldn't open '%s', "
+		       "err = %d\n", proc_stat, -fd);
 		return ARBITRARY_ADDR;
 	}
 	CATCH_EINTR(err = read(fd, buf, sizeof(buf)));
-	if(err < 0){
-		printk("os_process_pc - couldn't read '%s', err = %d\n",
-		       proc_stat, errno);
+	if (err < 0) {
+		printk(UM_KERN_ERR "os_process_pc - couldn't read '%s', "
+		       "err = %d\n", proc_stat, errno);
 		os_close_file(fd);
 		return ARBITRARY_ADDR;
 	}
 	os_close_file(fd);
 	pc = ARBITRARY_ADDR;
-	if(sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d "
+	if (sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d "
 		  "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
-		  "%*d %*d %*d %*d %*d %lu", &pc) != 1){
-		printk("os_process_pc - couldn't find pc in '%s'\n", buf);
+		  "%*d %*d %*d %*d %*d %lu", &pc) != 1) {
+		printk(UM_KERN_ERR "os_process_pc - couldn't find pc in '%s'\n",
+		       buf);
 	}
 	return pc;
 }
@@ -65,28 +62,29 @@ int os_process_parent(int pid)
 	char data[256];
 	int parent, n, fd;
 
-	if(pid == -1)
+	if (pid == -1)
 		return -1;
 
 	snprintf(stat, sizeof(stat), "/proc/%d/stat", pid);
 	fd = os_open_file(stat, of_read(OPENFLAGS()), 0);
-	if(fd < 0){
-		printk("Couldn't open '%s', err = %d\n", stat, -fd);
+	if (fd < 0) {
+		printk(UM_KERN_ERR "Couldn't open '%s', err = %d\n", stat, -fd);
 		return FAILURE_PID;
 	}
 
 	CATCH_EINTR(n = read(fd, data, sizeof(data)));
 	os_close_file(fd);
 
-	if(n < 0){
-		printk("Couldn't read '%s', err = %d\n", stat, errno);
+	if (n < 0) {
+		printk(UM_KERN_ERR "Couldn't read '%s', err = %d\n", stat,
+		       errno);
 		return FAILURE_PID;
 	}
 
 	parent = FAILURE_PID;
 	n = sscanf(data, "%*d " COMM_SCANF " %*c %d", &parent);
-	if(n != 1)
-		printk("Failed to scan '%s'\n", data);
+	if (n != 1)
+		printk(UM_KERN_ERR "Failed to scan '%s'\n", data);
 
 	return parent;
 }
@@ -99,9 +97,8 @@ void os_stop_process(int pid)
 void os_kill_process(int pid, int reap_child)
 {
 	kill(pid, SIGKILL);
-	if(reap_child)
+	if (reap_child)
 		CATCH_EINTR(waitpid(pid, NULL, 0));
-		
 }
 
 /* This is here uniquely to have access to the userspace errno, i.e. the one
@@ -129,7 +126,7 @@ void os_kill_ptraced_process(int pid, int reap_child)
 	kill(pid, SIGKILL);
 	ptrace(PTRACE_KILL, pid);
 	ptrace(PTRACE_CONT, pid);
-	if(reap_child)
+	if (reap_child)
 		CATCH_EINTR(waitpid(pid, NULL, 0));
 }
 
@@ -153,34 +150,35 @@ int os_map_memory(void *virt, int fd, unsigned long long off, unsigned long len,
 	void *loc;
 	int prot;
 
-	prot = (r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) | 
+	prot = (r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) |
 		(x ? PROT_EXEC : 0);
 
 	loc = mmap64((void *) virt, len, prot, MAP_SHARED | MAP_FIXED,
 		     fd, off);
-	if(loc == MAP_FAILED)
+	if (loc == MAP_FAILED)
 		return -errno;
 	return 0;
 }
 
 int os_protect_memory(void *addr, unsigned long len, int r, int w, int x)
 {
-        int prot = ((r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) | 
+	int prot = ((r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) |
 		    (x ? PROT_EXEC : 0));
 
-        if(mprotect(addr, len, prot) < 0)
+	if (mprotect(addr, len, prot) < 0)
 		return -errno;
-        return 0;
+
+	return 0;
 }
 
 int os_unmap_memory(void *addr, int len)
 {
-        int err;
+	int err;
 
-        err = munmap(addr, len);
-	if(err < 0)
+	err = munmap(addr, len);
+	if (err < 0)
 		return -errno;
-        return 0;
+	return 0;
 }
 
 #ifndef MADV_REMOVE
@@ -192,7 +190,7 @@ int os_drop_memory(void *addr, int length)
 	int err;
 
 	err = madvise(addr, length, MADV_REMOVE);
-	if(err < 0)
+	if (err < 0)
 		err = -errno;
 	return err;
 }
@@ -202,22 +200,24 @@ int __init can_drop_memory(void)
 	void *addr;
 	int fd, ok = 0;
 
-	printk("Checking host MADV_REMOVE support...");
+	printk(UM_KERN_INFO "Checking host MADV_REMOVE support...");
 	fd = create_mem_file(UM_KERN_PAGE_SIZE);
-	if(fd < 0){
-		printk("Creating test memory file failed, err = %d\n", -fd);
+	if (fd < 0) {
+		printk(UM_KERN_ERR "Creating test memory file failed, "
+		       "err = %d\n", -fd);
 		goto out;
 	}
 
 	addr = mmap64(NULL, UM_KERN_PAGE_SIZE, PROT_READ | PROT_WRITE,
 		      MAP_SHARED, fd, 0);
-	if(addr == MAP_FAILED){
-		printk("Mapping test memory file failed, err = %d\n", -errno);
+	if (addr == MAP_FAILED) {
+		printk(UM_KERN_ERR "Mapping test memory file failed, "
+		       "err = %d\n", -errno);
 		goto out_close;
 	}
 
-	if(madvise(addr, UM_KERN_PAGE_SIZE, MADV_REMOVE) != 0){
-		printk("MADV_REMOVE failed, err = %d\n", -errno);
+	if (madvise(addr, UM_KERN_PAGE_SIZE, MADV_REMOVE) != 0) {
+		printk(UM_KERN_ERR "MADV_REMOVE failed, err = %d\n", -errno);
 		goto out_unmap;
 	}
 
@@ -256,7 +256,7 @@ int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
 
 	*jmp_ptr = &buf;
 	n = UML_SETJMP(&buf);
-	if(n != 0)
+	if (n != 0)
 		return n;
 	(*fn)(arg);
 	return 0;

commit 77bf4400319db9d2a8af6b00c2be6faa0f3d07cb
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:58 2007 -0700

    uml: remove code made redundant by CHOOSE_MODE removal
    
    This patch makes a number of simplifications enabled by the removal of
    CHOOSE_MODE.  There were lots of functions that looked like
    
            int foo(args){
                    foo_skas(args);
            }
    
    The bodies of foo_skas are now folded into foo, and their declarations (and
    sometimes entire header files) are deleted.
    
    In addition, the union uml_pt_regs, which was a union between the tt and skas
    register formats, is now a struct, with the tt-mode arm of the union being
    removed.
    
    It turns out that usr2_handler was unused, so it is gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index d5fef4ce0112..a955e9bcd04d 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -244,9 +244,6 @@ void init_new_thread_signals(void)
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
 	set_handler(SIGBUS, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
-	set_handler(SIGUSR2, (__sighandler_t) sig_handler,
-		    SA_ONSTACK, SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM,
-		    -1);
 	signal(SIGHUP, SIG_IGN);
 
 	init_irq_signals(1);

commit 42fda66387daa53538ae13a2c858396aaf037158
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:50 2007 -0700

    uml: throw out CONFIG_MODE_TT
    
    This patchset throws out tt mode, which has been non-functional for a while.
    
    This is done in phases, interspersed with code cleanups on the affected files.
    
    The removal is done as follows:
            remove all code, config options, and files which depend on
    CONFIG_MODE_TT
            get rid of the CHOOSE_MODE macro, which decided whether to
    call tt-mode or skas-mode code, and replace invocations with their
    skas portions
            replace all now-trivial procedures with their skas equivalents
    
    There are now a bunch of now-redundant pieces of data structures, including
    mode-specific pieces of the thread structure, pt_regs, and mm_context.  These
    are all replaced with their skas-specific contents.
    
    As part of the ongoing style compliance project, I made a style pass over all
    files that were changed.  There are three such patches, one for each phase,
    covering the files affected by that phase but no later ones.
    
    I noticed that we weren't freeing the LDT state associated with a process when
    it exited, so that's fixed in one of the later patches.
    
    The last patch is a tidying patch which I've had for a while, but which caused
    inexplicable crashes under tt mode.  Since that is no longer a problem, this
    can now go in.
    
    This patch:
    
    Start getting rid of tt mode support.
    
    This patch throws out CONFIG_MODE_TT and all config options, code, and files
    which depend on it.
    
    CONFIG_MODE_SKAS is gone and everything that depends on it is included
    unconditionally.
    
    The few changed lines are in re-written Kconfig help, lines which needed
    something skas-related removed from them, and a few more which weren't
    strictly deletions.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index e9c143297512..d5fef4ce0112 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -133,13 +133,6 @@ void os_kill_ptraced_process(int pid, int reap_child)
 		CATCH_EINTR(waitpid(pid, NULL, 0));
 }
 
-#ifdef UML_CONFIG_MODE_TT
-void os_usr1_process(int pid)
-{
-	kill(pid, SIGUSR1);
-}
-#endif
-
 /* Don't use the glibc version, which caches the result in TLS. It misses some
  * syscalls, and also breaks with clone(), which does not unshare the TLS.
  */
@@ -239,30 +232,6 @@ int __init can_drop_memory(void)
 	return ok;
 }
 
-#ifdef UML_CONFIG_MODE_TT
-void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
-{
-	int flags = 0, pages;
-
-	if(sig_stack != NULL){
-		pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER);
-		set_sigstack(sig_stack, pages * UM_KERN_PAGE_SIZE);
-		flags = SA_ONSTACK;
-	}
-	if(usr1_handler){
-		struct sigaction sa;
-
-		sa.sa_handler = usr1_handler;
-		sigemptyset(&sa.sa_mask);
-		sa.sa_flags = flags;
-		sa.sa_restorer = NULL;
-		if(sigaction(SIGUSR1, &sa, NULL) < 0)
-			panic("init_new_thread_stack - sigaction failed - "
-			      "errno = %d\n", errno);
-	}
-}
-#endif
-
 void init_new_thread_signals(void)
 {
 	set_handler(SIGSEGV, (__sighandler_t) sig_handler, SA_ONSTACK,

commit 97a1fcbb20fcbb0177567fd2dbcc6ed1bcc450ce
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 23 18:43:48 2007 -0700

    uml: more __init annotations
    
    2.6.23-rc1 turned up another batch of references from non-__init code to
    __init code.  In most cases, these were missing __init annotations.  In one
    case (os_drop_memory), the annotation was present but wrong.
    
    init_maps is __init, but for some reason was being very careful about the
    mechanism by which it allocated memory, checking whether it was OK to use
    kmalloc (at this point in the boot, it definitely isn't) and using either
    alloc_bootmem_low_pages or kmalloc/vmalloc.  So, the kmalloc/vmalloc code is
    removed.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 2d9d2ca39299..e9c143297512 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -194,7 +194,7 @@ int os_unmap_memory(void *addr, int len)
 #define MADV_REMOVE KERNEL_MADV_REMOVE
 #endif
 
-int __init os_drop_memory(void *addr, int length)
+int os_drop_memory(void *addr, int length)
 {
 	int err;
 

commit 231f7e9d029a710c14352bff3b8d3753cb9bfde8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed May 9 02:33:21 2007 -0700

    uml: mark a tt-only function
    
    Mark another function as tt-mode only.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 92a7b59120d6..2d9d2ca39299 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -239,6 +239,7 @@ int __init can_drop_memory(void)
 	return ok;
 }
 
+#ifdef UML_CONFIG_MODE_TT
 void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 {
 	int flags = 0, pages;
@@ -260,6 +261,7 @@ void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 			      "errno = %d\n", errno);
 	}
 }
+#endif
 
 void init_new_thread_signals(void)
 {

commit a61f334fd2864b9b040f7e882726426ed7e8a317
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:35 2007 -0700

    uml: convert libc layer to call read and write
    
    This patch converts calls in the os layer to os_{read,write}_file to calls
    directly to libc read() and write() where it is clear that the I/O buffer is
    in the kernel.
    
    We can do that here instead of calling os_{read,write}_file_k since we are in
    libc code and can call libc directly.
    
    With the change in the calls, error handling needs to be changed to refer to
    errno directly rather than the return value of the call.
    
    CATCH_EINTR wrappers were also added where needed.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index a84a45843f83..92a7b59120d6 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -42,10 +42,10 @@ unsigned long os_process_pc(int pid)
 		       proc_stat, -fd);
 		return ARBITRARY_ADDR;
 	}
-	err = os_read_file(fd, buf, sizeof(buf));
+	CATCH_EINTR(err = read(fd, buf, sizeof(buf)));
 	if(err < 0){
 		printk("os_process_pc - couldn't read '%s', err = %d\n",
-		       proc_stat, -err);
+		       proc_stat, errno);
 		os_close_file(fd);
 		return ARBITRARY_ADDR;
 	}
@@ -75,11 +75,11 @@ int os_process_parent(int pid)
 		return FAILURE_PID;
 	}
 
-	n = os_read_file(fd, data, sizeof(data));
+	CATCH_EINTR(n = read(fd, data, sizeof(data)));
 	os_close_file(fd);
 
 	if(n < 0){
-		printk("Couldn't read '%s', err = %d\n", stat, -n);
+		printk("Couldn't read '%s', err = %d\n", stat, errno);
 		return FAILURE_PID;
 	}
 

commit ef0470c053274c343b2be8737e0146d65e17f9be
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:33 2007 -0700

    uml: tidy libc code
    
    This patch lays some groundwork for the next one, which converts calls to
    os_{read,write}_file into {read,write}, by doing some tidying in the affected
    areas.
    
    do_not_aio gets restructured to make the final result a bit cleaner.
    
    There are also whitespace and other formatting fixes, fixes in error messages,
    and a typo fix.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 37933d3f92b8..a84a45843f83 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -40,14 +40,14 @@ unsigned long os_process_pc(int pid)
 	if(fd < 0){
 		printk("os_process_pc - couldn't open '%s', err = %d\n",
 		       proc_stat, -fd);
-		return(ARBITRARY_ADDR);
+		return ARBITRARY_ADDR;
 	}
 	err = os_read_file(fd, buf, sizeof(buf));
 	if(err < 0){
 		printk("os_process_pc - couldn't read '%s', err = %d\n",
 		       proc_stat, -err);
 		os_close_file(fd);
-		return(ARBITRARY_ADDR);
+		return ARBITRARY_ADDR;
 	}
 	os_close_file(fd);
 	pc = ARBITRARY_ADDR;
@@ -56,7 +56,7 @@ unsigned long os_process_pc(int pid)
 		  "%*d %*d %*d %*d %*d %lu", &pc) != 1){
 		printk("os_process_pc - couldn't find pc in '%s'\n", buf);
 	}
-	return(pc);
+	return pc;
 }
 
 int os_process_parent(int pid)
@@ -65,13 +65,14 @@ int os_process_parent(int pid)
 	char data[256];
 	int parent, n, fd;
 
-	if(pid == -1) return(-1);
+	if(pid == -1)
+		return -1;
 
 	snprintf(stat, sizeof(stat), "/proc/%d/stat", pid);
 	fd = os_open_file(stat, of_read(OPENFLAGS()), 0);
 	if(fd < 0){
 		printk("Couldn't open '%s', err = %d\n", stat, -fd);
-		return(FAILURE_PID);
+		return FAILURE_PID;
 	}
 
 	n = os_read_file(fd, data, sizeof(data));
@@ -79,7 +80,7 @@ int os_process_parent(int pid)
 
 	if(n < 0){
 		printk("Couldn't read '%s', err = %d\n", stat, -n);
-		return(FAILURE_PID);
+		return FAILURE_PID;
 	}
 
 	parent = FAILURE_PID;
@@ -87,7 +88,7 @@ int os_process_parent(int pid)
 	if(n != 1)
 		printk("Failed to scan '%s'\n", data);
 
-	return(parent);
+	return parent;
 }
 
 void os_stop_process(int pid)
@@ -145,7 +146,7 @@ void os_usr1_process(int pid)
 
 int os_getpid(void)
 {
-	return(syscall(__NR_getpid));
+	return syscall(__NR_getpid);
 }
 
 int os_getpgrp(void)
@@ -165,8 +166,8 @@ int os_map_memory(void *virt, int fd, unsigned long long off, unsigned long len,
 	loc = mmap64((void *) virt, len, prot, MAP_SHARED | MAP_FIXED,
 		     fd, off);
 	if(loc == MAP_FAILED)
-		return(-errno);
-	return(0);
+		return -errno;
+	return 0;
 }
 
 int os_protect_memory(void *addr, unsigned long len, int r, int w, int x)
@@ -175,8 +176,8 @@ int os_protect_memory(void *addr, unsigned long len, int r, int w, int x)
 		    (x ? PROT_EXEC : 0));
 
         if(mprotect(addr, len, prot) < 0)
-		return(-errno);
-        return(0);
+		return -errno;
+        return 0;
 }
 
 int os_unmap_memory(void *addr, int len)
@@ -185,8 +186,8 @@ int os_unmap_memory(void *addr, int len)
 
         err = munmap(addr, len);
 	if(err < 0)
-		return(-errno);
-        return(0);
+		return -errno;
+        return 0;
 }
 
 #ifndef MADV_REMOVE

commit 1ffb9164f51094b7105ce9f81600b222ddf5b82c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:22 2007 -0700

    uml: remove page_size()
    
    userspace code used to have to call the kernelspace function page_size() in
    order to determine the value of the kernel's PAGE_SIZE.  Since this is now
    available directly from kern_constants.h as UM_KERN_PAGE_SIZE, page_size() can
    be deleted and calls changed to use the constant.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 2babea30345e..37933d3f92b8 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -244,7 +244,7 @@ void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 
 	if(sig_stack != NULL){
 		pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER);
-		set_sigstack(sig_stack, pages * page_size());
+		set_sigstack(sig_stack, pages * UM_KERN_PAGE_SIZE);
 		flags = SA_ONSTACK;
 	}
 	if(usr1_handler){

commit 36e454630473caa178bcbc4982ed6a68cf002e95
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:11 2007 -0700

    uml: add missing __init declarations
    
    The build started finding calls from non-init to init functions.  These are
    just cases of init functions not being properly marked, so this patch fixes
    that.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 697828220af2..2babea30345e 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -21,6 +21,7 @@
 #include "skas_ptrace.h"
 #include "kern_constants.h"
 #include "uml-config.h"
+#include "init.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -192,7 +193,7 @@ int os_unmap_memory(void *addr, int len)
 #define MADV_REMOVE KERNEL_MADV_REMOVE
 #endif
 
-int os_drop_memory(void *addr, int length)
+int __init os_drop_memory(void *addr, int length)
 {
 	int err;
 
@@ -202,7 +203,7 @@ int os_drop_memory(void *addr, int length)
 	return err;
 }
 
-int can_drop_memory(void)
+int __init can_drop_memory(void)
 {
 	void *addr;
 	int fd, ok = 0;

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 76bdd6712417..697828220af2 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -14,7 +14,6 @@
 #include "ptrace_user.h"
 #include "os.h"
 #include "user.h"
-#include "user_util.h"
 #include "process.h"
 #include "irq_user.h"
 #include "kern_util.h"

commit 9ff1d36cf4b8b7dc4efbc83ac617a63020b1125d
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Wed Mar 7 20:41:10 2007 -0800

    [PATCH] um: remove dead code about os_usr1_signal() and os_usr1_process()
    
    os_usr1_signal() is totally unused, os_usr1_process() is used only by TT mode.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Acked-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index c692a192957a..76bdd6712417 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -21,6 +21,7 @@
 #include "longjmp.h"
 #include "skas_ptrace.h"
 #include "kern_constants.h"
+#include "uml-config.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -131,10 +132,12 @@ void os_kill_ptraced_process(int pid, int reap_child)
 		CATCH_EINTR(waitpid(pid, NULL, 0));
 }
 
+#ifdef UML_CONFIG_MODE_TT
 void os_usr1_process(int pid)
 {
 	kill(pid, SIGUSR1);
 }
+#endif
 
 /* Don't use the glibc version, which caches the result in TLS. It misses some
  * syscalls, and also breaks with clone(), which does not unshare the TLS.

commit 1f6f61649d8c64d7a3a4d143405df9a7bdd4af10
Author: Jeff Dike <jdike@addtoit.com>
Date:   Thu Nov 2 22:07:23 2006 -0800

    [PATCH] uml: include tidying
    
    In order to get the __NR_* constants, we need sys/syscall.h.
    linux/unistd.h works as well since it includes syscall.h, however syscall.h
    is more parsimonious.  We were inconsistent in this, and this patch adds
    syscall.h includes where necessary and removes linux/unistd.h includes
    where they are not needed.
    
    asm/unistd.h also includes the __NR_* constants, but these are not the
    glibc-sanctioned ones, so this also removes one such inclusion.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 51f0893640a6..c692a192957a 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -7,7 +7,6 @@
 #include <stdio.h>
 #include <errno.h>
 #include <signal.h>
-#include <linux/unistd.h>
 #include <sys/mman.h>
 #include <sys/wait.h>
 #include <sys/mman.h>

commit 5f4c6bc1f369f20807a8e753c2308d1629478c61
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 2 02:18:37 2006 -0700

    [PATCH] Remove the use of _syscallX macros in UML
    
    User mode linux uses _syscallX() to call into the host kernel.  The
    recommended way to do this is to use the syscall() function from libc.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Richard Curnow <rc@rc0.org.uk>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index ff203625a4bd..51f0893640a6 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -11,6 +11,7 @@
 #include <sys/mman.h>
 #include <sys/wait.h>
 #include <sys/mman.h>
+#include <sys/syscall.h>
 #include "ptrace_user.h"
 #include "os.h"
 #include "user.h"
@@ -140,11 +141,9 @@ void os_usr1_process(int pid)
  * syscalls, and also breaks with clone(), which does not unshare the TLS.
  */
 
-inline _syscall0(pid_t, getpid)
-
 int os_getpid(void)
 {
-	return(getpid());
+	return(syscall(__NR_getpid));
 }
 
 int os_getpgrp(void)

commit 4b84c69b5f6c08a540e3683f1360a6cdef2806c7
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Sep 25 23:33:04 2006 -0700

    [PATCH] uml: Move signal handlers to arch code
    
    Have most signals go through an arch-provided handler which recovers the
    sigcontext and then calls a generic handler.  This replaces the
    ARCH_GET_SIGCONTEXT macro, which was somewhat fragile.  On x86_64, recovering
    %rdx (which holds the sigcontext pointer) must be the first thing that
    happens.  sig_handler duly invokes that first, but there is no guarantee that
    I can see that instructions won't be reordered such that %rdx is used before
    that.  Having the arch provide the handler seems much more robust.
    
    Some signals in some parts of UML require their own handlers - these places
    don't call set_handler any more.  They call sigaction or signal themselves.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 3afde92ad2c0..ff203625a4bd 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -246,7 +246,17 @@ void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 		set_sigstack(sig_stack, pages * page_size());
 		flags = SA_ONSTACK;
 	}
-	if(usr1_handler) set_handler(SIGUSR1, usr1_handler, flags, -1);
+	if(usr1_handler){
+		struct sigaction sa;
+
+		sa.sa_handler = usr1_handler;
+		sigemptyset(&sa.sa_mask);
+		sa.sa_flags = flags;
+		sa.sa_restorer = NULL;
+		if(sigaction(SIGUSR1, &sa, NULL) < 0)
+			panic("init_new_thread_stack - sigaction failed - "
+			      "errno = %d\n", errno);
+	}
 }
 
 void init_new_thread_signals(void)

commit 13c06be399902c9ebda08e092edb1614bb4a3761
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Sep 25 23:32:59 2006 -0700

    [PATCH] uml: Use klibc setjmp/longjmp
    
    This patch adds an implementation of setjmp and longjmp to UML, allowing
    access to the inside of a jmpbuf without needing the access macros formerly
    provided by libc.
    
    The implementation is stolen from klibc.  I copy the relevant files into
    arch/um.  I have another patch which avoids the copying, but requires klibc be
    in the tree.
    
    setjmp and longjmp users required some tweaking.  Includes of <setjmp.h> were
    removed and includes of the UML longjmp.h were added where necessary.  There
    are also replacements of siglongjmp with UML_LONGJMP which I somehow missed
    earlier.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index b98d3ca2cd1b..3afde92ad2c0 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -7,7 +7,6 @@
 #include <stdio.h>
 #include <errno.h>
 #include <signal.h>
-#include <setjmp.h>
 #include <linux/unistd.h>
 #include <sys/mman.h>
 #include <sys/wait.h>

commit a5df0d1a2c0f7dbd135d978d02daf2d99e62ff7a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Jul 14 00:24:02 2006 -0700

    [PATCH] uml: tidy longjmp macro
    
    The UML_SETJMP macro was requiring its users to pass in a argument which it
    could supply itself, since it wasn't used outside that invocation of the
    macro.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index b1cda818f5b5..b98d3ca2cd1b 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -273,12 +273,12 @@ void init_new_thread_signals(void)
 int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
 {
 	jmp_buf buf;
-	int n, enable;
+	int n;
 
 	*jmp_ptr = &buf;
-	n = UML_SETJMP(&buf, enable);
+	n = UML_SETJMP(&buf);
 	if(n != 0)
-		return(n);
+		return n;
 	(*fn)(arg);
-	return(0);
+	return 0;
 }

commit e64bd134085451fe3f751025c5d5a70729164b7c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:07 2006 -0700

    [PATCH] uml: signal initialization cleanup
    
    It turns out that init_new_thread_signals is always called with altstack == 1,
    so we can eliminate the parameter.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 233be2f4f8cb..b1cda818f5b5 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -250,25 +250,24 @@ void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 	if(usr1_handler) set_handler(SIGUSR1, usr1_handler, flags, -1);
 }
 
-void init_new_thread_signals(int altstack)
+void init_new_thread_signals(void)
 {
-	int flags = altstack ? SA_ONSTACK : 0;
-
-	set_handler(SIGSEGV, (__sighandler_t) sig_handler, flags,
+	set_handler(SIGSEGV, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
-	set_handler(SIGTRAP, (__sighandler_t) sig_handler, flags,
+	set_handler(SIGTRAP, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
-	set_handler(SIGFPE, (__sighandler_t) sig_handler, flags,
+	set_handler(SIGFPE, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
-	set_handler(SIGILL, (__sighandler_t) sig_handler, flags,
+	set_handler(SIGILL, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
-	set_handler(SIGBUS, (__sighandler_t) sig_handler, flags,
+	set_handler(SIGBUS, (__sighandler_t) sig_handler, SA_ONSTACK,
 		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
 	set_handler(SIGUSR2, (__sighandler_t) sig_handler,
-		    flags, SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+		    SA_ONSTACK, SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM,
+		    -1);
 	signal(SIGHUP, SIG_IGN);
 
-	init_irq_signals(altstack);
+	init_irq_signals(1);
 }
 
 int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)

commit e3104f50d89b1fffe1fd973e32248a5c7f1bb41e
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 1 12:15:58 2006 -0700

    [PATCH] uml: clean up after MADVISE_REMOVE
    
    The MADVISE_REMOVE-checking code didn't clean up after itself.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 3505f44f8a25..233be2f4f8cb 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -206,29 +206,36 @@ int os_drop_memory(void *addr, int length)
 int can_drop_memory(void)
 {
 	void *addr;
-	int fd;
+	int fd, ok = 0;
 
 	printk("Checking host MADV_REMOVE support...");
 	fd = create_mem_file(UM_KERN_PAGE_SIZE);
 	if(fd < 0){
 		printk("Creating test memory file failed, err = %d\n", -fd);
-		return 0;
+		goto out;
 	}
 
 	addr = mmap64(NULL, UM_KERN_PAGE_SIZE, PROT_READ | PROT_WRITE,
 		      MAP_SHARED, fd, 0);
 	if(addr == MAP_FAILED){
 		printk("Mapping test memory file failed, err = %d\n", -errno);
-		return 0;
+		goto out_close;
 	}
 
 	if(madvise(addr, UM_KERN_PAGE_SIZE, MADV_REMOVE) != 0){
 		printk("MADV_REMOVE failed, err = %d\n", -errno);
-		return 0;
+		goto out_unmap;
 	}
 
 	printk("OK\n");
-	return 1;
+	ok = 1;
+
+out_unmap:
+	munmap(addr, UM_KERN_PAGE_SIZE);
+out_close:
+	close(fd);
+out:
+	return ok;
 }
 
 void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))

commit ad28e029789ef46aebdfb9ece01d431ce1c637c8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Apr 18 22:21:41 2006 -0700

    [PATCH] uml: change sigjmp_buf to jmp_buf
    
    Clean up the jmpbuf code.  Since softints, we no longer use sig_setjmp, so
    the UML_SIGSETJMP wrapper now has a misleading name.  Also, I forgot to
    change the buffers from sigjmp_buf to jmp_buf.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 2064e8400d94..3505f44f8a25 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -266,11 +266,11 @@ void init_new_thread_signals(int altstack)
 
 int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
 {
-	sigjmp_buf buf;
+	jmp_buf buf;
 	int n, enable;
 
 	*jmp_ptr = &buf;
-	n = UML_SIGSETJMP(&buf, enable);
+	n = UML_SETJMP(&buf, enable);
 	if(n != 0)
 		return(n);
 	(*fn)(arg);

commit b73781c866f671ff5a84d7c840510b43e8731d13
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Apr 18 22:20:24 2006 -0700

    [PATCH] uml: MADV_REMOVE fixes
    
    MADV_REMOVE fixes - change the test mapping to be MAP_SHARED instead of
    MAP_PRIVATE, as MADV_REMOVE on MAP_PRIVATE maps won't work.  Also, use
    the kernel's definition of MADV_REMOVE instead of hardcoding it if there
    isn't a libc definition.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 8176b0b52047..2064e8400d94 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -190,7 +190,7 @@ int os_unmap_memory(void *addr, int len)
 }
 
 #ifndef MADV_REMOVE
-#define MADV_REMOVE	0x5		/* remove these pages & resources */
+#define MADV_REMOVE KERNEL_MADV_REMOVE
 #endif
 
 int os_drop_memory(void *addr, int length)
@@ -216,7 +216,7 @@ int can_drop_memory(void)
 	}
 
 	addr = mmap64(NULL, UM_KERN_PAGE_SIZE, PROT_READ | PROT_WRITE,
-		      MAP_PRIVATE, fd, 0);
+		      MAP_SHARED, fd, 0);
 	if(addr == MAP_FAILED){
 		printk("Mapping test memory file failed, err = %d\n", -errno);
 		return 0;

commit 02dea0875b0f9b331a65fd6097dfd6115ca4ef24
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Mar 31 02:30:08 2006 -0800

    [PATCH] UML: Hotplug memory, take 2
    
    Changes since first version
            added check for MADV_REMOVE support on the host
            fixed error return botch
            shrunk sprintf array by one character
    
    This adds hotplug memory support to UML.  The mconsole syntax is
            config mem=[+-]n[KMG]
    In other words, add or subtract some number of kilobytes, megabytes, or
    gigabytes.
    
    Unplugged pages are allocated and then madvise(MADV_TRUNCATE), which is a
    currently experimental madvise extension.  These pages are tracked so they
    can be plugged back in later if the admin decides to give them back.  The
    first page to be unplugged is used to keep track of about 4M of other
    pages.  A list_head is the first thing on this page.  The rest is filled
    with addresses of other unplugged pages.  This first page is not madvised,
    obviously.
    
    When this page is filled, the next page is used in a similar way and linked
    onto a list with the first page.  Etc.  This whole process reverses when
    pages are plugged back in.  When a tracking page no longer tracks any
    unplugged pages, then it is next in line for plugging, which is done by
    freeing pages back to the kernel.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index d261888f39c4..8176b0b52047 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -11,6 +11,7 @@
 #include <linux/unistd.h>
 #include <sys/mman.h>
 #include <sys/wait.h>
+#include <sys/mman.h>
 #include "ptrace_user.h"
 #include "os.h"
 #include "user.h"
@@ -20,6 +21,7 @@
 #include "kern_util.h"
 #include "longjmp.h"
 #include "skas_ptrace.h"
+#include "kern_constants.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -187,6 +189,48 @@ int os_unmap_memory(void *addr, int len)
         return(0);
 }
 
+#ifndef MADV_REMOVE
+#define MADV_REMOVE	0x5		/* remove these pages & resources */
+#endif
+
+int os_drop_memory(void *addr, int length)
+{
+	int err;
+
+	err = madvise(addr, length, MADV_REMOVE);
+	if(err < 0)
+		err = -errno;
+	return err;
+}
+
+int can_drop_memory(void)
+{
+	void *addr;
+	int fd;
+
+	printk("Checking host MADV_REMOVE support...");
+	fd = create_mem_file(UM_KERN_PAGE_SIZE);
+	if(fd < 0){
+		printk("Creating test memory file failed, err = %d\n", -fd);
+		return 0;
+	}
+
+	addr = mmap64(NULL, UM_KERN_PAGE_SIZE, PROT_READ | PROT_WRITE,
+		      MAP_PRIVATE, fd, 0);
+	if(addr == MAP_FAILED){
+		printk("Mapping test memory file failed, err = %d\n", -errno);
+		return 0;
+	}
+
+	if(madvise(addr, UM_KERN_PAGE_SIZE, MADV_REMOVE) != 0){
+		printk("MADV_REMOVE failed, err = %d\n", -errno);
+		return 0;
+	}
+
+	printk("OK\n");
+	return 1;
+}
+
 void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
 {
 	int flags = 0, pages;

commit 07f4e2c61c76e8b543c0a2589063aea85c15fb25
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Fri Feb 24 13:03:55 2006 -0800

    [PATCH] uml: fix usage of kernel_errno in place of errno
    
    To avoid conflicts, in kernel files errno is expanded to kernel_errno, to
    distinguish it from glibc errno.  In this case, the code wants to use the libc
    errno but the kernel one is used; in the other usage, we return errno in place
    of -errno in case of an error.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Acked-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 7f5e2dac2a35..d261888f39c4 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -19,6 +19,7 @@
 #include "irq_user.h"
 #include "kern_util.h"
 #include "longjmp.h"
+#include "skas_ptrace.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -100,6 +101,21 @@ void os_kill_process(int pid, int reap_child)
 		
 }
 
+/* This is here uniquely to have access to the userspace errno, i.e. the one
+ * used by ptrace in case of error.
+ */
+
+long os_ptrace_ldt(long pid, long addr, long data)
+{
+	int ret;
+
+	ret = ptrace(PTRACE_LDT, pid, addr, data);
+
+	if (ret < 0)
+		return -errno;
+	return ret;
+}
+
 /* Kill off a ptraced child by all means available.  kill it normally first,
  * then PTRACE_KILL it, then PTRACE_CONT it in case it's in a run state from
  * which it can't exit directly.

commit 1d7173baf286c8b720f97f119ec92be43076ebde
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Jan 18 17:42:49 2006 -0800

    [PATCH] uml: implement soft interrupts
    
    This patch implements soft interrupts.  Interrupt enabling and disabling no
    longer map to sigprocmask.  Rather, a flag is set indicating whether
    interrupts may be handled.  If a signal comes in and interrupts are marked as
    OK, then it is handled normally.  If interrupts are marked as off, then the
    signal handler simply returns after noting that a signal needs handling.  When
    interrupts are enabled later on, this pending signals flag is checked, and the
    IRQ handlers are called at that point.
    
    The point of this is to reduce the cost of local_irq_save et al, since they
    are very much more common than the signals that they are enabling and
    disabling.  Soft interrupts produce a speed-up of ~25% on a kernel build.
    
    Subtleties -
    
        UML uses sigsetjmp/siglongjmp to switch contexts.  sigsetjmp has been
        wrapped in a save_flags-like macro which remembers the interrupt state at
        setjmp time, and restores it when it is longjmp-ed back to.
    
        The enable_signals function has to loop because the IRQ handler
        disables interrupts before returning.  enable_signals has to return with
        signals enabled, and signals may come in between the disabling and the
        return to enable_signals.  So, it loops for as long as there are pending
        signals, ensuring that signals are enabled when it finally returns, and
        that there are no pending signals that need to be dealt with.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 39815c6b5e45..7f5e2dac2a35 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -18,6 +18,7 @@
 #include "process.h"
 #include "irq_user.h"
 #include "kern_util.h"
+#include "longjmp.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -205,24 +206,13 @@ void init_new_thread_signals(int altstack)
 
 int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
 {
-       sigjmp_buf buf;
-       int n;
-
-       *jmp_ptr = &buf;
-       n = sigsetjmp(buf, 1);
-       if(n != 0)
-               return(n);
-       (*fn)(arg);
-       return(0);
+	sigjmp_buf buf;
+	int n, enable;
+
+	*jmp_ptr = &buf;
+	n = UML_SIGSETJMP(&buf, enable);
+	if(n != 0)
+		return(n);
+	(*fn)(arg);
+	return(0);
 }
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit 0805d89c151b4800eade4c2f50d39c5253d7d054
Author: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
Date:   Sun Jan 8 01:01:29 2006 -0800

    [PATCH] uml: move libc-dependent code from signal_user.c
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from signal_user.c file under os-Linux dir
    
    Signed-off-by: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index d9c52387c4a1..39815c6b5e45 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -15,7 +15,6 @@
 #include "os.h"
 #include "user.h"
 #include "user_util.h"
-#include "signal_user.h"
 #include "process.h"
 #include "irq_user.h"
 #include "kern_util.h"

commit ae756df8ddd00a30bb3bdf6774b514c096dda4a4
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Wed Sep 21 18:40:10 2005 +0200

    [PATCH] uml: readd removed unistd.h inclusion
    
    Readd this header (deleted in 60d339f6fe0831060600c62418b71a62ad26c281). A
    warning is spit out here about undeclared getpgrp().
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index d32413e4b4ce..d9c52387c4a1 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -3,6 +3,7 @@
  * Licensed under the GPL
  */
 
+#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <signal.h>

commit 60d339f6fe0831060600c62418b71a62ad26c281
Author: Gennady Sharapov <gennady.v.sharapov@intel.com>
Date:   Sat Sep 3 15:57:47 2005 -0700

    [PATCH] uml: move libc-dependent startup and signal code
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from process.c file under os-Linux dir and join
    process.c and process_kern.c files.
    
    Signed-off-by: Gennady Sharapov <gennady.v.sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index 1e126bfd31a7..d32413e4b4ce 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -3,10 +3,10 @@
  * Licensed under the GPL
  */
 
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <signal.h>
+#include <setjmp.h>
 #include <linux/unistd.h>
 #include <sys/mman.h>
 #include <sys/wait.h>
@@ -14,6 +14,10 @@
 #include "os.h"
 #include "user.h"
 #include "user_util.h"
+#include "signal_user.h"
+#include "process.h"
+#include "irq_user.h"
+#include "kern_util.h"
 
 #define ARBITRARY_ADDR -1
 #define FAILURE_PID    -1
@@ -114,8 +118,10 @@ void os_usr1_process(int pid)
 	kill(pid, SIGUSR1);
 }
 
-/*Don't use the glibc version, which caches the result in TLS. It misses some
- * syscalls, and also breaks with clone(), which does not unshare the TLS.*/
+/* Don't use the glibc version, which caches the result in TLS. It misses some
+ * syscalls, and also breaks with clone(), which does not unshare the TLS.
+ */
+
 inline _syscall0(pid_t, getpid)
 
 int os_getpid(void)
@@ -164,6 +170,52 @@ int os_unmap_memory(void *addr, int len)
         return(0);
 }
 
+void init_new_thread_stack(void *sig_stack, void (*usr1_handler)(int))
+{
+	int flags = 0, pages;
+
+	if(sig_stack != NULL){
+		pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER);
+		set_sigstack(sig_stack, pages * page_size());
+		flags = SA_ONSTACK;
+	}
+	if(usr1_handler) set_handler(SIGUSR1, usr1_handler, flags, -1);
+}
+
+void init_new_thread_signals(int altstack)
+{
+	int flags = altstack ? SA_ONSTACK : 0;
+
+	set_handler(SIGSEGV, (__sighandler_t) sig_handler, flags,
+		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	set_handler(SIGTRAP, (__sighandler_t) sig_handler, flags,
+		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	set_handler(SIGFPE, (__sighandler_t) sig_handler, flags,
+		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	set_handler(SIGILL, (__sighandler_t) sig_handler, flags,
+		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	set_handler(SIGBUS, (__sighandler_t) sig_handler, flags,
+		    SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	set_handler(SIGUSR2, (__sighandler_t) sig_handler,
+		    flags, SIGUSR1, SIGIO, SIGWINCH, SIGALRM, SIGVTALRM, -1);
+	signal(SIGHUP, SIG_IGN);
+
+	init_irq_signals(altstack);
+}
+
+int run_kernel_thread(int (*fn)(void *), void *arg, void **jmp_ptr)
+{
+       sigjmp_buf buf;
+       int n;
+
+       *jmp_ptr = &buf;
+       n = sigsetjmp(buf, 1);
+       if(n != 0)
+               return(n);
+       (*fn)(arg);
+       return(0);
+}
+
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically

commit cd2ee4a30cc0775d8b54e5b958613361a7cacfec
Author: Jeff Dike <jdike@addtoit.com>
Date:   Thu May 5 16:15:32 2005 -0700

    [PATCH] uml: Fix SIGWINCH relaying
    
    This makes SIGWINCH work again, and fixes a couple of SIGWINCH-associated
    crashes.  First, the sigio thread disables SIGWINCH because all hell breaks
    loose if it ever gets one and tries to call the signal handling code.  Second,
    there was a problem with deferencing tty structs after they were freed.  The
    SIGWINCH support for a tty wasn't being turned off or freed after the tty went
    away.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
index ba9ca1cc790a..1e126bfd31a7 100644
--- a/arch/um/os-Linux/process.c
+++ b/arch/um/os-Linux/process.c
@@ -123,6 +123,11 @@ int os_getpid(void)
 	return(getpid());
 }
 
+int os_getpgrp(void)
+{
+	return getpgrp();
+}
+
 int os_map_memory(void *virt, int fd, unsigned long long off, unsigned long len,
 		  int r, int w, int x)
 {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/os-Linux/process.c b/arch/um/os-Linux/process.c
new file mode 100644
index 000000000000..ba9ca1cc790a
--- /dev/null
+++ b/arch/um/os-Linux/process.c
@@ -0,0 +1,171 @@
+/* 
+ * Copyright (C) 2002 Jeff Dike (jdike@addtoit.com)
+ * Licensed under the GPL
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <signal.h>
+#include <linux/unistd.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include "ptrace_user.h"
+#include "os.h"
+#include "user.h"
+#include "user_util.h"
+
+#define ARBITRARY_ADDR -1
+#define FAILURE_PID    -1
+
+#define STAT_PATH_LEN sizeof("/proc/#######/stat\0")
+#define COMM_SCANF "%*[^)])"
+
+unsigned long os_process_pc(int pid)
+{
+	char proc_stat[STAT_PATH_LEN], buf[256];
+	unsigned long pc;
+	int fd, err;
+
+	sprintf(proc_stat, "/proc/%d/stat", pid);
+	fd = os_open_file(proc_stat, of_read(OPENFLAGS()), 0);
+	if(fd < 0){
+		printk("os_process_pc - couldn't open '%s', err = %d\n",
+		       proc_stat, -fd);
+		return(ARBITRARY_ADDR);
+	}
+	err = os_read_file(fd, buf, sizeof(buf));
+	if(err < 0){
+		printk("os_process_pc - couldn't read '%s', err = %d\n",
+		       proc_stat, -err);
+		os_close_file(fd);
+		return(ARBITRARY_ADDR);
+	}
+	os_close_file(fd);
+	pc = ARBITRARY_ADDR;
+	if(sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d "
+		  "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
+		  "%*d %*d %*d %*d %*d %lu", &pc) != 1){
+		printk("os_process_pc - couldn't find pc in '%s'\n", buf);
+	}
+	return(pc);
+}
+
+int os_process_parent(int pid)
+{
+	char stat[STAT_PATH_LEN];
+	char data[256];
+	int parent, n, fd;
+
+	if(pid == -1) return(-1);
+
+	snprintf(stat, sizeof(stat), "/proc/%d/stat", pid);
+	fd = os_open_file(stat, of_read(OPENFLAGS()), 0);
+	if(fd < 0){
+		printk("Couldn't open '%s', err = %d\n", stat, -fd);
+		return(FAILURE_PID);
+	}
+
+	n = os_read_file(fd, data, sizeof(data));
+	os_close_file(fd);
+
+	if(n < 0){
+		printk("Couldn't read '%s', err = %d\n", stat, -n);
+		return(FAILURE_PID);
+	}
+
+	parent = FAILURE_PID;
+	n = sscanf(data, "%*d " COMM_SCANF " %*c %d", &parent);
+	if(n != 1)
+		printk("Failed to scan '%s'\n", data);
+
+	return(parent);
+}
+
+void os_stop_process(int pid)
+{
+	kill(pid, SIGSTOP);
+}
+
+void os_kill_process(int pid, int reap_child)
+{
+	kill(pid, SIGKILL);
+	if(reap_child)
+		CATCH_EINTR(waitpid(pid, NULL, 0));
+		
+}
+
+/* Kill off a ptraced child by all means available.  kill it normally first,
+ * then PTRACE_KILL it, then PTRACE_CONT it in case it's in a run state from
+ * which it can't exit directly.
+ */
+
+void os_kill_ptraced_process(int pid, int reap_child)
+{
+	kill(pid, SIGKILL);
+	ptrace(PTRACE_KILL, pid);
+	ptrace(PTRACE_CONT, pid);
+	if(reap_child)
+		CATCH_EINTR(waitpid(pid, NULL, 0));
+}
+
+void os_usr1_process(int pid)
+{
+	kill(pid, SIGUSR1);
+}
+
+/*Don't use the glibc version, which caches the result in TLS. It misses some
+ * syscalls, and also breaks with clone(), which does not unshare the TLS.*/
+inline _syscall0(pid_t, getpid)
+
+int os_getpid(void)
+{
+	return(getpid());
+}
+
+int os_map_memory(void *virt, int fd, unsigned long long off, unsigned long len,
+		  int r, int w, int x)
+{
+	void *loc;
+	int prot;
+
+	prot = (r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) | 
+		(x ? PROT_EXEC : 0);
+
+	loc = mmap64((void *) virt, len, prot, MAP_SHARED | MAP_FIXED,
+		     fd, off);
+	if(loc == MAP_FAILED)
+		return(-errno);
+	return(0);
+}
+
+int os_protect_memory(void *addr, unsigned long len, int r, int w, int x)
+{
+        int prot = ((r ? PROT_READ : 0) | (w ? PROT_WRITE : 0) | 
+		    (x ? PROT_EXEC : 0));
+
+        if(mprotect(addr, len, prot) < 0)
+		return(-errno);
+        return(0);
+}
+
+int os_unmap_memory(void *addr, int len)
+{
+        int err;
+
+        err = munmap(addr, len);
+	if(err < 0)
+		return(-errno);
+        return(0);
+}
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
