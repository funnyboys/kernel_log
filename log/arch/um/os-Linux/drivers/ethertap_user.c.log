commit 97870c34b453251cda9c2341f8534b78003a74dc
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:18 2019 +0100

    um: Add SPDX headers for files in arch/um/os-Linux
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 6d4918246ffe..9483021d86dd 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -1,9 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Copyright (C) 2001 Lennert Buytenhek (buytenh@gnu.org) and
  * James Leu (jleu@mindspring.net).
  * Copyright (C) 2001 by various other people who didn't put their name here.
- * Licensed under the GPL.
  */
 
 #include <stdio.h>

commit 7879b1d94badb5c34fa777244091c2304191dddf
Author: Alan <gnomes@lxorguk.ukuu.org.uk>
Date:   Wed Apr 8 13:59:21 2015 +0100

    um,ethertap: use strncpy
    
    [um maintainers appear to be vanished]
    
    I can't prove the case pointed out in
    https://bugzilla.kernel.org/show_bug.cgi?id=82341
    is correct so let us play safe.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index b39b6696ac58..6d4918246ffe 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -105,7 +105,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	sprintf(data_fd_buf, "%d", data_remote);
 	sprintf(version_buf, "%d", UML_NET_VERSION);
 	if (gate != NULL) {
-		strcpy(gate_buf, gate);
+		strncpy(gate_buf, gate, 15);
 		args = setup_args;
 	}
 	else args = nosetup_args;

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index db3d6481375a..b39b6696ac58 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -13,9 +13,9 @@
 #include <sys/socket.h>
 #include <sys/wait.h>
 #include "etap.h"
-#include "os.h"
-#include "net_user.h"
-#include "um_malloc.h"
+#include <os.h>
+#include <net_user.h>
+#include <um_malloc.h>
 
 #define MAX_PACKET ETH_MAX_PACKET
 

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index cc72cb2c1af6..db3d6481375a 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -13,11 +13,9 @@
 #include <sys/socket.h>
 #include <sys/wait.h>
 #include "etap.h"
-#include "kern_constants.h"
 #include "os.h"
 #include "net_user.h"
 #include "um_malloc.h"
-#include "user.h"
 
 #define MAX_PACKET ETH_MAX_PACKET
 

commit 43f5b3085fdd27c4edf535d938b2cb0ccead4f75
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 12 14:01:52 2008 -0700

    uml: fix build when SLOB is enabled
    
    Reintroduce uml_kmalloc for the benefit of UML libc code.  The
    previous tactic of declaring __kmalloc so it could be called directly
    from the libc side of the house turned out to be getting too intimate
    with slab, and it doesn't work with slob.
    
    So, the uml_kmalloc wrapper is back.  It calls kmalloc or whatever
    that translates into, and libc code calls it.
    
    kfree is left alone since that still works, leaving a somewhat
    inconsistent API.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 6fb0b174f538..cc72cb2c1af6 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -52,7 +52,7 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 		return;
 	}
 
-	output = kmalloc(UM_KERN_PAGE_SIZE, UM_GFP_KERNEL);
+	output = uml_kmalloc(UM_KERN_PAGE_SIZE, UM_GFP_KERNEL);
 	if (output == NULL)
 		printk(UM_KERN_ERR "etap_change : Failed to allocate output "
 		       "buffer\n");
@@ -165,7 +165,7 @@ static int etap_open(void *data)
 	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0],
 			 control_fds[1], data_fds[0], data_fds[1]);
 	output_len = UM_KERN_PAGE_SIZE;
-	output = kmalloc(output_len, UM_GFP_KERNEL);
+	output = uml_kmalloc(output_len, UM_GFP_KERNEL);
 	read_output(control_fds[0], output, output_len);
 
 	if (output == NULL)

commit 1aa351a308d2c3ddb92b6cc45083fc54271d0010
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:10 2008 -0800

    uml: tidy helper code
    
    Style fixes to arch/um/os/helper.c and tidying up the breakpoint fix a
    bit.
    
    helper.c gets all the usual style fixes -
             updated copyright
             all printks get severities
    
    Also -
             errval changes to err in helper_child
             fixed an obsolete comment
             run_helper was killing a child process which is guaranteed to
    be dead or dying anyway
    
    Removed the nohang and pname arguments from helper_wait and fixed the
    declaration and callers.  nohang was used only in the slirp driver and
    I don't think it was needed.  I think pname was a bit of overkill in
    putting out an error message when something goes wrong.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 07ca0cb472ac..6fb0b174f538 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -131,7 +131,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	}
 	if (c != 1) {
 		printk(UM_KERN_ERR "etap_tramp : uml_net failed\n");
-		err = helper_wait(pid, 0, "uml_net");
+		err = helper_wait(pid);
 	}
 	return err;
 }

commit 4dbed85a35ed37d9608f4f32e5d69efa775d6223
Author: Stanislaw Gruszka <stf_xl@wp.pl>
Date:   Mon Dec 17 16:19:46 2007 -0800

    uml: stop gdb from deleting breakpoints when running UML
    
    Sometimes when UML is debugged gdb miss breakpoints.
    
    When process traced by gdb do fork, debugger remove breakpoints from
    child address space. There is possibility to trace more than one fork,
    but this not work with UML, I guess (only guess) there is a deadlock -
    gdb waits for UML and UML waits for gdb.
    
    When clone() is called with SIGCHLD and CLONE_VM flags, gdb see this
    as PTRACE_EVENT_FORK not as PTRACE_EVENT_CLONE and remove breakpoints
    from child and at the same time from traced process, because either
    have the same address space.
    
    Maybe it is possible to do fix in gdb, but I'm not sure if there is
    easy way to find out if traced and child processes share memory. So I
    do fix for UML, it simply do not call clone() with both SIGCHLD and
    CLONE_VM flags together.  Additionally __WALL flag is used for
    waitpid() to assure not miss clone and normal process events.
    
    [ jdike - checkpatch fixes ]
    
    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 4ff553603449..07ca0cb472ac 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -94,7 +94,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 		      int control_remote, int data_me, int data_remote)
 {
 	struct etap_pre_exec_data pe_data;
-	int pid, status, err, n;
+	int pid, err, n;
 	char version_buf[sizeof("nnnnn\0")];
 	char data_fd_buf[sizeof("nnnnnn\0")];
 	char gate_buf[sizeof("nnn.nnn.nnn.nnn\0")];
@@ -131,13 +131,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	}
 	if (c != 1) {
 		printk(UM_KERN_ERR "etap_tramp : uml_net failed\n");
-		err = -EINVAL;
-		CATCH_EINTR(n = waitpid(pid, &status, 0));
-		if (n < 0)
-			err = -errno;
-		else if (!WIFEXITED(status) || (WEXITSTATUS(status) != 1))
-			printk(UM_KERN_ERR "uml_net didn't exit with "
-			       "status 1\n");
+		err = helper_wait(pid, 0, "uml_net");
 	}
 	return err;
 }

commit b53f35a8093e6aed7e8e880eaa0b89a3d2fdfb0a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:31 2007 -0700

    uml: network driver MTU cleanups
    
    A bunch of MTU-related cleanups in the network code.
    
    First, there is the addition of the notion of a maximally-sized packet, which
    is the MTU plus headers.  This is used to size the skb that will receive a
    packet.  This allows ether_adjust_skb to go away, as it was used to resize the
    skb after it was allocated.
    
    Since the skb passed into the low-level read routine is no longer resized, and
    possibly reallocated, there, they (and the write routines) don't need to get
    an sk_buff **.  They just need the sk_buff * now.  The callers of
    ether_adjust_skb still need to do the skb_put, so that's now inlined.
    
    The MAX_PACKET definitions in most of the drivers are gone.
    
    The set_mtu methods were all the same and did nothing, so they can be
    removed.
    
    The ethertap driver had a typo which doubled the size of the packet rather
    than adding two bytes to it.  It also wasn't defining its setup_size, causing
    a zero-byte kmalloc and crash when the invalid pointer returned from kmalloc
    was dereferenced.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 29404b955f18..4ff553603449 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -222,11 +222,6 @@ static void etap_close(int fd, void *data)
 	pri->control_fd = -1;
 }
 
-static int etap_set_mtu(int mtu, void *data)
-{
-	return mtu;
-}
-
 static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
 			  void *data)
 {
@@ -254,8 +249,8 @@ const struct net_user_info ethertap_user_info = {
 	.open		= etap_open,
 	.close	 	= etap_close,
 	.remove	 	= NULL,
-	.set_mtu	= etap_set_mtu,
 	.add_address	= etap_add_addr,
 	.delete_address = etap_del_addr,
-	.max_packet	= MAX_PACKET - ETH_HEADER_ETHERTAP
+	.mtu		= ETH_MAX_PACKET,
+	.max_packet	= ETH_MAX_PACKET + ETH_HEADER_ETHERTAP,
 };

commit cd1ae0e49bdd814cfaa2e5ab28cff21a30e20085
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:29 2007 -0700

    uml: network formatting
    
    Style and other non-functional changes in the UML networking code, including
            include tidying
            style violations
            copyright updates
            printks getting severities
            userspace code calling libc directly rather than using the os_*
    wrappers
    
    There's also a exit path cleanup in the pcap driver.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index d74eedb7e682..29404b955f18 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Copyright (C) 2001 Lennert Buytenhek (buytenh@gnu.org) and
  * James Leu (jleu@mindspring.net).
  * Copyright (C) 2001 by various other people who didn't put their name here.
@@ -7,20 +8,16 @@
 
 #include <stdio.h>
 #include <unistd.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include <sys/errno.h>
+#include <errno.h>
+#include <string.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
-#include <sys/un.h>
-#include <net/if.h>
-#include "user.h"
-#include "kern_util.h"
-#include "net_user.h"
 #include "etap.h"
+#include "kern_constants.h"
 #include "os.h"
+#include "net_user.h"
 #include "um_malloc.h"
-#include "kern_constants.h"
+#include "user.h"
 
 #define MAX_PACKET ETH_MAX_PACKET
 
@@ -49,16 +46,18 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 	memcpy(change.addr, addr, sizeof(change.addr));
 	memcpy(change.netmask, netmask, sizeof(change.netmask));
 	CATCH_EINTR(n = write(fd, &change, sizeof(change)));
-	if(n != sizeof(change)){
-		printk("etap_change - request failed, err = %d\n", errno);
+	if (n != sizeof(change)) {
+		printk(UM_KERN_ERR "etap_change - request failed, err = %d\n",
+		       errno);
 		return;
 	}
 
 	output = kmalloc(UM_KERN_PAGE_SIZE, UM_GFP_KERNEL);
-	if(output == NULL)
-		printk("etap_change : Failed to allocate output buffer\n");
+	if (output == NULL)
+		printk(UM_KERN_ERR "etap_change : Failed to allocate output "
+		       "buffer\n");
 	read_output(fd, output, UM_KERN_PAGE_SIZE);
-	if(output != NULL){
+	if (output != NULL) {
 		printk("%s", output);
 		kfree(output);
 	}
@@ -107,7 +106,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 
 	sprintf(data_fd_buf, "%d", data_remote);
 	sprintf(version_buf, "%d", UML_NET_VERSION);
-	if(gate != NULL){
+	if (gate != NULL) {
 		strcpy(gate_buf, gate);
 		args = setup_args;
 	}
@@ -119,24 +118,26 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	pe_data.data_me = data_me;
 	pid = run_helper(etap_pre_exec, &pe_data, args);
 
-	if(pid < 0)
+	if (pid < 0)
 		err = pid;
 	close(data_remote);
 	close(control_remote);
 	CATCH_EINTR(n = read(control_me, &c, sizeof(c)));
-	if(n != sizeof(c)){
+	if (n != sizeof(c)) {
 		err = -errno;
-		printk("etap_tramp : read of status failed, err = %d\n", -err);
+		printk(UM_KERN_ERR "etap_tramp : read of status failed, "
+		       "err = %d\n", -err);
 		return err;
 	}
-	if(c != 1){
-		printk("etap_tramp : uml_net failed\n");
+	if (c != 1) {
+		printk(UM_KERN_ERR "etap_tramp : uml_net failed\n");
 		err = -EINVAL;
 		CATCH_EINTR(n = waitpid(pid, &status, 0));
-		if(n < 0)
+		if (n < 0)
 			err = -errno;
-		else if(!WIFEXITED(status) || (WEXITSTATUS(status) != 1))
-			printk("uml_net didn't exit with status 1\n");
+		else if (!WIFEXITED(status) || (WEXITSTATUS(status) != 1))
+			printk(UM_KERN_ERR "uml_net didn't exit with "
+			       "status 1\n");
 	}
 	return err;
 }
@@ -148,22 +149,22 @@ static int etap_open(void *data)
 	int data_fds[2], control_fds[2], err, output_len;
 
 	err = tap_open_common(pri->dev, pri->gate_addr);
-	if(err)
+	if (err)
 		return err;
 
 	err = socketpair(AF_UNIX, SOCK_DGRAM, 0, data_fds);
-	if(err){
+	if (err) {
 		err = -errno;
-		printk("etap_open - data socketpair failed - err = %d\n",
-		       errno);
+		printk(UM_KERN_ERR "etap_open - data socketpair failed - "
+		       "err = %d\n", errno);
 		return err;
 	}
 
 	err = socketpair(AF_UNIX, SOCK_STREAM, 0, control_fds);
-	if(err){
+	if (err) {
 		err = -errno;
-		printk("etap_open - control socketpair failed - err = %d\n",
-		       errno);
+		printk(UM_KERN_ERR "etap_open - control socketpair failed - "
+		       "err = %d\n", errno);
 		goto out_close_data;
 	}
 
@@ -173,15 +174,16 @@ static int etap_open(void *data)
 	output = kmalloc(output_len, UM_GFP_KERNEL);
 	read_output(control_fds[0], output, output_len);
 
-	if(output == NULL)
-		printk("etap_open : failed to allocate output buffer\n");
+	if (output == NULL)
+		printk(UM_KERN_ERR "etap_open : failed to allocate output "
+		       "buffer\n");
 	else {
 		printk("%s", output);
 		kfree(output);
 	}
 
-	if(err < 0){
-		printk("etap_tramp failed - err = %d\n", -err);
+	if (err < 0) {
+		printk(UM_KERN_ERR "etap_tramp failed - err = %d\n", -err);
 		goto out_close_control;
 	}
 
@@ -206,14 +208,14 @@ static void etap_close(int fd, void *data)
 	iter_addresses(pri->dev, etap_close_addr, &pri->control_fd);
 	close(fd);
 
-	if(shutdown(pri->data_fd, SHUT_RDWR) < 0)
-		printk("etap_close - shutdown data socket failed, errno = %d\n",
-		       errno);
-
-	if(shutdown(pri->control_fd, SHUT_RDWR) < 0)
-		printk("etap_close - shutdown control socket failed, "
+	if (shutdown(pri->data_fd, SHUT_RDWR) < 0)
+		printk(UM_KERN_ERR "etap_close - shutdown data socket failed, "
 		       "errno = %d\n", errno);
 
+	if (shutdown(pri->control_fd, SHUT_RDWR) < 0)
+		printk(UM_KERN_ERR "etap_close - shutdown control socket "
+		       "failed, errno = %d\n", errno);
+
 	close(pri->data_fd);
 	pri->data_fd = -1;
 	close(pri->control_fd);
@@ -231,7 +233,7 @@ static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
 	struct ethertap_data *pri = data;
 
 	tap_check_ips(pri->gate_addr, addr);
-	if(pri->control_fd == -1)
+	if (pri->control_fd == -1)
 		return;
 	etap_open_addr(addr, netmask, &pri->control_fd);
 }
@@ -241,7 +243,7 @@ static void etap_del_addr(unsigned char *addr, unsigned char *netmask,
 {
 	struct ethertap_data *pri = data;
 
-	if(pri->control_fd == -1)
+	if (pri->control_fd == -1)
 		return;
 
 	etap_close_addr(addr, netmask, &pri->control_fd);

commit 512b6fb1c14d4c34f23a3419b0789ad01914a899
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:11 2007 -0700

    uml: userspace files should call libc directly
    
    A number of files that were changed in the recent removal of tt mode
    are userspace files which call the os_* wrappers instead of calling
    libc directly.  A few other files were affected by this, through
    
    This patch makes these call glibc directly.
    
    There are also style fixes in the affected areas.
    
    os_print_error has no remaining callers, so it is deleted.
    
    There is a interface change to os_set_exec_close, eliminating a
    parameter which was always the same.  The callers are fixed as well.
    
    os_process_pc got its error path cleaned up.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 61d3953c7ac9..d74eedb7e682 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -87,11 +87,11 @@ static void etap_pre_exec(void *arg)
 	struct etap_pre_exec_data *data = arg;
 
 	dup2(data->control_remote, 1);
-	os_close_file(data->data_me);
-	os_close_file(data->control_me);
+	close(data->data_me);
+	close(data->control_me);
 }
 
-static int etap_tramp(char *dev, char *gate, int control_me, 
+static int etap_tramp(char *dev, char *gate, int control_me,
 		      int control_remote, int data_me, int data_remote)
 {
 	struct etap_pre_exec_data pe_data;
@@ -101,7 +101,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	char gate_buf[sizeof("nnn.nnn.nnn.nnn\0")];
 	char *setup_args[] = { "uml_net", version_buf, "ethertap", dev,
 			       data_fd_buf, gate_buf, NULL };
-	char *nosetup_args[] = { "uml_net", version_buf, "ethertap", 
+	char *nosetup_args[] = { "uml_net", version_buf, "ethertap",
 				 dev, data_fd_buf, NULL };
 	char **args, c;
 
@@ -121,8 +121,8 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 
 	if(pid < 0)
 		err = pid;
-	os_close_file(data_remote);
-	os_close_file(control_remote);
+	close(data_remote);
+	close(control_remote);
 	CATCH_EINTR(n = read(control_me, &c, sizeof(c)));
 	if(n != sizeof(c)){
 		err = -errno;
@@ -151,19 +151,23 @@ static int etap_open(void *data)
 	if(err)
 		return err;
 
-	err = os_pipe(data_fds, 0, 0);
-	if(err < 0){
-		printk("data os_pipe failed - err = %d\n", -err);
+	err = socketpair(AF_UNIX, SOCK_DGRAM, 0, data_fds);
+	if(err){
+		err = -errno;
+		printk("etap_open - data socketpair failed - err = %d\n",
+		       errno);
 		return err;
 	}
 
-	err = os_pipe(control_fds, 1, 0);
-	if(err < 0){
-		printk("control os_pipe failed - err = %d\n", -err);
-		return err;
+	err = socketpair(AF_UNIX, SOCK_STREAM, 0, control_fds);
+	if(err){
+		err = -errno;
+		printk("etap_open - control socketpair failed - err = %d\n",
+		       errno);
+		goto out_close_data;
 	}
 
-	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0], 
+	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0],
 			 control_fds[1], data_fds[0], data_fds[1]);
 	output_len = UM_KERN_PAGE_SIZE;
 	output = kmalloc(output_len, UM_GFP_KERNEL);
@@ -178,13 +182,21 @@ static int etap_open(void *data)
 
 	if(err < 0){
 		printk("etap_tramp failed - err = %d\n", -err);
-		return err;
+		goto out_close_control;
 	}
 
 	pri->data_fd = data_fds[0];
 	pri->control_fd = control_fds[0];
 	iter_addresses(pri->dev, etap_open_addr, &pri->control_fd);
 	return data_fds[0];
+
+out_close_control:
+	close(control_fds[0]);
+	close(control_fds[1]);
+out_close_data:
+	close(data_fds[0]);
+	close(data_fds[1]);
+	return err;
 }
 
 static void etap_close(int fd, void *data)
@@ -192,11 +204,19 @@ static void etap_close(int fd, void *data)
 	struct ethertap_data *pri = data;
 
 	iter_addresses(pri->dev, etap_close_addr, &pri->control_fd);
-	os_close_file(fd);
-	os_shutdown_socket(pri->data_fd, 1, 1);
-	os_close_file(pri->data_fd);
+	close(fd);
+
+	if(shutdown(pri->data_fd, SHUT_RDWR) < 0)
+		printk("etap_close - shutdown data socket failed, errno = %d\n",
+		       errno);
+
+	if(shutdown(pri->control_fd, SHUT_RDWR) < 0)
+		printk("etap_close - shutdown control socket failed, "
+		       "errno = %d\n", errno);
+
+	close(pri->data_fd);
 	pri->data_fd = -1;
-	os_close_file(pri->control_fd);
+	close(pri->control_fd);
 	pri->control_fd = -1;
 }
 
@@ -216,13 +236,14 @@ static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
 	etap_open_addr(addr, netmask, &pri->control_fd);
 }
 
-static void etap_del_addr(unsigned char *addr, unsigned char *netmask, 
+static void etap_del_addr(unsigned char *addr, unsigned char *netmask,
 			  void *data)
 {
 	struct ethertap_data *pri = data;
 
 	if(pri->control_fd == -1)
 		return;
+
 	etap_close_addr(addr, netmask, &pri->control_fd);
 }
 

commit e4c4bf9968cb4f0fceb1b8fb54790ccae73caf4e
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:56 2007 -0700

    uml: Eliminate kernel allocator wrappers
    
    UML had two wrapper procedures for kmalloc, um_kmalloc and um_kmalloc_atomic
    because the flag constants weren't available in userspace code.
    kern_constants.h had made kernel constants available for a long time, so there
    is no need for these wrappers any more.  Rather, userspace code calls kmalloc
    directly with the userspace versions of the gfp flags.
    
    kmalloc isn't a real procedure, so I had to essentially copy the inline
    wrapper around __kmalloc.
    
    vmalloc also had its own wrapper for no good reason.  This is now gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index cac01b31ea95..61d3953c7ac9 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -54,7 +54,7 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 		return;
 	}
 
-	output = um_kmalloc(UM_KERN_PAGE_SIZE);
+	output = kmalloc(UM_KERN_PAGE_SIZE, UM_GFP_KERNEL);
 	if(output == NULL)
 		printk("etap_change : Failed to allocate output buffer\n");
 	read_output(fd, output, UM_KERN_PAGE_SIZE);
@@ -166,7 +166,7 @@ static int etap_open(void *data)
 	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0], 
 			 control_fds[1], data_fds[0], data_fds[1]);
 	output_len = UM_KERN_PAGE_SIZE;
-	output = um_kmalloc(output_len);
+	output = kmalloc(output_len, UM_GFP_KERNEL);
 	read_output(control_fds[0], output, output_len);
 
 	if(output == NULL)

commit c43990162fc7f9d2f15a12797fdc6f9c0905f704
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:56 2007 -0700

    uml: simplify helper stack handling
    
    run_helper and run_helper_thread had arguments which were the same in all
    callers.  run_helper's stack_out was always NULL and run_helper_thread's
    stack_order was always 0.  These are now gone, and the constants folded
    into the code.
    
    Also fixed leaks of the helper stack in the AIO and SIGIO code.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index acba30161287..cac01b31ea95 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -117,7 +117,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	pe_data.control_remote = control_remote;
 	pe_data.control_me = control_me;
 	pe_data.data_me = data_me;
-	pid = run_helper(etap_pre_exec, &pe_data, args, NULL);
+	pid = run_helper(etap_pre_exec, &pe_data, args);
 
 	if(pid < 0)
 		err = pid;

commit a61f334fd2864b9b040f7e882726426ed7e8a317
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:35 2007 -0700

    uml: convert libc layer to call read and write
    
    This patch converts calls in the os layer to os_{read,write}_file to calls
    directly to libc read() and write() where it is clear that the I/O buffer is
    in the kernel.
    
    We can do that here instead of calling os_{read,write}_file_k since we are in
    libc code and can call libc directly.
    
    With the change in the calls, error handling needs to be changed to refer to
    errno directly rather than the return value of the call.
    
    CATCH_EINTR wrappers were also added where needed.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index fd6cfa5b4a78..acba30161287 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -48,9 +48,9 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 	change.what = op;
 	memcpy(change.addr, addr, sizeof(change.addr));
 	memcpy(change.netmask, netmask, sizeof(change.netmask));
-	n = os_write_file(fd, &change, sizeof(change));
+	CATCH_EINTR(n = write(fd, &change, sizeof(change)));
 	if(n != sizeof(change)){
-		printk("etap_change - request failed, err = %d\n", -n);
+		printk("etap_change - request failed, err = %d\n", errno);
 		return;
 	}
 
@@ -123,10 +123,11 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 		err = pid;
 	os_close_file(data_remote);
 	os_close_file(control_remote);
-	n = os_read_file(control_me, &c, sizeof(c));
+	CATCH_EINTR(n = read(control_me, &c, sizeof(c)));
 	if(n != sizeof(c)){
-		printk("etap_tramp : read of status failed, err = %d\n", -n);
-		return -EINVAL;
+		err = -errno;
+		printk("etap_tramp : read of status failed, err = %d\n", -err);
+		return err;
 	}
 	if(c != 1){
 		printk("etap_tramp : uml_net failed\n");

commit ef0470c053274c343b2be8737e0146d65e17f9be
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:33 2007 -0700

    uml: tidy libc code
    
    This patch lays some groundwork for the next one, which converts calls to
    os_{read,write}_file into {read,write}, by doing some tidying in the affected
    areas.
    
    do_not_aio gets restructured to make the final result a bit cleaner.
    
    There are also whitespace and other formatting fixes, fixes in error messages,
    and a typo fix.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 96e12ea8172c..fd6cfa5b4a78 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001 Lennert Buytenhek (buytenh@gnu.org) and 
+ * Copyright (C) 2001 Lennert Buytenhek (buytenh@gnu.org) and
  * James Leu (jleu@mindspring.net).
  * Copyright (C) 2001 by various other people who didn't put their name here.
  * Licensed under the GPL.
@@ -49,8 +49,11 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 	memcpy(change.addr, addr, sizeof(change.addr));
 	memcpy(change.netmask, netmask, sizeof(change.netmask));
 	n = os_write_file(fd, &change, sizeof(change));
-	if(n != sizeof(change))
+	if(n != sizeof(change)){
 		printk("etap_change - request failed, err = %d\n", -n);
+		return;
+	}
+
 	output = um_kmalloc(UM_KERN_PAGE_SIZE);
 	if(output == NULL)
 		printk("etap_change : Failed to allocate output buffer\n");
@@ -116,7 +119,8 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	pe_data.data_me = data_me;
 	pid = run_helper(etap_pre_exec, &pe_data, args, NULL);
 
-	if(pid < 0) err = pid;
+	if(pid < 0)
+		err = pid;
 	os_close_file(data_remote);
 	os_close_file(control_remote);
 	n = os_read_file(control_me, &c, sizeof(c));

commit 1ffb9164f51094b7105ce9f81600b222ddf5b82c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:22 2007 -0700

    uml: remove page_size()
    
    userspace code used to have to call the kernelspace function page_size() in
    order to determine the value of the kernel's PAGE_SIZE.  Since this is now
    available directly from kern_constants.h as UM_KERN_PAGE_SIZE, page_size() can
    be deleted and calls changed to use the constant.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 4e38ccf35129..96e12ea8172c 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -20,6 +20,7 @@
 #include "etap.h"
 #include "os.h"
 #include "um_malloc.h"
+#include "kern_constants.h"
 
 #define MAX_PACKET ETH_MAX_PACKET
 
@@ -50,10 +51,10 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 	n = os_write_file(fd, &change, sizeof(change));
 	if(n != sizeof(change))
 		printk("etap_change - request failed, err = %d\n", -n);
-	output = um_kmalloc(page_size());
+	output = um_kmalloc(UM_KERN_PAGE_SIZE);
 	if(output == NULL)
 		printk("etap_change : Failed to allocate output buffer\n");
-	read_output(fd, output, page_size());
+	read_output(fd, output, UM_KERN_PAGE_SIZE);
 	if(output != NULL){
 		printk("%s", output);
 		kfree(output);
@@ -159,7 +160,7 @@ static int etap_open(void *data)
 
 	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0], 
 			 control_fds[1], data_fds[0], data_fds[1]);
-	output_len = page_size();
+	output_len = UM_KERN_PAGE_SIZE;
 	output = um_kmalloc(output_len);
 	read_output(control_fds[0], output, output_len);
 

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 2cc2d3ea2e6d..4e38ccf35129 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -16,7 +16,6 @@
 #include <net/if.h>
 #include "user.h"
 #include "kern_util.h"
-#include "user_util.h"
 #include "net_user.h"
 #include "etap.h"
 #include "os.h"

commit f34d9d2dcb7f17b64124841345b23adc0843e7a5
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:04 2007 -0700

    uml: network interface hotplug error handling
    
    This fixes a number of problems associated with network interface hotplug.
    
    The userspace initialization function can fail in some cases, but the
    failure was never passed back to eth_configure, which proceeded with the
    configuration.  This results in a zombie device that is present, but can't
    work.  This is fixed by allowing the initialization routines to return an
    error, which is checked, and the configuration aborted on failure.
    
    eth_configure failed to check for many failures.  Even when it did check,
    it didn't undo whatever initializations has already happened, so a present,
    but partially initialized and non-working device could result.  It now
    checks everything that can fail, and bails out, undoing whatever had been
    done.
    
    The return value of eth_configure was always ignored, so it is now just
    void.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index f3ad0dac7cdc..2cc2d3ea2e6d 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -24,11 +24,12 @@
 
 #define MAX_PACKET ETH_MAX_PACKET
 
-void etap_user_init(void *data, void *dev)
+static int etap_user_init(void *data, void *dev)
 {
 	struct ethertap_data *pri = data;
 
 	pri->dev = dev;
+	return 0;
 }
 
 struct addr_change {

commit 56bd194bb200ef0c49517de67a7d7f4b043b11b1
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:02 2007 -0700

    uml: driver formatting fixes
    
    Fix a bunch of formatting violations in the drivers:
            return(n) -> return n
            whitespace fixes
            emacs formatting comment removal
            breaking if(foo) return(n) into two lines
    
    There are also a couple of errno use bugs:
            using errno in a printk when the failure put errno into a local variable
            saving errno after a printk, which can change it
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 863981ba1468..f3ad0dac7cdc 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -121,7 +121,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 	n = os_read_file(control_me, &c, sizeof(c));
 	if(n != sizeof(c)){
 		printk("etap_tramp : read of status failed, err = %d\n", -n);
-		return(-EINVAL);
+		return -EINVAL;
 	}
 	if(c != 1){
 		printk("etap_tramp : uml_net failed\n");
@@ -132,7 +132,7 @@ static int etap_tramp(char *dev, char *gate, int control_me,
 		else if(!WIFEXITED(status) || (WEXITSTATUS(status) != 1))
 			printk("uml_net didn't exit with status 1\n");
 	}
-	return(err);
+	return err;
 }
 
 static int etap_open(void *data)
@@ -142,20 +142,21 @@ static int etap_open(void *data)
 	int data_fds[2], control_fds[2], err, output_len;
 
 	err = tap_open_common(pri->dev, pri->gate_addr);
-	if(err) return(err);
+	if(err)
+		return err;
 
 	err = os_pipe(data_fds, 0, 0);
 	if(err < 0){
 		printk("data os_pipe failed - err = %d\n", -err);
-		return(err);
+		return err;
 	}
 
 	err = os_pipe(control_fds, 1, 0);
 	if(err < 0){
 		printk("control os_pipe failed - err = %d\n", -err);
-		return(err);
+		return err;
 	}
-	
+
 	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0], 
 			 control_fds[1], data_fds[0], data_fds[1]);
 	output_len = page_size();
@@ -171,13 +172,13 @@ static int etap_open(void *data)
 
 	if(err < 0){
 		printk("etap_tramp failed - err = %d\n", -err);
-		return(err);
+		return err;
 	}
 
 	pri->data_fd = data_fds[0];
 	pri->control_fd = control_fds[0];
 	iter_addresses(pri->dev, etap_open_addr, &pri->control_fd);
-	return(data_fds[0]);
+	return data_fds[0];
 }
 
 static void etap_close(int fd, void *data)
@@ -195,7 +196,7 @@ static void etap_close(int fd, void *data)
 
 static int etap_set_mtu(int mtu, void *data)
 {
-	return(mtu);
+	return mtu;
 }
 
 static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
@@ -204,7 +205,8 @@ static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
 	struct ethertap_data *pri = data;
 
 	tap_check_ips(pri->gate_addr, addr);
-	if(pri->control_fd == -1) return;
+	if(pri->control_fd == -1)
+		return;
 	etap_open_addr(addr, netmask, &pri->control_fd);
 }
 
@@ -213,7 +215,8 @@ static void etap_del_addr(unsigned char *addr, unsigned char *netmask,
 {
 	struct ethertap_data *pri = data;
 
-	if(pri->control_fd == -1) return;
+	if(pri->control_fd == -1)
+		return;
 	etap_close_addr(addr, netmask, &pri->control_fd);
 }
 
@@ -227,14 +230,3 @@ const struct net_user_info ethertap_user_info = {
 	.delete_address = etap_del_addr,
 	.max_packet	= MAX_PACKET - ETH_HEADER_ETHERTAP
 };
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit c13e569073b89eb75216a2551e89ae93ad1f9951
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Thu Oct 19 23:28:20 2006 -0700

    [PATCH] uml: split memory allocation prototypes out of user.h
    
    user.h is too generic a header name.  I've split out allocation routines from
    it.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index f559bdf746e6..863981ba1468 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -20,6 +20,7 @@
 #include "net_user.h"
 #include "etap.h"
 #include "os.h"
+#include "um_malloc.h"
 
 #define MAX_PACKET ETH_MAX_PACKET
 

commit 5e7672ec3f059f764fcc5c78216e24bb16c44dba
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Sep 27 01:50:33 2006 -0700

    [PATCH] uml: const more data
    
    Make lots of structures const in order to make it obvious that they need no
    locking.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 8f49507e64ef..f559bdf746e6 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -216,7 +216,7 @@ static void etap_del_addr(unsigned char *addr, unsigned char *netmask,
 	etap_close_addr(addr, netmask, &pri->control_fd);
 }
 
-struct net_user_info ethertap_user_info = {
+const struct net_user_info ethertap_user_info = {
 	.init		= etap_user_init,
 	.open		= etap_open,
 	.close	 	= etap_close,

commit 802e307795c9cf57e91389d65cb87bfe6d03a89e
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Mon Apr 10 22:53:32 2006 -0700

    [PATCH] uml: fix format errors
    
    Now that GCC warns about format errors, fix them.  Nothing able to cause a
    crash, however.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index 901b85e8a1c6..8f49507e64ef 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -40,7 +40,7 @@ static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
 			int fd)
 {
 	struct addr_change change;
-	void *output;
+	char *output;
 	int n;
 
 	change.what = op;

commit ff5c6ff54215fe284e515032878111de5d8a5ce1
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Nov 7 00:58:51 2005 -0800

    [PATCH] uml: separate libc-dependent helper code
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from helper.c file under os-Linux dir
    
    Signed-off-by: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
index cd4d6544da71..901b85e8a1c6 100644
--- a/arch/um/os-Linux/drivers/ethertap_user.c
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -19,7 +19,6 @@
 #include "user_util.h"
 #include "net_user.h"
 #include "etap.h"
-#include "helper.h"
 #include "os.h"
 
 #define MAX_PACKET ETH_MAX_PACKET

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/os-Linux/drivers/ethertap_user.c b/arch/um/os-Linux/drivers/ethertap_user.c
new file mode 100644
index 000000000000..cd4d6544da71
--- /dev/null
+++ b/arch/um/os-Linux/drivers/ethertap_user.c
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2001 Lennert Buytenhek (buytenh@gnu.org) and 
+ * James Leu (jleu@mindspring.net).
+ * Copyright (C) 2001 by various other people who didn't put their name here.
+ * Licensed under the GPL.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/errno.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <sys/un.h>
+#include <net/if.h>
+#include "user.h"
+#include "kern_util.h"
+#include "user_util.h"
+#include "net_user.h"
+#include "etap.h"
+#include "helper.h"
+#include "os.h"
+
+#define MAX_PACKET ETH_MAX_PACKET
+
+void etap_user_init(void *data, void *dev)
+{
+	struct ethertap_data *pri = data;
+
+	pri->dev = dev;
+}
+
+struct addr_change {
+	enum { ADD_ADDR, DEL_ADDR } what;
+	unsigned char addr[4];
+	unsigned char netmask[4];
+};
+
+static void etap_change(int op, unsigned char *addr, unsigned char *netmask,
+			int fd)
+{
+	struct addr_change change;
+	void *output;
+	int n;
+
+	change.what = op;
+	memcpy(change.addr, addr, sizeof(change.addr));
+	memcpy(change.netmask, netmask, sizeof(change.netmask));
+	n = os_write_file(fd, &change, sizeof(change));
+	if(n != sizeof(change))
+		printk("etap_change - request failed, err = %d\n", -n);
+	output = um_kmalloc(page_size());
+	if(output == NULL)
+		printk("etap_change : Failed to allocate output buffer\n");
+	read_output(fd, output, page_size());
+	if(output != NULL){
+		printk("%s", output);
+		kfree(output);
+	}
+}
+
+static void etap_open_addr(unsigned char *addr, unsigned char *netmask,
+			   void *arg)
+{
+	etap_change(ADD_ADDR, addr, netmask, *((int *) arg));
+}
+
+static void etap_close_addr(unsigned char *addr, unsigned char *netmask,
+			    void *arg)
+{
+	etap_change(DEL_ADDR, addr, netmask, *((int *) arg));
+}
+
+struct etap_pre_exec_data {
+	int control_remote;
+	int control_me;
+	int data_me;
+};
+
+static void etap_pre_exec(void *arg)
+{
+	struct etap_pre_exec_data *data = arg;
+
+	dup2(data->control_remote, 1);
+	os_close_file(data->data_me);
+	os_close_file(data->control_me);
+}
+
+static int etap_tramp(char *dev, char *gate, int control_me, 
+		      int control_remote, int data_me, int data_remote)
+{
+	struct etap_pre_exec_data pe_data;
+	int pid, status, err, n;
+	char version_buf[sizeof("nnnnn\0")];
+	char data_fd_buf[sizeof("nnnnnn\0")];
+	char gate_buf[sizeof("nnn.nnn.nnn.nnn\0")];
+	char *setup_args[] = { "uml_net", version_buf, "ethertap", dev,
+			       data_fd_buf, gate_buf, NULL };
+	char *nosetup_args[] = { "uml_net", version_buf, "ethertap", 
+				 dev, data_fd_buf, NULL };
+	char **args, c;
+
+	sprintf(data_fd_buf, "%d", data_remote);
+	sprintf(version_buf, "%d", UML_NET_VERSION);
+	if(gate != NULL){
+		strcpy(gate_buf, gate);
+		args = setup_args;
+	}
+	else args = nosetup_args;
+
+	err = 0;
+	pe_data.control_remote = control_remote;
+	pe_data.control_me = control_me;
+	pe_data.data_me = data_me;
+	pid = run_helper(etap_pre_exec, &pe_data, args, NULL);
+
+	if(pid < 0) err = pid;
+	os_close_file(data_remote);
+	os_close_file(control_remote);
+	n = os_read_file(control_me, &c, sizeof(c));
+	if(n != sizeof(c)){
+		printk("etap_tramp : read of status failed, err = %d\n", -n);
+		return(-EINVAL);
+	}
+	if(c != 1){
+		printk("etap_tramp : uml_net failed\n");
+		err = -EINVAL;
+		CATCH_EINTR(n = waitpid(pid, &status, 0));
+		if(n < 0)
+			err = -errno;
+		else if(!WIFEXITED(status) || (WEXITSTATUS(status) != 1))
+			printk("uml_net didn't exit with status 1\n");
+	}
+	return(err);
+}
+
+static int etap_open(void *data)
+{
+	struct ethertap_data *pri = data;
+	char *output;
+	int data_fds[2], control_fds[2], err, output_len;
+
+	err = tap_open_common(pri->dev, pri->gate_addr);
+	if(err) return(err);
+
+	err = os_pipe(data_fds, 0, 0);
+	if(err < 0){
+		printk("data os_pipe failed - err = %d\n", -err);
+		return(err);
+	}
+
+	err = os_pipe(control_fds, 1, 0);
+	if(err < 0){
+		printk("control os_pipe failed - err = %d\n", -err);
+		return(err);
+	}
+	
+	err = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0], 
+			 control_fds[1], data_fds[0], data_fds[1]);
+	output_len = page_size();
+	output = um_kmalloc(output_len);
+	read_output(control_fds[0], output, output_len);
+
+	if(output == NULL)
+		printk("etap_open : failed to allocate output buffer\n");
+	else {
+		printk("%s", output);
+		kfree(output);
+	}
+
+	if(err < 0){
+		printk("etap_tramp failed - err = %d\n", -err);
+		return(err);
+	}
+
+	pri->data_fd = data_fds[0];
+	pri->control_fd = control_fds[0];
+	iter_addresses(pri->dev, etap_open_addr, &pri->control_fd);
+	return(data_fds[0]);
+}
+
+static void etap_close(int fd, void *data)
+{
+	struct ethertap_data *pri = data;
+
+	iter_addresses(pri->dev, etap_close_addr, &pri->control_fd);
+	os_close_file(fd);
+	os_shutdown_socket(pri->data_fd, 1, 1);
+	os_close_file(pri->data_fd);
+	pri->data_fd = -1;
+	os_close_file(pri->control_fd);
+	pri->control_fd = -1;
+}
+
+static int etap_set_mtu(int mtu, void *data)
+{
+	return(mtu);
+}
+
+static void etap_add_addr(unsigned char *addr, unsigned char *netmask,
+			  void *data)
+{
+	struct ethertap_data *pri = data;
+
+	tap_check_ips(pri->gate_addr, addr);
+	if(pri->control_fd == -1) return;
+	etap_open_addr(addr, netmask, &pri->control_fd);
+}
+
+static void etap_del_addr(unsigned char *addr, unsigned char *netmask, 
+			  void *data)
+{
+	struct ethertap_data *pri = data;
+
+	if(pri->control_fd == -1) return;
+	etap_close_addr(addr, netmask, &pri->control_fd);
+}
+
+struct net_user_info ethertap_user_info = {
+	.init		= etap_user_init,
+	.open		= etap_open,
+	.close	 	= etap_close,
+	.remove	 	= NULL,
+	.set_mtu	= etap_set_mtu,
+	.add_address	= etap_add_addr,
+	.delete_address = etap_del_addr,
+	.max_packet	= MAX_PACKET - ETH_HEADER_ETHERTAP
+};
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
