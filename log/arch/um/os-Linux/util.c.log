commit 97870c34b453251cda9c2341f8534b78003a74dc
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:18 2019 +0100

    um: Add SPDX headers for files in arch/um/os-Linux
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 8cc8b2617a67..ecf2f390fad2 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2000 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <stdio.h>

commit 721ccae88d04f7e9334fde4cbb3eecfaa70a31ac
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu May 18 02:18:22 2017 +0900

    um: Add os_warn() for pre-boot warning/error messages
    
    Add os_warn() for printing out pre-boot warning/error
    messages in stderr. The messages via os_warn() are not
    suppressed by quiet option.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index c9bad1bca108..8cc8b2617a67 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -177,3 +177,12 @@ void os_info(const char *fmt, ...)
 	vfprintf(stderr, fmt, list);
 	va_end(list);
 }
+
+void os_warn(const char *fmt, ...)
+{
+	va_list list;
+
+	va_start(list, fmt);
+	vfprintf(stderr, fmt, list);
+	va_end(list);
+}

commit f7887ee11082b468517f31ae315b474eaa48b843
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu May 18 02:16:05 2017 +0900

    um: Add os_info() for pre-boot information messages
    
    Add os_info() for printing out pre-boot information
    level messages in stderr. The messages via os_info()
    are suppressed by "quiet" kernel command line.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index faee55ef6d2f..c9bad1bca108 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -13,6 +13,7 @@
 #include <wait.h>
 #include <sys/mman.h>
 #include <sys/utsname.h>
+#include <init.h>
 #include <os.h>
 
 void stack_protections(unsigned long address)
@@ -152,3 +153,27 @@ void um_early_printk(const char *s, unsigned int n)
 {
 	printf("%.*s", n, s);
 }
+
+static int quiet_info;
+
+static int __init quiet_cmd_param(char *str, int *add)
+{
+	quiet_info = 1;
+	return 0;
+}
+
+__uml_setup("quiet", quiet_cmd_param,
+"quiet\n"
+"    Turns off information messages during boot.\n\n");
+
+void os_info(const char *fmt, ...)
+{
+	va_list list;
+
+	if (quiet_info)
+		return;
+
+	va_start(list, fmt);
+	vfprintf(stderr, fmt, list);
+	va_end(list);
+}

commit 91d44ff860a9e9c0db81a89cbc24fa31fbd8e6d3
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Aug 18 13:30:08 2013 +0200

    um: Cleanup SIGTERM handling
    
    Richard reported that some UML processes survive if the UML
    main process receives a SIGTERM.
    This issue was caused by a wrongly placed signal(SIGTERM, SIG_DFL)
    in init_new_thread_signals().
    It disabled the UML exit handler accidently for some processes.
    The correct solution is to disable the fatal handler for all
    UML helper threads/processes.
    Such that last_ditch_exit() does not get called multiple times
    and all processes can exit due to SIGTERM.
    
    Reported-and-tested-by: Richard W.M. Jones <rjones@redhat.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 492ef5e6e166..faee55ef6d2f 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -94,6 +94,16 @@ static inline void __attribute__ ((noreturn)) uml_abort(void)
 			exit(127);
 }
 
+/*
+ * UML helper threads must not handle SIGWINCH/INT/TERM
+ */
+void os_fix_helper_signals(void)
+{
+	signal(SIGWINCH, SIG_IGN);
+	signal(SIGINT, SIG_DFL);
+	signal(SIGTERM, SIG_DFL);
+}
+
 void os_dump_core(void)
 {
 	int pid;

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 9e3b43bb84c9..492ef5e6e166 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -13,7 +13,7 @@
 #include <wait.h>
 #include <sys/mman.h>
 #include <sys/utsname.h>
-#include "os.h"
+#include <os.h>
 
 void stack_protections(unsigned long address)
 {

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 5803b1887672..9e3b43bb84c9 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -13,9 +13,7 @@
 #include <wait.h>
 #include <sys/mman.h>
 #include <sys/utsname.h>
-#include "kern_constants.h"
 #include "os.h"
-#include "user.h"
 
 void stack_protections(unsigned long address)
 {

commit d634f194d4e2e58d57927c812aca097e67a2287d
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 24 17:13:01 2011 -0700

    um: add earlyprintk support
    
    User Mode Linux can also benefit from earlyprintk.  UML's earlyprintk
    writes kernel messages directly to stdout.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 42827cafa6af..5803b1887672 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -139,3 +139,8 @@ void os_dump_core(void)
 
 	uml_abort();
 }
+
+void um_early_printk(const char *s, unsigned int n)
+{
+	printf("%.*s", n, s);
+}

commit b2db21997f43907f54500edaf063253ca2a186f9
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 17 15:44:11 2011 -0700

    um: fix abort
    
    os_dump_core() uses abort() to terminate UML in case of an fatal error.
    
    glibc's abort() calls raise(SIGABRT) which makes use of tgkill().
    tgkill() has no effect within UML's kernel threads because they are not
    pthreads.  As fallback abort() executes an invalid instruction to
    terminate the process.  Therefore UML gets killed by SIGSEGV and leaves a
    ugly log entry in the host's kernel ring buffer.
    
    To get rid of this we use our own abort routine.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 6ea77979531c..42827cafa6af 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -5,6 +5,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <errno.h>
 #include <signal.h>
 #include <string.h>
@@ -75,6 +76,26 @@ void setup_hostinfo(char *buf, int len)
 		 host.release, host.version, host.machine);
 }
 
+/*
+ * We cannot use glibc's abort(). It makes use of tgkill() which
+ * has no effect within UML's kernel threads.
+ * After that glibc would execute an invalid instruction to kill
+ * the calling process and UML crashes with SIGSEGV.
+ */
+static inline void __attribute__ ((noreturn)) uml_abort(void)
+{
+	sigset_t sig;
+
+	fflush(NULL);
+
+	if (!sigemptyset(&sig) && !sigaddset(&sig, SIGABRT))
+		sigprocmask(SIG_UNBLOCK, &sig, 0);
+
+	for (;;)
+		if (kill(getpid(), SIGABRT) < 0)
+			exit(127);
+}
+
 void os_dump_core(void)
 {
 	int pid;
@@ -116,5 +137,5 @@ void os_dump_core(void)
 	while ((pid = waitpid(-1, NULL, WNOHANG | __WALL)) > 0)
 		os_kill_ptraced_process(pid, 0);
 
-	abort();
+	uml_abort();
 }

commit 5134d8fea06ab51459fd095d091d1e6f73a44553
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Feb 8 04:22:08 2008 -0800

    uml: style fixes in arch/um/os-Linux
    
    Style changes under arch/um/os-Linux:
            include trimming
            CodingStyle fixes
            some printks needed severity indicators
    
    make_tempfile turns out not to be used outside of mem.c, so it is now static.
    Its declaration in tempfile.h is no longer needed, and tempfile.h itself is no
    longer needed.
    
    create_tmp_file was also made static.
    
    checkpatch moans about an EXPORT_SYMBOL in user_syms.c which is part of a
    macro definition - this is copying a bit of kernel infrastructure into the
    libc side of UML because the kernel headers can't be included there.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index a6f31d476993..6ea77979531c 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -1,39 +1,24 @@
 /*
- * Copyright (C) 2000, 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2000 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
-#include <limits.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/utsname.h>
-#include <sys/param.h>
-#include <sys/time.h>
-#include "asm/types.h"
-#include <ctype.h>
-#include <signal.h>
-#include <wait.h>
 #include <errno.h>
-#include <stdarg.h>
-#include <sched.h>
-#include <termios.h>
+#include <signal.h>
 #include <string.h>
-#include "kern_util.h"
-#include "user.h"
-#include "mem_user.h"
-#include "init.h"
-#include "ptrace_user.h"
-#include "uml-config.h"
-#include "os.h"
-#include "longjmp.h"
+#include <termios.h>
+#include <wait.h>
+#include <sys/mman.h>
+#include <sys/utsname.h>
 #include "kern_constants.h"
+#include "os.h"
+#include "user.h"
 
 void stack_protections(unsigned long address)
 {
-	if(mprotect((void *) address, UM_THREAD_SIZE,
+	if (mprotect((void *) address, UM_THREAD_SIZE,
 		    PROT_READ | PROT_WRITE | PROT_EXEC) < 0)
 		panic("protecting stack failed, errno = %d", errno);
 }
@@ -44,17 +29,19 @@ int raw(int fd)
 	int err;
 
 	CATCH_EINTR(err = tcgetattr(fd, &tt));
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
 	cfmakeraw(&tt);
 
 	CATCH_EINTR(err = tcsetattr(fd, TCSADRAIN, &tt));
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
-	/* XXX tcsetattr could have applied only some changes
-	 * (and cfmakeraw() is a set of changes) */
+	/*
+	 * XXX tcsetattr could have applied only some changes
+	 * (and cfmakeraw() is a set of changes)
+	 */
 	return 0;
 }
 

commit 8efa3c9d545ab6adc5c5e001cbd7aee60909b3da
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:07 2008 -0800

    uml: eliminate setjmp_wrapper
    
    setjmp_wrapper existed to provide setjmp to kernel code when UML used libc's
    setjmp and longjmp.  Now that UML has its own implementation, this isn't
    needed and kernel code can invoke setjmp directly.
    
    do_buffer_op is massively cleaned up since it is no longer a callback from
    setjmp_wrapper and given a va_list from which it must extract its arguments.
    
    The actual setjmp is moved from buffer_op to do_op_one_page because the copy
    operation is inside an atomic section (kmap_atomic to kunmap_atomic) and it
    shouldn't be longjmp-ed out of.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 3e058ce9ffb6..a6f31d476993 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -88,21 +88,6 @@ void setup_hostinfo(char *buf, int len)
 		 host.release, host.version, host.machine);
 }
 
-int setjmp_wrapper(void (*proc)(void *, void *), ...)
-{
-	va_list args;
-	jmp_buf buf;
-	int n;
-
-	n = UML_SETJMP(&buf);
-	if(n == 0){
-		va_start(args, proc);
-		(*proc)(&buf, &args);
-	}
-	va_end(args);
-	return n;
-}
-
 void os_dump_core(void)
 {
 	int pid;

commit 4dbed85a35ed37d9608f4f32e5d69efa775d6223
Author: Stanislaw Gruszka <stf_xl@wp.pl>
Date:   Mon Dec 17 16:19:46 2007 -0800

    uml: stop gdb from deleting breakpoints when running UML
    
    Sometimes when UML is debugged gdb miss breakpoints.
    
    When process traced by gdb do fork, debugger remove breakpoints from
    child address space. There is possibility to trace more than one fork,
    but this not work with UML, I guess (only guess) there is a deadlock -
    gdb waits for UML and UML waits for gdb.
    
    When clone() is called with SIGCHLD and CLONE_VM flags, gdb see this
    as PTRACE_EVENT_FORK not as PTRACE_EVENT_CLONE and remove breakpoints
    from child and at the same time from traced process, because either
    have the same address space.
    
    Maybe it is possible to do fix in gdb, but I'm not sure if there is
    easy way to find out if traced and child processes share memory. So I
    do fix for UML, it simply do not call clone() with both SIGCHLD and
    CLONE_VM flags together.  Additionally __WALL flag is used for
    waitpid() to assure not miss clone and normal process events.
    
    [ jdike - checkpatch fixes ]
    
    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index ef095436a78c..3e058ce9ffb6 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -141,7 +141,7 @@ void os_dump_core(void)
 	 * nothing reasonable to do if that fails.
 	 */
 
-	while ((pid = waitpid(-1, NULL, WNOHANG)) > 0)
+	while ((pid = waitpid(-1, NULL, WNOHANG | __WALL)) > 0)
 		os_kill_ptraced_process(pid, 0);
 
 	abort();

commit a24864a1d52a97e345a6bd4862a057f98364d098
Author: Lepton Wu <ytht.net@gmail.com>
Date:   Tue Oct 16 01:27:35 2007 -0700

    uml: definitively kill subprocesses on panic
    
    In a stock 2.6.22.6 kernel, poweroff a user mode linux guest (2.6.22.6 running
    in skas0 mode) will halt the host linux.  I think the reason is the kernel
    thread abort because of a bug.  Then the sys_reboot in process of user mode
    linux guest is not trapped by the user mode linux kernel and is executed by
    host.  I think it is better to make sure all of our children process to quit
    when user mode linux kernel abort.
    
    [ jdike - the kernel process needs to ignore SIGTERM, plus the waitpid/kill
    loop is needed to make sure that all of our children are dead before the
    kernel exits ]
    
    Signed-off-by: Lepton Wu <ytht.net@gmail.com>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 7cbcf484e13d..ef095436a78c 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -105,6 +105,44 @@ int setjmp_wrapper(void (*proc)(void *, void *), ...)
 
 void os_dump_core(void)
 {
+	int pid;
+
 	signal(SIGSEGV, SIG_DFL);
+
+	/*
+	 * We are about to SIGTERM this entire process group to ensure that
+	 * nothing is around to run after the kernel exits.  The
+	 * kernel wants to abort, not die through SIGTERM, so we
+	 * ignore it here.
+	 */
+
+	signal(SIGTERM, SIG_IGN);
+	kill(0, SIGTERM);
+	/*
+	 * Most of the other processes associated with this UML are
+	 * likely sTopped, so give them a SIGCONT so they see the
+	 * SIGTERM.
+	 */
+	kill(0, SIGCONT);
+
+	/*
+	 * Now, having sent signals to everyone but us, make sure they
+	 * die by ptrace.  Processes can survive what's been done to
+	 * them so far - the mechanism I understand is receiving a
+	 * SIGSEGV and segfaulting immediately upon return.  There is
+	 * always a SIGSEGV pending, and (I'm guessing) signals are
+	 * processed in numeric order so the SIGTERM (signal 15 vs
+	 * SIGSEGV being signal 11) is never handled.
+	 *
+	 * Run a waitpid loop until we get some kind of error.
+	 * Hopefully, it's ECHILD, but there's not a lot we can do if
+	 * it's something else.  Tell os_kill_ptraced_process not to
+	 * wait for the child to report its death because there's
+	 * nothing reasonable to do if that fails.
+	 */
+
+	while ((pid = waitpid(-1, NULL, WNOHANG)) > 0)
+		os_kill_ptraced_process(pid, 0);
+
 	abort();
 }

commit 57598fd7b31f6437874308a79ca23e51c74da59b
Author: Jeff Dike <jdike@addtoit.com>
Date:   Thu May 10 22:22:30 2007 -0700

    uml: remove task_protections
    
    Replaced task_protections with stack_protections since they do the same
    thing, and task_protections was misnamed anyway.
    
    This needs THREAD_SIZE, so that's imported via common-offsets.h
    
    Also tidied up the code in the vicinity.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index c307a89ed259..7cbcf484e13d 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -33,25 +33,8 @@
 
 void stack_protections(unsigned long address)
 {
-	int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
-
-	if(mprotect((void *) address, UM_KERN_PAGE_SIZE, prot) < 0)
-		panic("protecting stack failed, errno = %d", errno);
-}
-
-void task_protections(unsigned long address)
-{
-	unsigned long guard = address + UM_KERN_PAGE_SIZE;
-	unsigned long stack = guard + UM_KERN_PAGE_SIZE;
-	int prot = 0, pages;
-
-#ifdef notdef
-	if(mprotect((void *) stack, UM_KERN_PAGE_SIZE, prot) < 0)
-		panic("protecting guard page failed, errno = %d", errno);
-#endif
-	pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER) - 2;
-	prot = PROT_READ | PROT_WRITE | PROT_EXEC;
-	if(mprotect((void *) stack, pages * UM_KERN_PAGE_SIZE, prot) < 0)
+	if(mprotect((void *) address, UM_THREAD_SIZE,
+		    PROT_READ | PROT_WRITE | PROT_EXEC) < 0)
 		panic("protecting stack failed, errno = %d", errno);
 }
 
@@ -72,7 +55,7 @@ int raw(int fd)
 
 	/* XXX tcsetattr could have applied only some changes
 	 * (and cfmakeraw() is a set of changes) */
-	return(0);
+	return 0;
 }
 
 void setup_machinename(char *machine_out)

commit 63843c265fd0e0c7894f713e0db5777560e756ae
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:39 2007 -0700

    uml: dump core on panic
    
    Dump core after a panic.  This will provide better debugging information than
    is currently available.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 48bc4927b996..c307a89ed259 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -119,3 +119,9 @@ int setjmp_wrapper(void (*proc)(void *, void *), ...)
 	va_end(args);
 	return n;
 }
+
+void os_dump_core(void)
+{
+	signal(SIGSEGV, SIG_DFL);
+	abort();
+}

commit 1ffb9164f51094b7105ce9f81600b222ddf5b82c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:22 2007 -0700

    uml: remove page_size()
    
    userspace code used to have to call the kernelspace function page_size() in
    order to determine the value of the kernel's PAGE_SIZE.  Since this is now
    available directly from kern_constants.h as UM_KERN_PAGE_SIZE, page_size() can
    be deleted and calls changed to use the constant.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 0e771bb04dd2..48bc4927b996 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -29,28 +29,29 @@
 #include "uml-config.h"
 #include "os.h"
 #include "longjmp.h"
+#include "kern_constants.h"
 
 void stack_protections(unsigned long address)
 {
 	int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
 
-	if(mprotect((void *) address, page_size(), prot) < 0)
+	if(mprotect((void *) address, UM_KERN_PAGE_SIZE, prot) < 0)
 		panic("protecting stack failed, errno = %d", errno);
 }
 
 void task_protections(unsigned long address)
 {
-	unsigned long guard = address + page_size();
-	unsigned long stack = guard + page_size();
+	unsigned long guard = address + UM_KERN_PAGE_SIZE;
+	unsigned long stack = guard + UM_KERN_PAGE_SIZE;
 	int prot = 0, pages;
 
 #ifdef notdef
-	if(mprotect((void *) stack, page_size(), prot) < 0)
+	if(mprotect((void *) stack, UM_KERN_PAGE_SIZE, prot) < 0)
 		panic("protecting guard page failed, errno = %d", errno);
 #endif
 	pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER) - 2;
 	prot = PROT_READ | PROT_WRITE | PROT_EXEC;
-	if(mprotect((void *) stack, pages * page_size(), prot) < 0)
+	if(mprotect((void *) stack, pages * UM_KERN_PAGE_SIZE, prot) < 0)
 		panic("protecting stack failed, errno = %d", errno);
 }
 

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 125854a2aa22..0e771bb04dd2 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -21,7 +21,6 @@
 #include <sched.h>
 #include <termios.h>
 #include <string.h>
-#include "user_util.h"
 #include "kern_util.h"
 #include "user.h"
 #include "mem_user.h"

commit b4ffb6ad8d8477b561377ca150bbbfc0db02da54
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:50:59 2007 -0700

    uml: host_info tidying
    
    Move the host_info string from util.c to um_arch.c, where it is
    actually initialized and used.  Also document its lack of locking.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 56b8a50e8bc2..125854a2aa22 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -96,15 +96,13 @@ void setup_machinename(char *machine_out)
 	strcpy(machine_out, host.machine);
 }
 
-char host_info[(_UTSNAME_LENGTH + 1) * 4 + _UTSNAME_NODENAME_LENGTH + 1];
-
-void setup_hostinfo(void)
+void setup_hostinfo(char *buf, int len)
 {
 	struct utsname host;
 
 	uname(&host);
-	sprintf(host_info, "%s %s %s %s %s", host.sysname, host.nodename,
-		host.release, host.version, host.machine);
+	snprintf(buf, len, "%s %s %s %s %s", host.sysname, host.nodename,
+		 host.release, host.version, host.machine);
 }
 
 int setjmp_wrapper(void (*proc)(void *, void *), ...)

commit 69fada32d868d7f4be128ea4df8fbe4fd897fc34
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Wed Oct 11 01:21:36 2006 -0700

    [PATCH] uml: fix uname under setarch i386
    
    On a 64bit Uml, if run under "setarch i386" (which a user did), uname()
    currently returns the obtained i686 as machine - fix that.  Btw, I'm quite
    surprised that under setarch i386 a 64-bit binary can run.
    
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index 3f5b1514e8a7..56b8a50e8bc2 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -80,11 +80,18 @@ void setup_machinename(char *machine_out)
 	struct utsname host;
 
 	uname(&host);
-#if defined(UML_CONFIG_UML_X86) && !defined(UML_CONFIG_64BIT)
+#ifdef UML_CONFIG_UML_X86
+# ifndef UML_CONFIG_64BIT
 	if (!strcmp(host.machine, "x86_64")) {
 		strcpy(machine_out, "i686");
 		return;
 	}
+# else
+	if (!strcmp(host.machine, "i686")) {
+		strcpy(machine_out, "x86_64");
+		return;
+	}
+# endif
 #endif
 	strcpy(machine_out, host.machine);
 }

commit 13c06be399902c9ebda08e092edb1614bb4a3761
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Sep 25 23:32:59 2006 -0700

    [PATCH] uml: Use klibc setjmp/longjmp
    
    This patch adds an implementation of setjmp and longjmp to UML, allowing
    access to the inside of a jmpbuf without needing the access macros formerly
    provided by libc.
    
    The implementation is stolen from klibc.  I copy the relevant files into
    arch/um.  I have another patch which avoids the copying, but requires klibc be
    in the tree.
    
    setjmp and longjmp users required some tweaking.  Includes of <setjmp.h> were
    removed and includes of the UML longjmp.h were added where necessary.  There
    are also replacements of siglongjmp with UML_LONGJMP which I somehow missed
    earlier.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index c47a2a7ce70e..3f5b1514e8a7 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -7,7 +7,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <limits.h>
-#include <setjmp.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/utsname.h>
@@ -107,11 +106,11 @@ int setjmp_wrapper(void (*proc)(void *, void *), ...)
 	jmp_buf buf;
 	int n;
 
-	n = sigsetjmp(buf, 1);
+	n = UML_SETJMP(&buf);
 	if(n == 0){
 		va_start(args, proc);
 		(*proc)(&buf, &args);
 	}
 	va_end(args);
-	return(n);
+	return n;
 }

commit ad28e029789ef46aebdfb9ece01d431ce1c637c8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Apr 18 22:21:41 2006 -0700

    [PATCH] uml: change sigjmp_buf to jmp_buf
    
    Clean up the jmpbuf code.  Since softints, we no longer use sig_setjmp, so
    the UML_SIGSETJMP wrapper now has a misleading name.  Also, I forgot to
    change the buffers from sigjmp_buf to jmp_buf.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index e32065e2fdc8..c47a2a7ce70e 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -104,7 +104,7 @@ void setup_hostinfo(void)
 int setjmp_wrapper(void (*proc)(void *, void *), ...)
 {
 	va_list args;
-	sigjmp_buf buf;
+	jmp_buf buf;
 	int n;
 
 	n = sigsetjmp(buf, 1);

commit 1d7173baf286c8b720f97f119ec92be43076ebde
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Jan 18 17:42:49 2006 -0800

    [PATCH] uml: implement soft interrupts
    
    This patch implements soft interrupts.  Interrupt enabling and disabling no
    longer map to sigprocmask.  Rather, a flag is set indicating whether
    interrupts may be handled.  If a signal comes in and interrupts are marked as
    OK, then it is handled normally.  If interrupts are marked as off, then the
    signal handler simply returns after noting that a signal needs handling.  When
    interrupts are enabled later on, this pending signals flag is checked, and the
    IRQ handlers are called at that point.
    
    The point of this is to reduce the cost of local_irq_save et al, since they
    are very much more common than the signals that they are enabling and
    disabling.  Soft interrupts produce a speed-up of ~25% on a kernel build.
    
    Subtleties -
    
        UML uses sigsetjmp/siglongjmp to switch contexts.  sigsetjmp has been
        wrapped in a save_flags-like macro which remembers the interrupt state at
        setjmp time, and restores it when it is longjmp-ed back to.
    
        The enable_signals function has to loop because the IRQ handler
        disables interrupts before returning.  enable_signals has to return with
        signals enabled, and signals may come in between the disabling and the
        return to enable_signals.  So, it loops for as long as there are pending
        signals, ensuring that signals are enabled when it finally returns, and
        that there are no pending signals that need to be dealt with.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
index d224434d5610..e32065e2fdc8 100644
--- a/arch/um/os-Linux/util.c
+++ b/arch/um/os-Linux/util.c
@@ -30,6 +30,7 @@
 #include "ptrace_user.h"
 #include "uml-config.h"
 #include "os.h"
+#include "longjmp.h"
 
 void stack_protections(unsigned long address)
 {

commit 4fef0c10fa174b57a10854b8b4b2b90d155706e0
Author: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
Date:   Wed Jan 18 17:42:41 2006 -0800

    [PATCH] uml: move libc-dependent utility procedures
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from user_util.c file under os-Linux dir
    
    Signed-off-by: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/util.c b/arch/um/os-Linux/util.c
new file mode 100644
index 000000000000..d224434d5610
--- /dev/null
+++ b/arch/um/os-Linux/util.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2000, 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <limits.h>
+#include <setjmp.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/utsname.h>
+#include <sys/param.h>
+#include <sys/time.h>
+#include "asm/types.h"
+#include <ctype.h>
+#include <signal.h>
+#include <wait.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sched.h>
+#include <termios.h>
+#include <string.h>
+#include "user_util.h"
+#include "kern_util.h"
+#include "user.h"
+#include "mem_user.h"
+#include "init.h"
+#include "ptrace_user.h"
+#include "uml-config.h"
+#include "os.h"
+
+void stack_protections(unsigned long address)
+{
+	int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
+
+	if(mprotect((void *) address, page_size(), prot) < 0)
+		panic("protecting stack failed, errno = %d", errno);
+}
+
+void task_protections(unsigned long address)
+{
+	unsigned long guard = address + page_size();
+	unsigned long stack = guard + page_size();
+	int prot = 0, pages;
+
+#ifdef notdef
+	if(mprotect((void *) stack, page_size(), prot) < 0)
+		panic("protecting guard page failed, errno = %d", errno);
+#endif
+	pages = (1 << UML_CONFIG_KERNEL_STACK_ORDER) - 2;
+	prot = PROT_READ | PROT_WRITE | PROT_EXEC;
+	if(mprotect((void *) stack, pages * page_size(), prot) < 0)
+		panic("protecting stack failed, errno = %d", errno);
+}
+
+int raw(int fd)
+{
+	struct termios tt;
+	int err;
+
+	CATCH_EINTR(err = tcgetattr(fd, &tt));
+	if(err < 0)
+		return -errno;
+
+	cfmakeraw(&tt);
+
+	CATCH_EINTR(err = tcsetattr(fd, TCSADRAIN, &tt));
+	if(err < 0)
+		return -errno;
+
+	/* XXX tcsetattr could have applied only some changes
+	 * (and cfmakeraw() is a set of changes) */
+	return(0);
+}
+
+void setup_machinename(char *machine_out)
+{
+	struct utsname host;
+
+	uname(&host);
+#if defined(UML_CONFIG_UML_X86) && !defined(UML_CONFIG_64BIT)
+	if (!strcmp(host.machine, "x86_64")) {
+		strcpy(machine_out, "i686");
+		return;
+	}
+#endif
+	strcpy(machine_out, host.machine);
+}
+
+char host_info[(_UTSNAME_LENGTH + 1) * 4 + _UTSNAME_NODENAME_LENGTH + 1];
+
+void setup_hostinfo(void)
+{
+	struct utsname host;
+
+	uname(&host);
+	sprintf(host_info, "%s %s %s %s %s", host.sysname, host.nodename,
+		host.release, host.version, host.machine);
+}
+
+int setjmp_wrapper(void (*proc)(void *, void *), ...)
+{
+	va_list args;
+	sigjmp_buf buf;
+	int n;
+
+	n = sigsetjmp(buf, 1);
+	if(n == 0){
+		va_start(args, proc);
+		(*proc)(&buf, &args);
+	}
+	va_end(args);
+	return(n);
+}
