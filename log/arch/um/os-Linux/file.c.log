commit 54ebe4060fe6c4ab76c79354417612ac9cf4f95e
Author: Anton Ivanov <anton.ivanov@cambridgegreys.com>
Date:   Wed Apr 22 17:00:01 2020 +0100

    um: Use fdatasync() when mapping the UBD FSYNC command
    
    We do not need to update the metadata (atime, mtime, etc)
    on the UBD file and/or the COW file until UML exits.
    
    UBD image mtime is checked in UML only when opening
    the files. After that they are locked and used
    exclusively by a single UML instance, so there is
    no point wasting resources on updating metadata on
    every sync. We can sync data only. The host will
    always update mtime if a file has been modified upon
    closing it.
    
    Signed-off-by: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 044836ad7392..e4421dbc4c36 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -290,7 +290,7 @@ int os_write_file(int fd, const void *buf, int len)
 
 int os_sync_file(int fd)
 {
-	int n = fsync(fd);
+	int n = fdatasync(fd);
 
 	if (n < 0)
 		return -errno;

commit 38bccfbeb0af039e59eb75fe6d9b2a83cda3d381
Author: Zach van Rijn <me@zv.io>
Date:   Wed Apr 1 16:30:48 2020 -0500

    um: Add include: memset() and memcpy() are in <string.h>
    
    These two functions are otherwise unknown to the pedantic compiler.
    Include the correct header to enable the build to succeed.
    
    Signed-off-by: Zach van Rijn <me@zv.io>
    Acked-By: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 26ecbd64c409..044836ad7392 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -6,6 +6,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>

commit 88ce642492339f49a0b391af40e5798c08948e49
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 13 14:26:47 2020 +0100

    um: Implement time-travel=ext
    
    This implements synchronized time-travel mode which - using a special
    application on a unix socket - lets multiple machines take part in a
    time-travelling simulation together.
    
    The protocol for the unix domain socket is defined in the new file
    include/uapi/linux/um_timetravel.h.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 5c819f89b8c2..26ecbd64c409 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -5,6 +5,7 @@
 
 #include <stdio.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
@@ -17,6 +18,7 @@
 #include <sys/un.h>
 #include <sys/types.h>
 #include <sys/eventfd.h>
+#include <poll.h>
 #include <os.h>
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
@@ -665,3 +667,31 @@ int os_sendmsg_fds(int fd, const void *buf, unsigned int len, const int *fds,
 		return -errno;
 	return err;
 }
+
+int os_poll(unsigned int n, const int *fds)
+{
+	/* currently need 2 FDs at most so avoid dynamic allocation */
+	struct pollfd pollfds[2] = {};
+	unsigned int i;
+	int ret;
+
+	if (n > ARRAY_SIZE(pollfds))
+		return -EINVAL;
+
+	for (i = 0; i < n; i++) {
+		pollfds[i].fd = fds[i];
+		pollfds[i].events = POLLIN;
+	}
+
+	ret = poll(pollfds, n, -1);
+	if (ret < 0)
+		return -errno;
+
+	/* Return the index of the available FD */
+	for (i = 0; i < n; i++) {
+		if (pollfds[i].revents)
+			return i;
+	}
+
+	return -EIO;
+}

commit 35f3401317a3b26aa01fde8facfd320f2628fdcc
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Tue Mar 17 17:35:34 2020 +0000

    um: falloc.h needs to be directly included for older libc
    
    When building UML with glibc 2.17 installed, compilation
    of arch/um/os-Linux/file.c fails due to failure to find
    FALLOC_FL_PUNCH_HOLE and FALLOC_FL_KEEP_SIZE definitions.
    
    It appears that /usr/include/bits/fcntl-linux.h (indirectly
    included by /usr/include/fcntl.h) does not include falloc.h
    with an older glibc, whereas a more up-to-date version
    does.
    
    Adding the direct include to file.c resolves the issue
    and does not cause problems for more recent glibc.
    
    Fixes: 50109b5a03b4 ("um: Add support for DISCARD in the UBD Driver")
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-By: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index fbda10535dab..5c819f89b8c2 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -8,6 +8,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <linux/falloc.h>
 #include <sys/ioctl.h>
 #include <sys/mount.h>
 #include <sys/socket.h>

commit 853bc0ab341b0c99619f83f4060dedcccad77b2a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 5 09:39:51 2019 +0100

    um: ubd: use 64-bit time_t where possible
    
    The ubd code suffers from a possible y2038 overflow on 32-bit
    architectures, both for the cow header and the os_file_modtime()
    function.
    
    Replace time_t with time64_t to extend the ubd_kern side as much
    as possible.
    
    Whether this makes a difference for the user side depends on
    the host libc implementation that may use either 32-bit or 64-bit
    time_t.
    
    For the cow file format, the header contains an unsigned 32-bit
    timestamp, which is good until y2106, passing this through a
    'long long' gives us a consistent interpretation between 32-bit
    and 64-bit um kernels.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 5133e3afb96f..fbda10535dab 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -341,7 +341,7 @@ int os_file_size(const char *file, unsigned long long *size_out)
 	return 0;
 }
 
-int os_file_modtime(const char *file, unsigned long *modtime)
+int os_file_modtime(const char *file, long long *modtime)
 {
 	struct uml_stat buf;
 	int err;

commit 97870c34b453251cda9c2341f8534b78003a74dc
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:18 2019 +0100

    um: Add SPDX headers for files in arch/um/os-Linux
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 91f23035be08..5133e3afb96f 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <stdio.h>

commit 5d38f324993f49d1226ec81efe045834b46cd85a
Author: Erel Geron <erelx.geron@intel.com>
Date:   Wed Sep 11 14:51:20 2019 +0200

    um: drivers: Add virtio vhost-user driver
    
    This module allows virtio devices to be used over a vhost-user socket.
    
    Signed-off-by: Erel Geron <erelx.geron@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index f25b110d4e70..91f23035be08 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -15,6 +15,7 @@
 #include <sys/sysmacros.h>
 #include <sys/un.h>
 #include <sys/types.h>
+#include <sys/eventfd.h>
 #include <os.h>
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
@@ -620,3 +621,46 @@ int os_falloc_punch(int fd, unsigned long long offset, int len)
 	return n;
 }
 
+int os_eventfd(unsigned int initval, int flags)
+{
+	int fd = eventfd(initval, flags);
+
+	if (fd < 0)
+		return -errno;
+	return fd;
+}
+
+int os_sendmsg_fds(int fd, const void *buf, unsigned int len, const int *fds,
+		   unsigned int fds_num)
+{
+	struct iovec iov = {
+		.iov_base = (void *) buf,
+		.iov_len = len,
+	};
+	union {
+		char control[CMSG_SPACE(sizeof(*fds) * OS_SENDMSG_MAX_FDS)];
+		struct cmsghdr align;
+	} u;
+	unsigned int fds_size = sizeof(*fds) * fds_num;
+	struct msghdr msg = {
+		.msg_iov = &iov,
+		.msg_iovlen = 1,
+		.msg_control = u.control,
+		.msg_controllen = CMSG_SPACE(fds_size),
+	};
+	struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+	int err;
+
+	if (fds_num > OS_SENDMSG_MAX_FDS)
+		return -EINVAL;
+	memset(u.control, 0, sizeof(u.control));
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = SCM_RIGHTS;
+	cmsg->cmsg_len = CMSG_LEN(fds_size);
+	memcpy(CMSG_DATA(cmsg), fds, fds_size);
+	err = sendmsg(fd, &msg, 0);
+
+	if (err < 0)
+		return -errno;
+	return err;
+}

commit 50109b5a03b4024eb6b8df3ab8f427625f54fe92
Author: Anton Ivanov <anton.ivanov@cambridgegreys.com>
Date:   Wed Nov 14 18:41:09 2018 +0000

    um: Add support for DISCARD in the UBD Driver
    
    Support for DISCARD and WRITE_ZEROES in the ubd driver using
    fallocate.
    
    DISCARD is enabled by default and can be disabled using a new
    UBD command line flag.
    
    If the underlying fs on which the UBD image is stored does not
    support DISCARD the support for both DISCARD and WRITE_ZEROES
    is turned off.
    
    Signed-off-by: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index c0197097c86e..f25b110d4e70 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -610,3 +610,13 @@ unsigned long long os_makedev(unsigned major, unsigned minor)
 {
 	return makedev(major, minor);
 }
+
+int os_falloc_punch(int fd, unsigned long long offset, int len)
+{
+	int n = fallocate(fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, offset, len);
+
+	if (n < 0)
+		return -errno;
+	return n;
+}
+

commit 530ba6c7cb3c22435a4d26de47037bb6f86a5329
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 14 03:23:37 2017 +0100

    um: Compile with modern headers
    
    Recent libcs have gotten a bit more strict, so we actually need to
    include the right headers and use the right types. This enables UML to
    compile again.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 2db18cbbb0ea..c0197097c86e 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -12,6 +12,7 @@
 #include <sys/mount.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 #include <sys/un.h>
 #include <sys/types.h>
 #include <os.h>

commit 8c6157b6b30a765ec233a1be5f9446f24a5283de
Author: Anton Ivanov <aivanov@brocade.com>
Date:   Mon Dec 21 18:54:00 2015 +0000

    um: Update UBD to use pread/pwrite family of functions
    
    This decreases the number of syscalls per read/write by half.
    
    Signed-off-by: Anton Ivanov <aivanov@brocade.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 26e0164895e4..2db18cbbb0ea 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -264,6 +264,15 @@ int os_read_file(int fd, void *buf, int len)
 	return n;
 }
 
+int os_pread_file(int fd, void *buf, int len, unsigned long long offset)
+{
+	int n = pread(fd, buf, len, offset);
+
+	if (n < 0)
+		return -errno;
+	return n;
+}
+
 int os_write_file(int fd, const void *buf, int len)
 {
 	int n = write(fd, (void *) buf, len);
@@ -282,6 +291,16 @@ int os_sync_file(int fd)
 	return n;
 }
 
+int os_pwrite_file(int fd, const void *buf, int len, unsigned long long offset)
+{
+	int n = pwrite(fd, (void *) buf, len, offset);
+
+	if (n < 0)
+		return -errno;
+	return n;
+}
+
+
 int os_file_size(const char *file, unsigned long long *size_out)
 {
 	struct uml_stat buf;

commit 8eeba4e9a76cd126e737d3d303d9c424b66ea90d
Author: Hans-Werner Hilse <hwhilse@gmail.com>
Date:   Thu Jun 11 11:29:20 2015 +0200

    um: Include sys/types.h for makedev(), major(), minor()
    
    The functions in question are not part of the POSIX standard,
    documentation however hints that the corresponding header shall
    be sys/types.h. C libraries other than glibc, namely musl, did
    not include that header via other ways and complained.
    
    Signed-off-by: Hans-Werner Hilse <hwhilse@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 08d90fba952c..26e0164895e4 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -13,6 +13,7 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
+#include <sys/types.h>
 #include <os.h>
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)

commit 0565103d1adbd765ca45248d04c327c076dd1571
Author: Anton Ivanov <antivano@cisco.com>
Date:   Fri Mar 7 18:37:47 2014 +0000

    um: Memory corruption on startup
    
    The reverse case of this race (you must msync before read) is
    well known. This is the not so common one.
    
    It can be triggered only on systems which do a lot of task
    switching and only at UML startup. If you are starting 200+ UMLs
    ~ 0.5% will always die without this fix.
    
    Signed-off-by: Anton Ivanov <antivano@cisco.com>
    [rw: minor whitespace fixes]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 07a750197bb0..08d90fba952c 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -237,6 +237,12 @@ void os_close_file(int fd)
 {
 	close(fd);
 }
+int os_fsync_file(int fd)
+{
+	if (fsync(fd) < 0)
+	    return -errno;
+	return 0;
+}
 
 int os_seek_file(int fd, unsigned long long offset)
 {

commit 805f11a0d515658106bfbfadceff0eb30bd90ad2
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Aug 18 13:30:06 2013 +0200

    um: ubd: Add REQ_FLUSH suppport
    
    UML's block device driver does not support write barriers,
    to support this this patch adds REQ_FLUSH suppport.
    Every time the block layer sends a REQ_FLUSH we fsync() now
    our backing file to guarantee data consistency.
    
    Reported-and-tested-by: Richard W.M. Jones <rjones@redhat.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index c17bd6f7d674..07a750197bb0 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -266,6 +266,15 @@ int os_write_file(int fd, const void *buf, int len)
 	return n;
 }
 
+int os_sync_file(int fd)
+{
+	int n = fsync(fd);
+
+	if (n < 0)
+		return -errno;
+	return n;
+}
+
 int os_file_size(const char *file, unsigned long long *size_out)
 {
 	struct uml_stat buf;

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index b049a63bb74b..c17bd6f7d674 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -13,7 +13,7 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
-#include "os.h"
+#include <os.h>
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
 {

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 140e587bc0ad..b049a63bb74b 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -13,9 +13,7 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
-#include "kern_constants.h"
 #include "os.h"
-#include "user.h"
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
 {

commit 005a59ec745d23f60222f7712adde48f64d7d3c8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 21 01:27:08 2009 -0400

    Deal with missing exports for hostfs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index b5afcfd0f861..140e587bc0ad 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -561,3 +561,18 @@ int os_lock_file(int fd, int excl)
  out:
 	return err;
 }
+
+unsigned os_major(unsigned long long dev)
+{
+	return major(dev);
+}
+
+unsigned os_minor(unsigned long long dev)
+{
+	return minor(dev);
+}
+
+unsigned long long os_makedev(unsigned major, unsigned minor)
+{
+	return makedev(major, minor);
+}

commit bf53d85ec20c228e0efdadbdb12c0f92283fcfd0
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:18 2008 -0800

    uml: implement O_APPEND
    
    The .a flags in openflags never had an implementation.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index d7404c621ff7..b5afcfd0f861 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -191,6 +191,8 @@ int os_open_file(const char *file, struct openflags flags, int mode)
 		f |= O_TRUNC;
 	if (flags.e)
 		f |= O_EXCL;
+	if (flags.a)
+		f |= O_APPEND;
 
 	fd = open64(file, f, mode);
 	if (fd < 0)

commit 1adfd6095e1c654dce5a692db5aa5a2b2a8d6b0d
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:05 2008 -0800

    uml: style fixes in file.c
    
    arch/um/os-Linux/file.c needed some style work -
            updated the copyright
            cleaned up the includes
            CodingStyle fixes
            added some missing CATCH_EINTRs
            os_set_owner was unused, so it is gone
            all printks now have severities
            fcntl(F_GETFL) was being called without checking the return
            removed an obsolete comment
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 4f547d75b17e..d7404c621ff7 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
@@ -8,13 +8,12 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
 #include <sys/ioctl.h>
 #include <sys/mount.h>
-#include <sys/uio.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include "kern_constants.h"
 #include "os.h"
 #include "user.h"
 
@@ -42,10 +41,10 @@ int os_stat_fd(const int fd, struct uml_stat *ubuf)
 	int err;
 
 	CATCH_EINTR(err = fstat64(fd, &sbuf));
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
-	if(ubuf != NULL)
+	if (ubuf != NULL)
 		copy_stat(ubuf, &sbuf);
 	return err;
 }
@@ -55,27 +54,26 @@ int os_stat_file(const char *file_name, struct uml_stat *ubuf)
 	struct stat64 sbuf;
 	int err;
 
-	do {
-		err = stat64(file_name, &sbuf);
-	} while((err < 0) && (errno == EINTR)) ;
-
-	if(err < 0)
+	CATCH_EINTR(err = stat64(file_name, &sbuf));
+	if (err < 0)
 		return -errno;
 
-	if(ubuf != NULL)
+	if (ubuf != NULL)
 		copy_stat(ubuf, &sbuf);
 	return err;
 }
 
-int os_access(const char* file, int mode)
+int os_access(const char *file, int mode)
 {
 	int amode, err;
 
-	amode=(mode&OS_ACC_R_OK ? R_OK : 0) | (mode&OS_ACC_W_OK ? W_OK : 0) |
-	      (mode&OS_ACC_X_OK ? X_OK : 0) | (mode&OS_ACC_F_OK ? F_OK : 0) ;
+	amode = (mode & OS_ACC_R_OK ? R_OK : 0) |
+		(mode & OS_ACC_W_OK ? W_OK : 0) |
+		(mode & OS_ACC_X_OK ? X_OK : 0) |
+		(mode & OS_ACC_F_OK ? F_OK : 0);
 
 	err = access(file, amode);
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
 	return 0;
@@ -87,7 +85,7 @@ int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 	int err;
 
 	err = ioctl(fd, cmd, arg);
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
 	return err;
@@ -96,7 +94,7 @@ int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 /* FIXME: ensure namebuf in os_get_if_name is big enough */
 int os_get_ifname(int fd, char* namebuf)
 {
-	if(ioctl(fd, SIOCGIFNAME, namebuf) < 0)
+	if (ioctl(fd, SIOCGIFNAME, namebuf) < 0)
 		return -errno;
 
 	return 0;
@@ -107,37 +105,22 @@ int os_set_slip(int fd)
 	int disc, sencap;
 
 	disc = N_SLIP;
-	if(ioctl(fd, TIOCSETD, &disc) < 0)
+	if (ioctl(fd, TIOCSETD, &disc) < 0)
 		return -errno;
 
 	sencap = 0;
-	if(ioctl(fd, SIOCSIFENCAP, &sencap) < 0)
+	if (ioctl(fd, SIOCSIFENCAP, &sencap) < 0)
 		return -errno;
 
 	return 0;
 }
 
-int os_set_owner(int fd, int pid)
-{
-	if(fcntl(fd, F_SETOWN, pid) < 0){
-		int save_errno = errno;
-
-		if(fcntl(fd, F_GETOWN, 0) != pid)
-			return -save_errno;
-	}
-
-	return 0;
-}
-
 int os_mode_fd(int fd, int mode)
 {
 	int err;
 
-	do {
-		err = fchmod(fd, mode);
-	} while((err < 0) && (errno==EINTR)) ;
-
-	if(err < 0)
+	CATCH_EINTR(err = fchmod(fd, mode));
+	if (err < 0)
 		return -errno;
 
 	return 0;
@@ -149,20 +132,20 @@ int os_file_type(char *file)
 	int err;
 
 	err = os_stat_file(file, &buf);
-	if(err < 0)
+	if (err < 0)
 		return err;
 
-	if(S_ISDIR(buf.ust_mode))
+	if (S_ISDIR(buf.ust_mode))
 		return OS_TYPE_DIR;
-	else if(S_ISLNK(buf.ust_mode))
+	else if (S_ISLNK(buf.ust_mode))
 		return OS_TYPE_SYMLINK;
-	else if(S_ISCHR(buf.ust_mode))
+	else if (S_ISCHR(buf.ust_mode))
 		return OS_TYPE_CHARDEV;
-	else if(S_ISBLK(buf.ust_mode))
+	else if (S_ISBLK(buf.ust_mode))
 		return OS_TYPE_BLOCKDEV;
-	else if(S_ISFIFO(buf.ust_mode))
+	else if (S_ISFIFO(buf.ust_mode))
 		return OS_TYPE_FIFO;
-	else if(S_ISSOCK(buf.ust_mode))
+	else if (S_ISSOCK(buf.ust_mode))
 		return OS_TYPE_SOCK;
 	else return OS_TYPE_FILE;
 }
@@ -174,15 +157,15 @@ int os_file_mode(const char *file, struct openflags *mode_out)
 	*mode_out = OPENFLAGS();
 
 	err = access(file, W_OK);
-	if(err && (errno != EACCES))
+	if (err && (errno != EACCES))
 		return -errno;
-	else if(!err)
+	else if (!err)
 		*mode_out = of_write(*mode_out);
 
 	err = access(file, R_OK);
-	if(err && (errno != EACCES))
+	if (err && (errno != EACCES))
 		return -errno;
-	else if(!err)
+	else if (!err)
 		*mode_out = of_read(*mode_out);
 
 	return err;
@@ -192,21 +175,28 @@ int os_open_file(const char *file, struct openflags flags, int mode)
 {
 	int fd, err, f = 0;
 
-	if(flags.r && flags.w) f = O_RDWR;
-	else if(flags.r) f = O_RDONLY;
-	else if(flags.w) f = O_WRONLY;
+	if (flags.r && flags.w)
+		f = O_RDWR;
+	else if (flags.r)
+		f = O_RDONLY;
+	else if (flags.w)
+		f = O_WRONLY;
 	else f = 0;
 
-	if(flags.s) f |= O_SYNC;
-	if(flags.c) f |= O_CREAT;
-	if(flags.t) f |= O_TRUNC;
-	if(flags.e) f |= O_EXCL;
+	if (flags.s)
+		f |= O_SYNC;
+	if (flags.c)
+		f |= O_CREAT;
+	if (flags.t)
+		f |= O_TRUNC;
+	if (flags.e)
+		f |= O_EXCL;
 
 	fd = open64(file, f, mode);
-	if(fd < 0)
+	if (fd < 0)
 		return -errno;
 
-	if(flags.cl && fcntl(fd, F_SETFD, 1)){
+	if (flags.cl && fcntl(fd, F_SETFD, 1)) {
 		err = -errno;
 		close(fd);
 		return err;
@@ -224,13 +214,13 @@ int os_connect_socket(const char *name)
 	snprintf(sock.sun_path, sizeof(sock.sun_path), "%s", name);
 
 	fd = socket(AF_UNIX, SOCK_STREAM, 0);
-	if(fd < 0) {
+	if (fd < 0) {
 		err = -errno;
 		goto out;
 	}
 
 	err = connect(fd, (struct sockaddr *) &sock, sizeof(sock));
-	if(err) {
+	if (err) {
 		err = -errno;
 		goto out_close;
 	}
@@ -253,7 +243,7 @@ int os_seek_file(int fd, unsigned long long offset)
 	unsigned long long actual;
 
 	actual = lseek64(fd, offset, SEEK_SET);
-	if(actual != offset)
+	if (actual != offset)
 		return -errno;
 	return 0;
 }
@@ -262,7 +252,7 @@ int os_read_file(int fd, void *buf, int len)
 {
 	int n = read(fd, buf, len);
 
-	if(n < 0)
+	if (n < 0)
 		return -errno;
 	return n;
 }
@@ -271,7 +261,7 @@ int os_write_file(int fd, const void *buf, int len)
 {
 	int n = write(fd, (void *) buf, len);
 
-	if(n < 0)
+	if (n < 0)
 		return -errno;
 	return n;
 }
@@ -282,26 +272,27 @@ int os_file_size(const char *file, unsigned long long *size_out)
 	int err;
 
 	err = os_stat_file(file, &buf);
-	if(err < 0){
-		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
+	if (err < 0) {
+		printk(UM_KERN_ERR "Couldn't stat \"%s\" : err = %d\n", file,
+		       -err);
 		return err;
 	}
 
-	if(S_ISBLK(buf.ust_mode)){
+	if (S_ISBLK(buf.ust_mode)) {
 		int fd;
 		long blocks;
 
 		fd = open(file, O_RDONLY, 0);
-		if(fd < 0) {
+		if (fd < 0) {
 			err = -errno;
-			printk("Couldn't open \"%s\", errno = %d\n", file,
-			       errno);
+			printk(UM_KERN_ERR "Couldn't open \"%s\", "
+			       "errno = %d\n", file, errno);
 			return err;
 		}
-		if(ioctl(fd, BLKGETSIZE, &blocks) < 0){
+		if (ioctl(fd, BLKGETSIZE, &blocks) < 0) {
 			err = -errno;
-			printk("Couldn't get the block size of \"%s\", "
-			       "errno = %d\n", file, errno);
+			printk(UM_KERN_ERR "Couldn't get the block size of "
+			       "\"%s\", errno = %d\n", file, errno);
 			close(fd);
 			return err;
 		}
@@ -319,8 +310,9 @@ int os_file_modtime(const char *file, unsigned long *modtime)
 	int err;
 
 	err = os_stat_file(file, &buf);
-	if(err < 0){
-		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
+	if (err < 0) {
+		printk(UM_KERN_ERR "Couldn't stat \"%s\" : err = %d\n", file,
+		       -err);
 		return err;
 	}
 
@@ -334,7 +326,7 @@ int os_set_exec_close(int fd)
 
 	CATCH_EINTR(err = fcntl(fd, F_SETFD, FD_CLOEXEC));
 
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 	return err;
 }
@@ -344,24 +336,25 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 	int err, type = stream ? SOCK_STREAM : SOCK_DGRAM;
 
 	err = socketpair(AF_UNIX, type, 0, fds);
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
-	if(!close_on_exec)
+	if (!close_on_exec)
 		return 0;
 
 	err = os_set_exec_close(fds[0]);
-	if(err < 0)
+	if (err < 0)
 		goto error;
 
 	err = os_set_exec_close(fds[1]);
-	if(err < 0)
+	if (err < 0)
 		goto error;
 
 	return 0;
 
  error:
-	printk("os_pipe : Setting FD_CLOEXEC failed, err = %d\n", -err);
+	printk(UM_KERN_ERR "os_pipe : Setting FD_CLOEXEC failed, err = %d\n",
+	       -err);
 	close(fds[1]);
 	close(fds[0]);
 	return err;
@@ -378,15 +371,15 @@ int os_set_fd_async(int fd)
 	flags |= O_ASYNC | O_NONBLOCK;
 	if (fcntl(fd, F_SETFL, flags) < 0) {
 		err = -errno;
-		printk("os_set_fd_async : failed to set O_ASYNC and "
-		       "O_NONBLOCK on fd # %d, errno = %d\n", fd, errno);
+		printk(UM_KERN_ERR "os_set_fd_async : failed to set O_ASYNC "
+		       "and O_NONBLOCK on fd # %d, errno = %d\n", fd, errno);
 		return err;
 	}
 
 	if ((fcntl(fd, F_SETSIG, SIGIO) < 0) ||
 	    (fcntl(fd, F_SETOWN, os_getpid()) < 0)) {
 		err = -errno;
-		printk("os_set_fd_async : Failed to fcntl F_SETOWN "
+		printk(UM_KERN_ERR "os_set_fd_async : Failed to fcntl F_SETOWN "
 		       "(or F_SETSIG) fd %d, errno = %d\n", fd, errno);
 		return err;
 	}
@@ -396,10 +389,14 @@ int os_set_fd_async(int fd)
 
 int os_clear_fd_async(int fd)
 {
-	int flags = fcntl(fd, F_GETFL);
+	int flags;
+
+	flags = fcntl(fd, F_GETFL);
+	if (flags < 0)
+		return -errno;
 
 	flags &= ~(O_ASYNC | O_NONBLOCK);
-	if(fcntl(fd, F_SETFL, flags) < 0)
+	if (fcntl(fd, F_SETFL, flags) < 0)
 		return -errno;
 	return 0;
 }
@@ -409,11 +406,15 @@ int os_set_fd_block(int fd, int blocking)
 	int flags;
 
 	flags = fcntl(fd, F_GETFL);
+	if (flags < 0)
+		return -errno;
 
-	if(blocking) flags &= ~O_NONBLOCK;
-	else flags |= O_NONBLOCK;
+	if (blocking)
+		flags &= ~O_NONBLOCK;
+	else
+		flags |= O_NONBLOCK;
 
-	if(fcntl(fd, F_SETFL, flags) < 0)
+	if (fcntl(fd, F_SETFL, flags) < 0)
 		return -errno;
 
 	return 0;
@@ -424,7 +425,7 @@ int os_accept_connection(int fd)
 	int new;
 
 	new = accept(fd, NULL, 0);
-	if(new < 0)
+	if (new < 0)
 		return -errno;
 	return new;
 }
@@ -445,15 +446,17 @@ int os_shutdown_socket(int fd, int r, int w)
 {
 	int what, err;
 
-	if(r && w) what = SHUT_RDWR;
-	else if(r) what = SHUT_RD;
-	else if(w) what = SHUT_WR;
-	else {
-		printk("os_shutdown_socket : neither r or w was set\n");
+	if (r && w)
+		what = SHUT_RDWR;
+	else if (r)
+		what = SHUT_RD;
+	else if (w)
+		what = SHUT_WR;
+	else
 		return -EINVAL;
-	}
+
 	err = shutdown(fd, what);
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 	return 0;
 }
@@ -477,19 +480,20 @@ int os_rcv_fd(int fd, int *helper_pid_out)
 	msg.msg_flags = 0;
 
 	n = recvmsg(fd, &msg, 0);
-	if(n < 0)
+	if (n < 0)
 		return -errno;
-	else if(n != iov.iov_len)
+	else if (n != iov.iov_len)
 		*helper_pid_out = -1;
 
 	cmsg = CMSG_FIRSTHDR(&msg);
-	if(cmsg == NULL){
-		printk("rcv_fd didn't receive anything, error = %d\n", errno);
+	if (cmsg == NULL) {
+		printk(UM_KERN_ERR "rcv_fd didn't receive anything, "
+		       "error = %d\n", errno);
 		return -1;
 	}
-	if((cmsg->cmsg_level != SOL_SOCKET) ||
-	   (cmsg->cmsg_type != SCM_RIGHTS)){
-		printk("rcv_fd didn't receive a descriptor\n");
+	if ((cmsg->cmsg_level != SOL_SOCKET) ||
+	    (cmsg->cmsg_type != SCM_RIGHTS)) {
+		printk(UM_KERN_ERR "rcv_fd didn't receive a descriptor\n");
 		return -1;
 	}
 
@@ -503,23 +507,22 @@ int os_create_unix_socket(const char *file, int len, int close_on_exec)
 	int sock, err;
 
 	sock = socket(PF_UNIX, SOCK_DGRAM, 0);
-	if(sock < 0)
+	if (sock < 0)
 		return -errno;
 
-	if(close_on_exec) {
+	if (close_on_exec) {
 		err = os_set_exec_close(sock);
-		if(err < 0)
-			printk("create_unix_socket : close_on_exec failed, "
-		       "err = %d", -err);
+		if (err < 0)
+			printk(UM_KERN_ERR "create_unix_socket : "
+			       "close_on_exec failed, err = %d", -err);
 	}
 
 	addr.sun_family = AF_UNIX;
 
-	/* XXX Be more careful about overflow */
 	snprintf(addr.sun_path, len, "%s", file);
 
 	err = bind(sock, (struct sockaddr *) &addr, sizeof(addr));
-	if(err < 0)
+	if (err < 0)
 		return -errno;
 
 	return sock;
@@ -540,17 +543,18 @@ int os_lock_file(int fd, int excl)
 	int err, save;
 
 	err = fcntl(fd, F_SETLK, &lock);
-	if(!err)
+	if (!err)
 		goto out;
 
 	save = -errno;
 	err = fcntl(fd, F_GETLK, &lock);
-	if(err){
+	if (err) {
 		err = -errno;
 		goto out;
 	}
 
-	printk("F_SETLK failed, file already locked by pid %d\n", lock.l_pid);
+	printk(UM_KERN_ERR "F_SETLK failed, file already locked by pid %d\n",
+	       lock.l_pid);
 	err = save;
  out:
 	return err;

commit bf8fde785b872282e7e86d9ea8a9c4e543985bb3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:04 2008 -0800

    uml: miscellaneous code cleanups
    
    Code tidying -
            the pid field of struct irq_fd isn't used, so it is removed
            os_set_fd_async needed to read flags before changing them, it
    doesn't need a pid passed in because it can call getpid itself, and a
    block of unused code needed deleting
            os_get_exec_close was unused, so it is removed
            ptrace_child called _exit for historical reasons which are no
    longer valid, so just calls exit instead
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 9387cb11c0ad..4f547d75b17e 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -328,19 +328,6 @@ int os_file_modtime(const char *file, unsigned long *modtime)
 	return 0;
 }
 
-int os_get_exec_close(int fd, int *close_on_exec)
-{
-	int ret;
-
-	CATCH_EINTR(ret = fcntl(fd, F_GETFD));
-
-	if(ret < 0)
-		return -errno;
-
-	*close_on_exec = (ret & FD_CLOEXEC) ? 1 : 0;
-	return ret;
-}
-
 int os_set_exec_close(int fd)
 {
 	int err;
@@ -380,30 +367,27 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 	return err;
 }
 
-int os_set_fd_async(int fd, int owner)
+int os_set_fd_async(int fd)
 {
-	int err;
+	int err, flags;
+
+	flags = fcntl(fd, F_GETFL);
+	if (flags < 0)
+		return -errno;
 
-	/* XXX This should do F_GETFL first */
-	if(fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0){
+	flags |= O_ASYNC | O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, flags) < 0) {
 		err = -errno;
 		printk("os_set_fd_async : failed to set O_ASYNC and "
 		       "O_NONBLOCK on fd # %d, errno = %d\n", fd, errno);
 		return err;
 	}
-#ifdef notdef
-	if(fcntl(fd, F_SETFD, 1) < 0){
-		printk("os_set_fd_async : Setting FD_CLOEXEC failed, "
-		       "errno = %d\n", errno);
-	}
-#endif
 
-	if((fcntl(fd, F_SETSIG, SIGIO) < 0) ||
-	   (fcntl(fd, F_SETOWN, owner) < 0)){
+	if ((fcntl(fd, F_SETSIG, SIGIO) < 0) ||
+	    (fcntl(fd, F_SETOWN, os_getpid()) < 0)) {
 		err = -errno;
 		printk("os_set_fd_async : Failed to fcntl F_SETOWN "
-		       "(or F_SETSIG) fd %d to pid %d, errno = %d\n", fd,
-		       owner, errno);
+		       "(or F_SETSIG) fd %d, errno = %d\n", fd, errno);
 		return err;
 	}
 

commit edea138584d7586a3b93b6d5ab5ec021d18e11e9
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:30:46 2008 -0800

    uml: tidy kern_util.h
    
    Tidy kern_util.h.  It turns out that most of the function declarations
    aren't used, so they can go away.  os.h no longer includes
    kern_util.h, so files which got it through os.h now need to include it
    directly.  A number of other files never needed it, so these includes
    are deleted.
    
    The structure which was used to pass signal handlers from the kernel
    side to the userspace side is gone.  Instead, the handlers are
    declared here, and used directly from libc code.  This allows
    arch/um/os-Linux/trap.c to be deleted, with its remnants being moved
    to arch/um/os-Linux/skas/trap.c.
    
    arch/um/os-Linux/tty.c had its inclusions changed, and it needed some
    style attention, so it got tidied.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index c3bb5ce70c95..9387cb11c0ad 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -17,7 +17,6 @@
 #include <sys/uio.h>
 #include "os.h"
 #include "user.h"
-#include "kern_util.h"
 
 static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
 {

commit c9a3072d13e4b8a6549ecc1db6390a55c7ee2ddf
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Mon Feb 4 22:30:35 2008 -0800

    uml: code tidying under arch/um/os-Linux
    
    This patch contains varied fixes and improvements for some files under
    arch/um/os-Linux/, such as a typo fix in a perror message, a missing
    argument fix for a printf, some constifying for pointers and so on.
    
    [ jdike - made sigprocmask failure return -errno instead of -1 ]
    
    Signed-off-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index f83462758627..c3bb5ce70c95 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -19,7 +19,7 @@
 #include "user.h"
 #include "kern_util.h"
 
-static void copy_stat(struct uml_stat *dst, struct stat64 *src)
+static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
 {
 	*dst = ((struct uml_stat) {
 		.ust_dev     = src->st_dev,     /* device */
@@ -168,7 +168,7 @@ int os_file_type(char *file)
 	else return OS_TYPE_FILE;
 }
 
-int os_file_mode(char *file, struct openflags *mode_out)
+int os_file_mode(const char *file, struct openflags *mode_out)
 {
 	int err;
 
@@ -189,7 +189,7 @@ int os_file_mode(char *file, struct openflags *mode_out)
 	return err;
 }
 
-int os_open_file(char *file, struct openflags flags, int mode)
+int os_open_file(const char *file, struct openflags flags, int mode)
 {
 	int fd, err, f = 0;
 
@@ -216,7 +216,7 @@ int os_open_file(char *file, struct openflags flags, int mode)
 	return fd;
 }
 
-int os_connect_socket(char *name)
+int os_connect_socket(const char *name)
 {
 	struct sockaddr_un sock;
 	int fd, err;
@@ -277,7 +277,7 @@ int os_write_file(int fd, const void *buf, int len)
 	return n;
 }
 
-int os_file_size(char *file, unsigned long long *size_out)
+int os_file_size(const char *file, unsigned long long *size_out)
 {
 	struct uml_stat buf;
 	int err;
@@ -314,7 +314,7 @@ int os_file_size(char *file, unsigned long long *size_out)
 	return 0;
 }
 
-int os_file_modtime(char *file, unsigned long *modtime)
+int os_file_modtime(const char *file, unsigned long *modtime)
 {
 	struct uml_stat buf;
 	int err;
@@ -514,7 +514,7 @@ int os_rcv_fd(int fd, int *helper_pid_out)
 	return new;
 }
 
-int os_create_unix_socket(char *file, int len, int close_on_exec)
+int os_create_unix_socket(const char *file, int len, int close_on_exec)
 {
 	struct sockaddr_un addr;
 	int sock, err;

commit d4d5d205b653fe68c898d42e7a27a7363a4fb3ba
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Nov 14 16:58:51 2007 -0800

    uml: fix recvmsg return value checking
    
    Stupid bug - we need to compare the return value of recvmsg to the value of
    iov_len, not its size.  This caused port_helper processes not to be killed on
    shutdown on x86_64 because the pids weren't being passed out properly.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index b542a3a021bf..f83462758627 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -496,8 +496,7 @@ int os_rcv_fd(int fd, int *helper_pid_out)
 	n = recvmsg(fd, &msg, 0);
 	if(n < 0)
 		return -errno;
-
-	else if(n != sizeof(iov.iov_len))
+	else if(n != iov.iov_len)
 		*helper_pid_out = -1;
 
 	cmsg = CMSG_FIRSTHDR(&msg);

commit 512b6fb1c14d4c34f23a3419b0789ad01914a899
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:11 2007 -0700

    uml: userspace files should call libc directly
    
    A number of files that were changed in the recent removal of tt mode
    are userspace files which call the os_* wrappers instead of calling
    libc directly.  A few other files were affected by this, through
    
    This patch makes these call glibc directly.
    
    There are also style fixes in the affected areas.
    
    os_print_error has no remaining callers, so it is deleted.
    
    There is a interface change to os_set_exec_close, eliminating a
    parameter which was always the same.  The callers are fixed as well.
    
    os_process_pc got its error path cleaned up.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 5f10c3031ef2..b542a3a021bf 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -82,13 +82,6 @@ int os_access(const char* file, int mode)
 	return 0;
 }
 
-void os_print_error(int error, const char* str)
-{
-	errno = error < 0 ? -error : error;
-
-	perror(str);
-}
-
 /* FIXME? required only by hostaudio (because it passes ioctls verbatim) */
 int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 {
@@ -181,19 +174,19 @@ int os_file_mode(char *file, struct openflags *mode_out)
 
 	*mode_out = OPENFLAGS();
 
-	err = os_access(file, OS_ACC_W_OK);
-	if((err < 0) && (err != -EACCES))
-		return(err);
-
-	*mode_out = of_write(*mode_out);
-
-	err = os_access(file, OS_ACC_R_OK);
-	if((err < 0) && (err != -EACCES))
-		return(err);
+	err = access(file, W_OK);
+	if(err && (errno != EACCES))
+		return -errno;
+	else if(!err)
+		*mode_out = of_write(*mode_out);
 
-	*mode_out = of_read(*mode_out);
+	err = access(file, R_OK);
+	if(err && (errno != EACCES))
+		return -errno;
+	else if(!err)
+		*mode_out = of_read(*mode_out);
 
-	return(0);
+	return err;
 }
 
 int os_open_file(char *file, struct openflags flags, int mode)
@@ -212,15 +205,15 @@ int os_open_file(char *file, struct openflags flags, int mode)
 
 	fd = open64(file, f, mode);
 	if(fd < 0)
-		return(-errno);
+		return -errno;
 
 	if(flags.cl && fcntl(fd, F_SETFD, 1)){
 		err = -errno;
-		os_close_file(fd);
+		close(fd);
 		return err;
 	}
 
-	return(fd);
+	return fd;
 }
 
 int os_connect_socket(char *name)
@@ -292,31 +285,33 @@ int os_file_size(char *file, unsigned long long *size_out)
 	err = os_stat_file(file, &buf);
 	if(err < 0){
 		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
-		return(err);
+		return err;
 	}
 
 	if(S_ISBLK(buf.ust_mode)){
 		int fd;
 		long blocks;
 
-		fd = os_open_file(file, of_read(OPENFLAGS()), 0);
-		if(fd < 0){
-			printk("Couldn't open \"%s\", errno = %d\n", file, -fd);
-			return(fd);
+		fd = open(file, O_RDONLY, 0);
+		if(fd < 0) {
+			err = -errno;
+			printk("Couldn't open \"%s\", errno = %d\n", file,
+			       errno);
+			return err;
 		}
 		if(ioctl(fd, BLKGETSIZE, &blocks) < 0){
 			err = -errno;
 			printk("Couldn't get the block size of \"%s\", "
 			       "errno = %d\n", file, errno);
-			os_close_file(fd);
-			return(err);
+			close(fd);
+			return err;
 		}
 		*size_out = ((long long) blocks) * 512;
-		os_close_file(fd);
-		return(0);
+		close(fd);
 	}
-	*size_out = buf.ust_size;
-	return(0);
+	else *size_out = buf.ust_size;
+
+	return 0;
 }
 
 int os_file_modtime(char *file, unsigned long *modtime)
@@ -334,35 +329,28 @@ int os_file_modtime(char *file, unsigned long *modtime)
 	return 0;
 }
 
-int os_get_exec_close(int fd, int* close_on_exec)
+int os_get_exec_close(int fd, int *close_on_exec)
 {
 	int ret;
 
-	do {
-		ret = fcntl(fd, F_GETFD);
-	} while((ret < 0) && (errno == EINTR)) ;
+	CATCH_EINTR(ret = fcntl(fd, F_GETFD));
 
 	if(ret < 0)
-		return(-errno);
+		return -errno;
 
-	*close_on_exec = (ret&FD_CLOEXEC) ? 1 : 0;
-	return(ret);
+	*close_on_exec = (ret & FD_CLOEXEC) ? 1 : 0;
+	return ret;
 }
 
-int os_set_exec_close(int fd, int close_on_exec)
+int os_set_exec_close(int fd)
 {
-	int flag, err;
-
-	if(close_on_exec) flag = FD_CLOEXEC;
-	else flag = 0;
+	int err;
 
-	do {
-		err = fcntl(fd, F_SETFD, flag);
-	} while((err < 0) && (errno == EINTR)) ;
+	CATCH_EINTR(err = fcntl(fd, F_SETFD, FD_CLOEXEC));
 
 	if(err < 0)
-		return(-errno);
-	return(err);
+		return -errno;
+	return err;
 }
 
 int os_pipe(int *fds, int stream, int close_on_exec)
@@ -371,16 +359,16 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 
 	err = socketpair(AF_UNIX, type, 0, fds);
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
 	if(!close_on_exec)
-		return(0);
+		return 0;
 
-	err = os_set_exec_close(fds[0], 1);
+	err = os_set_exec_close(fds[0]);
 	if(err < 0)
 		goto error;
 
-	err = os_set_exec_close(fds[1], 1);
+	err = os_set_exec_close(fds[1]);
 	if(err < 0)
 		goto error;
 
@@ -388,9 +376,9 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 
  error:
 	printk("os_pipe : Setting FD_CLOEXEC failed, err = %d\n", -err);
-	os_close_file(fds[1]);
-	os_close_file(fds[0]);
-	return(err);
+	close(fds[1]);
+	close(fds[0]);
+	return err;
 }
 
 int os_set_fd_async(int fd, int owner)
@@ -537,7 +525,7 @@ int os_create_unix_socket(char *file, int len, int close_on_exec)
 		return -errno;
 
 	if(close_on_exec) {
-		err = os_set_exec_close(sock, 1);
+		err = os_set_exec_close(sock);
 		if(err < 0)
 			printk("create_unix_socket : close_on_exec failed, "
 		       "err = %d", -err);

commit 8ca842c4b5cbc70b9180617e9f26b6ac9f40dbb9
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:08 2007 -0700

    uml: remove os_* usage from userspace files
    
    This patch fixes some userspace files which were calling libc through the os_*
    wrappers.
    
    It turns out that there was only one user of os_new_tty_pgrp, so it can be
    deleted.
    
    There are also some style and whitespace fixes in here.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index d463a8205637..5f10c3031ef2 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -101,17 +101,6 @@ int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 	return err;
 }
 
-int os_new_tty_pgrp(int fd, int pid)
-{
-	if(ioctl(fd, TIOCSCTTY, 0) < 0)
-		return -errno;
-
-	if(tcsetpgrp(fd, pid) < 0)
-		return -errno;
-
-	return 0;
-}
-
 /* FIXME: ensure namebuf in os_get_if_name is big enough */
 int os_get_ifname(int fd, char* namebuf)
 {

commit ba180fd437156f7fd8cfb2fdd021d949eeef08d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:00 2007 -0700

    uml: style fixes pass 3
    
    Formatting changes in the files which have been changed in the course
    of folding foo_skas functions into their callers.  These include:
            copyright updates
            header file trimming
            style fixes
            adding severity to printks
    
    These changes should be entirely non-functional.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index f52006ee70e8..d463a8205637 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -267,9 +267,9 @@ void os_close_file(int fd)
 	close(fd);
 }
 
-int os_seek_file(int fd, __u64 offset)
+int os_seek_file(int fd, unsigned long long offset)
 {
-	__u64 actual;
+	unsigned long long actual;
 
 	actual = lseek64(fd, offset, SEEK_SET);
 	if(actual != offset)

commit 8e2d10e1e76d894ec73d66dd63b641ccf5f5fb67
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:40 2007 -0700

    uml: tidy recently-moved code
    
    Now that the generic console operations are in a userspace file, we
    can do the following:
            directly call into libc instead of through the os_* wrappers
            eliminate os_window_size since it has only one user
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index c3ecc2a84e0c..f52006ee70e8 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -101,19 +101,6 @@ int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 	return err;
 }
 
-int os_window_size(int fd, int *rows, int *cols)
-{
-	struct winsize size;
-
-	if(ioctl(fd, TIOCGWINSZ, &size) < 0)
-		return -errno;
-
-	*rows = size.ws_row;
-	*cols = size.ws_col;
-
-	return 0;
-}
-
 int os_new_tty_pgrp(int fd, int pid)
 {
 	if(ioctl(fd, TIOCSCTTY, 0) < 0)

commit 2c392a4f47f41b24432e6aa77bb5167d0bbb10c5
Author: Nicolas George <nicolas.george@ens.fr>
Date:   Tue Sep 18 22:46:21 2007 -0700

    uml: use correct type in BLKGETSIZE ioctl
    
    I found a type mismatch in UML that makes host block devices unusable as ubd
    devices on x86_64 and other 64 bits systems (segfault of the mm subsystem):
    
    In block/ioctl.c, the following lines show that the BLKGETSIZE ioctl expects
    a pointer to a long:
    
            case BLKGETSIZE:
                    if ((bdev->bd_inode->i_size >> 9) > ~0UL)
                            return -EFBIG;
                    return put_ulong(arg, bdev->bd_inode->i_size >> 9);
    
    In arch/um/os-Linux/file.c, os_file_size calls it with an int.
    
    The ioctl_list man page should be fixed as well.
    
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 6f92f732d253..c3ecc2a84e0c 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -320,7 +320,8 @@ int os_file_size(char *file, unsigned long long *size_out)
 	}
 
 	if(S_ISBLK(buf.ust_mode)){
-		int fd, blocks;
+		int fd;
+		long blocks;
 
 		fd = os_open_file(file, of_read(OPENFLAGS()), 0);
 		if(fd < 0){

commit a6ea4cceed18edebe1eb6001cb9e0f88cd741a6c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:43 2007 -0700

    uml: rename os_{read_write}_file_k back to os_{read_write}_file
    
    Rename os_{read_write}_file_k back to os_{read_write}_file, delete
    the originals and their bogus infrastructure, and fix all the callers.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 5e9b8dcf34d4..6f92f732d253 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -290,51 +290,7 @@ int os_seek_file(int fd, __u64 offset)
 	return 0;
 }
 
-static int fault_buffer(void *start, int len,
-			int (*copy_proc)(void *addr, void *buf, int len))
-{
-	int page = getpagesize(), i;
-	char c;
-
-	for(i = 0; i < len; i += page){
-		if((*copy_proc)(start + i, &c, sizeof(c)))
-			return -EFAULT;
-	}
-	if((len % page) != 0){
-		if((*copy_proc)(start + len - 1, &c, sizeof(c)))
-			return -EFAULT;
-	}
-	return 0;
-}
-
-static int file_io(int fd, void *buf, int len,
-		   int (*io_proc)(int fd, void *buf, int len),
-		   int (*copy_user_proc)(void *addr, void *buf, int len))
-{
-	int n, err;
-
-	do {
-		n = (*io_proc)(fd, buf, len);
-		if((n < 0) && (errno == EFAULT)){
-			err = fault_buffer(buf, len, copy_user_proc);
-			if(err)
-				return err;
-			n = (*io_proc)(fd, buf, len);
-		}
-	} while((n < 0) && (errno == EINTR));
-
-	if(n < 0)
-		return -errno;
-	return n;
-}
-
 int os_read_file(int fd, void *buf, int len)
-{
-	return file_io(fd, buf, len, (int (*)(int, void *, int)) read,
-		       copy_from_user_proc);
-}
-
-int os_read_file_k(int fd, void *buf, int len)
 {
 	int n = read(fd, buf, len);
 
@@ -344,12 +300,6 @@ int os_read_file_k(int fd, void *buf, int len)
 }
 
 int os_write_file(int fd, const void *buf, int len)
-{
-	return file_io(fd, (void *) buf, len,
-		       (int (*)(int, void *, int)) write, copy_to_user_proc);
-}
-
-int os_write_file_k(int fd, const void *buf, int len)
 {
 	int n = write(fd, (void *) buf, len);
 

commit 3d564047a5f45cb628ec72514f68076e532988f3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:32 2007 -0700

    uml: start fixing os_read_file and os_write_file
    
    This patch starts the removal of a very old, very broken piece of code.  This
    stems from the problem of passing a userspace buffer into read() or write() on
    the host.  If that buffer had not yet been faulted in, read and write will
    return -EFAULT.
    
    To avoid this problem, the solution was to fault the buffer in before the
    system call by touching the pages that hold the buffer by doing a copy-user of
    a byte to each page.  This is obviously bogus, but it does usually work, in tt
    mode, since the kernel and process are in the same address space and userspace
    addresses can be accessed directly in the kernel.
    
    In skas mode, where the kernel and process are in separate address spaces, it
    is completely bogus because the userspace address, which is invalid in the
    kernel, is passed into the system call instead of the corresponding physical
    address, which would be valid.  Here, it appears that this code, on every host
    read() or write(), tries to fault in a random process page.  This doesn't seem
    to cause any correctness problems, but there is a performance impact.  This
    patch, and the ones following, result in a 10-15% performance gain on a kernel
    build.
    
    This code can't be immediately tossed out because when it is, you can't log
    in.  Apparently, there is some code in the console driver which depends on
    this somehow.
    
    However, we can start removing it by switching the code which does I/O using
    kernel addresses to using plain read() and write().  This patch introduces
    os_read_file_k and os_write_file_k for use with kernel buffers and converts
    all call locations which use obvious kernel buffers to use them.  These
    include I/O using buffers which are local variables which are on the stack or
    kmalloc-ed.  Later patches will handle the less obvious cases, followed by a
    mass conversion back to the original interface.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 4a9510c67622..5e9b8dcf34d4 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -334,12 +334,30 @@ int os_read_file(int fd, void *buf, int len)
 		       copy_from_user_proc);
 }
 
+int os_read_file_k(int fd, void *buf, int len)
+{
+	int n = read(fd, buf, len);
+
+	if(n < 0)
+		return -errno;
+	return n;
+}
+
 int os_write_file(int fd, const void *buf, int len)
 {
 	return file_io(fd, (void *) buf, len,
 		       (int (*)(int, void *, int)) write, copy_to_user_proc);
 }
 
+int os_write_file_k(int fd, const void *buf, int len)
+{
+	int n = write(fd, (void *) buf, len);
+
+	if(n < 0)
+		return -errno;
+	return n;
+}
+
 int os_file_size(char *file, unsigned long long *size_out)
 {
 	struct uml_stat buf;

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 371b4335f46d..4a9510c67622 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -18,7 +18,6 @@
 #include "os.h"
 #include "user.h"
 #include "kern_util.h"
-#include "user_util.h"
 
 static void copy_stat(struct uml_stat *dst, struct stat64 *src)
 {

commit 73c8f4441f07dd3b9d198ec0e97ce83138a6224c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:20 2007 -0800

    [PATCH] uml: libc-dependent code should call libc directly
    
    We shouldn't be using the os wrappers from os code - we can use libc directly.
    This patch replaces wrapper calls with libc calls.
    
    It turns out that os_sigio_async had only one caller, which was in startup.c,
    so that function is moved there and its name changed.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 189fa677085a..371b4335f46d 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -162,25 +162,6 @@ int os_set_owner(int fd, int pid)
 	return 0;
 }
 
-/* FIXME? moved wholesale from sigio_user.c to get fcntls out of that file */
-int os_sigio_async(int master, int slave)
-{
-	int flags;
-
-	flags = fcntl(master, F_GETFL);
-	if(flags < 0)
-		return -errno;
-
-	if((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||
-	   (fcntl(master, F_SETOWN, os_getpid()) < 0))
-		return -errno;
-
-	if((fcntl(slave, F_SETFL, flags | O_NONBLOCK) < 0))
-		return -errno;
-
-	return(0);
-}
-
 int os_mode_fd(int fd, int mode)
 {
 	int err;

commit 9ead6feedd28091d86cde0843be914847b4e10e8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:15 2006 -0700

    [PATCH] uml: add some EINTR protection
    
    Add some more uses of the CATCH_EINTR wrapper.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 367ac33c566d..189fa677085a 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -18,6 +18,7 @@
 #include "os.h"
 #include "user.h"
 #include "kern_util.h"
+#include "user_util.h"
 
 static void copy_stat(struct uml_stat *dst, struct stat64 *src)
 {
@@ -42,10 +43,7 @@ int os_stat_fd(const int fd, struct uml_stat *ubuf)
 	struct stat64 sbuf;
 	int err;
 
-	do {
-		err = fstat64(fd, &sbuf);
-	} while((err < 0) && (errno == EINTR)) ;
-
+	CATCH_EINTR(err = fstat64(fd, &sbuf));
 	if(err < 0)
 		return -errno;
 

commit 108ffa8cbfa323d462a2f4b49f38da3205d36e5a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:14 2006 -0700

    [PATCH] uml: formatting fixes
    
    Fix a bunch of formatting problems.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 09251338d99e..367ac33c566d 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
  * Licensed under the GPL
  */
@@ -47,11 +47,11 @@ int os_stat_fd(const int fd, struct uml_stat *ubuf)
 	} while((err < 0) && (errno == EINTR)) ;
 
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
 	if(ubuf != NULL)
 		copy_stat(ubuf, &sbuf);
-	return(err);
+	return err;
 }
 
 int os_stat_file(const char *file_name, struct uml_stat *ubuf)
@@ -64,11 +64,11 @@ int os_stat_file(const char *file_name, struct uml_stat *ubuf)
 	} while((err < 0) && (errno == EINTR)) ;
 
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
 	if(ubuf != NULL)
 		copy_stat(ubuf, &sbuf);
-	return(err);
+	return err;
 }
 
 int os_access(const char* file, int mode)
@@ -80,9 +80,9 @@ int os_access(const char* file, int mode)
 
 	err = access(file, amode);
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
-	return(0);
+	return 0;
 }
 
 void os_print_error(int error, const char* str)
@@ -99,9 +99,9 @@ int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
 
 	err = ioctl(fd, cmd, arg);
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
-	return(err);
+	return err;
 }
 
 int os_window_size(int fd, int *rows, int *cols)
@@ -109,12 +109,12 @@ int os_window_size(int fd, int *rows, int *cols)
 	struct winsize size;
 
 	if(ioctl(fd, TIOCGWINSZ, &size) < 0)
-		return(-errno);
+		return -errno;
 
 	*rows = size.ws_row;
 	*cols = size.ws_col;
 
-	return(0);
+	return 0;
 }
 
 int os_new_tty_pgrp(int fd, int pid)
@@ -125,16 +125,16 @@ int os_new_tty_pgrp(int fd, int pid)
 	if(tcsetpgrp(fd, pid) < 0)
 		return -errno;
 
-	return(0);
+	return 0;
 }
 
 /* FIXME: ensure namebuf in os_get_if_name is big enough */
 int os_get_ifname(int fd, char* namebuf)
 {
 	if(ioctl(fd, SIOCGIFNAME, namebuf) < 0)
-		return(-errno);
+		return -errno;
 
-	return(0);
+	return 0;
 }
 
 int os_set_slip(int fd)
@@ -149,7 +149,7 @@ int os_set_slip(int fd)
 	if(ioctl(fd, SIOCSIFENCAP, &sencap) < 0)
 		return -errno;
 
-	return(0);
+	return 0;
 }
 
 int os_set_owner(int fd, int pid)
@@ -158,10 +158,10 @@ int os_set_owner(int fd, int pid)
 		int save_errno = errno;
 
 		if(fcntl(fd, F_GETOWN, 0) != pid)
-			return(-save_errno);
+			return -save_errno;
 	}
 
-	return(0);
+	return 0;
 }
 
 /* FIXME? moved wholesale from sigio_user.c to get fcntls out of that file */
@@ -192,9 +192,9 @@ int os_mode_fd(int fd, int mode)
 	} while((err < 0) && (errno==EINTR)) ;
 
 	if(err < 0)
-		return(-errno);
+		return -errno;
 
-	return(0);
+	return 0;
 }
 
 int os_file_type(char *file)
@@ -204,15 +204,21 @@ int os_file_type(char *file)
 
 	err = os_stat_file(file, &buf);
 	if(err < 0)
-		return(err);
+		return err;
 
-	if(S_ISDIR(buf.ust_mode)) return(OS_TYPE_DIR);
-	else if(S_ISLNK(buf.ust_mode)) return(OS_TYPE_SYMLINK);
-	else if(S_ISCHR(buf.ust_mode)) return(OS_TYPE_CHARDEV);
-	else if(S_ISBLK(buf.ust_mode)) return(OS_TYPE_BLOCKDEV);
-	else if(S_ISFIFO(buf.ust_mode)) return(OS_TYPE_FIFO);
-	else if(S_ISSOCK(buf.ust_mode)) return(OS_TYPE_SOCK);
-	else return(OS_TYPE_FILE);
+	if(S_ISDIR(buf.ust_mode))
+		return OS_TYPE_DIR;
+	else if(S_ISLNK(buf.ust_mode))
+		return OS_TYPE_SYMLINK;
+	else if(S_ISCHR(buf.ust_mode))
+		return OS_TYPE_CHARDEV;
+	else if(S_ISBLK(buf.ust_mode))
+		return OS_TYPE_BLOCKDEV;
+	else if(S_ISFIFO(buf.ust_mode))
+		return OS_TYPE_FIFO;
+	else if(S_ISSOCK(buf.ust_mode))
+		return OS_TYPE_SOCK;
+	else return OS_TYPE_FILE;
 }
 
 int os_file_mode(char *file, struct openflags *mode_out)
@@ -302,8 +308,8 @@ int os_seek_file(int fd, __u64 offset)
 
 	actual = lseek64(fd, offset, SEEK_SET);
 	if(actual != offset)
-		return(-errno);
-	return(0);
+		return -errno;
+	return 0;
 }
 
 static int fault_buffer(void *start, int len,
@@ -314,13 +320,13 @@ static int fault_buffer(void *start, int len,
 
 	for(i = 0; i < len; i += page){
 		if((*copy_proc)(start + i, &c, sizeof(c)))
-			return(-EFAULT);
+			return -EFAULT;
 	}
 	if((len % page) != 0){
 		if((*copy_proc)(start + len - 1, &c, sizeof(c)))
-			return(-EFAULT);
+			return -EFAULT;
 	}
-	return(0);
+	return 0;
 }
 
 static int file_io(int fd, void *buf, int len,
@@ -334,26 +340,26 @@ static int file_io(int fd, void *buf, int len,
 		if((n < 0) && (errno == EFAULT)){
 			err = fault_buffer(buf, len, copy_user_proc);
 			if(err)
-				return(err);
+				return err;
 			n = (*io_proc)(fd, buf, len);
 		}
 	} while((n < 0) && (errno == EINTR));
 
 	if(n < 0)
-		return(-errno);
-	return(n);
+		return -errno;
+	return n;
 }
 
 int os_read_file(int fd, void *buf, int len)
 {
-	return(file_io(fd, buf, len, (int (*)(int, void *, int)) read,
-		       copy_from_user_proc));
+	return file_io(fd, buf, len, (int (*)(int, void *, int)) read,
+		       copy_from_user_proc);
 }
 
 int os_write_file(int fd, const void *buf, int len)
 {
-	return(file_io(fd, (void *) buf, len,
-		       (int (*)(int, void *, int)) write, copy_to_user_proc));
+	return file_io(fd, (void *) buf, len,
+		       (int (*)(int, void *, int)) write, copy_to_user_proc);
 }
 
 int os_file_size(char *file, unsigned long long *size_out)
@@ -398,11 +404,11 @@ int os_file_modtime(char *file, unsigned long *modtime)
 	err = os_stat_file(file, &buf);
 	if(err < 0){
 		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
-		return(err);
+		return err;
 	}
 
 	*modtime = buf.ust_mtime;
-	return(0);
+	return 0;
 }
 
 int os_get_exec_close(int fd, int* close_on_exec)
@@ -455,7 +461,7 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 	if(err < 0)
 		goto error;
 
-	return(0);
+	return 0;
 
  error:
 	printk("os_pipe : Setting FD_CLOEXEC failed, err = %d\n", -err);
@@ -486,12 +492,12 @@ int os_set_fd_async(int fd, int owner)
 	   (fcntl(fd, F_SETOWN, owner) < 0)){
 		err = -errno;
 		printk("os_set_fd_async : Failed to fcntl F_SETOWN "
-		       "(or F_SETSIG) fd %d to pid %d, errno = %d\n", fd, 
+		       "(or F_SETSIG) fd %d to pid %d, errno = %d\n", fd,
 		       owner, errno);
 		return err;
 	}
 
-	return(0);
+	return 0;
 }
 
 int os_clear_fd_async(int fd)
@@ -500,8 +506,8 @@ int os_clear_fd_async(int fd)
 
 	flags &= ~(O_ASYNC | O_NONBLOCK);
 	if(fcntl(fd, F_SETFL, flags) < 0)
-		return(-errno);
-	return(0);
+		return -errno;
+	return 0;
 }
 
 int os_set_fd_block(int fd, int blocking)
@@ -516,7 +522,7 @@ int os_set_fd_block(int fd, int blocking)
 	if(fcntl(fd, F_SETFL, flags) < 0)
 		return -errno;
 
-	return(0);
+	return 0;
 }
 
 int os_accept_connection(int fd)
@@ -524,9 +530,9 @@ int os_accept_connection(int fd)
 	int new;
 
 	new = accept(fd, NULL, 0);
-	if(new < 0) 
-		return(-errno);
-	return(new);
+	if(new < 0)
+		return -errno;
+	return new;
 }
 
 #ifndef SHUT_RD
@@ -550,12 +556,12 @@ int os_shutdown_socket(int fd, int r, int w)
 	else if(w) what = SHUT_WR;
 	else {
 		printk("os_shutdown_socket : neither r or w was set\n");
-		return(-EINVAL);
+		return -EINVAL;
 	}
 	err = shutdown(fd, what);
 	if(err < 0)
-		return(-errno);
-	return(0);
+		return -errno;
+	return 0;
 }
 
 int os_rcv_fd(int fd, int *helper_pid_out)
@@ -578,7 +584,7 @@ int os_rcv_fd(int fd, int *helper_pid_out)
 
 	n = recvmsg(fd, &msg, 0);
 	if(n < 0)
-		return(-errno);
+		return -errno;
 
 	else if(n != sizeof(iov.iov_len))
 		*helper_pid_out = -1;
@@ -586,16 +592,16 @@ int os_rcv_fd(int fd, int *helper_pid_out)
 	cmsg = CMSG_FIRSTHDR(&msg);
 	if(cmsg == NULL){
 		printk("rcv_fd didn't receive anything, error = %d\n", errno);
-		return(-1);
+		return -1;
 	}
-	if((cmsg->cmsg_level != SOL_SOCKET) || 
+	if((cmsg->cmsg_level != SOL_SOCKET) ||
 	   (cmsg->cmsg_type != SCM_RIGHTS)){
 		printk("rcv_fd didn't receive a descriptor\n");
-		return(-1);
+		return -1;
 	}
 
 	new = ((int *) CMSG_DATA(cmsg))[0];
-	return(new);
+	return new;
 }
 
 int os_create_unix_socket(char *file, int len, int close_on_exec)
@@ -623,7 +629,7 @@ int os_create_unix_socket(char *file, int len, int close_on_exec)
 	if(err < 0)
 		return -errno;
 
-	return(sock);
+	return sock;
 }
 
 void os_flush_stdout(void)
@@ -654,16 +660,5 @@ int os_lock_file(int fd, int excl)
 	printk("F_SETLK failed, file already locked by pid %d\n", lock.l_pid);
 	err = save;
  out:
-	return(err);
+	return err;
 }
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit 2ace87b9502d922397cabaf07d73e0b60c480ecf
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 1 12:16:00 2006 -0700

    [PATCH] uml: error handling fixes
    
    Blairsorblade noticed some confusion between our use of a system
    call's return value and errno.  This patch fixes a number of related
    bugs -
            using errno instead of a return value
            using a return value instead of errno
            forgetting to negate a error return to get a positive error code
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 3bd10deea280..09251338d99e 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -171,7 +171,7 @@ int os_sigio_async(int master, int slave)
 
 	flags = fcntl(master, F_GETFL);
 	if(flags < 0)
-		return errno;
+		return -errno;
 
 	if((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||
 	   (fcntl(master, F_SETOWN, os_getpid()) < 0))

commit dc1561ac019ff7b6f75c5175abd2ec65c8dbd581
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Fri Feb 24 13:03:56 2006 -0800

    [PATCH] uml: os_connect_socket error path fixup
    
    Fix an fd leak and a return of -1 instead of -errno in the error path - this
    showed up in intensive testing of HPPFS, the os_connect_socket user.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Acked-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index f55773c819e6..3bd10deea280 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -272,14 +272,23 @@ int os_connect_socket(char *name)
 	snprintf(sock.sun_path, sizeof(sock.sun_path), "%s", name);
 
 	fd = socket(AF_UNIX, SOCK_STREAM, 0);
-	if(fd < 0)
-		return(fd);
+	if(fd < 0) {
+		err = -errno;
+		goto out;
+	}
 
 	err = connect(fd, (struct sockaddr *) &sock, sizeof(sock));
-	if(err)
-		return(-errno);
+	if(err) {
+		err = -errno;
+		goto out_close;
+	}
 
-	return(fd);
+	return fd;
+
+out_close:
+	close(fd);
+out:
+	return err;
 }
 
 void os_close_file(int fd)

commit b4fd310e163477236a241580b3b8c29aee65f4cc
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Sep 16 19:27:49 2005 -0700

    [PATCH] uml: preserve errno in error paths
    
    The poster child for this patch is the third tuntap_user hunk.  When an ioctl
    fails, it properly closes the opened file descriptor and returns.  However,
    the close resets errno to 0, and the 'return errno' that follows returns 0
    rather than the value that ioctl set.  This caused the caller to believe that
    the device open succeeded and had opened file descriptor 0, which caused no
    end of interesting behavior.
    
    The rest of this patch is a pass through the UML sources looking for places
    where errno could be reset before being passed back out.  A common culprit is
    printk, which could call write, being called before errno is returned.
    
    In some cases, where the code ends up being much smaller, I just deleted the
    printk.
    
    There was another case where a caller of run_helper looked at errno after a
    failure, rather than the return value of run_helper, which was the errno value
    that it wanted.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index fd45bb260907..f55773c819e6 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -119,15 +119,11 @@ int os_window_size(int fd, int *rows, int *cols)
 
 int os_new_tty_pgrp(int fd, int pid)
 {
-	if(ioctl(fd, TIOCSCTTY, 0) < 0){
-		printk("TIOCSCTTY failed, errno = %d\n", errno);
-		return(-errno);
-	}
+	if(ioctl(fd, TIOCSCTTY, 0) < 0)
+		return -errno;
 
-	if(tcsetpgrp(fd, pid) < 0){
-		printk("tcsetpgrp failed, errno = %d\n", errno);
-		return(-errno);
-	}
+	if(tcsetpgrp(fd, pid) < 0)
+		return -errno;
 
 	return(0);
 }
@@ -146,18 +142,12 @@ int os_set_slip(int fd)
 	int disc, sencap;
 
 	disc = N_SLIP;
-	if(ioctl(fd, TIOCSETD, &disc) < 0){
-		printk("Failed to set slip line discipline - "
-		       "errno = %d\n", errno);
-		return(-errno);
-	}
+	if(ioctl(fd, TIOCSETD, &disc) < 0)
+		return -errno;
 
 	sencap = 0;
-	if(ioctl(fd, SIOCSIFENCAP, &sencap) < 0){
-		printk("Failed to set slip encapsulation - "
-		       "errno = %d\n", errno);
-		return(-errno);
-	}
+	if(ioctl(fd, SIOCSIFENCAP, &sencap) < 0)
+		return -errno;
 
 	return(0);
 }
@@ -180,22 +170,15 @@ int os_sigio_async(int master, int slave)
 	int flags;
 
 	flags = fcntl(master, F_GETFL);
-	if(flags < 0) {
-		printk("fcntl F_GETFL failed, errno = %d\n", errno);
-		return(-errno);
-	}
+	if(flags < 0)
+		return errno;
 
 	if((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||
-	   (fcntl(master, F_SETOWN, os_getpid()) < 0)){
-		printk("fcntl F_SETFL or F_SETOWN failed, errno = %d\n",
-		       errno);
-		return(-errno);
-	}
+	   (fcntl(master, F_SETOWN, os_getpid()) < 0))
+		return -errno;
 
-	if((fcntl(slave, F_SETFL, flags | O_NONBLOCK) < 0)){
-		printk("fcntl F_SETFL failed, errno = %d\n", errno);
-		return(-errno);
-	}
+	if((fcntl(slave, F_SETFL, flags | O_NONBLOCK) < 0))
+		return -errno;
 
 	return(0);
 }
@@ -255,7 +238,7 @@ int os_file_mode(char *file, struct openflags *mode_out)
 
 int os_open_file(char *file, struct openflags flags, int mode)
 {
-	int fd, f = 0;
+	int fd, err, f = 0;
 
 	if(flags.r && flags.w) f = O_RDWR;
 	else if(flags.r) f = O_RDONLY;
@@ -272,8 +255,9 @@ int os_open_file(char *file, struct openflags flags, int mode)
 		return(-errno);
 
 	if(flags.cl && fcntl(fd, F_SETFD, 1)){
+		err = -errno;
 		os_close_file(fd);
-		return(-errno);
+		return err;
 	}
 
 	return(fd);
@@ -383,9 +367,9 @@ int os_file_size(char *file, unsigned long long *size_out)
 			return(fd);
 		}
 		if(ioctl(fd, BLKGETSIZE, &blocks) < 0){
+			err = -errno;
 			printk("Couldn't get the block size of \"%s\", "
 			       "errno = %d\n", file, errno);
-			err = -errno;
 			os_close_file(fd);
 			return(err);
 		}
@@ -473,11 +457,14 @@ int os_pipe(int *fds, int stream, int close_on_exec)
 
 int os_set_fd_async(int fd, int owner)
 {
+	int err;
+
 	/* XXX This should do F_GETFL first */
 	if(fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0){
+		err = -errno;
 		printk("os_set_fd_async : failed to set O_ASYNC and "
 		       "O_NONBLOCK on fd # %d, errno = %d\n", fd, errno);
-		return(-errno);
+		return err;
 	}
 #ifdef notdef
 	if(fcntl(fd, F_SETFD, 1) < 0){
@@ -488,10 +475,11 @@ int os_set_fd_async(int fd, int owner)
 
 	if((fcntl(fd, F_SETSIG, SIGIO) < 0) ||
 	   (fcntl(fd, F_SETOWN, owner) < 0)){
+		err = -errno;
 		printk("os_set_fd_async : Failed to fcntl F_SETOWN "
 		       "(or F_SETSIG) fd %d to pid %d, errno = %d\n", fd, 
 		       owner, errno);
-		return(-errno);
+		return err;
 	}
 
 	return(0);
@@ -516,11 +504,9 @@ int os_set_fd_block(int fd, int blocking)
 	if(blocking) flags &= ~O_NONBLOCK;
 	else flags |= O_NONBLOCK;
 
-	if(fcntl(fd, F_SETFL, flags) < 0){
-		printk("Failed to change blocking on fd # %d, errno = %d\n",
-		       fd, errno);
-		return(-errno);
-	}
+	if(fcntl(fd, F_SETFL, flags) < 0)
+		return -errno;
+
 	return(0);
 }
 
@@ -609,11 +595,8 @@ int os_create_unix_socket(char *file, int len, int close_on_exec)
 	int sock, err;
 
 	sock = socket(PF_UNIX, SOCK_DGRAM, 0);
-	if (sock < 0){
-		printk("create_unix_socket - socket failed, errno = %d\n",
-		       errno);
-		return(-errno);
-	}
+	if(sock < 0)
+		return -errno;
 
 	if(close_on_exec) {
 		err = os_set_exec_close(sock, 1);
@@ -628,11 +611,8 @@ int os_create_unix_socket(char *file, int len, int close_on_exec)
 	snprintf(addr.sun_path, len, "%s", file);
 
 	err = bind(sock, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0){
-		printk("create_listening_socket at '%s' - bind failed, "
-		       "errno = %d\n", file, errno);
-		return(-errno);
-	}
+	if(err < 0)
+		return -errno;
 
 	return(sock);
 }

commit da00d9a5466558ccd9e7b7d04b13d7cb9160c876
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Jun 8 15:48:01 2005 -0700

    [PATCH] uml: compile fixes for gcc 4
    
    This is a bunch of compile fixes provoked by building UML with gcc 4.  There
    are a bunch of signedness mismatches, a couple of uninitialized references,
    and a botched C99 structure initialization which had somehow gone unnoticed.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
index 77d4066d1af8..fd45bb260907 100644
--- a/arch/um/os-Linux/file.c
+++ b/arch/um/os-Linux/file.c
@@ -363,7 +363,7 @@ int os_write_file(int fd, const void *buf, int len)
 		       (int (*)(int, void *, int)) write, copy_to_user_proc));
 }
 
-int os_file_size(char *file, long long *size_out)
+int os_file_size(char *file, unsigned long long *size_out)
 {
 	struct uml_stat buf;
 	int err;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/os-Linux/file.c b/arch/um/os-Linux/file.c
new file mode 100644
index 000000000000..77d4066d1af8
--- /dev/null
+++ b/arch/um/os-Linux/file.c
@@ -0,0 +1,680 @@
+/* 
+ * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+#include <sys/uio.h>
+#include "os.h"
+#include "user.h"
+#include "kern_util.h"
+
+static void copy_stat(struct uml_stat *dst, struct stat64 *src)
+{
+	*dst = ((struct uml_stat) {
+		.ust_dev     = src->st_dev,     /* device */
+		.ust_ino     = src->st_ino,     /* inode */
+		.ust_mode    = src->st_mode,    /* protection */
+		.ust_nlink   = src->st_nlink,   /* number of hard links */
+		.ust_uid     = src->st_uid,     /* user ID of owner */
+		.ust_gid     = src->st_gid,     /* group ID of owner */
+		.ust_size    = src->st_size,    /* total size, in bytes */
+		.ust_blksize = src->st_blksize, /* blocksize for filesys I/O */
+		.ust_blocks  = src->st_blocks,  /* number of blocks allocated */
+		.ust_atime   = src->st_atime,   /* time of last access */
+		.ust_mtime   = src->st_mtime,   /* time of last modification */
+		.ust_ctime   = src->st_ctime,   /* time of last change */
+	});
+}
+
+int os_stat_fd(const int fd, struct uml_stat *ubuf)
+{
+	struct stat64 sbuf;
+	int err;
+
+	do {
+		err = fstat64(fd, &sbuf);
+	} while((err < 0) && (errno == EINTR)) ;
+
+	if(err < 0)
+		return(-errno);
+
+	if(ubuf != NULL)
+		copy_stat(ubuf, &sbuf);
+	return(err);
+}
+
+int os_stat_file(const char *file_name, struct uml_stat *ubuf)
+{
+	struct stat64 sbuf;
+	int err;
+
+	do {
+		err = stat64(file_name, &sbuf);
+	} while((err < 0) && (errno == EINTR)) ;
+
+	if(err < 0)
+		return(-errno);
+
+	if(ubuf != NULL)
+		copy_stat(ubuf, &sbuf);
+	return(err);
+}
+
+int os_access(const char* file, int mode)
+{
+	int amode, err;
+
+	amode=(mode&OS_ACC_R_OK ? R_OK : 0) | (mode&OS_ACC_W_OK ? W_OK : 0) |
+	      (mode&OS_ACC_X_OK ? X_OK : 0) | (mode&OS_ACC_F_OK ? F_OK : 0) ;
+
+	err = access(file, amode);
+	if(err < 0)
+		return(-errno);
+
+	return(0);
+}
+
+void os_print_error(int error, const char* str)
+{
+	errno = error < 0 ? -error : error;
+
+	perror(str);
+}
+
+/* FIXME? required only by hostaudio (because it passes ioctls verbatim) */
+int os_ioctl_generic(int fd, unsigned int cmd, unsigned long arg)
+{
+	int err;
+
+	err = ioctl(fd, cmd, arg);
+	if(err < 0)
+		return(-errno);
+
+	return(err);
+}
+
+int os_window_size(int fd, int *rows, int *cols)
+{
+	struct winsize size;
+
+	if(ioctl(fd, TIOCGWINSZ, &size) < 0)
+		return(-errno);
+
+	*rows = size.ws_row;
+	*cols = size.ws_col;
+
+	return(0);
+}
+
+int os_new_tty_pgrp(int fd, int pid)
+{
+	if(ioctl(fd, TIOCSCTTY, 0) < 0){
+		printk("TIOCSCTTY failed, errno = %d\n", errno);
+		return(-errno);
+	}
+
+	if(tcsetpgrp(fd, pid) < 0){
+		printk("tcsetpgrp failed, errno = %d\n", errno);
+		return(-errno);
+	}
+
+	return(0);
+}
+
+/* FIXME: ensure namebuf in os_get_if_name is big enough */
+int os_get_ifname(int fd, char* namebuf)
+{
+	if(ioctl(fd, SIOCGIFNAME, namebuf) < 0)
+		return(-errno);
+
+	return(0);
+}
+
+int os_set_slip(int fd)
+{
+	int disc, sencap;
+
+	disc = N_SLIP;
+	if(ioctl(fd, TIOCSETD, &disc) < 0){
+		printk("Failed to set slip line discipline - "
+		       "errno = %d\n", errno);
+		return(-errno);
+	}
+
+	sencap = 0;
+	if(ioctl(fd, SIOCSIFENCAP, &sencap) < 0){
+		printk("Failed to set slip encapsulation - "
+		       "errno = %d\n", errno);
+		return(-errno);
+	}
+
+	return(0);
+}
+
+int os_set_owner(int fd, int pid)
+{
+	if(fcntl(fd, F_SETOWN, pid) < 0){
+		int save_errno = errno;
+
+		if(fcntl(fd, F_GETOWN, 0) != pid)
+			return(-save_errno);
+	}
+
+	return(0);
+}
+
+/* FIXME? moved wholesale from sigio_user.c to get fcntls out of that file */
+int os_sigio_async(int master, int slave)
+{
+	int flags;
+
+	flags = fcntl(master, F_GETFL);
+	if(flags < 0) {
+		printk("fcntl F_GETFL failed, errno = %d\n", errno);
+		return(-errno);
+	}
+
+	if((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||
+	   (fcntl(master, F_SETOWN, os_getpid()) < 0)){
+		printk("fcntl F_SETFL or F_SETOWN failed, errno = %d\n",
+		       errno);
+		return(-errno);
+	}
+
+	if((fcntl(slave, F_SETFL, flags | O_NONBLOCK) < 0)){
+		printk("fcntl F_SETFL failed, errno = %d\n", errno);
+		return(-errno);
+	}
+
+	return(0);
+}
+
+int os_mode_fd(int fd, int mode)
+{
+	int err;
+
+	do {
+		err = fchmod(fd, mode);
+	} while((err < 0) && (errno==EINTR)) ;
+
+	if(err < 0)
+		return(-errno);
+
+	return(0);
+}
+
+int os_file_type(char *file)
+{
+	struct uml_stat buf;
+	int err;
+
+	err = os_stat_file(file, &buf);
+	if(err < 0)
+		return(err);
+
+	if(S_ISDIR(buf.ust_mode)) return(OS_TYPE_DIR);
+	else if(S_ISLNK(buf.ust_mode)) return(OS_TYPE_SYMLINK);
+	else if(S_ISCHR(buf.ust_mode)) return(OS_TYPE_CHARDEV);
+	else if(S_ISBLK(buf.ust_mode)) return(OS_TYPE_BLOCKDEV);
+	else if(S_ISFIFO(buf.ust_mode)) return(OS_TYPE_FIFO);
+	else if(S_ISSOCK(buf.ust_mode)) return(OS_TYPE_SOCK);
+	else return(OS_TYPE_FILE);
+}
+
+int os_file_mode(char *file, struct openflags *mode_out)
+{
+	int err;
+
+	*mode_out = OPENFLAGS();
+
+	err = os_access(file, OS_ACC_W_OK);
+	if((err < 0) && (err != -EACCES))
+		return(err);
+
+	*mode_out = of_write(*mode_out);
+
+	err = os_access(file, OS_ACC_R_OK);
+	if((err < 0) && (err != -EACCES))
+		return(err);
+
+	*mode_out = of_read(*mode_out);
+
+	return(0);
+}
+
+int os_open_file(char *file, struct openflags flags, int mode)
+{
+	int fd, f = 0;
+
+	if(flags.r && flags.w) f = O_RDWR;
+	else if(flags.r) f = O_RDONLY;
+	else if(flags.w) f = O_WRONLY;
+	else f = 0;
+
+	if(flags.s) f |= O_SYNC;
+	if(flags.c) f |= O_CREAT;
+	if(flags.t) f |= O_TRUNC;
+	if(flags.e) f |= O_EXCL;
+
+	fd = open64(file, f, mode);
+	if(fd < 0)
+		return(-errno);
+
+	if(flags.cl && fcntl(fd, F_SETFD, 1)){
+		os_close_file(fd);
+		return(-errno);
+	}
+
+	return(fd);
+}
+
+int os_connect_socket(char *name)
+{
+	struct sockaddr_un sock;
+	int fd, err;
+
+	sock.sun_family = AF_UNIX;
+	snprintf(sock.sun_path, sizeof(sock.sun_path), "%s", name);
+
+	fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if(fd < 0)
+		return(fd);
+
+	err = connect(fd, (struct sockaddr *) &sock, sizeof(sock));
+	if(err)
+		return(-errno);
+
+	return(fd);
+}
+
+void os_close_file(int fd)
+{
+	close(fd);
+}
+
+int os_seek_file(int fd, __u64 offset)
+{
+	__u64 actual;
+
+	actual = lseek64(fd, offset, SEEK_SET);
+	if(actual != offset)
+		return(-errno);
+	return(0);
+}
+
+static int fault_buffer(void *start, int len,
+			int (*copy_proc)(void *addr, void *buf, int len))
+{
+	int page = getpagesize(), i;
+	char c;
+
+	for(i = 0; i < len; i += page){
+		if((*copy_proc)(start + i, &c, sizeof(c)))
+			return(-EFAULT);
+	}
+	if((len % page) != 0){
+		if((*copy_proc)(start + len - 1, &c, sizeof(c)))
+			return(-EFAULT);
+	}
+	return(0);
+}
+
+static int file_io(int fd, void *buf, int len,
+		   int (*io_proc)(int fd, void *buf, int len),
+		   int (*copy_user_proc)(void *addr, void *buf, int len))
+{
+	int n, err;
+
+	do {
+		n = (*io_proc)(fd, buf, len);
+		if((n < 0) && (errno == EFAULT)){
+			err = fault_buffer(buf, len, copy_user_proc);
+			if(err)
+				return(err);
+			n = (*io_proc)(fd, buf, len);
+		}
+	} while((n < 0) && (errno == EINTR));
+
+	if(n < 0)
+		return(-errno);
+	return(n);
+}
+
+int os_read_file(int fd, void *buf, int len)
+{
+	return(file_io(fd, buf, len, (int (*)(int, void *, int)) read,
+		       copy_from_user_proc));
+}
+
+int os_write_file(int fd, const void *buf, int len)
+{
+	return(file_io(fd, (void *) buf, len,
+		       (int (*)(int, void *, int)) write, copy_to_user_proc));
+}
+
+int os_file_size(char *file, long long *size_out)
+{
+	struct uml_stat buf;
+	int err;
+
+	err = os_stat_file(file, &buf);
+	if(err < 0){
+		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
+		return(err);
+	}
+
+	if(S_ISBLK(buf.ust_mode)){
+		int fd, blocks;
+
+		fd = os_open_file(file, of_read(OPENFLAGS()), 0);
+		if(fd < 0){
+			printk("Couldn't open \"%s\", errno = %d\n", file, -fd);
+			return(fd);
+		}
+		if(ioctl(fd, BLKGETSIZE, &blocks) < 0){
+			printk("Couldn't get the block size of \"%s\", "
+			       "errno = %d\n", file, errno);
+			err = -errno;
+			os_close_file(fd);
+			return(err);
+		}
+		*size_out = ((long long) blocks) * 512;
+		os_close_file(fd);
+		return(0);
+	}
+	*size_out = buf.ust_size;
+	return(0);
+}
+
+int os_file_modtime(char *file, unsigned long *modtime)
+{
+	struct uml_stat buf;
+	int err;
+
+	err = os_stat_file(file, &buf);
+	if(err < 0){
+		printk("Couldn't stat \"%s\" : err = %d\n", file, -err);
+		return(err);
+	}
+
+	*modtime = buf.ust_mtime;
+	return(0);
+}
+
+int os_get_exec_close(int fd, int* close_on_exec)
+{
+	int ret;
+
+	do {
+		ret = fcntl(fd, F_GETFD);
+	} while((ret < 0) && (errno == EINTR)) ;
+
+	if(ret < 0)
+		return(-errno);
+
+	*close_on_exec = (ret&FD_CLOEXEC) ? 1 : 0;
+	return(ret);
+}
+
+int os_set_exec_close(int fd, int close_on_exec)
+{
+	int flag, err;
+
+	if(close_on_exec) flag = FD_CLOEXEC;
+	else flag = 0;
+
+	do {
+		err = fcntl(fd, F_SETFD, flag);
+	} while((err < 0) && (errno == EINTR)) ;
+
+	if(err < 0)
+		return(-errno);
+	return(err);
+}
+
+int os_pipe(int *fds, int stream, int close_on_exec)
+{
+	int err, type = stream ? SOCK_STREAM : SOCK_DGRAM;
+
+	err = socketpair(AF_UNIX, type, 0, fds);
+	if(err < 0)
+		return(-errno);
+
+	if(!close_on_exec)
+		return(0);
+
+	err = os_set_exec_close(fds[0], 1);
+	if(err < 0)
+		goto error;
+
+	err = os_set_exec_close(fds[1], 1);
+	if(err < 0)
+		goto error;
+
+	return(0);
+
+ error:
+	printk("os_pipe : Setting FD_CLOEXEC failed, err = %d\n", -err);
+	os_close_file(fds[1]);
+	os_close_file(fds[0]);
+	return(err);
+}
+
+int os_set_fd_async(int fd, int owner)
+{
+	/* XXX This should do F_GETFL first */
+	if(fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0){
+		printk("os_set_fd_async : failed to set O_ASYNC and "
+		       "O_NONBLOCK on fd # %d, errno = %d\n", fd, errno);
+		return(-errno);
+	}
+#ifdef notdef
+	if(fcntl(fd, F_SETFD, 1) < 0){
+		printk("os_set_fd_async : Setting FD_CLOEXEC failed, "
+		       "errno = %d\n", errno);
+	}
+#endif
+
+	if((fcntl(fd, F_SETSIG, SIGIO) < 0) ||
+	   (fcntl(fd, F_SETOWN, owner) < 0)){
+		printk("os_set_fd_async : Failed to fcntl F_SETOWN "
+		       "(or F_SETSIG) fd %d to pid %d, errno = %d\n", fd, 
+		       owner, errno);
+		return(-errno);
+	}
+
+	return(0);
+}
+
+int os_clear_fd_async(int fd)
+{
+	int flags = fcntl(fd, F_GETFL);
+
+	flags &= ~(O_ASYNC | O_NONBLOCK);
+	if(fcntl(fd, F_SETFL, flags) < 0)
+		return(-errno);
+	return(0);
+}
+
+int os_set_fd_block(int fd, int blocking)
+{
+	int flags;
+
+	flags = fcntl(fd, F_GETFL);
+
+	if(blocking) flags &= ~O_NONBLOCK;
+	else flags |= O_NONBLOCK;
+
+	if(fcntl(fd, F_SETFL, flags) < 0){
+		printk("Failed to change blocking on fd # %d, errno = %d\n",
+		       fd, errno);
+		return(-errno);
+	}
+	return(0);
+}
+
+int os_accept_connection(int fd)
+{
+	int new;
+
+	new = accept(fd, NULL, 0);
+	if(new < 0) 
+		return(-errno);
+	return(new);
+}
+
+#ifndef SHUT_RD
+#define SHUT_RD 0
+#endif
+
+#ifndef SHUT_WR
+#define SHUT_WR 1
+#endif
+
+#ifndef SHUT_RDWR
+#define SHUT_RDWR 2
+#endif
+
+int os_shutdown_socket(int fd, int r, int w)
+{
+	int what, err;
+
+	if(r && w) what = SHUT_RDWR;
+	else if(r) what = SHUT_RD;
+	else if(w) what = SHUT_WR;
+	else {
+		printk("os_shutdown_socket : neither r or w was set\n");
+		return(-EINVAL);
+	}
+	err = shutdown(fd, what);
+	if(err < 0)
+		return(-errno);
+	return(0);
+}
+
+int os_rcv_fd(int fd, int *helper_pid_out)
+{
+	int new, n;
+	char buf[CMSG_SPACE(sizeof(new))];
+	struct msghdr msg;
+	struct cmsghdr *cmsg;
+	struct iovec iov;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	iov = ((struct iovec) { .iov_base  = helper_pid_out,
+				.iov_len   = sizeof(*helper_pid_out) });
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = buf;
+	msg.msg_controllen = sizeof(buf);
+	msg.msg_flags = 0;
+
+	n = recvmsg(fd, &msg, 0);
+	if(n < 0)
+		return(-errno);
+
+	else if(n != sizeof(iov.iov_len))
+		*helper_pid_out = -1;
+
+	cmsg = CMSG_FIRSTHDR(&msg);
+	if(cmsg == NULL){
+		printk("rcv_fd didn't receive anything, error = %d\n", errno);
+		return(-1);
+	}
+	if((cmsg->cmsg_level != SOL_SOCKET) || 
+	   (cmsg->cmsg_type != SCM_RIGHTS)){
+		printk("rcv_fd didn't receive a descriptor\n");
+		return(-1);
+	}
+
+	new = ((int *) CMSG_DATA(cmsg))[0];
+	return(new);
+}
+
+int os_create_unix_socket(char *file, int len, int close_on_exec)
+{
+	struct sockaddr_un addr;
+	int sock, err;
+
+	sock = socket(PF_UNIX, SOCK_DGRAM, 0);
+	if (sock < 0){
+		printk("create_unix_socket - socket failed, errno = %d\n",
+		       errno);
+		return(-errno);
+	}
+
+	if(close_on_exec) {
+		err = os_set_exec_close(sock, 1);
+		if(err < 0)
+			printk("create_unix_socket : close_on_exec failed, "
+		       "err = %d", -err);
+	}
+
+	addr.sun_family = AF_UNIX;
+
+	/* XXX Be more careful about overflow */
+	snprintf(addr.sun_path, len, "%s", file);
+
+	err = bind(sock, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0){
+		printk("create_listening_socket at '%s' - bind failed, "
+		       "errno = %d\n", file, errno);
+		return(-errno);
+	}
+
+	return(sock);
+}
+
+void os_flush_stdout(void)
+{
+	fflush(stdout);
+}
+
+int os_lock_file(int fd, int excl)
+{
+	int type = excl ? F_WRLCK : F_RDLCK;
+	struct flock lock = ((struct flock) { .l_type	= type,
+					      .l_whence	= SEEK_SET,
+					      .l_start	= 0,
+					      .l_len	= 0 } );
+	int err, save;
+
+	err = fcntl(fd, F_SETLK, &lock);
+	if(!err)
+		goto out;
+
+	save = -errno;
+	err = fcntl(fd, F_GETLK, &lock);
+	if(err){
+		err = -errno;
+		goto out;
+	}
+
+	printk("F_SETLK failed, file already locked by pid %d\n", lock.l_pid);
+	err = save;
+ out:
+	return(err);
+}
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
