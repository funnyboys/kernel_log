commit 0d1fb0a47c09b21d82c680476da26035f402660a
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:17 2019 +0100

    um: Add SPDX headers to files in arch/um/kernel/
    
    Convert files to use SPDX header. All files are licensed under the
    GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 870c80c88a97..e7c7b53a1435 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2000 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <linux/module.h>

commit 5d38f324993f49d1226ec81efe045834b46cd85a
Author: Erel Geron <erelx.geron@intel.com>
Date:   Wed Sep 11 14:51:20 2019 +0200

    um: drivers: Add virtio vhost-user driver
    
    This module allows virtio devices to be used over a vhost-user socket.
    
    Signed-off-by: Erel Geron <erelx.geron@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 5bf56af4d5b9..870c80c88a97 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -143,6 +143,7 @@ int phys_mapping(unsigned long phys, unsigned long long *offset_out)
 
 	return fd;
 }
+EXPORT_SYMBOL(phys_mapping);
 
 static int __init uml_mem_setup(char *line, int *add)
 {

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 296a91a04598..5bf56af4d5b9 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -4,7 +4,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/mm.h>
 #include <linux/pfn.h>

commit ddf63983576ac2520d13a49f03f2d382ac60e2c7
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Fri Oct 26 15:05:02 2018 -0700

    um: switch to NO_BOOTMEM
    
    Replace bootmem initialization with memblock_add and memblock_reserve calls
    and explicit initialization of {min,max}_low_pfn.
    
    Link: http://lkml.kernel.org/r/1533326330-31677-7-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Richard Weinberger <richard@nod.at>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Michal Hocko <mhocko@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 0eaec0e24767..296a91a04598 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -5,6 +5,7 @@
 
 #include <linux/module.h>
 #include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/mm.h>
 #include <linux/pfn.h>
 #include <asm/page.h>
@@ -80,23 +81,18 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 			  unsigned long len, unsigned long long highmem)
 {
 	unsigned long reserve = reserve_end - start;
-	unsigned long pfn = PFN_UP(__pa(reserve_end));
-	unsigned long delta = (len - reserve) >> PAGE_SHIFT;
-	unsigned long offset, bootmap_size;
-	long map_size;
+	long map_size = len - reserve;
 	int err;
 
-	offset = reserve_end - start;
-	map_size = len - offset;
 	if(map_size <= 0) {
 		os_warn("Too few physical memory! Needed=%lu, given=%lu\n",
-			offset, len);
+			reserve, len);
 		exit(1);
 	}
 
 	physmem_fd = create_mem_file(len + highmem);
 
-	err = os_map_memory((void *) reserve_end, physmem_fd, offset,
+	err = os_map_memory((void *) reserve_end, physmem_fd, reserve,
 			    map_size, 1, 1, 1);
 	if (err < 0) {
 		os_warn("setup_physmem - mapping %ld bytes of memory at 0x%p "
@@ -113,9 +109,11 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	os_write_file(physmem_fd, __syscall_stub_start, PAGE_SIZE);
 	os_fsync_file(physmem_fd);
 
-	bootmap_size = init_bootmem(pfn, pfn + delta);
-	free_bootmem(__pa(reserve_end) + bootmap_size,
-		     len - bootmap_size - reserve);
+	memblock_add(__pa(start), len + highmem);
+	memblock_reserve(__pa(start), reserve);
+
+	min_low_pfn = PFN_UP(__pa(reserve_end));
+	max_low_pfn = min_low_pfn + (map_size >> PAGE_SHIFT);
 }
 
 int phys_mapping(unsigned long phys, unsigned long long *offset_out)

commit be6ec5b1eecf1c5e985831540b90a320a9ed3aa5
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Fri Oct 26 15:04:58 2018 -0700

    um: setup_physmem: stop using global variables
    
    The setup_physmem() function receives uml_physmem and uml_reserved as
    parameters and still used these global variables.  Replace such usage with
    local variables.
    
    Link: http://lkml.kernel.org/r/1533326330-31677-6-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Richard Weinberger <richard@nod.at>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Michal Hocko <mhocko@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index f02596e9931d..0eaec0e24767 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -86,7 +86,7 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	long map_size;
 	int err;
 
-	offset = uml_reserved - uml_physmem;
+	offset = reserve_end - start;
 	map_size = len - offset;
 	if(map_size <= 0) {
 		os_warn("Too few physical memory! Needed=%lu, given=%lu\n",
@@ -96,12 +96,12 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 
 	physmem_fd = create_mem_file(len + highmem);
 
-	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
+	err = os_map_memory((void *) reserve_end, physmem_fd, offset,
 			    map_size, 1, 1, 1);
 	if (err < 0) {
 		os_warn("setup_physmem - mapping %ld bytes of memory at 0x%p "
 			"failed - errno = %d\n", map_size,
-			(void *) uml_reserved, err);
+			(void *) reserve_end, err);
 		exit(1);
 	}
 

commit 0936d4f3d5a3d5daf453bc341f02ba4e68cfe40e
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu May 18 02:19:31 2017 +0900

    um: Use os_warn to print out pre-boot warning/error messages
    
    Use os_warn() instead of printf/fprintf to print out
    pre-boot warning/error messages to stderr.
    Note that the help message and version message are
    kept to print out to stdout, because user explicitly
    specifies those options to get such information.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 4c9861b421fd..f02596e9931d 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -89,8 +89,8 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	offset = uml_reserved - uml_physmem;
 	map_size = len - offset;
 	if(map_size <= 0) {
-		printf("Too few physical memory! Needed=%d, given=%d\n",
-		       offset, len);
+		os_warn("Too few physical memory! Needed=%lu, given=%lu\n",
+			offset, len);
 		exit(1);
 	}
 
@@ -99,9 +99,9 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
 			    map_size, 1, 1, 1);
 	if (err < 0) {
-		printf("setup_physmem - mapping %ld bytes of memory at 0x%p "
-		       "failed - errno = %d\n", map_size,
-		       (void *) uml_reserved, err);
+		os_warn("setup_physmem - mapping %ld bytes of memory at 0x%p "
+			"failed - errno = %d\n", map_size,
+			(void *) uml_reserved, err);
 		exit(1);
 	}
 

commit 05eacfd00ccf239a24cfb409b084fa126c2e9468
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Sun Oct 12 13:02:12 2014 +0200

    um: Use char[] for linker script address declarations
    
    The linker script defines some variables which are declared either with
    type char[] in include/asm-generic/sections.h or with a meaningless
    integer type in arch/um/include/asm/sections.h.
    
    Fix this inconsistency by declaring every variable char[].
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 249c9feb5485..4c9861b421fd 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -109,8 +109,8 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	 * Special kludge - This page will be mapped in to userspace processes
 	 * from physmem_fd, so it needs to be written out there.
 	 */
-	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
-	os_write_file(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
+	os_seek_file(physmem_fd, __pa(__syscall_stub_start));
+	os_write_file(physmem_fd, __syscall_stub_start, PAGE_SIZE);
 	os_fsync_file(physmem_fd);
 
 	bootmap_size = init_bootmem(pfn, pfn + delta);

commit d5f20be7cab85e6e701751323eea77c7935ae522
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Sun Oct 12 13:02:11 2014 +0200

    um: Create asm/sections.h
    
    arch/um/kernel/dyn.lds.S and arch/um/kernel/uml.lds.S define some
    UML-specific symbols.  These symbols are used in the kernel part of UML
    with extern declarations.
    
    Move these declarations to a new header, asm/sections.h, like other
    architectures do.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 9034fc8056b4..249c9feb5485 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -8,6 +8,7 @@
 #include <linux/mm.h>
 #include <linux/pfn.h>
 #include <asm/page.h>
+#include <asm/sections.h>
 #include <as-layout.h>
 #include <init.h>
 #include <kern.h>
@@ -55,8 +56,6 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 	}
 }
 
-extern int __syscall_stub_start;
-
 /**
  * setup_physmem() - Setup physical memory for UML
  * @start:	Start address of the physical kernel memory,

commit fe205bdd1321f95f8f3c35d243ea7cb22af8fbe1
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Fri Apr 3 16:51:26 2015 +0200

    um: Print minimum physical memory requirement
    
    Print a more sensible message about the minimum physical memory
    requirement.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 549ecf3f5857..9034fc8056b4 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -57,22 +57,51 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 
 extern int __syscall_stub_start;
 
+/**
+ * setup_physmem() - Setup physical memory for UML
+ * @start:	Start address of the physical kernel memory,
+ *		i.e start address of the executable image.
+ * @reserve_end:	end address of the physical kernel memory.
+ * @len:	Length of total physical memory that should be mapped/made
+ *		available, in bytes.
+ * @highmem:	Number of highmem bytes that should be mapped/made available.
+ *
+ * Creates an unlinked temporary file of size (len + highmem) and memory maps
+ * it on the last executable image address (uml_reserved).
+ *
+ * The offset is needed as the length of the total physical memory
+ * (len + highmem) includes the size of the memory used be the executable image,
+ * but the mapped-to address is the last address of the executable image
+ * (uml_reserved == end address of executable image).
+ *
+ * The memory mapped memory of the temporary file is used as backing memory
+ * of all user space processes/kernel tasks.
+ */
 void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 			  unsigned long len, unsigned long long highmem)
 {
 	unsigned long reserve = reserve_end - start;
-	int pfn = PFN_UP(__pa(reserve_end));
-	int delta = (len - reserve) >> PAGE_SHIFT;
-	int err, offset, bootmap_size;
+	unsigned long pfn = PFN_UP(__pa(reserve_end));
+	unsigned long delta = (len - reserve) >> PAGE_SHIFT;
+	unsigned long offset, bootmap_size;
+	long map_size;
+	int err;
+
+	offset = uml_reserved - uml_physmem;
+	map_size = len - offset;
+	if(map_size <= 0) {
+		printf("Too few physical memory! Needed=%d, given=%d\n",
+		       offset, len);
+		exit(1);
+	}
 
 	physmem_fd = create_mem_file(len + highmem);
 
-	offset = uml_reserved - uml_physmem;
 	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
-			    len - offset, 1, 1, 1);
+			    map_size, 1, 1, 1);
 	if (err < 0) {
 		printf("setup_physmem - mapping %ld bytes of memory at 0x%p "
-		       "failed - errno = %d\n", len - offset,
+		       "failed - errno = %d\n", map_size,
 		       (void *) uml_reserved, err);
 		exit(1);
 	}

commit 9e6a57d2cdee36a6d9c5d5cc3db85713dd416719
Author: Honggang Li <enjoymindful@gmail.com>
Date:   Tue Jun 3 13:30:45 2014 +0800

    um: delete unnecessary bootmem struct page array
    
    1) uml kernel bootmem managed through bootmem_data->node_bootmem_map,
    not the struct page array, so the array is unnecessary.
    
    2) the bootmem struct page array has been pointed by a *local* pointer,
    struct page *map, in init_maps function. The array can be accessed only
    in init_maps's scope. As a result, uml kernel wastes about 1% of total
    memory.
    
    Signed-off-by: Honggang Li <enjoymindful@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 30fdd5d0067b..549ecf3f5857 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -22,39 +22,19 @@ EXPORT_SYMBOL(high_physmem);
 
 extern unsigned long long physmem_size;
 
-int __init init_maps(unsigned long physmem, unsigned long iomem,
+void __init mem_total_pages(unsigned long physmem, unsigned long iomem,
 		     unsigned long highmem)
 {
-	struct page *p, *map;
-	unsigned long phys_len, phys_pages, highmem_len, highmem_pages;
-	unsigned long iomem_len, iomem_pages, total_len, total_pages;
-	int i;
-
-	phys_pages = physmem >> PAGE_SHIFT;
-	phys_len = phys_pages * sizeof(struct page);
-
-	iomem_pages = iomem >> PAGE_SHIFT;
-	iomem_len = iomem_pages * sizeof(struct page);
+	unsigned long phys_pages, highmem_pages;
+	unsigned long iomem_pages, total_pages;
 
+	phys_pages    = physmem >> PAGE_SHIFT;
+	iomem_pages   = iomem   >> PAGE_SHIFT;
 	highmem_pages = highmem >> PAGE_SHIFT;
-	highmem_len = highmem_pages * sizeof(struct page);
-
-	total_pages = phys_pages + iomem_pages + highmem_pages;
-	total_len = phys_len + iomem_len + highmem_len;
 
-	map = alloc_bootmem_low_pages(total_len);
-	if (map == NULL)
-		return -ENOMEM;
-
-	for (i = 0; i < total_pages; i++) {
-		p = &map[i];
-		memset(p, 0, sizeof(struct page));
-		SetPageReserved(p);
-		INIT_LIST_HEAD(&p->lru);
-	}
+	total_pages   = phys_pages + iomem_pages + highmem_pages;
 
 	max_mapnr = total_pages;
-	return 0;
 }
 
 void map_memory(unsigned long virt, unsigned long phys, unsigned long len,

commit 0565103d1adbd765ca45248d04c327c076dd1571
Author: Anton Ivanov <antivano@cisco.com>
Date:   Fri Mar 7 18:37:47 2014 +0000

    um: Memory corruption on startup
    
    The reverse case of this race (you must msync before read) is
    well known. This is the not so common one.
    
    It can be triggered only on systems which do a lot of task
    switching and only at UML startup. If you are starting 200+ UMLs
    ~ 0.5% will always die without this fix.
    
    Signed-off-by: Anton Ivanov <antivano@cisco.com>
    [rw: minor whitespace fixes]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index f116db15d402..30fdd5d0067b 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -103,6 +103,7 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	 */
 	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
 	os_write_file(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
+	os_fsync_file(physmem_fd);
 
 	bootmap_size = init_bootmem(pfn, pfn + delta);
 	free_bootmem(__pa(reserve_end) + bootmap_size,

commit 73395a0002aa9573ffc8d989587b79663847f705
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:14:10 2011 +0100

    um: distribute exports to where exported stuff is defined
    
    ksyms.c is down to the stuff defined in various USER_OBJS
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index a1a9090254c2..f116db15d402 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -3,20 +3,22 @@
  * Licensed under the GPL
  */
 
-#include "linux/bootmem.h"
-#include "linux/mm.h"
-#include "linux/pfn.h"
-#include "asm/page.h"
-#include "as-layout.h"
-#include "init.h"
-#include "kern.h"
-#include "mem_user.h"
-#include "os.h"
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/mm.h>
+#include <linux/pfn.h>
+#include <asm/page.h>
+#include <as-layout.h>
+#include <init.h>
+#include <kern.h>
+#include <mem_user.h>
+#include <os.h>
 
 static int physmem_fd = -1;
 
 /* Changed during early boot */
 unsigned long high_physmem;
+EXPORT_SYMBOL(high_physmem);
 
 extern unsigned long long physmem_size;
 
@@ -184,6 +186,7 @@ unsigned long find_iomem(char *driver, unsigned long *len_out)
 
 	return 0;
 }
+EXPORT_SYMBOL(find_iomem);
 
 static int setup_iomem(void)
 {

commit 99764fa4ceeecba8b9e0a8a5565b418a2e94f83b
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Wed Jul 23 21:28:49 2008 -0700

    UML: make several more things static
    
    - Make some variables and functions static, since they don't need to be
      global.
    
    - Remove an unused function - arch/um/kernel/time.c::sched_clock().
    
    - Clean the style a bit as complained by checkpatch.pl.
    
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: WANG Cong <wangcong@zeuux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 9757085a0220..a1a9090254c2 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -185,7 +185,7 @@ unsigned long find_iomem(char *driver, unsigned long *len_out)
 	return 0;
 }
 
-int setup_iomem(void)
+static int setup_iomem(void)
 {
 	struct iomem_region *region = iomem_regions;
 	unsigned long iomem_start = high_physmem + PAGE_SIZE;

commit 80e39311ff3d7d2267ea8d259aab8dc9d5a59d61
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:17 2008 -0800

    uml: SMP locking commentary
    
    Add some more commentary about various pieces of global data not needing
    locking.
    
    Also got rid of unmap_physmem since that is no longer used.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 9c9290005792..9757085a0220 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -164,10 +164,10 @@ __uml_setup("iomem=", parse_iomem,
  * setup_iomem, both of which run during early boot.  Afterwards, it's
  * unchanged.
  */
-struct iomem_region *iomem_regions = NULL;
+struct iomem_region *iomem_regions;
 
-/* Initialized in parse_iomem */
-int iomem_size = 0;
+/* Initialized in parse_iomem and unchanged thereafter */
+int iomem_size;
 
 unsigned long find_iomem(char *driver, unsigned long *len_out)
 {

commit 42a2b54ce8c7b9d4f418995a7950e7e2e15e52ce
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:00 2008 -0800

    uml: clean up TASK_SIZE usage
    
    Clean up the calculation and use of the usable address space size on the host.
    
    task_size is gone, replaced with TASK_SIZE, which is calculated from
    CONFIG_TOP_ADDR.  get_kmem_end and set_task_sizes_skas are also gone.
    
    host_task_size, which refers to the entire address space usable by the UML
    kernel and which may be larger than the address space usable by a UML process,
    since that has to end on a pgdir boundary, is replaced by CONFIG_TOP_ADDR.
    
    STACK_TOP is now TASK_SIZE minus the two stub pages.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index e66432f42485..9c9290005792 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -55,16 +55,6 @@ int __init init_maps(unsigned long physmem, unsigned long iomem,
 	return 0;
 }
 
-/* Changed during early boot */
-static unsigned long kmem_top = 0;
-
-unsigned long get_kmem_end(void)
-{
-	if (kmem_top == 0)
-		kmem_top = host_task_size - 1024 * 1024;
-	return kmem_top;
-}
-
 void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 		int r, int w, int x)
 {

commit 512b6fb1c14d4c34f23a3419b0789ad01914a899
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:11 2007 -0700

    uml: userspace files should call libc directly
    
    A number of files that were changed in the recent removal of tt mode
    are userspace files which call the os_* wrappers instead of calling
    libc directly.  A few other files were affected by this, through
    
    This patch makes these call glibc directly.
    
    There are also style fixes in the affected areas.
    
    os_print_error has no remaining callers, so it is deleted.
    
    There is a interface change to os_set_exec_close, eliminating a
    parameter which was always the same.  The callers are fixed as well.
    
    os_process_pc got its error path cleaned up.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 1fe86d8cf092..e66432f42485 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -99,7 +99,9 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
 			    len - offset, 1, 1, 1);
 	if (err < 0) {
-		os_print_error(err, "Mapping memory");
+		printf("setup_physmem - mapping %ld bytes of memory at 0x%p "
+		       "failed - errno = %d\n", len - offset,
+		       (void *) uml_reserved, err);
 		exit(1);
 	}
 

commit 0a7675aa204ac2470bb06f562557978b03914a71
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:05 2007 -0700

    uml: remove __u64 usage from physical memory subsystem
    
    Eliminate some uses of __u64 in the physical memory support.  It's hard to get
    a definition of __u64 in both kernel and userspace code on x86_64, so this
    changes them to unsigned long long.
    
    There are also a copyright update and formatting comment removal from the
    affected header.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index a55d221d8a4c..1fe86d8cf092 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -115,7 +115,7 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 		     len - bootmap_size - reserve);
 }
 
-int phys_mapping(unsigned long phys, __u64 *offset_out)
+int phys_mapping(unsigned long phys, unsigned long long *offset_out)
 {
 	int fd = -1;
 

commit ba180fd437156f7fd8cfb2fdd021d949eeef08d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:00 2007 -0700

    uml: style fixes pass 3
    
    Formatting changes in the files which have been changed in the course
    of folding foo_skas functions into their callers.  These include:
            copyright updates
            header file trimming
            style fixes
            adding severity to printks
    
    These changes should be entirely non-functional.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 90e89e838173..a55d221d8a4c 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -75,7 +75,7 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 	err = os_map_memory((void *) virt, fd, offset, len, r, w, x);
 	if (err) {
 		if (err == -ENOMEM)
-			printk("try increasing the host's "
+			printk(KERN_ERR "try increasing the host's "
 			       "/proc/sys/vm/max_map_count to <physical "
 			       "memory size>/4096\n");
 		panic("map_memory(0x%lx, %d, 0x%llx, %ld, %d, %d, %d) failed, "
@@ -103,7 +103,8 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 		exit(1);
 	}
 
-	/* Special kludge - This page will be mapped in to userspace processes
+	/*
+	 * Special kludge - This page will be mapped in to userspace processes
 	 * from physmem_fd, so it needs to be written out there.
 	 */
 	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
@@ -202,8 +203,8 @@ int setup_iomem(void)
 		err = os_map_memory((void *) iomem_start, region->fd, 0,
 				    region->size, 1, 1, 0);
 		if (err)
-			printk("Mapping iomem region for driver '%s' failed, "
-			       "errno = %d\n", region->driver, -err);
+			printk(KERN_ERR "Mapping iomem region for driver '%s' "
+			       "failed, errno = %d\n", region->driver, -err);
 		else {
 			region->virt = iomem_start;
 			region->phys = __pa(region->virt);

commit 77bf4400319db9d2a8af6b00c2be6faa0f3d07cb
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:58 2007 -0700

    uml: remove code made redundant by CHOOSE_MODE removal
    
    This patch makes a number of simplifications enabled by the removal of
    CHOOSE_MODE.  There were lots of functions that looked like
    
            int foo(args){
                    foo_skas(args);
            }
    
    The bodies of foo_skas are now folded into foo, and their declarations (and
    sometimes entire header files) are deleted.
    
    In addition, the union uml_pt_regs, which was a union between the tt and skas
    register formats, is now a struct, with the tt-mode arm of the union being
    removed.
    
    It turns out that usr2_handler was unused, so it is gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index f7b2f3594793..90e89e838173 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -10,7 +10,7 @@
 #include "as-layout.h"
 #include "init.h"
 #include "kern.h"
-#include "mode_kern.h"
+#include "mem_user.h"
 #include "os.h"
 
 static int physmem_fd = -1;
@@ -61,7 +61,7 @@ static unsigned long kmem_top = 0;
 unsigned long get_kmem_end(void)
 {
 	if (kmem_top == 0)
-		kmem_top = kmem_end_skas;
+		kmem_top = host_task_size - 1024 * 1024;
 	return kmem_top;
 }
 

commit 6aa802ce6acc9b1f0b34114b3f7c21c84872cc3a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:56 2007 -0700

    uml: throw out CHOOSE_MODE
    
    The next stage after removing code which depends on CONFIG_MODE_TT is removing
    the CHOOSE_MODE abstraction, which provided both compile-time and run-time
    branching to either tt-mode or skas-mode code.
    
    This patch removes choose-mode.h and all inclusions of it, and replaces all
    CHOOSE_MODE invocations with the skas branch.  This leaves a number of trivial
    functions which will be dealt with in a later patch.
    
    There are some changes in the uaccess and tls support which go somewhat beyond
    this and eliminate some of the now-redundant functions.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index fb695e48fad7..f7b2f3594793 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -61,7 +61,7 @@ static unsigned long kmem_top = 0;
 unsigned long get_kmem_end(void)
 {
 	if (kmem_top == 0)
-		kmem_top = CHOOSE_MODE(kmem_end_tt, kmem_end_skas);
+		kmem_top = kmem_end_skas;
 	return kmem_top;
 }
 

commit 6d536e4b59f77c34a0e5a414dfa934db373c85c2
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:47 2007 -0700

    uml: physmem code tidying
    
    Tidying of the UML physical memory system.  These are mostly style fixes,
    however the includes were cleaned as well.  This uncovered a need for
    mem_user.h to be included in mode_kern_skas.h.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 8aeac4d93511..fb695e48fad7 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -1,25 +1,17 @@
 /*
- * Copyright (C) 2000 - 2003 Jeff Dike (jdike@addtoit.com)
+ * Copyright (C) 2000 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
-#include "linux/mm.h"
-#include "linux/rbtree.h"
-#include "linux/slab.h"
-#include "linux/vmalloc.h"
 #include "linux/bootmem.h"
-#include "linux/module.h"
+#include "linux/mm.h"
 #include "linux/pfn.h"
-#include "asm/types.h"
-#include "asm/pgtable.h"
-#include "kern_util.h"
+#include "asm/page.h"
 #include "as-layout.h"
+#include "init.h"
+#include "kern.h"
 #include "mode_kern.h"
-#include "mem.h"
-#include "mem_user.h"
 #include "os.h"
-#include "kern.h"
-#include "init.h"
 
 static int physmem_fd = -1;
 
@@ -49,10 +41,10 @@ int __init init_maps(unsigned long physmem, unsigned long iomem,
 	total_len = phys_len + iomem_len + highmem_len;
 
 	map = alloc_bootmem_low_pages(total_len);
-	if(map == NULL)
+	if (map == NULL)
 		return -ENOMEM;
 
-	for(i = 0; i < total_pages; i++){
+	for (i = 0; i < total_pages; i++) {
 		p = &map[i];
 		memset(p, 0, sizeof(struct page));
 		SetPageReserved(p);
@@ -68,7 +60,7 @@ static unsigned long kmem_top = 0;
 
 unsigned long get_kmem_end(void)
 {
-	if(kmem_top == 0)
+	if (kmem_top == 0)
 		kmem_top = CHOOSE_MODE(kmem_end_tt, kmem_end_skas);
 	return kmem_top;
 }
@@ -81,8 +73,8 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 
 	fd = phys_mapping(phys, &offset);
 	err = os_map_memory((void *) virt, fd, offset, len, r, w, x);
-	if(err) {
-		if(err == -ENOMEM)
+	if (err) {
+		if (err == -ENOMEM)
 			printk("try increasing the host's "
 			       "/proc/sys/vm/max_map_count to <physical "
 			       "memory size>/4096\n");
@@ -106,7 +98,7 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 	offset = uml_reserved - uml_physmem;
 	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
 			    len - offset, 1, 1, 1);
-	if(err < 0){
+	if (err < 0) {
 		os_print_error(err, "Mapping memory");
 		exit(1);
 	}
@@ -126,16 +118,16 @@ int phys_mapping(unsigned long phys, __u64 *offset_out)
 {
 	int fd = -1;
 
-	if(phys < physmem_size){
+	if (phys < physmem_size) {
 		fd = physmem_fd;
 		*offset_out = phys;
 	}
-	else if(phys < __pa(end_iomem)){
+	else if (phys < __pa(end_iomem)) {
 		struct iomem_region *region = iomem_regions;
 
-		while(region != NULL){
-			if((phys >= region->phys) &&
-			   (phys < region->phys + region->size)){
+		while (region != NULL) {
+			if ((phys >= region->phys) &&
+			    (phys < region->phys + region->size)) {
 				fd = region->fd;
 				*offset_out = phys - region->phys;
 				break;
@@ -143,7 +135,7 @@ int phys_mapping(unsigned long phys, __u64 *offset_out)
 			region = region->next;
 		}
 	}
-	else if(phys < __pa(end_iomem) + highmem){
+	else if (phys < __pa(end_iomem) + highmem) {
 		fd = physmem_fd;
 		*offset_out = phys - iomem_size;
 	}
@@ -188,8 +180,8 @@ unsigned long find_iomem(char *driver, unsigned long *len_out)
 {
 	struct iomem_region *region = iomem_regions;
 
-	while(region != NULL){
-		if(!strcmp(region->driver, driver)){
+	while (region != NULL) {
+		if (!strcmp(region->driver, driver)) {
 			*len_out = region->size;
 			return region->virt;
 		}
@@ -206,10 +198,10 @@ int setup_iomem(void)
 	unsigned long iomem_start = high_physmem + PAGE_SIZE;
 	int err;
 
-	while(region != NULL){
+	while (region != NULL) {
 		err = os_map_memory((void *) iomem_start, region->fd, 0,
 				    region->size, 1, 1, 0);
-		if(err)
+		if (err)
 			printk("Mapping iomem region for driver '%s' failed, "
 			       "errno = %d\n", region->driver, -err);
 		else {

commit 5c8aaceab88ac787c0a4038b29143c954c2a45e0
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:46 2007 -0700

    uml: stop specially protecting kernel stacks
    
    Map all of physical memory as executable to avoid having to change stack
    protections during fork and exit.
    
    unprotect_stack is now called only from MODE_TT code, so it is marked as such.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 5ee7e851bbc1..8aeac4d93511 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -105,7 +105,7 @@ void __init setup_physmem(unsigned long start, unsigned long reserve_end,
 
 	offset = uml_reserved - uml_physmem;
 	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
-			    len - offset, 1, 1, 0);
+			    len - offset, 1, 1, 1);
 	if(err < 0){
 		os_print_error(err, "Mapping memory");
 		exit(1);

commit 97a1fcbb20fcbb0177567fd2dbcc6ed1bcc450ce
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 23 18:43:48 2007 -0700

    uml: more __init annotations
    
    2.6.23-rc1 turned up another batch of references from non-__init code to
    __init code.  In most cases, these were missing __init annotations.  In one
    case (os_drop_memory), the annotation was present but wrong.
    
    init_maps is __init, but for some reason was being very careful about the
    mechanism by which it allocated memory, checking whether it was OK to use
    kmalloc (at this point in the boot, it definitely isn't) and using either
    alloc_bootmem_low_pages or kmalloc/vmalloc.  So, the kmalloc/vmalloc code is
    removed.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 3ba6e4c841da..5ee7e851bbc1 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -28,7 +28,8 @@ unsigned long high_physmem;
 
 extern unsigned long long physmem_size;
 
-int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
+int __init init_maps(unsigned long physmem, unsigned long iomem,
+		     unsigned long highmem)
 {
 	struct page *p, *map;
 	unsigned long phys_len, phys_pages, highmem_len, highmem_pages;
@@ -47,13 +48,7 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 	total_pages = phys_pages + iomem_pages + highmem_pages;
 	total_len = phys_len + iomem_len + highmem_len;
 
-	if(kmalloc_ok){
-		map = kmalloc(total_len, GFP_KERNEL);
-		if(map == NULL)
-			map = vmalloc(total_len);
-	}
-	else map = alloc_bootmem_low_pages(total_len);
-
+	map = alloc_bootmem_low_pages(total_len);
 	if(map == NULL)
 		return -ENOMEM;
 
@@ -98,8 +93,8 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 
 extern int __syscall_stub_start;
 
-void setup_physmem(unsigned long start, unsigned long reserve_end,
-		   unsigned long len, unsigned long long highmem)
+void __init setup_physmem(unsigned long start, unsigned long reserve_end,
+			  unsigned long len, unsigned long long highmem)
 {
 	unsigned long reserve = reserve_end - start;
 	int pfn = PFN_UP(__pa(reserve_end));

commit 16dd07bc6404c8da0bdfeb7a5cde4e4a63991c00
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:48 2007 -0700

    uml: more page fault path trimming
    
    More trimming of the page fault path.
    
    Permissions are passed around in a single int rather than one bit per
    int.  The permission values are copied from libc so that they can be
    passed to mmap and mprotect without any further conversion.
    
    The register sets used by do_syscall_stub and copy_context_skas0 are
    initialized once, at boot time, rather than once per call.
    
    wait_stub_done checks whether it is getting the signals it expects by
    comparing the wait status to a mask containing bits for the signals of
    interest rather than comparing individually to the signal numbers.  It
    also has one check for a wait failure instead of two.  The caller is
    expected to do the initial continue of the stub.  This gets rid of an
    argument and some logic.  The fname argument is gone, as that can be
    had from a stack trace.
    
    user_signal() is collapsed into userspace() as it is basically one or
    two lines of code afterwards.
    
    The physical memory remapping stuff is gone, as it is unused.
    
    flush_tlb_page is inlined.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index df1ad3ba130c..3ba6e4c841da 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -21,229 +21,8 @@
 #include "kern.h"
 #include "init.h"
 
-struct phys_desc {
-	struct rb_node rb;
-	int fd;
-	__u64 offset;
-	void *virt;
-	unsigned long phys;
-	struct list_head list;
-};
-
-static struct rb_root phys_mappings = RB_ROOT;
-
-static struct rb_node **find_rb(void *virt)
-{
-	struct rb_node **n = &phys_mappings.rb_node;
-	struct phys_desc *d;
-
-	while(*n != NULL){
-		d = rb_entry(*n, struct phys_desc, rb);
-		if(d->virt == virt)
-			return n;
-
-		if(d->virt > virt)
-			n = &(*n)->rb_left;
-		else
-			n = &(*n)->rb_right;
-	}
-
-	return n;
-}
-
-static struct phys_desc *find_phys_mapping(void *virt)
-{
-	struct rb_node **n = find_rb(virt);
-
-	if(*n == NULL)
-		return NULL;
-
-	return rb_entry(*n, struct phys_desc, rb);
-}
-
-static void insert_phys_mapping(struct phys_desc *desc)
-{
-	struct rb_node **n = find_rb(desc->virt);
-
-	if(*n != NULL)
-		panic("Physical remapping for %p already present",
-		      desc->virt);
-
-	rb_link_node(&desc->rb, rb_parent(*n), n);
-	rb_insert_color(&desc->rb, &phys_mappings);
-}
-
-LIST_HEAD(descriptor_mappings);
-
-struct desc_mapping {
-	int fd;
-	struct list_head list;
-	struct list_head pages;
-};
-
-static struct desc_mapping *find_mapping(int fd)
-{
-	struct desc_mapping *desc;
-	struct list_head *ele;
-
-	list_for_each(ele, &descriptor_mappings){
-		desc = list_entry(ele, struct desc_mapping, list);
-		if(desc->fd == fd)
-			return desc;
-	}
-
-	return NULL;
-}
-
-static struct desc_mapping *descriptor_mapping(int fd)
-{
-	struct desc_mapping *desc;
-
-	desc = find_mapping(fd);
-	if(desc != NULL)
-		return desc;
-
-	desc = kmalloc(sizeof(*desc), GFP_ATOMIC);
-	if(desc == NULL)
-		return NULL;
-
-	*desc = ((struct desc_mapping)
-		{ .fd =		fd,
-		  .list =	LIST_HEAD_INIT(desc->list),
-		  .pages =	LIST_HEAD_INIT(desc->pages) });
-	list_add(&desc->list, &descriptor_mappings);
-
-	return desc;
-}
-
-int physmem_subst_mapping(void *virt, int fd, __u64 offset, int w)
-{
-	struct desc_mapping *fd_maps;
-	struct phys_desc *desc;
-	unsigned long phys;
-	int err;
-
-	fd_maps = descriptor_mapping(fd);
-	if(fd_maps == NULL)
-		return -ENOMEM;
-
-	phys = __pa(virt);
-	desc = find_phys_mapping(virt);
-	if(desc != NULL)
-		panic("Address 0x%p is already substituted\n", virt);
-
-	err = -ENOMEM;
-	desc = kmalloc(sizeof(*desc), GFP_ATOMIC);
-	if(desc == NULL)
-		goto out;
-
-	*desc = ((struct phys_desc)
-		{ .fd =			fd,
-		  .offset =		offset,
-		  .virt =		virt,
-		  .phys =		__pa(virt),
-		  .list = 		LIST_HEAD_INIT(desc->list) });
-	insert_phys_mapping(desc);
-
-	list_add(&desc->list, &fd_maps->pages);
-
-	virt = (void *) ((unsigned long) virt & PAGE_MASK);
-	err = os_map_memory(virt, fd, offset, PAGE_SIZE, 1, w, 0);
-	if(!err)
-		goto out;
-
-	rb_erase(&desc->rb, &phys_mappings);
-	kfree(desc);
- out:
-	return err;
-}
-
 static int physmem_fd = -1;
 
-static void remove_mapping(struct phys_desc *desc)
-{
-	void *virt = desc->virt;
-	int err;
-
-	rb_erase(&desc->rb, &phys_mappings);
-	list_del(&desc->list);
-	kfree(desc);
-
-	err = os_map_memory(virt, physmem_fd, __pa(virt), PAGE_SIZE, 1, 1, 0);
-	if(err)
-		panic("Failed to unmap block device page from physical memory, "
-		      "errno = %d", -err);
-}
-
-int physmem_remove_mapping(void *virt)
-{
-	struct phys_desc *desc;
-
-	virt = (void *) ((unsigned long) virt & PAGE_MASK);
-	desc = find_phys_mapping(virt);
-	if(desc == NULL)
-		return 0;
-
-	remove_mapping(desc);
-	return 1;
-}
-
-void physmem_forget_descriptor(int fd)
-{
-	struct desc_mapping *desc;
-	struct phys_desc *page;
-	struct list_head *ele, *next;
-	__u64 offset;
-	void *addr;
-	int err;
-
-	desc = find_mapping(fd);
-	if(desc == NULL)
-		return;
-
-	list_for_each_safe(ele, next, &desc->pages){
-		page = list_entry(ele, struct phys_desc, list);
-		offset = page->offset;
-		addr = page->virt;
-		remove_mapping(page);
-		err = os_seek_file(fd, offset);
-		if(err)
-			panic("physmem_forget_descriptor - failed to seek "
-			      "to %lld in fd %d, error = %d\n",
-			      offset, fd, -err);
-		err = os_read_file(fd, addr, PAGE_SIZE);
-		if(err < 0)
-			panic("physmem_forget_descriptor - failed to read "
-			      "from fd %d to 0x%p, error = %d\n",
-			      fd, addr, -err);
-	}
-
-	list_del(&desc->list);
-	kfree(desc);
-}
-
-EXPORT_SYMBOL(physmem_forget_descriptor);
-EXPORT_SYMBOL(physmem_remove_mapping);
-EXPORT_SYMBOL(physmem_subst_mapping);
-
-void arch_free_page(struct page *page, int order)
-{
-	void *virt;
-	int i;
-
-	for(i = 0; i < (1 << order); i++){
-		virt = __va(page_to_phys(page + i));
-		physmem_remove_mapping(virt);
-	}
-}
-
-int is_remapped(void *virt)
-{
- 	struct phys_desc *desc = find_phys_mapping(virt);
-
-	return desc != NULL;
-}
-
 /* Changed during early boot */
 unsigned long high_physmem;
 
@@ -350,14 +129,9 @@ void setup_physmem(unsigned long start, unsigned long reserve_end,
 
 int phys_mapping(unsigned long phys, __u64 *offset_out)
 {
-	struct phys_desc *desc = find_phys_mapping(__va(phys & PAGE_MASK));
 	int fd = -1;
 
-	if(desc != NULL){
-		fd = desc->fd;
-		*offset_out = desc->offset;
-	}
-	else if(phys < physmem_size){
+	if(phys < physmem_size){
 		fd = physmem_fd;
 		*offset_out = phys;
 	}

commit a6ea4cceed18edebe1eb6001cb9e0f88cd741a6c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:43 2007 -0700

    uml: rename os_{read_write}_file_k back to os_{read_write}_file
    
    Rename os_{read_write}_file_k back to os_{read_write}_file, delete
    the originals and their bogus infrastructure, and fix all the callers.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 77021a627da6..df1ad3ba130c 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -211,7 +211,7 @@ void physmem_forget_descriptor(int fd)
 			panic("physmem_forget_descriptor - failed to seek "
 			      "to %lld in fd %d, error = %d\n",
 			      offset, fd, -err);
-		err = os_read_file_k(fd, addr, PAGE_SIZE);
+		err = os_read_file(fd, addr, PAGE_SIZE);
 		if(err < 0)
 			panic("physmem_forget_descriptor - failed to read "
 			      "from fd %d to 0x%p, error = %d\n",
@@ -341,7 +341,7 @@ void setup_physmem(unsigned long start, unsigned long reserve_end,
 	 * from physmem_fd, so it needs to be written out there.
 	 */
 	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
-	os_write_file_k(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
+	os_write_file(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
 
 	bootmap_size = init_bootmem(pfn, pfn + delta);
 	free_bootmem(__pa(reserve_end) + bootmap_size,

commit fda83a99b2b49016b9d7ed562745969db25c4ef9
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:41 2007 -0700

    uml: change remaining callers of os_{read_write}_file
    
    Convert all remaining os_{read_write}_file users to use the simple
    {read,write} wrappers, os_{read_write}_file_k.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index a9856209006b..77021a627da6 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -211,7 +211,7 @@ void physmem_forget_descriptor(int fd)
 			panic("physmem_forget_descriptor - failed to seek "
 			      "to %lld in fd %d, error = %d\n",
 			      offset, fd, -err);
-		err = os_read_file(fd, addr, PAGE_SIZE);
+		err = os_read_file_k(fd, addr, PAGE_SIZE);
 		if(err < 0)
 			panic("physmem_forget_descriptor - failed to read "
 			      "from fd %d to 0x%p, error = %d\n",

commit 3d564047a5f45cb628ec72514f68076e532988f3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:32 2007 -0700

    uml: start fixing os_read_file and os_write_file
    
    This patch starts the removal of a very old, very broken piece of code.  This
    stems from the problem of passing a userspace buffer into read() or write() on
    the host.  If that buffer had not yet been faulted in, read and write will
    return -EFAULT.
    
    To avoid this problem, the solution was to fault the buffer in before the
    system call by touching the pages that hold the buffer by doing a copy-user of
    a byte to each page.  This is obviously bogus, but it does usually work, in tt
    mode, since the kernel and process are in the same address space and userspace
    addresses can be accessed directly in the kernel.
    
    In skas mode, where the kernel and process are in separate address spaces, it
    is completely bogus because the userspace address, which is invalid in the
    kernel, is passed into the system call instead of the corresponding physical
    address, which would be valid.  Here, it appears that this code, on every host
    read() or write(), tries to fault in a random process page.  This doesn't seem
    to cause any correctness problems, but there is a performance impact.  This
    patch, and the ones following, result in a 10-15% performance gain on a kernel
    build.
    
    This code can't be immediately tossed out because when it is, you can't log
    in.  Apparently, there is some code in the console driver which depends on
    this somehow.
    
    However, we can start removing it by switching the code which does I/O using
    kernel addresses to using plain read() and write().  This patch introduces
    os_read_file_k and os_write_file_k for use with kernel buffers and converts
    all call locations which use obvious kernel buffers to use them.  These
    include I/O using buffers which are local variables which are on the stack or
    kmalloc-ed.  Later patches will handle the less obvious cases, followed by a
    mass conversion back to the original interface.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index df1ad3ba130c..a9856209006b 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -341,7 +341,7 @@ void setup_physmem(unsigned long start, unsigned long reserve_end,
 	 * from physmem_fd, so it needs to be written out there.
 	 */
 	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
-	os_write_file(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
+	os_write_file_k(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
 
 	bootmap_size = init_bootmem(pfn, pfn + delta);
 	free_bootmem(__pa(reserve_end) + bootmap_size,

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index f92f06c35db7..df1ad3ba130c 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -14,7 +14,6 @@
 #include "asm/pgtable.h"
 #include "kern_util.h"
 #include "as-layout.h"
-#include "user_util.h"
 #include "mode_kern.h"
 #include "mem.h"
 #include "mem_user.h"

commit 4ff83ce1114827f707b7f1f4f2e5f69de9df94ac
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:08 2007 -0700

    uml: create as-layout.h
    
    This patch moves all the the symbols defined in um_arch.c, which are mostly
    boundaries between different parts of the UML kernel address space, to a new
    header, as-layout.h.  There are also a few things here which aren't really
    related to address space layout, but which don't really have a better place to
    go.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 638f3b5f6094..f92f06c35db7 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -13,6 +13,7 @@
 #include "asm/types.h"
 #include "asm/pgtable.h"
 #include "kern_util.h"
+#include "as-layout.h"
 #include "user_util.h"
 #include "mode_kern.h"
 #include "mem.h"

commit 60678bbc76685bea47043e61981b8fc5cffc10da
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:10 2007 -0800

    [PATCH] uml: mem.c and physmem.c formatting fixes
    
    Fix a bunch of style violations in mem.c and physmem.c
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 22d3cf359669..638f3b5f6094 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -40,7 +40,7 @@ static struct rb_node **find_rb(void *virt)
 	while(*n != NULL){
 		d = rb_entry(*n, struct phys_desc, rb);
 		if(d->virt == virt)
-			return(n);
+			return n;
 
 		if(d->virt > virt)
 			n = &(*n)->rb_left;
@@ -48,7 +48,7 @@ static struct rb_node **find_rb(void *virt)
 			n = &(*n)->rb_right;
 	}
 
-	return(n);
+	return n;
 }
 
 static struct phys_desc *find_phys_mapping(void *virt)
@@ -56,9 +56,9 @@ static struct phys_desc *find_phys_mapping(void *virt)
 	struct rb_node **n = find_rb(virt);
 
 	if(*n == NULL)
-		return(NULL);
+		return NULL;
 
-	return(rb_entry(*n, struct phys_desc, rb));
+	return rb_entry(*n, struct phys_desc, rb);
 }
 
 static void insert_phys_mapping(struct phys_desc *desc)
@@ -89,10 +89,10 @@ static struct desc_mapping *find_mapping(int fd)
 	list_for_each(ele, &descriptor_mappings){
 		desc = list_entry(ele, struct desc_mapping, list);
 		if(desc->fd == fd)
-			return(desc);
+			return desc;
 	}
 
-	return(NULL);
+	return NULL;
 }
 
 static struct desc_mapping *descriptor_mapping(int fd)
@@ -101,11 +101,11 @@ static struct desc_mapping *descriptor_mapping(int fd)
 
 	desc = find_mapping(fd);
 	if(desc != NULL)
-		return(desc);
+		return desc;
 
 	desc = kmalloc(sizeof(*desc), GFP_ATOMIC);
 	if(desc == NULL)
-		return(NULL);
+		return NULL;
 
 	*desc = ((struct desc_mapping)
 		{ .fd =		fd,
@@ -113,7 +113,7 @@ static struct desc_mapping *descriptor_mapping(int fd)
 		  .pages =	LIST_HEAD_INIT(desc->pages) });
 	list_add(&desc->list, &descriptor_mappings);
 
-	return(desc);
+	return desc;
 }
 
 int physmem_subst_mapping(void *virt, int fd, __u64 offset, int w)
@@ -125,11 +125,11 @@ int physmem_subst_mapping(void *virt, int fd, __u64 offset, int w)
 
 	fd_maps = descriptor_mapping(fd);
 	if(fd_maps == NULL)
-		return(-ENOMEM);
+		return -ENOMEM;
 
 	phys = __pa(virt);
 	desc = find_phys_mapping(virt);
-  	if(desc != NULL)
+	if(desc != NULL)
 		panic("Address 0x%p is already substituted\n", virt);
 
 	err = -ENOMEM;
@@ -155,7 +155,7 @@ int physmem_subst_mapping(void *virt, int fd, __u64 offset, int w)
 	rb_erase(&desc->rb, &phys_mappings);
 	kfree(desc);
  out:
-	return(err);
+	return err;
 }
 
 static int physmem_fd = -1;
@@ -182,10 +182,10 @@ int physmem_remove_mapping(void *virt)
 	virt = (void *) ((unsigned long) virt & PAGE_MASK);
 	desc = find_phys_mapping(virt);
 	if(desc == NULL)
-		return(0);
+		return 0;
 
 	remove_mapping(desc);
-	return(1);
+	return 1;
 }
 
 void physmem_forget_descriptor(int fd)
@@ -239,9 +239,9 @@ void arch_free_page(struct page *page, int order)
 
 int is_remapped(void *virt)
 {
-  	struct phys_desc *desc = find_phys_mapping(virt);
+ 	struct phys_desc *desc = find_phys_mapping(virt);
 
-	return(desc != NULL);
+	return desc != NULL;
 }
 
 /* Changed during early boot */
@@ -276,7 +276,7 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 	else map = alloc_bootmem_low_pages(total_len);
 
 	if(map == NULL)
-		return(-ENOMEM);
+		return -ENOMEM;
 
 	for(i = 0; i < total_pages; i++){
 		p = &map[i];
@@ -286,7 +286,7 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 	}
 
 	max_mapnr = total_pages;
-	return(0);
+	return 0;
 }
 
 /* Changed during early boot */
@@ -296,7 +296,7 @@ unsigned long get_kmem_end(void)
 {
 	if(kmem_top == 0)
 		kmem_top = CHOOSE_MODE(kmem_end_tt, kmem_end_skas);
-	return(kmem_top);
+	return kmem_top;
 }
 
 void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
@@ -379,7 +379,7 @@ int phys_mapping(unsigned long phys, __u64 *offset_out)
 		*offset_out = phys - iomem_size;
 	}
 
-	return(fd);
+	return fd;
 }
 
 static int __init uml_mem_setup(char *line, int *add)
@@ -422,13 +422,13 @@ unsigned long find_iomem(char *driver, unsigned long *len_out)
 	while(region != NULL){
 		if(!strcmp(region->driver, driver)){
 			*len_out = region->size;
-			return(region->virt);
+			return region->virt;
 		}
 
 		region = region->next;
 	}
 
-	return(0);
+	return 0;
 }
 
 int setup_iomem(void)
@@ -452,18 +452,7 @@ int setup_iomem(void)
 		region = region->next;
 	}
 
-	return(0);
+	return 0;
 }
 
 __initcall(setup_iomem);
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit 94c282d79e17a83ccc876990e05378ed6dfbccae
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:09 2007 -0800

    [PATCH] uml: locking comments in iomem driver
    
    Comment some lack of locking in the iomem driver.
    
    Also, a couple of variables are in the wrong place, so they are moved.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index abafa64b8727..22d3cf359669 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -398,6 +398,23 @@ __uml_setup("mem=", uml_mem_setup,
 "	Example: mem=64M\n\n"
 );
 
+extern int __init parse_iomem(char *str, int *add);
+
+__uml_setup("iomem=", parse_iomem,
+"iomem=<name>,<file>\n"
+"    Configure <file> as an IO memory region named <name>.\n\n"
+);
+
+/*
+ * This list is constructed in parse_iomem and addresses filled in in
+ * setup_iomem, both of which run during early boot.  Afterwards, it's
+ * unchanged.
+ */
+struct iomem_region *iomem_regions = NULL;
+
+/* Initialized in parse_iomem */
+int iomem_size = 0;
+
 unsigned long find_iomem(char *driver, unsigned long *len_out)
 {
 	struct iomem_region *region = iomem_regions;

commit 23bbd586ed7894982fd9323f63b2065afbb77773
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:06 2006 -0700

    [PATCH] uml: fix static binary segfault
    
    When UML is built as a static binary, it segfaults when run.  The reason is
    that a memory hole that is present in dynamic binaries isn't there in static
    binaries, and it contains essential stuff.
    
    This fix removes the code which maps some anonymous memory into that hole and
    cleans up some related code.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 166cb09cae4c..abafa64b8727 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -317,7 +317,7 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 	}
 }
 
-extern int __syscall_stub_start, __binary_start;
+extern int __syscall_stub_start;
 
 void setup_physmem(unsigned long start, unsigned long reserve_end,
 		   unsigned long len, unsigned long long highmem)

commit 2edc322d420a4cec8dbc184a1220ecd7fa9f8ae6
Merge: be967b7e2f77 2f3243aebd8d
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jun 20 14:51:22 2006 -0700

    Merge git://git.infradead.org/~dwmw2/rbtree-2.6
    
    * git://git.infradead.org/~dwmw2/rbtree-2.6:
      [RBTREE] Switch rb_colour() et al to en_US spelling of 'color' for consistency
      Update UML kernel/physmem.c to use rb_parent() accessor macro
      [RBTREE] Update hrtimers to use rb_parent() accessor macro.
      [RBTREE] Add explicit alignment to sizeof(long) for struct rb_node.
      [RBTREE] Merge colour and parent fields of struct rb_node.
      [RBTREE] Remove dead code in rb_erase()
      [RBTREE] Update JFFS2 to use rb_parent() accessor macro.
      [RBTREE] Update eventpoll.c to use rb_parent() accessor macro.
      [RBTREE] Update key.c to use rb_parent() accessor macro.
      [RBTREE] Update ext3 to use rb_parent() accessor macro.
      [RBTREE] Change rbtree off-tree marking in I/O schedulers.
      [RBTREE] Add accessor macros for colour and parent fields of rb_node

commit c39e50b4bada27102306d7fa68ea35dc4e61bd68
Author: Victor V. Vengerov <Victor.Vengerov@oktetlabs.ru>
Date:   Mon May 1 12:15:53 2006 -0700

    [PATCH] uml: fix iomem list traversal
    
    We need to walk the region list properly.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 0500800df1c1..fc0f0b085ca7 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -407,6 +407,8 @@ unsigned long find_iomem(char *driver, unsigned long *len_out)
 			*len_out = region->size;
 			return(region->virt);
 		}
+
+		region = region->next;
 	}
 
 	return(0);

commit aa783a8f31c79f493bd49ba926b171b79b9839fb
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon May 1 09:41:47 2006 +0100

    Update UML kernel/physmem.c to use rb_parent() accessor macro
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 0500800df1c1..73c741d37af9 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -69,7 +69,7 @@ static void insert_phys_mapping(struct phys_desc *desc)
 		panic("Physical remapping for %p already present",
 		      desc->virt);
 
-	rb_link_node(&desc->rb, (*n)->rb_parent, n);
+	rb_link_node(&desc->rb, rb_parent(*n), n);
 	rb_insert_color(&desc->rb, &phys_mappings);
 }
 

commit 22a9835c350782a5c3257343713932af3ac92ee0
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Mon Mar 27 01:16:04 2006 -0800

    [PATCH] unify PFN_* macros
    
    Just about every architecture defines some macros to do operations on pfns.
     They're all virtually identical.  This patch consolidates all of them.
    
    One minor glitch is that at least i386 uses them in a very skeletal header
    file.  To keep away from #include dependency hell, I stuck the new
    definitions in a new, isolated header.
    
    Of all of the implementations, sh64 is the only one that varied by a bit.
    It used some masks to ensure that any sign-extension got ripped away before
    the arithmetic is done.  This has been posted to that sh64 maintainers and
    the development list.
    
    Compiles on x86, x86_64, ia64 and ppc64.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 0e65340eee33..0500800df1c1 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -9,6 +9,7 @@
 #include "linux/vmalloc.h"
 #include "linux/bootmem.h"
 #include "linux/module.h"
+#include "linux/pfn.h"
 #include "asm/types.h"
 #include "asm/pgtable.h"
 #include "kern_util.h"
@@ -316,8 +317,6 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 	}
 }
 
-#define PFN_UP(x) (((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
-
 extern int __syscall_stub_start, __binary_start;
 
 void setup_physmem(unsigned long start, unsigned long reserve_end,

commit 70dc991d66cac40fdb07346dba2b5d862d732c34
Author: Nick Piggin <npiggin@suse.de>
Date:   Wed Mar 22 00:08:35 2006 -0800

    [PATCH] remove set_page_count(page, 0) users (outside mm)
    
    A couple of places set_page_count(page, 1) that don't need to.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 544665e04513..0e65340eee33 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -279,7 +279,7 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 
 	for(i = 0; i < total_pages; i++){
 		p = &map[i];
-		set_page_count(p, 0);
+		memset(p, 0, sizeof(struct page));
 		SetPageReserved(p);
 		INIT_LIST_HEAD(&p->lru);
 	}

commit 3dfd95b378953f6cf0bd58fc990c05ef5a0ea1a6
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Wed Feb 1 03:06:26 2006 -0800

    [PATCH] uml: fix "apples/bananas" typo
    
    Fix stupid typo.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index f3b583a878a6..544665e04513 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -265,7 +265,7 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 	highmem_len = highmem_pages * sizeof(struct page);
 
 	total_pages = phys_pages + iomem_pages + highmem_pages;
-	total_len = phys_len + iomem_pages + highmem_len;
+	total_len = phys_len + iomem_len + highmem_len;
 
 	if(kmalloc_ok){
 		map = kmalloc(total_len, GFP_KERNEL);

commit ae17381608a11781a6a67e0ce51607f36780aac7
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Nov 7 00:58:57 2005 -0800

    [PATCH] uml: big memory fixes
    
    A number of fixes to improve behavior when large physical memory sizes
    are specified:
    
    - libc files need -D_FILE_OFFSET_BITS=64 because there are unavoidable uses
      of non-64 interfaces in libc
    
    - some %d need to be %u
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index ea670fcc8af5..f3b583a878a6 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -246,7 +246,7 @@ int is_remapped(void *virt)
 /* Changed during early boot */
 unsigned long high_physmem;
 
-extern unsigned long physmem_size;
+extern unsigned long long physmem_size;
 
 int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 {
@@ -321,7 +321,7 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 extern int __syscall_stub_start, __binary_start;
 
 void setup_physmem(unsigned long start, unsigned long reserve_end,
-		   unsigned long len, unsigned long highmem)
+		   unsigned long len, unsigned long long highmem)
 {
 	unsigned long reserve = reserve_end - start;
 	int pfn = PFN_UP(__pa(reserve_end));

commit d99c4022f60a9aa3a8dc6b7d71f3d0998c696912
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Sat Sep 10 19:44:56 2005 +0200

    [PATCH] uml: inline mk_pte and various friends
    
    Turns out that, for UML, a *lot* of VM-related trivial functions are not
    inlined but rather normal functions.
    
    In other sections of UML code, this is justified by having files which
    interact with the host and cannot therefore include kernel headers, but in
    this case there's no such justification.
    
    I've had to turn many of them to macros because of missing declarations. While
    doing this, I've decided to reuse some already existing macros.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index a24e3b7f4bf0..ea670fcc8af5 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -248,16 +248,6 @@ unsigned long high_physmem;
 
 extern unsigned long physmem_size;
 
-void *to_virt(unsigned long phys)
-{
-	return((void *) uml_physmem + phys);
-}
-
-unsigned long to_phys(void *virt)
-{
-	return(((unsigned long) virt) - uml_physmem);
-}
-
 int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 {
 	struct page *p, *map;
@@ -298,31 +288,6 @@ int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
 	return(0);
 }
 
-struct page *phys_to_page(const unsigned long phys)
-{
-	return(&mem_map[phys >> PAGE_SHIFT]);
-}
-
-struct page *__virt_to_page(const unsigned long virt)
-{
-	return(&mem_map[__pa(virt) >> PAGE_SHIFT]);
-}
-
-phys_t page_to_phys(struct page *page)
-{
-	return((page - mem_map) << PAGE_SHIFT);
-}
-
-pte_t mk_pte(struct page *page, pgprot_t pgprot)
-{
-	pte_t pte;
-
-	pte_set_val(pte, page_to_phys(page), pgprot);
-	if(pte_present(pte))
-		pte_mknewprot(pte_mknewpage(pte));
-	return(pte);
-}
-
 /* Changed during early boot */
 static unsigned long kmem_top = 0;
 

commit d67b569f5f620c0fb95d5212642746b7ba9d29e4
Author: Jeff Dike <jdike@addtoit.com>
Date:   Thu Jul 7 17:56:49 2005 -0700

    [PATCH] uml: skas0 - separate kernel address space on stock hosts
    
    UML has had two modes of operation - an insecure, slow mode (tt mode) in
    which the kernel is mapped into every process address space which requires
    no host kernel modifications, and a secure, faster mode (skas mode) in
    which the UML kernel is in a separate host address space, which requires a
    patch to the host kernel.
    
    This patch implements something very close to skas mode for hosts which
    don't support skas - I'm calling this skas0.  It provides the security of
    the skas host patch, and some of the performance gains.
    
    The two main things that are provided by the skas patch, /proc/mm and
    PTRACE_FAULTINFO, are implemented in a way that require no host patch.
    
    For the remote address space changing stuff (mmap, munmap, and mprotect),
    we set aside two pages in the process above its stack, one of which
    contains a little bit of code which can call mmap et al.
    
    To update the address space, the system call information (system call
    number and arguments) are written to the stub page above the code.  The
    %esp is set to the beginning of the data, the %eip is set the the start of
    the stub, and it repeatedly pops the information into its registers and
    makes the system call until it sees a system call number of zero.  This is
    to amortize the cost of the context switch across multiple address space
    updates.
    
    When the updates are done, it SIGSTOPs itself, and the kernel process
    continues what it was doing.
    
    For a PTRACE_FAULTINFO replacement, we set up a SIGSEGV handler in the
    child, and let it handle segfaults rather than nullifying them.  The
    handler is in the same page as the mmap stub.  The second page is used as
    the stack.  The handler reads cr2 and err from the sigcontext, sticks them
    at the base of the stack in a faultinfo struct, and SIGSTOPs itself.  The
    kernel then reads the faultinfo and handles the fault.
    
    A complication on x86_64 is that this involves resetting the registers to
    the segfault values when the process is inside the kill system call.  This
    breaks on x86_64 because %rcx will contain %rip because you tell SYSRET
    where to return to by putting the value in %rcx.  So, this corrupts $rcx on
    return from the segfault.  To work around this, I added an
    arch_finish_segv, which on x86 does nothing, but which on x86_64 ptraces
    the child back through the sigreturn.  This causes %rcx to be restored by
    sigreturn and avoids the corruption.  Ultimately, I think I will replace
    this with the trick of having it send itself a blocked signal which will be
    unblocked by the sigreturn.  This will allow it to be stopped just after
    the sigreturn, and PTRACE_SYSCALLed without all the back-and-forth of
    PTRACE_SYSCALLing it through sigreturn.
    
    This runs on a stock host, so theoretically (and hopefully), tt mode isn't
    needed any more.  We need to make sure that this is better in every way
    than tt mode, though.  I'm concerned about the speed of address space
    updates and page fault handling, since they involve extra round-trips to
    the child.  We can amortize the round-trip cost for large address space
    updates by writing all of the operations to the data page and having the
    child execute them all at the same time.  This will help fork and exec, but
    not page faults, since they involve only one page.
    
    I can't think of any way to help page faults, except to add something like
    PTRACE_FAULTINFO to the host.  There is PTRACE_SIGINFO, but UML doesn't use
    siginfo for SIGSEGV (or anything else) because there isn't enough
    information in the siginfo struct to handle page faults (the faulting
    operation type is missing).  Adding that would make PTRACE_SIGINFO a usable
    equivalent to PTRACE_FAULTINFO.
    
    As for the code itself:
    
    - The system call stub is in arch/um/kernel/sys-$(SUBARCH)/stub.S.  It is
      put in its own section of the binary along with stub_segv_handler in
      arch/um/kernel/skas/process.c.  This is manipulated with run_syscall_stub
      in arch/um/kernel/skas/mem_user.c.  syscall_stub will execute any system
      call at all, but it's only used for mmap, munmap, and mprotect.
    
    - The x86_64 stub calls sigreturn by hand rather than allowing the normal
      sigreturn to happen, because the normal sigreturn is a SA_RESTORER in
      UML's address space provided by libc.  Needless to say, this is not
      available in the child's address space.  Also, it does a couple of odd
      pops before that which restore the stack to the state it was in at the
      time the signal handler was called.
    
    - There is a new field in the arch mmu_context, which is now a union.
      This is the pid to be manipulated rather than the /proc/mm file
      descriptor.  Code which deals with this now checks proc_mm to see whether
      it should use the usual skas code or the new code.
    
    - userspace_tramp is now used to create a new host process for every UML
      process, rather than one per UML processor.  It checks proc_mm and
      ptrace_faultinfo to decide whether to map in the pages above its stack.
    
    - start_userspace now makes CLONE_VM conditional on proc_mm since we need
      separate address spaces now.
    
    - switch_mm_skas now just sets userspace_pid[0] to the new pid rather
      than PTRACE_SWITCH_MM.  There is an addition to userspace which updates
      its idea of the pid being manipulated each time around the loop.  This is
      important on exec, when the pid will change underneath userspace().
    
    - The stub page has a pte, but it can't be mapped in using tlb_flush
      because it is part of tlb_flush.  This is why it's required for it to be
      mapped in by userspace_tramp.
    
    Other random things:
    
    - The stub section in uml.lds.S is page aligned.  This page is written
      out to the backing vm file in setup_physmem because it is mapped from
      there into user processes.
    
    - There's some confusion with TASK_SIZE now that there are a couple of
      extra pages that the process can't use.  TASK_SIZE is considered by the
      elf code to be the usable process memory, which is reasonable, so it is
      decreased by two pages.  This confuses the definition of
      USER_PGDS_IN_LAST_PML4, making it too small because of the rounding down
      of the uneven division.  So we round it to the nearest PGDIR_SIZE rather
      than the lower one.
    
    - I added a missing PT_SYSCALL_ARG6_OFFSET macro.
    
    - um_mmu.h was made into a userspace-usable file.
    
    - proc_mm and ptrace_faultinfo are globals which say whether the host
      supports these features.
    
    - There is a bad interaction between the mm.nr_ptes check at the end of
      exit_mmap, stack randomization, and skas0.  exit_mmap will stop freeing
      pages at the PGDIR_SIZE boundary after the last vma.  If the stack isn't
      on the last page table page, the last pte page won't be freed, as it
      should be since the stub ptes are there, and exit_mmap will BUG because
      there is an unfreed page.  To get around this, TASK_SIZE is set to the
      next lowest PGDIR_SIZE boundary and mm->nr_ptes is decremented after the
      calls to init_stub_pte.  This ensures that we know the process stack (and
      all other process mappings) will be below the top page table page, and
      thus we know that mm->nr_ptes will be one too many, and can be
      decremented.
    
    Things that need fixing:
    
    - We may need better assurrences that the stub code is PIC.
    
    - The stub pte is set up in init_new_context_skas.
    
    - alloc_pgdir is probably the right place.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
index 420e6d51fa0f..a24e3b7f4bf0 100644
--- a/arch/um/kernel/physmem.c
+++ b/arch/um/kernel/physmem.c
@@ -353,6 +353,8 @@ void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
 
 #define PFN_UP(x) (((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
 
+extern int __syscall_stub_start, __binary_start;
+
 void setup_physmem(unsigned long start, unsigned long reserve_end,
 		   unsigned long len, unsigned long highmem)
 {
@@ -371,6 +373,12 @@ void setup_physmem(unsigned long start, unsigned long reserve_end,
 		exit(1);
 	}
 
+	/* Special kludge - This page will be mapped in to userspace processes
+	 * from physmem_fd, so it needs to be written out there.
+	 */
+	os_seek_file(physmem_fd, __pa(&__syscall_stub_start));
+	os_write_file(physmem_fd, &__syscall_stub_start, PAGE_SIZE);
+
 	bootmap_size = init_bootmem(pfn, pfn + delta);
 	free_bootmem(__pa(reserve_end) + bootmap_size,
 		     len - bootmap_size - reserve);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/kernel/physmem.c b/arch/um/kernel/physmem.c
new file mode 100644
index 000000000000..420e6d51fa0f
--- /dev/null
+++ b/arch/um/kernel/physmem.c
@@ -0,0 +1,478 @@
+/*
+ * Copyright (C) 2000 - 2003 Jeff Dike (jdike@addtoit.com)
+ * Licensed under the GPL
+ */
+
+#include "linux/mm.h"
+#include "linux/rbtree.h"
+#include "linux/slab.h"
+#include "linux/vmalloc.h"
+#include "linux/bootmem.h"
+#include "linux/module.h"
+#include "asm/types.h"
+#include "asm/pgtable.h"
+#include "kern_util.h"
+#include "user_util.h"
+#include "mode_kern.h"
+#include "mem.h"
+#include "mem_user.h"
+#include "os.h"
+#include "kern.h"
+#include "init.h"
+
+struct phys_desc {
+	struct rb_node rb;
+	int fd;
+	__u64 offset;
+	void *virt;
+	unsigned long phys;
+	struct list_head list;
+};
+
+static struct rb_root phys_mappings = RB_ROOT;
+
+static struct rb_node **find_rb(void *virt)
+{
+	struct rb_node **n = &phys_mappings.rb_node;
+	struct phys_desc *d;
+
+	while(*n != NULL){
+		d = rb_entry(*n, struct phys_desc, rb);
+		if(d->virt == virt)
+			return(n);
+
+		if(d->virt > virt)
+			n = &(*n)->rb_left;
+		else
+			n = &(*n)->rb_right;
+	}
+
+	return(n);
+}
+
+static struct phys_desc *find_phys_mapping(void *virt)
+{
+	struct rb_node **n = find_rb(virt);
+
+	if(*n == NULL)
+		return(NULL);
+
+	return(rb_entry(*n, struct phys_desc, rb));
+}
+
+static void insert_phys_mapping(struct phys_desc *desc)
+{
+	struct rb_node **n = find_rb(desc->virt);
+
+	if(*n != NULL)
+		panic("Physical remapping for %p already present",
+		      desc->virt);
+
+	rb_link_node(&desc->rb, (*n)->rb_parent, n);
+	rb_insert_color(&desc->rb, &phys_mappings);
+}
+
+LIST_HEAD(descriptor_mappings);
+
+struct desc_mapping {
+	int fd;
+	struct list_head list;
+	struct list_head pages;
+};
+
+static struct desc_mapping *find_mapping(int fd)
+{
+	struct desc_mapping *desc;
+	struct list_head *ele;
+
+	list_for_each(ele, &descriptor_mappings){
+		desc = list_entry(ele, struct desc_mapping, list);
+		if(desc->fd == fd)
+			return(desc);
+	}
+
+	return(NULL);
+}
+
+static struct desc_mapping *descriptor_mapping(int fd)
+{
+	struct desc_mapping *desc;
+
+	desc = find_mapping(fd);
+	if(desc != NULL)
+		return(desc);
+
+	desc = kmalloc(sizeof(*desc), GFP_ATOMIC);
+	if(desc == NULL)
+		return(NULL);
+
+	*desc = ((struct desc_mapping)
+		{ .fd =		fd,
+		  .list =	LIST_HEAD_INIT(desc->list),
+		  .pages =	LIST_HEAD_INIT(desc->pages) });
+	list_add(&desc->list, &descriptor_mappings);
+
+	return(desc);
+}
+
+int physmem_subst_mapping(void *virt, int fd, __u64 offset, int w)
+{
+	struct desc_mapping *fd_maps;
+	struct phys_desc *desc;
+	unsigned long phys;
+	int err;
+
+	fd_maps = descriptor_mapping(fd);
+	if(fd_maps == NULL)
+		return(-ENOMEM);
+
+	phys = __pa(virt);
+	desc = find_phys_mapping(virt);
+  	if(desc != NULL)
+		panic("Address 0x%p is already substituted\n", virt);
+
+	err = -ENOMEM;
+	desc = kmalloc(sizeof(*desc), GFP_ATOMIC);
+	if(desc == NULL)
+		goto out;
+
+	*desc = ((struct phys_desc)
+		{ .fd =			fd,
+		  .offset =		offset,
+		  .virt =		virt,
+		  .phys =		__pa(virt),
+		  .list = 		LIST_HEAD_INIT(desc->list) });
+	insert_phys_mapping(desc);
+
+	list_add(&desc->list, &fd_maps->pages);
+
+	virt = (void *) ((unsigned long) virt & PAGE_MASK);
+	err = os_map_memory(virt, fd, offset, PAGE_SIZE, 1, w, 0);
+	if(!err)
+		goto out;
+
+	rb_erase(&desc->rb, &phys_mappings);
+	kfree(desc);
+ out:
+	return(err);
+}
+
+static int physmem_fd = -1;
+
+static void remove_mapping(struct phys_desc *desc)
+{
+	void *virt = desc->virt;
+	int err;
+
+	rb_erase(&desc->rb, &phys_mappings);
+	list_del(&desc->list);
+	kfree(desc);
+
+	err = os_map_memory(virt, physmem_fd, __pa(virt), PAGE_SIZE, 1, 1, 0);
+	if(err)
+		panic("Failed to unmap block device page from physical memory, "
+		      "errno = %d", -err);
+}
+
+int physmem_remove_mapping(void *virt)
+{
+	struct phys_desc *desc;
+
+	virt = (void *) ((unsigned long) virt & PAGE_MASK);
+	desc = find_phys_mapping(virt);
+	if(desc == NULL)
+		return(0);
+
+	remove_mapping(desc);
+	return(1);
+}
+
+void physmem_forget_descriptor(int fd)
+{
+	struct desc_mapping *desc;
+	struct phys_desc *page;
+	struct list_head *ele, *next;
+	__u64 offset;
+	void *addr;
+	int err;
+
+	desc = find_mapping(fd);
+	if(desc == NULL)
+		return;
+
+	list_for_each_safe(ele, next, &desc->pages){
+		page = list_entry(ele, struct phys_desc, list);
+		offset = page->offset;
+		addr = page->virt;
+		remove_mapping(page);
+		err = os_seek_file(fd, offset);
+		if(err)
+			panic("physmem_forget_descriptor - failed to seek "
+			      "to %lld in fd %d, error = %d\n",
+			      offset, fd, -err);
+		err = os_read_file(fd, addr, PAGE_SIZE);
+		if(err < 0)
+			panic("physmem_forget_descriptor - failed to read "
+			      "from fd %d to 0x%p, error = %d\n",
+			      fd, addr, -err);
+	}
+
+	list_del(&desc->list);
+	kfree(desc);
+}
+
+EXPORT_SYMBOL(physmem_forget_descriptor);
+EXPORT_SYMBOL(physmem_remove_mapping);
+EXPORT_SYMBOL(physmem_subst_mapping);
+
+void arch_free_page(struct page *page, int order)
+{
+	void *virt;
+	int i;
+
+	for(i = 0; i < (1 << order); i++){
+		virt = __va(page_to_phys(page + i));
+		physmem_remove_mapping(virt);
+	}
+}
+
+int is_remapped(void *virt)
+{
+  	struct phys_desc *desc = find_phys_mapping(virt);
+
+	return(desc != NULL);
+}
+
+/* Changed during early boot */
+unsigned long high_physmem;
+
+extern unsigned long physmem_size;
+
+void *to_virt(unsigned long phys)
+{
+	return((void *) uml_physmem + phys);
+}
+
+unsigned long to_phys(void *virt)
+{
+	return(((unsigned long) virt) - uml_physmem);
+}
+
+int init_maps(unsigned long physmem, unsigned long iomem, unsigned long highmem)
+{
+	struct page *p, *map;
+	unsigned long phys_len, phys_pages, highmem_len, highmem_pages;
+	unsigned long iomem_len, iomem_pages, total_len, total_pages;
+	int i;
+
+	phys_pages = physmem >> PAGE_SHIFT;
+	phys_len = phys_pages * sizeof(struct page);
+
+	iomem_pages = iomem >> PAGE_SHIFT;
+	iomem_len = iomem_pages * sizeof(struct page);
+
+	highmem_pages = highmem >> PAGE_SHIFT;
+	highmem_len = highmem_pages * sizeof(struct page);
+
+	total_pages = phys_pages + iomem_pages + highmem_pages;
+	total_len = phys_len + iomem_pages + highmem_len;
+
+	if(kmalloc_ok){
+		map = kmalloc(total_len, GFP_KERNEL);
+		if(map == NULL)
+			map = vmalloc(total_len);
+	}
+	else map = alloc_bootmem_low_pages(total_len);
+
+	if(map == NULL)
+		return(-ENOMEM);
+
+	for(i = 0; i < total_pages; i++){
+		p = &map[i];
+		set_page_count(p, 0);
+		SetPageReserved(p);
+		INIT_LIST_HEAD(&p->lru);
+	}
+
+	max_mapnr = total_pages;
+	return(0);
+}
+
+struct page *phys_to_page(const unsigned long phys)
+{
+	return(&mem_map[phys >> PAGE_SHIFT]);
+}
+
+struct page *__virt_to_page(const unsigned long virt)
+{
+	return(&mem_map[__pa(virt) >> PAGE_SHIFT]);
+}
+
+phys_t page_to_phys(struct page *page)
+{
+	return((page - mem_map) << PAGE_SHIFT);
+}
+
+pte_t mk_pte(struct page *page, pgprot_t pgprot)
+{
+	pte_t pte;
+
+	pte_set_val(pte, page_to_phys(page), pgprot);
+	if(pte_present(pte))
+		pte_mknewprot(pte_mknewpage(pte));
+	return(pte);
+}
+
+/* Changed during early boot */
+static unsigned long kmem_top = 0;
+
+unsigned long get_kmem_end(void)
+{
+	if(kmem_top == 0)
+		kmem_top = CHOOSE_MODE(kmem_end_tt, kmem_end_skas);
+	return(kmem_top);
+}
+
+void map_memory(unsigned long virt, unsigned long phys, unsigned long len,
+		int r, int w, int x)
+{
+	__u64 offset;
+	int fd, err;
+
+	fd = phys_mapping(phys, &offset);
+	err = os_map_memory((void *) virt, fd, offset, len, r, w, x);
+	if(err) {
+		if(err == -ENOMEM)
+			printk("try increasing the host's "
+			       "/proc/sys/vm/max_map_count to <physical "
+			       "memory size>/4096\n");
+		panic("map_memory(0x%lx, %d, 0x%llx, %ld, %d, %d, %d) failed, "
+		      "err = %d\n", virt, fd, offset, len, r, w, x, err);
+	}
+}
+
+#define PFN_UP(x) (((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
+
+void setup_physmem(unsigned long start, unsigned long reserve_end,
+		   unsigned long len, unsigned long highmem)
+{
+	unsigned long reserve = reserve_end - start;
+	int pfn = PFN_UP(__pa(reserve_end));
+	int delta = (len - reserve) >> PAGE_SHIFT;
+	int err, offset, bootmap_size;
+
+	physmem_fd = create_mem_file(len + highmem);
+
+	offset = uml_reserved - uml_physmem;
+	err = os_map_memory((void *) uml_reserved, physmem_fd, offset,
+			    len - offset, 1, 1, 0);
+	if(err < 0){
+		os_print_error(err, "Mapping memory");
+		exit(1);
+	}
+
+	bootmap_size = init_bootmem(pfn, pfn + delta);
+	free_bootmem(__pa(reserve_end) + bootmap_size,
+		     len - bootmap_size - reserve);
+}
+
+int phys_mapping(unsigned long phys, __u64 *offset_out)
+{
+	struct phys_desc *desc = find_phys_mapping(__va(phys & PAGE_MASK));
+	int fd = -1;
+
+	if(desc != NULL){
+		fd = desc->fd;
+		*offset_out = desc->offset;
+	}
+	else if(phys < physmem_size){
+		fd = physmem_fd;
+		*offset_out = phys;
+	}
+	else if(phys < __pa(end_iomem)){
+		struct iomem_region *region = iomem_regions;
+
+		while(region != NULL){
+			if((phys >= region->phys) &&
+			   (phys < region->phys + region->size)){
+				fd = region->fd;
+				*offset_out = phys - region->phys;
+				break;
+			}
+			region = region->next;
+		}
+	}
+	else if(phys < __pa(end_iomem) + highmem){
+		fd = physmem_fd;
+		*offset_out = phys - iomem_size;
+	}
+
+	return(fd);
+}
+
+static int __init uml_mem_setup(char *line, int *add)
+{
+	char *retptr;
+	physmem_size = memparse(line,&retptr);
+	return 0;
+}
+__uml_setup("mem=", uml_mem_setup,
+"mem=<Amount of desired ram>\n"
+"    This controls how much \"physical\" memory the kernel allocates\n"
+"    for the system. The size is specified as a number followed by\n"
+"    one of 'k', 'K', 'm', 'M', which have the obvious meanings.\n"
+"    This is not related to the amount of memory in the host.  It can\n"
+"    be more, and the excess, if it's ever used, will just be swapped out.\n"
+"	Example: mem=64M\n\n"
+);
+
+unsigned long find_iomem(char *driver, unsigned long *len_out)
+{
+	struct iomem_region *region = iomem_regions;
+
+	while(region != NULL){
+		if(!strcmp(region->driver, driver)){
+			*len_out = region->size;
+			return(region->virt);
+		}
+	}
+
+	return(0);
+}
+
+int setup_iomem(void)
+{
+	struct iomem_region *region = iomem_regions;
+	unsigned long iomem_start = high_physmem + PAGE_SIZE;
+	int err;
+
+	while(region != NULL){
+		err = os_map_memory((void *) iomem_start, region->fd, 0,
+				    region->size, 1, 1, 0);
+		if(err)
+			printk("Mapping iomem region for driver '%s' failed, "
+			       "errno = %d\n", region->driver, -err);
+		else {
+			region->virt = iomem_start;
+			region->phys = __pa(region->virt);
+		}
+
+		iomem_start += region->size + PAGE_SIZE;
+		region = region->next;
+	}
+
+	return(0);
+}
+
+__initcall(setup_iomem);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
