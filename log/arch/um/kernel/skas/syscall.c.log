commit e6da5df0eefc0ff5c48aba29157d738888b214e1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 15 09:51:52 2020 +0200

    um: syscall.c: include <asm/unistd.h>
    
    Without CONFIG_SECCOMP, we don't get this include recursively
    through the existing includes, thus failing the build on not
    having __NR_syscall_max defined. Add the necessary include to
    fix this.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-By: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 0a12d5a09217..3d91f89fd852 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -11,6 +11,7 @@
 #include <sysdep/ptrace_user.h>
 #include <sysdep/syscalls.h>
 #include <linux/time-internal.h>
+#include <asm/unistd.h>
 
 void handle_syscall(struct uml_pt_regs *r)
 {

commit 88ce642492339f49a0b391af40e5798c08948e49
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 13 14:26:47 2020 +0100

    um: Implement time-travel=ext
    
    This implements synchronized time-travel mode which - using a special
    application on a unix socket - lets multiple machines take part in a
    time-travelling simulation together.
    
    The protocol for the unix domain socket is defined in the new file
    include/uapi/linux/um_timetravel.h.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 2e82820f7d29..0a12d5a09217 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -24,7 +24,8 @@ void handle_syscall(struct uml_pt_regs *r)
 	 * went to sleep, even if said userspace interacts with the kernel in
 	 * various ways.
 	 */
-	if (time_travel_mode == TT_MODE_INFCPU)
+	if (time_travel_mode == TT_MODE_INFCPU ||
+	    time_travel_mode == TT_MODE_EXTERNAL)
 		schedule();
 
 	/* Initialize the syscall number and default return value. */

commit f185063bff914e589b50f1b711fc42218c4790c6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 13 14:26:44 2020 +0100

    um: Move timer-internal.h to non-shared
    
    This file isn't really shared, it's only used on the kernel side,
    not on the user side. Remove the include from the user-side and
    move the file to a better place.
    
    While at it, rename it to time-internal.h, it's not really just
    timers but all kinds of things related to timekeeping.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 40d90dddf3f1..2e82820f7d29 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -10,7 +10,7 @@
 #include <sysdep/ptrace.h>
 #include <sysdep/ptrace_user.h>
 #include <sysdep/syscalls.h>
-#include <shared/timer-internal.h>
+#include <linux/time-internal.h>
 
 void handle_syscall(struct uml_pt_regs *r)
 {

commit fefad9ef58ffc228f7b78b667c2aea8267503350
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Tue Sep 24 08:44:20 2019 +0200

    seccomp: simplify secure_computing()
    
    Afaict, the struct seccomp_data argument to secure_computing() is unused
    by all current callers. So let's remove it.
    The argument was added in [1]. It was added because having the arch
    supply the syscall arguments used to be faster than having it done by
    secure_computing() (cf. Andy's comment in [2]). This is not true anymore
    though.
    
    /* References */
    [1]: 2f275de5d1ed ("seccomp: Add a seccomp_data parameter secure_computing()")
    [2]: https://lore.kernel.org/r/CALCETrU_fs_At-hTpr231kpaAd0z7xJN4ku-DvzhRU6cvcJA_w@mail.gmail.com
    
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: x86@kernel.org
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20190924064420.6353-1-christian.brauner@ubuntu.com
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index f574b1856bc6..40d90dddf3f1 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -35,7 +35,7 @@ void handle_syscall(struct uml_pt_regs *r)
 		goto out;
 
 	/* Do the seccomp check after ptrace; failures should be fast. */
-	if (secure_computing(NULL) == -1)
+	if (secure_computing() == -1)
 		goto out;
 
 	syscall = UPT_SYSCALL_NR(r);

commit 0d1fb0a47c09b21d82c680476da26035f402660a
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:17 2019 +0100

    um: Add SPDX headers to files in arch/um/kernel/
    
    Convert files to use SPDX header. All files are licensed under the
    GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 44bb10785075..f574b1856bc6 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <linux/kernel.h>

commit 065038706f77a56754e8f0c2556dab7e22dfe577
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon May 27 10:34:27 2019 +0200

    um: Support time travel mode
    
    Sometimes it can be useful to run with "time travel" inside the
    UML instance, for example for testing. For example, some tests
    for the wireless subsystem and userspace are based on hwsim, a
    virtual wireless adapter. Some tests can take a long time to
    run because they e.g. wait for 120 seconds to elapse for some
    regulatory checks. This obviously goes faster if it need not
    actually wait that long, but time inside the test environment
    just "bumps up" when there's nothing to do.
    
    Add CONFIG_UML_TIME_TRAVEL_SUPPORT to enable code to support
    such modes at runtime, selected on the command line:
     * just "time-travel", in which time inside the UML instance
       can move faster than real time, if there's nothing to do
     * "time-travel=inf-cpu" in which time also moves slower and
       any CPU processing takes no time at all, which allows to
       implement consistent behaviour regardless of host CPU load
       (or speed) or debug overhead.
    
    An additional "time-travel-start=<seconds>" parameter is also
    supported in this case to start the wall clock at this time
    (in unix epoch).
    
    With this enabled, the test mentioned above goes from a runtime
    of about 140 seconds (with startup overhead and all) to being
    CPU bound and finishing in 15 seconds (on my slow laptop).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index b783ac87d98a..44bb10785075 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -10,12 +10,23 @@
 #include <sysdep/ptrace.h>
 #include <sysdep/ptrace_user.h>
 #include <sysdep/syscalls.h>
+#include <shared/timer-internal.h>
 
 void handle_syscall(struct uml_pt_regs *r)
 {
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
 	int syscall;
 
+	/*
+	 * If we have infinite CPU resources, then make every syscall also a
+	 * preemption point, since we don't have any other preemption in this
+	 * case, and kernel threads would basically never run until userspace
+	 * went to sleep, even if said userspace interacts with the kernel in
+	 * various ways.
+	 */
+	if (time_travel_mode == TT_MODE_INFCPU)
+		schedule();
+
 	/* Initialize the syscall number and default return value. */
 	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
 	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);

commit ce29856a5e1aabe52e18b2c60db1490769a6ab55
Author: Mickaël Salaün <mic@digikod.net>
Date:   Mon Aug 1 23:01:56 2016 +0200

    um/ptrace: Fix the syscall number update after a ptrace
    
    Update the syscall number after each PTRACE_SETREGS on ORIG_*AX.
    
    This is needed to get the potentially altered syscall number in the
    seccomp filters after RET_TRACE.
    
    This fix four seccomp_bpf tests:
    > [ RUN      ] TRACE_syscall.skip_after_RET_TRACE
    > seccomp_bpf.c:1560:TRACE_syscall.skip_after_RET_TRACE:Expected -1 (18446744073709551615) == syscall(39) (26)
    > seccomp_bpf.c:1561:TRACE_syscall.skip_after_RET_TRACE:Expected 1 (1) == (*__errno_location ()) (22)
    > [     FAIL ] TRACE_syscall.skip_after_RET_TRACE
    > [ RUN      ] TRACE_syscall.kill_after_RET_TRACE
    > TRACE_syscall.kill_after_RET_TRACE: Test exited normally instead of by signal (code: 1)
    > [     FAIL ] TRACE_syscall.kill_after_RET_TRACE
    > [ RUN      ] TRACE_syscall.skip_after_ptrace
    > seccomp_bpf.c:1622:TRACE_syscall.skip_after_ptrace:Expected -1 (18446744073709551615) == syscall(39) (26)
    > seccomp_bpf.c:1623:TRACE_syscall.skip_after_ptrace:Expected 1 (1) == (*__errno_location ()) (22)
    > [     FAIL ] TRACE_syscall.skip_after_ptrace
    > [ RUN      ] TRACE_syscall.kill_after_ptrace
    > TRACE_syscall.kill_after_ptrace: Test exited normally instead of by signal (code: 1)
    > [     FAIL ] TRACE_syscall.kill_after_ptrace
    
    Fixes: 26703c636c1f ("um/ptrace: run seccomp after ptrace")
    
    Signed-off-by: Mickaël Salaün <mic@digikod.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: James Morris <jmorris@namei.org>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Signed-off-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 0728fee94398..b783ac87d98a 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -27,12 +27,7 @@ void handle_syscall(struct uml_pt_regs *r)
 	if (secure_computing(NULL) == -1)
 		goto out;
 
-	/* Update the syscall number after orig_ax has potentially been updated
-	 * with ptrace.
-	 */
-	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
 	syscall = UPT_SYSCALL_NR(r);
-
 	if (syscall >= 0 && syscall <= __NR_syscall_max)
 		PT_REGS_SET_SYSCALL_RETURN(regs,
 				EXECUTE_SYSCALL(syscall, regs));

commit 972939e28592ec61e2e8334786152be2c80de677
Author: Mickaël Salaün <mic@digikod.net>
Date:   Mon Aug 1 23:01:55 2016 +0200

    um/ptrace: Fix the syscall_trace_leave call
    
    Keep the same semantic as before the commit 26703c636c1f: deallocate
    audit context and fake a proper syscall exit.
    
    This fix a kernel panic triggered by the seccomp_bpf test:
    > [ RUN      ] global.ERRNO_valid
    > BUG: failure at kernel/auditsc.c:1504/__audit_syscall_entry()!
    > Kernel panic - not syncing: BUG!
    
    Fixes: 26703c636c1f ("um/ptrace: run seccomp after ptrace")
    
    Signed-off-by: Mickaël Salaün <mic@digikod.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: James Morris <jmorris@namei.org>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Signed-off-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index ef4b8f949b51..0728fee94398 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -21,11 +21,11 @@ void handle_syscall(struct uml_pt_regs *r)
 	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);
 
 	if (syscall_trace_enter(regs))
-		return;
+		goto out;
 
 	/* Do the seccomp check after ptrace; failures should be fast. */
 	if (secure_computing(NULL) == -1)
-		return;
+		goto out;
 
 	/* Update the syscall number after orig_ax has potentially been updated
 	 * with ptrace.
@@ -37,5 +37,6 @@ void handle_syscall(struct uml_pt_regs *r)
 		PT_REGS_SET_SYSCALL_RETURN(regs,
 				EXECUTE_SYSCALL(syscall, regs));
 
+out:
 	syscall_trace_leave(regs);
 }

commit 26703c636c1f3272b39bd0f6d04d2e970984f1b6
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jun 2 19:59:42 2016 -0700

    um/ptrace: run seccomp after ptrace
    
    Close the hole where ptrace can change a syscall out from under seccomp.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: user-mode-linux-devel@lists.sourceforge.net

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 9c5570f0f397..ef4b8f949b51 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -20,12 +20,12 @@ void handle_syscall(struct uml_pt_regs *r)
 	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
 	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);
 
-	/* Do the secure computing check first; failures should be fast. */
-	if (secure_computing(NULL) == -1)
+	if (syscall_trace_enter(regs))
 		return;
 
-	if (syscall_trace_enter(regs))
-		goto out;
+	/* Do the seccomp check after ptrace; failures should be fast. */
+	if (secure_computing(NULL) == -1)
+		return;
 
 	/* Update the syscall number after orig_ax has potentially been updated
 	 * with ptrace.
@@ -37,6 +37,5 @@ void handle_syscall(struct uml_pt_regs *r)
 		PT_REGS_SET_SYSCALL_RETURN(regs,
 				EXECUTE_SYSCALL(syscall, regs));
 
-out:
 	syscall_trace_leave(regs);
 }

commit 2f275de5d1ed7269913ef9b4c64a13952c0a38e8
Author: Andy Lutomirski <luto@kernel.org>
Date:   Fri May 27 12:57:02 2016 -0700

    seccomp: Add a seccomp_data parameter secure_computing()
    
    Currently, if arch code wants to supply seccomp_data directly to
    seccomp (which is generally much faster than having seccomp do it
    using the syscall_get_xyz() API), it has to use the two-phase
    seccomp hooks. Add it to the easy hooks, too.
    
    Cc: linux-arch@vger.kernel.org
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 48b0dcbd87be..9c5570f0f397 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -21,7 +21,7 @@ void handle_syscall(struct uml_pt_regs *r)
 	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);
 
 	/* Do the secure computing check first; failures should be fast. */
-	if (secure_computing() == -1)
+	if (secure_computing(NULL) == -1)
 		return;
 
 	if (syscall_trace_enter(regs))

commit c50b4659e444b020657e01bdf769c965e5597cb0
Author: Mickaël Salaün <mic@digikod.net>
Date:   Tue Dec 29 21:35:47 2015 +0100

    um: Add seccomp support
    
    This brings SECCOMP_MODE_STRICT and SECCOMP_MODE_FILTER support through
    prctl(2) and seccomp(2) to User-mode Linux for i386 and x86_64
    subarchitectures.
    
    secure_computing() is called first in handle_syscall() so that the
    syscall emulation will be aborted quickly if matching a seccomp rule.
    
    This is inspired from Meredydd Luff's patch
    (https://gerrit.chromium.org/gerrit/21425).
    
    Signed-off-by: Mickaël Salaün <mic@digikod.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Meredydd Luff <meredydd@senatehouse.org>
    Cc: David Drysdale <drysdale@google.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Acked-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 6cadce761bcf..48b0dcbd87be 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -5,6 +5,7 @@
 
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
+#include <linux/seccomp.h>
 #include <kern_util.h>
 #include <sysdep/ptrace.h>
 #include <sysdep/ptrace_user.h>
@@ -19,6 +20,10 @@ void handle_syscall(struct uml_pt_regs *r)
 	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
 	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);
 
+	/* Do the secure computing check first; failures should be fast. */
+	if (secure_computing() == -1)
+		return;
+
 	if (syscall_trace_enter(regs))
 		goto out;
 

commit e04c989eb785af61d2895d76d38c09166296f9c5
Author: Mickaël Salaün <mic@digikod.net>
Date:   Tue Dec 29 21:35:44 2015 +0100

    um: Fix ptrace GETREGS/SETREGS bugs
    
    This fix two related bugs:
    * PTRACE_GETREGS doesn't get the right orig_ax (syscall) value
    * PTRACE_SETREGS can't set the orig_ax value (erased by initial value)
    
    Get rid of the now useless and error-prone get_syscall().
    
    Fix inconsistent behavior in the ptrace implementation for i386 when
    updating orig_eax automatically update the syscall number as well. This
    is now updated in handle_syscall().
    
    Signed-off-by: Mickaël Salaün <mic@digikod.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Thomas Meyer <thomas@m3y3r.de>
    Cc: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Cc: Anton Ivanov <aivanov@brocade.com>
    Cc: Meredydd Luff <meredydd@senatehouse.org>
    Cc: David Drysdale <drysdale@google.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Acked-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 1683b8efdfda..6cadce761bcf 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -7,29 +7,31 @@
 #include <linux/ptrace.h>
 #include <kern_util.h>
 #include <sysdep/ptrace.h>
+#include <sysdep/ptrace_user.h>
 #include <sysdep/syscalls.h>
-#include <os.h>
 
 void handle_syscall(struct uml_pt_regs *r)
 {
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
-	long result;
 	int syscall;
 
-	if (syscall_trace_enter(regs)) {
-		result = -ENOSYS;
+	/* Initialize the syscall number and default return value. */
+	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
+	PT_REGS_SET_SYSCALL_RETURN(regs, -ENOSYS);
+
+	if (syscall_trace_enter(regs))
 		goto out;
-	}
 
-	syscall = get_syscall(r);
+	/* Update the syscall number after orig_ax has potentially been updated
+	 * with ptrace.
+	 */
+	UPT_SYSCALL_NR(r) = PT_SYSCALL_NR(r->gp);
+	syscall = UPT_SYSCALL_NR(r);
 
-	if ((syscall > __NR_syscall_max) || syscall < 0)
-		result = -ENOSYS;
-	else
-		result = EXECUTE_SYSCALL(syscall, regs);
+	if (syscall >= 0 && syscall <= __NR_syscall_max)
+		PT_REGS_SET_SYSCALL_RETURN(regs,
+				EXECUTE_SYSCALL(syscall, regs));
 
 out:
-	PT_REGS_SET_SYSCALL_RETURN(regs, result);
-
 	syscall_trace_leave(regs);
 }

commit f10e6d652bc2dad67b5e7b6e6d890c76f739ed77
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Oct 25 20:28:14 2015 +0100

    um: Get rid of open coded NR_SYSCALLS
    
    We can use __NR_syscall_max.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 64a8fe589d6f..1683b8efdfda 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -10,9 +10,6 @@
 #include <sysdep/syscalls.h>
 #include <os.h>
 
-extern int syscall_table_size;
-#define NR_SYSCALLS (syscall_table_size / sizeof(void *))
-
 void handle_syscall(struct uml_pt_regs *r)
 {
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
@@ -26,9 +23,10 @@ void handle_syscall(struct uml_pt_regs *r)
 
 	syscall = get_syscall(r);
 
-	if ((syscall >= NR_SYSCALLS) || (syscall < 0))
+	if ((syscall > __NR_syscall_max) || syscall < 0)
 		result = -ENOSYS;
-	else result = EXECUTE_SYSCALL(syscall, regs);
+	else
+		result = EXECUTE_SYSCALL(syscall, regs);
 
 out:
 	PT_REGS_SET_SYSCALL_RETURN(regs, result);

commit 1d80f0cda10118d7505bd0a09a5c1c72f3a5f6c8
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Oct 25 19:54:33 2015 +0100

    um: Store syscall number after syscall_trace_enter()
    
    To support changing syscall numbers we have to store
    it after syscall_trace_enter().
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index d9ec0068b623..64a8fe589d6f 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -8,6 +8,7 @@
 #include <kern_util.h>
 #include <sysdep/ptrace.h>
 #include <sysdep/syscalls.h>
+#include <os.h>
 
 extern int syscall_table_size;
 #define NR_SYSCALLS (syscall_table_size / sizeof(void *))
@@ -23,16 +24,8 @@ void handle_syscall(struct uml_pt_regs *r)
 		goto out;
 	}
 
-	/*
-	 * This should go in the declaration of syscall, but when I do that,
-	 * strace -f -c bash -c 'ls ; ls' breaks, sometimes not tracing
-	 * children at all, sometimes hanging when bash doesn't see the first
-	 * ls exit.
-	 * The assembly looks functionally the same to me.  This is
-	 *     gcc version 4.0.1 20050727 (Red Hat 4.0.1-5)
-	 * in case it's a compiler bug.
-	 */
-	syscall = UPT_SYSCALL_NR(r);
+	syscall = get_syscall(r);
+
 	if ((syscall >= NR_SYSCALLS) || (syscall < 0))
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);

commit 5334cdae407a5778a297a98a75ca61140e37ebfa
Author: Richard Weinberger <richard@nod.at>
Date:   Sun May 31 22:59:03 2015 +0200

    um: Handle tracehook_report_syscall_entry() result
    
    tracehook_report_syscall_entry() is allowed to fail,
    in case of failure we have to abort the current syscall.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index c0681e097432..d9ec0068b623 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -18,7 +18,10 @@ void handle_syscall(struct uml_pt_regs *r)
 	long result;
 	int syscall;
 
-	syscall_trace_enter(regs);
+	if (syscall_trace_enter(regs)) {
+		result = -ENOSYS;
+		goto out;
+	}
 
 	/*
 	 * This should go in the declaration of syscall, but when I do that,
@@ -34,6 +37,7 @@ void handle_syscall(struct uml_pt_regs *r)
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 
+out:
 	PT_REGS_SET_SYSCALL_RETURN(regs, result);
 
 	syscall_trace_leave(regs);

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 86368a025a96..c0681e097432 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -3,11 +3,11 @@
  * Licensed under the GPL
  */
 
-#include "linux/kernel.h"
-#include "linux/ptrace.h"
-#include "kern_util.h"
-#include "sysdep/ptrace.h"
-#include "sysdep/syscalls.h"
+#include <linux/kernel.h>
+#include <linux/ptrace.h>
+#include <kern_util.h>
+#include <sysdep/ptrace.h>
+#include <sysdep/syscalls.h>
 
 extern int syscall_table_size;
 #define NR_SYSCALLS (syscall_table_size / sizeof(void *))

commit 1bfa2317b21750f739b59ab6df2c8efb12875045
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 23 00:18:33 2012 -0400

    um: split syscall_trace(), pass pt_regs to it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    [richard@nod.at: Fixed some minor build issues]
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 800551a29dbf..86368a025a96 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -18,7 +18,7 @@ void handle_syscall(struct uml_pt_regs *r)
 	long result;
 	int syscall;
 
-	syscall_trace(r, 0);
+	syscall_trace_enter(regs);
 
 	/*
 	 * This should go in the declaration of syscall, but when I do that,
@@ -36,5 +36,5 @@ void handle_syscall(struct uml_pt_regs *r)
 
 	PT_REGS_SET_SYSCALL_RETURN(regs, result);
 
-	syscall_trace(r, 1);
+	syscall_trace_leave(regs);
 }

commit a3170d2ec25f841bee1b52487693ac1a2f191ba6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue May 22 21:16:35 2012 -0400

    um: switch UPT_SET_RETURN_VALUE and regs_return_value to pt_regs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 05fbeb480e0b..800551a29dbf 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -34,7 +34,7 @@ void handle_syscall(struct uml_pt_regs *r)
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 
-	UPT_SET_SYSCALL_RETURN(r, result);
+	PT_REGS_SET_SYSCALL_RETURN(regs, result);
 
 	syscall_trace(r, 1);
 }

commit 243412be9cecfc7fddebb912a277b76119fd4ecd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 20 00:05:58 2012 -0400

    um/x86: merge (and trim) 32- and 64-bit variants of ptrace.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index f5173e1ec3ac..05fbeb480e0b 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -34,7 +34,7 @@ void handle_syscall(struct uml_pt_regs *r)
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 
-	REGS_SET_SYSCALL_RETURN(r->gp, result);
+	UPT_SET_SYSCALL_RETURN(r, result);
 
 	syscall_trace(r, 1);
 }

commit ce60d4d5d50a5454768faa522da98aa5f8070bd0
Author: Jan Kiszka <jan.kiszka@web.de>
Date:   Mon Apr 19 23:53:07 2010 +0200

    uml: i386: Avoid redefinition of NR_syscalls
    
    The i386 subarch happens to pull in original NR_syscalls. Maybe we can
    make that work for all host arch, but for now just avoid the clash by
    using an all-upper-case name.
    
      CC      arch/um/kernel/skas/syscall.o/data/linux-2.6/arch/um/kernel/skas/syscall.c:13:1: warning: "NR_syscalls" redefined
    In file included from /data/linux-2.6/arch/x86/include/asm/unistd.h:3,
                     from /data/linux-2.6/arch/um/sys-i386/shared/sysdep/syscalls.h:6,
                     from /data/linux-2.6/arch/um/kernel/skas/syscall.c:10:
    /data/linux-2.6/arch/x86/include/asm/unistd_32.h:349:1: warning: this is the location of the previous definition
    
    Signed-off-by: Jan Kiszka <jan.kiszka@web.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 4e3b820bd2be..f5173e1ec3ac 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -10,7 +10,7 @@
 #include "sysdep/syscalls.h"
 
 extern int syscall_table_size;
-#define NR_syscalls (syscall_table_size / sizeof(void *))
+#define NR_SYSCALLS (syscall_table_size / sizeof(void *))
 
 void handle_syscall(struct uml_pt_regs *r)
 {
@@ -30,7 +30,7 @@ void handle_syscall(struct uml_pt_regs *r)
 	 * in case it's a compiler bug.
 	 */
 	syscall = UPT_SYSCALL_NR(r);
-	if ((syscall >= NR_syscalls) || (syscall < 0))
+	if ((syscall >= NR_SYSCALLS) || (syscall < 0))
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 

commit f87ea91d988637b3bbf6aa2d281c6010e7d5f48d
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:29 2008 -0800

    uml: redo the calculation of NR_syscalls
    
    Redo the calculation of NR_syscalls since that disappeared from i386 and
    use a similar mechanism on x86_64.
    
    We now figure out the size of the system call table in arch code and stick
    that in syscall_table_size.  arch/um/kernel/skas/syscall.c defines
    NR_syscalls in terms of that since its the only thing that needs to know
    how many system calls there are.
    
    The old mechananism that was used on x86_64 is gone.
    
    arch/um/include/sysdep-i386/syscalls.h got some formatting since I was
    looking at it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 6450f024290f..4e3b820bd2be 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -9,6 +9,9 @@
 #include "sysdep/ptrace.h"
 #include "sysdep/syscalls.h"
 
+extern int syscall_table_size;
+#define NR_syscalls (syscall_table_size / sizeof(void *))
+
 void handle_syscall(struct uml_pt_regs *r)
 {
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);

commit a9b71b6c5473d2c1526deac0a1a207fe476f6088
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:11 2008 -0800

    uml: get rid of syscall counters
    
    Get rid of some syscall counters which haven't been useful in ages.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 50b476f2b38d..6450f024290f 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -17,9 +17,6 @@ void handle_syscall(struct uml_pt_regs *r)
 
 	syscall_trace(r, 0);
 
-	current->thread.nsyscalls++;
-	nsyscalls++;
-
 	/*
 	 * This should go in the declaration of syscall, but when I do that,
 	 * strace -f -c bash -c 'ls ; ls' breaks, sometimes not tracing

commit 18badddaa84e13e126f4ca5df47ac55b97a2635a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:07 2007 -0700

    uml: rename pt_regs general-purpose register file
    
    Before the removal of tt mode, access to a register on the skas-mode side of a
    pt_regs struct looked like pt_regs.regs.skas.regs.regs[FOO].  This was bad
    enough, but it became pt_regs.regs.regs.regs[FOO] with the removal of the
    union from the middle.  To get rid of the run of three "regs", the last field
    is renamed to "gp".
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 8582c1331048..50b476f2b38d 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -34,7 +34,7 @@ void handle_syscall(struct uml_pt_regs *r)
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 
-	REGS_SET_SYSCALL_RETURN(r->regs, result);
+	REGS_SET_SYSCALL_RETURN(r->gp, result);
 
 	syscall_trace(r, 1);
 }

commit ba180fd437156f7fd8cfb2fdd021d949eeef08d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:00 2007 -0700

    uml: style fixes pass 3
    
    Formatting changes in the files which have been changed in the course
    of folding foo_skas functions into their callers.  These include:
            copyright updates
            header file trimming
            style fixes
            adding severity to printks
    
    These changes should be entirely non-functional.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index e183da633c89..8582c1331048 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -1,17 +1,13 @@
 /*
- * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2002 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
-#include "linux/sys.h"
+#include "linux/kernel.h"
 #include "linux/ptrace.h"
-#include "asm/errno.h"
-#include "asm/unistd.h"
-#include "asm/ptrace.h"
-#include "asm/current.h"
-#include "sysdep/syscalls.h"
 #include "kern_util.h"
-#include "syscall.h"
+#include "sysdep/ptrace.h"
+#include "sysdep/syscalls.h"
 
 void handle_syscall(struct uml_pt_regs *r)
 {
@@ -24,7 +20,8 @@ void handle_syscall(struct uml_pt_regs *r)
 	current->thread.nsyscalls++;
 	nsyscalls++;
 
-	/* This should go in the declaration of syscall, but when I do that,
+	/*
+	 * This should go in the declaration of syscall, but when I do that,
 	 * strace -f -c bash -c 'ls ; ls' breaks, sometimes not tracing
 	 * children at all, sometimes hanging when bash doesn't see the first
 	 * ls exit.
@@ -33,7 +30,7 @@ void handle_syscall(struct uml_pt_regs *r)
 	 * in case it's a compiler bug.
 	 */
 	syscall = UPT_SYSCALL_NR(r);
-	if((syscall >= NR_syscalls) || (syscall < 0))
+	if ((syscall >= NR_syscalls) || (syscall < 0))
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 

commit 77bf4400319db9d2a8af6b00c2be6faa0f3d07cb
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:58 2007 -0700

    uml: remove code made redundant by CHOOSE_MODE removal
    
    This patch makes a number of simplifications enabled by the removal of
    CHOOSE_MODE.  There were lots of functions that looked like
    
            int foo(args){
                    foo_skas(args);
            }
    
    The bodies of foo_skas are now folded into foo, and their declarations (and
    sometimes entire header files) are deleted.
    
    In addition, the union uml_pt_regs, which was a union between the tt and skas
    register formats, is now a struct, with the tt-mode arm of the union being
    removed.
    
    It turns out that usr2_handler was unused, so it is gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 0ae4eea21be4..e183da633c89 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -13,7 +13,7 @@
 #include "kern_util.h"
 #include "syscall.h"
 
-void handle_syscall(union uml_pt_regs *r)
+void handle_syscall(struct uml_pt_regs *r)
 {
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
 	long result;
@@ -37,7 +37,7 @@ void handle_syscall(union uml_pt_regs *r)
 		result = -ENOSYS;
 	else result = EXECUTE_SYSCALL(syscall, regs);
 
-	REGS_SET_SYSCALL_RETURN(r->skas.regs, result);
+	REGS_SET_SYSCALL_RETURN(r->regs, result);
 
 	syscall_trace(r, 1);
 }

commit 469226a431f553a7b3ec17d87ce3c2d1c6c25fb2
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:13 2006 -0700

    [PATCH] uml: remove syscall debugging
    
    Eliminate an unused debug option.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
index 51fb94076fcf..0ae4eea21be4 100644
--- a/arch/um/kernel/skas/syscall.c
+++ b/arch/um/kernel/skas/syscall.c
@@ -18,11 +18,7 @@ void handle_syscall(union uml_pt_regs *r)
 	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
 	long result;
 	int syscall;
-#ifdef UML_CONFIG_SYSCALL_DEBUG
-  	int index;
 
-  	index = record_syscall_start(UPT_SYSCALL_NR(r));
-#endif
 	syscall_trace(r, 0);
 
 	current->thread.nsyscalls++;
@@ -44,7 +40,4 @@ void handle_syscall(union uml_pt_regs *r)
 	REGS_SET_SYSCALL_RETURN(r->skas.regs, result);
 
 	syscall_trace(r, 1);
-#ifdef UML_CONFIG_SYSCALL_DEBUG
-  	record_syscall_end(index, result);
-#endif
 }

commit e32dacb9f481fd6decb41adb28e720c923d34f54
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Sep 3 15:57:42 2005 -0700

    [PATCH] uml: system call path cleanup
    
    This merges two sets of files which had no business being split apart in the
    first place.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/kernel/skas/syscall.c b/arch/um/kernel/skas/syscall.c
new file mode 100644
index 000000000000..51fb94076fcf
--- /dev/null
+++ b/arch/um/kernel/skas/syscall.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include "linux/sys.h"
+#include "linux/ptrace.h"
+#include "asm/errno.h"
+#include "asm/unistd.h"
+#include "asm/ptrace.h"
+#include "asm/current.h"
+#include "sysdep/syscalls.h"
+#include "kern_util.h"
+#include "syscall.h"
+
+void handle_syscall(union uml_pt_regs *r)
+{
+	struct pt_regs *regs = container_of(r, struct pt_regs, regs);
+	long result;
+	int syscall;
+#ifdef UML_CONFIG_SYSCALL_DEBUG
+  	int index;
+
+  	index = record_syscall_start(UPT_SYSCALL_NR(r));
+#endif
+	syscall_trace(r, 0);
+
+	current->thread.nsyscalls++;
+	nsyscalls++;
+
+	/* This should go in the declaration of syscall, but when I do that,
+	 * strace -f -c bash -c 'ls ; ls' breaks, sometimes not tracing
+	 * children at all, sometimes hanging when bash doesn't see the first
+	 * ls exit.
+	 * The assembly looks functionally the same to me.  This is
+	 *     gcc version 4.0.1 20050727 (Red Hat 4.0.1-5)
+	 * in case it's a compiler bug.
+	 */
+	syscall = UPT_SYSCALL_NR(r);
+	if((syscall >= NR_syscalls) || (syscall < 0))
+		result = -ENOSYS;
+	else result = EXECUTE_SYSCALL(syscall, regs);
+
+	REGS_SET_SYSCALL_RETURN(r->skas.regs, result);
+
+	syscall_trace(r, 1);
+#ifdef UML_CONFIG_SYSCALL_DEBUG
+  	record_syscall_end(index, result);
+#endif
+}
