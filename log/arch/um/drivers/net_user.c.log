commit dbddf429dc514257170d4c5e116cbd95a86408ab
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:16 2019 +0100

    um: Add SPDX headers for files in arch/um/drivers
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index e9f8445861dc..4c9576452ab0 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <stdio.h>

commit 887a9853092c09e20598f4a7f91ac1cfb762be50
Author: Geyslan G. Bem <geyslan@gmail.com>
Date:   Tue Dec 1 17:18:55 2015 -0300

    um: fix returns without va_end
    
    When using va_list ensure that va_start will be followed by va_end.
    
    Signed-off-by: Geyslan G. Bem <geyslan@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index e697a4136707..e9f8445861dc 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -249,21 +249,23 @@ void close_addr(unsigned char *addr, unsigned char *netmask, void *arg)
 
 char *split_if_spec(char *str, ...)
 {
-	char **arg, *end;
+	char **arg, *end, *ret = NULL;
 	va_list ap;
 
 	va_start(ap, str);
 	while ((arg = va_arg(ap, char **)) != NULL) {
 		if (*str == '\0')
-			return NULL;
+			goto out;
 		end = strchr(str, ',');
 		if (end != str)
 			*arg = str;
 		if (end == NULL)
-			return NULL;
+			goto out;
 		*end++ = '\0';
 		str = end;
 	}
+	ret = str;
+out:
 	va_end(ap);
-	return str;
+	return ret;
 }

commit f9bb3b5947c507d402eecbffabb8fb0864263ad1
Author: Hans-Werner Hilse <hwhilse@gmail.com>
Date:   Thu Jun 11 11:29:19 2015 +0200

    um: Do not use stdin and stdout identifiers for struct members
    
    stdin, stdout and stderr are macros according to C89/C99.
    Thus do not use them as struct member identifiers to avoid
    bad results from macro expansion.
    
    Signed-off-by: Hans-Werner Hilse <hwhilse@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index cd14157b556d..e697a4136707 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -166,7 +166,7 @@ int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
 
 struct change_pre_exec_data {
 	int close_me;
-	int stdout;
+	int stdout_fd;
 };
 
 static void change_pre_exec(void *arg)
@@ -174,7 +174,7 @@ static void change_pre_exec(void *arg)
 	struct change_pre_exec_data *data = arg;
 
 	close(data->close_me);
-	dup2(data->stdout, 1);
+	dup2(data->stdout_fd, 1);
 }
 
 static int change_tramp(char **argv, char *output, int output_len)
@@ -189,7 +189,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 		return err;
 	}
 	pe_data.close_me = fds[0];
-	pe_data.stdout = fds[1];
+	pe_data.stdout_fd = fds[1];
 	pid = run_helper(change_pre_exec, &pe_data, argv);
 
 	if (pid > 0)	/* Avoid hang as we won't get data in failure case. */

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 05090c37fa84..cd14157b556d 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -11,9 +11,9 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
-#include "net_user.h"
-#include "os.h"
-#include "um_malloc.h"
+#include <net_user.h>
+#include <os.h>
+#include <um_malloc.h>
 
 int tap_open_common(void *dev, char *gate_addr)
 {

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 520118888f16..05090c37fa84 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -12,10 +12,8 @@
 #include <sys/socket.h>
 #include <sys/wait.h>
 #include "net_user.h"
-#include "kern_constants.h"
 #include "os.h"
 #include "um_malloc.h"
-#include "user.h"
 
 int tap_open_common(void *dev, char *gate_addr)
 {

commit fbee8d933c775cdb9daac3063659cda38c1776c2
Author: Vitaliy Ivanov <vitalivanov@gmail.com>
Date:   Mon Jul 25 17:12:49 2011 -0700

    uml: drivers/net_user.c memory leak fix
    
    Perform memory cleanup on exit.  On receiving invalid 'pid' we still
    should clean 'output' variable.
    
    Signed-off-by: Vitaliy Ivanov <vitalivanov@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 9415dd9e63ef..520118888f16 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -228,7 +228,10 @@ static void change(char *dev, char *what, unsigned char *addr,
 		       "buffer\n");
 
 	pid = change_tramp(argv, output, output_len);
-	if (pid < 0) return;
+	if (pid < 0) {
+		kfree(output);
+		return;
+	}
 
 	if (output != NULL) {
 		printk("%s", output);

commit 43f5b3085fdd27c4edf535d938b2cb0ccead4f75
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 12 14:01:52 2008 -0700

    uml: fix build when SLOB is enabled
    
    Reintroduce uml_kmalloc for the benefit of UML libc code.  The
    previous tactic of declaring __kmalloc so it could be called directly
    from the libc side of the house turned out to be getting too intimate
    with slab, and it doesn't work with slob.
    
    So, the uml_kmalloc wrapper is back.  It calls kmalloc or whatever
    that translates into, and libc code calls it.
    
    kfree is left alone since that still works, leaving a somewhat
    inconsistent API.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index abf2653f5517..9415dd9e63ef 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -222,7 +222,7 @@ static void change(char *dev, char *what, unsigned char *addr,
 		netmask[2], netmask[3]);
 
 	output_len = UM_KERN_PAGE_SIZE;
-	output = kmalloc(output_len, UM_GFP_KERNEL);
+	output = uml_kmalloc(output_len, UM_GFP_KERNEL);
 	if (output == NULL)
 		printk(UM_KERN_ERR "change : failed to allocate output "
 		       "buffer\n");

commit 1aa351a308d2c3ddb92b6cc45083fc54271d0010
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Feb 4 22:31:10 2008 -0800

    uml: tidy helper code
    
    Style fixes to arch/um/os/helper.c and tidying up the breakpoint fix a
    bit.
    
    helper.c gets all the usual style fixes -
             updated copyright
             all printks get severities
    
    Also -
             errval changes to err in helper_child
             fixed an obsolete comment
             run_helper was killing a child process which is guaranteed to
    be dead or dying anyway
    
    Removed the nohang and pname arguments from helper_wait and fixed the
    declaration and callers.  nohang was used only in the slirp driver and
    I don't think it was needed.  I think pname was a bit of overkill in
    putting out an error message when something goes wrong.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 29185cad9fff..abf2653f5517 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -201,7 +201,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 	close(fds[1]);
 
 	if (pid > 0)
-		helper_wait(pid, 0, "change_tramp");
+		helper_wait(pid);
 	return pid;
 }
 

commit 4dbed85a35ed37d9608f4f32e5d69efa775d6223
Author: Stanislaw Gruszka <stf_xl@wp.pl>
Date:   Mon Dec 17 16:19:46 2007 -0800

    uml: stop gdb from deleting breakpoints when running UML
    
    Sometimes when UML is debugged gdb miss breakpoints.
    
    When process traced by gdb do fork, debugger remove breakpoints from
    child address space. There is possibility to trace more than one fork,
    but this not work with UML, I guess (only guess) there is a deadlock -
    gdb waits for UML and UML waits for gdb.
    
    When clone() is called with SIGCHLD and CLONE_VM flags, gdb see this
    as PTRACE_EVENT_FORK not as PTRACE_EVENT_CLONE and remove breakpoints
    from child and at the same time from traced process, because either
    have the same address space.
    
    Maybe it is possible to do fix in gdb, but I'm not sure if there is
    easy way to find out if traced and child processes share memory. So I
    do fix for UML, it simply do not call clone() with both SIGCHLD and
    CLONE_VM flags together.  Additionally __WALL flag is used for
    waitpid() to assure not miss clone and normal process events.
    
    [ jdike - checkpatch fixes ]
    
    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 90d7f2e8ead8..29185cad9fff 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -201,7 +201,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 	close(fds[1]);
 
 	if (pid > 0)
-		CATCH_EINTR(err = waitpid(pid, NULL, 0));
+		helper_wait(pid, 0, "change_tramp");
 	return pid;
 }
 

commit cd1ae0e49bdd814cfaa2e5ab28cff21a30e20085
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:29 2007 -0700

    uml: network formatting
    
    Style and other non-functional changes in the UML networking code, including
            include tidying
            style violations
            copyright updates
            printks getting severities
            userspace code calling libc directly rather than using the os_*
    wrappers
    
    There's also a exit path cleanup in the pcap driver.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index da946e3e1bf2..90d7f2e8ead8 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -1,34 +1,32 @@
-/* 
- * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+/*
+ * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
-#include <stddef.h>
-#include <stdarg.h>
-#include <unistd.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <stdarg.h>
 #include <errno.h>
-#include <stdlib.h>
+#include <stddef.h>
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
-#include <sys/time.h>
-#include "user.h"
-#include "kern_util.h"
 #include "net_user.h"
+#include "kern_constants.h"
 #include "os.h"
 #include "um_malloc.h"
-#include "kern_constants.h"
+#include "user.h"
 
 int tap_open_common(void *dev, char *gate_addr)
 {
 	int tap_addr[4];
 
-	if(gate_addr == NULL)
+	if (gate_addr == NULL)
 		return 0;
-	if(sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0], 
-		  &tap_addr[1], &tap_addr[2], &tap_addr[3]) != 4){
-		printk("Invalid tap IP address - '%s'\n", gate_addr);
+	if (sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0],
+		  &tap_addr[1], &tap_addr[2], &tap_addr[3]) != 4) {
+		printk(UM_KERN_ERR "Invalid tap IP address - '%s'\n",
+		       gate_addr);
 		return -EINVAL;
 	}
 	return 0;
@@ -38,15 +36,15 @@ void tap_check_ips(char *gate_addr, unsigned char *eth_addr)
 {
 	int tap_addr[4];
 
-	if((gate_addr != NULL) && 
-	   (sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0], 
-		   &tap_addr[1], &tap_addr[2], &tap_addr[3]) == 4) &&
-	   (eth_addr[0] == tap_addr[0]) && 
-	   (eth_addr[1] == tap_addr[1]) && 
-	   (eth_addr[2] == tap_addr[2]) && 
-	   (eth_addr[3] == tap_addr[3])){
-		printk("The tap IP address and the UML eth IP address"
-		       " must be different\n");
+	if ((gate_addr != NULL) &&
+	    (sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0],
+		    &tap_addr[1], &tap_addr[2], &tap_addr[3]) == 4) &&
+	    (eth_addr[0] == tap_addr[0]) &&
+	    (eth_addr[1] == tap_addr[1]) &&
+	    (eth_addr[2] == tap_addr[2]) &&
+	    (eth_addr[3] == tap_addr[3])) {
+		printk(UM_KERN_ERR "The tap IP address and the UML eth IP "
+		       "address must be different\n");
 	}
 }
 
@@ -57,24 +55,28 @@ void read_output(int fd, char *output, int len)
 	char c;
 	char *str;
 
-	if(output == NULL){
+	if (output == NULL) {
 		output = &c;
 		len = sizeof(c);
 	}
-		
+
 	*output = '\0';
-	ret = os_read_file(fd, &remain, sizeof(remain));
+	ret = read(fd, &remain, sizeof(remain));
 
 	if (ret != sizeof(remain)) {
+		if (ret < 0)
+			ret = -errno;
 		expected = sizeof(remain);
 		str = "length";
 		goto err;
 	}
 
-	while(remain != 0){
+	while (remain != 0) {
 		expected = (remain < len) ? remain : len;
-		ret = os_read_file(fd, output, expected);
+		ret = read(fd, output, expected);
 		if (ret != expected) {
+			if (ret < 0)
+				ret = -errno;
 			str = "data";
 			goto err;
 		}
@@ -85,20 +87,22 @@ void read_output(int fd, char *output, int len)
 
 err:
 	if (ret < 0)
-		printk("read_output - read of %s failed, errno = %d\n", str, -ret);
+		printk(UM_KERN_ERR "read_output - read of %s failed, "
+		       "errno = %d\n", str, -ret);
 	else
-		printk("read_output - read of %s failed, read only %d of %d bytes\n", str, ret, expected);
+		printk(UM_KERN_ERR "read_output - read of %s failed, read only "
+		       "%d of %d bytes\n", str, ret, expected);
 }
 
 int net_read(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_read_file(fd,  buf,  len);
+	n = read(fd,  buf,  len);
 
-	if(n == -EAGAIN)
+	if ((n < 0) && (errno == EAGAIN))
 		return 0;
-	else if(n == 0)
+	else if (n == 0)
 		return -ENOTCONN;
 	return n;
 }
@@ -108,12 +112,12 @@ int net_recvfrom(int fd, void *buf, int len)
 	int n;
 
 	CATCH_EINTR(n = recvfrom(fd,  buf,  len, 0, NULL, NULL));
-	if(n < 0){
-		if(errno == EAGAIN)
+	if (n < 0) {
+		if (errno == EAGAIN)
 			return 0;
 		return -errno;
 	}
-	else if(n == 0)
+	else if (n == 0)
 		return -ENOTCONN;
 	return n;
 }
@@ -122,11 +126,11 @@ int net_write(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_write_file(fd, buf, len);
+	n = write(fd, buf, len);
 
-	if(n == -EAGAIN)
+	if ((n < 0) && (errno == EAGAIN))
 		return 0;
-	else if(n == 0)
+	else if (n == 0)
 		return -ENOTCONN;
 	return n;
 }
@@ -136,12 +140,12 @@ int net_send(int fd, void *buf, int len)
 	int n;
 
 	CATCH_EINTR(n = send(fd, buf, len, 0));
-	if(n < 0){
-		if(errno == EAGAIN)
+	if (n < 0) {
+		if (errno == EAGAIN)
 			return 0;
 		return -errno;
 	}
-	else if(n == 0)
+	else if (n == 0)
 		return -ENOTCONN;
 	return n;
 }
@@ -152,12 +156,12 @@ int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
 
 	CATCH_EINTR(n = sendto(fd, buf, len, 0, (struct sockaddr *) to,
 			       sock_len));
-	if(n < 0){
-		if(errno == EAGAIN)
+	if (n < 0) {
+		if (errno == EAGAIN)
 			return 0;
 		return -errno;
 	}
-	else if(n == 0)
+	else if (n == 0)
 		return -ENOTCONN;
 	return n;
 }
@@ -171,7 +175,7 @@ static void change_pre_exec(void *arg)
 {
 	struct change_pre_exec_data *data = arg;
 
-	os_close_file(data->close_me);
+	close(data->close_me);
 	dup2(data->stdout, 1);
 }
 
@@ -181,8 +185,9 @@ static int change_tramp(char **argv, char *output, int output_len)
 	struct change_pre_exec_data pe_data;
 
 	err = os_pipe(fds, 1, 0);
-	if(err < 0){
-		printk("change_tramp - pipe failed, err = %d\n", -err);
+	if (err < 0) {
+		printk(UM_KERN_ERR "change_tramp - pipe failed, err = %d\n",
+		       -err);
 		return err;
 	}
 	pe_data.close_me = fds[0];
@@ -192,8 +197,8 @@ static int change_tramp(char **argv, char *output, int output_len)
 	if (pid > 0)	/* Avoid hang as we won't get data in failure case. */
 		read_output(fds[0], output, output_len);
 
-	os_close_file(fds[0]);
-	os_close_file(fds[1]);
+	close(fds[0]);
+	close(fds[1]);
 
 	if (pid > 0)
 		CATCH_EINTR(err = waitpid(pid, NULL, 0));
@@ -206,25 +211,26 @@ static void change(char *dev, char *what, unsigned char *addr,
 	char addr_buf[sizeof("255.255.255.255\0")];
 	char netmask_buf[sizeof("255.255.255.255\0")];
 	char version[sizeof("nnnnn\0")];
-	char *argv[] = { "uml_net", version, what, dev, addr_buf, 
+	char *argv[] = { "uml_net", version, what, dev, addr_buf,
 			 netmask_buf, NULL };
 	char *output;
 	int output_len, pid;
 
 	sprintf(version, "%d", UML_NET_VERSION);
 	sprintf(addr_buf, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]);
-	sprintf(netmask_buf, "%d.%d.%d.%d", netmask[0], netmask[1], 
+	sprintf(netmask_buf, "%d.%d.%d.%d", netmask[0], netmask[1],
 		netmask[2], netmask[3]);
 
 	output_len = UM_KERN_PAGE_SIZE;
 	output = kmalloc(output_len, UM_GFP_KERNEL);
-	if(output == NULL)
-		printk("change : failed to allocate output buffer\n");
+	if (output == NULL)
+		printk(UM_KERN_ERR "change : failed to allocate output "
+		       "buffer\n");
 
 	pid = change_tramp(argv, output, output_len);
-	if(pid < 0) return;
+	if (pid < 0) return;
 
-	if(output != NULL){
+	if (output != NULL) {
 		printk("%s", output);
 		kfree(output);
 	}
@@ -246,13 +252,13 @@ char *split_if_spec(char *str, ...)
 	va_list ap;
 
 	va_start(ap, str);
-	while((arg = va_arg(ap, char **)) != NULL){
-		if(*str == '\0')
+	while ((arg = va_arg(ap, char **)) != NULL) {
+		if (*str == '\0')
 			return NULL;
 		end = strchr(str, ',');
-		if(end != str)
+		if (end != str)
 			*arg = str;
-		if(end == NULL)
+		if (end == NULL)
 			return NULL;
 		*end++ = '\0';
 		str = end;

commit e4c4bf9968cb4f0fceb1b8fb54790ccae73caf4e
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:56 2007 -0700

    uml: Eliminate kernel allocator wrappers
    
    UML had two wrapper procedures for kmalloc, um_kmalloc and um_kmalloc_atomic
    because the flag constants weren't available in userspace code.
    kern_constants.h had made kernel constants available for a long time, so there
    is no need for these wrappers any more.  Rather, userspace code calls kmalloc
    directly with the userspace versions of the gfp flags.
    
    kmalloc isn't a real procedure, so I had to essentially copy the inline
    wrapper around __kmalloc.
    
    vmalloc also had its own wrapper for no good reason.  This is now gone.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 6fa948ba969d..da946e3e1bf2 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -217,7 +217,7 @@ static void change(char *dev, char *what, unsigned char *addr,
 		netmask[2], netmask[3]);
 
 	output_len = UM_KERN_PAGE_SIZE;
-	output = um_kmalloc(output_len);
+	output = kmalloc(output_len, UM_GFP_KERNEL);
 	if(output == NULL)
 		printk("change : failed to allocate output buffer\n");
 

commit c43990162fc7f9d2f15a12797fdc6f9c0905f704
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:56 2007 -0700

    uml: simplify helper stack handling
    
    run_helper and run_helper_thread had arguments which were the same in all
    callers.  run_helper's stack_out was always NULL and run_helper_thread's
    stack_order was always 0.  These are now gone, and the constants folded
    into the code.
    
    Also fixed leaks of the helper stack in the AIO and SIGIO code.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 3503cff867c3..6fa948ba969d 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -187,7 +187,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 	}
 	pe_data.close_me = fds[0];
 	pe_data.stdout = fds[1];
-	pid = run_helper(change_pre_exec, &pe_data, argv, NULL);
+	pid = run_helper(change_pre_exec, &pe_data, argv);
 
 	if (pid > 0)	/* Avoid hang as we won't get data in failure case. */
 		read_output(fds[0], output, output_len);

commit a6ea4cceed18edebe1eb6001cb9e0f88cd741a6c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:43 2007 -0700

    uml: rename os_{read_write}_file_k back to os_{read_write}_file
    
    Rename os_{read_write}_file_k back to os_{read_write}_file, delete
    the originals and their bogus infrastructure, and fix all the callers.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 8bc6688c4f0f..3503cff867c3 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -63,7 +63,7 @@ void read_output(int fd, char *output, int len)
 	}
 		
 	*output = '\0';
-	ret = os_read_file_k(fd, &remain, sizeof(remain));
+	ret = os_read_file(fd, &remain, sizeof(remain));
 
 	if (ret != sizeof(remain)) {
 		expected = sizeof(remain);
@@ -73,7 +73,7 @@ void read_output(int fd, char *output, int len)
 
 	while(remain != 0){
 		expected = (remain < len) ? remain : len;
-		ret = os_read_file_k(fd, output, expected);
+		ret = os_read_file(fd, output, expected);
 		if (ret != expected) {
 			str = "data";
 			goto err;
@@ -94,7 +94,7 @@ int net_read(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_read_file_k(fd,  buf,  len);
+	n = os_read_file(fd,  buf,  len);
 
 	if(n == -EAGAIN)
 		return 0;
@@ -122,7 +122,7 @@ int net_write(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_write_file_k(fd, buf, len);
+	n = os_write_file(fd, buf, len);
 
 	if(n == -EAGAIN)
 		return 0;

commit fda83a99b2b49016b9d7ed562745969db25c4ef9
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:41 2007 -0700

    uml: change remaining callers of os_{read_write}_file
    
    Convert all remaining os_{read_write}_file users to use the simple
    {read,write} wrappers, os_{read_write}_file_k.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 2dc57a37e4b7..8bc6688c4f0f 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -73,7 +73,7 @@ void read_output(int fd, char *output, int len)
 
 	while(remain != 0){
 		expected = (remain < len) ? remain : len;
-		ret = os_read_file(fd, output, expected);
+		ret = os_read_file_k(fd, output, expected);
 		if (ret != expected) {
 			str = "data";
 			goto err;
@@ -94,7 +94,7 @@ int net_read(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_read_file(fd,  buf,  len);
+	n = os_read_file_k(fd,  buf,  len);
 
 	if(n == -EAGAIN)
 		return 0;
@@ -122,7 +122,7 @@ int net_write(int fd, void *buf, int len)
 {
 	int n;
 
-	n = os_write_file(fd, buf, len);
+	n = os_write_file_k(fd, buf, len);
 
 	if(n == -EAGAIN)
 		return 0;

commit 3d564047a5f45cb628ec72514f68076e532988f3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:32 2007 -0700

    uml: start fixing os_read_file and os_write_file
    
    This patch starts the removal of a very old, very broken piece of code.  This
    stems from the problem of passing a userspace buffer into read() or write() on
    the host.  If that buffer had not yet been faulted in, read and write will
    return -EFAULT.
    
    To avoid this problem, the solution was to fault the buffer in before the
    system call by touching the pages that hold the buffer by doing a copy-user of
    a byte to each page.  This is obviously bogus, but it does usually work, in tt
    mode, since the kernel and process are in the same address space and userspace
    addresses can be accessed directly in the kernel.
    
    In skas mode, where the kernel and process are in separate address spaces, it
    is completely bogus because the userspace address, which is invalid in the
    kernel, is passed into the system call instead of the corresponding physical
    address, which would be valid.  Here, it appears that this code, on every host
    read() or write(), tries to fault in a random process page.  This doesn't seem
    to cause any correctness problems, but there is a performance impact.  This
    patch, and the ones following, result in a 10-15% performance gain on a kernel
    build.
    
    This code can't be immediately tossed out because when it is, you can't log
    in.  Apparently, there is some code in the console driver which depends on
    this somehow.
    
    However, we can start removing it by switching the code which does I/O using
    kernel addresses to using plain read() and write().  This patch introduces
    os_read_file_k and os_write_file_k for use with kernel buffers and converts
    all call locations which use obvious kernel buffers to use them.  These
    include I/O using buffers which are local variables which are on the stack or
    kmalloc-ed.  Later patches will handle the less obvious cases, followed by a
    mass conversion back to the original interface.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 3503cff867c3..2dc57a37e4b7 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -63,7 +63,7 @@ void read_output(int fd, char *output, int len)
 	}
 		
 	*output = '\0';
-	ret = os_read_file(fd, &remain, sizeof(remain));
+	ret = os_read_file_k(fd, &remain, sizeof(remain));
 
 	if (ret != sizeof(remain)) {
 		expected = sizeof(remain);

commit 1ffb9164f51094b7105ce9f81600b222ddf5b82c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:22 2007 -0700

    uml: remove page_size()
    
    userspace code used to have to call the kernelspace function page_size() in
    order to determine the value of the kernel's PAGE_SIZE.  Since this is now
    available directly from kern_constants.h as UM_KERN_PAGE_SIZE, page_size() can
    be deleted and calls changed to use the constant.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index b63a86046374..3503cff867c3 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -18,6 +18,7 @@
 #include "net_user.h"
 #include "os.h"
 #include "um_malloc.h"
+#include "kern_constants.h"
 
 int tap_open_common(void *dev, char *gate_addr)
 {
@@ -215,7 +216,7 @@ static void change(char *dev, char *what, unsigned char *addr,
 	sprintf(netmask_buf, "%d.%d.%d.%d", netmask[0], netmask[1], 
 		netmask[2], netmask[3]);
 
-	output_len = page_size();
+	output_len = UM_KERN_PAGE_SIZE;
 	output = um_kmalloc(output_len);
 	if(output == NULL)
 		printk("change : failed to allocate output buffer\n");

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 0ffd7ac295d4..b63a86046374 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -14,7 +14,6 @@
 #include <sys/wait.h>
 #include <sys/time.h>
 #include "user.h"
-#include "user_util.h"
 #include "kern_util.h"
 #include "net_user.h"
 #include "os.h"

commit c13e569073b89eb75216a2551e89ae93ad1f9951
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Thu Oct 19 23:28:20 2006 -0700

    [PATCH] uml: split memory allocation prototypes out of user.h
    
    user.h is too generic a header name.  I've split out allocation routines from
    it.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index f3a3f8a29c7a..0ffd7ac295d4 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -18,6 +18,7 @@
 #include "kern_util.h"
 #include "net_user.h"
 #include "os.h"
+#include "um_malloc.h"
 
 int tap_open_common(void *dev, char *gate_addr)
 {

commit fade5d5461b0379b27ca96faf560d855d7a0ea8b
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Sep 29 01:58:53 2006 -0700

    [PATCH] uml: don't roll my own random MAC generator
    
    Use the existing random_ether_addr() instead of cooking up my own
    version.  Pointed out by Dave Hollis and Jason Lunz.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 142bcb2c7c6a..f3a3f8a29c7a 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -259,32 +259,3 @@ char *split_if_spec(char *str, ...)
 	va_end(ap);
 	return str;
 }
-
-void random_mac(unsigned char *addr)
-{
-	struct timeval tv;
-	long n;
-	unsigned int seed;
-
-	gettimeofday(&tv, NULL);
-
-	/* Assume that 20 bits of microseconds and 12 bits of the pid are
-	 * reasonably unpredictable.
-	 */
-	seed = tv.tv_usec | (os_getpid() << 20);
-	srandom(seed);
-
-	/* Don't care about endianness here - switching endianness
-	 * just rearranges what are hopefully random numbers.
-	 *
-	 * Assume that RAND_MAX > 65536, so random is called twice and
-	 * we use 16 bits of the result.
-	 */
-	n = random();
-	addr[2] = (n >> 8) & 255;
-	addr[3] = n % 255;
-
-	n = random();
-	addr[4] = (n >> 8) & 255;
-	addr[5] = n % 255;
-}

commit f3e7ed2b617824f79d1223f37430ccffae59e5b8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Sep 29 01:58:46 2006 -0700

    [PATCH] uml: assign random MACs to interfaces if necessary
    
    Assign a random MAC to an ethernet interface if one was not provided on the
    command line.  This became pressing when distros started bringing interfaces
    up before assigning IPs to them.  The previous pattern of assigning an IP then
    bringing it up allowed the MAC to be generated from the first IP assigned.
    However, once the thing is up, it's probably a bad idea to change the MAC, so
    the MAC stayed initialized to fe:fd:0:0:0:0.
    
    Now, if there is no MAC from the command line, one is generated.  We use the
    microseconds from gettimeofday (20 bits), plus the low 12 bits of the pid to
    seed the random number generator.  random() is called twice, with 16 bits of
    each result used.  I didn't want to have to try to fill in 32 bits optimally
    given an arbitrary RAND_MAX, so I just assume that it is greater than 65536
    and use 16 bits of each random() return.
    
    There is also a bit of reformatting and whitespace cleanup here.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 107c5e43fa00..142bcb2c7c6a 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -12,6 +12,7 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
+#include <sys/time.h>
 #include "user.h"
 #include "user_util.h"
 #include "kern_util.h"
@@ -258,3 +259,32 @@ char *split_if_spec(char *str, ...)
 	va_end(ap);
 	return str;
 }
+
+void random_mac(unsigned char *addr)
+{
+	struct timeval tv;
+	long n;
+	unsigned int seed;
+
+	gettimeofday(&tv, NULL);
+
+	/* Assume that 20 bits of microseconds and 12 bits of the pid are
+	 * reasonably unpredictable.
+	 */
+	seed = tv.tv_usec | (os_getpid() << 20);
+	srandom(seed);
+
+	/* Don't care about endianness here - switching endianness
+	 * just rearranges what are hopefully random numbers.
+	 *
+	 * Assume that RAND_MAX > 65536, so random is called twice and
+	 * we use 16 bits of the result.
+	 */
+	n = random();
+	addr[2] = (n >> 8) & 255;
+	addr[3] = n % 255;
+
+	n = random();
+	addr[4] = (n >> 8) & 255;
+	addr[5] = n % 255;
+}

commit 9ead6feedd28091d86cde0843be914847b4e10e8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:15 2006 -0700

    [PATCH] uml: add some EINTR protection
    
    Add some more uses of the CATCH_EINTR wrapper.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 8cd851be0e4d..107c5e43fa00 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -105,9 +105,7 @@ int net_recvfrom(int fd, void *buf, int len)
 {
 	int n;
 
-	while(((n = recvfrom(fd,  buf,  len, 0, NULL, NULL)) < 0) && 
-	      (errno == EINTR)) ;
-
+	CATCH_EINTR(n = recvfrom(fd,  buf,  len, 0, NULL, NULL));
 	if(n < 0){
 		if(errno == EAGAIN)
 			return 0;
@@ -135,7 +133,7 @@ int net_send(int fd, void *buf, int len)
 {
 	int n;
 
-	while(((n = send(fd, buf, len, 0)) < 0) && (errno == EINTR)) ;
+	CATCH_EINTR(n = send(fd, buf, len, 0));
 	if(n < 0){
 		if(errno == EAGAIN)
 			return 0;
@@ -150,8 +148,8 @@ int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
 {
 	int n;
 
-	while(((n = sendto(fd, buf, len, 0, (struct sockaddr *) to,
-			   sock_len)) < 0) && (errno == EINTR)) ;
+	CATCH_EINTR(n = sendto(fd, buf, len, 0, (struct sockaddr *) to,
+			       sock_len));
 	if(n < 0){
 		if(errno == EAGAIN)
 			return 0;

commit 108ffa8cbfa323d462a2f4b49f38da3205d36e5a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Jul 10 04:45:14 2006 -0700

    [PATCH] uml: formatting fixes
    
    Fix a bunch of formatting problems.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 0a7786e00cfb..8cd851be0e4d 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -22,13 +22,14 @@ int tap_open_common(void *dev, char *gate_addr)
 {
 	int tap_addr[4];
 
-	if(gate_addr == NULL) return(0);
+	if(gate_addr == NULL)
+		return 0;
 	if(sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0], 
 		  &tap_addr[1], &tap_addr[2], &tap_addr[3]) != 4){
 		printk("Invalid tap IP address - '%s'\n", gate_addr);
-		return(-EINVAL);
+		return -EINVAL;
 	}
-	return(0);
+	return 0;
 }
 
 void tap_check_ips(char *gate_addr, unsigned char *eth_addr)
@@ -94,10 +95,10 @@ int net_read(int fd, void *buf, int len)
 	n = os_read_file(fd,  buf,  len);
 
 	if(n == -EAGAIN)
-		return(0);
+		return 0;
 	else if(n == 0)
-		return(-ENOTCONN);
-	return(n);
+		return -ENOTCONN;
+	return n;
 }
 
 int net_recvfrom(int fd, void *buf, int len)
@@ -108,11 +109,13 @@ int net_recvfrom(int fd, void *buf, int len)
 	      (errno == EINTR)) ;
 
 	if(n < 0){
-		if(errno == EAGAIN) return(0);
-		return(-errno);
+		if(errno == EAGAIN)
+			return 0;
+		return -errno;
 	}
-	else if(n == 0) return(-ENOTCONN);
-	return(n);
+	else if(n == 0)
+		return -ENOTCONN;
+	return n;
 }
 
 int net_write(int fd, void *buf, int len)
@@ -122,10 +125,10 @@ int net_write(int fd, void *buf, int len)
 	n = os_write_file(fd, buf, len);
 
 	if(n == -EAGAIN)
-		return(0);
+		return 0;
 	else if(n == 0)
-		return(-ENOTCONN);
-	return(n);
+		return -ENOTCONN;
+	return n;
 }
 
 int net_send(int fd, void *buf, int len)
@@ -134,11 +137,13 @@ int net_send(int fd, void *buf, int len)
 
 	while(((n = send(fd, buf, len, 0)) < 0) && (errno == EINTR)) ;
 	if(n < 0){
-		if(errno == EAGAIN) return(0);
-		return(-errno);
+		if(errno == EAGAIN)
+			return 0;
+		return -errno;
 	}
-	else if(n == 0) return(-ENOTCONN);
-	return(n);	
+	else if(n == 0)
+		return -ENOTCONN;
+	return n;
 }
 
 int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
@@ -148,11 +153,13 @@ int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
 	while(((n = sendto(fd, buf, len, 0, (struct sockaddr *) to,
 			   sock_len)) < 0) && (errno == EINTR)) ;
 	if(n < 0){
-		if(errno == EAGAIN) return(0);
-		return(-errno);
+		if(errno == EAGAIN)
+			return 0;
+		return -errno;
 	}
-	else if(n == 0) return(-ENOTCONN);
-	return(n);	
+	else if(n == 0)
+		return -ENOTCONN;
+	return n;
 }
 
 struct change_pre_exec_data {
@@ -176,7 +183,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 	err = os_pipe(fds, 1, 0);
 	if(err < 0){
 		printk("change_tramp - pipe failed, err = %d\n", -err);
-		return(err);
+		return err;
 	}
 	pe_data.close_me = fds[0];
 	pe_data.stdout = fds[1];
@@ -190,7 +197,7 @@ static int change_tramp(char **argv, char *output, int output_len)
 
 	if (pid > 0)
 		CATCH_EINTR(err = waitpid(pid, NULL, 0));
-	return(pid);
+	return pid;
 }
 
 static void change(char *dev, char *what, unsigned char *addr,
@@ -241,26 +248,15 @@ char *split_if_spec(char *str, ...)
 	va_start(ap, str);
 	while((arg = va_arg(ap, char **)) != NULL){
 		if(*str == '\0')
-			return(NULL);
+			return NULL;
 		end = strchr(str, ',');
 		if(end != str)
 			*arg = str;
 		if(end == NULL)
-			return(NULL);
+			return NULL;
 		*end++ = '\0';
 		str = end;
 	}
 	va_end(ap);
-	return(str);
+	return str;
 }
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit b1c332c9e813cbee6ca77c3a66ee4d312eb96770
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Mon Apr 10 22:53:37 2006 -0700

    [PATCH] uml: fix hang on run_helper() failure on uml_net
    
    Fix an hang on a pipe when run_helper() fails when called by change_tramp()
    (i.e.  when calling uml_net) - reproduced the bug and verified this fixes it.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 0e2f06187ea7..0a7786e00cfb 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -182,7 +182,9 @@ static int change_tramp(char **argv, char *output, int output_len)
 	pe_data.stdout = fds[1];
 	pid = run_helper(change_pre_exec, &pe_data, argv, NULL);
 
-	read_output(fds[0], output, output_len);
+	if (pid > 0)	/* Avoid hang as we won't get data in failure case. */
+		read_output(fds[0], output, output_len);
+
 	os_close_file(fds[0]);
 	os_close_file(fds[1]);
 

commit f462e8f913bdc7a28ce55508d0c045a0c445b157
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Fri Feb 24 13:03:57 2006 -0800

    [PATCH] uml: better error reporting for read_output
    
    Do precise error handling: print precise error messages, distinguishing short
    reads and read errors.  This functions fails frequently enough for me so I
    bothered doing this fix.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Acked-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 098fa65981ab..0e2f06187ea7 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -47,10 +47,12 @@ void tap_check_ips(char *gate_addr, unsigned char *eth_addr)
 	}
 }
 
+/* Do reliable error handling as this fails frequently enough. */
 void read_output(int fd, char *output, int len)
 {
-	int remain, n, actual;
+	int remain, ret, expected;
 	char c;
+	char *str;
 
 	if(output == NULL){
 		output = &c;
@@ -58,23 +60,31 @@ void read_output(int fd, char *output, int len)
 	}
 		
 	*output = '\0';
-	n = os_read_file(fd, &remain, sizeof(remain));
-	if(n != sizeof(remain)){
-		printk("read_output - read of length failed, err = %d\n", -n);
-		return;
+	ret = os_read_file(fd, &remain, sizeof(remain));
+
+	if (ret != sizeof(remain)) {
+		expected = sizeof(remain);
+		str = "length";
+		goto err;
 	}
 
 	while(remain != 0){
-		n = (remain < len) ? remain : len;
-		actual = os_read_file(fd, output, n);
-		if(actual != n){
-			printk("read_output - read of data failed, "
-			       "err = %d\n", -actual);
-			return;
+		expected = (remain < len) ? remain : len;
+		ret = os_read_file(fd, output, expected);
+		if (ret != expected) {
+			str = "data";
+			goto err;
 		}
-		remain -= actual;
+		remain -= ret;
 	}
+
 	return;
+
+err:
+	if (ret < 0)
+		printk("read_output - read of %s failed, errno = %d\n", str, -ret);
+	else
+		printk("read_output - read of %s failed, read only %d of %d bytes\n", str, ret, expected);
 }
 
 int net_read(int fd, void *buf, int len)

commit ff5c6ff54215fe284e515032878111de5d8a5ce1
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Nov 7 00:58:51 2005 -0800

    [PATCH] uml: separate libc-dependent helper code
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from helper.c file under os-Linux dir
    
    Signed-off-by: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 3730d4f12713..098fa65981ab 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -16,7 +16,6 @@
 #include "user_util.h"
 #include "kern_util.h"
 #include "net_user.h"
-#include "helper.h"
 #include "os.h"
 
 int tap_open_common(void *dev, char *gate_addr)

commit da00d9a5466558ccd9e7b7d04b13d7cb9160c876
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Jun 8 15:48:01 2005 -0700

    [PATCH] uml: compile fixes for gcc 4
    
    This is a bunch of compile fixes provoked by building UML with gcc 4.  There
    are a bunch of signedness mismatches, a couple of uninitialized references,
    and a botched C99 structure initialization which had somehow gone unnoticed.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 47229fe4a813..3730d4f12713 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -32,7 +32,7 @@ int tap_open_common(void *dev, char *gate_addr)
 	return(0);
 }
 
-void tap_check_ips(char *gate_addr, char *eth_addr)
+void tap_check_ips(char *gate_addr, unsigned char *eth_addr)
 {
 	int tap_addr[4];
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
new file mode 100644
index 000000000000..47229fe4a813
--- /dev/null
+++ b/arch/um/drivers/net_user.c
@@ -0,0 +1,255 @@
+/* 
+ * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include <stddef.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include "user.h"
+#include "user_util.h"
+#include "kern_util.h"
+#include "net_user.h"
+#include "helper.h"
+#include "os.h"
+
+int tap_open_common(void *dev, char *gate_addr)
+{
+	int tap_addr[4];
+
+	if(gate_addr == NULL) return(0);
+	if(sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0], 
+		  &tap_addr[1], &tap_addr[2], &tap_addr[3]) != 4){
+		printk("Invalid tap IP address - '%s'\n", gate_addr);
+		return(-EINVAL);
+	}
+	return(0);
+}
+
+void tap_check_ips(char *gate_addr, char *eth_addr)
+{
+	int tap_addr[4];
+
+	if((gate_addr != NULL) && 
+	   (sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0], 
+		   &tap_addr[1], &tap_addr[2], &tap_addr[3]) == 4) &&
+	   (eth_addr[0] == tap_addr[0]) && 
+	   (eth_addr[1] == tap_addr[1]) && 
+	   (eth_addr[2] == tap_addr[2]) && 
+	   (eth_addr[3] == tap_addr[3])){
+		printk("The tap IP address and the UML eth IP address"
+		       " must be different\n");
+	}
+}
+
+void read_output(int fd, char *output, int len)
+{
+	int remain, n, actual;
+	char c;
+
+	if(output == NULL){
+		output = &c;
+		len = sizeof(c);
+	}
+		
+	*output = '\0';
+	n = os_read_file(fd, &remain, sizeof(remain));
+	if(n != sizeof(remain)){
+		printk("read_output - read of length failed, err = %d\n", -n);
+		return;
+	}
+
+	while(remain != 0){
+		n = (remain < len) ? remain : len;
+		actual = os_read_file(fd, output, n);
+		if(actual != n){
+			printk("read_output - read of data failed, "
+			       "err = %d\n", -actual);
+			return;
+		}
+		remain -= actual;
+	}
+	return;
+}
+
+int net_read(int fd, void *buf, int len)
+{
+	int n;
+
+	n = os_read_file(fd,  buf,  len);
+
+	if(n == -EAGAIN)
+		return(0);
+	else if(n == 0)
+		return(-ENOTCONN);
+	return(n);
+}
+
+int net_recvfrom(int fd, void *buf, int len)
+{
+	int n;
+
+	while(((n = recvfrom(fd,  buf,  len, 0, NULL, NULL)) < 0) && 
+	      (errno == EINTR)) ;
+
+	if(n < 0){
+		if(errno == EAGAIN) return(0);
+		return(-errno);
+	}
+	else if(n == 0) return(-ENOTCONN);
+	return(n);
+}
+
+int net_write(int fd, void *buf, int len)
+{
+	int n;
+
+	n = os_write_file(fd, buf, len);
+
+	if(n == -EAGAIN)
+		return(0);
+	else if(n == 0)
+		return(-ENOTCONN);
+	return(n);
+}
+
+int net_send(int fd, void *buf, int len)
+{
+	int n;
+
+	while(((n = send(fd, buf, len, 0)) < 0) && (errno == EINTR)) ;
+	if(n < 0){
+		if(errno == EAGAIN) return(0);
+		return(-errno);
+	}
+	else if(n == 0) return(-ENOTCONN);
+	return(n);	
+}
+
+int net_sendto(int fd, void *buf, int len, void *to, int sock_len)
+{
+	int n;
+
+	while(((n = sendto(fd, buf, len, 0, (struct sockaddr *) to,
+			   sock_len)) < 0) && (errno == EINTR)) ;
+	if(n < 0){
+		if(errno == EAGAIN) return(0);
+		return(-errno);
+	}
+	else if(n == 0) return(-ENOTCONN);
+	return(n);	
+}
+
+struct change_pre_exec_data {
+	int close_me;
+	int stdout;
+};
+
+static void change_pre_exec(void *arg)
+{
+	struct change_pre_exec_data *data = arg;
+
+	os_close_file(data->close_me);
+	dup2(data->stdout, 1);
+}
+
+static int change_tramp(char **argv, char *output, int output_len)
+{
+	int pid, fds[2], err;
+	struct change_pre_exec_data pe_data;
+
+	err = os_pipe(fds, 1, 0);
+	if(err < 0){
+		printk("change_tramp - pipe failed, err = %d\n", -err);
+		return(err);
+	}
+	pe_data.close_me = fds[0];
+	pe_data.stdout = fds[1];
+	pid = run_helper(change_pre_exec, &pe_data, argv, NULL);
+
+	read_output(fds[0], output, output_len);
+	os_close_file(fds[0]);
+	os_close_file(fds[1]);
+
+	if (pid > 0)
+		CATCH_EINTR(err = waitpid(pid, NULL, 0));
+	return(pid);
+}
+
+static void change(char *dev, char *what, unsigned char *addr,
+		   unsigned char *netmask)
+{
+	char addr_buf[sizeof("255.255.255.255\0")];
+	char netmask_buf[sizeof("255.255.255.255\0")];
+	char version[sizeof("nnnnn\0")];
+	char *argv[] = { "uml_net", version, what, dev, addr_buf, 
+			 netmask_buf, NULL };
+	char *output;
+	int output_len, pid;
+
+	sprintf(version, "%d", UML_NET_VERSION);
+	sprintf(addr_buf, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]);
+	sprintf(netmask_buf, "%d.%d.%d.%d", netmask[0], netmask[1], 
+		netmask[2], netmask[3]);
+
+	output_len = page_size();
+	output = um_kmalloc(output_len);
+	if(output == NULL)
+		printk("change : failed to allocate output buffer\n");
+
+	pid = change_tramp(argv, output, output_len);
+	if(pid < 0) return;
+
+	if(output != NULL){
+		printk("%s", output);
+		kfree(output);
+	}
+}
+
+void open_addr(unsigned char *addr, unsigned char *netmask, void *arg)
+{
+	change(arg, "add", addr, netmask);
+}
+
+void close_addr(unsigned char *addr, unsigned char *netmask, void *arg)
+{
+	change(arg, "del", addr, netmask);
+}
+
+char *split_if_spec(char *str, ...)
+{
+	char **arg, *end;
+	va_list ap;
+
+	va_start(ap, str);
+	while((arg = va_arg(ap, char **)) != NULL){
+		if(*str == '\0')
+			return(NULL);
+		end = strchr(str, ',');
+		if(end != str)
+			*arg = str;
+		if(end == NULL)
+			return(NULL);
+		*end++ = '\0';
+		str = end;
+	}
+	va_end(ap);
+	return(str);
+}
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
