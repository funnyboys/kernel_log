commit dbddf429dc514257170d4c5e116cbd95a86408ab
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:16 2019 +0100

    um: Add SPDX headers for files in arch/um/drivers
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 20e30be44795..fc7f1e746703 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
- * Licensed under the GPL
  */
 
 #include <stddef.h>

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 969110e56487..20e30be44795 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -11,8 +11,8 @@
 #include <string.h>
 #include <termios.h>
 #include "chan_user.h"
-#include "os.h"
-#include "um_malloc.h"
+#include <os.h>
+#include <um_malloc.h>
 #include "xterm.h"
 
 struct xterm_chan {

commit 078073a3d48ce7c140f1538d249da3ac545065a6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Aug 18 20:01:29 2011 +0100

    um: -include user.h for USER_OBJ, trim includes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 2e1de5728604..969110e56487 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -11,10 +11,8 @@
 #include <string.h>
 #include <termios.h>
 #include "chan_user.h"
-#include "kern_constants.h"
 #include "os.h"
 #include "um_malloc.h"
-#include "user.h"
 #include "xterm.h"
 
 struct xterm_chan {

commit b40997b872cdb70140f127af6069f00a86b6cf81
Author: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
Date:   Wed Sep 14 16:21:20 2011 -0700

    um: drivers/xterm.c: fix a file descriptor leak
    
    I could use out_close1, but that seems to be the code path to close the fd
    returned by os_create_unix_socket, and using it to close the fd returned
    by mkstemp might lead to some confusion, so I don't do it.
    
    Signed-off-by: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 8ac7146c237f..2e1de5728604 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -123,6 +123,7 @@ static int xterm_open(int input, int output, int primary, void *d,
 		err = -errno;
 		printk(UM_KERN_ERR "xterm_open : unlink failed, errno = %d\n",
 		       errno);
+		close(fd);
 		return err;
 	}
 	close(fd);

commit 0ce451acb1872eab0fcf22753f93f51567e812fa
Author: Richard Weinberger <richard@nod.at>
Date:   Tue May 24 17:13:00 2011 -0700

    um: fix UML_LIB_PATH
    
    UML_LIB_PATH is hardcoded to /usr/lib/uml/, on 64bit systems UML_LIB_PATH
    needs to be /usr/lib64/uml/.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index da2caa5a21ef..8ac7146c237f 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -90,7 +90,7 @@ static int xterm_open(int input, int output, int primary, void *d,
 	int pid, fd, new, err;
 	char title[256], file[] = "/tmp/xterm-pipeXXXXXX";
 	char *argv[] = { terminal_emulator, title_switch, title, exec_switch,
-			 "/usr/lib/uml/port-helper", "-uml-socket",
+			 OS_LIB_PATH "/uml/port-helper", "-uml-socket",
 			 file, NULL };
 
 	if (access(argv[4], X_OK) < 0)

commit 43f5b3085fdd27c4edf535d938b2cb0ccead4f75
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 12 14:01:52 2008 -0700

    uml: fix build when SLOB is enabled
    
    Reintroduce uml_kmalloc for the benefit of UML libc code.  The
    previous tactic of declaring __kmalloc so it could be called directly
    from the libc side of the house turned out to be getting too intimate
    with slab, and it doesn't work with slob.
    
    So, the uml_kmalloc wrapper is back.  It calls kmalloc or whatever
    that translates into, and libc code calls it.
    
    kfree is left alone since that still works, leaving a somewhat
    inconsistent API.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 8a1c18a9b240..da2caa5a21ef 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -30,7 +30,7 @@ static void *xterm_init(char *str, int device, const struct chan_opts *opts)
 {
 	struct xterm_chan *data;
 
-	data = kmalloc(sizeof(*data), UM_GFP_KERNEL);
+	data = uml_kmalloc(sizeof(*data), UM_GFP_KERNEL);
 	if (data == NULL)
 		return NULL;
 	*data = ((struct xterm_chan) { .pid 		= -1,

commit cb8fa61c2b8b29d422d7310f064d60022f18f89b
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:34 2007 -0700

    uml: arch/um/drivers formatting
    
    Style fixes for the rest of the drivers.  arch/um/drivers should be pretty
    CodingStyle-compliant now.
    
    Except for the ubd driver, which will have to be treated separately.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 87e18bf2c667..8a1c18a9b240 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -1,11 +1,11 @@
-/* 
+/*
  * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
 #include <stddef.h>
-#include <stdlib.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
@@ -96,8 +96,10 @@ static int xterm_open(int input, int output, int primary, void *d,
 	if (access(argv[4], X_OK) < 0)
 		argv[4] = "port-helper";
 
-	/* Check that DISPLAY is set, this doesn't guarantee the xterm
-	 * will work but w/o it we can be pretty sure it won't. */
+	/*
+	 * Check that DISPLAY is set, this doesn't guarantee the xterm
+	 * will work but w/o it we can be pretty sure it won't.
+	 */
 	if (getenv("DISPLAY") == NULL) {
 		printk(UM_KERN_ERR "xterm_open: $DISPLAY not set.\n");
 		return -ENODEV;
@@ -196,7 +198,7 @@ static int xterm_open(int input, int output, int primary, void *d,
 static void xterm_close(int fd, void *d)
 {
 	struct xterm_chan *data = d;
-	
+
 	if (data->pid != -1)
 		os_kill_process(data->pid, 1);
 	data->pid = -1;

commit e99525f9706900417f37721e601d2b414d41bfee
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:41 2007 -0700

    uml: console subsystem tidying
    
    This does a lot of cleanup on the UML console system.  This patch should be
    entirely non-functional.
    
    The tidying is as follows:
            header cleanups - the includes should be closer to minimal and complete
            all printks now have a severity
            lots of style fixes
            fd_close is restructured a little in order to reduce the nesting
            some functions were calling the os_* wrappers when they can
    call libc directly
            port_accept had a unnecessary variable
            it also tested a pid unecessarily before killing it
            some functions were made static
            xterm_free is gone, as it was identical to generic_free
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index fd817e541543..87e18bf2c667 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -3,18 +3,19 @@
  * Licensed under the GPL
  */
 
+#include <stddef.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <string.h>
 #include <errno.h>
+#include <string.h>
 #include <termios.h>
 #include "chan_user.h"
+#include "kern_constants.h"
 #include "os.h"
-#include "init.h"
+#include "um_malloc.h"
 #include "user.h"
 #include "xterm.h"
-#include "kern_constants.h"
 
 struct xterm_chan {
 	int pid;
@@ -29,7 +30,7 @@ static void *xterm_init(char *str, int device, const struct chan_opts *opts)
 {
 	struct xterm_chan *data;
 
-	data = malloc(sizeof(*data));
+	data = kmalloc(sizeof(*data), UM_GFP_KERNEL);
 	if (data == NULL)
 		return NULL;
 	*data = ((struct xterm_chan) { .pid 		= -1,
@@ -207,11 +208,6 @@ static void xterm_close(int fd, void *d)
 	os_close_file(fd);
 }
 
-static void xterm_free(void *d)
-{
-	free(d);
-}
-
 const struct chan_ops xterm_ops = {
 	.type		= "xterm",
 	.init		= xterm_init,
@@ -221,6 +217,6 @@ const struct chan_ops xterm_ops = {
 	.write		= generic_write,
 	.console_write	= generic_console_write,
 	.window_size	= generic_window_size,
-	.free		= xterm_free,
+	.free		= generic_free,
 	.winch		= 1,
 };

commit c43990162fc7f9d2f15a12797fdc6f9c0905f704
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:56 2007 -0700

    uml: simplify helper stack handling
    
    run_helper and run_helper_thread had arguments which were the same in all
    callers.  run_helper's stack_out was always NULL and run_helper_thread's
    stack_order was always 0.  These are now gone, and the constants folded
    into the code.
    
    Also fixed leaks of the helper stack in the AIO and SIGIO code.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 35912846ed21..fd817e541543 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -132,7 +132,7 @@ static int xterm_open(int input, int output, int primary, void *d,
 	}
 
 	sprintf(title, data->title, data->device);
-	pid = run_helper(NULL, NULL, argv, NULL);
+	pid = run_helper(NULL, NULL, argv);
 	if (pid < 0) {
 		err = pid;
 		printk(UM_KERN_ERR "xterm_open : run_helper failed, "

commit 63920f4717924206c3fa23d42645d4f8965de4cd
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun Jul 15 23:38:52 2007 -0700

    uml: xterm driver tidying
    
    Major tidying of the xterm console driver:
            got rid of the tt-mode gdb support
            tidied up the includes
            fixed lots of style violations
            replaced os_* calls with glibc calls in xterm.c
            all printk calls now have a severity indicator
            the error paths of xterm_open are closer to being right
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index fe238e03a300..35912846ed21 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -1,22 +1,20 @@
 /* 
- * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
  * Licensed under the GPL
  */
 
-#include <stdio.h>
 #include <stdlib.h>
+#include <stdio.h>
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
 #include <termios.h>
-#include <signal.h>
-#include <sched.h>
-#include <sys/socket.h>
-#include "kern_util.h"
 #include "chan_user.h"
-#include "user.h"
 #include "os.h"
+#include "init.h"
+#include "user.h"
 #include "xterm.h"
+#include "kern_constants.h"
 
 struct xterm_chan {
 	int pid;
@@ -25,25 +23,21 @@ struct xterm_chan {
 	int device;
 	int raw;
 	struct termios tt;
-	unsigned long stack;
-	int direct_rcv;
 };
 
-/* Not static because it's called directly by the tt mode gdb code */
-void *xterm_init(char *str, int device, const struct chan_opts *opts)
+static void *xterm_init(char *str, int device, const struct chan_opts *opts)
 {
 	struct xterm_chan *data;
 
 	data = malloc(sizeof(*data));
-	if(data == NULL) return(NULL);
-	*data = ((struct xterm_chan) { .pid 		= -1, 
+	if (data == NULL)
+		return NULL;
+	*data = ((struct xterm_chan) { .pid 		= -1,
 				       .helper_pid 	= -1,
-				       .device 		= device, 
+				       .device 		= device,
 				       .title 		= opts->xterm_title,
-				       .raw  		= opts->raw,
-				       .stack 		= opts->tramp_stack,
-				       .direct_rcv 	= !opts->in_kernel } );
-	return(data);
+				       .raw  		= opts->raw } );
+	return data;
 }
 
 /* Only changed by xterm_setup, which is a setup */
@@ -57,16 +51,22 @@ static int __init xterm_setup(char *line, int *add)
 	terminal_emulator = line;
 
 	line = strchr(line, ',');
-	if(line == NULL) return(0);
+	if (line == NULL)
+		return 0;
+
 	*line++ = '\0';
-	if(*line) title_switch = line;
+	if (*line)
+		title_switch = line;
 
 	line = strchr(line, ',');
-	if(line == NULL) return(0);
+	if (line == NULL)
+		return 0;
+
 	*line++ = '\0';
-	if(*line) exec_switch = line;
+	if (*line)
+		exec_switch = line;
 
-	return(0);
+	return 0;
 }
 
 __uml_setup("xterm=", xterm_setup,
@@ -82,114 +82,128 @@ __uml_setup("xterm=", xterm_setup,
 "    are 'xterm=gnome-terminal,-t,-x'.\n\n"
 );
 
-/* XXX This badly needs some cleaning up in the error paths
- * Not static because it's called directly by the tt mode gdb code
- */
-int xterm_open(int input, int output, int primary, void *d,
+static int xterm_open(int input, int output, int primary, void *d,
 		      char **dev_out)
 {
 	struct xterm_chan *data = d;
-	unsigned long stack;
 	int pid, fd, new, err;
 	char title[256], file[] = "/tmp/xterm-pipeXXXXXX";
-	char *argv[] = { terminal_emulator, title_switch, title, exec_switch, 
+	char *argv[] = { terminal_emulator, title_switch, title, exec_switch,
 			 "/usr/lib/uml/port-helper", "-uml-socket",
 			 file, NULL };
 
-	if(os_access(argv[4], OS_ACC_X_OK) < 0)
+	if (access(argv[4], X_OK) < 0)
 		argv[4] = "port-helper";
 
 	/* Check that DISPLAY is set, this doesn't guarantee the xterm
 	 * will work but w/o it we can be pretty sure it won't. */
-	if (!getenv("DISPLAY")) {
-		printk("xterm_open: $DISPLAY not set.\n");
+	if (getenv("DISPLAY") == NULL) {
+		printk(UM_KERN_ERR "xterm_open: $DISPLAY not set.\n");
 		return -ENODEV;
 	}
 
+	/*
+	 * This business of getting a descriptor to a temp file,
+	 * deleting the file and closing the descriptor is just to get
+	 * a known-unused name for the Unix socket that we really
+	 * want.
+	 */
 	fd = mkstemp(file);
-	if(fd < 0){
+	if (fd < 0) {
 		err = -errno;
-		printk("xterm_open : mkstemp failed, errno = %d\n", errno);
+		printk(UM_KERN_ERR "xterm_open : mkstemp failed, errno = %d\n",
+		       errno);
 		return err;
 	}
 
-	if(unlink(file)){
+	if (unlink(file)) {
 		err = -errno;
-		printk("xterm_open : unlink failed, errno = %d\n", errno);
+		printk(UM_KERN_ERR "xterm_open : unlink failed, errno = %d\n",
+		       errno);
 		return err;
 	}
-	os_close_file(fd);
+	close(fd);
 
 	fd = os_create_unix_socket(file, sizeof(file), 1);
-	if(fd < 0){
-		printk("xterm_open : create_unix_socket failed, errno = %d\n", 
-		       -fd);
-		return(fd);
+	if (fd < 0) {
+		printk(UM_KERN_ERR "xterm_open : create_unix_socket failed, "
+		       "errno = %d\n", -fd);
+		return fd;
 	}
 
 	sprintf(title, data->title, data->device);
-	stack = data->stack;
-	pid = run_helper(NULL, NULL, argv, &stack);
-	if(pid < 0){
-		printk("xterm_open : run_helper failed, errno = %d\n", -pid);
-		return(pid);
+	pid = run_helper(NULL, NULL, argv, NULL);
+	if (pid < 0) {
+		err = pid;
+		printk(UM_KERN_ERR "xterm_open : run_helper failed, "
+		       "errno = %d\n", -err);
+		goto out_close1;
 	}
 
-	if (data->direct_rcv) {
-		new = os_rcv_fd(fd, &data->helper_pid);
-	} else {
-		err = os_set_fd_block(fd, 0);
-		if(err < 0){
-			printk("xterm_open : failed to set descriptor "
-			       "non-blocking, err = %d\n", -err);
-			return(err);
-		}
-		new = xterm_fd(fd, &data->helper_pid);
+	err = os_set_fd_block(fd, 0);
+	if (err < 0) {
+		printk(UM_KERN_ERR "xterm_open : failed to set descriptor "
+		       "non-blocking, err = %d\n", -err);
+		goto out_kill;
 	}
-	if(new < 0){
-		printk("xterm_open : os_rcv_fd failed, err = %d\n", -new);
-		goto out;
+
+	new = xterm_fd(fd, &data->helper_pid);
+	if (new < 0) {
+		err = new;
+		printk(UM_KERN_ERR "xterm_open : os_rcv_fd failed, err = %d\n",
+		       -err);
+		goto out_kill;
 	}
 
 	err = os_set_fd_block(new, 0);
 	if (err) {
-		printk("xterm_open : failed to set xterm descriptor "
-		       "non-blocking, err = %d\n", -err);
-		goto out;
+		printk(UM_KERN_ERR "xterm_open : failed to set xterm "
+		       "descriptor non-blocking, err = %d\n", -err);
+		goto out_close2;
 	}
 
 	CATCH_EINTR(err = tcgetattr(new, &data->tt));
-	if(err){
+	if (err) {
 		new = err;
-		goto out;
+		goto out_close2;
 	}
 
-	if(data->raw){
+	if (data->raw) {
 		err = raw(new);
-		if(err){
+		if (err) {
 			new = err;
-			goto out;
+			goto out_close2;
 		}
 	}
 
+	unlink(file);
 	data->pid = pid;
 	*dev_out = NULL;
- out:
-	unlink(file);
-	return(new);
+
+	return new;
+
+ out_close2:
+	close(new);
+ out_kill:
+	os_kill_process(pid, 1);
+ out_close1:
+	close(fd);
+
+	return err;
 }
 
-/* Not static because it's called directly by the tt mode gdb code */
-void xterm_close(int fd, void *d)
+static void xterm_close(int fd, void *d)
 {
 	struct xterm_chan *data = d;
 	
-	if(data->pid != -1) 
+	if (data->pid != -1)
 		os_kill_process(data->pid, 1);
 	data->pid = -1;
-	if(data->helper_pid != -1) 
+
+	if (data->helper_pid != -1)
 		os_kill_process(data->helper_pid, 0);
 	data->helper_pid = -1;
+
 	os_close_file(fd);
 }
 
@@ -210,14 +224,3 @@ const struct chan_ops xterm_ops = {
 	.free		= xterm_free,
 	.winch		= 1,
 };
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit 89df6bfc04059716de2eb2fe529f05b3e124fafd
Author: Eduard-Gabriel Munteanu <maxdamage@aladin.ro>
Date:   Sun Jul 15 23:38:51 2007 -0700

    uml: DEBUG_SHIRQ fixes
    
    DEBUG_SHIRQ generates spurious interrupts, triggering handlers such as
    mconsole_interrupt() or line_interrupt().  They expect data to be available to
    be read from their sockets/pipes, but in the case of spurious interrupts, the
    host didn't actually send anything, so UML hangs in read() and friends.
    Setting those fd's as O_NONBLOCK makes DEBUG_SHIRQ-enabled UML kernels boot
    and run correctly.
    
    Signed-off-by: Eduard-Gabriel Munteanu <maxdamage@aladin.ro>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 571c2b3325d5..fe238e03a300 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -151,6 +151,13 @@ int xterm_open(int input, int output, int primary, void *d,
 		goto out;
 	}
 
+	err = os_set_fd_block(new, 0);
+	if (err) {
+		printk("xterm_open : failed to set xterm descriptor "
+		       "non-blocking, err = %d\n", -err);
+		goto out;
+	}
+
 	CATCH_EINTR(err = tcgetattr(new, &data->tt));
 	if(err){
 		new = err;

commit 9218b1714949095bff9d9739d80f431d58e561d6
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:10 2007 -0700

    uml: remove user_util.h
    
    user_util.h isn't needed any more, so delete it and remove all includes of it.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 850221d9b4c9..571c2b3325d5 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -14,7 +14,6 @@
 #include <sys/socket.h>
 #include "kern_util.h"
 #include "chan_user.h"
-#include "user_util.h"
 #include "user.h"
 #include "os.h"
 #include "xterm.h"

commit d9d645f06a8f50659bbae2be64ed8367ba068fc0
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Thu Oct 19 23:28:24 2006 -0700

    [PATCH] uml: cleanup run_helper() API to fix a leak
    
    Freeing the stack is left uselessly to the caller of run_helper in some cases
    - this is taken from run_helper_thread, but here it is useless, so no caller
    needs it and the only place where this happens has a potential leak - in case
    of error neither run_helper() nor xterm_open() call free_stack().  At this
    point passing a pointer is not needed - the stack pointer should be passed
    directly, but this change is not done here.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 386f8b952982..850221d9b4c9 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -136,8 +136,6 @@ int xterm_open(int input, int output, int primary, void *d,
 		return(pid);
 	}
 
-	if(data->stack == 0) free_stack(stack, 0);
-
 	if (data->direct_rcv) {
 		new = os_rcv_fd(fd, &data->helper_pid);
 	} else {

commit 5e7672ec3f059f764fcc5c78216e24bb16c44dba
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Sep 27 01:50:33 2006 -0700

    [PATCH] uml: const more data
    
    Make lots of structures const in order to make it obvious that they need no
    locking.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index aaa636661043..386f8b952982 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -31,7 +31,7 @@ struct xterm_chan {
 };
 
 /* Not static because it's called directly by the tt mode gdb code */
-void *xterm_init(char *str, int device, struct chan_opts *opts)
+void *xterm_init(char *str, int device, const struct chan_opts *opts)
 {
 	struct xterm_chan *data;
 
@@ -194,7 +194,7 @@ static void xterm_free(void *d)
 	free(d);
 }
 
-struct chan_ops xterm_ops = {
+const struct chan_ops xterm_ops = {
 	.type		= "xterm",
 	.init		= xterm_init,
 	.open		= xterm_open,

commit fd9bc53b99a77aefe89d810d889aa6385565959b
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Sun Nov 13 16:07:10 2005 -0800

    [PATCH] uml console channels: remove console_write wrappers
    
    We were using a long series of (stupid) wrappers which all call
    generic_console_write().  Since the wrappers only change the 4th param, which
    is unused by the called proc, remove them and call generic_console_write()
    directly.
    
    If needed at any time in the future to reintroduce this stuff, the member
    could be moved to a generic struct, to avoid this duplicated handling.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Acked-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index b530f1a6540d..aaa636661043 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -194,13 +194,6 @@ static void xterm_free(void *d)
 	free(d);
 }
 
-static int xterm_console_write(int fd, const char *buf, int n, void *d)
-{
-	struct xterm_chan *data = d;
-
-	return(generic_console_write(fd, buf, n, &data->tt));
-}
-
 struct chan_ops xterm_ops = {
 	.type		= "xterm",
 	.init		= xterm_init,
@@ -208,7 +201,7 @@ struct chan_ops xterm_ops = {
 	.close		= xterm_close,
 	.read		= generic_read,
 	.write		= generic_write,
-	.console_write	= xterm_console_write,
+	.console_write	= generic_console_write,
 	.window_size	= generic_window_size,
 	.free		= xterm_free,
 	.winch		= 1,

commit ff5c6ff54215fe284e515032878111de5d8a5ce1
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Nov 7 00:58:51 2005 -0800

    [PATCH] uml: separate libc-dependent helper code
    
    The serial UML OS-abstraction layer patch (um/kernel dir).
    
    This moves all systemcalls from helper.c file under os-Linux dir
    
    Signed-off-by: Gennady Sharapov <Gennady.V.Sharapov@intel.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 90e0e5ff451e..b530f1a6540d 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -14,7 +14,6 @@
 #include <sys/socket.h>
 #include "kern_util.h"
 #include "chan_user.h"
-#include "helper.h"
 #include "user_util.h"
 #include "user.h"
 #include "os.h"

commit b4fd310e163477236a241580b3b8c29aee65f4cc
Author: Jeff Dike <jdike@addtoit.com>
Date:   Fri Sep 16 19:27:49 2005 -0700

    [PATCH] uml: preserve errno in error paths
    
    The poster child for this patch is the third tuntap_user hunk.  When an ioctl
    fails, it properly closes the opened file descriptor and returns.  However,
    the close resets errno to 0, and the 'return errno' that follows returns 0
    rather than the value that ioctl set.  This caused the caller to believe that
    the device open succeeded and had opened file descriptor 0, which caused no
    end of interesting behavior.
    
    The rest of this patch is a pass through the UML sources looking for places
    where errno could be reset before being passed back out.  A common culprit is
    printk, which could call write, being called before errno is returned.
    
    In some cases, where the code ends up being much smaller, I just deleted the
    printk.
    
    There was another case where a caller of run_helper looked at errno after a
    failure, rather than the return value of run_helper, which was the errno value
    that it wanted.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
index 93dc1911363f..90e0e5ff451e 100644
--- a/arch/um/drivers/xterm.c
+++ b/arch/um/drivers/xterm.c
@@ -110,13 +110,15 @@ int xterm_open(int input, int output, int primary, void *d,
 
 	fd = mkstemp(file);
 	if(fd < 0){
+		err = -errno;
 		printk("xterm_open : mkstemp failed, errno = %d\n", errno);
-		return(-errno);
+		return err;
 	}
 
 	if(unlink(file)){
+		err = -errno;
 		printk("xterm_open : unlink failed, errno = %d\n", errno);
-		return(-errno);
+		return err;
 	}
 	os_close_file(fd);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/drivers/xterm.c b/arch/um/drivers/xterm.c
new file mode 100644
index 000000000000..93dc1911363f
--- /dev/null
+++ b/arch/um/drivers/xterm.c
@@ -0,0 +1,225 @@
+/* 
+ * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <termios.h>
+#include <signal.h>
+#include <sched.h>
+#include <sys/socket.h>
+#include "kern_util.h"
+#include "chan_user.h"
+#include "helper.h"
+#include "user_util.h"
+#include "user.h"
+#include "os.h"
+#include "xterm.h"
+
+struct xterm_chan {
+	int pid;
+	int helper_pid;
+	char *title;
+	int device;
+	int raw;
+	struct termios tt;
+	unsigned long stack;
+	int direct_rcv;
+};
+
+/* Not static because it's called directly by the tt mode gdb code */
+void *xterm_init(char *str, int device, struct chan_opts *opts)
+{
+	struct xterm_chan *data;
+
+	data = malloc(sizeof(*data));
+	if(data == NULL) return(NULL);
+	*data = ((struct xterm_chan) { .pid 		= -1, 
+				       .helper_pid 	= -1,
+				       .device 		= device, 
+				       .title 		= opts->xterm_title,
+				       .raw  		= opts->raw,
+				       .stack 		= opts->tramp_stack,
+				       .direct_rcv 	= !opts->in_kernel } );
+	return(data);
+}
+
+/* Only changed by xterm_setup, which is a setup */
+static char *terminal_emulator = "xterm";
+static char *title_switch = "-T";
+static char *exec_switch = "-e";
+
+static int __init xterm_setup(char *line, int *add)
+{
+	*add = 0;
+	terminal_emulator = line;
+
+	line = strchr(line, ',');
+	if(line == NULL) return(0);
+	*line++ = '\0';
+	if(*line) title_switch = line;
+
+	line = strchr(line, ',');
+	if(line == NULL) return(0);
+	*line++ = '\0';
+	if(*line) exec_switch = line;
+
+	return(0);
+}
+
+__uml_setup("xterm=", xterm_setup,
+"xterm=<terminal emulator>,<title switch>,<exec switch>\n"
+"    Specifies an alternate terminal emulator to use for the debugger,\n"
+"    consoles, and serial lines when they are attached to the xterm channel.\n"
+"    The values are the terminal emulator binary, the switch it uses to set\n"
+"    its title, and the switch it uses to execute a subprocess,\n"
+"    respectively.  The title switch must have the form '<switch> title',\n"
+"    not '<switch>=title'.  Similarly, the exec switch must have the form\n"
+"    '<switch> command arg1 arg2 ...'.\n"
+"    The default values are 'xterm=xterm,-T,-e'.  Values for gnome-terminal\n"
+"    are 'xterm=gnome-terminal,-t,-x'.\n\n"
+);
+
+/* XXX This badly needs some cleaning up in the error paths
+ * Not static because it's called directly by the tt mode gdb code
+ */
+int xterm_open(int input, int output, int primary, void *d,
+		      char **dev_out)
+{
+	struct xterm_chan *data = d;
+	unsigned long stack;
+	int pid, fd, new, err;
+	char title[256], file[] = "/tmp/xterm-pipeXXXXXX";
+	char *argv[] = { terminal_emulator, title_switch, title, exec_switch, 
+			 "/usr/lib/uml/port-helper", "-uml-socket",
+			 file, NULL };
+
+	if(os_access(argv[4], OS_ACC_X_OK) < 0)
+		argv[4] = "port-helper";
+
+	/* Check that DISPLAY is set, this doesn't guarantee the xterm
+	 * will work but w/o it we can be pretty sure it won't. */
+	if (!getenv("DISPLAY")) {
+		printk("xterm_open: $DISPLAY not set.\n");
+		return -ENODEV;
+	}
+
+	fd = mkstemp(file);
+	if(fd < 0){
+		printk("xterm_open : mkstemp failed, errno = %d\n", errno);
+		return(-errno);
+	}
+
+	if(unlink(file)){
+		printk("xterm_open : unlink failed, errno = %d\n", errno);
+		return(-errno);
+	}
+	os_close_file(fd);
+
+	fd = os_create_unix_socket(file, sizeof(file), 1);
+	if(fd < 0){
+		printk("xterm_open : create_unix_socket failed, errno = %d\n", 
+		       -fd);
+		return(fd);
+	}
+
+	sprintf(title, data->title, data->device);
+	stack = data->stack;
+	pid = run_helper(NULL, NULL, argv, &stack);
+	if(pid < 0){
+		printk("xterm_open : run_helper failed, errno = %d\n", -pid);
+		return(pid);
+	}
+
+	if(data->stack == 0) free_stack(stack, 0);
+
+	if (data->direct_rcv) {
+		new = os_rcv_fd(fd, &data->helper_pid);
+	} else {
+		err = os_set_fd_block(fd, 0);
+		if(err < 0){
+			printk("xterm_open : failed to set descriptor "
+			       "non-blocking, err = %d\n", -err);
+			return(err);
+		}
+		new = xterm_fd(fd, &data->helper_pid);
+	}
+	if(new < 0){
+		printk("xterm_open : os_rcv_fd failed, err = %d\n", -new);
+		goto out;
+	}
+
+	CATCH_EINTR(err = tcgetattr(new, &data->tt));
+	if(err){
+		new = err;
+		goto out;
+	}
+
+	if(data->raw){
+		err = raw(new);
+		if(err){
+			new = err;
+			goto out;
+		}
+	}
+
+	data->pid = pid;
+	*dev_out = NULL;
+ out:
+	unlink(file);
+	return(new);
+}
+
+/* Not static because it's called directly by the tt mode gdb code */
+void xterm_close(int fd, void *d)
+{
+	struct xterm_chan *data = d;
+	
+	if(data->pid != -1) 
+		os_kill_process(data->pid, 1);
+	data->pid = -1;
+	if(data->helper_pid != -1) 
+		os_kill_process(data->helper_pid, 0);
+	data->helper_pid = -1;
+	os_close_file(fd);
+}
+
+static void xterm_free(void *d)
+{
+	free(d);
+}
+
+static int xterm_console_write(int fd, const char *buf, int n, void *d)
+{
+	struct xterm_chan *data = d;
+
+	return(generic_console_write(fd, buf, n, &data->tt));
+}
+
+struct chan_ops xterm_ops = {
+	.type		= "xterm",
+	.init		= xterm_init,
+	.open		= xterm_open,
+	.close		= xterm_close,
+	.read		= generic_read,
+	.write		= generic_write,
+	.console_write	= xterm_console_write,
+	.window_size	= generic_window_size,
+	.free		= xterm_free,
+	.winch		= 1,
+};
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
