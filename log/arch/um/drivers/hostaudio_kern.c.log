commit 2022ca0a940a1625904bfff6879dc8732171d089
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 6 22:54:38 2018 +0200

    compat_ioctl: remove translation for sound ioctls
    
    The SNDCTL_* and SOUND_* commands are the old OSS user interface.
    
    I checked all the sound ioctl commands listed in fs/compat_ioctl.c
    to see if we still need the translation handlers. Here is what I
    found:
    
    - sound/oss/ is (almost) gone from the kernel, this is what actually
      needed all the translations
    - The ALSA emulation for OSS correctly handles all compat_ioctl
      commands already.
    - sound/oss/dmasound/ is the last holdout of the original OSS code,
      this is only used on arch/m68k, which has no 64-bit mode and
      hence needs no compat handlers
    - arch/um/drivers/hostaudio_kern.c may run in 64-bit mode with
      32-bit x86 user space underneath it. This rare corner case is
      the only one that still needs the compat handlers.
    
    By adding a simple redirect of .compat_ioctl to .unlocked_ioctl in the
    UML driver, we can remove all the COMPATIBLE_IOCTL() annotations without
    a change in functionality. For completeness, I'm adding the same thing
    to the dmasound file, knowing that it makes no difference.
    
    The compat_ioctl list contains one comment about SNDCTL_DSP_MAPINBUF and
    SNDCTL_DSP_MAPOUTBUF, which actually would need a translation handler
    if implemented. However, the native implementation just returns -EINVAL,
    so we don't care.
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index bf75b1ceac47..d35d3f305a31 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -298,6 +298,7 @@ static const struct file_operations hostaudio_fops = {
 	.write          = hostaudio_write,
 	.poll           = hostaudio_poll,
 	.unlocked_ioctl	= hostaudio_ioctl,
+	.compat_ioctl	= compat_ptr_ioctl,
 	.mmap           = NULL,
 	.open           = hostaudio_open,
 	.release        = hostaudio_release,

commit dbddf429dc514257170d4c5e116cbd95a86408ab
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:16 2019 +0100

    um: Add SPDX headers for files in arch/um/drivers
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 7f9dbdbc4eb7..bf75b1ceac47 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 Steve Schmidtke
- * Licensed under the GPL
  */
 
 #include <linux/fs.h>

commit 76d2d4a11b877e9f10f3d494180ec9a6f01f0857
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 22:59:49 2017 -0400

    um: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 12bdb5996bf5..7f9dbdbc4eb7 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -119,10 +119,10 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 	return err;
 }
 
-static unsigned int hostaudio_poll(struct file *file,
-				   struct poll_table_struct *wait)
+static __poll_t hostaudio_poll(struct file *file,
+				struct poll_table_struct *wait)
 {
-	unsigned int mask = 0;
+	__poll_t mask = 0;
 
 #ifdef DEBUG
 	printk(KERN_DEBUG "hostaudio: poll called (unimplemented)\n");

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 3a4b58730f5f..12bdb5996bf5 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -9,7 +9,7 @@
 #include <linux/sound.h>
 #include <linux/soundcard.h>
 #include <linux/mutex.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <init.h>
 #include <os.h>
 

commit 1ceb36285c256347ffa062b7b1b593f801b6697b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 2 14:50:51 2016 -0500

    [um] hostaudio: don't open-code memdup_user()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index f6b911cc3923..3a4b58730f5f 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -105,13 +105,9 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 	printk(KERN_DEBUG "hostaudio: write called, count = %d\n", count);
 #endif
 
-	kbuf = kmalloc(count, GFP_KERNEL);
-	if (kbuf == NULL)
-		return -ENOMEM;
-
-	err = -EFAULT;
-	if (copy_from_user(kbuf, buffer, count))
-		goto out;
+	kbuf = memdup_user(buffer, count);
+	if (IS_ERR(kbuf))
+		return PTR_ERR(kbuf);
 
 	err = os_write_file(state->fd, kbuf, count);
 	if (err < 0)

commit b51d23e4e9fea6f264d39535c2a62d1f51e7ccc3
Author: Dan Streetman <ddstreet@ieee.org>
Date:   Wed Jun 17 06:18:52 2015 +0930

    module: add per-module param_lock
    
    Add a "param_lock" mutex to each module, and update params.c to use
    the correct built-in or module mutex while locking kernel params.
    Remove the kparam_block_sysfs_r/w() macros, replace them with direct
    calls to kernel_param_[un]lock(module).
    
    The kernel param code currently uses a single mutex to protect
    modification of any and all kernel params.  While this generally works,
    there is one specific problem with it; a module callback function
    cannot safely load another module, i.e. with request_module() or even
    with indirect calls such as crypto_has_alg().  If the module to be
    loaded has any of its params configured (e.g. with a /etc/modprobe.d/*
    config file), then the attempt will result in a deadlock between the
    first module param callback waiting for modprobe, and modprobe trying to
    lock the single kernel param mutex to set the new module's param.
    
    This fixes that by using per-module mutexes, so that each individual module
    is protected against concurrent changes in its own kernel params, but is
    not blocked by changes to other module params.  All built-in modules
    continue to use the built-in mutex, since they will always be loaded at
    runtime and references (e.g. request_module(), crypto_has_alg()) to them
    will never cause load-time param changing.
    
    This also simplifies the interface used by modules to block sysfs access
    to their params; while there are currently functions to block and unblock
    sysfs param access which are split up by read and write and expect a single
    kernel param to be passed, their actual operation is identical and applies
    to all params, not just the one passed to them; they simply lock and unlock
    the global param mutex.  They are replaced with direct calls to
    kernel_param_[un]lock(THIS_MODULE), which locks THIS_MODULE's param_lock, or
    if the module is built-in, it locks the built-in mutex.
    
    Suggested-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Dan Streetman <ddstreet@ieee.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 9b90fdc4b151..f6b911cc3923 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -185,9 +185,9 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	int ret;
 
 #ifdef DEBUG
-	kparam_block_sysfs_write(dsp);
+	kernel_param_lock(THIS_MODULE);
 	printk(KERN_DEBUG "hostaudio: open called (host: %s)\n", dsp);
-	kparam_unblock_sysfs_write(dsp);
+	kernel_param_unlock(THIS_MODULE);
 #endif
 
 	state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
@@ -199,11 +199,11 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
-	kparam_block_sysfs_write(dsp);
+	kernel_param_lock(THIS_MODULE);
 	mutex_lock(&hostaudio_mutex);
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
 	mutex_unlock(&hostaudio_mutex);
-	kparam_unblock_sysfs_write(dsp);
+	kernel_param_unlock(THIS_MODULE);
 
 	if (ret < 0) {
 		kfree(state);
@@ -260,17 +260,17 @@ static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
-	kparam_block_sysfs_write(mixer);
+	kernel_param_lock(THIS_MODULE);
 	mutex_lock(&hostaudio_mutex);
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
 	mutex_unlock(&hostaudio_mutex);
-	kparam_unblock_sysfs_write(mixer);
+	kernel_param_unlock(THIS_MODULE);
 
 	if (ret < 0) {
-		kparam_block_sysfs_write(dsp);
+		kernel_param_lock(THIS_MODULE);
 		printk(KERN_ERR "hostaudio_open_mixdev failed to open '%s', "
 		       "err = %d\n", dsp, -ret);
-		kparam_unblock_sysfs_write(dsp);
+		kernel_param_unlock(THIS_MODULE);
 		kfree(state);
 		return ret;
 	}
@@ -326,10 +326,10 @@ MODULE_LICENSE("GPL");
 
 static int __init hostaudio_init_module(void)
 {
-	__kernel_param_lock();
+	kernel_param_lock(THIS_MODULE);
 	printk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",
 	       dsp, mixer);
-	__kernel_param_unlock();
+	kernel_param_unlock(THIS_MODULE);
 
 	module_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);
 	if (module_data.dev_audio < 0) {

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index f9f6a4e20590..9b90fdc4b151 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -3,15 +3,15 @@
  * Licensed under the GPL
  */
 
-#include "linux/fs.h"
-#include "linux/module.h"
-#include "linux/slab.h"
-#include "linux/sound.h"
-#include "linux/soundcard.h"
-#include "linux/mutex.h"
-#include "asm/uaccess.h"
-#include "init.h"
-#include "os.h"
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+#include <init.h>
+#include <os.h>
 
 struct hostaudio_state {
 	int fd;

commit 5704e44d283e907623e3775c1262f206a2c48cf3
Merge: 91151240ed8e 6de5bd128d38
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:43:11 2010 -0700

    Merge branch 'config' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'config' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      BKL: introduce CONFIG_BKL.
      dabusb: remove the BKL
      sunrpc: remove the big kernel lock
      init/main.c: remove BKL notations
      blktrace: remove the big kernel lock
      rtmutex-tester: make it build without BKL
      dvb-core: kill the big kernel lock
      dvb/bt8xx: kill the big kernel lock
      tlclk: remove big kernel lock
      fix rawctl compat ioctls breakage on amd64 and itanic
      uml: kill big kernel lock
      parisc: remove big kernel lock
      cris: autoconvert trivial BKL users
      alpha: kill big kernel lock
      isapnp: BKL removal
      s390/block: kill the big kernel lock
      hpet: kill BKL, add compat_ioctl

commit 9a181c58617134822ae596339dbea076ef9b5cf7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Sep 11 18:38:03 2010 +0200

    uml: kill big kernel lock
    
    Three uml device drivers still use the big kernel lock,
    but all of them can be safely converted to using
    a per-driver mutex instead. Most likely this is not
    even necessary, so after further review these can
    and should be removed as well.
    
    The exec system call no longer requires the BKL either,
    so remove it from there, too.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: user-mode-linux-devel@lists.sourceforge.net

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 0c46e398cd8f..d92ff6d60297 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -8,7 +8,7 @@
 #include "linux/slab.h"
 #include "linux/sound.h"
 #include "linux/soundcard.h"
-#include "linux/smp_lock.h"
+#include "linux/mutex.h"
 #include "asm/uaccess.h"
 #include "init.h"
 #include "os.h"
@@ -67,6 +67,8 @@ MODULE_PARM_DESC(mixer, MIXER_HELP);
 
 #endif
 
+static DEFINE_MUTEX(hostaudio_mutex);
+
 /* /dev/dsp file operations */
 
 static ssize_t hostaudio_read(struct file *file, char __user *buffer,
@@ -202,9 +204,9 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 		w = 1;
 
 	kparam_block_sysfs_write(dsp);
-	lock_kernel();
+	mutex_lock(&hostaudio_mutex);
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
-	unlock_kernel();
+	mutex_unlock(&hostaudio_mutex);
 	kparam_unblock_sysfs_write(dsp);
 
 	if (ret < 0) {
@@ -263,9 +265,9 @@ static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 		w = 1;
 
 	kparam_block_sysfs_write(mixer);
-	lock_kernel();
+	mutex_lock(&hostaudio_mutex);
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
-	unlock_kernel();
+	mutex_unlock(&hostaudio_mutex);
 	kparam_unblock_sysfs_write(mixer);
 
 	if (ret < 0) {

commit e3c6cf61815b0af0c697aeed4c6f11762f913002
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Oct 15 14:34:13 2010 -0700

    uml: fix build
    
    Fix a build error introduced by d6d1b650ae6acce73d55dd024 ("param: simple
    locking for sysfs-writable charp parameters").
    
        CC      arch/um/kernel/trap.o
      arch/um/drivers/hostaudio_kern.c: In function 'hostaudio_open':
      arch/um/drivers/hostaudio_kern.c:204: error: '__param_dsp' undeclared (first use in this function)
      arch/um/drivers/hostaudio_kern.c:204: error: (Each undeclared identifier is reported only once
      arch/um/drivers/hostaudio_kern.c:204: error: for each function it appears in.)
      arch/um/drivers/hostaudio_kern.c: In function 'hostmixer_open_mixdev':
      arch/um/drivers/hostaudio_kern.c:265: error: '__param_mixer' undeclared (first use in this function)
      arch/um/drivers/hostaudio_kern.c:272: error: '__param_dsp' undeclared (first use in this function)
    
    Reported-by: Toralf Förster <toralf.foerster@gmx.de>
    Tested-by: Toralf Förster <toralf.foerster@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 0c46e398cd8f..63c740a85b4c 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -40,6 +40,11 @@ static char *mixer = HOSTAUDIO_DEV_MIXER;
 "    This is used to specify the host mixer device to the hostaudio driver.\n"\
 "    The default is \"" HOSTAUDIO_DEV_MIXER "\".\n\n"
 
+module_param(dsp, charp, 0644);
+MODULE_PARM_DESC(dsp, DSP_HELP);
+module_param(mixer, charp, 0644);
+MODULE_PARM_DESC(mixer, MIXER_HELP);
+
 #ifndef MODULE
 static int set_dsp(char *name, int *add)
 {
@@ -56,15 +61,6 @@ static int set_mixer(char *name, int *add)
 }
 
 __uml_setup("mixer=", set_mixer, "mixer=<mixer device>\n" MIXER_HELP);
-
-#else /*MODULE*/
-
-module_param(dsp, charp, 0644);
-MODULE_PARM_DESC(dsp, DSP_HELP);
-
-module_param(mixer, charp, 0644);
-MODULE_PARM_DESC(mixer, MIXER_HELP);
-
 #endif
 
 /* /dev/dsp file operations */

commit d6d1b650ae6acce73d55dd0246de22180303ae73
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Aug 11 23:04:27 2010 -0600

    param: simple locking for sysfs-writable charp parameters
    
    Since the writing to sysfs can free the old one, we need to block that
    when we access the charp variables.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Tested-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: John W. Linville <linville@tuxdriver.com>
    Cc: Jing Huang <huangj@brocade.com>
    Cc: James E.J. Bottomley <James.Bottomley@suse.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: libertas-dev@lists.infradead.org
    Cc: linux-wireless@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-usb@vger.kernel.org

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 68142df76608..0c46e398cd8f 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -187,7 +187,9 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	int ret;
 
 #ifdef DEBUG
+	kparam_block_sysfs_write(dsp);
 	printk(KERN_DEBUG "hostaudio: open called (host: %s)\n", dsp);
+	kparam_unblock_sysfs_write(dsp);
 #endif
 
 	state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
@@ -199,9 +201,11 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
+	kparam_block_sysfs_write(dsp);
 	lock_kernel();
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
 	unlock_kernel();
+	kparam_unblock_sysfs_write(dsp);
 
 	if (ret < 0) {
 		kfree(state);
@@ -258,13 +262,17 @@ static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
+	kparam_block_sysfs_write(mixer);
 	lock_kernel();
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
 	unlock_kernel();
+	kparam_unblock_sysfs_write(mixer);
 
 	if (ret < 0) {
+		kparam_block_sysfs_write(dsp);
 		printk(KERN_ERR "hostaudio_open_mixdev failed to open '%s', "
 		       "err = %d\n", dsp, -ret);
+		kparam_unblock_sysfs_write(dsp);
 		kfree(state);
 		return ret;
 	}
@@ -320,8 +328,10 @@ MODULE_LICENSE("GPL");
 
 static int __init hostaudio_init_module(void)
 {
+	__kernel_param_lock();
 	printk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",
 	       dsp, mixer);
+	__kernel_param_unlock();
 
 	module_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);
 	if (module_data.dev_audio < 0) {

commit 90dc763fef4c869e60b2a7ad92e1a7dab68575ea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Jul 11 12:16:36 2010 +0200

    sound: push BKL into open functions
    
    This moves the lock_kernel() call from soundcore_open
    to the individual OSS device drivers, where we can deal
    with it one driver at a time if needed, or just kill
    off the drivers.
    
    All core components in ALSA already provide
    adequate locking in their open()-functions
    and do not require the big kernel lock, so
    there is no need to add the BKL there.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index ae42695c3597..68142df76608 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -8,6 +8,7 @@
 #include "linux/slab.h"
 #include "linux/sound.h"
 #include "linux/soundcard.h"
+#include "linux/smp_lock.h"
 #include "asm/uaccess.h"
 #include "init.h"
 #include "os.h"
@@ -198,7 +199,10 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
+	lock_kernel();
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
+	unlock_kernel();
+
 	if (ret < 0) {
 		kfree(state);
 		return ret;
@@ -254,7 +258,9 @@ static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		w = 1;
 
+	lock_kernel();
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
+	unlock_kernel();
 
 	if (ret < 0) {
 		printk(KERN_ERR "hostaudio_open_mixdev failed to open '%s', "

commit d6c89d9aca0933d90ab926bf448b32f24a163792
Author: John Kacur <jkacur@redhat.com>
Date:   Fri May 7 17:34:28 2010 +0200

    uml: Convert to unlocked_ioctls to remove implicit BKL
    
    Convert hostaudio_ioctl and hostmixer_ioctl_mixdev to
    unlocked_ioctl without pushdown.
    
    There is nothing to protect inside, the synchronization
    is made from the host already.
    
    Signed-off-by: John Kacur <jkacur@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 368219cc2366..ae42695c3597 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -136,7 +136,7 @@ static unsigned int hostaudio_poll(struct file *file,
 	return mask;
 }
 
-static int hostaudio_ioctl(struct inode *inode, struct file *file,
+static long hostaudio_ioctl(struct file *file,
 			   unsigned int cmd, unsigned long arg)
 {
 	struct hostaudio_state *state = file->private_data;
@@ -223,7 +223,7 @@ static int hostaudio_release(struct inode *inode, struct file *file)
 
 /* /dev/mixer file operations */
 
-static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file,
+static long hostmixer_ioctl_mixdev(struct file *file,
 				  unsigned int cmd, unsigned long arg)
 {
 	struct hostmixer_state *state = file->private_data;
@@ -289,7 +289,7 @@ static const struct file_operations hostaudio_fops = {
 	.read           = hostaudio_read,
 	.write          = hostaudio_write,
 	.poll           = hostaudio_poll,
-	.ioctl          = hostaudio_ioctl,
+	.unlocked_ioctl	= hostaudio_ioctl,
 	.mmap           = NULL,
 	.open           = hostaudio_open,
 	.release        = hostaudio_release,
@@ -298,7 +298,7 @@ static const struct file_operations hostaudio_fops = {
 static const struct file_operations hostmixer_fops = {
 	.owner          = THIS_MODULE,
 	.llseek         = no_llseek,
-	.ioctl          = hostmixer_ioctl_mixdev,
+	.unlocked_ioctl	= hostmixer_ioctl_mixdev,
 	.open           = hostmixer_open_mixdev,
 	.release        = hostmixer_release,
 };

commit 484f1e2c1ea58c6a4352313f7ee4edd4b52deecd
Author: Johann Felix Soden <johfel@users.sourceforge.net>
Date:   Mon May 12 14:01:51 2008 -0700

    uml: fix errno return
    
    Error returns are negative.
    
    Signed-off-by: Johann Felix Soden <johfel@users.sourceforge.net>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index ff1b22b69e9c..368219cc2366 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -154,7 +154,7 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	case SNDCTL_DSP_SUBDIVIDE:
 	case SNDCTL_DSP_SETFRAGMENT:
 		if (get_user(data, (int __user *) arg))
-			return EFAULT;
+			return -EFAULT;
 		break;
 	default:
 		break;

commit cb8fa61c2b8b29d422d7310f064d60022f18f89b
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:34 2007 -0700

    uml: arch/um/drivers formatting
    
    Style fixes for the rest of the drivers.  arch/um/drivers should be pretty
    CodingStyle-compliant now.
    
    Except for the ubd driver, which will have to be treated separately.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 10e08a8c17c3..ff1b22b69e9c 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -1,16 +1,14 @@
-/* 
- * Copyright (C) 2002 Steve Schmidtke 
+/*
+ * Copyright (C) 2002 Steve Schmidtke
  * Licensed under the GPL
  */
 
+#include "linux/fs.h"
 #include "linux/module.h"
-#include "linux/init.h"
 #include "linux/slab.h"
-#include "linux/fs.h"
 #include "linux/sound.h"
 #include "linux/soundcard.h"
 #include "asm/uaccess.h"
-#include "kern_util.h"
 #include "init.h"
 #include "os.h"
 
@@ -25,7 +23,8 @@ struct hostmixer_state {
 #define HOSTAUDIO_DEV_DSP "/dev/sound/dsp"
 #define HOSTAUDIO_DEV_MIXER "/dev/sound/mixer"
 
-/* Changed either at boot time or module load time.  At boot, this is
+/*
+ * Changed either at boot time or module load time.  At boot, this is
  * single-threaded; at module load, multiple modules would each have
  * their own copy of these variables.
  */
@@ -44,7 +43,7 @@ static char *mixer = HOSTAUDIO_DEV_MIXER;
 static int set_dsp(char *name, int *add)
 {
 	dsp = name;
-	return(0);
+	return 0;
 }
 
 __uml_setup("dsp=", set_dsp, "dsp=<dsp device>\n" DSP_HELP);
@@ -52,7 +51,7 @@ __uml_setup("dsp=", set_dsp, "dsp=<dsp device>\n" DSP_HELP);
 static int set_mixer(char *name, int *add)
 {
 	mixer = name;
-	return(0);
+	return 0;
 }
 
 __uml_setup("mixer=", set_mixer, "mixer=<mixer device>\n" MIXER_HELP);
@@ -77,23 +76,23 @@ static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 	int err;
 
 #ifdef DEBUG
-	printk("hostaudio: read called, count = %d\n", count);
+	printk(KERN_DEBUG "hostaudio: read called, count = %d\n", count);
 #endif
 
 	kbuf = kmalloc(count, GFP_KERNEL);
-	if(kbuf == NULL)
-		return(-ENOMEM);
+	if (kbuf == NULL)
+		return -ENOMEM;
 
 	err = os_read_file(state->fd, kbuf, count);
-	if(err < 0)
+	if (err < 0)
 		goto out;
 
-	if(copy_to_user(buffer, kbuf, err))
+	if (copy_to_user(buffer, kbuf, err))
 		err = -EFAULT;
 
 out:
 	kfree(kbuf);
-	return(err);
+	return err;
 }
 
 static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
@@ -104,40 +103,40 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 	int err;
 
 #ifdef DEBUG
-	printk("hostaudio: write called, count = %d\n", count);
+	printk(KERN_DEBUG "hostaudio: write called, count = %d\n", count);
 #endif
 
 	kbuf = kmalloc(count, GFP_KERNEL);
-	if(kbuf == NULL)
-		return(-ENOMEM);
+	if (kbuf == NULL)
+		return -ENOMEM;
 
 	err = -EFAULT;
-	if(copy_from_user(kbuf, buffer, count))
+	if (copy_from_user(kbuf, buffer, count))
 		goto out;
 
 	err = os_write_file(state->fd, kbuf, count);
-	if(err < 0)
+	if (err < 0)
 		goto out;
 	*ppos += err;
 
  out:
 	kfree(kbuf);
-	return(err);
+	return err;
 }
 
-static unsigned int hostaudio_poll(struct file *file, 
+static unsigned int hostaudio_poll(struct file *file,
 				   struct poll_table_struct *wait)
 {
 	unsigned int mask = 0;
 
 #ifdef DEBUG
-	printk("hostaudio: poll called (unimplemented)\n");
+	printk(KERN_DEBUG "hostaudio: poll called (unimplemented)\n");
 #endif
 
-	return(mask);
+	return mask;
 }
 
-static int hostaudio_ioctl(struct inode *inode, struct file *file, 
+static int hostaudio_ioctl(struct inode *inode, struct file *file,
 			   unsigned int cmd, unsigned long arg)
 {
 	struct hostaudio_state *state = file->private_data;
@@ -145,7 +144,7 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	int err;
 
 #ifdef DEBUG
-	printk("hostaudio: ioctl called, cmd = %u\n", cmd);
+	printk(KERN_DEBUG "hostaudio: ioctl called, cmd = %u\n", cmd);
 #endif
 	switch(cmd){
 	case SNDCTL_DSP_SPEED:
@@ -154,8 +153,8 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	case SNDCTL_DSP_CHANNELS:
 	case SNDCTL_DSP_SUBDIVIDE:
 	case SNDCTL_DSP_SETFRAGMENT:
-		if(get_user(data, (int __user *) arg))
-			return(-EFAULT);
+		if (get_user(data, (int __user *) arg))
+			return EFAULT;
 		break;
 	default:
 		break;
@@ -170,14 +169,14 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	case SNDCTL_DSP_CHANNELS:
 	case SNDCTL_DSP_SUBDIVIDE:
 	case SNDCTL_DSP_SETFRAGMENT:
-		if(put_user(data, (int __user *) arg))
-			return(-EFAULT);
+		if (put_user(data, (int __user *) arg))
+			return -EFAULT;
 		break;
 	default:
 		break;
 	}
 
-	return(err);
+	return err;
 }
 
 static int hostaudio_open(struct inode *inode, struct file *file)
@@ -187,24 +186,26 @@ static int hostaudio_open(struct inode *inode, struct file *file)
 	int ret;
 
 #ifdef DEBUG
-	printk("hostaudio: open called (host: %s)\n", dsp);
+	printk(KERN_DEBUG "hostaudio: open called (host: %s)\n", dsp);
 #endif
 
 	state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
-	if(state == NULL)
-		return(-ENOMEM);
+	if (state == NULL)
+		return -ENOMEM;
 
-	if(file->f_mode & FMODE_READ) r = 1;
-	if(file->f_mode & FMODE_WRITE) w = 1;
+	if (file->f_mode & FMODE_READ)
+		r = 1;
+	if (file->f_mode & FMODE_WRITE)
+		w = 1;
 
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
-	if(ret < 0){
+	if (ret < 0) {
 		kfree(state);
-		return(ret);
+		return ret;
 	}
 	state->fd = ret;
 	file->private_data = state;
-	return(0);
+	return 0;
 }
 
 static int hostaudio_release(struct inode *inode, struct file *file)
@@ -212,26 +213,26 @@ static int hostaudio_release(struct inode *inode, struct file *file)
 	struct hostaudio_state *state = file->private_data;
 
 #ifdef DEBUG
-	printk("hostaudio: release called\n");
+	printk(KERN_DEBUG "hostaudio: release called\n");
 #endif
 	os_close_file(state->fd);
 	kfree(state);
 
-	return(0);
+	return 0;
 }
 
 /* /dev/mixer file operations */
 
-static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file, 
+static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file,
 				  unsigned int cmd, unsigned long arg)
 {
 	struct hostmixer_state *state = file->private_data;
 
 #ifdef DEBUG
-	printk("hostmixer: ioctl called\n");
+	printk(KERN_DEBUG "hostmixer: ioctl called\n");
 #endif
 
-	return(os_ioctl_generic(state->fd, cmd, arg));
+	return os_ioctl_generic(state->fd, cmd, arg);
 }
 
 static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
@@ -241,26 +242,29 @@ static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 	int ret;
 
 #ifdef DEBUG
-	printk("hostmixer: open called (host: %s)\n", mixer);
+	printk(KERN_DEBUG "hostmixer: open called (host: %s)\n", mixer);
 #endif
 
 	state = kmalloc(sizeof(struct hostmixer_state), GFP_KERNEL);
-	if(state == NULL) return(-ENOMEM);
+	if (state == NULL)
+		return -ENOMEM;
 
-	if(file->f_mode & FMODE_READ) r = 1;
-	if(file->f_mode & FMODE_WRITE) w = 1;
+	if (file->f_mode & FMODE_READ)
+		r = 1;
+	if (file->f_mode & FMODE_WRITE)
+		w = 1;
 
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
-        
-	if(ret < 0){
-		printk("hostaudio_open_mixdev failed to open '%s', err = %d\n",
-		       dsp, -ret);
+
+	if (ret < 0) {
+		printk(KERN_ERR "hostaudio_open_mixdev failed to open '%s', "
+		       "err = %d\n", dsp, -ret);
 		kfree(state);
-		return(ret);
+		return ret;
 	}
 
 	file->private_data = state;
-	return(0);
+	return 0;
 }
 
 static int hostmixer_release(struct inode *inode, struct file *file)
@@ -268,13 +272,13 @@ static int hostmixer_release(struct inode *inode, struct file *file)
 	struct hostmixer_state *state = file->private_data;
 
 #ifdef DEBUG
-	printk("hostmixer: release called\n");
+	printk(KERN_DEBUG "hostmixer: release called\n");
 #endif
 
 	os_close_file(state->fd);
 	kfree(state);
 
-	return(0);
+	return 0;
 }
 
 /* kernel module operations */
@@ -314,13 +318,13 @@ static int __init hostaudio_init_module(void)
 	       dsp, mixer);
 
 	module_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);
-	if(module_data.dev_audio < 0){
+	if (module_data.dev_audio < 0) {
 		printk(KERN_ERR "hostaudio: couldn't register DSP device!\n");
 		return -ENODEV;
 	}
 
 	module_data.dev_mixer = register_sound_mixer(&hostmixer_fops, -1);
-	if(module_data.dev_mixer < 0){
+	if (module_data.dev_mixer < 0) {
 		printk(KERN_ERR "hostmixer: couldn't register mixer "
 		       "device!\n");
 		unregister_sound_dsp(module_data.dev_audio);

commit a6ea4cceed18edebe1eb6001cb9e0f88cd741a6c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:43 2007 -0700

    uml: rename os_{read_write}_file_k back to os_{read_write}_file
    
    Rename os_{read_write}_file_k back to os_{read_write}_file, delete
    the originals and their bogus infrastructure, and fix all the callers.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index bd6688ea96de..10e08a8c17c3 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -84,7 +84,7 @@ static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 	if(kbuf == NULL)
 		return(-ENOMEM);
 
-	err = os_read_file_k(state->fd, kbuf, count);
+	err = os_read_file(state->fd, kbuf, count);
 	if(err < 0)
 		goto out;
 
@@ -115,7 +115,7 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 	if(copy_from_user(kbuf, buffer, count))
 		goto out;
 
-	err = os_write_file_k(state->fd, kbuf, count);
+	err = os_write_file(state->fd, kbuf, count);
 	if(err < 0)
 		goto out;
 	*ppos += err;

commit 3d564047a5f45cb628ec72514f68076e532988f3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:32 2007 -0700

    uml: start fixing os_read_file and os_write_file
    
    This patch starts the removal of a very old, very broken piece of code.  This
    stems from the problem of passing a userspace buffer into read() or write() on
    the host.  If that buffer had not yet been faulted in, read and write will
    return -EFAULT.
    
    To avoid this problem, the solution was to fault the buffer in before the
    system call by touching the pages that hold the buffer by doing a copy-user of
    a byte to each page.  This is obviously bogus, but it does usually work, in tt
    mode, since the kernel and process are in the same address space and userspace
    addresses can be accessed directly in the kernel.
    
    In skas mode, where the kernel and process are in separate address spaces, it
    is completely bogus because the userspace address, which is invalid in the
    kernel, is passed into the system call instead of the corresponding physical
    address, which would be valid.  Here, it appears that this code, on every host
    read() or write(), tries to fault in a random process page.  This doesn't seem
    to cause any correctness problems, but there is a performance impact.  This
    patch, and the ones following, result in a 10-15% performance gain on a kernel
    build.
    
    This code can't be immediately tossed out because when it is, you can't log
    in.  Apparently, there is some code in the console driver which depends on
    this somehow.
    
    However, we can start removing it by switching the code which does I/O using
    kernel addresses to using plain read() and write().  This patch introduces
    os_read_file_k and os_write_file_k for use with kernel buffers and converts
    all call locations which use obvious kernel buffers to use them.  These
    include I/O using buffers which are local variables which are on the stack or
    kmalloc-ed.  Later patches will handle the less obvious cases, followed by a
    mass conversion back to the original interface.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 10e08a8c17c3..bd6688ea96de 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -84,7 +84,7 @@ static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 	if(kbuf == NULL)
 		return(-ENOMEM);
 
-	err = os_read_file(state->fd, kbuf, count);
+	err = os_read_file_k(state->fd, kbuf, count);
 	if(err < 0)
 		goto out;
 
@@ -115,7 +115,7 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 	if(copy_from_user(kbuf, buffer, count))
 		goto out;
 
-	err = os_write_file(state->fd, kbuf, count);
+	err = os_write_file_k(state->fd, kbuf, count);
 	if(err < 0)
 		goto out;
 	*ppos += err;

commit d471c0fca7eae1ffd4f7d4c11ee835ff70aaa71f
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:00 2007 -0800

    [PATCH] uml: audio driver formatting
    
    Whitespace and style fixes.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index f61fa0562202..10e08a8c17c3 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -15,11 +15,11 @@
 #include "os.h"
 
 struct hostaudio_state {
-  int fd;
+	int fd;
 };
 
 struct hostmixer_state {
-  int fd;
+	int fd;
 };
 
 #define HOSTAUDIO_DEV_DSP "/dev/sound/dsp"
@@ -72,12 +72,12 @@ MODULE_PARM_DESC(mixer, MIXER_HELP);
 static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 			      size_t count, loff_t *ppos)
 {
-        struct hostaudio_state *state = file->private_data;
+	struct hostaudio_state *state = file->private_data;
 	void *kbuf;
 	int err;
 
 #ifdef DEBUG
-        printk("hostaudio: read called, count = %d\n", count);
+	printk("hostaudio: read called, count = %d\n", count);
 #endif
 
 	kbuf = kmalloc(count, GFP_KERNEL);
@@ -91,7 +91,7 @@ static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 	if(copy_to_user(buffer, kbuf, err))
 		err = -EFAULT;
 
- out:
+out:
 	kfree(kbuf);
 	return(err);
 }
@@ -99,12 +99,12 @@ static ssize_t hostaudio_read(struct file *file, char __user *buffer,
 static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 			       size_t count, loff_t *ppos)
 {
-        struct hostaudio_state *state = file->private_data;
+	struct hostaudio_state *state = file->private_data;
 	void *kbuf;
 	int err;
 
 #ifdef DEBUG
-        printk("hostaudio: write called, count = %d\n", count);
+	printk("hostaudio: write called, count = %d\n", count);
 #endif
 
 	kbuf = kmalloc(count, GFP_KERNEL);
@@ -128,24 +128,24 @@ static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 static unsigned int hostaudio_poll(struct file *file, 
 				   struct poll_table_struct *wait)
 {
-        unsigned int mask = 0;
+	unsigned int mask = 0;
 
 #ifdef DEBUG
-        printk("hostaudio: poll called (unimplemented)\n");
+	printk("hostaudio: poll called (unimplemented)\n");
 #endif
 
-        return(mask);
+	return(mask);
 }
 
 static int hostaudio_ioctl(struct inode *inode, struct file *file, 
 			   unsigned int cmd, unsigned long arg)
 {
-        struct hostaudio_state *state = file->private_data;
+	struct hostaudio_state *state = file->private_data;
 	unsigned long data = 0;
 	int err;
 
 #ifdef DEBUG
-        printk("hostaudio: ioctl called, cmd = %u\n", cmd);
+	printk("hostaudio: ioctl called, cmd = %u\n", cmd);
 #endif
 	switch(cmd){
 	case SNDCTL_DSP_SPEED:
@@ -182,42 +182,40 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 
 static int hostaudio_open(struct inode *inode, struct file *file)
 {
-        struct hostaudio_state *state;
-        int r = 0, w = 0;
-        int ret;
+	struct hostaudio_state *state;
+	int r = 0, w = 0;
+	int ret;
 
 #ifdef DEBUG
-        printk("hostaudio: open called (host: %s)\n", dsp);
+	printk("hostaudio: open called (host: %s)\n", dsp);
 #endif
 
-        state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
-        if(state == NULL)
+	state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
+	if(state == NULL)
 		return(-ENOMEM);
 
-        if(file->f_mode & FMODE_READ) r = 1;
-        if(file->f_mode & FMODE_WRITE) w = 1;
+	if(file->f_mode & FMODE_READ) r = 1;
+	if(file->f_mode & FMODE_WRITE) w = 1;
 
 	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
-        if(ret < 0){
+	if(ret < 0){
 		kfree(state);
 		return(ret);
-        }
-
+	}
 	state->fd = ret;
-        file->private_data = state;
-        return(0);
+	file->private_data = state;
+	return(0);
 }
 
 static int hostaudio_release(struct inode *inode, struct file *file)
 {
-        struct hostaudio_state *state = file->private_data;
+	struct hostaudio_state *state = file->private_data;
 
 #ifdef DEBUG
-        printk("hostaudio: release called\n");
+	printk("hostaudio: release called\n");
 #endif
-
-		os_close_file(state->fd);
-        kfree(state);
+	os_close_file(state->fd);
+	kfree(state);
 
 	return(0);
 }
@@ -227,10 +225,10 @@ static int hostaudio_release(struct inode *inode, struct file *file)
 static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file, 
 				  unsigned int cmd, unsigned long arg)
 {
-        struct hostmixer_state *state = file->private_data;
+	struct hostmixer_state *state = file->private_data;
 
 #ifdef DEBUG
-        printk("hostmixer: ioctl called\n");
+	printk("hostmixer: ioctl called\n");
 #endif
 
 	return(os_ioctl_generic(state->fd, cmd, arg));
@@ -238,68 +236,67 @@ static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file,
 
 static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
 {
-        struct hostmixer_state *state;
-        int r = 0, w = 0;
-        int ret;
+	struct hostmixer_state *state;
+	int r = 0, w = 0;
+	int ret;
 
 #ifdef DEBUG
-        printk("hostmixer: open called (host: %s)\n", mixer);
+	printk("hostmixer: open called (host: %s)\n", mixer);
 #endif
 
-        state = kmalloc(sizeof(struct hostmixer_state), GFP_KERNEL);
-        if(state == NULL) return(-ENOMEM);
+	state = kmalloc(sizeof(struct hostmixer_state), GFP_KERNEL);
+	if(state == NULL) return(-ENOMEM);
 
-        if(file->f_mode & FMODE_READ) r = 1;
-        if(file->f_mode & FMODE_WRITE) w = 1;
+	if(file->f_mode & FMODE_READ) r = 1;
+	if(file->f_mode & FMODE_WRITE) w = 1;
 
 	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
         
-        if(ret < 0){
+	if(ret < 0){
 		printk("hostaudio_open_mixdev failed to open '%s', err = %d\n",
 		       dsp, -ret);
 		kfree(state);
 		return(ret);
-        }
+	}
 
-        file->private_data = state;
-        return(0);
+	file->private_data = state;
+	return(0);
 }
 
 static int hostmixer_release(struct inode *inode, struct file *file)
 {
-        struct hostmixer_state *state = file->private_data;
+	struct hostmixer_state *state = file->private_data;
 
 #ifdef DEBUG
-        printk("hostmixer: release called\n");
+	printk("hostmixer: release called\n");
 #endif
 
-		os_close_file(state->fd);
-        kfree(state);
+	os_close_file(state->fd);
+	kfree(state);
 
 	return(0);
 }
 
-
 /* kernel module operations */
 
 static const struct file_operations hostaudio_fops = {
-        .owner          = THIS_MODULE,
-        .llseek         = no_llseek,
-        .read           = hostaudio_read,
-        .write          = hostaudio_write,
-        .poll           = hostaudio_poll,
-        .ioctl          = hostaudio_ioctl,
-        .mmap           = NULL,
-        .open           = hostaudio_open,
-        .release        = hostaudio_release,
+	.owner          = THIS_MODULE,
+	.llseek         = no_llseek,
+	.read           = hostaudio_read,
+	.write          = hostaudio_write,
+	.poll           = hostaudio_poll,
+	.ioctl          = hostaudio_ioctl,
+	.mmap           = NULL,
+	.open           = hostaudio_open,
+	.release        = hostaudio_release,
 };
 
 static const struct file_operations hostmixer_fops = {
-        .owner          = THIS_MODULE,
-        .llseek         = no_llseek,
-        .ioctl          = hostmixer_ioctl_mixdev,
-        .open           = hostmixer_open_mixdev,
-        .release        = hostmixer_release,
+	.owner          = THIS_MODULE,
+	.llseek         = no_llseek,
+	.ioctl          = hostmixer_ioctl_mixdev,
+	.open           = hostmixer_open_mixdev,
+	.release        = hostmixer_release,
 };
 
 struct {
@@ -313,42 +310,31 @@ MODULE_LICENSE("GPL");
 
 static int __init hostaudio_init_module(void)
 {
-        printk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",
+	printk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",
 	       dsp, mixer);
 
 	module_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);
-        if(module_data.dev_audio < 0){
-                printk(KERN_ERR "hostaudio: couldn't register DSP device!\n");
-                return -ENODEV;
-        }
+	if(module_data.dev_audio < 0){
+		printk(KERN_ERR "hostaudio: couldn't register DSP device!\n");
+		return -ENODEV;
+	}
 
 	module_data.dev_mixer = register_sound_mixer(&hostmixer_fops, -1);
-        if(module_data.dev_mixer < 0){
-                printk(KERN_ERR "hostmixer: couldn't register mixer "
+	if(module_data.dev_mixer < 0){
+		printk(KERN_ERR "hostmixer: couldn't register mixer "
 		       "device!\n");
-                unregister_sound_dsp(module_data.dev_audio);
-                return -ENODEV;
-        }
+		unregister_sound_dsp(module_data.dev_audio);
+		return -ENODEV;
+	}
 
-        return 0;
+	return 0;
 }
 
 static void __exit hostaudio_cleanup_module (void)
 {
-       unregister_sound_mixer(module_data.dev_mixer);
-       unregister_sound_dsp(module_data.dev_audio);
+	unregister_sound_mixer(module_data.dev_mixer);
+	unregister_sound_dsp(module_data.dev_audio);
 }
 
 module_init(hostaudio_init_module);
 module_exit(hostaudio_cleanup_module);
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */

commit b612e475e75f860002d88dd8440ce250506c5094
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:43:59 2007 -0800

    [PATCH] uml: audio driver locking
    
    Comment the lack of locking and make a couple of variables static.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index a0d148ea63d6..f61fa0562202 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -25,9 +25,12 @@ struct hostmixer_state {
 #define HOSTAUDIO_DEV_DSP "/dev/sound/dsp"
 #define HOSTAUDIO_DEV_MIXER "/dev/sound/mixer"
 
-/* Only changed from linux_main at boot time */
-char *dsp = HOSTAUDIO_DEV_DSP;
-char *mixer = HOSTAUDIO_DEV_MIXER;
+/* Changed either at boot time or module load time.  At boot, this is
+ * single-threaded; at module load, multiple modules would each have
+ * their own copy of these variables.
+ */
+static char *dsp = HOSTAUDIO_DEV_DSP;
+static char *mixer = HOSTAUDIO_DEV_MIXER;
 
 #define DSP_HELP \
 "    This is used to specify the host dsp device to the hostaudio driver.\n" \

commit 038b0a6d8d32db934bba6a24e74e76e4e327a94f
Author: Dave Jones <davej@redhat.com>
Date:   Wed Oct 4 03:38:54 2006 -0400

    Remove all inclusions of <linux/config.h>
    kbuild explicitly includes this at build time.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index d247ef45c374..a0d148ea63d6 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -3,7 +3,6 @@
  * Licensed under the GPL
  */
 
-#include "linux/config.h"
 #include "linux/module.h"
 #include "linux/init.h"
 #include "linux/slab.h"

commit 5e7672ec3f059f764fcc5c78216e24bb16c44dba
Author: Jeff Dike <jdike@addtoit.com>
Date:   Wed Sep 27 01:50:33 2006 -0700

    [PATCH] uml: const more data
    
    Make lots of structures const in order to make it obvious that they need no
    locking.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 37232f908cd7..d247ef45c374 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -280,7 +280,7 @@ static int hostmixer_release(struct inode *inode, struct file *file)
 
 /* kernel module operations */
 
-static struct file_operations hostaudio_fops = {
+static const struct file_operations hostaudio_fops = {
         .owner          = THIS_MODULE,
         .llseek         = no_llseek,
         .read           = hostaudio_read,
@@ -292,7 +292,7 @@ static struct file_operations hostaudio_fops = {
         .release        = hostaudio_release,
 };
 
-static struct file_operations hostmixer_fops = {
+static const struct file_operations hostmixer_fops = {
         .owner          = THIS_MODULE,
         .llseek         = no_llseek,
         .ioctl          = hostmixer_ioctl_mixdev,

commit 4d338e1accfc3473f7e453427dfd4f1ebf4dbbe6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 31 02:30:15 2006 -0800

    [PATCH] uml: sparse cleanups
    
    misc sparse annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index 59602b81b240..37232f908cd7 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -67,8 +67,8 @@ MODULE_PARM_DESC(mixer, MIXER_HELP);
 
 /* /dev/dsp file operations */
 
-static ssize_t hostaudio_read(struct file *file, char *buffer, size_t count, 
-			      loff_t *ppos)
+static ssize_t hostaudio_read(struct file *file, char __user *buffer,
+			      size_t count, loff_t *ppos)
 {
         struct hostaudio_state *state = file->private_data;
 	void *kbuf;
@@ -94,7 +94,7 @@ static ssize_t hostaudio_read(struct file *file, char *buffer, size_t count,
 	return(err);
 }
 
-static ssize_t hostaudio_write(struct file *file, const char *buffer, 
+static ssize_t hostaudio_write(struct file *file, const char __user *buffer,
 			       size_t count, loff_t *ppos)
 {
         struct hostaudio_state *state = file->private_data;
@@ -152,7 +152,7 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	case SNDCTL_DSP_CHANNELS:
 	case SNDCTL_DSP_SUBDIVIDE:
 	case SNDCTL_DSP_SETFRAGMENT:
-		if(get_user(data, (int *) arg))
+		if(get_user(data, (int __user *) arg))
 			return(-EFAULT);
 		break;
 	default:
@@ -168,7 +168,7 @@ static int hostaudio_ioctl(struct inode *inode, struct file *file,
 	case SNDCTL_DSP_CHANNELS:
 	case SNDCTL_DSP_SUBDIVIDE:
 	case SNDCTL_DSP_SETFRAGMENT:
-		if(put_user(data, (int *) arg))
+		if(put_user(data, (int __user *) arg))
 			return(-EFAULT);
 		break;
 	default:

commit 20a64f1d70a1a9cc001f2fec5ba1b0a4ff3f6bd5
Author: Dominik Hackl <dominik@hackl.dhs.org>
Date:   Wed Jul 27 11:43:32 2005 -0700

    [PATCH] uml: update module interface
    
    This patch replaces the deprecated MODULE_PARM function by the new
    module_param function.
    
    Signed-off-by: Dominik Hackl <dominik@hackl.dhs.org>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
index d5742783e19d..59602b81b240 100644
--- a/arch/um/drivers/hostaudio_kern.c
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -57,10 +57,10 @@ __uml_setup("mixer=", set_mixer, "mixer=<mixer device>\n" MIXER_HELP);
 
 #else /*MODULE*/
 
-MODULE_PARM(dsp, "s");
+module_param(dsp, charp, 0644);
 MODULE_PARM_DESC(dsp, DSP_HELP);
 
-MODULE_PARM(mixer, "s");
+module_param(mixer, charp, 0644);
 MODULE_PARM_DESC(mixer, MIXER_HELP);
 
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/drivers/hostaudio_kern.c b/arch/um/drivers/hostaudio_kern.c
new file mode 100644
index 000000000000..d5742783e19d
--- /dev/null
+++ b/arch/um/drivers/hostaudio_kern.c
@@ -0,0 +1,352 @@
+/* 
+ * Copyright (C) 2002 Steve Schmidtke 
+ * Licensed under the GPL
+ */
+
+#include "linux/config.h"
+#include "linux/module.h"
+#include "linux/init.h"
+#include "linux/slab.h"
+#include "linux/fs.h"
+#include "linux/sound.h"
+#include "linux/soundcard.h"
+#include "asm/uaccess.h"
+#include "kern_util.h"
+#include "init.h"
+#include "os.h"
+
+struct hostaudio_state {
+  int fd;
+};
+
+struct hostmixer_state {
+  int fd;
+};
+
+#define HOSTAUDIO_DEV_DSP "/dev/sound/dsp"
+#define HOSTAUDIO_DEV_MIXER "/dev/sound/mixer"
+
+/* Only changed from linux_main at boot time */
+char *dsp = HOSTAUDIO_DEV_DSP;
+char *mixer = HOSTAUDIO_DEV_MIXER;
+
+#define DSP_HELP \
+"    This is used to specify the host dsp device to the hostaudio driver.\n" \
+"    The default is \"" HOSTAUDIO_DEV_DSP "\".\n\n"
+
+#define MIXER_HELP \
+"    This is used to specify the host mixer device to the hostaudio driver.\n"\
+"    The default is \"" HOSTAUDIO_DEV_MIXER "\".\n\n"
+
+#ifndef MODULE
+static int set_dsp(char *name, int *add)
+{
+	dsp = name;
+	return(0);
+}
+
+__uml_setup("dsp=", set_dsp, "dsp=<dsp device>\n" DSP_HELP);
+
+static int set_mixer(char *name, int *add)
+{
+	mixer = name;
+	return(0);
+}
+
+__uml_setup("mixer=", set_mixer, "mixer=<mixer device>\n" MIXER_HELP);
+
+#else /*MODULE*/
+
+MODULE_PARM(dsp, "s");
+MODULE_PARM_DESC(dsp, DSP_HELP);
+
+MODULE_PARM(mixer, "s");
+MODULE_PARM_DESC(mixer, MIXER_HELP);
+
+#endif
+
+/* /dev/dsp file operations */
+
+static ssize_t hostaudio_read(struct file *file, char *buffer, size_t count, 
+			      loff_t *ppos)
+{
+        struct hostaudio_state *state = file->private_data;
+	void *kbuf;
+	int err;
+
+#ifdef DEBUG
+        printk("hostaudio: read called, count = %d\n", count);
+#endif
+
+	kbuf = kmalloc(count, GFP_KERNEL);
+	if(kbuf == NULL)
+		return(-ENOMEM);
+
+	err = os_read_file(state->fd, kbuf, count);
+	if(err < 0)
+		goto out;
+
+	if(copy_to_user(buffer, kbuf, err))
+		err = -EFAULT;
+
+ out:
+	kfree(kbuf);
+	return(err);
+}
+
+static ssize_t hostaudio_write(struct file *file, const char *buffer, 
+			       size_t count, loff_t *ppos)
+{
+        struct hostaudio_state *state = file->private_data;
+	void *kbuf;
+	int err;
+
+#ifdef DEBUG
+        printk("hostaudio: write called, count = %d\n", count);
+#endif
+
+	kbuf = kmalloc(count, GFP_KERNEL);
+	if(kbuf == NULL)
+		return(-ENOMEM);
+
+	err = -EFAULT;
+	if(copy_from_user(kbuf, buffer, count))
+		goto out;
+
+	err = os_write_file(state->fd, kbuf, count);
+	if(err < 0)
+		goto out;
+	*ppos += err;
+
+ out:
+	kfree(kbuf);
+	return(err);
+}
+
+static unsigned int hostaudio_poll(struct file *file, 
+				   struct poll_table_struct *wait)
+{
+        unsigned int mask = 0;
+
+#ifdef DEBUG
+        printk("hostaudio: poll called (unimplemented)\n");
+#endif
+
+        return(mask);
+}
+
+static int hostaudio_ioctl(struct inode *inode, struct file *file, 
+			   unsigned int cmd, unsigned long arg)
+{
+        struct hostaudio_state *state = file->private_data;
+	unsigned long data = 0;
+	int err;
+
+#ifdef DEBUG
+        printk("hostaudio: ioctl called, cmd = %u\n", cmd);
+#endif
+	switch(cmd){
+	case SNDCTL_DSP_SPEED:
+	case SNDCTL_DSP_STEREO:
+	case SNDCTL_DSP_GETBLKSIZE:
+	case SNDCTL_DSP_CHANNELS:
+	case SNDCTL_DSP_SUBDIVIDE:
+	case SNDCTL_DSP_SETFRAGMENT:
+		if(get_user(data, (int *) arg))
+			return(-EFAULT);
+		break;
+	default:
+		break;
+	}
+
+	err = os_ioctl_generic(state->fd, cmd, (unsigned long) &data);
+
+	switch(cmd){
+	case SNDCTL_DSP_SPEED:
+	case SNDCTL_DSP_STEREO:
+	case SNDCTL_DSP_GETBLKSIZE:
+	case SNDCTL_DSP_CHANNELS:
+	case SNDCTL_DSP_SUBDIVIDE:
+	case SNDCTL_DSP_SETFRAGMENT:
+		if(put_user(data, (int *) arg))
+			return(-EFAULT);
+		break;
+	default:
+		break;
+	}
+
+	return(err);
+}
+
+static int hostaudio_open(struct inode *inode, struct file *file)
+{
+        struct hostaudio_state *state;
+        int r = 0, w = 0;
+        int ret;
+
+#ifdef DEBUG
+        printk("hostaudio: open called (host: %s)\n", dsp);
+#endif
+
+        state = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);
+        if(state == NULL)
+		return(-ENOMEM);
+
+        if(file->f_mode & FMODE_READ) r = 1;
+        if(file->f_mode & FMODE_WRITE) w = 1;
+
+	ret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);
+        if(ret < 0){
+		kfree(state);
+		return(ret);
+        }
+
+	state->fd = ret;
+        file->private_data = state;
+        return(0);
+}
+
+static int hostaudio_release(struct inode *inode, struct file *file)
+{
+        struct hostaudio_state *state = file->private_data;
+
+#ifdef DEBUG
+        printk("hostaudio: release called\n");
+#endif
+
+		os_close_file(state->fd);
+        kfree(state);
+
+	return(0);
+}
+
+/* /dev/mixer file operations */
+
+static int hostmixer_ioctl_mixdev(struct inode *inode, struct file *file, 
+				  unsigned int cmd, unsigned long arg)
+{
+        struct hostmixer_state *state = file->private_data;
+
+#ifdef DEBUG
+        printk("hostmixer: ioctl called\n");
+#endif
+
+	return(os_ioctl_generic(state->fd, cmd, arg));
+}
+
+static int hostmixer_open_mixdev(struct inode *inode, struct file *file)
+{
+        struct hostmixer_state *state;
+        int r = 0, w = 0;
+        int ret;
+
+#ifdef DEBUG
+        printk("hostmixer: open called (host: %s)\n", mixer);
+#endif
+
+        state = kmalloc(sizeof(struct hostmixer_state), GFP_KERNEL);
+        if(state == NULL) return(-ENOMEM);
+
+        if(file->f_mode & FMODE_READ) r = 1;
+        if(file->f_mode & FMODE_WRITE) w = 1;
+
+	ret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);
+        
+        if(ret < 0){
+		printk("hostaudio_open_mixdev failed to open '%s', err = %d\n",
+		       dsp, -ret);
+		kfree(state);
+		return(ret);
+        }
+
+        file->private_data = state;
+        return(0);
+}
+
+static int hostmixer_release(struct inode *inode, struct file *file)
+{
+        struct hostmixer_state *state = file->private_data;
+
+#ifdef DEBUG
+        printk("hostmixer: release called\n");
+#endif
+
+		os_close_file(state->fd);
+        kfree(state);
+
+	return(0);
+}
+
+
+/* kernel module operations */
+
+static struct file_operations hostaudio_fops = {
+        .owner          = THIS_MODULE,
+        .llseek         = no_llseek,
+        .read           = hostaudio_read,
+        .write          = hostaudio_write,
+        .poll           = hostaudio_poll,
+        .ioctl          = hostaudio_ioctl,
+        .mmap           = NULL,
+        .open           = hostaudio_open,
+        .release        = hostaudio_release,
+};
+
+static struct file_operations hostmixer_fops = {
+        .owner          = THIS_MODULE,
+        .llseek         = no_llseek,
+        .ioctl          = hostmixer_ioctl_mixdev,
+        .open           = hostmixer_open_mixdev,
+        .release        = hostmixer_release,
+};
+
+struct {
+	int dev_audio;
+	int dev_mixer;
+} module_data;
+
+MODULE_AUTHOR("Steve Schmidtke");
+MODULE_DESCRIPTION("UML Audio Relay");
+MODULE_LICENSE("GPL");
+
+static int __init hostaudio_init_module(void)
+{
+        printk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",
+	       dsp, mixer);
+
+	module_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);
+        if(module_data.dev_audio < 0){
+                printk(KERN_ERR "hostaudio: couldn't register DSP device!\n");
+                return -ENODEV;
+        }
+
+	module_data.dev_mixer = register_sound_mixer(&hostmixer_fops, -1);
+        if(module_data.dev_mixer < 0){
+                printk(KERN_ERR "hostmixer: couldn't register mixer "
+		       "device!\n");
+                unregister_sound_dsp(module_data.dev_audio);
+                return -ENODEV;
+        }
+
+        return 0;
+}
+
+static void __exit hostaudio_cleanup_module (void)
+{
+       unregister_sound_mixer(module_data.dev_mixer);
+       unregister_sound_dsp(module_data.dev_audio);
+}
+
+module_init(hostaudio_init_module);
+module_exit(hostaudio_cleanup_module);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-file-style: "linux"
+ * End:
+ */
