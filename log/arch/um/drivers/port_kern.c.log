commit dbddf429dc514257170d4c5e116cbd95a86408ab
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:16 2019 +0100

    um: Add SPDX headers for files in arch/um/drivers
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index b0e9ff35daee..a47ca5376d9d 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{linux.intel,addtoit}.com)
- * Licensed under the GPL
  */
 
 #include <linux/completion.h>

commit 940b241d9050fc354f68c182e99fc3da1ff36bc0
Author: Anton Ivanov <anton.ivanov@cambridgegreys.com>
Date:   Tue Nov 13 15:08:02 2018 +0000

    um: Remove obsolete reenable_XX calls
    
    reenable_fd has been a NOP since the introduction of the EPOLL
    based interrupt controller.
    reenable_channel() is no longer needed as the flow control is
    now handled via the write IRQs on the channel.
    
    Signed-off-by: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 40ca5cc275e9..b0e9ff35daee 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -137,7 +137,6 @@ static void port_work_proc(struct work_struct *unused)
 		if (!port->has_connection)
 			continue;
 
-		reactivate_fd(port->fd, ACCEPT_IRQ);
 		while (port_accept(port))
 			;
 		port->has_connection = 0;

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 1d83d50236e1..40ca5cc275e9 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -3,16 +3,16 @@
  * Licensed under the GPL
  */
 
-#include "linux/completion.h"
-#include "linux/interrupt.h"
-#include "linux/list.h"
-#include "linux/mutex.h"
-#include "linux/slab.h"
-#include "linux/workqueue.h"
-#include "asm/atomic.h"
-#include "init.h"
-#include "irq_kern.h"
-#include "os.h"
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <asm/atomic.h>
+#include <init.h>
+#include <irq_kern.h>
+#include <os.h>
 #include "port.h"
 
 struct port_list {

commit aab944606f9490f158d3b28f6c44a33c4701a5b3
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue Jul 17 14:18:23 2012 -0400

    um: remove IRQF_SAMPLE_RANDOM which is now a no-op
    
    With the changes in the random tree, IRQF_SAMPLE_RANDOM is now a
    no-op; interrupt randomness is now collected unconditionally in a very
    low-overhead fashion; see commit 775f4b297b.  The IRQF_SAMPLE_RANDOM
    flag was scheduled to be removed in 2009 on the
    feature-removal-schedule, so this patch is preparation for the final
    removal of this flag.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 11866ffd45a9..1d83d50236e1 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -100,8 +100,7 @@ static int port_accept(struct port_list *port)
 		  .port 	= port });
 
 	if (um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
-			  IRQF_SHARED | IRQF_SAMPLE_RANDOM,
-			  "telnetd", conn)) {
+			  IRQF_SHARED, "telnetd", conn)) {
 		printk(KERN_ERR "port_accept : failed to get IRQ for "
 		       "telnetd\n");
 		goto out_free;
@@ -184,8 +183,7 @@ void *port_data(int port_num)
 	}
 
 	if (um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
-			  IRQF_SHARED | IRQF_SAMPLE_RANDOM,
-			  "port", port)) {
+			  IRQF_SHARED, "port", port)) {
 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
 		goto out_close;
 	}

commit fa7a0449e0ea6588f64c06a045ea8728280f3457
Author: Richard Weinberger <richard@nod.at>
Date:   Tue Apr 17 22:37:13 2012 +0200

    um: Implement um_free_irq()
    
    Instead of using chip->release() we can achieve the same
    using a simple wrapper for free_irq().
    We have already um_request_irq(), so um_free_irq() is the perfect
    counterpart.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index e31680e662a4..11866ffd45a9 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -254,7 +254,7 @@ int port_wait(void *data)
 		 * connection.  Then we loop here throwing out failed
 		 * connections until a good one is found.
 		 */
-		free_irq(TELNETD_IRQ, conn);
+		um_free_irq(TELNETD_IRQ, conn);
 
 		if (conn->fd >= 0)
 			break;

commit c0b79a90b1556a7e51d7a49a655eb60306f6258d
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:58:46 2011 +0800

    um: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index a11573be0961..e31680e662a4 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -100,7 +100,7 @@ static int port_accept(struct port_list *port)
 		  .port 	= port });
 
 	if (um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			  IRQF_SHARED | IRQF_SAMPLE_RANDOM,
 			  "telnetd", conn)) {
 		printk(KERN_ERR "port_accept : failed to get IRQ for "
 		       "telnetd\n");
@@ -184,7 +184,7 @@ void *port_data(int port_num)
 	}
 
 	if (um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			  IRQF_SHARED | IRQF_SAMPLE_RANDOM,
 			  "port", port)) {
 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
 		goto out_close;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 4ebc8a34738f..a11573be0961 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -7,6 +7,7 @@
 #include "linux/interrupt.h"
 #include "linux/list.h"
 #include "linux/mutex.h"
+#include "linux/slab.h"
 #include "linux/workqueue.h"
 #include "asm/atomic.h"
 #include "init.h"

commit d43c36dc6b357fa1806800f18aa30123c747a6d1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Oct 7 17:09:06 2009 +0400

    headers: remove sched.h from interrupt.h
    
    After m68k's task_thread_info() doesn't refer to current,
    it's possible to remove sched.h from interrupt.h and not break m68k!
    Many thanks to Heiko Carstens for allowing this.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 19930081d3d8..4ebc8a34738f 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -7,6 +7,7 @@
 #include "linux/interrupt.h"
 #include "linux/list.h"
 #include "linux/mutex.h"
+#include "linux/workqueue.h"
 #include "asm/atomic.h"
 #include "init.h"
 #include "irq_kern.h"

commit 2aa9c5db8e1eadf12a6c938dbd3e39ba6b923b8c
Author: Daniel Walker <dwalker@mvista.com>
Date:   Mon Feb 4 22:31:27 2008 -0800

    uml: port mutex conversion
    
    The port_sem is already used as a mutex since it's using DECLARE_MUTEX(), but
    the underlying construct is still a semaphore ..  This patch switches it over
    to a struct mutex.
    
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 330543b3129b..19930081d3d8 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -6,6 +6,7 @@
 #include "linux/completion.h"
 #include "linux/interrupt.h"
 #include "linux/list.h"
+#include "linux/mutex.h"
 #include "asm/atomic.h"
 #include "init.h"
 #include "irq_kern.h"
@@ -120,7 +121,7 @@ static int port_accept(struct port_list *port)
 	return 0;
 }
 
-static DECLARE_MUTEX(ports_sem);
+static DEFINE_MUTEX(ports_mutex);
 static LIST_HEAD(ports);
 
 static void port_work_proc(struct work_struct *unused)
@@ -161,7 +162,7 @@ void *port_data(int port_num)
 	struct port_dev *dev = NULL;
 	int fd;
 
-	down(&ports_sem);
+	mutex_lock(&ports_mutex);
 	list_for_each(ele, &ports) {
 		port = list_entry(ele, struct port_list, list);
 		if (port->port == port_num)
@@ -216,7 +217,7 @@ void *port_data(int port_num)
  out_free:
 	kfree(port);
  out:
-	up(&ports_sem);
+	mutex_unlock(&ports_mutex);
 	return dev;
 }
 

commit e99525f9706900417f37721e601d2b414d41bfee
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:41 2007 -0700

    uml: console subsystem tidying
    
    This does a lot of cleanup on the UML console system.  This patch should be
    entirely non-functional.
    
    The tidying is as follows:
            header cleanups - the includes should be closer to minimal and complete
            all printks now have a severity
            lots of style fixes
            fd_close is restructured a little in order to reduce the nesting
            some functions were calling the os_* wrappers when they can
    call libc directly
            port_accept had a unnecessary variable
            it also tested a pid unecessarily before killing it
            some functions were made static
            xterm_free is gone, as it was identical to generic_free
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index d8acf7470e70..330543b3129b 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -1,24 +1,16 @@
 /*
- * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{linux.intel,addtoit}.com)
  * Licensed under the GPL
  */
 
-#include "linux/list.h"
-#include "linux/sched.h"
-#include "linux/slab.h"
+#include "linux/completion.h"
 #include "linux/interrupt.h"
-#include "linux/spinlock.h"
-#include "linux/errno.h"
+#include "linux/list.h"
 #include "asm/atomic.h"
-#include "asm/semaphore.h"
-#include "asm/errno.h"
-#include "kern_util.h"
-#include "kern.h"
-#include "irq_user.h"
-#include "irq_kern.h"
-#include "port.h"
 #include "init.h"
+#include "irq_kern.h"
 #include "os.h"
+#include "port.h"
 
 struct port_list {
 	struct list_head list;
@@ -53,8 +45,8 @@ static irqreturn_t pipe_interrupt(int irq, void *data)
 	int fd;
 
 	fd = os_rcv_fd(conn->socket[0], &conn->helper_pid);
-	if(fd < 0){
-		if(fd == -EAGAIN)
+	if (fd < 0) {
+		if (fd == -EAGAIN)
 			return IRQ_NONE;
 
 		printk(KERN_ERR "pipe_interrupt : os_rcv_fd returned %d\n",
@@ -81,18 +73,18 @@ static irqreturn_t pipe_interrupt(int irq, void *data)
 static int port_accept(struct port_list *port)
 {
 	struct connection *conn;
-	int fd, socket[2], pid, ret = 0;
+	int fd, socket[2], pid;
 
 	fd = port_connection(port->fd, socket, &pid);
-	if(fd < 0){
-		if(fd != -EAGAIN)
+	if (fd < 0) {
+		if (fd != -EAGAIN)
 			printk(KERN_ERR "port_accept : port_connection "
 			       "returned %d\n", -fd);
 		goto out;
 	}
 
 	conn = kmalloc(sizeof(*conn), GFP_ATOMIC);
-	if(conn == NULL){
+	if (conn == NULL) {
 		printk(KERN_ERR "port_accept : failed to allocate "
 		       "connection\n");
 		goto out_close;
@@ -104,17 +96,17 @@ static int port_accept(struct port_list *port)
 		  .telnetd_pid 	= pid,
 		  .port 	= port });
 
-	if(um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
+	if (um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
 			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
-			  "telnetd", conn)){
+			  "telnetd", conn)) {
 		printk(KERN_ERR "port_accept : failed to get IRQ for "
 		       "telnetd\n");
 		goto out_free;
 	}
 
-	if(atomic_read(&port->wait_count) == 0){
+	if (atomic_read(&port->wait_count) == 0) {
 		os_write_file(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
-		printk("No one waiting for port\n");
+		printk(KERN_ERR "No one waiting for port\n");
 	}
 	list_add(&conn->list, &port->pending);
 	return 1;
@@ -123,28 +115,29 @@ static int port_accept(struct port_list *port)
 	kfree(conn);
  out_close:
 	os_close_file(fd);
-	if(pid != -1)
-		os_kill_process(pid, 1);
+	os_kill_process(pid, 1);
  out:
-	return ret;
+	return 0;
 }
 
 static DECLARE_MUTEX(ports_sem);
 static LIST_HEAD(ports);
 
-void port_work_proc(struct work_struct *unused)
+static void port_work_proc(struct work_struct *unused)
 {
 	struct port_list *port;
 	struct list_head *ele;
 	unsigned long flags;
 
 	local_irq_save(flags);
-	list_for_each(ele, &ports){
+	list_for_each(ele, &ports) {
 		port = list_entry(ele, struct port_list, list);
-		if(!port->has_connection)
+		if (!port->has_connection)
 			continue;
+
 		reactivate_fd(port->fd, ACCEPT_IRQ);
-		while(port_accept(port)) ;
+		while (port_accept(port))
+			;
 		port->has_connection = 0;
 	}
 	local_irq_restore(flags);
@@ -169,25 +162,27 @@ void *port_data(int port_num)
 	int fd;
 
 	down(&ports_sem);
-	list_for_each(ele, &ports){
+	list_for_each(ele, &ports) {
 		port = list_entry(ele, struct port_list, list);
-		if(port->port == port_num) goto found;
+		if (port->port == port_num)
+			goto found;
 	}
 	port = kmalloc(sizeof(struct port_list), GFP_KERNEL);
-	if(port == NULL){
+	if (port == NULL) {
 		printk(KERN_ERR "Allocation of port list failed\n");
 		goto out;
 	}
 
 	fd = port_listen_fd(port_num);
-	if(fd < 0){
+	if (fd < 0) {
 		printk(KERN_ERR "binding to port %d failed, errno = %d\n",
 		       port_num, -fd);
 		goto out_free;
 	}
-	if(um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
+
+	if (um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
 			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
-			  "port", port)){
+			  "port", port)) {
 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
 		goto out_close;
 	}
@@ -206,7 +201,7 @@ void *port_data(int port_num)
 
  found:
 	dev = kmalloc(sizeof(struct port_dev), GFP_KERNEL);
-	if(dev == NULL){
+	if (dev == NULL) {
 		printk(KERN_ERR "Allocation of port device entry failed\n");
 		goto out;
 	}
@@ -233,9 +228,9 @@ int port_wait(void *data)
 	int fd;
 
 	atomic_inc(&port->wait_count);
-	while(1){
+	while (1) {
 		fd = -ERESTARTSYS;
-		if(wait_for_completion_interruptible(&port->done))
+		if (wait_for_completion_interruptible(&port->done))
 			goto out;
 
 		spin_lock(&port->lock);
@@ -258,7 +253,8 @@ int port_wait(void *data)
 		 */
 		free_irq(TELNETD_IRQ, conn);
 
-		if(conn->fd >= 0) break;
+		if (conn->fd >= 0)
+			break;
 		os_close_file(conn->fd);
 		kfree(conn);
 	}
@@ -276,9 +272,9 @@ void port_remove_dev(void *d)
 {
 	struct port_dev *dev = d;
 
-	if(dev->helper_pid != -1)
+	if (dev->helper_pid != -1)
 		os_kill_process(dev->helper_pid, 0);
-	if(dev->telnetd_pid != -1)
+	if (dev->telnetd_pid != -1)
 		os_kill_process(dev->telnetd_pid, 1);
 	dev->helper_pid = -1;
 	dev->telnetd_pid = -1;
@@ -297,7 +293,7 @@ static void free_port(void)
 	struct list_head *ele;
 	struct port_list *port;
 
-	list_for_each(ele, &ports){
+	list_for_each(ele, &ports) {
 		port = list_entry(ele, struct port_list, list);
 		free_irq_by_fd(port->fd);
 		os_close_file(port->fd);

commit 79f662334fefa2dd3fdf66c44a4d2dca5e378ab4
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:40 2007 -0700

    uml: fix error cleanup ordering
    
    I messed up the error cleanup ordering in the console port driver.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 1c8efd95c421..d8acf7470e70 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -216,10 +216,10 @@ void *port_data(int port_num)
 				    .telnetd_pid  	= -1 });
 	goto out;
 
- out_free:
-	kfree(port);
  out_close:
 	os_close_file(fd);
+ out_free:
+	kfree(port);
  out:
 	up(&ports_sem);
 	return dev;

commit a6ea4cceed18edebe1eb6001cb9e0f88cd741a6c
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:43 2007 -0700

    uml: rename os_{read_write}_file_k back to os_{read_write}_file
    
    Rename os_{read_write}_file_k back to os_{read_write}_file, delete
    the originals and their bogus infrastructure, and fix all the callers.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 75bb40126c2e..1c8efd95c421 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -113,7 +113,7 @@ static int port_accept(struct port_list *port)
 	}
 
 	if(atomic_read(&port->wait_count) == 0){
-		os_write_file_k(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
+		os_write_file(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
 		printk("No one waiting for port\n");
 	}
 	list_add(&conn->list, &port->pending);

commit 3d564047a5f45cb628ec72514f68076e532988f3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:32 2007 -0700

    uml: start fixing os_read_file and os_write_file
    
    This patch starts the removal of a very old, very broken piece of code.  This
    stems from the problem of passing a userspace buffer into read() or write() on
    the host.  If that buffer had not yet been faulted in, read and write will
    return -EFAULT.
    
    To avoid this problem, the solution was to fault the buffer in before the
    system call by touching the pages that hold the buffer by doing a copy-user of
    a byte to each page.  This is obviously bogus, but it does usually work, in tt
    mode, since the kernel and process are in the same address space and userspace
    addresses can be accessed directly in the kernel.
    
    In skas mode, where the kernel and process are in separate address spaces, it
    is completely bogus because the userspace address, which is invalid in the
    kernel, is passed into the system call instead of the corresponding physical
    address, which would be valid.  Here, it appears that this code, on every host
    read() or write(), tries to fault in a random process page.  This doesn't seem
    to cause any correctness problems, but there is a performance impact.  This
    patch, and the ones following, result in a 10-15% performance gain on a kernel
    build.
    
    This code can't be immediately tossed out because when it is, you can't log
    in.  Apparently, there is some code in the console driver which depends on
    this somehow.
    
    However, we can start removing it by switching the code which does I/O using
    kernel addresses to using plain read() and write().  This patch introduces
    os_read_file_k and os_write_file_k for use with kernel buffers and converts
    all call locations which use obvious kernel buffers to use them.  These
    include I/O using buffers which are local variables which are on the stack or
    kmalloc-ed.  Later patches will handle the less obvious cases, followed by a
    mass conversion back to the original interface.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 1c8efd95c421..75bb40126c2e 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -113,7 +113,7 @@ static int port_accept(struct port_list *port)
 	}
 
 	if(atomic_read(&port->wait_count) == 0){
-		os_write_file(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
+		os_write_file_k(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
 		printk("No one waiting for port\n");
 	}
 	list_add(&conn->list, &port->pending);

commit c59bce6262f9511c8e2504231f60609bf7332833
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:04 2007 -0800

    [PATCH] uml: use LIST_HEAD where possible
    
    A couple of list_head declarations can be improved through the use of
    LIST_HEAD().
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 4dd7d8a11db2..1c8efd95c421 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -130,7 +130,7 @@ static int port_accept(struct port_list *port)
 }
 
 static DECLARE_MUTEX(ports_sem);
-static struct list_head ports = LIST_HEAD_INIT(ports);
+static LIST_HEAD(ports);
 
 void port_work_proc(struct work_struct *unused)
 {

commit 67608e0c809ceca1b44755ee818199af7478ca77
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:02 2007 -0800

    [PATCH] uml: port driver formatting
    
    Whitespace and style fixes.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index c688da722177..4dd7d8a11db2 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
  * Licensed under the GPL
  */
@@ -55,9 +55,9 @@ static irqreturn_t pipe_interrupt(int irq, void *data)
 	fd = os_rcv_fd(conn->socket[0], &conn->helper_pid);
 	if(fd < 0){
 		if(fd == -EAGAIN)
-			return(IRQ_NONE);
+			return IRQ_NONE;
 
-		printk(KERN_ERR "pipe_interrupt : os_rcv_fd returned %d\n", 
+		printk(KERN_ERR "pipe_interrupt : os_rcv_fd returned %d\n",
 		       -fd);
 		os_close_file(conn->fd);
 	}
@@ -68,7 +68,7 @@ static irqreturn_t pipe_interrupt(int irq, void *data)
 	list_add(&conn->list, &conn->port->connections);
 
 	complete(&conn->port->done);
-	return(IRQ_HANDLED);
+	return IRQ_HANDLED;
 }
 
 #define NO_WAITER_MSG \
@@ -97,14 +97,14 @@ static int port_accept(struct port_list *port)
 		       "connection\n");
 		goto out_close;
 	}
-	*conn = ((struct connection) 
+	*conn = ((struct connection)
 		{ .list 	= LIST_HEAD_INIT(conn->list),
 		  .fd 		= fd,
 		  .socket  	= { socket[0], socket[1] },
 		  .telnetd_pid 	= pid,
 		  .port 	= port });
 
-	if(um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt, 
+	if(um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
 			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
 			  "telnetd", conn)){
 		printk(KERN_ERR "port_accept : failed to get IRQ for "
@@ -117,17 +117,17 @@ static int port_accept(struct port_list *port)
 		printk("No one waiting for port\n");
 	}
 	list_add(&conn->list, &port->pending);
-	return(1);
+	return 1;
 
  out_free:
 	kfree(conn);
  out_close:
 	os_close_file(fd);
-	if(pid != -1) 
+	if(pid != -1)
 		os_kill_process(pid, 1);
  out:
-	return(ret);
-} 
+	return ret;
+}
 
 static DECLARE_MUTEX(ports_sem);
 static struct list_head ports = LIST_HEAD_INIT(ports);
@@ -158,8 +158,8 @@ static irqreturn_t port_interrupt(int irq, void *data)
 
 	port->has_connection = 1;
 	schedule_work(&port_work);
-	return(IRQ_HANDLED);
-} 
+	return IRQ_HANDLED;
+}
 
 void *port_data(int port_num)
 {
@@ -185,14 +185,14 @@ void *port_data(int port_num)
 		       port_num, -fd);
 		goto out_free;
 	}
-	if(um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt, 
-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM, "port",
-			  port)){
+	if(um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
+			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			  "port", port)){
 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
 		goto out_close;
 	}
 
-	*port = ((struct port_list) 
+	*port = ((struct port_list)
 		{ .list 	 	= LIST_HEAD_INIT(port->list),
 		  .wait_count		= ATOMIC_INIT(0),
 		  .has_connection 	= 0,
@@ -222,7 +222,7 @@ void *port_data(int port_num)
 	os_close_file(fd);
  out:
 	up(&ports_sem);
-	return(dev);
+	return dev;
 }
 
 int port_wait(void *data)
@@ -232,15 +232,15 @@ int port_wait(void *data)
 	struct port_list *port = dev->port;
 	int fd;
 
-        atomic_inc(&port->wait_count);
+	atomic_inc(&port->wait_count);
 	while(1){
 		fd = -ERESTARTSYS;
-                if(wait_for_completion_interruptible(&port->done))
-                        goto out;
+		if(wait_for_completion_interruptible(&port->done))
+			goto out;
 
 		spin_lock(&port->lock);
 
-		conn = list_entry(port->connections.next, struct connection, 
+		conn = list_entry(port->connections.next, struct connection,
 				  list);
 		list_del(&conn->list);
 		spin_unlock(&port->lock);
@@ -248,12 +248,12 @@ int port_wait(void *data)
 		os_shutdown_socket(conn->socket[0], 1, 1);
 		os_close_file(conn->socket[0]);
 		os_shutdown_socket(conn->socket[1], 1, 1);
-		os_close_file(conn->socket[1]);	
+		os_close_file(conn->socket[1]);
 
 		/* This is done here because freeing an IRQ can't be done
 		 * within the IRQ handler.  So, pipe_interrupt always ups
 		 * the semaphore regardless of whether it got a successful
-		 * connection.  Then we loop here throwing out failed 
+		 * connection.  Then we loop here throwing out failed
 		 * connections until a good one is found.
 		 */
 		free_irq(TELNETD_IRQ, conn);

commit d832fc60d533d52da7170cf5f95271c331259bca
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sat Feb 10 01:44:01 2007 -0800

    [PATCH] uml: make two variables static
    
    Make a couple of variables static.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 6dfe632f1c14..c688da722177 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -129,8 +129,8 @@ static int port_accept(struct port_list *port)
 	return(ret);
 } 
 
-DECLARE_MUTEX(ports_sem);
-struct list_head ports = LIST_HEAD_INIT(ports);
+static DECLARE_MUTEX(ports_sem);
+static struct list_head ports = LIST_HEAD_INIT(ports);
 
 void port_work_proc(struct work_struct *unused)
 {

commit 6d5aefb8eaa38e44b5b8cf60c812aceafc02d924
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 19:36:26 2006 +0000

    WorkQueue: Fix up arch-specific work items where possible
    
    Fix up arch-specific work items where possible to use the new work_struct and
    delayed_work structs.
    
    Three places that enqueue bits of their stack and then return have been marked
    with #error as this is not permitted.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index ce9f3733f73e..6dfe632f1c14 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -132,7 +132,7 @@ static int port_accept(struct port_list *port)
 DECLARE_MUTEX(ports_sem);
 struct list_head ports = LIST_HEAD_INIT(ports);
 
-void port_work_proc(void *unused)
+void port_work_proc(struct work_struct *unused)
 {
 	struct port_list *port;
 	struct list_head *ele;
@@ -150,7 +150,7 @@ void port_work_proc(void *unused)
 	local_irq_restore(flags);
 }
 
-DECLARE_WORK(port_work, port_work_proc, NULL);
+DECLARE_WORK(port_work, port_work_proc);
 
 static irqreturn_t port_interrupt(int irq, void *data)
 {

commit 7bea96fd22a8fd19f90817405b4abe032317a0e3
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 8 22:49:34 2006 +0100

    [PATCH] uml pt_regs fixes
    
    Real fix for UML pt_regs stuff.  Note set_irq_regs() logics in there...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 73755f37a8a8..ce9f3733f73e 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -47,7 +47,7 @@ struct connection {
 	struct port_list *port;
 };
 
-static irqreturn_t pipe_interrupt(int irq, void *data, struct pt_regs *regs)
+static irqreturn_t pipe_interrupt(int irq, void *data)
 {
 	struct connection *conn = data;
 	int fd;
@@ -152,7 +152,7 @@ void port_work_proc(void *unused)
 
 DECLARE_WORK(port_work, port_work_proc, NULL);
 
-static irqreturn_t port_interrupt(int irq, void *data, struct pt_regs *regs)
+static irqreturn_t port_interrupt(int irq, void *data)
 {
 	struct port_list *port = data;
 

commit bd6aa6502e7f82c39090aea29e4b644c29e720bd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:27 2006 -0700

    [PATCH] irq-flags: UM: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index 189839e4f1d4..73755f37a8a8 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -105,7 +105,7 @@ static int port_accept(struct port_list *port)
 		  .port 	= port });
 
 	if(um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt, 
-			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, 
+			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
 			  "telnetd", conn)){
 		printk(KERN_ERR "port_accept : failed to get IRQ for "
 		       "telnetd\n");
@@ -186,7 +186,7 @@ void *port_data(int port_num)
 		goto out_free;
 	}
 	if(um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt, 
-			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, "port",
+			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM, "port",
 			  port)){
 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
 		goto out_close;

commit 74ba1fd96666170338dc732480b35b7a83cd164b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Sep 30 03:16:43 2005 +0100

    [PATCH] useless linux/irq.h includes (arch/um)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index c41efd207fcc..189839e4f1d4 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -7,7 +7,6 @@
 #include "linux/sched.h"
 #include "linux/slab.h"
 #include "linux/interrupt.h"
-#include "linux/irq.h"
 #include "linux/spinlock.h"
 #include "linux/errno.h"
 #include "asm/atomic.h"

commit dbce706e2550253c5ab6043f4f5dfde0cd02470f
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Tue Jun 21 17:16:19 2005 -0700

    [PATCH] uml: add and use generic hw_controller_type->release
    
    With Chris Wedgwood <cw@f00f.org>
    
    Currently UML must explicitly call the UML-specific
    free_irq_by_irq_and_dev() for each free_irq call it's done.
    
    This is needed because ->shutdown and/or ->disable are only called when the
    last "action" for that irq is removed.
    
    Instead, for UML shared IRQs (UML IRQs are very often, if not always,
    shared), for each dev_id some setup is done, which must be cleared on the
    release of that fd.  For instance, for each open console a new instance
    (i.e.  new dev_id) of the same IRQ is requested().
    
    Exactly, a fd is stored in an array (pollfds), which is after read by a
    host thread and passed to poll().  Each event registered by poll() triggers
    an interrupt.  So, for each free_irq() we must remove the corresponding
    host fd from the table, which we do via this -release() method.
    
    In this patch we add an appropriate hook for this, and remove all uses of
    it by pointing the hook to the said procedure; this is safe to do since the
    said procedure.
    
    Also some cosmetic improvements are included.
    
    This is heavily based on some work by Chris Wedgwood, which however didn't
    get the patch merged for something I'd call a "misunderstanding" (the need
    for this patch wasn't cleanly explained, thus adding the generic hook was
    felt as undesirable).
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    CC: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
index b5ee07472f79..c41efd207fcc 100644
--- a/arch/um/drivers/port_kern.c
+++ b/arch/um/drivers/port_kern.c
@@ -257,7 +257,6 @@ int port_wait(void *data)
 		 * connection.  Then we loop here throwing out failed 
 		 * connections until a good one is found.
 		 */
-		free_irq_by_irq_and_dev(TELNETD_IRQ, conn);
 		free_irq(TELNETD_IRQ, conn);
 
 		if(conn->fd >= 0) break;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/um/drivers/port_kern.c b/arch/um/drivers/port_kern.c
new file mode 100644
index 000000000000..b5ee07472f79
--- /dev/null
+++ b/arch/um/drivers/port_kern.c
@@ -0,0 +1,309 @@
+/* 
+ * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include "linux/list.h"
+#include "linux/sched.h"
+#include "linux/slab.h"
+#include "linux/interrupt.h"
+#include "linux/irq.h"
+#include "linux/spinlock.h"
+#include "linux/errno.h"
+#include "asm/atomic.h"
+#include "asm/semaphore.h"
+#include "asm/errno.h"
+#include "kern_util.h"
+#include "kern.h"
+#include "irq_user.h"
+#include "irq_kern.h"
+#include "port.h"
+#include "init.h"
+#include "os.h"
+
+struct port_list {
+	struct list_head list;
+	atomic_t wait_count;
+	int has_connection;
+	struct completion done;
+	int port;
+	int fd;
+	spinlock_t lock;
+	struct list_head pending;
+	struct list_head connections;
+};
+
+struct port_dev {
+	struct port_list *port;
+	int helper_pid;
+	int telnetd_pid;
+};
+
+struct connection {
+	struct list_head list;
+	int fd;
+	int helper_pid;
+	int socket[2];
+	int telnetd_pid;
+	struct port_list *port;
+};
+
+static irqreturn_t pipe_interrupt(int irq, void *data, struct pt_regs *regs)
+{
+	struct connection *conn = data;
+	int fd;
+
+	fd = os_rcv_fd(conn->socket[0], &conn->helper_pid);
+	if(fd < 0){
+		if(fd == -EAGAIN)
+			return(IRQ_NONE);
+
+		printk(KERN_ERR "pipe_interrupt : os_rcv_fd returned %d\n", 
+		       -fd);
+		os_close_file(conn->fd);
+	}
+
+	list_del(&conn->list);
+
+	conn->fd = fd;
+	list_add(&conn->list, &conn->port->connections);
+
+	complete(&conn->port->done);
+	return(IRQ_HANDLED);
+}
+
+#define NO_WAITER_MSG \
+    "****\n" \
+    "There are currently no UML consoles waiting for port connections.\n" \
+    "Either disconnect from one to make it available or activate some more\n" \
+    "by enabling more consoles in the UML /etc/inittab.\n" \
+    "****\n"
+
+static int port_accept(struct port_list *port)
+{
+	struct connection *conn;
+	int fd, socket[2], pid, ret = 0;
+
+	fd = port_connection(port->fd, socket, &pid);
+	if(fd < 0){
+		if(fd != -EAGAIN)
+			printk(KERN_ERR "port_accept : port_connection "
+			       "returned %d\n", -fd);
+		goto out;
+	}
+
+	conn = kmalloc(sizeof(*conn), GFP_ATOMIC);
+	if(conn == NULL){
+		printk(KERN_ERR "port_accept : failed to allocate "
+		       "connection\n");
+		goto out_close;
+	}
+	*conn = ((struct connection) 
+		{ .list 	= LIST_HEAD_INIT(conn->list),
+		  .fd 		= fd,
+		  .socket  	= { socket[0], socket[1] },
+		  .telnetd_pid 	= pid,
+		  .port 	= port });
+
+	if(um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt, 
+			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, 
+			  "telnetd", conn)){
+		printk(KERN_ERR "port_accept : failed to get IRQ for "
+		       "telnetd\n");
+		goto out_free;
+	}
+
+	if(atomic_read(&port->wait_count) == 0){
+		os_write_file(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));
+		printk("No one waiting for port\n");
+	}
+	list_add(&conn->list, &port->pending);
+	return(1);
+
+ out_free:
+	kfree(conn);
+ out_close:
+	os_close_file(fd);
+	if(pid != -1) 
+		os_kill_process(pid, 1);
+ out:
+	return(ret);
+} 
+
+DECLARE_MUTEX(ports_sem);
+struct list_head ports = LIST_HEAD_INIT(ports);
+
+void port_work_proc(void *unused)
+{
+	struct port_list *port;
+	struct list_head *ele;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	list_for_each(ele, &ports){
+		port = list_entry(ele, struct port_list, list);
+		if(!port->has_connection)
+			continue;
+		reactivate_fd(port->fd, ACCEPT_IRQ);
+		while(port_accept(port)) ;
+		port->has_connection = 0;
+	}
+	local_irq_restore(flags);
+}
+
+DECLARE_WORK(port_work, port_work_proc, NULL);
+
+static irqreturn_t port_interrupt(int irq, void *data, struct pt_regs *regs)
+{
+	struct port_list *port = data;
+
+	port->has_connection = 1;
+	schedule_work(&port_work);
+	return(IRQ_HANDLED);
+} 
+
+void *port_data(int port_num)
+{
+	struct list_head *ele;
+	struct port_list *port;
+	struct port_dev *dev = NULL;
+	int fd;
+
+	down(&ports_sem);
+	list_for_each(ele, &ports){
+		port = list_entry(ele, struct port_list, list);
+		if(port->port == port_num) goto found;
+	}
+	port = kmalloc(sizeof(struct port_list), GFP_KERNEL);
+	if(port == NULL){
+		printk(KERN_ERR "Allocation of port list failed\n");
+		goto out;
+	}
+
+	fd = port_listen_fd(port_num);
+	if(fd < 0){
+		printk(KERN_ERR "binding to port %d failed, errno = %d\n",
+		       port_num, -fd);
+		goto out_free;
+	}
+	if(um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt, 
+			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, "port",
+			  port)){
+		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
+		goto out_close;
+	}
+
+	*port = ((struct port_list) 
+		{ .list 	 	= LIST_HEAD_INIT(port->list),
+		  .wait_count		= ATOMIC_INIT(0),
+		  .has_connection 	= 0,
+		  .port 	 	= port_num,
+		  .fd  			= fd,
+		  .pending 		= LIST_HEAD_INIT(port->pending),
+		  .connections 		= LIST_HEAD_INIT(port->connections) });
+	spin_lock_init(&port->lock);
+	init_completion(&port->done);
+	list_add(&port->list, &ports);
+
+ found:
+	dev = kmalloc(sizeof(struct port_dev), GFP_KERNEL);
+	if(dev == NULL){
+		printk(KERN_ERR "Allocation of port device entry failed\n");
+		goto out;
+	}
+
+	*dev = ((struct port_dev) { .port  		= port,
+				    .helper_pid  	= -1,
+				    .telnetd_pid  	= -1 });
+	goto out;
+
+ out_free:
+	kfree(port);
+ out_close:
+	os_close_file(fd);
+ out:
+	up(&ports_sem);
+	return(dev);
+}
+
+int port_wait(void *data)
+{
+	struct port_dev *dev = data;
+	struct connection *conn;
+	struct port_list *port = dev->port;
+	int fd;
+
+        atomic_inc(&port->wait_count);
+	while(1){
+		fd = -ERESTARTSYS;
+                if(wait_for_completion_interruptible(&port->done))
+                        goto out;
+
+		spin_lock(&port->lock);
+
+		conn = list_entry(port->connections.next, struct connection, 
+				  list);
+		list_del(&conn->list);
+		spin_unlock(&port->lock);
+
+		os_shutdown_socket(conn->socket[0], 1, 1);
+		os_close_file(conn->socket[0]);
+		os_shutdown_socket(conn->socket[1], 1, 1);
+		os_close_file(conn->socket[1]);	
+
+		/* This is done here because freeing an IRQ can't be done
+		 * within the IRQ handler.  So, pipe_interrupt always ups
+		 * the semaphore regardless of whether it got a successful
+		 * connection.  Then we loop here throwing out failed 
+		 * connections until a good one is found.
+		 */
+		free_irq_by_irq_and_dev(TELNETD_IRQ, conn);
+		free_irq(TELNETD_IRQ, conn);
+
+		if(conn->fd >= 0) break;
+		os_close_file(conn->fd);
+		kfree(conn);
+	}
+
+	fd = conn->fd;
+	dev->helper_pid = conn->helper_pid;
+	dev->telnetd_pid = conn->telnetd_pid;
+	kfree(conn);
+ out:
+	atomic_dec(&port->wait_count);
+	return fd;
+}
+
+void port_remove_dev(void *d)
+{
+	struct port_dev *dev = d;
+
+	if(dev->helper_pid != -1)
+		os_kill_process(dev->helper_pid, 0);
+	if(dev->telnetd_pid != -1)
+		os_kill_process(dev->telnetd_pid, 1);
+	dev->helper_pid = -1;
+	dev->telnetd_pid = -1;
+}
+
+void port_kern_free(void *d)
+{
+	struct port_dev *dev = d;
+
+	port_remove_dev(dev);
+	kfree(dev);
+}
+
+static void free_port(void)
+{
+	struct list_head *ele;
+	struct port_list *port;
+
+	list_for_each(ele, &ports){
+		port = list_entry(ele, struct port_list, list);
+		free_irq_by_fd(port->fd);
+		os_close_file(port->fd);
+	}
+}
+
+__uml_exitcall(free_port);
