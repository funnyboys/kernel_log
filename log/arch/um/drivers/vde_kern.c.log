commit dbddf429dc514257170d4c5e116cbd95a86408ab
Author: Alex Dewar <alex.dewar@gmx.co.uk>
Date:   Sun Aug 25 10:49:16 2019 +0100

    um: Add SPDX headers for files in arch/um/drivers
    
    Convert files to use SPDX header. All files are licensed under the GPLv2.
    
    Signed-off-by: Alex Dewar <alex.dewar@gmx.co.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
index 6a365fadc7c4..bc6f22cbfb35 100644
--- a/arch/um/drivers/vde_kern.c
+++ b/arch/um/drivers/vde_kern.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007 Luca Bigliardi (shammash@artha.org).
- * Licensed under the GPL.
  *
  * Transport usage:
  *  ethN=vde,<vde_switch>,<mac addr>,<port>,<group>,<mode>,<description>

commit 37185b33240870719b6b5913a46e6a441f1ae96f
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Oct 8 03:27:32 2012 +0100

    um: get rid of pointless include "..." where include <...> will do
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
index 1b852bffdebc..6a365fadc7c4 100644
--- a/arch/um/drivers/vde_kern.c
+++ b/arch/um/drivers/vde_kern.c
@@ -7,10 +7,10 @@
  *
  */
 
-#include "linux/init.h"
+#include <linux/init.h>
 #include <linux/netdevice.h>
-#include "net_kern.h"
-#include "net_user.h"
+#include <net_kern.h>
+#include <net_user.h>
 #include "vde.h"
 
 static void vde_init(struct net_device *dev, void *data)

commit 17c324fa80914e5b39d423dfd1a3cd61a3ec9866
Author: Wang Chen <wangchen@cn.fujitsu.com>
Date:   Thu Dec 4 15:07:33 2008 -0800

    um: Kill directly reference of netdev->priv
    
    Simply replace netdev->priv with netdev_priv().
    
    Signed-off-by: Wang Chen <wangchen@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
index add7e722defb..1b852bffdebc 100644
--- a/arch/um/drivers/vde_kern.c
+++ b/arch/um/drivers/vde_kern.c
@@ -19,7 +19,7 @@ static void vde_init(struct net_device *dev, void *data)
 	struct uml_net_private *pri;
 	struct vde_data *vpri;
 
-	pri = dev->priv;
+	pri = netdev_priv(dev);
 	vpri = (struct vde_data *) pri->user;
 
 	vpri->vde_switch = init->vde_switch;

commit b53f35a8093e6aed7e8e880eaa0b89a3d2fdfb0a
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:31 2007 -0700

    uml: network driver MTU cleanups
    
    A bunch of MTU-related cleanups in the network code.
    
    First, there is the addition of the notion of a maximally-sized packet, which
    is the MTU plus headers.  This is used to size the skb that will receive a
    packet.  This allows ether_adjust_skb to go away, as it was used to resize the
    skb after it was allocated.
    
    Since the skb passed into the low-level read routine is no longer resized, and
    possibly reallocated, there, they (and the write routines) don't need to get
    an sk_buff **.  They just need the sk_buff * now.  The callers of
    ether_adjust_skb still need to do the skb_put, so that's now inlined.
    
    The MAX_PACKET definitions in most of the drivers are gone.
    
    The set_mtu methods were all the same and did nothing, so they can be
    removed.
    
    The ethertap driver had a typo which doubled the size of the packet rather
    than adding two bytes to it.  It also wasn't defining its setup_size, causing
    a zero-byte kmalloc and crash when the invalid pointer returned from kmalloc
    was dereferenced.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
index c5d01685d2b5..add7e722defb 100644
--- a/arch/um/drivers/vde_kern.c
+++ b/arch/um/drivers/vde_kern.c
@@ -36,30 +36,25 @@ static void vde_init(struct net_device *dev, void *data)
 	printk("\n");
 }
 
-static int vde_read(int fd, struct sk_buff **skb, struct uml_net_private *lp)
+static int vde_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
 {
 	struct vde_data *pri = (struct vde_data *) &lp->user;
 
-	if (pri->conn != NULL) {
-		*skb = ether_adjust_skb(*skb, ETH_HEADER_OTHER);
-		if (*skb == NULL)
-			return -ENOMEM;
-
-		return vde_user_read(pri->conn, skb_mac_header(*skb),
-				     (*skb)->dev->mtu + ETH_HEADER_OTHER);
-	}
+	if (pri->conn != NULL)
+		return vde_user_read(pri->conn, skb_mac_header(skb),
+				     skb->dev->mtu + ETH_HEADER_OTHER);
 
 	printk(KERN_ERR "vde_read - we have no VDECONN to read from");
 	return -EBADF;
 }
 
-static int vde_write(int fd, struct sk_buff **skb, struct uml_net_private *lp)
+static int vde_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
 {
 	struct vde_data *pri = (struct vde_data *) &lp->user;
 
 	if (pri->conn != NULL)
-		return vde_user_write((void *)pri->conn, (*skb)->data,
-				      (*skb)->len);
+		return vde_user_write((void *)pri->conn, skb->data,
+				      skb->len);
 
 	printk(KERN_ERR "vde_write - we have no VDECONN to write to");
 	return -EBADF;

commit cd1ae0e49bdd814cfaa2e5ab28cff21a30e20085
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:27:29 2007 -0700

    uml: network formatting
    
    Style and other non-functional changes in the UML networking code, including
            include tidying
            style violations
            copyright updates
            printks getting severities
            userspace code calling libc directly rather than using the os_*
    wrappers
    
    There's also a exit path cleanup in the pcap driver.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
index eb8cf31b820d..c5d01685d2b5 100644
--- a/arch/um/drivers/vde_kern.c
+++ b/arch/um/drivers/vde_kern.c
@@ -7,10 +7,8 @@
  *
  */
 
-#include "linux/kernel.h"
 #include "linux/init.h"
-#include "linux/netdevice.h"
-#include "linux/etherdevice.h"
+#include <linux/netdevice.h>
 #include "net_kern.h"
 #include "net_user.h"
 #include "vde.h"
@@ -30,12 +28,12 @@ static void vde_init(struct net_device *dev, void *data)
 	vpri->conn = NULL;
 	vpri->dev = dev;
 
-	printk(KERN_INFO "vde backend - %s, ", vpri->vde_switch ?
+	printk("vde backend - %s, ", vpri->vde_switch ?
 	       vpri->vde_switch : "(default socket)");
 
 	vde_init_libstuff(vpri, init);
 
-	printk(KERN_INFO "\n");
+	printk("\n");
 }
 
 static int vde_read(int fd, struct sk_buff **skb, struct uml_net_private *lp)

commit ad43c3565bebada7e5a13288e37542fd940369e8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Oct 16 01:26:48 2007 -0700

    uml: add VDE networking support
    
    Added vde network backend in uml to introduce native Virtual Distributed
    Ethernet support (using libvdeplug).
    
    Signed-off-by: Luca Bigliardi <shammash@artha.org>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/um/drivers/vde_kern.c b/arch/um/drivers/vde_kern.c
new file mode 100644
index 000000000000..eb8cf31b820d
--- /dev/null
+++ b/arch/um/drivers/vde_kern.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2007 Luca Bigliardi (shammash@artha.org).
+ * Licensed under the GPL.
+ *
+ * Transport usage:
+ *  ethN=vde,<vde_switch>,<mac addr>,<port>,<group>,<mode>,<description>
+ *
+ */
+
+#include "linux/kernel.h"
+#include "linux/init.h"
+#include "linux/netdevice.h"
+#include "linux/etherdevice.h"
+#include "net_kern.h"
+#include "net_user.h"
+#include "vde.h"
+
+static void vde_init(struct net_device *dev, void *data)
+{
+	struct vde_init *init = data;
+	struct uml_net_private *pri;
+	struct vde_data *vpri;
+
+	pri = dev->priv;
+	vpri = (struct vde_data *) pri->user;
+
+	vpri->vde_switch = init->vde_switch;
+	vpri->descr = init->descr ? init->descr : "UML vde_transport";
+	vpri->args = NULL;
+	vpri->conn = NULL;
+	vpri->dev = dev;
+
+	printk(KERN_INFO "vde backend - %s, ", vpri->vde_switch ?
+	       vpri->vde_switch : "(default socket)");
+
+	vde_init_libstuff(vpri, init);
+
+	printk(KERN_INFO "\n");
+}
+
+static int vde_read(int fd, struct sk_buff **skb, struct uml_net_private *lp)
+{
+	struct vde_data *pri = (struct vde_data *) &lp->user;
+
+	if (pri->conn != NULL) {
+		*skb = ether_adjust_skb(*skb, ETH_HEADER_OTHER);
+		if (*skb == NULL)
+			return -ENOMEM;
+
+		return vde_user_read(pri->conn, skb_mac_header(*skb),
+				     (*skb)->dev->mtu + ETH_HEADER_OTHER);
+	}
+
+	printk(KERN_ERR "vde_read - we have no VDECONN to read from");
+	return -EBADF;
+}
+
+static int vde_write(int fd, struct sk_buff **skb, struct uml_net_private *lp)
+{
+	struct vde_data *pri = (struct vde_data *) &lp->user;
+
+	if (pri->conn != NULL)
+		return vde_user_write((void *)pri->conn, (*skb)->data,
+				      (*skb)->len);
+
+	printk(KERN_ERR "vde_write - we have no VDECONN to write to");
+	return -EBADF;
+}
+
+static const struct net_kern_info vde_kern_info = {
+	.init			= vde_init,
+	.protocol		= eth_protocol,
+	.read			= vde_read,
+	.write			= vde_write,
+};
+
+static int vde_setup(char *str, char **mac_out, void *data)
+{
+	struct vde_init *init = data;
+	char *remain, *port_str = NULL, *mode_str = NULL, *last;
+
+	*init = ((struct vde_init)
+		{ .vde_switch		= NULL,
+		  .descr		= NULL,
+		  .port			= 0,
+		  .group		= NULL,
+		  .mode			= 0 });
+
+	remain = split_if_spec(str, &init->vde_switch, mac_out, &port_str,
+				&init->group, &mode_str, &init->descr, NULL);
+
+	if (remain != NULL)
+		printk(KERN_WARNING "vde_setup - Ignoring extra data :"
+		       "'%s'\n", remain);
+
+	if (port_str != NULL) {
+		init->port = simple_strtoul(port_str, &last, 10);
+		if ((*last != '\0') || (last == port_str)) {
+			printk(KERN_ERR "vde_setup - Bad port : '%s'\n",
+						port_str);
+			return 0;
+		}
+	}
+
+	if (mode_str != NULL) {
+		init->mode = simple_strtoul(mode_str, &last, 8);
+		if ((*last != '\0') || (last == mode_str)) {
+			printk(KERN_ERR "vde_setup - Bad mode : '%s'\n",
+						mode_str);
+			return 0;
+		}
+	}
+
+	printk(KERN_INFO "Configured vde device: %s\n", init->vde_switch ?
+	       init->vde_switch : "(default socket)");
+
+	return 1;
+}
+
+static struct transport vde_transport = {
+	.list 		= LIST_HEAD_INIT(vde_transport.list),
+	.name 		= "vde",
+	.setup  	= vde_setup,
+	.user 		= &vde_user_info,
+	.kern 		= &vde_kern_info,
+	.private_size 	= sizeof(struct vde_data),
+	.setup_size 	= sizeof(struct vde_init),
+};
+
+static int register_vde(void)
+{
+	register_transport(&vde_transport);
+	return 0;
+}
+
+late_initcall(register_vde);
