commit 8fa9eb388eb00f7a63caf0fd370f8c134015fc1f
Author: Paul E. McKenney <paulmck@linux.ibm.com>
Date:   Tue Oct 30 15:45:04 2018 -0700

    sparc/oprofile: Convert timer_stop() to use synchronize_rcu()
    
    Now that synchronize_rcu() waits for preempt-disable regions of code
    in addition to explicitly marked RCU read-side critical sections,
    synchronize_rcu() can be used in place of synchronize_sched().  This
    commit therefore makes that change.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: <oprofile-list@lists.sf.net>
    Cc: <sparclinux@vger.kernel.org>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index f9024bccff16..43730c9b1c86 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -53,7 +53,7 @@ static void timer_stop(void)
 {
 	nmi_adjust_hz(1);
 	unregister_die_notifier(&profile_timer_exceptions_nb);
-	synchronize_sched();  /* Allow already-started NMIs to complete. */
+	synchronize_rcu();  /* Allow already-started NMIs to complete. */
 }
 
 static int op_nmi_timer_init(struct oprofile_operations *ops)

commit c4a57435db67c4522c2e688c357051f35e36d6d6
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Oct 5 00:46:08 2009 -0700

    sparc: using HZ needs an include of linux/param.h
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index f97cb8b6ee5f..f9024bccff16 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -11,6 +11,7 @@
 #include <linux/oprofile.h>
 #include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/param.h>	/* for HZ */
  
 #ifdef CONFIG_SPARC64
 #include <linux/notifier.h>

commit 4e85f5915dedb7c852c1e1189aa4133c87798a5e
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 8 23:20:39 2009 -0700

    sparc64: Kill unnecessary cast in profile_timer_exceptions_notify().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index 9ce34fd294c9..f97cb8b6ee5f 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -21,7 +21,7 @@
 static int profile_timer_exceptions_notify(struct notifier_block *self,
 					   unsigned long val, void *data)
 {
-	struct die_args *args = (struct die_args *)data;
+	struct die_args *args = data;
 	int ret = NOTIFY_DONE;
 
 	switch (val) {

commit a8f22264550e64c0cd11fb6647284b0bd6407f9c
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 8 23:16:06 2009 -0700

    sparc64: Manage NMI watchdog enabling like x86.
    
    Use a per-cpu 'wd_enabled' boolean and a global atomic_t count
    of watchdog NMI enabled cpus which is set to '-1' if something
    is wrong with the watchdog and it can't be used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index d172f86439b1..9ce34fd294c9 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -57,7 +57,7 @@ static void timer_stop(void)
 
 static int op_nmi_timer_init(struct oprofile_operations *ops)
 {
-	if (!nmi_usable)
+	if (atomic_read(&nmi_active) <= 0)
 		return -ENODEV;
 
 	ops->start = timer_start;

commit e5553a6d04421eec326a629571d696e8e745a0e4
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jan 29 21:22:47 2009 -0800

    sparc64: Implement NMI watchdog on capable cpus.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index c8877a5202b0..d172f86439b1 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -13,117 +13,57 @@
 #include <linux/init.h>
  
 #ifdef CONFIG_SPARC64
-#include <asm/hypervisor.h>
-#include <asm/spitfire.h>
-#include <asm/cpudata.h>
-#include <asm/irq.h>
-#include <asm/pcr.h>
+#include <linux/notifier.h>
+#include <linux/rcupdate.h>
+#include <linux/kdebug.h>
+#include <asm/nmi.h>
 
-static int nmi_enabled;
-
-/* In order to commonize as much of the implementation as
- * possible, we use PICH as our counter.  Mostly this is
- * to accomodate Niagara-1 which can only count insn cycles
- * in PICH.
- */
-static u64 picl_value(void)
-{
-	u32 delta = local_cpu_data().clock_tick / HZ;
-
-	return ((u64)((0 - delta) & 0xffffffff)) << 32;
-}
-
-#define PCR_SUN4U_ENABLE	(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE)
-#define PCR_N2_ENABLE		(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE | \
-				 PCR_N2_TOE_OV1 | \
-				 (2 << PCR_N2_SL1_SHIFT) | \
-				 (0xff << PCR_N2_MASK1_SHIFT))
-
-static u64 pcr_enable;
-
-static void nmi_handler(struct pt_regs *regs)
+static int profile_timer_exceptions_notify(struct notifier_block *self,
+					   unsigned long val, void *data)
 {
-	pcr_ops->write(PCR_PIC_PRIV);
+	struct die_args *args = (struct die_args *)data;
+	int ret = NOTIFY_DONE;
 
-	if (nmi_enabled) {
-		oprofile_add_sample(regs, 0);
-
-		write_pic(picl_value());
-		pcr_ops->write(pcr_enable);
+	switch (val) {
+	case DIE_NMI:
+		oprofile_add_sample(args->regs, 0);
+		ret = NOTIFY_STOP;
+		break;
+	default:
+		break;
 	}
+	return ret;
 }
 
-/* We count "clock cycle" events in the lower 32-bit PIC.
- * Then configure it such that it overflows every HZ, and thus
- * generates a level 15 interrupt at that frequency.
- */
-static void cpu_nmi_start(void *_unused)
-{
-	pcr_ops->write(PCR_PIC_PRIV);
-	write_pic(picl_value());
-
-	pcr_ops->write(pcr_enable);
-}
+static struct notifier_block profile_timer_exceptions_nb = {
+	.notifier_call	= profile_timer_exceptions_notify,
+};
 
-static void cpu_nmi_stop(void *_unused)
+static int timer_start(void)
 {
-	pcr_ops->write(PCR_PIC_PRIV);
+	if (register_die_notifier(&profile_timer_exceptions_nb))
+		return 1;
+	nmi_adjust_hz(HZ);
+	return 0;
 }
 
-static int nmi_start(void)
-{
-	int err = register_perfctr_intr(nmi_handler);
-
-	if (!err) {
-		nmi_enabled = 1;
-		wmb();
-		err = on_each_cpu(cpu_nmi_start, NULL, 1);
-		if (err) {
-			nmi_enabled = 0;
-			wmb();
-			on_each_cpu(cpu_nmi_stop, NULL, 1);
-			release_perfctr_intr(nmi_handler);
-		}
-	}
-
-	return err;
-}
 
-static void nmi_stop(void)
+static void timer_stop(void)
 {
-	nmi_enabled = 0;
-	wmb();
-
-	on_each_cpu(cpu_nmi_stop, NULL, 1);
-	release_perfctr_intr(nmi_handler);
-	synchronize_sched();
+	nmi_adjust_hz(1);
+	unregister_die_notifier(&profile_timer_exceptions_nb);
+	synchronize_sched();  /* Allow already-started NMIs to complete. */
 }
 
-static int oprofile_nmi_init(struct oprofile_operations *ops)
+static int op_nmi_timer_init(struct oprofile_operations *ops)
 {
-	switch (tlb_type) {
-	case hypervisor:
-		pcr_enable = PCR_N2_ENABLE;
-		break;
-
-	case cheetah:
-	case cheetah_plus:
-		pcr_enable = PCR_SUN4U_ENABLE;
-		break;
-
-	default:
+	if (!nmi_usable)
 		return -ENODEV;
-	}
 
-	ops->create_files = NULL;
-	ops->setup = NULL;
-	ops->shutdown = NULL;
-	ops->start = nmi_start;
-	ops->stop = nmi_stop;
+	ops->start = timer_start;
+	ops->stop = timer_stop;
 	ops->cpu_type = "timer";
-
-	printk(KERN_INFO "oprofile: Using perfctr based NMI timer interrupt.\n");
-
+	printk(KERN_INFO "oprofile: Using perfctr NMI timer interrupt.\n");
 	return 0;
 }
 #endif
@@ -133,7 +73,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	int ret = -ENODEV;
 
 #ifdef CONFIG_SPARC64
-	ret = oprofile_nmi_init(ops);
+	ret = op_nmi_timer_init(ops);
 	if (!ret)
 		return ret;
 #endif

commit 3eb8057bbafc64dbf09d5c18513aa80c1b7f2fcb
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 21 21:30:23 2009 -0800

    sparc64: Move generic PCR support code to seperate file.
    
    It all lives in the oprofile support code currently and we will need
    to share this stuff with NMI watchdog and perf_counter support.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index d6e170c074fc..c8877a5202b0 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -17,47 +17,10 @@
 #include <asm/spitfire.h>
 #include <asm/cpudata.h>
 #include <asm/irq.h>
+#include <asm/pcr.h>
 
 static int nmi_enabled;
 
-struct pcr_ops {
-	u64 (*read)(void);
-	void (*write)(u64);
-};
-static const struct pcr_ops *pcr_ops;
-
-static u64 direct_pcr_read(void)
-{
-	u64 val;
-
-	read_pcr(val);
-	return val;
-}
-
-static void direct_pcr_write(u64 val)
-{
-	write_pcr(val);
-}
-
-static const struct pcr_ops direct_pcr_ops = {
-	.read	= direct_pcr_read,
-	.write	= direct_pcr_write,
-};
-
-static void n2_pcr_write(u64 val)
-{
-	unsigned long ret;
-
-	ret = sun4v_niagara2_setperf(HV_N2_PERF_SPARC_CTL, val);
-	if (val != HV_EOK)
-		write_pcr(val);
-}
-
-static const struct pcr_ops n2_pcr_ops = {
-	.read	= direct_pcr_read,
-	.write	= n2_pcr_write,
-};
-
 /* In order to commonize as much of the implementation as
  * possible, we use PICH as our counter.  Mostly this is
  * to accomodate Niagara-1 which can only count insn cycles
@@ -70,30 +33,13 @@ static u64 picl_value(void)
 	return ((u64)((0 - delta) & 0xffffffff)) << 32;
 }
 
-#define PCR_PIC_PRIV		0x00000001 /* PIC access is privileged */
-#define PCR_STRACE		0x00000002 /* Trace supervisor events  */
-#define PCR_UTRACE		0x00000004 /* Trace user events        */
-#define PCR_N2_HTRACE		0x00000008 /* Trace hypervisor events  */
-#define PCR_N2_TOE_OV0		0x00000010 /* Trap if PIC 0 overflows  */
-#define PCR_N2_TOE_OV1		0x00000020 /* Trap if PIC 1 overflows  */
-#define PCR_N2_MASK0		0x00003fc0
-#define PCR_N2_MASK0_SHIFT	6
-#define PCR_N2_SL0		0x0003c000
-#define PCR_N2_SL0_SHIFT	14
-#define PCR_N2_OV0		0x00040000
-#define PCR_N2_MASK1		0x07f80000
-#define PCR_N2_MASK1_SHIFT	19
-#define PCR_N2_SL1		0x78000000
-#define PCR_N2_SL1_SHIFT	27
-#define PCR_N2_OV1		0x80000000
-
 #define PCR_SUN4U_ENABLE	(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE)
 #define PCR_N2_ENABLE		(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE | \
 				 PCR_N2_TOE_OV1 | \
 				 (2 << PCR_N2_SL1_SHIFT) | \
 				 (0xff << PCR_N2_MASK1_SHIFT))
 
-static u64 pcr_enable = PCR_SUN4U_ENABLE;
+static u64 pcr_enable;
 
 static void nmi_handler(struct pt_regs *regs)
 {
@@ -153,62 +99,16 @@ static void nmi_stop(void)
 	synchronize_sched();
 }
 
-static unsigned long perf_hsvc_group;
-static unsigned long perf_hsvc_major;
-static unsigned long perf_hsvc_minor;
-
-static int __init register_perf_hsvc(void)
-{
-	if (tlb_type == hypervisor) {
-		switch (sun4v_chip_type) {
-		case SUN4V_CHIP_NIAGARA1:
-			perf_hsvc_group = HV_GRP_NIAG_PERF;
-			break;
-
-		case SUN4V_CHIP_NIAGARA2:
-			perf_hsvc_group = HV_GRP_N2_CPU;
-			break;
-
-		default:
-			return -ENODEV;
-		}
-
-
-		perf_hsvc_major = 1;
-		perf_hsvc_minor = 0;
-		if (sun4v_hvapi_register(perf_hsvc_group,
-					 perf_hsvc_major,
-					 &perf_hsvc_minor)) {
-			printk("perfmon: Could not register N2 hvapi.\n");
-			return -ENODEV;
-		}
-	}
-	return 0;
-}
-
-static void unregister_perf_hsvc(void)
-{
-	if (tlb_type != hypervisor)
-		return;
-	sun4v_hvapi_unregister(perf_hsvc_group);
-}
-
 static int oprofile_nmi_init(struct oprofile_operations *ops)
 {
-	int err = register_perf_hsvc();
-
-	if (err)
-		return err;
-
 	switch (tlb_type) {
 	case hypervisor:
-		pcr_ops = &n2_pcr_ops;
 		pcr_enable = PCR_N2_ENABLE;
 		break;
 
 	case cheetah:
 	case cheetah_plus:
-		pcr_ops = &direct_pcr_ops;
+		pcr_enable = PCR_SUN4U_ENABLE;
 		break;
 
 	default:
@@ -241,10 +141,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	return ret;
 }
 
-
 void oprofile_arch_exit(void)
 {
-#ifdef CONFIG_SPARC64
-	unregister_perf_hsvc();
-#endif
 }

commit 63ef34827c1f5ac838e869cc3ecc2d9cfebae152
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Nov 28 02:27:42 2008 -0800

    sparc64: Provide oprofile pseudo-NMI on Niagara.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index e979dcd77726..d6e170c074fc 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -13,32 +13,97 @@
 #include <linux/init.h>
  
 #ifdef CONFIG_SPARC64
+#include <asm/hypervisor.h>
 #include <asm/spitfire.h>
 #include <asm/cpudata.h>
 #include <asm/irq.h>
 
 static int nmi_enabled;
 
+struct pcr_ops {
+	u64 (*read)(void);
+	void (*write)(u64);
+};
+static const struct pcr_ops *pcr_ops;
+
+static u64 direct_pcr_read(void)
+{
+	u64 val;
+
+	read_pcr(val);
+	return val;
+}
+
+static void direct_pcr_write(u64 val)
+{
+	write_pcr(val);
+}
+
+static const struct pcr_ops direct_pcr_ops = {
+	.read	= direct_pcr_read,
+	.write	= direct_pcr_write,
+};
+
+static void n2_pcr_write(u64 val)
+{
+	unsigned long ret;
+
+	ret = sun4v_niagara2_setperf(HV_N2_PERF_SPARC_CTL, val);
+	if (val != HV_EOK)
+		write_pcr(val);
+}
+
+static const struct pcr_ops n2_pcr_ops = {
+	.read	= direct_pcr_read,
+	.write	= n2_pcr_write,
+};
+
+/* In order to commonize as much of the implementation as
+ * possible, we use PICH as our counter.  Mostly this is
+ * to accomodate Niagara-1 which can only count insn cycles
+ * in PICH.
+ */
 static u64 picl_value(void)
 {
 	u32 delta = local_cpu_data().clock_tick / HZ;
 
-	return (0 - delta) & 0xffffffff;
+	return ((u64)((0 - delta) & 0xffffffff)) << 32;
 }
 
-#define PCR_PIC_PRIV	0x1 /* PIC access is privileged */
-#define PCR_STRACE	0x2 /* Trace supervisor events  */
-#define PCR_UTRACE	0x4 /* Trace user events        */
+#define PCR_PIC_PRIV		0x00000001 /* PIC access is privileged */
+#define PCR_STRACE		0x00000002 /* Trace supervisor events  */
+#define PCR_UTRACE		0x00000004 /* Trace user events        */
+#define PCR_N2_HTRACE		0x00000008 /* Trace hypervisor events  */
+#define PCR_N2_TOE_OV0		0x00000010 /* Trap if PIC 0 overflows  */
+#define PCR_N2_TOE_OV1		0x00000020 /* Trap if PIC 1 overflows  */
+#define PCR_N2_MASK0		0x00003fc0
+#define PCR_N2_MASK0_SHIFT	6
+#define PCR_N2_SL0		0x0003c000
+#define PCR_N2_SL0_SHIFT	14
+#define PCR_N2_OV0		0x00040000
+#define PCR_N2_MASK1		0x07f80000
+#define PCR_N2_MASK1_SHIFT	19
+#define PCR_N2_SL1		0x78000000
+#define PCR_N2_SL1_SHIFT	27
+#define PCR_N2_OV1		0x80000000
+
+#define PCR_SUN4U_ENABLE	(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE)
+#define PCR_N2_ENABLE		(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE | \
+				 PCR_N2_TOE_OV1 | \
+				 (2 << PCR_N2_SL1_SHIFT) | \
+				 (0xff << PCR_N2_MASK1_SHIFT))
+
+static u64 pcr_enable = PCR_SUN4U_ENABLE;
 
 static void nmi_handler(struct pt_regs *regs)
 {
-	write_pcr(PCR_PIC_PRIV);
+	pcr_ops->write(PCR_PIC_PRIV);
 
 	if (nmi_enabled) {
 		oprofile_add_sample(regs, 0);
 
 		write_pic(picl_value());
-		write_pcr(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE);
+		pcr_ops->write(pcr_enable);
 	}
 }
 
@@ -48,21 +113,15 @@ static void nmi_handler(struct pt_regs *regs)
  */
 static void cpu_nmi_start(void *_unused)
 {
-	write_pcr(PCR_PIC_PRIV);
+	pcr_ops->write(PCR_PIC_PRIV);
 	write_pic(picl_value());
 
-	/* Bit 0: PIC access is privileged
-	 * Bit 1: Supervisor Trace
-	 * Bit 2: User Trace
-	 *
-	 * And the event selection code for cpu cycles is zero.
-	 */
-	write_pcr(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE);
+	pcr_ops->write(pcr_enable);
 }
 
 static void cpu_nmi_stop(void *_unused)
 {
-	write_pcr(PCR_PIC_PRIV);
+	pcr_ops->write(PCR_PIC_PRIV);
 }
 
 static int nmi_start(void)
@@ -94,10 +153,67 @@ static void nmi_stop(void)
 	synchronize_sched();
 }
 
+static unsigned long perf_hsvc_group;
+static unsigned long perf_hsvc_major;
+static unsigned long perf_hsvc_minor;
+
+static int __init register_perf_hsvc(void)
+{
+	if (tlb_type == hypervisor) {
+		switch (sun4v_chip_type) {
+		case SUN4V_CHIP_NIAGARA1:
+			perf_hsvc_group = HV_GRP_NIAG_PERF;
+			break;
+
+		case SUN4V_CHIP_NIAGARA2:
+			perf_hsvc_group = HV_GRP_N2_CPU;
+			break;
+
+		default:
+			return -ENODEV;
+		}
+
+
+		perf_hsvc_major = 1;
+		perf_hsvc_minor = 0;
+		if (sun4v_hvapi_register(perf_hsvc_group,
+					 perf_hsvc_major,
+					 &perf_hsvc_minor)) {
+			printk("perfmon: Could not register N2 hvapi.\n");
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static void unregister_perf_hsvc(void)
+{
+	if (tlb_type != hypervisor)
+		return;
+	sun4v_hvapi_unregister(perf_hsvc_group);
+}
+
 static int oprofile_nmi_init(struct oprofile_operations *ops)
 {
-	if (tlb_type != cheetah && tlb_type != cheetah_plus)
+	int err = register_perf_hsvc();
+
+	if (err)
+		return err;
+
+	switch (tlb_type) {
+	case hypervisor:
+		pcr_ops = &n2_pcr_ops;
+		pcr_enable = PCR_N2_ENABLE;
+		break;
+
+	case cheetah:
+	case cheetah_plus:
+		pcr_ops = &direct_pcr_ops;
+		break;
+
+	default:
 		return -ENODEV;
+	}
 
 	ops->create_files = NULL;
 	ops->setup = NULL;
@@ -128,4 +244,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 void oprofile_arch_exit(void)
 {
+#ifdef CONFIG_SPARC64
+	unregister_perf_hsvc();
+#endif
 }

commit 422e23ea0865177b61527874b1b80023e4215d67
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Nov 25 22:29:24 2008 -0800

    sparc64: Use NMI oprofile profiling on cheetah and derivative cpus.
    
    We use clock cycle counter, adjusted to HZ.
    
    This can be extended to sun4v based processors as well, as they
    also have a proper overflow interrupt facility for the performance
    counters.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index 17bb6035069b..e979dcd77726 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -12,9 +12,117 @@
 #include <linux/errno.h>
 #include <linux/init.h>
  
+#ifdef CONFIG_SPARC64
+#include <asm/spitfire.h>
+#include <asm/cpudata.h>
+#include <asm/irq.h>
+
+static int nmi_enabled;
+
+static u64 picl_value(void)
+{
+	u32 delta = local_cpu_data().clock_tick / HZ;
+
+	return (0 - delta) & 0xffffffff;
+}
+
+#define PCR_PIC_PRIV	0x1 /* PIC access is privileged */
+#define PCR_STRACE	0x2 /* Trace supervisor events  */
+#define PCR_UTRACE	0x4 /* Trace user events        */
+
+static void nmi_handler(struct pt_regs *regs)
+{
+	write_pcr(PCR_PIC_PRIV);
+
+	if (nmi_enabled) {
+		oprofile_add_sample(regs, 0);
+
+		write_pic(picl_value());
+		write_pcr(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE);
+	}
+}
+
+/* We count "clock cycle" events in the lower 32-bit PIC.
+ * Then configure it such that it overflows every HZ, and thus
+ * generates a level 15 interrupt at that frequency.
+ */
+static void cpu_nmi_start(void *_unused)
+{
+	write_pcr(PCR_PIC_PRIV);
+	write_pic(picl_value());
+
+	/* Bit 0: PIC access is privileged
+	 * Bit 1: Supervisor Trace
+	 * Bit 2: User Trace
+	 *
+	 * And the event selection code for cpu cycles is zero.
+	 */
+	write_pcr(PCR_PIC_PRIV | PCR_STRACE | PCR_UTRACE);
+}
+
+static void cpu_nmi_stop(void *_unused)
+{
+	write_pcr(PCR_PIC_PRIV);
+}
+
+static int nmi_start(void)
+{
+	int err = register_perfctr_intr(nmi_handler);
+
+	if (!err) {
+		nmi_enabled = 1;
+		wmb();
+		err = on_each_cpu(cpu_nmi_start, NULL, 1);
+		if (err) {
+			nmi_enabled = 0;
+			wmb();
+			on_each_cpu(cpu_nmi_stop, NULL, 1);
+			release_perfctr_intr(nmi_handler);
+		}
+	}
+
+	return err;
+}
+
+static void nmi_stop(void)
+{
+	nmi_enabled = 0;
+	wmb();
+
+	on_each_cpu(cpu_nmi_stop, NULL, 1);
+	release_perfctr_intr(nmi_handler);
+	synchronize_sched();
+}
+
+static int oprofile_nmi_init(struct oprofile_operations *ops)
+{
+	if (tlb_type != cheetah && tlb_type != cheetah_plus)
+		return -ENODEV;
+
+	ops->create_files = NULL;
+	ops->setup = NULL;
+	ops->shutdown = NULL;
+	ops->start = nmi_start;
+	ops->stop = nmi_stop;
+	ops->cpu_type = "timer";
+
+	printk(KERN_INFO "oprofile: Using perfctr based NMI timer interrupt.\n");
+
+	return 0;
+}
+#endif
+
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	return -ENODEV;
+	int ret = -ENODEV;
+
+#ifdef CONFIG_SPARC64
+	ret = oprofile_nmi_init(ops);
+	if (!ret)
+		return ret;
+#endif
+
+	return ret;
 }
 
 

commit 25ad2913cae9c9e3ed28075caeb2eefccd636f4f
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Sep 5 17:12:36 2008 +0200

    oprofile: more whitespace fixes
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
index 9ab815b95b5a..17bb6035069b 100644
--- a/arch/sparc/oprofile/init.c
+++ b/arch/sparc/oprofile/init.c
@@ -12,7 +12,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
  
-int __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	return -ENODEV;
 }

commit 9550e59c4587f637d9aa34689e32eea460e6f50c
Author: Martin Habets <errandir_news@mph.eclipse.co.uk>
Date:   Tue Oct 17 19:21:48 2006 -0700

    [SPARC]: Add sparc profiling support
    
    This patch adds profiling support to the sparc architecture. It is a
    copy of the sparc64 implementation.
    
    Signed-off-by: Martin Habets <errandir_news@mph.eclipse.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/oprofile/init.c b/arch/sparc/oprofile/init.c
new file mode 100644
index 000000000000..9ab815b95b5a
--- /dev/null
+++ b/arch/sparc/oprofile/init.c
@@ -0,0 +1,23 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+ 
+int __init oprofile_arch_init(struct oprofile_operations * ops)
+{
+	return -ENODEV;
+}
+
+
+void oprofile_arch_exit(void)
+{
+}
