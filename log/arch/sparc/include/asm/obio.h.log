commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/include/asm/obio.h b/arch/sparc/include/asm/obio.h
index 426ad75103fb..1b151f738b00 100644
--- a/arch/sparc/include/asm/obio.h
+++ b/arch/sparc/include/asm/obio.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * obio.h:  Some useful locations in 0xFXXXXXXXX PA obio space on sun4d.
  *

commit 9ef595d83aea6b4d93c9a120df3c5db2e226929f
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 10 15:21:43 2016 -0800

    sparc: Convert naked unsigned uses to unsigned int
    
    Use the more normal kernel definition/declaration style.
    
    Done via:
    
    $ git ls-files arch/sparc | \
      xargs ./scripts/checkpatch.pl -f --fix-inplace --types=unspecified_int
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/include/asm/obio.h b/arch/sparc/include/asm/obio.h
index 910c1d9af1f8..426ad75103fb 100644
--- a/arch/sparc/include/asm/obio.h
+++ b/arch/sparc/include/asm/obio.h
@@ -117,9 +117,9 @@ static inline void bw_clear_intr_mask(int sbus_level, int mask)
 			      "i" (ASI_M_CTL));
 }
 
-static inline unsigned bw_get_prof_limit(int cpu)
+static inline unsigned int bw_get_prof_limit(int cpu)
 {
-	unsigned limit;
+	unsigned int limit;
 	
 	__asm__ __volatile__ ("lda [%1] %2, %0" :
 			      "=r" (limit) :
@@ -128,7 +128,7 @@ static inline unsigned bw_get_prof_limit(int cpu)
 	return limit;
 }
 
-static inline void bw_set_prof_limit(int cpu, unsigned limit)
+static inline void bw_set_prof_limit(int cpu, unsigned int limit)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (limit),
@@ -136,9 +136,9 @@ static inline void bw_set_prof_limit(int cpu, unsigned limit)
 			      "i" (ASI_M_CTL));
 }
 
-static inline unsigned bw_get_ctrl(int cpu)
+static inline unsigned int bw_get_ctrl(int cpu)
 {
-	unsigned ctrl;
+	unsigned int ctrl;
 	
 	__asm__ __volatile__ ("lda [%1] %2, %0" :
 			      "=r" (ctrl) :
@@ -147,7 +147,7 @@ static inline unsigned bw_get_ctrl(int cpu)
 	return ctrl;
 }
 
-static inline void bw_set_ctrl(int cpu, unsigned ctrl)
+static inline void bw_set_ctrl(int cpu, unsigned int ctrl)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (ctrl),
@@ -155,9 +155,9 @@ static inline void bw_set_ctrl(int cpu, unsigned ctrl)
 			      "i" (ASI_M_CTL));
 }
 
-static inline unsigned cc_get_ipen(void)
+static inline unsigned int cc_get_ipen(void)
 {
-	unsigned pending;
+	unsigned int pending;
 	
 	__asm__ __volatile__ ("lduha [%1] %2, %0" :
 			      "=r" (pending) :
@@ -166,7 +166,7 @@ static inline unsigned cc_get_ipen(void)
 	return pending;
 }
 
-static inline void cc_set_iclr(unsigned clear)
+static inline void cc_set_iclr(unsigned int clear)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (clear),
@@ -174,9 +174,9 @@ static inline void cc_set_iclr(unsigned clear)
 			      "i" (ASI_M_MXCC));
 }
 
-static inline unsigned cc_get_imsk(void)
+static inline unsigned int cc_get_imsk(void)
 {
-	unsigned mask;
+	unsigned int mask;
 	
 	__asm__ __volatile__ ("lduha [%1] %2, %0" :
 			      "=r" (mask) :
@@ -185,7 +185,7 @@ static inline unsigned cc_get_imsk(void)
 	return mask;
 }
 
-static inline void cc_set_imsk(unsigned mask)
+static inline void cc_set_imsk(unsigned int mask)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (mask),
@@ -193,9 +193,9 @@ static inline void cc_set_imsk(unsigned mask)
 			      "i" (ASI_M_MXCC));
 }
 
-static inline unsigned cc_get_imsk_other(int cpuid)
+static inline unsigned int cc_get_imsk_other(int cpuid)
 {
-	unsigned mask;
+	unsigned int mask;
 	
 	__asm__ __volatile__ ("lduha [%1] %2, %0" :
 			      "=r" (mask) :
@@ -204,7 +204,7 @@ static inline unsigned cc_get_imsk_other(int cpuid)
 	return mask;
 }
 
-static inline void cc_set_imsk_other(int cpuid, unsigned mask)
+static inline void cc_set_imsk_other(int cpuid, unsigned int mask)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (mask),
@@ -212,7 +212,7 @@ static inline void cc_set_imsk_other(int cpuid, unsigned mask)
 			      "i" (ASI_M_CTL));
 }
 
-static inline void cc_set_igen(unsigned gen)
+static inline void cc_set_igen(unsigned int gen)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (gen),

commit 4ba22b16bbf354822b7988ec5b4b35774dcd479f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon May 14 15:14:36 2012 +0200

    sparc32: move smp ipi to method ops
    
    I ended up renaming set_cpu_int to send_ipi to
    be consistent all way around.
    send_ipi was moved to the *_smp.c files so
    we could call the relevant method direct,
    without any _ops indirection.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/include/asm/obio.h b/arch/sparc/include/asm/obio.h
index 4ade0c8a2c79..910c1d9af1f8 100644
--- a/arch/sparc/include/asm/obio.h
+++ b/arch/sparc/include/asm/obio.h
@@ -220,19 +220,6 @@ static inline void cc_set_igen(unsigned gen)
 			      "i" (ASI_M_MXCC));
 }
 
-/* +-------+-------------+-----------+------------------------------------+
- * | bcast |  devid      |   sid     |              levels mask           |
- * +-------+-------------+-----------+------------------------------------+
- *  31      30         23 22       15 14                                 0
- */
-#define IGEN_MESSAGE(bcast, devid, sid, levels) \
-	(((bcast) << 31) | ((devid) << 23) | ((sid) << 15) | (levels))
-            
-static inline void sun4d_send_ipi(int cpu, int level)
-{
-	cc_set_igen(IGEN_MESSAGE(0, cpu << 3, 6 + ((level >> 1) & 7), 1 << (level - 1)));
-}
-
 #endif /* !__ASSEMBLY__ */
 
 #endif /* !(_SPARC_OBIO_H) */

commit 7b1af32f52077402157f8bb8fc22d8da17606095
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 2 01:17:41 2008 -0700

    sparc32: Move sun4d show_leds() out of asm/obio.h
    
    Put it, as well as cpu_leds[] array, into sun4d_irq.c
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/include/asm/obio.h b/arch/sparc/include/asm/obio.h
index 1a7544ceb574..4ade0c8a2c79 100644
--- a/arch/sparc/include/asm/obio.h
+++ b/arch/sparc/include/asm/obio.h
@@ -155,17 +155,6 @@ static inline void bw_set_ctrl(int cpu, unsigned ctrl)
 			      "i" (ASI_M_CTL));
 }
 
-extern unsigned char cpu_leds[32];
-
-static inline void show_leds(int cpuid)
-{
-	cpuid &= 0x1e;
-	__asm__ __volatile__ ("stba %0, [%1] %2" : :
-			      "r" ((cpu_leds[cpuid] << 4) | cpu_leds[cpuid+1]),
-			      "r" (ECSR_BASE(cpuid) | BB_LEDS),
-			      "i" (ASI_M_CTL));
-}
-
 static inline unsigned cc_get_ipen(void)
 {
 	unsigned pending;

commit a439fe51a1f8eb087c22dd24d69cebae4a3addac
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jul 27 23:00:59 2008 +0200

    sparc, sparc64: use arch/sparc/include
    
    The majority of this patch was created by the following script:
    
    ***
    ASM=arch/sparc/include/asm
    mkdir -p $ASM
    git mv include/asm-sparc64/ftrace.h $ASM
    git rm include/asm-sparc64/*
    git mv include/asm-sparc/* $ASM
    sed -ie 's/asm-sparc64/asm/g' $ASM/*
    sed -ie 's/asm-sparc/asm/g' $ASM/*
    ***
    
    The rest was an update of the top-level Makefile to use sparc
    for header files when sparc64 is being build.
    And a small fixlet to pick up the correct unistd.h from
    sparc64 code.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/arch/sparc/include/asm/obio.h b/arch/sparc/include/asm/obio.h
new file mode 100644
index 000000000000..1a7544ceb574
--- /dev/null
+++ b/arch/sparc/include/asm/obio.h
@@ -0,0 +1,249 @@
+/*
+ * obio.h:  Some useful locations in 0xFXXXXXXXX PA obio space on sun4d.
+ *
+ * Copyright (C) 1997 Jakub Jelinek <jj@sunsite.mff.cuni.cz>
+ */
+
+#ifndef _SPARC_OBIO_H
+#define _SPARC_OBIO_H
+
+#include <asm/asi.h>
+
+/* This weird monster likes to use the very upper parts of
+   36bit PA for these things :) */
+   
+/* CSR space (for each XDBUS)
+ *  ------------------------------------------------------------------------
+ *  |   0xFE  |   DEVID    |                | XDBUS ID |                   |
+ *  ------------------------------------------------------------------------
+ *  35      28 27        20 19            10 9        8 7                 0
+ */
+   
+#define CSR_BASE_ADDR		0xe0000000
+#define CSR_CPU_SHIFT		(32 - 4 - 5)
+#define CSR_XDBUS_SHIFT		8
+
+#define CSR_BASE(cpu) (((CSR_BASE_ADDR >> CSR_CPU_SHIFT) + cpu) << CSR_CPU_SHIFT)
+
+/* ECSR space (not for each XDBUS)
+ *  ------------------------------------------------------------------------
+ *  |   0xF  | DEVID[7:1] |                			           |
+ *  ------------------------------------------------------------------------
+ *  35     32 31        25 24                 				  0
+ */
+   
+#define ECSR_BASE_ADDR		0x00000000
+#define ECSR_CPU_SHIFT		(32 - 5)
+#define ECSR_DEV_SHIFT		(32 - 8)
+
+#define ECSR_BASE(cpu) ((cpu) << ECSR_CPU_SHIFT)
+#define ECSR_DEV_BASE(devid) ((devid) << ECSR_DEV_SHIFT) 
+
+/* Bus Watcher */
+#define BW_LOCAL_BASE		0xfff00000
+
+#define BW_CID			0x00000000
+#define BW_DBUS_CTRL		0x00000008
+#define BW_DBUS_DATA		0x00000010
+#define BW_CTRL			0x00001000
+#define BW_INTR_TABLE		0x00001040
+#define BW_INTR_TABLE_CLEAR	0x00001080
+#define BW_PRESCALER		0x000010c0
+#define BW_PTIMER_LIMIT		0x00002000
+#define BW_PTIMER_COUNTER2	0x00002004
+#define BW_PTIMER_NDLIMIT	0x00002008
+#define BW_PTIMER_CTRL		0x0000200c
+#define BW_PTIMER_COUNTER	0x00002010
+#define BW_TIMER_LIMIT		0x00003000
+#define BW_TIMER_COUNTER2	0x00003004
+#define BW_TIMER_NDLIMIT	0x00003008
+#define BW_TIMER_CTRL		0x0000300c
+#define BW_TIMER_COUNTER	0x00003010
+
+/* BW Control */
+#define BW_CTRL_USER_TIMER	0x00000004	/* Is User Timer Free run enabled */
+
+/* Boot Bus */
+#define BB_LOCAL_BASE		0xf0000000
+
+#define BB_STAT1		0x00100000
+#define BB_STAT2		0x00120000
+#define BB_STAT3		0x00140000
+#define BB_LEDS			0x002e0000
+
+/* Bits in BB_STAT2 */
+#define BB_STAT2_AC_INTR	0x04	/* Aiee! 5ms and power is gone... */
+#define BB_STAT2_TMP_INTR	0x10	/* My Penguins are burning. Are you able to smell it? */
+#define BB_STAT2_FAN_INTR	0x20	/* My fan refuses to work */
+#define BB_STAT2_PWR_INTR	0x40	/* On SC2000, one of the two ACs died. Ok, we go on... */
+#define BB_STAT2_MASK		(BB_STAT2_AC_INTR|BB_STAT2_TMP_INTR|BB_STAT2_FAN_INTR|BB_STAT2_PWR_INTR)
+
+/* Cache Controller */
+#define CC_BASE		0x1F00000
+#define CC_DATSTREAM	0x1F00000  /* Data stream register */
+#define CC_DATSIZE	0x1F0003F  /* Size */
+#define CC_SRCSTREAM	0x1F00100  /* Source stream register */
+#define CC_DESSTREAM	0x1F00200  /* Destination stream register */
+#define CC_RMCOUNT	0x1F00300  /* Count of references and misses */
+#define CC_IPEN		0x1F00406  /* Pending Interrupts */
+#define CC_IMSK		0x1F00506  /* Interrupt Mask */
+#define CC_ICLR		0x1F00606  /* Clear pending Interrupts */
+#define CC_IGEN		0x1F00704  /* Generate Interrupt register */
+#define CC_STEST	0x1F00804  /* Internal self-test */
+#define CC_CREG		0x1F00A04  /* Control register */
+#define CC_SREG		0x1F00B00  /* Status register */
+#define CC_RREG		0x1F00C04  /* Reset register */
+#define CC_EREG		0x1F00E00  /* Error code register */
+#define CC_CID		0x1F00F04  /* Component ID */
+
+#ifndef __ASSEMBLY__
+
+static inline int bw_get_intr_mask(int sbus_level)
+{
+	int mask;
+	
+	__asm__ __volatile__ ("lduha [%1] %2, %0" :
+			      "=r" (mask) :
+			      "r" (BW_LOCAL_BASE + BW_INTR_TABLE + (sbus_level << 3)),
+			      "i" (ASI_M_CTL));
+	return mask;
+}
+
+static inline void bw_clear_intr_mask(int sbus_level, int mask)
+{
+	__asm__ __volatile__ ("stha %0, [%1] %2" : :
+			      "r" (mask),
+			      "r" (BW_LOCAL_BASE + BW_INTR_TABLE_CLEAR + (sbus_level << 3)),
+			      "i" (ASI_M_CTL));
+}
+
+static inline unsigned bw_get_prof_limit(int cpu)
+{
+	unsigned limit;
+	
+	__asm__ __volatile__ ("lda [%1] %2, %0" :
+			      "=r" (limit) :
+			      "r" (CSR_BASE(cpu) + BW_PTIMER_LIMIT),
+			      "i" (ASI_M_CTL));
+	return limit;
+}
+
+static inline void bw_set_prof_limit(int cpu, unsigned limit)
+{
+	__asm__ __volatile__ ("sta %0, [%1] %2" : :
+			      "r" (limit),
+			      "r" (CSR_BASE(cpu) + BW_PTIMER_LIMIT),
+			      "i" (ASI_M_CTL));
+}
+
+static inline unsigned bw_get_ctrl(int cpu)
+{
+	unsigned ctrl;
+	
+	__asm__ __volatile__ ("lda [%1] %2, %0" :
+			      "=r" (ctrl) :
+			      "r" (CSR_BASE(cpu) + BW_CTRL),
+			      "i" (ASI_M_CTL));
+	return ctrl;
+}
+
+static inline void bw_set_ctrl(int cpu, unsigned ctrl)
+{
+	__asm__ __volatile__ ("sta %0, [%1] %2" : :
+			      "r" (ctrl),
+			      "r" (CSR_BASE(cpu) + BW_CTRL),
+			      "i" (ASI_M_CTL));
+}
+
+extern unsigned char cpu_leds[32];
+
+static inline void show_leds(int cpuid)
+{
+	cpuid &= 0x1e;
+	__asm__ __volatile__ ("stba %0, [%1] %2" : :
+			      "r" ((cpu_leds[cpuid] << 4) | cpu_leds[cpuid+1]),
+			      "r" (ECSR_BASE(cpuid) | BB_LEDS),
+			      "i" (ASI_M_CTL));
+}
+
+static inline unsigned cc_get_ipen(void)
+{
+	unsigned pending;
+	
+	__asm__ __volatile__ ("lduha [%1] %2, %0" :
+			      "=r" (pending) :
+			      "r" (CC_IPEN),
+			      "i" (ASI_M_MXCC));
+	return pending;
+}
+
+static inline void cc_set_iclr(unsigned clear)
+{
+	__asm__ __volatile__ ("stha %0, [%1] %2" : :
+			      "r" (clear),
+			      "r" (CC_ICLR),
+			      "i" (ASI_M_MXCC));
+}
+
+static inline unsigned cc_get_imsk(void)
+{
+	unsigned mask;
+	
+	__asm__ __volatile__ ("lduha [%1] %2, %0" :
+			      "=r" (mask) :
+			      "r" (CC_IMSK),
+			      "i" (ASI_M_MXCC));
+	return mask;
+}
+
+static inline void cc_set_imsk(unsigned mask)
+{
+	__asm__ __volatile__ ("stha %0, [%1] %2" : :
+			      "r" (mask),
+			      "r" (CC_IMSK),
+			      "i" (ASI_M_MXCC));
+}
+
+static inline unsigned cc_get_imsk_other(int cpuid)
+{
+	unsigned mask;
+	
+	__asm__ __volatile__ ("lduha [%1] %2, %0" :
+			      "=r" (mask) :
+			      "r" (ECSR_BASE(cpuid) | CC_IMSK),
+			      "i" (ASI_M_CTL));
+	return mask;
+}
+
+static inline void cc_set_imsk_other(int cpuid, unsigned mask)
+{
+	__asm__ __volatile__ ("stha %0, [%1] %2" : :
+			      "r" (mask),
+			      "r" (ECSR_BASE(cpuid) | CC_IMSK),
+			      "i" (ASI_M_CTL));
+}
+
+static inline void cc_set_igen(unsigned gen)
+{
+	__asm__ __volatile__ ("sta %0, [%1] %2" : :
+			      "r" (gen),
+			      "r" (CC_IGEN),
+			      "i" (ASI_M_MXCC));
+}
+
+/* +-------+-------------+-----------+------------------------------------+
+ * | bcast |  devid      |   sid     |              levels mask           |
+ * +-------+-------------+-----------+------------------------------------+
+ *  31      30         23 22       15 14                                 0
+ */
+#define IGEN_MESSAGE(bcast, devid, sid, levels) \
+	(((bcast) << 31) | ((devid) << 23) | ((sid) << 15) | (levels))
+            
+static inline void sun4d_send_ipi(int cpu, int level)
+{
+	cc_set_igen(IGEN_MESSAGE(0, cpu << 3, 6 + ((level >> 1) & 7), 1 << (level - 1)));
+}
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !(_SPARC_OBIO_H) */
