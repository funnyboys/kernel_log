commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index acf8314cec48..264b186478f3 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* ebus.c: EBUS DMA library code.
  *
  * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)

commit 8b2abcbc5ef1c135b03c7009f98350dbad2fe293
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 15:25:39 2014 -0500

    sparc: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index e306fb08ee5e..acf8314cec48 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -7,7 +7,6 @@
 #include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 

commit 066bcaca51946c8305e3d637a795e8ccf8dbd3cf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 13:18:16 2011 -0400

    sparc: move symbol exporters to use export.h not module.h
    
    Many of the core sparc kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 77dbf6d45faf..e306fb08ee5e 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -4,7 +4,7 @@
  * Copyright (C) 1999  David S. Miller (davem@redhat.com)
  */
 
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>

commit a88b5ba8bd8ac18aad65ee6c6a254e2e74876db3
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Dec 3 03:11:52 2008 -0800

    sparc,sparc64: unify kernel/
    
    o Move all files from sparc64/kernel/ to sparc/kernel
      - rename as appropriate
    o Update sparc/Makefile to the changes
    o Update sparc/kernel/Makefile to include the sparc64 files
    
    NOTE: This commit changes link order on sparc64!
    
    Link order had to change for either of sparc32 and sparc64.
    And assuming sparc64 see more testing than sparc32 change link
    order on sparc64 where issues will be caught faster.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
new file mode 100644
index 000000000000..77dbf6d45faf
--- /dev/null
+++ b/arch/sparc/kernel/ebus.c
@@ -0,0 +1,257 @@
+/* ebus.c: EBUS DMA library code.
+ *
+ * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
+ * Copyright (C) 1999  David S. Miller (davem@redhat.com)
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <asm/ebus_dma.h>
+#include <asm/io.h>
+
+#define EBDMA_CSR	0x00UL	/* Control/Status */
+#define EBDMA_ADDR	0x04UL	/* DMA Address */
+#define EBDMA_COUNT	0x08UL	/* DMA Count */
+
+#define EBDMA_CSR_INT_PEND	0x00000001
+#define EBDMA_CSR_ERR_PEND	0x00000002
+#define EBDMA_CSR_DRAIN		0x00000004
+#define EBDMA_CSR_INT_EN	0x00000010
+#define EBDMA_CSR_RESET		0x00000080
+#define EBDMA_CSR_WRITE		0x00000100
+#define EBDMA_CSR_EN_DMA	0x00000200
+#define EBDMA_CSR_CYC_PEND	0x00000400
+#define EBDMA_CSR_DIAG_RD_DONE	0x00000800
+#define EBDMA_CSR_DIAG_WR_DONE	0x00001000
+#define EBDMA_CSR_EN_CNT	0x00002000
+#define EBDMA_CSR_TC		0x00004000
+#define EBDMA_CSR_DIS_CSR_DRN	0x00010000
+#define EBDMA_CSR_BURST_SZ_MASK	0x000c0000
+#define EBDMA_CSR_BURST_SZ_1	0x00080000
+#define EBDMA_CSR_BURST_SZ_4	0x00000000
+#define EBDMA_CSR_BURST_SZ_8	0x00040000
+#define EBDMA_CSR_BURST_SZ_16	0x000c0000
+#define EBDMA_CSR_DIAG_EN	0x00100000
+#define EBDMA_CSR_DIS_ERR_PEND	0x00400000
+#define EBDMA_CSR_TCI_DIS	0x00800000
+#define EBDMA_CSR_EN_NEXT	0x01000000
+#define EBDMA_CSR_DMA_ON	0x02000000
+#define EBDMA_CSR_A_LOADED	0x04000000
+#define EBDMA_CSR_NA_LOADED	0x08000000
+#define EBDMA_CSR_DEV_ID_MASK	0xf0000000
+
+#define EBUS_DMA_RESET_TIMEOUT	10000
+
+static void __ebus_dma_reset(struct ebus_dma_info *p, int no_drain)
+{
+	int i;
+	u32 val = 0;
+
+	writel(EBDMA_CSR_RESET, p->regs + EBDMA_CSR);
+	udelay(1);
+
+	if (no_drain)
+		return;
+
+	for (i = EBUS_DMA_RESET_TIMEOUT; i > 0; i--) {
+		val = readl(p->regs + EBDMA_CSR);
+
+		if (!(val & (EBDMA_CSR_DRAIN | EBDMA_CSR_CYC_PEND)))
+			break;
+		udelay(10);
+	}
+}
+
+static irqreturn_t ebus_dma_irq(int irq, void *dev_id)
+{
+	struct ebus_dma_info *p = dev_id;
+	unsigned long flags;
+	u32 csr = 0;
+
+	spin_lock_irqsave(&p->lock, flags);
+	csr = readl(p->regs + EBDMA_CSR);
+	writel(csr, p->regs + EBDMA_CSR);
+	spin_unlock_irqrestore(&p->lock, flags);
+
+	if (csr & EBDMA_CSR_ERR_PEND) {
+		printk(KERN_CRIT "ebus_dma(%s): DMA error!\n", p->name);
+		p->callback(p, EBUS_DMA_EVENT_ERROR, p->client_cookie);
+		return IRQ_HANDLED;
+	} else if (csr & EBDMA_CSR_INT_PEND) {
+		p->callback(p,
+			    (csr & EBDMA_CSR_TC) ?
+			    EBUS_DMA_EVENT_DMA : EBUS_DMA_EVENT_DEVICE,
+			    p->client_cookie);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+
+}
+
+int ebus_dma_register(struct ebus_dma_info *p)
+{
+	u32 csr;
+
+	if (!p->regs)
+		return -EINVAL;
+	if (p->flags & ~(EBUS_DMA_FLAG_USE_EBDMA_HANDLER |
+			 EBUS_DMA_FLAG_TCI_DISABLE))
+		return -EINVAL;
+	if ((p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) && !p->callback)
+		return -EINVAL;
+	if (!strlen(p->name))
+		return -EINVAL;
+
+	__ebus_dma_reset(p, 1);
+
+	csr = EBDMA_CSR_BURST_SZ_16 | EBDMA_CSR_EN_CNT;
+
+	if (p->flags & EBUS_DMA_FLAG_TCI_DISABLE)
+		csr |= EBDMA_CSR_TCI_DIS;
+
+	writel(csr, p->regs + EBDMA_CSR);
+
+	return 0;
+}
+EXPORT_SYMBOL(ebus_dma_register);
+
+int ebus_dma_irq_enable(struct ebus_dma_info *p, int on)
+{
+	unsigned long flags;
+	u32 csr;
+
+	if (on) {
+		if (p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) {
+			if (request_irq(p->irq, ebus_dma_irq, IRQF_SHARED, p->name, p))
+				return -EBUSY;
+		}
+
+		spin_lock_irqsave(&p->lock, flags);
+		csr = readl(p->regs + EBDMA_CSR);
+		csr |= EBDMA_CSR_INT_EN;
+		writel(csr, p->regs + EBDMA_CSR);
+		spin_unlock_irqrestore(&p->lock, flags);
+	} else {
+		spin_lock_irqsave(&p->lock, flags);
+		csr = readl(p->regs + EBDMA_CSR);
+		csr &= ~EBDMA_CSR_INT_EN;
+		writel(csr, p->regs + EBDMA_CSR);
+		spin_unlock_irqrestore(&p->lock, flags);
+
+		if (p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) {
+			free_irq(p->irq, p);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ebus_dma_irq_enable);
+
+void ebus_dma_unregister(struct ebus_dma_info *p)
+{
+	unsigned long flags;
+	u32 csr;
+	int irq_on = 0;
+
+	spin_lock_irqsave(&p->lock, flags);
+	csr = readl(p->regs + EBDMA_CSR);
+	if (csr & EBDMA_CSR_INT_EN) {
+		csr &= ~EBDMA_CSR_INT_EN;
+		writel(csr, p->regs + EBDMA_CSR);
+		irq_on = 1;
+	}
+	spin_unlock_irqrestore(&p->lock, flags);
+
+	if (irq_on)
+		free_irq(p->irq, p);
+}
+EXPORT_SYMBOL(ebus_dma_unregister);
+
+int ebus_dma_request(struct ebus_dma_info *p, dma_addr_t bus_addr, size_t len)
+{
+	unsigned long flags;
+	u32 csr;
+	int err;
+
+	if (len >= (1 << 24))
+		return -EINVAL;
+
+	spin_lock_irqsave(&p->lock, flags);
+	csr = readl(p->regs + EBDMA_CSR);
+	err = -EINVAL;
+	if (!(csr & EBDMA_CSR_EN_DMA))
+		goto out;
+	err = -EBUSY;
+	if (csr & EBDMA_CSR_NA_LOADED)
+		goto out;
+
+	writel(len,      p->regs + EBDMA_COUNT);
+	writel(bus_addr, p->regs + EBDMA_ADDR);
+	err = 0;
+
+out:
+	spin_unlock_irqrestore(&p->lock, flags);
+
+	return err;
+}
+EXPORT_SYMBOL(ebus_dma_request);
+
+void ebus_dma_prepare(struct ebus_dma_info *p, int write)
+{
+	unsigned long flags;
+	u32 csr;
+
+	spin_lock_irqsave(&p->lock, flags);
+	__ebus_dma_reset(p, 0);
+
+	csr = (EBDMA_CSR_INT_EN |
+	       EBDMA_CSR_EN_CNT |
+	       EBDMA_CSR_BURST_SZ_16 |
+	       EBDMA_CSR_EN_NEXT);
+
+	if (write)
+		csr |= EBDMA_CSR_WRITE;
+	if (p->flags & EBUS_DMA_FLAG_TCI_DISABLE)
+		csr |= EBDMA_CSR_TCI_DIS;
+
+	writel(csr, p->regs + EBDMA_CSR);
+
+	spin_unlock_irqrestore(&p->lock, flags);
+}
+EXPORT_SYMBOL(ebus_dma_prepare);
+
+unsigned int ebus_dma_residue(struct ebus_dma_info *p)
+{
+	return readl(p->regs + EBDMA_COUNT);
+}
+EXPORT_SYMBOL(ebus_dma_residue);
+
+unsigned int ebus_dma_addr(struct ebus_dma_info *p)
+{
+	return readl(p->regs + EBDMA_ADDR);
+}
+EXPORT_SYMBOL(ebus_dma_addr);
+
+void ebus_dma_enable(struct ebus_dma_info *p, int on)
+{
+	unsigned long flags;
+	u32 orig_csr, csr;
+
+	spin_lock_irqsave(&p->lock, flags);
+	orig_csr = csr = readl(p->regs + EBDMA_CSR);
+	if (on)
+		csr |= EBDMA_CSR_EN_DMA;
+	else
+		csr &= ~EBDMA_CSR_EN_DMA;
+	if ((orig_csr & EBDMA_CSR_EN_DMA) !=
+	    (csr & EBDMA_CSR_EN_DMA))
+		writel(csr, p->regs + EBDMA_CSR);
+	spin_unlock_irqrestore(&p->lock, flags);
+}
+EXPORT_SYMBOL(ebus_dma_enable);

commit 356d164757310cd822d71da2027d50ec39798b7f
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Aug 30 00:36:11 2008 -0700

    sparc: Kill EBUS driver layer.
    
    All that remains is the EBUS DMA programming library for
    sparc64.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
deleted file mode 100644
index 7e9397fc6081..000000000000
--- a/arch/sparc/kernel/ebus.c
+++ /dev/null
@@ -1,392 +0,0 @@
-/*
- * ebus.c: PCI to EBus bridge device.
- *
- * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
- *
- * Adopted for sparc by V. Roganov and G. Raiko.
- * Fixes for different platforms by Pete Zaitcev.
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-
-#include <asm/system.h>
-#include <asm/page.h>
-#include <asm/pbm.h>
-#include <asm/ebus.h>
-#include <asm/io.h>
-#include <asm/oplib.h>
-#include <asm/prom.h>
-
-struct linux_ebus *ebus_chain = NULL;
-
-/* We are together with pcic.c under CONFIG_PCI. */
-extern unsigned int pcic_pin_to_irq(unsigned int, const char *name);
-
-/*
- * IRQ Blacklist
- * Here we list PROMs and systems that are known to supply crap as IRQ numbers.
- */
-struct ebus_device_irq {
-	char *name;
-	unsigned int pin;
-};
-
-struct ebus_system_entry {
-	char *esname;
-	struct ebus_device_irq *ipt;
-};
-
-static struct ebus_device_irq je1_1[] = {
-	{ "8042",		 3 },
-	{ "SUNW,CS4231",	 0 },
-	{ "parallel",		 0 },
-	{ "se",			 2 },
-	{ NULL, 0 }
-};
-
-/*
- * Gleb's JE1 supplied reasonable pin numbers, but mine did not (OBP 2.32).
- * Blacklist the sucker... Note that Gleb's system will work.
- */
-static struct ebus_system_entry ebus_blacklist[] = {
-	{ "SUNW,JavaEngine1", je1_1 },
-	{ NULL, NULL }
-};
-
-static struct ebus_device_irq *ebus_blackp = NULL;
-
-/*
- */
-static inline unsigned long ebus_alloc(size_t size)
-{
-	return (unsigned long)kmalloc(size, GFP_ATOMIC);
-}
-
-/*
- */
-static int __init ebus_blacklist_irq(const char *name)
-{
-	struct ebus_device_irq *dp;
-
-	if ((dp = ebus_blackp) != NULL) {
-		for (; dp->name != NULL; dp++) {
-			if (strcmp(name, dp->name) == 0) {
-				return pcic_pin_to_irq(dp->pin, name);
-			}
-		}
-	}
-	return 0;
-}
-
-static void __init fill_ebus_child(struct device_node *dp,
-				   struct linux_ebus_child *dev)
-{
-	const int *regs;
-	const int *irqs;
-	int i, len;
-
-	dev->prom_node = dp;
-	regs = of_get_property(dp, "reg", &len);
-	if (!regs)
-		len = 0;
-	dev->num_addrs = len / sizeof(regs[0]);
-
-	for (i = 0; i < dev->num_addrs; i++) {
-		if (regs[i] >= dev->parent->num_addrs) {
-			prom_printf("UGH: property for %s was %d, need < %d\n",
-				    dev->prom_node->name, len,
-				    dev->parent->num_addrs);
-			panic(__func__);
-		}
-
-		/* XXX resource */
-		dev->resource[i].start =
-			dev->parent->resource[regs[i]].start;
-	}
-
-	for (i = 0; i < PROMINTR_MAX; i++)
-		dev->irqs[i] = PCI_IRQ_NONE;
-
-	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_node->name)) != 0) {
-		dev->num_irqs = 1;
-	} else {
-		irqs = of_get_property(dp, "interrupts", &len);
-		if (!irqs) {
-			dev->num_irqs = 0;
-			dev->irqs[0] = 0;
-			if (dev->parent->num_irqs != 0) {
-				dev->num_irqs = 1;
-				dev->irqs[0] = dev->parent->irqs[0];
-			}
-		} else {
-			dev->num_irqs = len / sizeof(irqs[0]);
-			if (irqs[0] == 0 || irqs[0] >= 8) {
-				/*
-				 * XXX Zero is a valid pin number...
-				 * This works as long as Ebus is not wired
-				 * to INTA#.
-				 */
-				printk("EBUS: %s got bad irq %d from PROM\n",
-				       dev->prom_node->name, irqs[0]);
-				dev->num_irqs = 0;
-				dev->irqs[0] = 0;
-			} else {
-				dev->irqs[0] =
-					pcic_pin_to_irq(irqs[0],
-							dev->prom_node->name);
-			}
-		}
-	}
-}
-
-static void __init fill_ebus_device(struct device_node *dp,
-				    struct linux_ebus_device *dev)
-{
-	const struct linux_prom_registers *regs;
-	struct linux_ebus_child *child;
-	struct dev_archdata *sd;
-	const int *irqs;
-	int i, n, len;
-	unsigned long baseaddr;
-
-	dev->prom_node = dp;
-
-	regs = of_get_property(dp, "reg", &len);
-	if (!regs)
-		len = 0;
-	if (len % sizeof(struct linux_prom_registers)) {
-		prom_printf("UGH: proplen for %s was %d, need multiple of %d\n",
-			    dev->prom_node->name, len,
-			    (int)sizeof(struct linux_prom_registers));
-		panic(__func__);
-	}
-	dev->num_addrs = len / sizeof(struct linux_prom_registers);
-
-	for (i = 0; i < dev->num_addrs; i++) {
-		/*
-		 * XXX Collect JE-1 PROM
-		 * 
-		 * Example - JS-E with 3.11:
-		 *  /ebus
-		 *      regs 
-		 *        0x00000000, 0x0, 0x00000000, 0x0, 0x00000000,
-		 *        0x82000010, 0x0, 0xf0000000, 0x0, 0x01000000,
-		 *        0x82000014, 0x0, 0x38800000, 0x0, 0x00800000,
-		 *      ranges
-		 *        0x00, 0x00000000, 0x02000010, 0x0, 0x0, 0x01000000,
-		 *        0x01, 0x01000000, 0x02000014, 0x0, 0x0, 0x00800000,
-		 *  /ebus/8042
-		 *      regs
-		 *        0x00000001, 0x00300060, 0x00000008,
-		 *        0x00000001, 0x00300060, 0x00000008,
-		 */
-		n = regs[i].which_io;
-		if (n >= 4) {
-			/* XXX This is copied from old JE-1 by Gleb. */
-			n = (regs[i].which_io - 0x10) >> 2;
-		} else {
-			;
-		}
-
-/*
- * XXX Now as we have regions, why don't we make an on-demand allocation...
- */
-		dev->resource[i].start = 0;
-		if ((baseaddr = dev->bus->self->resource[n].start +
-		    regs[i].phys_addr) != 0) {
-			/* dev->resource[i].name = dev->prom_name; */
-			if ((baseaddr = (unsigned long) ioremap(baseaddr,
-			    regs[i].reg_size)) == 0) {
-				panic("ebus: unable to remap dev %s",
-				      dev->prom_node->name);
-			}
-		}
-		dev->resource[i].start = baseaddr;	/* XXX Unaligned */
-	}
-
-	for (i = 0; i < PROMINTR_MAX; i++)
-		dev->irqs[i] = PCI_IRQ_NONE;
-
-	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_node->name)) != 0) {
-		dev->num_irqs = 1;
-	} else {
-		irqs = of_get_property(dp, "interrupts", &len);
-		if (!irqs) {
-			dev->num_irqs = 0;
-			if ((dev->irqs[0] = dev->bus->self->irq) != 0) {
-				dev->num_irqs = 1;
-/* P3 */ /* printk("EBUS: child %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
-			}
-		} else {
-			dev->num_irqs = 1;  /* dev->num_irqs = len / sizeof(irqs[0]); */
-			if (irqs[0] == 0 || irqs[0] >= 8) {
-				/* See above for the parent. XXX */
-				printk("EBUS: %s got bad irq %d from PROM\n",
-				       dev->prom_node->name, irqs[0]);
-				dev->num_irqs = 0;
-				dev->irqs[0] = 0;
-			} else {
-				dev->irqs[0] =
-					pcic_pin_to_irq(irqs[0],
-							dev->prom_node->name);
-			}
-		}
-	}
-
-	sd = &dev->ofdev.dev.archdata;
-	sd->prom_node = dp;
-	sd->op = &dev->ofdev;
-	sd->iommu = dev->bus->ofdev.dev.parent->archdata.iommu;
-
-	dev->ofdev.node = dp;
-	dev->ofdev.dev.parent = &dev->bus->ofdev.dev;
-	dev->ofdev.dev.bus = &ebus_bus_type;
-	sprintf(dev->ofdev.dev.bus_id, "ebus[%08x]", dp->node);
-
-	/* Register with core */
-	if (of_device_register(&dev->ofdev) != 0)
-		printk(KERN_DEBUG "ebus: device registration error for %s!\n",
-		       dp->path_component_name);
-
-	if ((dp = dp->child) != NULL) {
-		dev->children = (struct linux_ebus_child *)
-			ebus_alloc(sizeof(struct linux_ebus_child));
-
-		child = dev->children;
-		child->next = NULL;
-		child->parent = dev;
-		child->bus = dev->bus;
-		fill_ebus_child(dp, child);
-
-		while ((dp = dp->sibling) != NULL) {
-			child->next = (struct linux_ebus_child *)
-				ebus_alloc(sizeof(struct linux_ebus_child));
-
-			child = child->next;
-			child->next = NULL;
-			child->parent = dev;
-			child->bus = dev->bus;
-			fill_ebus_child(dp, child);
-		}
-	}
-}
-
-void __init ebus_init(void)
-{
-	const struct linux_prom_pci_registers *regs;
-	struct linux_pbm_info *pbm;
-	struct linux_ebus_device *dev;
-	struct linux_ebus *ebus;
-	struct ebus_system_entry *sp;
-	struct pci_dev *pdev;
-	struct pcidev_cookie *cookie;
-	struct device_node *dp;
-	struct resource *p;
-	unsigned short pci_command;
-	int len, reg, nreg;
-	int num_ebus = 0;
-
-	dp = of_find_node_by_path("/");
-	for (sp = ebus_blacklist; sp->esname != NULL; sp++) {
-		if (strcmp(dp->name, sp->esname) == 0) {
-			ebus_blackp = sp->ipt;
-			break;
-		}
-	}
-
-	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, NULL);
-	if (!pdev)
-		return;
-
-	cookie = pdev->sysdata;
-	dp = cookie->prom_node;
-
-	ebus_chain = ebus = (struct linux_ebus *)
-			ebus_alloc(sizeof(struct linux_ebus));
-	ebus->next = NULL;
-
-	while (dp) {
-		struct device_node *nd;
-
-		ebus->prom_node = dp;
-		ebus->self = pdev;
-		ebus->parent = pbm = cookie->pbm;
-
-		/* Enable BUS Master. */
-		pci_read_config_word(pdev, PCI_COMMAND, &pci_command);
-		pci_command |= PCI_COMMAND_MASTER;
-		pci_write_config_word(pdev, PCI_COMMAND, pci_command);
-
-		regs = of_get_property(dp, "reg", &len);
-		if (!regs) {
-			prom_printf("%s: can't find reg property\n",
-				    __func__);
-			prom_halt();
-		}
-		nreg = len / sizeof(struct linux_prom_pci_registers);
-
-		p = &ebus->self->resource[0];
-		for (reg = 0; reg < nreg; reg++) {
-			if (!(regs[reg].which_io & 0x03000000))
-				continue;
-
-			(p++)->start = regs[reg].phys_lo;
-		}
-
-		ebus->ofdev.node = dp;
-		ebus->ofdev.dev.parent = &pdev->dev;
-		ebus->ofdev.dev.bus = &ebus_bus_type;
-		sprintf(ebus->ofdev.dev.bus_id, "ebus%d", num_ebus);
-
-		/* Register with core */
-		if (of_device_register(&ebus->ofdev) != 0)
-			printk(KERN_DEBUG "ebus: device registration error for %s!\n",
-			       dp->path_component_name);
-
-
-		nd = dp->child;
-		if (!nd)
-			goto next_ebus;
-
-		ebus->devices = (struct linux_ebus_device *)
-				ebus_alloc(sizeof(struct linux_ebus_device));
-
-		dev = ebus->devices;
-		dev->next = NULL;
-		dev->children = NULL;
-		dev->bus = ebus;
-		fill_ebus_device(nd, dev);
-
-		while ((nd = nd->sibling) != NULL) {
-			dev->next = (struct linux_ebus_device *)
-				ebus_alloc(sizeof(struct linux_ebus_device));
-
-			dev = dev->next;
-			dev->next = NULL;
-			dev->children = NULL;
-			dev->bus = ebus;
-			fill_ebus_device(nd, dev);
-		}
-
-	next_ebus:
-		pdev = pci_get_device(PCI_VENDOR_ID_SUN,
-				       PCI_DEVICE_ID_SUN_EBUS, pdev);
-		if (!pdev)
-			break;
-
-		cookie = pdev->sysdata;
-		dp = cookie->prom_node;
-
-		ebus->next = (struct linux_ebus *)
-			ebus_alloc(sizeof(struct linux_ebus));
-		ebus = ebus->next;
-		ebus->next = NULL;
-		++num_ebus;
-	}
-	if (pdev)
-		pci_dev_put(pdev);
-}

commit 902663f6ea4a2603bee0d88450aae2d653a46f5d
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 26 22:25:03 2008 -0700

    sparc: Delete bare sbus char bpp driver, obsoleted by parport_sunbpp
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 97294232259c..7e9397fc6081 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -20,7 +20,6 @@
 #include <asm/io.h>
 #include <asm/oplib.h>
 #include <asm/prom.h>
-#include <asm/bpp.h>
 
 struct linux_ebus *ebus_chain = NULL;
 

commit c61c65cdcd1021cfbd7be8685ff1cf4f86c68c44
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jun 5 11:40:58 2008 -0700

    sparc/kernel/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global code static:
      - apc.c: apc_swift_idle()
      - ebus.c: ebus_blacklist_irq()
      - ebus.c: fill_ebus_child()
      - ebus.c: fill_ebus_device()
      - entry.S: syscall_is_too_hard
      - etra: tsetup_sun4c_stackchk
      - head.S: cputyp
      - head.S: prom_vector_p
      - idprom.c: Sun_Machines[]
      - ioport.c: _sparc_find_resource()
      - ioport.c: create_proc_read_entry()
      - irq.c: struct sparc_irq[]
      - rtrap.S: sun4c_rett_stackchk
      - setup.c: prom_sync_me()
      - setup.c: boot_flags
      - sun4c_irq.c: sun4c_sbint_to_irq()
      - sun4d_irq.c: sbus_tid[]
      - sun4d_irq.c: struct sbus_actions
      - sun4d_irq.c: sun4d_sbint_to_irq()
      - sun4m_irq.c: sun4m_sbint_to_irq()
      - sun4m_irq.c: sun4m_get_irqmask()
      - sun4m_irq.c: sun4m_timers
      - sun4m_smp.c: smp4m_cross_call()
      - sun4m_smp.c: smp4m_blackbox_id()
      - sun4m_smp.c: smp4m_blackbox_current()
      - time.c: sp_clock_typ
      - time.c: sbus_time_init()
      - traps.c: instruction_dump()
      - wof.S: spwin_sun4c_stackchk
      - wuf.S: sun4c_fwin_stackchk
    - #if 0 the following unused code:
      - process.c: sparc_backtrace_lock
      - process.c: __show_backtrace()
      - process.c: show_backtrace()
      - process.c: smp_show_backtrace_all_cpus()
    - remove the following unused code:
      - entry.S: __handle_exception
      - smp.c: smp_num_cpus
      - smp.c: smp_activated
      - smp.c: __cpu_number_map[]
      - smp.c: __cpu_logical_map[]
      - smp.c: bitops_spinlock
      - traps.c: trap_curbuf
      - traps.c: trapbuf[]
      - traps.c: linux_smp_still_initting
      - traps.c: thiscpus_tbr
      - traps.c: thiscpus_mid
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 92c6fc07e59c..97294232259c 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -69,7 +69,7 @@ static inline unsigned long ebus_alloc(size_t size)
 
 /*
  */
-int __init ebus_blacklist_irq(const char *name)
+static int __init ebus_blacklist_irq(const char *name)
 {
 	struct ebus_device_irq *dp;
 
@@ -83,8 +83,8 @@ int __init ebus_blacklist_irq(const char *name)
 	return 0;
 }
 
-void __init fill_ebus_child(struct device_node *dp,
-			    struct linux_ebus_child *dev)
+static void __init fill_ebus_child(struct device_node *dp,
+				   struct linux_ebus_child *dev)
 {
 	const int *regs;
 	const int *irqs;
@@ -144,7 +144,8 @@ void __init fill_ebus_child(struct device_node *dp,
 	}
 }
 
-void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *dev)
+static void __init fill_ebus_device(struct device_node *dp,
+				    struct linux_ebus_device *dev)
 {
 	const struct linux_prom_registers *regs;
 	struct linux_ebus_child *child;

commit 88278ca27a43ae503572b52ea2c171fbf45db5a2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon May 19 16:53:02 2008 -0700

    sparc: remove CVS keywords
    
    This patch removes the CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 96344ff2bbe1..92c6fc07e59c 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -1,4 +1,4 @@
-/* $Id: ebus.c,v 1.20 2002/01/05 01:13:43 davem Exp $
+/*
  * ebus.c: PCI to EBus bridge device.
  *
  * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)

commit 74074dec4f365e1b042ad47f75854f06bd771455
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 11:41:51 2008 -0800

    sparc: replace remaining __FUNCTION__ occurances
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index d850785b2080..96344ff2bbe1 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -101,7 +101,7 @@ void __init fill_ebus_child(struct device_node *dp,
 			prom_printf("UGH: property for %s was %d, need < %d\n",
 				    dev->prom_node->name, len,
 				    dev->parent->num_addrs);
-			panic(__FUNCTION__);
+			panic(__func__);
 		}
 
 		/* XXX resource */
@@ -162,7 +162,7 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 		prom_printf("UGH: proplen for %s was %d, need multiple of %d\n",
 			    dev->prom_node->name, len,
 			    (int)sizeof(struct linux_prom_registers));
-		panic(__FUNCTION__);
+		panic(__func__);
 	}
 	dev->num_addrs = len / sizeof(struct linux_prom_registers);
 
@@ -324,7 +324,7 @@ void __init ebus_init(void)
 		regs = of_get_property(dp, "reg", &len);
 		if (!regs) {
 			prom_printf("%s: can't find reg property\n",
-				    __FUNCTION__);
+				    __func__);
 			prom_halt();
 		}
 		nreg = len / sizeof(struct linux_prom_pci_registers);

commit 9c908f97d0f9aee32fa6d4b0a44c4c5d0ccab2b0
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Sep 27 13:09:28 2007 -0700

    [SPARC]: Fix EBUS use of uninitialized variable.
    
    If of_get_property() fails, it returns NULL and the 'len'
    parameter is undefined.  So we need to explicitly set len
    to zero in such cases.
    
    Noticed by Al Viro.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index e2d02fd13f35..d850785b2080 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -156,6 +156,8 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 	dev->prom_node = dp;
 
 	regs = of_get_property(dp, "reg", &len);
+	if (!regs)
+		len = 0;
 	if (len % sizeof(struct linux_prom_registers)) {
 		prom_printf("UGH: proplen for %s was %d, need multiple of %d\n",
 			    dev->prom_node->name, len,

commit 3ac4c949e02f26be1e4378f9acfb07ec87db947b
Author: Robert Reif <reif@earthlink.net>
Date:   Fri Aug 10 15:52:06 2007 -0700

    [SPARC32]: Remove iommu from struct sbus_bus and use archdata like sparc64.
    
    Signed-off-by: Robert Reif <reif@earthlink.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index ac352eb6dff3..e2d02fd13f35 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -238,6 +238,7 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 	sd = &dev->ofdev.dev.archdata;
 	sd->prom_node = dp;
 	sd->op = &dev->ofdev;
+	sd->iommu = dev->bus->ofdev.dev.parent->archdata.iommu;
 
 	dev->ofdev.node = dp;
 	dev->ofdev.dev.parent = &dev->bus->ofdev.dev;

commit 3d6e470236bc759f43c9f2377899b526a50e2e63
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Wed Jul 18 22:03:25 2007 -0700

    [SPARC]: Make sure dev_archdata is filled in for all devices.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 7bb86b9cdaa3..ac352eb6dff3 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -148,6 +148,7 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 {
 	const struct linux_prom_registers *regs;
 	struct linux_ebus_child *child;
+	struct dev_archdata *sd;
 	const int *irqs;
 	int i, n, len;
 	unsigned long baseaddr;
@@ -234,6 +235,10 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 		}
 	}
 
+	sd = &dev->ofdev.dev.archdata;
+	sd->prom_node = dp;
+	sd->op = &dev->ofdev;
+
 	dev->ofdev.node = dp;
 	dev->ofdev.dev.parent = &dev->bus->ofdev.dev;
 	dev->ofdev.dev.bus = &ebus_bus_type;

commit ee5ac9ddf2ea13be2418ac7d0ce5a930e78af013
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Apr 26 00:03:53 2007 -0700

    [SPARC]: device_node name constification fallout
    
    A couple of routines need their arguments to be const.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 7724e2067159..7bb86b9cdaa3 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -25,7 +25,7 @@
 struct linux_ebus *ebus_chain = NULL;
 
 /* We are together with pcic.c under CONFIG_PCI. */
-extern unsigned int pcic_pin_to_irq(unsigned int, char *name);
+extern unsigned int pcic_pin_to_irq(unsigned int, const char *name);
 
 /*
  * IRQ Blacklist
@@ -69,7 +69,7 @@ static inline unsigned long ebus_alloc(size_t size)
 
 /*
  */
-int __init ebus_blacklist_irq(char *name)
+int __init ebus_blacklist_irq(const char *name)
 {
 	struct ebus_device_irq *dp;
 

commit 8271f04242af8ddf8390f289cd6ef78fb3e3c6d9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 29 00:47:23 2007 -0700

    [SPARC]: constify of_get_property return: arch/sparc
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index ba58c3a061fd..7724e2067159 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -86,8 +86,8 @@ int __init ebus_blacklist_irq(char *name)
 void __init fill_ebus_child(struct device_node *dp,
 			    struct linux_ebus_child *dev)
 {
-	int *regs;
-	int *irqs;
+	const int *regs;
+	const int *irqs;
 	int i, len;
 
 	dev->prom_node = dp;
@@ -146,9 +146,9 @@ void __init fill_ebus_child(struct device_node *dp,
 
 void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *dev)
 {
-	struct linux_prom_registers *regs;
+	const struct linux_prom_registers *regs;
 	struct linux_ebus_child *child;
-	int *irqs;
+	const int *irqs;
 	int i, n, len;
 	unsigned long baseaddr;
 
@@ -269,7 +269,7 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 
 void __init ebus_init(void)
 {
-	struct linux_prom_pci_registers *regs;
+	const struct linux_prom_pci_registers *regs;
 	struct linux_pbm_info *pbm;
 	struct linux_ebus_device *dev;
 	struct linux_ebus *ebus;

commit f5ef9d11fd255b30b455d18f8d721bc44cd1296b
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Oct 27 01:03:31 2006 -0700

    [SPARC]: Fix bus_id[] string overflow.
    
    dp->path_component_name can be larger than ->bus_id[]
    so use a different naming scheme for this stuff.
    
    Noticed by Jurij Smakov.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 75ac24d229b1..ba58c3a061fd 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -237,12 +237,12 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 	dev->ofdev.node = dp;
 	dev->ofdev.dev.parent = &dev->bus->ofdev.dev;
 	dev->ofdev.dev.bus = &ebus_bus_type;
-	strcpy(dev->ofdev.dev.bus_id, dp->path_component_name);
+	sprintf(dev->ofdev.dev.bus_id, "ebus[%08x]", dp->node);
 
 	/* Register with core */
 	if (of_device_register(&dev->ofdev) != 0)
 		printk(KERN_DEBUG "ebus: device registration error for %s!\n",
-		       dev->ofdev.dev.bus_id);
+		       dp->path_component_name);
 
 	if ((dp = dp->child) != NULL) {
 		dev->children = (struct linux_ebus_child *)
@@ -332,12 +332,12 @@ void __init ebus_init(void)
 		ebus->ofdev.node = dp;
 		ebus->ofdev.dev.parent = &pdev->dev;
 		ebus->ofdev.dev.bus = &ebus_bus_type;
-		strcpy(ebus->ofdev.dev.bus_id, dp->path_component_name);
+		sprintf(ebus->ofdev.dev.bus_id, "ebus%d", num_ebus);
 
 		/* Register with core */
 		if (of_device_register(&ebus->ofdev) != 0)
 			printk(KERN_DEBUG "ebus: device registration error for %s!\n",
-			       ebus->ofdev.dev.bus_id);
+			       dp->path_component_name);
 
 
 		nd = dp->child;

commit cc9bd99e9adfa4f44ea050a63fb41a3f764acf84
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Sep 23 01:18:41 2006 +0100

    [PATCH] fix ancient breakage in ebus_init()
    
    Back when pci_dev had base_address[], loop of form
            base = &...->base_address[0];
            for (.....) {
                    ...
                    *base++ = addr;
            }
    was fine, but when that array got spread in ->resource[...].start
    replacing the initialization with
            base = &...->resource[0].start;
    was not a sufficient modification.  IOW this code got broken for cases
    when there had been more than one resource to fill.  All way back in
    2.3.41-pre3...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 81c0cbd96ff0..75ac24d229b1 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -277,7 +277,7 @@ void __init ebus_init(void)
 	struct pci_dev *pdev;
 	struct pcidev_cookie *cookie;
 	struct device_node *dp;
-	unsigned long addr, *base;
+	struct resource *p;
 	unsigned short pci_command;
 	int len, reg, nreg;
 	int num_ebus = 0;
@@ -321,13 +321,12 @@ void __init ebus_init(void)
 		}
 		nreg = len / sizeof(struct linux_prom_pci_registers);
 
-		base = &ebus->self->resource[0].start;
+		p = &ebus->self->resource[0];
 		for (reg = 0; reg < nreg; reg++) {
 			if (!(regs[reg].which_io & 0x03000000))
 				continue;
 
-			addr = regs[reg].phys_lo;
-			*base++ = addr;
+			(p++)->start = regs[reg].phys_lo;
 		}
 
 		ebus->ofdev.node = dp;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index a7a4892956c8..81c0cbd96ff0 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -7,7 +7,6 @@
  * Fixes for different platforms by Pete Zaitcev.
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>

commit fd5314311634245172d40ccb418d89dac91d6ad6
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 15:55:17 2006 -0700

    [SPARC]: Port of_device layer and make ebus use it.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 9d461da76399..a7a4892956c8 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -235,6 +235,16 @@ void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *d
 		}
 	}
 
+	dev->ofdev.node = dp;
+	dev->ofdev.dev.parent = &dev->bus->ofdev.dev;
+	dev->ofdev.dev.bus = &ebus_bus_type;
+	strcpy(dev->ofdev.dev.bus_id, dp->path_component_name);
+
+	/* Register with core */
+	if (of_device_register(&dev->ofdev) != 0)
+		printk(KERN_DEBUG "ebus: device registration error for %s!\n",
+		       dev->ofdev.dev.bus_id);
+
 	if ((dp = dp->child) != NULL) {
 		dev->children = (struct linux_ebus_child *)
 			ebus_alloc(sizeof(struct linux_ebus_child));
@@ -321,6 +331,17 @@ void __init ebus_init(void)
 			*base++ = addr;
 		}
 
+		ebus->ofdev.node = dp;
+		ebus->ofdev.dev.parent = &pdev->dev;
+		ebus->ofdev.dev.bus = &ebus_bus_type;
+		strcpy(ebus->ofdev.dev.bus_id, dp->path_component_name);
+
+		/* Register with core */
+		if (of_device_register(&ebus->ofdev) != 0)
+			printk(KERN_DEBUG "ebus: device registration error for %s!\n",
+			       ebus->ofdev.dev.bus_id);
+
+
 		nd = dp->child;
 		if (!nd)
 			goto next_ebus;

commit 942a6bdd1c4d2419a42be77ba1c964e4ba8dae9e
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 15:53:31 2006 -0700

    [SPARC]: Port sparc64 in-kernel device tree code to sparc32.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 5c3529ceb5d6..9d461da76399 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -20,6 +20,7 @@
 #include <asm/ebus.h>
 #include <asm/io.h>
 #include <asm/oplib.h>
+#include <asm/prom.h>
 #include <asm/bpp.h>
 
 struct linux_ebus *ebus_chain = NULL;
@@ -83,79 +84,81 @@ int __init ebus_blacklist_irq(char *name)
 	return 0;
 }
 
-void __init fill_ebus_child(int node, struct linux_prom_registers *preg,
-				struct linux_ebus_child *dev)
+void __init fill_ebus_child(struct device_node *dp,
+			    struct linux_ebus_child *dev)
 {
-	int regs[PROMREG_MAX];
-	int irqs[PROMREG_MAX];
-	char lbuf[128];
+	int *regs;
+	int *irqs;
 	int i, len;
 
-	dev->prom_node = node;
-	prom_getstring(node, "name", lbuf, sizeof(lbuf));
-	strcpy(dev->prom_name, lbuf);
-
-	len = prom_getproperty(node, "reg", (void *)regs, sizeof(regs));
-	if (len == -1) len = 0;
+	dev->prom_node = dp;
+	regs = of_get_property(dp, "reg", &len);
+	if (!regs)
+		len = 0;
 	dev->num_addrs = len / sizeof(regs[0]);
 
 	for (i = 0; i < dev->num_addrs; i++) {
 		if (regs[i] >= dev->parent->num_addrs) {
 			prom_printf("UGH: property for %s was %d, need < %d\n",
-				    dev->prom_name, len, dev->parent->num_addrs);
+				    dev->prom_node->name, len,
+				    dev->parent->num_addrs);
 			panic(__FUNCTION__);
 		}
-		dev->resource[i].start = dev->parent->resource[regs[i]].start; /* XXX resource */
+
+		/* XXX resource */
+		dev->resource[i].start =
+			dev->parent->resource[regs[i]].start;
 	}
 
 	for (i = 0; i < PROMINTR_MAX; i++)
 		dev->irqs[i] = PCI_IRQ_NONE;
 
-	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_name)) != 0) {
+	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_node->name)) != 0) {
 		dev->num_irqs = 1;
-	} else if ((len = prom_getproperty(node, "interrupts",
-	    (char *)&irqs, sizeof(irqs))) == -1 || len == 0) {
-		dev->num_irqs = 0;
-		dev->irqs[0] = 0;
-		if (dev->parent->num_irqs != 0) {
-			dev->num_irqs = 1;
-			dev->irqs[0] = dev->parent->irqs[0];
-/* P3 */ /* printk("EBUS: dev %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
-		}
 	} else {
-		dev->num_irqs = len / sizeof(irqs[0]);
-		if (irqs[0] == 0 || irqs[0] >= 8) {
-			/*
-			 * XXX Zero is a valid pin number...
-			 * This works as long as Ebus is not wired to INTA#.
-			 */
-			printk("EBUS: %s got bad irq %d from PROM\n",
-			    dev->prom_name, irqs[0]);
+		irqs = of_get_property(dp, "interrupts", &len);
+		if (!irqs) {
 			dev->num_irqs = 0;
 			dev->irqs[0] = 0;
+			if (dev->parent->num_irqs != 0) {
+				dev->num_irqs = 1;
+				dev->irqs[0] = dev->parent->irqs[0];
+			}
 		} else {
-			dev->irqs[0] = pcic_pin_to_irq(irqs[0], dev->prom_name);
+			dev->num_irqs = len / sizeof(irqs[0]);
+			if (irqs[0] == 0 || irqs[0] >= 8) {
+				/*
+				 * XXX Zero is a valid pin number...
+				 * This works as long as Ebus is not wired
+				 * to INTA#.
+				 */
+				printk("EBUS: %s got bad irq %d from PROM\n",
+				       dev->prom_node->name, irqs[0]);
+				dev->num_irqs = 0;
+				dev->irqs[0] = 0;
+			} else {
+				dev->irqs[0] =
+					pcic_pin_to_irq(irqs[0],
+							dev->prom_node->name);
+			}
 		}
 	}
 }
 
-void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
+void __init fill_ebus_device(struct device_node *dp, struct linux_ebus_device *dev)
 {
-	struct linux_prom_registers regs[PROMREG_MAX];
+	struct linux_prom_registers *regs;
 	struct linux_ebus_child *child;
-	int irqs[PROMINTR_MAX];
-	char lbuf[128];
+	int *irqs;
 	int i, n, len;
 	unsigned long baseaddr;
 
-	dev->prom_node = node;
-	prom_getstring(node, "name", lbuf, sizeof(lbuf));
-	strcpy(dev->prom_name, lbuf);
+	dev->prom_node = dp;
 
-	len = prom_getproperty(node, "reg", (void *)regs, sizeof(regs));
+	regs = of_get_property(dp, "reg", &len);
 	if (len % sizeof(struct linux_prom_registers)) {
 		prom_printf("UGH: proplen for %s was %d, need multiple of %d\n",
-			    dev->prom_name, len,
+			    dev->prom_node->name, len,
 			    (int)sizeof(struct linux_prom_registers));
 		panic(__FUNCTION__);
 	}
@@ -197,7 +200,7 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 			if ((baseaddr = (unsigned long) ioremap(baseaddr,
 			    regs[i].reg_size)) == 0) {
 				panic("ebus: unable to remap dev %s",
-				    dev->prom_name);
+				      dev->prom_node->name);
 			}
 		}
 		dev->resource[i].start = baseaddr;	/* XXX Unaligned */
@@ -206,29 +209,33 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 	for (i = 0; i < PROMINTR_MAX; i++)
 		dev->irqs[i] = PCI_IRQ_NONE;
 
-	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_name)) != 0) {
+	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_node->name)) != 0) {
 		dev->num_irqs = 1;
-	} else if ((len = prom_getproperty(node, "interrupts",
-	    (char *)&irqs, sizeof(irqs))) == -1 || len == 0) {
-		dev->num_irqs = 0;
-		if ((dev->irqs[0] = dev->bus->self->irq) != 0) {
-			 dev->num_irqs = 1;
-/* P3 */ /* printk("EBUS: child %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
-		}
 	} else {
-		dev->num_irqs = 1;  /* dev->num_irqs = len / sizeof(irqs[0]); */
-		if (irqs[0] == 0 || irqs[0] >= 8) {
-			/* See above for the parent. XXX */
-			printk("EBUS: %s got bad irq %d from PROM\n",
-			    dev->prom_name, irqs[0]);
+		irqs = of_get_property(dp, "interrupts", &len);
+		if (!irqs) {
 			dev->num_irqs = 0;
-			dev->irqs[0] = 0;
+			if ((dev->irqs[0] = dev->bus->self->irq) != 0) {
+				dev->num_irqs = 1;
+/* P3 */ /* printk("EBUS: child %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
+			}
 		} else {
-			dev->irqs[0] = pcic_pin_to_irq(irqs[0], dev->prom_name);
+			dev->num_irqs = 1;  /* dev->num_irqs = len / sizeof(irqs[0]); */
+			if (irqs[0] == 0 || irqs[0] >= 8) {
+				/* See above for the parent. XXX */
+				printk("EBUS: %s got bad irq %d from PROM\n",
+				       dev->prom_node->name, irqs[0]);
+				dev->num_irqs = 0;
+				dev->irqs[0] = 0;
+			} else {
+				dev->irqs[0] =
+					pcic_pin_to_irq(irqs[0],
+							dev->prom_node->name);
+			}
 		}
 	}
 
-	if ((node = prom_getchild(node))) {
+	if ((dp = dp->child) != NULL) {
 		dev->children = (struct linux_ebus_child *)
 			ebus_alloc(sizeof(struct linux_ebus_child));
 
@@ -236,9 +243,9 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 		child->next = NULL;
 		child->parent = dev;
 		child->bus = dev->bus;
-		fill_ebus_child(node, &regs[0], child);
+		fill_ebus_child(dp, child);
 
-		while ((node = prom_getsibling(node)) != 0) {
+		while ((dp = dp->sibling) != NULL) {
 			child->next = (struct linux_ebus_child *)
 				ebus_alloc(sizeof(struct linux_ebus_child));
 
@@ -246,51 +253,49 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 			child->next = NULL;
 			child->parent = dev;
 			child->bus = dev->bus;
-			fill_ebus_child(node, &regs[0], child);
+			fill_ebus_child(dp, child);
 		}
 	}
 }
 
 void __init ebus_init(void)
 {
-	struct linux_prom_pci_registers regs[PROMREG_MAX];
+	struct linux_prom_pci_registers *regs;
 	struct linux_pbm_info *pbm;
 	struct linux_ebus_device *dev;
 	struct linux_ebus *ebus;
 	struct ebus_system_entry *sp;
 	struct pci_dev *pdev;
 	struct pcidev_cookie *cookie;
-	char lbuf[128];
+	struct device_node *dp;
 	unsigned long addr, *base;
 	unsigned short pci_command;
-	int nd, len, ebusnd;
-	int reg, nreg;
+	int len, reg, nreg;
 	int num_ebus = 0;
 
-	prom_getstring(prom_root_node, "name", lbuf, sizeof(lbuf));
+	dp = of_find_node_by_path("/");
 	for (sp = ebus_blacklist; sp->esname != NULL; sp++) {
-		if (strcmp(lbuf, sp->esname) == 0) {
+		if (strcmp(dp->name, sp->esname) == 0) {
 			ebus_blackp = sp->ipt;
 			break;
 		}
 	}
 
 	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, NULL);
-	if (!pdev) {
+	if (!pdev)
 		return;
-	}
+
 	cookie = pdev->sysdata;
-	ebusnd = cookie->prom_node;
+	dp = cookie->prom_node;
 
 	ebus_chain = ebus = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));
 	ebus->next = NULL;
 
-	while (ebusnd) {
+	while (dp) {
+		struct device_node *nd;
 
-		prom_getstring(ebusnd, "name", lbuf, sizeof(lbuf));
-		ebus->prom_node = ebusnd;
-		strcpy(ebus->prom_name, lbuf);
+		ebus->prom_node = dp;
 		ebus->self = pdev;
 		ebus->parent = pbm = cookie->pbm;
 
@@ -299,9 +304,8 @@ void __init ebus_init(void)
 		pci_command |= PCI_COMMAND_MASTER;
 		pci_write_config_word(pdev, PCI_COMMAND, pci_command);
 
-		len = prom_getproperty(ebusnd, "reg", (void *)regs,
-				       sizeof(regs));
-		if (len == 0 || len == -1) {
+		regs = of_get_property(dp, "reg", &len);
+		if (!regs) {
 			prom_printf("%s: can't find reg property\n",
 				    __FUNCTION__);
 			prom_halt();
@@ -317,7 +321,7 @@ void __init ebus_init(void)
 			*base++ = addr;
 		}
 
-		nd = prom_getchild(ebusnd);
+		nd = dp->child;
 		if (!nd)
 			goto next_ebus;
 
@@ -330,7 +334,7 @@ void __init ebus_init(void)
 		dev->bus = ebus;
 		fill_ebus_device(nd, dev);
 
-		while ((nd = prom_getsibling(nd)) != 0) {
+		while ((nd = nd->sibling) != NULL) {
 			dev->next = (struct linux_ebus_device *)
 				ebus_alloc(sizeof(struct linux_ebus_device));
 
@@ -348,7 +352,7 @@ void __init ebus_init(void)
 			break;
 
 		cookie = pdev->sysdata;
-		ebusnd = cookie->prom_node;
+		dp = cookie->prom_node;
 
 		ebus->next = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));

commit e4fe342f932346a306f98f5401ad510b890c0a15
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 4 18:48:45 2005 -0500

    [PATCH] sparc: NULL noise removal (ebus.c)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
index 1754192c69d0..5c3529ceb5d6 100644
--- a/arch/sparc/kernel/ebus.c
+++ b/arch/sparc/kernel/ebus.c
@@ -22,7 +22,7 @@
 #include <asm/oplib.h>
 #include <asm/bpp.h>
 
-struct linux_ebus *ebus_chain = 0;
+struct linux_ebus *ebus_chain = NULL;
 
 /* We are together with pcic.c under CONFIG_PCI. */
 extern unsigned int pcic_pin_to_irq(unsigned int, char *name);
@@ -46,7 +46,7 @@ static struct ebus_device_irq je1_1[] = {
 	{ "SUNW,CS4231",	 0 },
 	{ "parallel",		 0 },
 	{ "se",			 2 },
-	{ 0, 0 }
+	{ NULL, 0 }
 };
 
 /*
@@ -55,7 +55,7 @@ static struct ebus_device_irq je1_1[] = {
  */
 static struct ebus_system_entry ebus_blacklist[] = {
 	{ "SUNW,JavaEngine1", je1_1 },
-	{ 0, 0 }
+	{ NULL, NULL }
 };
 
 static struct ebus_device_irq *ebus_blackp = NULL;
@@ -233,7 +233,7 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 			ebus_alloc(sizeof(struct linux_ebus_child));
 
 		child = dev->children;
-		child->next = 0;
+		child->next = NULL;
 		child->parent = dev;
 		child->bus = dev->bus;
 		fill_ebus_child(node, &regs[0], child);
@@ -243,7 +243,7 @@ void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
 				ebus_alloc(sizeof(struct linux_ebus_child));
 
 			child = child->next;
-			child->next = 0;
+			child->next = NULL;
 			child->parent = dev;
 			child->bus = dev->bus;
 			fill_ebus_child(node, &regs[0], child);
@@ -275,7 +275,7 @@ void __init ebus_init(void)
 		}
 	}
 
-	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, 0);
+	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, NULL);
 	if (!pdev) {
 		return;
 	}
@@ -284,7 +284,7 @@ void __init ebus_init(void)
 
 	ebus_chain = ebus = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));
-	ebus->next = 0;
+	ebus->next = NULL;
 
 	while (ebusnd) {
 
@@ -325,8 +325,8 @@ void __init ebus_init(void)
 				ebus_alloc(sizeof(struct linux_ebus_device));
 
 		dev = ebus->devices;
-		dev->next = 0;
-		dev->children = 0;
+		dev->next = NULL;
+		dev->children = NULL;
 		dev->bus = ebus;
 		fill_ebus_device(nd, dev);
 
@@ -335,8 +335,8 @@ void __init ebus_init(void)
 				ebus_alloc(sizeof(struct linux_ebus_device));
 
 			dev = dev->next;
-			dev->next = 0;
-			dev->children = 0;
+			dev->next = NULL;
+			dev->children = NULL;
 			dev->bus = ebus;
 			fill_ebus_device(nd, dev);
 		}
@@ -353,7 +353,7 @@ void __init ebus_init(void)
 		ebus->next = (struct linux_ebus *)
 			ebus_alloc(sizeof(struct linux_ebus));
 		ebus = ebus->next;
-		ebus->next = 0;
+		ebus->next = NULL;
 		++num_ebus;
 	}
 	if (pdev)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sparc/kernel/ebus.c b/arch/sparc/kernel/ebus.c
new file mode 100644
index 000000000000..1754192c69d0
--- /dev/null
+++ b/arch/sparc/kernel/ebus.c
@@ -0,0 +1,361 @@
+/* $Id: ebus.c,v 1.20 2002/01/05 01:13:43 davem Exp $
+ * ebus.c: PCI to EBus bridge device.
+ *
+ * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
+ *
+ * Adopted for sparc by V. Roganov and G. Raiko.
+ * Fixes for different platforms by Pete Zaitcev.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include <asm/system.h>
+#include <asm/page.h>
+#include <asm/pbm.h>
+#include <asm/ebus.h>
+#include <asm/io.h>
+#include <asm/oplib.h>
+#include <asm/bpp.h>
+
+struct linux_ebus *ebus_chain = 0;
+
+/* We are together with pcic.c under CONFIG_PCI. */
+extern unsigned int pcic_pin_to_irq(unsigned int, char *name);
+
+/*
+ * IRQ Blacklist
+ * Here we list PROMs and systems that are known to supply crap as IRQ numbers.
+ */
+struct ebus_device_irq {
+	char *name;
+	unsigned int pin;
+};
+
+struct ebus_system_entry {
+	char *esname;
+	struct ebus_device_irq *ipt;
+};
+
+static struct ebus_device_irq je1_1[] = {
+	{ "8042",		 3 },
+	{ "SUNW,CS4231",	 0 },
+	{ "parallel",		 0 },
+	{ "se",			 2 },
+	{ 0, 0 }
+};
+
+/*
+ * Gleb's JE1 supplied reasonable pin numbers, but mine did not (OBP 2.32).
+ * Blacklist the sucker... Note that Gleb's system will work.
+ */
+static struct ebus_system_entry ebus_blacklist[] = {
+	{ "SUNW,JavaEngine1", je1_1 },
+	{ 0, 0 }
+};
+
+static struct ebus_device_irq *ebus_blackp = NULL;
+
+/*
+ */
+static inline unsigned long ebus_alloc(size_t size)
+{
+	return (unsigned long)kmalloc(size, GFP_ATOMIC);
+}
+
+/*
+ */
+int __init ebus_blacklist_irq(char *name)
+{
+	struct ebus_device_irq *dp;
+
+	if ((dp = ebus_blackp) != NULL) {
+		for (; dp->name != NULL; dp++) {
+			if (strcmp(name, dp->name) == 0) {
+				return pcic_pin_to_irq(dp->pin, name);
+			}
+		}
+	}
+	return 0;
+}
+
+void __init fill_ebus_child(int node, struct linux_prom_registers *preg,
+				struct linux_ebus_child *dev)
+{
+	int regs[PROMREG_MAX];
+	int irqs[PROMREG_MAX];
+	char lbuf[128];
+	int i, len;
+
+	dev->prom_node = node;
+	prom_getstring(node, "name", lbuf, sizeof(lbuf));
+	strcpy(dev->prom_name, lbuf);
+
+	len = prom_getproperty(node, "reg", (void *)regs, sizeof(regs));
+	if (len == -1) len = 0;
+	dev->num_addrs = len / sizeof(regs[0]);
+
+	for (i = 0; i < dev->num_addrs; i++) {
+		if (regs[i] >= dev->parent->num_addrs) {
+			prom_printf("UGH: property for %s was %d, need < %d\n",
+				    dev->prom_name, len, dev->parent->num_addrs);
+			panic(__FUNCTION__);
+		}
+		dev->resource[i].start = dev->parent->resource[regs[i]].start; /* XXX resource */
+	}
+
+	for (i = 0; i < PROMINTR_MAX; i++)
+		dev->irqs[i] = PCI_IRQ_NONE;
+
+	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_name)) != 0) {
+		dev->num_irqs = 1;
+	} else if ((len = prom_getproperty(node, "interrupts",
+	    (char *)&irqs, sizeof(irqs))) == -1 || len == 0) {
+		dev->num_irqs = 0;
+		dev->irqs[0] = 0;
+		if (dev->parent->num_irqs != 0) {
+			dev->num_irqs = 1;
+			dev->irqs[0] = dev->parent->irqs[0];
+/* P3 */ /* printk("EBUS: dev %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
+		}
+	} else {
+		dev->num_irqs = len / sizeof(irqs[0]);
+		if (irqs[0] == 0 || irqs[0] >= 8) {
+			/*
+			 * XXX Zero is a valid pin number...
+			 * This works as long as Ebus is not wired to INTA#.
+			 */
+			printk("EBUS: %s got bad irq %d from PROM\n",
+			    dev->prom_name, irqs[0]);
+			dev->num_irqs = 0;
+			dev->irqs[0] = 0;
+		} else {
+			dev->irqs[0] = pcic_pin_to_irq(irqs[0], dev->prom_name);
+		}
+	}
+}
+
+void __init fill_ebus_device(int node, struct linux_ebus_device *dev)
+{
+	struct linux_prom_registers regs[PROMREG_MAX];
+	struct linux_ebus_child *child;
+	int irqs[PROMINTR_MAX];
+	char lbuf[128];
+	int i, n, len;
+	unsigned long baseaddr;
+
+	dev->prom_node = node;
+	prom_getstring(node, "name", lbuf, sizeof(lbuf));
+	strcpy(dev->prom_name, lbuf);
+
+	len = prom_getproperty(node, "reg", (void *)regs, sizeof(regs));
+	if (len % sizeof(struct linux_prom_registers)) {
+		prom_printf("UGH: proplen for %s was %d, need multiple of %d\n",
+			    dev->prom_name, len,
+			    (int)sizeof(struct linux_prom_registers));
+		panic(__FUNCTION__);
+	}
+	dev->num_addrs = len / sizeof(struct linux_prom_registers);
+
+	for (i = 0; i < dev->num_addrs; i++) {
+		/*
+		 * XXX Collect JE-1 PROM
+		 * 
+		 * Example - JS-E with 3.11:
+		 *  /ebus
+		 *      regs 
+		 *        0x00000000, 0x0, 0x00000000, 0x0, 0x00000000,
+		 *        0x82000010, 0x0, 0xf0000000, 0x0, 0x01000000,
+		 *        0x82000014, 0x0, 0x38800000, 0x0, 0x00800000,
+		 *      ranges
+		 *        0x00, 0x00000000, 0x02000010, 0x0, 0x0, 0x01000000,
+		 *        0x01, 0x01000000, 0x02000014, 0x0, 0x0, 0x00800000,
+		 *  /ebus/8042
+		 *      regs
+		 *        0x00000001, 0x00300060, 0x00000008,
+		 *        0x00000001, 0x00300060, 0x00000008,
+		 */
+		n = regs[i].which_io;
+		if (n >= 4) {
+			/* XXX This is copied from old JE-1 by Gleb. */
+			n = (regs[i].which_io - 0x10) >> 2;
+		} else {
+			;
+		}
+
+/*
+ * XXX Now as we have regions, why don't we make an on-demand allocation...
+ */
+		dev->resource[i].start = 0;
+		if ((baseaddr = dev->bus->self->resource[n].start +
+		    regs[i].phys_addr) != 0) {
+			/* dev->resource[i].name = dev->prom_name; */
+			if ((baseaddr = (unsigned long) ioremap(baseaddr,
+			    regs[i].reg_size)) == 0) {
+				panic("ebus: unable to remap dev %s",
+				    dev->prom_name);
+			}
+		}
+		dev->resource[i].start = baseaddr;	/* XXX Unaligned */
+	}
+
+	for (i = 0; i < PROMINTR_MAX; i++)
+		dev->irqs[i] = PCI_IRQ_NONE;
+
+	if ((dev->irqs[0] = ebus_blacklist_irq(dev->prom_name)) != 0) {
+		dev->num_irqs = 1;
+	} else if ((len = prom_getproperty(node, "interrupts",
+	    (char *)&irqs, sizeof(irqs))) == -1 || len == 0) {
+		dev->num_irqs = 0;
+		if ((dev->irqs[0] = dev->bus->self->irq) != 0) {
+			 dev->num_irqs = 1;
+/* P3 */ /* printk("EBUS: child %s irq %d from parent\n", dev->prom_name, dev->irqs[0]); */
+		}
+	} else {
+		dev->num_irqs = 1;  /* dev->num_irqs = len / sizeof(irqs[0]); */
+		if (irqs[0] == 0 || irqs[0] >= 8) {
+			/* See above for the parent. XXX */
+			printk("EBUS: %s got bad irq %d from PROM\n",
+			    dev->prom_name, irqs[0]);
+			dev->num_irqs = 0;
+			dev->irqs[0] = 0;
+		} else {
+			dev->irqs[0] = pcic_pin_to_irq(irqs[0], dev->prom_name);
+		}
+	}
+
+	if ((node = prom_getchild(node))) {
+		dev->children = (struct linux_ebus_child *)
+			ebus_alloc(sizeof(struct linux_ebus_child));
+
+		child = dev->children;
+		child->next = 0;
+		child->parent = dev;
+		child->bus = dev->bus;
+		fill_ebus_child(node, &regs[0], child);
+
+		while ((node = prom_getsibling(node)) != 0) {
+			child->next = (struct linux_ebus_child *)
+				ebus_alloc(sizeof(struct linux_ebus_child));
+
+			child = child->next;
+			child->next = 0;
+			child->parent = dev;
+			child->bus = dev->bus;
+			fill_ebus_child(node, &regs[0], child);
+		}
+	}
+}
+
+void __init ebus_init(void)
+{
+	struct linux_prom_pci_registers regs[PROMREG_MAX];
+	struct linux_pbm_info *pbm;
+	struct linux_ebus_device *dev;
+	struct linux_ebus *ebus;
+	struct ebus_system_entry *sp;
+	struct pci_dev *pdev;
+	struct pcidev_cookie *cookie;
+	char lbuf[128];
+	unsigned long addr, *base;
+	unsigned short pci_command;
+	int nd, len, ebusnd;
+	int reg, nreg;
+	int num_ebus = 0;
+
+	prom_getstring(prom_root_node, "name", lbuf, sizeof(lbuf));
+	for (sp = ebus_blacklist; sp->esname != NULL; sp++) {
+		if (strcmp(lbuf, sp->esname) == 0) {
+			ebus_blackp = sp->ipt;
+			break;
+		}
+	}
+
+	pdev = pci_get_device(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_EBUS, 0);
+	if (!pdev) {
+		return;
+	}
+	cookie = pdev->sysdata;
+	ebusnd = cookie->prom_node;
+
+	ebus_chain = ebus = (struct linux_ebus *)
+			ebus_alloc(sizeof(struct linux_ebus));
+	ebus->next = 0;
+
+	while (ebusnd) {
+
+		prom_getstring(ebusnd, "name", lbuf, sizeof(lbuf));
+		ebus->prom_node = ebusnd;
+		strcpy(ebus->prom_name, lbuf);
+		ebus->self = pdev;
+		ebus->parent = pbm = cookie->pbm;
+
+		/* Enable BUS Master. */
+		pci_read_config_word(pdev, PCI_COMMAND, &pci_command);
+		pci_command |= PCI_COMMAND_MASTER;
+		pci_write_config_word(pdev, PCI_COMMAND, pci_command);
+
+		len = prom_getproperty(ebusnd, "reg", (void *)regs,
+				       sizeof(regs));
+		if (len == 0 || len == -1) {
+			prom_printf("%s: can't find reg property\n",
+				    __FUNCTION__);
+			prom_halt();
+		}
+		nreg = len / sizeof(struct linux_prom_pci_registers);
+
+		base = &ebus->self->resource[0].start;
+		for (reg = 0; reg < nreg; reg++) {
+			if (!(regs[reg].which_io & 0x03000000))
+				continue;
+
+			addr = regs[reg].phys_lo;
+			*base++ = addr;
+		}
+
+		nd = prom_getchild(ebusnd);
+		if (!nd)
+			goto next_ebus;
+
+		ebus->devices = (struct linux_ebus_device *)
+				ebus_alloc(sizeof(struct linux_ebus_device));
+
+		dev = ebus->devices;
+		dev->next = 0;
+		dev->children = 0;
+		dev->bus = ebus;
+		fill_ebus_device(nd, dev);
+
+		while ((nd = prom_getsibling(nd)) != 0) {
+			dev->next = (struct linux_ebus_device *)
+				ebus_alloc(sizeof(struct linux_ebus_device));
+
+			dev = dev->next;
+			dev->next = 0;
+			dev->children = 0;
+			dev->bus = ebus;
+			fill_ebus_device(nd, dev);
+		}
+
+	next_ebus:
+		pdev = pci_get_device(PCI_VENDOR_ID_SUN,
+				       PCI_DEVICE_ID_SUN_EBUS, pdev);
+		if (!pdev)
+			break;
+
+		cookie = pdev->sysdata;
+		ebusnd = cookie->prom_node;
+
+		ebus->next = (struct linux_ebus *)
+			ebus_alloc(sizeof(struct linux_ebus));
+		ebus = ebus->next;
+		ebus->next = 0;
+		++num_ebus;
+	}
+	if (pdev)
+		pci_dev_put(pdev);
+}
