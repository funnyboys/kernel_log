commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 36936b613d36..79cd6ccfeac0 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -11,9 +11,9 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/threads.h>
+#include <linux/pgtable.h>
 
 #include <asm/spitfire.h>
-#include <linux/pgtable.h>
 #include <asm/oplib.h>
 #include <asm/setup.h>
 #include <asm/page.h>

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 4401dee30018..36936b613d36 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -13,7 +13,7 @@
 #include <linux/threads.h>
 
 #include <asm/spitfire.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/oplib.h>
 #include <asm/setup.h>
 #include <asm/page.h>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index ef4f18f7a674..4401dee30018 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* cpu.c: Dinky routines to look for the kind of Sparc cpu
  *        we are on.
  *

commit 7d484acb2f90643de7e242fd47e48c3ebb22df3a
Author: Allen Pais <allen.pais@oracle.com>
Date:   Mon Jul 24 11:44:18 2017 +0530

    sparc64: recognize and support sparc M8 cpu type
    
    Recognize SPARC-M8 cpu type, hardware caps and cpu
    distribution map.
    
    Signed-off-by: Allen Pais <allen.pais@oracle.com>
    Signed-off-by: David Aldridge <david.j.aldridge@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 493e023a468a..ef4f18f7a674 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -506,6 +506,12 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "sparc-m7";
 		break;
 
+	case SUN4V_CHIP_SPARC_M8:
+		sparc_cpu_type = "SPARC-M8";
+		sparc_fpu_type = "SPARC-M8 integrated FPU";
+		sparc_pmu_type = "sparc-m8";
+		break;
+
 	case SUN4V_CHIP_SPARC_SN:
 		sparc_cpu_type = "SPARC-SN";
 		sparc_fpu_type = "SPARC-SN integrated FPU";

commit c5b8b5beee1e2aadef0409dba555b7085d57910d
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Tue Apr 19 11:12:54 2016 -0600

    sparc64: recognize and support Sonoma CPU type
    
    Add code to recognize SPARC-Sonoma cpu correctly and update cpu hardware
    caps and cpu distribution map. SPARC-Sonoma is based upon SPARC-M7 core
    along with additional PCI functions added on and is reported by firmware
    as "SPARC-SN".
    
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Acked-by: Allen Pais <allen.pais@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index dfad8b1aea9f..493e023a468a 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -506,6 +506,12 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "sparc-m7";
 		break;
 
+	case SUN4V_CHIP_SPARC_SN:
+		sparc_cpu_type = "SPARC-SN";
+		sparc_fpu_type = "SPARC-SN integrated FPU";
+		sparc_pmu_type = "sparc-sn";
+		break;
+
 	case SUN4V_CHIP_SPARC64X:
 		sparc_cpu_type = "SPARC64-X";
 		sparc_fpu_type = "SPARC64-X integrated FPU";

commit cadbb58039f7cab1def9c931012ab04c953a6997
Author: Allen Pais <allen.pais@oracle.com>
Date:   Mon Sep 8 11:48:53 2014 +0530

    sparc64: correctly recognise M6 and M7 cpu type
    
    The following patch adds support for correctly
    recognising M6 and M7 cpu type.
    
    Signed-off-by: Allen Pais <allen.pais@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 82a3a71c451e..dfad8b1aea9f 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -494,6 +494,18 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "niagara5";
 		break;
 
+	case SUN4V_CHIP_SPARC_M6:
+		sparc_cpu_type = "SPARC-M6";
+		sparc_fpu_type = "SPARC-M6 integrated FPU";
+		sparc_pmu_type = "sparc-m6";
+		break;
+
+	case SUN4V_CHIP_SPARC_M7:
+		sparc_cpu_type = "SPARC-M7";
+		sparc_fpu_type = "SPARC-M7 integrated FPU";
+		sparc_pmu_type = "sparc-m7";
+		break;
+
 	case SUN4V_CHIP_SPARC64X:
 		sparc_cpu_type = "SPARC64-X";
 		sparc_fpu_type = "SPARC64-X integrated FPU";

commit fd250a664d35d6eb3e09694419c2ee16f23d536a
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Apr 21 21:39:30 2014 +0200

    sparc: fix sparse warnings in cpu.c
    
    Fix following sparc32 warning:
    cpu.c:430:29: warning: symbol 'cpuinfo_op' was not declared. Should it be static?
    
    Fix following sparc64 warnings:
    cpu.c:364:14: warning: symbol 'dcache_parity_tl1_occurred' was not declared. Should it be static?
    cpu.c:365:14: warning: symbol 'icache_parity_tl1_occurred' was not declared. Should it be static?
    
    Rearrange asm/cpu.h to share more stuff between sparc32 and sparc64.
    Added missing include to cpu.c of kernel.h
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 5c5125895db8..82a3a71c451e 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -22,6 +22,7 @@
 #include <asm/cpudata.h>
 
 #include "kernel.h"
+#include "entry.h"
 
 DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
 EXPORT_PER_CPU_SYMBOL(__cpu_data);

commit 76950e6e54ccfc98a25b501dbb1bc879cce1aa29
Author: Allen Pais <allen.pais@oracle.com>
Date:   Tue Mar 5 23:47:59 2013 +0000

    sparc64: correctly recognize SPARC64-X chips
    
    The following patch adds support for correctly
    recognizing SPARC-X chips.
    
    cpu : Unknown SUN4V CPU
    fpu : Unknown SUN4V FPU
    pmu : Unknown SUN4V PMU
    
    Signed-off-by: Katayama Yoshihiro <kata1@jp.fujitsu.com>
    Signed-off-by: Allen Pais <allen.pais@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index a6c94a2bf9d4..5c5125895db8 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -493,6 +493,12 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "niagara5";
 		break;
 
+	case SUN4V_CHIP_SPARC64X:
+		sparc_cpu_type = "SPARC64-X";
+		sparc_fpu_type = "SPARC64-X integrated FPU";
+		sparc_pmu_type = "sparc64-x";
+		break;
+
 	default:
 		printk(KERN_WARNING "CPU: Unknown sun4v cpu type [%s]\n",
 		       prom_cpu_compatible);

commit d87d8c11f347e743f0223d16c8ec57ef7e0274b2
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri May 25 21:20:11 2012 +0000

    sparc32: handle leon in cpu.c
    
    A few hardcoded constant were replaced by symbolic
    versions to improve readability
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Daniel Hellstrom <daniel@gaisler.com>
    Cc: Konrad Eisele <konrad@gaisler.com>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 2d1819641769..a6c94a2bf9d4 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -121,7 +121,7 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 		FPU(-1, NULL)
 	}
 },{
-	4,
+	PSR_IMPL_TI,
 	.cpu_info = {
 		CPU(0, "Texas Instruments, Inc. - SuperSparc-(II)"),
 		/* SparcClassic  --  borned STP1010TAB-50*/
@@ -191,7 +191,7 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 		FPU(-1, NULL)
 	}
 },{
-	0xF,		/* Aeroflex Gaisler */
+	PSR_IMPL_LEON,		/* Aeroflex Gaisler */
 	.cpu_info = {
 		CPU(3, "LEON"),
 		CPU(-1, NULL)
@@ -440,16 +440,16 @@ static int __init cpu_type_probe(void)
 	int psr_impl, psr_vers, fpu_vers;
 	int psr;
 
-	psr_impl = ((get_psr() >> 28) & 0xf);
-	psr_vers = ((get_psr() >> 24) & 0xf);
+	psr_impl = ((get_psr() >> PSR_IMPL_SHIFT) & PSR_IMPL_SHIFTED_MASK);
+	psr_vers = ((get_psr() >> PSR_VERS_SHIFT) & PSR_VERS_SHIFTED_MASK);
 
 	psr = get_psr();
 	put_psr(psr | PSR_EF);
-#ifdef CONFIG_SPARC_LEON
-	fpu_vers = get_psr() & PSR_EF ? ((get_fsr() >> 17) & 0x7) : 7;
-#else
-	fpu_vers = ((get_fsr() >> 17) & 0x7);
-#endif
+
+	if (psr_impl == PSR_IMPL_LEON)
+		fpu_vers = get_psr() & PSR_EF ? ((get_fsr() >> 17) & 0x7) : 7;
+	else
+		fpu_vers = ((get_fsr() >> 17) & 0x7);
 
 	put_psr(psr);
 

commit 066bcaca51946c8305e3d637a795e8ccf8dbd3cf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 13:18:16 2011 -0400

    sparc: move symbol exporters to use export.h not module.h
    
    Many of the core sparc kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index ba9b1cec4e6b..2d1819641769 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -6,7 +6,7 @@
 
 #include <linux/seq_file.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/threads.h>

commit 08cefa9fa7e5b3ddaefb8b7bfa408d148429c08d
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Sep 11 10:42:20 2011 -0700

    sparc64: Future proof Niagara cpu detection.
    
    Recognize T4 and T5 chips.  Treating them both as "T2 plus other
    stuff" should be extremely safe and make sure distributions will work
    when those chips actually ship to customers.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 9810fd881058..ba9b1cec4e6b 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -481,6 +481,18 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "niagara3";
 		break;
 
+	case SUN4V_CHIP_NIAGARA4:
+		sparc_cpu_type = "UltraSparc T4 (Niagara4)";
+		sparc_fpu_type = "UltraSparc T4 integrated FPU";
+		sparc_pmu_type = "niagara4";
+		break;
+
+	case SUN4V_CHIP_NIAGARA5:
+		sparc_cpu_type = "UltraSparc T5 (Niagara5)";
+		sparc_fpu_type = "UltraSparc T5 integrated FPU";
+		sparc_pmu_type = "niagara5";
+		break;
+
 	default:
 		printk(KERN_WARNING "CPU: Unknown sun4v cpu type [%s]\n",
 		       prom_cpu_compatible);

commit ac85fe8b21248054851e05bfaa352562e5b06dd3
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 28 23:31:26 2011 -0700

    sparc: Sanitize cpu feature detection and reporting.
    
    Instead of evaluating the cpu features for ELF_HWCAP every exec,
    calculate it once at boot time.
    
    Add AV_SPARC_* capability flag bits, compatible with what Solaris
    reports to applications.
    
    Report these capabilities once in the kernel log, and also via
    /proc/cpuinfo in a new "cpucaps" entry.
    
    If available, fetch the cpu features from the machine description
    'hwcap-list' property of the 'cpu' node.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 17cf290dc2bc..9810fd881058 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -396,6 +396,7 @@ static int show_cpuinfo(struct seq_file *m, void *__unused)
 		   , cpu_data(0).clock_tick
 #endif
 		);
+	cpucap_info(m);
 #ifdef CONFIG_SMP
 	smp_bogo(m);
 #endif

commit 4ba991d3eb379fbaa22049e7002341e97a673685
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jul 27 21:06:16 2011 -0700

    sparc: Detect and handle UltraSPARC-T3 cpu types.
    
    The cpu compatible string we look for is "SPARC-T3".
    
    As far as memset/memcpy optimizations go, we treat this chip the same
    as Niagara-T2/T2+.  Use cache initializing stores for memset, and use
    perfetch, FPU block loads, cache initializing stores, and block stores
    for copies.
    
    We use the Niagara-T2 perf support, since T3 is a close relative in
    this regard.  Later we'll add support for the new events T3 can
    report, plus enable T3's new "sample" mode.
    
    For now I haven't added any new ELF hwcap flags.  We probably need
    to add a couple, for example:
    
    T2 and T3 both support the population count instruction in hardware.
    
    T3 supports VIS3 instructions, including support (finally) for
    partitioned shift.  One can also now move directly between float
    and integer registers.
    
    T3 supports instructions meant to help with Galois Field and other HPC
    calculations, such as XOR multiply.  Also there are "OP and negate"
    instructions, for example "fnmul" which is multiply-and-negate.
    
    T3 recognizes the transactional memory opcodes, however since
    transactional memory isn't supported: 1) 'commit' behaves as a NOP and
    2) 'chkpt' always branches 3) 'rdcps' returns all zeros and 4) 'wrcps'
    behaves as a NOP.
    
    So we'll need about 3 new elf capability flags in the end to represent
    all of these things.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 70f035c86c03..17cf290dc2bc 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -474,6 +474,12 @@ static void __init sun4v_cpu_probe(void)
 		sparc_pmu_type = "niagara2";
 		break;
 
+	case SUN4V_CHIP_NIAGARA3:
+		sparc_cpu_type = "UltraSparc T3 (Niagara3)";
+		sparc_fpu_type = "UltraSparc T3 integrated FPU";
+		sparc_pmu_type = "niagara3";
+		break;
+
 	default:
 		printk(KERN_WARNING "CPU: Unknown sun4v cpu type [%s]\n",
 		       prom_cpu_compatible);

commit facfddef2c76110b8e321921f7e54518c3dd1579
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jul 27 20:25:57 2011 -0700

    sparc: Don't leave sparc_pmu_type NULL on sun4v.
    
    Otherwise we'll crash in the sparc perf init code.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 138dbbc8dc84..70f035c86c03 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -479,6 +479,7 @@ static void __init sun4v_cpu_probe(void)
 		       prom_cpu_compatible);
 		sparc_cpu_type = "Unknown SUN4V CPU";
 		sparc_fpu_type = "Unknown SUN4V FPU";
+		sparc_pmu_type = "Unknown SUN4V PMU";
 		break;
 	}
 }

commit 9c2853af1fcbe01a123d666aa373e99119148ee6
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Apr 21 15:46:21 2011 -0700

    sparc32: probe for cpu info only during startup
    
    We did a cpu_probe() call each time a CPU got online - which
    only effect was to save latest CPU/FPU info for use by show_cpuinfo().
    Use same setup as for sparc64 where we probe for this info during startup,
    and only once.
    
    This allowed us to annotate a few functions __init which again
    fixed the following section mismatch warnings:
    
    WARNING: vmlinux.o(.text+0x65f0): Section mismatch in reference from the function set_cpu_and_fpu() to the (unknown reference) .init.rodata:(unknown)
    WARNING: vmlinux.o(.text+0x65f8): Section mismatch in reference from the function set_cpu_and_fpu() to the (unknown reference) .init.rodata:(unknown)
    WARNING: vmlinux.o(.text+0x664c): Section mismatch in reference from the function set_cpu_and_fpu() to the variable .init.rodata:manufacturer_info
    WARNING: vmlinux.o(.text+0x6650): Section mismatch in reference from the function set_cpu_and_fpu() to the variable .init.rodata:manufacturer_info
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index c3483c71aa04..138dbbc8dc84 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -258,7 +258,7 @@ static const char *sparc_fpu_type;
 const char *sparc_pmu_type;
 
 
-static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
+static void __init set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 {
 	const struct manufacturer_info *manuf;
 	int i;
@@ -434,7 +434,7 @@ const struct seq_operations cpuinfo_op = {
 };
 
 #ifdef CONFIG_SPARC32
-void __cpuinit cpu_probe(void)
+static int __init cpu_type_probe(void)
 {
 	int psr_impl, psr_vers, fpu_vers;
 	int psr;
@@ -453,8 +453,12 @@ void __cpuinit cpu_probe(void)
 	put_psr(psr);
 
 	set_cpu_and_fpu(psr_impl, psr_vers, fpu_vers);
+
+	return 0;
 }
-#else
+#endif /* CONFIG_SPARC32 */
+
+#ifdef CONFIG_SPARC64
 static void __init sun4v_cpu_probe(void)
 {
 	switch (sun4v_chip_type) {
@@ -495,6 +499,6 @@ static int __init cpu_type_probe(void)
 	}
 	return 0;
 }
+#endif /* CONFIG_SPARC64 */
 
 early_initcall(cpu_type_probe);
-#endif

commit cb1b8209815594613650772eeb889c170107dad4
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Apr 21 15:45:45 2011 -0700

    sparc: consolidate show_cpuinfo in cpu.c
    
    We have all the cpu related info in cpu.c - so move
    the remaining functions to support /proc/cpuinfo to this file.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 7925c54f4133..c3483c71aa04 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -4,6 +4,7 @@
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
  */
 
+#include <linux/seq_file.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -11,7 +12,9 @@
 #include <linux/threads.h>
 
 #include <asm/spitfire.h>
+#include <asm/pgtable.h>
 #include <asm/oplib.h>
+#include <asm/setup.h>
 #include <asm/page.h>
 #include <asm/head.h>
 #include <asm/psr.h>
@@ -23,6 +26,9 @@
 DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
 EXPORT_PER_CPU_SYMBOL(__cpu_data);
 
+int ncpus_probed;
+unsigned int fsr_storage;
+
 struct cpu_info {
 	int psr_vers;
 	const char *name;
@@ -247,11 +253,10 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
  * machine type value into consideration too.  I will fix this.
  */
 
-const char *sparc_cpu_type;
-const char *sparc_fpu_type;
+static const char *sparc_cpu_type;
+static const char *sparc_fpu_type;
 const char *sparc_pmu_type;
 
-unsigned int fsr_storage;
 
 static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 {
@@ -312,6 +317,122 @@ static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 		sparc_pmu_type = "Unknown PMU";
 }
 
+#ifdef CONFIG_SPARC32
+static int show_cpuinfo(struct seq_file *m, void *__unused)
+{
+	seq_printf(m,
+		   "cpu\t\t: %s\n"
+		   "fpu\t\t: %s\n"
+		   "promlib\t\t: Version %d Revision %d\n"
+		   "prom\t\t: %d.%d\n"
+		   "type\t\t: %s\n"
+		   "ncpus probed\t: %d\n"
+		   "ncpus active\t: %d\n"
+#ifndef CONFIG_SMP
+		   "CPU0Bogo\t: %lu.%02lu\n"
+		   "CPU0ClkTck\t: %ld\n"
+#endif
+		   ,
+		   sparc_cpu_type,
+		   sparc_fpu_type ,
+		   romvec->pv_romvers,
+		   prom_rev,
+		   romvec->pv_printrev >> 16,
+		   romvec->pv_printrev & 0xffff,
+		   &cputypval[0],
+		   ncpus_probed,
+		   num_online_cpus()
+#ifndef CONFIG_SMP
+		   , cpu_data(0).udelay_val/(500000/HZ),
+		   (cpu_data(0).udelay_val/(5000/HZ)) % 100,
+		   cpu_data(0).clock_tick
+#endif
+		);
+
+#ifdef CONFIG_SMP
+	smp_bogo(m);
+#endif
+	mmu_info(m);
+#ifdef CONFIG_SMP
+	smp_info(m);
+#endif
+	return 0;
+}
+#endif /* CONFIG_SPARC32 */
+
+#ifdef CONFIG_SPARC64
+unsigned int dcache_parity_tl1_occurred;
+unsigned int icache_parity_tl1_occurred;
+
+
+static int show_cpuinfo(struct seq_file *m, void *__unused)
+{
+	seq_printf(m,
+		   "cpu\t\t: %s\n"
+		   "fpu\t\t: %s\n"
+		   "pmu\t\t: %s\n"
+		   "prom\t\t: %s\n"
+		   "type\t\t: %s\n"
+		   "ncpus probed\t: %d\n"
+		   "ncpus active\t: %d\n"
+		   "D$ parity tl1\t: %u\n"
+		   "I$ parity tl1\t: %u\n"
+#ifndef CONFIG_SMP
+		   "Cpu0ClkTck\t: %016lx\n"
+#endif
+		   ,
+		   sparc_cpu_type,
+		   sparc_fpu_type,
+		   sparc_pmu_type,
+		   prom_version,
+		   ((tlb_type == hypervisor) ?
+		    "sun4v" :
+		    "sun4u"),
+		   ncpus_probed,
+		   num_online_cpus(),
+		   dcache_parity_tl1_occurred,
+		   icache_parity_tl1_occurred
+#ifndef CONFIG_SMP
+		   , cpu_data(0).clock_tick
+#endif
+		);
+#ifdef CONFIG_SMP
+	smp_bogo(m);
+#endif
+	mmu_info(m);
+#ifdef CONFIG_SMP
+	smp_info(m);
+#endif
+	return 0;
+}
+#endif /* CONFIG_SPARC64 */
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	/* The pointer we are returning is arbitrary,
+	 * it just has to be non-NULL and not IS_ERR
+	 * in the success case.
+	 */
+	return *pos == 0 ? &c_start : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return c_start(m, pos);
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+const struct seq_operations cpuinfo_op = {
+	.start =c_start,
+	.next =	c_next,
+	.stop =	c_stop,
+	.show =	show_cpuinfo,
+};
+
 #ifdef CONFIG_SPARC32
 void __cpuinit cpu_probe(void)
 {

commit 2666e476022c678b3758e753b20c22ca598dc73f
Author: Daniel Hellstrom <daniel@gaisler.com>
Date:   Wed Jan 26 06:37:05 2011 +0000

    sparc32/leon: FPU-FSR only available when FPU present
    
    Signed-off-by: Daniel Hellstrom <daniel@gaisler.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 0dc714fa23d8..7925c54f4133 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -324,7 +324,7 @@ void __cpuinit cpu_probe(void)
 	psr = get_psr();
 	put_psr(psr | PSR_EF);
 #ifdef CONFIG_SPARC_LEON
-	fpu_vers = 7;
+	fpu_vers = get_psr() & PSR_EF ? ((get_fsr() >> 17) & 0x7) : 7;
 #else
 	fpu_vers = ((get_fsr() >> 17) & 0x7);
 #endif

commit 5edddaab1d5d6143c23fef119a24ea768915681a
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jan 9 15:36:46 2011 -0800

    sparc64: Fix bootup regression due to perf init ordering.
    
    Commit 004417a6d468e24399e383645c068b498eed84ad
    ("perf, arch: Cleanup perf-pmu init vs lockup-detector")
    move the perf events init to be an early_initcall.
    
    But this won't work properly unless the dependencies for
    this code initialize beforehand.
    
    Fix it by making cpu_type_probe and pcr_arch_init be
    an early_initcall as well.
    
    Reported-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index e447938d39cf..0dc714fa23d8 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -375,5 +375,5 @@ static int __init cpu_type_probe(void)
 	return 0;
 }
 
-arch_initcall(cpu_type_probe);
+early_initcall(cpu_type_probe);
 #endif

commit 3560f788fe207de25c96ea547c56fc8a750e37a5
Author: Kristoffer Glembo <kristoffer@gaisler.com>
Date:   Wed Dec 2 04:30:20 2009 +0000

    sparc, leon: Added Aeroflex Gaisler entry in manufacturer_info structure
    
    Signed-off-by: Kristoffer Glembo <kristoffer@gaisler.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 1446df90ef85..e447938d39cf 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -184,6 +184,17 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 		FPU(3, "Fujitsu or Weitek on-chip FPU"),
 		FPU(-1, NULL)
 	}
+},{
+	0xF,		/* Aeroflex Gaisler */
+	.cpu_info = {
+		CPU(3, "LEON"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(2, "GRFPU"),
+		FPU(3, "GRFPU-Lite"),
+		FPU(-1, NULL)
+	}
 },{
 	0x17,
 	.cpu_info = {

commit 0fd7ef1fe0e6e70c7851ce65a2eb8a8d3f49147e
Author: Konrad Eisele <konrad@gaisler.com>
Date:   Mon Aug 17 00:13:31 2009 +0000

    sparc,leon: Introduce the sparc-leon CPU type.
    
    Add sparc_leon enum, M_LEON|M_LEON3_SOC machine. Add compilation of
    leon.c in mm and kernel
    if CONFIG_SPARC_LEON is defined. Add sparc_leon dependent
    initialization to switch statements + head.S.
    
    Signed-off-by: Konrad Eisele <konrad@gaisler.com>
    Reviewed-by:   Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index d85c3dc4953a..1446df90ef85 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -312,7 +312,12 @@ void __cpuinit cpu_probe(void)
 
 	psr = get_psr();
 	put_psr(psr | PSR_EF);
+#ifdef CONFIG_SPARC_LEON
+	fpu_vers = 7;
+#else
 	fpu_vers = ((get_fsr() >> 17) & 0x7);
+#endif
+
 	put_psr(psr);
 
 	set_cpu_and_fpu(psr_impl, psr_vers, fpu_vers);

commit c3cf5e8cc56d272f828a66610bb78bbb727b2ce1
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 21 23:16:40 2009 -0800

    sparc: Probe PMU type and record in sparc_pmu_type.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 32d32b4824f5..d85c3dc4953a 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -26,6 +26,7 @@ EXPORT_PER_CPU_SYMBOL(__cpu_data);
 struct cpu_info {
 	int psr_vers;
 	const char *name;
+	const char *pmu_name;
 };
 
 struct fpu_info {
@@ -45,6 +46,9 @@ struct manufacturer_info {
 #define CPU(ver, _name) \
 { .psr_vers = ver, .name = _name }
 
+#define CPU_PMU(ver, _name, _pmu_name)	\
+{ .psr_vers = ver, .name = _name, .pmu_name = _pmu_name }
+
 #define FPU(ver, _name) \
 { .fp_vers = ver, .name = _name }
 
@@ -183,10 +187,10 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 },{
 	0x17,
 	.cpu_info = {
-		CPU(0x10, "TI UltraSparc I   (SpitFire)"),
-		CPU(0x11, "TI UltraSparc II  (BlackBird)"),
-		CPU(0x12, "TI UltraSparc IIi (Sabre)"),
-		CPU(0x13, "TI UltraSparc IIe (Hummingbird)"),
+		CPU_PMU(0x10, "TI UltraSparc I   (SpitFire)", "ultra12"),
+		CPU_PMU(0x11, "TI UltraSparc II  (BlackBird)", "ultra12"),
+		CPU_PMU(0x12, "TI UltraSparc IIi (Sabre)", "ultra12"),
+		CPU_PMU(0x13, "TI UltraSparc IIe (Hummingbird)", "ultra12"),
 		CPU(-1, NULL)
 	},
 	.fpu_info = {
@@ -199,7 +203,7 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 },{
 	0x22,
 	.cpu_info = {
-		CPU(0x10, "TI UltraSparc I   (SpitFire)"),
+		CPU_PMU(0x10, "TI UltraSparc I   (SpitFire)", "ultra12"),
 		CPU(-1, NULL)
 	},
 	.fpu_info = {
@@ -209,12 +213,12 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 },{
 	0x3e,
 	.cpu_info = {
-		CPU(0x14, "TI UltraSparc III (Cheetah)"),
-		CPU(0x15, "TI UltraSparc III+ (Cheetah+)"),
-		CPU(0x16, "TI UltraSparc IIIi (Jalapeno)"),
-		CPU(0x18, "TI UltraSparc IV (Jaguar)"),
-		CPU(0x19, "TI UltraSparc IV+ (Panther)"),
-		CPU(0x22, "TI UltraSparc IIIi+ (Serrano)"),
+		CPU_PMU(0x14, "TI UltraSparc III (Cheetah)", "ultra3"),
+		CPU_PMU(0x15, "TI UltraSparc III+ (Cheetah+)", "ultra3+"),
+		CPU_PMU(0x16, "TI UltraSparc IIIi (Jalapeno)", "ultra3i"),
+		CPU_PMU(0x18, "TI UltraSparc IV (Jaguar)", "ultra3+"),
+		CPU_PMU(0x19, "TI UltraSparc IV+ (Panther)", "ultra4+"),
+		CPU_PMU(0x22, "TI UltraSparc IIIi+ (Serrano)", "ultra3i"),
 		CPU(-1, NULL)
 	},
 	.fpu_info = {
@@ -234,6 +238,7 @@ static const struct manufacturer_info __initconst manufacturer_info[] = {
 
 const char *sparc_cpu_type;
 const char *sparc_fpu_type;
+const char *sparc_pmu_type;
 
 unsigned int fsr_storage;
 
@@ -244,6 +249,7 @@ static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 
 	sparc_cpu_type = NULL;
 	sparc_fpu_type = NULL;
+	sparc_pmu_type = NULL;
 	manuf = NULL;
 
 	for (i = 0; i < ARRAY_SIZE(manufacturer_info); i++)
@@ -263,6 +269,7 @@ static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 		{
 			if (cpu->psr_vers == psr_vers) {
 				sparc_cpu_type = cpu->name;
+				sparc_pmu_type = cpu->pmu_name;
 				sparc_fpu_type = "No FPU";
 				break;
 			}
@@ -290,6 +297,8 @@ static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 		       psr_impl, fpu_vers);
 		sparc_fpu_type = "Unknown FPU";
 	}
+	if (sparc_pmu_type == NULL)
+		sparc_pmu_type = "Unknown PMU";
 }
 
 #ifdef CONFIG_SPARC32
@@ -315,11 +324,13 @@ static void __init sun4v_cpu_probe(void)
 	case SUN4V_CHIP_NIAGARA1:
 		sparc_cpu_type = "UltraSparc T1 (Niagara)";
 		sparc_fpu_type = "UltraSparc T1 integrated FPU";
+		sparc_pmu_type = "niagara";
 		break;
 
 	case SUN4V_CHIP_NIAGARA2:
 		sparc_cpu_type = "UltraSparc T2 (Niagara2)";
 		sparc_fpu_type = "UltraSparc T2 integrated FPU";
+		sparc_pmu_type = "niagara2";
 		break;
 
 	default:

commit c275ce44929402664902cbb09d4f054b315623d7
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jan 17 23:10:35 2009 -0800

    sparc64: fix readout of cpu/fpu type
    
    Meelis reported that on his box /proc/cpuinfo started
    to reported "Unknow CPU" and the same did the boot messages.
    
    It was a stupid bug I introduced when merging
    cpu.c for 32 and 64 bit.
    
    The code did an array reference where it had to search
    for the right index.
    
    Reported-by: Meelis Roos <mroos@linux.ee>
    Tested-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index f0b825505da5..32d32b4824f5 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -239,14 +239,26 @@ unsigned int fsr_storage;
 
 static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 {
+	const struct manufacturer_info *manuf;
+	int i;
+
 	sparc_cpu_type = NULL;
 	sparc_fpu_type = NULL;
-	if (psr_impl < ARRAY_SIZE(manufacturer_info))
+	manuf = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(manufacturer_info); i++)
+	{
+		if (psr_impl == manufacturer_info[i].psr_impl) {
+			manuf = &manufacturer_info[i];
+			break;
+		}
+	}
+	if (manuf != NULL)
 	{
 		const struct cpu_info *cpu;
 		const struct fpu_info *fpu;
 
-		cpu = &manufacturer_info[psr_impl].cpu_info[0];
+		cpu = &manuf->cpu_info[0];
 		while (cpu->psr_vers != -1)
 		{
 			if (cpu->psr_vers == psr_vers) {
@@ -256,7 +268,7 @@ static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
 			}
 			cpu++;
 		}
-		fpu =  &manufacturer_info[psr_impl].fpu_info[0];
+		fpu =  &manuf->fpu_info[0];
 		while (fpu->fp_vers != -1)
 		{
 			if (fpu->fp_vers == fpu_vers) {

commit 6943f3da3e64edd95ee2d33abc0a642357746ba6
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jan 8 16:58:05 2009 -0800

    sparc: move EXPORT_SYMBOL to the symbols definition
    
    Move all applicable EXPORT_SYMBOL()s to the file where the respective
    symbol is defined.
    
    Removed all the includes that are no longer needed in sparc_ksyms_32.c
    
    Comment all remaining EXPORT_SYMBOL()s in sparc_ksyms_32.c
    
    Two symbols are shared with sparc64 thus the exports were removed from
    the sparc_ksyms_64.c too, along with the include their ommission made
    redundant.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    
    Additions by Julian Calaby:
    * Moved EXPORT_SYMBOL()s for prom functions to their rightful places.
    * Made some minor cleanups to the includes and comments of sparc_ksyms_32.c
    * Made another subtraction from sparc_ksyms_64.c
    * Updated and tidied commit message.
    * Rebased patch over sparc-2.6.git HEAD.
    * Ensured that all modified files have the correct includes.
    
    Signed-off-by: Julian Calaby <julian.calaby@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 6c2da2420f76..f0b825505da5 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -5,6 +5,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/threads.h>
@@ -20,6 +21,7 @@
 #include "kernel.h"
 
 DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
+EXPORT_PER_CPU_SYMBOL(__cpu_data);
 
 struct cpu_info {
 	int psr_vers;

commit d34dd82905fb8e1117b67ab6c32989f88cfa0ba8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Dec 7 00:04:30 2008 -0800

    sparc: unify kernel/cpu
    
    o use cpu_32.c as base
    o move all sparc64 definitions to the common cpu.c
    o use ifdef for the parts that differs and use cpu_32 as base
    o spitfire.h required a CONFIG_SPARC64 guard to fix build on 32 bit
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
new file mode 100644
index 000000000000..6c2da2420f76
--- /dev/null
+++ b/arch/sparc/kernel/cpu.c
@@ -0,0 +1,338 @@
+/* cpu.c: Dinky routines to look for the kind of Sparc cpu
+ *        we are on.
+ *
+ * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+
+#include <asm/spitfire.h>
+#include <asm/oplib.h>
+#include <asm/page.h>
+#include <asm/head.h>
+#include <asm/psr.h>
+#include <asm/mbus.h>
+#include <asm/cpudata.h>
+
+#include "kernel.h"
+
+DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
+
+struct cpu_info {
+	int psr_vers;
+	const char *name;
+};
+
+struct fpu_info {
+	int fp_vers;
+	const char *name;
+};
+
+#define NOCPU 8
+#define NOFPU 8
+
+struct manufacturer_info {
+	int psr_impl;
+	struct cpu_info cpu_info[NOCPU];
+	struct fpu_info fpu_info[NOFPU];
+};
+
+#define CPU(ver, _name) \
+{ .psr_vers = ver, .name = _name }
+
+#define FPU(ver, _name) \
+{ .fp_vers = ver, .name = _name }
+
+static const struct manufacturer_info __initconst manufacturer_info[] = {
+{
+	0,
+	/* Sun4/100, 4/200, SLC */
+	.cpu_info = {
+		CPU(0, "Fujitsu  MB86900/1A or LSI L64831 SparcKIT-40"),
+		/* borned STP1012PGA */
+		CPU(4,  "Fujitsu  MB86904"),
+		CPU(5, "Fujitsu TurboSparc MB86907"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0, "Fujitsu MB86910 or Weitek WTL1164/5"),
+		FPU(1, "Fujitsu MB86911 or Weitek WTL1164/5 or LSI L64831"),
+		FPU(2, "LSI Logic L64802 or Texas Instruments ACT8847"),
+		/* SparcStation SLC, SparcStation1 */
+		FPU(3, "Weitek WTL3170/2"),
+		/* SPARCstation-5 */
+		FPU(4, "Lsi Logic/Meiko L64804 or compatible"),
+		FPU(-1, NULL)
+	}
+},{
+	1,
+	.cpu_info = {
+		/* SparcStation2, SparcServer 490 & 690 */
+		CPU(0, "LSI Logic Corporation - L64811"),
+		/* SparcStation2 */
+		CPU(1, "Cypress/ROSS CY7C601"),
+		/* Embedded controller */
+		CPU(3, "Cypress/ROSS CY7C611"),
+		/* Ross Technologies HyperSparc */
+		CPU(0xf, "ROSS HyperSparc RT620"),
+		CPU(0xe, "ROSS HyperSparc RT625 or RT626"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0, "ROSS HyperSparc combined IU/FPU"),
+		FPU(1, "Lsi Logic L64814"),
+		FPU(2, "Texas Instruments TMS390-C602A"),
+		FPU(3, "Cypress CY7C602 FPU"),
+		FPU(-1, NULL)
+	}
+},{
+	2,
+	.cpu_info = {
+		/* ECL Implementation, CRAY S-MP Supercomputer... AIEEE! */
+		/* Someone please write the code to support this beast! ;) */
+		CPU(0, "Bipolar Integrated Technology - B5010"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(-1, NULL)
+	}
+},{
+	3,
+	.cpu_info = {
+		CPU(0, "LSI Logic Corporation - unknown-type"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(-1, NULL)
+	}
+},{
+	4,
+	.cpu_info = {
+		CPU(0, "Texas Instruments, Inc. - SuperSparc-(II)"),
+		/* SparcClassic  --  borned STP1010TAB-50*/
+		CPU(1, "Texas Instruments, Inc. - MicroSparc"),
+		CPU(2, "Texas Instruments, Inc. - MicroSparc II"),
+		CPU(3, "Texas Instruments, Inc. - SuperSparc 51"),
+		CPU(4, "Texas Instruments, Inc. - SuperSparc 61"),
+		CPU(5, "Texas Instruments, Inc. - unknown"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		/* SuperSparc 50 module */
+		FPU(0, "SuperSparc on-chip FPU"),
+		/* SparcClassic */
+		FPU(4, "TI MicroSparc on chip FPU"),
+		FPU(-1, NULL)
+	}
+},{
+	5,
+	.cpu_info = {
+		CPU(0, "Matsushita - MN10501"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0, "Matsushita MN10501"),
+		FPU(-1, NULL)
+	}
+},{
+	6,
+	.cpu_info = {
+		CPU(0, "Philips Corporation - unknown"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(-1, NULL)
+	}
+},{
+	7,
+	.cpu_info = {
+		CPU(0, "Harvest VLSI Design Center, Inc. - unknown"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(-1, NULL)
+	}
+},{
+	8,
+	.cpu_info = {
+		CPU(0, "Systems and Processes Engineering Corporation (SPEC)"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(-1, NULL)
+	}
+},{
+	9,
+	.cpu_info = {
+		/* Gallium arsenide 200MHz, BOOOOGOOOOMIPS!!! */
+		CPU(0, "Fujitsu or Weitek Power-UP"),
+		CPU(1, "Fujitsu or Weitek Power-UP"),
+		CPU(2, "Fujitsu or Weitek Power-UP"),
+		CPU(3, "Fujitsu or Weitek Power-UP"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(3, "Fujitsu or Weitek on-chip FPU"),
+		FPU(-1, NULL)
+	}
+},{
+	0x17,
+	.cpu_info = {
+		CPU(0x10, "TI UltraSparc I   (SpitFire)"),
+		CPU(0x11, "TI UltraSparc II  (BlackBird)"),
+		CPU(0x12, "TI UltraSparc IIi (Sabre)"),
+		CPU(0x13, "TI UltraSparc IIe (Hummingbird)"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0x10, "UltraSparc I integrated FPU"),
+		FPU(0x11, "UltraSparc II integrated FPU"),
+		FPU(0x12, "UltraSparc IIi integrated FPU"),
+		FPU(0x13, "UltraSparc IIe integrated FPU"),
+		FPU(-1, NULL)
+	}
+},{
+	0x22,
+	.cpu_info = {
+		CPU(0x10, "TI UltraSparc I   (SpitFire)"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0x10, "UltraSparc I integrated FPU"),
+		FPU(-1, NULL)
+	}
+},{
+	0x3e,
+	.cpu_info = {
+		CPU(0x14, "TI UltraSparc III (Cheetah)"),
+		CPU(0x15, "TI UltraSparc III+ (Cheetah+)"),
+		CPU(0x16, "TI UltraSparc IIIi (Jalapeno)"),
+		CPU(0x18, "TI UltraSparc IV (Jaguar)"),
+		CPU(0x19, "TI UltraSparc IV+ (Panther)"),
+		CPU(0x22, "TI UltraSparc IIIi+ (Serrano)"),
+		CPU(-1, NULL)
+	},
+	.fpu_info = {
+		FPU(0x14, "UltraSparc III integrated FPU"),
+		FPU(0x15, "UltraSparc III+ integrated FPU"),
+		FPU(0x16, "UltraSparc IIIi integrated FPU"),
+		FPU(0x18, "UltraSparc IV integrated FPU"),
+		FPU(0x19, "UltraSparc IV+ integrated FPU"),
+		FPU(0x22, "UltraSparc IIIi+ integrated FPU"),
+		FPU(-1, NULL)
+	}
+}};
+
+/* In order to get the fpu type correct, you need to take the IDPROM's
+ * machine type value into consideration too.  I will fix this.
+ */
+
+const char *sparc_cpu_type;
+const char *sparc_fpu_type;
+
+unsigned int fsr_storage;
+
+static void set_cpu_and_fpu(int psr_impl, int psr_vers, int fpu_vers)
+{
+	sparc_cpu_type = NULL;
+	sparc_fpu_type = NULL;
+	if (psr_impl < ARRAY_SIZE(manufacturer_info))
+	{
+		const struct cpu_info *cpu;
+		const struct fpu_info *fpu;
+
+		cpu = &manufacturer_info[psr_impl].cpu_info[0];
+		while (cpu->psr_vers != -1)
+		{
+			if (cpu->psr_vers == psr_vers) {
+				sparc_cpu_type = cpu->name;
+				sparc_fpu_type = "No FPU";
+				break;
+			}
+			cpu++;
+		}
+		fpu =  &manufacturer_info[psr_impl].fpu_info[0];
+		while (fpu->fp_vers != -1)
+		{
+			if (fpu->fp_vers == fpu_vers) {
+				sparc_fpu_type = fpu->name;
+				break;
+			}
+			fpu++;
+		}
+	}
+	if (sparc_cpu_type == NULL)
+	{
+		printk(KERN_ERR "CPU: Unknown chip, impl[0x%x] vers[0x%x]\n",
+		       psr_impl, psr_vers);
+		sparc_cpu_type = "Unknown CPU";
+	}
+	if (sparc_fpu_type == NULL)
+	{
+		printk(KERN_ERR "FPU: Unknown chip, impl[0x%x] vers[0x%x]\n",
+		       psr_impl, fpu_vers);
+		sparc_fpu_type = "Unknown FPU";
+	}
+}
+
+#ifdef CONFIG_SPARC32
+void __cpuinit cpu_probe(void)
+{
+	int psr_impl, psr_vers, fpu_vers;
+	int psr;
+
+	psr_impl = ((get_psr() >> 28) & 0xf);
+	psr_vers = ((get_psr() >> 24) & 0xf);
+
+	psr = get_psr();
+	put_psr(psr | PSR_EF);
+	fpu_vers = ((get_fsr() >> 17) & 0x7);
+	put_psr(psr);
+
+	set_cpu_and_fpu(psr_impl, psr_vers, fpu_vers);
+}
+#else
+static void __init sun4v_cpu_probe(void)
+{
+	switch (sun4v_chip_type) {
+	case SUN4V_CHIP_NIAGARA1:
+		sparc_cpu_type = "UltraSparc T1 (Niagara)";
+		sparc_fpu_type = "UltraSparc T1 integrated FPU";
+		break;
+
+	case SUN4V_CHIP_NIAGARA2:
+		sparc_cpu_type = "UltraSparc T2 (Niagara2)";
+		sparc_fpu_type = "UltraSparc T2 integrated FPU";
+		break;
+
+	default:
+		printk(KERN_WARNING "CPU: Unknown sun4v cpu type [%s]\n",
+		       prom_cpu_compatible);
+		sparc_cpu_type = "Unknown SUN4V CPU";
+		sparc_fpu_type = "Unknown SUN4V FPU";
+		break;
+	}
+}
+
+static int __init cpu_type_probe(void)
+{
+	if (tlb_type == hypervisor) {
+		sun4v_cpu_probe();
+	} else {
+		unsigned long ver;
+		int manuf, impl;
+
+		__asm__ __volatile__("rdpr %%ver, %0" : "=r" (ver));
+
+		manuf = ((ver >> 48) & 0xffff);
+		impl = ((ver >> 32) & 0xffff);
+		set_cpu_and_fpu(manuf, impl, impl);
+	}
+	return 0;
+}
+
+arch_initcall(cpu_type_probe);
+#endif

commit d670bd4f803c8b646acd20f3ba21e65458293faf
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Dec 3 03:08:37 2008 -0800

    sparc: prepare kernel/ for unification
    
    o sparc32 files with identical names to sparc64 renamed to <name>_32.S
    o introduced a few Kconfig helpers to simplify Makefile logic
    o refactored Makefile to prepare for unification
      - use obj-$(CONFIG_SPARC32) for sparc32 specific files
      - use <name>_$(BITS) for files where sparc64 has a _64 variant
      - sparc64 directly include a few files where sparc32 builds them,
        refer to these files directly (no BITS)
      - sneaked in -Werror as used by sparc64
    o modified sparc/Makefile to use the new names for head/init_task
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
deleted file mode 100644
index 1fc17f59c6bf..000000000000
--- a/arch/sparc/kernel/cpu.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/* cpu.c: Dinky routines to look for the kind of Sparc cpu
- *        we are on.
- *
- * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/threads.h>
-#include <asm/oplib.h>
-#include <asm/page.h>
-#include <asm/head.h>
-#include <asm/psr.h>
-#include <asm/mbus.h>
-#include <asm/cpudata.h>
-
-DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
-
-struct cpu_iu_info {
-  int psr_impl;
-  int psr_vers;
-  char* cpu_name;   /* should be enough I hope... */
-};
-
-struct cpu_fp_info {
-  int psr_impl;
-  int fp_vers;
-  char* fp_name;
-};
-
-/* In order to get the fpu type correct, you need to take the IDPROM's
- * machine type value into consideration too.  I will fix this.
- */
-static struct cpu_fp_info linux_sparc_fpu[] = {
-  { 0, 0, "Fujitsu MB86910 or Weitek WTL1164/5"},
-  { 0, 1, "Fujitsu MB86911 or Weitek WTL1164/5 or LSI L64831"},
-  { 0, 2, "LSI Logic L64802 or Texas Instruments ACT8847"},
-  /* SparcStation SLC, SparcStation1 */
-  { 0, 3, "Weitek WTL3170/2"},
-  /* SPARCstation-5 */
-  { 0, 4, "Lsi Logic/Meiko L64804 or compatible"},
-  { 0, 5, "reserved"},
-  { 0, 6, "reserved"},
-  { 0, 7, "No FPU"},
-  { 1, 0, "ROSS HyperSparc combined IU/FPU"},
-  { 1, 1, "Lsi Logic L64814"},
-  { 1, 2, "Texas Instruments TMS390-C602A"},
-  { 1, 3, "Cypress CY7C602 FPU"},
-  { 1, 4, "reserved"},
-  { 1, 5, "reserved"},
-  { 1, 6, "reserved"},
-  { 1, 7, "No FPU"},
-  { 2, 0, "BIT B5010 or B5110/20 or B5210"},
-  { 2, 1, "reserved"},
-  { 2, 2, "reserved"},
-  { 2, 3, "reserved"},
-  { 2, 4, "reserved"},
-  { 2, 5, "reserved"},
-  { 2, 6, "reserved"},
-  { 2, 7, "No FPU"},
-  /* SuperSparc 50 module */
-  { 4, 0, "SuperSparc on-chip FPU"},
-  /* SparcClassic */
-  { 4, 4, "TI MicroSparc on chip FPU"},
-  { 5, 0, "Matsushita MN10501"},
-  { 5, 1, "reserved"},
-  { 5, 2, "reserved"},
-  { 5, 3, "reserved"},
-  { 5, 4, "reserved"},
-  { 5, 5, "reserved"},
-  { 5, 6, "reserved"},
-  { 5, 7, "No FPU"},
-  { 9, 3, "Fujitsu or Weitek on-chip FPU"},
-};
-
-#define NSPARCFPU  ARRAY_SIZE(linux_sparc_fpu)
-
-static struct cpu_iu_info linux_sparc_chips[] = {
-  /* Sun4/100, 4/200, SLC */
-  { 0, 0, "Fujitsu  MB86900/1A or LSI L64831 SparcKIT-40"},
-  /* borned STP1012PGA */
-  { 0, 4, "Fujitsu  MB86904"},
-  { 0, 5, "Fujitsu TurboSparc MB86907"},
-  /* SparcStation2, SparcServer 490 & 690 */
-  { 1, 0, "LSI Logic Corporation - L64811"},
-  /* SparcStation2 */
-  { 1, 1, "Cypress/ROSS CY7C601"},
-  /* Embedded controller */
-  { 1, 3, "Cypress/ROSS CY7C611"},
-  /* Ross Technologies HyperSparc */
-  { 1, 0xf, "ROSS HyperSparc RT620"},
-  { 1, 0xe, "ROSS HyperSparc RT625 or RT626"},
-  /* ECL Implementation, CRAY S-MP Supercomputer... AIEEE! */
-  /* Someone please write the code to support this beast! ;) */
-  { 2, 0, "Bipolar Integrated Technology - B5010"},
-  { 3, 0, "LSI Logic Corporation - unknown-type"},
-  { 4, 0, "Texas Instruments, Inc. - SuperSparc-(II)"},
-  /* SparcClassic  --  borned STP1010TAB-50*/
-  { 4, 1, "Texas Instruments, Inc. - MicroSparc"},
-  { 4, 2, "Texas Instruments, Inc. - MicroSparc II"},
-  { 4, 3, "Texas Instruments, Inc. - SuperSparc 51"},
-  { 4, 4, "Texas Instruments, Inc. - SuperSparc 61"},
-  { 4, 5, "Texas Instruments, Inc. - unknown"},
-  { 5, 0, "Matsushita - MN10501"},
-  { 6, 0, "Philips Corporation - unknown"},
-  { 7, 0, "Harvest VLSI Design Center, Inc. - unknown"},
-  /* Gallium arsenide 200MHz, BOOOOGOOOOMIPS!!! */
-  { 8, 0, "Systems and Processes Engineering Corporation (SPEC)"},
-  { 9, 0, "Fujitsu or Weitek Power-UP"},
-  { 9, 1, "Fujitsu or Weitek Power-UP"},
-  { 9, 2, "Fujitsu or Weitek Power-UP"},
-  { 9, 3, "Fujitsu or Weitek Power-UP"},
-  { 0xa, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-  { 0xb, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-  { 0xc, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-  { 0xd, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-  { 0xe, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-  { 0xf, 0, "UNKNOWN CPU-VENDOR/TYPE"},
-};
-
-#define NSPARCCHIPS  ARRAY_SIZE(linux_sparc_chips)
-
-char *sparc_cpu_type;
-char *sparc_fpu_type;
-
-unsigned int fsr_storage;
-
-void __cpuinit cpu_probe(void)
-{
-	int psr_impl, psr_vers, fpu_vers;
-	int i, psr;
-
-	psr_impl = ((get_psr()>>28)&0xf);
-	psr_vers = ((get_psr()>>24)&0xf);
-
-	psr = get_psr();
-	put_psr(psr | PSR_EF);
-	fpu_vers = ((get_fsr()>>17)&0x7);
-	put_psr(psr);
-
-	for(i = 0; i<NSPARCCHIPS; i++) {
-		if(linux_sparc_chips[i].psr_impl == psr_impl)
-			if(linux_sparc_chips[i].psr_vers == psr_vers) {
-				sparc_cpu_type = linux_sparc_chips[i].cpu_name;
-				break;
-			}
-	}
-
-	if(i==NSPARCCHIPS)
-		printk("DEBUG: psr.impl = 0x%x   psr.vers = 0x%x\n", psr_impl, 
-			    psr_vers);
-
-	for(i = 0; i<NSPARCFPU; i++) {
-		if(linux_sparc_fpu[i].psr_impl == psr_impl)
-			if(linux_sparc_fpu[i].fp_vers == fpu_vers) {
-				sparc_fpu_type = linux_sparc_fpu[i].fp_name;
-				break;
-			}
-	}
-
-	if(i == NSPARCFPU) {
-		printk("DEBUG: psr.impl = 0x%x  fsr.vers = 0x%x\n", psr_impl,
-			    fpu_vers);
-		sparc_fpu_type = linux_sparc_fpu[31].fp_name;
-	}
-}

commit 409832f5484cd1e2d8812c3236dffb33d01c359b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:33:54 2008 +0000

    sparc32 cpuinit flase positives
    
    All noise since we don't have CPU hotplug there.  However, they
    did expose something very odd-looking in there - poke_viking()
    does a bunch of identical btfixup each time it's called (i.e.
    for each CPU).  That one is left alone for now; just the trivial
    misannotation fixes.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index e7a0edfc1a32..1fc17f59c6bf 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -126,7 +126,7 @@ char *sparc_fpu_type;
 
 unsigned int fsr_storage;
 
-void __init cpu_probe(void)
+void __cpuinit cpu_probe(void)
 {
 	int psr_impl, psr_vers, fpu_vers;
 	int i, psr;

commit c8edc89d24546c834d7f595663afd14602855c02
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Feb 28 21:46:59 2008 -0800

    [SPARC]: Mark linux_sparc_{fpu,chips} static.
    
    Caught by sparse.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 259a559d4cea..e7a0edfc1a32 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -32,7 +32,7 @@ struct cpu_fp_info {
 /* In order to get the fpu type correct, you need to take the IDPROM's
  * machine type value into consideration too.  I will fix this.
  */
-struct cpu_fp_info linux_sparc_fpu[] = {
+static struct cpu_fp_info linux_sparc_fpu[] = {
   { 0, 0, "Fujitsu MB86910 or Weitek WTL1164/5"},
   { 0, 1, "Fujitsu MB86911 or Weitek WTL1164/5 or LSI L64831"},
   { 0, 2, "LSI Logic L64802 or Texas Instruments ACT8847"},
@@ -76,7 +76,7 @@ struct cpu_fp_info linux_sparc_fpu[] = {
 
 #define NSPARCFPU  ARRAY_SIZE(linux_sparc_fpu)
 
-struct cpu_iu_info linux_sparc_chips[] = {
+static struct cpu_iu_info linux_sparc_chips[] = {
   /* Sun4/100, 4/200, SLC */
   { 0, 0, "Fujitsu  MB86900/1A or LSI L64831 SparcKIT-40"},
   /* borned STP1012PGA */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index d7bfc61d2879..259a559d4cea 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -4,7 +4,6 @@
  * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/smp.h>

commit 940fdc6e1223f1323b88b7f1e7ae09a93a76b74d
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Wed Nov 9 12:03:05 2005 -0800

    [SPARC]: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove a
    duplicate of ARRAY_SIZE which is never used anyways.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 6a4ebc62193e..d7bfc61d2879 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -75,7 +75,7 @@ struct cpu_fp_info linux_sparc_fpu[] = {
   { 9, 3, "Fujitsu or Weitek on-chip FPU"},
 };
 
-#define NSPARCFPU  (sizeof(linux_sparc_fpu)/sizeof(struct cpu_fp_info))
+#define NSPARCFPU  ARRAY_SIZE(linux_sparc_fpu)
 
 struct cpu_iu_info linux_sparc_chips[] = {
   /* Sun4/100, 4/200, SLC */
@@ -120,7 +120,7 @@ struct cpu_iu_info linux_sparc_chips[] = {
   { 0xf, 0, "UNKNOWN CPU-VENDOR/TYPE"},
 };
 
-#define NSPARCCHIPS  (sizeof(linux_sparc_chips)/sizeof(struct cpu_iu_info))
+#define NSPARCCHIPS  ARRAY_SIZE(linux_sparc_chips)
 
 char *sparc_cpu_type;
 char *sparc_fpu_type;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
new file mode 100644
index 000000000000..6a4ebc62193e
--- /dev/null
+++ b/arch/sparc/kernel/cpu.c
@@ -0,0 +1,168 @@
+/* cpu.c: Dinky routines to look for the kind of Sparc cpu
+ *        we are on.
+ *
+ * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <asm/oplib.h>
+#include <asm/page.h>
+#include <asm/head.h>
+#include <asm/psr.h>
+#include <asm/mbus.h>
+#include <asm/cpudata.h>
+
+DEFINE_PER_CPU(cpuinfo_sparc, __cpu_data) = { 0 };
+
+struct cpu_iu_info {
+  int psr_impl;
+  int psr_vers;
+  char* cpu_name;   /* should be enough I hope... */
+};
+
+struct cpu_fp_info {
+  int psr_impl;
+  int fp_vers;
+  char* fp_name;
+};
+
+/* In order to get the fpu type correct, you need to take the IDPROM's
+ * machine type value into consideration too.  I will fix this.
+ */
+struct cpu_fp_info linux_sparc_fpu[] = {
+  { 0, 0, "Fujitsu MB86910 or Weitek WTL1164/5"},
+  { 0, 1, "Fujitsu MB86911 or Weitek WTL1164/5 or LSI L64831"},
+  { 0, 2, "LSI Logic L64802 or Texas Instruments ACT8847"},
+  /* SparcStation SLC, SparcStation1 */
+  { 0, 3, "Weitek WTL3170/2"},
+  /* SPARCstation-5 */
+  { 0, 4, "Lsi Logic/Meiko L64804 or compatible"},
+  { 0, 5, "reserved"},
+  { 0, 6, "reserved"},
+  { 0, 7, "No FPU"},
+  { 1, 0, "ROSS HyperSparc combined IU/FPU"},
+  { 1, 1, "Lsi Logic L64814"},
+  { 1, 2, "Texas Instruments TMS390-C602A"},
+  { 1, 3, "Cypress CY7C602 FPU"},
+  { 1, 4, "reserved"},
+  { 1, 5, "reserved"},
+  { 1, 6, "reserved"},
+  { 1, 7, "No FPU"},
+  { 2, 0, "BIT B5010 or B5110/20 or B5210"},
+  { 2, 1, "reserved"},
+  { 2, 2, "reserved"},
+  { 2, 3, "reserved"},
+  { 2, 4, "reserved"},
+  { 2, 5, "reserved"},
+  { 2, 6, "reserved"},
+  { 2, 7, "No FPU"},
+  /* SuperSparc 50 module */
+  { 4, 0, "SuperSparc on-chip FPU"},
+  /* SparcClassic */
+  { 4, 4, "TI MicroSparc on chip FPU"},
+  { 5, 0, "Matsushita MN10501"},
+  { 5, 1, "reserved"},
+  { 5, 2, "reserved"},
+  { 5, 3, "reserved"},
+  { 5, 4, "reserved"},
+  { 5, 5, "reserved"},
+  { 5, 6, "reserved"},
+  { 5, 7, "No FPU"},
+  { 9, 3, "Fujitsu or Weitek on-chip FPU"},
+};
+
+#define NSPARCFPU  (sizeof(linux_sparc_fpu)/sizeof(struct cpu_fp_info))
+
+struct cpu_iu_info linux_sparc_chips[] = {
+  /* Sun4/100, 4/200, SLC */
+  { 0, 0, "Fujitsu  MB86900/1A or LSI L64831 SparcKIT-40"},
+  /* borned STP1012PGA */
+  { 0, 4, "Fujitsu  MB86904"},
+  { 0, 5, "Fujitsu TurboSparc MB86907"},
+  /* SparcStation2, SparcServer 490 & 690 */
+  { 1, 0, "LSI Logic Corporation - L64811"},
+  /* SparcStation2 */
+  { 1, 1, "Cypress/ROSS CY7C601"},
+  /* Embedded controller */
+  { 1, 3, "Cypress/ROSS CY7C611"},
+  /* Ross Technologies HyperSparc */
+  { 1, 0xf, "ROSS HyperSparc RT620"},
+  { 1, 0xe, "ROSS HyperSparc RT625 or RT626"},
+  /* ECL Implementation, CRAY S-MP Supercomputer... AIEEE! */
+  /* Someone please write the code to support this beast! ;) */
+  { 2, 0, "Bipolar Integrated Technology - B5010"},
+  { 3, 0, "LSI Logic Corporation - unknown-type"},
+  { 4, 0, "Texas Instruments, Inc. - SuperSparc-(II)"},
+  /* SparcClassic  --  borned STP1010TAB-50*/
+  { 4, 1, "Texas Instruments, Inc. - MicroSparc"},
+  { 4, 2, "Texas Instruments, Inc. - MicroSparc II"},
+  { 4, 3, "Texas Instruments, Inc. - SuperSparc 51"},
+  { 4, 4, "Texas Instruments, Inc. - SuperSparc 61"},
+  { 4, 5, "Texas Instruments, Inc. - unknown"},
+  { 5, 0, "Matsushita - MN10501"},
+  { 6, 0, "Philips Corporation - unknown"},
+  { 7, 0, "Harvest VLSI Design Center, Inc. - unknown"},
+  /* Gallium arsenide 200MHz, BOOOOGOOOOMIPS!!! */
+  { 8, 0, "Systems and Processes Engineering Corporation (SPEC)"},
+  { 9, 0, "Fujitsu or Weitek Power-UP"},
+  { 9, 1, "Fujitsu or Weitek Power-UP"},
+  { 9, 2, "Fujitsu or Weitek Power-UP"},
+  { 9, 3, "Fujitsu or Weitek Power-UP"},
+  { 0xa, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+  { 0xb, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+  { 0xc, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+  { 0xd, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+  { 0xe, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+  { 0xf, 0, "UNKNOWN CPU-VENDOR/TYPE"},
+};
+
+#define NSPARCCHIPS  (sizeof(linux_sparc_chips)/sizeof(struct cpu_iu_info))
+
+char *sparc_cpu_type;
+char *sparc_fpu_type;
+
+unsigned int fsr_storage;
+
+void __init cpu_probe(void)
+{
+	int psr_impl, psr_vers, fpu_vers;
+	int i, psr;
+
+	psr_impl = ((get_psr()>>28)&0xf);
+	psr_vers = ((get_psr()>>24)&0xf);
+
+	psr = get_psr();
+	put_psr(psr | PSR_EF);
+	fpu_vers = ((get_fsr()>>17)&0x7);
+	put_psr(psr);
+
+	for(i = 0; i<NSPARCCHIPS; i++) {
+		if(linux_sparc_chips[i].psr_impl == psr_impl)
+			if(linux_sparc_chips[i].psr_vers == psr_vers) {
+				sparc_cpu_type = linux_sparc_chips[i].cpu_name;
+				break;
+			}
+	}
+
+	if(i==NSPARCCHIPS)
+		printk("DEBUG: psr.impl = 0x%x   psr.vers = 0x%x\n", psr_impl, 
+			    psr_vers);
+
+	for(i = 0; i<NSPARCFPU; i++) {
+		if(linux_sparc_fpu[i].psr_impl == psr_impl)
+			if(linux_sparc_fpu[i].fp_vers == fpu_vers) {
+				sparc_fpu_type = linux_sparc_fpu[i].fp_name;
+				break;
+			}
+	}
+
+	if(i == NSPARCFPU) {
+		printk("DEBUG: psr.impl = 0x%x  fsr.vers = 0x%x\n", psr_impl,
+			    fpu_vers);
+		sparc_fpu_type = linux_sparc_fpu[31].fp_name;
+	}
+}
