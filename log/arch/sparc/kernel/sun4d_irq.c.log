commit 29c990dfc77c58b21a0f2ff4640b6a26955d0661
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 15:06:58 2018 -0600

    sparc: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 6d266d7dd2b6..9a137c70e8d1 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -335,12 +335,12 @@ static unsigned int sun4d_build_device_irq(struct platform_device *op,
 
 	irq = real_irq;
 	while (bus) {
-		if (!strcmp(bus->name, "sbi")) {
+		if (of_node_name_eq(bus, "sbi")) {
 			bus_connection = "io-unit";
 			break;
 		}
 
-		if (!strcmp(bus->name, "bootbus")) {
+		if (of_node_name_eq(bus, "bootbus")) {
 			bus_connection = "cpu-unit";
 			break;
 		}
@@ -360,7 +360,7 @@ static unsigned int sun4d_build_device_irq(struct platform_device *op,
 	 * If Bus nodes parent is not io-unit/cpu-unit or the io-unit/cpu-unit
 	 * lacks a "board#" property, something is very wrong.
 	 */
-	if (!bus->parent || strcmp(bus->parent->name, bus_connection)) {
+	if (!of_node_name_eq(bus->parent, bus_connection)) {
 		printk(KERN_ERR "%pOF: Error, parent is not %s.\n",
 			bus, bus_connection);
 		goto err_out;

commit a412c85aa82a5c8d585b08808aeefcd186712bb5
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 15:06:54 2018 -0600

    sparc: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index d869d409fce6..6d266d7dd2b6 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -361,15 +361,15 @@ static unsigned int sun4d_build_device_irq(struct platform_device *op,
 	 * lacks a "board#" property, something is very wrong.
 	 */
 	if (!bus->parent || strcmp(bus->parent->name, bus_connection)) {
-		printk(KERN_ERR "%s: Error, parent is not %s.\n",
-			bus->full_name, bus_connection);
+		printk(KERN_ERR "%pOF: Error, parent is not %s.\n",
+			bus, bus_connection);
 		goto err_out;
 	}
 	board_parent = bus->parent;
 	board = of_getintprop_default(board_parent, "board#", -1);
 	if (board == -1) {
-		printk(KERN_ERR "%s: Error, lacks board# property.\n",
-			board_parent->full_name);
+		printk(KERN_ERR "%pOF: Error, lacks board# property.\n",
+			board_parent);
 		goto err_out;
 	}
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index a87d0e47c168..d869d409fce6 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SS1000/SC2000 interrupt handling.
  *

commit 6a4a5b34c315be04abdc366cda7a00b7249550f3
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:17 2015 +0800

    sparc/irq: Use helper irq_data_get_irq_handler_data()
    
    Use helper function irq_data_get_irq_handler_data() to hide irq_desc
    implementation details. This allows to move irq_data->handler_data to
    irq_data_common, once all usage sites are converted.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: David S. Miller <davem@davemloft.net>
    Link: http://lkml.kernel.org/r/1433145945-789-9-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index a1bb2675b280..a87d0e47c168 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -188,7 +188,7 @@ void sun4d_handler_irq(unsigned int pil, struct pt_regs *regs)
 
 static void sun4d_mask_irq(struct irq_data *data)
 {
-	struct sun4d_handler_data *handler_data = data->handler_data;
+	struct sun4d_handler_data *handler_data = irq_data_get_irq_handler_data(data);
 	unsigned int real_irq;
 #ifdef CONFIG_SMP
 	int cpuid = handler_data->cpuid;
@@ -206,7 +206,7 @@ static void sun4d_mask_irq(struct irq_data *data)
 
 static void sun4d_unmask_irq(struct irq_data *data)
 {
-	struct sun4d_handler_data *handler_data = data->handler_data;
+	struct sun4d_handler_data *handler_data = irq_data_get_irq_handler_data(data);
 	unsigned int real_irq;
 #ifdef CONFIG_SMP
 	int cpuid = handler_data->cpuid;

commit 5ac7568829b5a2c61285695acb18dce3c67e4cf5
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Apr 21 21:39:23 2014 +0200

    sparc32: fix sparse warnings in sun4d_irq.c
    
    Fix following warnings:
    sun4d_irq.c:146:6: warning: symbol 'sun4d_handler_irq' was not declared. Should it be static?
    sun4d_irq.c:239:17: warning: symbol 'sun4d_irq' was not declared. Should it be static?
    sun4d_irq.c:288:14: warning: symbol '_sun4d_build_device_irq' was not declared. Should it be static?
    sun4d_irq.c:323:14: warning: symbol 'sun4d_build_device_irq' was not declared. Should it be static?
    sun4d_irq.c:386:14: warning: symbol 'sun4d_build_timer_irq' was not declared. Should it be static?
    sun4d_irq.c:482:13: warning: symbol 'sun4d_init_sbi_irq' was not declared. Should it be static?
    
    Apply static when applicable, otherwise add prototype
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index f8933be3ca8b..a1bb2675b280 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -143,7 +143,7 @@ static void sun4d_sbus_handler_irq(int sbusl)
 	}
 }
 
-void sun4d_handler_irq(int pil, struct pt_regs *regs)
+void sun4d_handler_irq(unsigned int pil, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs;
 	/* SBUS IRQ level (1 - 7) */
@@ -236,7 +236,7 @@ static void sun4d_shutdown_irq(struct irq_data *data)
 	irq_unlink(data->irq);
 }
 
-struct irq_chip sun4d_irq = {
+static struct irq_chip sun4d_irq = {
 	.name		= "sun4d",
 	.irq_startup	= sun4d_startup_irq,
 	.irq_shutdown	= sun4d_shutdown_irq,
@@ -285,9 +285,9 @@ static void __init sun4d_load_profile_irqs(void)
 	}
 }
 
-unsigned int _sun4d_build_device_irq(unsigned int real_irq,
-                                     unsigned int pil,
-                                     unsigned int board)
+static unsigned int _sun4d_build_device_irq(unsigned int real_irq,
+                                            unsigned int pil,
+                                            unsigned int board)
 {
 	struct sun4d_handler_data *handler_data;
 	unsigned int irq;
@@ -320,8 +320,8 @@ unsigned int _sun4d_build_device_irq(unsigned int real_irq,
 
 
 
-unsigned int sun4d_build_device_irq(struct platform_device *op,
-                                    unsigned int real_irq)
+static unsigned int sun4d_build_device_irq(struct platform_device *op,
+                                           unsigned int real_irq)
 {
 	struct device_node *dp = op->dev.of_node;
 	struct device_node *board_parent, *bus = dp->parent;
@@ -383,7 +383,8 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
 	return irq;
 }
 
-unsigned int sun4d_build_timer_irq(unsigned int board, unsigned int real_irq)
+static unsigned int sun4d_build_timer_irq(unsigned int board,
+                                          unsigned int real_irq)
 {
 	return _sun4d_build_device_irq(real_irq, real_irq, board);
 }

commit 0d01ff2583086fd532181d2ee16112f5342eb78d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 11 23:51:01 2013 +0100

    Include missing linux/slab.h inclusions
    
    Include missing linux/slab.h inclusions where the source file is currently
    expecting to get kmalloc() and co. through linux/proc_fs.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: linux-s390@vger.kernel.org
    cc: sparclinux@vger.kernel.org
    cc: linux-efi@vger.kernel.org
    cc: linux-mtd@lists.infradead.org
    cc: devel@driverdev.osuosl.org
    cc: x86@kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index e490ac9327c7..f8933be3ca8b 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -6,6 +6,7 @@
  */
 
 #include <linux/kernel_stat.h>
+#include <linux/slab.h>
 #include <linux/seq_file.h>
 
 #include <asm/timer.h>

commit 08c9388f5816ac9285dce7d07c8867ae1c1e4bcb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon May 14 17:30:35 2012 +0200

    sparc32: remove remaining users of btfixup
    
    Use sparc_config to hold the last two function pointers.  There was no
    point generating dedicated _ops structures only for these.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index e8e4f1411585..e490ac9327c7 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -506,12 +506,11 @@ void __init sun4d_init_IRQ(void)
 {
 	local_irq_disable();
 
-	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
-
 	sparc_config.init_timers      = sun4d_init_timers;
 	sparc_config.build_device_irq = sun4d_build_device_irq;
 	sparc_config.clock_rate       = SBUS_CLOCK_RATE;
+	sparc_config.clear_clock_irq  = sun4d_clear_clock_irq;
+	sparc_config.load_profile_irq = sun4d_load_profile_irq;
 
 	/* Cannot enable interrupts until OBP ticker is disabled. */
 }

commit 4ba22b16bbf354822b7988ec5b4b35774dcd479f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon May 14 15:14:36 2012 +0200

    sparc32: move smp ipi to method ops
    
    I ended up renaming set_cpu_int to send_ipi to
    be consistent all way around.
    send_ipi was moved to the *_smp.c files so
    we could call the relevant method direct,
    without any _ops indirection.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index b2fdb3d78c19..e8e4f1411585 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -244,11 +244,6 @@ struct irq_chip sun4d_irq = {
 };
 
 #ifdef CONFIG_SMP
-static void sun4d_set_cpu_int(int cpu, int level)
-{
-	sun4d_send_ipi(cpu, level);
-}
-
 /* Setup IRQ distribution scheme. */
 void __init sun4d_distribute_irqs(void)
 {
@@ -518,8 +513,5 @@ void __init sun4d_init_IRQ(void)
 	sparc_config.build_device_irq = sun4d_build_device_irq;
 	sparc_config.clock_rate       = SBUS_CLOCK_RATE;
 
-#ifdef CONFIG_SMP
-	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);
-#endif
 	/* Cannot enable interrupts until OBP ticker is disabled. */
 }

commit 5d83d66635bb1642f3c6a3690c28ff4afdf1ae5f
Author: David S. Miller <davem@davemloft.net>
Date:   Sun May 13 20:49:31 2012 -0700

    sparc32: Move cache and TLB flushes over to method ops.
    
    This eliminated most of the remaining users of btfixup.
    
    There are some complications because of the special cases we
    have for sun4d, leon, and some flavors of viking.
    
    It was found that there are no cases where a flush_page_for_dma
    method was not hooked up to something, so the "noflush" iommu
    methods were removed.
    
    Add some documentation to the viking_sun4d_smp_ops to describe exactly
    the hardware bug which causes us to need special TLB flushing on
    sun4d.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 15593ee1c120..b2fdb3d78c19 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -15,6 +15,7 @@
 #include <asm/sbi.h>
 #include <asm/cacheflush.h>
 #include <asm/setup.h>
+#include <asm/oplib.h>
 
 #include "kernel.h"
 #include "irq.h"
@@ -411,7 +412,7 @@ static void __init sun4d_fixup_trap_table(void)
 	trap_table->inst_two = lvl14_save[1];
 	trap_table->inst_three = lvl14_save[2];
 	trap_table->inst_four = lvl14_save[3];
-	local_flush_cache_all();
+	local_ops->cache_all();
 	local_irq_restore(flags);
 #endif
 }

commit 0f031b3f26c5fc019d541e41ae53b32e2dc6a373
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 13 15:43:41 2012 +0200

    sparc32: drop unused clear_cpu_int
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 7796fa511f27..15593ee1c120 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -248,10 +248,6 @@ static void sun4d_set_cpu_int(int cpu, int level)
 	sun4d_send_ipi(cpu, level);
 }
 
-static void sun4d_clear_ipi(int cpu, int level)
-{
-}
-
 /* Setup IRQ distribution scheme. */
 void __init sun4d_distribute_irqs(void)
 {
@@ -523,7 +519,6 @@ void __init sun4d_init_IRQ(void)
 
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(clear_cpu_int, sun4d_clear_ipi, BTFIXUPCALL_NOP);
 #endif
 	/* Cannot enable interrupts until OBP ticker is disabled. */
 }

commit 41eb17ce9888d759bf327cf0a4e1ea618016be64
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 13 15:29:09 2012 +0200

    sparc32: drop unused set_irq_udt
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index abf52654a8bc..7796fa511f27 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -252,10 +252,6 @@ static void sun4d_clear_ipi(int cpu, int level)
 {
 }
 
-static void sun4d_set_udt(int cpu)
-{
-}
-
 /* Setup IRQ distribution scheme. */
 void __init sun4d_distribute_irqs(void)
 {
@@ -528,7 +524,6 @@ void __init sun4d_init_IRQ(void)
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_cpu_int, sun4d_clear_ipi, BTFIXUPCALL_NOP);
-	BTFIXUPSET_CALL(set_irq_udt, sun4d_set_udt, BTFIXUPCALL_NOP);
 #endif
 	/* Cannot enable interrupts until OBP ticker is disabled. */
 }

commit 62f082830d63cf753ed0dab16f8d3b2d0ffc7f43
Author: Tkhai Kirill <tkhai@yandex.ru>
Date:   Wed Apr 4 21:49:26 2012 +0200

    sparc32: generic clockevent support
    
    The kernel uses l14 timers as clockevents. l10 timer is used
    as clocksource if platform master_l10_counter isn't constantly
    zero. The clocksource is continuous, so it's possible to use
    high resolution timers. l10 timer is also used as clockevent
    on UP configurations.
    
    This realization is for sun4m, sun4d, sun4c, microsparc-IIep
    and LEON platforms. The appropriate LEON changes was made by
    Konrad Eisele.
    
    In case of sun4m's oneshot mode, profile irq is zeroed in
    smp4m_percpu_timer_interrupt(). It is maybe
    needless (double, triple etc overflow does nothing).
    
    sun4d is able to have oneshot mode too, but I haven't
    any way to test it. So code of its percpu timer handler
    is made as much equal to the current code as possible.
    
    The patch is tested on sun4m box in SMP mode by me,
    and tested by Konrad on leon in up mode (leon smp
    is broken atm - due to other reasons).
    
    Signed-off-by: Tkhai Kirill <tkhai@yandex.ru>
    Tested-by: Konrad Eisele <konrad@gaisler.com> [leon up]
    [sam: revised patch to provide generic support for leon]
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 30119f662eff..abf52654a8bc 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -282,7 +282,8 @@ static void sun4d_clear_clock_irq(void)
 
 static void sun4d_load_profile_irq(int cpu, unsigned int limit)
 {
-	bw_set_prof_limit(cpu, limit);
+	unsigned int value = limit ? timer_value(limit) : 0;
+	bw_set_prof_limit(cpu, value);
 }
 
 static void __init sun4d_load_profile_irqs(void)
@@ -423,7 +424,7 @@ static void __init sun4d_fixup_trap_table(void)
 #endif
 }
 
-static void __init sun4d_init_timers(irq_handler_t counter_fn)
+static void __init sun4d_init_timers(void)
 {
 	struct device_node *dp;
 	struct resource res;
@@ -466,12 +467,20 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 		prom_halt();
 	}
 
-	sbus_writel((((1000000/HZ) + 1) << 10), &sun4d_timers->l10_timer_limit);
+#ifdef CONFIG_SMP
+	sparc_config.cs_period = SBUS_CLOCK_RATE * 2;  /* 2 seconds */
+#else
+	sparc_config.cs_period = SBUS_CLOCK_RATE / HZ; /* 1/HZ sec  */
+	sparc_config.features |= FEAT_L10_CLOCKEVENT;
+#endif
+	sparc_config.features |= FEAT_L10_CLOCKSOURCE;
+	sbus_writel(timer_value(sparc_config.cs_period),
+		    &sun4d_timers->l10_timer_limit);
 
 	master_l10_counter = &sun4d_timers->l10_cur_count;
 
 	irq = sun4d_build_timer_irq(board, SUN4D_TIMER_IRQ);
-	err = request_irq(irq, counter_fn, IRQF_TIMER, "timer", NULL);
+	err = request_irq(irq, timer_interrupt, IRQF_TIMER, "timer", NULL);
 	if (err) {
 		prom_printf("sun4d_init_timers: request_irq() failed with %d\n",
 		             err);
@@ -514,6 +523,7 @@ void __init sun4d_init_IRQ(void)
 
 	sparc_config.init_timers      = sun4d_init_timers;
 	sparc_config.build_device_irq = sun4d_build_device_irq;
+	sparc_config.clock_rate       = SBUS_CLOCK_RATE;
 
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);

commit 472bc4f2ad164a5aac2e85d891c4faecfc5d62c4
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Apr 4 13:21:13 2012 +0200

    sparc32: rename sparc_irq_config to sparc_config
    
    This struct holds platform specific config and is thus not
    limited to irq stuff.
    Do not let the name confuse us to think this is irq only.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 1d13c5bda0b1..30119f662eff 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -512,8 +512,8 @@ void __init sun4d_init_IRQ(void)
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
 
-	sparc_irq_config.init_timers      = sun4d_init_timers;
-	sparc_irq_config.build_device_irq = sun4d_build_device_irq;
+	sparc_config.init_timers      = sun4d_init_timers;
+	sparc_config.build_device_irq = sun4d_build_device_irq;
 
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);

commit 9eeb08986f41c0740306f6f56cf04e619e2fe525
Author: oftedal <oftedal@gmail.com>
Date:   Wed Jun 1 11:11:41 2011 +0000

    Add support for allocating irqs for bootbus devices
    
    Some devices that can generate interrupts are connected directly to the
    CPU through the bootbus on sun4d. This patch allows IRQs to be allocated
    for such devices. The information used for allocating interrupts for
    sbus devices are present at the corresponding SBI node. For bootbus
    devices this information is present in the bootbus node.
    
    Signed-off-by: Kjetil Oftedal <oftedal@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index eaec8a90fb9f..1d13c5bda0b1 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -334,7 +334,8 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
                                     unsigned int real_irq)
 {
 	struct device_node *dp = op->dev.of_node;
-	struct device_node *io_unit, *sbi = dp->parent;
+	struct device_node *board_parent, *bus = dp->parent;
+	char *bus_connection;
 	const struct linux_prom_registers *regs;
 	unsigned int pil;
 	unsigned int irq;
@@ -342,13 +343,20 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
 	int sbusl;
 
 	irq = real_irq;
-	while (sbi) {
-		if (!strcmp(sbi->name, "sbi"))
+	while (bus) {
+		if (!strcmp(bus->name, "sbi")) {
+			bus_connection = "io-unit";
 			break;
+		}
+
+		if (!strcmp(bus->name, "bootbus")) {
+			bus_connection = "cpu-unit";
+			break;
+		}
 
-		sbi = sbi->parent;
+		bus = bus->parent;
 	}
-	if (!sbi)
+	if (!bus)
 		goto err_out;
 
 	regs = of_get_property(dp, "reg", NULL);
@@ -358,17 +366,19 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
 	slot = regs->which_io;
 
 	/*
-	 *  If SBI's parent is not io-unit or the io-unit lacks
-	 * a "board#" property, something is very wrong.
+	 * If Bus nodes parent is not io-unit/cpu-unit or the io-unit/cpu-unit
+	 * lacks a "board#" property, something is very wrong.
 	 */
-	if (!sbi->parent || strcmp(sbi->parent->name, "io-unit")) {
-		printk("%s: Error, parent is not io-unit.\n", sbi->full_name);
+	if (!bus->parent || strcmp(bus->parent->name, bus_connection)) {
+		printk(KERN_ERR "%s: Error, parent is not %s.\n",
+			bus->full_name, bus_connection);
 		goto err_out;
 	}
-	io_unit = sbi->parent;
-	board = of_getintprop_default(io_unit, "board#", -1);
+	board_parent = bus->parent;
+	board = of_getintprop_default(board_parent, "board#", -1);
 	if (board == -1) {
-		printk("%s: Error, lacks board# property.\n", io_unit->full_name);
+		printk(KERN_ERR "%s: Error, lacks board# property.\n",
+			board_parent->full_name);
 		goto err_out;
 	}
 

commit ea160584574e345495e75ee4a7d3a7dbcad9e16c
Author: oftedal <oftedal@gmail.com>
Date:   Wed Jun 1 11:04:20 2011 +0000

    Do not skip interrupt sources in sun4d interrupt handler and acknowledge interrupts correctly
    
    During the introduction of genirq on sparc32 bugs were introduced in
    the interrupt handler for sun4d. The interrupts handler checks the status
    of the various sbus interfaces in the system and generates a virtual
    interrupt, based upon the location of the interrupt source. This lookup
    was broken by restructuring the code in such a way that index and shift
    operations were performed prior to comparing this against the values
    read from the interrupt controllers.
    
    This could cause the handler to loop eternally as the interrupt source
    could be skipped before any check was performed. Additionally
    sun4d_encode_irq performs shifting internally, so it should not be performed
    twice.
    
    In sun4d_unmask interrupts were not correctly acknowledged, as the
    corresponding bit it the interrupt mask was not actually cleared.
    
    Signed-off-by: Kjetil Oftedal <oftedal@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 487c1bb374f5..eaec8a90fb9f 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -103,10 +103,9 @@ static void sun4d_sbus_handler_irq(int sbusl)
 
 	sbil = (sbusl << 2);
 	/* Loop for each pending SBI */
-	for (sbino = 0; bus_mask; sbino++) {
+	for (sbino = 0; bus_mask; sbino++, bus_mask >>= 1) {
 		unsigned int idx, mask;
 
-		bus_mask >>= 1;
 		if (!(bus_mask & 1))
 			continue;
 		/* XXX This seems to ACK the irq twice.  acquire_sbi()
@@ -118,19 +117,16 @@ static void sun4d_sbus_handler_irq(int sbusl)
 		mask &= (0xf << sbil);
 
 		/* Loop for each pending SBI slot */
-		idx = 0;
 		slot = (1 << sbil);
-		while (mask != 0) {
+		for (idx = 0; mask != 0; idx++, slot <<= 1) {
 			unsigned int pil;
 			struct irq_bucket *p;
 
-			idx++;
-			slot <<= 1;
 			if (!(mask & slot))
 				continue;
 
 			mask &= ~slot;
-			pil = sun4d_encode_irq(sbino, sbil, idx);
+			pil = sun4d_encode_irq(sbino, sbusl, idx);
 
 			p = irq_map[pil];
 			while (p) {
@@ -218,10 +214,10 @@ static void sun4d_unmask_irq(struct irq_data *data)
 
 #ifdef CONFIG_SMP
 	spin_lock_irqsave(&sun4d_imsk_lock, flags);
-	cc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) | ~(1 << real_irq));
+	cc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) & ~(1 << real_irq));
 	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
 #else
-	cc_set_imsk(cc_get_imsk() | ~(1 << real_irq));
+	cc_set_imsk(cc_get_imsk() & ~(1 << real_irq));
 #endif
 }
 

commit 5fba17084e5d1b00bf24e17b2b580cfa7705e7be
Author: oftedal <oftedal@gmail.com>
Date:   Wed Jun 1 10:43:50 2011 +0000

    Restructure sun4d_build_device_irq so that timer interrupts can be allocated
    
    sun4d_build_device_irq was called without a valid platform_device when
    the system timer was initialized on sun4d systems. This caused a NULL
    pointer crash.
    
    Josip Rodin suggested that the current sun4d_build_device_irq should be
    split into two functions. So that the timer initialization could skip
    the slot and sbus interface detection code in sun4d_build_device_irq, as
    this does not make sence due to the timer interrupts not being generated
    from a device located on sbus.
    
    Signed-off-by: Kjetil Oftedal <oftedal@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index a9ea60eb2c10..487c1bb374f5 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -299,19 +299,53 @@ static void __init sun4d_load_profile_irqs(void)
 	}
 }
 
+unsigned int _sun4d_build_device_irq(unsigned int real_irq,
+                                     unsigned int pil,
+                                     unsigned int board)
+{
+	struct sun4d_handler_data *handler_data;
+	unsigned int irq;
+
+	irq = irq_alloc(real_irq, pil);
+	if (irq == 0) {
+		prom_printf("IRQ: allocate for %d %d %d failed\n",
+			real_irq, pil, board);
+		goto err_out;
+	}
+
+	handler_data = irq_get_handler_data(irq);
+	if (unlikely(handler_data))
+		goto err_out;
+
+	handler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);
+	if (unlikely(!handler_data)) {
+		prom_printf("IRQ: kzalloc(sun4d_handler_data) failed.\n");
+		prom_halt();
+	}
+	handler_data->cpuid    = board_to_cpu[board];
+	handler_data->real_irq = real_irq;
+	irq_set_chip_and_handler_name(irq, &sun4d_irq,
+	                              handle_level_irq, "level");
+	irq_set_handler_data(irq, handler_data);
+
+err_out:
+	return irq;
+}
+
+
+
 unsigned int sun4d_build_device_irq(struct platform_device *op,
                                     unsigned int real_irq)
 {
 	struct device_node *dp = op->dev.of_node;
 	struct device_node *io_unit, *sbi = dp->parent;
 	const struct linux_prom_registers *regs;
-	struct sun4d_handler_data *handler_data;
 	unsigned int pil;
 	unsigned int irq;
 	int board, slot;
 	int sbusl;
 
-	irq = 0;
+	irq = real_irq;
 	while (sbi) {
 		if (!strcmp(sbi->name, "sbi"))
 			break;
@@ -348,29 +382,17 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
 	else
 		pil = real_irq;
 
-	irq = irq_alloc(real_irq, pil);
-	if (irq == 0)
-		goto err_out;
-
-	handler_data = irq_get_handler_data(irq);
-	if (unlikely(handler_data))
-		goto err_out;
-
-	handler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);
-	if (unlikely(!handler_data)) {
-		prom_printf("IRQ: kzalloc(sun4d_handler_data) failed.\n");
-		prom_halt();
-	}
-	handler_data->cpuid    = board_to_cpu[board];
-	handler_data->real_irq = real_irq;
-	irq_set_chip_and_handler_name(irq, &sun4d_irq,
-	                              handle_level_irq, "level");
-	irq_set_handler_data(irq, handler_data);
-
+	irq = _sun4d_build_device_irq(real_irq, pil, board);
 err_out:
-	return real_irq;
+	return irq;
 }
 
+unsigned int sun4d_build_timer_irq(unsigned int board, unsigned int real_irq)
+{
+	return _sun4d_build_device_irq(real_irq, real_irq, board);
+}
+
+
 static void __init sun4d_fixup_trap_table(void)
 {
 #ifdef CONFIG_SMP
@@ -402,6 +424,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 	unsigned int irq;
 	const u32 *reg;
 	int err;
+	int board;
 
 	dp = of_find_node_by_name(NULL, "cpu-unit");
 	if (!dp) {
@@ -414,12 +437,19 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 	 * bootbus.
 	 */
 	reg = of_get_property(dp, "reg", NULL);
-	of_node_put(dp);
 	if (!reg) {
 		prom_printf("sun4d_init_timers: No reg property\n");
 		prom_halt();
 	}
 
+	board = of_getintprop_default(dp, "board#", -1);
+	if (board == -1) {
+		prom_printf("sun4d_init_timers: No board# property on cpu-unit\n");
+		prom_halt();
+	}
+
+	of_node_put(dp);
+
 	res.start = reg[1];
 	res.end = reg[2] - 1;
 	res.flags = reg[0] & 0xff;
@@ -434,7 +464,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 
 	master_l10_counter = &sun4d_timers->l10_cur_count;
 
-	irq = sun4d_build_device_irq(NULL, SUN4D_TIMER_IRQ);
+	irq = sun4d_build_timer_irq(board, SUN4D_TIMER_IRQ);
 	err = request_irq(irq, counter_fn, IRQF_TIMER, "timer", NULL);
 	if (err) {
 		prom_printf("sun4d_init_timers: request_irq() failed with %d\n",

commit 55dd23eca666876e6028aa35d5e391cfced54871
Author: Daniel Hellstrom <daniel@gaisler.com>
Date:   Mon May 2 00:08:54 2011 +0000

    sparc32, sun4d: Implemented SMP IPIs support for SUN4D machines
    
    The sun4d does not seem to have a distingstion between soft and hard
    IRQs. When generating IPIs the generated IRQ looks like a hard IRQ,
    this patch adds a "IPI check" in the sun4d irq trap handler at a
    predefined IRQ number (SUN4D_IPI_IRQ). Before generating an IPI
    a per-cpu memory structure is modified for the "IPI check" to
    successfully detect a IPI request to a specific processor, the check
    clears the IPI work requested.
    
    All three IPIs (resched, single and cpu-mask) use the same IRQ
    number.
    
    The IPI IRQ should preferrably be on a separate IRQ and definitly
    not shared with IRQ handlers requesting IRQ with IRQF_SHARED.
    
    Signed-off-by: Daniel Hellstrom <daniel@gaisler.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index b830914e32d3..a9ea60eb2c10 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -156,6 +156,15 @@ void sun4d_handler_irq(int pil, struct pt_regs *regs)
 
 	cc_set_iclr(1 << pil);
 
+#ifdef CONFIG_SMP
+	/*
+	 * Check IPI data structures after IRQ has been cleared. Hard and Soft
+	 * IRQ can happen at the same time, so both cases are always handled.
+	 */
+	if (pil == SUN4D_IPI_IRQ)
+		sun4d_ipi_interrupt();
+#endif
+
 	old_regs = set_irq_regs(regs);
 	irq_enter();
 	if (sbusl == 0) {

commit 5fcafb7a23e35b2f1a5243f4dd536240f52c8ceb
Author: Daniel Hellstrom <daniel@gaisler.com>
Date:   Thu Apr 21 04:20:23 2011 +0000

    sparc32: always define boot_cpu_id
    
    Define boot_cpu_id in single-processor kernels as well. This is
    to support architectures which can boot on other than CPU0.
    
    Sam Ravnborg has written the cleanup parts by extracting
    boot_cpu_id from smp_32.c into setup_32.c and cleaned up
    sun4d_irq.c.
    
    boot_cpu_id was initialized before BSS was cleared in
    sun4c_continue_boot, instead boot_cpu_id is set to 0xff to
    avoid BSS. If boot_cpu_id is untouched (0xff) by bootup code
    it will be overwritten to 0. boot_cpu_id4 is automatically
    calculated in common code.
    
    Signed-off-by: Daniel Hellstrom <daniel@gaisler.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 14a043531dcb..b830914e32d3 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -14,6 +14,7 @@
 #include <asm/io.h>
 #include <asm/sbi.h>
 #include <asm/cacheflush.h>
+#include <asm/setup.h>
 
 #include "kernel.h"
 #include "irq.h"
@@ -438,11 +439,9 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 void __init sun4d_init_sbi_irq(void)
 {
 	struct device_node *dp;
-	int target_cpu = 0;
+	int target_cpu;
 
-#ifdef CONFIG_SMP
 	target_cpu = boot_cpu_id;
-#endif
 	for_each_node_by_name(dp, "sbi") {
 		int devid = of_getintprop_default(dp, "device-id", 0);
 		int board = of_getintprop_default(dp, "board#", 0);

commit 6baa9b20a68a88c2fd751cbe8d7652009379351b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Apr 18 11:25:44 2011 +0000

    sparc32: genirq support
    
    The conversion of sparc32 to genirq is based on original work done
    by David S. Miller.
    Daniel Hellstrom has helped in the conversion and implemented
    the shutdowm functionality.
    Marcel van Nies <morcles@gmail.com> has tested this on Sparc Station 20
    
    Test status:
    sun4c      - not tested
    sun4m,pci  - not tested
    sun4m,sbus - tested (Sparc Classic, Sparc Station 5, Sparc Station 20)
    sun4d      - not tested
    leon       - tested on various combinations of leon boards,
                 including SMP variants
    
    generic
       Introduce use of GENERIC_HARDIRQS and GENERIC_IRQ_SHOW
       Allocate 64 IRQs - which is enough even for SS2000
       Use a table of irq_bucket to maintain uses IRQs
          irq_bucket is also used to chain several irq's that
          must be called when the same intrrupt is asserted
       Use irq_link to link a interrupt source to the irq
       All plafforms must now supply their own build_device_irq method
       handler_irq rewriten to use generic irq support
    
    floppy
       Read FLOPPY_IRQ from platform device
       Use generic request_irq to register the floppy interrupt
       Rewrote sparc_floppy_irq to use the generic irq support
    
    pcic:
       Introduce irq_chip
       Store mask in chip_data for use in mask/unmask functions
       Add build_device_irq for pcic
       Use pcic_build_device_irq in pci_time_init
       allocate virtual irqs in pcic_fill_irq
    
    sun4c:
       Introduce irq_chip
       Store mask in chip_data for use in mask/unmask functions
       Add build_device_irq for sun4c
       Use sun4c_build_device_irq in sun4c_init_timers
    
    sun4m:
       Introduce irq_chip
       Introduce dedicated mask/unmask methods
       Introduce sun4m_handler_data that allow easy access to necessary
         data in the mask/unmask functions
       Add a helper method to enable profile_timer (used from smp)
       Added sun4m_build_device_irq
       Use sun4m_build_device_irq in sun4m_init_timers
    
       TODO:
          There is no replacement for smp_rotate that always scheduled
          next CPU as interrupt target upon an interrupt
    
    sun4d:
       Introduce irq_chip
       Introduce dedicated mask/unmask methods
       Introduce sun4d_handler_data that allow easy access to
       necessary data in mask/unmask fuctions
       Rewrote sun4d_handler_irq to use generic irq support
    
       TODO:
          The original implmentation of enable/disable had:
    
              if (irq < NR_IRQS)
                   return;
    
          The new implmentation does not distingush between SBUS and cpu
          interrupts.
          I am no sure what is right here. I assume we need to do
          something for the cpu interrupts.
    
          I have not succeeded booting my sun4d box (with or without this patch)
          and my understanding of this platfrom is limited.
          So I would be a bit suprised if this works.
    
    leon:
       Introduce irq_chip
       Store mask in chip_data for use in mask/unmask functions
       Add build_device_irq for leon
       Use leon_build_device_irq in leon_init_timers
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Daniel Hellstrom <daniel@gaisler.com>
    Tested-by: Daniel Hellstrom <daniel@gaisler.com>
    Tested-by: Marcel van Nies <morcles@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index ee35c45ffb89..14a043531dcb 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -22,22 +22,20 @@
  * cpu local.  CPU local interrupts cover the timer interrupts
  * and whatnot, and we encode those as normal PILs between
  * 0 and 15.
- *
- * SBUS interrupts are encoded integers including the board number
- * (plus one), the SBUS level, and the SBUS slot number.  Sun4D
- * IRQ dispatch is done by:
- *
- * 1) Reading the BW local interrupt table in order to get the bus
- *    interrupt mask.
- *
- *    This table is indexed by SBUS interrupt level which can be
- *    derived from the PIL we got interrupted on.
- *
- * 2) For each bus showing interrupt pending from #1, read the
- *    SBI interrupt state register.  This will indicate which slots
- *    have interrupts pending for that SBUS interrupt level.
+ * SBUS interrupts are encodes as a combination of board, level and slot.
  */
 
+struct sun4d_handler_data {
+	unsigned int cpuid;    /* target cpu */
+	unsigned int real_irq; /* interrupt level */
+};
+
+
+static unsigned int sun4d_encode_irq(int board, int lvl, int slot)
+{
+	return (board + 1) << 5 | (lvl << 2) | slot;
+}
+
 struct sun4d_timer_regs {
 	u32	l10_timer_limit;
 	u32	l10_cur_countx;
@@ -48,22 +46,13 @@ struct sun4d_timer_regs {
 
 static struct sun4d_timer_regs __iomem *sun4d_timers;
 
-#define TIMER_IRQ	10
-
-#define MAX_STATIC_ALLOC	4
+#define SUN4D_TIMER_IRQ        10
 
 /* Specify which cpu handle interrupts from which board.
  * Index is board - value is cpu.
  */
 static unsigned char board_to_cpu[32];
 
-static struct irqaction *irq_action[NR_IRQS];
-
-static struct sbus_action {
-	struct irqaction *action;
-	/* For SMP this needs to be extended */
-} *sbus_actions;
-
 static int pil_to_sbus[] = {
 	0,
 	0,
@@ -83,152 +72,81 @@ static int pil_to_sbus[] = {
 	0,
 };
 
-static int sbus_to_pil[] = {
-	0,
-	2,
-	3,
-	5,
-	7,
-	9,
-	11,
-	13,
-};
-
-static int nsbi;
-
 /* Exported for sun4d_smp.c */
 DEFINE_SPINLOCK(sun4d_imsk_lock);
 
-int show_sun4d_interrupts(struct seq_file *p, void *v)
+/* SBUS interrupts are encoded integers including the board number
+ * (plus one), the SBUS level, and the SBUS slot number.  Sun4D
+ * IRQ dispatch is done by:
+ *
+ * 1) Reading the BW local interrupt table in order to get the bus
+ *    interrupt mask.
+ *
+ *    This table is indexed by SBUS interrupt level which can be
+ *    derived from the PIL we got interrupted on.
+ *
+ * 2) For each bus showing interrupt pending from #1, read the
+ *    SBI interrupt state register.  This will indicate which slots
+ *    have interrupts pending for that SBUS interrupt level.
+ *
+ * 3) Call the genreric IRQ support.
+ */
+static void sun4d_sbus_handler_irq(int sbusl)
 {
-	int i = *(loff_t *) v, j = 0, k = 0, sbusl;
-	struct irqaction *action;
-	unsigned long flags;
-#ifdef CONFIG_SMP
-	int x;
-#endif
-
-	spin_lock_irqsave(&irq_action_lock, flags);
-	if (i < NR_IRQS) {
-		sbusl = pil_to_sbus[i];
-		if (!sbusl) {
-			action = *(i + irq_action);
-			if (!action)
-				goto out_unlock;
-		} else {
-			for (j = 0; j < nsbi; j++) {
-				for (k = 0; k < 4; k++)
-					action = sbus_actions[(j << 5) + (sbusl << 2) + k].action;
-					if (action)
-						goto found_it;
-			}
-			goto out_unlock;
-		}
-found_it:	seq_printf(p, "%3d: ", i);
-#ifndef CONFIG_SMP
-		seq_printf(p, "%10u ", kstat_irqs(i));
-#else
-		for_each_online_cpu(x)
-			seq_printf(p, "%10u ",
-			       kstat_cpu(cpu_logical_map(x)).irqs[i]);
-#endif
-		seq_printf(p, "%c %s",
-			(action->flags & IRQF_DISABLED) ? '+' : ' ',
-			action->name);
-		action = action->next;
-		for (;;) {
-			for (; action; action = action->next) {
-				seq_printf(p, ",%s %s",
-					(action->flags & IRQF_DISABLED) ? " +" : "",
-					action->name);
-			}
-			if (!sbusl)
-				break;
-			k++;
-			if (k < 4) {
-				action = sbus_actions[(j << 5) + (sbusl << 2) + k].action;
-			} else {
-				j++;
-				if (j == nsbi)
-					break;
-				k = 0;
-				action = sbus_actions[(j << 5) + (sbusl << 2)].action;
+	unsigned int bus_mask;
+	unsigned int sbino, slot;
+	unsigned int sbil;
+
+	bus_mask = bw_get_intr_mask(sbusl) & 0x3ffff;
+	bw_clear_intr_mask(sbusl, bus_mask);
+
+	sbil = (sbusl << 2);
+	/* Loop for each pending SBI */
+	for (sbino = 0; bus_mask; sbino++) {
+		unsigned int idx, mask;
+
+		bus_mask >>= 1;
+		if (!(bus_mask & 1))
+			continue;
+		/* XXX This seems to ACK the irq twice.  acquire_sbi()
+		 * XXX uses swap, therefore this writes 0xf << sbil,
+		 * XXX then later release_sbi() will write the individual
+		 * XXX bits which were set again.
+		 */
+		mask = acquire_sbi(SBI2DEVID(sbino), 0xf << sbil);
+		mask &= (0xf << sbil);
+
+		/* Loop for each pending SBI slot */
+		idx = 0;
+		slot = (1 << sbil);
+		while (mask != 0) {
+			unsigned int pil;
+			struct irq_bucket *p;
+
+			idx++;
+			slot <<= 1;
+			if (!(mask & slot))
+				continue;
+
+			mask &= ~slot;
+			pil = sun4d_encode_irq(sbino, sbil, idx);
+
+			p = irq_map[pil];
+			while (p) {
+				struct irq_bucket *next;
+
+				next = p->next;
+				generic_handle_irq(p->irq);
+				p = next;
 			}
+			release_sbi(SBI2DEVID(sbino), slot);
 		}
-		seq_putc(p, '\n');
-	}
-out_unlock:
-	spin_unlock_irqrestore(&irq_action_lock, flags);
-	return 0;
-}
-
-void sun4d_free_irq(unsigned int irq, void *dev_id)
-{
-	struct irqaction *action, **actionp;
-	struct irqaction *tmp = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&irq_action_lock, flags);
-	if (irq < 15)
-		actionp = irq + irq_action;
-	else
-		actionp = &(sbus_actions[irq - (1 << 5)].action);
-	action = *actionp;
-	if (!action) {
-		printk(KERN_ERR "Trying to free free IRQ%d\n", irq);
-		goto out_unlock;
-	}
-	if (dev_id) {
-		for (; action; action = action->next) {
-			if (action->dev_id == dev_id)
-				break;
-			tmp = action;
-		}
-		if (!action) {
-			printk(KERN_ERR "Trying to free free shared IRQ%d\n",
-			       irq);
-			goto out_unlock;
-		}
-	} else if (action->flags & IRQF_SHARED) {
-		printk(KERN_ERR "Trying to free shared IRQ%d with NULL device ID\n",
-		       irq);
-		goto out_unlock;
-	}
-	if (action->flags & SA_STATIC_ALLOC) {
-		/*
-		 * This interrupt is marked as specially allocated
-		 * so it is a bad idea to free it.
-		 */
-		printk(KERN_ERR "Attempt to free statically allocated IRQ%d (%s)\n",
-		       irq, action->name);
-		goto out_unlock;
 	}
-
-	if (tmp)
-		tmp->next = action->next;
-	else
-		*actionp = action->next;
-
-	spin_unlock_irqrestore(&irq_action_lock, flags);
-
-	synchronize_irq(irq);
-
-	spin_lock_irqsave(&irq_action_lock, flags);
-
-	kfree(action);
-
-	if (!(*actionp))
-		__disable_irq(irq);
-
-out_unlock:
-	spin_unlock_irqrestore(&irq_action_lock, flags);
 }
 
 void sun4d_handler_irq(int pil, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs;
-	struct irqaction *action;
-	int cpu = smp_processor_id();
 	/* SBUS IRQ level (1 - 7) */
 	int sbusl = pil_to_sbus[pil];
 
@@ -239,158 +157,85 @@ void sun4d_handler_irq(int pil, struct pt_regs *regs)
 
 	old_regs = set_irq_regs(regs);
 	irq_enter();
-	kstat_cpu(cpu).irqs[pil]++;
-	if (!sbusl) {
-		action = *(pil + irq_action);
-		if (!action)
-			unexpected_irq(pil, NULL, regs);
-		do {
-			action->handler(pil, action->dev_id);
-			action = action->next;
-		} while (action);
+	if (sbusl == 0) {
+		/* cpu interrupt */
+		struct irq_bucket *p;
+
+		p = irq_map[pil];
+		while (p) {
+			struct irq_bucket *next;
+
+			next = p->next;
+			generic_handle_irq(p->irq);
+			p = next;
+		}
 	} else {
-		int bus_mask = bw_get_intr_mask(sbusl) & 0x3ffff;
-		int sbino;
-		struct sbus_action *actionp;
-		unsigned mask, slot;
-		int sbil = (sbusl << 2);
-
-		bw_clear_intr_mask(sbusl, bus_mask);
-
-		/* Loop for each pending SBI */
-		for (sbino = 0; bus_mask; sbino++, bus_mask >>= 1)
-			if (bus_mask & 1) {
-				mask = acquire_sbi(SBI2DEVID(sbino), 0xf << sbil);
-				mask &= (0xf << sbil);
-				actionp = sbus_actions + (sbino << 5) + (sbil);
-				/* Loop for each pending SBI slot */
-				for (slot = (1 << sbil); mask; slot <<= 1, actionp++)
-					if (mask & slot) {
-						mask &= ~slot;
-						action = actionp->action;
-
-						if (!action)
-							unexpected_irq(pil, NULL, regs);
-						do {
-							action->handler(pil, action->dev_id);
-							action = action->next;
-						} while (action);
-						release_sbi(SBI2DEVID(sbino), slot);
-					}
-			}
+		/* SBUS interrupt */
+		sun4d_sbus_handler_irq(sbusl);
 	}
 	irq_exit();
 	set_irq_regs(old_regs);
 }
 
-int sun4d_request_irq(unsigned int irq,
-		irq_handler_t handler,
-		unsigned long irqflags, const char *devname, void *dev_id)
+
+static void sun4d_mask_irq(struct irq_data *data)
 {
-	struct irqaction *action, *tmp = NULL, **actionp;
+	struct sun4d_handler_data *handler_data = data->handler_data;
+	unsigned int real_irq;
+#ifdef CONFIG_SMP
+	int cpuid = handler_data->cpuid;
 	unsigned long flags;
-	int ret;
-
-	if (irq > 14 && irq < (1 << 5)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (!handler) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	spin_lock_irqsave(&irq_action_lock, flags);
-
-	if (irq >= (1 << 5))
-		actionp = &(sbus_actions[irq - (1 << 5)].action);
-	else
-		actionp = irq + irq_action;
-	action = *actionp;
-
-	if (action) {
-		if ((action->flags & IRQF_SHARED) && (irqflags & IRQF_SHARED)) {
-			for (tmp = action; tmp->next; tmp = tmp->next)
-				/* find last entry - tmp used below */;
-		} else {
-			ret = -EBUSY;
-			goto out_unlock;
-		}
-		if ((action->flags & IRQF_DISABLED) ^ (irqflags & IRQF_DISABLED)) {
-			printk(KERN_ERR "Attempt to mix fast and slow interrupts on IRQ%d denied\n",
-			       irq);
-			ret = -EBUSY;
-			goto out_unlock;
-		}
-		action = NULL;		/* Or else! */
-	}
-
-	/* If this is flagged as statically allocated then we use our
-	 * private struct which is never freed.
-	 */
-	if (irqflags & SA_STATIC_ALLOC) {
-		if (static_irq_count < MAX_STATIC_ALLOC)
-			action = &static_irqaction[static_irq_count++];
-		else
-			printk(KERN_ERR "Request for IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc\n",
-			       irq, devname);
-	}
-
-	if (action == NULL)
-		action = kmalloc(sizeof(struct irqaction), GFP_ATOMIC);
-
-	if (!action) {
-		ret = -ENOMEM;
-		goto out_unlock;
-	}
-
-	action->handler = handler;
-	action->flags = irqflags;
-	action->name = devname;
-	action->next = NULL;
-	action->dev_id = dev_id;
-
-	if (tmp)
-		tmp->next = action;
-	else
-		*actionp = action;
-
-	__enable_irq(irq);
-
-	ret = 0;
-out_unlock:
-	spin_unlock_irqrestore(&irq_action_lock, flags);
-out:
-	return ret;
+#endif
+	real_irq = handler_data->real_irq;
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&sun4d_imsk_lock, flags);
+	cc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) | (1 << real_irq));
+	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
+#else
+	cc_set_imsk(cc_get_imsk() | (1 << real_irq));
+#endif
 }
 
-static void sun4d_disable_irq(unsigned int irq)
+static void sun4d_unmask_irq(struct irq_data *data)
 {
-	int tid = board_to_cpu[(irq >> 5) - 1];
+	struct sun4d_handler_data *handler_data = data->handler_data;
+	unsigned int real_irq;
+#ifdef CONFIG_SMP
+	int cpuid = handler_data->cpuid;
 	unsigned long flags;
+#endif
+	real_irq = handler_data->real_irq;
 
-	if (irq < NR_IRQS)
-		return;
-
+#ifdef CONFIG_SMP
 	spin_lock_irqsave(&sun4d_imsk_lock, flags);
-	cc_set_imsk_other(tid, cc_get_imsk_other(tid) | (1 << sbus_to_pil[(irq >> 2) & 7]));
+	cc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) | ~(1 << real_irq));
 	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
+#else
+	cc_set_imsk(cc_get_imsk() | ~(1 << real_irq));
+#endif
 }
 
-static void sun4d_enable_irq(unsigned int irq)
+static unsigned int sun4d_startup_irq(struct irq_data *data)
 {
-	int tid = board_to_cpu[(irq >> 5) - 1];
-	unsigned long flags;
-
-	if (irq < NR_IRQS)
-		return;
+	irq_link(data->irq);
+	sun4d_unmask_irq(data);
+	return 0;
+}
 
-	spin_lock_irqsave(&sun4d_imsk_lock, flags);
-	cc_set_imsk_other(tid, cc_get_imsk_other(tid) & ~(1 << sbus_to_pil[(irq >> 2) & 7]));
-	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
+static void sun4d_shutdown_irq(struct irq_data *data)
+{
+	sun4d_mask_irq(data);
+	irq_unlink(data->irq);
 }
 
+struct irq_chip sun4d_irq = {
+	.name		= "sun4d",
+	.irq_startup	= sun4d_startup_irq,
+	.irq_shutdown	= sun4d_shutdown_irq,
+	.irq_unmask	= sun4d_unmask_irq,
+	.irq_mask	= sun4d_mask_irq,
+};
+
 #ifdef CONFIG_SMP
 static void sun4d_set_cpu_int(int cpu, int level)
 {
@@ -447,15 +292,16 @@ static void __init sun4d_load_profile_irqs(void)
 unsigned int sun4d_build_device_irq(struct platform_device *op,
                                     unsigned int real_irq)
 {
-	static int pil_to_sbus[] = {
-		0, 0, 1, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 0,
-	};
 	struct device_node *dp = op->dev.of_node;
 	struct device_node *io_unit, *sbi = dp->parent;
 	const struct linux_prom_registers *regs;
+	struct sun4d_handler_data *handler_data;
+	unsigned int pil;
+	unsigned int irq;
 	int board, slot;
 	int sbusl;
 
+	irq = 0;
 	while (sbi) {
 		if (!strcmp(sbi->name, "sbi"))
 			break;
@@ -488,7 +334,28 @@ unsigned int sun4d_build_device_irq(struct platform_device *op,
 
 	sbusl = pil_to_sbus[real_irq];
 	if (sbusl)
-		return (((board + 1) << 5) + (sbusl << 2) + slot);
+		pil = sun4d_encode_irq(board, sbusl, slot);
+	else
+		pil = real_irq;
+
+	irq = irq_alloc(real_irq, pil);
+	if (irq == 0)
+		goto err_out;
+
+	handler_data = irq_get_handler_data(irq);
+	if (unlikely(handler_data))
+		goto err_out;
+
+	handler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);
+	if (unlikely(!handler_data)) {
+		prom_printf("IRQ: kzalloc(sun4d_handler_data) failed.\n");
+		prom_halt();
+	}
+	handler_data->cpuid    = board_to_cpu[board];
+	handler_data->real_irq = real_irq;
+	irq_set_chip_and_handler_name(irq, &sun4d_irq,
+	                              handle_level_irq, "level");
+	irq_set_handler_data(irq, handler_data);
 
 err_out:
 	return real_irq;
@@ -522,6 +389,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 {
 	struct device_node *dp;
 	struct resource res;
+	unsigned int irq;
 	const u32 *reg;
 	int err;
 
@@ -556,9 +424,8 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 
 	master_l10_counter = &sun4d_timers->l10_cur_count;
 
-	err = request_irq(TIMER_IRQ, counter_fn,
-			  (IRQF_DISABLED | SA_STATIC_ALLOC),
-			  "timer", NULL);
+	irq = sun4d_build_device_irq(NULL, SUN4D_TIMER_IRQ);
+	err = request_irq(irq, counter_fn, IRQF_TIMER, "timer", NULL);
 	if (err) {
 		prom_printf("sun4d_init_timers: request_irq() failed with %d\n",
 		             err);
@@ -576,15 +443,6 @@ void __init sun4d_init_sbi_irq(void)
 #ifdef CONFIG_SMP
 	target_cpu = boot_cpu_id;
 #endif
-
-	nsbi = 0;
-	for_each_node_by_name(dp, "sbi")
-		nsbi++;
-	sbus_actions = kzalloc(nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
-	if (!sbus_actions) {
-		prom_printf("SUN4D: Cannot allocate sbus_actions, halting.\n");
-		prom_halt();
-	}
 	for_each_node_by_name(dp, "sbi") {
 		int devid = of_getintprop_default(dp, "device-id", 0);
 		int board = of_getintprop_default(dp, "board#", 0);
@@ -607,12 +465,10 @@ void __init sun4d_init_IRQ(void)
 {
 	local_irq_disable();
 
-	BTFIXUPSET_CALL(enable_irq, sun4d_enable_irq, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(disable_irq, sun4d_disable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
 
-	sparc_irq_config.init_timers = sun4d_init_timers;
+	sparc_irq_config.init_timers      = sun4d_init_timers;
 	sparc_irq_config.build_device_irq = sun4d_build_device_irq;
 
 #ifdef CONFIG_SMP

commit db1cdd146a0814b6f312fe1a7fa1ab87ac177b2a
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Apr 18 11:25:42 2011 +0000

    sparc32,sun4d: rename sbus_tid to board_to_cpu in irq support
    
    The new name reflects the actual usage much better.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 77b4a8992710..ee35c45ffb89 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -51,7 +51,11 @@ static struct sun4d_timer_regs __iomem *sun4d_timers;
 #define TIMER_IRQ	10
 
 #define MAX_STATIC_ALLOC	4
-static unsigned char sbus_tid[32];
+
+/* Specify which cpu handle interrupts from which board.
+ * Index is board - value is cpu.
+ */
+static unsigned char board_to_cpu[32];
 
 static struct irqaction *irq_action[NR_IRQS];
 
@@ -363,7 +367,7 @@ int sun4d_request_irq(unsigned int irq,
 
 static void sun4d_disable_irq(unsigned int irq)
 {
-	int tid = sbus_tid[(irq >> 5) - 1];
+	int tid = board_to_cpu[(irq >> 5) - 1];
 	unsigned long flags;
 
 	if (irq < NR_IRQS)
@@ -376,7 +380,7 @@ static void sun4d_disable_irq(unsigned int irq)
 
 static void sun4d_enable_irq(unsigned int irq)
 {
-	int tid = sbus_tid[(irq >> 5) - 1];
+	int tid = board_to_cpu[(irq >> 5) - 1];
 	unsigned long flags;
 
 	if (irq < NR_IRQS)
@@ -413,7 +417,7 @@ void __init sun4d_distribute_irqs(void)
 	for_each_node_by_name(dp, "sbi") {
 		int devid = of_getintprop_default(dp, "device-id", 0);
 		int board = of_getintprop_default(dp, "board#", 0);
-		sbus_tid[board] = cpuid;
+		board_to_cpu[board] = cpuid;
 		set_sbi_tid(devid, cpuid << 3);
 	}
 	printk(KERN_ERR "All sbus IRQs directed to CPU%d\n", cpuid);
@@ -587,7 +591,7 @@ void __init sun4d_init_sbi_irq(void)
 		unsigned int mask;
 
 		set_sbi_tid(devid, target_cpu << 3);
-		sbus_tid[board] = target_cpu;
+		board_to_cpu[board] = target_cpu;
 
 		/* Get rid of pending irqs from PROM */
 		mask = acquire_sbi(devid, 0xffffffff);

commit 1d05995b0880b23353741d5b2b826f7c2fd6a296
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Feb 25 23:01:19 2011 -0800

    sparc32: introduce build_device_irq
    
    build_device_irq() is used to encapsulate the plaform
    specific details when we build an irq.
    For now the default is a simple 1:1 but sun4d differs.
    This patch refactors functionality - but does not change
    the existing functionality.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index fc1c22f121fd..77b4a8992710 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -440,6 +440,56 @@ static void __init sun4d_load_profile_irqs(void)
 	}
 }
 
+unsigned int sun4d_build_device_irq(struct platform_device *op,
+                                    unsigned int real_irq)
+{
+	static int pil_to_sbus[] = {
+		0, 0, 1, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 0,
+	};
+	struct device_node *dp = op->dev.of_node;
+	struct device_node *io_unit, *sbi = dp->parent;
+	const struct linux_prom_registers *regs;
+	int board, slot;
+	int sbusl;
+
+	while (sbi) {
+		if (!strcmp(sbi->name, "sbi"))
+			break;
+
+		sbi = sbi->parent;
+	}
+	if (!sbi)
+		goto err_out;
+
+	regs = of_get_property(dp, "reg", NULL);
+	if (!regs)
+		goto err_out;
+
+	slot = regs->which_io;
+
+	/*
+	 *  If SBI's parent is not io-unit or the io-unit lacks
+	 * a "board#" property, something is very wrong.
+	 */
+	if (!sbi->parent || strcmp(sbi->parent->name, "io-unit")) {
+		printk("%s: Error, parent is not io-unit.\n", sbi->full_name);
+		goto err_out;
+	}
+	io_unit = sbi->parent;
+	board = of_getintprop_default(io_unit, "board#", -1);
+	if (board == -1) {
+		printk("%s: Error, lacks board# property.\n", io_unit->full_name);
+		goto err_out;
+	}
+
+	sbusl = pil_to_sbus[real_irq];
+	if (sbusl)
+		return (((board + 1) << 5) + (sbusl << 2) + slot);
+
+err_out:
+	return real_irq;
+}
+
 static void __init sun4d_fixup_trap_table(void)
 {
 #ifdef CONFIG_SMP
@@ -559,6 +609,7 @@ void __init sun4d_init_IRQ(void)
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
 
 	sparc_irq_config.init_timers = sun4d_init_timers;
+	sparc_irq_config.build_device_irq = sun4d_build_device_irq;
 
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);

commit bbdc2661eabddd442240533a66b2290f77d89ccc
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Feb 25 23:00:19 2011 -0800

    sparc32: introduce sparc_irq_config
    
    sparc_irq_config is used to hold the platform specific irq setup.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 609a13c85823..fc1c22f121fd 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -557,7 +557,9 @@ void __init sun4d_init_IRQ(void)
 	BTFIXUPSET_CALL(disable_irq, sun4d_disable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
-	sparc_init_timers = sun4d_init_timers;
+
+	sparc_irq_config.init_timers = sun4d_init_timers;
+
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_cpu_int, sun4d_clear_ipi, BTFIXUPCALL_NOP);

commit 70044df4111e1afbff91a731785673aeb42a34fd
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 28 22:08:23 2011 +0000

    sparc32, sun4d: add comment in empty statement in sun4d_request_irq()
    
    This looked like a bug to me.
    Add a comment so next reader is hopefully less confused.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index b2e3fbf7c6fa..609a13c85823 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -307,7 +307,8 @@ int sun4d_request_irq(unsigned int irq,
 
 	if (action) {
 		if ((action->flags & IRQF_SHARED) && (irqflags & IRQF_SHARED)) {
-			for (tmp = action; tmp->next; tmp = tmp->next);
+			for (tmp = action; tmp->next; tmp = tmp->next)
+				/* find last entry - tmp used below */;
 		} else {
 			ret = -EBUSY;
 			goto out_unlock;

commit a625a12a763fa5cfe9775aa354790782d89efb6f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 28 22:08:22 2011 +0000

    sparc32,sun4d: drop unused code in sun4d_distribute_irqs()
    
    The preprocessor symbol was not defined and the code
    was therefore not in use.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 5fc4c220158c..b2e3fbf7c6fa 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -38,13 +38,6 @@
  *    have interrupts pending for that SBUS interrupt level.
  */
 
-/*
- * If you trust current SCSI layer to handle different
- * SCSI IRQs, enable this.
- * I don't trust it... -jj
- */
-/* #define DISTRIBUTE_IRQS */
-
 struct sun4d_timer_regs {
 	u32	l10_timer_limit;
 	u32	l10_cur_countx;
@@ -412,45 +405,6 @@ void __init sun4d_distribute_irqs(void)
 {
 	struct device_node *dp;
 
-#ifdef DISTRIBUTE_IRQS
-	cpumask_t sbus_serving_map;
-
-	sbus_serving_map = cpu_present_map;
-	for_each_node_by_name(dp, "sbi") {
-		int board = of_getintprop_default(dp, "board#", 0);
-
-		if ((board * 2) == boot_cpu_id && cpu_isset(board * 2 + 1, cpu_present_map))
-			sbus_tid[board] = (board * 2 + 1);
-		else if (cpu_isset(board * 2, cpu_present_map))
-			sbus_tid[board] = (board * 2);
-		else if (cpu_isset(board * 2 + 1, cpu_present_map))
-			sbus_tid[board] = (board * 2 + 1);
-		else
-			sbus_tid[board] = 0xff;
-		if (sbus_tid[board] != 0xff)
-			cpu_clear(sbus_tid[board], sbus_serving_map);
-	}
-	for_each_node_by_name(dp, "sbi") {
-		int board = of_getintprop_default(dp, "board#", 0);
-		if (sbus_tid[board] == 0xff) {
-			int i = 31;
-
-			if (cpus_empty(sbus_serving_map))
-				sbus_serving_map = cpu_present_map;
-			while (cpu_isset(i, sbus_serving_map))
-				i--;
-			sbus_tid[board] = i;
-			cpu_clear(i, sbus_serving_map);
-		}
-	}
-	for_each_node_by_name(dp, "sbi") {
-		int devid = of_getintprop_default(dp, "device-id", 0);
-		int board = of_getintprop_default(dp, "board#", 0);
-		printk(KERN_ERR "sbus%d IRQs directed to CPU%d\n",
-		       board, sbus_tid[board]);
-		set_sbi_tid(devid, sbus_tid[board] << 3);
-	}
-#else
 	int cpuid = cpu_logical_map(1);
 
 	if (cpuid == -1)
@@ -462,7 +416,6 @@ void __init sun4d_distribute_irqs(void)
 		set_sbi_tid(devid, cpuid << 3);
 	}
 	printk(KERN_ERR "All sbus IRQs directed to CPU%d\n", cpuid);
-#endif
 }
 #endif
 

commit e54f8548ff5285f57125c08d8092eec38dd05e0d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 28 22:08:21 2011 +0000

    sparc32,sun4d: irq, smp files cleanup
    
    - drop filename in file header
    - drop unused includes
    - add description of sun4d interrupts (from davem)
    - add KERN_* to printk
    - fix spaces => tabs
    - add spaces after reserved words
    - fix indent of a whole code block in smp4d_boot_one_cpu()
      Note: two printk() was updated from debug to KERN_INFO in this code block
    - drop all externs, they are now in header files
    
    This is partly based on a patch from: David Miller <davem@davemloft.net>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 3af649e64f0d..5fc4c220158c 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -1,49 +1,48 @@
 /*
- *  arch/sparc/kernel/sun4d_irq.c:
- *			SS1000/SC2000 interrupt handling.
+ * SS1000/SC2000 interrupt handling.
  *
  *  Copyright (C) 1997,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
  *  Heavily based on arch/sparc/kernel/irq.c.
  */
 
-#include <linux/errno.h>
-#include <linux/linkage.h>
 #include <linux/kernel_stat.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/ptrace.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/random.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/spinlock.h>
 #include <linux/seq_file.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-
-#include <asm/ptrace.h>
-#include <asm/processor.h>
-#include <asm/system.h>
-#include <asm/psr.h>
-#include <asm/smp.h>
-#include <asm/vaddrs.h>
+
 #include <asm/timer.h>
-#include <asm/openprom.h>
-#include <asm/oplib.h>
 #include <asm/traps.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/pgalloc.h>
-#include <asm/pgtable.h>
 #include <asm/sbi.h>
 #include <asm/cacheflush.h>
-#include <asm/irq_regs.h>
 
 #include "kernel.h"
 #include "irq.h"
 
-/* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
+/* Sun4d interrupts fall roughly into two categories.  SBUS and
+ * cpu local.  CPU local interrupts cover the timer interrupts
+ * and whatnot, and we encode those as normal PILs between
+ * 0 and 15.
+ *
+ * SBUS interrupts are encoded integers including the board number
+ * (plus one), the SBUS level, and the SBUS slot number.  Sun4D
+ * IRQ dispatch is done by:
+ *
+ * 1) Reading the BW local interrupt table in order to get the bus
+ *    interrupt mask.
+ *
+ *    This table is indexed by SBUS interrupt level which can be
+ *    derived from the PIL we got interrupted on.
+ *
+ * 2) For each bus showing interrupt pending from #1, read the
+ *    SBI interrupt state register.  This will indicate which slots
+ *    have interrupts pending for that SBUS interrupt level.
+ */
+
+/*
+ * If you trust current SCSI layer to handle different
+ * SCSI IRQs, enable this.
+ * I don't trust it... -jj
+ */
 /* #define DISTRIBUTE_IRQS */
 
 struct sun4d_timer_regs {
@@ -59,11 +58,9 @@ static struct sun4d_timer_regs __iomem *sun4d_timers;
 #define TIMER_IRQ	10
 
 #define MAX_STATIC_ALLOC	4
-extern int static_irq_count;
 static unsigned char sbus_tid[32];
 
 static struct irqaction *irq_action[NR_IRQS];
-extern spinlock_t irq_action_lock;
 
 static struct sbus_action {
 	struct irqaction *action;
@@ -71,11 +68,33 @@ static struct sbus_action {
 } *sbus_actions;
 
 static int pil_to_sbus[] = {
-	0, 0, 1, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 0,
+	0,
+	0,
+	1,
+	2,
+	0,
+	3,
+	0,
+	4,
+	0,
+	5,
+	0,
+	6,
+	0,
+	7,
+	0,
+	0,
 };
 
 static int sbus_to_pil[] = {
-	0, 2, 3, 5, 7, 9, 11, 13,
+	0,
+	2,
+	3,
+	5,
+	7,
+	9,
+	11,
+	13,
 };
 
 static int nsbi;
@@ -86,7 +105,7 @@ DEFINE_SPINLOCK(sun4d_imsk_lock);
 int show_sun4d_interrupts(struct seq_file *p, void *v)
 {
 	int i = *(loff_t *) v, j = 0, k = 0, sbusl;
-	struct irqaction * action;
+	struct irqaction *action;
 	unsigned long flags;
 #ifdef CONFIG_SMP
 	int x;
@@ -96,13 +115,14 @@ int show_sun4d_interrupts(struct seq_file *p, void *v)
 	if (i < NR_IRQS) {
 		sbusl = pil_to_sbus[i];
 		if (!sbusl) {
-	 		action = *(i + irq_action);
-			if (!action) 
-		        	goto out_unlock;
+			action = *(i + irq_action);
+			if (!action)
+				goto out_unlock;
 		} else {
 			for (j = 0; j < nsbi; j++) {
 				for (k = 0; k < 4; k++)
-					if ((action = sbus_actions [(j << 5) + (sbusl << 2) + k].action))
+					action = sbus_actions[(j << 5) + (sbusl << 2) + k].action;
+					if (action)
 						goto found_it;
 			}
 			goto out_unlock;
@@ -125,15 +145,17 @@ found_it:	seq_printf(p, "%3d: ", i);
 					(action->flags & IRQF_DISABLED) ? " +" : "",
 					action->name);
 			}
-			if (!sbusl) break;
+			if (!sbusl)
+				break;
 			k++;
-			if (k < 4)
-				action = sbus_actions [(j << 5) + (sbusl << 2) + k].action;
-			else {
+			if (k < 4) {
+				action = sbus_actions[(j << 5) + (sbusl << 2) + k].action;
+			} else {
 				j++;
-				if (j == nsbi) break;
+				if (j == nsbi)
+					break;
 				k = 0;
-				action = sbus_actions [(j << 5) + (sbusl << 2)].action;
+				action = sbus_actions[(j << 5) + (sbusl << 2)].action;
 			}
 		}
 		seq_putc(p, '\n');
@@ -147,7 +169,7 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 {
 	struct irqaction *action, **actionp;
 	struct irqaction *tmp = NULL;
-        unsigned long flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&irq_action_lock, flags);
 	if (irq < 15)
@@ -156,7 +178,7 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 		actionp = &(sbus_actions[irq - (1 << 5)].action);
 	action = *actionp;
 	if (!action) {
-		printk("Trying to free free IRQ%d\n",irq);
+		printk(KERN_ERR "Trying to free free IRQ%d\n", irq);
 		goto out_unlock;
 	}
 	if (dev_id) {
@@ -166,23 +188,25 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 			tmp = action;
 		}
 		if (!action) {
-			printk("Trying to free free shared IRQ%d\n",irq);
+			printk(KERN_ERR "Trying to free free shared IRQ%d\n",
+			       irq);
 			goto out_unlock;
 		}
 	} else if (action->flags & IRQF_SHARED) {
-		printk("Trying to free shared IRQ%d with NULL device ID\n", irq);
+		printk(KERN_ERR "Trying to free shared IRQ%d with NULL device ID\n",
+		       irq);
 		goto out_unlock;
 	}
-	if (action->flags & SA_STATIC_ALLOC)
-	{
-		/* This interrupt is marked as specially allocated
+	if (action->flags & SA_STATIC_ALLOC) {
+		/*
+		 * This interrupt is marked as specially allocated
 		 * so it is a bad idea to free it.
 		 */
-		printk("Attempt to free statically allocated IRQ%d (%s)\n",
+		printk(KERN_ERR "Attempt to free statically allocated IRQ%d (%s)\n",
 		       irq, action->name);
 		goto out_unlock;
 	}
-	
+
 	if (tmp)
 		tmp->next = action->next;
 	else
@@ -203,21 +227,19 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 	spin_unlock_irqrestore(&irq_action_lock, flags);
 }
 
-extern void unexpected_irq(int, void *, struct pt_regs *);
-
-void sun4d_handler_irq(int pil, struct pt_regs * regs)
+void sun4d_handler_irq(int pil, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs;
-	struct irqaction * action;
+	struct irqaction *action;
 	int cpu = smp_processor_id();
 	/* SBUS IRQ level (1 - 7) */
 	int sbusl = pil_to_sbus[pil];
-	
+
 	/* FIXME: Is this necessary?? */
 	cc_get_ipen();
-	
+
 	cc_set_iclr(1 << pil);
-	
+
 	old_regs = set_irq_regs(regs);
 	irq_enter();
 	kstat_cpu(cpu).irqs[pil]++;
@@ -235,9 +257,9 @@ void sun4d_handler_irq(int pil, struct pt_regs * regs)
 		struct sbus_action *actionp;
 		unsigned mask, slot;
 		int sbil = (sbusl << 2);
-		
+
 		bw_clear_intr_mask(sbusl, bus_mask);
-		
+
 		/* Loop for each pending SBI */
 		for (sbino = 0; bus_mask; sbino++, bus_mask >>= 1)
 			if (bus_mask & 1) {
@@ -249,7 +271,7 @@ void sun4d_handler_irq(int pil, struct pt_regs * regs)
 					if (mask & slot) {
 						mask &= ~slot;
 						action = actionp->action;
-						
+
 						if (!action)
 							unexpected_irq(pil, NULL, regs);
 						do {
@@ -266,13 +288,13 @@ void sun4d_handler_irq(int pil, struct pt_regs * regs)
 
 int sun4d_request_irq(unsigned int irq,
 		irq_handler_t handler,
-		unsigned long irqflags, const char * devname, void *dev_id)
+		unsigned long irqflags, const char *devname, void *dev_id)
 {
 	struct irqaction *action, *tmp = NULL, **actionp;
 	unsigned long flags;
 	int ret;
-	
-	if(irq > 14 && irq < (1 << 5)) {
+
+	if (irq > 14 && irq < (1 << 5)) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -289,7 +311,7 @@ int sun4d_request_irq(unsigned int irq,
 	else
 		actionp = irq + irq_action;
 	action = *actionp;
-	
+
 	if (action) {
 		if ((action->flags & IRQF_SHARED) && (irqflags & IRQF_SHARED)) {
 			for (tmp = action; tmp->next; tmp = tmp->next);
@@ -298,7 +320,8 @@ int sun4d_request_irq(unsigned int irq,
 			goto out_unlock;
 		}
 		if ((action->flags & IRQF_DISABLED) ^ (irqflags & IRQF_DISABLED)) {
-			printk("Attempt to mix fast and slow interrupts on IRQ%d denied\n", irq);
+			printk(KERN_ERR "Attempt to mix fast and slow interrupts on IRQ%d denied\n",
+			       irq);
 			ret = -EBUSY;
 			goto out_unlock;
 		}
@@ -312,14 +335,14 @@ int sun4d_request_irq(unsigned int irq,
 		if (static_irq_count < MAX_STATIC_ALLOC)
 			action = &static_irqaction[static_irq_count++];
 		else
-			printk("Request for IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc\n", irq, devname);
+			printk(KERN_ERR "Request for IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc\n",
+			       irq, devname);
 	}
-	
+
 	if (action == NULL)
-		action = kmalloc(sizeof(struct irqaction),
-						     GFP_ATOMIC);
-	
-	if (!action) { 
+		action = kmalloc(sizeof(struct irqaction), GFP_ATOMIC);
+
+	if (!action) {
 		ret = -ENOMEM;
 		goto out_unlock;
 	}
@@ -334,7 +357,7 @@ int sun4d_request_irq(unsigned int irq,
 		tmp->next = action;
 	else
 		*actionp = action;
-		
+
 	__enable_irq(irq);
 
 	ret = 0;
@@ -348,7 +371,7 @@ static void sun4d_disable_irq(unsigned int irq)
 {
 	int tid = sbus_tid[(irq >> 5) - 1];
 	unsigned long flags;
-	
+
 	if (irq < NR_IRQS)
 		return;
 
@@ -361,7 +384,7 @@ static void sun4d_enable_irq(unsigned int irq)
 {
 	int tid = sbus_tid[(irq >> 5) - 1];
 	unsigned long flags;
-	
+
 	if (irq < NR_IRQS)
 		return;
 
@@ -411,7 +434,7 @@ void __init sun4d_distribute_irqs(void)
 		int board = of_getintprop_default(dp, "board#", 0);
 		if (sbus_tid[board] == 0xff) {
 			int i = 31;
-				
+
 			if (cpus_empty(sbus_serving_map))
 				sbus_serving_map = cpu_present_map;
 			while (cpu_isset(i, sbus_serving_map))
@@ -423,7 +446,8 @@ void __init sun4d_distribute_irqs(void)
 	for_each_node_by_name(dp, "sbi") {
 		int devid = of_getintprop_default(dp, "device-id", 0);
 		int board = of_getintprop_default(dp, "board#", 0);
-		printk("sbus%d IRQs directed to CPU%d\n", board, sbus_tid[board]);
+		printk(KERN_ERR "sbus%d IRQs directed to CPU%d\n",
+		       board, sbus_tid[board]);
 		set_sbi_tid(devid, sbus_tid[board] << 3);
 	}
 #else
@@ -437,11 +461,11 @@ void __init sun4d_distribute_irqs(void)
 		sbus_tid[board] = cpuid;
 		set_sbi_tid(devid, cpuid << 3);
 	}
-	printk("All sbus IRQs directed to CPU%d\n", cpuid);
+	printk(KERN_ERR "All sbus IRQs directed to CPU%d\n", cpuid);
 #endif
 }
 #endif
- 
+
 static void sun4d_clear_clock_irq(void)
 {
 	sbus_readl(&sun4d_timers->l10_timer_limit);
@@ -466,10 +490,7 @@ static void __init sun4d_fixup_trap_table(void)
 {
 #ifdef CONFIG_SMP
 	unsigned long flags;
-	extern unsigned long lvl14_save[4];
 	struct tt_entry *trap_table = &sparc_ttable[SP_TRAP_IRQ1 + (14 - 1)];
-	extern unsigned int real_irq_entry[], smp4d_ticker[];
-	extern unsigned int patchme_maybe_smp_msg[];
 
 	/* Adjust so that we jump directly to smp4d_ticker */
 	lvl14_save[2] += smp4d_ticker - real_irq_entry;
@@ -531,7 +552,8 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 			  (IRQF_DISABLED | SA_STATIC_ALLOC),
 			  "timer", NULL);
 	if (err) {
-		prom_printf("sun4d_init_timers: request_irq() failed with %d\n", err);
+		prom_printf("sun4d_init_timers: request_irq() failed with %d\n",
+		             err);
 		prom_halt();
 	}
 	sun4d_load_profile_irqs();
@@ -550,7 +572,7 @@ void __init sun4d_init_sbi_irq(void)
 	nsbi = 0;
 	for_each_node_by_name(dp, "sbi")
 		nsbi++;
-	sbus_actions = kzalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
+	sbus_actions = kzalloc(nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
 	if (!sbus_actions) {
 		prom_printf("SUN4D: Cannot allocate sbus_actions, halting.\n");
 		prom_halt();
@@ -566,7 +588,8 @@ void __init sun4d_init_sbi_irq(void)
 		/* Get rid of pending irqs from PROM */
 		mask = acquire_sbi(devid, 0xffffffff);
 		if (mask) {
-			printk ("Clearing pending IRQs %08x on SBI %d\n", mask, board);
+			printk(KERN_ERR "Clearing pending IRQs %08x on SBI %d\n",
+			       mask, board);
 			release_sbi(devid, mask);
 		}
 	}

commit d4d1ec48c4b1568338931bf8e7833543b78ec9d5
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jan 22 11:32:15 2011 +0000

    sparc: in handler_irq() rename irq parameter to pil
    
    The generic irq support uses "irq" to identify the
    virtual irq number. To avoid confusion rename the
    argument to handler_irq() to pil to match the
    name of the parameter in the PCR register.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index e11b4612dabb..3af649e64f0d 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -205,28 +205,28 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 
 extern void unexpected_irq(int, void *, struct pt_regs *);
 
-void sun4d_handler_irq(int irq, struct pt_regs * regs)
+void sun4d_handler_irq(int pil, struct pt_regs * regs)
 {
 	struct pt_regs *old_regs;
 	struct irqaction * action;
 	int cpu = smp_processor_id();
 	/* SBUS IRQ level (1 - 7) */
-	int sbusl = pil_to_sbus[irq];
+	int sbusl = pil_to_sbus[pil];
 	
 	/* FIXME: Is this necessary?? */
 	cc_get_ipen();
 	
-	cc_set_iclr(1 << irq);
+	cc_set_iclr(1 << pil);
 	
 	old_regs = set_irq_regs(regs);
 	irq_enter();
-	kstat_cpu(cpu).irqs[irq]++;
+	kstat_cpu(cpu).irqs[pil]++;
 	if (!sbusl) {
-		action = *(irq + irq_action);
+		action = *(pil + irq_action);
 		if (!action)
-			unexpected_irq(irq, NULL, regs);
+			unexpected_irq(pil, NULL, regs);
 		do {
-			action->handler(irq, action->dev_id);
+			action->handler(pil, action->dev_id);
 			action = action->next;
 		} while (action);
 	} else {
@@ -251,9 +251,9 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 						action = actionp->action;
 						
 						if (!action)
-							unexpected_irq(irq, NULL, regs);
+							unexpected_irq(pil, NULL, regs);
 						do {
-							action->handler(irq, action->dev_id);
+							action->handler(pil, action->dev_id);
 							action = action->next;
 						} while (action);
 						release_sbi(SBI2DEVID(sbino), slot);

commit 0d0659c78d7ea29ad6c3c538dcaae0227f31b9d2
Author: Julia Lawall <julia@diku.dk>
Date:   Fri Jun 4 16:17:37 2010 -0700

    arch/sparc/kernel: Eliminate what looks like a NULL pointer dereference
    
    At the point of the test, action cannot be NULL, as it has been dereferenced
    in the code just above.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    expression E,E1;
    identifier f;
    statement S1,S2,S3;
    @@
    
    if ((E == NULL && ...) || ...)
    {
      ... when != if (...) S1 else S2
          when != E = E1
    * E->f
      ... when any
    }
    else S3
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index ab036a72de5a..e11b4612dabb 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -183,7 +183,7 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 		goto out_unlock;
 	}
 	
-	if (action && tmp)
+	if (tmp)
 		tmp->next = action->next;
 	else
 		*actionp = action->next;

commit 1a8a51004a18b627ea81444201f7867875212f46
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 30 22:05:13 2009 -0600

    cpumask: remove references to struct irqaction's mask field.
    
    Impact: cleanup
    
    It's unused, since about 1995.  So remove all initialization of it in
    preparation for actually removing the field.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 3369fef5b4b3..ab036a72de5a 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -326,7 +326,6 @@ int sun4d_request_irq(unsigned int irq,
 
 	action->handler = handler;
 	action->flags = irqflags;
-	cpus_clear(action->mask);
 	action->name = devname;
 	action->next = NULL;
 	action->dev_id = dev_id;

commit 81265fd93bc40c7c43fd36796571786ae3df00e0
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Dec 8 01:08:24 2008 -0800

    sparc: fix sparse warnings in irq_32.c
    
    Fix following sparse warnings:
    symbol 'static_irqaction' was not declared. Should it be static?
    symbol 'static_irq_count' was not declared. Should it be static?
    symbol 'irq_action_lock' was not declared. Should it be static?
    symbol 'unexpected_irq' was not declared. Should it be static?
    symbol 'handler_irq' was not declared. Should it be static?
    returning void-valued expression
    returning void-valued expression
    returning void-valued expression
    symbol 'init_IRQ' was not declared. Should it be static?
    
    Warnings were fixed by addding proper declarations
    and fixing return path of a few functions.
    
    There remains several warnings all related to the floppy driver.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 1c98821e1a64..3369fef5b4b3 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -40,6 +40,7 @@
 #include <asm/cacheflush.h>
 #include <asm/irq_regs.h>
 
+#include "kernel.h"
 #include "irq.h"
 
 /* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
@@ -58,7 +59,6 @@ static struct sun4d_timer_regs __iomem *sun4d_timers;
 #define TIMER_IRQ	10
 
 #define MAX_STATIC_ALLOC	4
-extern struct irqaction static_irqaction[MAX_STATIC_ALLOC];
 extern int static_irq_count;
 static unsigned char sbus_tid[32];
 

commit c2e27c359ab76fecbbd292dbfc0bcfa8399afdd9
Author: Nicolas Palix <npalix@diku.dk>
Date:   Wed Dec 3 21:10:57 2008 -0800

    sparc: Add missing of_node_put
    
    of_node_put is needed before discarding a value received from
    of_find_node_by_name, eg in error handling code or when the device
    node is no longer used.
    
    The semantic match that catches the bug is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r exists@
    local idexpression struct device_node *n;
    position p1, p2;
    struct device_node *n1;
    statement S;
    identifier f;
    expression E;
    expression *ptr != NULL;
    @@
    
    n@p1 = of_find_node_by_name(...)
    ...
    if (!n) S
    ... when != of_node_put(n)
        when != n1 = f(n,...)
        when != E = n
        when any
        when strict
    (
      return \(0\|<+...n...+>\|ptr\);
    |
    return@p2 ...;
    |
      of_node_put(n);
    |
      n1 = f(n,...)
    |
      E = n
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    print "* file: %s of_find_node_by_name %s return %s" % (p1[0].file,p1[0].line,p2[0].line)
    // </smpl>
    
    Signed-off-by: Nicolas Palix <npalix@diku.dk>
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index d3cb76ce418b..1c98821e1a64 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -508,6 +508,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 	 * bootbus.
 	 */
 	reg = of_get_property(dp, "reg", NULL);
+	of_node_put(dp);
 	if (!reg) {
 		prom_printf("sun4d_init_timers: No reg property\n");
 		prom_halt();

commit c7e606a8f863b2119176674610618dad3d80a16d
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Sep 13 22:48:04 2008 -0700

    sparc32: Delete master_l10_limit.
    
    It is only set, never used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index d376d380ac0a..d3cb76ce418b 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -526,7 +526,6 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 	sbus_writel((((1000000/HZ) + 1) << 10), &sun4d_timers->l10_timer_limit);
 
 	master_l10_counter = &sun4d_timers->l10_cur_count;
-	master_l10_limit = &sun4d_timers->l10_timer_limit;
 
 	err = request_irq(TIMER_IRQ, counter_fn,
 			  (IRQF_DISABLED | SA_STATIC_ALLOC),

commit 76954261ba907950cb5216e5c3075b5ba03c1a6b
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Sep 13 22:07:06 2008 -0700

    sparc32: Kill clear_profile_irq btfixup entry.
    
    Unused.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 6e3bf6eee543..d376d380ac0a 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -448,11 +448,6 @@ static void sun4d_clear_clock_irq(void)
 	sbus_readl(&sun4d_timers->l10_timer_limit);
 }
 
-static void sun4d_clear_profile_irq(int cpu)
-{
-	bw_get_prof_limit(cpu);
-}
-
 static void sun4d_load_profile_irq(int cpu, unsigned int limit)
 {
 	bw_set_prof_limit(cpu, limit);
@@ -585,7 +580,6 @@ void __init sun4d_init_IRQ(void)
 	BTFIXUPSET_CALL(enable_irq, sun4d_enable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(disable_irq, sun4d_disable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(clear_profile_irq, sun4d_clear_profile_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
 	sparc_init_timers = sun4d_init_timers;
 #ifdef CONFIG_SMP

commit f8376e933c4e80663f6f66a5b5dd90390a0feba2
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Sep 13 22:05:25 2008 -0700

    sparc32: Remove some SMP ifdefs in sun4d_irq.c
    
    Always do the sbus_tid[] handling.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 4156bf6657fb..6e3bf6eee543 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -60,9 +60,7 @@ static struct sun4d_timer_regs __iomem *sun4d_timers;
 #define MAX_STATIC_ALLOC	4
 extern struct irqaction static_irqaction[MAX_STATIC_ALLOC];
 extern int static_irq_count;
-#ifdef CONFIG_SMP
 static unsigned char sbus_tid[32];
-#endif
 
 static struct irqaction *irq_action[NR_IRQS];
 extern spinlock_t irq_action_lock;
@@ -81,9 +79,9 @@ static int sbus_to_pil[] = {
 };
 
 static int nsbi;
-#ifdef CONFIG_SMP
+
+/* Exported for sun4d_smp.c */
 DEFINE_SPINLOCK(sun4d_imsk_lock);
-#endif
 
 int show_sun4d_interrupts(struct seq_file *p, void *v)
 {
@@ -349,36 +347,28 @@ int sun4d_request_irq(unsigned int irq,
 
 static void sun4d_disable_irq(unsigned int irq)
 {
-#ifdef CONFIG_SMP
 	int tid = sbus_tid[(irq >> 5) - 1];
 	unsigned long flags;
-#endif	
 	
-	if (irq < NR_IRQS) return;
-#ifdef CONFIG_SMP
+	if (irq < NR_IRQS)
+		return;
+
 	spin_lock_irqsave(&sun4d_imsk_lock, flags);
 	cc_set_imsk_other(tid, cc_get_imsk_other(tid) | (1 << sbus_to_pil[(irq >> 2) & 7]));
 	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
-#else		
-	cc_set_imsk(cc_get_imsk() | (1 << sbus_to_pil[(irq >> 2) & 7]));
-#endif
 }
 
 static void sun4d_enable_irq(unsigned int irq)
 {
-#ifdef CONFIG_SMP
 	int tid = sbus_tid[(irq >> 5) - 1];
 	unsigned long flags;
-#endif	
 	
-	if (irq < NR_IRQS) return;
-#ifdef CONFIG_SMP
+	if (irq < NR_IRQS)
+		return;
+
 	spin_lock_irqsave(&sun4d_imsk_lock, flags);
 	cc_set_imsk_other(tid, cc_get_imsk_other(tid) & ~(1 << sbus_to_pil[(irq >> 2) & 7]));
 	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
-#else		
-	cc_set_imsk(cc_get_imsk() & ~(1 << sbus_to_pil[(irq >> 2) & 7]));
-#endif
 }
 
 #ifdef CONFIG_SMP
@@ -557,6 +547,11 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 void __init sun4d_init_sbi_irq(void)
 {
 	struct device_node *dp;
+	int target_cpu = 0;
+
+#ifdef CONFIG_SMP
+	target_cpu = boot_cpu_id;
+#endif
 
 	nsbi = 0;
 	for_each_node_by_name(dp, "sbi")
@@ -571,14 +566,9 @@ void __init sun4d_init_sbi_irq(void)
 		int board = of_getintprop_default(dp, "board#", 0);
 		unsigned int mask;
 
-#ifdef CONFIG_SMP	
-		{
-			extern unsigned char boot_cpu_id;
-		
-			set_sbi_tid(devid, boot_cpu_id << 3);
-			sbus_tid[board] = boot_cpu_id;
-		}
-#endif
+		set_sbi_tid(devid, target_cpu << 3);
+		sbus_tid[board] = target_cpu;
+
 		/* Get rid of pending irqs from PROM */
 		mask = acquire_sbi(devid, 0xffffffff);
 		if (mask) {

commit f5f1085720c4799dd1437f78e28e40c8dd557bba
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Sep 13 22:04:55 2008 -0700

    sparc32: Use PROM infrastructure for probing and mapping sun4d timers.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 12541f51fcfc..4156bf6657fb 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -45,7 +45,16 @@
 /* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
 /* #define DISTRIBUTE_IRQS */
 
-struct sun4d_timer_regs *sun4d_timers;
+struct sun4d_timer_regs {
+	u32	l10_timer_limit;
+	u32	l10_cur_countx;
+	u32	l10_limit_noclear;
+	u32	ctrl;
+	u32	l10_cur_count;
+};
+
+static struct sun4d_timer_regs __iomem *sun4d_timers;
+
 #define TIMER_IRQ	10
 
 #define MAX_STATIC_ALLOC	4
@@ -446,8 +455,7 @@ void __init sun4d_distribute_irqs(void)
  
 static void sun4d_clear_clock_irq(void)
 {
-	volatile unsigned int clear_intr;
-	clear_intr = sun4d_timers->l10_timer_limit;
+	sbus_readl(&sun4d_timers->l10_timer_limit);
 }
 
 static void sun4d_clear_profile_irq(int cpu)
@@ -460,71 +468,90 @@ static void sun4d_load_profile_irq(int cpu, unsigned int limit)
 	bw_set_prof_limit(cpu, limit);
 }
 
-static void __init sun4d_init_timers(irq_handler_t counter_fn)
+static void __init sun4d_load_profile_irqs(void)
 {
-	int irq;
-	int cpu;
-	struct resource r;
-	int mid;
+	int cpu = 0, mid;
 
-	/* Map the User Timer registers. */
-	memset(&r, 0, sizeof(r));
+	while (!cpu_find_by_instance(cpu, NULL, &mid)) {
+		sun4d_load_profile_irq(mid >> 3, 0);
+		cpu++;
+	}
+}
+
+static void __init sun4d_fixup_trap_table(void)
+{
 #ifdef CONFIG_SMP
-	r.start = CSR_BASE(boot_cpu_id)+BW_TIMER_LIMIT;
-#else
-	r.start = CSR_BASE(0)+BW_TIMER_LIMIT;
+	unsigned long flags;
+	extern unsigned long lvl14_save[4];
+	struct tt_entry *trap_table = &sparc_ttable[SP_TRAP_IRQ1 + (14 - 1)];
+	extern unsigned int real_irq_entry[], smp4d_ticker[];
+	extern unsigned int patchme_maybe_smp_msg[];
+
+	/* Adjust so that we jump directly to smp4d_ticker */
+	lvl14_save[2] += smp4d_ticker - real_irq_entry;
+
+	/* For SMP we use the level 14 ticker, however the bootup code
+	 * has copied the firmware's level 14 vector into the boot cpu's
+	 * trap table, we must fix this now or we get squashed.
+	 */
+	local_irq_save(flags);
+	patchme_maybe_smp_msg[0] = 0x01000000; /* NOP out the branch */
+	trap_table->inst_one = lvl14_save[0];
+	trap_table->inst_two = lvl14_save[1];
+	trap_table->inst_three = lvl14_save[2];
+	trap_table->inst_four = lvl14_save[3];
+	local_flush_cache_all();
+	local_irq_restore(flags);
 #endif
-	r.flags = 0xf;
-	sun4d_timers = (struct sun4d_timer_regs *) of_ioremap(&r, 0,
-	    PAGE_SIZE, "user timer");
+}
+
+static void __init sun4d_init_timers(irq_handler_t counter_fn)
+{
+	struct device_node *dp;
+	struct resource res;
+	const u32 *reg;
+	int err;
+
+	dp = of_find_node_by_name(NULL, "cpu-unit");
+	if (!dp) {
+		prom_printf("sun4d_init_timers: Unable to find cpu-unit\n");
+		prom_halt();
+	}
+
+	/* Which cpu-unit we use is arbitrary, we can view the bootbus timer
+	 * registers via any cpu's mapping.  The first 'reg' property is the
+	 * bootbus.
+	 */
+	reg = of_get_property(dp, "reg", NULL);
+	if (!reg) {
+		prom_printf("sun4d_init_timers: No reg property\n");
+		prom_halt();
+	}
+
+	res.start = reg[1];
+	res.end = reg[2] - 1;
+	res.flags = reg[0] & 0xff;
+	sun4d_timers = of_ioremap(&res, BW_TIMER_LIMIT,
+				  sizeof(struct sun4d_timer_regs), "user timer");
+	if (!sun4d_timers) {
+		prom_printf("sun4d_init_timers: Can't map timer regs\n");
+		prom_halt();
+	}
+
+	sbus_writel((((1000000/HZ) + 1) << 10), &sun4d_timers->l10_timer_limit);
 
-	sun4d_timers->l10_timer_limit =  (((1000000/HZ) + 1) << 10);
 	master_l10_counter = &sun4d_timers->l10_cur_count;
 	master_l10_limit = &sun4d_timers->l10_timer_limit;
 
-	irq = request_irq(TIMER_IRQ,
-			  counter_fn,
+	err = request_irq(TIMER_IRQ, counter_fn,
 			  (IRQF_DISABLED | SA_STATIC_ALLOC),
 			  "timer", NULL);
-	if (irq) {
-		prom_printf("time_init: unable to attach IRQ%d\n",TIMER_IRQ);
+	if (err) {
+		prom_printf("sun4d_init_timers: request_irq() failed with %d\n", err);
 		prom_halt();
 	}
-	
-	/* Enable user timer free run for CPU 0 in BW */
-	/* bw_set_ctrl(0, bw_get_ctrl(0) | BW_CTRL_USER_TIMER); */
-
-	cpu = 0;
-	while (!cpu_find_by_instance(cpu, NULL, &mid)) {
-		sun4d_load_profile_irq(mid >> 3, 0);
-		cpu++;
-	}
-		
-#ifdef CONFIG_SMP
-	{
-		unsigned long flags;
-		extern unsigned long lvl14_save[4];
-		struct tt_entry *trap_table = &sparc_ttable[SP_TRAP_IRQ1 + (14 - 1)];
-		extern unsigned int real_irq_entry[], smp4d_ticker[];
-		extern unsigned int patchme_maybe_smp_msg[];
-
-		/* Adjust so that we jump directly to smp4d_ticker */
-		lvl14_save[2] += smp4d_ticker - real_irq_entry;
-
-		/* For SMP we use the level 14 ticker, however the bootup code
-		 * has copied the firmware's level 14 vector into the boot cpu's
-		 * trap table, we must fix this now or we get squashed.
-		 */
-		local_irq_save(flags);
-		patchme_maybe_smp_msg[0] = 0x01000000; /* NOP out the branch */
-		trap_table->inst_one = lvl14_save[0];
-		trap_table->inst_two = lvl14_save[1];
-		trap_table->inst_three = lvl14_save[2];
-		trap_table->inst_four = lvl14_save[3];
-		local_flush_cache_all();
-		local_irq_restore(flags);
-	}
-#endif
+	sun4d_load_profile_irqs();
+	sun4d_fixup_trap_table();
 }
 
 void __init sun4d_init_sbi_irq(void)

commit 7b1af32f52077402157f8bb8fc22d8da17606095
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 2 01:17:41 2008 -0700

    sparc32: Move sun4d show_leds() out of asm/obio.h
    
    Put it, as well as cpu_leds[] array, into sun4d_irq.c
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index c4a2bfb750a4..12541f51fcfc 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -51,7 +51,6 @@ struct sun4d_timer_regs *sun4d_timers;
 #define MAX_STATIC_ALLOC	4
 extern struct irqaction static_irqaction[MAX_STATIC_ALLOC];
 extern int static_irq_count;
-unsigned char cpu_leds[32];
 #ifdef CONFIG_SMP
 static unsigned char sbus_tid[32];
 #endif

commit 454eeb2dd7bd0418451ea33a606d0fa50aa36718
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 04:05:35 2008 -0700

    sparc: Convert remaining sbus_ioremap() and sbus_iounmap() users.
    
    Use of_ioremap() and of_iounmap() instead.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index acfb447c00d0..c4a2bfb750a4 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -19,6 +19,8 @@
 #include <linux/smp.h>
 #include <linux/spinlock.h>
 #include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <asm/ptrace.h>
 #include <asm/processor.h>
@@ -34,7 +36,6 @@
 #include <asm/io.h>
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
-#include <asm/sbus.h>
 #include <asm/sbi.h>
 #include <asm/cacheflush.h>
 #include <asm/irq_regs.h>
@@ -475,7 +476,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 	r.start = CSR_BASE(0)+BW_TIMER_LIMIT;
 #endif
 	r.flags = 0xf;
-	sun4d_timers = (struct sun4d_timer_regs *) sbus_ioremap(&r, 0,
+	sun4d_timers = (struct sun4d_timer_regs *) of_ioremap(&r, 0,
 	    PAGE_SIZE, "user timer");
 
 	sun4d_timers->l10_timer_limit =  (((1000000/HZ) + 1) << 10);

commit 33c4655c00e6af3ec4023f2cafd63dd4a42de49b
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 02:56:39 2008 -0700

    sparc: Kill SBUS layer IRQ hooks.
    
    IRQs are obtained by drivers from the of_device struct.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 7424967142f0..acfb447c00d0 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -257,26 +257,6 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 	set_irq_regs(old_regs);
 }
 
-unsigned int sun4d_build_irq(struct sbus_dev *sdev, int irq)
-{
-	int sbusl = pil_to_sbus[irq];
-
-	if (sbusl)
-		return ((sdev->bus->board + 1) << 5) + (sbusl << 2) + sdev->slot;
-	else
-		return irq;
-}
-
-static unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev,
-				       unsigned int sbint)
-{
-	if (sbint >= sizeof(sbus_to_pil)) {
-		printk(KERN_ERR "%s: bogus SBINT %d\n", sdev->prom_name, sbint);
-		BUG();
-	}
-	return sun4d_build_irq(sdev, sbus_to_pil[sbint]);
-}
-
 int sun4d_request_irq(unsigned int irq,
 		irq_handler_t handler,
 		unsigned long irqflags, const char * devname, void *dev_id)
@@ -585,7 +565,6 @@ void __init sun4d_init_IRQ(void)
 {
 	local_irq_disable();
 
-	BTFIXUPSET_CALL(sbint_to_irq, sun4d_sbint_to_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(enable_irq, sun4d_enable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(disable_irq, sun4d_disable_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);

commit 71d3721189c0f4fad105a81e052bddfb826b693b
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 02:50:57 2008 -0700

    sparc32: Convert sun4d IRQ code to use generic device tree probing.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 1290b5998f83..7424967142f0 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -409,47 +409,55 @@ static void sun4d_set_udt(int cpu)
 /* Setup IRQ distribution scheme. */
 void __init sun4d_distribute_irqs(void)
 {
+	struct device_node *dp;
+
 #ifdef DISTRIBUTE_IRQS
-	struct sbus_bus *sbus;
-	unsigned long sbus_serving_map;
+	cpumask_t sbus_serving_map;
 
 	sbus_serving_map = cpu_present_map;
-	for_each_sbus(sbus) {
-		if ((sbus->board * 2) == boot_cpu_id && (cpu_present_map & (1 << (sbus->board * 2 + 1))))
-			sbus_tid[sbus->board] = (sbus->board * 2 + 1);
-		else if (cpu_present_map & (1 << (sbus->board * 2)))
-			sbus_tid[sbus->board] = (sbus->board * 2);
-		else if (cpu_present_map & (1 << (sbus->board * 2 + 1)))
-			sbus_tid[sbus->board] = (sbus->board * 2 + 1);
+	for_each_node_by_name(dp, "sbi") {
+		int board = of_getintprop_default(dp, "board#", 0);
+
+		if ((board * 2) == boot_cpu_id && cpu_isset(board * 2 + 1, cpu_present_map))
+			sbus_tid[board] = (board * 2 + 1);
+		else if (cpu_isset(board * 2, cpu_present_map))
+			sbus_tid[board] = (board * 2);
+		else if (cpu_isset(board * 2 + 1, cpu_present_map))
+			sbus_tid[board] = (board * 2 + 1);
 		else
-			sbus_tid[sbus->board] = 0xff;
-		if (sbus_tid[sbus->board] != 0xff)
-			sbus_serving_map &= ~(1 << sbus_tid[sbus->board]);
+			sbus_tid[board] = 0xff;
+		if (sbus_tid[board] != 0xff)
+			cpu_clear(sbus_tid[board], sbus_serving_map);
 	}
-	for_each_sbus(sbus)
-		if (sbus_tid[sbus->board] == 0xff) {
+	for_each_node_by_name(dp, "sbi") {
+		int board = of_getintprop_default(dp, "board#", 0);
+		if (sbus_tid[board] == 0xff) {
 			int i = 31;
 				
-			if (!sbus_serving_map)
+			if (cpus_empty(sbus_serving_map))
 				sbus_serving_map = cpu_present_map;
-			while (!(sbus_serving_map & (1 << i)))
+			while (cpu_isset(i, sbus_serving_map))
 				i--;
-			sbus_tid[sbus->board] = i;
-			sbus_serving_map &= ~(1 << i);
+			sbus_tid[board] = i;
+			cpu_clear(i, sbus_serving_map);
 		}
-	for_each_sbus(sbus) {
-		printk("sbus%d IRQs directed to CPU%d\n", sbus->board, sbus_tid[sbus->board]);
-		set_sbi_tid(sbus->devid, sbus_tid[sbus->board] << 3);
+	}
+	for_each_node_by_name(dp, "sbi") {
+		int devid = of_getintprop_default(dp, "device-id", 0);
+		int board = of_getintprop_default(dp, "board#", 0);
+		printk("sbus%d IRQs directed to CPU%d\n", board, sbus_tid[board]);
+		set_sbi_tid(devid, sbus_tid[board] << 3);
 	}
 #else
-	struct sbus_bus *sbus;
 	int cpuid = cpu_logical_map(1);
 
 	if (cpuid == -1)
 		cpuid = cpu_logical_map(0);
-	for_each_sbus(sbus) {
-		sbus_tid[sbus->board] = cpuid;
-		set_sbi_tid(sbus->devid, cpuid << 3);
+	for_each_node_by_name(dp, "sbi") {
+		int devid = of_getintprop_default(dp, "device-id", 0);
+		int board = of_getintprop_default(dp, "board#", 0);
+		sbus_tid[board] = cpuid;
+		set_sbi_tid(devid, cpuid << 3);
 	}
 	printk("All sbus IRQs directed to CPU%d\n", cpuid);
 #endif
@@ -541,29 +549,34 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 
 void __init sun4d_init_sbi_irq(void)
 {
-	struct sbus_bus *sbus;
-	unsigned mask;
+	struct device_node *dp;
 
 	nsbi = 0;
-	for_each_sbus(sbus)
+	for_each_node_by_name(dp, "sbi")
 		nsbi++;
 	sbus_actions = kzalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
 	if (!sbus_actions) {
 		prom_printf("SUN4D: Cannot allocate sbus_actions, halting.\n");
 		prom_halt();
 	}
-	for_each_sbus(sbus) {
+	for_each_node_by_name(dp, "sbi") {
+		int devid = of_getintprop_default(dp, "device-id", 0);
+		int board = of_getintprop_default(dp, "board#", 0);
+		unsigned int mask;
+
 #ifdef CONFIG_SMP	
-		extern unsigned char boot_cpu_id;
+		{
+			extern unsigned char boot_cpu_id;
 		
-		set_sbi_tid(sbus->devid, boot_cpu_id << 3);
-		sbus_tid[sbus->board] = boot_cpu_id;
+			set_sbi_tid(devid, boot_cpu_id << 3);
+			sbus_tid[board] = boot_cpu_id;
+		}
 #endif
 		/* Get rid of pending irqs from PROM */
-		mask = acquire_sbi(sbus->devid, 0xffffffff);
+		mask = acquire_sbi(devid, 0xffffffff);
 		if (mask) {
-			printk ("Clearing pending IRQs %08x on SBI %d\n", mask, sbus->board);
-			release_sbi(sbus->devid, mask);
+			printk ("Clearing pending IRQs %08x on SBI %d\n", mask, board);
+			release_sbi(devid, mask);
 		}
 	}
 }

commit c61c65cdcd1021cfbd7be8685ff1cf4f86c68c44
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jun 5 11:40:58 2008 -0700

    sparc/kernel/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global code static:
      - apc.c: apc_swift_idle()
      - ebus.c: ebus_blacklist_irq()
      - ebus.c: fill_ebus_child()
      - ebus.c: fill_ebus_device()
      - entry.S: syscall_is_too_hard
      - etra: tsetup_sun4c_stackchk
      - head.S: cputyp
      - head.S: prom_vector_p
      - idprom.c: Sun_Machines[]
      - ioport.c: _sparc_find_resource()
      - ioport.c: create_proc_read_entry()
      - irq.c: struct sparc_irq[]
      - rtrap.S: sun4c_rett_stackchk
      - setup.c: prom_sync_me()
      - setup.c: boot_flags
      - sun4c_irq.c: sun4c_sbint_to_irq()
      - sun4d_irq.c: sbus_tid[]
      - sun4d_irq.c: struct sbus_actions
      - sun4d_irq.c: sun4d_sbint_to_irq()
      - sun4m_irq.c: sun4m_sbint_to_irq()
      - sun4m_irq.c: sun4m_get_irqmask()
      - sun4m_irq.c: sun4m_timers
      - sun4m_smp.c: smp4m_cross_call()
      - sun4m_smp.c: smp4m_blackbox_id()
      - sun4m_smp.c: smp4m_blackbox_current()
      - time.c: sp_clock_typ
      - time.c: sbus_time_init()
      - traps.c: instruction_dump()
      - wof.S: spwin_sun4c_stackchk
      - wuf.S: sun4c_fwin_stackchk
    - #if 0 the following unused code:
      - process.c: sparc_backtrace_lock
      - process.c: __show_backtrace()
      - process.c: show_backtrace()
      - process.c: smp_show_backtrace_all_cpus()
    - remove the following unused code:
      - entry.S: __handle_exception
      - smp.c: smp_num_cpus
      - smp.c: smp_activated
      - smp.c: __cpu_number_map[]
      - smp.c: __cpu_logical_map[]
      - smp.c: bitops_spinlock
      - traps.c: trap_curbuf
      - traps.c: trapbuf[]
      - traps.c: linux_smp_still_initting
      - traps.c: thiscpus_tbr
      - traps.c: thiscpus_mid
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 8ac5661cafff..1290b5998f83 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -52,13 +52,13 @@ extern struct irqaction static_irqaction[MAX_STATIC_ALLOC];
 extern int static_irq_count;
 unsigned char cpu_leds[32];
 #ifdef CONFIG_SMP
-unsigned char sbus_tid[32];
+static unsigned char sbus_tid[32];
 #endif
 
 static struct irqaction *irq_action[NR_IRQS];
 extern spinlock_t irq_action_lock;
 
-struct sbus_action {
+static struct sbus_action {
 	struct irqaction *action;
 	/* For SMP this needs to be extended */
 } *sbus_actions;
@@ -267,7 +267,8 @@ unsigned int sun4d_build_irq(struct sbus_dev *sdev, int irq)
 		return irq;
 }
 
-unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev, unsigned int sbint)
+static unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev,
+				       unsigned int sbint)
 {
 	if (sbint >= sizeof(sbus_to_pil)) {
 		printk(KERN_ERR "%s: bogus SBINT %d\n", sdev->prom_name, sbint);

commit 88278ca27a43ae503572b52ea2c171fbf45db5a2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon May 19 16:53:02 2008 -0700

    sparc: remove CVS keywords
    
    This patch removes the CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index e0efab2a6bef..8ac5661cafff 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -1,4 +1,4 @@
-/*  $Id: sun4d_irq.c,v 1.29 2001/12/11 04:55:51 davem Exp $
+/*
  *  arch/sparc/kernel/sun4d_irq.c:
  *			SS1000/SC2000 interrupt handling.
  *

commit 0f516813ce5aa78b30084cd0cc2e7e2ba1777168
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 21 19:19:38 2007 -0700

    [SPARC32]: Take enable_irq/disable_irq out of line.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 7a09186a432e..e0efab2a6bef 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -190,7 +190,7 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 	kfree(action);
 
 	if (!(*actionp))
-		disable_irq(irq);
+		__disable_irq(irq);
 
 out_unlock:
 	spin_unlock_irqrestore(&irq_action_lock, flags);
@@ -348,7 +348,7 @@ int sun4d_request_irq(unsigned int irq,
 	else
 		*actionp = action;
 		
-	enable_irq(irq);
+	__enable_irq(irq);
 
 	ret = 0;
 out_unlock:

commit 32231a66b4e1b649c346dc76b7d191f7e64a663a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 21 19:18:57 2007 -0700

    [SPARC32]: clean include/asm-sparc/irq.h
    
    Move stuff used only by arch/sparc/kernel/* into arch/sparc/kernel/irq.h
    and into individual files in there (e.g. macros internal to sun4m_irq.c,
    etc.)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 396797e20c39..7a09186a432e 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -39,6 +39,8 @@
 #include <asm/cacheflush.h>
 #include <asm/irq_regs.h>
 
+#include "irq.h"
+
 /* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
 /* #define DISTRIBUTE_IRQS */
 

commit d1a78c32edcabea8c7c6449c967191a47f83a77f
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Fri May 11 13:51:23 2007 -0700

    [SPARC]: Spelling fixes.
    
    Spelling fixes in arch/sparc/.
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 116d6a241ca2..396797e20c39 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -521,7 +521,7 @@ static void __init sun4d_init_timers(irq_handler_t counter_fn)
 		lvl14_save[2] += smp4d_ticker - real_irq_entry;
 
 		/* For SMP we use the level 14 ticker, however the bootup code
-		 * has copied the firmwares level 14 vector into boot cpu's
+		 * has copied the firmware's level 14 vector into the boot cpu's
 		 * trap table, we must fix this now or we get squashed.
 		 */
 		local_irq_save(flags);

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 0e27e226e0e2..116d6a241ca2 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -17,7 +17,6 @@
 #include <linux/random.h>
 #include <linux/init.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/seq_file.h>
 

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index cf1b8baa57ea..0e27e226e0e2 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -327,7 +327,7 @@ int sun4d_request_irq(unsigned int irq,
 	}
 	
 	if (action == NULL)
-		action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
+		action = kmalloc(sizeof(struct irqaction),
 						     GFP_ATOMIC);
 	
 	if (!action) { 

commit d4accd60d23f3c8a576fd08b727f88096f42d445
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Nov 30 17:11:26 2006 -0800

    [SPARC]: Check kzalloc() return value in SUN4D irq/iommu init.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index b8bd53ab29c5..cf1b8baa57ea 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -546,6 +546,10 @@ void __init sun4d_init_sbi_irq(void)
 	for_each_sbus(sbus)
 		nsbi++;
 	sbus_actions = kzalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
+	if (!sbus_actions) {
+		prom_printf("SUN4D: Cannot allocate sbus_actions, halting.\n");
+		prom_halt();
+	}
 	for_each_sbus(sbus) {
 #ifdef CONFIG_SMP	
 		extern unsigned char boot_cpu_id;

commit c80892d150a872b18cedfbf789211bfbebfc67ce
Author: Yan Burman <burman.yan@gmail.com>
Date:   Thu Nov 30 17:07:04 2006 -0800

    [SPARC]: Replace kmalloc+memset with kzalloc
    
    Replace kmalloc+memset with kzalloc
    
    Signed-off-by: Yan Burman <burman.yan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index d4f9da8170c5..b8bd53ab29c5 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -545,8 +545,7 @@ void __init sun4d_init_sbi_irq(void)
 	nsbi = 0;
 	for_each_sbus(sbus)
 		nsbi++;
-	sbus_actions = (struct sbus_action *)kmalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
-	memset (sbus_actions, 0, (nsbi * 8 * 4 * sizeof(struct sbus_action)));
+	sbus_actions = kzalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
 	for_each_sbus(sbus) {
 #ifdef CONFIG_SMP	
 		extern unsigned char boot_cpu_id;

commit 40220c1a192f51695f806d75b1f9970f0f17a6e8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 9 12:19:47 2006 +0100

    IRQ: Use the new typedef for interrupt handler function pointers
    
    Use the new typedef for interrupt handler function pointers rather than
    actually spelling out the full thing each time.  This was scripted with the
    following small shell script:
    
    #!/bin/sh
    egrep -nHrl -e 'irqreturn_t[    ]*[(][*]' $* |
    while read i
    do
        echo $i
        perl -pi -e 's/irqreturn_t\s*[(]\s*[*]\s*([_a-zA-Z0-9]*)\s*[)]\s*[(]\s*int\s*,\s*void\s*[*]\s*[)]/irq_handler_t \1/g' $i || exit $?
    done
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 836d1562787a..d4f9da8170c5 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -276,7 +276,7 @@ unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev, unsigned int sbint)
 }
 
 int sun4d_request_irq(unsigned int irq,
-		irqreturn_t (*handler)(int, void *),
+		irq_handler_t handler,
 		unsigned long irqflags, const char * devname, void *dev_id)
 {
 	struct irqaction *action, *tmp = NULL, **actionp;
@@ -470,7 +470,7 @@ static void sun4d_load_profile_irq(int cpu, unsigned int limit)
 	bw_set_prof_limit(cpu, limit);
 }
 
-static void __init sun4d_init_timers(irqreturn_t (*counter_fn)(int, void *))
+static void __init sun4d_init_timers(irq_handler_t counter_fn)
 {
 	int irq;
 	int cpu;

commit 0d84438d98777b0f9425d39121c42f47a06878ca
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 8 14:30:44 2006 +0100

    [PATCH] sparc32 pt_regs fixes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 74eed9775ac0..836d1562787a 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -38,6 +38,7 @@
 #include <asm/sbus.h>
 #include <asm/sbi.h>
 #include <asm/cacheflush.h>
+#include <asm/irq_regs.h>
 
 /* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
 /* #define DISTRIBUTE_IRQS */
@@ -198,6 +199,7 @@ extern void unexpected_irq(int, void *, struct pt_regs *);
 
 void sun4d_handler_irq(int irq, struct pt_regs * regs)
 {
+	struct pt_regs *old_regs;
 	struct irqaction * action;
 	int cpu = smp_processor_id();
 	/* SBUS IRQ level (1 - 7) */
@@ -208,6 +210,7 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 	
 	cc_set_iclr(1 << irq);
 	
+	old_regs = set_irq_regs(regs);
 	irq_enter();
 	kstat_cpu(cpu).irqs[irq]++;
 	if (!sbusl) {
@@ -215,7 +218,7 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 		if (!action)
 			unexpected_irq(irq, NULL, regs);
 		do {
-			action->handler(irq, action->dev_id, regs);
+			action->handler(irq, action->dev_id);
 			action = action->next;
 		} while (action);
 	} else {
@@ -242,7 +245,7 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 						if (!action)
 							unexpected_irq(irq, NULL, regs);
 						do {
-							action->handler(irq, action->dev_id, regs);
+							action->handler(irq, action->dev_id);
 							action = action->next;
 						} while (action);
 						release_sbi(SBI2DEVID(sbino), slot);
@@ -250,6 +253,7 @@ void sun4d_handler_irq(int irq, struct pt_regs * regs)
 			}
 	}
 	irq_exit();
+	set_irq_regs(old_regs);
 }
 
 unsigned int sun4d_build_irq(struct sbus_dev *sdev, int irq)
@@ -272,7 +276,7 @@ unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev, unsigned int sbint)
 }
 
 int sun4d_request_irq(unsigned int irq,
-		irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		irqreturn_t (*handler)(int, void *),
 		unsigned long irqflags, const char * devname, void *dev_id)
 {
 	struct irqaction *action, *tmp = NULL, **actionp;
@@ -466,7 +470,7 @@ static void sun4d_load_profile_irq(int cpu, unsigned int limit)
 	bw_set_prof_limit(cpu, limit);
 }
 
-static void __init sun4d_init_timers(irqreturn_t (*counter_fn)(int, void *, struct pt_regs *))
+static void __init sun4d_init_timers(irqreturn_t (*counter_fn)(int, void *))
 {
 	int irq;
 	int cpu;

commit 6741320247fbf147ab8aa41b2a7201425ac1e1df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:26 2006 -0700

    [PATCH] irq-flags: SPARC: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index cbf8ee81cf5b..74eed9775ac0 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -107,13 +107,13 @@ found_it:	seq_printf(p, "%3d: ", i);
 			       kstat_cpu(cpu_logical_map(x)).irqs[i]);
 #endif
 		seq_printf(p, "%c %s",
-			(action->flags & SA_INTERRUPT) ? '+' : ' ',
+			(action->flags & IRQF_DISABLED) ? '+' : ' ',
 			action->name);
 		action = action->next;
 		for (;;) {
 			for (; action; action = action->next) {
 				seq_printf(p, ",%s %s",
-					(action->flags & SA_INTERRUPT) ? " +" : "",
+					(action->flags & IRQF_DISABLED) ? " +" : "",
 					action->name);
 			}
 			if (!sbusl) break;
@@ -160,7 +160,7 @@ void sun4d_free_irq(unsigned int irq, void *dev_id)
 			printk("Trying to free free shared IRQ%d\n",irq);
 			goto out_unlock;
 		}
-	} else if (action->flags & SA_SHIRQ) {
+	} else if (action->flags & IRQF_SHARED) {
 		printk("Trying to free shared IRQ%d with NULL device ID\n", irq);
 		goto out_unlock;
 	}
@@ -298,13 +298,13 @@ int sun4d_request_irq(unsigned int irq,
 	action = *actionp;
 	
 	if (action) {
-		if ((action->flags & SA_SHIRQ) && (irqflags & SA_SHIRQ)) {
+		if ((action->flags & IRQF_SHARED) && (irqflags & IRQF_SHARED)) {
 			for (tmp = action; tmp->next; tmp = tmp->next);
 		} else {
 			ret = -EBUSY;
 			goto out_unlock;
 		}
-		if ((action->flags & SA_INTERRUPT) ^ (irqflags & SA_INTERRUPT)) {
+		if ((action->flags & IRQF_DISABLED) ^ (irqflags & IRQF_DISABLED)) {
 			printk("Attempt to mix fast and slow interrupts on IRQ%d denied\n", irq);
 			ret = -EBUSY;
 			goto out_unlock;
@@ -490,7 +490,7 @@ static void __init sun4d_init_timers(irqreturn_t (*counter_fn)(int, void *, stru
 
 	irq = request_irq(TIMER_IRQ,
 			  counter_fn,
-			  (SA_INTERRUPT | SA_STATIC_ALLOC),
+			  (IRQF_DISABLED | SA_STATIC_ALLOC),
 			  "timer", NULL);
 	if (irq) {
 		prom_printf("time_init: unable to attach IRQ%d\n",TIMER_IRQ);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 9c30e35c88f7..cbf8ee81cf5b 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -6,7 +6,6 @@
  *  Heavily based on arch/sparc/kernel/irq.c.
  */
 
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/linkage.h>
 #include <linux/kernel_stat.h>

commit c6387a48cf5958e43c201fc27a158c328927531a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 20 01:21:29 2006 -0700

    [SPARC]: Kill __irq_itoa().
    
    This ugly hack was long overdue to die.
    
    It was a way to print out Sparc interrupts in a more freindly format,
    since IRQ numbers were arbitrary opaque 32-bit integers which vectored
    into PIL levels.  These 32-bit integers were not necessarily in the
    0-->NR_IRQS range, but the PILs they vectored to were.
    
    The idea now is that we will increase NR_IRQS a little bit and use a
    virtual<-->real IRQ number mapping scheme similar to PowerPC.
    
    That makes this IRQ printing hack irrelevant, and furthermore only a
    handful of drivers actually used __irq_itoa() making it even less
    useful.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index ca656d9bd6fd..9c30e35c88f7 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -560,17 +560,6 @@ void __init sun4d_init_sbi_irq(void)
 	}
 }
 
-static char *sun4d_irq_itoa(unsigned int irq)
-{
-	static char buff[16];
-	
-	if (irq < (1 << 5))
-		sprintf(buff, "%d", irq);
-	else
-		sprintf(buff, "%d,%x", sbus_to_pil[(irq >> 2) & 7], irq);
-	return buff;
-}
-
 void __init sun4d_init_IRQ(void)
 {
 	local_irq_disable();
@@ -581,7 +570,6 @@ void __init sun4d_init_IRQ(void)
 	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(clear_profile_irq, sun4d_clear_profile_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(__irq_itoa, sun4d_irq_itoa, BTFIXUPCALL_NORM);
 	sparc_init_timers = sun4d_init_timers;
 #ifdef CONFIG_SMP
 	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);

commit a54123e27779049d27d21e6c8adfee73aa2c0734
Author: Bob Breuer <breuerr@mc.net>
Date:   Thu Mar 23 22:36:19 2006 -0800

    [SPARC]: Try to start getting SMP back into shape.
    
    Todo items:
     - IRQ_INPROGRESS flag - use sparc64 irq buckets, or generic irq_desc?
     - sun4d
     - re-indent large chunks of sun4m_smp.c
     - some places assume sequential cpu numbering (i.e. 0,1 instead of 0,2)
    
    Last I checked (with 2.6.14), random programs segfault with dual
    HyperSPARC.  And with SuperSPARC II's, it seems stable but will
    eventually die from a write lock error (wrong lock owner or something).
    
    I haven't tried the HyperSPARC + highmem combination recently, so that
    may still be a problem.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index cea7fc6fc6e5..ca656d9bd6fd 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -54,7 +54,7 @@ unsigned char cpu_leds[32];
 unsigned char sbus_tid[32];
 #endif
 
-extern struct irqaction *irq_action[];
+static struct irqaction *irq_action[NR_IRQS];
 extern spinlock_t irq_action_lock;
 
 struct sbus_action {

commit 394e3902c55e667945f6f1c2bdbc59842cce70f7
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Mar 23 03:01:05 2006 -0800

    [PATCH] more for_each_cpu() conversions
    
    When we stop allocating percpu memory for not-possible CPUs we must not touch
    the percpu data for not-possible CPUs at all.  The correct way of doing this
    is to test cpu_possible() or to use for_each_cpu().
    
    This patch is a kernel-wide sweep of all instances of NR_CPUS.  I found very
    few instances of this bug, if any.  But the patch converts lots of open-coded
    test to use the preferred helper macros.
    
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Acked-by: Kyle McMartin <kyle@parisc-linux.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Christian Zankel <chris@zankel.net>
    Cc: Philippe Elie <phil.el@wanadoo.fr>
    Cc: Nathan Scott <nathans@sgi.com>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
index 52621348a56c..cea7fc6fc6e5 100644
--- a/arch/sparc/kernel/sun4d_irq.c
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -103,11 +103,9 @@ found_it:	seq_printf(p, "%3d: ", i);
 #ifndef CONFIG_SMP
 		seq_printf(p, "%10u ", kstat_irqs(i));
 #else
-		for (x = 0; x < NR_CPUS; x++) {
-			if (cpu_online(x))
-				seq_printf(p, "%10u ",
-				       kstat_cpu(cpu_logical_map(x)).irqs[i]);
-		}
+		for_each_online_cpu(x)
+			seq_printf(p, "%10u ",
+			       kstat_cpu(cpu_logical_map(x)).irqs[i]);
 #endif
 		seq_printf(p, "%c %s",
 			(action->flags & SA_INTERRUPT) ? '+' : ' ',

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sparc/kernel/sun4d_irq.c b/arch/sparc/kernel/sun4d_irq.c
new file mode 100644
index 000000000000..52621348a56c
--- /dev/null
+++ b/arch/sparc/kernel/sun4d_irq.c
@@ -0,0 +1,594 @@
+/*  $Id: sun4d_irq.c,v 1.29 2001/12/11 04:55:51 davem Exp $
+ *  arch/sparc/kernel/sun4d_irq.c:
+ *			SS1000/SC2000 interrupt handling.
+ *
+ *  Copyright (C) 1997,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+ *  Heavily based on arch/sparc/kernel/irq.c.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/linkage.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/spinlock.h>
+#include <linux/seq_file.h>
+
+#include <asm/ptrace.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/psr.h>
+#include <asm/smp.h>
+#include <asm/vaddrs.h>
+#include <asm/timer.h>
+#include <asm/openprom.h>
+#include <asm/oplib.h>
+#include <asm/traps.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/sbus.h>
+#include <asm/sbi.h>
+#include <asm/cacheflush.h>
+
+/* If you trust current SCSI layer to handle different SCSI IRQs, enable this. I don't trust it... -jj */
+/* #define DISTRIBUTE_IRQS */
+
+struct sun4d_timer_regs *sun4d_timers;
+#define TIMER_IRQ	10
+
+#define MAX_STATIC_ALLOC	4
+extern struct irqaction static_irqaction[MAX_STATIC_ALLOC];
+extern int static_irq_count;
+unsigned char cpu_leds[32];
+#ifdef CONFIG_SMP
+unsigned char sbus_tid[32];
+#endif
+
+extern struct irqaction *irq_action[];
+extern spinlock_t irq_action_lock;
+
+struct sbus_action {
+	struct irqaction *action;
+	/* For SMP this needs to be extended */
+} *sbus_actions;
+
+static int pil_to_sbus[] = {
+	0, 0, 1, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 0,
+};
+
+static int sbus_to_pil[] = {
+	0, 2, 3, 5, 7, 9, 11, 13,
+};
+
+static int nsbi;
+#ifdef CONFIG_SMP
+DEFINE_SPINLOCK(sun4d_imsk_lock);
+#endif
+
+int show_sun4d_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v, j = 0, k = 0, sbusl;
+	struct irqaction * action;
+	unsigned long flags;
+#ifdef CONFIG_SMP
+	int x;
+#endif
+
+	spin_lock_irqsave(&irq_action_lock, flags);
+	if (i < NR_IRQS) {
+		sbusl = pil_to_sbus[i];
+		if (!sbusl) {
+	 		action = *(i + irq_action);
+			if (!action) 
+		        	goto out_unlock;
+		} else {
+			for (j = 0; j < nsbi; j++) {
+				for (k = 0; k < 4; k++)
+					if ((action = sbus_actions [(j << 5) + (sbusl << 2) + k].action))
+						goto found_it;
+			}
+			goto out_unlock;
+		}
+found_it:	seq_printf(p, "%3d: ", i);
+#ifndef CONFIG_SMP
+		seq_printf(p, "%10u ", kstat_irqs(i));
+#else
+		for (x = 0; x < NR_CPUS; x++) {
+			if (cpu_online(x))
+				seq_printf(p, "%10u ",
+				       kstat_cpu(cpu_logical_map(x)).irqs[i]);
+		}
+#endif
+		seq_printf(p, "%c %s",
+			(action->flags & SA_INTERRUPT) ? '+' : ' ',
+			action->name);
+		action = action->next;
+		for (;;) {
+			for (; action; action = action->next) {
+				seq_printf(p, ",%s %s",
+					(action->flags & SA_INTERRUPT) ? " +" : "",
+					action->name);
+			}
+			if (!sbusl) break;
+			k++;
+			if (k < 4)
+				action = sbus_actions [(j << 5) + (sbusl << 2) + k].action;
+			else {
+				j++;
+				if (j == nsbi) break;
+				k = 0;
+				action = sbus_actions [(j << 5) + (sbusl << 2)].action;
+			}
+		}
+		seq_putc(p, '\n');
+	}
+out_unlock:
+	spin_unlock_irqrestore(&irq_action_lock, flags);
+	return 0;
+}
+
+void sun4d_free_irq(unsigned int irq, void *dev_id)
+{
+	struct irqaction *action, **actionp;
+	struct irqaction *tmp = NULL;
+        unsigned long flags;
+
+	spin_lock_irqsave(&irq_action_lock, flags);
+	if (irq < 15)
+		actionp = irq + irq_action;
+	else
+		actionp = &(sbus_actions[irq - (1 << 5)].action);
+	action = *actionp;
+	if (!action) {
+		printk("Trying to free free IRQ%d\n",irq);
+		goto out_unlock;
+	}
+	if (dev_id) {
+		for (; action; action = action->next) {
+			if (action->dev_id == dev_id)
+				break;
+			tmp = action;
+		}
+		if (!action) {
+			printk("Trying to free free shared IRQ%d\n",irq);
+			goto out_unlock;
+		}
+	} else if (action->flags & SA_SHIRQ) {
+		printk("Trying to free shared IRQ%d with NULL device ID\n", irq);
+		goto out_unlock;
+	}
+	if (action->flags & SA_STATIC_ALLOC)
+	{
+		/* This interrupt is marked as specially allocated
+		 * so it is a bad idea to free it.
+		 */
+		printk("Attempt to free statically allocated IRQ%d (%s)\n",
+		       irq, action->name);
+		goto out_unlock;
+	}
+	
+	if (action && tmp)
+		tmp->next = action->next;
+	else
+		*actionp = action->next;
+
+	spin_unlock_irqrestore(&irq_action_lock, flags);
+
+	synchronize_irq(irq);
+
+	spin_lock_irqsave(&irq_action_lock, flags);
+
+	kfree(action);
+
+	if (!(*actionp))
+		disable_irq(irq);
+
+out_unlock:
+	spin_unlock_irqrestore(&irq_action_lock, flags);
+}
+
+extern void unexpected_irq(int, void *, struct pt_regs *);
+
+void sun4d_handler_irq(int irq, struct pt_regs * regs)
+{
+	struct irqaction * action;
+	int cpu = smp_processor_id();
+	/* SBUS IRQ level (1 - 7) */
+	int sbusl = pil_to_sbus[irq];
+	
+	/* FIXME: Is this necessary?? */
+	cc_get_ipen();
+	
+	cc_set_iclr(1 << irq);
+	
+	irq_enter();
+	kstat_cpu(cpu).irqs[irq]++;
+	if (!sbusl) {
+		action = *(irq + irq_action);
+		if (!action)
+			unexpected_irq(irq, NULL, regs);
+		do {
+			action->handler(irq, action->dev_id, regs);
+			action = action->next;
+		} while (action);
+	} else {
+		int bus_mask = bw_get_intr_mask(sbusl) & 0x3ffff;
+		int sbino;
+		struct sbus_action *actionp;
+		unsigned mask, slot;
+		int sbil = (sbusl << 2);
+		
+		bw_clear_intr_mask(sbusl, bus_mask);
+		
+		/* Loop for each pending SBI */
+		for (sbino = 0; bus_mask; sbino++, bus_mask >>= 1)
+			if (bus_mask & 1) {
+				mask = acquire_sbi(SBI2DEVID(sbino), 0xf << sbil);
+				mask &= (0xf << sbil);
+				actionp = sbus_actions + (sbino << 5) + (sbil);
+				/* Loop for each pending SBI slot */
+				for (slot = (1 << sbil); mask; slot <<= 1, actionp++)
+					if (mask & slot) {
+						mask &= ~slot;
+						action = actionp->action;
+						
+						if (!action)
+							unexpected_irq(irq, NULL, regs);
+						do {
+							action->handler(irq, action->dev_id, regs);
+							action = action->next;
+						} while (action);
+						release_sbi(SBI2DEVID(sbino), slot);
+					}
+			}
+	}
+	irq_exit();
+}
+
+unsigned int sun4d_build_irq(struct sbus_dev *sdev, int irq)
+{
+	int sbusl = pil_to_sbus[irq];
+
+	if (sbusl)
+		return ((sdev->bus->board + 1) << 5) + (sbusl << 2) + sdev->slot;
+	else
+		return irq;
+}
+
+unsigned int sun4d_sbint_to_irq(struct sbus_dev *sdev, unsigned int sbint)
+{
+	if (sbint >= sizeof(sbus_to_pil)) {
+		printk(KERN_ERR "%s: bogus SBINT %d\n", sdev->prom_name, sbint);
+		BUG();
+	}
+	return sun4d_build_irq(sdev, sbus_to_pil[sbint]);
+}
+
+int sun4d_request_irq(unsigned int irq,
+		irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		unsigned long irqflags, const char * devname, void *dev_id)
+{
+	struct irqaction *action, *tmp = NULL, **actionp;
+	unsigned long flags;
+	int ret;
+	
+	if(irq > 14 && irq < (1 << 5)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (!handler) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	spin_lock_irqsave(&irq_action_lock, flags);
+
+	if (irq >= (1 << 5))
+		actionp = &(sbus_actions[irq - (1 << 5)].action);
+	else
+		actionp = irq + irq_action;
+	action = *actionp;
+	
+	if (action) {
+		if ((action->flags & SA_SHIRQ) && (irqflags & SA_SHIRQ)) {
+			for (tmp = action; tmp->next; tmp = tmp->next);
+		} else {
+			ret = -EBUSY;
+			goto out_unlock;
+		}
+		if ((action->flags & SA_INTERRUPT) ^ (irqflags & SA_INTERRUPT)) {
+			printk("Attempt to mix fast and slow interrupts on IRQ%d denied\n", irq);
+			ret = -EBUSY;
+			goto out_unlock;
+		}
+		action = NULL;		/* Or else! */
+	}
+
+	/* If this is flagged as statically allocated then we use our
+	 * private struct which is never freed.
+	 */
+	if (irqflags & SA_STATIC_ALLOC) {
+		if (static_irq_count < MAX_STATIC_ALLOC)
+			action = &static_irqaction[static_irq_count++];
+		else
+			printk("Request for IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc\n", irq, devname);
+	}
+	
+	if (action == NULL)
+		action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
+						     GFP_ATOMIC);
+	
+	if (!action) { 
+		ret = -ENOMEM;
+		goto out_unlock;
+	}
+
+	action->handler = handler;
+	action->flags = irqflags;
+	cpus_clear(action->mask);
+	action->name = devname;
+	action->next = NULL;
+	action->dev_id = dev_id;
+
+	if (tmp)
+		tmp->next = action;
+	else
+		*actionp = action;
+		
+	enable_irq(irq);
+
+	ret = 0;
+out_unlock:
+	spin_unlock_irqrestore(&irq_action_lock, flags);
+out:
+	return ret;
+}
+
+static void sun4d_disable_irq(unsigned int irq)
+{
+#ifdef CONFIG_SMP
+	int tid = sbus_tid[(irq >> 5) - 1];
+	unsigned long flags;
+#endif	
+	
+	if (irq < NR_IRQS) return;
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&sun4d_imsk_lock, flags);
+	cc_set_imsk_other(tid, cc_get_imsk_other(tid) | (1 << sbus_to_pil[(irq >> 2) & 7]));
+	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
+#else		
+	cc_set_imsk(cc_get_imsk() | (1 << sbus_to_pil[(irq >> 2) & 7]));
+#endif
+}
+
+static void sun4d_enable_irq(unsigned int irq)
+{
+#ifdef CONFIG_SMP
+	int tid = sbus_tid[(irq >> 5) - 1];
+	unsigned long flags;
+#endif	
+	
+	if (irq < NR_IRQS) return;
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&sun4d_imsk_lock, flags);
+	cc_set_imsk_other(tid, cc_get_imsk_other(tid) & ~(1 << sbus_to_pil[(irq >> 2) & 7]));
+	spin_unlock_irqrestore(&sun4d_imsk_lock, flags);
+#else		
+	cc_set_imsk(cc_get_imsk() & ~(1 << sbus_to_pil[(irq >> 2) & 7]));
+#endif
+}
+
+#ifdef CONFIG_SMP
+static void sun4d_set_cpu_int(int cpu, int level)
+{
+	sun4d_send_ipi(cpu, level);
+}
+
+static void sun4d_clear_ipi(int cpu, int level)
+{
+}
+
+static void sun4d_set_udt(int cpu)
+{
+}
+
+/* Setup IRQ distribution scheme. */
+void __init sun4d_distribute_irqs(void)
+{
+#ifdef DISTRIBUTE_IRQS
+	struct sbus_bus *sbus;
+	unsigned long sbus_serving_map;
+
+	sbus_serving_map = cpu_present_map;
+	for_each_sbus(sbus) {
+		if ((sbus->board * 2) == boot_cpu_id && (cpu_present_map & (1 << (sbus->board * 2 + 1))))
+			sbus_tid[sbus->board] = (sbus->board * 2 + 1);
+		else if (cpu_present_map & (1 << (sbus->board * 2)))
+			sbus_tid[sbus->board] = (sbus->board * 2);
+		else if (cpu_present_map & (1 << (sbus->board * 2 + 1)))
+			sbus_tid[sbus->board] = (sbus->board * 2 + 1);
+		else
+			sbus_tid[sbus->board] = 0xff;
+		if (sbus_tid[sbus->board] != 0xff)
+			sbus_serving_map &= ~(1 << sbus_tid[sbus->board]);
+	}
+	for_each_sbus(sbus)
+		if (sbus_tid[sbus->board] == 0xff) {
+			int i = 31;
+				
+			if (!sbus_serving_map)
+				sbus_serving_map = cpu_present_map;
+			while (!(sbus_serving_map & (1 << i)))
+				i--;
+			sbus_tid[sbus->board] = i;
+			sbus_serving_map &= ~(1 << i);
+		}
+	for_each_sbus(sbus) {
+		printk("sbus%d IRQs directed to CPU%d\n", sbus->board, sbus_tid[sbus->board]);
+		set_sbi_tid(sbus->devid, sbus_tid[sbus->board] << 3);
+	}
+#else
+	struct sbus_bus *sbus;
+	int cpuid = cpu_logical_map(1);
+
+	if (cpuid == -1)
+		cpuid = cpu_logical_map(0);
+	for_each_sbus(sbus) {
+		sbus_tid[sbus->board] = cpuid;
+		set_sbi_tid(sbus->devid, cpuid << 3);
+	}
+	printk("All sbus IRQs directed to CPU%d\n", cpuid);
+#endif
+}
+#endif
+ 
+static void sun4d_clear_clock_irq(void)
+{
+	volatile unsigned int clear_intr;
+	clear_intr = sun4d_timers->l10_timer_limit;
+}
+
+static void sun4d_clear_profile_irq(int cpu)
+{
+	bw_get_prof_limit(cpu);
+}
+
+static void sun4d_load_profile_irq(int cpu, unsigned int limit)
+{
+	bw_set_prof_limit(cpu, limit);
+}
+
+static void __init sun4d_init_timers(irqreturn_t (*counter_fn)(int, void *, struct pt_regs *))
+{
+	int irq;
+	int cpu;
+	struct resource r;
+	int mid;
+
+	/* Map the User Timer registers. */
+	memset(&r, 0, sizeof(r));
+#ifdef CONFIG_SMP
+	r.start = CSR_BASE(boot_cpu_id)+BW_TIMER_LIMIT;
+#else
+	r.start = CSR_BASE(0)+BW_TIMER_LIMIT;
+#endif
+	r.flags = 0xf;
+	sun4d_timers = (struct sun4d_timer_regs *) sbus_ioremap(&r, 0,
+	    PAGE_SIZE, "user timer");
+
+	sun4d_timers->l10_timer_limit =  (((1000000/HZ) + 1) << 10);
+	master_l10_counter = &sun4d_timers->l10_cur_count;
+	master_l10_limit = &sun4d_timers->l10_timer_limit;
+
+	irq = request_irq(TIMER_IRQ,
+			  counter_fn,
+			  (SA_INTERRUPT | SA_STATIC_ALLOC),
+			  "timer", NULL);
+	if (irq) {
+		prom_printf("time_init: unable to attach IRQ%d\n",TIMER_IRQ);
+		prom_halt();
+	}
+	
+	/* Enable user timer free run for CPU 0 in BW */
+	/* bw_set_ctrl(0, bw_get_ctrl(0) | BW_CTRL_USER_TIMER); */
+
+	cpu = 0;
+	while (!cpu_find_by_instance(cpu, NULL, &mid)) {
+		sun4d_load_profile_irq(mid >> 3, 0);
+		cpu++;
+	}
+		
+#ifdef CONFIG_SMP
+	{
+		unsigned long flags;
+		extern unsigned long lvl14_save[4];
+		struct tt_entry *trap_table = &sparc_ttable[SP_TRAP_IRQ1 + (14 - 1)];
+		extern unsigned int real_irq_entry[], smp4d_ticker[];
+		extern unsigned int patchme_maybe_smp_msg[];
+
+		/* Adjust so that we jump directly to smp4d_ticker */
+		lvl14_save[2] += smp4d_ticker - real_irq_entry;
+
+		/* For SMP we use the level 14 ticker, however the bootup code
+		 * has copied the firmwares level 14 vector into boot cpu's
+		 * trap table, we must fix this now or we get squashed.
+		 */
+		local_irq_save(flags);
+		patchme_maybe_smp_msg[0] = 0x01000000; /* NOP out the branch */
+		trap_table->inst_one = lvl14_save[0];
+		trap_table->inst_two = lvl14_save[1];
+		trap_table->inst_three = lvl14_save[2];
+		trap_table->inst_four = lvl14_save[3];
+		local_flush_cache_all();
+		local_irq_restore(flags);
+	}
+#endif
+}
+
+void __init sun4d_init_sbi_irq(void)
+{
+	struct sbus_bus *sbus;
+	unsigned mask;
+
+	nsbi = 0;
+	for_each_sbus(sbus)
+		nsbi++;
+	sbus_actions = (struct sbus_action *)kmalloc (nsbi * 8 * 4 * sizeof(struct sbus_action), GFP_ATOMIC);
+	memset (sbus_actions, 0, (nsbi * 8 * 4 * sizeof(struct sbus_action)));
+	for_each_sbus(sbus) {
+#ifdef CONFIG_SMP	
+		extern unsigned char boot_cpu_id;
+		
+		set_sbi_tid(sbus->devid, boot_cpu_id << 3);
+		sbus_tid[sbus->board] = boot_cpu_id;
+#endif
+		/* Get rid of pending irqs from PROM */
+		mask = acquire_sbi(sbus->devid, 0xffffffff);
+		if (mask) {
+			printk ("Clearing pending IRQs %08x on SBI %d\n", mask, sbus->board);
+			release_sbi(sbus->devid, mask);
+		}
+	}
+}
+
+static char *sun4d_irq_itoa(unsigned int irq)
+{
+	static char buff[16];
+	
+	if (irq < (1 << 5))
+		sprintf(buff, "%d", irq);
+	else
+		sprintf(buff, "%d,%x", sbus_to_pil[(irq >> 2) & 7], irq);
+	return buff;
+}
+
+void __init sun4d_init_IRQ(void)
+{
+	local_irq_disable();
+
+	BTFIXUPSET_CALL(sbint_to_irq, sun4d_sbint_to_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(enable_irq, sun4d_enable_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(disable_irq, sun4d_disable_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(clear_clock_irq, sun4d_clear_clock_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(clear_profile_irq, sun4d_clear_profile_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(load_profile_irq, sun4d_load_profile_irq, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(__irq_itoa, sun4d_irq_itoa, BTFIXUPCALL_NORM);
+	sparc_init_timers = sun4d_init_timers;
+#ifdef CONFIG_SMP
+	BTFIXUPSET_CALL(set_cpu_int, sun4d_set_cpu_int, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(clear_cpu_int, sun4d_clear_ipi, BTFIXUPCALL_NOP);
+	BTFIXUPSET_CALL(set_irq_udt, sun4d_set_udt, BTFIXUPCALL_NOP);
+#endif
+	/* Cannot enable interrupts until OBP ticker is disabled. */
+}
