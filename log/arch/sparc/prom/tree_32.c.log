commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index f30e8d038f01..0fed89375b74 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * tree.c: Basic device tree traversal/scanning for the Linux
  *         prom library.

commit 0bd2cbcdfaff9cb22267d66fc843fa4f73f0c281
Merge: 57cc7215b708 a081748735c5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 10 08:57:03 2011 -0800

    Merge branch 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6
    
    * 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6: (29 commits)
      of/flattree: forward declare struct device_node in of_fdt.h
      ipmi: explicitly include of_address.h and of_irq.h
      sparc: explicitly cast negative phandle checks to s32
      powerpc/405: Fix missing #{address,size}-cells in i2c node
      powerpc/5200: dts: refactor dts files
      powerpc/5200: dts: Change combatible strings on localbus
      powerpc/5200: dts: remove unused properties
      powerpc/5200: dts: rename nodes to prepare for refactoring dts files
      of/flattree: Update dtc to current mainline.
      of/device: Don't register disabled devices
      powerpc/dts: fix syntax bugs in bluestone.dts
      of: Fixes for OF probing on little endian systems
      of: make drivers depend on CONFIG_OF instead of CONFIG_PPC_OF
      of/flattree: Add of_flat_dt_match() helper function
      of_serial: explicitly include of_irq.h
      of/flattree: Refactor unflatten_device_tree and add fdt_unflatten_tree
      of/flattree: Reorder unflatten_dt_node
      of/flattree: Refactor unflatten_dt_node
      of/flattree: Add non-boottime device tree functions
      of/flattree: Add Kconfig for EARLY_FLATTREE
      ...
    
    Fix up trivial conflict in arch/sparc/prom/tree_32.c as per Grant.

commit 4a3a255289e7e322b8044286cce85031990f888a
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Nov 11 22:42:06 2010 -0800

    sparc: explicitly cast negative phandle checks to s32
    
    When we switched sparc from using 'int's to 'phandle's (which is a u32), we
    neglected to do anything with the various checks for -1.  For those tests,
    explicitly cast the phandles to s32.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 535e2e69ac1d..f1d0734c245e 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -40,11 +40,11 @@ phandle prom_getchild(phandle node)
 {
 	phandle cnode;
 
-	if (node == -1)
+	if ((s32)node == -1)
 		return 0;
 
 	cnode = __prom_getchild(node);
-	if (cnode == 0 || cnode == -1)
+	if (cnode == 0 || (s32)cnode == -1)
 		return 0;
 
 	return cnode;
@@ -72,11 +72,11 @@ phandle prom_getsibling(phandle node)
 {
 	phandle sibnode;
 
-	if (node == -1)
+	if ((s32)node == -1)
 		return 0;
 
 	sibnode = __prom_getsibling(node);
-	if (sibnode == 0 || sibnode == -1)
+	if (sibnode == 0 || (s32)sibnode == -1)
 		return 0;
 
 	return sibnode;
@@ -231,7 +231,7 @@ char *__prom_nextprop(phandle node, char * oprop)
 /* buffer is unused argument, but as v9 uses it, we need to have the same interface */
 char *prom_firstprop(phandle node, char *bufer)
 {
-	if (node == 0 || node == -1)
+	if (node == 0 || (s32)node == -1)
 		return "";
 
 	return __prom_nextprop(node, "");
@@ -244,7 +244,7 @@ EXPORT_SYMBOL(prom_firstprop);
  */
 char *prom_nextprop(phandle node, char *oprop, char *buffer)
 {
-	if (node == 0 || node == -1)
+	if (node == 0 || (s32)node == -1)
 		return "";
 
 	return __prom_nextprop(node, oprop);
@@ -278,7 +278,7 @@ phandle prom_finddevice(char *name)
 				if (d != s + 3 && (!*d || *d == '/')
 				    && d <= s + 3 + 8) {
 					node2 = node;
-					while (node2 && node2 != -1) {
+					while (node2 && (s32)node2 != -1) {
 						if (prom_getproperty (node2, "reg", (char *)reg, sizeof (reg)) > 0) {
 							if (which_io == reg[0].which_io && phys_addr == reg[0].phys_addr) {
 								node = node2;
@@ -286,7 +286,7 @@ phandle prom_finddevice(char *name)
 							}
 						}
 						node2 = prom_getsibling(node2);
-						if (!node2 || node2 == -1)
+						if (!node2 || (s32)node2 == -1)
 							break;
 						node2 = prom_searchsiblings(prom_getsibling(node2), nbuf);
 					}
@@ -339,6 +339,7 @@ phandle prom_inst2pkg(int inst)
 	node = (*romvec->pv_v2devops.v2_inst2pkg)(inst);
 	restore_current();
 	spin_unlock_irqrestore(&prom_lock, flags);
-	if (node == -1) return 0;
+	if ((s32)node == -1)
+		return 0;
 	return node;
 }

commit 5f66dd35b49ea81a03e71bfd74c28364f4e32d21
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jan 3 08:27:55 2011 +0000

    sparc: fix sparse warnings in arch/sparc/prom for 32 bit build
    
    Fix following sparse warnings:
    arch/sparc/prom/bootstr_32.c:32:35: warning: Using plain integer as NULL pointer
    arch/sparc/prom/memory.c:61:13: warning: symbol 'prom_meminit' was not declared. Should it be static?
    arch/sparc/prom/misc_32.c:74:1: error: symbol 'prom_halt' redeclared with different type (originally declared at arch/sparc/include/asm/oplib_32.h:67) - different modifiers
    arch/sparc/prom/ranges.c:16:26: warning: symbol 'promlib_obio_ranges' was not declared. Should it be static?
    arch/sparc/prom/ranges.c:17:5: warning: symbol 'num_obio_ranges' was not declared. Should it be static?
    arch/sparc/prom/ranges.c:39:1: warning: symbol 'prom_adjust_ranges' was not declared. Should it be static?
    arch/sparc/prom/ranges.c:69:13: warning: symbol 'prom_ranges_init' was not declared. Should it be static?
    arch/sparc/prom/tree_32.c:286:22: warning: Using plain integer as NULL pointer
    arch/sparc/prom/tree_32.c:286:38: warning: Using plain integer as NULL pointer
    
    None of the warnings indicated any serious issues.
    
    We are now sparse clean for 32 bit build in arch/sparc/prom.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index f8860eba32c2..bc8e4cb87a68 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -282,8 +282,10 @@ int prom_setprop(phandle node, const char *pname, char *value, int size)
 	unsigned long flags;
 	int ret;
 
-	if(size == 0) return 0;
-	if((pname == 0) || (value == 0)) return 0;
+	if (size == 0)
+		return 0;
+	if ((pname == NULL) || (value == NULL))
+		return 0;
 	spin_lock_irqsave(&prom_lock, flags);
 	ret = prom_nodeops->no_setprop(node, pname, value, size);
 	restore_current();

commit 1f42be484ffc5559a29466c82adac7dd472d4439
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jan 1 12:53:11 2011 +0000

    sparc: remove unused prom tree functions
    
    Remove the following unused funtions:
    prom_nodematch()
    prom_firstprop()
    prom_node_has_property()
    
    Also declare a few local functions static.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 535e2e69ac1d..f8860eba32c2 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -20,7 +20,7 @@ extern void restore_current(void);
 static char promlib_buf[128];
 
 /* Internal version of prom_getchild that does not alter return values. */
-phandle __prom_getchild(phandle node)
+static phandle __prom_getchild(phandle node)
 {
 	unsigned long flags;
 	phandle cnode;
@@ -52,7 +52,7 @@ phandle prom_getchild(phandle node)
 EXPORT_SYMBOL(prom_getchild);
 
 /* Internal version of prom_getsibling that does not alter return values. */
-phandle __prom_getsibling(phandle node)
+static phandle __prom_getsibling(phandle node)
 {
 	unsigned long flags;
 	phandle cnode;
@@ -177,20 +177,6 @@ void prom_getstring(phandle node, char *prop, char *user_buf, int ubuf_size)
 EXPORT_SYMBOL(prom_getstring);
 
 
-/* Does the device at node 'node' have name 'name'?
- * YES = 1   NO = 0
- */
-int prom_nodematch(phandle node, char *name)
-{
-	int error;
-
-	static char namebuf[128];
-	error = prom_getproperty(node, "name", namebuf, sizeof(namebuf));
-	if (error == -1) return 0;
-	if(strcmp(namebuf, name) == 0) return 1;
-	return 0;
-}
-
 /* Search siblings at 'node_start' for a node with name
  * 'nodename'.  Return node if successful, zero if not.
  */
@@ -214,7 +200,7 @@ phandle prom_searchsiblings(phandle node_start, char *nodename)
 EXPORT_SYMBOL(prom_searchsiblings);
 
 /* Interal version of nextprop that does not alter return values. */
-char *__prom_nextprop(phandle node, char * oprop)
+static char *__prom_nextprop(phandle node, char * oprop)
 {
 	unsigned long flags;
 	char *prop;
@@ -227,17 +213,6 @@ char *__prom_nextprop(phandle node, char * oprop)
 	return prop;
 }
 
-/* Return the first property name for node 'node'. */
-/* buffer is unused argument, but as v9 uses it, we need to have the same interface */
-char *prom_firstprop(phandle node, char *bufer)
-{
-	if (node == 0 || node == -1)
-		return "";
-
-	return __prom_nextprop(node, "");
-}
-EXPORT_SYMBOL(prom_firstprop);
-
 /* Return the property type string after property type 'oprop'
  * at node 'node' .  Returns empty string if no more
  * property types for this node.
@@ -299,19 +274,6 @@ phandle prom_finddevice(char *name)
 }
 EXPORT_SYMBOL(prom_finddevice);
 
-int prom_node_has_property(phandle node, char *prop)
-{
-	char *current_property = "";
-
-	do {
-		current_property = prom_nextprop(node, current_property, NULL);
-		if(!strcmp(current_property, prop))
-		   return 1;
-	} while (*current_property);
-	return 0;
-}
-EXPORT_SYMBOL(prom_node_has_property);
-
 /* Set property 'pname' at node 'node' to value 'value' which has a length
  * of 'size' bytes.  Return the number of bytes the prom accepted.
  */

commit 17d70d6df0c4ea7a203b444001572a91ad9c2bef
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Nov 16 12:11:15 2010 -0800

    sparc: Remove prom_pathtoinode()
    
    Unused.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 63e08e149774..535e2e69ac1d 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -342,19 +342,3 @@ phandle prom_inst2pkg(int inst)
 	if (node == -1) return 0;
 	return node;
 }
-
-/* Return 'node' assigned to a particular prom 'path'
- * FIXME: Should work for v0 as well
- */
-phandle prom_pathtoinode(char *path)
-{
-	phandle node;
-	int inst;
-	
-	inst = prom_devopen (path);
-	if (inst == -1) return 0;
-	node = prom_inst2pkg (inst);
-	prom_devclose (inst);
-	if (node == -1) return 0;
-	return node;
-}

commit 8d1255627d4ce9cb4b9d0a1c44b6c18d92e84a99
Author: Andres Salomon <dilinger@queued.net>
Date:   Fri Oct 8 14:18:11 2010 -0700

    of/sparc: convert various prom_* functions to use phandle
    
    Rather than passing around ints everywhere, use the
    phandle type where appropriate for the various functions
    that talk to the PROM.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index b21592f8e3fe..63e08e149774 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -20,10 +20,10 @@ extern void restore_current(void);
 static char promlib_buf[128];
 
 /* Internal version of prom_getchild that does not alter return values. */
-int __prom_getchild(int node)
+phandle __prom_getchild(phandle node)
 {
 	unsigned long flags;
-	int cnode;
+	phandle cnode;
 
 	spin_lock_irqsave(&prom_lock, flags);
 	cnode = prom_nodeops->no_child(node);
@@ -36,9 +36,9 @@ int __prom_getchild(int node)
 /* Return the child of node 'node' or zero if no this node has no
  * direct descendent.
  */
-int prom_getchild(int node)
+phandle prom_getchild(phandle node)
 {
-	int cnode;
+	phandle cnode;
 
 	if (node == -1)
 		return 0;
@@ -52,10 +52,10 @@ int prom_getchild(int node)
 EXPORT_SYMBOL(prom_getchild);
 
 /* Internal version of prom_getsibling that does not alter return values. */
-int __prom_getsibling(int node)
+phandle __prom_getsibling(phandle node)
 {
 	unsigned long flags;
-	int cnode;
+	phandle cnode;
 
 	spin_lock_irqsave(&prom_lock, flags);
 	cnode = prom_nodeops->no_nextnode(node);
@@ -68,9 +68,9 @@ int __prom_getsibling(int node)
 /* Return the next sibling of node 'node' or zero if no more siblings
  * at this level of depth in the tree.
  */
-int prom_getsibling(int node)
+phandle prom_getsibling(phandle node)
 {
-	int sibnode;
+	phandle sibnode;
 
 	if (node == -1)
 		return 0;
@@ -86,7 +86,7 @@ EXPORT_SYMBOL(prom_getsibling);
 /* Return the length in bytes of property 'prop' at node 'node'.
  * Return -1 on error.
  */
-int prom_getproplen(int node, const char *prop)
+int prom_getproplen(phandle node, const char *prop)
 {
 	int ret;
 	unsigned long flags;
@@ -106,7 +106,7 @@ EXPORT_SYMBOL(prom_getproplen);
  * 'buffer' which has a size of 'bufsize'.  If the acquisition
  * was successful the length will be returned, else -1 is returned.
  */
-int prom_getproperty(int node, const char *prop, char *buffer, int bufsize)
+int prom_getproperty(phandle node, const char *prop, char *buffer, int bufsize)
 {
 	int plen, ret;
 	unsigned long flags;
@@ -126,7 +126,7 @@ EXPORT_SYMBOL(prom_getproperty);
 /* Acquire an integer property and return its value.  Returns -1
  * on failure.
  */
-int prom_getint(int node, char *prop)
+int prom_getint(phandle node, char *prop)
 {
 	static int intprop;
 
@@ -140,7 +140,7 @@ EXPORT_SYMBOL(prom_getint);
 /* Acquire an integer property, upon error return the passed default
  * integer.
  */
-int prom_getintdefault(int node, char *property, int deflt)
+int prom_getintdefault(phandle node, char *property, int deflt)
 {
 	int retval;
 
@@ -152,7 +152,7 @@ int prom_getintdefault(int node, char *property, int deflt)
 EXPORT_SYMBOL(prom_getintdefault);
 
 /* Acquire a boolean property, 1=TRUE 0=FALSE. */
-int prom_getbool(int node, char *prop)
+int prom_getbool(phandle node, char *prop)
 {
 	int retval;
 
@@ -166,7 +166,7 @@ EXPORT_SYMBOL(prom_getbool);
  * string on error.  The char pointer is the user supplied string
  * buffer.
  */
-void prom_getstring(int node, char *prop, char *user_buf, int ubuf_size)
+void prom_getstring(phandle node, char *prop, char *user_buf, int ubuf_size)
 {
 	int len;
 
@@ -180,7 +180,7 @@ EXPORT_SYMBOL(prom_getstring);
 /* Does the device at node 'node' have name 'name'?
  * YES = 1   NO = 0
  */
-int prom_nodematch(int node, char *name)
+int prom_nodematch(phandle node, char *name)
 {
 	int error;
 
@@ -194,10 +194,11 @@ int prom_nodematch(int node, char *name)
 /* Search siblings at 'node_start' for a node with name
  * 'nodename'.  Return node if successful, zero if not.
  */
-int prom_searchsiblings(int node_start, char *nodename)
+phandle prom_searchsiblings(phandle node_start, char *nodename)
 {
 
-	int thisnode, error;
+	phandle thisnode;
+	int error;
 
 	for(thisnode = node_start; thisnode;
 	    thisnode=prom_getsibling(thisnode)) {
@@ -213,7 +214,7 @@ int prom_searchsiblings(int node_start, char *nodename)
 EXPORT_SYMBOL(prom_searchsiblings);
 
 /* Interal version of nextprop that does not alter return values. */
-char * __prom_nextprop(int node, char * oprop)
+char *__prom_nextprop(phandle node, char * oprop)
 {
 	unsigned long flags;
 	char *prop;
@@ -228,7 +229,7 @@ char * __prom_nextprop(int node, char * oprop)
 
 /* Return the first property name for node 'node'. */
 /* buffer is unused argument, but as v9 uses it, we need to have the same interface */
-char * prom_firstprop(int node, char *bufer)
+char *prom_firstprop(phandle node, char *bufer)
 {
 	if (node == 0 || node == -1)
 		return "";
@@ -241,7 +242,7 @@ EXPORT_SYMBOL(prom_firstprop);
  * at node 'node' .  Returns empty string if no more
  * property types for this node.
  */
-char * prom_nextprop(int node, char *oprop, char *buffer)
+char *prom_nextprop(phandle node, char *oprop, char *buffer)
 {
 	if (node == 0 || node == -1)
 		return "";
@@ -250,11 +251,11 @@ char * prom_nextprop(int node, char *oprop, char *buffer)
 }
 EXPORT_SYMBOL(prom_nextprop);
 
-int prom_finddevice(char *name)
+phandle prom_finddevice(char *name)
 {
 	char nbuf[128];
 	char *s = name, *d;
-	int node = prom_root_node, node2;
+	phandle node = prom_root_node, node2;
 	unsigned int which_io, phys_addr;
 	struct linux_prom_registers reg[PROMREG_MAX];
 
@@ -298,7 +299,7 @@ int prom_finddevice(char *name)
 }
 EXPORT_SYMBOL(prom_finddevice);
 
-int prom_node_has_property(int node, char *prop)
+int prom_node_has_property(phandle node, char *prop)
 {
 	char *current_property = "";
 
@@ -314,7 +315,7 @@ EXPORT_SYMBOL(prom_node_has_property);
 /* Set property 'pname' at node 'node' to value 'value' which has a length
  * of 'size' bytes.  Return the number of bytes the prom accepted.
  */
-int prom_setprop(int node, const char *pname, char *value, int size)
+int prom_setprop(phandle node, const char *pname, char *value, int size)
 {
 	unsigned long flags;
 	int ret;
@@ -329,9 +330,9 @@ int prom_setprop(int node, const char *pname, char *value, int size)
 }
 EXPORT_SYMBOL(prom_setprop);
 
-int prom_inst2pkg(int inst)
+phandle prom_inst2pkg(int inst)
 {
-	int node;
+	phandle node;
 	unsigned long flags;
 	
 	spin_lock_irqsave(&prom_lock, flags);
@@ -345,9 +346,10 @@ int prom_inst2pkg(int inst)
 /* Return 'node' assigned to a particular prom 'path'
  * FIXME: Should work for v0 as well
  */
-int prom_pathtoinode(char *path)
+phandle prom_pathtoinode(char *path)
 {
-	int node, inst;
+	phandle node;
+	int inst;
 	
 	inst = prom_devopen (path);
 	if (inst == -1) return 0;

commit 1349ea08e8de7b3e09998f33ea4e6c74f3e0db1a
Author: Jan Engelhardt <jengelh@medozas.de>
Date:   Wed Feb 10 11:47:57 2010 -0800

    sparc: remove redundant return statements
    
    Signed-off-by: Jan Engelhardt <jengelh@medozas.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 646d244b1fdb..b21592f8e3fe 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -173,7 +173,6 @@ void prom_getstring(int node, char *prop, char *user_buf, int ubuf_size)
 	len = prom_getproperty(node, prop, user_buf, ubuf_size);
 	if(len != -1) return;
 	user_buf[0] = 0;
-	return;
 }
 EXPORT_SYMBOL(prom_getstring);
 

commit 222bfda032d01d99501257e01a79833094f689f6
Author: Julian Calaby <julian.calaby@gmail.com>
Date:   Thu Jan 8 16:59:01 2009 -0800

    sparc: Eliminate PROMLIB_INTERNAL as it does nothing
    
    Signed-off-by: Julian Calaby <julian.calaby@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 431e04c364e2..646d244b1fdb 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -5,8 +5,6 @@
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
  */
 
-#define PROMLIB_INTERNAL
-
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/kernel.h>

commit bc835978cfb5dbb904a9d2e13804b6c343743530
Author: Julian Calaby <julian.calaby@gmail.com>
Date:   Thu Jan 8 16:58:42 2009 -0800

    sparc: Kill exports of prom internal functions
    
    __prom_getchild() and __prom_getsibling() are not used anywhere, so
    don't export them.
    
    Signed-off-by: Julian Calaby <julian.calaby@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 9d9965cd8bca..431e04c364e2 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -34,7 +34,6 @@ int __prom_getchild(int node)
 
 	return cnode;
 }
-EXPORT_SYMBOL(__prom_getchild);
 
 /* Return the child of node 'node' or zero if no this node has no
  * direct descendent.
@@ -67,7 +66,6 @@ int __prom_getsibling(int node)
 
 	return cnode;
 }
-EXPORT_SYMBOL(__prom_getsibling);
 
 /* Return the next sibling of node 'node' or zero if no more siblings
  * at this level of depth in the tree.

commit 6943f3da3e64edd95ee2d33abc0a642357746ba6
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jan 8 16:58:05 2009 -0800

    sparc: move EXPORT_SYMBOL to the symbols definition
    
    Move all applicable EXPORT_SYMBOL()s to the file where the respective
    symbol is defined.
    
    Removed all the includes that are no longer needed in sparc_ksyms_32.c
    
    Comment all remaining EXPORT_SYMBOL()s in sparc_ksyms_32.c
    
    Two symbols are shared with sparc64 thus the exports were removed from
    the sparc_ksyms_64.c too, along with the include their ommission made
    redundant.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    
    Additions by Julian Calaby:
    * Moved EXPORT_SYMBOL()s for prom functions to their rightful places.
    * Made some minor cleanups to the includes and comments of sparc_ksyms_32.c
    * Made another subtraction from sparc_ksyms_64.c
    * Updated and tidied commit message.
    * Rebased patch over sparc-2.6.git HEAD.
    * Ensured that all modified files have the correct includes.
    
    Signed-off-by: Julian Calaby <julian.calaby@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index 6d8187357331..9d9965cd8bca 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/ctype.h>
+#include <linux/module.h>
 
 #include <asm/openprom.h>
 #include <asm/oplib.h>
@@ -33,6 +34,7 @@ int __prom_getchild(int node)
 
 	return cnode;
 }
+EXPORT_SYMBOL(__prom_getchild);
 
 /* Return the child of node 'node' or zero if no this node has no
  * direct descendent.
@@ -50,6 +52,7 @@ int prom_getchild(int node)
 
 	return cnode;
 }
+EXPORT_SYMBOL(prom_getchild);
 
 /* Internal version of prom_getsibling that does not alter return values. */
 int __prom_getsibling(int node)
@@ -64,6 +67,7 @@ int __prom_getsibling(int node)
 
 	return cnode;
 }
+EXPORT_SYMBOL(__prom_getsibling);
 
 /* Return the next sibling of node 'node' or zero if no more siblings
  * at this level of depth in the tree.
@@ -81,6 +85,7 @@ int prom_getsibling(int node)
 
 	return sibnode;
 }
+EXPORT_SYMBOL(prom_getsibling);
 
 /* Return the length in bytes of property 'prop' at node 'node'.
  * Return -1 on error.
@@ -99,6 +104,7 @@ int prom_getproplen(int node, const char *prop)
 	spin_unlock_irqrestore(&prom_lock, flags);
 	return ret;
 }
+EXPORT_SYMBOL(prom_getproplen);
 
 /* Acquire a property 'prop' at node 'node' and place it in
  * 'buffer' which has a size of 'bufsize'.  If the acquisition
@@ -119,6 +125,7 @@ int prom_getproperty(int node, const char *prop, char *buffer, int bufsize)
 	spin_unlock_irqrestore(&prom_lock, flags);
 	return ret;
 }
+EXPORT_SYMBOL(prom_getproperty);
 
 /* Acquire an integer property and return its value.  Returns -1
  * on failure.
@@ -132,6 +139,7 @@ int prom_getint(int node, char *prop)
 
 	return -1;
 }
+EXPORT_SYMBOL(prom_getint);
 
 /* Acquire an integer property, upon error return the passed default
  * integer.
@@ -145,6 +153,7 @@ int prom_getintdefault(int node, char *property, int deflt)
 
 	return retval;
 }
+EXPORT_SYMBOL(prom_getintdefault);
 
 /* Acquire a boolean property, 1=TRUE 0=FALSE. */
 int prom_getbool(int node, char *prop)
@@ -155,6 +164,7 @@ int prom_getbool(int node, char *prop)
 	if(retval == -1) return 0;
 	return 1;
 }
+EXPORT_SYMBOL(prom_getbool);
 
 /* Acquire a property whose value is a string, returns a null
  * string on error.  The char pointer is the user supplied string
@@ -169,6 +179,7 @@ void prom_getstring(int node, char *prop, char *user_buf, int ubuf_size)
 	user_buf[0] = 0;
 	return;
 }
+EXPORT_SYMBOL(prom_getstring);
 
 
 /* Does the device at node 'node' have name 'name'?
@@ -204,6 +215,7 @@ int prom_searchsiblings(int node_start, char *nodename)
 
 	return 0;
 }
+EXPORT_SYMBOL(prom_searchsiblings);
 
 /* Interal version of nextprop that does not alter return values. */
 char * __prom_nextprop(int node, char * oprop)
@@ -228,6 +240,7 @@ char * prom_firstprop(int node, char *bufer)
 
 	return __prom_nextprop(node, "");
 }
+EXPORT_SYMBOL(prom_firstprop);
 
 /* Return the property type string after property type 'oprop'
  * at node 'node' .  Returns empty string if no more
@@ -240,6 +253,7 @@ char * prom_nextprop(int node, char *oprop, char *buffer)
 
 	return __prom_nextprop(node, oprop);
 }
+EXPORT_SYMBOL(prom_nextprop);
 
 int prom_finddevice(char *name)
 {
@@ -287,6 +301,7 @@ int prom_finddevice(char *name)
 	}
 	return node;
 }
+EXPORT_SYMBOL(prom_finddevice);
 
 int prom_node_has_property(int node, char *prop)
 {
@@ -299,6 +314,7 @@ int prom_node_has_property(int node, char *prop)
 	} while (*current_property);
 	return 0;
 }
+EXPORT_SYMBOL(prom_node_has_property);
 
 /* Set property 'pname' at node 'node' to value 'value' which has a length
  * of 'size' bytes.  Return the number of bytes the prom accepted.
@@ -316,6 +332,7 @@ int prom_setprop(int node, const char *pname, char *value, int size)
 	spin_unlock_irqrestore(&prom_lock, flags);
 	return ret;
 }
+EXPORT_SYMBOL(prom_setprop);
 
 int prom_inst2pkg(int inst)
 {

commit ab04323e5b8c50d6e8f7f4a3e4118ba5fcba61a1
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Dec 5 16:54:44 2008 -0800

    sparc: Const'ify prom_*prop*() on sparc32.
    
    This brings things in line with sparc64.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
index f228fe057b24..6d8187357331 100644
--- a/arch/sparc/prom/tree_32.c
+++ b/arch/sparc/prom/tree_32.c
@@ -85,7 +85,7 @@ int prom_getsibling(int node)
 /* Return the length in bytes of property 'prop' at node 'node'.
  * Return -1 on error.
  */
-int prom_getproplen(int node, char *prop)
+int prom_getproplen(int node, const char *prop)
 {
 	int ret;
 	unsigned long flags;
@@ -104,7 +104,7 @@ int prom_getproplen(int node, char *prop)
  * 'buffer' which has a size of 'bufsize'.  If the acquisition
  * was successful the length will be returned, else -1 is returned.
  */
-int prom_getproperty(int node, char *prop, char *buffer, int bufsize)
+int prom_getproperty(int node, const char *prop, char *buffer, int bufsize)
 {
 	int plen, ret;
 	unsigned long flags;
@@ -303,7 +303,7 @@ int prom_node_has_property(int node, char *prop)
 /* Set property 'pname' at node 'node' to value 'value' which has a length
  * of 'size' bytes.  Return the number of bytes the prom accepted.
  */
-int prom_setprop(int node, char *pname, char *value, int size)
+int prom_setprop(int node, const char *pname, char *value, int size)
 {
 	unsigned long flags;
 	int ret;

commit 708d4f09647106d549c646dc459c7ccf2c237cc8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 29 22:15:38 2008 -0800

    sparc: prepare prom/ for unification
    
    - rename files where sparc64 uses identical names to *_32.c
    - refactor Makefile (but keep linking order)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/prom/tree_32.c b/arch/sparc/prom/tree_32.c
new file mode 100644
index 000000000000..f228fe057b24
--- /dev/null
+++ b/arch/sparc/prom/tree_32.c
@@ -0,0 +1,346 @@
+/*
+ * tree.c: Basic device tree traversal/scanning for the Linux
+ *         prom library.
+ *
+ * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#define PROMLIB_INTERNAL
+
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+
+#include <asm/openprom.h>
+#include <asm/oplib.h>
+
+extern void restore_current(void);
+
+static char promlib_buf[128];
+
+/* Internal version of prom_getchild that does not alter return values. */
+int __prom_getchild(int node)
+{
+	unsigned long flags;
+	int cnode;
+
+	spin_lock_irqsave(&prom_lock, flags);
+	cnode = prom_nodeops->no_child(node);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+
+	return cnode;
+}
+
+/* Return the child of node 'node' or zero if no this node has no
+ * direct descendent.
+ */
+int prom_getchild(int node)
+{
+	int cnode;
+
+	if (node == -1)
+		return 0;
+
+	cnode = __prom_getchild(node);
+	if (cnode == 0 || cnode == -1)
+		return 0;
+
+	return cnode;
+}
+
+/* Internal version of prom_getsibling that does not alter return values. */
+int __prom_getsibling(int node)
+{
+	unsigned long flags;
+	int cnode;
+
+	spin_lock_irqsave(&prom_lock, flags);
+	cnode = prom_nodeops->no_nextnode(node);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+
+	return cnode;
+}
+
+/* Return the next sibling of node 'node' or zero if no more siblings
+ * at this level of depth in the tree.
+ */
+int prom_getsibling(int node)
+{
+	int sibnode;
+
+	if (node == -1)
+		return 0;
+
+	sibnode = __prom_getsibling(node);
+	if (sibnode == 0 || sibnode == -1)
+		return 0;
+
+	return sibnode;
+}
+
+/* Return the length in bytes of property 'prop' at node 'node'.
+ * Return -1 on error.
+ */
+int prom_getproplen(int node, char *prop)
+{
+	int ret;
+	unsigned long flags;
+
+	if((!node) || (!prop))
+		return -1;
+		
+	spin_lock_irqsave(&prom_lock, flags);
+	ret = prom_nodeops->no_proplen(node, prop);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+	return ret;
+}
+
+/* Acquire a property 'prop' at node 'node' and place it in
+ * 'buffer' which has a size of 'bufsize'.  If the acquisition
+ * was successful the length will be returned, else -1 is returned.
+ */
+int prom_getproperty(int node, char *prop, char *buffer, int bufsize)
+{
+	int plen, ret;
+	unsigned long flags;
+
+	plen = prom_getproplen(node, prop);
+	if((plen > bufsize) || (plen == 0) || (plen == -1))
+		return -1;
+	/* Ok, things seem all right. */
+	spin_lock_irqsave(&prom_lock, flags);
+	ret = prom_nodeops->no_getprop(node, prop, buffer);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+	return ret;
+}
+
+/* Acquire an integer property and return its value.  Returns -1
+ * on failure.
+ */
+int prom_getint(int node, char *prop)
+{
+	static int intprop;
+
+	if(prom_getproperty(node, prop, (char *) &intprop, sizeof(int)) != -1)
+		return intprop;
+
+	return -1;
+}
+
+/* Acquire an integer property, upon error return the passed default
+ * integer.
+ */
+int prom_getintdefault(int node, char *property, int deflt)
+{
+	int retval;
+
+	retval = prom_getint(node, property);
+	if(retval == -1) return deflt;
+
+	return retval;
+}
+
+/* Acquire a boolean property, 1=TRUE 0=FALSE. */
+int prom_getbool(int node, char *prop)
+{
+	int retval;
+
+	retval = prom_getproplen(node, prop);
+	if(retval == -1) return 0;
+	return 1;
+}
+
+/* Acquire a property whose value is a string, returns a null
+ * string on error.  The char pointer is the user supplied string
+ * buffer.
+ */
+void prom_getstring(int node, char *prop, char *user_buf, int ubuf_size)
+{
+	int len;
+
+	len = prom_getproperty(node, prop, user_buf, ubuf_size);
+	if(len != -1) return;
+	user_buf[0] = 0;
+	return;
+}
+
+
+/* Does the device at node 'node' have name 'name'?
+ * YES = 1   NO = 0
+ */
+int prom_nodematch(int node, char *name)
+{
+	int error;
+
+	static char namebuf[128];
+	error = prom_getproperty(node, "name", namebuf, sizeof(namebuf));
+	if (error == -1) return 0;
+	if(strcmp(namebuf, name) == 0) return 1;
+	return 0;
+}
+
+/* Search siblings at 'node_start' for a node with name
+ * 'nodename'.  Return node if successful, zero if not.
+ */
+int prom_searchsiblings(int node_start, char *nodename)
+{
+
+	int thisnode, error;
+
+	for(thisnode = node_start; thisnode;
+	    thisnode=prom_getsibling(thisnode)) {
+		error = prom_getproperty(thisnode, "name", promlib_buf,
+					 sizeof(promlib_buf));
+		/* Should this ever happen? */
+		if(error == -1) continue;
+		if(strcmp(nodename, promlib_buf)==0) return thisnode;
+	}
+
+	return 0;
+}
+
+/* Interal version of nextprop that does not alter return values. */
+char * __prom_nextprop(int node, char * oprop)
+{
+	unsigned long flags;
+	char *prop;
+
+	spin_lock_irqsave(&prom_lock, flags);
+	prop = prom_nodeops->no_nextprop(node, oprop);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+
+	return prop;
+}
+
+/* Return the first property name for node 'node'. */
+/* buffer is unused argument, but as v9 uses it, we need to have the same interface */
+char * prom_firstprop(int node, char *bufer)
+{
+	if (node == 0 || node == -1)
+		return "";
+
+	return __prom_nextprop(node, "");
+}
+
+/* Return the property type string after property type 'oprop'
+ * at node 'node' .  Returns empty string if no more
+ * property types for this node.
+ */
+char * prom_nextprop(int node, char *oprop, char *buffer)
+{
+	if (node == 0 || node == -1)
+		return "";
+
+	return __prom_nextprop(node, oprop);
+}
+
+int prom_finddevice(char *name)
+{
+	char nbuf[128];
+	char *s = name, *d;
+	int node = prom_root_node, node2;
+	unsigned int which_io, phys_addr;
+	struct linux_prom_registers reg[PROMREG_MAX];
+
+	while (*s++) {
+		if (!*s) return node; /* path '.../' is legal */
+		node = prom_getchild(node);
+
+		for (d = nbuf; *s != 0 && *s != '@' && *s != '/';)
+			*d++ = *s++;
+		*d = 0;
+		
+		node = prom_searchsiblings(node, nbuf);
+		if (!node)
+			return 0;
+
+		if (*s == '@') {
+			if (isxdigit(s[1]) && s[2] == ',') {
+				which_io = simple_strtoul(s+1, NULL, 16);
+				phys_addr = simple_strtoul(s+3, &d, 16);
+				if (d != s + 3 && (!*d || *d == '/')
+				    && d <= s + 3 + 8) {
+					node2 = node;
+					while (node2 && node2 != -1) {
+						if (prom_getproperty (node2, "reg", (char *)reg, sizeof (reg)) > 0) {
+							if (which_io == reg[0].which_io && phys_addr == reg[0].phys_addr) {
+								node = node2;
+								break;
+							}
+						}
+						node2 = prom_getsibling(node2);
+						if (!node2 || node2 == -1)
+							break;
+						node2 = prom_searchsiblings(prom_getsibling(node2), nbuf);
+					}
+				}
+			}
+			while (*s != 0 && *s != '/') s++;
+		}
+	}
+	return node;
+}
+
+int prom_node_has_property(int node, char *prop)
+{
+	char *current_property = "";
+
+	do {
+		current_property = prom_nextprop(node, current_property, NULL);
+		if(!strcmp(current_property, prop))
+		   return 1;
+	} while (*current_property);
+	return 0;
+}
+
+/* Set property 'pname' at node 'node' to value 'value' which has a length
+ * of 'size' bytes.  Return the number of bytes the prom accepted.
+ */
+int prom_setprop(int node, char *pname, char *value, int size)
+{
+	unsigned long flags;
+	int ret;
+
+	if(size == 0) return 0;
+	if((pname == 0) || (value == 0)) return 0;
+	spin_lock_irqsave(&prom_lock, flags);
+	ret = prom_nodeops->no_setprop(node, pname, value, size);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+	return ret;
+}
+
+int prom_inst2pkg(int inst)
+{
+	int node;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&prom_lock, flags);
+	node = (*romvec->pv_v2devops.v2_inst2pkg)(inst);
+	restore_current();
+	spin_unlock_irqrestore(&prom_lock, flags);
+	if (node == -1) return 0;
+	return node;
+}
+
+/* Return 'node' assigned to a particular prom 'path'
+ * FIXME: Should work for v0 as well
+ */
+int prom_pathtoinode(char *path)
+{
+	int node, inst;
+	
+	inst = prom_devopen (path);
+	if (inst == -1) return 0;
+	node = prom_inst2pkg (inst);
+	prom_devclose (inst);
+	if (node == -1) return 0;
+	return node;
+}
