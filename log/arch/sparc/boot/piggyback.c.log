commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
index bb7c95161d71..a7a38fb4ece0 100644
--- a/arch/sparc/boot/piggyback.c
+++ b/arch/sparc/boot/piggyback.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
    Simple utility to make a single-image install kernel with initial ramdisk
    for Sparc tftpbooting without need to set up nfs.
@@ -6,19 +7,7 @@
    Pete Zaitcev <zaitcev@yahoo.com> endian fixes for cross-compiles, 2000.
    Copyright (C) 2011 Sam Ravnborg <sam@ravnborg.org>
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ */
 
 #include <dirent.h>
 #include <stdlib.h>

commit 0032c857454581510de1ca12615de5e38e543c92
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Dec 3 11:24:25 2012 -0800

    sparc: Fix piggyback with newer binutils.
    
    Newer versions of binutils mark '_end' as 'B' instead of 'A' for
    whatever reason.
    
    To be honest, the piggyback code doesn't actually care what kind
    of symbol _start and _end are, it just wants to find them and
    record the address.
    
    So remove the type from the match strings.
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
index c0a798fcf030..bb7c95161d71 100644
--- a/arch/sparc/boot/piggyback.c
+++ b/arch/sparc/boot/piggyback.c
@@ -81,18 +81,18 @@ static void usage(void)
 
 static int start_line(const char *line)
 {
-	if (strcmp(line + 8, " T _start\n") == 0)
+	if (strcmp(line + 10, " _start\n") == 0)
 		return 1;
-	else if (strcmp(line + 16, " T _start\n") == 0)
+	else if (strcmp(line + 18, " _start\n") == 0)
 		return 1;
 	return 0;
 }
 
 static int end_line(const char *line)
 {
-	if (strcmp(line + 8, " A _end\n") == 0)
+	if (strcmp(line + 10, " _end\n") == 0)
 		return 1;
-	else if (strcmp (line + 16, " A _end\n") == 0)
+	else if (strcmp (line + 18, " _end\n") == 0)
 		return 1;
 	return 0;
 }
@@ -100,8 +100,8 @@ static int end_line(const char *line)
 /*
  * Find address for start and end in System.map.
  * The file looks like this:
- * f0004000 T _start
- * f0379f79 A _end
+ * f0004000 ... _start
+ * f0379f79 ... _end
  * 1234567890123456
  * ^coloumn 1
  * There is support for 64 bit addresses too.

commit 050855887236701c5e7ff803b42265824ce99885
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 4 11:39:19 2011 +0000

    sparc: update copyright in piggyback.c
    
    Update copyright info in piggyback.c to include
    info from piggyback_64.c.
    Include my own copyright too.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Josip Rodin <joy@entuzijast.net>
    Cc: Jakub Jelinek <jakub@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
index d56e9de85d27..c0a798fcf030 100644
--- a/arch/sparc/boot/piggyback.c
+++ b/arch/sparc/boot/piggyback.c
@@ -2,8 +2,9 @@
    Simple utility to make a single-image install kernel with initial ramdisk
    for Sparc tftpbooting without need to set up nfs.
 
-   Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+   Copyright (C) 1996,1997 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
    Pete Zaitcev <zaitcev@yahoo.com> endian fixes for cross-compiles, 2000.
+   Copyright (C) 2011 Sam Ravnborg <sam@ravnborg.org>
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by

commit 56818a6f9105ac016ecf5907f7cb63bcdab639fe
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 4 11:39:17 2011 +0000

    sparc: rename piggyback_32 to piggyback
    
    Now that we use the same piggyback for 32 and 64 bit
    we can drop the _32 suffix.
    Include some trivial unification in the Makefile
    now that 32 and 64 bit can share the same piggyback command.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
new file mode 100644
index 000000000000..d56e9de85d27
--- /dev/null
+++ b/arch/sparc/boot/piggyback.c
@@ -0,0 +1,271 @@
+/*
+   Simple utility to make a single-image install kernel with initial ramdisk
+   for Sparc tftpbooting without need to set up nfs.
+
+   Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+   Pete Zaitcev <zaitcev@yahoo.com> endian fixes for cross-compiles, 2000.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#include <dirent.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+/*
+ * Note: run this on an a.out kernel (use elftoaout for it),
+ * as PROM looks for a.out image only.
+ */
+
+#define AOUT_TEXT_OFFSET   32
+
+static int is64bit = 0;
+
+/* align to power-of-two size */
+static int align(int n)
+{
+	if (is64bit)
+		return (n + 0x1fff) & ~0x1fff;
+	else
+		return (n + 0xfff) & ~0xfff;
+}
+
+/* read two bytes as big endian */
+static unsigned short ld2(char *p)
+{
+	return (p[0] << 8) | p[1];
+}
+
+/* save 4 bytes as big endian */
+static void st4(char *p, unsigned int x)
+{
+	p[0] = x >> 24;
+	p[1] = x >> 16;
+	p[2] = x >> 8;
+	p[3] = x;
+}
+
+static void die(const char *str)
+{
+	perror(str);
+	exit(1);
+}
+
+static void usage(void)
+{
+	/* fs_img.gz is an image of initial ramdisk. */
+	fprintf(stderr, "Usage: piggyback bits vmlinux.aout System.map fs_img.gz\n");
+	fprintf(stderr, "\tKernel image will be modified in place.\n");
+	exit(1);
+}
+
+static int start_line(const char *line)
+{
+	if (strcmp(line + 8, " T _start\n") == 0)
+		return 1;
+	else if (strcmp(line + 16, " T _start\n") == 0)
+		return 1;
+	return 0;
+}
+
+static int end_line(const char *line)
+{
+	if (strcmp(line + 8, " A _end\n") == 0)
+		return 1;
+	else if (strcmp (line + 16, " A _end\n") == 0)
+		return 1;
+	return 0;
+}
+
+/*
+ * Find address for start and end in System.map.
+ * The file looks like this:
+ * f0004000 T _start
+ * f0379f79 A _end
+ * 1234567890123456
+ * ^coloumn 1
+ * There is support for 64 bit addresses too.
+ *
+ * Return 0 if either start or end is not found
+ */
+static int get_start_end(const char *filename, unsigned int *start,
+                                               unsigned int *end)
+{
+	FILE *map;
+	char buffer[1024];
+
+	*start = 0;
+	*end = 0;
+	map = fopen(filename, "r");
+	if (!map)
+		die(filename);
+	while (fgets(buffer, 1024, map)) {
+		if (start_line(buffer))
+			*start = strtoul(buffer, NULL, 16);
+		else if (end_line(buffer))
+			*end = strtoul(buffer, NULL, 16);
+	}
+	fclose (map);
+
+	if (*start == 0 || *end == 0)
+		return 0;
+
+	return 1;
+}
+
+#define LOOKBACK (128 * 4)
+#define BUFSIZE 1024
+/*
+ * Find the HdrS entry from head_32/head_64.
+ * We check if it is at the beginning of the file (sparc64 case)
+ * and if not we search for it.
+ * When we search do so in steps of 4 as HdrS is on a 4-byte aligned
+ * address (it is on same alignment as sparc instructions)
+ * Return the offset to the HdrS entry (as off_t)
+ */
+static off_t get_hdrs_offset(int kernelfd, const char *filename)
+{
+	char buffer[BUFSIZE];
+	off_t offset;
+	int i;
+
+	if (lseek(kernelfd, 0, SEEK_SET) < 0)
+		die("lseek");
+	if (read(kernelfd, buffer, BUFSIZE) != BUFSIZE)
+		die(filename);
+
+	if (buffer[40] == 'H' && buffer[41] == 'd' &&
+	    buffer[42] == 'r' && buffer[43] == 'S') {
+		return 40;
+	} else {
+		/*  Find the gokernel label */
+		/* Decode offset from branch instruction */
+		offset = ld2(buffer + AOUT_TEXT_OFFSET + 2) << 2;
+		/* Go back 512 bytes so we do not miss HdrS */
+		offset -= LOOKBACK;
+		/* skip a.out header */
+		offset += AOUT_TEXT_OFFSET;
+		if (lseek(kernelfd, offset, SEEK_SET) < 0)
+			die("lseek");
+		if (read(kernelfd, buffer, BUFSIZE) != BUFSIZE)
+			die(filename);
+
+		for (i = 0; i < LOOKBACK; i += 4) {
+			if (buffer[i + 0] == 'H' && buffer[i + 1] == 'd' &&
+			    buffer[i + 2] == 'r' && buffer[i + 3] == 'S') {
+				return offset + i;
+			}
+		}
+	}
+	fprintf (stderr, "Couldn't find headers signature in %s\n", filename);
+	exit(1);
+}
+
+int main(int argc,char **argv)
+{
+	static char aout_magic[] = { 0x01, 0x03, 0x01, 0x07 };
+	char buffer[1024];
+	unsigned int i, start, end;
+	off_t offset;
+	struct stat s;
+	int image, tail;
+
+	if (argc != 5)
+		usage();
+	if (strcmp(argv[1], "64") == 0)
+		is64bit = 1;
+	if (stat (argv[4], &s) < 0)
+		die(argv[4]);
+
+	if (!get_start_end(argv[3], &start, &end)) {
+		fprintf(stderr, "Could not determine start and end from %s\n",
+		        argv[3]);
+		exit(1);
+	}
+	if ((image = open(argv[2], O_RDWR)) < 0)
+		die(argv[2]);
+	if (read(image, buffer, 512) != 512)
+		die(argv[2]);
+	if (memcmp(buffer, aout_magic, 4) != 0) {
+		fprintf (stderr, "Not a.out. Don't blame me.\n");
+		exit(1);
+	}
+	/*
+	 * We need to fill in values for
+	 * sparc_ramdisk_image + sparc_ramdisk_size
+	 * To locate these symbols search for the "HdrS" text which appear
+	 * in the image a little before the gokernel symbol.
+	 * See definition of these in init_32.S
+	 */
+
+	offset = get_hdrs_offset(image, argv[2]);
+	/* skip HdrS + LINUX_VERSION_CODE + HdrS version */
+	offset += 10;
+
+	if (lseek(image, offset, 0) < 0)
+		die("lseek");
+
+	/*
+	 * root_flags = 0
+	 * root_dev = 1 (RAMDISK_MAJOR)
+	 * ram_flags = 0
+	 * sparc_ramdisk_image = "PAGE aligned address after _end")
+	 * sparc_ramdisk_size = size of image
+	 */
+	st4(buffer, 0);
+	st4(buffer + 4, 0x01000000);
+	st4(buffer + 8, align(end + 32));
+	st4(buffer + 12, s.st_size);
+
+	if (write(image, buffer + 2, 14) != 14)
+		die(argv[2]);
+
+	/* For sparc64 update a_text and clear a_data + a_bss */
+	if (is64bit)
+	{
+		if (lseek(image, 4, 0) < 0)
+			die("lseek");
+		/* a_text */
+		st4(buffer, align(end + 32 + 8191) - (start & ~0x3fffffUL) +
+		            s.st_size);
+		/* a_data */
+		st4(buffer + 4, 0);
+		/* a_bss */
+		st4(buffer + 8, 0);
+		if (write(image, buffer, 12) != 12)
+			die(argv[2]);
+	}
+
+	/* seek page aligned boundary in the image file and add boot image */
+	if (lseek(image, AOUT_TEXT_OFFSET - start + align(end + 32), 0) < 0)
+		die("lseek");
+	if ((tail = open(argv[4], O_RDONLY)) < 0)
+		die(argv[4]);
+	while ((i = read(tail, buffer, 1024)) > 0)
+		if (write(image, buffer, i) != i)
+			die(argv[2]);
+	if (close(image) < 0)
+		die("close");
+	if (close(tail) < 0)
+		die("close");
+	return 0;
+}

commit a8c601ca21e790f6a9d996bb0bf31f7496eb9509
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Dec 3 03:14:26 2008 -0800

    sparc,sparc64: unify boot/
    
    Simple unification:
    o renamed piggyback to *_32.c/*_64.c
    o copied content of Makefile from sparc64 to sparc and guard it
    o updated sparc/boot/.gitignore
    o deleted remaining files in sparc64/boot
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
deleted file mode 100644
index c9f500c1a8b2..000000000000
--- a/arch/sparc/boot/piggyback.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
-   Simple utility to make a single-image install kernel with initial ramdisk
-   for Sparc tftpbooting without need to set up nfs.
-
-   Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
-   Pete Zaitcev <zaitcev@yahoo.com> endian fixes for cross-compiles, 2000.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
-   
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-/*
- * Note: run this on an a.out kernel (use elftoaout for it),
- * as PROM looks for a.out image only.
- */
-
-unsigned short ld2(char *p)
-{
-	return (p[0] << 8) | p[1];
-}
-
-unsigned int ld4(char *p)
-{
-	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
-}
-
-void st4(char *p, unsigned int x)
-{
-	p[0] = x >> 24;
-	p[1] = x >> 16;
-	p[2] = x >> 8;
-	p[3] = x;
-}
-
-void usage(void)
-{
-	/* fs_img.gz is an image of initial ramdisk. */
-	fprintf(stderr, "Usage: piggyback vmlinux.aout System.map fs_img.gz\n");
-	fprintf(stderr, "\tKernel image will be modified in place.\n");
-	exit(1);
-}
-
-void die(char *str)
-{
-	perror (str);
-	exit(1);
-}
-
-int main(int argc,char **argv)
-{
-	static char aout_magic[] = { 0x01, 0x03, 0x01, 0x07 };
-	unsigned char buffer[1024], *q, *r;
-	unsigned int i, j, k, start, end, offset;
-	FILE *map;
-	struct stat s;
-	int image, tail;
-
-	if (argc != 4) usage();
-	start = end = 0;
-	if (stat (argv[3], &s) < 0) die (argv[3]);
-	map = fopen (argv[2], "r");
-	if (!map) die(argv[2]);
-	while (fgets (buffer, 1024, map)) {
-		if (!strcmp (buffer + 8, " T start\n") || !strcmp (buffer + 16, " T start\n"))
-			start = strtoul (buffer, NULL, 16);
-		else if (!strcmp (buffer + 8, " A end\n") || !strcmp (buffer + 16, " A end\n"))
-			end = strtoul (buffer, NULL, 16);
-	}
-	fclose (map);
-	if (!start || !end) {
-		fprintf (stderr, "Could not determine start and end from System.map\n");
-		exit(1);
-	}
-	if ((image = open(argv[1],O_RDWR)) < 0) die(argv[1]);
-	if (read(image,buffer,512) != 512) die(argv[1]);
-	if (memcmp (buffer, "\177ELF", 4) == 0) {
-		q = buffer + ld4(buffer + 28);
-		i = ld4(q + 4) + ld4(buffer + 24) - ld4(q + 8);
-		if (lseek(image,i,0) < 0) die("lseek");
-		if (read(image,buffer,512) != 512) die(argv[1]);
-		j = 0;
-	} else if (memcmp(buffer, aout_magic, 4) == 0) {
-		i = j = 32;
-	} else {
-		fprintf (stderr, "Not ELF nor a.out. Don't blame me.\n");
-		exit(1);
-	}
-	k = i;
-	i += (ld2(buffer + j + 2)<<2) - 512;
-	if (lseek(image,i,0) < 0) die("lseek");
-	if (read(image,buffer,1024) != 1024) die(argv[1]);
-	for (q = buffer, r = q + 512; q < r; q += 4) {
-		if (*q == 'H' && q[1] == 'd' && q[2] == 'r' && q[3] == 'S')
-			break;
-	}
-	if (q == r) {
-		fprintf (stderr, "Couldn't find headers signature in the kernel.\n");
-		exit(1);
-	}
-	offset = i + (q - buffer) + 10;
-	if (lseek(image, offset, 0) < 0) die ("lseek");
-
-	st4(buffer, 0);
-	st4(buffer + 4, 0x01000000);
-	st4(buffer + 8, (end + 32 + 4095) & ~4095);
-	st4(buffer + 12, s.st_size);
-
-	if (write(image,buffer+2,14) != 14) die (argv[1]);
-	if (lseek(image, k - start + ((end + 32 + 4095) & ~4095), 0) < 0) die ("lseek");
-	if ((tail = open(argv[3],O_RDONLY)) < 0) die(argv[3]);
-	while ((i = read (tail,buffer,1024)) > 0)
-		if (write(image,buffer,i) != i) die (argv[1]);
-	if (close(image) < 0) die("close");
-	if (close(tail) < 0) die("close");
-    	return 0;
-}

commit 88278ca27a43ae503572b52ea2c171fbf45db5a2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon May 19 16:53:02 2008 -0700

    sparc: remove CVS keywords
    
    This patch removes the CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
index 6962cc68ed5b..c9f500c1a8b2 100644
--- a/arch/sparc/boot/piggyback.c
+++ b/arch/sparc/boot/piggyback.c
@@ -1,4 +1,4 @@
-/* $Id: piggyback.c,v 1.4 2000/12/05 00:48:57 anton Exp $
+/*
    Simple utility to make a single-image install kernel with initial ramdisk
    for Sparc tftpbooting without need to set up nfs.
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sparc/boot/piggyback.c b/arch/sparc/boot/piggyback.c
new file mode 100644
index 000000000000..6962cc68ed5b
--- /dev/null
+++ b/arch/sparc/boot/piggyback.c
@@ -0,0 +1,137 @@
+/* $Id: piggyback.c,v 1.4 2000/12/05 00:48:57 anton Exp $
+   Simple utility to make a single-image install kernel with initial ramdisk
+   for Sparc tftpbooting without need to set up nfs.
+
+   Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+   Pete Zaitcev <zaitcev@yahoo.com> endian fixes for cross-compiles, 2000.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+   
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+/*
+ * Note: run this on an a.out kernel (use elftoaout for it),
+ * as PROM looks for a.out image only.
+ */
+
+unsigned short ld2(char *p)
+{
+	return (p[0] << 8) | p[1];
+}
+
+unsigned int ld4(char *p)
+{
+	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+}
+
+void st4(char *p, unsigned int x)
+{
+	p[0] = x >> 24;
+	p[1] = x >> 16;
+	p[2] = x >> 8;
+	p[3] = x;
+}
+
+void usage(void)
+{
+	/* fs_img.gz is an image of initial ramdisk. */
+	fprintf(stderr, "Usage: piggyback vmlinux.aout System.map fs_img.gz\n");
+	fprintf(stderr, "\tKernel image will be modified in place.\n");
+	exit(1);
+}
+
+void die(char *str)
+{
+	perror (str);
+	exit(1);
+}
+
+int main(int argc,char **argv)
+{
+	static char aout_magic[] = { 0x01, 0x03, 0x01, 0x07 };
+	unsigned char buffer[1024], *q, *r;
+	unsigned int i, j, k, start, end, offset;
+	FILE *map;
+	struct stat s;
+	int image, tail;
+
+	if (argc != 4) usage();
+	start = end = 0;
+	if (stat (argv[3], &s) < 0) die (argv[3]);
+	map = fopen (argv[2], "r");
+	if (!map) die(argv[2]);
+	while (fgets (buffer, 1024, map)) {
+		if (!strcmp (buffer + 8, " T start\n") || !strcmp (buffer + 16, " T start\n"))
+			start = strtoul (buffer, NULL, 16);
+		else if (!strcmp (buffer + 8, " A end\n") || !strcmp (buffer + 16, " A end\n"))
+			end = strtoul (buffer, NULL, 16);
+	}
+	fclose (map);
+	if (!start || !end) {
+		fprintf (stderr, "Could not determine start and end from System.map\n");
+		exit(1);
+	}
+	if ((image = open(argv[1],O_RDWR)) < 0) die(argv[1]);
+	if (read(image,buffer,512) != 512) die(argv[1]);
+	if (memcmp (buffer, "\177ELF", 4) == 0) {
+		q = buffer + ld4(buffer + 28);
+		i = ld4(q + 4) + ld4(buffer + 24) - ld4(q + 8);
+		if (lseek(image,i,0) < 0) die("lseek");
+		if (read(image,buffer,512) != 512) die(argv[1]);
+		j = 0;
+	} else if (memcmp(buffer, aout_magic, 4) == 0) {
+		i = j = 32;
+	} else {
+		fprintf (stderr, "Not ELF nor a.out. Don't blame me.\n");
+		exit(1);
+	}
+	k = i;
+	i += (ld2(buffer + j + 2)<<2) - 512;
+	if (lseek(image,i,0) < 0) die("lseek");
+	if (read(image,buffer,1024) != 1024) die(argv[1]);
+	for (q = buffer, r = q + 512; q < r; q += 4) {
+		if (*q == 'H' && q[1] == 'd' && q[2] == 'r' && q[3] == 'S')
+			break;
+	}
+	if (q == r) {
+		fprintf (stderr, "Couldn't find headers signature in the kernel.\n");
+		exit(1);
+	}
+	offset = i + (q - buffer) + 10;
+	if (lseek(image, offset, 0) < 0) die ("lseek");
+
+	st4(buffer, 0);
+	st4(buffer + 4, 0x01000000);
+	st4(buffer + 8, (end + 32 + 4095) & ~4095);
+	st4(buffer + 12, s.st_size);
+
+	if (write(image,buffer+2,14) != 14) die (argv[1]);
+	if (lseek(image, k - start + ((end + 32 + 4095) & ~4095), 0) < 0) die ("lseek");
+	if ((tail = open(argv[3],O_RDONLY)) < 0) die(argv[3]);
+	while ((i = read (tail,buffer,1024)) > 0)
+		if (write(image,buffer,i) != i) die (argv[1]);
+	if (close(image) < 0) die("close");
+	if (close(tail) < 0) die("close");
+    	return 0;
+}
