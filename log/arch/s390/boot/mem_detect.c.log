commit 9b692102d87d13d24c97461207cae259121ed44b
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Mon Aug 19 23:14:10 2019 +0200

    s390/mem_detect: provide single get_mem_detect_end
    
    get_mem_detect_end is already used in couple of places with potential
    to be utilized in more cases. Provide single get_mem_detect_end
    implementation in asm/mem_detect.h to be used by kasan and startup code.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 5d316fe40480..62e7c13ce85c 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -63,13 +63,6 @@ void add_mem_detect_block(u64 start, u64 end)
 	mem_detect.count++;
 }
 
-static unsigned long get_mem_detect_end(void)
-{
-	if (mem_detect.count)
-		return __get_mem_detect_block_ptr(mem_detect.count - 1)->end;
-	return 0;
-}
-
 static int __diag260(unsigned long rx1, unsigned long rx2)
 {
 	register unsigned long _rx1 asm("2") = rx1;

commit 2d4ea4b95cae3133de6b18ec5d5a42ee824fa0ef
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 7 15:51:45 2019 -0800

    s390/mem_detect: Use IS_ENABLED(CONFIG_BLK_DEV_INITRD)
    
    IS_ENABLED should generally use CONFIG_ prefaced symbols and
    it doesn't appear as if there is a BLK_DEV_INITRD define.
    
    Cc: <stable@vger.kernel.org> # 4.20
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 4cb771ba13fa..5d316fe40480 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -25,7 +25,7 @@ static void *mem_detect_alloc_extended(void)
 {
 	unsigned long offset = ALIGN(mem_safe_offset(), sizeof(u64));
 
-	if (IS_ENABLED(BLK_DEV_INITRD) && INITRD_START && INITRD_SIZE &&
+	if (IS_ENABLED(CONFIG_BLK_DEV_INITRD) && INITRD_START && INITRD_SIZE &&
 	    INITRD_START < offset + ENTRIES_EXTENDED_MAX)
 		offset = ALIGN(INITRD_START + INITRD_SIZE, sizeof(u64));
 

commit c72251ad879056d096d39db21c08cb52e481eb2d
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Tue Oct 9 12:23:43 2018 +0200

    s390/mem_detect: add missing include
    
    Fix this allnoconfig build breakage:
    
    arch/s390/boot/mem_detect.c: In function 'tprot':
    arch/s390/boot/mem_detect.c:122:12: error: 'EFAULT' undeclared (first use in this function)
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 65ae3c926042..4cb771ba13fa 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
+#include <linux/errno.h>
 #include <linux/init.h>
 #include <asm/sclp.h>
 #include <asm/sections.h>

commit 54c57795e848100a2502b7a39b12b784292f4576
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 19:15:24 2018 +0200

    s390/mem_detect: replace tprot loop with binary search
    
    In a situation when other memory detection methods are not available
    (no SCLP and no z/VM diag260), continuous online memory is assumed.
    Replacing tprot loop with faster binary search, as only online memory
    end has to be found.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 3becf6bbe4c7..65ae3c926042 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -3,12 +3,10 @@
 #include <asm/sclp.h>
 #include <asm/sections.h>
 #include <asm/mem_detect.h>
+#include <asm/sparsemem.h>
 #include "compressed/decompressor.h"
 #include "boot.h"
 
-#define CHUNK_READ_WRITE 0
-#define CHUNK_READ_ONLY  1
-
 unsigned long __bootdata(max_physmem_end);
 struct mem_detect_info __bootdata(mem_detect);
 
@@ -141,38 +139,25 @@ static int tprot(unsigned long addr)
 	return rc;
 }
 
-static void scan_memory(unsigned long rzm)
+static void search_mem_end(void)
 {
-	unsigned long addr, size;
-	int type;
-
-	if (!rzm)
-		rzm = 1UL << 20;
-
-	addr = 0;
-	do {
-		size = 0;
-		/* assume lowcore is writable */
-		type = addr ? tprot(addr) : CHUNK_READ_WRITE;
-		do {
-			size += rzm;
-			if (max_physmem_end && addr + size >= max_physmem_end)
-				break;
-		} while (type == tprot(addr + size));
-		if (type == CHUNK_READ_WRITE || type == CHUNK_READ_ONLY) {
-			if (max_physmem_end && (addr + size > max_physmem_end))
-				size = max_physmem_end - addr;
-			add_mem_detect_block(addr, addr + size);
-		}
-		addr += size;
-	} while (addr < max_physmem_end);
+	unsigned long range = 1 << (MAX_PHYSMEM_BITS - 20); /* in 1MB blocks */
+	unsigned long offset = 0;
+	unsigned long pivot;
+
+	while (range > 1) {
+		range >>= 1;
+		pivot = offset + range;
+		if (!tprot(pivot << 20))
+			offset = pivot;
+	}
+
+	add_mem_detect_block(0, (offset + 1) << 20);
 }
 
 void detect_memory(void)
 {
-	unsigned long rzm;
-
-	sclp_early_get_meminfo(&max_physmem_end, &rzm);
+	sclp_early_get_memsize(&max_physmem_end);
 
 	if (!sclp_early_read_storage_info()) {
 		mem_detect.info_source = MEM_DETECT_SCLP_STOR_INFO;
@@ -190,7 +175,7 @@ void detect_memory(void)
 		return;
 	}
 
-	scan_memory(rzm);
-	mem_detect.info_source = MEM_DETECT_TPROT_LOOP;
+	search_mem_end();
+	mem_detect.info_source = MEM_DETECT_BIN_SEARCH;
 	max_physmem_end = get_mem_detect_end();
 }

commit cd45c995610420755c5fe0d09afee3106c586e26
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:54:40 2018 +0200

    s390/mem_detect: use SCLP info for continuous memory detection
    
    When neither SCLP storage info, nor z/VM diag260 "storage configuration"
    are available assume a continuous online memory of size specified by
    SCLP info.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 42b0cd23f04a..3becf6bbe4c7 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -184,8 +184,13 @@ void detect_memory(void)
 		return;
 	}
 
+	if (max_physmem_end) {
+		add_mem_detect_block(0, max_physmem_end);
+		mem_detect.info_source = MEM_DETECT_SCLP_READ_INFO;
+		return;
+	}
+
 	scan_memory(rzm);
 	mem_detect.info_source = MEM_DETECT_TPROT_LOOP;
-	if (!max_physmem_end)
-		max_physmem_end = get_mem_detect_end();
+	max_physmem_end = get_mem_detect_end();
 }

commit 6e98e6432995a3094a88bf6024187c3c235be976
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:48:20 2018 +0200

    s390/mem_detect: introduce z/VM specific diag260 call
    
    In the case when z/VM memory is defined with "define storage config"
    command, SCLP storage info is not available. Utilize diag260 "storage
    configuration" call, to get information about z/VM specific guest memory
    definitions with potential memory holes.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 8974e3dde1e4..42b0cd23f04a 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -71,6 +71,53 @@ static unsigned long get_mem_detect_end(void)
 	return 0;
 }
 
+static int __diag260(unsigned long rx1, unsigned long rx2)
+{
+	register unsigned long _rx1 asm("2") = rx1;
+	register unsigned long _rx2 asm("3") = rx2;
+	register unsigned long _ry asm("4") = 0x10; /* storage configuration */
+	int rc = -1;				    /* fail */
+	unsigned long reg1, reg2;
+	psw_t old = S390_lowcore.program_new_psw;
+
+	asm volatile(
+		"	epsw	%0,%1\n"
+		"	st	%0,%[psw_pgm]\n"
+		"	st	%1,%[psw_pgm]+4\n"
+		"	larl	%0,1f\n"
+		"	stg	%0,%[psw_pgm]+8\n"
+		"	diag	%[rx],%[ry],0x260\n"
+		"	ipm	%[rc]\n"
+		"	srl	%[rc],28\n"
+		"1:\n"
+		: "=&d" (reg1), "=&a" (reg2),
+		  [psw_pgm] "=Q" (S390_lowcore.program_new_psw),
+		  [rc] "+&d" (rc), [ry] "+d" (_ry)
+		: [rx] "d" (_rx1), "d" (_rx2)
+		: "cc", "memory");
+	S390_lowcore.program_new_psw = old;
+	return rc == 0 ? _ry : -1;
+}
+
+static int diag260(void)
+{
+	int rc, i;
+
+	struct {
+		unsigned long start;
+		unsigned long end;
+	} storage_extents[8] __aligned(16); /* VM supports up to 8 extends */
+
+	memset(storage_extents, 0, sizeof(storage_extents));
+	rc = __diag260((unsigned long)storage_extents, sizeof(storage_extents));
+	if (rc == -1)
+		return -1;
+
+	for (i = 0; i < min_t(int, rc, ARRAY_SIZE(storage_extents)); i++)
+		add_mem_detect_block(storage_extents[i].start, storage_extents[i].end + 1);
+	return 0;
+}
+
 static int tprot(unsigned long addr)
 {
 	unsigned long pgm_addr;
@@ -132,6 +179,11 @@ void detect_memory(void)
 		return;
 	}
 
+	if (!diag260()) {
+		mem_detect.info_source = MEM_DETECT_DIAG260;
+		return;
+	}
+
 	scan_memory(rzm);
 	mem_detect.info_source = MEM_DETECT_TPROT_LOOP;
 	if (!max_physmem_end)

commit fddbaa5c423f7ca0a187f88e0b1d98a5c8b4edcf
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:42:37 2018 +0200

    s390/mem_detect: introduce SCLP storage info
    
    SCLP storage info allows to detect continuous and non-continuous online
    memory under LPAR, z/VM and KVM, when standby memory is defined.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
index 920e6fee75de..8974e3dde1e4 100644
--- a/arch/s390/boot/mem_detect.c
+++ b/arch/s390/boot/mem_detect.c
@@ -126,6 +126,12 @@ void detect_memory(void)
 	unsigned long rzm;
 
 	sclp_early_get_meminfo(&max_physmem_end, &rzm);
+
+	if (!sclp_early_read_storage_info()) {
+		mem_detect.info_source = MEM_DETECT_SCLP_STOR_INFO;
+		return;
+	}
+
 	scan_memory(rzm);
 	mem_detect.info_source = MEM_DETECT_TPROT_LOOP;
 	if (!max_physmem_end)

commit 6966d604e2ec4ecf5691aea953538f63597a250d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 11:56:55 2018 +0200

    s390/mem_detect: move tprot loop to early boot phase
    
    Move memory detection to early boot phase. To store online memory
    regions "struct mem_detect_info" has been introduced together with
    for_each_mem_detect_block iterator. mem_detect_info is later converted
    to memblock.
    
    Also introduces sclp_early_get_meminfo function to get maximum physical
    memory and maximum increment number.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/mem_detect.c b/arch/s390/boot/mem_detect.c
new file mode 100644
index 000000000000..920e6fee75de
--- /dev/null
+++ b/arch/s390/boot/mem_detect.c
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/init.h>
+#include <asm/sclp.h>
+#include <asm/sections.h>
+#include <asm/mem_detect.h>
+#include "compressed/decompressor.h"
+#include "boot.h"
+
+#define CHUNK_READ_WRITE 0
+#define CHUNK_READ_ONLY  1
+
+unsigned long __bootdata(max_physmem_end);
+struct mem_detect_info __bootdata(mem_detect);
+
+/* up to 256 storage elements, 1020 subincrements each */
+#define ENTRIES_EXTENDED_MAX						       \
+	(256 * (1020 / 2) * sizeof(struct mem_detect_block))
+
+/*
+ * To avoid corrupting old kernel memory during dump, find lowest memory
+ * chunk possible either right after the kernel end (decompressed kernel) or
+ * after initrd (if it is present and there is no hole between the kernel end
+ * and initrd)
+ */
+static void *mem_detect_alloc_extended(void)
+{
+	unsigned long offset = ALIGN(mem_safe_offset(), sizeof(u64));
+
+	if (IS_ENABLED(BLK_DEV_INITRD) && INITRD_START && INITRD_SIZE &&
+	    INITRD_START < offset + ENTRIES_EXTENDED_MAX)
+		offset = ALIGN(INITRD_START + INITRD_SIZE, sizeof(u64));
+
+	return (void *)offset;
+}
+
+static struct mem_detect_block *__get_mem_detect_block_ptr(u32 n)
+{
+	if (n < MEM_INLINED_ENTRIES)
+		return &mem_detect.entries[n];
+	if (unlikely(!mem_detect.entries_extended))
+		mem_detect.entries_extended = mem_detect_alloc_extended();
+	return &mem_detect.entries_extended[n - MEM_INLINED_ENTRIES];
+}
+
+/*
+ * sequential calls to add_mem_detect_block with adjacent memory areas
+ * are merged together into single memory block.
+ */
+void add_mem_detect_block(u64 start, u64 end)
+{
+	struct mem_detect_block *block;
+
+	if (mem_detect.count) {
+		block = __get_mem_detect_block_ptr(mem_detect.count - 1);
+		if (block->end == start) {
+			block->end = end;
+			return;
+		}
+	}
+
+	block = __get_mem_detect_block_ptr(mem_detect.count);
+	block->start = start;
+	block->end = end;
+	mem_detect.count++;
+}
+
+static unsigned long get_mem_detect_end(void)
+{
+	if (mem_detect.count)
+		return __get_mem_detect_block_ptr(mem_detect.count - 1)->end;
+	return 0;
+}
+
+static int tprot(unsigned long addr)
+{
+	unsigned long pgm_addr;
+	int rc = -EFAULT;
+	psw_t old = S390_lowcore.program_new_psw;
+
+	S390_lowcore.program_new_psw.mask = __extract_psw();
+	asm volatile(
+		"	larl	%[pgm_addr],1f\n"
+		"	stg	%[pgm_addr],%[psw_pgm_addr]\n"
+		"	tprot	0(%[addr]),0\n"
+		"	ipm	%[rc]\n"
+		"	srl	%[rc],28\n"
+		"1:\n"
+		: [pgm_addr] "=&d"(pgm_addr),
+		  [psw_pgm_addr] "=Q"(S390_lowcore.program_new_psw.addr),
+		  [rc] "+&d"(rc)
+		: [addr] "a"(addr)
+		: "cc", "memory");
+	S390_lowcore.program_new_psw = old;
+	return rc;
+}
+
+static void scan_memory(unsigned long rzm)
+{
+	unsigned long addr, size;
+	int type;
+
+	if (!rzm)
+		rzm = 1UL << 20;
+
+	addr = 0;
+	do {
+		size = 0;
+		/* assume lowcore is writable */
+		type = addr ? tprot(addr) : CHUNK_READ_WRITE;
+		do {
+			size += rzm;
+			if (max_physmem_end && addr + size >= max_physmem_end)
+				break;
+		} while (type == tprot(addr + size));
+		if (type == CHUNK_READ_WRITE || type == CHUNK_READ_ONLY) {
+			if (max_physmem_end && (addr + size > max_physmem_end))
+				size = max_physmem_end - addr;
+			add_mem_detect_block(addr, addr + size);
+		}
+		addr += size;
+	} while (addr < max_physmem_end);
+}
+
+void detect_memory(void)
+{
+	unsigned long rzm;
+
+	sclp_early_get_meminfo(&max_physmem_end, &rzm);
+	scan_memory(rzm);
+	mem_detect.info_source = MEM_DETECT_TPROT_LOOP;
+	if (!max_physmem_end)
+		max_physmem_end = get_mem_detect_end();
+}
