commit a9f2f6865d784477e1c7b59269d3a384abafd9ca
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Tue Nov 19 12:30:53 2019 +0100

    s390/kaslr: store KASLR offset for early dumps
    
    The KASLR offset is added to vmcoreinfo in arch_crash_save_vmcoreinfo(),
    so that it can be found by crash when processing kernel dumps.
    
    However, arch_crash_save_vmcoreinfo() is called during a subsys_initcall,
    so if the kernel crashes before that, we have no vmcoreinfo and no KASLR
    offset.
    
    Fix this by storing the KASLR offset in the lowcore, where the vmcore_info
    pointer will be stored, and where it can be found by crash. In order to
    make it distinguishable from a real vmcore_info pointer, mark it as uneven
    (KASLR offset itself is aligned to THREAD_SIZE).
    
    When arch_crash_save_vmcoreinfo() stores the real vmcore_info pointer in
    the lowcore, it overwrites the KASLR offset. At that point, the KASLR
    offset is not yet added to vmcoreinfo, so we also need to move the
    mem_assign_absolute() behind the vmcoreinfo_append_str().
    
    Fixes: b2d24b97b2a9 ("s390/kernel: add support for kernel address space layout randomization (KASLR)")
    Cc: <stable@vger.kernel.org> # v5.2+
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index fbd341ea03b8..3b3a11f95269 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -170,6 +170,11 @@ void startup_kernel(void)
 		handle_relocs(__kaslr_offset);
 
 	if (__kaslr_offset) {
+		/*
+		 * Save KASLR offset for early dumps, before vmcore_info is set.
+		 * Mark as uneven to distinguish from real vmcore_info pointer.
+		 */
+		S390_lowcore.vmcore_info = __kaslr_offset | 0x1UL;
 		/* Clear non-relocated kernel */
 		if (IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED))
 			memset(img, 0, vmlinux.image_size);

commit ea1f56fa16ae5f6e67f6ea03836b36c6053d33d1
Merge: 4ba380f61624 6a82e23f45fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 17:23:53 2019 -0800

    Merge tag 's390-5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 updates from Vasily Gorbik:
    
     - Adjust PMU device drivers registration to avoid WARN_ON and few other
       perf improvements.
    
     - Enhance tracing in vfio-ccw.
    
     - Few stack unwinder fixes and improvements, convert get_wchan custom
       stack unwinding to generic api usage.
    
     - Fixes for mm helpers issues uncovered with tests validating
       architecture page table helpers.
    
     - Fix noexec bit handling when hardware doesn't support it.
    
     - Fix memleak and unsigned value compared with zero bugs in crypto
       code. Minor code simplification.
    
     - Fix crash during kdump with kasan enabled kernel.
    
     - Switch bug and alternatives from asm to asm_inline to improve
       inlining decisions.
    
     - Use 'depends on cc-option' for MARCH and TUNE options in Kconfig, add
       z13s and z14 ZR1 to TUNE descriptions.
    
     - Minor head64.S simplification.
    
     - Fix physical to logical CPU map for SMT.
    
     - Several cleanups in qdio code.
    
     - Other minor cleanups and fixes all over the code.
    
    * tag 's390-5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux: (41 commits)
      s390/cpumf: Adjust registration of s390 PMU device drivers
      s390/smp: fix physical to logical CPU map for SMT
      s390/early: move access registers setup in C code
      s390/head64: remove unnecessary vdso_per_cpu_data setup
      s390/early: move control registers setup in C code
      s390/kasan: support memcpy_real with TRACE_IRQFLAGS
      s390/crypto: Fix unsigned variable compared with zero
      s390/pkey: use memdup_user() to simplify code
      s390/pkey: fix memory leak within _copy_apqns_from_user()
      s390/disassembler: don't hide instruction addresses
      s390/cpum_sf: Assign error value to err variable
      s390/cpum_sf: Replace function name in debug statements
      s390/cpum_sf: Use consistant debug print format for sampling
      s390/unwind: drop unnecessary code around calling ftrace_graph_ret_addr()
      s390: add error handling to perf_callchain_kernel
      s390: always inline current_stack_pointer()
      s390/mm: add mm_pxd_folded() checks to pxd_free()
      s390/mm: properly clear _PAGE_NOEXEC bit when it is not supported
      s390/mm: simplify page table helpers for large entries
      s390/mm: make pmd/pud_bad() report large entries as bad
      ...

commit 4f84b383511de8dabc9bed2b98d2918830723527
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Mon Aug 12 14:50:34 2019 -0700

    s390/boot: fix section name escaping
    
    GCC unescapes escaped string section names while Clang does not. Because
    __section uses the `#` stringification operator for the section name, it
    doesn't need to be escaped.
    
    This antipattern was found with:
    $ grep -e __section\(\" -e __section__\(\" -r
    
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Suggested-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Message-Id: <20190812215052.71840-1-ndesaulniers@google.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 596ca7cc4d7b..1a41545becec 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -46,7 +46,7 @@ struct diag_ops __bootdata_preserved(diag_dma_ops) = {
 	.diag0c = _diag0c_dma,
 	.diag308_reset = _diag308_reset_dma
 };
-static struct diag210 _diag210_tmp_dma __section(".dma.data");
+static struct diag210 _diag210_tmp_dma __section(.dma.data);
 struct diag210 *__bootdata_preserved(__diag210_tmp_dma) = &_diag210_tmp_dma;
 void _swsusp_reset_dma(void);
 unsigned long __bootdata_preserved(__swsusp_reset_dma) = __pa(_swsusp_reset_dma);

commit ac49303d9ef0ad98b79867a380ef23480e48870b
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Mon Oct 21 19:56:00 2019 +0200

    s390/kaslr: add support for R_390_GLOB_DAT relocation type
    
    Commit "bpf: Process in-kernel BTF" in linux-next introduced an undefined
    __weak symbol, which results in an R_390_GLOB_DAT relocation type. That
    is not yet handled by the KASLR relocation code, and the kernel stops with
    the message "Unknown relocation type".
    
    Add code to detect and handle R_390_GLOB_DAT relocation types and undefined
    symbols.
    
    Fixes: 805bc0bc238f ("s390/kernel: build a relocatable kernel")
    Cc: <stable@vger.kernel.org> # v5.2+
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 596ca7cc4d7b..5367950510f6 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -101,10 +101,18 @@ static void handle_relocs(unsigned long offset)
 	dynsym = (Elf64_Sym *) vmlinux.dynsym_start;
 	for (rela = rela_start; rela < rela_end; rela++) {
 		loc = rela->r_offset + offset;
-		val = rela->r_addend + offset;
+		val = rela->r_addend;
 		r_sym = ELF64_R_SYM(rela->r_info);
-		if (r_sym)
-			val += dynsym[r_sym].st_value;
+		if (r_sym) {
+			if (dynsym[r_sym].st_shndx != SHN_UNDEF)
+				val += dynsym[r_sym].st_value + offset;
+		} else {
+			/*
+			 * 0 == undefined symbol table index (STN_UNDEF),
+			 * used for R_390_RELATIVE, only add KASLR offset
+			 */
+			val += offset;
+		}
 		r_type = ELF64_R_TYPE(rela->r_info);
 		rc = arch_kexec_do_relocs(r_type, (void *) loc, val, 0);
 		if (rc)

commit 2e83e0eb85ca62985406920f97ece36d822d421f
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Sun Aug 11 20:55:18 2019 +0200

    s390: clean .bss before running uncompressed kernel
    
    Clean uncompressed kernel .bss section in the startup code before
    the uncompressed kernel is executed. At this point of time initrd and
    certificates have been already rescued. Uncompressed kernel .bss size
    is known from vmlinux_info. It is also taken into consideration during
    uncompressed kernel positioning by kaslr (so it is safe to clean it).
    
    With that uncompressed kernel is starting with .bss section zeroed and
    no .bss section usage restrictions apply. Which makes chkbss checks for
    uncompressed kernel objects obsolete and they can be removed.
    
    early_nobss.c is also not needed anymore. Parts of it which are still
    relevant are moved to early.c. Kasan initialization code is now called
    directly from head64 (early.c is instrumented and should not be
    executed before kasan shadow memory is set up).
    
    Reviewed-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 7b0d05414618..596ca7cc4d7b 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -112,6 +112,11 @@ static void handle_relocs(unsigned long offset)
 	}
 }
 
+static void clear_bss_section(void)
+{
+	memset((void *)vmlinux.default_lma + vmlinux.image_size, 0, vmlinux.bss_size);
+}
+
 void startup_kernel(void)
 {
 	unsigned long random_lma;
@@ -151,6 +156,7 @@ void startup_kernel(void)
 	} else if (__kaslr_offset)
 		memcpy((void *)vmlinux.default_lma, img, vmlinux.image_size);
 
+	clear_bss_section();
 	copy_bootdata();
 	if (IS_ENABLED(CONFIG_RELOCATABLE))
 		handle_relocs(__kaslr_offset);

commit 98587c2d894c34c9af5cd84ca169e1cd493aa692
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Apr 30 12:33:45 2019 +0200

    s390: simplify disabled_wait
    
    The disabled_wait() function uses its argument as the PSW address when
    it stops the CPU with a wait PSW that is disabled for interrupts.
    The different callers sometimes use a specific number like 0xdeadbeef
    to indicate a specific failure, the early boot code uses 0 and some
    other calls sites use __builtin_return_address(0).
    
    At the time a dump is created the current PSW and the registers of a
    CPU are written to lowcore to make them avaiable to the dump analysis
    tool. For a CPU stopped with disabled_wait the PSW and the registers
    do not really make sense together, the PSW address does not point to
    the function the registers belong to.
    
    Simplify disabled_wait() by using _THIS_IP_ for the PSW address and
    drop the argument to the function.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 4401e992bda1..7b0d05414618 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -57,7 +57,7 @@ void error(char *x)
 	sclp_early_printk(x);
 	sclp_early_printk("\n\n -- System halted");
 
-	disabled_wait(0xdeadbeef);
+	disabled_wait();
 }
 
 #ifdef CONFIG_KERNEL_UNCOMPRESSED

commit b2d24b97b2a9691351920e700bfda4368c177232
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Sun Feb 3 21:37:20 2019 +0100

    s390/kernel: add support for kernel address space layout randomization (KASLR)
    
    This patch adds support for relocating the kernel to a random address.
    The random kernel offset is obtained from cpacf, using either TRNG, PRNO,
    or KMC_PRNG, depending on supported MSA level.
    
    KERNELOFFSET is added to vmcoreinfo, for crash --kaslr support.
    
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Reviewed-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index e3f339d248ce..4401e992bda1 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -12,6 +12,7 @@
 
 extern char __boot_data_start[], __boot_data_end[];
 extern char __boot_data_preserved_start[], __boot_data_preserved_end[];
+unsigned long __bootdata_preserved(__kaslr_offset);
 
 /*
  * Some code and data needs to stay below 2 GB, even when the kernel would be
@@ -113,6 +114,7 @@ static void handle_relocs(unsigned long offset)
 
 void startup_kernel(void)
 {
+	unsigned long random_lma;
 	unsigned long safe_addr;
 	void *img;
 
@@ -126,12 +128,37 @@ void startup_kernel(void)
 	parse_boot_command_line();
 	setup_memory_end();
 	detect_memory();
+
+	random_lma = __kaslr_offset = 0;
+	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && kaslr_enabled) {
+		random_lma = get_random_base(safe_addr);
+		if (random_lma) {
+			__kaslr_offset = random_lma - vmlinux.default_lma;
+			img = (void *)vmlinux.default_lma;
+			vmlinux.default_lma += __kaslr_offset;
+			vmlinux.entry += __kaslr_offset;
+			vmlinux.bootdata_off += __kaslr_offset;
+			vmlinux.bootdata_preserved_off += __kaslr_offset;
+			vmlinux.rela_dyn_start += __kaslr_offset;
+			vmlinux.rela_dyn_end += __kaslr_offset;
+			vmlinux.dynsym_start += __kaslr_offset;
+		}
+	}
+
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
 		img = decompress_kernel();
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);
-	}
+	} else if (__kaslr_offset)
+		memcpy((void *)vmlinux.default_lma, img, vmlinux.image_size);
+
 	copy_bootdata();
 	if (IS_ENABLED(CONFIG_RELOCATABLE))
-		handle_relocs(0);
+		handle_relocs(__kaslr_offset);
+
+	if (__kaslr_offset) {
+		/* Clear non-relocated kernel */
+		if (IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED))
+			memset(img, 0, vmlinux.image_size);
+	}
 	vmlinux.entry();
 }

commit a80313ff91abda67641dc33bed97f6bcc5e9f6a4
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Sun Feb 3 21:37:20 2019 +0100

    s390/kernel: introduce .dma sections
    
    With a relocatable kernel that could reside at any place in memory, code
    and data that has to stay below 2 GB needs special handling.
    
    This patch introduces .dma sections for such text, data and ex_table.
    The sections will be part of the decompressor kernel, so they will not
    be relocated and stay below 2 GB. Their location is passed over to the
    decompressed / relocated kernel via the .boot.preserved.data section.
    
    The duald and aste for control register setup also need to stay below
    2 GB, so move the setup code from arch/s390/kernel/head64.S to
    arch/s390/boot/head.S. The duct and linkage_stack could reside above
    2 GB, but their content has to be preserved for the decompresed kernel,
    so they are also moved into the .dma section.
    
    The start and end address of the .dma sections is added to vmcoreinfo,
    for crash support, to help debugging in case the kernel crashed there.
    
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Reviewed-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index b7d6a76cb5e9..e3f339d248ce 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -1,9 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/string.h>
 #include <linux/elf.h>
+#include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/kexec.h>
 #include <asm/sclp.h>
+#include <asm/diag.h>
 #include <asm/uv.h>
 #include "compressed/decompressor.h"
 #include "boot.h"
@@ -11,6 +13,43 @@
 extern char __boot_data_start[], __boot_data_end[];
 extern char __boot_data_preserved_start[], __boot_data_preserved_end[];
 
+/*
+ * Some code and data needs to stay below 2 GB, even when the kernel would be
+ * relocated above 2 GB, because it has to use 31 bit addresses.
+ * Such code and data is part of the .dma section, and its location is passed
+ * over to the decompressed / relocated kernel via the .boot.preserved.data
+ * section.
+ */
+extern char _sdma[], _edma[];
+extern char _stext_dma[], _etext_dma[];
+extern struct exception_table_entry _start_dma_ex_table[];
+extern struct exception_table_entry _stop_dma_ex_table[];
+unsigned long __bootdata_preserved(__sdma) = __pa(&_sdma);
+unsigned long __bootdata_preserved(__edma) = __pa(&_edma);
+unsigned long __bootdata_preserved(__stext_dma) = __pa(&_stext_dma);
+unsigned long __bootdata_preserved(__etext_dma) = __pa(&_etext_dma);
+struct exception_table_entry *
+	__bootdata_preserved(__start_dma_ex_table) = _start_dma_ex_table;
+struct exception_table_entry *
+	__bootdata_preserved(__stop_dma_ex_table) = _stop_dma_ex_table;
+
+int _diag210_dma(struct diag210 *addr);
+int _diag26c_dma(void *req, void *resp, enum diag26c_sc subcode);
+int _diag14_dma(unsigned long rx, unsigned long ry1, unsigned long subcode);
+void _diag0c_dma(struct hypfs_diag0c_entry *entry);
+void _diag308_reset_dma(void);
+struct diag_ops __bootdata_preserved(diag_dma_ops) = {
+	.diag210 = _diag210_dma,
+	.diag26c = _diag26c_dma,
+	.diag14 = _diag14_dma,
+	.diag0c = _diag0c_dma,
+	.diag308_reset = _diag308_reset_dma
+};
+static struct diag210 _diag210_tmp_dma __section(".dma.data");
+struct diag210 *__bootdata_preserved(__diag210_tmp_dma) = &_diag210_tmp_dma;
+void _swsusp_reset_dma(void);
+unsigned long __bootdata_preserved(__swsusp_reset_dma) = __pa(_swsusp_reset_dma);
+
 void error(char *x)
 {
 	sclp_early_printk("\n\n");

commit 805bc0bc238f7209fca5e39c152b0d3c12046ac9
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Sun Feb 3 21:35:45 2019 +0100

    s390/kernel: build a relocatable kernel
    
    This patch adds support for building a relocatable kernel with -fPIE.
    The kernel will be relocated to 0 early in the boot process.
    
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Reviewed-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 90898976a941..b7d6a76cb5e9 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -1,6 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/string.h>
+#include <linux/elf.h>
 #include <asm/setup.h>
+#include <asm/kexec.h>
 #include <asm/sclp.h>
 #include <asm/uv.h>
 #include "compressed/decompressor.h"
@@ -47,6 +49,29 @@ static void copy_bootdata(void)
 	memcpy((void *)vmlinux.bootdata_preserved_off, __boot_data_preserved_start, vmlinux.bootdata_preserved_size);
 }
 
+static void handle_relocs(unsigned long offset)
+{
+	Elf64_Rela *rela_start, *rela_end, *rela;
+	int r_type, r_sym, rc;
+	Elf64_Addr loc, val;
+	Elf64_Sym *dynsym;
+
+	rela_start = (Elf64_Rela *) vmlinux.rela_dyn_start;
+	rela_end = (Elf64_Rela *) vmlinux.rela_dyn_end;
+	dynsym = (Elf64_Sym *) vmlinux.dynsym_start;
+	for (rela = rela_start; rela < rela_end; rela++) {
+		loc = rela->r_offset + offset;
+		val = rela->r_addend + offset;
+		r_sym = ELF64_R_SYM(rela->r_info);
+		if (r_sym)
+			val += dynsym[r_sym].st_value;
+		r_type = ELF64_R_TYPE(rela->r_info);
+		rc = arch_kexec_do_relocs(r_type, (void *) loc, val, 0);
+		if (rc)
+			error("Unknown relocation type");
+	}
+}
+
 void startup_kernel(void)
 {
 	unsigned long safe_addr;
@@ -67,5 +92,7 @@ void startup_kernel(void)
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);
 	}
 	copy_bootdata();
+	if (IS_ENABLED(CONFIG_RELOCATABLE))
+		handle_relocs(0);
 	vmlinux.entry();
 }

commit 9641b8cc733f70a5400aa7e6831de4542c46a94c
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Feb 21 14:23:04 2019 +0100

    s390/ipl: read IPL report at early boot
    
    Read the IPL Report block provided by secure-boot, add the entries
    of the certificate list to the system key ring and print the list
    of components.
    
    PR: Adjust to Vasilys bootdata_preserved patch set. Preserve ipl_cert_list
    for later use in kexec_file.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 2bd4a62d436c..90898976a941 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -25,19 +25,16 @@ unsigned long mem_safe_offset(void)
 }
 #endif
 
-static void rescue_initrd(void)
+static void rescue_initrd(unsigned long addr)
 {
-	unsigned long min_initrd_addr;
-
 	if (!IS_ENABLED(CONFIG_BLK_DEV_INITRD))
 		return;
 	if (!INITRD_START || !INITRD_SIZE)
 		return;
-	min_initrd_addr = mem_safe_offset();
-	if (min_initrd_addr <= INITRD_START)
+	if (addr <= INITRD_START)
 		return;
-	memmove((void *)min_initrd_addr, (void *)INITRD_START, INITRD_SIZE);
-	INITRD_START = min_initrd_addr;
+	memmove((void *)addr, (void *)INITRD_START, INITRD_SIZE);
+	INITRD_START = addr;
 }
 
 static void copy_bootdata(void)
@@ -52,12 +49,15 @@ static void copy_bootdata(void)
 
 void startup_kernel(void)
 {
+	unsigned long safe_addr;
 	void *img;
 
+	store_ipl_parmblock();
+	safe_addr = mem_safe_offset();
+	safe_addr = read_ipl_report(safe_addr);
 	uv_query_info();
-	rescue_initrd();
+	rescue_initrd(safe_addr);
 	sclp_early_read_info();
-	store_ipl_parmblock();
 	setup_boot_command_line();
 	parse_boot_command_line();
 	setup_memory_end();

commit 5abb9351dfd937d43193f4d09af9c72bfe2c4180
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Mon Apr 1 19:11:03 2019 +0200

    s390/uv: introduce guest side ultravisor code
    
    The Ultravisor Call Facility (stfle bit 158) defines an API to the
    Ultravisor (UV calls), a mini hypervisor located at machine
    level. With help of the Ultravisor, KVM will be able to run
    "protected" VMs, special VMs whose memory and management data are
    unavailable to KVM.
    
    The protected VMs can also request services from the Ultravisor.
    The guest api consists of UV calls to share and unshare memory with the
    kvm hypervisor.
    
    To enable this feature support PROTECTED_VIRTUALIZATION_GUEST kconfig
    option has been introduced.
    
    Co-developed-by: Janosch Frank <frankja@de.ibm.com>
    Signed-off-by: Janosch Frank <frankja@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 57d7f9446e29..2bd4a62d436c 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -2,6 +2,7 @@
 #include <linux/string.h>
 #include <asm/setup.h>
 #include <asm/sclp.h>
+#include <asm/uv.h>
 #include "compressed/decompressor.h"
 #include "boot.h"
 
@@ -53,6 +54,7 @@ void startup_kernel(void)
 {
 	void *img;
 
+	uv_query_info();
 	rescue_initrd();
 	sclp_early_read_info();
 	store_ipl_parmblock();

commit bf9921a9c15bad089c08b94c300a6cafa035a612
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Mon Apr 1 19:10:45 2019 +0200

    s390: introduce .boot.preserved.data section
    
    Introduce .boot.preserve.data section which is similar to .boot.data and
    "shared" between the decompressor code and the decompressed kernel. The
    decompressor will store values in it, and copy over to the decompressed
    image before starting it. This method allows to avoid using pre-defined
    addresses and other hacks to pass values between those boot phases.
    
    Unlike .boot.data section .boot.preserved.data is NOT a part of init data,
    and hence will be preserved for the kernel life time.
    
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index bdfc5549a299..57d7f9446e29 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -6,6 +6,7 @@
 #include "boot.h"
 
 extern char __boot_data_start[], __boot_data_end[];
+extern char __boot_data_preserved_start[], __boot_data_preserved_end[];
 
 void error(char *x)
 {
@@ -43,6 +44,9 @@ static void copy_bootdata(void)
 	if (__boot_data_end - __boot_data_start != vmlinux.bootdata_size)
 		error(".boot.data section size mismatch");
 	memcpy((void *)vmlinux.bootdata_off, __boot_data_start, vmlinux.bootdata_size);
+	if (__boot_data_preserved_end - __boot_data_preserved_start != vmlinux.bootdata_preserved_size)
+		error(".boot.preserved.data section size mismatch");
+	memcpy((void *)vmlinux.bootdata_preserved_off, __boot_data_preserved_start, vmlinux.bootdata_preserved_size);
 }
 
 void startup_kernel(void)

commit b5e804598d594934407a1a8548d7b65341fe2617
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Feb 27 16:52:42 2019 +0100

    s390: allow overriding facilities via command line
    
    Add "facilities=" command line option which allows to override
    facility bits returned by stfle. The main purpose of that is debugging
    aids which allows to test specific kernel behaviour depending on
    specific facilities presence. It also affects CPU alternatives.
    
    "facilities=" command line option format is comma separated list of
    integer values to be additionally set or cleared (if value is starting
    with "!"). Values ranges are also supported. e.g.:
    
    facilities=!130-160,159,167-169
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 4d441317cdeb..bdfc5549a299 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -53,6 +53,7 @@ void startup_kernel(void)
 	sclp_early_read_info();
 	store_ipl_parmblock();
 	setup_boot_command_line();
+	parse_boot_command_line();
 	setup_memory_end();
 	detect_memory();
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {

commit 49698745e53c417370ac5cfe8b849bb65d62f129
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Tue May 15 13:28:53 2018 +0200

    s390: move ipl block and cmd line handling to early boot phase
    
    To distinguish zfcpdump case and to be able to parse some of the kernel
    command line arguments early (e.g. mem=) ipl block retrieval and command
    line construction code is moved to the early boot phase.
    
    "memory_end" is set up correctly respecting "mem=" and hsa_size in case
    of the zfcpdump.
    
    arch/s390/boot/string.c is introduced to provide string handling and
    command line parsing functions to early boot phase code for the compressed
    kernel image case.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index b0e9f4619203..4d441317cdeb 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -51,6 +51,9 @@ void startup_kernel(void)
 
 	rescue_initrd();
 	sclp_early_read_info();
+	store_ipl_parmblock();
+	setup_boot_command_line();
+	setup_memory_end();
 	detect_memory();
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
 		img = decompress_kernel();

commit 6966d604e2ec4ecf5691aea953538f63597a250d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 11:56:55 2018 +0200

    s390/mem_detect: move tprot loop to early boot phase
    
    Move memory detection to early boot phase. To store online memory
    regions "struct mem_detect_info" has been introduced together with
    for_each_mem_detect_block iterator. mem_detect_info is later converted
    to memblock.
    
    Also introduces sclp_early_get_meminfo function to get maximum physical
    memory and maximum increment number.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 78651a2c26b0..b0e9f4619203 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -51,6 +51,7 @@ void startup_kernel(void)
 
 	rescue_initrd();
 	sclp_early_read_info();
+	detect_memory();
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
 		img = decompress_kernel();
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);

commit 17aacfbfa1ae386d3e54d12a13b88b7981e04896
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed May 23 11:07:13 2018 +0200

    s390/sclp: move sclp_early_read_info to sclp_early_core.c
    
    To enable early online memory detection sclp_early_read_info has
    been moved to sclp_early_core.c. sclp_info_sccb has been made a part
    of .boot.data, which allows to reuse it later during early kernel
    startup and make sclp_early_read_info call just once.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index e9eea37894b3..78651a2c26b0 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -50,6 +50,7 @@ void startup_kernel(void)
 	void *img;
 
 	rescue_initrd();
+	sclp_early_read_info();
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
 		img = decompress_kernel();
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);

commit d1b52a4388ffdcff47fb53de7fffe052fe766a9f
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Tue Apr 10 14:14:02 2018 +0200

    s390: introduce .boot.data section
    
    Introduce .boot.data section which is "shared" between the decompressor
    code and the decompressed kernel. The decompressor will store values in
    it, and copy over to the decompressed image before starting it. This
    method allows to avoid using pre-defined addresses and other hacks to
    pass values between those boot phases.
    
    .boot.data section is a part of init data, and will be freed after kernel
    initialization is complete.
    
    For uncompressed kernel image, .boot.data section is basically the same
    as .init.data
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 81199ca4a513..e9eea37894b3 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -5,6 +5,8 @@
 #include "compressed/decompressor.h"
 #include "boot.h"
 
+extern char __boot_data_start[], __boot_data_end[];
+
 void error(char *x)
 {
 	sclp_early_printk("\n\n");
@@ -36,6 +38,13 @@ static void rescue_initrd(void)
 	INITRD_START = min_initrd_addr;
 }
 
+static void copy_bootdata(void)
+{
+	if (__boot_data_end - __boot_data_start != vmlinux.bootdata_size)
+		error(".boot.data section size mismatch");
+	memcpy((void *)vmlinux.bootdata_off, __boot_data_start, vmlinux.bootdata_size);
+}
+
 void startup_kernel(void)
 {
 	void *img;
@@ -45,5 +54,6 @@ void startup_kernel(void)
 		img = decompress_kernel();
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);
 	}
+	copy_bootdata();
 	vmlinux.entry();
 }

commit 7516fc11e44e73f1fcf8a3808dd88f82142e6585
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Jul 25 15:01:11 2018 +0200

    s390/decompressor: clean up and rename compressed/misc.c
    
    Since compressed/misc.c is conditionally compiled move error reporting
    code to boot/main.c. With that being done compressed/misc.c has no
    "miscellaneous" functions left and is all about plain decompression
    now. Rename it accordingly.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 5aeac7564e67..81199ca4a513 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -1,9 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/string.h>
 #include <asm/setup.h>
+#include <asm/sclp.h>
 #include "compressed/decompressor.h"
 #include "boot.h"
 
+void error(char *x)
+{
+	sclp_early_printk("\n\n");
+	sclp_early_printk(x);
+	sclp_early_printk("\n\n -- System halted");
+
+	disabled_wait(0xdeadbeef);
+}
+
 #ifdef CONFIG_KERNEL_UNCOMPRESSED
 unsigned long mem_safe_offset(void)
 {

commit 15426ca43d888e79f2dc4012bce0cbd6be96baf1
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 11:56:55 2018 +0200

    s390: rescue initrd as early as possible
    
    To avoid multi-stage initrd rescue operation and to simplify
    assumptions during early memory allocations move initrd at some final
    safe destination as early as possible. This would also allow us to
    drop .bss usage restrictions for some files.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 474dee84d8a8..5aeac7564e67 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -1,12 +1,36 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/string.h>
+#include <asm/setup.h>
 #include "compressed/decompressor.h"
 #include "boot.h"
 
+#ifdef CONFIG_KERNEL_UNCOMPRESSED
+unsigned long mem_safe_offset(void)
+{
+	return vmlinux.default_lma + vmlinux.image_size + vmlinux.bss_size;
+}
+#endif
+
+static void rescue_initrd(void)
+{
+	unsigned long min_initrd_addr;
+
+	if (!IS_ENABLED(CONFIG_BLK_DEV_INITRD))
+		return;
+	if (!INITRD_START || !INITRD_SIZE)
+		return;
+	min_initrd_addr = mem_safe_offset();
+	if (min_initrd_addr <= INITRD_START)
+		return;
+	memmove((void *)min_initrd_addr, (void *)INITRD_START, INITRD_SIZE);
+	INITRD_START = min_initrd_addr;
+}
+
 void startup_kernel(void)
 {
 	void *img;
 
+	rescue_initrd();
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
 		img = decompress_kernel();
 		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);

commit 369f91c374514f9491d52fec12f7ee9ef6d44b23
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Thu Jul 19 16:51:25 2018 +0200

    s390/decompressor: rework uncompressed image info collection
    
    The kernel decompressor has to know several bits of information about
    uncompressed image. Currently this info is collected by running "nm" on
    uncompressed vmlinux + "sed" and producing sizes.h file. This method
    worked well, but it has several disadvantages. Obscure symbols name
    pattern matching is fragile. Adding new values makes pattern even
    longer. Logic is spread across code and make file. Limited ability to
    adjust symbols values (currently magic lma value of 0x100000 is always
    subtracted). Apart from that same pieces of information (and more)
    would be needed for early memory detection and features like KASLR
    outside of boot/compressed/ folder where sizes.h is generated.
    
    To overcome limitations new "struct vmlinux_info" has been introduced
    to include values needed for the decompressor and the rest of the
    boot code. The only static instance of vmlinux_info is produced during
    vmlinux link step by filling in struct fields by the linker (like it is
    done with input_data in boot/compressed/vmlinux.scr.lds.S). This way
    individual values could be adjusted with all the knowledge linker has
    and arithmetic it supports. Later .vmlinux.info section (which contains
    struct vmlinux_info) is transplanted into the decompressor image and
    dropped from uncompressed image altogether.
    
    While doing that replace "compressed/vmlinux.scr.lds.S" linker
    script (whose purpose is to rename .data section in piggy.o to
    .rodata.compressed) with plain objcopy command. And simplify
    decompressor's linker script.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
index 2a9ce355f8e6..474dee84d8a8 100644
--- a/arch/s390/boot/startup.c
+++ b/arch/s390/boot/startup.c
@@ -5,13 +5,11 @@
 
 void startup_kernel(void)
 {
-	void (*startup_continue)(void) = (void *)0x100000;
-	unsigned long uncompressed_size;
-	void *uncompressed_img;
+	void *img;
 
 	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
-		uncompressed_img = decompress_kernel(&uncompressed_size);
-		memmove(startup_continue, uncompressed_img, uncompressed_size);
+		img = decompress_kernel();
+		memmove((void *)vmlinux.default_lma, img, vmlinux.image_size);
 	}
-	startup_continue();
+	vmlinux.entry();
 }

commit 8f75582a2fb6e2c5afc5252b6d6932f61a79c939
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Thu Jul 19 13:11:28 2018 +0200

    s390: remove decompressor's head.S
    
    Decompressor's head.S provided "data mover" sole purpose of which has
    been to safely move uncompressed kernel at 0x100000 and jump to it.
    
    With current bzImage layout entire decompressor's code guaranteed to be
    in a safe location under 0x100000, and hence could not be overwritten
    during kernel move. For that reason head.S could be replaced with simple
    memmove function. To do so introduce early boot code phase which is
    executed from arch/s390/boot/head.S after "verify_facilities" and takes
    care of optional kernel image decompression and transition to it.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/boot/startup.c b/arch/s390/boot/startup.c
new file mode 100644
index 000000000000..2a9ce355f8e6
--- /dev/null
+++ b/arch/s390/boot/startup.c
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/string.h>
+#include "compressed/decompressor.h"
+#include "boot.h"
+
+void startup_kernel(void)
+{
+	void (*startup_continue)(void) = (void *)0x100000;
+	unsigned long uncompressed_size;
+	void *uncompressed_img;
+
+	if (!IS_ENABLED(CONFIG_KERNEL_UNCOMPRESSED)) {
+		uncompressed_img = decompress_kernel(&uncompressed_size);
+		memmove(startup_continue, uncompressed_img, uncompressed_size);
+	}
+	startup_continue();
+}
