commit 222ee9087a730b1df08d09baed0d03626e67600f
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Nov 27 17:37:51 2019 +0100

    s390/unwind: start unwinding from reliable state
    
    A comment in arch/s390/include/asm/unwind.h says:
    > If 'first_frame' is not zero unwind_start skips unwind frames until it
    > reaches the specified stack pointer.
    > The end of the unwinding is indicated with unwind_done, this can be true
    > right after unwind_start, e.g. with first_frame!=0 that can not be found.
    > unwind_next_frame skips to the next frame.
    > Once the unwind is completed unwind_error() can be used to check if there
    > has been a situation where the unwinder could not correctly understand
    > the tasks call chain.
    
    With this change backchain unwinder now comply with behaviour
    described. As well as matches orc unwinder implementation.  Now unwinder
    starts from reliable state, i.e. __unwind_start own stack frame is
    taken or stack frame generated by __switch_to (ksp) - both known to be
    valid. In case of pt_regs %r15 is better match for pt_regs psw, than
    sometimes random "sp" caller passed.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
index 5d6c8fe7a271..de9006b0cfeb 100644
--- a/arch/s390/include/asm/unwind.h
+++ b/arch/s390/include/asm/unwind.h
@@ -58,11 +58,11 @@ static inline bool unwind_error(struct unwind_state *state)
 static inline void unwind_start(struct unwind_state *state,
 				struct task_struct *task,
 				struct pt_regs *regs,
-				unsigned long sp)
+				unsigned long first_frame)
 {
 	task = task ?: current;
-	sp = sp ?: get_stack_pointer(task, regs);
-	__unwind_start(state, task, regs, sp);
+	first_frame = first_frame ?: get_stack_pointer(task, regs);
+	__unwind_start(state, task, regs, first_frame);
 }
 
 static inline struct pt_regs *unwind_get_entry_regs(struct unwind_state *state)

commit 97806dfb6f3838ee4b7bc69e6f160d83eadbc74a
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Nov 22 15:58:42 2019 +0100

    s390/unwind: make reuse_sp default when unwinding pt_regs
    
    Currently unwinder yields 2 entries when pt_regs are met:
    sp="address of pt_regs itself" ip=pt_regs->psw
    sp=pt_regs->gprs[15] ip="r14 from stack frame pointed by pt_regs->gprs[15]"
    
    And neither of those 2 states (combination of sp and ip) ever happened.
    
    reuse_sp has been introduced by commit a1d863ac3e10 ("s390/unwind: fix
    mixing regs and sp"). reuse_sp=true makes unwinder keen to produce the
    following result, when pt_regs are given (as an arg to unwind_start):
    sp=pt_regs->gprs[15] ip=pt_regs->psw
    sp=pt_regs->gprs[15] ip="r14 from stack frame pointed by pt_regs->gprs[15]"
    
    The first state is an actual state in which a task was when pt_regs were
    collected. The second state is marked unreliable and is for debugging
    purposes to cover the case when a task has been interrupted in between
    stack frame allocation and writing back_chain - in this case r14 might
    show an actual caller.
    
    Make unwinder behaviour enabled via reuse_sp=true default and drop the
    special case handling.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
index a2d8dd766987..5d6c8fe7a271 100644
--- a/arch/s390/include/asm/unwind.h
+++ b/arch/s390/include/asm/unwind.h
@@ -35,7 +35,6 @@ struct unwind_state {
 	struct task_struct *task;
 	struct pt_regs *regs;
 	unsigned long sp, ip;
-	bool reuse_sp;
 	int graph_idx;
 	bool reliable;
 	bool error;

commit 103b4cca60d2c8c51f1290cc984b7046ccb8b46d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Nov 22 12:35:34 2019 +0100

    s390/unwind: unify task is current checks
    
    Avoid mixture of task == NULL and task == current meaning the same
    thing and simply always initialize task with current in unwind_start.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
index eaaefeceef6f..a2d8dd766987 100644
--- a/arch/s390/include/asm/unwind.h
+++ b/arch/s390/include/asm/unwind.h
@@ -61,7 +61,8 @@ static inline void unwind_start(struct unwind_state *state,
 				struct pt_regs *regs,
 				unsigned long sp)
 {
-	sp = sp ? : get_stack_pointer(task, regs);
+	task = task ?: current;
+	sp = sp ?: get_stack_pointer(task, regs);
 	__unwind_start(state, task, regs, sp);
 }
 

commit a1d863ac3e1085e1fea9caafd87252d08731de2e
Author: Ilya Leoshkevich <iii@linux.ibm.com>
Date:   Wed Oct 2 13:29:57 2019 +0200

    s390/unwind: fix mixing regs and sp
    
    unwind_for_each_frame stops after the first frame if regs->gprs[15] <=
    sp.
    
    The reason is that in case regs are specified, the first frame should be
    regs->psw.addr and the second frame should be sp->gprs[8]. However,
    currently the second frame is regs->gprs[15], which confuses
    outside_of_stack().
    
    Fix by introducing a flag to distinguish this special case from
    unwinding the interrupt handler, for which the current behavior is
    appropriate.
    
    Fixes: 78c98f907413 ("s390/unwind: introduce stack unwind API")
    Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
    Cc: stable@vger.kernel.org # v5.2+
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
index d827b5b9a32c..eaaefeceef6f 100644
--- a/arch/s390/include/asm/unwind.h
+++ b/arch/s390/include/asm/unwind.h
@@ -35,6 +35,7 @@ struct unwind_state {
 	struct task_struct *task;
 	struct pt_regs *regs;
 	unsigned long sp, ip;
+	bool reuse_sp;
 	int graph_idx;
 	bool reliable;
 	bool error;

commit da1776733617c4a92319eddb4e765ce60426b20a
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Thu Jun 20 10:18:35 2019 +0200

    s390/unwind: cleanup unused READ_ONCE_TASK_STACK
    
    Kasan instrumentation of backchain unwinder stack reads is disabled
    completely and simply uses READ_ONCE_NOCHECK now.
    READ_ONCE_TASK_STACK macro is unused and could be removed.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
index 6eb2ef105d87..d827b5b9a32c 100644
--- a/arch/s390/include/asm/unwind.h
+++ b/arch/s390/include/asm/unwind.h
@@ -79,23 +79,4 @@ static inline void unwind_module_init(struct module *mod, void *orc_ip,
 				      size_t orc_ip_size, void *orc,
 				      size_t orc_size) {}
 
-#ifdef CONFIG_KASAN
-/*
- * This disables KASAN checking when reading a value from another task's stack,
- * since the other task could be running on another CPU and could have poisoned
- * the stack in the meantime.
- */
-#define READ_ONCE_TASK_STACK(task, x)			\
-({							\
-	unsigned long val;				\
-	if (task == current)				\
-		val = READ_ONCE(x);			\
-	else						\
-		val = READ_ONCE_NOCHECK(x);		\
-	val;						\
-})
-#else
-#define READ_ONCE_TASK_STACK(task, x) READ_ONCE(x)
-#endif
-
 #endif /* _ASM_S390_UNWIND_H */

commit 78c98f9074135d3dab4e39544e0a537f92388fce
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Jan 28 08:33:08 2019 +0100

    s390/unwind: introduce stack unwind API
    
    Rework the dump_trace() stack unwinder interface to support different
    unwinding algorithms. The new interface looks like this:
    
            struct unwind_state state;
            unwind_for_each_frame(&state, task, regs, start_stack)
                    do_something(state.sp, state.ip, state.reliable);
    
    The unwind_bc.c file contains the implementation for the classic
    back-chain unwinder.
    
    One positive side effect of the new code is it now handles ftraced
    functions gracefully. It prints the real name of the return function
    instead of 'return_to_handler'.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/unwind.h b/arch/s390/include/asm/unwind.h
new file mode 100644
index 000000000000..6eb2ef105d87
--- /dev/null
+++ b/arch/s390/include/asm/unwind.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_S390_UNWIND_H
+#define _ASM_S390_UNWIND_H
+
+#include <linux/sched.h>
+#include <linux/ftrace.h>
+#include <asm/ptrace.h>
+#include <asm/stacktrace.h>
+
+/*
+ * To use the stack unwinder it has to be initialized with unwind_start.
+ * There four combinations for task and regs:
+ * 1) task==NULL, regs==NULL: the unwind starts for the task that is currently
+ *    running, sp/ip picked up from the CPU registers
+ * 2) task==NULL, regs!=NULL: the unwind starts from the sp/ip found in
+ *    the struct pt_regs of an interrupt frame for the current task
+ * 3) task!=NULL, regs==NULL: the unwind starts for an inactive task with
+ *    the sp picked up from task->thread.ksp and the ip picked up from the
+ *    return address stored by __switch_to
+ * 4) task!=NULL, regs!=NULL: the sp/ip are picked up from the interrupt
+ *    frame 'regs' of a inactive task
+ * If 'first_frame' is not zero unwind_start skips unwind frames until it
+ * reaches the specified stack pointer.
+ * The end of the unwinding is indicated with unwind_done, this can be true
+ * right after unwind_start, e.g. with first_frame!=0 that can not be found.
+ * unwind_next_frame skips to the next frame.
+ * Once the unwind is completed unwind_error() can be used to check if there
+ * has been a situation where the unwinder could not correctly understand
+ * the tasks call chain.
+ */
+
+struct unwind_state {
+	struct stack_info stack_info;
+	unsigned long stack_mask;
+	struct task_struct *task;
+	struct pt_regs *regs;
+	unsigned long sp, ip;
+	int graph_idx;
+	bool reliable;
+	bool error;
+};
+
+void __unwind_start(struct unwind_state *state, struct task_struct *task,
+		    struct pt_regs *regs, unsigned long first_frame);
+bool unwind_next_frame(struct unwind_state *state);
+unsigned long unwind_get_return_address(struct unwind_state *state);
+
+static inline bool unwind_done(struct unwind_state *state)
+{
+	return state->stack_info.type == STACK_TYPE_UNKNOWN;
+}
+
+static inline bool unwind_error(struct unwind_state *state)
+{
+	return state->error;
+}
+
+static inline void unwind_start(struct unwind_state *state,
+				struct task_struct *task,
+				struct pt_regs *regs,
+				unsigned long sp)
+{
+	sp = sp ? : get_stack_pointer(task, regs);
+	__unwind_start(state, task, regs, sp);
+}
+
+static inline struct pt_regs *unwind_get_entry_regs(struct unwind_state *state)
+{
+	return unwind_done(state) ? NULL : state->regs;
+}
+
+#define unwind_for_each_frame(state, task, regs, first_frame)	\
+	for (unwind_start(state, task, regs, first_frame);	\
+	     !unwind_done(state);				\
+	     unwind_next_frame(state))
+
+static inline void unwind_init(void) {}
+static inline void unwind_module_init(struct module *mod, void *orc_ip,
+				      size_t orc_ip_size, void *orc,
+				      size_t orc_size) {}
+
+#ifdef CONFIG_KASAN
+/*
+ * This disables KASAN checking when reading a value from another task's stack,
+ * since the other task could be running on another CPU and could have poisoned
+ * the stack in the meantime.
+ */
+#define READ_ONCE_TASK_STACK(task, x)			\
+({							\
+	unsigned long val;				\
+	if (task == current)				\
+		val = READ_ONCE(x);			\
+	else						\
+		val = READ_ONCE_NOCHECK(x);		\
+	val;						\
+})
+#else
+#define READ_ONCE_TASK_STACK(task, x) READ_ONCE(x)
+#endif
+
+#endif /* _ASM_S390_UNWIND_H */
