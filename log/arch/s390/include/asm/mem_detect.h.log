commit 9b692102d87d13d24c97461207cae259121ed44b
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Mon Aug 19 23:14:10 2019 +0200

    s390/mem_detect: provide single get_mem_detect_end
    
    get_mem_detect_end is already used in couple of places with potential
    to be utilized in more cases. Provide single get_mem_detect_end
    implementation in asm/mem_detect.h to be used by kasan and startup code.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
index 6114b92ab667..a7c922a69050 100644
--- a/arch/s390/include/asm/mem_detect.h
+++ b/arch/s390/include/asm/mem_detect.h
@@ -79,4 +79,16 @@ static inline void get_mem_detect_reserved(unsigned long *start,
 		*size = 0;
 }
 
+static inline unsigned long get_mem_detect_end(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	if (mem_detect.count) {
+		__get_mem_detect_block(mem_detect.count - 1, &start, &end);
+		return end;
+	}
+	return 0;
+}
+
 #endif

commit 54c57795e848100a2502b7a39b12b784292f4576
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 19:15:24 2018 +0200

    s390/mem_detect: replace tprot loop with binary search
    
    In a situation when other memory detection methods are not available
    (no SCLP and no z/VM diag260), continuous online memory is assumed.
    Replacing tprot loop with faster binary search, as only online memory
    end has to be found.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
index 153c3542fa8a..6114b92ab667 100644
--- a/arch/s390/include/asm/mem_detect.h
+++ b/arch/s390/include/asm/mem_detect.h
@@ -9,7 +9,7 @@ enum mem_info_source {
 	MEM_DETECT_SCLP_STOR_INFO,
 	MEM_DETECT_DIAG260,
 	MEM_DETECT_SCLP_READ_INFO,
-	MEM_DETECT_TPROT_LOOP
+	MEM_DETECT_BIN_SEARCH
 };
 
 struct mem_detect_block {

commit cd45c995610420755c5fe0d09afee3106c586e26
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:54:40 2018 +0200

    s390/mem_detect: use SCLP info for continuous memory detection
    
    When neither SCLP storage info, nor z/VM diag260 "storage configuration"
    are available assume a continuous online memory of size specified by
    SCLP info.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
index 6047a28656f5..153c3542fa8a 100644
--- a/arch/s390/include/asm/mem_detect.h
+++ b/arch/s390/include/asm/mem_detect.h
@@ -8,6 +8,7 @@ enum mem_info_source {
 	MEM_DETECT_NONE = 0,
 	MEM_DETECT_SCLP_STOR_INFO,
 	MEM_DETECT_DIAG260,
+	MEM_DETECT_SCLP_READ_INFO,
 	MEM_DETECT_TPROT_LOOP
 };
 

commit 6e98e6432995a3094a88bf6024187c3c235be976
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:48:20 2018 +0200

    s390/mem_detect: introduce z/VM specific diag260 call
    
    In the case when z/VM memory is defined with "define storage config"
    command, SCLP storage info is not available. Utilize diag260 "storage
    configuration" call, to get information about z/VM specific guest memory
    definitions with potential memory holes.
    
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
index 00426c07f6df..6047a28656f5 100644
--- a/arch/s390/include/asm/mem_detect.h
+++ b/arch/s390/include/asm/mem_detect.h
@@ -7,6 +7,7 @@
 enum mem_info_source {
 	MEM_DETECT_NONE = 0,
 	MEM_DETECT_SCLP_STOR_INFO,
+	MEM_DETECT_DIAG260,
 	MEM_DETECT_TPROT_LOOP
 };
 

commit fddbaa5c423f7ca0a187f88e0b1d98a5c8b4edcf
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 18:42:37 2018 +0200

    s390/mem_detect: introduce SCLP storage info
    
    SCLP storage info allows to detect continuous and non-continuous online
    memory under LPAR, z/VM and KVM, when standby memory is defined.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
index 8586adef1c65..00426c07f6df 100644
--- a/arch/s390/include/asm/mem_detect.h
+++ b/arch/s390/include/asm/mem_detect.h
@@ -6,6 +6,7 @@
 
 enum mem_info_source {
 	MEM_DETECT_NONE = 0,
+	MEM_DETECT_SCLP_STOR_INFO,
 	MEM_DETECT_TPROT_LOOP
 };
 
@@ -32,6 +33,8 @@ struct mem_detect_info {
 };
 extern struct mem_detect_info mem_detect;
 
+void add_mem_detect_block(u64 start, u64 end);
+
 static inline int __get_mem_detect_block(u32 n, unsigned long *start,
 					 unsigned long *end)
 {

commit 6966d604e2ec4ecf5691aea953538f63597a250d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Apr 11 11:56:55 2018 +0200

    s390/mem_detect: move tprot loop to early boot phase
    
    Move memory detection to early boot phase. To store online memory
    regions "struct mem_detect_info" has been introduced together with
    for_each_mem_detect_block iterator. mem_detect_info is later converted
    to memblock.
    
    Also introduces sclp_early_get_meminfo function to get maximum physical
    memory and maximum increment number.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/include/asm/mem_detect.h b/arch/s390/include/asm/mem_detect.h
new file mode 100644
index 000000000000..8586adef1c65
--- /dev/null
+++ b/arch/s390/include/asm/mem_detect.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_S390_MEM_DETECT_H
+#define _ASM_S390_MEM_DETECT_H
+
+#include <linux/types.h>
+
+enum mem_info_source {
+	MEM_DETECT_NONE = 0,
+	MEM_DETECT_TPROT_LOOP
+};
+
+struct mem_detect_block {
+	u64 start;
+	u64 end;
+};
+
+/*
+ * Storage element id is defined as 1 byte (up to 256 storage elements).
+ * In practise only storage element id 0 and 1 are used).
+ * According to architecture one storage element could have as much as
+ * 1020 subincrements. 255 mem_detect_blocks are embedded in mem_detect_info.
+ * If more mem_detect_blocks are required, a block of memory from already
+ * known mem_detect_block is taken (entries_extended points to it).
+ */
+#define MEM_INLINED_ENTRIES 255 /* (PAGE_SIZE - 16) / 16 */
+
+struct mem_detect_info {
+	u32 count;
+	u8 info_source;
+	struct mem_detect_block entries[MEM_INLINED_ENTRIES];
+	struct mem_detect_block *entries_extended;
+};
+extern struct mem_detect_info mem_detect;
+
+static inline int __get_mem_detect_block(u32 n, unsigned long *start,
+					 unsigned long *end)
+{
+	if (n >= mem_detect.count) {
+		*start = 0;
+		*end = 0;
+		return -1;
+	}
+
+	if (n < MEM_INLINED_ENTRIES) {
+		*start = (unsigned long)mem_detect.entries[n].start;
+		*end = (unsigned long)mem_detect.entries[n].end;
+	} else {
+		*start = (unsigned long)mem_detect.entries_extended[n - MEM_INLINED_ENTRIES].start;
+		*end = (unsigned long)mem_detect.entries_extended[n - MEM_INLINED_ENTRIES].end;
+	}
+	return 0;
+}
+
+/**
+ * for_each_mem_detect_block - early online memory range iterator
+ * @i: an integer used as loop variable
+ * @p_start: ptr to unsigned long for start address of the range
+ * @p_end: ptr to unsigned long for end address of the range
+ *
+ * Walks over detected online memory ranges.
+ */
+#define for_each_mem_detect_block(i, p_start, p_end)			\
+	for (i = 0, __get_mem_detect_block(i, p_start, p_end);		\
+	     i < mem_detect.count;					\
+	     i++, __get_mem_detect_block(i, p_start, p_end))
+
+static inline void get_mem_detect_reserved(unsigned long *start,
+					   unsigned long *size)
+{
+	*start = (unsigned long)mem_detect.entries_extended;
+	if (mem_detect.count > MEM_INLINED_ENTRIES)
+		*size = (mem_detect.count - MEM_INLINED_ENTRIES) * sizeof(struct mem_detect_block);
+	else
+		*size = 0;
+}
+
+#endif
