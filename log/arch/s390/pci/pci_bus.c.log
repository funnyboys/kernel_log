commit e5794cf1a270d813a5b9373a6876487d4d154195
Author: Niklas Schnelle <schnelle@linux.ibm.com>
Date:   Tue Apr 28 11:54:46 2020 +0200

    s390/pci: create links between PFs and VFs
    
    On s390 PCI Virtual Functions (VFs) are scanned by firmware and are made
    available to Linux via the hot-plug interface. As such the common code
    path of doing the scan directly using the parent Physical Function (PF)
    is not used and fenced off with the no_vf_scan attribute.
    
    Even if the partition created the VFs itself e.g. using the sriov_numvfs
    attribute of a PF, the PF/VF links thus need to be established after the
    fact. To do this when a VF is plugged we scan through all functions on
    the same zbus and test whether they are the parent PF in which case we
    establish the necessary links.
    
    With these links established there is now no more need to fence off
    pci_iov_remove_virtfn() for pdev->no_vf_scan as the common code now
    works fine.
    
    Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
    Link: https://lore.kernel.org/r/20200506154139.90609-3-schnelle@linux.ibm.com
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
index ada571d1c630..642a99384688 100644
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@ -126,6 +126,64 @@ static struct zpci_bus *zpci_bus_alloc(int pchid)
 	return zbus;
 }
 
+#ifdef CONFIG_PCI_IOV
+static int zpci_bus_link_virtfn(struct pci_dev *pdev,
+		struct pci_dev *virtfn, int vfid)
+{
+	int rc;
+
+	virtfn->physfn = pci_dev_get(pdev);
+	rc = pci_iov_sysfs_link(pdev, virtfn, vfid);
+	if (rc) {
+		pci_dev_put(pdev);
+		virtfn->physfn = NULL;
+		return rc;
+	}
+	return 0;
+}
+
+static int zpci_bus_setup_virtfn(struct zpci_bus *zbus,
+		struct pci_dev *virtfn, int vfn)
+{
+	int i, cand_devfn;
+	struct zpci_dev *zdev;
+	struct pci_dev *pdev;
+	int vfid = vfn - 1; /* Linux' vfid's start at 0 vfn at 1*/
+	int rc = 0;
+
+	virtfn->is_virtfn = 1;
+	virtfn->multifunction = 0;
+	WARN_ON(vfid < 0);
+	/* If the parent PF for the given VF is also configured in the
+	 * instance, it must be on the same zbus.
+	 * We can then identify the parent PF by checking what
+	 * devfn the VF would have if it belonged to that PF using the PF's
+	 * stride and offset. Only if this candidate devfn matches the
+	 * actual devfn will we link both functions.
+	 */
+	for (i = 0; i < ZPCI_FUNCTIONS_PER_BUS; i++) {
+		zdev = zbus->function[i];
+		if (zdev && zdev->is_physfn) {
+			pdev = pci_get_slot(zbus->bus, zdev->devfn);
+			cand_devfn = pci_iov_virtfn_devfn(pdev, vfid);
+			if (cand_devfn == virtfn->devfn) {
+				rc = zpci_bus_link_virtfn(pdev, virtfn, vfid);
+				break;
+			}
+		}
+	}
+	return rc;
+}
+#else
+static inline int zpci_bus_setup_virtfn(struct zpci_bus *zbus,
+		struct pci_dev *virtfn, int vfn)
+{
+	virtfn->is_virtfn = 1;
+	virtfn->multifunction = 0;
+	return 0;
+}
+#endif
+
 static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
 {
 	struct pci_bus *bus;
@@ -156,10 +214,20 @@ static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
 	}
 
 	pdev = pci_scan_single_device(bus, zdev->devfn);
-	if (pdev)
+	if (pdev) {
+		if (!zdev->is_physfn) {
+			rc = zpci_bus_setup_virtfn(zbus, pdev, zdev->vfn);
+			if (rc)
+				goto failed_with_pdev;
+		}
 		pci_bus_add_device(pdev);
-
+	}
 	return 0;
+
+failed_with_pdev:
+	pci_stop_and_remove_bus_device(pdev);
+	pci_dev_put(pdev);
+	return rc;
 }
 
 static void zpci_bus_add_devices(struct zpci_bus *zbus)

commit d1379279f2d6b407bd08324a170cb21928e69854
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Tue Apr 28 11:25:56 2020 -0400

    s390/pci: removes wrong PCI multifunction assignment
    
    The assignment of the PCI device multifunction attribute
    is set during the PCI device probe.
    There is no need to set it here.
    
    Let's do it right and remove this assignment.
    
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
index 542c6b8f56df..ada571d1c630 100644
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@ -156,10 +156,8 @@ static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
 	}
 
 	pdev = pci_scan_single_device(bus, zdev->devfn);
-	if (pdev) {
-		pdev->multifunction = 1;
+	if (pdev)
 		pci_bus_add_device(pdev);
-	}
 
 	return 0;
 }

commit 44510d6fa0c00aa90b80075caa6b313b25927475
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Wed Apr 22 15:15:23 2020 +0200

    s390/pci: Handling multifunctions
    
    We allow multiple functions on a single bus.
    We suppress the ZPCI_DEVFN definition and replace its
    occurences with zpci->devfn.
    
    We verify the number of device during the registration.
    
    There can never be more domains in use than existing
    devices, so we do not need to verify the count of domain
    after having verified the count of devices.
    
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
index b4fefc69c461..542c6b8f56df 100644
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@ -62,14 +62,16 @@ static void zpci_bus_release(struct kref *kref)
 {
 	struct zpci_bus *zbus = container_of(kref, struct zpci_bus, kref);
 
-	pci_lock_rescan_remove();
-	pci_stop_root_bus(zbus->bus);
+	if (zbus->bus) {
+		pci_lock_rescan_remove();
+		pci_stop_root_bus(zbus->bus);
 
-	zpci_free_domain(zbus->domain_nr);
-	pci_free_resource_list(&zbus->resources);
+		zpci_free_domain(zbus->domain_nr);
+		pci_free_resource_list(&zbus->resources);
 
-	pci_remove_root_bus(zbus->bus);
-	pci_unlock_rescan_remove();
+		pci_remove_root_bus(zbus->bus);
+		pci_unlock_rescan_remove();
+	}
 
 	spin_lock(&zbus_list_lock);
 	list_del(&zbus->bus_next);
@@ -82,6 +84,23 @@ static void zpci_bus_put(struct zpci_bus *zbus)
 	kref_put(&zbus->kref, zpci_bus_release);
 }
 
+static struct zpci_bus *zpci_bus_get(int pchid)
+{
+	struct zpci_bus *zbus;
+
+	spin_lock(&zbus_list_lock);
+	list_for_each_entry(zbus, &zbus_list, bus_next) {
+		if (pchid == zbus->pchid) {
+			kref_get(&zbus->kref);
+			goto out_unlock;
+		}
+	}
+	zbus = NULL;
+out_unlock:
+	spin_unlock(&zbus_list_lock);
+	return zbus;
+}
+
 static struct zpci_bus *zpci_bus_alloc(int pchid)
 {
 	struct zpci_bus *zbus;
@@ -107,11 +126,62 @@ static struct zpci_bus *zpci_bus_alloc(int pchid)
 	return zbus;
 }
 
-int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
+static int zpci_bus_add_device(struct zpci_bus *zbus, struct zpci_dev *zdev)
 {
-	struct zpci_bus *zbus;
+	struct pci_bus *bus;
+	struct resource_entry *window, *n;
+	struct resource *res;
+	struct pci_dev *pdev;
 	int rc;
 
+	bus = zbus->bus;
+	if (!bus)
+		return -EINVAL;
+
+	pdev = pci_get_slot(bus, zdev->devfn);
+	if (pdev) {
+		/* Device is already known. */
+		pci_dev_put(pdev);
+		return 0;
+	}
+
+	rc = zpci_init_slot(zdev);
+	if (rc)
+		return rc;
+	zdev->has_hp_slot = 1;
+
+	resource_list_for_each_entry_safe(window, n, &zbus->resources) {
+		res = window->res;
+		pci_bus_add_resource(bus, res, 0);
+	}
+
+	pdev = pci_scan_single_device(bus, zdev->devfn);
+	if (pdev) {
+		pdev->multifunction = 1;
+		pci_bus_add_device(pdev);
+	}
+
+	return 0;
+}
+
+static void zpci_bus_add_devices(struct zpci_bus *zbus)
+{
+	int i;
+
+	for (i = 1; i < ZPCI_FUNCTIONS_PER_BUS; i++)
+		if (zbus->function[i])
+			zpci_bus_add_device(zbus, zbus->function[i]);
+
+	pci_lock_rescan_remove();
+	pci_bus_add_devices(zbus->bus);
+	pci_unlock_rescan_remove();
+}
+
+int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
+{
+	struct zpci_bus *zbus = NULL;
+	int rc = -EBADF;
+
 	if (zpci_nb_devices == ZPCI_NR_DEVICES) {
 		pr_warn("Adding PCI function %08x failed because the configured limit of %d is reached\n",
 			zdev->fid, ZPCI_NR_DEVICES);
@@ -119,25 +189,65 @@ int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
 	}
 	zpci_nb_devices++;
 
-	if (zdev->devfn != ZPCI_DEVFN)
+	if (zdev->devfn >= ZPCI_FUNCTIONS_PER_BUS)
 		return -EINVAL;
 
-	zbus = zpci_bus_alloc(zdev->pchid);
-	if (!zbus)
-		return -ENOMEM;
+	if (!s390_pci_no_rid && zdev->rid_available)
+		zbus = zpci_bus_get(zdev->pchid);
+
+	if (!zbus) {
+		zbus = zpci_bus_alloc(zdev->pchid);
+		if (!zbus)
+			return -ENOMEM;
+	}
 
 	zdev->zbus = zbus;
-	zbus->function[ZPCI_DEVFN] = zdev;
+	if (zbus->function[zdev->devfn]) {
+		pr_err("devfn %04x is already assigned\n", zdev->devfn);
+		goto error; /* rc already set */
+	}
+	zbus->function[zdev->devfn] = zdev;
 
 	zpci_setup_bus_resources(zdev, &zbus->resources);
-	zbus->max_bus_speed = zdev->max_bus_speed;
 
-	rc = zpci_bus_scan(zbus, (u16)zdev->uid, ops);
-	if (!rc)
-		return 0;
+	if (zbus->bus) {
+		if (!zbus->multifunction) {
+			WARN_ONCE(1, "zbus is not multifunction\n");
+			goto error_bus;
+		}
+		if (!zdev->rid_available) {
+			WARN_ONCE(1, "rid_available not set for multifunction\n");
+			goto error_bus;
+		}
+		rc = zpci_bus_add_device(zbus, zdev);
+		if (rc)
+			goto error_bus;
+	} else if (zdev->devfn == 0) {
+		if (zbus->multifunction && !zdev->rid_available) {
+			WARN_ONCE(1, "rid_available not set on function 0 for multifunction\n");
+			goto error_bus;
+		}
+		rc = zpci_bus_scan(zbus, (u16)zdev->uid, ops);
+		if (rc)
+			goto error_bus;
+		zpci_bus_add_devices(zbus);
+		rc = zpci_init_slot(zdev);
+		if (rc)
+			goto error_bus;
+		zdev->has_hp_slot = 1;
+		zbus->multifunction = zdev->rid_available;
+		zbus->max_bus_speed = zdev->max_bus_speed;
+	} else {
+		zbus->multifunction = 1;
+	}
 
+	return 0;
+
+error_bus:
+	zpci_nb_devices--;
+	zbus->function[zdev->devfn] = NULL;
+error:
 	pr_err("Adding PCI function %08x failed\n", zdev->fid);
-	zdev->zbus = NULL;
 	zpci_bus_put(zbus);
 	return rc;
 }
@@ -147,6 +257,6 @@ void zpci_bus_device_unregister(struct zpci_dev *zdev)
 	struct zpci_bus *zbus = zdev->zbus;
 
 	zpci_nb_devices--;
-	zbus->function[ZPCI_DEVFN] = NULL;
+	zbus->function[zdev->devfn] = NULL;
 	zpci_bus_put(zbus);
 }

commit 65e450a9f9adabf3de1305a4c616f1313df402a3
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Mon Mar 23 12:29:37 2020 +0100

    s390/pci: Adding bus resource
    
    The current PCI implementation do not provide a bus resource.
    This leads to a notice being print at boot.
    Let's do it more nicely and provide the bus resource.
    
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
index e1565b8537de..b4fefc69c461 100644
--- a/arch/s390/pci/pci_bus.c
+++ b/arch/s390/pci/pci_bus.c
@@ -99,6 +99,11 @@ static struct zpci_bus *zpci_bus_alloc(int pchid)
 	kref_init(&zbus->kref);
 	INIT_LIST_HEAD(&zbus->resources);
 
+	zbus->bus_resource.start = 0;
+	zbus->bus_resource.end = ZPCI_BUS_NR;
+	zbus->bus_resource.flags = IORESOURCE_BUS;
+	pci_add_resource(&zbus->resources, &zbus->bus_resource);
+
 	return zbus;
 }
 

commit 05bc1be6db4b2683bbf5b9394a75d0fb3acfcede
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Mon Mar 23 10:45:43 2020 +0100

    s390/pci: create zPCI bus
    
    The zPCI bus is in charge to handle common zPCI resources for
    zPCI devices.
    
    Creating the zPCI bus, the PCI bus, the zPCI devices and the
    PCI devices and hotplug slots
    done in a specific order:
    - PCI hotplug slot creation needs a PCI bus
    - PCI bus needs a PCI domain
      which is reported by the pci_domain_nr() when setting up the
      host bridge
    - PCI domain is set from the zPCI with devfn 0
      this is necessary to have a reproducible enumeration
    
    Therefore we can not create devices or hotplug slots for any PCI
    device associated with a zPCI device before having discovered
    the function zero of the bus.
    
    The discovery and initialization of devices can be done at several
    points in the code:
    - On Events, serialized in a thread context
    - On initialization, in the kernel init thread context
    - When powering on the hotplug slot, in a user thread context
    
    The removal of devices and their parent bus may also be done on
    events or for devices when powering down the slot.
    
    To guarantee the existence of the bus and devices until they are
    no more needed we use kref in zPCI bus and introduce a reference
    count in the zPCI devices.
    
    In this patch the zPCI bus still only accept a device with
    a devfn 0.
    
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/pci/pci_bus.c b/arch/s390/pci/pci_bus.c
new file mode 100644
index 000000000000..e1565b8537de
--- /dev/null
+++ b/arch/s390/pci/pci_bus.c
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright IBM Corp. 2020
+ *
+ * Author(s):
+ *   Pierre Morel <pmorel@linux.ibm.com>
+ *
+ */
+
+#define KMSG_COMPONENT "zpci"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/jump_label.h>
+#include <linux/pci.h>
+#include <linux/printk.h>
+
+#include <asm/pci_clp.h>
+#include <asm/pci_dma.h>
+
+#include "pci_bus.h"
+
+static LIST_HEAD(zbus_list);
+static DEFINE_SPINLOCK(zbus_list_lock);
+static int zpci_nb_devices;
+
+/* zpci_bus_scan
+ * @zbus: the zbus holding the zdevices
+ * @ops: the pci operations
+ *
+ * The domain number must be set before pci_scan_root_bus is called.
+ * This function can be called once the domain is known, hence
+ * when the function_0 is dicovered.
+ */
+static int zpci_bus_scan(struct zpci_bus *zbus, int domain, struct pci_ops *ops)
+{
+	struct pci_bus *bus;
+	int rc;
+
+	rc = zpci_alloc_domain(domain);
+	if (rc < 0)
+		return rc;
+	zbus->domain_nr = rc;
+
+	bus = pci_scan_root_bus(NULL, ZPCI_BUS_NR, ops, zbus, &zbus->resources);
+	if (!bus) {
+		zpci_free_domain(zbus->domain_nr);
+		return -EFAULT;
+	}
+
+	zbus->bus = bus;
+	pci_bus_add_devices(bus);
+	return 0;
+}
+
+static void zpci_bus_release(struct kref *kref)
+{
+	struct zpci_bus *zbus = container_of(kref, struct zpci_bus, kref);
+
+	pci_lock_rescan_remove();
+	pci_stop_root_bus(zbus->bus);
+
+	zpci_free_domain(zbus->domain_nr);
+	pci_free_resource_list(&zbus->resources);
+
+	pci_remove_root_bus(zbus->bus);
+	pci_unlock_rescan_remove();
+
+	spin_lock(&zbus_list_lock);
+	list_del(&zbus->bus_next);
+	spin_unlock(&zbus_list_lock);
+	kfree(zbus);
+}
+
+static void zpci_bus_put(struct zpci_bus *zbus)
+{
+	kref_put(&zbus->kref, zpci_bus_release);
+}
+
+static struct zpci_bus *zpci_bus_alloc(int pchid)
+{
+	struct zpci_bus *zbus;
+
+	zbus = kzalloc(sizeof(*zbus), GFP_KERNEL);
+	if (!zbus)
+		return NULL;
+
+	zbus->pchid = pchid;
+	INIT_LIST_HEAD(&zbus->bus_next);
+	spin_lock(&zbus_list_lock);
+	list_add_tail(&zbus->bus_next, &zbus_list);
+	spin_unlock(&zbus_list_lock);
+
+	kref_init(&zbus->kref);
+	INIT_LIST_HEAD(&zbus->resources);
+
+	return zbus;
+}
+
+int zpci_bus_device_register(struct zpci_dev *zdev, struct pci_ops *ops)
+{
+	struct zpci_bus *zbus;
+	int rc;
+
+	if (zpci_nb_devices == ZPCI_NR_DEVICES) {
+		pr_warn("Adding PCI function %08x failed because the configured limit of %d is reached\n",
+			zdev->fid, ZPCI_NR_DEVICES);
+		return -ENOSPC;
+	}
+	zpci_nb_devices++;
+
+	if (zdev->devfn != ZPCI_DEVFN)
+		return -EINVAL;
+
+	zbus = zpci_bus_alloc(zdev->pchid);
+	if (!zbus)
+		return -ENOMEM;
+
+	zdev->zbus = zbus;
+	zbus->function[ZPCI_DEVFN] = zdev;
+
+	zpci_setup_bus_resources(zdev, &zbus->resources);
+	zbus->max_bus_speed = zdev->max_bus_speed;
+
+	rc = zpci_bus_scan(zbus, (u16)zdev->uid, ops);
+	if (!rc)
+		return 0;
+
+	pr_err("Adding PCI function %08x failed\n", zdev->fid);
+	zdev->zbus = NULL;
+	zpci_bus_put(zbus);
+	return rc;
+}
+
+void zpci_bus_device_unregister(struct zpci_dev *zdev)
+{
+	struct zpci_bus *zbus = zdev->zbus;
+
+	zpci_nb_devices--;
+	zbus->function[ZPCI_DEVFN] = NULL;
+	zpci_bus_put(zbus);
+}
