commit ad82a928eb58471adb2dec2001f5fbe57e5ee4b5
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Mon Jun 18 17:51:29 2018 +0200

    s390/perf: fix gcc 8 array-bounds warning
    
    arch/s390/kernel/perf_regs.c:36:19: warning: array subscript 16 is above
    array bounds of 'long unsigned int[16]' [-Warray-bounds]
      return regs->gprs[idx];
    
    gcc tries to be smart here and since there is a condition:
    if (idx >= PERF_REG_S390_R0 && idx <= PERF_REG_S390_R15)
            return regs->gprs[idx];
    which covers all possible array subscripts, it gives the warning
    for the last function return statement:
            return regs->gprs[idx];
    which in presence of that condition does not really make sense and
    should be replaced with "return 0;"
    
    Also move WARN_ON_ONCE((u32)idx >= PERF_REG_S390_MAX) to the end of the
    function.
    
    Reviewed-by: Hendrik Brueckner <brueckner@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/perf_regs.c b/arch/s390/kernel/perf_regs.c
index 54e2d634b849..4352a504f235 100644
--- a/arch/s390/kernel/perf_regs.c
+++ b/arch/s390/kernel/perf_regs.c
@@ -12,9 +12,6 @@ u64 perf_reg_value(struct pt_regs *regs, int idx)
 {
 	freg_t fp;
 
-	if (WARN_ON_ONCE((u32)idx >= PERF_REG_S390_MAX))
-		return 0;
-
 	if (idx >= PERF_REG_S390_R0 && idx <= PERF_REG_S390_R15)
 		return regs->gprs[idx];
 
@@ -33,7 +30,8 @@ u64 perf_reg_value(struct pt_regs *regs, int idx)
 	if (idx == PERF_REG_S390_PC)
 		return regs->psw.addr;
 
-	return regs->gprs[idx];
+	WARN_ON_ONCE((u32)idx >= PERF_REG_S390_MAX);
+	return 0;
 }
 
 #define REG_RESERVED (~((1UL << PERF_REG_S390_MAX) - 1))

commit 9fa1db4c7511543c951128758f358cd7aad99628
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Dec 4 10:39:38 2017 +0100

    s390: add a few more SPDX identifiers
    
    Add the correct SPDX license to a few more files under arch/s390 and
    drivers/s390 which have been missed to far.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/perf_regs.c b/arch/s390/kernel/perf_regs.c
index f8603ebed669..54e2d634b849 100644
--- a/arch/s390/kernel/perf_regs.c
+++ b/arch/s390/kernel/perf_regs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/perf_event.h>
 #include <linux/perf_regs.h>
 #include <linux/kernel.h>

commit 0da0017f72554c005c1a04c3adc5da9eb64fa7e5
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Wed Nov 8 07:30:15 2017 +0100

    s390/perf: extend perf_regs support to include floating-point registers
    
    Extend the perf register support to also export floating-point register
    contents for user space tasks.  Floating-point registers might be used
    in leaf functions to contain the return address.  Hence, they are required
    for proper DWARF unwinding.
    
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Reviewed-and-tested-by: Thomas Richter <tmricht@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/perf_regs.c b/arch/s390/kernel/perf_regs.c
index e883e6a2146a..f8603ebed669 100644
--- a/arch/s390/kernel/perf_regs.c
+++ b/arch/s390/kernel/perf_regs.c
@@ -4,12 +4,29 @@
 #include <linux/errno.h>
 #include <linux/bug.h>
 #include <asm/ptrace.h>
+#include <asm/fpu/api.h>
+#include <asm/fpu/types.h>
 
 u64 perf_reg_value(struct pt_regs *regs, int idx)
 {
+	freg_t fp;
+
 	if (WARN_ON_ONCE((u32)idx >= PERF_REG_S390_MAX))
 		return 0;
 
+	if (idx >= PERF_REG_S390_R0 && idx <= PERF_REG_S390_R15)
+		return regs->gprs[idx];
+
+	if (idx >= PERF_REG_S390_FP0 && idx <= PERF_REG_S390_FP15) {
+		if (!user_mode(regs))
+			return 0;
+
+		idx -= PERF_REG_S390_FP0;
+		fp = MACHINE_HAS_VX ? *(freg_t *)(current->thread.fpu.vxrs + idx)
+				    : current->thread.fpu.fprs[idx];
+		return fp.ui;
+	}
+
 	if (idx == PERF_REG_S390_MASK)
 		return regs->psw.mask;
 	if (idx == PERF_REG_S390_PC)
@@ -43,7 +60,11 @@ void perf_get_regs_user(struct perf_regs *regs_user,
 	/*
 	 * Use the regs from the first interruption and let
 	 * perf_sample_regs_intr() handle interrupts (regs == get_irq_regs()).
+	 *
+	 * Also save FPU registers for user-space tasks only.
 	 */
 	regs_user->regs = task_pt_regs(current);
+	if (user_mode(regs_user->regs))
+		save_fpu_regs();
 	regs_user->abi = perf_reg_abi(current);
 }

commit c33eff600584ed493adfb42e3f130a6335f97750
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Sat Jun 6 12:44:25 2015 +0200

    s390/perf: add perf_regs support and user stack dump
    
    Add s390 support to dump user stack to user space for DWARF
    stack unwinding.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reviewed-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Reviewed-and-tested-by: Thomas Richter <tmricht@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/perf_regs.c b/arch/s390/kernel/perf_regs.c
new file mode 100644
index 000000000000..e883e6a2146a
--- /dev/null
+++ b/arch/s390/kernel/perf_regs.c
@@ -0,0 +1,49 @@
+#include <linux/perf_event.h>
+#include <linux/perf_regs.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <asm/ptrace.h>
+
+u64 perf_reg_value(struct pt_regs *regs, int idx)
+{
+	if (WARN_ON_ONCE((u32)idx >= PERF_REG_S390_MAX))
+		return 0;
+
+	if (idx == PERF_REG_S390_MASK)
+		return regs->psw.mask;
+	if (idx == PERF_REG_S390_PC)
+		return regs->psw.addr;
+
+	return regs->gprs[idx];
+}
+
+#define REG_RESERVED (~((1UL << PERF_REG_S390_MAX) - 1))
+
+int perf_reg_validate(u64 mask)
+{
+	if (!mask || mask & REG_RESERVED)
+		return -EINVAL;
+
+	return 0;
+}
+
+u64 perf_reg_abi(struct task_struct *task)
+{
+	if (test_tsk_thread_flag(task, TIF_31BIT))
+		return PERF_SAMPLE_REGS_ABI_32;
+
+	return PERF_SAMPLE_REGS_ABI_64;
+}
+
+void perf_get_regs_user(struct perf_regs *regs_user,
+			struct pt_regs *regs,
+			struct pt_regs *regs_user_copy)
+{
+	/*
+	 * Use the regs from the first interruption and let
+	 * perf_sample_regs_intr() handle interrupts (regs == get_irq_regs()).
+	 */
+	regs_user->regs = task_pt_regs(current);
+	regs_user->abi = perf_reg_abi(current);
+}
