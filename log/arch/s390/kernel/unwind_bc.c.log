commit eef06cbf670aaa2ccb56c9a7b84042acd657aa5d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Dec 11 17:27:31 2019 +0100

    s390/unwind: stop gracefully at user mode pt_regs in irq stack
    
    Consider reaching user mode pt_regs at the bottom of irq stack graceful
    unwinder termination. This is the case when irq/mcck/ext interrupt arrives
    while in user mode.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index da2d4d4c5b0e..707fd99f6734 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -36,10 +36,17 @@ static bool update_stack_info(struct unwind_state *state, unsigned long sp)
 	return true;
 }
 
-static inline bool is_task_pt_regs(struct unwind_state *state,
-				   struct pt_regs *regs)
+static inline bool is_final_pt_regs(struct unwind_state *state,
+				    struct pt_regs *regs)
 {
-	return task_pt_regs(state->task) == regs;
+	/* user mode or kernel thread pt_regs at the bottom of task stack */
+	if (task_pt_regs(state->task) == regs)
+		return true;
+
+	/* user mode pt_regs at the bottom of irq stack */
+	return state->stack_info.type == STACK_TYPE_IRQ &&
+	       state->stack_info.end - sizeof(struct pt_regs) == (unsigned long)regs &&
+	       READ_ONCE_NOCHECK(regs->psw.mask) & PSW_MASK_PSTATE;
 }
 
 bool unwind_next_frame(struct unwind_state *state)
@@ -80,7 +87,7 @@ bool unwind_next_frame(struct unwind_state *state)
 			if (!on_stack(info, sp, sizeof(struct pt_regs)))
 				goto out_err;
 			regs = (struct pt_regs *) sp;
-			if (is_task_pt_regs(state, regs))
+			if (is_final_pt_regs(state, regs))
 				goto out_stop;
 			ip = READ_ONCE_NOCHECK(regs->psw.addr);
 			sp = READ_ONCE_NOCHECK(regs->gprs[15]);

commit be2d11b2a1e86586ace9f6839a159b170b00f2b3
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Wed Nov 27 19:35:19 2019 +0100

    s390/unwind: add stack pointer alignment sanity checks
    
    ABI requires SP to be aligned 8 bytes, report unwinding error otherwise.
    
    Link: https://lkml.kernel.org/r/20191106095601.29986-5-mbenes@suse.cz
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Tested-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index ef42d5f77ce7..da2d4d4c5b0e 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -92,6 +92,10 @@ bool unwind_next_frame(struct unwind_state *state)
 		}
 	}
 
+	/* Sanity check: ABI requires SP to be aligned 8 bytes. */
+	if (sp & 0x7)
+		goto out_err;
+
 	ip = ftrace_graph_ret_addr(state->task, &state->graph_idx, ip, (void *) sp);
 
 	/* Update unwind state */

commit bf018ee644897d7982e1b8dd8b15e97db6e1a4da
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Nov 27 18:12:04 2019 +0100

    s390/unwind: filter out unreliable bogus %r14
    
    Currently unwinder unconditionally returns %r14 from the first frame
    pointed by %r15 from pt_regs. A task could be interrupted when a function
    already allocated this frame (if it needs it) for its callees or to
    store local variables. In that case this frame would contain random
    values from stack or values stored there by a callee. As we are only
    interested in %r14 to get potential return address, skip bogus return
    addresses which doesn't belong to kernel text.
    
    This helps to avoid duplicating filtering logic in unwider users, most
    of which use unwind_get_return_address() and would choke on bogus 0
    address returned by it otherwise.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index e1371cdf9fa5..ef42d5f77ce7 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -57,6 +57,11 @@ bool unwind_next_frame(struct unwind_state *state)
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
 		regs = NULL;
+		if (!__kernel_text_address(ip)) {
+			/* skip bogus %r14 */
+			state->regs = NULL;
+			return unwind_next_frame(state);
+		}
 	} else {
 		sf = (struct stack_frame *) state->sp;
 		sp = READ_ONCE_NOCHECK(sf->back_chain);

commit 222ee9087a730b1df08d09baed0d03626e67600f
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Wed Nov 27 17:37:51 2019 +0100

    s390/unwind: start unwinding from reliable state
    
    A comment in arch/s390/include/asm/unwind.h says:
    > If 'first_frame' is not zero unwind_start skips unwind frames until it
    > reaches the specified stack pointer.
    > The end of the unwinding is indicated with unwind_done, this can be true
    > right after unwind_start, e.g. with first_frame!=0 that can not be found.
    > unwind_next_frame skips to the next frame.
    > Once the unwind is completed unwind_error() can be used to check if there
    > has been a situation where the unwinder could not correctly understand
    > the tasks call chain.
    
    With this change backchain unwinder now comply with behaviour
    described. As well as matches orc unwinder implementation.  Now unwinder
    starts from reliable state, i.e. __unwind_start own stack frame is
    taken or stack frame generated by __switch_to (ksp) - both known to be
    valid. In case of pt_regs %r15 is better match for pt_regs psw, than
    sometimes random "sp" caller passed.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index c5ebb8a4cdd6..e1371cdf9fa5 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -105,13 +105,11 @@ bool unwind_next_frame(struct unwind_state *state)
 EXPORT_SYMBOL_GPL(unwind_next_frame);
 
 void __unwind_start(struct unwind_state *state, struct task_struct *task,
-		    struct pt_regs *regs, unsigned long sp)
+		    struct pt_regs *regs, unsigned long first_frame)
 {
 	struct stack_info *info = &state->stack_info;
-	unsigned long *mask = &state->stack_mask;
-	bool reliable;
 	struct stack_frame *sf;
-	unsigned long ip;
+	unsigned long ip, sp;
 
 	memset(state, 0, sizeof(*state));
 	state->task = task;
@@ -123,23 +121,28 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 		return;
 	}
 
+	/* Get the instruction pointer from pt_regs or the stack frame */
+	if (regs) {
+		ip = regs->psw.addr;
+		sp = regs->gprs[15];
+	} else if (task == current) {
+		sp = current_frame_address();
+	} else {
+		sp = task->thread.ksp;
+	}
+
 	/* Get current stack pointer and initialize stack info */
-	if (get_stack_info(sp, task, info, mask) != 0 ||
-	    !on_stack(info, sp, sizeof(struct stack_frame))) {
+	if (!update_stack_info(state, sp)) {
 		/* Something is wrong with the stack pointer */
 		info->type = STACK_TYPE_UNKNOWN;
 		state->error = true;
 		return;
 	}
 
-	/* Get the instruction pointer from pt_regs or the stack frame */
-	if (regs) {
-		ip = READ_ONCE_NOCHECK(regs->psw.addr);
-		reliable = true;
-	} else {
-		sf = (struct stack_frame *) sp;
+	if (!regs) {
+		/* Stack frame is within valid stack */
+		sf = (struct stack_frame *)sp;
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
-		reliable = false;
 	}
 
 	ip = ftrace_graph_ret_addr(state->task, &state->graph_idx, ip, NULL);
@@ -147,6 +150,17 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	/* Update unwind state */
 	state->sp = sp;
 	state->ip = ip;
-	state->reliable = reliable;
+	state->reliable = true;
+
+	if (!first_frame)
+		return;
+	/* Skip through the call chain to the specified starting frame */
+	while (!unwind_done(state)) {
+		if (on_stack(&state->stack_info, first_frame, sizeof(struct stack_frame))) {
+			if (state->sp >= first_frame)
+				break;
+		}
+		unwind_next_frame(state);
+	}
 }
 EXPORT_SYMBOL_GPL(__unwind_start);

commit e76e69611e944ecc38aaf8fe3a7bebdc3c5daf84
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Nov 22 16:49:13 2019 +0100

    s390/unwind: stop gracefully at task pt_regs
    
    Consider reaching task pt_regs graceful unwinder termination. Task
    pt_regs itself never contains a valid state to which a task might return
    within the kernel context (user task pt_regs is a special case). Since
    we already avoid printing user task pt_regs and in most cases we don't
    even bother filling task pt_regs psw and r15 with something reasonable
    simply skip task pt_regs altogether. With this change unwind_error() now
    accurately represent whether unwinder reached task pt_regs successfully
    or failed along the way.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index ac6cfab567d1..c5ebb8a4cdd6 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -36,6 +36,12 @@ static bool update_stack_info(struct unwind_state *state, unsigned long sp)
 	return true;
 }
 
+static inline bool is_task_pt_regs(struct unwind_state *state,
+				   struct pt_regs *regs)
+{
+	return task_pt_regs(state->task) == regs;
+}
+
 bool unwind_next_frame(struct unwind_state *state)
 {
 	struct stack_info *info = &state->stack_info;
@@ -69,7 +75,7 @@ bool unwind_next_frame(struct unwind_state *state)
 			if (!on_stack(info, sp, sizeof(struct pt_regs)))
 				goto out_err;
 			regs = (struct pt_regs *) sp;
-			if (READ_ONCE_NOCHECK(regs->psw.mask) & PSW_MASK_PSTATE)
+			if (is_task_pt_regs(state, regs))
 				goto out_stop;
 			ip = READ_ONCE_NOCHECK(regs->psw.addr);
 			sp = READ_ONCE_NOCHECK(regs->gprs[15]);

commit 97806dfb6f3838ee4b7bc69e6f160d83eadbc74a
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Nov 22 15:58:42 2019 +0100

    s390/unwind: make reuse_sp default when unwinding pt_regs
    
    Currently unwinder yields 2 entries when pt_regs are met:
    sp="address of pt_regs itself" ip=pt_regs->psw
    sp=pt_regs->gprs[15] ip="r14 from stack frame pointed by pt_regs->gprs[15]"
    
    And neither of those 2 states (combination of sp and ip) ever happened.
    
    reuse_sp has been introduced by commit a1d863ac3e10 ("s390/unwind: fix
    mixing regs and sp"). reuse_sp=true makes unwinder keen to produce the
    following result, when pt_regs are given (as an arg to unwind_start):
    sp=pt_regs->gprs[15] ip=pt_regs->psw
    sp=pt_regs->gprs[15] ip="r14 from stack frame pointed by pt_regs->gprs[15]"
    
    The first state is an actual state in which a task was when pt_regs were
    collected. The second state is marked unreliable and is for debugging
    purposes to cover the case when a task has been interrupted in between
    stack frame allocation and writing back_chain - in this case r14 might
    show an actual caller.
    
    Make unwinder behaviour enabled via reuse_sp=true default and drop the
    special case handling.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index fd90b6e21663..ac6cfab567d1 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -46,16 +46,7 @@ bool unwind_next_frame(struct unwind_state *state)
 
 	regs = state->regs;
 	if (unlikely(regs)) {
-		if (state->reuse_sp) {
-			sp = state->sp;
-			state->reuse_sp = false;
-		} else {
-			sp = READ_ONCE_NOCHECK(regs->gprs[15]);
-			if (unlikely(outside_of_stack(state, sp))) {
-				if (!update_stack_info(state, sp))
-					goto out_err;
-			}
-		}
+		sp = state->sp;
 		sf = (struct stack_frame *) sp;
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
@@ -81,6 +72,11 @@ bool unwind_next_frame(struct unwind_state *state)
 			if (READ_ONCE_NOCHECK(regs->psw.mask) & PSW_MASK_PSTATE)
 				goto out_stop;
 			ip = READ_ONCE_NOCHECK(regs->psw.addr);
+			sp = READ_ONCE_NOCHECK(regs->gprs[15]);
+			if (unlikely(outside_of_stack(state, sp))) {
+				if (!update_stack_info(state, sp))
+					goto out_err;
+			}
 			reliable = true;
 		}
 	}
@@ -107,7 +103,7 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 {
 	struct stack_info *info = &state->stack_info;
 	unsigned long *mask = &state->stack_mask;
-	bool reliable, reuse_sp;
+	bool reliable;
 	struct stack_frame *sf;
 	unsigned long ip;
 
@@ -134,12 +130,10 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	if (regs) {
 		ip = READ_ONCE_NOCHECK(regs->psw.addr);
 		reliable = true;
-		reuse_sp = true;
 	} else {
 		sf = (struct stack_frame *) sp;
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
-		reuse_sp = false;
 	}
 
 	ip = ftrace_graph_ret_addr(state->task, &state->graph_idx, ip, NULL);
@@ -148,6 +142,5 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	state->sp = sp;
 	state->ip = ip;
 	state->reliable = reliable;
-	state->reuse_sp = reuse_sp;
 }
 EXPORT_SYMBOL_GPL(__unwind_start);

commit 67f5593419878798bb306632cdca0698a2dd3cbd
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Nov 22 15:53:30 2019 +0100

    s390/unwind: report an error if pt_regs are not on stack
    
    If unwinder is looking at pt_regs which is not on stack then something
    went wrong and an error has to be reported rather than successful
    unwinding termination.
    
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index fa111d3d378f..fd90b6e21663 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -76,7 +76,7 @@ bool unwind_next_frame(struct unwind_state *state)
 			/* No back-chain, look for a pt_regs structure */
 			sp = state->sp + STACK_FRAME_OVERHEAD;
 			if (!on_stack(info, sp, sizeof(struct pt_regs)))
-				goto out_stop;
+				goto out_err;
 			regs = (struct pt_regs *) sp;
 			if (READ_ONCE_NOCHECK(regs->psw.mask) & PSW_MASK_PSTATE)
 				goto out_stop;

commit ea1f56fa16ae5f6e67f6ea03836b36c6053d33d1
Merge: 4ba380f61624 6a82e23f45fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 17:23:53 2019 -0800

    Merge tag 's390-5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 updates from Vasily Gorbik:
    
     - Adjust PMU device drivers registration to avoid WARN_ON and few other
       perf improvements.
    
     - Enhance tracing in vfio-ccw.
    
     - Few stack unwinder fixes and improvements, convert get_wchan custom
       stack unwinding to generic api usage.
    
     - Fixes for mm helpers issues uncovered with tests validating
       architecture page table helpers.
    
     - Fix noexec bit handling when hardware doesn't support it.
    
     - Fix memleak and unsigned value compared with zero bugs in crypto
       code. Minor code simplification.
    
     - Fix crash during kdump with kasan enabled kernel.
    
     - Switch bug and alternatives from asm to asm_inline to improve
       inlining decisions.
    
     - Use 'depends on cc-option' for MARCH and TUNE options in Kconfig, add
       z13s and z14 ZR1 to TUNE descriptions.
    
     - Minor head64.S simplification.
    
     - Fix physical to logical CPU map for SMT.
    
     - Several cleanups in qdio code.
    
     - Other minor cleanups and fixes all over the code.
    
    * tag 's390-5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux: (41 commits)
      s390/cpumf: Adjust registration of s390 PMU device drivers
      s390/smp: fix physical to logical CPU map for SMT
      s390/early: move access registers setup in C code
      s390/head64: remove unnecessary vdso_per_cpu_data setup
      s390/early: move control registers setup in C code
      s390/kasan: support memcpy_real with TRACE_IRQFLAGS
      s390/crypto: Fix unsigned variable compared with zero
      s390/pkey: use memdup_user() to simplify code
      s390/pkey: fix memory leak within _copy_apqns_from_user()
      s390/disassembler: don't hide instruction addresses
      s390/cpum_sf: Assign error value to err variable
      s390/cpum_sf: Replace function name in debug statements
      s390/cpum_sf: Use consistant debug print format for sampling
      s390/unwind: drop unnecessary code around calling ftrace_graph_ret_addr()
      s390: add error handling to perf_callchain_kernel
      s390: always inline current_stack_pointer()
      s390/mm: add mm_pxd_folded() checks to pxd_free()
      s390/mm: properly clear _PAGE_NOEXEC bit when it is not supported
      s390/mm: simplify page table helpers for large entries
      s390/mm: make pmd/pud_bad() report large entries as bad
      ...

commit c2f2093e149d3109f1457deac4909191d9aca323
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Tue Oct 29 15:39:02 2019 +0100

    s390/unwind: drop unnecessary code around calling ftrace_graph_ret_addr()
    
    The current code around calling ftrace_graph_ret_addr() is ifdeffed and
    also tests if ftrace redirection is present on stack.
    ftrace_graph_ret_addr() however performs the test internally and there
    is a version for !CONFIG_FUNCTION_GRAPH_TRACER as well. The unnecessary
    code can thus be dropped.
    
    Link: http://lkml.kernel.org/r/20191029143904.24051-2-mbenes@suse.cz
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index 8fc9daae47a2..5699e820c621 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -80,12 +80,7 @@ bool unwind_next_frame(struct unwind_state *state)
 		}
 	}
 
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	/* Decode any ftrace redirection */
-	if (ip == (unsigned long) return_to_handler)
-		ip = ftrace_graph_ret_addr(state->task, &state->graph_idx,
-					   ip, (void *) sp);
-#endif
+	ip = ftrace_graph_ret_addr(state->task, &state->graph_idx, ip, (void *) sp);
 
 	/* Update unwind state */
 	state->sp = sp;
@@ -140,12 +135,7 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 		reliable = false;
 	}
 
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	/* Decode any ftrace redirection */
-	if (ip == (unsigned long) return_to_handler)
-		ip = ftrace_graph_ret_addr(state->task, &state->graph_idx,
-					   ip, NULL);
-#endif
+	ip = ftrace_graph_ret_addr(state->task, &state->graph_idx, ip, NULL);
 
 	/* Update unwind state */
 	state->sp = sp;

commit a1d863ac3e1085e1fea9caafd87252d08731de2e
Author: Ilya Leoshkevich <iii@linux.ibm.com>
Date:   Wed Oct 2 13:29:57 2019 +0200

    s390/unwind: fix mixing regs and sp
    
    unwind_for_each_frame stops after the first frame if regs->gprs[15] <=
    sp.
    
    The reason is that in case regs are specified, the first frame should be
    regs->psw.addr and the second frame should be sp->gprs[8]. However,
    currently the second frame is regs->gprs[15], which confuses
    outside_of_stack().
    
    Fix by introducing a flag to distinguish this special case from
    unwinding the interrupt handler, for which the current behavior is
    appropriate.
    
    Fixes: 78c98f907413 ("s390/unwind: introduce stack unwind API")
    Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
    Cc: stable@vger.kernel.org # v5.2+
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index 8fc9daae47a2..a8204f952315 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -46,10 +46,15 @@ bool unwind_next_frame(struct unwind_state *state)
 
 	regs = state->regs;
 	if (unlikely(regs)) {
-		sp = READ_ONCE_NOCHECK(regs->gprs[15]);
-		if (unlikely(outside_of_stack(state, sp))) {
-			if (!update_stack_info(state, sp))
-				goto out_err;
+		if (state->reuse_sp) {
+			sp = state->sp;
+			state->reuse_sp = false;
+		} else {
+			sp = READ_ONCE_NOCHECK(regs->gprs[15]);
+			if (unlikely(outside_of_stack(state, sp))) {
+				if (!update_stack_info(state, sp))
+					goto out_err;
+			}
 		}
 		sf = (struct stack_frame *) sp;
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
@@ -107,9 +112,9 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 {
 	struct stack_info *info = &state->stack_info;
 	unsigned long *mask = &state->stack_mask;
+	bool reliable, reuse_sp;
 	struct stack_frame *sf;
 	unsigned long ip;
-	bool reliable;
 
 	memset(state, 0, sizeof(*state));
 	state->task = task;
@@ -134,10 +139,12 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	if (regs) {
 		ip = READ_ONCE_NOCHECK(regs->psw.addr);
 		reliable = true;
+		reuse_sp = true;
 	} else {
 		sf = (struct stack_frame *) sp;
 		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
+		reuse_sp = false;
 	}
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
@@ -151,5 +158,6 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 	state->sp = sp;
 	state->ip = ip;
 	state->reliable = reliable;
+	state->reuse_sp = reuse_sp;
 }
 EXPORT_SYMBOL_GPL(__unwind_start);

commit 9a159190414d461fdac7ae5bb749c2d532b35419
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Mon Jul 8 14:24:38 2019 +0200

    s390/unwind: avoid int overflow in outside_of_stack
    
    When current task is interrupted in-between stack frame allocation
    and backchain write instructions new stack frame backchain pointer
    is left uninitialized. That invalid backchain value is passed into
    outside_of_stack for sanity check. Make sure int overflow does not happen
    by subtracting stack_frame size from the stack "end" rather than adding
    it to "random" backchain value.
    
    Fixes: 41b0474c1b1c ("s390/unwind: introduce stack unwind API")
    Reviewed-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index 3ce8a0808059..8fc9daae47a2 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -20,7 +20,7 @@ EXPORT_SYMBOL_GPL(unwind_get_return_address);
 static bool outside_of_stack(struct unwind_state *state, unsigned long sp)
 {
 	return (sp <= state->sp) ||
-		(sp + sizeof(struct stack_frame) > state->stack_info.end);
+		(sp > state->stack_info.end - sizeof(struct stack_frame));
 }
 
 static bool update_stack_info(struct unwind_state *state, unsigned long sp)

commit 20955746320e252b41c6b3505587766012e3e06d
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Thu Jun 20 10:18:31 2019 +0200

    s390/kasan: avoid false positives during stack unwind
    
    Avoid kasan false positive when current task is interrupted in-between
    stack frame allocation and backchain write instructions leaving new stack
    frame backchain invalid. In particular if backchain is 0 the unwinder
    tries to read pt_regs from the stack and might hit kasan poisoned bytes,
    leading to kasan "stack-out-of-bounds" report.
    
    Disable kasan instrumentation of unwinder stack reads, since this
    limitation couldn't be handled otherwise with current backchain unwinder
    implementation.
    
    Fixes: 78c98f907413 ("s390/unwind: introduce stack unwind API")
    Reported-by: Julian Wiedmann <jwi@linux.ibm.com>
    Tested-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index 57fd4e902f1f..3ce8a0808059 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -46,18 +46,18 @@ bool unwind_next_frame(struct unwind_state *state)
 
 	regs = state->regs;
 	if (unlikely(regs)) {
-		sp = READ_ONCE_TASK_STACK(state->task, regs->gprs[15]);
+		sp = READ_ONCE_NOCHECK(regs->gprs[15]);
 		if (unlikely(outside_of_stack(state, sp))) {
 			if (!update_stack_info(state, sp))
 				goto out_err;
 		}
 		sf = (struct stack_frame *) sp;
-		ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
 		regs = NULL;
 	} else {
 		sf = (struct stack_frame *) state->sp;
-		sp = READ_ONCE_TASK_STACK(state->task, sf->back_chain);
+		sp = READ_ONCE_NOCHECK(sf->back_chain);
 		if (likely(sp)) {
 			/* Non-zero back-chain points to the previous frame */
 			if (unlikely(outside_of_stack(state, sp))) {
@@ -65,7 +65,7 @@ bool unwind_next_frame(struct unwind_state *state)
 					goto out_err;
 			}
 			sf = (struct stack_frame *) sp;
-			ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+			ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 			reliable = true;
 		} else {
 			/* No back-chain, look for a pt_regs structure */
@@ -73,9 +73,9 @@ bool unwind_next_frame(struct unwind_state *state)
 			if (!on_stack(info, sp, sizeof(struct pt_regs)))
 				goto out_stop;
 			regs = (struct pt_regs *) sp;
-			if (user_mode(regs))
+			if (READ_ONCE_NOCHECK(regs->psw.mask) & PSW_MASK_PSTATE)
 				goto out_stop;
-			ip = READ_ONCE_TASK_STACK(state->task, regs->psw.addr);
+			ip = READ_ONCE_NOCHECK(regs->psw.addr);
 			reliable = true;
 		}
 	}
@@ -132,11 +132,11 @@ void __unwind_start(struct unwind_state *state, struct task_struct *task,
 
 	/* Get the instruction pointer from pt_regs or the stack frame */
 	if (regs) {
-		ip = READ_ONCE_TASK_STACK(state->task, regs->psw.addr);
+		ip = READ_ONCE_NOCHECK(regs->psw.addr);
 		reliable = true;
 	} else {
 		sf = (struct stack_frame *) sp;
-		ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+		ip = READ_ONCE_NOCHECK(sf->gprs[8]);
 		reliable = false;
 	}
 

commit ec7bf4789d95a0053bac0dfa36fbefd8cc584eea
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Feb 18 16:51:28 2019 +0100

    s390/ftrace: use HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
    
    Make the call chain more reliable by tagging the ftrace stack entries
    with the stack pointer that is associated with the return address.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
index cf5a630f3aa9..57fd4e902f1f 100644
--- a/arch/s390/kernel/unwind_bc.c
+++ b/arch/s390/kernel/unwind_bc.c
@@ -84,7 +84,7 @@ bool unwind_next_frame(struct unwind_state *state)
 	/* Decode any ftrace redirection */
 	if (ip == (unsigned long) return_to_handler)
 		ip = ftrace_graph_ret_addr(state->task, &state->graph_idx,
-					   ip, NULL);
+					   ip, (void *) sp);
 #endif
 
 	/* Update unwind state */

commit 78c98f9074135d3dab4e39544e0a537f92388fce
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Jan 28 08:33:08 2019 +0100

    s390/unwind: introduce stack unwind API
    
    Rework the dump_trace() stack unwinder interface to support different
    unwinding algorithms. The new interface looks like this:
    
            struct unwind_state state;
            unwind_for_each_frame(&state, task, regs, start_stack)
                    do_something(state.sp, state.ip, state.reliable);
    
    The unwind_bc.c file contains the implementation for the classic
    back-chain unwinder.
    
    One positive side effect of the new code is it now handles ftraced
    functions gracefully. It prints the real name of the return function
    instead of 'return_to_handler'.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/unwind_bc.c b/arch/s390/kernel/unwind_bc.c
new file mode 100644
index 000000000000..cf5a630f3aa9
--- /dev/null
+++ b/arch/s390/kernel/unwind_bc.c
@@ -0,0 +1,155 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/sched.h>
+#include <linux/sched/task.h>
+#include <linux/sched/task_stack.h>
+#include <linux/interrupt.h>
+#include <asm/sections.h>
+#include <asm/ptrace.h>
+#include <asm/bitops.h>
+#include <asm/stacktrace.h>
+#include <asm/unwind.h>
+
+unsigned long unwind_get_return_address(struct unwind_state *state)
+{
+	if (unwind_done(state))
+		return 0;
+	return __kernel_text_address(state->ip) ? state->ip : 0;
+}
+EXPORT_SYMBOL_GPL(unwind_get_return_address);
+
+static bool outside_of_stack(struct unwind_state *state, unsigned long sp)
+{
+	return (sp <= state->sp) ||
+		(sp + sizeof(struct stack_frame) > state->stack_info.end);
+}
+
+static bool update_stack_info(struct unwind_state *state, unsigned long sp)
+{
+	struct stack_info *info = &state->stack_info;
+	unsigned long *mask = &state->stack_mask;
+
+	/* New stack pointer leaves the current stack */
+	if (get_stack_info(sp, state->task, info, mask) != 0 ||
+	    !on_stack(info, sp, sizeof(struct stack_frame)))
+		/* 'sp' does not point to a valid stack */
+		return false;
+	return true;
+}
+
+bool unwind_next_frame(struct unwind_state *state)
+{
+	struct stack_info *info = &state->stack_info;
+	struct stack_frame *sf;
+	struct pt_regs *regs;
+	unsigned long sp, ip;
+	bool reliable;
+
+	regs = state->regs;
+	if (unlikely(regs)) {
+		sp = READ_ONCE_TASK_STACK(state->task, regs->gprs[15]);
+		if (unlikely(outside_of_stack(state, sp))) {
+			if (!update_stack_info(state, sp))
+				goto out_err;
+		}
+		sf = (struct stack_frame *) sp;
+		ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+		reliable = false;
+		regs = NULL;
+	} else {
+		sf = (struct stack_frame *) state->sp;
+		sp = READ_ONCE_TASK_STACK(state->task, sf->back_chain);
+		if (likely(sp)) {
+			/* Non-zero back-chain points to the previous frame */
+			if (unlikely(outside_of_stack(state, sp))) {
+				if (!update_stack_info(state, sp))
+					goto out_err;
+			}
+			sf = (struct stack_frame *) sp;
+			ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+			reliable = true;
+		} else {
+			/* No back-chain, look for a pt_regs structure */
+			sp = state->sp + STACK_FRAME_OVERHEAD;
+			if (!on_stack(info, sp, sizeof(struct pt_regs)))
+				goto out_stop;
+			regs = (struct pt_regs *) sp;
+			if (user_mode(regs))
+				goto out_stop;
+			ip = READ_ONCE_TASK_STACK(state->task, regs->psw.addr);
+			reliable = true;
+		}
+	}
+
+#ifdef CONFIG_FUNCTION_GRAPH_TRACER
+	/* Decode any ftrace redirection */
+	if (ip == (unsigned long) return_to_handler)
+		ip = ftrace_graph_ret_addr(state->task, &state->graph_idx,
+					   ip, NULL);
+#endif
+
+	/* Update unwind state */
+	state->sp = sp;
+	state->ip = ip;
+	state->regs = regs;
+	state->reliable = reliable;
+	return true;
+
+out_err:
+	state->error = true;
+out_stop:
+	state->stack_info.type = STACK_TYPE_UNKNOWN;
+	return false;
+}
+EXPORT_SYMBOL_GPL(unwind_next_frame);
+
+void __unwind_start(struct unwind_state *state, struct task_struct *task,
+		    struct pt_regs *regs, unsigned long sp)
+{
+	struct stack_info *info = &state->stack_info;
+	unsigned long *mask = &state->stack_mask;
+	struct stack_frame *sf;
+	unsigned long ip;
+	bool reliable;
+
+	memset(state, 0, sizeof(*state));
+	state->task = task;
+	state->regs = regs;
+
+	/* Don't even attempt to start from user mode regs: */
+	if (regs && user_mode(regs)) {
+		info->type = STACK_TYPE_UNKNOWN;
+		return;
+	}
+
+	/* Get current stack pointer and initialize stack info */
+	if (get_stack_info(sp, task, info, mask) != 0 ||
+	    !on_stack(info, sp, sizeof(struct stack_frame))) {
+		/* Something is wrong with the stack pointer */
+		info->type = STACK_TYPE_UNKNOWN;
+		state->error = true;
+		return;
+	}
+
+	/* Get the instruction pointer from pt_regs or the stack frame */
+	if (regs) {
+		ip = READ_ONCE_TASK_STACK(state->task, regs->psw.addr);
+		reliable = true;
+	} else {
+		sf = (struct stack_frame *) sp;
+		ip = READ_ONCE_TASK_STACK(state->task, sf->gprs[8]);
+		reliable = false;
+	}
+
+#ifdef CONFIG_FUNCTION_GRAPH_TRACER
+	/* Decode any ftrace redirection */
+	if (ip == (unsigned long) return_to_handler)
+		ip = ftrace_graph_ret_addr(state->task, &state->graph_idx,
+					   ip, NULL);
+#endif
+
+	/* Update unwind state */
+	state->sp = sp;
+	state->ip = ip;
+	state->reliable = reliable;
+}
+EXPORT_SYMBOL_GPL(__unwind_start);
