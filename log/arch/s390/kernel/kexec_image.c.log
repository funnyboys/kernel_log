commit 99d5cadfde2b1acb7650021df5abaa5ec447dd10
Author: Jiri Bohac <jbohac@suse.cz>
Date:   Mon Aug 19 17:17:44 2019 -0700

    kexec_file: split KEXEC_VERIFY_SIG into KEXEC_SIG and KEXEC_SIG_FORCE
    
    This is a preparatory patch for kexec_file_load() lockdown.  A locked down
    kernel needs to prevent unsigned kernel images from being loaded with
    kexec_file_load().  Currently, the only way to force the signature
    verification is compiling with KEXEC_VERIFY_SIG.  This prevents loading
    usigned images even when the kernel is not locked down at runtime.
    
    This patch splits KEXEC_VERIFY_SIG into KEXEC_SIG and KEXEC_SIG_FORCE.
    Analogous to the MODULE_SIG and MODULE_SIG_FORCE for modules, KEXEC_SIG
    turns on the signature verification but allows unsigned images to be
    loaded.  KEXEC_SIG_FORCE disallows images without a valid signature.
    
    Signed-off-by: Jiri Bohac <jbohac@suse.cz>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    cc: kexec@lists.infradead.org
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index 58318bf89fd9..af23eff5774d 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -59,7 +59,7 @@ static int s390_image_probe(const char *buf, unsigned long len)
 const struct kexec_file_ops s390_kexec_image_ops = {
 	.probe = s390_image_probe,
 	.load = s390_image_load,
-#ifdef CONFIG_KEXEC_VERIFY_SIG
+#ifdef CONFIG_KEXEC_SIG
 	.verify_sig = s390_verify_sig,
-#endif /* CONFIG_KEXEC_VERIFY_SIG */
+#endif /* CONFIG_KEXEC_SIG */
 };

commit 99feaa717e558cf4f2ad0faf53acac3cf9cc7438
Author: Philipp Rudo <prudo@linux.ibm.com>
Date:   Mon Mar 18 12:53:47 2019 +0100

    s390/kexec_file: Create ipl report and pass to next kernel
    
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index c378bbac5b35..58318bf89fd9 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -10,6 +10,7 @@
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/kexec.h>
+#include <asm/ipl.h>
 #include <asm/setup.h>
 
 static int kexec_file_add_kernel_image(struct kimage *image,
@@ -32,6 +33,10 @@ static int kexec_file_add_kernel_image(struct kimage *image,
 	data->parm = image->kernel_buf + PARMAREA;
 	data->memsz += buf.memsz;
 
+	ipl_report_add_component(data->report, &buf,
+				 IPL_RB_COMPONENT_FLAG_SIGNED |
+				 IPL_RB_COMPONENT_FLAG_VERIFIED,
+				 IPL_RB_CERT_UNKNOWN);
 	return kexec_add_buffer(&buf);
 }
 

commit e23a8020ce4e094e10d717d39a8ce799243bf8c1
Author: Philipp Rudo <prudo@linux.ibm.com>
Date:   Tue Feb 26 10:50:39 2019 +0100

    s390/kexec_file: Signature verification prototype
    
    Add kernel signature verification to kexec_file. The verification is based
    on module signature verification and works with kernel images signed via
    scripts/sign-file.
    
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index 7281540605b7..c378bbac5b35 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -54,4 +54,7 @@ static int s390_image_probe(const char *buf, unsigned long len)
 const struct kexec_file_ops s390_kexec_image_ops = {
 	.probe = s390_image_probe,
 	.load = s390_image_load,
+#ifdef CONFIG_KEXEC_VERIFY_SIG
+	.verify_sig = s390_verify_sig,
+#endif /* CONFIG_KEXEC_VERIFY_SIG */
 };

commit 653beba24d4cd281b078eab48c9bce956939061c
Author: Philipp Rudo <prudo@linux.ibm.com>
Date:   Thu Mar 7 15:56:34 2019 +0100

    s390/kexec_file: Load new kernel to absolute 0
    
    The leading 64 kB of a kernel image doesn't contain any data needed to boot
    the new kernel when it was loaded via kexec_file. Thus kexec_file currently
    strips them off before loading the image. Keep the leading 64 kB in order
    to be able to pass a ipl_report to the next kernel.
    
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index d7e65eeae22f..7281540605b7 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -19,17 +19,18 @@ static int kexec_file_add_kernel_image(struct kimage *image,
 
 	buf.image = image;
 
-	buf.buffer = image->kernel_buf + STARTUP_NORMAL_OFFSET;
-	buf.bufsz = image->kernel_buf_len - STARTUP_NORMAL_OFFSET;
+	buf.buffer = image->kernel_buf;
+	buf.bufsz = image->kernel_buf_len;
 
-	buf.mem = STARTUP_NORMAL_OFFSET;
+	buf.mem = 0;
 	if (image->type == KEXEC_TYPE_CRASH)
 		buf.mem += crashk_res.start;
 	buf.memsz = buf.bufsz;
 
 	data->kernel_buf = image->kernel_buf;
+	data->kernel_mem = buf.mem;
 	data->parm = image->kernel_buf + PARMAREA;
-	data->memsz += buf.memsz + STARTUP_NORMAL_OFFSET;
+	data->memsz += buf.memsz;
 
 	return kexec_add_buffer(&buf);
 }

commit 8e4964261374aaec9f4a83de076ceb11c8cdc044
Author: Philipp Rudo <prudo@linux.ibm.com>
Date:   Thu Mar 7 12:48:03 2019 +0100

    s390/kexec_file: Unify loader code
    
    s390_image_load and s390_elf_load have the same code to load the different
    components. Combine this functionality in one shared function.
    
    While at it move kexec_file_update_kernel into the new function as well.
    
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index d9025adc2bbb..d7e65eeae22f 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -12,30 +12,26 @@
 #include <linux/kexec.h>
 #include <asm/setup.h>
 
-static int kexec_file_add_image_kernel(struct kimage *image,
-				       struct s390_load_data *data,
-				       char *kernel, unsigned long kernel_len)
+static int kexec_file_add_kernel_image(struct kimage *image,
+				       struct s390_load_data *data)
 {
 	struct kexec_buf buf;
-	int ret;
 
 	buf.image = image;
 
-	buf.buffer = kernel + STARTUP_NORMAL_OFFSET;
-	buf.bufsz = kernel_len - STARTUP_NORMAL_OFFSET;
+	buf.buffer = image->kernel_buf + STARTUP_NORMAL_OFFSET;
+	buf.bufsz = image->kernel_buf_len - STARTUP_NORMAL_OFFSET;
 
 	buf.mem = STARTUP_NORMAL_OFFSET;
 	if (image->type == KEXEC_TYPE_CRASH)
 		buf.mem += crashk_res.start;
 	buf.memsz = buf.bufsz;
 
-	ret = kexec_add_buffer(&buf);
-
-	data->kernel_buf = kernel;
-	data->parm = (void *)kernel + PARMAREA;
+	data->kernel_buf = image->kernel_buf;
+	data->parm = image->kernel_buf + PARMAREA;
 	data->memsz += buf.memsz + STARTUP_NORMAL_OFFSET;
 
-	return ret;
+	return kexec_add_buffer(&buf);
 }
 
 static void *s390_image_load(struct kimage *image,
@@ -43,24 +39,7 @@ static void *s390_image_load(struct kimage *image,
 			     char *initrd, unsigned long initrd_len,
 			     char *cmdline, unsigned long cmdline_len)
 {
-	struct s390_load_data data = {0};
-	int ret;
-
-	ret = kexec_file_add_image_kernel(image, &data, kernel, kernel_len);
-	if (ret)
-		return ERR_PTR(ret);
-
-	if (initrd) {
-		ret = kexec_file_add_initrd(image, &data, initrd, initrd_len);
-		if (ret)
-			return ERR_PTR(ret);
-	}
-
-	ret = kexec_file_add_purgatory(image, &data);
-	if (ret)
-		return ERR_PTR(ret);
-
-	return kexec_file_update_kernel(image, &data);
+	return kexec_file_add_components(image, kexec_file_add_kernel_image);
 }
 
 static int s390_image_probe(const char *buf, unsigned long len)

commit d0d249d75dda1b101624316a52d117be07b8ccff
Author: Philipp Rudo <prudo@linux.ibm.com>
Date:   Wed Mar 6 17:36:26 2019 +0100

    s390/kexec_file: Simplify parmarea access
    
    Access the parmarea in head.S via a struct instead of individual offsets.
    
    While at it make the fields in the parmarea .quads.
    
    Signed-off-by: Philipp Rudo <prudo@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index 3800852595e8..d9025adc2bbb 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -32,6 +32,7 @@ static int kexec_file_add_image_kernel(struct kimage *image,
 	ret = kexec_add_buffer(&buf);
 
 	data->kernel_buf = kernel;
+	data->parm = (void *)kernel + PARMAREA;
 	data->memsz += buf.memsz + STARTUP_NORMAL_OFFSET;
 
 	return ret;

commit ee337f5469fd67f22d231e520ec4189ce0589d92
Author: Philipp Rudo <prudo@linux.vnet.ibm.com>
Date:   Tue Sep 5 11:55:23 2017 +0200

    s390/kexec_file: Add crash support to image loader
    
    Add support to load a crash kernel to the image loader. This requires
    extending the purgatory.
    
    Signed-off-by: Philipp Rudo <prudo@linux.vnet.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
index 7f5021e6c242..3800852595e8 100644
--- a/arch/s390/kernel/kexec_image.c
+++ b/arch/s390/kernel/kexec_image.c
@@ -25,6 +25,8 @@ static int kexec_file_add_image_kernel(struct kimage *image,
 	buf.bufsz = kernel_len - STARTUP_NORMAL_OFFSET;
 
 	buf.mem = STARTUP_NORMAL_OFFSET;
+	if (image->type == KEXEC_TYPE_CRASH)
+		buf.mem += crashk_res.start;
 	buf.memsz = buf.bufsz;
 
 	ret = kexec_add_buffer(&buf);
@@ -43,10 +45,6 @@ static void *s390_image_load(struct kimage *image,
 	struct s390_load_data data = {0};
 	int ret;
 
-	/* We don't support crash kernels yet. */
-	if (image->type == KEXEC_TYPE_CRASH)
-		return ERR_PTR(-ENOTSUPP);
-
 	ret = kexec_file_add_image_kernel(image, &data, kernel, kernel_len);
 	if (ret)
 		return ERR_PTR(ret);

commit e49bb0a27fa3c6ec45cc13e2102a6ec13c4ae697
Author: Philipp Rudo <prudo@linux.vnet.ibm.com>
Date:   Wed Aug 30 14:03:38 2017 +0200

    s390/kexec_file: Add image loader
    
    Add an image loader for kexec_file_load. For simplicity first skip crash
    support. The functions defined in machine_kexec_file will later be shared
    with the ELF loader.
    
    Signed-off-by: Philipp Rudo <prudo@linux.vnet.ibm.com>
    Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/kexec_image.c b/arch/s390/kernel/kexec_image.c
new file mode 100644
index 000000000000..7f5021e6c242
--- /dev/null
+++ b/arch/s390/kernel/kexec_image.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Image loader for kexec_file_load system call.
+ *
+ * Copyright IBM Corp. 2018
+ *
+ * Author(s): Philipp Rudo <prudo@linux.vnet.ibm.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/kexec.h>
+#include <asm/setup.h>
+
+static int kexec_file_add_image_kernel(struct kimage *image,
+				       struct s390_load_data *data,
+				       char *kernel, unsigned long kernel_len)
+{
+	struct kexec_buf buf;
+	int ret;
+
+	buf.image = image;
+
+	buf.buffer = kernel + STARTUP_NORMAL_OFFSET;
+	buf.bufsz = kernel_len - STARTUP_NORMAL_OFFSET;
+
+	buf.mem = STARTUP_NORMAL_OFFSET;
+	buf.memsz = buf.bufsz;
+
+	ret = kexec_add_buffer(&buf);
+
+	data->kernel_buf = kernel;
+	data->memsz += buf.memsz + STARTUP_NORMAL_OFFSET;
+
+	return ret;
+}
+
+static void *s390_image_load(struct kimage *image,
+			     char *kernel, unsigned long kernel_len,
+			     char *initrd, unsigned long initrd_len,
+			     char *cmdline, unsigned long cmdline_len)
+{
+	struct s390_load_data data = {0};
+	int ret;
+
+	/* We don't support crash kernels yet. */
+	if (image->type == KEXEC_TYPE_CRASH)
+		return ERR_PTR(-ENOTSUPP);
+
+	ret = kexec_file_add_image_kernel(image, &data, kernel, kernel_len);
+	if (ret)
+		return ERR_PTR(ret);
+
+	if (initrd) {
+		ret = kexec_file_add_initrd(image, &data, initrd, initrd_len);
+		if (ret)
+			return ERR_PTR(ret);
+	}
+
+	ret = kexec_file_add_purgatory(image, &data);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return kexec_file_update_kernel(image, &data);
+}
+
+static int s390_image_probe(const char *buf, unsigned long len)
+{
+	/* Can't reliably tell if an image is valid.  Therefore give the
+	 * user whatever he wants.
+	 */
+	return 0;
+}
+
+const struct kexec_file_ops s390_kexec_image_ops = {
+	.probe = s390_image_probe,
+	.load = s390_image_load,
+};
