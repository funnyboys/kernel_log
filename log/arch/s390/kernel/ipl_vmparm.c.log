commit 5f1207fbe74450eb887155ba432bfc079312b0fe
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Wed Feb 20 14:26:51 2019 +0100

    s390/ipl: provide uapi header for list directed IPL
    
    The IPL parameter block is used as an interface between Linux and
    the machine to query and change the boot device and boot options.
    To be able to create IPL parameter block in user space and pass it
    as segment to kexec provide an uapi header with proper structure
    definitions for the block.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/ipl_vmparm.c b/arch/s390/kernel/ipl_vmparm.c
index 41613c1617ff..af43535a976d 100644
--- a/arch/s390/kernel/ipl_vmparm.c
+++ b/arch/s390/kernel/ipl_vmparm.c
@@ -11,7 +11,7 @@ size_t ipl_block_get_ascii_vmparm(char *dest, size_t size,
 	char has_lowercase = 0;
 
 	len = 0;
-	if ((ipb->ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID) &&
+	if ((ipb->ccw.vm_flags & IPL_PB0_CCW_VM_FLAG_VP) &&
 	    (ipb->ccw.vm_parm_len > 0)) {
 
 		len = min_t(size_t, size - 1, ipb->ccw.vm_parm_len);

commit 86c74d869d321bee4753dc3f8c3d1c3809d8ed8a
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Wed Feb 20 14:08:26 2019 +0100

    s390/ipl: make ipl_info less confusing
    
    The ipl_info union in struct ipl_parameter_block has the same name as
    the struct ipl_info. This does not help while reading the code and the
    union in struct ipl_parameter_block does not need to be named. Drop
    the name from the union.
    
    Reviewed-by: Hendrik Brueckner <brueckner@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/ipl_vmparm.c b/arch/s390/kernel/ipl_vmparm.c
index 411838c0a0af..41613c1617ff 100644
--- a/arch/s390/kernel/ipl_vmparm.c
+++ b/arch/s390/kernel/ipl_vmparm.c
@@ -11,11 +11,11 @@ size_t ipl_block_get_ascii_vmparm(char *dest, size_t size,
 	char has_lowercase = 0;
 
 	len = 0;
-	if ((ipb->ipl_info.ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID) &&
-	    (ipb->ipl_info.ccw.vm_parm_len > 0)) {
+	if ((ipb->ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID) &&
+	    (ipb->ccw.vm_parm_len > 0)) {
 
-		len = min_t(size_t, size - 1, ipb->ipl_info.ccw.vm_parm_len);
-		memcpy(dest, ipb->ipl_info.ccw.vm_parm, len);
+		len = min_t(size_t, size - 1, ipb->ccw.vm_parm_len);
+		memcpy(dest, ipb->ccw.vm_parm, len);
 		/* If at least one character is lowercase, we assume mixed
 		 * case; otherwise we convert everything to lowercase.
 		 */

commit 49698745e53c417370ac5cfe8b849bb65d62f129
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Tue May 15 13:28:53 2018 +0200

    s390: move ipl block and cmd line handling to early boot phase
    
    To distinguish zfcpdump case and to be able to parse some of the kernel
    command line arguments early (e.g. mem=) ipl block retrieval and command
    line construction code is moved to the early boot phase.
    
    "memory_end" is set up correctly respecting "mem=" and hsa_size in case
    of the zfcpdump.
    
    arch/s390/boot/string.c is introduced to provide string handling and
    command line parsing functions to early boot phase code for the compressed
    kernel image case.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/ipl_vmparm.c b/arch/s390/kernel/ipl_vmparm.c
new file mode 100644
index 000000000000..411838c0a0af
--- /dev/null
+++ b/arch/s390/kernel/ipl_vmparm.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <asm/ebcdic.h>
+#include <asm/ipl.h>
+
+/* VM IPL PARM routines */
+size_t ipl_block_get_ascii_vmparm(char *dest, size_t size,
+				  const struct ipl_parameter_block *ipb)
+{
+	int i;
+	size_t len;
+	char has_lowercase = 0;
+
+	len = 0;
+	if ((ipb->ipl_info.ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID) &&
+	    (ipb->ipl_info.ccw.vm_parm_len > 0)) {
+
+		len = min_t(size_t, size - 1, ipb->ipl_info.ccw.vm_parm_len);
+		memcpy(dest, ipb->ipl_info.ccw.vm_parm, len);
+		/* If at least one character is lowercase, we assume mixed
+		 * case; otherwise we convert everything to lowercase.
+		 */
+		for (i = 0; i < len; i++)
+			if ((dest[i] > 0x80 && dest[i] < 0x8a) || /* a-i */
+			    (dest[i] > 0x90 && dest[i] < 0x9a) || /* j-r */
+			    (dest[i] > 0xa1 && dest[i] < 0xaa)) { /* s-z */
+				has_lowercase = 1;
+				break;
+			}
+		if (!has_lowercase)
+			EBC_TOLOWER(dest, len);
+		EBCASC(dest, len);
+	}
+	dest[len] = 0;
+
+	return len;
+}
