commit 92c9abf5e57500ea7dc59a55273aa7850b631bda
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Oct 30 16:43:11 2019 +0100

    livepatch: Allow to distinguish different version of system state changes
    
    The atomic replace runs pre/post (un)install callbacks only from the new
    livepatch. There are several reasons for this:
    
      + Simplicity: clear ordering of operations, no interactions between
            old and new callbacks.
    
      + Reliability: only new livepatch knows what changes can already be made
            by older livepatches and how to take over the state.
    
      + Testing: the atomic replace can be properly tested only when a newer
            livepatch is available. It might be too late to fix unwanted effect
            of callbacks from older livepatches.
    
    It might happen that an older change is not enough and the same system
    state has to be modified another way. Different changes need to get
    distinguished by a version number added to struct klp_state.
    
    The version can also be used to prevent loading incompatible livepatches.
    The check is done when the livepatch is enabled. The rules are:
    
      + Any completely new system state modification is allowed.
    
      + System state modifications with the same or higher version are allowed
        for already modified system states.
    
      + Cumulative livepatches must handle all system state modifications from
        already installed livepatches.
    
      + Non-cumulative livepatches are allowed to touch already modified
        system states.
    
    Link: http://lkml.kernel.org/r/20191030154313.13263-4-pmladek@suse.com
    To: Jiri Kosina <jikos@kernel.org>
    Cc: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Cc: Nicolai Stange <nstange@suse.de>
    Cc: live-patching@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/livepatch/state.c b/kernel/livepatch/state.c
index 6ab15b642c0a..7ee19476de9d 100644
--- a/kernel/livepatch/state.c
+++ b/kernel/livepatch/state.c
@@ -9,6 +9,7 @@
 
 #include <linux/livepatch.h>
 #include "core.h"
+#include "state.h"
 #include "transition.h"
 
 #define klp_for_each_state(patch, state)		\
@@ -81,3 +82,38 @@ struct klp_state *klp_get_prev_state(unsigned long id)
 	return last_state;
 }
 EXPORT_SYMBOL_GPL(klp_get_prev_state);
+
+/* Check if the patch is able to deal with the existing system state. */
+static bool klp_is_state_compatible(struct klp_patch *patch,
+				    struct klp_state *old_state)
+{
+	struct klp_state *state;
+
+	state = klp_get_state(patch, old_state->id);
+
+	/* A cumulative livepatch must handle all already modified states. */
+	if (!state)
+		return !patch->replace;
+
+	return state->version >= old_state->version;
+}
+
+/*
+ * Check that the new livepatch will not break the existing system states.
+ * Cumulative patches must handle all already modified states.
+ * Non-cumulative patches can touch already modified states.
+ */
+bool klp_is_patch_compatible(struct klp_patch *patch)
+{
+	struct klp_patch *old_patch;
+	struct klp_state *old_state;
+
+	klp_for_each_patch(old_patch) {
+		klp_for_each_state(old_patch, old_state) {
+			if (!klp_is_state_compatible(patch, old_state))
+				return false;
+		}
+	}
+
+	return true;
+}

commit 73727f4dafa2df107e85753c5ab703a1f344e1f1
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Oct 30 16:43:10 2019 +0100

    livepatch: Basic API to track system state changes
    
    This is another step how to help maintaining more livepatches.
    
    One big help was the atomic replace and cumulative livepatches. These
    livepatches replace the already installed ones. Therefore it should
    be enough when each cumulative livepatch is consistent.
    
    The problems might come with shadow variables and callbacks. They might
    change the system behavior or state so that it is no longer safe to
    go back and use an older livepatch or the original kernel code. Also,
    a new livepatch must be able to detect changes which were made by
    the already installed livepatches.
    
    This is where the livepatch system state tracking gets useful. It
    allows to:
    
      - find whether a system state has already been modified by
        previous livepatches
    
      - store data needed to manipulate and restore the system state
    
    The information about the manipulated system states is stored in an
    array of struct klp_state. It can be searched by two new functions
    klp_get_state() and klp_get_prev_state().
    
    The dependencies are going to be solved by a version field added later.
    The only important information is that it will be allowed to modify
    the same state by more non-cumulative livepatches. It is similar
    to allowing to modify the same function several times. The livepatch
    author is responsible for preventing incompatible changes.
    
    Link: http://lkml.kernel.org/r/20191030154313.13263-3-pmladek@suse.com
    To: Jiri Kosina <jikos@kernel.org>
    Cc: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Cc: Nicolai Stange <nstange@suse.de>
    Cc: live-patching@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/livepatch/state.c b/kernel/livepatch/state.c
new file mode 100644
index 000000000000..6ab15b642c0a
--- /dev/null
+++ b/kernel/livepatch/state.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * system_state.c - State of the system modified by livepatches
+ *
+ * Copyright (C) 2019 SUSE
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/livepatch.h>
+#include "core.h"
+#include "transition.h"
+
+#define klp_for_each_state(patch, state)		\
+	for (state = patch->states; state && state->id; state++)
+
+/**
+ * klp_get_state() - get information about system state modified by
+ *	the given patch
+ * @patch:	livepatch that modifies the given system state
+ * @id:		custom identifier of the modified system state
+ *
+ * Checks whether the given patch modifies the given system state.
+ *
+ * The function can be called either from pre/post (un)patch
+ * callbacks or from the kernel code added by the livepatch.
+ *
+ * Return: pointer to struct klp_state when found, otherwise NULL.
+ */
+struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)
+{
+	struct klp_state *state;
+
+	klp_for_each_state(patch, state) {
+		if (state->id == id)
+			return state;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(klp_get_state);
+
+/**
+ * klp_get_prev_state() - get information about system state modified by
+ *	the already installed livepatches
+ * @id:		custom identifier of the modified system state
+ *
+ * Checks whether already installed livepatches modify the given
+ * system state.
+ *
+ * The same system state can be modified by more non-cumulative
+ * livepatches. It is expected that the latest livepatch has
+ * the most up-to-date information.
+ *
+ * The function can be called only during transition when a new
+ * livepatch is being enabled or when such a transition is reverted.
+ * It is typically called only from from pre/post (un)patch
+ * callbacks.
+ *
+ * Return: pointer to the latest struct klp_state from already
+ *	installed livepatches, NULL when not found.
+ */
+struct klp_state *klp_get_prev_state(unsigned long id)
+{
+	struct klp_patch *patch;
+	struct klp_state *state, *last_state = NULL;
+
+	if (WARN_ON_ONCE(!klp_transition_patch))
+		return NULL;
+
+	klp_for_each_patch(patch) {
+		if (patch == klp_transition_patch)
+			goto out;
+
+		state = klp_get_state(patch, id);
+		if (state)
+			last_state = state;
+	}
+
+out:
+	return last_state;
+}
+EXPORT_SYMBOL_GPL(klp_get_prev_state);
