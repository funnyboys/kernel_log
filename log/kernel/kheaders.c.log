commit f7b101d33046a837c2aa4526cef28a3c785d7af2
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Wed May 15 17:35:51 2019 -0400

    kheaders: Move from proc to sysfs
    
    The kheaders archive consisting of the kernel headers used for compiling
    bpf programs is in /proc. However there is concern that moving it here
    will make it permanent. Let us move it to /sys/kernel as discussed [1].
    
    [1] https://lore.kernel.org/patchwork/patch/1067310/#1265969
    
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/kheaders.c b/kernel/kheaders.c
index 70ae6052920d..8f69772af77b 100644
--- a/kernel/kheaders.c
+++ b/kernel/kheaders.c
@@ -8,9 +8,8 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/proc_fs.h>
+#include <linux/kobject.h>
 #include <linux/init.h>
-#include <linux/uaccess.h>
 
 /*
  * Define kernel_headers_data and kernel_headers_data_end, within which the
@@ -31,39 +30,32 @@ extern char kernel_headers_data;
 extern char kernel_headers_data_end;
 
 static ssize_t
-ikheaders_read_current(struct file *file, char __user *buf,
-		      size_t len, loff_t *offset)
+ikheaders_read(struct file *file,  struct kobject *kobj,
+	       struct bin_attribute *bin_attr,
+	       char *buf, loff_t off, size_t len)
 {
-	return simple_read_from_buffer(buf, len, offset,
-				       &kernel_headers_data,
-				       &kernel_headers_data_end -
-				       &kernel_headers_data);
+	memcpy(buf, &kernel_headers_data + off, len);
+	return len;
 }
 
-static const struct file_operations ikheaders_file_ops = {
-	.read = ikheaders_read_current,
-	.llseek = default_llseek,
+static struct bin_attribute kheaders_attr __ro_after_init = {
+	.attr = {
+		.name = "kheaders.tar.xz",
+		.mode = 0444,
+	},
+	.read = &ikheaders_read,
 };
 
 static int __init ikheaders_init(void)
 {
-	struct proc_dir_entry *entry;
-
-	/* create the current headers file */
-	entry = proc_create("kheaders.tar.xz", S_IRUGO, NULL,
-			    &ikheaders_file_ops);
-	if (!entry)
-		return -ENOMEM;
-
-	proc_set_size(entry,
-		      &kernel_headers_data_end -
-		      &kernel_headers_data);
-	return 0;
+	kheaders_attr.size = (&kernel_headers_data_end -
+			      &kernel_headers_data);
+	return sysfs_create_bin_file(kernel_kobj, &kheaders_attr);
 }
 
 static void __exit ikheaders_cleanup(void)
 {
-	remove_proc_entry("kheaders.tar.xz", NULL);
+	sysfs_remove_bin_file(kernel_kobj, &kheaders_attr);
 }
 
 module_init(ikheaders_init);

commit 43d8ce9d65a54846d378545770991e65838981e0
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Fri Apr 26 15:04:29 2019 -0400

    Provide in-kernel headers to make extending kernel easier
    
    Introduce in-kernel headers which are made available as an archive
    through proc (/proc/kheaders.tar.xz file). This archive makes it
    possible to run eBPF and other tracing programs that need to extend the
    kernel for tracing purposes without any dependency on the file system
    having headers.
    
    A github PR is sent for the corresponding BCC patch at:
    https://github.com/iovisor/bcc/pull/2312
    
    On Android and embedded systems, it is common to switch kernels but not
    have kernel headers available on the file system. Further once a
    different kernel is booted, any headers stored on the file system will
    no longer be useful. This is an issue even well known to distros.
    By storing the headers as a compressed archive within the kernel, we can
    avoid these issues that have been a hindrance for a long time.
    
    The best way to use this feature is by building it in. Several users
    have a need for this, when they switch debug kernels, they do not want to
    update the filesystem or worry about it where to store the headers on
    it. However, the feature is also buildable as a module in case the user
    desires it not being part of the kernel image. This makes it possible to
    load and unload the headers from memory on demand. A tracing program can
    load the module, do its operations, and then unload the module to save
    kernel memory. The total memory needed is 3.3MB.
    
    By having the archive available at a fixed location independent of
    filesystem dependencies and conventions, all debugging tools can
    directly refer to the fixed location for the archive, without concerning
    with where the headers on a typical filesystem which significantly
    simplifies tooling that needs kernel headers.
    
    The code to read the headers is based on /proc/config.gz code and uses
    the same technique to embed the headers.
    
    Other approaches were discussed such as having an in-memory mountable
    filesystem, but that has drawbacks such as requiring an in-kernel xz
    decompressor which we don't have today, and requiring usage of 42 MB of
    kernel memory to host the decompressed headers at anytime. Also this
    approach is simpler than such approaches.
    
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/kheaders.c b/kernel/kheaders.c
new file mode 100644
index 000000000000..70ae6052920d
--- /dev/null
+++ b/kernel/kheaders.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Provide kernel headers useful to build tracing programs
+ * such as for running eBPF tracing tools.
+ *
+ * (Borrowed code from kernel/configs.c)
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/uaccess.h>
+
+/*
+ * Define kernel_headers_data and kernel_headers_data_end, within which the
+ * compressed kernel headers are stored. The file is first compressed with xz.
+ */
+
+asm (
+"	.pushsection .rodata, \"a\"		\n"
+"	.global kernel_headers_data		\n"
+"kernel_headers_data:				\n"
+"	.incbin \"kernel/kheaders_data.tar.xz\"	\n"
+"	.global kernel_headers_data_end		\n"
+"kernel_headers_data_end:			\n"
+"	.popsection				\n"
+);
+
+extern char kernel_headers_data;
+extern char kernel_headers_data_end;
+
+static ssize_t
+ikheaders_read_current(struct file *file, char __user *buf,
+		      size_t len, loff_t *offset)
+{
+	return simple_read_from_buffer(buf, len, offset,
+				       &kernel_headers_data,
+				       &kernel_headers_data_end -
+				       &kernel_headers_data);
+}
+
+static const struct file_operations ikheaders_file_ops = {
+	.read = ikheaders_read_current,
+	.llseek = default_llseek,
+};
+
+static int __init ikheaders_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	/* create the current headers file */
+	entry = proc_create("kheaders.tar.xz", S_IRUGO, NULL,
+			    &ikheaders_file_ops);
+	if (!entry)
+		return -ENOMEM;
+
+	proc_set_size(entry,
+		      &kernel_headers_data_end -
+		      &kernel_headers_data);
+	return 0;
+}
+
+static void __exit ikheaders_cleanup(void)
+{
+	remove_proc_entry("kheaders.tar.xz", NULL);
+}
+
+module_init(ikheaders_init);
+module_exit(ikheaders_cleanup);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Joel Fernandes");
+MODULE_DESCRIPTION("Echo the kernel header artifacts used to build the kernel");
