commit 942437c97fd9ff23a17c13118f50bd0490f6868c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jul 15 11:46:10 2019 +0200

    y2038: allow disabling time32 system calls
    
    At the moment, the compilation of the old time32 system calls depends
    purely on the architecture. As systems with new libc based on 64-bit
    time_t are getting deployed, even architectures that previously supported
    these (notably x86-32 and arm32 but also many others) no longer depend on
    them, and removing them from a kernel image results in a smaller kernel
    binary, the same way we can leave out many other optional system calls.
    
    More importantly, on an embedded system that needs to keep working
    beyond year 2038, any user space program calling these system calls
    is likely a bug, so removing them from the kernel image does provide
    an extra debugging help for finding broken applications.
    
    I've gone back and forth on hiding this option unless CONFIG_EXPERT
    is set. This version leaves it visible based on the logic that
    eventually it will be turned off indefinitely.
    
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 34b76895b81e..3b69a560a7ac 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -410,6 +410,29 @@ COND_SYSCALL(send);
 COND_SYSCALL(bdflush);
 COND_SYSCALL(uselib);
 
+/* optional: time32 */
+COND_SYSCALL(time32);
+COND_SYSCALL(stime32);
+COND_SYSCALL(utime32);
+COND_SYSCALL(adjtimex_time32);
+COND_SYSCALL(sched_rr_get_interval_time32);
+COND_SYSCALL(nanosleep_time32);
+COND_SYSCALL(rt_sigtimedwait_time32);
+COND_SYSCALL_COMPAT(rt_sigtimedwait_time32);
+COND_SYSCALL(timer_settime32);
+COND_SYSCALL(timer_gettime32);
+COND_SYSCALL(clock_settime32);
+COND_SYSCALL(clock_gettime32);
+COND_SYSCALL(clock_getres_time32);
+COND_SYSCALL(clock_nanosleep_time32);
+COND_SYSCALL(utimes_time32);
+COND_SYSCALL(futimesat_time32);
+COND_SYSCALL(pselect6_time32);
+COND_SYSCALL_COMPAT(pselect6_time32);
+COND_SYSCALL(ppoll_time32);
+COND_SYSCALL_COMPAT(ppoll_time32);
+COND_SYSCALL(utimensat_time32);
+COND_SYSCALL(clock_adjtime32);
 
 /*
  * The syscalls below are not found in include/uapi/asm-generic/unistd.h

commit d68dbb0c9ac8b1ff52eb09aa58ce6358400fa939
Author: Christian Brauner <christian@brauner.io>
Date:   Fri Jun 21 01:26:35 2019 +0200

    arch: handle arches who do not yet define clone3
    
    This cleanly handles arches who do not yet define clone3.
    
    clone3() was initially placed under __ARCH_WANT_SYS_CLONE under the
    assumption that this would cleanly handle all architectures. It does
    not.
    Architectures such as nios2 or h8300 simply take the asm-generic syscall
    definitions and generate their syscall table from it. Since they don't
    define __ARCH_WANT_SYS_CLONE the build would fail complaining about
    sys_clone3 missing. The reason this doesn't happen for legacy clone is
    that nios2 and h8300 provide assembly stubs for sys_clone. This seems to
    be done for architectural reasons.
    
    The build failures for nios2 and h8300 were caught int -next luckily.
    The solution is to define __ARCH_WANT_SYS_CLONE3 that architectures can
    add. Additionally, we need a cond_syscall(clone3) for architectures such
    as nios2 or h8300 that generate their syscall table in the way I
    explained above.
    
    Fixes: 8f3220a80654 ("arch: wire-up clone3() syscall")
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Adrian Reber <adrian@lisas.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Florian Weimer <fweimer@redhat.com>
    Cc: linux-api@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: x86@kernel.org

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 4d9ae5ea6caf..34b76895b81e 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -137,6 +137,8 @@ COND_SYSCALL(capset);
 /* kernel/exit.c */
 
 /* kernel/fork.c */
+/* __ARCH_WANT_SYS_CLONE3 */
+COND_SYSCALL(clone3);
 
 /* kernel/futex.c */
 COND_SYSCALL(futex);

commit 2151ad1b067275730de1b38c7257478cae47d29e
Author: Christian Brauner <christian@brauner.io>
Date:   Wed Apr 17 22:50:25 2019 +0200

    signal: support CLONE_PIDFD with pidfd_send_signal
    
    Let pidfd_send_signal() use pidfds retrieved via CLONE_PIDFD.  With this
    patch pidfd_send_signal() becomes independent of procfs.  This fullfils
    the request made when we merged the pidfd_send_signal() patchset.  The
    pidfd_send_signal() syscall is now always available allowing for it to
    be used by users without procfs mounted or even users without procfs
    support compiled into the kernel.
    
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Co-developed-by: Jann Horn <jannh@google.com>
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Michael Kerrisk (man-pages)" <mtk.manpages@gmail.com>
    Cc: Andy Lutomirsky <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Aleksa Sarai <cyphar@cyphar.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d21f4befaea4..4d9ae5ea6caf 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -167,9 +167,6 @@ COND_SYSCALL(syslog);
 
 /* kernel/sched/core.c */
 
-/* kernel/signal.c */
-COND_SYSCALL(pidfd_send_signal);
-
 /* kernel/sys.c */
 COND_SYSCALL(setregid);
 COND_SYSCALL(setgid);

commit a9dce6679d736cb3d612af39bab9f31f8db66f9b
Merge: f67e3fb48912 575a0ae9744d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 16 13:47:14 2019 -0700

    Merge tag 'pidfd-v5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/brauner/linux
    
    Pull pidfd system call from Christian Brauner:
     "This introduces the ability to use file descriptors from /proc/<pid>/
      as stable handles on struct pid. Even if a pid is recycled the handle
      will not change. For a start these fds can be used to send signals to
      the processes they refer to.
    
      With the ability to use /proc/<pid> fds as stable handles on struct
      pid we can fix a long-standing issue where after a process has exited
      its pid can be reused by another process. If a caller sends a signal
      to a reused pid it will end up signaling the wrong process.
    
      With this patchset we enable a variety of use cases. One obvious
      example is that we can now safely delegate an important part of
      process management - sending signals - to processes other than the
      parent of a given process by sending file descriptors around via scm
      rights and not fearing that the given process will have been recycled
      in the meantime. It also allows for easy testing whether a given
      process is still alive or not by sending signal 0 to a pidfd which is
      quite handy.
    
      There has been some interest in this feature e.g. from systems
      management (systemd, glibc) and container managers. I have requested
      and gotten comments from glibc to make sure that this syscall is
      suitable for their needs as well. In the future I expect it to take on
      most other pid-based signal syscalls. But such features are left for
      the future once they are needed.
    
      This has been sitting in linux-next for quite a while and has not
      caused any issues. It comes with selftests which verify basic
      functionality and also test that a recycled pid cannot be signaled via
      a pidfd.
    
      Jon has written about a prior version of this patchset. It should
      cover the basic functionality since not a lot has changed since then:
    
          https://lwn.net/Articles/773459/
    
      The commit message for the syscall itself is extensively documenting
      the syscall, including it's functionality and extensibility"
    
    * tag 'pidfd-v5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/brauner/linux:
      selftests: add tests for pidfd_send_signal()
      signal: add pidfd_send_signal() syscall

commit 38e7571c07be01f9f19b355a9306a4e3d5cb0f5b
Merge: 80201fe175cb 21b4aa5d20fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 14:48:40 2019 -0800

    Merge tag 'io_uring-2019-03-06' of git://git.kernel.dk/linux-block
    
    Pull io_uring IO interface from Jens Axboe:
     "Second attempt at adding the io_uring interface.
    
      Since the first one, we've added basic unit testing of the three
      system calls, that resides in liburing like the other unit tests that
      we have so far. It'll take a while to get full coverage of it, but
      we're working towards it. I've also added two basic test programs to
      tools/io_uring. One uses the raw interface and has support for all the
      various features that io_uring supports outside of standard IO, like
      fixed files, fixed IO buffers, and polled IO. The other uses the
      liburing API, and is a simplified version of cp(1).
    
      This adds support for a new IO interface, io_uring.
    
      io_uring allows an application to communicate with the kernel through
      two rings, the submission queue (SQ) and completion queue (CQ) ring.
      This allows for very efficient handling of IOs, see the v5 posting for
      some basic numbers:
    
        https://lore.kernel.org/linux-block/20190116175003.17880-1-axboe@kernel.dk/
    
      Outside of just efficiency, the interface is also flexible and
      extendable, and allows for future use cases like the upcoming NVMe
      key-value store API, networked IO, and so on. It also supports async
      buffered IO, something that we've always failed to support in the
      kernel.
    
      Outside of basic IO features, it supports async polled IO as well.
      This particular feature has already been tested at Facebook months ago
      for flash storage boxes, with 25-33% improvements. It makes polled IO
      actually useful for real world use cases, where even basic flash sees
      a nice win in terms of efficiency, latency, and performance. These
      boxes were IOPS bound before, now they are not.
    
      This series adds three new system calls. One for setting up an
      io_uring instance (io_uring_setup(2)), one for submitting/completing
      IO (io_uring_enter(2)), and one for aux functions like registrating
      file sets, buffers, etc (io_uring_register(2)). Through the help of
      Arnd, I've coordinated the syscall numbers so merge on that front
      should be painless.
    
      Jon did a writeup of the interface a while back, which (except for
      minor details that have been tweaked) is still accurate. Find that
      here:
    
        https://lwn.net/Articles/776703/
    
      Huge thanks to Al Viro for helping getting the reference cycle code
      correct, and to Jann Horn for his extensive reviews focused on both
      security and bugs in general.
    
      There's a userspace library that provides basic functionality for
      applications that don't need or want to care about how to fiddle with
      the rings directly. It has helpers to allow applications to easily set
      up an io_uring instance, and submit/complete IO through it without
      knowing about the intricacies of the rings. It also includes man pages
      (thanks to Jeff Moyer), and will continue to grow support helper
      functions and features as time progresses. Find it here:
    
        git://git.kernel.dk/liburing
    
      Fio has full support for the raw interface, both in the form of an IO
      engine (io_uring), but also with a small test application (t/io_uring)
      that can exercise and benchmark the interface"
    
    * tag 'io_uring-2019-03-06' of git://git.kernel.dk/linux-block:
      io_uring: add a few test tools
      io_uring: allow workqueue item to handle multiple buffered requests
      io_uring: add support for IORING_OP_POLL
      io_uring: add io_kiocb ref count
      io_uring: add submission polling
      io_uring: add file set registration
      net: split out functions related to registering inflight socket files
      io_uring: add support for pre-mapped user IO buffers
      block: implement bio helper to add iter bvec pages to bio
      io_uring: batch io_kiocb allocation
      io_uring: use fget/fput_many() for file references
      fs: add fget_many() and fput_many()
      io_uring: support for IO polling
      io_uring: add fsync support
      Add io_uring IO interface

commit 7e89a37c477c4caacde7b511c64720e20104945f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 28 15:22:53 2019 +0100

    ipc: Fix building compat mode without sysvipc
    
    As John Stultz noticed, my y2038 syscall series caused a link
    failure when CONFIG_SYSVIPC is disabled but CONFIG_COMPAT is
    enabled:
    
    arch/arm64/kernel/sys32.o:(.rodata+0x960): undefined reference to `__arm64_compat_sys_old_semctl'
    arch/arm64/kernel/sys32.o:(.rodata+0x980): undefined reference to `__arm64_compat_sys_old_msgctl'
    arch/arm64/kernel/sys32.o:(.rodata+0x9a0): undefined reference to `__arm64_compat_sys_old_shmctl'
    
    Add the missing entries in kernel/sys_ni.c for the new system
    calls.
    
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 85e5ccec0955..62a6c8707799 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -202,6 +202,7 @@ COND_SYSCALL(msgget);
 COND_SYSCALL(old_msgctl);
 COND_SYSCALL(msgctl);
 COND_SYSCALL_COMPAT(msgctl);
+COND_SYSCALL_COMPAT(old_msgctl);
 COND_SYSCALL(msgrcv);
 COND_SYSCALL_COMPAT(msgrcv);
 COND_SYSCALL(msgsnd);
@@ -212,6 +213,7 @@ COND_SYSCALL(semget);
 COND_SYSCALL(old_semctl);
 COND_SYSCALL(semctl);
 COND_SYSCALL_COMPAT(semctl);
+COND_SYSCALL_COMPAT(old_semctl);
 COND_SYSCALL(semtimedop);
 COND_SYSCALL(semtimedop_time32);
 COND_SYSCALL(semop);
@@ -221,6 +223,7 @@ COND_SYSCALL(shmget);
 COND_SYSCALL(old_shmctl);
 COND_SYSCALL(shmctl);
 COND_SYSCALL_COMPAT(shmctl);
+COND_SYSCALL_COMPAT(old_shmctl);
 COND_SYSCALL(shmat);
 COND_SYSCALL_COMPAT(shmat);
 COND_SYSCALL(shmdt);

commit 3eb39f47934f9d5a3027fe00d906a45fe3a15fad
Author: Christian Brauner <christian@brauner.io>
Date:   Mon Nov 19 00:51:56 2018 +0100

    signal: add pidfd_send_signal() syscall
    
    The kill() syscall operates on process identifiers (pid). After a process
    has exited its pid can be reused by another process. If a caller sends a
    signal to a reused pid it will end up signaling the wrong process. This
    issue has often surfaced and there has been a push to address this problem [1].
    
    This patch uses file descriptors (fd) from proc/<pid> as stable handles on
    struct pid. Even if a pid is recycled the handle will not change. The fd
    can be used to send signals to the process it refers to.
    Thus, the new syscall pidfd_send_signal() is introduced to solve this
    problem. Instead of pids it operates on process fds (pidfd).
    
    /* prototype and argument /*
    long pidfd_send_signal(int pidfd, int sig, siginfo_t *info, unsigned int flags);
    
    /* syscall number 424 */
    The syscall number was chosen to be 424 to align with Arnd's rework in his
    y2038 to minimize merge conflicts (cf. [25]).
    
    In addition to the pidfd and signal argument it takes an additional
    siginfo_t and flags argument. If the siginfo_t argument is NULL then
    pidfd_send_signal() is equivalent to kill(<positive-pid>, <signal>). If it
    is not NULL pidfd_send_signal() is equivalent to rt_sigqueueinfo().
    The flags argument is added to allow for future extensions of this syscall.
    It currently needs to be passed as 0. Failing to do so will cause EINVAL.
    
    /* pidfd_send_signal() replaces multiple pid-based syscalls */
    The pidfd_send_signal() syscall currently takes on the job of
    rt_sigqueueinfo(2) and parts of the functionality of kill(2), Namely, when a
    positive pid is passed to kill(2). It will however be possible to also
    replace tgkill(2) and rt_tgsigqueueinfo(2) if this syscall is extended.
    
    /* sending signals to threads (tid) and process groups (pgid) */
    Specifically, the pidfd_send_signal() syscall does currently not operate on
    process groups or threads. This is left for future extensions.
    In order to extend the syscall to allow sending signal to threads and
    process groups appropriately named flags (e.g. PIDFD_TYPE_PGID, and
    PIDFD_TYPE_TID) should be added. This implies that the flags argument will
    determine what is signaled and not the file descriptor itself. Put in other
    words, grouping in this api is a property of the flags argument not a
    property of the file descriptor (cf. [13]). Clarification for this has been
    requested by Eric (cf. [19]).
    When appropriate extensions through the flags argument are added then
    pidfd_send_signal() can additionally replace the part of kill(2) which
    operates on process groups as well as the tgkill(2) and
    rt_tgsigqueueinfo(2) syscalls.
    How such an extension could be implemented has been very roughly sketched
    in [14], [15], and [16]. However, this should not be taken as a commitment
    to a particular implementation. There might be better ways to do it.
    Right now this is intentionally left out to keep this patchset as simple as
    possible (cf. [4]).
    
    /* naming */
    The syscall had various names throughout iterations of this patchset:
    - procfd_signal()
    - procfd_send_signal()
    - taskfd_send_signal()
    In the last round of reviews it was pointed out that given that if the
    flags argument decides the scope of the signal instead of different types
    of fds it might make sense to either settle for "procfd_" or "pidfd_" as
    prefix. The community was willing to accept either (cf. [17] and [18]).
    Given that one developer expressed strong preference for the "pidfd_"
    prefix (cf. [13]) and with other developers less opinionated about the name
    we should settle for "pidfd_" to avoid further bikeshedding.
    
    The  "_send_signal" suffix was chosen to reflect the fact that the syscall
    takes on the job of multiple syscalls. It is therefore intentional that the
    name is not reminiscent of neither kill(2) nor rt_sigqueueinfo(2). Not the
    fomer because it might imply that pidfd_send_signal() is a replacement for
    kill(2), and not the latter because it is a hassle to remember the correct
    spelling - especially for non-native speakers - and because it is not
    descriptive enough of what the syscall actually does. The name
    "pidfd_send_signal" makes it very clear that its job is to send signals.
    
    /* zombies */
    Zombies can be signaled just as any other process. No special error will be
    reported since a zombie state is an unreliable state (cf. [3]). However,
    this can be added as an extension through the @flags argument if the need
    ever arises.
    
    /* cross-namespace signals */
    The patch currently enforces that the signaler and signalee either are in
    the same pid namespace or that the signaler's pid namespace is an ancestor
    of the signalee's pid namespace. This is done for the sake of simplicity
    and because it is unclear to what values certain members of struct
    siginfo_t would need to be set to (cf. [5], [6]).
    
    /* compat syscalls */
    It became clear that we would like to avoid adding compat syscalls
    (cf. [7]).  The compat syscall handling is now done in kernel/signal.c
    itself by adding __copy_siginfo_from_user_generic() which lets us avoid
    compat syscalls (cf. [8]). It should be noted that the addition of
    __copy_siginfo_from_user_any() is caused by a bug in the original
    implementation of rt_sigqueueinfo(2) (cf. 12).
    With upcoming rework for syscall handling things might improve
    significantly (cf. [11]) and __copy_siginfo_from_user_any() will not gain
    any additional callers.
    
    /* testing */
    This patch was tested on x64 and x86.
    
    /* userspace usage */
    An asciinema recording for the basic functionality can be found under [9].
    With this patch a process can be killed via:
    
     #define _GNU_SOURCE
     #include <errno.h>
     #include <fcntl.h>
     #include <signal.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>
     #include <sys/stat.h>
     #include <sys/syscall.h>
     #include <sys/types.h>
     #include <unistd.h>
    
     static inline int do_pidfd_send_signal(int pidfd, int sig, siginfo_t *info,
                                             unsigned int flags)
     {
     #ifdef __NR_pidfd_send_signal
             return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);
     #else
             return -ENOSYS;
     #endif
     }
    
     int main(int argc, char *argv[])
     {
             int fd, ret, saved_errno, sig;
    
             if (argc < 3)
                     exit(EXIT_FAILURE);
    
             fd = open(argv[1], O_DIRECTORY | O_CLOEXEC);
             if (fd < 0) {
                     printf("%s - Failed to open \"%s\"\n", strerror(errno), argv[1]);
                     exit(EXIT_FAILURE);
             }
    
             sig = atoi(argv[2]);
    
             printf("Sending signal %d to process %s\n", sig, argv[1]);
             ret = do_pidfd_send_signal(fd, sig, NULL, 0);
    
             saved_errno = errno;
             close(fd);
             errno = saved_errno;
    
             if (ret < 0) {
                     printf("%s - Failed to send signal %d to process %s\n",
                            strerror(errno), sig, argv[1]);
                     exit(EXIT_FAILURE);
             }
    
             exit(EXIT_SUCCESS);
     }
    
    /* Q&A
     * Given that it seems the same questions get asked again by people who are
     * late to the party it makes sense to add a Q&A section to the commit
     * message so it's hopefully easier to avoid duplicate threads.
     *
     * For the sake of progress please consider these arguments settled unless
     * there is a new point that desperately needs to be addressed. Please make
     * sure to check the links to the threads in this commit message whether
     * this has not already been covered.
     */
    Q-01: (Florian Weimer [20], Andrew Morton [21])
          What happens when the target process has exited?
    A-01: Sending the signal will fail with ESRCH (cf. [22]).
    
    Q-02:  (Andrew Morton [21])
           Is the task_struct pinned by the fd?
    A-02:  No. A reference to struct pid is kept. struct pid - as far as I
           understand - was created exactly for the reason to not require to
           pin struct task_struct (cf. [22]).
    
    Q-03: (Andrew Morton [21])
          Does the entire procfs directory remain visible? Just one entry
          within it?
    A-03: The same thing that happens right now when you hold a file descriptor
          to /proc/<pid> open (cf. [22]).
    
    Q-04: (Andrew Morton [21])
          Does the pid remain reserved?
    A-04: No. This patchset guarantees a stable handle not that pids are not
          recycled (cf. [22]).
    
    Q-05: (Andrew Morton [21])
          Do attempts to signal that fd return errors?
    A-05: See {Q,A}-01.
    
    Q-06: (Andrew Morton [22])
          Is there a cleaner way of obtaining the fd? Another syscall perhaps.
    A-06: Userspace can already trivially retrieve file descriptors from procfs
          so this is something that we will need to support anyway. Hence,
          there's no immediate need to add another syscalls just to make
          pidfd_send_signal() not dependent on the presence of procfs. However,
          adding a syscalls to get such file descriptors is planned for a
          future patchset (cf. [22]).
    
    Q-07: (Andrew Morton [21] and others)
          This fd-for-a-process sounds like a handy thing and people may well
          think up other uses for it in the future, probably unrelated to
          signals. Are the code and the interface designed to permit such
          future applications?
    A-07: Yes (cf. [22]).
    
    Q-08: (Andrew Morton [21] and others)
          Now I think about it, why a new syscall? This thing is looking
          rather like an ioctl?
    A-08: This has been extensively discussed. It was agreed that a syscall is
          preferred for a variety or reasons. Here are just a few taken from
          prior threads. Syscalls are safer than ioctl()s especially when
          signaling to fds. Processes are a core kernel concept so a syscall
          seems more appropriate. The layout of the syscall with its four
          arguments would require the addition of a custom struct for the
          ioctl() thereby causing at least the same amount or even more
          complexity for userspace than a simple syscall. The new syscall will
          replace multiple other pid-based syscalls (see description above).
          The file-descriptors-for-processes concept introduced with this
          syscall will be extended with other syscalls in the future. See also
          [22], [23] and various other threads already linked in here.
    
    Q-09: (Florian Weimer [24])
          What happens if you use the new interface with an O_PATH descriptor?
    A-09:
          pidfds opened as O_PATH fds cannot be used to send signals to a
          process (cf. [2]). Signaling processes through pidfds is the
          equivalent of writing to a file. Thus, this is not an operation that
          operates "purely at the file descriptor level" as required by the
          open(2) manpage. See also [4].
    
    /* References */
    [1]:  https://lore.kernel.org/lkml/20181029221037.87724-1-dancol@google.com/
    [2]:  https://lore.kernel.org/lkml/874lbtjvtd.fsf@oldenburg2.str.redhat.com/
    [3]:  https://lore.kernel.org/lkml/20181204132604.aspfupwjgjx6fhva@brauner.io/
    [4]:  https://lore.kernel.org/lkml/20181203180224.fkvw4kajtbvru2ku@brauner.io/
    [5]:  https://lore.kernel.org/lkml/20181121213946.GA10795@mail.hallyn.com/
    [6]:  https://lore.kernel.org/lkml/20181120103111.etlqp7zop34v6nv4@brauner.io/
    [7]:  https://lore.kernel.org/lkml/36323361-90BD-41AF-AB5B-EE0D7BA02C21@amacapital.net/
    [8]:  https://lore.kernel.org/lkml/87tvjxp8pc.fsf@xmission.com/
    [9]:  https://asciinema.org/a/IQjuCHew6bnq1cr78yuMv16cy
    [11]: https://lore.kernel.org/lkml/F53D6D38-3521-4C20-9034-5AF447DF62FF@amacapital.net/
    [12]: https://lore.kernel.org/lkml/87zhtjn8ck.fsf@xmission.com/
    [13]: https://lore.kernel.org/lkml/871s6u9z6u.fsf@xmission.com/
    [14]: https://lore.kernel.org/lkml/20181206231742.xxi4ghn24z4h2qki@brauner.io/
    [15]: https://lore.kernel.org/lkml/20181207003124.GA11160@mail.hallyn.com/
    [16]: https://lore.kernel.org/lkml/20181207015423.4miorx43l3qhppfz@brauner.io/
    [17]: https://lore.kernel.org/lkml/CAGXu5jL8PciZAXvOvCeCU3wKUEB_dU-O3q0tDw4uB_ojMvDEew@mail.gmail.com/
    [18]: https://lore.kernel.org/lkml/20181206222746.GB9224@mail.hallyn.com/
    [19]: https://lore.kernel.org/lkml/20181208054059.19813-1-christian@brauner.io/
    [20]: https://lore.kernel.org/lkml/8736rebl9s.fsf@oldenburg.str.redhat.com/
    [21]: https://lore.kernel.org/lkml/20181228152012.dbf0508c2508138efc5f2bbe@linux-foundation.org/
    [22]: https://lore.kernel.org/lkml/20181228233725.722tdfgijxcssg76@brauner.io/
    [23]: https://lwn.net/Articles/773459/
    [24]: https://lore.kernel.org/lkml/8736rebl9s.fsf@oldenburg.str.redhat.com/
    [25]: https://lore.kernel.org/lkml/CAK8P3a0ej9NcJM8wXNPbcGUyOUZYX+VLoDFdbenW3s3114oQZw@mail.gmail.com/
    
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Jann Horn <jannh@google.com>
    Cc: Andy Lutomirsky <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Florian Weimer <fweimer@redhat.com>
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Reviewed-by: Tycho Andersen <tycho@tycho.ws>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Acked-by: Aleksa Sarai <cyphar@cyphar.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ab9d0e3c6d50..f905f4f9f677 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -163,6 +163,7 @@ COND_SYSCALL(syslog);
 /* kernel/sched/core.c */
 
 /* kernel/signal.c */
+COND_SYSCALL(pidfd_send_signal);
 
 /* kernel/sys.c */
 COND_SYSCALL(setregid);

commit edafccee56ff31678a091ddb7219aba9b28bc3cb
Author: Jens Axboe <axboe@kernel.dk>
Date:   Wed Jan 9 09:16:05 2019 -0700

    io_uring: add support for pre-mapped user IO buffers
    
    If we have fixed user buffers, we can map them into the kernel when we
    setup the io_uring. That avoids the need to do get_user_pages() for
    each and every IO.
    
    To utilize this feature, the application must call io_uring_register()
    after having setup an io_uring instance, passing in
    IORING_REGISTER_BUFFERS as the opcode. The argument must be a pointer to
    an iovec array, and the nr_args should contain how many iovecs the
    application wishes to map.
    
    If successful, these buffers are now mapped into the kernel, eligible
    for IO. To use these fixed buffers, the application must use the
    IORING_OP_READ_FIXED and IORING_OP_WRITE_FIXED opcodes, and then
    set sqe->index to the desired buffer index. sqe->addr..sqe->addr+seq->len
    must point to somewhere inside the indexed buffer.
    
    The application may register buffers throughout the lifetime of the
    io_uring instance. It can call io_uring_register() with
    IORING_UNREGISTER_BUFFERS as the opcode to unregister the current set of
    buffers, and then register a new set. The application need not
    unregister buffers explicitly before shutting down the io_uring
    instance.
    
    It's perfectly valid to setup a larger buffer, and then sometimes only
    use parts of it for an IO. As long as the range is within the originally
    mapped region, it will work just fine.
    
    For now, buffers must not be file backed. If file backed buffers are
    passed in, the registration will fail with -1/EOPNOTSUPP. This
    restriction may be relaxed in the future.
    
    RLIMIT_MEMLOCK is used to check how much memory we can pin. A somewhat
    arbitrary 1G per buffer size is also imposed.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ee5e523564bb..1bb6604dc19f 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -48,6 +48,7 @@ COND_SYSCALL_COMPAT(io_getevents);
 COND_SYSCALL_COMPAT(io_pgetevents);
 COND_SYSCALL(io_uring_setup);
 COND_SYSCALL(io_uring_enter);
+COND_SYSCALL(io_uring_register);
 
 /* fs/xattr.c */
 

commit 2b188cc1bb857a9d4701ae59aa7768b5124e262e
Author: Jens Axboe <axboe@kernel.dk>
Date:   Mon Jan 7 10:46:33 2019 -0700

    Add io_uring IO interface
    
    The submission queue (SQ) and completion queue (CQ) rings are shared
    between the application and the kernel. This eliminates the need to
    copy data back and forth to submit and complete IO.
    
    IO submissions use the io_uring_sqe data structure, and completions
    are generated in the form of io_uring_cqe data structures. The SQ
    ring is an index into the io_uring_sqe array, which makes it possible
    to submit a batch of IOs without them being contiguous in the ring.
    The CQ ring is always contiguous, as completion events are inherently
    unordered, and hence any io_uring_cqe entry can point back to an
    arbitrary submission.
    
    Two new system calls are added for this:
    
    io_uring_setup(entries, params)
            Sets up an io_uring instance for doing async IO. On success,
            returns a file descriptor that the application can mmap to
            gain access to the SQ ring, CQ ring, and io_uring_sqes.
    
    io_uring_enter(fd, to_submit, min_complete, flags, sigset, sigsetsize)
            Initiates IO against the rings mapped to this fd, or waits for
            them to complete, or both. The behavior is controlled by the
            parameters passed in. If 'to_submit' is non-zero, then we'll
            try and submit new IO. If IORING_ENTER_GETEVENTS is set, the
            kernel will wait for 'min_complete' events, if they aren't
            already available. It's valid to set IORING_ENTER_GETEVENTS
            and 'min_complete' == 0 at the same time, this allows the
            kernel to return already completed events without waiting
            for them. This is useful only for polling, as for IRQ
            driven IO, the application can just check the CQ ring
            without entering the kernel.
    
    With this setup, it's possible to do async IO with a single system
    call. Future developments will enable polled IO with this interface,
    and polled submission as well. The latter will enable an application
    to do IO without doing ANY system calls at all.
    
    For IRQ driven IO, an application only needs to enter the kernel for
    completions if it wants to wait for them to occur.
    
    Each io_uring is backed by a workqueue, to support buffered async IO
    as well. We will only punt to an async context if the command would
    need to wait for IO on the device side. Any data that can be accessed
    directly in the page cache is done inline. This avoids the slowness
    issue of usual threadpools, since cached data is accessed as quickly
    as a sync interface.
    
    Sample application: http://git.kernel.dk/cgit/fio/plain/t/io_uring.c
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ab9d0e3c6d50..ee5e523564bb 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -46,6 +46,8 @@ COND_SYSCALL(io_getevents);
 COND_SYSCALL(io_pgetevents);
 COND_SYSCALL_COMPAT(io_getevents);
 COND_SYSCALL_COMPAT(io_pgetevents);
+COND_SYSCALL(io_uring_setup);
+COND_SYSCALL(io_uring_enter);
 
 /* fs/xattr.c */
 

commit 8dabe7245bbc134f2cfcc12cde75c019dab924cc
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 7 00:33:08 2019 +0100

    y2038: syscalls: rename y2038 compat syscalls
    
    A lot of system calls that pass a time_t somewhere have an implementation
    using a COMPAT_SYSCALL_DEFINEx() on 64-bit architectures, and have
    been reworked so that this implementation can now be used on 32-bit
    architectures as well.
    
    The missing step is to redefine them using the regular SYSCALL_DEFINEx()
    to get them out of the compat namespace and make it possible to build them
    on 32-bit architectures.
    
    Any system call that ends in 'time' gets a '32' suffix on its name for
    that version, while the others get a '_time32' suffix, to distinguish
    them from the normal version, which takes a 64-bit time argument in the
    future.
    
    In this step, only 64-bit architectures are changed, doing this rename
    first lets us avoid touching the 32-bit architectures twice.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ce04431a40d1..85e5ccec0955 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -42,9 +42,11 @@ COND_SYSCALL(io_destroy);
 COND_SYSCALL(io_submit);
 COND_SYSCALL_COMPAT(io_submit);
 COND_SYSCALL(io_cancel);
+COND_SYSCALL(io_getevents_time32);
 COND_SYSCALL(io_getevents);
+COND_SYSCALL(io_pgetevents_time32);
 COND_SYSCALL(io_pgetevents);
-COND_SYSCALL_COMPAT(io_getevents);
+COND_SYSCALL_COMPAT(io_pgetevents_time32);
 COND_SYSCALL_COMPAT(io_pgetevents);
 
 /* fs/xattr.c */
@@ -114,9 +116,9 @@ COND_SYSCALL_COMPAT(signalfd4);
 /* fs/timerfd.c */
 COND_SYSCALL(timerfd_create);
 COND_SYSCALL(timerfd_settime);
-COND_SYSCALL_COMPAT(timerfd_settime);
+COND_SYSCALL(timerfd_settime32);
 COND_SYSCALL(timerfd_gettime);
-COND_SYSCALL_COMPAT(timerfd_gettime);
+COND_SYSCALL(timerfd_gettime32);
 
 /* fs/utimes.c */
 
@@ -135,7 +137,7 @@ COND_SYSCALL(capset);
 
 /* kernel/futex.c */
 COND_SYSCALL(futex);
-COND_SYSCALL_COMPAT(futex);
+COND_SYSCALL(futex_time32);
 COND_SYSCALL(set_robust_list);
 COND_SYSCALL_COMPAT(set_robust_list);
 COND_SYSCALL(get_robust_list);
@@ -187,9 +189,9 @@ COND_SYSCALL(mq_open);
 COND_SYSCALL_COMPAT(mq_open);
 COND_SYSCALL(mq_unlink);
 COND_SYSCALL(mq_timedsend);
-COND_SYSCALL_COMPAT(mq_timedsend);
+COND_SYSCALL(mq_timedsend_time32);
 COND_SYSCALL(mq_timedreceive);
-COND_SYSCALL_COMPAT(mq_timedreceive);
+COND_SYSCALL(mq_timedreceive_time32);
 COND_SYSCALL(mq_notify);
 COND_SYSCALL_COMPAT(mq_notify);
 COND_SYSCALL(mq_getsetattr);
@@ -211,7 +213,7 @@ COND_SYSCALL(old_semctl);
 COND_SYSCALL(semctl);
 COND_SYSCALL_COMPAT(semctl);
 COND_SYSCALL(semtimedop);
-COND_SYSCALL_COMPAT(semtimedop);
+COND_SYSCALL(semtimedop_time32);
 COND_SYSCALL(semop);
 
 /* ipc/shm.c */
@@ -288,7 +290,7 @@ COND_SYSCALL(perf_event_open);
 COND_SYSCALL(accept4);
 COND_SYSCALL(recvmmsg);
 COND_SYSCALL(recvmmsg_time32);
-COND_SYSCALL_COMPAT(recvmmsg);
+COND_SYSCALL_COMPAT(recvmmsg_time32);
 COND_SYSCALL_COMPAT(recvmmsg_time64);
 
 /*

commit 275f22148e8720e84b180d9e0cdf8abfd69bac5b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 31 22:22:40 2018 +0100

    ipc: rename old-style shmctl/semctl/msgctl syscalls
    
    The behavior of these system calls is slightly different between
    architectures, as determined by the CONFIG_ARCH_WANT_IPC_PARSE_VERSION
    symbol. Most architectures that implement the split IPC syscalls don't set
    that symbol and only get the modern version, but alpha, arm, microblaze,
    mips-n32, mips-n64 and xtensa expect the caller to pass the IPC_64 flag.
    
    For the architectures that so far only implement sys_ipc(), i.e. m68k,
    mips-o32, powerpc, s390, sh, sparc, and x86-32, we want the new behavior
    when adding the split syscalls, so we need to distinguish between the
    two groups of architectures.
    
    The method I picked for this distinction is to have a separate system call
    entry point: sys_old_*ctl() now uses ipc_parse_version, while sys_*ctl()
    does not. The system call tables of the five architectures are changed
    accordingly.
    
    As an additional benefit, we no longer need the configuration specific
    definition for ipc_parse_version(), it always does the same thing now,
    but simply won't get called on architectures with the modern interface.
    
    A small downside is that on architectures that do set
    ARCH_WANT_IPC_PARSE_VERSION, we now have an extra set of entry points
    that are never called. They only add a few bytes of bloat, so it seems
    better to keep them compared to adding yet another Kconfig symbol.
    I considered adding new syscall numbers for the IPC_64 variants for
    consistency, but decided against that for now.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index bc934f31ab10..ce04431a40d1 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -197,6 +197,7 @@ COND_SYSCALL_COMPAT(mq_getsetattr);
 
 /* ipc/msg.c */
 COND_SYSCALL(msgget);
+COND_SYSCALL(old_msgctl);
 COND_SYSCALL(msgctl);
 COND_SYSCALL_COMPAT(msgctl);
 COND_SYSCALL(msgrcv);
@@ -206,6 +207,7 @@ COND_SYSCALL_COMPAT(msgsnd);
 
 /* ipc/sem.c */
 COND_SYSCALL(semget);
+COND_SYSCALL(old_semctl);
 COND_SYSCALL(semctl);
 COND_SYSCALL_COMPAT(semctl);
 COND_SYSCALL(semtimedop);
@@ -214,6 +216,7 @@ COND_SYSCALL(semop);
 
 /* ipc/shm.c */
 COND_SYSCALL(shmget);
+COND_SYSCALL(old_shmctl);
 COND_SYSCALL(shmctl);
 COND_SYSCALL_COMPAT(shmctl);
 COND_SYSCALL(shmat);

commit 58fa4a410fc31afe08d0d0c6b6d8860c22ec17c2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 16 14:15:20 2019 +0100

    ipc: introduce ksys_ipc()/compat_ksys_ipc() for s390
    
    The sys_ipc() and compat_ksys_ipc() functions are meant to only
    be used from the system call table, not called by another function.
    
    Introduce ksys_*() interfaces for this purpose, as we have done
    for many other system calls.
    
    Link: https://lore.kernel.org/lkml/20190116131527.2071570-3-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    [heiko.carstens@de.ibm.com: compile fix for !CONFIG_COMPAT]
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ab9d0e3c6d50..bc934f31ab10 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -366,6 +366,7 @@ COND_SYSCALL(kexec_file_load);
 /* s390 */
 COND_SYSCALL(s390_pci_mmio_read);
 COND_SYSCALL(s390_pci_mmio_write);
+COND_SYSCALL(s390_ipc);
 COND_SYSCALL_COMPAT(s390_ipc);
 
 /* powerpc */

commit e11d4284e2f4de5048c6d1787c82226f0a198292
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 18 13:43:52 2018 +0200

    y2038: socket: Add compat_sys_recvmmsg_time64
    
    recvmmsg() takes two arguments to pointers of structures that differ
    between 32-bit and 64-bit architectures: mmsghdr and timespec.
    
    For y2038 compatbility, we are changing the native system call from
    timespec to __kernel_timespec with a 64-bit time_t (in another patch),
    and use the existing compat system call on both 32-bit and 64-bit
    architectures for compatibility with traditional 32-bit user space.
    
    As we now have two variants of recvmmsg() for 32-bit tasks that are both
    different from the variant that we use on 64-bit tasks, this means we
    also require two compat system calls!
    
    The solution I picked is to flip things around: The existing
    compat_sys_recvmmsg() call gets moved from net/compat.c into net/socket.c
    and now handles the case for old user space on all architectures that
    have set CONFIG_COMPAT_32BIT_TIME.  A new compat_sys_recvmmsg_time64()
    call gets added in the old place for 64-bit architectures only, this
    one handles the case of a compat mmsghdr structure combined with
    __kernel_timespec.
    
    In the indirect sys_socketcall(), we now need to call either
    do_sys_recvmmsg() or __compat_sys_recvmmsg(), depending on what kind of
    architecture we are on. For compat_sys_socketcall(), no such change is
    needed, we always call __compat_sys_recvmmsg().
    
    I decided to not add a new SYS_RECVMMSG_TIME64 socketcall: Any libc
    implementation for 64-bit time_t will need significant changes including
    an updated asm/unistd.h, and it seems better to consistently use the
    separate syscalls that configuration, leaving the socketcall only for
    backward compatibility with 32-bit time_t based libc.
    
    The naming is asymmetric for the moment, so both existing syscalls
    entry points keep their names, while the new ones are recvmmsg_time32
    and compat_recvmmsg_time64 respectively. I expect that we will rename
    the compat syscalls later as we start using generated syscall tables
    everywhere and add these entry points.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index df556175be50..ab9d0e3c6d50 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -284,7 +284,9 @@ COND_SYSCALL_COMPAT(move_pages);
 COND_SYSCALL(perf_event_open);
 COND_SYSCALL(accept4);
 COND_SYSCALL(recvmmsg);
+COND_SYSCALL(recvmmsg_time32);
 COND_SYSCALL_COMPAT(recvmmsg);
+COND_SYSCALL_COMPAT(recvmmsg_time64);
 
 /*
  * Architecture specific syscalls: see further below

commit d82991a8688ad128b46db1b42d5d84396487a508
Merge: f4e5b30d809d ccba8b64452b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 10:17:09 2018 -0700

    Merge branch 'core-rseq-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull restartable sequence support from Thomas Gleixner:
     "The restartable sequences syscall (finally):
    
      After a lot of back and forth discussion and massive delays caused by
      the speculative distraction of maintainers, the core set of
      restartable sequences has finally reached a consensus.
    
      It comes with the basic non disputed core implementation along with
      support for arm, powerpc and x86 and a full set of selftests
    
      It was exposed to linux-next earlier this week, so it does not fully
      comply with the merge window requirements, but there is really no
      point to drag it out for yet another cycle"
    
    * 'core-rseq-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      rseq/selftests: Provide Makefile, scripts, gitignore
      rseq/selftests: Provide parametrized tests
      rseq/selftests: Provide basic percpu ops test
      rseq/selftests: Provide basic test
      rseq/selftests: Provide rseq library
      selftests/lib.mk: Introduce OVERRIDE_TARGETS
      powerpc: Wire up restartable sequences system call
      powerpc: Add syscall detection for restartable sequences
      powerpc: Add support for restartable sequences
      x86: Wire up restartable sequence system call
      x86: Add support for restartable sequences
      arm: Wire up restartable sequences system call
      arm: Add syscall detection for restartable sequences
      arm: Add restartable sequences support
      rseq: Introduce restartable sequences system call
      uapi/headers: Provide types_32_64.h

commit c90fca951e90ba470a3dc6087667edffcf8db21b
Merge: c0ab85267e25 ff5bc793e47b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 7 10:23:33 2018 -0700

    Merge tag 'powerpc-4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - Support for split PMD page table lock on 64-bit Book3S (Power8/9).
    
       - Add support for HAVE_RELIABLE_STACKTRACE, so we properly support
         live patching again.
    
       - Add support for patching barrier_nospec in copy_from_user() and
         syscall entry.
    
       - A couple of fixes for our data breakpoints on Book3S.
    
       - A series from Nick optimising TLB/mm handling with the Radix MMU.
    
       - Numerous small cleanups to squash sparse/gcc warnings from Mathieu
         Malaterre.
    
       - Several series optimising various parts of the 32-bit code from
         Christophe Leroy.
    
       - Removal of support for two old machines, "SBC834xE" and "C2K"
         ("GEFanuc,C2K"), which is why the diffstat has so many deletions.
    
      And many other small improvements & fixes.
    
      There's a few out-of-area changes. Some minor ftrace changes OK'ed by
      Steve, and a fix to our powernv cpuidle driver. Then there's a series
      touching mm, x86 and fs/proc/task_mmu.c, which cleans up some details
      around pkey support. It was ack'ed/reviewed by Ingo & Dave and has
      been in next for several weeks.
    
      Thanks to: Akshay Adiga, Alastair D'Silva, Alexey Kardashevskiy, Al
      Viro, Andrew Donnellan, Aneesh Kumar K.V, Anju T Sudhakar, Arnd
      Bergmann, Balbir Singh, Cédric Le Goater, Christophe Leroy, Christophe
      Lombard, Colin Ian King, Dave Hansen, Fabio Estevam, Finn Thain,
      Frederic Barrat, Gautham R. Shenoy, Haren Myneni, Hari Bathini, Ingo
      Molnar, Jonathan Neuschäfer, Josh Poimboeuf, Kamalesh Babulal,
      Madhavan Srinivasan, Mahesh Salgaonkar, Mark Greer, Mathieu Malaterre,
      Matthew Wilcox, Michael Neuling, Michal Suchanek, Naveen N. Rao,
      Nicholas Piggin, Nicolai Stange, Olof Johansson, Paul Gortmaker, Paul
      Mackerras, Peter Rosin, Pridhiviraj Paidipeddi, Ram Pai, Rashmica
      Gupta, Ravi Bangoria, Russell Currey, Sam Bobroff, Samuel
      Mendoza-Jonas, Segher Boessenkool, Shilpasri G Bhat, Simon Guo,
      Souptick Joarder, Stewart Smith, Thiago Jung Bauermann, Torsten Duwe,
      Vaibhav Jain, Wei Yongjun, Wolfram Sang, Yisheng Xie, YueHaibing"
    
    * tag 'powerpc-4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (251 commits)
      powerpc/64s/radix: Fix missing ptesync in flush_cache_vmap
      cpuidle: powernv: Fix promotion from snooze if next state disabled
      powerpc: fix build failure by disabling attribute-alias warning in pci_32
      ocxl: Fix missing unlock on error in afu_ioctl_enable_p9_wait()
      powerpc-opal: fix spelling mistake "Uniterrupted" -> "Uninterrupted"
      powerpc: fix spelling mistake: "Usupported" -> "Unsupported"
      powerpc/pkeys: Detach execute_only key on !PROT_EXEC
      powerpc/powernv: copy/paste - Mask SO bit in CR
      powerpc: Remove core support for Marvell mv64x60 hostbridges
      powerpc/boot: Remove core support for Marvell mv64x60 hostbridges
      powerpc/boot: Remove support for Marvell mv64x60 i2c controller
      powerpc/boot: Remove support for Marvell MPSC serial controller
      powerpc/embedded6xx: Remove C2K board support
      powerpc/lib: optimise PPC32 memcmp
      powerpc/lib: optimise 32 bits __clear_user()
      powerpc/time: inline arch_vtime_task_switch()
      powerpc/Makefile: set -mcpu=860 flag for the 8xx
      powerpc: Implement csum_ipv6_magic in assembly
      powerpc/32: Optimise __csum_partial()
      powerpc/lib: Adjust .balign inside string functions for PPC32
      ...

commit d7822b1e24f2df5df98c76f0e94a5416349ff759
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Sat Jun 2 08:43:54 2018 -0400

    rseq: Introduce restartable sequences system call
    
    Expose a new system call allowing each thread to register one userspace
    memory area to be used as an ABI between kernel and user-space for two
    purposes: user-space restartable sequences and quick access to read the
    current CPU number value from user-space.
    
    * Restartable sequences (per-cpu atomics)
    
    Restartables sequences allow user-space to perform update operations on
    per-cpu data without requiring heavy-weight atomic operations.
    
    The restartable critical sections (percpu atomics) work has been started
    by Paul Turner and Andrew Hunter. It lets the kernel handle restart of
    critical sections. [1] [2] The re-implementation proposed here brings a
    few simplifications to the ABI which facilitates porting to other
    architectures and speeds up the user-space fast path.
    
    Here are benchmarks of various rseq use-cases.
    
    Test hardware:
    
    arm32: ARMv7 Processor rev 4 (v7l) "Cubietruck", 2-core
    x86-64: Intel E5-2630 v3@2.40GHz, 16-core, hyperthreading
    
    The following benchmarks were all performed on a single thread.
    
    * Per-CPU statistic counter increment
    
                    getcpu+atomic (ns/op)    rseq (ns/op)    speedup
    arm32:                344.0                 31.4          11.0
    x86-64:                15.3                  2.0           7.7
    
    * LTTng-UST: write event 32-bit header, 32-bit payload into tracer
                 per-cpu buffer
    
                    getcpu+atomic (ns/op)    rseq (ns/op)    speedup
    arm32:               2502.0                 2250.0         1.1
    x86-64:               117.4                   98.0         1.2
    
    * liburcu percpu: lock-unlock pair, dereference, read/compare word
    
                    getcpu+atomic (ns/op)    rseq (ns/op)    speedup
    arm32:                751.0                 128.5          5.8
    x86-64:                53.4                  28.6          1.9
    
    * jemalloc memory allocator adapted to use rseq
    
    Using rseq with per-cpu memory pools in jemalloc at Facebook (based on
    rseq 2016 implementation):
    
    The production workload response-time has 1-2% gain avg. latency, and
    the P99 overall latency drops by 2-3%.
    
    * Reading the current CPU number
    
    Speeding up reading the current CPU number on which the caller thread is
    running is done by keeping the current CPU number up do date within the
    cpu_id field of the memory area registered by the thread. This is done
    by making scheduler preemption set the TIF_NOTIFY_RESUME flag on the
    current thread. Upon return to user-space, a notify-resume handler
    updates the current CPU value within the registered user-space memory
    area. User-space can then read the current CPU number directly from
    memory.
    
    Keeping the current cpu id in a memory area shared between kernel and
    user-space is an improvement over current mechanisms available to read
    the current CPU number, which has the following benefits over
    alternative approaches:
    
    - 35x speedup on ARM vs system call through glibc
    - 20x speedup on x86 compared to calling glibc, which calls vdso
      executing a "lsl" instruction,
    - 14x speedup on x86 compared to inlined "lsl" instruction,
    - Unlike vdso approaches, this cpu_id value can be read from an inline
      assembly, which makes it a useful building block for restartable
      sequences.
    - The approach of reading the cpu id through memory mapping shared
      between kernel and user-space is portable (e.g. ARM), which is not the
      case for the lsl-based x86 vdso.
    
    On x86, yet another possible approach would be to use the gs segment
    selector to point to user-space per-cpu data. This approach performs
    similarly to the cpu id cache, but it has two disadvantages: it is
    not portable, and it is incompatible with existing applications already
    using the gs segment selector for other purposes.
    
    Benchmarking various approaches for reading the current CPU number:
    
    ARMv7 Processor rev 4 (v7l)
    Machine model: Cubietruck
    - Baseline (empty loop):                                    8.4 ns
    - Read CPU from rseq cpu_id:                               16.7 ns
    - Read CPU from rseq cpu_id (lazy register):               19.8 ns
    - glibc 2.19-0ubuntu6.6 getcpu:                           301.8 ns
    - getcpu system call:                                     234.9 ns
    
    x86-64 Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz:
    - Baseline (empty loop):                                    0.8 ns
    - Read CPU from rseq cpu_id:                                0.8 ns
    - Read CPU from rseq cpu_id (lazy register):                0.8 ns
    - Read using gs segment selector:                           0.8 ns
    - "lsl" inline assembly:                                   13.0 ns
    - glibc 2.19-0ubuntu6 getcpu:                              16.6 ns
    - getcpu system call:                                      53.9 ns
    
    - Speed (benchmark taken on v8 of patchset)
    
    Running 10 runs of hackbench -l 100000 seems to indicate, contrary to
    expectations, that enabling CONFIG_RSEQ slightly accelerates the
    scheduler:
    
    Configuration: 2 sockets * 8-core Intel(R) Xeon(R) CPU E5-2630 v3 @
    2.40GHz (directly on hardware, hyperthreading disabled in BIOS, energy
    saving disabled in BIOS, turboboost disabled in BIOS, cpuidle.off=1
    kernel parameter), with a Linux v4.6 defconfig+localyesconfig,
    restartable sequences series applied.
    
    * CONFIG_RSEQ=n
    
    avg.:      41.37 s
    std.dev.:   0.36 s
    
    * CONFIG_RSEQ=y
    
    avg.:      40.46 s
    std.dev.:   0.33 s
    
    - Size
    
    On x86-64, between CONFIG_RSEQ=n/y, the text size increase of vmlinux is
    567 bytes, and the data size increase of vmlinux is 5696 bytes.
    
    [1] https://lwn.net/Articles/650333/
    [2] http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1695/original/LPC%20-%20PerCpu%20Atomics.pdf
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Joel Fernandes <joelaf@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Dave Watson <davejwatson@fb.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: "H . Peter Anvin" <hpa@zytor.com>
    Cc: Chris Lameter <cl@linux.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Andrew Hunter <ahh@google.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: "Paul E . McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Paul Turner <pjt@google.com>
    Cc: Boqun Feng <boqun.feng@gmail.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Ben Maurer <bmaurer@fb.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-api@vger.kernel.org
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20151027235635.16059.11630.stgit@pjt-glaptop.roam.corp.google.com
    Link: http://lkml.kernel.org/r/20150624222609.6116.86035.stgit@kitami.mtv.corp.google.com
    Link: https://lkml.kernel.org/r/20180602124408.8430-3-mathieu.desnoyers@efficios.com

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 183169c2a75b..86f832d6ff6f 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -432,3 +432,6 @@ COND_SYSCALL(setresgid16);
 COND_SYSCALL(setresuid16);
 COND_SYSCALL(setreuid16);
 COND_SYSCALL(setuid16);
+
+/* restartable sequence */
+COND_SYSCALL(rseq);

commit 4c392e6591e3257ebd08210e1ac0a175eefd0168
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 2 23:20:48 2018 +1000

    powerpc/syscalls: switch rtas(2) to SYSCALL_DEFINE
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    [mpe: Update sys_ni.c for s/ppc_rtas/sys_rtas/]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 9791364925dc..3751a511e2b8 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -365,7 +365,7 @@ COND_SYSCALL(s390_pci_mmio_write);
 COND_SYSCALL_COMPAT(s390_ipc);
 
 /* powerpc */
-cond_syscall(ppc_rtas);
+COND_SYSCALL(rtas);
 COND_SYSCALL(spu_run);
 COND_SYSCALL(spu_create);
 COND_SYSCALL(subpage_prot);

commit 7a074e96dee62586c935c80cecd931431bfdd0be
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 2 19:51:00 2018 +0200

    aio: implement io_pgetevents
    
    This is the io_getevents equivalent of ppoll/pselect and allows to
    properly mix signals and aio completions (especially with IOCB_CMD_POLL)
    and atomically executes the following sequence:
    
            sigset_t origmask;
    
            pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
            ret = io_getevents(ctx, min_nr, nr, events, timeout);
            pthread_sigmask(SIG_SETMASK, &origmask, NULL);
    
    Note that unlike many other signal related calls we do not pass a sigmask
    size, as that would get us to 7 arguments, which aren't easily supported
    by the syscall infrastructure.  It seems a lot less painful to just add a
    new syscall variant in the unlikely case we're going to increase the
    sigset size.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 9791364925dc..183169c2a75b 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -43,7 +43,9 @@ COND_SYSCALL(io_submit);
 COND_SYSCALL_COMPAT(io_submit);
 COND_SYSCALL(io_cancel);
 COND_SYSCALL(io_getevents);
+COND_SYSCALL(io_pgetevents);
 COND_SYSCALL_COMPAT(io_getevents);
+COND_SYSCALL_COMPAT(io_pgetevents);
 
 /* fs/xattr.c */
 

commit 7303e30ec1d8fb5ca1f07c92d069241c32b2ee1b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Apr 5 11:53:03 2018 +0200

    syscalls/core: Prepare CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y for compat syscalls
    
    It may be useful for an architecture to override the definitions of the
    COMPAT_SYSCALL_DEFINE0() and __COMPAT_SYSCALL_DEFINEx() macros in
    <linux/compat.h>, in particular to use a different calling convention
    for syscalls. This patch provides a mechanism to do so, based on the
    previously introduced CONFIG_ARCH_HAS_SYSCALL_WRAPPER. If it is enabled,
    <asm/sycall_wrapper.h> is included in <linux/compat.h> and may be used
    to define the macros mentioned above. Moreover, as the syscall calling
    convention may be different if CONFIG_ARCH_HAS_SYSCALL_WRAPPER is set,
    the compat syscall function prototypes in <linux/compat.h> are #ifndef'd
    out in that case.
    
    As some of the syscalls and/or compat syscalls may not be present,
    the COND_SYSCALL() and COND_SYSCALL_COMPAT() macros in kernel/sys_ni.c
    as well as the SYS_NI() and COMPAT_SYS_NI() macros in
    kernel/time/posix-stubs.c can be re-defined in <asm/syscall_wrapper.h> iff
    CONFIG_ARCH_HAS_SYSCALL_WRAPPER is enabled.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20180405095307.3730-5-linux@dominikbrodowski.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 6cafc008f6db..9791364925dc 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -5,6 +5,11 @@
 
 #include <asm/unistd.h>
 
+#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER
+/* Architectures may override COND_SYSCALL and COND_SYSCALL_COMPAT */
+#include <asm/syscall_wrapper.h>
+#endif /* CONFIG_ARCH_HAS_SYSCALL_WRAPPER */
+
 /*  we can't #include <linux/syscalls.h> here,
     but tell gcc to not warn with -Wmissing-prototypes  */
 asmlinkage long sys_ni_syscall(void);
@@ -17,8 +22,13 @@ asmlinkage long sys_ni_syscall(void)
 	return -ENOSYS;
 }
 
+#ifndef COND_SYSCALL
 #define COND_SYSCALL(name) cond_syscall(sys_##name)
+#endif /* COND_SYSCALL */
+
+#ifndef COND_SYSCALL_COMPAT
 #define COND_SYSCALL_COMPAT(name) cond_syscall(compat_sys_##name)
+#endif /* COND_SYSCALL_COMPAT */
 
 /*
  * This list is kept in the same order as include/uapi/asm-generic/unistd.h.

commit 67a7acd3773a94df2e671601a288685485463cf9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 4 19:06:35 2018 +0100

    kernel/sys_ni: remove {sys_,sys_compat} from cond_syscall definitions
    
    This keeps it in line with the SYSCALL_DEFINEx() / COMPAT_SYSCALL_DEFINEx()
    calling convention.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0c1538f5a559..6cafc008f6db 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -17,53 +17,56 @@ asmlinkage long sys_ni_syscall(void)
 	return -ENOSYS;
 }
 
+#define COND_SYSCALL(name) cond_syscall(sys_##name)
+#define COND_SYSCALL_COMPAT(name) cond_syscall(compat_sys_##name)
+
 /*
  * This list is kept in the same order as include/uapi/asm-generic/unistd.h.
  * Architecture specific entries go below, followed by deprecated or obsolete
  * system calls.
  */
 
-cond_syscall(sys_io_setup);
-cond_syscall(compat_sys_io_setup);
-cond_syscall(sys_io_destroy);
-cond_syscall(sys_io_submit);
-cond_syscall(compat_sys_io_submit);
-cond_syscall(sys_io_cancel);
-cond_syscall(sys_io_getevents);
-cond_syscall(compat_sys_io_getevents);
+COND_SYSCALL(io_setup);
+COND_SYSCALL_COMPAT(io_setup);
+COND_SYSCALL(io_destroy);
+COND_SYSCALL(io_submit);
+COND_SYSCALL_COMPAT(io_submit);
+COND_SYSCALL(io_cancel);
+COND_SYSCALL(io_getevents);
+COND_SYSCALL_COMPAT(io_getevents);
 
 /* fs/xattr.c */
 
 /* fs/dcache.c */
 
 /* fs/cookies.c */
-cond_syscall(sys_lookup_dcookie);
-cond_syscall(compat_sys_lookup_dcookie);
+COND_SYSCALL(lookup_dcookie);
+COND_SYSCALL_COMPAT(lookup_dcookie);
 
 /* fs/eventfd.c */
-cond_syscall(sys_eventfd2);
+COND_SYSCALL(eventfd2);
 
 /* fs/eventfd.c */
-cond_syscall(sys_epoll_create1);
-cond_syscall(sys_epoll_ctl);
-cond_syscall(sys_epoll_pwait);
-cond_syscall(compat_sys_epoll_pwait);
+COND_SYSCALL(epoll_create1);
+COND_SYSCALL(epoll_ctl);
+COND_SYSCALL(epoll_pwait);
+COND_SYSCALL_COMPAT(epoll_pwait);
 
 /* fs/fcntl.c */
 
 /* fs/inotify_user.c */
-cond_syscall(sys_inotify_init1);
-cond_syscall(sys_inotify_add_watch);
-cond_syscall(sys_inotify_rm_watch);
+COND_SYSCALL(inotify_init1);
+COND_SYSCALL(inotify_add_watch);
+COND_SYSCALL(inotify_rm_watch);
 
 /* fs/ioctl.c */
 
 /* fs/ioprio.c */
-cond_syscall(sys_ioprio_set);
-cond_syscall(sys_ioprio_get);
+COND_SYSCALL(ioprio_set);
+COND_SYSCALL(ioprio_get);
 
 /* fs/locks.c */
-cond_syscall(sys_flock);
+COND_SYSCALL(flock);
 
 /* fs/namei.c */
 
@@ -76,7 +79,7 @@ cond_syscall(sys_flock);
 /* fs/pipe.c */
 
 /* fs/quota.c */
-cond_syscall(sys_quotactl);
+COND_SYSCALL(quotactl);
 
 /* fs/readdir.c */
 
@@ -87,8 +90,8 @@ cond_syscall(sys_quotactl);
 /* fs/select.c */
 
 /* fs/signalfd.c */
-cond_syscall(sys_signalfd4);
-cond_syscall(compat_sys_signalfd4);
+COND_SYSCALL(signalfd4);
+COND_SYSCALL_COMPAT(signalfd4);
 
 /* fs/splice.c */
 
@@ -97,20 +100,20 @@ cond_syscall(compat_sys_signalfd4);
 /* fs/sync.c */
 
 /* fs/timerfd.c */
-cond_syscall(sys_timerfd_create);
-cond_syscall(sys_timerfd_settime);
-cond_syscall(compat_sys_timerfd_settime);
-cond_syscall(sys_timerfd_gettime);
-cond_syscall(compat_sys_timerfd_gettime);
+COND_SYSCALL(timerfd_create);
+COND_SYSCALL(timerfd_settime);
+COND_SYSCALL_COMPAT(timerfd_settime);
+COND_SYSCALL(timerfd_gettime);
+COND_SYSCALL_COMPAT(timerfd_gettime);
 
 /* fs/utimes.c */
 
 /* kernel/acct.c */
-cond_syscall(sys_acct);
+COND_SYSCALL(acct);
 
 /* kernel/capability.c */
-cond_syscall(sys_capget);
-cond_syscall(sys_capset);
+COND_SYSCALL(capget);
+COND_SYSCALL(capset);
 
 /* kernel/exec_domain.c */
 
@@ -119,29 +122,29 @@ cond_syscall(sys_capset);
 /* kernel/fork.c */
 
 /* kernel/futex.c */
-cond_syscall(sys_futex);
-cond_syscall(compat_sys_futex);
-cond_syscall(sys_set_robust_list);
-cond_syscall(compat_sys_set_robust_list);
-cond_syscall(sys_get_robust_list);
-cond_syscall(compat_sys_get_robust_list);
+COND_SYSCALL(futex);
+COND_SYSCALL_COMPAT(futex);
+COND_SYSCALL(set_robust_list);
+COND_SYSCALL_COMPAT(set_robust_list);
+COND_SYSCALL(get_robust_list);
+COND_SYSCALL_COMPAT(get_robust_list);
 
 /* kernel/hrtimer.c */
 
 /* kernel/itimer.c */
 
 /* kernel/kexec.c */
-cond_syscall(sys_kexec_load);
-cond_syscall(compat_sys_kexec_load);
+COND_SYSCALL(kexec_load);
+COND_SYSCALL_COMPAT(kexec_load);
 
 /* kernel/module.c */
-cond_syscall(sys_init_module);
-cond_syscall(sys_delete_module);
+COND_SYSCALL(init_module);
+COND_SYSCALL(delete_module);
 
 /* kernel/posix-timers.c */
 
 /* kernel/printk.c */
-cond_syscall(sys_syslog);
+COND_SYSCALL(syslog);
 
 /* kernel/ptrace.c */
 
@@ -150,176 +153,176 @@ cond_syscall(sys_syslog);
 /* kernel/signal.c */
 
 /* kernel/sys.c */
-cond_syscall(sys_setregid);
-cond_syscall(sys_setgid);
-cond_syscall(sys_setreuid);
-cond_syscall(sys_setuid);
-cond_syscall(sys_setresuid);
-cond_syscall(sys_getresuid);
-cond_syscall(sys_setresgid);
-cond_syscall(sys_getresgid);
-cond_syscall(sys_setfsuid);
-cond_syscall(sys_setfsgid);
-cond_syscall(sys_setgroups);
-cond_syscall(sys_getgroups);
+COND_SYSCALL(setregid);
+COND_SYSCALL(setgid);
+COND_SYSCALL(setreuid);
+COND_SYSCALL(setuid);
+COND_SYSCALL(setresuid);
+COND_SYSCALL(getresuid);
+COND_SYSCALL(setresgid);
+COND_SYSCALL(getresgid);
+COND_SYSCALL(setfsuid);
+COND_SYSCALL(setfsgid);
+COND_SYSCALL(setgroups);
+COND_SYSCALL(getgroups);
 
 /* kernel/time.c */
 
 /* kernel/timer.c */
 
 /* ipc/mqueue.c */
-cond_syscall(sys_mq_open);
-cond_syscall(compat_sys_mq_open);
-cond_syscall(sys_mq_unlink);
-cond_syscall(sys_mq_timedsend);
-cond_syscall(compat_sys_mq_timedsend);
-cond_syscall(sys_mq_timedreceive);
-cond_syscall(compat_sys_mq_timedreceive);
-cond_syscall(sys_mq_notify);
-cond_syscall(compat_sys_mq_notify);
-cond_syscall(sys_mq_getsetattr);
-cond_syscall(compat_sys_mq_getsetattr);
+COND_SYSCALL(mq_open);
+COND_SYSCALL_COMPAT(mq_open);
+COND_SYSCALL(mq_unlink);
+COND_SYSCALL(mq_timedsend);
+COND_SYSCALL_COMPAT(mq_timedsend);
+COND_SYSCALL(mq_timedreceive);
+COND_SYSCALL_COMPAT(mq_timedreceive);
+COND_SYSCALL(mq_notify);
+COND_SYSCALL_COMPAT(mq_notify);
+COND_SYSCALL(mq_getsetattr);
+COND_SYSCALL_COMPAT(mq_getsetattr);
 
 /* ipc/msg.c */
-cond_syscall(sys_msgget);
-cond_syscall(sys_msgctl);
-cond_syscall(compat_sys_msgctl);
-cond_syscall(sys_msgrcv);
-cond_syscall(compat_sys_msgrcv);
-cond_syscall(sys_msgsnd);
-cond_syscall(compat_sys_msgsnd);
+COND_SYSCALL(msgget);
+COND_SYSCALL(msgctl);
+COND_SYSCALL_COMPAT(msgctl);
+COND_SYSCALL(msgrcv);
+COND_SYSCALL_COMPAT(msgrcv);
+COND_SYSCALL(msgsnd);
+COND_SYSCALL_COMPAT(msgsnd);
 
 /* ipc/sem.c */
-cond_syscall(sys_semget);
-cond_syscall(sys_semctl);
-cond_syscall(compat_sys_semctl);
-cond_syscall(sys_semtimedop);
-cond_syscall(compat_sys_semtimedop);
-cond_syscall(sys_semop);
+COND_SYSCALL(semget);
+COND_SYSCALL(semctl);
+COND_SYSCALL_COMPAT(semctl);
+COND_SYSCALL(semtimedop);
+COND_SYSCALL_COMPAT(semtimedop);
+COND_SYSCALL(semop);
 
 /* ipc/shm.c */
-cond_syscall(sys_shmget);
-cond_syscall(sys_shmctl);
-cond_syscall(compat_sys_shmctl);
-cond_syscall(sys_shmat);
-cond_syscall(compat_sys_shmat);
-cond_syscall(sys_shmdt);
+COND_SYSCALL(shmget);
+COND_SYSCALL(shmctl);
+COND_SYSCALL_COMPAT(shmctl);
+COND_SYSCALL(shmat);
+COND_SYSCALL_COMPAT(shmat);
+COND_SYSCALL(shmdt);
 
 /* net/socket.c */
-cond_syscall(sys_socket);
-cond_syscall(sys_socketpair);
-cond_syscall(sys_bind);
-cond_syscall(sys_listen);
-cond_syscall(sys_accept);
-cond_syscall(sys_connect);
-cond_syscall(sys_getsockname);
-cond_syscall(sys_getpeername);
-cond_syscall(sys_setsockopt);
-cond_syscall(compat_sys_setsockopt);
-cond_syscall(sys_getsockopt);
-cond_syscall(compat_sys_getsockopt);
-cond_syscall(sys_sendto);
-cond_syscall(sys_shutdown);
-cond_syscall(sys_recvfrom);
-cond_syscall(compat_sys_recvfrom);
-cond_syscall(sys_sendmsg);
-cond_syscall(compat_sys_sendmsg);
-cond_syscall(sys_recvmsg);
-cond_syscall(compat_sys_recvmsg);
+COND_SYSCALL(socket);
+COND_SYSCALL(socketpair);
+COND_SYSCALL(bind);
+COND_SYSCALL(listen);
+COND_SYSCALL(accept);
+COND_SYSCALL(connect);
+COND_SYSCALL(getsockname);
+COND_SYSCALL(getpeername);
+COND_SYSCALL(setsockopt);
+COND_SYSCALL_COMPAT(setsockopt);
+COND_SYSCALL(getsockopt);
+COND_SYSCALL_COMPAT(getsockopt);
+COND_SYSCALL(sendto);
+COND_SYSCALL(shutdown);
+COND_SYSCALL(recvfrom);
+COND_SYSCALL_COMPAT(recvfrom);
+COND_SYSCALL(sendmsg);
+COND_SYSCALL_COMPAT(sendmsg);
+COND_SYSCALL(recvmsg);
+COND_SYSCALL_COMPAT(recvmsg);
 
 /* mm/filemap.c */
 
 /* mm/nommu.c, also with MMU */
-cond_syscall(sys_mremap);
+COND_SYSCALL(mremap);
 
 /* security/keys/keyctl.c */
-cond_syscall(sys_add_key);
-cond_syscall(sys_request_key);
-cond_syscall(sys_keyctl);
-cond_syscall(compat_sys_keyctl);
+COND_SYSCALL(add_key);
+COND_SYSCALL(request_key);
+COND_SYSCALL(keyctl);
+COND_SYSCALL_COMPAT(keyctl);
 
 /* arch/example/kernel/sys_example.c */
 
 /* mm/fadvise.c */
-cond_syscall(sys_fadvise64_64);
+COND_SYSCALL(fadvise64_64);
 
 /* mm/, CONFIG_MMU only */
-cond_syscall(sys_swapon);
-cond_syscall(sys_swapoff);
-cond_syscall(sys_mprotect);
-cond_syscall(sys_msync);
-cond_syscall(sys_mlock);
-cond_syscall(sys_munlock);
-cond_syscall(sys_mlockall);
-cond_syscall(sys_munlockall);
-cond_syscall(sys_mincore);
-cond_syscall(sys_madvise);
-cond_syscall(sys_remap_file_pages);
-cond_syscall(sys_mbind);
-cond_syscall(compat_sys_mbind);
-cond_syscall(sys_get_mempolicy);
-cond_syscall(compat_sys_get_mempolicy);
-cond_syscall(sys_set_mempolicy);
-cond_syscall(compat_sys_set_mempolicy);
-cond_syscall(sys_migrate_pages);
-cond_syscall(compat_sys_migrate_pages);
-cond_syscall(sys_move_pages);
-cond_syscall(compat_sys_move_pages);
-
-cond_syscall(sys_perf_event_open);
-cond_syscall(sys_accept4);
-cond_syscall(sys_recvmmsg);
-cond_syscall(compat_sys_recvmmsg);
+COND_SYSCALL(swapon);
+COND_SYSCALL(swapoff);
+COND_SYSCALL(mprotect);
+COND_SYSCALL(msync);
+COND_SYSCALL(mlock);
+COND_SYSCALL(munlock);
+COND_SYSCALL(mlockall);
+COND_SYSCALL(munlockall);
+COND_SYSCALL(mincore);
+COND_SYSCALL(madvise);
+COND_SYSCALL(remap_file_pages);
+COND_SYSCALL(mbind);
+COND_SYSCALL_COMPAT(mbind);
+COND_SYSCALL(get_mempolicy);
+COND_SYSCALL_COMPAT(get_mempolicy);
+COND_SYSCALL(set_mempolicy);
+COND_SYSCALL_COMPAT(set_mempolicy);
+COND_SYSCALL(migrate_pages);
+COND_SYSCALL_COMPAT(migrate_pages);
+COND_SYSCALL(move_pages);
+COND_SYSCALL_COMPAT(move_pages);
+
+COND_SYSCALL(perf_event_open);
+COND_SYSCALL(accept4);
+COND_SYSCALL(recvmmsg);
+COND_SYSCALL_COMPAT(recvmmsg);
 
 /*
  * Architecture specific syscalls: see further below
  */
 
 /* fanotify */
-cond_syscall(sys_fanotify_init);
-cond_syscall(sys_fanotify_mark);
+COND_SYSCALL(fanotify_init);
+COND_SYSCALL(fanotify_mark);
 
 /* open by handle */
-cond_syscall(sys_name_to_handle_at);
-cond_syscall(sys_open_by_handle_at);
-cond_syscall(compat_sys_open_by_handle_at);
+COND_SYSCALL(name_to_handle_at);
+COND_SYSCALL(open_by_handle_at);
+COND_SYSCALL_COMPAT(open_by_handle_at);
 
-cond_syscall(sys_sendmmsg);
-cond_syscall(compat_sys_sendmmsg);
-cond_syscall(sys_process_vm_readv);
-cond_syscall(compat_sys_process_vm_readv);
-cond_syscall(sys_process_vm_writev);
-cond_syscall(compat_sys_process_vm_writev);
+COND_SYSCALL(sendmmsg);
+COND_SYSCALL_COMPAT(sendmmsg);
+COND_SYSCALL(process_vm_readv);
+COND_SYSCALL_COMPAT(process_vm_readv);
+COND_SYSCALL(process_vm_writev);
+COND_SYSCALL_COMPAT(process_vm_writev);
 
 /* compare kernel pointers */
-cond_syscall(sys_kcmp);
+COND_SYSCALL(kcmp);
 
-cond_syscall(sys_finit_module);
+COND_SYSCALL(finit_module);
 
 /* operate on Secure Computing state */
-cond_syscall(sys_seccomp);
+COND_SYSCALL(seccomp);
 
-cond_syscall(sys_memfd_create);
+COND_SYSCALL(memfd_create);
 
 /* access BPF programs and maps */
-cond_syscall(sys_bpf);
+COND_SYSCALL(bpf);
 
 /* execveat */
-cond_syscall(sys_execveat);
+COND_SYSCALL(execveat);
 
-cond_syscall(sys_userfaultfd);
+COND_SYSCALL(userfaultfd);
 
 /* membarrier */
-cond_syscall(sys_membarrier);
+COND_SYSCALL(membarrier);
 
-cond_syscall(sys_mlock2);
+COND_SYSCALL(mlock2);
 
-cond_syscall(sys_copy_file_range);
+COND_SYSCALL(copy_file_range);
 
 /* memory protection keys */
-cond_syscall(sys_pkey_mprotect);
-cond_syscall(sys_pkey_alloc);
-cond_syscall(sys_pkey_free);
+COND_SYSCALL(pkey_mprotect);
+COND_SYSCALL(pkey_alloc);
+COND_SYSCALL(pkey_free);
 
 
 /*
@@ -327,35 +330,35 @@ cond_syscall(sys_pkey_free);
  */
 
 /* pciconfig: alpha, arm, arm64, ia64, sparc */
-cond_syscall(sys_pciconfig_read);
-cond_syscall(sys_pciconfig_write);
-cond_syscall(sys_pciconfig_iobase);
+COND_SYSCALL(pciconfig_read);
+COND_SYSCALL(pciconfig_write);
+COND_SYSCALL(pciconfig_iobase);
 
 /* sys_socketcall: arm, mips, x86, ... */
-cond_syscall(sys_socketcall);
-cond_syscall(compat_sys_socketcall);
+COND_SYSCALL(socketcall);
+COND_SYSCALL_COMPAT(socketcall);
 
 /* compat syscalls for arm64, x86, ... */
-cond_syscall(compat_sys_sysctl);
-cond_syscall(compat_sys_fanotify_mark);
+COND_SYSCALL_COMPAT(sysctl);
+COND_SYSCALL_COMPAT(fanotify_mark);
 
 /* x86 */
-cond_syscall(sys_vm86old);
-cond_syscall(sys_modify_ldt);
-cond_syscall(compat_sys_quotactl32);
-cond_syscall(sys_vm86);
-cond_syscall(sys_kexec_file_load);
+COND_SYSCALL(vm86old);
+COND_SYSCALL(modify_ldt);
+COND_SYSCALL_COMPAT(quotactl32);
+COND_SYSCALL(vm86);
+COND_SYSCALL(kexec_file_load);
 
 /* s390 */
-cond_syscall(sys_s390_pci_mmio_read);
-cond_syscall(sys_s390_pci_mmio_write);
-cond_syscall(compat_sys_s390_ipc);
+COND_SYSCALL(s390_pci_mmio_read);
+COND_SYSCALL(s390_pci_mmio_write);
+COND_SYSCALL_COMPAT(s390_ipc);
 
 /* powerpc */
 cond_syscall(ppc_rtas);
-cond_syscall(sys_spu_run);
-cond_syscall(sys_spu_create);
-cond_syscall(sys_subpage_prot);
+COND_SYSCALL(spu_run);
+COND_SYSCALL(spu_create);
+COND_SYSCALL(subpage_prot);
 
 
 /*
@@ -364,22 +367,22 @@ cond_syscall(sys_subpage_prot);
  */
 
 /* __ARCH_WANT_SYSCALL_NO_FLAGS */
-cond_syscall(sys_epoll_create);
-cond_syscall(sys_inotify_init);
-cond_syscall(sys_eventfd);
-cond_syscall(sys_signalfd);
-cond_syscall(compat_sys_signalfd);
+COND_SYSCALL(epoll_create);
+COND_SYSCALL(inotify_init);
+COND_SYSCALL(eventfd);
+COND_SYSCALL(signalfd);
+COND_SYSCALL_COMPAT(signalfd);
 
 /* __ARCH_WANT_SYSCALL_OFF_T */
-cond_syscall(sys_fadvise64);
+COND_SYSCALL(fadvise64);
 
 /* __ARCH_WANT_SYSCALL_DEPRECATED */
-cond_syscall(sys_epoll_wait);
-cond_syscall(sys_recv);
-cond_syscall(compat_sys_recv);
-cond_syscall(sys_send);
-cond_syscall(sys_bdflush);
-cond_syscall(sys_uselib);
+COND_SYSCALL(epoll_wait);
+COND_SYSCALL(recv);
+COND_SYSCALL_COMPAT(recv);
+COND_SYSCALL(send);
+COND_SYSCALL(bdflush);
+COND_SYSCALL(uselib);
 
 
 /*
@@ -387,33 +390,33 @@ cond_syscall(sys_uselib);
  */
 
 /* obsolete: SGETMASK_SYSCALL */
-cond_syscall(sys_sgetmask);
-cond_syscall(sys_ssetmask);
+COND_SYSCALL(sgetmask);
+COND_SYSCALL(ssetmask);
 
 /* obsolete: SYSFS_SYSCALL */
-cond_syscall(sys_sysfs);
+COND_SYSCALL(sysfs);
 
 /* obsolete: __ARCH_WANT_SYS_IPC */
-cond_syscall(sys_ipc);
-cond_syscall(compat_sys_ipc);
+COND_SYSCALL(ipc);
+COND_SYSCALL_COMPAT(ipc);
 
 /* obsolete: UID16 */
-cond_syscall(sys_chown16);
-cond_syscall(sys_fchown16);
-cond_syscall(sys_getegid16);
-cond_syscall(sys_geteuid16);
-cond_syscall(sys_getgid16);
-cond_syscall(sys_getgroups16);
-cond_syscall(sys_getresgid16);
-cond_syscall(sys_getresuid16);
-cond_syscall(sys_getuid16);
-cond_syscall(sys_lchown16);
-cond_syscall(sys_setfsgid16);
-cond_syscall(sys_setfsuid16);
-cond_syscall(sys_setgid16);
-cond_syscall(sys_setgroups16);
-cond_syscall(sys_setregid16);
-cond_syscall(sys_setresgid16);
-cond_syscall(sys_setresuid16);
-cond_syscall(sys_setreuid16);
-cond_syscall(sys_setuid16);
+COND_SYSCALL(chown16);
+COND_SYSCALL(fchown16);
+COND_SYSCALL(getegid16);
+COND_SYSCALL(geteuid16);
+COND_SYSCALL(getgid16);
+COND_SYSCALL(getgroups16);
+COND_SYSCALL(getresgid16);
+COND_SYSCALL(getresuid16);
+COND_SYSCALL(getuid16);
+COND_SYSCALL(lchown16);
+COND_SYSCALL(setfsgid16);
+COND_SYSCALL(setfsuid16);
+COND_SYSCALL(setgid16);
+COND_SYSCALL(setgroups16);
+COND_SYSCALL(setregid16);
+COND_SYSCALL(setresgid16);
+COND_SYSCALL(setresuid16);
+COND_SYSCALL(setreuid16);
+COND_SYSCALL(setuid16);

commit 70dd4b3160798b647b7f30baf9fb6e8a5933d4e2
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 6 19:53:01 2018 +0100

    kernel/sys_ni: sort cond_syscall() entries
    
    Shuffle the cond_syscall() entries in kernel/sys_ni.c around so that they
    are kept in the same order as in include/uapi/asm-generic/unistd.h. For
    better structuring, add the same comments as in that file, but keep a few
    additional comments and extend the commentary where it seems useful.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 951dbda5c2b4..0c1538f5a559 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -17,245 +17,403 @@ asmlinkage long sys_ni_syscall(void)
 	return -ENOSYS;
 }
 
-cond_syscall(sys_quotactl);
-cond_syscall(compat_sys_quotactl32);
-cond_syscall(sys_acct);
+/*
+ * This list is kept in the same order as include/uapi/asm-generic/unistd.h.
+ * Architecture specific entries go below, followed by deprecated or obsolete
+ * system calls.
+ */
+
+cond_syscall(sys_io_setup);
+cond_syscall(compat_sys_io_setup);
+cond_syscall(sys_io_destroy);
+cond_syscall(sys_io_submit);
+cond_syscall(compat_sys_io_submit);
+cond_syscall(sys_io_cancel);
+cond_syscall(sys_io_getevents);
+cond_syscall(compat_sys_io_getevents);
+
+/* fs/xattr.c */
+
+/* fs/dcache.c */
+
+/* fs/cookies.c */
 cond_syscall(sys_lookup_dcookie);
 cond_syscall(compat_sys_lookup_dcookie);
-cond_syscall(sys_swapon);
-cond_syscall(sys_swapoff);
+
+/* fs/eventfd.c */
+cond_syscall(sys_eventfd2);
+
+/* fs/eventfd.c */
+cond_syscall(sys_epoll_create1);
+cond_syscall(sys_epoll_ctl);
+cond_syscall(sys_epoll_pwait);
+cond_syscall(compat_sys_epoll_pwait);
+
+/* fs/fcntl.c */
+
+/* fs/inotify_user.c */
+cond_syscall(sys_inotify_init1);
+cond_syscall(sys_inotify_add_watch);
+cond_syscall(sys_inotify_rm_watch);
+
+/* fs/ioctl.c */
+
+/* fs/ioprio.c */
+cond_syscall(sys_ioprio_set);
+cond_syscall(sys_ioprio_get);
+
+/* fs/locks.c */
+cond_syscall(sys_flock);
+
+/* fs/namei.c */
+
+/* fs/namespace.c */
+
+/* fs/nfsctl.c */
+
+/* fs/open.c */
+
+/* fs/pipe.c */
+
+/* fs/quota.c */
+cond_syscall(sys_quotactl);
+
+/* fs/readdir.c */
+
+/* fs/read_write.c */
+
+/* fs/sendfile.c */
+
+/* fs/select.c */
+
+/* fs/signalfd.c */
+cond_syscall(sys_signalfd4);
+cond_syscall(compat_sys_signalfd4);
+
+/* fs/splice.c */
+
+/* fs/stat.c */
+
+/* fs/sync.c */
+
+/* fs/timerfd.c */
+cond_syscall(sys_timerfd_create);
+cond_syscall(sys_timerfd_settime);
+cond_syscall(compat_sys_timerfd_settime);
+cond_syscall(sys_timerfd_gettime);
+cond_syscall(compat_sys_timerfd_gettime);
+
+/* fs/utimes.c */
+
+/* kernel/acct.c */
+cond_syscall(sys_acct);
+
+/* kernel/capability.c */
+cond_syscall(sys_capget);
+cond_syscall(sys_capset);
+
+/* kernel/exec_domain.c */
+
+/* kernel/exit.c */
+
+/* kernel/fork.c */
+
+/* kernel/futex.c */
+cond_syscall(sys_futex);
+cond_syscall(compat_sys_futex);
+cond_syscall(sys_set_robust_list);
+cond_syscall(compat_sys_set_robust_list);
+cond_syscall(sys_get_robust_list);
+cond_syscall(compat_sys_get_robust_list);
+
+/* kernel/hrtimer.c */
+
+/* kernel/itimer.c */
+
+/* kernel/kexec.c */
 cond_syscall(sys_kexec_load);
 cond_syscall(compat_sys_kexec_load);
-cond_syscall(sys_kexec_file_load);
+
+/* kernel/module.c */
 cond_syscall(sys_init_module);
-cond_syscall(sys_finit_module);
 cond_syscall(sys_delete_module);
+
+/* kernel/posix-timers.c */
+
+/* kernel/printk.c */
+cond_syscall(sys_syslog);
+
+/* kernel/ptrace.c */
+
+/* kernel/sched/core.c */
+
+/* kernel/signal.c */
+
+/* kernel/sys.c */
+cond_syscall(sys_setregid);
+cond_syscall(sys_setgid);
+cond_syscall(sys_setreuid);
+cond_syscall(sys_setuid);
+cond_syscall(sys_setresuid);
+cond_syscall(sys_getresuid);
+cond_syscall(sys_setresgid);
+cond_syscall(sys_getresgid);
+cond_syscall(sys_setfsuid);
+cond_syscall(sys_setfsgid);
+cond_syscall(sys_setgroups);
+cond_syscall(sys_getgroups);
+
+/* kernel/time.c */
+
+/* kernel/timer.c */
+
+/* ipc/mqueue.c */
+cond_syscall(sys_mq_open);
+cond_syscall(compat_sys_mq_open);
+cond_syscall(sys_mq_unlink);
+cond_syscall(sys_mq_timedsend);
+cond_syscall(compat_sys_mq_timedsend);
+cond_syscall(sys_mq_timedreceive);
+cond_syscall(compat_sys_mq_timedreceive);
+cond_syscall(sys_mq_notify);
+cond_syscall(compat_sys_mq_notify);
+cond_syscall(sys_mq_getsetattr);
+cond_syscall(compat_sys_mq_getsetattr);
+
+/* ipc/msg.c */
+cond_syscall(sys_msgget);
+cond_syscall(sys_msgctl);
+cond_syscall(compat_sys_msgctl);
+cond_syscall(sys_msgrcv);
+cond_syscall(compat_sys_msgrcv);
+cond_syscall(sys_msgsnd);
+cond_syscall(compat_sys_msgsnd);
+
+/* ipc/sem.c */
+cond_syscall(sys_semget);
+cond_syscall(sys_semctl);
+cond_syscall(compat_sys_semctl);
+cond_syscall(sys_semtimedop);
+cond_syscall(compat_sys_semtimedop);
+cond_syscall(sys_semop);
+
+/* ipc/shm.c */
+cond_syscall(sys_shmget);
+cond_syscall(sys_shmctl);
+cond_syscall(compat_sys_shmctl);
+cond_syscall(sys_shmat);
+cond_syscall(compat_sys_shmat);
+cond_syscall(sys_shmdt);
+
+/* net/socket.c */
+cond_syscall(sys_socket);
 cond_syscall(sys_socketpair);
 cond_syscall(sys_bind);
 cond_syscall(sys_listen);
 cond_syscall(sys_accept);
-cond_syscall(sys_accept4);
 cond_syscall(sys_connect);
 cond_syscall(sys_getsockname);
 cond_syscall(sys_getpeername);
-cond_syscall(sys_sendto);
-cond_syscall(sys_send);
-cond_syscall(sys_recvfrom);
-cond_syscall(sys_recv);
-cond_syscall(sys_socket);
 cond_syscall(sys_setsockopt);
 cond_syscall(compat_sys_setsockopt);
 cond_syscall(sys_getsockopt);
 cond_syscall(compat_sys_getsockopt);
+cond_syscall(sys_sendto);
 cond_syscall(sys_shutdown);
+cond_syscall(sys_recvfrom);
+cond_syscall(compat_sys_recvfrom);
 cond_syscall(sys_sendmsg);
-cond_syscall(sys_sendmmsg);
 cond_syscall(compat_sys_sendmsg);
-cond_syscall(compat_sys_sendmmsg);
 cond_syscall(sys_recvmsg);
-cond_syscall(sys_recvmmsg);
 cond_syscall(compat_sys_recvmsg);
-cond_syscall(compat_sys_recv);
-cond_syscall(compat_sys_recvfrom);
-cond_syscall(compat_sys_recvmmsg);
-cond_syscall(sys_socketcall);
-cond_syscall(sys_futex);
-cond_syscall(compat_sys_futex);
-cond_syscall(sys_set_robust_list);
-cond_syscall(compat_sys_set_robust_list);
-cond_syscall(sys_get_robust_list);
-cond_syscall(compat_sys_get_robust_list);
-cond_syscall(sys_epoll_create);
-cond_syscall(sys_epoll_create1);
-cond_syscall(sys_epoll_ctl);
-cond_syscall(sys_epoll_wait);
-cond_syscall(sys_epoll_pwait);
-cond_syscall(compat_sys_epoll_pwait);
-cond_syscall(sys_semget);
-cond_syscall(sys_semop);
-cond_syscall(sys_semtimedop);
-cond_syscall(compat_sys_semtimedop);
-cond_syscall(sys_semctl);
-cond_syscall(compat_sys_semctl);
-cond_syscall(sys_msgget);
-cond_syscall(sys_msgsnd);
-cond_syscall(compat_sys_msgsnd);
-cond_syscall(sys_msgrcv);
-cond_syscall(compat_sys_msgrcv);
-cond_syscall(sys_msgctl);
-cond_syscall(compat_sys_msgctl);
-cond_syscall(sys_shmget);
-cond_syscall(sys_shmat);
-cond_syscall(compat_sys_shmat);
-cond_syscall(sys_shmdt);
-cond_syscall(sys_shmctl);
-cond_syscall(compat_sys_shmctl);
-cond_syscall(sys_mq_open);
-cond_syscall(sys_mq_unlink);
-cond_syscall(sys_mq_timedsend);
-cond_syscall(sys_mq_timedreceive);
-cond_syscall(sys_mq_notify);
-cond_syscall(sys_mq_getsetattr);
-cond_syscall(compat_sys_mq_open);
-cond_syscall(compat_sys_mq_timedsend);
-cond_syscall(compat_sys_mq_timedreceive);
-cond_syscall(compat_sys_mq_notify);
-cond_syscall(compat_sys_mq_getsetattr);
-cond_syscall(sys_mbind);
-cond_syscall(sys_get_mempolicy);
-cond_syscall(sys_set_mempolicy);
-cond_syscall(compat_sys_mbind);
-cond_syscall(compat_sys_get_mempolicy);
-cond_syscall(compat_sys_set_mempolicy);
+
+/* mm/filemap.c */
+
+/* mm/nommu.c, also with MMU */
+cond_syscall(sys_mremap);
+
+/* security/keys/keyctl.c */
 cond_syscall(sys_add_key);
 cond_syscall(sys_request_key);
 cond_syscall(sys_keyctl);
 cond_syscall(compat_sys_keyctl);
-cond_syscall(compat_sys_socketcall);
-cond_syscall(sys_inotify_init);
-cond_syscall(sys_inotify_init1);
-cond_syscall(sys_inotify_add_watch);
-cond_syscall(sys_inotify_rm_watch);
-cond_syscall(sys_migrate_pages);
-cond_syscall(sys_move_pages);
-cond_syscall(sys_chown16);
-cond_syscall(sys_fchown16);
-cond_syscall(sys_getegid16);
-cond_syscall(sys_geteuid16);
-cond_syscall(sys_getgid16);
-cond_syscall(sys_getgroups16);
-cond_syscall(sys_getresgid16);
-cond_syscall(sys_getresuid16);
-cond_syscall(sys_getuid16);
-cond_syscall(sys_lchown16);
-cond_syscall(sys_setfsgid16);
-cond_syscall(sys_setfsuid16);
-cond_syscall(sys_setgid16);
-cond_syscall(sys_setgroups16);
-cond_syscall(sys_setregid16);
-cond_syscall(sys_setresgid16);
-cond_syscall(sys_setresuid16);
-cond_syscall(sys_setreuid16);
-cond_syscall(sys_setuid16);
-cond_syscall(sys_sgetmask);
-cond_syscall(sys_ssetmask);
-cond_syscall(sys_vm86old);
-cond_syscall(sys_vm86);
-cond_syscall(sys_modify_ldt);
-cond_syscall(sys_ipc);
-cond_syscall(compat_sys_ipc);
-cond_syscall(compat_sys_sysctl);
-cond_syscall(sys_flock);
-cond_syscall(sys_io_setup);
-cond_syscall(sys_io_destroy);
-cond_syscall(sys_io_submit);
-cond_syscall(sys_io_cancel);
-cond_syscall(sys_io_getevents);
-cond_syscall(compat_sys_io_setup);
-cond_syscall(compat_sys_io_submit);
-cond_syscall(compat_sys_io_getevents);
-cond_syscall(sys_sysfs);
-cond_syscall(sys_syslog);
-cond_syscall(sys_process_vm_readv);
-cond_syscall(sys_process_vm_writev);
-cond_syscall(compat_sys_process_vm_readv);
-cond_syscall(compat_sys_process_vm_writev);
-cond_syscall(sys_uselib);
-cond_syscall(sys_fadvise64);
-cond_syscall(sys_fadvise64_64);
-cond_syscall(sys_madvise);
-cond_syscall(sys_setuid);
-cond_syscall(sys_setregid);
-cond_syscall(sys_setgid);
-cond_syscall(sys_setreuid);
-cond_syscall(sys_setresuid);
-cond_syscall(sys_getresuid);
-cond_syscall(sys_setresgid);
-cond_syscall(sys_getresgid);
-cond_syscall(sys_setgroups);
-cond_syscall(sys_getgroups);
-cond_syscall(sys_setfsuid);
-cond_syscall(sys_setfsgid);
-cond_syscall(sys_capget);
-cond_syscall(sys_capset);
-cond_syscall(sys_copy_file_range);
 
-/* arch-specific weak syscall entries */
-cond_syscall(sys_pciconfig_read);
-cond_syscall(sys_pciconfig_write);
-cond_syscall(sys_pciconfig_iobase);
-cond_syscall(compat_sys_s390_ipc);
-cond_syscall(ppc_rtas);
-cond_syscall(sys_spu_run);
-cond_syscall(sys_spu_create);
-cond_syscall(sys_subpage_prot);
-cond_syscall(sys_s390_pci_mmio_read);
-cond_syscall(sys_s390_pci_mmio_write);
+/* arch/example/kernel/sys_example.c */
 
-/* mmu depending weak syscall entries */
+/* mm/fadvise.c */
+cond_syscall(sys_fadvise64_64);
+
+/* mm/, CONFIG_MMU only */
+cond_syscall(sys_swapon);
+cond_syscall(sys_swapoff);
 cond_syscall(sys_mprotect);
 cond_syscall(sys_msync);
 cond_syscall(sys_mlock);
 cond_syscall(sys_munlock);
 cond_syscall(sys_mlockall);
 cond_syscall(sys_munlockall);
-cond_syscall(sys_mlock2);
 cond_syscall(sys_mincore);
 cond_syscall(sys_madvise);
-cond_syscall(sys_mremap);
 cond_syscall(sys_remap_file_pages);
-cond_syscall(compat_sys_move_pages);
+cond_syscall(sys_mbind);
+cond_syscall(compat_sys_mbind);
+cond_syscall(sys_get_mempolicy);
+cond_syscall(compat_sys_get_mempolicy);
+cond_syscall(sys_set_mempolicy);
+cond_syscall(compat_sys_set_mempolicy);
+cond_syscall(sys_migrate_pages);
 cond_syscall(compat_sys_migrate_pages);
+cond_syscall(sys_move_pages);
+cond_syscall(compat_sys_move_pages);
 
-/* block-layer dependent */
-cond_syscall(sys_bdflush);
-cond_syscall(sys_ioprio_set);
-cond_syscall(sys_ioprio_get);
-
-/* New file descriptors */
-cond_syscall(sys_signalfd);
-cond_syscall(sys_signalfd4);
-cond_syscall(compat_sys_signalfd);
-cond_syscall(compat_sys_signalfd4);
-cond_syscall(sys_timerfd_create);
-cond_syscall(sys_timerfd_settime);
-cond_syscall(sys_timerfd_gettime);
-cond_syscall(compat_sys_timerfd_settime);
-cond_syscall(compat_sys_timerfd_gettime);
-cond_syscall(sys_eventfd);
-cond_syscall(sys_eventfd2);
-cond_syscall(sys_memfd_create);
-cond_syscall(sys_userfaultfd);
-
-/* performance counters: */
 cond_syscall(sys_perf_event_open);
+cond_syscall(sys_accept4);
+cond_syscall(sys_recvmmsg);
+cond_syscall(compat_sys_recvmmsg);
+
+/*
+ * Architecture specific syscalls: see further below
+ */
 
-/* fanotify! */
+/* fanotify */
 cond_syscall(sys_fanotify_init);
 cond_syscall(sys_fanotify_mark);
-cond_syscall(compat_sys_fanotify_mark);
 
 /* open by handle */
 cond_syscall(sys_name_to_handle_at);
 cond_syscall(sys_open_by_handle_at);
 cond_syscall(compat_sys_open_by_handle_at);
 
+cond_syscall(sys_sendmmsg);
+cond_syscall(compat_sys_sendmmsg);
+cond_syscall(sys_process_vm_readv);
+cond_syscall(compat_sys_process_vm_readv);
+cond_syscall(sys_process_vm_writev);
+cond_syscall(compat_sys_process_vm_writev);
+
 /* compare kernel pointers */
 cond_syscall(sys_kcmp);
 
+cond_syscall(sys_finit_module);
+
 /* operate on Secure Computing state */
 cond_syscall(sys_seccomp);
 
+cond_syscall(sys_memfd_create);
+
 /* access BPF programs and maps */
 cond_syscall(sys_bpf);
 
 /* execveat */
 cond_syscall(sys_execveat);
 
+cond_syscall(sys_userfaultfd);
+
 /* membarrier */
 cond_syscall(sys_membarrier);
 
+cond_syscall(sys_mlock2);
+
+cond_syscall(sys_copy_file_range);
+
 /* memory protection keys */
 cond_syscall(sys_pkey_mprotect);
 cond_syscall(sys_pkey_alloc);
 cond_syscall(sys_pkey_free);
+
+
+/*
+ * Architecture specific weak syscall entries.
+ */
+
+/* pciconfig: alpha, arm, arm64, ia64, sparc */
+cond_syscall(sys_pciconfig_read);
+cond_syscall(sys_pciconfig_write);
+cond_syscall(sys_pciconfig_iobase);
+
+/* sys_socketcall: arm, mips, x86, ... */
+cond_syscall(sys_socketcall);
+cond_syscall(compat_sys_socketcall);
+
+/* compat syscalls for arm64, x86, ... */
+cond_syscall(compat_sys_sysctl);
+cond_syscall(compat_sys_fanotify_mark);
+
+/* x86 */
+cond_syscall(sys_vm86old);
+cond_syscall(sys_modify_ldt);
+cond_syscall(compat_sys_quotactl32);
+cond_syscall(sys_vm86);
+cond_syscall(sys_kexec_file_load);
+
+/* s390 */
+cond_syscall(sys_s390_pci_mmio_read);
+cond_syscall(sys_s390_pci_mmio_write);
+cond_syscall(compat_sys_s390_ipc);
+
+/* powerpc */
+cond_syscall(ppc_rtas);
+cond_syscall(sys_spu_run);
+cond_syscall(sys_spu_create);
+cond_syscall(sys_subpage_prot);
+
+
+/*
+ * Deprecated system calls which are still defined in
+ * include/uapi/asm-generic/unistd.h and wanted by >= 1 arch
+ */
+
+/* __ARCH_WANT_SYSCALL_NO_FLAGS */
+cond_syscall(sys_epoll_create);
+cond_syscall(sys_inotify_init);
+cond_syscall(sys_eventfd);
+cond_syscall(sys_signalfd);
+cond_syscall(compat_sys_signalfd);
+
+/* __ARCH_WANT_SYSCALL_OFF_T */
+cond_syscall(sys_fadvise64);
+
+/* __ARCH_WANT_SYSCALL_DEPRECATED */
+cond_syscall(sys_epoll_wait);
+cond_syscall(sys_recv);
+cond_syscall(compat_sys_recv);
+cond_syscall(sys_send);
+cond_syscall(sys_bdflush);
+cond_syscall(sys_uselib);
+
+
+/*
+ * The syscalls below are not found in include/uapi/asm-generic/unistd.h
+ */
+
+/* obsolete: SGETMASK_SYSCALL */
+cond_syscall(sys_sgetmask);
+cond_syscall(sys_ssetmask);
+
+/* obsolete: SYSFS_SYSCALL */
+cond_syscall(sys_sysfs);
+
+/* obsolete: __ARCH_WANT_SYS_IPC */
+cond_syscall(sys_ipc);
+cond_syscall(compat_sys_ipc);
+
+/* obsolete: UID16 */
+cond_syscall(sys_chown16);
+cond_syscall(sys_fchown16);
+cond_syscall(sys_getegid16);
+cond_syscall(sys_geteuid16);
+cond_syscall(sys_getgid16);
+cond_syscall(sys_getgroups16);
+cond_syscall(sys_getresgid16);
+cond_syscall(sys_getresuid16);
+cond_syscall(sys_getuid16);
+cond_syscall(sys_lchown16);
+cond_syscall(sys_setfsgid16);
+cond_syscall(sys_setfsuid16);
+cond_syscall(sys_setgid16);
+cond_syscall(sys_setgroups16);
+cond_syscall(sys_setregid16);
+cond_syscall(sys_setresgid16);
+cond_syscall(sys_setresuid16);
+cond_syscall(sys_setreuid16);
+cond_syscall(sys_setuid16);

commit ab0d1e85bfd0c25260f02cd3708d5abdfb5b5a9c
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 4 21:54:05 2018 +0100

    fs/quota: use COMPAT_SYSCALL_DEFINE for sys32_quotactl()
    
    While sys32_quotactl() is only needed on x86, it can use the recommended
    COMPAT_SYSCALL_DEFINEx() machinery for its setup.
    
    Acked-by: Jan Kara <jack@suse.cz>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b5189762d275..951dbda5c2b4 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -18,7 +18,7 @@ asmlinkage long sys_ni_syscall(void)
 }
 
 cond_syscall(sys_quotactl);
-cond_syscall(sys32_quotactl);
+cond_syscall(compat_sys_quotactl32);
 cond_syscall(sys_acct);
 cond_syscall(sys_lookup_dcookie);
 cond_syscall(compat_sys_lookup_dcookie);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 8acef8576ce9..b5189762d275 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 
 #include <linux/linkage.h>
 #include <linux/errno.h>

commit c00d2c7e89880036f288a764599b2b8b87c0a364
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 20 07:04:57 2016 -0500

    move aio compat to fs/aio.c
    
    ... and fix the minor buglet in compat io_submit() - native one
    kills ioctx as cleanup when put_user() fails.  Get rid of
    bogus compat_... in !CONFIG_AIO case, while we are at it - they
    should simply fail with ENOSYS, same as for native counterparts.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 635482e60ca3..8acef8576ce9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -150,6 +150,9 @@ cond_syscall(sys_io_destroy);
 cond_syscall(sys_io_submit);
 cond_syscall(sys_io_cancel);
 cond_syscall(sys_io_getevents);
+cond_syscall(compat_sys_io_setup);
+cond_syscall(compat_sys_io_submit);
+cond_syscall(compat_sys_io_getevents);
 cond_syscall(sys_sysfs);
 cond_syscall(sys_syslog);
 cond_syscall(sys_process_vm_readv);

commit e2753293ac4bce8623650bb2d610b7e657bc869f
Author: Dave Hansen <dave.hansen@intel.com>
Date:   Mon Sep 12 13:38:42 2016 -0700

    x86/pkeys: Fix pkeys build breakage for some non-x86 arches
    
    Guenter Roeck reported breakage on the h8300 and c6x architectures (among
    others) caused by the new memory protection keys syscalls.  This patch does
    what Arnd suggested and adds them to kernel/sys_ni.c.
    
    Fixes: a60f7b69d92c ("generic syscalls: Wire up memory protection keys syscalls")
    Reported-and-tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dave Hansen <dave.hansen@intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-arch@vger.kernel.org
    Cc: Dave Hansen <dave@sr71.net>
    Cc: linux-api@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160912203842.48E7AC50@viggo.jf.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 2c5e3a8e00d7..635482e60ca3 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -250,3 +250,8 @@ cond_syscall(sys_execveat);
 
 /* membarrier */
 cond_syscall(sys_membarrier);
+
+/* memory protection keys */
+cond_syscall(sys_pkey_mprotect);
+cond_syscall(sys_pkey_alloc);
+cond_syscall(sys_pkey_free);

commit 29732938a6289a15e907da234d6692a2ead71855
Author: Zach Brown <zab@redhat.com>
Date:   Tue Nov 10 16:53:30 2015 -0500

    vfs: add copy_file_range syscall and vfs helper
    
    Add a copy_file_range() system call for offloading copies between
    regular files.
    
    This gives an interface to underlying layers of the storage stack which
    can copy without reading and writing all the data.  There are a few
    candidates that should support copy offloading in the nearer term:
    
    - btrfs shares extent references with its clone ioctl
    - NFS has patches to add a COPY command which copies on the server
    - SCSI has a family of XCOPY commands which copy in the device
    
    This system call avoids the complexity of also accelerating the creation
    of the destination file by operating on an existing destination file
    descriptor, not a path.
    
    Currently the high level vfs entry point limits copy offloading to files
    on the same mount and super (and not in the same file).  This can be
    relaxed if we get implementations which can copy between file systems
    safely.
    
    Signed-off-by: Zach Brown <zab@redhat.com>
    [Anna Schumaker: Change -EINVAL to -EBADF during file verification,
                     Change flags parameter from int to unsigned int,
                     Add function to include/linux/syscalls.h,
                     Check copy len after file open mode,
                     Don't forbid ranges inside the same file,
                     Use rw_verify_area() to veriy ranges,
                     Use file_out rather than file_in,
                     Add COPY_FR_REFLINK flag]
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0623787ec67a..2c5e3a8e00d7 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -174,6 +174,7 @@ cond_syscall(sys_setfsuid);
 cond_syscall(sys_setfsgid);
 cond_syscall(sys_capget);
 cond_syscall(sys_capset);
+cond_syscall(sys_copy_file_range);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
Author: Eric B Munson <emunson@akamai.com>
Date:   Thu Nov 5 18:51:33 2015 -0800

    mm: mlock: add new mlock system call
    
    With the refactored mlock code, introduce a new system call for mlock.
    The new call will allow the user to specify what lock states are being
    added.  mlock2 is trivial at the moment, but a follow on patch will add a
    new mlock state making it useful.
    
    Signed-off-by: Eric B Munson <emunson@akamai.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index a02decf15583..0623787ec67a 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -194,6 +194,7 @@ cond_syscall(sys_mlock);
 cond_syscall(sys_munlock);
 cond_syscall(sys_mlockall);
 cond_syscall(sys_munlockall);
+cond_syscall(sys_mlock2);
 cond_syscall(sys_mincore);
 cond_syscall(sys_madvise);
 cond_syscall(sys_mremap);

commit 5b25b13ab08f616efd566347d809b4ece54570d1
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Fri Sep 11 13:07:39 2015 -0700

    sys_membarrier(): system-wide memory barrier (generic, x86)
    
    Here is an implementation of a new system call, sys_membarrier(), which
    executes a memory barrier on all threads running on the system.  It is
    implemented by calling synchronize_sched().  It can be used to
    distribute the cost of user-space memory barriers asymmetrically by
    transforming pairs of memory barriers into pairs consisting of
    sys_membarrier() and a compiler barrier.  For synchronization primitives
    that distinguish between read-side and write-side (e.g.  userspace RCU
    [1], rwlocks), the read-side can be accelerated significantly by moving
    the bulk of the memory barrier overhead to the write-side.
    
    The existing applications of which I am aware that would be improved by
    this system call are as follows:
    
    * Through Userspace RCU library (http://urcu.so)
      - DNS server (Knot DNS) https://www.knot-dns.cz/
      - Network sniffer (http://netsniff-ng.org/)
      - Distributed object storage (https://sheepdog.github.io/sheepdog/)
      - User-space tracing (http://lttng.org)
      - Network storage system (https://www.gluster.org/)
      - Virtual routers (https://events.linuxfoundation.org/sites/events/files/slides/DPDK_RCU_0MQ.pdf)
      - Financial software (https://lkml.org/lkml/2015/3/23/189)
    
    Those projects use RCU in userspace to increase read-side speed and
    scalability compared to locking.  Especially in the case of RCU used by
    libraries, sys_membarrier can speed up the read-side by moving the bulk of
    the memory barrier cost to synchronize_rcu().
    
    * Direct users of sys_membarrier
      - core dotnet garbage collector (https://github.com/dotnet/coreclr/issues/198)
    
    Microsoft core dotnet GC developers are planning to use the mprotect()
    side-effect of issuing memory barriers through IPIs as a way to implement
    Windows FlushProcessWriteBuffers() on Linux.  They are referring to
    sys_membarrier in their github thread, specifically stating that
    sys_membarrier() is what they are looking for.
    
    To explain the benefit of this scheme, let's introduce two example threads:
    
    Thread A (non-frequent, e.g. executing liburcu synchronize_rcu())
    Thread B (frequent, e.g. executing liburcu
    rcu_read_lock()/rcu_read_unlock())
    
    In a scheme where all smp_mb() in thread A are ordering memory accesses
    with respect to smp_mb() present in Thread B, we can change each
    smp_mb() within Thread A into calls to sys_membarrier() and each
    smp_mb() within Thread B into compiler barriers "barrier()".
    
    Before the change, we had, for each smp_mb() pairs:
    
    Thread A                    Thread B
    previous mem accesses       previous mem accesses
    smp_mb()                    smp_mb()
    following mem accesses      following mem accesses
    
    After the change, these pairs become:
    
    Thread A                    Thread B
    prev mem accesses           prev mem accesses
    sys_membarrier()            barrier()
    follow mem accesses         follow mem accesses
    
    As we can see, there are two possible scenarios: either Thread B memory
    accesses do not happen concurrently with Thread A accesses (1), or they
    do (2).
    
    1) Non-concurrent Thread A vs Thread B accesses:
    
    Thread A                    Thread B
    prev mem accesses
    sys_membarrier()
    follow mem accesses
                                prev mem accesses
                                barrier()
                                follow mem accesses
    
    In this case, thread B accesses will be weakly ordered. This is OK,
    because at that point, thread A is not particularly interested in
    ordering them with respect to its own accesses.
    
    2) Concurrent Thread A vs Thread B accesses
    
    Thread A                    Thread B
    prev mem accesses           prev mem accesses
    sys_membarrier()            barrier()
    follow mem accesses         follow mem accesses
    
    In this case, thread B accesses, which are ensured to be in program
    order thanks to the compiler barrier, will be "upgraded" to full
    smp_mb() by synchronize_sched().
    
    * Benchmarks
    
    On Intel Xeon E5405 (8 cores)
    (one thread is calling sys_membarrier, the other 7 threads are busy
    looping)
    
    1000 non-expedited sys_membarrier calls in 33s =3D 33 milliseconds/call.
    
    * User-space user of this system call: Userspace RCU library
    
    Both the signal-based and the sys_membarrier userspace RCU schemes
    permit us to remove the memory barrier from the userspace RCU
    rcu_read_lock() and rcu_read_unlock() primitives, thus significantly
    accelerating them. These memory barriers are replaced by compiler
    barriers on the read-side, and all matching memory barriers on the
    write-side are turned into an invocation of a memory barrier on all
    active threads in the process. By letting the kernel perform this
    synchronization rather than dumbly sending a signal to every process
    threads (as we currently do), we diminish the number of unnecessary wake
    ups and only issue the memory barriers on active threads. Non-running
    threads do not need to execute such barrier anyway, because these are
    implied by the scheduler context switches.
    
    Results in liburcu:
    
    Operations in 10s, 6 readers, 2 writers:
    
    memory barriers in reader:    1701557485 reads, 2202847 writes
    signal-based scheme:          9830061167 reads,    6700 writes
    sys_membarrier:               9952759104 reads,     425 writes
    sys_membarrier (dyn. check):  7970328887 reads,     425 writes
    
    The dynamic sys_membarrier availability check adds some overhead to
    the read-side compared to the signal-based scheme, but besides that,
    sys_membarrier slightly outperforms the signal-based scheme. However,
    this non-expedited sys_membarrier implementation has a much slower grace
    period than signal and memory barrier schemes.
    
    Besides diminishing the number of wake-ups, one major advantage of the
    membarrier system call over the signal-based scheme is that it does not
    need to reserve a signal. This plays much more nicely with libraries,
    and with processes injected into for tracing purposes, for which we
    cannot expect that signals will be unused by the application.
    
    An expedited version of this system call can be added later on to speed
    up the grace period. Its implementation will likely depend on reading
    the cpu_curr()->mm without holding each CPU's rq lock.
    
    This patch adds the system call to x86 and to asm-generic.
    
    [1] http://urcu.so
    
    membarrier(2) man page:
    
    MEMBARRIER(2)              Linux Programmer's Manual             MEMBARRIER(2)
    
    NAME
           membarrier - issue memory barriers on a set of threads
    
    SYNOPSIS
           #include <linux/membarrier.h>
    
           int membarrier(int cmd, int flags);
    
    DESCRIPTION
           The cmd argument is one of the following:
    
           MEMBARRIER_CMD_QUERY
                  Query  the  set  of  supported commands. It returns a bitmask of
                  supported commands.
    
           MEMBARRIER_CMD_SHARED
                  Execute a memory barrier on all threads running on  the  system.
                  Upon  return from system call, the caller thread is ensured that
                  all running threads have passed through a state where all memory
                  accesses  to  user-space  addresses  match program order between
                  entry to and return from the system  call  (non-running  threads
                  are de facto in such a state). This covers threads from all pro=E2=80=90
                  cesses running on the system.  This command returns 0.
    
           The flags argument needs to be 0. For future extensions.
    
           All memory accesses performed  in  program  order  from  each  targeted
           thread is guaranteed to be ordered with respect to sys_membarrier(). If
           we use the semantic "barrier()" to represent a compiler barrier forcing
           memory  accesses  to  be performed in program order across the barrier,
           and smp_mb() to represent explicit memory barriers forcing full  memory
           ordering  across  the barrier, we have the following ordering table for
           each pair of barrier(), sys_membarrier() and smp_mb():
    
           The pair ordering is detailed as (O: ordered, X: not ordered):
    
                                  barrier()   smp_mb() sys_membarrier()
                  barrier()          X           X            O
                  smp_mb()           X           O            O
                  sys_membarrier()   O           O            O
    
    RETURN VALUE
           On success, these system calls return zero.  On error, -1 is  returned,
           and errno is set appropriately. For a given command, with flags
           argument set to 0, this system call is guaranteed to always return the
           same value until reboot.
    
    ERRORS
           ENOSYS System call is not implemented.
    
           EINVAL Invalid arguments.
    
    Linux                             2015-04-15                     MEMBARRIER(2)
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Nicholas Miell <nmiell@comcast.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Pranith Kumar <bobby.prani@gmail.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 03c3875d9958..a02decf15583 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -245,3 +245,6 @@ cond_syscall(sys_bpf);
 
 /* execveat */
 cond_syscall(sys_execveat);
+
+/* membarrier */
+cond_syscall(sys_membarrier);

commit 1380fca084743fef8d17e59b273473393944ce58
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Sep 4 15:46:58 2015 -0700

    userfaultfd: activate syscall
    
    This activates the userfaultfd syscall.
    
    [sfr@canb.auug.org.au: activate syscall fix]
    [akpm@linux-foundation.org: don't enable userfaultfd on powerpc]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Acked-by: Pavel Emelyanov <xemul@parallels.com>
    Cc: Sanidhya Kashyap <sanidhya.gatech@gmail.com>
    Cc: zhang.zhanghailiang@huawei.com
    Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
    Cc: Andres Lagar-Cavilla <andreslc@google.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Peter Feiner <pfeiner@google.com>
    Cc: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: "Huangpeng (Peter)" <peter.huangpeng@huawei.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index ca7d84f438f1..03c3875d9958 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -219,6 +219,7 @@ cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);
 cond_syscall(sys_eventfd2);
 cond_syscall(sys_memfd_create);
+cond_syscall(sys_userfaultfd);
 
 /* performance counters: */
 cond_syscall(sys_perf_event_open);

commit a5b9e5a2f14f25a8dae987494d50ad3aac7366b6
Author: Andy Lutomirski <luto@kernel.org>
Date:   Thu Jul 30 14:31:34 2015 -0700

    x86/ldt: Make modify_ldt() optional
    
    The modify_ldt syscall exposes a large attack surface and is
    unnecessary for modern userspace.  Make it optional.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Cooper <andrew.cooper3@citrix.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jan Beulich <jbeulich@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: security@kernel.org <security@kernel.org>
    Cc: xen-devel <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/a605166a771c343fd64802dece77a903507333bd.1438291540.git.luto@kernel.org
    [ Made MATH_EMULATION dependent on MODIFY_LDT_SYSCALL. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7995ef5868d8..ca7d84f438f1 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -140,6 +140,7 @@ cond_syscall(sys_sgetmask);
 cond_syscall(sys_ssetmask);
 cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
+cond_syscall(sys_modify_ldt);
 cond_syscall(sys_ipc);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);

commit 2813893f8b197a14f1e1ddb04d99bce46817c84a
Author: Iulia Manda <iulia.manda21@gmail.com>
Date:   Wed Apr 15 16:16:41 2015 -0700

    kernel: conditionally support non-root users, groups and capabilities
    
    There are a lot of embedded systems that run most or all of their
    functionality in init, running as root:root.  For these systems,
    supporting multiple users is not necessary.
    
    This patch adds a new symbol, CONFIG_MULTIUSER, that makes support for
    non-root users, non-root groups, and capabilities optional.  It is enabled
    under CONFIG_EXPERT menu.
    
    When this symbol is not defined, UID and GID are zero in any possible case
    and processes always have all capabilities.
    
    The following syscalls are compiled out: setuid, setregid, setgid,
    setreuid, setresuid, getresuid, setresgid, getresgid, setgroups,
    getgroups, setfsuid, setfsgid, capget, capset.
    
    Also, groups.c is compiled out completely.
    
    In kernel/capability.c, capable function was moved in order to avoid
    adding two ifdef blocks.
    
    This change saves about 25 KB on a defconfig build.  The most minimal
    kernels have total text sizes in the high hundreds of kB rather than
    low MB.  (The 25k goes down a bit with allnoconfig, but not that much.
    
    The kernel was booted in Qemu.  All the common functionalities work.
    Adding users/groups is not possible, failing with -ENOSYS.
    
    Bloat-o-meter output:
    add/remove: 7/87 grow/shrink: 19/397 up/down: 1675/-26325 (-24650)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Iulia Manda <iulia.manda21@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 5adcb0ae3a58..7995ef5868d8 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -159,6 +159,20 @@ cond_syscall(sys_uselib);
 cond_syscall(sys_fadvise64);
 cond_syscall(sys_fadvise64_64);
 cond_syscall(sys_madvise);
+cond_syscall(sys_setuid);
+cond_syscall(sys_setregid);
+cond_syscall(sys_setgid);
+cond_syscall(sys_setreuid);
+cond_syscall(sys_setresuid);
+cond_syscall(sys_getresuid);
+cond_syscall(sys_setresgid);
+cond_syscall(sys_getresgid);
+cond_syscall(sys_setgroups);
+cond_syscall(sys_getgroups);
+cond_syscall(sys_setfsuid);
+cond_syscall(sys_setfsgid);
+cond_syscall(sys_capget);
+cond_syscall(sys_capset);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
Author: David Drysdale <drysdale@google.com>
Date:   Fri Dec 12 16:57:29 2014 -0800

    syscalls: implement execveat() system call
    
    This patchset adds execveat(2) for x86, and is derived from Meredydd
    Luff's patch from Sept 2012 (https://lkml.org/lkml/2012/9/11/528).
    
    The primary aim of adding an execveat syscall is to allow an
    implementation of fexecve(3) that does not rely on the /proc filesystem,
    at least for executables (rather than scripts).  The current glibc version
    of fexecve(3) is implemented via /proc, which causes problems in sandboxed
    or otherwise restricted environments.
    
    Given the desire for a /proc-free fexecve() implementation, HPA suggested
    (https://lkml.org/lkml/2006/7/11/556) that an execveat(2) syscall would be
    an appropriate generalization.
    
    Also, having a new syscall means that it can take a flags argument without
    back-compatibility concerns.  The current implementation just defines the
    AT_EMPTY_PATH and AT_SYMLINK_NOFOLLOW flags, but other flags could be
    added in future -- for example, flags for new namespaces (as suggested at
    https://lkml.org/lkml/2006/7/11/474).
    
    Related history:
     - https://lkml.org/lkml/2006/12/27/123 is an example of someone
       realizing that fexecve() is likely to fail in a chroot environment.
     - http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=514043 covered
       documenting the /proc requirement of fexecve(3) in its manpage, to
       "prevent other people from wasting their time".
     - https://bugzilla.redhat.com/show_bug.cgi?id=241609 described a
       problem where a process that did setuid() could not fexecve()
       because it no longer had access to /proc/self/fd; this has since
       been fixed.
    
    This patch (of 4):
    
    Add a new execveat(2) system call.  execveat() is to execve() as openat()
    is to open(): it takes a file descriptor that refers to a directory, and
    resolves the filename relative to that.
    
    In addition, if the filename is empty and AT_EMPTY_PATH is specified,
    execveat() executes the file to which the file descriptor refers.  This
    replicates the functionality of fexecve(), which is a system call in other
    UNIXen, but in Linux glibc it depends on opening "/proc/self/fd/<fd>" (and
    so relies on /proc being mounted).
    
    The filename fed to the executed program as argv[0] (or the name of the
    script fed to a script interpreter) will be of the form "/dev/fd/<fd>"
    (for an empty filename) or "/dev/fd/<fd>/<filename>", effectively
    reflecting how the executable was found.  This does however mean that
    execution of a script in a /proc-less environment won't work; also, script
    execution via an O_CLOEXEC file descriptor fails (as the file will not be
    accessible after exec).
    
    Based on patches by Meredydd Luff.
    
    Signed-off-by: David Drysdale <drysdale@google.com>
    Cc: Meredydd Luff <meredydd@senatehouse.org>
    Cc: Shuah Khan <shuah.kh@samsung.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rich Felker <dalias@aerifal.cx>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 61eea02b53f5..5adcb0ae3a58 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -226,3 +226,6 @@ cond_syscall(sys_seccomp);
 
 /* access BPF programs and maps */
 cond_syscall(sys_bpf);
+
+/* execveat */
+cond_syscall(sys_execveat);

commit 4eafad7febd482092b331ea72c37274d745956be
Author: Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
Date:   Fri Nov 14 14:27:58 2014 +0100

    s390/kernel: add system calls for PCI memory access
    
    Add the new __NR_s390_pci_mmio_write and __NR_s390_pci_mmio_read
    system calls to allow user space applications to access device PCI I/O
    memory pages on s390x platform.
    
    [ Martin Schwidefsky: some code beautification ]
    
    Signed-off-by: Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 02aa4185b17e..61eea02b53f5 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -169,6 +169,8 @@ cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);
 cond_syscall(sys_subpage_prot);
+cond_syscall(sys_s390_pci_mmio_read);
+cond_syscall(sys_s390_pci_mmio_write);
 
 /* mmu depending weak syscall entries */
 cond_syscall(sys_mprotect);

commit 35a9ad8af0bb0fa3525e6d0d20e32551d226f38e
Merge: d5935b07da53 64b1f00a0830
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 21:40:54 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Most notable changes in here:
    
       1) By far the biggest accomplishment, thanks to a large range of
          contributors, is the addition of multi-send for transmit.  This is
          the result of discussions back in Chicago, and the hard work of
          several individuals.
    
          Now, when the ->ndo_start_xmit() method of a driver sees
          skb->xmit_more as true, it can choose to defer the doorbell
          telling the driver to start processing the new TX queue entires.
    
          skb->xmit_more means that the generic networking is guaranteed to
          call the driver immediately with another SKB to send.
    
          There is logic added to the qdisc layer to dequeue multiple
          packets at a time, and the handling mis-predicted offloads in
          software is now done with no locks held.
    
          Finally, pktgen is extended to have a "burst" parameter that can
          be used to test a multi-send implementation.
    
          Several drivers have xmit_more support: i40e, igb, ixgbe, mlx4,
          virtio_net
    
          Adding support is almost trivial, so export more drivers to
          support this optimization soon.
    
          I want to thank, in no particular or implied order, Jesper
          Dangaard Brouer, Eric Dumazet, Alexander Duyck, Tom Herbert, Jamal
          Hadi Salim, John Fastabend, Florian Westphal, Daniel Borkmann,
          David Tat, Hannes Frederic Sowa, and Rusty Russell.
    
       2) PTP and timestamping support in bnx2x, from Michal Kalderon.
    
       3) Allow adjusting the rx_copybreak threshold for a driver via
          ethtool, and add rx_copybreak support to enic driver.  From
          Govindarajulu Varadarajan.
    
       4) Significant enhancements to the generic PHY layer and the bcm7xxx
          driver in particular (EEE support, auto power down, etc.) from
          Florian Fainelli.
    
       5) Allow raw buffers to be used for flow dissection, allowing drivers
          to determine the optimal "linear pull" size for devices that DMA
          into pools of pages.  The objective is to get exactly the
          necessary amount of headers into the linear SKB area pre-pulled,
          but no more.  The new interface drivers use is eth_get_headlen().
          From WANG Cong, with driver conversions (several had their own
          by-hand duplicated implementations) by Alexander Duyck and Eric
          Dumazet.
    
       6) Support checksumming more smoothly and efficiently for
          encapsulations, and add "foo over UDP" facility.  From Tom
          Herbert.
    
       7) Add Broadcom SF2 switch driver to DSA layer, from Florian
          Fainelli.
    
       8) eBPF now can load programs via a system call and has an extensive
          testsuite.  Alexei Starovoitov and Daniel Borkmann.
    
       9) Major overhaul of the packet scheduler to use RCU in several major
          areas such as the classifiers and rate estimators.  From John
          Fastabend.
    
      10) Add driver for Intel FM10000 Ethernet Switch, from Alexander
          Duyck.
    
      11) Rearrange TCP_SKB_CB() to reduce cache line misses, from Eric
          Dumazet.
    
      12) Add Datacenter TCP congestion control algorithm support, From
          Florian Westphal.
    
      13) Reorganize sk_buff so that __copy_skb_header() is significantly
          faster.  From Eric Dumazet"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1558 commits)
      netlabel: directly return netlbl_unlabel_genl_init()
      net: add netdev_txq_bql_{enqueue, complete}_prefetchw() helpers
      net: description of dma_cookie cause make xmldocs warning
      cxgb4: clean up a type issue
      cxgb4: potential shift wrapping bug
      i40e: skb->xmit_more support
      net: fs_enet: Add NAPI TX
      net: fs_enet: Remove non NAPI RX
      r8169:add support for RTL8168EP
      net_sched: copy exts->type in tcf_exts_change()
      wimax: convert printk to pr_foo()
      af_unix: remove 0 assignment on static
      ipv6: Do not warn for informational ICMP messages, regardless of type.
      Update Intel Ethernet Driver maintainers list
      bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING
      tipc: fix bug in multicast congestion handling
      net: better IFF_XMIT_DST_RELEASE support
      net/mlx4_en: remove NETDEV_TX_BUSY
      3c59x: fix bad split of cpu_to_le32(pci_map_single())
      net: bcmgenet: fix Tx ring priority programming
      ...

commit 749730ce42a2121e1c88350d69478bff3994b10a
Author: Alexei Starovoitov <ast@plumgrid.com>
Date:   Fri Sep 26 00:16:58 2014 -0700

    bpf: enable bpf syscall on x64 and i386
    
    done as separate commit to ease conflict resolution
    
    Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 391d4ddb6f4b..b4b5083f5f5e 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -218,3 +218,6 @@ cond_syscall(sys_kcmp);
 
 /* operate on Secure Computing state */
 cond_syscall(sys_seccomp);
+
+/* access BPF programs and maps */
+cond_syscall(sys_bpf);

commit d3ac21cacc24790eb45d735769f35753f5b56ceb
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Sun Aug 17 19:41:09 2014 -0500

    mm: Support compiling out madvise and fadvise
    
    Many embedded systems will not need these syscalls, and omitting them
    saves space.  Add a new EXPERT config option CONFIG_ADVISE_SYSCALLS
    (default y) to support compiling them out.
    
    bloat-o-meter:
    add/remove: 0/3 grow/shrink: 0/0 up/down: 0/-2250 (-2250)
    function                                     old     new   delta
    sys_fadvise64                                 57       -     -57
    sys_fadvise64_64                             691       -    -691
    sys_madvise                                 1502       -   -1502
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 391d4ddb6f4b..d4709d481053 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -156,6 +156,9 @@ cond_syscall(sys_process_vm_writev);
 cond_syscall(compat_sys_process_vm_readv);
 cond_syscall(compat_sys_process_vm_writev);
 cond_syscall(sys_uselib);
+cond_syscall(sys_fadvise64);
+cond_syscall(sys_fadvise64_64);
+cond_syscall(sys_madvise);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit f0895685c7fd8c938c91a9d8a6f7c11f22df58d2
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Aug 8 14:25:55 2014 -0700

    kexec: new syscall kexec_file_load() declaration
    
    This is the new syscall kexec_file_load() declaration/interface.  I have
    reserved the syscall number only for x86_64 so far.  Other architectures
    (including i386) can reserve syscall number when they enable the support
    for this new syscall.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: WANG Chao <chaowang@redhat.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1f79e3714533..391d4ddb6f4b 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -25,6 +25,7 @@ cond_syscall(sys_swapon);
 cond_syscall(sys_swapoff);
 cond_syscall(sys_kexec_load);
 cond_syscall(compat_sys_kexec_load);
+cond_syscall(sys_kexec_file_load);
 cond_syscall(sys_init_module);
 cond_syscall(sys_finit_module);
 cond_syscall(sys_delete_module);

commit 9183df25fe7b194563db3fec6dc3202a5855839c
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 8 14:25:29 2014 -0700

    shm: add memfd_create() syscall
    
    memfd_create() is similar to mmap(MAP_ANON), but returns a file-descriptor
    that you can pass to mmap().  It can support sealing and avoids any
    connection to user-visible mount-points.  Thus, it's not subject to quotas
    on mounted file-systems, but can be used like malloc()'ed memory, but with
    a file-descriptor to it.
    
    memfd_create() returns the raw shmem file, so calls like ftruncate() can
    be used to modify the underlying inode.  Also calls like fstat() will
    return proper information and mark the file as regular file.  If you want
    sealing, you can specify MFD_ALLOW_SEALING.  Otherwise, sealing is not
    supported (like on all other regular files).
    
    Compared to O_TMPFILE, it does not require a tmpfs mount-point and is not
    subject to a filesystem size limit.  It is still properly accounted to
    memcg limits, though, and to the same overcommit or no-overcommit
    accounting as all user memory.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Ryan Lortie <desrt@desrt.ca>
    Cc: Lennart Poettering <lennart@poettering.net>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 2904a2105914..1f79e3714533 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -197,6 +197,7 @@ cond_syscall(compat_sys_timerfd_settime);
 cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);
 cond_syscall(sys_eventfd2);
+cond_syscall(sys_memfd_create);
 
 /* performance counters: */
 cond_syscall(sys_perf_event_open);

commit 48dc92b9fc3926844257316e75ba11eb5c742b2c
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jun 25 16:08:24 2014 -0700

    seccomp: add "seccomp" syscall
    
    This adds the new "seccomp" syscall with both an "operation" and "flags"
    parameter for future expansion. The third argument is a pointer value,
    used with the SECCOMP_SET_MODE_FILTER operation. Currently, flags must
    be 0. This is functionally equivalent to prctl(PR_SET_SECCOMP, ...).
    
    In addition to the TSYNC flag later in this patch series, there is a
    non-zero chance that this syscall could be used for configuring a fixed
    argument area for seccomp-tracer-aware processes to pass syscall arguments
    in the future. Hence, the use of "seccomp" not simply "seccomp_add_filter"
    for this syscall. Additionally, this syscall uses operation, flags,
    and user pointer for arguments because strictly passing arguments via
    a user pointer would mean seccomp itself would be unable to trivially
    filter the seccomp syscall itself.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 36441b51b5df..2904a2105914 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -213,3 +213,6 @@ cond_syscall(compat_sys_open_by_handle_at);
 
 /* compare kernel pointers */
 cond_syscall(sys_kcmp);
+
+/* operate on Secure Computing state */
+cond_syscall(sys_seccomp);

commit f6187769dae48234f3877df3c4d99294cc2254fa
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 4 16:11:12 2014 -0700

    sys_sgetmask/sys_ssetmask: add CONFIG_SGETMASK_SYSCALL
    
    sys_sgetmask and sys_ssetmask are obsolete system calls no longer
    supported in libc.
    
    This patch replaces architecture related __ARCH_WANT_SYS_SGETMAX by expert
    mode configuration.That option is enabled by default for those
    architectures.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Steven Miao <realmz6@gmail.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index bc8d1b74a6b9..36441b51b5df 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -135,6 +135,8 @@ cond_syscall(sys_setresgid16);
 cond_syscall(sys_setresuid16);
 cond_syscall(sys_setreuid16);
 cond_syscall(sys_setuid16);
+cond_syscall(sys_sgetmask);
+cond_syscall(sys_ssetmask);
 cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
 cond_syscall(sys_ipc);

commit 69369a7003735d0d8ef22097e27a55a8bad9557a
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Thu Apr 3 14:48:27 2014 -0700

    fs, kernel: permit disabling the uselib syscall
    
    uselib hasn't been used since libc5; glibc does not use it.  Support
    turning it off.
    
    When disabled, also omit the load_elf_library implementation from
    binfmt_elf.c, which only uselib invokes.
    
    bloat-o-meter:
    add/remove: 0/4 grow/shrink: 0/1 up/down: 0/-785 (-785)
    function                                     old     new   delta
    padzero                                       39      36      -3
    uselib_flags                                  20       -     -20
    sys_uselib                                   168       -    -168
    SyS_uselib                                   168       -    -168
    load_elf_library                             426       -    -426
    
    The new CONFIG_USELIB defaults to `y'.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 74395a95b7e9..bc8d1b74a6b9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -152,6 +152,7 @@ cond_syscall(sys_process_vm_readv);
 cond_syscall(sys_process_vm_writev);
 cond_syscall(compat_sys_process_vm_readv);
 cond_syscall(compat_sys_process_vm_writev);
+cond_syscall(sys_uselib);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 6af9f7bf3c399e0ab1eee048e13572c6d4e15fe9
Author: Fabian Frederick <fabf@skynet.be>
Date:   Thu Apr 3 14:48:25 2014 -0700

    sys_sysfs: Add CONFIG_SYSFS_SYSCALL
    
    sys_sysfs is an obsolete system call no longer supported by libc.
    
     - This patch adds a default CONFIG_SYSFS_SYSCALL=y
    
     - Option can be turned off in expert mode.
    
     - cond_syscall added to kernel/sys_ni.c
    
    [akpm@linux-foundation.org: tweak Kconfig help text]
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7078052284fd..74395a95b7e9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -146,6 +146,7 @@ cond_syscall(sys_io_destroy);
 cond_syscall(sys_io_submit);
 cond_syscall(sys_io_cancel);
 cond_syscall(sys_io_getevents);
+cond_syscall(sys_sysfs);
 cond_syscall(sys_syslog);
 cond_syscall(sys_process_vm_readv);
 cond_syscall(sys_process_vm_writev);

commit 91c2e0bcae72a3086c698b5de2b950b885abb0e6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 5 20:10:59 2013 -0500

    unify compat fanotify_mark(2), switch to COMPAT_SYSCALL_DEFINE
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index bfd6787b355a..7078052284fd 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -200,6 +200,7 @@ cond_syscall(sys_perf_event_open);
 /* fanotify! */
 cond_syscall(sys_fanotify_init);
 cond_syscall(sys_fanotify_mark);
+cond_syscall(compat_sys_fanotify_mark);
 
 /* open by handle */
 cond_syscall(sys_name_to_handle_at);

commit 56e41d3c5aa84d679eebdb3cb8a70b03c5fbd6c3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 21 23:15:25 2013 -0500

    merge compat sys_ipc instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b50e2a003c5a..bfd6787b355a 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -156,7 +156,7 @@ cond_syscall(compat_sys_process_vm_writev);
 cond_syscall(sys_pciconfig_read);
 cond_syscall(sys_pciconfig_write);
 cond_syscall(sys_pciconfig_iobase);
-cond_syscall(sys32_ipc);
+cond_syscall(compat_sys_s390_ipc);
 cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);

commit d5dc77bfeeab0b03a32e3db5e31e2f64605634ab
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Feb 25 18:42:04 2013 -0500

    consolidate compat lookup_dcookie()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 395084d4ce16..b50e2a003c5a 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -20,6 +20,7 @@ cond_syscall(sys_quotactl);
 cond_syscall(sys32_quotactl);
 cond_syscall(sys_acct);
 cond_syscall(sys_lookup_dcookie);
+cond_syscall(compat_sys_lookup_dcookie);
 cond_syscall(sys_swapon);
 cond_syscall(sys_swapoff);
 cond_syscall(sys_kexec_load);

commit 34e1169d996ab148490c01b65b4ee371cf8ffba2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 16 07:31:07 2012 +1030

    module: add syscall to load module from fd
    
    As part of the effort to create a stronger boundary between root and
    kernel, Chrome OS wants to be able to enforce that kernel modules are
    being loaded only from our read-only crypto-hash verified (dm_verity)
    root filesystem. Since the init_module syscall hands the kernel a module
    as a memory blob, no reasoning about the origin of the blob can be made.
    
    Earlier proposals for appending signatures to kernel modules would not be
    useful in Chrome OS, since it would involve adding an additional set of
    keys to our kernel and builds for no good reason: we already trust the
    contents of our root filesystem. We don't need to verify those kernel
    modules a second time. Having to do signature checking on module loading
    would slow us down and be redundant. All we need to know is where a
    module is coming from so we can say yes/no to loading it.
    
    If a file descriptor is used as the source of a kernel module, many more
    things can be reasoned about. In Chrome OS's case, we could enforce that
    the module lives on the filesystem we expect it to live on.  In the case
    of IMA (or other LSMs), it would be possible, for example, to examine
    extended attributes that may contain signatures over the contents of
    the module.
    
    This introduces a new syscall (on x86), similar to init_module, that has
    only two arguments. The first argument is used as a file descriptor to
    the module and the second argument is a pointer to the NULL terminated
    string of module arguments.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (merge fixes)

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index dbff751e4086..395084d4ce16 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -25,6 +25,7 @@ cond_syscall(sys_swapoff);
 cond_syscall(sys_kexec_load);
 cond_syscall(compat_sys_kexec_load);
 cond_syscall(sys_init_module);
+cond_syscall(sys_finit_module);
 cond_syscall(sys_delete_module);
 cond_syscall(sys_socketpair);
 cond_syscall(sys_bind);

commit d97b46a64674a267bc41c9e16132ee2a98c3347d
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Thu May 31 16:26:44 2012 -0700

    syscalls, x86: add __NR_kcmp syscall
    
    While doing the checkpoint-restore in the user space one need to determine
    whether various kernel objects (like mm_struct-s of file_struct-s) are
    shared between tasks and restore this state.
    
    The 2nd step can be solved by using appropriate CLONE_ flags and the
    unshare syscall, while there's currently no ways for solving the 1st one.
    
    One of the ways for checking whether two tasks share e.g.  mm_struct is to
    provide some mm_struct ID of a task to its proc file, but showing such
    info considered to be not that good for security reasons.
    
    Thus after some debates we end up in conclusion that using that named
    'comparison' syscall might be the best candidate.  So here is it --
    __NR_kcmp.
    
    It takes up to 5 arguments - the pids of the two tasks (which
    characteristics should be compared), the comparison type and (in case of
    comparison of files) two file descriptors.
    
    Lookups for pids are done in the caller's PID namespace only.
    
    At moment only x86 is supported and tested.
    
    [akpm@linux-foundation.org: fix up selftests, warnings]
    [akpm@linux-foundation.org: include errno.h]
    [akpm@linux-foundation.org: tweak comment text]
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Andrey Vagin <avagin@openvz.org>
    Cc: KOSAKI Motohiro <kosaki.motohiro@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Glauber Costa <glommer@parallels.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Vasiliy Kulikov <segoon@openwall.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Valdis.Kletnieks@vt.edu
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 47bfa16430d7..dbff751e4086 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -203,3 +203,6 @@ cond_syscall(sys_fanotify_mark);
 cond_syscall(sys_name_to_handle_at);
 cond_syscall(sys_open_by_handle_at);
 cond_syscall(compat_sys_open_by_handle_at);
+
+/* compare kernel pointers */
+cond_syscall(sys_kcmp);

commit fcf634098c00dd9cd247447368495f0b79be12d1
Author: Christopher Yeoh <cyeoh@au1.ibm.com>
Date:   Mon Oct 31 17:06:39 2011 -0700

    Cross Memory Attach
    
    The basic idea behind cross memory attach is to allow MPI programs doing
    intra-node communication to do a single copy of the message rather than a
    double copy of the message via shared memory.
    
    The following patch attempts to achieve this by allowing a destination
    process, given an address and size from a source process, to copy memory
    directly from the source process into its own address space via a system
    call.  There is also a symmetrical ability to copy from the current
    process's address space into a destination process's address space.
    
    - Use of /proc/pid/mem has been considered, but there are issues with
      using it:
      - Does not allow for specifying iovecs for both src and dest, assuming
        preadv or pwritev was implemented either the area read from or
      written to would need to be contiguous.
      - Currently mem_read allows only processes who are currently
      ptrace'ing the target and are still able to ptrace the target to read
      from the target. This check could possibly be moved to the open call,
      but its not clear exactly what race this restriction is stopping
      (reason  appears to have been lost)
      - Having to send the fd of /proc/self/mem via SCM_RIGHTS on unix
      domain socket is a bit ugly from a userspace point of view,
      especially when you may have hundreds if not (eventually) thousands
      of processes  that all need to do this with each other
      - Doesn't allow for some future use of the interface we would like to
      consider adding in the future (see below)
      - Interestingly reading from /proc/pid/mem currently actually
      involves two copies! (But this could be fixed pretty easily)
    
    As mentioned previously use of vmsplice instead was considered, but has
    problems.  Since you need the reader and writer working co-operatively if
    the pipe is not drained then you block.  Which requires some wrapping to
    do non blocking on the send side or polling on the receive.  In all to all
    communication it requires ordering otherwise you can deadlock.  And in the
    example of many MPI tasks writing to one MPI task vmsplice serialises the
    copying.
    
    There are some cases of MPI collectives where even a single copy interface
    does not get us the performance gain we could.  For example in an
    MPI_Reduce rather than copy the data from the source we would like to
    instead use it directly in a mathops (say the reduce is doing a sum) as
    this would save us doing a copy.  We don't need to keep a copy of the data
    from the source.  I haven't implemented this, but I think this interface
    could in the future do all this through the use of the flags - eg could
    specify the math operation and type and the kernel rather than just
    copying the data would apply the specified operation between the source
    and destination and store it in the destination.
    
    Although we don't have a "second user" of the interface (though I've had
    some nibbles from people who may be interested in using it for intra
    process messaging which is not MPI).  This interface is something which
    hardware vendors are already doing for their custom drivers to implement
    fast local communication.  And so in addition to this being useful for
    OpenMPI it would mean the driver maintainers don't have to fix things up
    when the mm changes.
    
    There was some discussion about how much faster a true zero copy would
    go. Here's a link back to the email with some testing I did on that:
    
    http://marc.info/?l=linux-mm&m=130105930902915&w=2
    
    There is a basic man page for the proposed interface here:
    
    http://ozlabs.org/~cyeoh/cma/process_vm_readv.txt
    
    This has been implemented for x86 and powerpc, other architecture should
    mainly (I think) just need to add syscall numbers for the process_vm_readv
    and process_vm_writev. There are 32 bit compatibility versions for
    64-bit kernels.
    
    For arch maintainers there are some simple tests to be able to quickly
    verify that the syscalls are working correctly here:
    
    http://ozlabs.org/~cyeoh/cma/cma-test-20110718.tgz
    
    Signed-off-by: Chris Yeoh <yeohc@au1.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: <linux-man@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index a9a5de07c4f1..47bfa16430d7 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -145,6 +145,10 @@ cond_syscall(sys_io_submit);
 cond_syscall(sys_io_cancel);
 cond_syscall(sys_io_getevents);
 cond_syscall(sys_syslog);
+cond_syscall(sys_process_vm_readv);
+cond_syscall(sys_process_vm_writev);
+cond_syscall(compat_sys_process_vm_readv);
+cond_syscall(compat_sys_process_vm_writev);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit f5b940997397229975ea073679b03967932a541b
Author: NeilBrown <neilb@suse.de>
Date:   Fri Aug 26 18:03:11 2011 -0400

    All Arch: remove linkage for sys_nfsservctl system call
    
    The nfsservctl system call is now gone, so we should remove all
    linkage for it.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 62cbc8877fef..a9a5de07c4f1 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -16,7 +16,6 @@ asmlinkage long sys_ni_syscall(void)
 	return -ENOSYS;
 }
 
-cond_syscall(sys_nfsservctl);
 cond_syscall(sys_quotactl);
 cond_syscall(sys32_quotactl);
 cond_syscall(sys_acct);

commit be84bfcc3ed8f824751ab79349779e50cc98aa01
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Tue May 17 10:39:58 2011 -0700

    ipc: Add missing sys_ni entries for ipc/compat.c functions
    
    When building with:
    
      CONFIG_64BIT=y
      CONFIG_MIPS32_COMPAT=y
      CONFIG_COMPAT=y
      CONFIG_MIPS32_O32=y
      CONFIG_MIPS32_N32=y
      CONFIG_SYSVIPC is not set
      (and implicitly: CONFIG_SYSVIPC_COMPAT is not set)
    
    the final link fails with unresolved symbols for:
    
      compat_sys_semctl, compat_sys_msgsnd, compat_sys_msgrcv,
      compat_sys_shmctl, compat_sys_msgctl, compat_sys_semtimedop
    
    The fix is to add cond_syscall declarations for all syscalls in
    ipc/compat.c
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 97e966f171c6..62cbc8877fef 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -71,15 +71,22 @@ cond_syscall(compat_sys_epoll_pwait);
 cond_syscall(sys_semget);
 cond_syscall(sys_semop);
 cond_syscall(sys_semtimedop);
+cond_syscall(compat_sys_semtimedop);
 cond_syscall(sys_semctl);
+cond_syscall(compat_sys_semctl);
 cond_syscall(sys_msgget);
 cond_syscall(sys_msgsnd);
+cond_syscall(compat_sys_msgsnd);
 cond_syscall(sys_msgrcv);
+cond_syscall(compat_sys_msgrcv);
 cond_syscall(sys_msgctl);
+cond_syscall(compat_sys_msgctl);
 cond_syscall(sys_shmget);
 cond_syscall(sys_shmat);
+cond_syscall(compat_sys_shmat);
 cond_syscall(sys_shmdt);
 cond_syscall(sys_shmctl);
+cond_syscall(compat_sys_shmctl);
 cond_syscall(sys_mq_open);
 cond_syscall(sys_mq_unlink);
 cond_syscall(sys_mq_timedsend);

commit 228e548e602061b08ee8e8966f567c12aa079682
Author: Anton Blanchard <anton@samba.org>
Date:   Mon May 2 20:21:35 2011 +0000

    net: Add sendmmsg socket system call
    
    This patch adds a multiple message send syscall and is the send
    version of the existing recvmmsg syscall. This is heavily
    based on the patch by Arnaldo that added recvmmsg.
    
    I wrote a microbenchmark to test the performance gains of using
    this new syscall:
    
    http://ozlabs.org/~anton/junkcode/sendmmsg_test.c
    
    The test was run on a ppc64 box with a 10 Gbit network card. The
    benchmark can send both UDP and RAW ethernet packets.
    
    64B UDP
    
    batch   pkts/sec
    1       804570
    2       872800 (+ 8 %)
    4       916556 (+14 %)
    8       939712 (+17 %)
    16      952688 (+18 %)
    32      956448 (+19 %)
    64      964800 (+20 %)
    
    64B raw socket
    
    batch   pkts/sec
    1       1201449
    2       1350028 (+12 %)
    4       1461416 (+22 %)
    8       1513080 (+26 %)
    16      1541216 (+28 %)
    32      1553440 (+29 %)
    64      1557888 (+30 %)
    
    We see a 20% improvement in throughput on UDP send and 30%
    on raw socket send.
    
    [ Add sparc syscall entries. -DaveM ]
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 25cc41cd8f33..97e966f171c6 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -46,7 +46,9 @@ cond_syscall(sys_getsockopt);
 cond_syscall(compat_sys_getsockopt);
 cond_syscall(sys_shutdown);
 cond_syscall(sys_sendmsg);
+cond_syscall(sys_sendmmsg);
 cond_syscall(compat_sys_sendmsg);
+cond_syscall(compat_sys_sendmmsg);
 cond_syscall(sys_recvmsg);
 cond_syscall(sys_recvmmsg);
 cond_syscall(compat_sys_recvmsg);

commit becfd1f37544798cbdfd788f32c827160fab98c1
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sat Jan 29 18:43:26 2011 +0530

    vfs: Add open by file handle support
    
    [AV: duplicate of open() guts removed; file_open_root() used instead]
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 4e013439ac28..25cc41cd8f33 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -189,3 +189,5 @@ cond_syscall(sys_fanotify_mark);
 
 /* open by handle */
 cond_syscall(sys_name_to_handle_at);
+cond_syscall(sys_open_by_handle_at);
+cond_syscall(compat_sys_open_by_handle_at);

commit 990d6c2d7aee921e3bce22b2d6a750fd552262be
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sat Jan 29 18:43:26 2011 +0530

    vfs: Add name to file handle conversion support
    
    The syscall also return mount id which can be used
    to lookup file system specific information such as uuid
    in /proc/<pid>/mountinfo
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index c782fe9924c7..4e013439ac28 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -186,3 +186,6 @@ cond_syscall(sys_perf_event_open);
 /* fanotify! */
 cond_syscall(sys_fanotify_init);
 cond_syscall(sys_fanotify_mark);
+
+/* open by handle */
+cond_syscall(sys_name_to_handle_at);

commit 1ef21199a5d98702755cfa0df39b8b5112c423d6
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Sep 3 13:19:04 2010 +1000

    powerpc: define a compat_sys_recv cond_syscall
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index bad369ec5403..c782fe9924c7 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -50,6 +50,7 @@ cond_syscall(compat_sys_sendmsg);
 cond_syscall(sys_recvmsg);
 cond_syscall(sys_recvmmsg);
 cond_syscall(compat_sys_recvmsg);
+cond_syscall(compat_sys_recv);
 cond_syscall(compat_sys_recvfrom);
 cond_syscall(compat_sys_recvmmsg);
 cond_syscall(sys_socketcall);

commit bbaa4168b2d2d8cc674e6d35806e8426aef464b8
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:26 2009 -0500

    fanotify: sys_fanotify_mark declartion
    
    This patch simply declares the new sys_fanotify_mark syscall
    
    int fanotify_mark(int fanotify_fd, unsigned int flags, u64_mask,
                      int dfd const char *pathname)
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 2c4adc2decc3..bad369ec5403 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -184,3 +184,4 @@ cond_syscall(sys_perf_event_open);
 
 /* fanotify! */
 cond_syscall(sys_fanotify_init);
+cond_syscall(sys_fanotify_mark);

commit 11637e4b7dc098e9a863f0a619d55ebc60f5949e
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:25 2009 -0500

    fanotify: fanotify_init syscall declaration
    
    This patch defines a new syscall fanotify_init() of the form:
    
    int sys_fanotify_init(unsigned int flags, unsigned int event_f_flags,
                          unsigned int priority)
    
    This syscall is used to create and fanotify group.  This is very similar to
    the inotify_init() syscall.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 70f2ea758ffe..2c4adc2decc3 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -181,3 +181,6 @@ cond_syscall(sys_eventfd2);
 
 /* performance counters: */
 cond_syscall(sys_perf_event_open);
+
+/* fanotify! */
+cond_syscall(sys_fanotify_init);

commit baed7fc9b580bd3fb8252ff1d9b36eaf1f86b670
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 10 15:21:18 2010 -0800

    Add generic sys_ipc wrapper
    
    Add a generic implementation of the ipc demultiplexer syscall.  Except for
    s390 and sparc64 all implementations of the sys_ipc are nearly identical.
    
    There are slight differences in the types of the parameters, where mips
    and powerpc as the only 64-bit architectures with sys_ipc use unsigned
    long for the "third" argument as it gets casted to a pointer later, while
    it traditionally is an "int" like most other paramters.  frv goes even
    further and uses unsigned long for all parameters execept for "ptr" which
    is a pointer type everywhere.  The change from int to unsigned long for
    "third" and back to "int" for the others on frv should be fine due to the
    in-register calling conventions for syscalls (we already had a similar
    issue with the generic sys_ptrace), but I'd prefer to have the arch
    maintainers looks over this in details.
    
    Except for that h8300, m68k and m68knommu lack an impplementation of the
    semtimedop sub call which this patch adds, and various architectures have
    gets used - at least on i386 it seems superflous as the compat code on
    x86-64 and ia64 doesn't even bother to implement it.
    
    [akpm@linux-foundation.org: add sys_ipc to sys_ni.c]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Andreas Schwab <schwab@linux-m68k.org>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: David Howells <dhowells@redhat.com>
    Acked-by: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 695384f12a7d..70f2ea758ffe 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -126,6 +126,7 @@ cond_syscall(sys_setreuid16);
 cond_syscall(sys_setuid16);
 cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
+cond_syscall(sys_ipc);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);
 cond_syscall(sys_flock);

commit d7fc02c7bae7b1cf69269992cf880a43a350cdaa
Merge: ee1262dbc65c 28b4d5cc17c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 07:55:01 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1815 commits)
      mac80211: fix reorder buffer release
      iwmc3200wifi: Enable wimax core through module parameter
      iwmc3200wifi: Add wifi-wimax coexistence mode as a module parameter
      iwmc3200wifi: Coex table command does not expect a response
      iwmc3200wifi: Update wiwi priority table
      iwlwifi: driver version track kernel version
      iwlwifi: indicate uCode type when fail dump error/event log
      iwl3945: remove duplicated event logging code
      b43: fix two warnings
      ipw2100: fix rebooting hang with driver loaded
      cfg80211: indent regulatory messages with spaces
      iwmc3200wifi: fix NULL pointer dereference in pmkid update
      mac80211: Fix TX status reporting for injected data frames
      ath9k: enable 2GHz band only if the device supports it
      airo: Fix integer overflow warning
      rt2x00: Fix padding bug on L2PAD devices.
      WE: Fix set events not propagated
      b43legacy: avoid PPC fault during resume
      b43: avoid PPC fault during resume
      tcp: fix a timewait refcnt race
      ...
    
    Fix up conflicts due to sysctl cleanups (dead sysctl_check code and
    CTL_UNNUMBERED removed) in
            kernel/sysctl_check.c
            net/ipv4/sysctl_net_ipv4.c
            net/ipv6/addrconf.c
            net/sctp/sysctl.c

commit 942405f36038b8f930ab67e24aa1ad72bee96a25
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Apr 3 01:01:43 2009 -0700

    sysctl: Remove the cond_syscall entry for sys32_sysctl
    
    Now that all architechtures are use compat_sys_sysctl and sys32_sysctl
    does not exist there is not point in retaining a cond_syscall
    entry for it.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index e06d0b8d1951..de5bf1448238 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -139,7 +139,6 @@ cond_syscall(sys_pciconfig_read);
 cond_syscall(sys_pciconfig_write);
 cond_syscall(sys_pciconfig_iobase);
 cond_syscall(sys32_ipc);
-cond_syscall(sys32_sysctl);
 cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);

commit a2e2725541fad72416326798c2d7fa4dafb7d337
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 12 23:40:10 2009 -0700

    net: Introduce recvmmsg socket syscall
    
    Meaning receive multiple messages, reducing the number of syscalls and
    net stack entry/exit operations.
    
    Next patches will introduce mechanisms where protocols that want to
    optimize this operation will provide an unlocked_recvmsg operation.
    
    This takes into account comments made by:
    
    . Paul Moore: sock_recvmsg is called only for the first datagram,
      sock_recvmsg_nosec is used for the rest.
    
    . Caitlin Bestler: recvmmsg now has a struct timespec timeout, that
      works in the same fashion as the ppoll one.
    
      If the underlying protocol returns a datagram with MSG_OOB set, this
      will make recvmmsg return right away with as many datagrams (+ the OOB
      one) it has received so far.
    
    . Rémi Denis-Courmont & Steven Whitehouse: If we receive N < vlen
      datagrams and then recvmsg returns an error, recvmmsg will return
      the successfully received datagrams, store the error and return it
      in the next call.
    
    This paves the way for a subsequent optimization, sk_prot->unlocked_recvmsg,
    where we will be able to acquire the lock only at batch start and end, not at
    every underlying recvmsg call.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index e06d0b8d1951..f050ba85d420 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -48,8 +48,10 @@ cond_syscall(sys_shutdown);
 cond_syscall(sys_sendmsg);
 cond_syscall(compat_sys_sendmsg);
 cond_syscall(sys_recvmsg);
+cond_syscall(sys_recvmmsg);
 cond_syscall(compat_sys_recvmsg);
 cond_syscall(compat_sys_recvfrom);
+cond_syscall(compat_sys_recvmmsg);
 cond_syscall(sys_socketcall);
 cond_syscall(sys_futex);
 cond_syscall(compat_sys_futex);

commit 8b3f6af86378d0a10ca2f1ded1da124aef13b62c
Merge: 139d6065c830 94e0fb086fc5
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Sep 24 15:13:11 2009 -0700

    Merge branch 'master' of /home/davem/src/GIT/linux-2.6/
    
    Conflicts:
            drivers/staging/Kconfig
            drivers/staging/Makefile
            drivers/staging/cpc-usb/TODO
            drivers/staging/cpc-usb/cpc-usb_drv.c
            drivers/staging/cpc-usb/cpc.h
            drivers/staging/cpc-usb/cpc_int.h
            drivers/staging/cpc-usb/cpcusb.h

commit dedcf2971c250473e724b642c0100d3621116616
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Sep 18 09:52:13 2009 +0000

    net: fix CONFIG_NET=n build on sparc64
    
    sparc64 allnoconfig:
    
    arch/sparc/kernel/built-in.o(.text+0x134e0): In function `sys32_recvfrom':
    : undefined reference to `compat_sys_recvfrom'
    arch/sparc/kernel/built-in.o(.text+0x134e4): In function `sys32_recvfrom':
    : undefined reference to `compat_sys_recvfrom'
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 68320f6b07b5..44e5936118d2 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -49,6 +49,7 @@ cond_syscall(sys_sendmsg);
 cond_syscall(compat_sys_sendmsg);
 cond_syscall(sys_recvmsg);
 cond_syscall(compat_sys_recvmsg);
+cond_syscall(compat_sys_recvfrom);
 cond_syscall(sys_socketcall);
 cond_syscall(sys_futex);
 cond_syscall(compat_sys_futex);

commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Sep 21 12:02:48 2009 +0200

    perf: Do the big rename: Performance Counters -> Performance Events
    
    Bye-bye Performance Counters, welcome Performance Events!
    
    In the past few months the perfcounters subsystem has grown out its
    initial role of counting hardware events, and has become (and is
    becoming) a much broader generic event enumeration, reporting, logging,
    monitoring, analysis facility.
    
    Naming its core object 'perf_counter' and naming the subsystem
    'perfcounters' has become more and more of a misnomer. With pending
    code like hw-breakpoints support the 'counter' name is less and
    less appropriate.
    
    All in one, we've decided to rename the subsystem to 'performance
    events' and to propagate this rename through all fields, variables
    and API names. (in an ABI compatible fashion)
    
    The word 'event' is also a bit shorter than 'counter' - which makes
    it slightly more convenient to write/handle as well.
    
    Thanks goes to Stephane Eranian who first observed this misnomer and
    suggested a rename.
    
    User-space tooling and ABI compatibility is not affected - this patch
    should be function-invariant. (Also, defconfigs were not touched to
    keep the size down.)
    
    This patch has been generated via the following script:
    
      FILES=$(find * -type f | grep -vE 'oprofile|[^K]config')
    
      sed -i \
        -e 's/PERF_EVENT_/PERF_RECORD_/g' \
        -e 's/PERF_COUNTER/PERF_EVENT/g' \
        -e 's/perf_counter/perf_event/g' \
        -e 's/nb_counters/nb_events/g' \
        -e 's/swcounter/swevent/g' \
        -e 's/tpcounter_event/tp_event/g' \
        $FILES
    
      for N in $(find . -name perf_counter.[ch]); do
        M=$(echo $N | sed 's/perf_counter/perf_event/g')
        mv $N $M
      done
    
      FILES=$(find . -name perf_event.*)
    
      sed -i \
        -e 's/COUNTER_MASK/REG_MASK/g' \
        -e 's/COUNTER/EVENT/g' \
        -e 's/\<event\>/event_id/g' \
        -e 's/counter/event/g' \
        -e 's/Counter/Event/g' \
        $FILES
    
    ... to keep it as correct as possible. This script can also be
    used by anyone who has pending perfcounters patches - it converts
    a Linux kernel tree over to the new naming. We tried to time this
    change to the point in time where the amount of pending patches
    is the smallest: the end of the merge window.
    
    Namespace clashes were fixed up in a preparatory patch - and some
    stylistic fallout will be fixed up in a subsequent patch.
    
    ( NOTE: 'counters' are still the proper terminology when we deal
      with hardware registers - and these sed scripts are a bit
      over-eager in renaming them. I've undone some of that, but
      in case there's something left where 'counter' would be
      better than 'event' we can undo that on an individual basis
      instead of touching an otherwise nicely automated patch. )
    
    Suggested-by: Stephane Eranian <eranian@google.com>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Reviewed-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: <linux-arch@vger.kernel.org>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 68320f6b07b5..515bc230ac2a 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -177,4 +177,4 @@ cond_syscall(sys_eventfd);
 cond_syscall(sys_eventfd2);
 
 /* performance counters: */
-cond_syscall(sys_perf_counter_open);
+cond_syscall(sys_perf_event_open);

commit 77835492ed489c0b870f82f4c50687bd267acc0a
Merge: af37501c7921 1de9e8e70f5a
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 21 16:37:27 2009 +0100

    Merge commit 'v2.6.29-rc2' into perfcounters/core
    
    Conflicts:
            include/linux/syscalls.h

commit f627a741d24f12955fa2d9f8831c3b12860635bd
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Jan 14 14:13:58 2009 +0100

    [CVE-2009-0029] Make sys_syslog a conditional system call
    
    Remove the -ENOSYS implementation for !CONFIG_PRINTK and use
    the cond_syscall infrastructure instead.
    
    Acked-by: Kyle McMartin <kyle@redhat.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index e14a23281707..27dad2967387 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -131,6 +131,7 @@ cond_syscall(sys_io_destroy);
 cond_syscall(sys_io_submit);
 cond_syscall(sys_io_cancel);
 cond_syscall(sys_io_getevents);
+cond_syscall(sys_syslog);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 0793a61d4df8daeac6492dbf8d2f3e5713caae5e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 4 20:12:29 2008 +0100

    performance counters: core code
    
    Implement the core kernel bits of Performance Counters subsystem.
    
    The Linux Performance Counter subsystem provides an abstraction of
    performance counter hardware capabilities. It provides per task and per
    CPU counters, and it provides event capabilities on top of those.
    
    Performance counters are accessed via special file descriptors.
    There's one file descriptor per virtual counter used.
    
    The special file descriptor is opened via the perf_counter_open()
    system call:
    
     int
     perf_counter_open(u32 hw_event_type,
                       u32 hw_event_period,
                       u32 record_type,
                       pid_t pid,
                       int cpu);
    
    The syscall returns the new fd. The fd can be used via the normal
    VFS system calls: read() can be used to read the counter, fcntl()
    can be used to set the blocking mode, etc.
    
    Multiple counters can be kept open at a time, and the counters
    can be poll()ed.
    
    See more details in Documentation/perf-counters.txt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index e14a23281707..4be8bbc7577c 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -174,3 +174,6 @@ cond_syscall(compat_sys_timerfd_settime);
 cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);
 cond_syscall(sys_eventfd2);
+
+/* performance counters: */
+cond_syscall(sys_perf_counter_open);

commit de11defebf00007677fb7ee91d9b089b78786fbb
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Nov 19 15:36:14 2008 -0800

    reintroduce accept4
    
    Introduce a new accept4() system call.  The addition of this system call
    matches analogous changes in 2.6.27 (dup3(), evenfd2(), signalfd4(),
    inotify_init1(), epoll_create1(), pipe2()) which added new system calls
    that differed from analogous traditional system calls in adding a flags
    argument that can be used to access additional functionality.
    
    The accept4() system call is exactly the same as accept(), except that
    it adds a flags bit-mask argument.  Two flags are initially implemented.
    (Most of the new system calls in 2.6.27 also had both of these flags.)
    
    SOCK_CLOEXEC causes the close-on-exec (FD_CLOEXEC) flag to be enabled
    for the new file descriptor returned by accept4().  This is a useful
    security feature to avoid leaking information in a multithreaded
    program where one thread is doing an accept() at the same time as
    another thread is doing a fork() plus exec().  More details here:
    http://udrepper.livejournal.com/20407.html "Secure File Descriptor Handling",
    Ulrich Drepper).
    
    The other flag is SOCK_NONBLOCK, which causes the O_NONBLOCK flag
    to be enabled on the new open file description created by accept4().
    (This flag is merely a convenience, saving the use of additional calls
    fcntl(F_GETFL) and fcntl (F_SETFL) to achieve the same result.
    
    Here's a test program.  Works on x86-32.  Should work on x86-64, but
    I (mtk) don't have a system to hand to test with.
    
    It tests accept4() with each of the four possible combinations of
    SOCK_CLOEXEC and SOCK_NONBLOCK set/clear in 'flags', and verifies
    that the appropriate flags are set on the file descriptor/open file
    description returned by accept4().
    
    I tested Ulrich's patch in this thread by applying against 2.6.28-rc2,
    and it passes according to my test program.
    
    /* test_accept4.c
    
      Copyright (C) 2008, Linux Foundation, written by Michael Kerrisk
           <mtk.manpages@gmail.com>
    
      Licensed under the GNU GPLv2 or later.
    */
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <stdio.h>
    #include <string.h>
    
    #define PORT_NUM 33333
    
    #define die(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)
    
    /**********************************************************************/
    
    /* The following is what we need until glibc gets a wrapper for
      accept4() */
    
    /* Flags for socket(), socketpair(), accept4() */
    #ifndef SOCK_CLOEXEC
    #define SOCK_CLOEXEC    O_CLOEXEC
    #endif
    #ifndef SOCK_NONBLOCK
    #define SOCK_NONBLOCK   O_NONBLOCK
    #endif
    
    #ifdef __x86_64__
    #define SYS_accept4 288
    #elif __i386__
    #define USE_SOCKETCALL 1
    #define SYS_ACCEPT4 18
    #else
    #error "Sorry -- don't know the syscall # on this architecture"
    #endif
    
    static int
    accept4(int fd, struct sockaddr *sockaddr, socklen_t *addrlen, int flags)
    {
       printf("Calling accept4(): flags = %x", flags);
       if (flags != 0) {
           printf(" (");
           if (flags & SOCK_CLOEXEC)
               printf("SOCK_CLOEXEC");
           if ((flags & SOCK_CLOEXEC) && (flags & SOCK_NONBLOCK))
               printf(" ");
           if (flags & SOCK_NONBLOCK)
               printf("SOCK_NONBLOCK");
           printf(")");
       }
       printf("\n");
    
    #if USE_SOCKETCALL
       long args[6];
    
       args[0] = fd;
       args[1] = (long) sockaddr;
       args[2] = (long) addrlen;
       args[3] = flags;
    
       return syscall(SYS_socketcall, SYS_ACCEPT4, args);
    #else
       return syscall(SYS_accept4, fd, sockaddr, addrlen, flags);
    #endif
    }
    
    /**********************************************************************/
    
    static int
    do_test(int lfd, struct sockaddr_in *conn_addr,
           int closeonexec_flag, int nonblock_flag)
    {
       int connfd, acceptfd;
       int fdf, flf, fdf_pass, flf_pass;
       struct sockaddr_in claddr;
       socklen_t addrlen;
    
       printf("=======================================\n");
    
       connfd = socket(AF_INET, SOCK_STREAM, 0);
       if (connfd == -1)
           die("socket");
       if (connect(connfd, (struct sockaddr *) conn_addr,
                   sizeof(struct sockaddr_in)) == -1)
           die("connect");
    
       addrlen = sizeof(struct sockaddr_in);
       acceptfd = accept4(lfd, (struct sockaddr *) &claddr, &addrlen,
                          closeonexec_flag | nonblock_flag);
       if (acceptfd == -1) {
           perror("accept4()");
           close(connfd);
           return 0;
       }
    
       fdf = fcntl(acceptfd, F_GETFD);
       if (fdf == -1)
           die("fcntl:F_GETFD");
       fdf_pass = ((fdf & FD_CLOEXEC) != 0) ==
                  ((closeonexec_flag & SOCK_CLOEXEC) != 0);
       printf("Close-on-exec flag is %sset (%s); ",
               (fdf & FD_CLOEXEC) ? "" : "not ",
               fdf_pass ? "OK" : "failed");
    
       flf = fcntl(acceptfd, F_GETFL);
       if (flf == -1)
           die("fcntl:F_GETFD");
       flf_pass = ((flf & O_NONBLOCK) != 0) ==
                  ((nonblock_flag & SOCK_NONBLOCK) !=0);
       printf("nonblock flag is %sset (%s)\n",
               (flf & O_NONBLOCK) ? "" : "not ",
               flf_pass ? "OK" : "failed");
    
       close(acceptfd);
       close(connfd);
    
       printf("Test result: %s\n", (fdf_pass && flf_pass) ? "PASS" : "FAIL");
       return fdf_pass && flf_pass;
    }
    
    static int
    create_listening_socket(int port_num)
    {
       struct sockaddr_in svaddr;
       int lfd;
       int optval;
    
       memset(&svaddr, 0, sizeof(struct sockaddr_in));
       svaddr.sin_family = AF_INET;
       svaddr.sin_addr.s_addr = htonl(INADDR_ANY);
       svaddr.sin_port = htons(port_num);
    
       lfd = socket(AF_INET, SOCK_STREAM, 0);
       if (lfd == -1)
           die("socket");
    
       optval = 1;
       if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval,
                      sizeof(optval)) == -1)
           die("setsockopt");
    
       if (bind(lfd, (struct sockaddr *) &svaddr,
                sizeof(struct sockaddr_in)) == -1)
           die("bind");
    
       if (listen(lfd, 5) == -1)
           die("listen");
    
       return lfd;
    }
    
    int
    main(int argc, char *argv[])
    {
       struct sockaddr_in conn_addr;
       int lfd;
       int port_num;
       int passed;
    
       passed = 1;
    
       port_num = (argc > 1) ? atoi(argv[1]) : PORT_NUM;
    
       memset(&conn_addr, 0, sizeof(struct sockaddr_in));
       conn_addr.sin_family = AF_INET;
       conn_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
       conn_addr.sin_port = htons(port_num);
    
       lfd = create_listening_socket(port_num);
    
       if (!do_test(lfd, &conn_addr, 0, 0))
           passed = 0;
       if (!do_test(lfd, &conn_addr, SOCK_CLOEXEC, 0))
           passed = 0;
       if (!do_test(lfd, &conn_addr, 0, SOCK_NONBLOCK))
           passed = 0;
       if (!do_test(lfd, &conn_addr, SOCK_CLOEXEC, SOCK_NONBLOCK))
           passed = 0;
    
       close(lfd);
    
       exit(passed ? EXIT_SUCCESS : EXIT_FAILURE);
    }
    
    [mtk.manpages@gmail.com: rewrote changelog, updated test program]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Tested-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index a77b27b11b04..e14a23281707 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -31,7 +31,7 @@ cond_syscall(sys_socketpair);
 cond_syscall(sys_bind);
 cond_syscall(sys_listen);
 cond_syscall(sys_accept);
-cond_syscall(sys_paccept);
+cond_syscall(sys_accept4);
 cond_syscall(sys_connect);
 cond_syscall(sys_getsockname);
 cond_syscall(sys_getpeername);

commit ebf3f09c634906d371f2bfd71b41c7e0c52efe7e
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Oct 15 22:05:12 2008 -0700

    Configure out AIO support
    
    This patchs adds the CONFIG_AIO option which allows to remove support
    for asynchronous I/O operations, that are not necessarly used by
    applications, particularly on embedded devices. As this is a
    size-reduction option, it depends on CONFIG_EMBEDDED. It allows to
    save ~7 kilobytes of kernel code/data:
    
       text    data     bss     dec     hex filename
    1115067  119180  217088 1451335  162547 vmlinux
    1108025  119048  217088 1444161  160941 vmlinux.new
      -7042    -132       0   -7174   -1C06 +/-
    
    This patch has been originally written by Matt Mackall
    <mpm@selenic.com>, and is part of the Linux Tiny project.
    
    [randy.dunlap@oracle.com: build fix]
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Benjamin LaHaise <bcrl@kvack.org>
    Cc: Zach Brown <zach.brown@oracle.com>
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 503d8d4eb80a..a77b27b11b04 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -126,6 +126,11 @@ cond_syscall(sys_vm86);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);
 cond_syscall(sys_flock);
+cond_syscall(sys_io_setup);
+cond_syscall(sys_io_destroy);
+cond_syscall(sys_io_submit);
+cond_syscall(sys_io_cancel);
+cond_syscall(sys_io_getevents);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit bfcd17a6c5529bc37234cfa720a047cf9397bcfc
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Aug 6 15:12:22 2008 +0200

    Configure out file locking features
    
    This patch adds the CONFIG_FILE_LOCKING option which allows to remove
    support for advisory locks. With this patch enabled, the flock()
    system call, the F_GETLK, F_SETLK and F_SETLKW operations of fcntl()
    and NFS support are disabled. These features are not necessarly needed
    on embedded systems. It allows to save ~11 Kb of kernel code and data:
    
       text          data     bss     dec     hex filename
    1125436        118764  212992 1457192  163c28 vmlinux.old
    1114299        118564  212992 1445855  160fdf vmlinux
     -11137    -200       0  -11337   -2C49 +/-
    
    This patch has originally been written by Matt Mackall
    <mpm@selenic.com>, and is part of the Linux Tiny project.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Cc: matthew@wil.cx
    Cc: linux-fsdevel@vger.kernel.org
    Cc: mpm@selenic.com
    Cc: akpm@linux-foundation.org
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 08d6e1bb99ac..503d8d4eb80a 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -125,6 +125,7 @@ cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);
+cond_syscall(sys_flock);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 9b81361631bbb1d85c99ddec677d42afe516737b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 25 13:02:37 2008 +0200

    signalfd: fix undefined reference to `compat_sys_signalfd4' when !CONFIG_SIGNALFD
    
    fix:
    
    arch/x86/ia32/built-in.o: In function `ia32_sys_call_table':
    (.rodata+0xa38): undefined reference to `compat_sys_signalfd4'
    
    on !CONFIG_SIGNALFD.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 55eca1594da9..08d6e1bb99ac 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -160,6 +160,7 @@ cond_syscall(sys_ioprio_get);
 cond_syscall(sys_signalfd);
 cond_syscall(sys_signalfd4);
 cond_syscall(compat_sys_signalfd);
+cond_syscall(compat_sys_signalfd4);
 cond_syscall(sys_timerfd_create);
 cond_syscall(sys_timerfd_settime);
 cond_syscall(sys_timerfd_gettime);

commit 5df439ef06d4173357711a04740aa8bfcf50d621
Author: Wang Chen <wangchen@cn.fujitsu.com>
Date:   Fri Jul 25 01:45:23 2008 -0700

    flag parameters: fix compile error of sys_epoll_create1
    
    GEN     .version
      CHK     include/linux/compile.h
      UPD     include/linux/compile.h
      CC      init/version.o
      LD      init/built-in.o
      LD      vmlinux
    arch/x86/kernel/built-in.o: In function `sys_call_table':
    (.rodata+0x8a4): undefined reference to `sys_epoll_create1'
    make: *** [vmlinux] Error 1
    
    Signed-off-by: Wang Chen <wangchen@cn.fujitsu.com>
    Cc: Ulrich Drepper <drepper@redhat.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index bd66ac5406f3..55eca1594da9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -57,6 +57,7 @@ cond_syscall(compat_sys_set_robust_list);
 cond_syscall(sys_get_robust_list);
 cond_syscall(compat_sys_get_robust_list);
 cond_syscall(sys_epoll_create);
+cond_syscall(sys_epoll_create1);
 cond_syscall(sys_epoll_ctl);
 cond_syscall(sys_epoll_wait);
 cond_syscall(sys_epoll_pwait);

commit 4006553b06306b34054529477b06b68a1c66249b
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:32 2008 -0700

    flag parameters: inotify_init
    
    This patch introduces the new syscall inotify_init1 (note: the 1 stands for
    the one parameter the syscall takes, as opposed to no parameter before).  The
    values accepted for this parameter are function-specific and defined in the
    inotify.h header.  Here the values must match the O_* flags, though.  In this
    patch CLOEXEC support is introduced.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_inotify_init1
    # ifdef __x86_64__
    #  define __NR_inotify_init1 294
    # elif defined __i386__
    #  define __NR_inotify_init1 332
    # else
    #  error "need __NR_inotify_init1"
    # endif
    #endif
    
    #define IN_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      int fd;
      fd = syscall (__NR_inotify_init1, 0);
      if (fd == -1)
        {
          puts ("inotify_init1(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("inotify_init1(0) set close-on-exit");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_inotify_init1, IN_CLOEXEC);
      if (fd == -1)
        {
          puts ("inotify_init1(IN_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("inotify_init1(O_CLOEXEC) does not set close-on-exit");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 2a361ccdc7ca..bd66ac5406f3 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -96,6 +96,7 @@ cond_syscall(sys_keyctl);
 cond_syscall(compat_sys_keyctl);
 cond_syscall(compat_sys_socketcall);
 cond_syscall(sys_inotify_init);
+cond_syscall(sys_inotify_init1);
 cond_syscall(sys_inotify_add_watch);
 cond_syscall(sys_inotify_rm_watch);
 cond_syscall(sys_migrate_pages);

commit b087498eb5605673b0f260a7620d91818cd72304
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:25 2008 -0700

    flag parameters: eventfd
    
    This patch adds the new eventfd2 syscall.  It extends the old eventfd
    syscall by one parameter which is meant to hold a flag value.  In this
    patch the only flag support is EFD_CLOEXEC which causes the close-on-exec
    flag for the returned file descriptor to be set.
    
    A new name EFD_CLOEXEC is introduced which in this implementation must
    have the same value as O_CLOEXEC.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_eventfd2
    # ifdef __x86_64__
    #  define __NR_eventfd2 290
    # elif defined __i386__
    #  define __NR_eventfd2 328
    # else
    #  error "need __NR_eventfd2"
    # endif
    #endif
    
    #define EFD_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      int fd = syscall (__NR_eventfd2, 1, 0);
      if (fd == -1)
        {
          puts ("eventfd2(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("eventfd2(0) sets close-on-exec flag");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_eventfd2, 1, EFD_CLOEXEC);
      if (fd == -1)
        {
          puts ("eventfd2(EFD_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("eventfd2(EFD_CLOEXEC) does not set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 8627c89ae9e8..2a361ccdc7ca 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -164,3 +164,4 @@ cond_syscall(sys_timerfd_gettime);
 cond_syscall(compat_sys_timerfd_settime);
 cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);
+cond_syscall(sys_eventfd2);

commit 9deb27baedb79759c3ab9435a7d8b841842d56e9
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:24 2008 -0700

    flag parameters: signalfd
    
    This patch adds the new signalfd4 syscall.  It extends the old signalfd
    syscall by one parameter which is meant to hold a flag value.  In this
    patch the only flag support is SFD_CLOEXEC which causes the close-on-exec
    flag for the returned file descriptor to be set.
    
    A new name SFD_CLOEXEC is introduced which in this implementation must
    have the same value as O_CLOEXEC.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <signal.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_signalfd4
    # ifdef __x86_64__
    #  define __NR_signalfd4 289
    # elif defined __i386__
    #  define __NR_signalfd4 327
    # else
    #  error "need __NR_signalfd4"
    # endif
    #endif
    
    #define SFD_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      sigset_t ss;
      sigemptyset (&ss);
      sigaddset (&ss, SIGUSR1);
      int fd = syscall (__NR_signalfd4, -1, &ss, 8, 0);
      if (fd == -1)
        {
          puts ("signalfd4(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("signalfd4(0) set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_signalfd4, -1, &ss, 8, SFD_CLOEXEC);
      if (fd == -1)
        {
          puts ("signalfd4(SFD_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("signalfd4(SFD_CLOEXEC) does not set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 2f0b8a2e600f..8627c89ae9e8 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -156,6 +156,7 @@ cond_syscall(sys_ioprio_get);
 
 /* New file descriptors */
 cond_syscall(sys_signalfd);
+cond_syscall(sys_signalfd4);
 cond_syscall(compat_sys_signalfd);
 cond_syscall(sys_timerfd_create);
 cond_syscall(sys_timerfd_settime);

commit aaca0bdca573f3f51ea03139f9c7289541e7bca3
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:20 2008 -0700

    flag parameters: paccept
    
    This patch is by far the most complex in the series.  It adds a new syscall
    paccept.  This syscall differs from accept in that it adds (at the userlevel)
    two additional parameters:
    
    - a signal mask
    - a flags value
    
    The flags parameter can be used to set flag like SOCK_CLOEXEC.  This is
    imlpemented here as well.  Some people argued that this is a property which
    should be inherited from the file desriptor for the server but this is against
    POSIX.  Additionally, we really want the signal mask parameter as well
    (similar to pselect, ppoll, etc).  So an interface change in inevitable.
    
    The flag value is the same as for socket and socketpair.  I think diverging
    here will only create confusion.  Similar to the filesystem interfaces where
    the use of the O_* constants differs, it is acceptable here.
    
    The signal mask is handled as for pselect etc.  The mask is temporarily
    installed for the thread and removed before the call returns.  I modeled the
    code after pselect.  If there is a problem it's likely also in pselect.
    
    For architectures which use socketcall I maintained this interface instead of
    adding a system call.  The symmetry shouldn't be broken.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <errno.h>
    #include <fcntl.h>
    #include <pthread.h>
    #include <signal.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <netinet/in.h>
    #include <sys/socket.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_paccept
    # ifdef __x86_64__
    #  define __NR_paccept 288
    # elif defined __i386__
    #  define SYS_PACCEPT 18
    #  define USE_SOCKETCALL 1
    # else
    #  error "need __NR_paccept"
    # endif
    #endif
    
    #ifdef USE_SOCKETCALL
    # define paccept(fd, addr, addrlen, mask, flags) \
      ({ long args[6] = { \
           (long) fd, (long) addr, (long) addrlen, (long) mask, 8, (long) flags }; \
         syscall (__NR_socketcall, SYS_PACCEPT, args); })
    #else
    # define paccept(fd, addr, addrlen, mask, flags) \
      syscall (__NR_paccept, fd, addr, addrlen, mask, 8, flags)
    #endif
    
    #define PORT 57392
    
    #define SOCK_CLOEXEC O_CLOEXEC
    
    static pthread_barrier_t b;
    
    static void *
    tf (void *arg)
    {
      pthread_barrier_wait (&b);
      int s = socket (AF_INET, SOCK_STREAM, 0);
      struct sockaddr_in sin;
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
    
      pthread_barrier_wait (&b);
      s = socket (AF_INET, SOCK_STREAM, 0);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
      pthread_barrier_wait (&b);
    
      pthread_barrier_wait (&b);
      sleep (2);
      pthread_kill ((pthread_t) arg, SIGUSR1);
    
      return NULL;
    }
    
    static void
    handler (int s)
    {
    }
    
    int
    main (void)
    {
      pthread_barrier_init (&b, NULL, 2);
    
      struct sockaddr_in sin;
      pthread_t th;
      if (pthread_create (&th, NULL, tf, (void *) pthread_self ()) != 0)
        {
          puts ("pthread_create failed");
          return 1;
        }
    
      int s = socket (AF_INET, SOCK_STREAM, 0);
      int reuse = 1;
      setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof (reuse));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      bind (s, (struct sockaddr *) &sin, sizeof (sin));
      listen (s, SOMAXCONN);
    
      pthread_barrier_wait (&b);
    
      int s2 = paccept (s, NULL, 0, NULL, 0);
      if (s2 < 0)
        {
          puts ("paccept(0) failed");
          return 1;
        }
    
      int coe = fcntl (s2, F_GETFD);
      if (coe & FD_CLOEXEC)
        {
          puts ("paccept(0) set close-on-exec-flag");
          return 1;
        }
      close (s2);
    
      pthread_barrier_wait (&b);
    
      s2 = paccept (s, NULL, 0, NULL, SOCK_CLOEXEC);
      if (s2 < 0)
        {
          puts ("paccept(SOCK_CLOEXEC) failed");
          return 1;
        }
    
      coe = fcntl (s2, F_GETFD);
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("paccept(SOCK_CLOEXEC) does not set close-on-exec flag");
          return 1;
        }
      close (s2);
    
      pthread_barrier_wait (&b);
    
      struct sigaction sa;
      sa.sa_handler = handler;
      sa.sa_flags = 0;
      sigemptyset (&sa.sa_mask);
      sigaction (SIGUSR1, &sa, NULL);
    
      sigset_t ss;
      pthread_sigmask (SIG_SETMASK, NULL, &ss);
      sigaddset (&ss, SIGUSR1);
      pthread_sigmask (SIG_SETMASK, &ss, NULL);
    
      sigdelset (&ss, SIGUSR1);
      alarm (4);
      pthread_barrier_wait (&b);
    
      errno = 0 ;
      s2 = paccept (s, NULL, 0, &ss, 0);
      if (s2 != -1 || errno != EINTR)
        {
          puts ("paccept did not fail with EINTR");
          return 1;
        }
    
      close (s);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: make it compile]
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0fea0ee12da9..2f0b8a2e600f 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -31,6 +31,7 @@ cond_syscall(sys_socketpair);
 cond_syscall(sys_bind);
 cond_syscall(sys_listen);
 cond_syscall(sys_accept);
+cond_syscall(sys_paccept);
 cond_syscall(sys_connect);
 cond_syscall(sys_getsockname);
 cond_syscall(sys_getpeername);

commit 5f17156fc55abac476d180e480bedb0f07f01b14
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jul 21 14:21:37 2008 -0700

    Fix build on COMPAT platforms when CONFIG_EPOLL is disabled
    
    Add missing cond_syscall() entry for compat_sys_epoll_pwait.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: <stable@kernel.org>         [2.6.25.x, 2.6.26.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 5b9b467de070..0fea0ee12da9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -59,6 +59,7 @@ cond_syscall(sys_epoll_create);
 cond_syscall(sys_epoll_ctl);
 cond_syscall(sys_epoll_wait);
 cond_syscall(sys_epoll_pwait);
+cond_syscall(compat_sys_epoll_pwait);
 cond_syscall(sys_semget);
 cond_syscall(sys_semop);
 cond_syscall(sys_semtimedop);

commit 4d672e7ac79b5ec5cdc90e450823441e20464691
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Mon Feb 4 22:27:26 2008 -0800

    timerfd: new timerfd API
    
    This is the new timerfd API as it is implemented by the following patch:
    
    int timerfd_create(int clockid, int flags);
    int timerfd_settime(int ufd, int flags,
                        const struct itimerspec *utmr,
                        struct itimerspec *otmr);
    int timerfd_gettime(int ufd, struct itimerspec *otmr);
    
    The timerfd_create() API creates an un-programmed timerfd fd.  The "clockid"
    parameter can be either CLOCK_MONOTONIC or CLOCK_REALTIME.
    
    The timerfd_settime() API give new settings by the timerfd fd, by optionally
    retrieving the previous expiration time (in case the "otmr" parameter is not
    NULL).
    
    The time value specified in "utmr" is absolute, if the TFD_TIMER_ABSTIME bit
    is set in the "flags" parameter.  Otherwise it's a relative time.
    
    The timerfd_gettime() API returns the next expiration time of the timer, or
    {0, 0} if the timerfd has not been set yet.
    
    Like the previous timerfd API implementation, read(2) and poll(2) are
    supported (with the same interface).  Here's a simple test program I used to
    exercise the new timerfd APIs:
    
    http://www.xmailserver.org/timerfd-test2.c
    
    [akpm@linux-foundation.org: coding-style cleanups]
    [akpm@linux-foundation.org: fix ia64 build]
    [akpm@linux-foundation.org: fix m68k build]
    [akpm@linux-foundation.org: fix mips build]
    [akpm@linux-foundation.org: fix alpha, arm, blackfin, cris, m68k, s390, sparc and sparc64 builds]
    [heiko.carstens@de.ibm.com: fix s390]
    [akpm@linux-foundation.org: fix powerpc build]
    [akpm@linux-foundation.org: fix sparc64 more]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index beee5b3b68a2..5b9b467de070 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -154,7 +154,10 @@ cond_syscall(sys_ioprio_get);
 
 /* New file descriptors */
 cond_syscall(sys_signalfd);
-cond_syscall(sys_timerfd);
 cond_syscall(compat_sys_signalfd);
-cond_syscall(compat_sys_timerfd);
+cond_syscall(sys_timerfd_create);
+cond_syscall(sys_timerfd_settime);
+cond_syscall(sys_timerfd_gettime);
+cond_syscall(compat_sys_timerfd_settime);
+cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);

commit fa28237cfcc5827553044cbd6ee52e33692b0faa
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Jan 24 08:35:13 2008 +1100

    [POWERPC] Provide a way to protect 4k subpages when using 64k pages
    
    Using 64k pages on 64-bit PowerPC systems makes life difficult for
    emulators that are trying to emulate an ISA, such as x86, which use a
    smaller page size, since the emulator can no longer use the MMU and
    the normal system calls for controlling page protections.  Of course,
    the emulator can emulate the MMU by checking and possibly remapping
    the address for each memory access in software, but that is pretty
    slow.
    
    This provides a facility for such programs to control the access
    permissions on individual 4k sub-pages of 64k pages.  The idea is
    that the emulator supplies an array of protection masks to apply to a
    specified range of virtual addresses.  These masks are applied at the
    level where hardware PTEs are inserted into the hardware page table
    based on the Linux PTEs, so the Linux PTEs are not affected.  Note
    that this new mechanism does not allow any access that would otherwise
    be prohibited; it can only prohibit accesses that would otherwise be
    allowed.  This new facility is only available on 64-bit PowerPC and
    only when the kernel is configured for 64k pages.
    
    The masks are supplied using a new subpage_prot system call, which
    takes a starting virtual address and length, and a pointer to an array
    of protection masks in memory.  The array has a 32-bit word per 64k
    page to be protected; each 32-bit word consists of 16 2-bit fields,
    for which 0 allows any access (that is otherwise allowed), 1 prevents
    write accesses, and 2 or 3 prevent any access.
    
    Implicit in this is that the regions of the address space that are
    protected are switched to use 4k hardware pages rather than 64k
    hardware pages (on machines with hardware 64k page support).  In fact
    the whole process is switched to use 4k hardware pages when the
    subpage_prot system call is used, but this could be improved in future
    to switch only the affected segments.
    
    The subpage protection bits are stored in a 3 level tree akin to the
    page table tree.  The top level of this tree is stored in a structure
    that is appended to the top level of the page table tree, i.e., the
    pgd array.  Since it will often only be 32-bit addresses (below 4GB)
    that are protected, the pointers to the first four bottom level pages
    are also stored in this structure (each bottom level page contains the
    protection bits for 1GB of address space), so the protection bits for
    addresses below 4GB can be accessed with one fewer loads than those
    for higher addresses.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 56cb009a4b35..beee5b3b68a2 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -131,6 +131,7 @@ cond_syscall(sys32_sysctl);
 cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);
+cond_syscall(sys_subpage_prot);
 
 /* mmu depending weak syscall entries */
 cond_syscall(sys_mprotect);

commit f3baa4827a4b13905dbbdddf15463541bd671dfd
Author: David S. Miller <davem@bnsf.davemloft.net>
Date:   Mon Oct 29 00:54:39 2007 -0700

    [COMPAT]: Fix build on COMPAT platforms when CONFIG_NET is disabled.
    
    Add some missing cond_syscall() entries for this case.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 52c7a151e298..56cb009a4b35 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -40,10 +40,14 @@ cond_syscall(sys_recvfrom);
 cond_syscall(sys_recv);
 cond_syscall(sys_socket);
 cond_syscall(sys_setsockopt);
+cond_syscall(compat_sys_setsockopt);
 cond_syscall(sys_getsockopt);
+cond_syscall(compat_sys_getsockopt);
 cond_syscall(sys_shutdown);
 cond_syscall(sys_sendmsg);
+cond_syscall(compat_sys_sendmsg);
 cond_syscall(sys_recvmsg);
+cond_syscall(compat_sys_recvmsg);
 cond_syscall(sys_socketcall);
 cond_syscall(sys_futex);
 cond_syscall(compat_sys_futex);

commit 0732a552cb31a40db47f7d48e54847190e452da9
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 23:29:25 2007 -0700

    kernel/sys_ni.c: add dummy sys_ni_syscall() prototype
    
    kernel/sys_ni.c can't #include <linux/syscalls.h> due to cond_syscall(),
    but let's tell gcc to not warn with -Wmissing-prototypes.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b0ec498a18d9..52c7a151e298 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -4,6 +4,10 @@
 
 #include <asm/unistd.h>
 
+/*  we can't #include <linux/syscalls.h> here,
+    but tell gcc to not warn with -Wmissing-prototypes  */
+asmlinkage long sys_ni_syscall(void);
+
 /*
  * Non-implemented system calls get redirected here.
  */

commit b716395e2b8e450e294537de0c91476ded2f0395
Author: Vasily Tarasov <vtaras@openvz.org>
Date:   Sun Jul 15 23:41:12 2007 -0700

    diskquota: 32bit quota tools on 64bit architectures
    
    OpenVZ Linux kernel team has discovered the problem with 32bit quota tools
    working on 64bit architectures.  In 2.6.10 kernel sys32_quotactl() function
    was replaced by sys_quotactl() with the comment "sys_quotactl seems to be
    32/64bit clean, enable it for 32bit" However this isn't right.  Look at
    if_dqblk structure:
    
    struct if_dqblk {
            __u64 dqb_bhardlimit;
            __u64 dqb_bsoftlimit;
            __u64 dqb_curspace;
            __u64 dqb_ihardlimit;
            __u64 dqb_isoftlimit;
            __u64 dqb_curinodes;
            __u64 dqb_btime;
            __u64 dqb_itime;
            __u32 dqb_valid;
    };
    
    For 32 bit quota tools sizeof(if_dqblk) == 0x44.
    But for 64 bit kernel its size is 0x48, 'cause of alignment!
    Thus we got a problem. Attached patch reintroduce sys32_quotactl() function,
    that handles this and related situations.
    
    [michal.k.k.piotrowski@gmail.com: build fix]
    [akpm@linux-foundation.org: Make it link with CONFIG_QUOTA=n]
    Signed-off-by: Vasily Tarasov <vtaras@openvz.org>
    Cc: Andi Kleen <ak@suse.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7e11e2c98bf9..b0ec498a18d9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -14,6 +14,7 @@ asmlinkage long sys_ni_syscall(void)
 
 cond_syscall(sys_nfsservctl);
 cond_syscall(sys_quotactl);
+cond_syscall(sys32_quotactl);
 cond_syscall(sys_acct);
 cond_syscall(sys_lookup_dcookie);
 cond_syscall(sys_swapon);

commit 8df767dd759c1390f604814ee5b2d1489f9a59f7
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Sat May 12 10:37:02 2007 -0700

    compat signalfd and timerfd are cond syscalls
    
    Add missing cond_syscall statements for compat_sys_signalfd and
    compat_sys_timerfd.
    
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b6d77a8a1ca9..7e11e2c98bf9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -145,4 +145,6 @@ cond_syscall(sys_ioprio_get);
 /* New file descriptors */
 cond_syscall(sys_signalfd);
 cond_syscall(sys_timerfd);
+cond_syscall(compat_sys_signalfd);
+cond_syscall(compat_sys_timerfd);
 cond_syscall(sys_eventfd);

commit e1ad7468c77ddb94b0615d5f50fa255525fde0f0
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:19 2007 -0700

    signal/timer/event: eventfd core
    
    This is a very simple and light file descriptor, that can be used as event
    wait/dispatch by userspace (both wait and dispatch) and by the kernel
    (dispatch only).  It can be used instead of pipe(2) in all cases where those
    would simply be used to signal events.  Their kernel overhead is much lower
    than pipes, and they do not consume two fds.  When used in the kernel, it can
    offer an fd-bridge to enable, for example, functionalities like KAIO or
    syslets/threadlets to signal to an fd the completion of certain operations.
    But more in general, an eventfd can be used by the kernel to signal readiness,
    in a POSIX poll/select way, of interfaces that would otherwise be incompatible
    with it.  The API is:
    
    int eventfd(unsigned int count);
    
    The eventfd API accepts an initial "count" parameter, and returns an eventfd
    fd.  It supports poll(2) (POLLIN, POLLOUT, POLLERR), read(2) and write(2).
    
    The POLLIN flag is raised when the internal counter is greater than zero.
    
    The POLLOUT flag is raised when at least a value of "1" can be written to the
    internal counter.
    
    The POLLERR flag is raised when an overflow in the counter value is detected.
    
    The write(2) operation can never overflow the counter, since it blocks (unless
    O_NONBLOCK is set, in which case -EAGAIN is returned).
    
    But the eventfd_signal() function can do it, since it's supposed to not sleep
    during its operation.
    
    The read(2) function reads the __u64 counter value, and reset the internal
    value to zero.  If the value read is equal to (__u64) -1, an overflow happened
    on the internal counter (due to 2^64 eventfd_signal() posts that has never
    been retired - unlickely, but possible).
    
    The write(2) call writes an __u64 count value, and adds it to the current
    counter.  The eventfd fd supports O_NONBLOCK also.
    
    On the kernel side, we have:
    
    struct file *eventfd_fget(int fd);
    int eventfd_signal(struct file *file, unsigned int n);
    
    The eventfd_fget() should be called to get a struct file* from an eventfd fd
    (this is an fget() + check of f_op being an eventfd fops pointer).
    
    The kernel can then call eventfd_signal() every time it wants to post an event
    to userspace.  The eventfd_signal() function can be called from any context.
    An eventfd() simple test and bench is available here:
    
    http://www.xmailserver.org/eventfd-bench.c
    
    This is the eventfd-based version of pipetest-4 (pipe(2) based):
    
    http://www.xmailserver.org/pipetest-4.c
    
    Not that performance matters much in the eventfd case, but eventfd-bench
    shows almost as double as performance than pipetest-4.
    
    [akpm@linux-foundation.org: fix i386 build]
    [akpm@linux-foundation.org: add sys_eventfd to sys_ni.c]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b18f62549515..b6d77a8a1ca9 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -145,3 +145,4 @@ cond_syscall(sys_ioprio_get);
 /* New file descriptors */
 cond_syscall(sys_signalfd);
 cond_syscall(sys_timerfd);
+cond_syscall(sys_eventfd);

commit b215e283992899650c4271e7385c79e26fb9a88e
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:16 2007 -0700

    signal/timer/event: timerfd core
    
    This patch introduces a new system call for timers events delivered though
    file descriptors.  This allows timer event to be used with standard POSIX
    poll(2), select(2) and read(2).  As a consequence of supporting the Linux
    f_op->poll subsystem, they can be used with epoll(2) too.
    
    The system call is defined as:
    
    int timerfd(int ufd, int clockid, int flags, const struct itimerspec *utmr);
    
    The "ufd" parameter allows for re-use (re-programming) of an existing timerfd
    w/out going through the close/open cycle (same as signalfd).  If "ufd" is -1,
    s new file descriptor will be created, otherwise the existing "ufd" will be
    re-programmed.
    
    The "clockid" parameter is either CLOCK_MONOTONIC or CLOCK_REALTIME.  The time
    specified in the "utmr->it_value" parameter is the expiry time for the timer.
    
    If the TFD_TIMER_ABSTIME flag is set in "flags", this is an absolute time,
    otherwise it's a relative time.
    
    If the time specified in the "utmr->it_interval" is not zero (.tv_sec == 0,
    tv_nsec == 0), this is the period at which the following ticks should be
    generated.
    
    The "utmr->it_interval" should be set to zero if only one tick is requested.
    Setting the "utmr->it_value" to zero will disable the timer, or will create a
    timerfd without the timer enabled.
    
    The function returns the new (or same, in case "ufd" is a valid timerfd
    descriptor) file, or -1 in case of error.
    
    As stated before, the timerfd file descriptor supports poll(2), select(2) and
    epoll(2).  When a timer event happened on the timerfd, a POLLIN mask will be
    returned.
    
    The read(2) call can be used, and it will return a u32 variable holding the
    number of "ticks" that happened on the interface since the last call to
    read(2).  The read(2) call supportes the O_NONBLOCK flag too, and EAGAIN will
    be returned if no ticks happened.
    
    A quick test program, shows timerfd working correctly on my amd64 box:
    
    http://www.xmailserver.org/timerfd-test.c
    
    [akpm@linux-foundation.org: add sys_timerfd to sys_ni.c]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 807e9bb8fcdb..b18f62549515 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -144,3 +144,4 @@ cond_syscall(sys_ioprio_get);
 
 /* New file descriptors */
 cond_syscall(sys_signalfd);
+cond_syscall(sys_timerfd);

commit fba2afaaec790dc5ab4ae8827972f342211bbb86
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:13 2007 -0700

    signal/timer/event: signalfd core
    
    This patch series implements the new signalfd() system call.
    
    I took part of the original Linus code (and you know how badly it can be
    broken :), and I added even more breakage ;) Signals are fetched from the same
    signal queue used by the process, so signalfd will compete with standard
    kernel delivery in dequeue_signal().  If you want to reliably fetch signals on
    the signalfd file, you need to block them with sigprocmask(SIG_BLOCK).  This
    seems to be working fine on my Dual Opteron machine.  I made a quick test
    program for it:
    
    http://www.xmailserver.org/signafd-test.c
    
    The signalfd() system call implements signal delivery into a file descriptor
    receiver.  The signalfd file descriptor if created with the following API:
    
    int signalfd(int ufd, const sigset_t *mask, size_t masksize);
    
    The "ufd" parameter allows to change an existing signalfd sigmask, w/out going
    to close/create cycle (Linus idea).  Use "ufd" == -1 if you want a brand new
    signalfd file.
    
    The "mask" allows to specify the signal mask of signals that we are interested
    in.  The "masksize" parameter is the size of "mask".
    
    The signalfd fd supports the poll(2) and read(2) system calls.  The poll(2)
    will return POLLIN when signals are available to be dequeued.  As a direct
    consequence of supporting the Linux poll subsystem, the signalfd fd can use
    used together with epoll(2) too.
    
    The read(2) system call will return a "struct signalfd_siginfo" structure in
    the userspace supplied buffer.  The return value is the number of bytes copied
    in the supplied buffer, or -1 in case of error.  The read(2) call can also
    return 0, in case the sighand structure to which the signalfd was attached,
    has been orphaned.  The O_NONBLOCK flag is also supported, and read(2) will
    return -EAGAIN in case no signal is available.
    
    If the size of the buffer passed to read(2) is lower than sizeof(struct
    signalfd_siginfo), -EINVAL is returned.  A read from the signalfd can also
    return -ERESTARTSYS in case a signal hits the process.  The format of the
    struct signalfd_siginfo is, and the valid fields depends of the (->code &
    __SI_MASK) value, in the same way a struct siginfo would:
    
    struct signalfd_siginfo {
            __u32 signo;    /* si_signo */
            __s32 err;      /* si_errno */
            __s32 code;     /* si_code */
            __u32 pid;      /* si_pid */
            __u32 uid;      /* si_uid */
            __s32 fd;       /* si_fd */
            __u32 tid;      /* si_fd */
            __u32 band;     /* si_band */
            __u32 overrun;  /* si_overrun */
            __u32 trapno;   /* si_trapno */
            __s32 status;   /* si_status */
            __s32 svint;    /* si_int */
            __u64 svptr;    /* si_ptr */
            __u64 utime;    /* si_utime */
            __u64 stime;    /* si_stime */
            __u64 addr;     /* si_addr */
    };
    
    [akpm@linux-foundation.org: fix signalfd_copyinfo() on i386]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d7306d0f3dfc..807e9bb8fcdb 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -141,3 +141,6 @@ cond_syscall(compat_sys_migrate_pages);
 cond_syscall(sys_bdflush);
 cond_syscall(sys_ioprio_set);
 cond_syscall(sys_ioprio_get);
+
+/* New file descriptors */
+cond_syscall(sys_signalfd);

commit 3fd593979802f81ff6452596ac61e3840f917589
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Nov 2 22:07:24 2006 -0800

    [PATCH] Create compat_sys_migrate_pages
    
    This is needed on bigendian 64bit architectures.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0e53314b14de..d7306d0f3dfc 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -135,6 +135,7 @@ cond_syscall(sys_madvise);
 cond_syscall(sys_mremap);
 cond_syscall(sys_remap_file_pages);
 cond_syscall(compat_sys_move_pages);
+cond_syscall(compat_sys_migrate_pages);
 
 /* block-layer dependent */
 cond_syscall(sys_bdflush);

commit 39af114377bf80d2a88e47be33d578d1fa9b0775
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Oct 16 09:01:46 2006 -0700

    [PATCH] fix epoll_pwait when EPOLL=n
    
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=7371
    
    sys_epoll_pwait needs to be listed as a conditional (weak)
    entry point for CONFIG_EPOLL=n.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7a3b2e75f040..0e53314b14de 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -49,6 +49,7 @@ cond_syscall(compat_sys_get_robust_list);
 cond_syscall(sys_epoll_create);
 cond_syscall(sys_epoll_ctl);
 cond_syscall(sys_epoll_wait);
+cond_syscall(sys_epoll_pwait);
 cond_syscall(sys_semget);
 cond_syscall(sys_semop);
 cond_syscall(sys_semtimedop);

commit 9361401eb7619c033e2394e4f9f6d410d6719ac7
Author: David Howells <dhowells@redhat.com>
Date:   Sat Sep 30 20:45:40 2006 +0200

    [PATCH] BLOCK: Make it possible to disable the block layer [try #6]
    
    Make it possible to disable the block layer.  Not all embedded devices require
    it, some can make do with just JFFS2, NFS, ramfs, etc - none of which require
    the block layer to be present.
    
    This patch does the following:
    
     (*) Introduces CONFIG_BLOCK to disable the block layer, buffering and blockdev
         support.
    
     (*) Adds dependencies on CONFIG_BLOCK to any configuration item that controls
         an item that uses the block layer.  This includes:
    
         (*) Block I/O tracing.
    
         (*) Disk partition code.
    
         (*) All filesystems that are block based, eg: Ext3, ReiserFS, ISOFS.
    
         (*) The SCSI layer.  As far as I can tell, even SCSI chardevs use the
             block layer to do scheduling.  Some drivers that use SCSI facilities -
             such as USB storage - end up disabled indirectly from this.
    
         (*) Various block-based device drivers, such as IDE and the old CDROM
             drivers.
    
         (*) MTD blockdev handling and FTL.
    
         (*) JFFS - which uses set_bdev_super(), something it could avoid doing by
             taking a leaf out of JFFS2's book.
    
     (*) Makes most of the contents of linux/blkdev.h, linux/buffer_head.h and
         linux/elevator.h contingent on CONFIG_BLOCK being set.  sector_div() is,
         however, still used in places, and so is still available.
    
     (*) Also made contingent are the contents of linux/mpage.h, linux/genhd.h and
         parts of linux/fs.h.
    
     (*) Makes a number of files in fs/ contingent on CONFIG_BLOCK.
    
     (*) Makes mm/bounce.c (bounce buffering) contingent on CONFIG_BLOCK.
    
     (*) set_page_dirty() doesn't call __set_page_dirty_buffers() if CONFIG_BLOCK
         is not enabled.
    
     (*) fs/no-block.c is created to hold out-of-line stubs and things that are
         required when CONFIG_BLOCK is not set:
    
         (*) Default blockdev file operations (to give error ENODEV on opening).
    
     (*) Makes some /proc changes:
    
         (*) /proc/devices does not list any blockdevs.
    
         (*) /proc/diskstats and /proc/partitions are contingent on CONFIG_BLOCK.
    
     (*) Makes some compat ioctl handling contingent on CONFIG_BLOCK.
    
     (*) If CONFIG_BLOCK is not defined, makes sys_quotactl() return -ENODEV if
         given command other than Q_SYNC or if a special device is specified.
    
     (*) In init/do_mounts.c, no reference is made to the blockdev routines if
         CONFIG_BLOCK is not defined.  This does not prohibit NFS roots or JFFS2.
    
     (*) The bdflush, ioprio_set and ioprio_get syscalls can now be absent (return
         error ENOSYS by way of cond_syscall if so).
    
     (*) The seclvl_bd_claim() and seclvl_bd_release() security calls do nothing if
         CONFIG_BLOCK is not set, since they can't then happen.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 6991bece67e8..7a3b2e75f040 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -134,3 +134,8 @@ cond_syscall(sys_madvise);
 cond_syscall(sys_mremap);
 cond_syscall(sys_remap_file_pages);
 cond_syscall(compat_sys_move_pages);
+
+/* block-layer dependent */
+cond_syscall(sys_bdflush);
+cond_syscall(sys_ioprio_set);
+cond_syscall(sys_ioprio_get);

commit 1b2db9fb7adc4d67d9ce7d16ce79c41ee84730fe
Author: Christoph Lameter <clameter@sgi.com>
Date:   Fri Jun 23 02:03:56 2006 -0700

    [PATCH] sys_move_pages: 32bit support (i386, x86_64)
    
    sys_move_pages() support for 32bit (i386 plus x86_64 compat layer)
    
    Add support for move_pages() on i386 and also add the compat functions
    necessary to run 32 bit binaries on x86_64.
    
    Add compat_sys_move_pages to the x86_64 32bit binary layer.  Note that it is
    not up to date so I added the missing pieces.  Not sure if this is done the
    right way.
    
    [akpm@osdl.org: compile fix]
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Cc: Andi Kleen <ak@muc.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 597229749dec..6991bece67e8 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -133,3 +133,4 @@ cond_syscall(sys_mincore);
 cond_syscall(sys_madvise);
 cond_syscall(sys_mremap);
 cond_syscall(sys_remap_file_pages);
+cond_syscall(compat_sys_move_pages);

commit 742755a1d8ce2b548428f7aacf1758b4bba50080
Author: Christoph Lameter <clameter@sgi.com>
Date:   Fri Jun 23 02:03:55 2006 -0700

    [PATCH] page migration: sys_move_pages(): support moving of individual pages
    
    move_pages() is used to move individual pages of a process. The function can
    be used to determine the location of pages and to move them onto the desired
    node. move_pages() returns status information for each page.
    
    long move_pages(pid, number_of_pages_to_move,
                    addresses_of_pages[],
                    nodes[] or NULL,
                    status[],
                    flags);
    
    The addresses of pages is an array of void * pointing to the
    pages to be moved.
    
    The nodes array contains the node numbers that the pages should be moved
    to. If a NULL is passed instead of an array then no pages are moved but
    the status array is updated. The status request may be used to determine
    the page state before issuing another move_pages() to move pages.
    
    The status array will contain the state of all individual page migration
    attempts when the function terminates. The status array is only valid if
    move_pages() completed successfullly.
    
    Possible page states in status[]:
    
    0..MAX_NUMNODES The page is now on the indicated node.
    
    -ENOENT         Page is not present
    
    -EACCES         Page is mapped by multiple processes and can only
                    be moved if MPOL_MF_MOVE_ALL is specified.
    
    -EPERM          The page has been mlocked by a process/driver and
                    cannot be moved.
    
    -EBUSY          Page is busy and cannot be moved. Try again later.
    
    -EFAULT         Invalid address (no VMA or zero page).
    
    -ENOMEM         Unable to allocate memory on target node.
    
    -EIO            Unable to write back page. The page must be written
                    back in order to move it since the page is dirty and the
                    filesystem does not provide a migration function that
                    would allow the moving of dirty pages.
    
    -EINVAL         A dirty page cannot be moved. The filesystem does not provide
                    a migration function and has no ability to write back pages.
    
    The flags parameter indicates what types of pages to move:
    
    MPOL_MF_MOVE    Move pages that are only mapped by the process.
    
    MPOL_MF_MOVE_ALL Also move pages that are mapped by multiple processes.
                    Requires sufficient capabilities.
    
    Possible return codes from move_pages()
    
    -ENOENT         No pages found that would require moving. All pages
                    are either already on the target node, not present, had an
                    invalid address or could not be moved because they were
                    mapped by multiple processes.
    
    -EINVAL         Flags other than MPOL_MF_MOVE(_ALL) specified or an attempt
                    to migrate pages in a kernel thread.
    
    -EPERM          MPOL_MF_MOVE_ALL specified without sufficient priviledges.
                    or an attempt to move a process belonging to another user.
    
    -EACCES         One of the target nodes is not allowed by the current cpuset.
    
    -ENODEV         One of the target nodes is not online.
    
    -ESRCH          Process does not exist.
    
    -E2BIG          Too many pages to move.
    
    -ENOMEM         Not enough memory to allocate control array.
    
    -EFAULT         Parameters could not be accessed.
    
    A test program for move_pages() may be found with the patches
    on ftp.kernel.org:/pub/linux/kernel/people/christoph/pmig/patches-2.6.17-rc4-mm3
    
    From: Christoph Lameter <clameter@sgi.com>
    
      Detailed results for sys_move_pages()
    
      Pass a pointer to an integer to get_new_page() that may be used to
      indicate where the completion status of a migration operation should be
      placed.  This allows sys_move_pags() to report back exactly what happened to
      each page.
    
      Wish there would be a better way to do this. Looks a bit hacky.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: Jes Sorensen <jes@trained-monkey.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Lee Schermerhorn <lee.schermerhorn@hp.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 5433195040f1..597229749dec 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -87,6 +87,7 @@ cond_syscall(sys_inotify_init);
 cond_syscall(sys_inotify_add_watch);
 cond_syscall(sys_inotify_rm_watch);
 cond_syscall(sys_migrate_pages);
+cond_syscall(sys_move_pages);
 cond_syscall(sys_chown16);
 cond_syscall(sys_fchown16);
 cond_syscall(sys_getegid16);

commit 3016b421534e2fa8a5eede1c12a3eba6164822f4
Author: Hyok S. Choi <hyok.choi@samsung.com>
Date:   Mon Apr 10 22:53:06 2006 -0700

    [PATCH] frv: define MMU mode specific syscalls as 'cond_syscall' and clean up unneeded macros
    
    For some architectures, a few syscalls are not linked in noMMU mode.  In
    that case, the MMU depending syscalls are needed to be defined as
    'cond_syscall'.  For example, ARM architecture selectively links sys_mlock
    by the mode configuration.
    
    In case of FRV, it has been managed by #ifdef CONFIG_MMU macro in
    arch/frv/kernel/entry.S.  However these conditional macros are just
    duplicates if they were defined as cond_syscall.  Compilation test is done
    with FRV toolchains for both of MMU and noMMU mode.
    
    Signed-off-by: Hyok S. Choi <hyok.choi@samsung.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d82864c4a617..5433195040f1 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -120,3 +120,15 @@ cond_syscall(sys32_sysctl);
 cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);
+
+/* mmu depending weak syscall entries */
+cond_syscall(sys_mprotect);
+cond_syscall(sys_msync);
+cond_syscall(sys_mlock);
+cond_syscall(sys_munlock);
+cond_syscall(sys_mlockall);
+cond_syscall(sys_munlockall);
+cond_syscall(sys_mincore);
+cond_syscall(sys_madvise);
+cond_syscall(sys_mremap);
+cond_syscall(sys_remap_file_pages);

commit 0771dfefc9e538f077d0b43b6dec19a5a67d0e70
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Mar 27 01:16:22 2006 -0800

    [PATCH] lightweight robust futexes: core
    
    Add the core infrastructure for robust futexes: structure definitions, the new
    syscalls and the do_exit() based cleanup mechanism.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Acked-by: Ulrich Drepper <drepper@redhat.com>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1067090db6b1..d82864c4a617 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -42,6 +42,10 @@ cond_syscall(sys_recvmsg);
 cond_syscall(sys_socketcall);
 cond_syscall(sys_futex);
 cond_syscall(compat_sys_futex);
+cond_syscall(sys_set_robust_list);
+cond_syscall(compat_sys_set_robust_list);
+cond_syscall(sys_get_robust_list);
+cond_syscall(compat_sys_get_robust_list);
 cond_syscall(sys_epoll_create);
 cond_syscall(sys_epoll_ctl);
 cond_syscall(sys_epoll_wait);

commit 7fd105e758c8d746d57ab7e77f100e096bf153c8
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Feb 20 18:28:08 2006 -0800

    [PATCH] Fix compile for CONFIG_SYSVIPC=n or CONFIG_SYSCTL=n
    
    The compat syscalls are added to sys_ni.c since they are not defined if the
    above CONFIG options are off.  Also, nfs would not build with CONFIG_SYSCTL
    off.
    
    Noticed by Arthur Othieno.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 17313b99e53d..1067090db6b1 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -104,6 +104,8 @@ cond_syscall(sys_setreuid16);
 cond_syscall(sys_setuid16);
 cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
+cond_syscall(compat_sys_ipc);
+cond_syscall(compat_sys_sysctl);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 6150c32589d1976ca8a5c987df951088c05a7542
Merge: 44637a12f80b be42d5fa3772
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jan 9 10:03:44 2006 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc-merge

commit 64ca9004b819ab87648dbfc78f3ef49ee491343e
Author: Matt Mackall <mpm@selenic.com>
Date:   Sun Jan 8 01:05:26 2006 -0800

    [PATCH] Make vm86 support optional
    
    This adds an option to remove vm86 support under CONFIG_EMBEDDED.  Saves
    about 5k.
    
    This version eliminates most of the #ifdefs of the previous version and
    instead uses function stubs in vm86.h.  Also, release_vm86_irqs is moved
    from asm-i386/irq.h to a more appropriate home in vm86.h so that the stubs
    can live together.
    
    $ size vmlinux-baseline vmlinux-novm86
       text    data     bss     dec     hex filename
    2920821  523232  190652 3634705  377611 vmlinux-baseline
    2916268  523100  190492 3629860  376324 vmlinux-novm86
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 72cafc922d39..bd3b9bfcfcec 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -102,6 +102,8 @@ cond_syscall(sys_setresgid16);
 cond_syscall(sys_setresuid16);
 cond_syscall(sys_setreuid16);
 cond_syscall(sys_setuid16);
+cond_syscall(sys_vm86old);
+cond_syscall(sys_vm86);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit e585e47031751f4e393e10ffd922885508b958dd
Author: Matt Mackall <mpm@selenic.com>
Date:   Sun Jan 8 01:05:24 2006 -0800

    [PATCH] tiny: Make *[ug]id16 support optional
    
    Configurable 16-bit UID and friends support
    
    This allows turning off the legacy 16 bit UID interfaces on embedded platforms.
    
       text    data     bss     dec     hex filename
    3330172  529036  190556 4049764  3dcb64 vmlinux-baseline
    3328268  529040  190556 4047864  3dc3f8 vmlinux
    
    From: Adrian Bunk <bunk@stusta.de>
    
        UID16 was accidentially disabled for !EMBEDDED.
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7a8bc7f60d91..72cafc922d39 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -83,6 +83,25 @@ cond_syscall(sys_inotify_init);
 cond_syscall(sys_inotify_add_watch);
 cond_syscall(sys_inotify_rm_watch);
 cond_syscall(sys_migrate_pages);
+cond_syscall(sys_chown16);
+cond_syscall(sys_fchown16);
+cond_syscall(sys_getegid16);
+cond_syscall(sys_geteuid16);
+cond_syscall(sys_getgid16);
+cond_syscall(sys_getgroups16);
+cond_syscall(sys_getresgid16);
+cond_syscall(sys_getresuid16);
+cond_syscall(sys_getuid16);
+cond_syscall(sys_lchown16);
+cond_syscall(sys_setfsgid16);
+cond_syscall(sys_setfsuid16);
+cond_syscall(sys_setgid16);
+cond_syscall(sys_setgroups16);
+cond_syscall(sys_setregid16);
+cond_syscall(sys_setresgid16);
+cond_syscall(sys_setresuid16);
+cond_syscall(sys_setreuid16);
+cond_syscall(sys_setuid16);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 39743889aaf76725152f16aa90ca3c45f6d52da3
Author: Christoph Lameter <clameter@sgi.com>
Date:   Sun Jan 8 01:00:51 2006 -0800

    [PATCH] Swap Migration V5: sys_migrate_pages interface
    
    sys_migrate_pages implementation using swap based page migration
    
    This is the original API proposed by Ray Bryant in his posts during the first
    half of 2005 on linux-mm@kvack.org and linux-kernel@vger.kernel.org.
    
    The intent of sys_migrate is to migrate memory of a process.  A process may
    have migrated to another node.  Memory was allocated optimally for the prior
    context.  sys_migrate_pages allows to shift the memory to the new node.
    
    sys_migrate_pages is also useful if the processes available memory nodes have
    changed through cpuset operations to manually move the processes memory.  Paul
    Jackson is working on an automated mechanism that will allow an automatic
    migration if the cpuset of a process is changed.  However, a user may decide
    to manually control the migration.
    
    This implementation is put into the policy layer since it uses concepts and
    functions that are also needed for mbind and friends.  The patch also provides
    a do_migrate_pages function that may be useful for cpusets to automatically
    move memory.  sys_migrate_pages does not modify policies in contrast to Ray's
    implementation.
    
    The current code here is based on the swap based page migration capability and
    thus is not able to preserve the physical layout relative to it containing
    nodeset (which may be a cpuset).  When direct page migration becomes available
    then the implementation needs to be changed to do a isomorphic move of pages
    between different nodesets.  The current implementation simply evicts all
    pages in source nodeset that are not in the target nodeset.
    
    Patch supports ia64, i386 and x86_64.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1ab2370e2efa..7a8bc7f60d91 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -82,6 +82,7 @@ cond_syscall(compat_sys_socketcall);
 cond_syscall(sys_inotify_init);
 cond_syscall(sys_inotify_add_watch);
 cond_syscall(sys_inotify_rm_watch);
+cond_syscall(sys_migrate_pages);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 67207b9664a8d603138ef1556141e6d0a102bea7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 15 15:53:48 2005 -0500

    [PATCH] spufs: The SPU file system, base
    
    This is the current version of the spu file system, used
    for driving SPEs on the Cell Broadband Engine.
    
    This release is almost identical to the version for the
    2.6.14 kernel posted earlier, which is available as part
    of the Cell BE Linux distribution from
    http://www.bsc.es/projects/deepcomputing/linuxoncell/.
    
    The first patch provides all the interfaces for running
    spu application, but does not have any support for
    debugging SPU tasks or for scheduling. Both these
    functionalities are added in the subsequent patches.
    
    See Documentation/filesystems/spufs.txt on how to use
    spufs.
    
    Signed-off-by: Arnd Bergmann <arndb@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1ab2370e2efa..d4739a475d23 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -90,3 +90,5 @@ cond_syscall(sys_pciconfig_iobase);
 cond_syscall(sys32_ipc);
 cond_syscall(sys32_sysctl);
 cond_syscall(ppc_rtas);
+cond_syscall(sys_spu_run);
+cond_syscall(sys_spu_create);

commit 6cb54819d7b1867053e2dfd8c0ca3a8dc65a7eff
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Aug 1 13:39:13 2005 +0200

    [PATCH] remove sys_set_zone_reclaim()
    
    This removes sys_set_zone_reclaim() for now.  While i'm sure Martin is
    trying to solve a real problem, we must not hard-code an incomplete and
    insufficient approach into a syscall, because syscalls are pretty much
    for eternity.  I am quite strongly convinced that this syscall must not
    hit v2.6.13 in its current form.
    
    Firstly, the syscall lacks basic syscall design: e.g. it allows the
    global setting of VM policy for unprivileged users. (!) [ Imagine an
    Oracle installation and a SAP installation on the same NUMA box fighting
    over the 'optimal' setting for this flag. What will they do? Will they
    try to set the flag to their own preferred value every second or so? ]
    
    Secondly, it was added based on a single datapoint from Martin:
    
     http://marc.theaimsgroup.com/?l=linux-mm&m=111763597218177&w=2
    
    where Martin characterizes the numbers the following way:
    
     ' Run-to-run variability for "make -j" is huge, so these numbers aren't
       terribly useful except to see that with reclaim the benchmark still
       finishes in a reasonable amount of time. '
    
    in other words: the fundamental problem has likely not been solved, only
    a tendential move into the right direction has been observed, and a
    handful of numbers were picked out of a set of hugely variable results,
    without showing the variability data. How much variance is there
    run-to-run?
    
    I'd really suggest to first walk the walk and see what's needed to get
    stable & predictable kernel compilation numbers on that NUMA box, before
    adding random syscalls to tune a particular aspect of the VM ... which
    approach might not even matter once the whole picture has been analyzed
    and understood!
    
    The third, most important point is that the syscall exposes VM tuning
    internals in a completely unstructured way. What sense does it make to
    have a _GLOBAL_ per-node setting for 'should we go to another node for
    reclaim'? If then it might make sense to do this per-app, via numalib or
    so.
    
    The change is minimalistic in that it doesnt remove the syscall and the
    underlying infrastructure changes, only the user-visible changes.  We
    could perhaps add a CAP_SYS_ADMIN-only sysctl for this hack, a'ka
    /proc/sys/vm/swappiness, but even that looks quite counterproductive
    when the generic approach is that we are trying to reduce the number of
    external factors in the VM balance picture.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 42b40ae5eada..1ab2370e2efa 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -79,7 +79,6 @@ cond_syscall(sys_request_key);
 cond_syscall(sys_keyctl);
 cond_syscall(compat_sys_keyctl);
 cond_syscall(compat_sys_socketcall);
-cond_syscall(sys_set_zone_reclaim);
 cond_syscall(sys_inotify_init);
 cond_syscall(sys_inotify_add_watch);
 cond_syscall(sys_inotify_rm_watch);

commit 0eeca28300df110bd6ed54b31193c83b87921443
Author: Robert Love <rml@novell.com>
Date:   Tue Jul 12 17:06:03 2005 -0400

    [PATCH] inotify
    
    inotify is intended to correct the deficiencies of dnotify, particularly
    its inability to scale and its terrible user interface:
    
            * dnotify requires the opening of one fd per each directory
              that you intend to watch. This quickly results in too many
              open files and pins removable media, preventing unmount.
            * dnotify is directory-based. You only learn about changes to
              directories. Sure, a change to a file in a directory affects
              the directory, but you are then forced to keep a cache of
              stat structures.
            * dnotify's interface to user-space is awful.  Signals?
    
    inotify provides a more usable, simple, powerful solution to file change
    notification:
    
            * inotify's interface is a system call that returns a fd, not SIGIO.
              You get a single fd, which is select()-able.
            * inotify has an event that says "the filesystem that the item
              you were watching is on was unmounted."
            * inotify can watch directories or files.
    
    Inotify is currently used by Beagle (a desktop search infrastructure),
    Gamin (a FAM replacement), and other projects.
    
    See Documentation/filesystems/inotify.txt.
    
    Signed-off-by: Robert Love <rml@novell.com>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 29196ce9b40f..42b40ae5eada 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -80,6 +80,9 @@ cond_syscall(sys_keyctl);
 cond_syscall(compat_sys_keyctl);
 cond_syscall(compat_sys_socketcall);
 cond_syscall(sys_set_zone_reclaim);
+cond_syscall(sys_inotify_init);
+cond_syscall(sys_inotify_add_watch);
+cond_syscall(sys_inotify_rm_watch);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit dc009d92435f99498cbc579ce76bf28e837e2c14
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jun 25 14:57:52 2005 -0700

    [PATCH] kexec: add kexec syscalls
    
    This patch introduces the architecture independent implementation the
    sys_kexec_load, the compat_sys_kexec_load system calls.
    
    Kexec on panic support has been integrated into the core patch and is
    relatively clean.
    
    In addition the hopefully architecture independent option
    crashkernel=size@location has been docuemented.  It's purpose is to reserve
    space for the panic kernel to live, and where no DMA transfer will ever be
    setup to access.
    
    Signed-off-by: Eric Biederman <ebiederm@xmission.com>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 6f15bea7d1a8..29196ce9b40f 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -18,6 +18,8 @@ cond_syscall(sys_acct);
 cond_syscall(sys_lookup_dcookie);
 cond_syscall(sys_swapon);
 cond_syscall(sys_swapoff);
+cond_syscall(sys_kexec_load);
+cond_syscall(compat_sys_kexec_load);
 cond_syscall(sys_init_module);
 cond_syscall(sys_delete_module);
 cond_syscall(sys_socketpair);

commit 753ee728964e5afb80c17659cc6c3a6fd0a42fe0
Author: Martin Hicks <mort@sgi.com>
Date:   Tue Jun 21 17:14:41 2005 -0700

    [PATCH] VM: early zone reclaim
    
    This is the core of the (much simplified) early reclaim.  The goal of this
    patch is to reclaim some easily-freed pages from a zone before falling back
    onto another zone.
    
    One of the major uses of this is NUMA machines.  With the default allocator
    behavior the allocator would look for memory in another zone, which might be
    off-node, before trying to reclaim from the current zone.
    
    This adds a zone tuneable to enable early zone reclaim.  It is selected on a
    per-zone basis and is turned on/off via syscall.
    
    Adding some extra throttling on the reclaim was also required (patch
    4/4).  Without the machine would grind to a crawl when doing a "make -j"
    kernel build.  Even with this patch the System Time is higher on
    average, but it seems tolerable.  Here are some numbers for kernbench
    runs on a 2-node, 4cpu, 8Gig RAM Altix in the "make -j" run:
    
                            wall  user   sys   %cpu  ctx sw.  sleeps
                            ----  ----   ---   ----   ------  ------
    No patch                1009  1384   847   258   298170   504402
    w/patch, no reclaim     880   1376   667   288   254064   396745
    w/patch & reclaim       1079  1385   926   252   291625   548873
    
    These numbers are the average of 2 runs of 3 "make -j" runs done right
    after system boot.  Run-to-run variability for "make -j" is huge, so
    these numbers aren't terribly useful except to seee that with reclaim
    the benchmark still finishes in a reasonable amount of time.
    
    I also looked at the NUMA hit/miss stats for the "make -j" runs and the
    reclaim doesn't make any difference when the machine is thrashing away.
    
    Doing a "make -j8" on a single node that is filled with page cache pages
    takes 700 seconds with reclaim turned on and 735 seconds without reclaim
    (due to remote memory accesses).
    
    The simple zone_reclaim syscall program is at
    http://www.bork.org/~mort/sgi/zone_reclaim.c
    
    Signed-off-by: Martin Hicks <mort@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0dda70ed1f98..6f15bea7d1a8 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -77,6 +77,7 @@ cond_syscall(sys_request_key);
 cond_syscall(sys_keyctl);
 cond_syscall(compat_sys_keyctl);
 cond_syscall(compat_sys_socketcall);
+cond_syscall(sys_set_zone_reclaim);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);

commit 7d87e14c236d6c4cab66d87cf0bc1e0f0375d308
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Sun May 1 08:59:12 2005 -0700

    [PATCH] consolidate sys_shmat
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1802a311dd3f..0dda70ed1f98 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -52,6 +52,7 @@ cond_syscall(sys_msgsnd);
 cond_syscall(sys_msgrcv);
 cond_syscall(sys_msgctl);
 cond_syscall(sys_shmget);
+cond_syscall(sys_shmat);
 cond_syscall(sys_shmdt);
 cond_syscall(sys_shmctl);
 cond_syscall(sys_mq_open);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
new file mode 100644
index 000000000000..1802a311dd3f
--- /dev/null
+++ b/kernel/sys_ni.c
@@ -0,0 +1,86 @@
+
+#include <linux/linkage.h>
+#include <linux/errno.h>
+
+#include <asm/unistd.h>
+
+/*
+ * Non-implemented system calls get redirected here.
+ */
+asmlinkage long sys_ni_syscall(void)
+{
+	return -ENOSYS;
+}
+
+cond_syscall(sys_nfsservctl);
+cond_syscall(sys_quotactl);
+cond_syscall(sys_acct);
+cond_syscall(sys_lookup_dcookie);
+cond_syscall(sys_swapon);
+cond_syscall(sys_swapoff);
+cond_syscall(sys_init_module);
+cond_syscall(sys_delete_module);
+cond_syscall(sys_socketpair);
+cond_syscall(sys_bind);
+cond_syscall(sys_listen);
+cond_syscall(sys_accept);
+cond_syscall(sys_connect);
+cond_syscall(sys_getsockname);
+cond_syscall(sys_getpeername);
+cond_syscall(sys_sendto);
+cond_syscall(sys_send);
+cond_syscall(sys_recvfrom);
+cond_syscall(sys_recv);
+cond_syscall(sys_socket);
+cond_syscall(sys_setsockopt);
+cond_syscall(sys_getsockopt);
+cond_syscall(sys_shutdown);
+cond_syscall(sys_sendmsg);
+cond_syscall(sys_recvmsg);
+cond_syscall(sys_socketcall);
+cond_syscall(sys_futex);
+cond_syscall(compat_sys_futex);
+cond_syscall(sys_epoll_create);
+cond_syscall(sys_epoll_ctl);
+cond_syscall(sys_epoll_wait);
+cond_syscall(sys_semget);
+cond_syscall(sys_semop);
+cond_syscall(sys_semtimedop);
+cond_syscall(sys_semctl);
+cond_syscall(sys_msgget);
+cond_syscall(sys_msgsnd);
+cond_syscall(sys_msgrcv);
+cond_syscall(sys_msgctl);
+cond_syscall(sys_shmget);
+cond_syscall(sys_shmdt);
+cond_syscall(sys_shmctl);
+cond_syscall(sys_mq_open);
+cond_syscall(sys_mq_unlink);
+cond_syscall(sys_mq_timedsend);
+cond_syscall(sys_mq_timedreceive);
+cond_syscall(sys_mq_notify);
+cond_syscall(sys_mq_getsetattr);
+cond_syscall(compat_sys_mq_open);
+cond_syscall(compat_sys_mq_timedsend);
+cond_syscall(compat_sys_mq_timedreceive);
+cond_syscall(compat_sys_mq_notify);
+cond_syscall(compat_sys_mq_getsetattr);
+cond_syscall(sys_mbind);
+cond_syscall(sys_get_mempolicy);
+cond_syscall(sys_set_mempolicy);
+cond_syscall(compat_sys_mbind);
+cond_syscall(compat_sys_get_mempolicy);
+cond_syscall(compat_sys_set_mempolicy);
+cond_syscall(sys_add_key);
+cond_syscall(sys_request_key);
+cond_syscall(sys_keyctl);
+cond_syscall(compat_sys_keyctl);
+cond_syscall(compat_sys_socketcall);
+
+/* arch-specific weak syscall entries */
+cond_syscall(sys_pciconfig_read);
+cond_syscall(sys_pciconfig_write);
+cond_syscall(sys_pciconfig_iobase);
+cond_syscall(sys32_ipc);
+cond_syscall(sys32_sysctl);
+cond_syscall(ppc_rtas);
