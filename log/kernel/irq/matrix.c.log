commit e8da8794a7fd9eef1ec9a07f0d4897c68581c72b
Author: Long Li <longli@microsoft.com>
Date:   Tue Nov 6 04:00:00 2018 +0000

    genirq/matrix: Improve target CPU selection for managed interrupts.
    
    On large systems with multiple devices of the same class (e.g. NVMe disks,
    using managed interrupts), the kernel can affinitize these interrupts to a
    small subset of CPUs instead of spreading them out evenly.
    
    irq_matrix_alloc_managed() tries to select the CPU in the supplied cpumask
    of possible target CPUs which has the lowest number of interrupt vectors
    allocated.
    
    This is done by searching the CPU with the highest number of available
    vectors. While this is correct for non-managed CPUs it can select the wrong
    CPU for managed interrupts. Under certain constellations this results in
    affinitizing the managed interrupts of several devices to a single CPU in
    a set.
    
    The book keeping of available vectors works the following way:
    
     1) Non-managed interrupts:
    
        available is decremented when the interrupt is actually requested by
        the device driver and a vector is assigned. It's incremented when the
        interrupt and the vector are freed.
    
     2) Managed interrupts:
    
        Managed interrupts guarantee vector reservation when the MSI/MSI-X
        functionality of a device is enabled, which is achieved by reserving
        vectors in the bitmaps of the possible target CPUs. This reservation
        decrements the available count on each possible target CPU.
    
        When the interrupt is requested by the device driver then a vector is
        allocated from the reserved region. The operation is reversed when the
        interrupt is freed by the device driver. Neither of these operations
        affect the available count.
    
        The reservation persist up to the point where the MSI/MSI-X
        functionality is disabled and only this operation increments the
        available count again.
    
    For non-managed interrupts the available count is the correct selection
    criterion because the guaranteed reservations need to be taken into
    account. Using the allocated counter could lead to a failing allocation in
    the following situation (total vector space of 10 assumed):
    
                     CPU0   CPU1
     available:         2      0
     allocated:         5      3   <--- CPU1 is selected, but available space = 0
     managed reserved:  3      7
    
     while available yields the correct result.
    
    For managed interrupts the available count is not the appropriate
    selection criterion because as explained above the available count is not
    affected by the actual vector allocation.
    
    The following example illustrates that. Total vector space of 10
    assumed. The starting point is:
    
                     CPU0   CPU1
     available:         5      4
     allocated:         2      3
     managed reserved:  3      3
    
     Allocating vectors for three non-managed interrupts will result in
     affinitizing the first two to CPU0 and the third one to CPU1 because the
     available count is adjusted with each allocation:
    
                      CPU0  CPU1
     available:          5     4    <- Select CPU0 for 1st allocation
     --> allocated:      3     3
    
     available:          4     4    <- Select CPU0 for 2nd allocation
     --> allocated:      4     3
    
     available:          3     4    <- Select CPU1 for 3rd allocation
     --> allocated:      4     4
    
     But the allocation of three managed interrupts starting from the same
     point will affinitize all of them to CPU0 because the available count is
     not affected by the allocation (see above). So the end result is:
    
                      CPU0  CPU1
     available:          5     4
     allocated:          5     3
    
    Introduce a "managed_allocated" field in struct cpumap to track the vector
    allocation for managed interrupts separately. Use this information to
    select the target CPU when a vector is allocated for a managed interrupt,
    which results in more evenly distributed vector assignments. The above
    example results in the following allocations:
    
                     CPU0   CPU1
     managed_allocated: 0      0    <- Select CPU0 for 1st allocation
     --> allocated:     3      3
    
     managed_allocated: 1      0    <- Select CPU1 for 2nd allocation
     --> allocated:     3      4
    
     managed_allocated: 1      1    <- Select CPU0 for 3rd allocation
     --> allocated:     4      4
    
    The allocation of non-managed interrupts is not affected by this change and
    is still evaluating the available count.
    
    The overall distribution of interrupt vectors for both types of interrupts
    might still not be perfectly even depending on the number of non-managed
    and managed interrupts in a system, but due to the reservation guarantee
    for managed interrupts this cannot be avoided.
    
    Expose the new field in debugfs as well.
    
    [ tglx: Clarified the background of the problem in the changelog and
            described it independent of NVME ]
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Michael Kelley <mikelley@microsoft.com>
    Link: https://lkml.kernel.org/r/20181106040000.27316-1-longli@linuxonhyperv.com

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 1f0985adf193..30cc217b8631 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -14,6 +14,7 @@ struct cpumap {
 	unsigned int		available;
 	unsigned int		allocated;
 	unsigned int		managed;
+	unsigned int		managed_allocated;
 	bool			initialized;
 	bool			online;
 	unsigned long		alloc_map[IRQ_MATRIX_SIZE];
@@ -145,6 +146,27 @@ static unsigned int matrix_find_best_cpu(struct irq_matrix *m,
 	return best_cpu;
 }
 
+/* Find the best CPU which has the lowest number of managed IRQs allocated */
+static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,
+						const struct cpumask *msk)
+{
+	unsigned int cpu, best_cpu, allocated = UINT_MAX;
+	struct cpumap *cm;
+
+	best_cpu = UINT_MAX;
+
+	for_each_cpu(cpu, msk) {
+		cm = per_cpu_ptr(m->maps, cpu);
+
+		if (!cm->online || cm->managed_allocated > allocated)
+			continue;
+
+		best_cpu = cpu;
+		allocated = cm->managed_allocated;
+	}
+	return best_cpu;
+}
+
 /**
  * irq_matrix_assign_system - Assign system wide entry in the matrix
  * @m:		Matrix pointer
@@ -269,7 +291,7 @@ int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,
 	if (cpumask_empty(msk))
 		return -EINVAL;
 
-	cpu = matrix_find_best_cpu(m, msk);
+	cpu = matrix_find_best_cpu_managed(m, msk);
 	if (cpu == UINT_MAX)
 		return -ENOSPC;
 
@@ -282,6 +304,7 @@ int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,
 		return -ENOSPC;
 	set_bit(bit, cm->alloc_map);
 	cm->allocated++;
+	cm->managed_allocated++;
 	m->total_allocated++;
 	*mapped_cpu = cpu;
 	trace_irq_matrix_alloc_managed(bit, cpu, m, cm);
@@ -395,6 +418,8 @@ void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
 
 	clear_bit(bit, cm->alloc_map);
 	cm->allocated--;
+	if(managed)
+		cm->managed_allocated--;
 
 	if (cm->online)
 		m->total_allocated--;
@@ -464,13 +489,14 @@ void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)
 	seq_printf(sf, "Total allocated:  %6u\n", m->total_allocated);
 	seq_printf(sf, "System: %u: %*pbl\n", nsys, m->matrix_bits,
 		   m->system_map);
-	seq_printf(sf, "%*s| CPU | avl | man | act | vectors\n", ind, " ");
+	seq_printf(sf, "%*s| CPU | avl | man | mac | act | vectors\n", ind, " ");
 	cpus_read_lock();
 	for_each_online_cpu(cpu) {
 		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
 
-		seq_printf(sf, "%*s %4d  %4u  %4u  %4u  %*pbl\n", ind, " ",
-			   cpu, cm->available, cm->managed, cm->allocated,
+		seq_printf(sf, "%*s %4d  %4u  %4u  %4u %4u  %*pbl\n", ind, " ",
+			   cpu, cm->available, cm->managed,
+			   cm->managed_allocated, cm->allocated,
 			   m->matrix_bits, cm->alloc_map);
 	}
 	cpus_read_unlock();

commit 57f01796f14fecf00d330fe39c8d2477ced9cd79
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Thu Nov 1 00:35:05 2018 +0000

    irq/matrix: Fix memory overallocation
    
    IRQ_MATRIX_SIZE is the number of longs needed for a bitmap, multiplied by
    the size of a long, yielding a byte count. But it is used to size an array
    of longs, which is way more memory than is needed.
    
    Change IRQ_MATRIX_SIZE so it is just the number of longs needed and the
    arrays come out the correct size.
    
    Fixes: 2f75d9e1c905 ("genirq: Implement bitmap matrix allocator")
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: KY Srinivasan <kys@microsoft.com>
    Link: https://lkml.kernel.org/r/1541032428-10392-1-git-send-email-mikelley@microsoft.com

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 6e6d467f3dec..1f0985adf193 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -8,7 +8,7 @@
 #include <linux/cpu.h>
 #include <linux/irq.h>
 
-#define IRQ_MATRIX_SIZE	(BITS_TO_LONGS(IRQ_MATRIX_BITS) * sizeof(unsigned long))
+#define IRQ_MATRIX_SIZE	(BITS_TO_LONGS(IRQ_MATRIX_BITS))
 
 struct cpumap {
 	unsigned int		available;

commit 76f99ae5b54d48430d1f0c5512a84da0ff9761e0
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Sun Sep 9 01:58:38 2018 +0800

    irq/matrix: Spread managed interrupts on allocation
    
    Linux spreads out the non managed interrupt across the possible target CPUs
    to avoid vector space exhaustion.
    
    Managed interrupts are treated differently, as for them the vectors are
    reserved (with guarantee) when the interrupt descriptors are initialized.
    
    When the interrupt is requested a real vector is assigned. The assignment
    logic uses the first CPU in the affinity mask for assignment. If the
    interrupt has more than one CPU in the affinity mask, which happens when a
    multi queue device has less queues than CPUs, then doing the same search as
    for non managed interrupts makes sense as it puts the interrupt on the
    least interrupt plagued CPU. For single CPU affine vectors that's obviously
    a NOOP.
    
    Restructre the matrix allocation code so it does the 'best CPU' search, add
    the sanity check for an empty affinity mask and adapt the call site in the
    x86 vector management code.
    
    [ tglx: Added the empty mask check to the core and improved change log ]
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20180908175838.14450-2-dou_liyang@163.com

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 67768bbe736e..6e6d467f3dec 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -260,11 +260,21 @@ void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)
  * @m:		Matrix pointer
  * @cpu:	On which CPU the interrupt should be allocated
  */
-int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu)
+int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,
+			     unsigned int *mapped_cpu)
 {
-	struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
-	unsigned int bit, end = m->alloc_end;
+	unsigned int bit, cpu, end = m->alloc_end;
+	struct cpumap *cm;
+
+	if (cpumask_empty(msk))
+		return -EINVAL;
 
+	cpu = matrix_find_best_cpu(m, msk);
+	if (cpu == UINT_MAX)
+		return -ENOSPC;
+
+	cm = per_cpu_ptr(m->maps, cpu);
+	end = m->alloc_end;
 	/* Get managed bit which are not allocated */
 	bitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);
 	bit = find_first_bit(m->scratch_map, end);
@@ -273,6 +283,7 @@ int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu)
 	set_bit(bit, cm->alloc_map);
 	cm->allocated++;
 	m->total_allocated++;
+	*mapped_cpu = cpu;
 	trace_irq_matrix_alloc_managed(bit, cpu, m, cm);
 	return bit;
 }

commit 8ffe4e61c06a48324cfd97f1199bb9838acce2f2
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Sun Sep 9 01:58:37 2018 +0800

    irq/matrix: Split out the CPU selection code into a helper
    
    Linux finds the CPU which has the lowest vector allocation count to spread
    out the non managed interrupts across the possible target CPUs, but does
    not do so for managed interrupts.
    
    Split out the CPU selection code into a helper function for reuse. No
    functional change.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20180908175838.14450-1-dou_liyang@163.com

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 5092494bf261..67768bbe736e 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -124,6 +124,27 @@ static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,
 	return area;
 }
 
+/* Find the best CPU which has the lowest vector allocation count */
+static unsigned int matrix_find_best_cpu(struct irq_matrix *m,
+					const struct cpumask *msk)
+{
+	unsigned int cpu, best_cpu, maxavl = 0;
+	struct cpumap *cm;
+
+	best_cpu = UINT_MAX;
+
+	for_each_cpu(cpu, msk) {
+		cm = per_cpu_ptr(m->maps, cpu);
+
+		if (!cm->online || cm->available <= maxavl)
+			continue;
+
+		best_cpu = cpu;
+		maxavl = cm->available;
+	}
+	return best_cpu;
+}
+
 /**
  * irq_matrix_assign_system - Assign system wide entry in the matrix
  * @m:		Matrix pointer
@@ -322,37 +343,27 @@ void irq_matrix_remove_reserved(struct irq_matrix *m)
 int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 		     bool reserved, unsigned int *mapped_cpu)
 {
-	unsigned int cpu, best_cpu, maxavl = 0;
+	unsigned int cpu, bit;
 	struct cpumap *cm;
-	unsigned int bit;
 
-	best_cpu = UINT_MAX;
-	for_each_cpu(cpu, msk) {
-		cm = per_cpu_ptr(m->maps, cpu);
-
-		if (!cm->online || cm->available <= maxavl)
-			continue;
+	cpu = matrix_find_best_cpu(m, msk);
+	if (cpu == UINT_MAX)
+		return -ENOSPC;
 
-		best_cpu = cpu;
-		maxavl = cm->available;
-	}
+	cm = per_cpu_ptr(m->maps, cpu);
+	bit = matrix_alloc_area(m, cm, 1, false);
+	if (bit >= m->alloc_end)
+		return -ENOSPC;
+	cm->allocated++;
+	cm->available--;
+	m->total_allocated++;
+	m->global_available--;
+	if (reserved)
+		m->global_reserved--;
+	*mapped_cpu = cpu;
+	trace_irq_matrix_alloc(bit, cpu, m, cm);
+	return bit;
 
-	if (maxavl) {
-		cm = per_cpu_ptr(m->maps, best_cpu);
-		bit = matrix_alloc_area(m, cm, 1, false);
-		if (bit < m->alloc_end) {
-			cm->allocated++;
-			cm->available--;
-			m->total_allocated++;
-			m->global_available--;
-			if (reserved)
-				m->global_reserved--;
-			*mapped_cpu = best_cpu;
-			trace_irq_matrix_alloc(bit, best_cpu, m, cm);
-			return bit;
-		}
-	}
-	return -ENOSPC;
 }
 
 /**

commit 90cafdd521721eb588a738fae17ac70e50675686
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 14 22:15:17 2018 +0100

    genirq/matrix: Cleanup SPDX identifier
    
    Use the proper SPDX-Identifier format.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Link: https://lkml.kernel.org/r/20180314212030.492674761@linutronix.de

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 4c5770407031..5092494bf261 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -1,8 +1,6 @@
-/*
- * Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>
- *
- * SPDX-License-Identifier: GPL-2.0
- */
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>
+
 #include <linux/spinlock.h>
 #include <linux/seq_file.h>
 #include <linux/bitmap.h>

commit 651ca2c00405a2ae3870cc0b4f15a182eb6fbe26
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 22 12:08:05 2018 +0100

    genirq/matrix: Handle CPU offlining proper
    
    At CPU hotunplug the corresponding per cpu matrix allocator is shut down and
    the allocated interrupt bits are discarded under the assumption that all
    allocated bits have been either migrated away or shut down through the
    managed interrupts mechanism.
    
    This is not true because interrupts which are not started up might have a
    vector allocated on the outgoing CPU. When the interrupt is started up
    later or completely shutdown and freed then the allocated vector is handed
    back, triggering warnings or causing accounting issues which result in
    suspend failures and other issues.
    
    Change the CPU hotplug mechanism of the matrix allocator so that the
    remaining allocations at unplug time are preserved and global accounting at
    hotplug is correctly readjusted to take the dormant vectors into account.
    
    Fixes: 2f75d9e1c905 ("genirq: Implement bitmap matrix allocator")
    Reported-by: Yuriy Vostrikov <delamonpansie@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Yuriy Vostrikov <delamonpansie@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20180222112316.849980972@linutronix.de

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 5187dfe809ac..4c5770407031 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -16,6 +16,7 @@ struct cpumap {
 	unsigned int		available;
 	unsigned int		allocated;
 	unsigned int		managed;
+	bool			initialized;
 	bool			online;
 	unsigned long		alloc_map[IRQ_MATRIX_SIZE];
 	unsigned long		managed_map[IRQ_MATRIX_SIZE];
@@ -81,9 +82,11 @@ void irq_matrix_online(struct irq_matrix *m)
 
 	BUG_ON(cm->online);
 
-	bitmap_zero(cm->alloc_map, m->matrix_bits);
-	cm->available = m->alloc_size - (cm->managed + m->systembits_inalloc);
-	cm->allocated = 0;
+	if (!cm->initialized) {
+		cm->available = m->alloc_size;
+		cm->available -= cm->managed + m->systembits_inalloc;
+		cm->initialized = true;
+	}
 	m->global_available += cm->available;
 	cm->online = true;
 	m->online_maps++;
@@ -370,14 +373,16 @@ void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
 	if (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))
 		return;
 
-	if (cm->online) {
-		clear_bit(bit, cm->alloc_map);
-		cm->allocated--;
+	clear_bit(bit, cm->alloc_map);
+	cm->allocated--;
+
+	if (cm->online)
 		m->total_allocated--;
-		if (!managed) {
-			cm->available++;
+
+	if (!managed) {
+		cm->available++;
+		if (cm->online)
 			m->global_available++;
-		}
 	}
 	trace_irq_matrix_free(bit, cpu, m, cm);
 }

commit a0c9259dc4e1923a98356967ce8b732da1979df8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jan 17 16:01:47 2018 +0100

    irq/matrix: Spread interrupts on allocation
    
    Keith reported an issue with vector space exhaustion on a server machine
    which is caused by the i40e driver allocating 168 MSI interrupts when the
    driver is initialized, even when most of these interrupts are not used at
    all.
    
    The x86 vector allocation code tries to avoid the immediate allocation with
    the reservation mode, but the card uses MSI and does not support MSI entry
    masking, which prevents reservation mode and requires immediate vector
    allocation.
    
    The matrix allocator is a bit naive and prefers the first CPU in the
    cpumask which describes the possible target CPUs for an allocation. That
    results in allocating all 168 vectors on CPU0 which later causes vector
    space exhaustion when the NVMe driver tries to allocate managed interrupts
    on each CPU for the per CPU queues.
    
    Avoid this by finding the CPU which has the lowest vector allocation count
    to spread out the non managed interrupt accross the possible target CPUs.
    
    Fixes: 2f75d9e1c905 ("genirq: Implement bitmap matrix allocator")
    Reported-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Keith Busch <keith.busch@intel.com>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.20.1801171557330.1777@nanos

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 0ba0dd8863a7..5187dfe809ac 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -321,15 +321,23 @@ void irq_matrix_remove_reserved(struct irq_matrix *m)
 int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 		     bool reserved, unsigned int *mapped_cpu)
 {
-	unsigned int cpu;
+	unsigned int cpu, best_cpu, maxavl = 0;
+	struct cpumap *cm;
+	unsigned int bit;
 
+	best_cpu = UINT_MAX;
 	for_each_cpu(cpu, msk) {
-		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
-		unsigned int bit;
+		cm = per_cpu_ptr(m->maps, cpu);
 
-		if (!cm->online)
+		if (!cm->online || cm->available <= maxavl)
 			continue;
 
+		best_cpu = cpu;
+		maxavl = cm->available;
+	}
+
+	if (maxavl) {
+		cm = per_cpu_ptr(m->maps, best_cpu);
 		bit = matrix_alloc_area(m, cm, 1, false);
 		if (bit < m->alloc_end) {
 			cm->allocated++;
@@ -338,8 +346,8 @@ int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 			m->global_available--;
 			if (reserved)
 				m->global_reserved--;
-			*mapped_cpu = cpu;
-			trace_irq_matrix_alloc(bit, cpu, m, cm);
+			*mapped_cpu = best_cpu;
+			trace_irq_matrix_alloc(bit, best_cpu, m, cm);
 			return bit;
 		}
 	}

commit bb5c43428252f27b875c764451321a83a531d6e5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 28 15:40:33 2017 +0100

    genirq/matrix: Fix the precedence fix for real
    
    The previous commit which made the operator precedence in
    irq_matrix_available() explicit made the implicit brokenness explicitely
    wrong. It was wrong in the original commit already. The overworked
    maintainer did not notice it either when merging the patch.
    
    Replace the confusing '?' construct by a simple and obvious if ().
    
    Fixes: 75f1133873d6 ("genirq/matrix: Make - vs ?: Precedence explicit")
    Reported-by: Rasmus Villemoes <rasmus.villemoes@prevas.dk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 7df2480005f8..0ba0dd8863a7 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -384,7 +384,9 @@ unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)
 {
 	struct cpumap *cm = this_cpu_ptr(m->maps);
 
-	return (m->global_available - cpudown) ? cm->available : 0;
+	if (!cpudown)
+		return m->global_available;
+	return m->global_available - cm->available;
 }
 
 /**

commit 75f1133873d6a1276d3c19918b7c94975840f990
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Nov 22 12:56:45 2017 -0800

    genirq/matrix: Make - vs ?: Precedence explicit
    
    Noticed with a Clang build. This improves the readability of the ?:
    expression, as it has lower precedence than the - expression. Show
    explicitly that - is evaluated first.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20171122205645.GA27125@beast

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index a3cbbc8191c5..7df2480005f8 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -384,7 +384,7 @@ unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)
 {
 	struct cpumap *cm = this_cpu_ptr(m->maps);
 
-	return m->global_available - cpudown ? cm->available : 0;
+	return (m->global_available - cpudown) ? cm->available : 0;
 }
 
 /**

commit ec0f7cd273dc41ab28bba703cac82690ea5f2863
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:15 2017 +0200

    genirq/matrix: Add tracepoints
    
    Add tracepoints for the irq bitmap matrix allocator.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.279468022@linutronix.de

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 7b2b4fbde1e2..a3cbbc8191c5 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -36,6 +36,9 @@ struct irq_matrix {
 	unsigned long		system_map[IRQ_MATRIX_SIZE];
 };
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/irq_matrix.h>
+
 /**
  * irq_alloc_matrix - Allocate a irq_matrix structure and initialize it
  * @matrix_bits:	Number of matrix bits must be <= IRQ_MATRIX_BITS
@@ -84,6 +87,7 @@ void irq_matrix_online(struct irq_matrix *m)
 	m->global_available += cm->available;
 	cm->online = true;
 	m->online_maps++;
+	trace_irq_matrix_online(m);
 }
 
 /**
@@ -98,6 +102,7 @@ void irq_matrix_offline(struct irq_matrix *m)
 	m->global_available -= cm->available;
 	cm->online = false;
 	m->online_maps--;
+	trace_irq_matrix_offline(m);
 }
 
 static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,
@@ -145,6 +150,8 @@ void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,
 	}
 	if (bit >= m->alloc_start && bit < m->alloc_end)
 		m->systembits_inalloc++;
+
+	trace_irq_matrix_assign_system(bit, m);
 }
 
 /**
@@ -172,6 +179,7 @@ int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)
 			cm->available--;
 			m->global_available--;
 		}
+		trace_irq_matrix_reserve_managed(bit, cpu, m, cm);
 	}
 	return 0;
 cleanup:
@@ -221,6 +229,7 @@ void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)
 			cm->available++;
 			m->global_available++;
 		}
+		trace_irq_matrix_remove_managed(bit, cpu, m, cm);
 	}
 }
 
@@ -242,6 +251,7 @@ int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu)
 	set_bit(bit, cm->alloc_map);
 	cm->allocated++;
 	m->total_allocated++;
+	trace_irq_matrix_alloc_managed(bit, cpu, m, cm);
 	return bit;
 }
 
@@ -264,6 +274,7 @@ void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)
 	m->total_allocated++;
 	cm->available--;
 	m->global_available--;
+	trace_irq_matrix_assign(bit, smp_processor_id(), m, cm);
 }
 
 /**
@@ -282,6 +293,7 @@ void irq_matrix_reserve(struct irq_matrix *m)
 		pr_warn("Interrupt reservation exceeds available resources\n");
 
 	m->global_reserved++;
+	trace_irq_matrix_reserve(m);
 }
 
 /**
@@ -296,6 +308,7 @@ void irq_matrix_reserve(struct irq_matrix *m)
 void irq_matrix_remove_reserved(struct irq_matrix *m)
 {
 	m->global_reserved--;
+	trace_irq_matrix_remove_reserved(m);
 }
 
 /**
@@ -326,6 +339,7 @@ int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 			if (reserved)
 				m->global_reserved--;
 			*mapped_cpu = cpu;
+			trace_irq_matrix_alloc(bit, cpu, m, cm);
 			return bit;
 		}
 	}
@@ -357,6 +371,7 @@ void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
 			m->global_available++;
 		}
 	}
+	trace_irq_matrix_free(bit, cpu, m, cm);
 }
 
 /**

commit 2f75d9e1c90511bff6d1ce4de94503cc28fec032
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:14 2017 +0200

    genirq: Implement bitmap matrix allocator
    
    Implement the infrastructure for a simple bitmap based allocator, which
    will replace the x86 vector allocator. It's in the core code as other
    architectures might be able to reuse/extend it. For now it only implements
    allocations for single CPUs, but it's simple to add multi CPU allocation
    support if required.
    
    The concept is rather simple:
    
     Global information:
            system_vector bitmap
            global accounting
    
     PerCPU information:
            allocation bitmap
            managed allocation bitmap
            local accounting
    
    The system vector bitmap is used to exclude vectors system wide from the
    allocation space.
    
    The allocation bitmap is used to keep track of per cpu used vectors.
    
    The managed allocation bitmap is used to reserve vectors for managed
    interrupts.
    
    When a regular (non managed) interrupt allocation happens then the
    following rule applies:
    
          tmpmap = system_map | alloc_map | managed_map
          find_zero_bit(tmpmap)
    
    Oring the bitmaps together gives the real available space. The same rule
    applies for reserving a managed interrupt vector. But contrary to the
    regular interrupts the reservation only marks the bit in the managed map
    and therefor excludes it from the regular allocations. The managed map is
    only cleaned out when the a managed interrupt is completely released and it
    stays alive accross CPU offline/online operations.
    
    For managed interrupt allocations the rule is:
    
          tmpmap = managed_map & ~alloc_map
          find_first_bit(tmpmap)
    
    This returns the first bit which is in the managed map, but not yet
    allocated in the allocation map. The allocation marks it in the allocation
    map and hands it back to the caller for use.
    
    The rest of the code are helper functions to handle the various
    requirements and the accounting which are necessary to replace the x86
    vector allocation code. The result is a single patch as the evolution of
    this infrastructure cannot be represented in bits and pieces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.185437174@linutronix.de

diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
new file mode 100644
index 000000000000..7b2b4fbde1e2
--- /dev/null
+++ b/kernel/irq/matrix.c
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+#include <linux/spinlock.h>
+#include <linux/seq_file.h>
+#include <linux/bitmap.h>
+#include <linux/percpu.h>
+#include <linux/cpu.h>
+#include <linux/irq.h>
+
+#define IRQ_MATRIX_SIZE	(BITS_TO_LONGS(IRQ_MATRIX_BITS) * sizeof(unsigned long))
+
+struct cpumap {
+	unsigned int		available;
+	unsigned int		allocated;
+	unsigned int		managed;
+	bool			online;
+	unsigned long		alloc_map[IRQ_MATRIX_SIZE];
+	unsigned long		managed_map[IRQ_MATRIX_SIZE];
+};
+
+struct irq_matrix {
+	unsigned int		matrix_bits;
+	unsigned int		alloc_start;
+	unsigned int		alloc_end;
+	unsigned int		alloc_size;
+	unsigned int		global_available;
+	unsigned int		global_reserved;
+	unsigned int		systembits_inalloc;
+	unsigned int		total_allocated;
+	unsigned int		online_maps;
+	struct cpumap __percpu	*maps;
+	unsigned long		scratch_map[IRQ_MATRIX_SIZE];
+	unsigned long		system_map[IRQ_MATRIX_SIZE];
+};
+
+/**
+ * irq_alloc_matrix - Allocate a irq_matrix structure and initialize it
+ * @matrix_bits:	Number of matrix bits must be <= IRQ_MATRIX_BITS
+ * @alloc_start:	From which bit the allocation search starts
+ * @alloc_end:		At which bit the allocation search ends, i.e first
+ *			invalid bit
+ */
+__init struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,
+					   unsigned int alloc_start,
+					   unsigned int alloc_end)
+{
+	struct irq_matrix *m;
+
+	if (matrix_bits > IRQ_MATRIX_BITS)
+		return NULL;
+
+	m = kzalloc(sizeof(*m), GFP_KERNEL);
+	if (!m)
+		return NULL;
+
+	m->matrix_bits = matrix_bits;
+	m->alloc_start = alloc_start;
+	m->alloc_end = alloc_end;
+	m->alloc_size = alloc_end - alloc_start;
+	m->maps = alloc_percpu(*m->maps);
+	if (!m->maps) {
+		kfree(m);
+		return NULL;
+	}
+	return m;
+}
+
+/**
+ * irq_matrix_online - Bring the local CPU matrix online
+ * @m:		Matrix pointer
+ */
+void irq_matrix_online(struct irq_matrix *m)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	BUG_ON(cm->online);
+
+	bitmap_zero(cm->alloc_map, m->matrix_bits);
+	cm->available = m->alloc_size - (cm->managed + m->systembits_inalloc);
+	cm->allocated = 0;
+	m->global_available += cm->available;
+	cm->online = true;
+	m->online_maps++;
+}
+
+/**
+ * irq_matrix_offline - Bring the local CPU matrix offline
+ * @m:		Matrix pointer
+ */
+void irq_matrix_offline(struct irq_matrix *m)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	/* Update the global available size */
+	m->global_available -= cm->available;
+	cm->online = false;
+	m->online_maps--;
+}
+
+static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,
+				      unsigned int num, bool managed)
+{
+	unsigned int area, start = m->alloc_start;
+	unsigned int end = m->alloc_end;
+
+	bitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);
+	bitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);
+	area = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);
+	if (area >= end)
+		return area;
+	if (managed)
+		bitmap_set(cm->managed_map, area, num);
+	else
+		bitmap_set(cm->alloc_map, area, num);
+	return area;
+}
+
+/**
+ * irq_matrix_assign_system - Assign system wide entry in the matrix
+ * @m:		Matrix pointer
+ * @bit:	Which bit to reserve
+ * @replace:	Replace an already allocated vector with a system
+ *		vector at the same bit position.
+ *
+ * The BUG_ON()s below are on purpose. If this goes wrong in the
+ * early boot process, then the chance to survive is about zero.
+ * If this happens when the system is life, it's not much better.
+ */
+void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,
+			      bool replace)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	BUG_ON(bit > m->matrix_bits);
+	BUG_ON(m->online_maps > 1 || (m->online_maps && !replace));
+
+	set_bit(bit, m->system_map);
+	if (replace) {
+		BUG_ON(!test_and_clear_bit(bit, cm->alloc_map));
+		cm->allocated--;
+		m->total_allocated--;
+	}
+	if (bit >= m->alloc_start && bit < m->alloc_end)
+		m->systembits_inalloc++;
+}
+
+/**
+ * irq_matrix_reserve_managed - Reserve a managed interrupt in a CPU map
+ * @m:		Matrix pointer
+ * @msk:	On which CPUs the bits should be reserved.
+ *
+ * Can be called for offline CPUs. Note, this will only reserve one bit
+ * on all CPUs in @msk, but it's not guaranteed that the bits are at the
+ * same offset on all CPUs
+ */
+int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)
+{
+	unsigned int cpu, failed_cpu;
+
+	for_each_cpu(cpu, msk) {
+		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+		unsigned int bit;
+
+		bit = matrix_alloc_area(m, cm, 1, true);
+		if (bit >= m->alloc_end)
+			goto cleanup;
+		cm->managed++;
+		if (cm->online) {
+			cm->available--;
+			m->global_available--;
+		}
+	}
+	return 0;
+cleanup:
+	failed_cpu = cpu;
+	for_each_cpu(cpu, msk) {
+		if (cpu == failed_cpu)
+			break;
+		irq_matrix_remove_managed(m, cpumask_of(cpu));
+	}
+	return -ENOSPC;
+}
+
+/**
+ * irq_matrix_remove_managed - Remove managed interrupts in a CPU map
+ * @m:		Matrix pointer
+ * @msk:	On which CPUs the bits should be removed
+ *
+ * Can be called for offline CPUs
+ *
+ * This removes not allocated managed interrupts from the map. It does
+ * not matter which one because the managed interrupts free their
+ * allocation when they shut down. If not, the accounting is screwed,
+ * but all what can be done at this point is warn about it.
+ */
+void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)
+{
+	unsigned int cpu;
+
+	for_each_cpu(cpu, msk) {
+		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+		unsigned int bit, end = m->alloc_end;
+
+		if (WARN_ON_ONCE(!cm->managed))
+			continue;
+
+		/* Get managed bit which are not allocated */
+		bitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);
+
+		bit = find_first_bit(m->scratch_map, end);
+		if (WARN_ON_ONCE(bit >= end))
+			continue;
+
+		clear_bit(bit, cm->managed_map);
+
+		cm->managed--;
+		if (cm->online) {
+			cm->available++;
+			m->global_available++;
+		}
+	}
+}
+
+/**
+ * irq_matrix_alloc_managed - Allocate a managed interrupt in a CPU map
+ * @m:		Matrix pointer
+ * @cpu:	On which CPU the interrupt should be allocated
+ */
+int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu)
+{
+	struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+	unsigned int bit, end = m->alloc_end;
+
+	/* Get managed bit which are not allocated */
+	bitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);
+	bit = find_first_bit(m->scratch_map, end);
+	if (bit >= end)
+		return -ENOSPC;
+	set_bit(bit, cm->alloc_map);
+	cm->allocated++;
+	m->total_allocated++;
+	return bit;
+}
+
+/**
+ * irq_matrix_assign - Assign a preallocated interrupt in the local CPU map
+ * @m:		Matrix pointer
+ * @bit:	Which bit to mark
+ *
+ * This should only be used to mark preallocated vectors
+ */
+void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	if (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))
+		return;
+	if (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))
+		return;
+	cm->allocated++;
+	m->total_allocated++;
+	cm->available--;
+	m->global_available--;
+}
+
+/**
+ * irq_matrix_reserve - Reserve interrupts
+ * @m:		Matrix pointer
+ *
+ * This is merily a book keeping call. It increments the number of globally
+ * reserved interrupt bits w/o actually allocating them. This allows to
+ * setup interrupt descriptors w/o assigning low level resources to it.
+ * The actual allocation happens when the interrupt gets activated.
+ */
+void irq_matrix_reserve(struct irq_matrix *m)
+{
+	if (m->global_reserved <= m->global_available &&
+	    m->global_reserved + 1 > m->global_available)
+		pr_warn("Interrupt reservation exceeds available resources\n");
+
+	m->global_reserved++;
+}
+
+/**
+ * irq_matrix_remove_reserved - Remove interrupt reservation
+ * @m:		Matrix pointer
+ *
+ * This is merily a book keeping call. It decrements the number of globally
+ * reserved interrupt bits. This is used to undo irq_matrix_reserve() when the
+ * interrupt was never in use and a real vector allocated, which undid the
+ * reservation.
+ */
+void irq_matrix_remove_reserved(struct irq_matrix *m)
+{
+	m->global_reserved--;
+}
+
+/**
+ * irq_matrix_alloc - Allocate a regular interrupt in a CPU map
+ * @m:		Matrix pointer
+ * @msk:	Which CPUs to search in
+ * @reserved:	Allocate previously reserved interrupts
+ * @mapped_cpu: Pointer to store the CPU for which the irq was allocated
+ */
+int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
+		     bool reserved, unsigned int *mapped_cpu)
+{
+	unsigned int cpu;
+
+	for_each_cpu(cpu, msk) {
+		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+		unsigned int bit;
+
+		if (!cm->online)
+			continue;
+
+		bit = matrix_alloc_area(m, cm, 1, false);
+		if (bit < m->alloc_end) {
+			cm->allocated++;
+			cm->available--;
+			m->total_allocated++;
+			m->global_available--;
+			if (reserved)
+				m->global_reserved--;
+			*mapped_cpu = cpu;
+			return bit;
+		}
+	}
+	return -ENOSPC;
+}
+
+/**
+ * irq_matrix_free - Free allocated interrupt in the matrix
+ * @m:		Matrix pointer
+ * @cpu:	Which CPU map needs be updated
+ * @bit:	The bit to remove
+ * @managed:	If true, the interrupt is managed and not accounted
+ *		as available.
+ */
+void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
+		     unsigned int bit, bool managed)
+{
+	struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+
+	if (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))
+		return;
+
+	if (cm->online) {
+		clear_bit(bit, cm->alloc_map);
+		cm->allocated--;
+		m->total_allocated--;
+		if (!managed) {
+			cm->available++;
+			m->global_available++;
+		}
+	}
+}
+
+/**
+ * irq_matrix_available - Get the number of globally available irqs
+ * @m:		Pointer to the matrix to query
+ * @cpudown:	If true, the local CPU is about to go down, adjust
+ *		the number of available irqs accordingly
+ */
+unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	return m->global_available - cpudown ? cm->available : 0;
+}
+
+/**
+ * irq_matrix_reserved - Get the number of globally reserved irqs
+ * @m:		Pointer to the matrix to query
+ */
+unsigned int irq_matrix_reserved(struct irq_matrix *m)
+{
+	return m->global_reserved;
+}
+
+/**
+ * irq_matrix_allocated - Get the number of allocated irqs on the local cpu
+ * @m:		Pointer to the matrix to search
+ *
+ * This returns number of allocated irqs
+ */
+unsigned int irq_matrix_allocated(struct irq_matrix *m)
+{
+	struct cpumap *cm = this_cpu_ptr(m->maps);
+
+	return cm->allocated;
+}
+
+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+/**
+ * irq_matrix_debug_show - Show detailed allocation information
+ * @sf:		Pointer to the seq_file to print to
+ * @m:		Pointer to the matrix allocator
+ * @ind:	Indentation for the print format
+ *
+ * Note, this is a lockless snapshot.
+ */
+void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)
+{
+	unsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);
+	int cpu;
+
+	seq_printf(sf, "Online bitmaps:   %6u\n", m->online_maps);
+	seq_printf(sf, "Global available: %6u\n", m->global_available);
+	seq_printf(sf, "Global reserved:  %6u\n", m->global_reserved);
+	seq_printf(sf, "Total allocated:  %6u\n", m->total_allocated);
+	seq_printf(sf, "System: %u: %*pbl\n", nsys, m->matrix_bits,
+		   m->system_map);
+	seq_printf(sf, "%*s| CPU | avl | man | act | vectors\n", ind, " ");
+	cpus_read_lock();
+	for_each_online_cpu(cpu) {
+		struct cpumap *cm = per_cpu_ptr(m->maps, cpu);
+
+		seq_printf(sf, "%*s %4d  %4u  %4u  %4u  %*pbl\n", ind, " ",
+			   cpu, cm->available, cm->managed, cm->allocated,
+			   m->matrix_bits, cm->alloc_map);
+	}
+	cpus_read_unlock();
+}
+#endif
