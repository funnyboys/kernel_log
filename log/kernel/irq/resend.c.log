commit acd26bcf362708594ea081ef55140e37d0854ed2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:47 2020 +0100

    genirq: Provide interrupt injection mechanism
    
    Error injection mechanisms need a half ways safe way to inject interrupts as
    invoking generic_handle_irq() or the actual device interrupt handler
    directly from e.g. a debugfs write is not guaranteed to be safe.
    
    On x86 generic_handle_irq() is unsafe due to the hardware trainwreck which
    is the base of x86 interrupt delivery and affinity management.
    
    Move the irq debugfs injection code into a separate function which can be
    used by error injection code as well.
    
    The implementation prevents at least that state is corrupted, but it cannot
    close a very tiny race window on x86 which might result in a stale and not
    serviced device interrupt under very unlikely circumstances.
    
    This is explicitly for debugging and testing and not for production use or
    abuse in random driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.990928309@linutronix.de

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index bef72dcfb79b..27634f4022d0 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -91,7 +91,7 @@ static int irq_sw_resend(struct irq_desc *desc)
  *
  * Is called with interrupts disabled and desc->lock held.
  */
-int check_irq_resend(struct irq_desc *desc)
+int check_irq_resend(struct irq_desc *desc, bool inject)
 {
 	int err = 0;
 
@@ -108,7 +108,7 @@ int check_irq_resend(struct irq_desc *desc)
 	if (desc->istate & IRQS_REPLAY)
 		return -EBUSY;
 
-	if (!(desc->istate & IRQS_PENDING))
+	if (!(desc->istate & IRQS_PENDING) && !inject)
 		return 0;
 
 	desc->istate &= ~IRQS_PENDING;
@@ -122,3 +122,52 @@ int check_irq_resend(struct irq_desc *desc)
 		desc->istate |= IRQS_REPLAY;
 	return err;
 }
+
+#ifdef CONFIG_GENERIC_IRQ_INJECTION
+/**
+ * irq_inject_interrupt - Inject an interrupt for testing/error injection
+ * @irq:	The interrupt number
+ *
+ * This function must only be used for debug and testing purposes!
+ *
+ * Especially on x86 this can cause a premature completion of an interrupt
+ * affinity change causing the interrupt line to become stale. Very
+ * unlikely, but possible.
+ *
+ * The injection can fail for various reasons:
+ * - Interrupt is not activated
+ * - Interrupt is NMI type or currently replaying
+ * - Interrupt is level type
+ * - Interrupt does not support hardware retrigger and software resend is
+ *   either not enabled or not possible for the interrupt.
+ */
+int irq_inject_interrupt(unsigned int irq)
+{
+	struct irq_desc *desc;
+	unsigned long flags;
+	int err;
+
+	/* Try the state injection hardware interface first */
+	if (!irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true))
+		return 0;
+
+	/* That failed, try via the resend mechanism */
+	desc = irq_get_desc_buslock(irq, &flags, 0);
+	if (!desc)
+		return -EINVAL;
+
+	/*
+	 * Only try to inject when the interrupt is:
+	 *  - not NMI type
+	 *  - activated
+	 */
+	if ((desc->istate & IRQS_NMI) || !irqd_is_activated(&desc->irq_data))
+		err = -EINVAL;
+	else
+		err = check_irq_resend(desc, true);
+
+	irq_put_desc_busunlock(desc, flags);
+	return err;
+}
+EXPORT_SYMBOL_GPL(irq_inject_interrupt);
+#endif

commit da90921acc62c71d27729ae211ccfda5370bf75b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:46 2020 +0100

    genirq: Sanitize state handling in check_irq_resend()
    
    The code sets IRQS_REPLAY unconditionally whether the resend happens or
    not. That doesn't have bad side effects right now, but inconsistent state
    is always a latent source of problems.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.882129117@linutronix.de

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index a21fc4eeedc7..bef72dcfb79b 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -93,6 +93,8 @@ static int irq_sw_resend(struct irq_desc *desc)
  */
 int check_irq_resend(struct irq_desc *desc)
 {
+	int err = 0;
+
 	/*
 	 * We do not resend level type interrupts. Level type interrupts
 	 * are resent by hardware when they are still active. Clear the
@@ -106,13 +108,17 @@ int check_irq_resend(struct irq_desc *desc)
 	if (desc->istate & IRQS_REPLAY)
 		return -EBUSY;
 
-	if (desc->istate & IRQS_PENDING) {
-		desc->istate &= ~IRQS_PENDING;
-		desc->istate |= IRQS_REPLAY;
+	if (!(desc->istate & IRQS_PENDING))
+		return 0;
 
-		if (!desc->irq_data.chip->irq_retrigger ||
-		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data))
-		    return irq_sw_resend(desc);
-	}
-	return 0;
+	desc->istate &= ~IRQS_PENDING;
+
+	if (!desc->irq_data.chip->irq_retrigger ||
+	    !desc->irq_data.chip->irq_retrigger(&desc->irq_data))
+		err = irq_sw_resend(desc);
+
+	/* If the retrigger was successfull, mark it with the REPLAY bit */
+	if (!err)
+		desc->istate |= IRQS_REPLAY;
+	return err;
 }

commit 1f85b1f5e1f5541272abedc19ba7b6c5b564c228
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:45 2020 +0100

    genirq: Add return value to check_irq_resend()
    
    In preparation for an interrupt injection interface which can be used
    safely by error injection mechanisms. e.g. PCI-E/ AER, add a return value
    to check_irq_resend() so errors can be propagated to the caller.
    
    Split out the software resend code so the ugly #ifdef in check_irq_resend()
    goes away and the whole thing becomes readable.
    
    Fix up the caller in debugfs. The caller in irq_startup() does not care
    about the return value as this is unconditionally invoked for all
    interrupts and the resend is best effort anyway.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.775200917@linutronix.de

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 5064b13b80d6..a21fc4eeedc7 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -47,6 +47,43 @@ static void resend_irqs(unsigned long arg)
 /* Tasklet to handle resend: */
 static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
 
+static int irq_sw_resend(struct irq_desc *desc)
+{
+	unsigned int irq = irq_desc_get_irq(desc);
+
+	/*
+	 * Validate whether this interrupt can be safely injected from
+	 * non interrupt context
+	 */
+	if (handle_enforce_irqctx(&desc->irq_data))
+		return -EINVAL;
+
+	/*
+	 * If the interrupt is running in the thread context of the parent
+	 * irq we need to be careful, because we cannot trigger it
+	 * directly.
+	 */
+	if (irq_settings_is_nested_thread(desc)) {
+		/*
+		 * If the parent_irq is valid, we retrigger the parent,
+		 * otherwise we do nothing.
+		 */
+		if (!desc->parent_irq)
+			return -EINVAL;
+		irq = desc->parent_irq;
+	}
+
+	/* Set it pending and activate the softirq: */
+	set_bit(irq, irqs_resend);
+	tasklet_schedule(&resend_tasklet);
+	return 0;
+}
+
+#else
+static int irq_sw_resend(struct irq_desc *desc)
+{
+	return -EINVAL;
+}
 #endif
 
 /*
@@ -54,50 +91,28 @@ static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
  *
  * Is called with interrupts disabled and desc->lock held.
  */
-void check_irq_resend(struct irq_desc *desc)
+int check_irq_resend(struct irq_desc *desc)
 {
 	/*
-	 * We do not resend level type interrupts. Level type
-	 * interrupts are resent by hardware when they are still
-	 * active. Clear the pending bit so suspend/resume does not
-	 * get confused.
+	 * We do not resend level type interrupts. Level type interrupts
+	 * are resent by hardware when they are still active. Clear the
+	 * pending bit so suspend/resume does not get confused.
 	 */
 	if (irq_settings_is_level(desc)) {
 		desc->istate &= ~IRQS_PENDING;
-		return;
+		return -EINVAL;
 	}
+
 	if (desc->istate & IRQS_REPLAY)
-		return;
+		return -EBUSY;
+
 	if (desc->istate & IRQS_PENDING) {
 		desc->istate &= ~IRQS_PENDING;
 		desc->istate |= IRQS_REPLAY;
 
-		if ((!desc->irq_data.chip->irq_retrigger ||
-		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) &&
-		    !handle_enforce_irqctx(&desc->irq_data)) {
-#ifdef CONFIG_HARDIRQS_SW_RESEND
-			unsigned int irq = irq_desc_get_irq(desc);
-
-			/*
-			 * If the interrupt is running in the thread
-			 * context of the parent irq we need to be
-			 * careful, because we cannot trigger it
-			 * directly.
-			 */
-			if (irq_settings_is_nested_thread(desc)) {
-				/*
-				 * If the parent_irq is valid, we
-				 * retrigger the parent, otherwise we
-				 * do nothing.
-				 */
-				if (!desc->parent_irq)
-					return;
-				irq = desc->parent_irq;
-			}
-			/* Set it pending and activate the softirq: */
-			set_bit(irq, irqs_resend);
-			tasklet_schedule(&resend_tasklet);
-#endif
-		}
+		if (!desc->irq_data.chip->irq_retrigger ||
+		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data))
+		    return irq_sw_resend(desc);
 	}
+	return 0;
 }

commit c16816acd08697b02a53f56f8936497a9f6f6e7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:43 2020 +0100

    genirq: Add protection against unsafe usage of generic_handle_irq()
    
    In general calling generic_handle_irq() with interrupts disabled from non
    interrupt context is harmless. For some interrupt controllers like the x86
    trainwrecks this is outright dangerous as it might corrupt state if an
    interrupt affinity change is pending.
    
    Add infrastructure which allows to mark interrupts as unsafe and catch such
    usage in generic_handle_irq().
    
    Reported-by: sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.590923677@linutronix.de

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 98c04ca5fa43..5064b13b80d6 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -72,8 +72,9 @@ void check_irq_resend(struct irq_desc *desc)
 		desc->istate &= ~IRQS_PENDING;
 		desc->istate |= IRQS_REPLAY;
 
-		if (!desc->irq_data.chip->irq_retrigger ||
-		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
+		if ((!desc->irq_data.chip->irq_retrigger ||
+		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) &&
+		    !handle_enforce_irqctx(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			unsigned int irq = irq_desc_get_irq(desc);
 

commit eddf3e9c7c7e4d0707c68d1bb22cc6ec8aef7d4a
Author: Yunfeng Ye <yeyunfeng@huawei.com>
Date:   Wed Sep 4 20:46:25 2019 +0800

    genirq: Prevent NULL pointer dereference in resend_irqs()
    
    The following crash was observed:
    
      Unable to handle kernel NULL pointer dereference at 0000000000000158
      Internal error: Oops: 96000004 [#1] SMP
      pc : resend_irqs+0x68/0xb0
      lr : resend_irqs+0x64/0xb0
      ...
      Call trace:
       resend_irqs+0x68/0xb0
       tasklet_action_common.isra.6+0x84/0x138
       tasklet_action+0x2c/0x38
       __do_softirq+0x120/0x324
       run_ksoftirqd+0x44/0x60
       smpboot_thread_fn+0x1ac/0x1e8
       kthread+0x134/0x138
       ret_from_fork+0x10/0x18
    
    The reason for this is that the interrupt resend mechanism happens in soft
    interrupt context, which is a asynchronous mechanism versus other
    operations on interrupts. free_irq() does not take resend handling into
    account. Thus, the irq descriptor might be already freed before the resend
    tasklet is executed. resend_irqs() does not check the return value of the
    interrupt descriptor lookup and derefences the return value
    unconditionally.
    
      1):
      __setup_irq
        irq_startup
          check_irq_resend  // activate softirq to handle resend irq
      2):
      irq_domain_free_irqs
        irq_free_descs
          free_desc
            call_rcu(&desc->rcu, delayed_free_desc)
      3):
      __do_softirq
        tasklet_action
          resend_irqs
            desc = irq_to_desc(irq)
            desc->handle_irq(desc)  // desc is NULL --> Ooops
    
    Fix this by adding a NULL pointer check in resend_irqs() before derefencing
    the irq descriptor.
    
    Fixes: a4633adcdbc1 ("[PATCH] genirq: add genirq sw IRQ-retrigger")
    Signed-off-by: Yunfeng Ye <yeyunfeng@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Zhiqiang Liu <liuzhiqiang26@huawei.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1630ae13-5c8e-901e-de09-e740b6a426a7@huawei.com

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 95414ad3506a..98c04ca5fa43 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -36,6 +36,8 @@ static void resend_irqs(unsigned long arg)
 		irq = find_first_bit(irqs_resend, nr_irqs);
 		clear_bit(irq, irqs_resend);
 		desc = irq_to_desc(irq);
+		if (!desc)
+			continue;
 		local_irq_disable();
 		desc->handle_irq(desc);
 		local_irq_enable();

commit 99bfce5db9c071800bdc7e9658a68e6d11aeecf6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 14 22:15:16 2018 +0100

    genirq: Cleanup top of file comments
    
    Remove pointless references to the file name itself and condense the
    information so it wastes less space.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Link: https://lkml.kernel.org/r/20180314212030.412095827@linutronix.de

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 1d08f45135c2..95414ad3506a 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -1,7 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/kernel/irq/resend.c
- *
  * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar
  * Copyright (C) 2005-2006, Thomas Gleixner
  *

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index b86886beee4f..1d08f45135c2 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * linux/kernel/irq/resend.c
  *

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index dd95f44f99b2..b86886beee4f 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -38,7 +38,7 @@ static void resend_irqs(unsigned long arg)
 		clear_bit(irq, irqs_resend);
 		desc = irq_to_desc(irq);
 		local_irq_disable();
-		desc->handle_irq(irq, desc);
+		desc->handle_irq(desc);
 		local_irq_enable();
 	}
 }

commit 4b979e4c611ce750d32b51737f837b485f43c69b
Merge: 1559f3b8d052 cbfe8fa6cd67
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 30 00:13:24 2015 +0200

    Merge branch 'linus' into irq/core
    
    Pull in upstream fixes before applying conflicting changes

commit 75a06189fc508a2acf470b0b12710362ffb2c4b1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 16 14:10:17 2015 +0200

    genirq: Prevent resend to interrupts marked IRQ_NESTED_THREAD
    
    The resend mechanism happily calls the interrupt handler of interrupts
    which are marked IRQ_NESTED_THREAD from softirq context. This can
    result in crashes because the interrupt handler is not the proper way
    to invoke the device handlers. They must be invoked via
    handle_nested_irq.
    
    Prevent the resend even if the interrupt has no valid parent irq
    set. Its better to have a lost interrupt than a crashing machine.
    
    Reported-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 9065107f083e..7a5237a1bce5 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -75,13 +75,21 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/*
-			 * If the interrupt has a parent irq and runs
-			 * in the thread context of the parent irq,
-			 * retrigger the parent.
+			 * If the interrupt is running in the thread
+			 * context of the parent irq we need to be
+			 * careful, because we cannot trigger it
+			 * directly.
 			 */
-			if (desc->parent_irq &&
-			    irq_settings_is_nested_thread(desc))
+			if (irq_settings_is_nested_thread(desc)) {
+				/*
+				 * If the parent_irq is valid, we
+				 * retrigger the parent, otherwise we
+				 * do nothing.
+				 */
+				if (!desc->parent_irq)
+					return;
 				irq = desc->parent_irq;
+			}
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);
 			tasklet_schedule(&resend_tasklet);

commit 0798abeb7eec37dcc20f252c2195fc31c41561f9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:27 2015 +0800

    genirq: Remove the irq argument from check_irq_resend()
    
    It's only used in the software resend case and can be retrieved from
    irq_desc if necessary.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1433391238-19471-18-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 9065107f083e..32fc47c2c622 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -53,7 +53,7 @@ static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
  *
  * Is called with interrupts disabled and desc->lock held.
  */
-void check_irq_resend(struct irq_desc *desc, unsigned int irq)
+void check_irq_resend(struct irq_desc *desc)
 {
 	/*
 	 * We do not resend level type interrupts. Level type
@@ -74,6 +74,8 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 		if (!desc->irq_data.chip->irq_retrigger ||
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
+			unsigned int irq = irq_desc_get_irq(desc);
+
 			/*
 			 * If the interrupt has a parent irq and runs
 			 * in the thread context of the parent irq,

commit 293a7a0a165c4f8327bbcf396cee9ec672727c98
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 16 15:07:49 2012 -0700

    genirq: Provide means to retrigger parent
    
    Attempts to retrigger nested threaded IRQs currently fail because they
    have no primary handler. In order to support retrigger of nested
    IRQs, the parent IRQ needs to be retriggered.
    
    To fix, when an IRQ needs to be resent, if the interrupt has a parent
    IRQ and runs in the context of the parent IRQ, then resend the parent.
    
    Also, handle_nested_irq() needs to clear the replay flag like the
    other handlers, otherwise check_irq_resend() will set it and it will
    never be cleared.  Without clearing, it results in the first resend
    working fine, but check_irq_resend() returning early on subsequent
    resends because the replay flag is still set.
    
    Problem discovered on ARM/OMAP platforms where a nested IRQ that's
    also a wakeup IRQ happens late in suspend and needed to be retriggered
    during the resume process.
    
    [khilman@ti.com: changelog edits, clear IRQS_REPLAY in handle_nested_irq()]
    
    Reported-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1350425269-11489-1-git-send-email-khilman@deeprootsystems.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 6454db7b6a4d..9065107f083e 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -74,6 +74,14 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 		if (!desc->irq_data.chip->irq_retrigger ||
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
+			/*
+			 * If the interrupt has a parent irq and runs
+			 * in the thread context of the parent irq,
+			 * retrigger the parent.
+			 */
+			if (desc->parent_irq &&
+			    irq_settings_is_nested_thread(desc))
+				irq = desc->parent_irq;
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);
 			tasklet_schedule(&resend_tasklet);

commit d4dc0f90d243fb54cfbca6601c9a7c5a758e437f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 25 12:54:54 2012 +0200

    genirq: Allow check_wakeup_irqs to notice level-triggered interrupts
    
    Level triggered interrupts do not cause IRQS_PENDING to be set when
    they fire while "disabled" as the 'pending' state is always present in
    the level - they automatically refire where re-enabled.
    
    However the IRQS_PENDING flag is also used to abort a suspend cycle -
    if any 'is_wakeup_set' interrupt is PENDING, check_wakeup_irqs() will
    cause suspend to abort. Without IRQS_PENDING, suspend won't abort.
    
    Consequently, level-triggered interrupts that fire during the 'noirq'
    phase of suspend do not currently abort suspend.
    
    So set IRQS_PENDING even for level triggered interrupts, and make sure
    to clear the flag in check_irq_resend.
    
    [ Changelog by courtesy of Neil ]
    
    Tested-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 14dd5761e8c9..6454db7b6a4d 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -58,10 +58,13 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	/*
 	 * We do not resend level type interrupts. Level type
 	 * interrupts are resent by hardware when they are still
-	 * active.
+	 * active. Clear the pending bit so suspend/resume does not
+	 * get confused.
 	 */
-	if (irq_settings_is_level(desc))
+	if (irq_settings_is_level(desc)) {
+		desc->istate &= ~IRQS_PENDING;
 		return;
+	}
 	if (desc->istate & IRQS_REPLAY)
 		return;
 	if (desc->istate & IRQS_PENDING) {

commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 13:32:20 2011 +0200

    genirq: Remove compat code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index ad683a99b1ec..14dd5761e8c9 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -65,7 +65,6 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	if (desc->istate & IRQS_REPLAY)
 		return;
 	if (desc->istate & IRQS_PENDING) {
-		irq_compat_clr_pending(desc);
 		desc->istate &= ~IRQS_PENDING;
 		desc->istate |= IRQS_REPLAY;
 

commit 876dbd4cc1b35c1a4cb96a2be1d43ea0eabce3b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:28:12 2011 +0100

    genirq: Mirror irq trigger type bits in irq_data.state
    
    That's the data structure chip functions get provided. Also allow them
    to signal the core code that they updated the flags in irq_data.state
    by returning IRQ_SET_MASK_OK_NOCOPY. The default is unchanged.
    
    The type bits should be accessed via:
    
    val = irqd_get_trigger_type(irqdata);
    and
    irqd_set_trigger_type(irqdata, val);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index ff1fea060014..ad683a99b1ec 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -60,7 +60,7 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	 * interrupts are resent by hardware when they are still
 	 * active.
 	 */
-	if (desc->status & IRQ_LEVEL)
+	if (irq_settings_is_level(desc))
 		return;
 	if (desc->istate & IRQS_REPLAY)
 		return;

commit 2a0d6fb335d4428285dab2d254911748e6040807
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:17:57 2011 +0100

    genirq: Move IRQ_PENDING flag to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index f83387cd11f3..ff1fea060014 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -64,8 +64,9 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 		return;
 	if (desc->istate & IRQS_REPLAY)
 		return;
-	if (desc->status & IRQ_PENDING) {
-		desc->status &= ~IRQ_PENDING;
+	if (desc->istate & IRQS_PENDING) {
+		irq_compat_clr_pending(desc);
+		desc->istate &= ~IRQS_PENDING;
 		desc->istate |= IRQS_REPLAY;
 
 		if (!desc->irq_data.chip->irq_retrigger ||

commit 163ef3091195f514a06f064b12914597d2644c55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 11:39:15 2011 +0100

    genirq: Move IRQ_REPLAY and IRQ_WAITING to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 60b20261041b..f83387cd11f3 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -62,8 +62,11 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	 */
 	if (desc->status & IRQ_LEVEL)
 		return;
-	if ((desc->status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
-		desc->status = (desc->status & ~IRQ_PENDING) | IRQ_REPLAY;
+	if (desc->istate & IRQS_REPLAY)
+		return;
+	if (desc->status & IRQ_PENDING) {
+		desc->status &= ~IRQ_PENDING;
+		desc->istate |= IRQS_REPLAY;
 
 		if (!desc->irq_data.chip->irq_retrigger ||
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {

commit 3aae994fb0f43f6d94a31c33536a83869504abdf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 4 10:17:52 2011 +0100

    genirq: Consolidate IRQ_DISABLED
    
    Handle IRQ_DISABLED consistent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 4bfe268dffe5..60b20261041b 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -55,11 +55,6 @@ static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
  */
 void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 {
-	/*
-	 * Make sure the interrupt is enabled, before resending it:
-	 */
-	irq_enable(desc);
-
 	/*
 	 * We do not resend level type interrupts. Level type
 	 * interrupts are resent by hardware when they are still

commit 87923470c712dff00b101ffb6b6fbc27bd7a6df5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 3 12:27:44 2011 +0100

    genirq: Consolidate disable/enable
    
    Create irq_disable/enable and use them to keep the flags consistent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index dc49358b73fa..4bfe268dffe5 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -55,20 +55,20 @@ static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
  */
 void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 {
-	unsigned int status = desc->status;
-
 	/*
 	 * Make sure the interrupt is enabled, before resending it:
 	 */
-	desc->irq_data.chip->irq_enable(&desc->irq_data);
+	irq_enable(desc);
 
 	/*
 	 * We do not resend level type interrupts. Level type
 	 * interrupts are resent by hardware when they are still
 	 * active.
 	 */
-	if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
-		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
+	if (desc->status & IRQ_LEVEL)
+		return;
+	if ((desc->status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
+		desc->status = (desc->status & ~IRQ_PENDING) | IRQ_REPLAY;
 
 		if (!desc->irq_data.chip->irq_retrigger ||
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {

commit c1ee6264280e740a9d3ff3feef38642cf0a57013
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 17 17:45:15 2011 +0100

    genirq: Prevent access beyond allocated_irqs bitmap
    
    Lars-Peter Clausen pointed out:
    
       I stumbled upon this while looking through the existing archs using
       SPARSE_IRQ.  Even with SPARSE_IRQ the NR_IRQS is still the upper
       limit for the number of IRQs.
    
       Both PXA and MMP set NR_IRQS to IRQ_BOARD_START, with
       IRQ_BOARD_START being the number of IRQs used by the core.
    
       In various machine files the nr_irqs field of the ARM machine
       defintion struct is then set to "IRQ_BOARD_START + NR_BOARD_IRQS".
    
       As a result "nr_irqs" will greater then NR_IRQS which then again
       causes the "allocated_irqs" bitmap in the core irq code to be
       accessed beyond its size overwriting unrelated data.
    
    The core code really misses a sanity check there.
    
    This went unnoticed so far as by chance the compiler/linker places
    data behind that bitmap which gets initialized later on those affected
    platforms.
    
    So the obvious fix would be to add a sanity check in early_irq_init()
    and break all affected platforms. Though that check wants to be
    backported to stable as well, which will require to fix all known
    problematic platforms and probably some more yet not known ones as
    well. Lots of churn.
    
    A way simpler solution is to allocate a slightly larger bitmap and
    avoid the whole churn w/o breaking anything. Add a few warnings when
    an arch returns utter crap.
    
    Reported-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org # .37
    Cc: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 891115a929aa..dc49358b73fa 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -23,7 +23,7 @@
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 
 /* Bitmap to handle software resend of interrupts: */
-static DECLARE_BITMAP(irqs_resend, NR_IRQS);
+static DECLARE_BITMAP(irqs_resend, IRQ_BITMAP_BITS);
 
 /*
  * Run software resends of IRQ's

commit 21e2b8c62cca8f7dbec0c8c131ca1637e4a5670f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 12:45:53 2010 +0000

    genirq: Provide compat handling for chip->retrigger()
    
    Wrap the old chip function retrigger() until the migration is complete
    and the old chip functions are removed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20100927121843.025801092@linutronix.de>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index a798a2328f8a..891115a929aa 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -70,8 +70,8 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 
-		if (!desc->irq_data.chip->retrigger ||
-		    !desc->irq_data.chip->retrigger(irq)) {
+		if (!desc->irq_data.chip->irq_retrigger ||
+		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);

commit c5f756344c390f629243b4a28c2bd198fdfd7ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 12:44:56 2010 +0000

    genirq: Provide compat handling for chip->enable()
    
    Wrap the old chip function enable() until the migration is complete and
    the old chip functions are removed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20100927121842.437159182@linutronix.de>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 47c56a097928..a798a2328f8a 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -60,7 +60,7 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	/*
 	 * Make sure the interrupt is enabled, before resending it:
 	 */
-	desc->irq_data.chip->enable(irq);
+	desc->irq_data.chip->irq_enable(&desc->irq_data);
 
 	/*
 	 * We do not resend level type interrupts. Level type

commit 6b8ff3120c758340505dddf08ad685ebb841d5d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 12:58:38 2010 +0200

    genirq: Convert core code to irq_data
    
    Convert all references in the core code to orq, chip, handler_data,
    chip_data, msi_desc, affinity to irq_data.*
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 090c3763f3a2..47c56a097928 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -60,7 +60,7 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	/*
 	 * Make sure the interrupt is enabled, before resending it:
 	 */
-	desc->chip->enable(irq);
+	desc->irq_data.chip->enable(irq);
 
 	/*
 	 * We do not resend level type interrupts. Level type
@@ -70,7 +70,8 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 
-		if (!desc->chip->retrigger || !desc->chip->retrigger(irq)) {
+		if (!desc->irq_data.chip->retrigger ||
+		    !desc->irq_data.chip->retrigger(irq)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);

commit c36ba80ea01d0aecb652c26799a912e760ce8981
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Aug 6 21:46:03 2009 +0200

    irq: Remove superfluous NULL pointer check in check_irq_resend()
    
    This takes care of the following entry from Dan's list:
    
    kernel/irq/resend.c +73 check_irq_resend(17) warning: variable derefenced before check 'desc->chip'
    
    Reported-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Eugene Teo <eteo@redhat.com>
    Cc: Julia Lawall <julia@diku.dk>
    LKML-Reference: <200908062146.03638.bzolnier@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 89c7117acf2b..090c3763f3a2 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -70,8 +70,7 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 
-		if (!desc->chip || !desc->chip->retrigger ||
-					!desc->chip->retrigger(irq)) {
+		if (!desc->chip->retrigger || !desc->chip->retrigger(irq)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);

commit 08678b0841267c1d00d771fe01548d86043d065e
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:05 2008 -0700

    generic: sparse irqs: use irq_desc() together with dyn_array, instead of irq_desc[]
    
    add CONFIG_HAVE_SPARSE_IRQ to for use condensed array.
    Get rid of irq_desc[] array assumptions.
    
    Preallocate 32 irq_desc, and irq_desc() will try to get more.
    
    ( No change in functionality is expected anywhere, except the odd build
      failure where we missed a code site or where a crossing commit itroduces
      new irq_desc[] usage. )
    
    v2: according to Eric, change get_irq_desc() to irq_desc()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index cba8aa5bc7f4..89c7117acf2b 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -36,7 +36,7 @@ static void resend_irqs(unsigned long arg)
 	while (!bitmap_empty(irqs_resend, nr_irqs)) {
 		irq = find_first_bit(irqs_resend, nr_irqs);
 		clear_bit(irq, irqs_resend);
-		desc = irq_desc + irq;
+		desc = irq_to_desc(irq);
 		local_irq_disable();
 		desc->handle_irq(irq, desc);
 		local_irq_enable();

commit 85c0f90978bf50596dbd23854648020f1f9b5bfd
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:49:47 2008 -0700

    irq: introduce nr_irqs
    
    at this point nr_irqs is equal NR_IRQS
    
    convert a few easy users from NR_IRQS to dynamic nr_irqs.
    
    v2: according to Eric, we need to take care of arch without generic_hardirqs
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index a8046791ba2d..cba8aa5bc7f4 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -33,8 +33,8 @@ static void resend_irqs(unsigned long arg)
 	struct irq_desc *desc;
 	int irq;
 
-	while (!bitmap_empty(irqs_resend, NR_IRQS)) {
-		irq = find_first_bit(irqs_resend, NR_IRQS);
+	while (!bitmap_empty(irqs_resend, nr_irqs)) {
+		irq = find_first_bit(irqs_resend, nr_irqs);
 		clear_bit(irq, irqs_resend);
 		desc = irq_desc + irq;
 		local_irq_disable();

commit 2464286ace55b3abddfb9cc30ab95e2dac1de9a6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 12 15:46:35 2007 +0000

    genirq: suppress resend of level interrupts
    
    Level type interrupts are resent by the interrupt hardware when they are
    still active at irq_enable().
    
    Suppress the resend mechanism for interrupts marked as level.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 5bfeaed7e487..a8046791ba2d 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -62,7 +62,12 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	 */
 	desc->chip->enable(irq);
 
-	if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
+	/*
+	 * We do not resend level type interrupts. Level type
+	 * interrupts are resent by hardware when they are still
+	 * active.
+	 */
+	if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 
 		if (!desc->chip || !desc->chip->retrigger ||

commit 88ffc3505988196ef5cfdc0278ad89025c2a7b1a
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Aug 9 08:10:16 2007 -0700

    Revert "genirq: temporary fix for level-triggered IRQ resend"
    
    This reverts commit 0fc4969b866671dfe39b1a9119d0fdc7ea0f63e5.  It was
    always meant to be temporary, but it's generating more useless noise
    than anything else, and we probably should never have done it in the
    generic kernel (only had the people involved test it on their own).
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index c38272746887..5bfeaed7e487 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -62,15 +62,6 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	 */
 	desc->chip->enable(irq);
 
-	/*
-	 * Temporary hack to figure out more about the problem, which
-	 * is causing the ancient network cards to die.
-	 */
-	if (desc->handle_irq != handle_edge_irq) {
-		WARN_ON_ONCE(1);
-		return;
-	}
-
 	if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 

commit 0fc4969b866671dfe39b1a9119d0fdc7ea0f63e5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Aug 1 17:13:19 2007 +0200

    genirq: temporary fix for level-triggered IRQ resend
    
    Marcin Slusarz reported a ne2k-pci "hung network interface" regression.
    
    delayed disable relies on the ability to re-trigger the interrupt in the
    case that a real interrupt happens after the software disable was set.
    In this case we actually disable the interrupt on the hardware level
    _after_ it occurred.
    
    On enable_irq, we need to re-trigger the interrupt. On i386 this relies
    on a hardware resend mechanism (send_IPI_self()).
    
    Actually we only need the resend for edge type interrupts. Level type
    interrupts come back once enable_irq() re-enables the interrupt line.
    
    I assume that the interrupt in question is level triggered because it is
    shared and above the legacy irqs 0-15:
    
            17:         12   IO-APIC-fasteoi   eth1, eth0
    
    Looking into the IO_APIC code, the resend via send_IPI_self() happens
    unconditionally. So the resend is done for level and edge interrupts.
    This makes the problem more mysterious.
    
    The code in question lib8390.c does
    
            disable_irq();
            fiddle_with_the_network_card_hardware()
            enable_irq();
    
    The fiddle_with_the_network_card_hardware() might cause interrupts,
    which are cleared in the same code path again,
    
    Marcin found that when he disables the irq line on the hardware level
    (removing the delayed disable) the card is kept alive.
    
    So the difference is that we can get a resend on enable_irq, when an
    interrupt happens during the time, where we are in the disabled region.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 5bfeaed7e487..c38272746887 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -62,6 +62,15 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	 */
 	desc->chip->enable(irq);
 
+	/*
+	 * Temporary hack to figure out more about the problem, which
+	 * is causing the ancient network cards to die.
+	 */
+	if (desc->handle_irq != handle_edge_irq) {
+		WARN_ON_ONCE(1);
+		return;
+	}
+
 	if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
 		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 

commit e317c8ccaaf900abf39cc3240e4dc5ba82a3cc67
Author: Frederik Deweerdt <deweerdt@free.fr>
Date:   Fri Oct 6 18:58:24 2006 +0000

    [PATCH] ixp4xxdefconfig arm fixes
    
    With the following patch, the ixp4xxdefconfig builds correctly.  I'll
    test some more configs if I get some time.
    
    Signed-off-by: Frederik Deweerdt <frederik.deweerdt@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 35f10f7ff94a..5bfeaed7e487 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -38,7 +38,7 @@ static void resend_irqs(unsigned long arg)
 		clear_bit(irq, irqs_resend);
 		desc = irq_desc + irq;
 		local_irq_disable();
-		desc->handle_irq(irq, desc, NULL);
+		desc->handle_irq(irq, desc);
 		local_irq_enable();
 	}
 }

commit e1ed7ac77b63abb6b3a2c0b4b070f50da5b1fb2f
Author: Imre Deak <imre.deak@solidboot.com>
Date:   Sat Sep 16 12:15:35 2006 -0700

    [PATCH] genirq: fix typo in IRQ resend
    
    Fix a bug where the IRQ_PENDING flag is never cleared and the ISR is called
    endlessly without an actual interrupt.
    
    Signed-off-by: Imre Deak <imre.deak@solidboot.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 872f91ba2ce8..35f10f7ff94a 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -63,8 +63,7 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 	desc->chip->enable(irq);
 
 	if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
-		desc->status &= ~IRQ_PENDING;
-		desc->status = status | IRQ_REPLAY;
+		desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
 
 		if (!desc->chip || !desc->chip->retrigger ||
 					!desc->chip->retrigger(irq)) {

commit 6a6de9ef5850d063c3d3fb50784bfe3a6d0712c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:51 2006 -0700

    [PATCH] genirq: core
    
    Core genirq support: add the irq-chip and irq-flow abstractions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 096b102fb392..872f91ba2ce8 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -37,9 +37,9 @@ static void resend_irqs(unsigned long arg)
 		irq = find_first_bit(irqs_resend, NR_IRQS);
 		clear_bit(irq, irqs_resend);
 		desc = irq_desc + irq;
-		spin_lock_irqsave(&desc->lock, flags);
+		local_irq_disable();
 		desc->handle_irq(irq, desc, NULL);
-		spin_unlock_irqrestore(&desc->lock, flags);
+		local_irq_enable();
 	}
 }
 

commit a4633adcdbc15ac51afcd0e1395de58cee27cf92
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:48 2006 -0700

    [PATCH] genirq: add genirq sw IRQ-retrigger
    
    Enable platforms that do not have a hardware-assisted hardirq-resend mechanism
    to resend them via a softirq-driven IRQ emulation mechanism.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
new file mode 100644
index 000000000000..096b102fb392
--- /dev/null
+++ b/kernel/irq/resend.c
@@ -0,0 +1,78 @@
+/*
+ * linux/kernel/irq/resend.c
+ *
+ * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar
+ * Copyright (C) 2005-2006, Thomas Gleixner
+ *
+ * This file contains the IRQ-resend code
+ *
+ * If the interrupt is waiting to be processed, we try to re-run it.
+ * We can't directly run it from here since the caller might be in an
+ * interrupt-protected region. Not all irq controller chips can
+ * retrigger interrupts at the hardware level, so in those cases
+ * we allow the resending of IRQs via a tasklet.
+ */
+
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/interrupt.h>
+
+#include "internals.h"
+
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+
+/* Bitmap to handle software resend of interrupts: */
+static DECLARE_BITMAP(irqs_resend, NR_IRQS);
+
+/*
+ * Run software resends of IRQ's
+ */
+static void resend_irqs(unsigned long arg)
+{
+	struct irq_desc *desc;
+	int irq;
+
+	while (!bitmap_empty(irqs_resend, NR_IRQS)) {
+		irq = find_first_bit(irqs_resend, NR_IRQS);
+		clear_bit(irq, irqs_resend);
+		desc = irq_desc + irq;
+		spin_lock_irqsave(&desc->lock, flags);
+		desc->handle_irq(irq, desc, NULL);
+		spin_unlock_irqrestore(&desc->lock, flags);
+	}
+}
+
+/* Tasklet to handle resend: */
+static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
+
+#endif
+
+/*
+ * IRQ resend
+ *
+ * Is called with interrupts disabled and desc->lock held.
+ */
+void check_irq_resend(struct irq_desc *desc, unsigned int irq)
+{
+	unsigned int status = desc->status;
+
+	/*
+	 * Make sure the interrupt is enabled, before resending it:
+	 */
+	desc->chip->enable(irq);
+
+	if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
+		desc->status &= ~IRQ_PENDING;
+		desc->status = status | IRQ_REPLAY;
+
+		if (!desc->chip || !desc->chip->retrigger ||
+					!desc->chip->retrigger(irq)) {
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+			/* Set it pending and activate the softirq: */
+			set_bit(irq, irqs_resend);
+			tasklet_schedule(&resend_tasklet);
+#endif
+		}
+	}
+}
