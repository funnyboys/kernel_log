commit acd26bcf362708594ea081ef55140e37d0854ed2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:47 2020 +0100

    genirq: Provide interrupt injection mechanism
    
    Error injection mechanisms need a half ways safe way to inject interrupts as
    invoking generic_handle_irq() or the actual device interrupt handler
    directly from e.g. a debugfs write is not guaranteed to be safe.
    
    On x86 generic_handle_irq() is unsafe due to the hardware trainwreck which
    is the base of x86 interrupt delivery and affinity management.
    
    Move the irq debugfs injection code into a separate function which can be
    used by error injection code as well.
    
    The implementation prevents at least that state is corrupted, but it cannot
    close a very tiny race window on x86 which might result in a stale and not
    serviced device interrupt under very unlikely circumstances.
    
    This is explicitly for debugging and testing and not for production use or
    abuse in random driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.990928309@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8980859bdf1e..7db284b10ac9 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -108,7 +108,7 @@ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 
 /* Resending of interrupts :*/
-int check_irq_resend(struct irq_desc *desc);
+int check_irq_resend(struct irq_desc *desc, bool inject);
 bool irq_wait_for_poll(struct irq_desc *desc);
 void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);
 

commit 1f85b1f5e1f5541272abedc19ba7b6c5b564c228
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:45 2020 +0100

    genirq: Add return value to check_irq_resend()
    
    In preparation for an interrupt injection interface which can be used
    safely by error injection mechanisms. e.g. PCI-E/ AER, add a return value
    to check_irq_resend() so errors can be propagated to the caller.
    
    Split out the software resend code so the ugly #ifdef in check_irq_resend()
    goes away and the whole thing becomes readable.
    
    Fix up the caller in debugfs. The caller in irq_startup() does not care
    about the return value as this is unconditionally invoked for all
    interrupts and the resend is best effort anyway.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.775200917@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 5be382fc9415..8980859bdf1e 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -108,7 +108,7 @@ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 
 /* Resending of interrupts :*/
-void check_irq_resend(struct irq_desc *desc);
+int check_irq_resend(struct irq_desc *desc);
 bool irq_wait_for_poll(struct irq_desc *desc);
 void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);
 

commit c16816acd08697b02a53f56f8936497a9f6f6e7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:43 2020 +0100

    genirq: Add protection against unsafe usage of generic_handle_irq()
    
    In general calling generic_handle_irq() with interrupts disabled from non
    interrupt context is harmless. For some interrupt controllers like the x86
    trainwrecks this is outright dangerous as it might corrupt state if an
    interrupt affinity change is pending.
    
    Add infrastructure which allows to mark interrupts as unsafe and catch such
    usage in generic_handle_irq().
    
    Reported-by: sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.590923677@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c9d8eb7f5c02..5be382fc9415 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -425,6 +425,10 @@ static inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)
 {
 	return desc->pending_mask;
 }
+static inline bool handle_enforce_irqctx(struct irq_data *data)
+{
+	return irqd_is_handle_enforce_irqctx(data);
+}
 bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);
 #else /* CONFIG_GENERIC_PENDING_IRQ */
 static inline bool irq_can_move_pcntxt(struct irq_data *data)
@@ -451,6 +455,10 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 {
 	return false;
 }
+static inline bool handle_enforce_irqctx(struct irq_data *data)
+{
+	return false;
+}
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)

commit cba6437a1854fde5934098ec3bd0ee83af3129f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 12 12:19:41 2020 +0100

    genirq/proc: Reject invalid affinity masks (again)
    
    Qian Cai reported that the WARN_ON() in the x86/msi affinity setting code,
    which catches cases where the affinity setting is not done on the CPU which
    is the current target of the interrupt, triggers during CPU hotplug stress
    testing.
    
    It turns out that the warning which was added with the commit addressing
    the MSI affinity race unearthed yet another long standing bug.
    
    If user space writes a bogus affinity mask, i.e. it contains no online CPUs,
    then it calls irq_select_affinity_usr(). This was introduced for ALPHA in
    
      eee45269b0f5 ("[PATCH] Alpha: convert to generic irq framework (generic part)")
    
    and subsequently made available for all architectures in
    
      18404756765c ("genirq: Expose default irq affinity mask (take 3)")
    
    which introduced the circumvention of the affinity setting restrictions for
    interrupt which cannot be moved in process context.
    
    The whole exercise is bogus in various aspects:
    
      1) If the interrupt is already started up then there is absolutely
         no point to honour a bogus interrupt affinity setting from user
         space. The interrupt is already assigned to an online CPU and it
         does not make any sense to reassign it to some other randomly
         chosen online CPU.
    
      2) If the interupt is not yet started up then there is no point
         either. A subsequent startup of the interrupt will invoke
         irq_setup_affinity() anyway which will chose a valid target CPU.
    
    So the only correct solution is to just return -EINVAL in case user space
    wrote an affinity mask which does not contain any online CPUs, except for
    ALPHA which has it's own magic sauce for this.
    
    Fixes: 18404756765c ("genirq: Expose default irq affinity mask (take 3)")
    Reported-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Qian Cai <cai@lca.pw>
    Link: https://lkml.kernel.org/r/878sl8xdbm.fsf@nanos.tec.linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 3924fbe829d4..c9d8eb7f5c02 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -128,8 +128,6 @@ static inline void unregister_handler_proc(unsigned int irq,
 
 extern bool irq_can_set_affinity_usr(unsigned int irq);
 
-extern int irq_select_affinity_usr(unsigned int irq);
-
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
 extern int irq_do_set_affinity(struct irq_data *data,

commit 0902d5011cfaabd6a09326299ef77e1c8735fb89
Merge: 927ba67a63c7 f8a8fe61fec8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:22:57 2019 -0700

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x96 apic updates from Thomas Gleixner:
     "Updates for the x86 APIC interrupt handling and APIC timer:
    
       - Fix a long standing issue with spurious interrupts which was caused
         by the big vector management rework a few years ago. Robert Hodaszi
         provided finally enough debug data and an excellent initial failure
         analysis which allowed to understand the underlying issues.
    
         This contains a change to the core interrupt management code which
         is required to handle this correctly for the APIC/IO_APIC. The core
         changes are NOOPs for most architectures except ARM64. ARM64 is not
         impacted by the change as confirmed by Marc Zyngier.
    
       - Newer systems allow to disable the PIT clock for power saving
         causing panic in the timer interrupt delivery check of the IO/APIC
         when the HPET timer is not enabled either. While the clock could be
         turned on this would cause an endless whack a mole game to chase
         the proper register in each affected chipset.
    
         These systems provide the relevant frequencies for TSC, CPU and the
         local APIC timer via CPUID and/or MSRs, which allows to avoid the
         PIT/HPET based calibration. As the calibration code is the only
         usage of the legacy timers on modern systems and is skipped anyway
         when the frequencies are known already, there is no point in
         setting up the PIT and actually checking for the interrupt delivery
         via IO/APIC.
    
         To achieve this on a wide variety of platforms, the CPUID/MSR based
         frequency readout has been made more robust, which also allowed to
         remove quite some workarounds which turned out to be not longer
         required. Thanks to Daniel Drake for analysis, patches and
         verification"
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/irq: Seperate unused system vectors from spurious entry again
      x86/irq: Handle spurious interrupt after shutdown gracefully
      x86/ioapic: Implement irq_get_irqchip_state() callback
      genirq: Add optional hardware synchronization for shutdown
      genirq: Fix misleading synchronize_irq() documentation
      genirq: Delay deactivation in free_irq()
      x86/timer: Skip PIT initialization on modern chipsets
      x86/apic: Use non-atomic operations when possible
      x86/apic: Make apic_bsp_setup() static
      x86/tsc: Set LAPIC timer period to crystal clock frequency
      x86/apic: Rename 'lapic_timer_frequency' to 'lapic_timer_period'
      x86/tsc: Use CPUID.0x16 to calculate missing crystal frequency

commit 62e0468650c30f0298822c580f382b16328119f6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 28 13:11:51 2019 +0200

    genirq: Add optional hardware synchronization for shutdown
    
    free_irq() ensures that no hardware interrupt handler is executing on a
    different CPU before actually releasing resources and deactivating the
    interrupt completely in a domain hierarchy.
    
    But that does not catch the case where the interrupt is on flight at the
    hardware level but not yet serviced by the target CPU. That creates an
    interesing race condition:
    
       CPU 0                  CPU 1               IRQ CHIP
    
                                                  interrupt is raised
                                                  sent to CPU1
                              Unable to handle
                              immediately
                              (interrupts off,
                               deep idle delay)
       mask()
       ...
       free()
         shutdown()
         synchronize_irq()
         release_resources()
                              do_IRQ()
                                -> resources are not available
    
    That might be harmless and just trigger a spurious interrupt warning, but
    some interrupt chips might get into a wedged state.
    
    Utilize the existing irq_get_irqchip_state() callback for the
    synchronization in free_irq().
    
    synchronize_hardirq() is not using this mechanism as it might actually
    deadlock unter certain conditions, e.g. when called with interrupts
    disabled and the target CPU is the one on which the synchronization is
    invoked. synchronize_irq() uses it because that function cannot be called
    from non preemtible contexts as it might sleep.
    
    No functional change intended and according to Marc the existing GIC
    implementations where the driver supports the callback should be able
    to cope with that core change. Famous last words.
    
    Fixes: 464d12309e1b ("x86/vector: Switch IOAPIC to global reservation mode")
    Reported-by: Robert Hodaszi <Robert.Hodaszi@digi.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/20190628111440.279463375@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 9c957f8b1198..3a948f41ab00 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -97,6 +97,10 @@ static inline void irq_mark_irq(unsigned int irq) { }
 extern void irq_mark_irq(unsigned int irq);
 #endif
 
+extern int __irq_get_irqchip_state(struct irq_data *data,
+				   enum irqchip_irq_state which,
+				   bool *state);
+
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
 irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags);

commit 4001d8e8762f57d418b66e4e668601791900a1dd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 28 13:11:49 2019 +0200

    genirq: Delay deactivation in free_irq()
    
    When interrupts are shutdown, they are immediately deactivated in the
    irqdomain hierarchy. While this looks obviously correct there is a subtle
    issue:
    
    There might be an interrupt in flight when free_irq() is invoking the
    shutdown. This is properly handled at the irq descriptor / primary handler
    level, but the deactivation might completely disable resources which are
    required to acknowledge the interrupt.
    
    Split the shutdown code and deactivate the interrupt after synchronization
    in free_irq(). Fixup all other usage sites where this is not an issue to
    invoke the combined shutdown_and_deactivate() function instead.
    
    This still might be an issue if the interrupt in flight servicing is
    delayed on a remote CPU beyond the invocation of synchronize_irq(), but
    that cannot be handled at that level and needs to be handled in the
    synchronize_irq() context.
    
    Fixes: f8264e34965a ("irqdomain: Introduce new interfaces to support hierarchy irqdomains")
    Reported-by: Robert Hodaszi <Robert.Hodaszi@digi.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/20190628111440.098196390@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 70c3053bc1f6..9c957f8b1198 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -82,6 +82,7 @@ extern int irq_activate_and_startup(struct irq_desc *desc, bool resend);
 extern int irq_startup(struct irq_desc *desc, bool resend, bool force);
 
 extern void irq_shutdown(struct irq_desc *desc);
+extern void irq_shutdown_and_deactivate(struct irq_desc *desc);
 extern void irq_enable(struct irq_desc *desc);
 extern void irq_disable(struct irq_desc *desc);
 extern void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu);

commit df025e47e4e34b779af2cc72c350877be7104ef3
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon May 27 22:55:17 2019 +0200

    genirq/timings: Encapsulate timings push
    
    For the next patches providing the selftest, it is required to artificially
    insert timings value in the circular buffer in order to check the
    correctness of the code. Encapsulate the common code between the future
    test code and the current code with an always-inline tag.
    
    No functional change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: andriy.shevchenko@linux.intel.com
    Link: https://lkml.kernel.org/r/20190527205521.12091-5-daniel.lezcano@linaro.org

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 70c3053bc1f6..21f9927ff5ad 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -354,6 +354,16 @@ static inline int irq_timing_decode(u64 value, u64 *timestamp)
 	return value & U16_MAX;
 }
 
+static __always_inline void irq_timings_push(u64 ts, int irq)
+{
+	struct irq_timings *timings = this_cpu_ptr(&irq_timings);
+
+	timings->values[timings->count & IRQ_TIMINGS_MASK] =
+		irq_timing_encode(ts, irq);
+
+	timings->count++;
+}
+
 /*
  * The function record_irq_time is only called in one place in the
  * interrupts handler. We want this function always inline so the code
@@ -367,15 +377,8 @@ static __always_inline void record_irq_time(struct irq_desc *desc)
 	if (!static_branch_likely(&irq_timing_enabled))
 		return;
 
-	if (desc->istate & IRQS_TIMINGS) {
-		struct irq_timings *timings = this_cpu_ptr(&irq_timings);
-
-		timings->values[timings->count & IRQ_TIMINGS_MASK] =
-			irq_timing_encode(local_clock(),
-					  irq_desc_get_irq(desc));
-
-		timings->count++;
-	}
+	if (desc->istate & IRQS_TIMINGS)
+		irq_timings_push(local_clock(), irq_desc_get_irq(desc));
 }
 #else
 static inline void irq_remove_timings(struct irq_desc *desc) {}

commit a324ca9cad4736252c33c1e28cffe1d87f262d03
Merge: 4e6b26d23dc1 28528fca4908
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 23 10:53:31 2019 +0100

    Merge tag 'irqchip-5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/core
    
    Pull irqchip updates from Marc Zyngier
    
    - Core pseudo-NMI handling code
    - Allow the default irq domain to be retrieved
    - A new interrupt controller for the Loongson LS1X platform
    - Affinity support for the SiFive PLIC
    - Better support for the iMX irqsteer driver
    - NUMA aware memory allocations for GICv3
    - A handful of other fixes (i8259, GICv3, PLIC)

commit 1136b0728969901a091f0471968b2b76ed14d9ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 8 14:48:03 2019 +0100

    genirq: Avoid summation loops for /proc/stat
    
    Waiman reported that on large systems with a large amount of interrupts the
    readout of /proc/stat takes a long time to sum up the interrupt
    statistics. In principle this is not a problem. but for unknown reasons
    some enterprise quality software reads /proc/stat with a high frequency.
    
    The reason for this is that interrupt statistics are accounted per cpu. So
    the /proc/stat logic has to sum up the interrupt stats for each interrupt.
    
    This can be largely avoided for interrupts which are not marked as
    'PER_CPU' interrupts by simply adding a per interrupt summation counter
    which is incremented along with the per interrupt per cpu counter.
    
    The PER_CPU interrupts need to avoid that and use only per cpu accounting
    because they share the interrupt number and the interrupt descriptor and
    concurrent updates would conflict or require unwanted synchronization.
    
    Reported-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Daniel Colascione <dancol@google.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Link: https://lkml.kernel.org/r/20190208135020.925487496@linutronix.de
    
    
    8<-------------
    
    v2: Undo the unintentional layout change of struct irq_desc.
    
     include/linux/irqdesc.h |    1 +
     kernel/irq/chip.c       |   12 ++++++++++--
     kernel/irq/internals.h  |    8 +++++++-
     kernel/irq/irqdesc.c    |    7 ++++++-
     4 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ca6afa267070..e74e7eea76cf 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -242,12 +242,18 @@ static inline void irq_state_set_masked(struct irq_desc *desc)
 
 #undef __irqd_to_state
 
-static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
+static inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 {
 	__this_cpu_inc(*desc->kstat_irqs);
 	__this_cpu_inc(kstat.irqs_sum);
 }
 
+static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
+{
+	__kstat_incr_irqs_this_cpu(desc);
+	desc->tot_count++;
+}
+
 static inline int irq_desc_get_node(struct irq_desc *desc)
 {
 	return irq_common_data_get_node(&desc->irq_common_data);

commit b525903c254dab2491410f0f23707691b7c2c317
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:53:58 2019 +0000

    genirq: Provide basic NMI management for interrupt lines
    
    Add functionality to allocate interrupt lines that will deliver IRQs
    as Non-Maskable Interrupts. These allocations are only successful if
    the irqchip provides the necessary support and allows NMI delivery for the
    interrupt line.
    
    Interrupt lines allocated for NMI delivery must be enabled/disabled through
    enable_nmi/disable_nmi_nosync to keep their state consistent.
    
    To treat a PERCPU IRQ as NMI, the interrupt must not be shared nor threaded,
    the irqchip directly managing the IRQ must be the root irqchip and the
    irqchip cannot be behind a slow bus.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ca6afa267070..2a77cdd27ca9 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -49,6 +49,7 @@ enum {
  * IRQS_WAITING			- irq is waiting
  * IRQS_PENDING			- irq is pending and replayed later
  * IRQS_SUSPENDED		- irq is suspended
+ * IRQS_NMI			- irq line is used to deliver NMIs
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -60,6 +61,7 @@ enum {
 	IRQS_PENDING		= 0x00000200,
 	IRQS_SUSPENDED		= 0x00000800,
 	IRQS_TIMINGS		= 0x00001000,
+	IRQS_NMI		= 0x00002000,
 };
 
 #include "debug.h"

commit 1beaeacdc88b537703d04d5536235d0bbb36db93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 30 19:36:32 2018 +0100

    genirq: Make legacy autoprobing work again
    
    Meelis reported the following warning on a quad P3 HP NetServer museum piece:
    
    WARNING: CPU: 3 PID: 258 at kernel/irq/chip.c:244 __irq_startup+0x80/0x100
    EIP: __irq_startup+0x80/0x100
    irq_startup+0x7e/0x170
    probe_irq_on+0x128/0x2b0
    parport_irq_probe.constprop.18+0x8d/0x1af [parport_pc]
    parport_pc_probe_port+0xf11/0x1260 [parport_pc]
    parport_pc_init+0x78a/0xf10 [parport_pc]
    parport_parse_param.constprop.16+0xf0/0xf0 [parport_pc]
    do_one_initcall+0x45/0x1e0
    
    This is caused by the rewrite of the irq activation/startup sequence which
    missed to convert a callsite in the irq legacy auto probing code.
    
    To fix this irq_activate_and_startup() needs to gain a return value so the
    pending logic can work proper.
    
    Fixes: c942cee46bba ("genirq: Separate activation and startup")
    Reported-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Meelis Roos <mroos@linux.ee>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/alpine.DEB.2.20.1801301935410.1797@nanos

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ab19371eab9b..ca6afa267070 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -76,7 +76,7 @@ extern void __enable_irq(struct irq_desc *desc);
 #define IRQ_START_COND	false
 
 extern int irq_activate(struct irq_desc *desc);
-extern void irq_activate_and_startup(struct irq_desc *desc, bool resend);
+extern int irq_activate_and_startup(struct irq_desc *desc, bool resend);
 extern int irq_startup(struct irq_desc *desc, bool resend, bool force);
 
 extern void irq_shutdown(struct irq_desc *desc);

commit 702cb0a02813299d6911b775c637906ae21b737d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 29 16:59:06 2017 +0100

    genirq/irqdomain: Rename early argument of irq_domain_activate_irq()
    
    The 'early' argument of irq_domain_activate_irq() is actually used to
    denote reservation mode. To avoid confusion, rename it before abuse
    happens.
    
    No functional change.
    
    Fixes: 72491643469a ("genirq/irqdomain: Update irq_domain_ops.activate() signature")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alexandru Chirvasitu <achirvasub@gmail.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Mikael Pettersson <mikpelinux@gmail.com>
    Cc: Josh Poulson <jopoulso@microsoft.com>
    Cc: Mihai Costache <v-micos@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-pci@vger.kernel.org
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Dexuan Cui <decui@microsoft.com>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Saeed Mahameed <saeedm@mellanox.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: devel@linuxdriverproject.org
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Sakari Ailus <sakari.ailus@intel.com>,
    Cc: linux-media@vger.kernel.org

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 07d08ca701ec..ab19371eab9b 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -440,7 +440,7 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)
-static inline int irq_domain_activate_irq(struct irq_data *data, bool early)
+static inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)
 {
 	irqd_set_activated(data);
 	return 0;

commit 670310dfbae0eefe7318ff6a61e29e67a7a7bbce
Merge: 43ff2f4db9d0 ffc661c99f62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:33:11 2017 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq core updates from Thomas Gleixner:
     "A rather large update for the interrupt core code and the irq chip drivers:
    
       - Add a new bitmap matrix allocator and supporting changes, which is
         used to replace the x86 vector allocator which comes with separate
         pull request. This allows to replace the convoluted nested loop
         allocation function in x86 with a facility which supports the
         recently added property of managed interrupts proper and allows to
         switch to a best effort vector reservation scheme, which addresses
         problems with vector exhaustion.
    
       - A large update to the ARM GIC-V3-ITS driver adding support for
         range selectors.
    
       - New interrupt controllers:
           - Meson and Meson8 GPIO
           - BCM7271 L2
           - Socionext EXIU
    
         If you expected that this will stop at some point, I have to
         disappoint you. There are new ones posted already. Sigh!
    
       - STM32 interrupt controller support for new platforms.
    
       - A pile of fixes, cleanups and updates to the MIPS GIC driver
    
       - The usual small fixes, cleanups and updates all over the place.
         Most visible one is to move the irq chip drivers Kconfig switches
         into a separate Kconfig menu"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (70 commits)
      genirq: Fix type of shifting literal 1 in __setup_irq()
      irqdomain: Drop pointless NULL check in virq_debug_show_one
      genirq/proc: Return proper error code when irq_set_affinity() fails
      irq/work: Use llist_for_each_entry_safe
      irqchip: mips-gic: Print warning if inherited GIC base is used
      irqchip/mips-gic: Add pr_fmt and reword pr_* messages
      irqchip/stm32: Move the wakeup on interrupt mask
      irqchip/stm32: Fix initial values
      irqchip/stm32: Add stm32h7 support
      dt-bindings/interrupt-controllers: Add compatible string for stm32h7
      irqchip/stm32: Add multi-bank management
      irqchip/stm32: Select GENERIC_IRQ_CHIP
      irqchip/exiu: Add support for Socionext Synquacer EXIU controller
      dt-bindings: Add description of Socionext EXIU interrupt controller
      irqchip/gic-v3-its: Fix VPE activate callback return value
      irqchip: mips-gic: Make IPI bitmaps static
      irqchip: mips-gic: Share register writes in gic_set_type()
      irqchip: mips-gic: Remove gic_vpes variable
      irqchip: mips-gic: Use num_possible_cpus() to reserve IPIs
      irqchip: mips-gic: Configure EIC when CPUs come online
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a4aa39009f0d..44ed5f8c8759 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * IRQ subsystem internal functions and variables:
  *

commit 42e1cc2dc5b698181ab1ffb7972bd880230c506e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:12 2017 +0200

    genirq/irqdomain: Propagate early activation
    
    Propagate the early activation mode to the irqdomain activate()
    callbacks. This is required for the upcoming reservation, late vector
    assignment scheme, so that the early activation call can act accordingly.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.028353660@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e84d0e3899f6..a0327136e469 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -439,7 +439,7 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)
-static inline int irq_domain_activate_irq(struct irq_data *data)
+static inline int irq_domain_activate_irq(struct irq_data *data, bool early)
 {
 	irqd_set_activated(data);
 	return 0;

commit bb9b428a5c832d7abb494fbabac37c515c01c6c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:11 2017 +0200

    genirq/irqdomain: Allow irq_domain_activate_irq() to fail
    
    Allow irq_domain_activate_irq() to fail. This is required to support a
    reservation and late vector assignment scheme.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.933882227@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8bd131e4c944..e84d0e3899f6 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -439,9 +439,10 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)
-static inline void irq_domain_activate_irq(struct irq_data *data)
+static inline int irq_domain_activate_irq(struct irq_data *data)
 {
 	irqd_set_activated(data);
+	return 0;
 }
 static inline void irq_domain_deactivate_irq(struct irq_data *data)
 {

commit c942cee46bba761ce97ee6d4fc71892e064e8628
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:09 2017 +0200

    genirq: Separate activation and startup
    
    Activation of an interrupt and startup are currently a combo
    functionlity. That works so far, but upcoming changes require a strict
    separation because the activation can fail in future.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.754334077@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 72b8da2a7c39..8bd131e4c944 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -74,6 +74,8 @@ extern void __enable_irq(struct irq_desc *desc);
 #define IRQ_START_FORCE	true
 #define IRQ_START_COND	false
 
+extern int irq_activate(struct irq_desc *desc);
+extern void irq_activate_and_startup(struct irq_desc *desc, bool resend);
 extern int irq_startup(struct irq_desc *desc, bool resend, bool force);
 
 extern void irq_shutdown(struct irq_desc *desc);

commit 457f6d35072f395508255ef09fd08f824382cf85
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:07 2017 +0200

    genirq: Make state consistent for !IRQ_DOMAIN_HIERARCHY
    
    In the !IRQ_DOMAIN_HIERARCHY cas the activation stubs are not
    setting/clearing the activation status bits. This is not a problem at the
    moment, but upcoming changes require a correct status.
    
    Add the set/clear incovations to the stub functions and move them to the
    core internal header to avoid duplication and visibility outside the core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.591985591@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index cfaec2669093..72b8da2a7c39 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -436,6 +436,17 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 }
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
+#if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)
+static inline void irq_domain_activate_irq(struct irq_data *data)
+{
+	irqd_set_activated(data);
+}
+static inline void irq_domain_deactivate_irq(struct irq_data *data)
+{
+	irqd_clr_activated(data);
+}
+#endif
+
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS
 #include <linux/debugfs.h>
 

commit 07557ccb8c83f315e409ddee181e9ffbf87c6ad1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:05 2017 +0200

    genirq/msi: Capture device name for debugfs
    
    For debugging the allocation of unused or potentially leaked interrupt
    descriptor it's helpful to have some information about the site which
    allocated them. In case of MSI this is simple because the caller hands the
    device struct pointer into the domain allocation function.
    
    Duplicate the device name and show it in the debugfs entry of the interrupt
    descriptor.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.433038426@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a4aa39009f0d..cfaec2669093 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -443,7 +443,9 @@ void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);
 static inline void irq_remove_debugfs_entry(struct irq_desc *desc)
 {
 	debugfs_remove(desc->debugfs_file);
+	kfree(desc->dev_name);
 }
+void irq_debugfs_copy_devname(int irq, struct device *dev);
 # ifdef CONFIG_IRQ_DOMAIN
 void irq_domain_debugfs_init(struct dentry *root);
 # else
@@ -458,4 +460,7 @@ static inline void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *d)
 static inline void irq_remove_debugfs_entry(struct irq_desc *d)
 {
 }
+static inline void irq_debugfs_copy_devname(int irq, struct device *dev)
+{
+}
 #endif /* CONFIG_GENERIC_IRQ_DEBUGFS */

commit 163616cf2f6ab7a8e37452ec00320039ab65bd45
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 9 15:32:21 2017 +0900

    genirq: Fix for_each_action_of_desc() macro
    
    struct irq_desc does not have a member named "act".  The correct
    name is "action".
    
    Currently, all users of this macro use an iterator named "action".
    If a different name is used, it will cause a build error.
    
    Fixes: f944b5a7aff0 ("genirq: Use a common macro to go through the actions list")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1502260341-28184-1-git-send-email-yamada.masahiro@socionext.com

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a2c48058354c..a4aa39009f0d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -151,7 +151,7 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 #define IRQ_GET_DESC_CHECK_PERCPU	(_IRQ_DESC_CHECK | _IRQ_DESC_PERCPU)
 
 #define for_each_action_of_desc(desc, act)			\
-	for (act = desc->act; act; act = act->next)
+	for (act = desc->action; act; act = act->next)
 
 struct irq_desc *
 __irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,

commit a696712c3dd54eb58d2c5a807b4aaa27782d80d6
Author: Juergen Gross <jgross@suse.com>
Date:   Mon Jul 17 19:47:02 2017 +0200

    genirq/PM: Properly pretend disabled state when force resuming interrupts
    
    Interrupts with the IRQF_FORCE_RESUME flag set have also the
    IRQF_NO_SUSPEND flag set. They are not disabled in the suspend path, but
    must be forcefully resumed. That's used by XEN to keep IPIs enabled beyond
    the suspension of device irqs. Force resume works by pretending that the
    interrupt was disabled and then calling __irq_enable().
    
    Incrementing the disabled depth counter was enough to do that, but with the
    recent changes which use state flags to avoid unnecessary hardware access,
    this is not longer sufficient. If the state flags are not set, then the
    hardware callbacks are not invoked and the interrupt line stays disabled in
    "hardware".
    
    Set the disabled and masked state when pretending that an interrupt got
    disabled by suspend.
    
    Fixes: bf22ff45bed6 ("genirq: Avoid unnecessary low level irq function calls")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: xen-devel@lists.xenproject.org
    Cc: boris.ostrovsky@oracle.com
    Link: http://lkml.kernel.org/r/20170717174703.4603-2-jgross@suse.com

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index dbfba9933ed2..a2c48058354c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -227,6 +227,16 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 	return __irqd_to_state(d) & mask;
 }
 
+static inline void irq_state_set_disabled(struct irq_desc *desc)
+{
+	irqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);
+}
+
+static inline void irq_state_set_masked(struct irq_desc *desc)
+{
+	irqd_set(&desc->irq_data, IRQD_IRQ_MASKED);
+}
+
 #undef __irqd_to_state
 
 static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)

commit e5682b4eecb2b73282853d0ef314d3164b986997
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Jul 4 11:25:15 2017 +0200

    genirq/debugfs: Fix build for !CONFIG_IRQ_DOMAIN
    
    Fix this build error:
    
    kernel/irq/internals.h:440:20: error: inlining failed in call to always_inline
      'irq_domain_debugfs_init': function body not available
    kernel/irq/debugfs.c:202:2: note: called from here
      irq_domain_debugfs_init(root_dir);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.20.1707041124000.1712@schleppi

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 9da14d125df4..dbfba9933ed2 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -437,7 +437,9 @@ static inline void irq_remove_debugfs_entry(struct irq_desc *desc)
 # ifdef CONFIG_IRQ_DOMAIN
 void irq_domain_debugfs_init(struct dentry *root);
 # else
-static inline void irq_domain_debugfs_init(struct dentry *root);
+static inline void irq_domain_debugfs_init(struct dentry *root)
+{
+}
 # endif
 #else /* CONFIG_GENERIC_IRQ_DEBUGFS */
 static inline void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *d)

commit e1c921495534002d727b15a76a2f8c20b6b108b5
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Jun 23 16:11:08 2017 +0200

    genirq/timings: Add infrastructure for estimating the next interrupt arrival time
    
    An interrupt behaves with a burst of activity with periodic interval of time
    followed by one or two peaks of longer interval.
    
    As the time intervals are periodic, statistically speaking they follow a normal
    distribution and each interrupts can be tracked individually.
    
    Add a mechanism to compute the statistics on all interrupts, except the
    timers which are deterministic from a prediction point of view, as their
    expiry time is known.
    
    The goal is to extract the periodicity for each interrupt, with the last
    timestamp and sum them, so the next event can be predicted to a certain
    extent.
    
    Taking the earliest prediction gives the expected wakeup on the system
    (assuming a timer won't expire before).
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: "Rafael J . Wysocki" <rafael@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1498227072-5980-2-git-send-email-daniel.lezcano@linaro.org

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b95b74920433..9da14d125df4 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -275,13 +275,21 @@ struct irq_timings {
 
 DECLARE_PER_CPU(struct irq_timings, irq_timings);
 
+extern void irq_timings_free(int irq);
+extern int irq_timings_alloc(int irq);
+
 static inline void irq_remove_timings(struct irq_desc *desc)
 {
 	desc->istate &= ~IRQS_TIMINGS;
+
+	irq_timings_free(irq_desc_get_irq(desc));
 }
 
 static inline void irq_setup_timings(struct irq_desc *desc, struct irqaction *act)
 {
+	int irq = irq_desc_get_irq(desc);
+	int ret;
+
 	/*
 	 * We don't need the measurement because the idle code already
 	 * knows the next expiry event.
@@ -289,6 +297,17 @@ static inline void irq_setup_timings(struct irq_desc *desc, struct irqaction *ac
 	if (act->flags & __IRQF_TIMER)
 		return;
 
+	/*
+	 * In case the timing allocation fails, we just want to warn,
+	 * not fail, so letting the system boot anyway.
+	 */
+	ret = irq_timings_alloc(irq);
+	if (ret) {
+		pr_warn("Failed to allocate irq timing stats for irq%d (%d)",
+			irq, ret);
+		return;
+	}
+
 	desc->istate |= IRQS_TIMINGS;
 }
 

commit b2d3d61adb7b73cfe5f82404f7a130a76fc64232
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Jun 23 16:11:07 2017 +0200

    genirq/timings: Add infrastructure to track the interrupt timings
    
    The interrupt framework gives a lot of information about each interrupt. It
    does not keep track of when those interrupts occur though, which is a
    prerequisite for estimating the next interrupt arrival for power management
    purposes.
    
    Add a mechanism to record the timestamp for each interrupt occurrences in a
    per-CPU circular buffer to help with the prediction of the next occurrence
    using a statistical model.
    
    Each CPU can store up to IRQ_TIMINGS_SIZE events <irq, timestamp>, the
    current value of IRQ_TIMINGS_SIZE is 32.
    
    Each event is encoded into a single u64, where the high 48 bits are used
    for the timestamp and the low 16 bits are for the irq number.
    
    A static key is introduced so when the irq prediction is switched off at
    runtime, the overhead is near to zero.
    
    It results in most of the code in internals.h for inline reasons and a very
    few in the new file timings.c. The latter will contain more in the next patch
    which will provide the statistical model for the next event prediction.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: "Rafael J . Wysocki" <rafael@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1498227072-5980-1-git-send-email-daniel.lezcano@linaro.org

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a573e0771baf..b95b74920433 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -8,6 +8,7 @@
 #include <linux/irqdesc.h>
 #include <linux/kernel_stat.h>
 #include <linux/pm_runtime.h>
+#include <linux/sched/clock.h>
 
 #ifdef CONFIG_SPARSE_IRQ
 # define IRQ_BITMAP_BITS	(NR_IRQS + 8196)
@@ -57,6 +58,7 @@ enum {
 	IRQS_WAITING		= 0x00000080,
 	IRQS_PENDING		= 0x00000200,
 	IRQS_SUSPENDED		= 0x00000800,
+	IRQS_TIMINGS		= 0x00001000,
 };
 
 #include "debug.h"
@@ -255,6 +257,94 @@ static inline void
 irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }
 #endif
 
+#ifdef CONFIG_IRQ_TIMINGS
+
+#define IRQ_TIMINGS_SHIFT	5
+#define IRQ_TIMINGS_SIZE	(1 << IRQ_TIMINGS_SHIFT)
+#define IRQ_TIMINGS_MASK	(IRQ_TIMINGS_SIZE - 1)
+
+/**
+ * struct irq_timings - irq timings storing structure
+ * @values: a circular buffer of u64 encoded <timestamp,irq> values
+ * @count: the number of elements in the array
+ */
+struct irq_timings {
+	u64	values[IRQ_TIMINGS_SIZE];
+	int	count;
+};
+
+DECLARE_PER_CPU(struct irq_timings, irq_timings);
+
+static inline void irq_remove_timings(struct irq_desc *desc)
+{
+	desc->istate &= ~IRQS_TIMINGS;
+}
+
+static inline void irq_setup_timings(struct irq_desc *desc, struct irqaction *act)
+{
+	/*
+	 * We don't need the measurement because the idle code already
+	 * knows the next expiry event.
+	 */
+	if (act->flags & __IRQF_TIMER)
+		return;
+
+	desc->istate |= IRQS_TIMINGS;
+}
+
+extern void irq_timings_enable(void);
+extern void irq_timings_disable(void);
+
+DECLARE_STATIC_KEY_FALSE(irq_timing_enabled);
+
+/*
+ * The interrupt number and the timestamp are encoded into a single
+ * u64 variable to optimize the size.
+ * 48 bit time stamp and 16 bit IRQ number is way sufficient.
+ *  Who cares an IRQ after 78 hours of idle time?
+ */
+static inline u64 irq_timing_encode(u64 timestamp, int irq)
+{
+	return (timestamp << 16) | irq;
+}
+
+static inline int irq_timing_decode(u64 value, u64 *timestamp)
+{
+	*timestamp = value >> 16;
+	return value & U16_MAX;
+}
+
+/*
+ * The function record_irq_time is only called in one place in the
+ * interrupts handler. We want this function always inline so the code
+ * inside is embedded in the function and the static key branching
+ * code can act at the higher level. Without the explicit
+ * __always_inline we can end up with a function call and a small
+ * overhead in the hotpath for nothing.
+ */
+static __always_inline void record_irq_time(struct irq_desc *desc)
+{
+	if (!static_branch_likely(&irq_timing_enabled))
+		return;
+
+	if (desc->istate & IRQS_TIMINGS) {
+		struct irq_timings *timings = this_cpu_ptr(&irq_timings);
+
+		timings->values[timings->count & IRQ_TIMINGS_MASK] =
+			irq_timing_encode(local_clock(),
+					  irq_desc_get_irq(desc));
+
+		timings->count++;
+	}
+}
+#else
+static inline void irq_remove_timings(struct irq_desc *desc) {}
+static inline void irq_setup_timings(struct irq_desc *desc,
+				     struct irqaction *act) {};
+static inline void record_irq_time(struct irq_desc *desc) {}
+#endif /* CONFIG_IRQ_TIMINGS */
+
+
 #ifdef CONFIG_GENERIC_IRQ_CHIP
 void irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,
 			   int num_ct, unsigned int irq_base,

commit c2ce34c0a0e5187195ecade872be950d2611ba68
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 24 11:05:59 2017 +0200

    genirq/debugfs: Remove pointless NULL pointer check
    
    debugfs_remove() has it's own NULL pointer check. Remove the conditional
    and make irq_remove_debugfs_entry() an inline helper
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 5fd105e252c3..a573e0771baf 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -318,8 +318,13 @@ static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+#include <linux/debugfs.h>
+
 void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);
-void irq_remove_debugfs_entry(struct irq_desc *desc);
+static inline void irq_remove_debugfs_entry(struct irq_desc *desc)
+{
+	debugfs_remove(desc->debugfs_file);
+}
 # ifdef CONFIG_IRQ_DOMAIN
 void irq_domain_debugfs_init(struct dentry *root);
 # else

commit 4cde9c6b826834b861a2b58653ab33150f562064
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:49 2017 +0200

    genirq: Add force argument to irq_startup()
    
    In order to handle managed interrupts gracefully on irq_startup() so they
    won't lose their assigned affinity, it's necessary to allow startups which
    keep the interrupts in managed shutdown state, if none of the assigend CPUs
    is online. This allows drivers to request interrupts w/o the CPUs being
    online, which avoid online/offline churn in drivers.
    
    Add a force argument which can override that decision and let only
    request_irq() and enable_irq() allow the managed shutdown
    handling. enable_irq() is required, because the interrupt might be
    requested with IRQF_NOAUTOEN and enable_irq() invokes irq_startup() which
    would then wreckage the assignment again. All other callers force startup
    and potentially break the assigned affinity.
    
    No functional change as this only adds the function argument.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235447.112094565@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ca4666b4cd39..5fd105e252c3 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -66,7 +66,14 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);
 extern void __disable_irq(struct irq_desc *desc);
 extern void __enable_irq(struct irq_desc *desc);
 
-extern int irq_startup(struct irq_desc *desc, bool resend);
+#define IRQ_RESEND	true
+#define IRQ_NORESEND	false
+
+#define IRQ_START_FORCE	true
+#define IRQ_START_COND	false
+
+extern int irq_startup(struct irq_desc *desc, bool resend, bool force);
+
 extern void irq_shutdown(struct irq_desc *desc);
 extern void irq_enable(struct irq_desc *desc);
 extern void irq_disable(struct irq_desc *desc);

commit 54fdf6a0875ca380647ac1cc9b5b8f2dbbbfa131
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:47 2017 +0200

    genirq: Introduce IRQD_MANAGED_SHUTDOWN
    
    Affinity managed interrupts should keep their assigned affinity accross CPU
    hotplug. To avoid magic hackery in device drivers, the core code shall
    manage them transparently. This will set these interrupts into a managed
    shutdown state when the last CPU of the assigned affinity mask goes
    offline. The interrupt will be restarted when one of the CPUs in the
    assigned affinity mask comes back online.
    
    Introduce the necessary state flag and the accessor functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.954523476@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 040806f1124c..ca4666b4cd39 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -193,6 +193,16 @@ static inline void irqd_clr_move_pending(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_SETAFFINITY_PENDING;
 }
 
+static inline void irqd_set_managed_shutdown(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_MANAGED_SHUTDOWN;
+}
+
+static inline void irqd_clr_managed_shutdown(struct irq_data *d)
+{
+	__irqd_to_state(d) &= ~IRQD_MANAGED_SHUTDOWN;
+}
+
 static inline void irqd_clear(struct irq_data *d, unsigned int mask)
 {
 	__irqd_to_state(d) &= ~mask;

commit 36d84fb45140f151fa4e145381dbce5e5ffed24d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:34 2017 +0200

    genirq: Move irq_fixup_move_pending() to core
    
    Now that x86 uses the generic code, the function declaration and inline
    stub can move to the core internal header.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235445.928156166@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fd4fa8382b8f..040806f1124c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -272,6 +272,7 @@ static inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)
 {
 	return desc->pending_mask;
 }
+bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);
 #else /* CONFIG_GENERIC_PENDING_IRQ */
 static inline bool irq_can_move_pcntxt(struct irq_data *data)
 {
@@ -293,6 +294,10 @@ static inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)
 {
 	return NULL;
 }
+static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
+{
+	return false;
+}
 #endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS

commit f0383c24b4855f6a4b5a358c7b2d2c16e0437e9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:29 2017 +0200

    genirq/cpuhotplug: Add support for cleaning up move in progress
    
    In order to move x86 to the generic hotplug migration code, add support for
    cleaning up move in progress bits.
    
    On architectures which have this x86 specific (mis)feature not enabled,
    this is optimized out by the compiler.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235445.525817311@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 20b197f0a7b5..fd4fa8382b8f 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -268,6 +268,10 @@ irq_get_pending(struct cpumask *mask, struct irq_desc *desc)
 {
 	cpumask_copy(mask, desc->pending_mask);
 }
+static inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)
+{
+	return desc->pending_mask;
+}
 #else /* CONFIG_GENERIC_PENDING_IRQ */
 static inline bool irq_can_move_pcntxt(struct irq_data *data)
 {
@@ -285,7 +289,11 @@ static inline void
 irq_get_pending(struct cpumask *mask, struct irq_desc *desc)
 {
 }
-#endif /* CONFIG_GENERIC_PENDING_IRQ */
+static inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)
+{
+	return NULL;
+}
+#endif /* !CONFIG_GENERIC_PENDING_IRQ */
 
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS
 void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);

commit 137221df69c6f8a7002f82dc3d95052d34f5667e
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 20 01:37:24 2017 +0200

    genirq: Move pending helpers to internal.h
    
    So that the affinity code can reuse them.
    
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170619235445.109426284@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 2d7927d9fb57..20b197f0a7b5 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -249,6 +249,44 @@ irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,
 		      void __iomem *reg_base, irq_flow_handler_t handler) { }
 #endif /* CONFIG_GENERIC_IRQ_CHIP */
 
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+static inline bool irq_can_move_pcntxt(struct irq_data *data)
+{
+	return irqd_can_move_in_process_context(data);
+}
+static inline bool irq_move_pending(struct irq_data *data)
+{
+	return irqd_is_setaffinity_pending(data);
+}
+static inline void
+irq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)
+{
+	cpumask_copy(desc->pending_mask, mask);
+}
+static inline void
+irq_get_pending(struct cpumask *mask, struct irq_desc *desc)
+{
+	cpumask_copy(mask, desc->pending_mask);
+}
+#else /* CONFIG_GENERIC_PENDING_IRQ */
+static inline bool irq_can_move_pcntxt(struct irq_data *data)
+{
+	return true;
+}
+static inline bool irq_move_pending(struct irq_data *data)
+{
+	return false;
+}
+static inline void
+irq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)
+{
+}
+static inline void
+irq_get_pending(struct cpumask *mask, struct irq_desc *desc)
+{
+}
+#endif /* CONFIG_GENERIC_PENDING_IRQ */
+
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS
 void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);
 void irq_remove_debugfs_entry(struct irq_desc *desc);

commit 43564bd97d0e6182bbd43b51b33254c728832551
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:22 2017 +0200

    genirq: Rename setup_affinity() to irq_setup_affinity()
    
    Rename it with a proper irq_ prefix and make it available for other files
    in the core code. Preparatory patch for moving the irq affinity setup
    around.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.928501004@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 33ca83816b8c..2d7927d9fb57 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -116,6 +116,12 @@ extern void irq_set_thread_affinity(struct irq_desc *desc);
 extern int irq_do_set_affinity(struct irq_data *data,
 			       const struct cpumask *dest, bool force);
 
+#ifdef CONFIG_SMP
+extern int irq_setup_affinity(struct irq_desc *desc);
+#else
+static inline int irq_setup_affinity(struct irq_desc *desc) { return 0; }
+#endif
+
 /* Inline functions for support of irq chips on slow busses */
 static inline void chip_bus_lock(struct irq_desc *desc)
 {

commit cba4235e6031e9318d68186f6d765c531cbea4e1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:21 2017 +0200

    genirq: Remove mask argument from setup_affinity()
    
    No point to have this alloc/free dance of cpumasks. Provide a static mask
    for setup_affinity() and protect it proper.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.851571573@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 094db5bfb83f..33ca83816b8c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -109,7 +109,7 @@ static inline void unregister_handler_proc(unsigned int irq,
 
 extern bool irq_can_set_affinity_usr(unsigned int irq);
 
-extern int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask);
+extern int irq_select_affinity_usr(unsigned int irq);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 

commit 087cdfb662ae50e3826e7cd2e54b6519d07b60f0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:17 2017 +0200

    genirq/debugfs: Add proper debugfs interface
    
    Debugging (hierarchical) interupt domains is tedious as there is no
    information about the hierarchy and no information about states of
    interrupts in the various domain levels.
    
    Add a debugfs directory 'irq' and subdirectories 'domains' and 'irqs'.
    
    The domains directory contains the domain files. The content is information
    about the domain. If the domain is part of a hierarchy then the parent
    domains are printed as well.
    
    # ls /sys/kernel/debug/irq/domains/
    default     INTEL-IR-2      INTEL-IR-MSI-2  IO-APIC-IR-2  PCI-MSI
    DMAR-MSI    INTEL-IR-3      INTEL-IR-MSI-3  IO-APIC-IR-3  unknown-1
    INTEL-IR-0  INTEL-IR-MSI-0  IO-APIC-IR-0    IO-APIC-IR-4  VECTOR
    INTEL-IR-1  INTEL-IR-MSI-1  IO-APIC-IR-1    PCI-HT
    
    # cat /sys/kernel/debug/irq/domains/VECTOR
    name:   VECTOR
     size:   0
     mapped: 216
     flags:  0x00000041
    
    # cat /sys/kernel/debug/irq/domains/IO-APIC-IR-0
    name:   IO-APIC-IR-0
     size:   24
     mapped: 19
     flags:  0x00000041
     parent: INTEL-IR-3
        name:   INTEL-IR-3
         size:   65536
         mapped: 167
         flags:  0x00000041
         parent: VECTOR
            name:   VECTOR
             size:   0
             mapped: 216
             flags:  0x00000041
    
    Unfortunately there is no per cpu information about the VECTOR domain (yet).
    
    The irqs directory contains detailed information about mapped interrupts.
    
    # cat /sys/kernel/debug/irq/irqs/3
    handler:  handle_edge_irq
    status:   0x00004000
    istate:   0x00000000
    ddepth:   1
    wdepth:   0
    dstate:   0x01018000
                IRQD_IRQ_DISABLED
                IRQD_SINGLE_TARGET
                IRQD_MOVE_PCNTXT
    node:     0
    affinity: 0-143
    effectiv: 0
    pending:
    domain:  IO-APIC-IR-0
     hwirq:   0x3
     chip:    IR-IO-APIC
      flags:   0x10
                 IRQCHIP_SKIP_SET_WAKE
     parent:
        domain:  INTEL-IR-3
         hwirq:   0x20000
         chip:    INTEL-IR
          flags:   0x0
         parent:
            domain:  VECTOR
             hwirq:   0x3
             chip:    APIC
              flags:   0x0
    
    This was developed to simplify the debugging of the managed affinity
    changes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.537566163@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 921a2419720c..094db5bfb83f 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -169,6 +169,11 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
 
+static inline unsigned int irqd_get(struct irq_data *d)
+{
+	return __irqd_to_state(d);
+}
+
 /*
  * Manipulation functions for irq_data.state
  */
@@ -237,3 +242,20 @@ irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,
 		      int num_ct, unsigned int irq_base,
 		      void __iomem *reg_base, irq_flow_handler_t handler) { }
 #endif /* CONFIG_GENERIC_IRQ_CHIP */
+
+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);
+void irq_remove_debugfs_entry(struct irq_desc *desc);
+# ifdef CONFIG_IRQ_DOMAIN
+void irq_domain_debugfs_init(struct dentry *root);
+# else
+static inline void irq_domain_debugfs_init(struct dentry *root);
+# endif
+#else /* CONFIG_GENERIC_IRQ_DEBUGFS */
+static inline void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *d)
+{
+}
+static inline void irq_remove_debugfs_entry(struct irq_desc *d)
+{
+}
+#endif /* CONFIG_GENERIC_IRQ_DEBUGFS */

commit f160203986a6ad23ab8077c4a25b260fe55d6e26
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:06:58 2017 +0200

    irq/generic-chip: Export irq_init_generic_chip() locally
    
    This function will be used in the devres variant of
    irq_alloc_generic_chip().
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-4-git-send-email-brgl@bgdev.pl

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index bc226e783bd2..921a2419720c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -226,3 +226,14 @@ irq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }
 static inline void
 irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }
 #endif
+
+#ifdef CONFIG_GENERIC_IRQ_CHIP
+void irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,
+			   int num_ct, unsigned int irq_base,
+			   void __iomem *reg_base, irq_flow_handler_t handler);
+#else
+static inline void
+irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,
+		      int num_ct, unsigned int irq_base,
+		      void __iomem *reg_base, irq_flow_handler_t handler) { }
+#endif /* CONFIG_GENERIC_IRQ_CHIP */

commit 8658be133baa92c06b6d832a436d437deb2e2a22
Merge: 4030103b9b2e 5e385a6ef31f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 12:26:05 2016 +0200

    Merge branch 'irq/for-block' into irq/core
    
    Pull the irq affinity managing code which is in a seperate branch for block
    developers to pull.

commit 9c2555835bb3d34dfac52a0be943dcc4bedd650f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 17:39:23 2016 +0900

    genirq: Introduce IRQD_AFFINITY_MANAGED flag
    
    Interupts marked with this flag are excluded from user space interrupt
    affinity changes. Contrary to the IRQ_NO_BALANCING flag, the kernel internal
    affinity mechanism is not blocked.
    
    This flag will be used for multi-queue device interrupts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-nvme@lists.infradead.org
    Cc: axboe@fb.com
    Cc: agordeev@redhat.com
    Link: http://lkml.kernel.org/r/1467621574-8277-3-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 09be2c903c6d..b15aa3b617a2 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -105,6 +105,8 @@ static inline void unregister_handler_proc(unsigned int irq,
 					   struct irqaction *action) { }
 #endif
 
+extern bool irq_can_set_affinity_usr(unsigned int irq);
+
 extern int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);

commit edd14cfebc4404698544d407ecf8eda6e19aa19e
Author: Keith Busch <keith.busch@intel.com>
Date:   Fri Jun 17 16:00:20 2016 -0600

    genirq: Add untracked irq handler
    
    This adds a software irq handler for controllers that multiplex
    interrupts from multiple devices, but don't know which device generated
    the interrupt. For these devices, the irq handler that demuxes must
    check every action for every software irq using the same h/w irq in order
    to find out which device generated the interrupt. This will inevitably
    trigger spurious interrupt detection if we are noting the irq.
    
    The new irq handler does not track the handling for spurious interrupt
    detection. An irq that uses this also won't get stats tracked since it
    didn't generate the interrupt, nor added to randomness since they are
    not random.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: linux-pci@vger.kernel.org
    Cc: Jon Derrick <jonathan.derrick@intel.com>
    Link: http://lkml.kernel.org/r/1466200821-29159-1-git-send-email-keith.busch@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index d5edcdc9382a..0c6f35ba9cc0 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -84,6 +84,7 @@ extern void irq_mark_irq(unsigned int irq);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
+irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags);
 irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 

commit be45beb2df6909d42a6b3b0052601b3eef878fc0
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Jun 7 16:12:29 2016 +0100

    genirq: Add runtime power management support for IRQ chips
    
    Some IRQ chips may be located in a power domain outside of the CPU
    subsystem and hence will require device specific runtime power
    management. In order to support such IRQ chips, add a pointer for a
    device structure to the irq_chip structure, and if this pointer is
    populated by the IRQ chip driver and CONFIG_PM is selected in the kernel
    configuration, then the pm_runtime_get/put APIs for this chip will be
    called when an IRQ is requested/freed, respectively.
    
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 09be2c903c6d..d5edcdc9382a 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -7,6 +7,7 @@
  */
 #include <linux/irqdesc.h>
 #include <linux/kernel_stat.h>
+#include <linux/pm_runtime.h>
 
 #ifdef CONFIG_SPARSE_IRQ
 # define IRQ_BITMAP_BITS	(NR_IRQS + 8196)

commit df2e37c814d51692803245fcbecca360d4882e96
Merge: 8a284c062ec9 8e7fe2660d4a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 12:48:48 2016 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The 4.6 pile of irq updates contains:
    
       - Support for IPI irqdomains to support proper integration of IPIs to
         and from coprocessors.  The first user of this new facility is
         MIPS.  The relevant MIPS patches come with the core to avoid merge
         ordering issues and have been acked by Ralf.
    
       - A new command line option to set the default interrupt affinity
         mask at boot time.
    
       - Support for some more new ARM and MIPS interrupt controllers:
         tango, alpine-msix and bcm6345-l1
    
       - Two small cleanups for x86/apic which we merged into irq/core to
         avoid yet another branch in x86 with two tiny commits.
    
       - The usual set of updates, cleanups in drivers/irqchip.  Mostly in
         the area of ARM-GIC, arada-37-xp and atmel chips.  Nothing
         outstanding here"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (56 commits)
      irqchip/irq-alpine-msi: Release the correct domain on error
      irqchip/mxs: Fix error check of of_io_request_and_map()
      irqchip/sunxi-nmi: Fix error check of of_io_request_and_map()
      genirq: Export IRQ functions for module use
      irqchip/gic/realview: Support more RealView DCC variants
      Documentation/bindings: Document the Alpine MSIX driver
      irqchip: Add the Alpine MSIX interrupt controller
      irqchip/gic-v3: Always return IRQ_SET_MASK_OK_DONE in gic_set_affinity
      irqchip/gic-v3-its: Mark its_init() and its children as __init
      irqchip/gic-v3: Remove gic_root_node variable from the ITS code
      irqchip/gic-v3: ACPI: Add redistributor support via GICC structures
      irqchip/gic-v3: Add ACPI support for GICv3/4 initialization
      irqchip/gic-v3: Refactor gic_of_init() for GICv3 driver
      x86/apic: Deinline _flat_send_IPI_mask, save ~150 bytes
      x86/apic: Deinline __default_send_IPI_*, save ~200 bytes
      dt-bindings: interrupt-controller: Add SoC-specific compatible string to Marvell ODMI
      irqchip/mips-gic: Add new DT property to reserve IPIs
      MIPS: Delete smp-gic.c
      MIPS: Make smp CMP, CPS and MT use the new generic IPI functions
      MIPS: Add generic SMP IPI support
      ...

commit b354286effa52da6cb1b1f16604d41ff81b8c445
Author: Boqun Feng <boqun.feng@gmail.com>
Date:   Tue Dec 29 12:18:48 2015 +0800

    irq: Privatize irq_common_data::state_use_accessors
    
    irq_common_data::state_use_accessors is not designed for public use.
    Therefore make it private so that people who write code accessing it
    directly will get blamed by sparse. Also #undef the macro
    __irqd_to_state after used in header files, so that the macro can't be
    misused.
    
    Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fcab63c66905..3d182932d2d1 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -160,6 +160,8 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
 	__irq_put_desc_unlock(desc, flags, false);
 }
 
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
+
 /*
  * Manipulation functions for irq_data.state
  */
@@ -188,6 +190,8 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 	return __irqd_to_state(d) & mask;
 }
 
+#undef __irqd_to_state
+
 static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 {
 	__this_cpu_inc(*desc->kstat_irqs);

commit f944b5a7aff05a244a6c8cac297819af09a199e4
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Thu Jan 14 10:54:13 2016 +0100

    genirq: Use a common macro to go through the actions list
    
    The irq code browses the list of actions differently to inspect the element
    one by one. Even if it is not a problem, for the sake of consistent code,
    provide a macro similar to for_each_irq_desc in order to have the same loop to
    go through the actions list and use it in the code.
    
    [ tglx: Renamed the macro ]
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1452765253-31148-1-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fcab63c66905..eab521fc547c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -131,6 +131,9 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 #define IRQ_GET_DESC_CHECK_GLOBAL	(_IRQ_DESC_CHECK)
 #define IRQ_GET_DESC_CHECK_PERCPU	(_IRQ_DESC_CHECK | _IRQ_DESC_PERCPU)
 
+#define for_each_action_of_desc(desc, act)			\
+	for (act = desc->act; act; act = act->next)
+
 struct irq_desc *
 __irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,
 		    unsigned int check);

commit 4717f133736dec10605da9e29e707144c8d486df
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Nov 10 11:58:12 2015 +0200

    genirq/PM: Restore system wake up from chained interrupts
    
    Commit e509bd7da149 ("genirq: Allow migration of chained interrupts
    by installing default action") breaks PCS wake up IRQ behaviour on
    TI OMAP based platforms (dra7-evm).
    
    TI OMAP IRQ wake up configuration:
    GIC-irqchip->PCM_IRQ
      |- omap_prcm_register_chain_handler
         |- PRCM-irqchip -> PRCM_IO_IRQ
            |- pcs_irq_chain_handler
               |- pinctrl-irqchip -> PCS_uart1_wakeup_irq
    
    This happens because IRQ PM code (irq/pm.c) is expected to ignore
    chained interrupts by default:
      static bool suspend_device_irq(struct irq_desc *desc)
      {
            if (!desc->action || desc->no_suspend_depth)
                    return false;
     - it's expected !desc->action = true for chained interrupts;
    
    but, after above change, all chained interrupt descriptors will
    have default action handler installed - chained_action.
    As result, chained interrupts will be silently disabled during system
    suspend.
    
    Hence, fix it by introducing helper function irq_desc_is_chained() and
    use it in suspend_device_irq() for chained interrupts identification
    and skip them, once detected.
    
    Fixes: e509bd7da149 ("genirq: Allow migration of chained interrupts..")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: <nsekhar@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/1447149492-20699-1-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 05c2188271b8..fcab63c66905 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -199,6 +199,11 @@ static inline int irq_desc_get_node(struct irq_desc *desc)
 	return irq_common_data_get_node(&desc->irq_common_data);
 }
 
+static inline int irq_desc_is_chained(struct irq_desc *desc)
+{
+	return (desc->action && desc->action == &chained_action);
+}
+
 #ifdef CONFIG_PM_SLEEP
 bool irq_pm_check_wakeup(struct irq_desc *desc);
 void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action);

commit e509bd7da149dc34916037484cd7545b2d48a2b0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Oct 5 13:12:15 2015 +0300

    genirq: Allow migration of chained interrupts by installing default action
    
    When a CPU is offlined all interrupts that have an action are migrated to
    other still online CPUs. However, if the interrupt has chained handler
    installed this is not done. Chained handlers are used by GPIO drivers which
    support interrupts, for instance.
    
    When the affinity is not corrected properly we end up in situation where
    most interrupts are not arriving to the online CPUs anymore. For example on
    Intel Braswell system which has SD-card card detection signal connected to
    a GPIO the IO-APIC routing entries look like below after CPU1 is offlined:
    
      pin30, enabled , level, low , V(52), IRR(0), S(0), logical , D(03), M(1)
      pin31, enabled , level, low , V(42), IRR(0), S(0), logical , D(03), M(1)
      pin32, enabled , level, low , V(62), IRR(0), S(0), logical , D(03), M(1)
      pin5b, enabled , level, low , V(72), IRR(0), S(0), logical , D(03), M(1)
    
    The problem here is that the destination mask still contains both CPUs even
    if CPU1 is already offline. This means that the IO-APIC still routes
    interrupts to the other CPU as well.
    
    We solve the problem by providing a default action for chained interrupts.
    This action allows the migration code to correct affinity (as it finds
    desc->action != NULL).
    
    Also make the default action handler to emit a warning if for some reason a
    chained handler ends up calling it.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Link: http://lkml.kernel.org/r/1444039935-30475-1-git-send-email-mika.westerberg@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index cd60bb48397f..05c2188271b8 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -18,6 +18,8 @@
 
 extern bool noirqdebug;
 
+extern struct irqaction chained_action;
+
 /*
  * Bits used by threaded handlers:
  * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run

commit 71f64340fc0eadd06036d0db9a511b6d726add1d
Author: Huang Shijie <shijie.huang@arm.com>
Date:   Wed Sep 2 10:24:55 2015 +0800

    genirq: Remove the second parameter from handle_irq_event_percpu()
    
    Actually, we always use the first irq action of the @desc->action
    chain, so remove the second parameter from handle_irq_event_percpu()
    which makes the code more tidy.
    
    Signed-off-by: Huang Shijie <shijie.huang@arm.com>
    Reviewed-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: peterz@infradead.org
    Cc: marc.zyngier@arm.com
    Link: http://lkml.kernel.org/r/1441160695-19809-1-git-send-email-shijie.huang@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 5ef0c2dbe930..cd60bb48397f 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -81,7 +81,7 @@ extern void irq_mark_irq(unsigned int irq);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
-irqreturn_t handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action);
+irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 
 /* Resending of interrupts :*/

commit 449e9cae58b06be1293858ec8e5d8cb728238baa
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:16 2015 +0800

    genirq: Move field 'node' from irq_data into irq_common_data
    
    NUMA node information is per-irq instead of per-irqchip, so move it into
    struct irq_common_data. Also use CONFIG_NUMA to guard irq_common_data.node.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433145945-789-8-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index eee4b385cffb..5ef0c2dbe930 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -194,7 +194,7 @@ static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 
 static inline int irq_desc_get_node(struct irq_desc *desc)
 {
-	return irq_data_get_node(&desc->irq_data);
+	return irq_common_data_get_node(&desc->irq_common_data);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit 4b979e4c611ce750d32b51737f837b485f43c69b
Merge: 1559f3b8d052 cbfe8fa6cd67
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 30 00:13:24 2015 +0200

    Merge branch 'linus' into irq/core
    
    Pull in upstream fixes before applying conflicting changes

commit 79ff1cda320b81dfe5feae0c5da52f029561ce93
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jun 23 19:52:36 2015 +0200

    genirq: Remove irq argument from __enable/__disable_irq()
    
    Solely used for debug output. Can be retrieved from irq descriptor if
    necessary.
    
    [ tglx: Split out from combo patch ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 429c5e34d619..c8dd8d723ee2 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -60,8 +60,8 @@ enum {
 #include "settings.h"
 
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);
-extern void __disable_irq(struct irq_desc *desc, unsigned int irq);
-extern void __enable_irq(struct irq_desc *desc, unsigned int irq);
+extern void __disable_irq(struct irq_desc *desc);
+extern void __enable_irq(struct irq_desc *desc);
 
 extern int irq_startup(struct irq_desc *desc, bool resend);
 extern void irq_shutdown(struct irq_desc *desc);

commit a1ff541a40e90df05f586bf6b157083b351c4a0c
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jun 23 19:47:29 2015 +0200

    genirq: Remove irq arg from __irq_set_trigger()
    
    It's only required for debug output and can be retrieved from the irq
    descriptor if necessary.
    
    [ tglx: Split out from combo patch ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 7054947e368e..429c5e34d619 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -59,8 +59,7 @@ enum {
 #include "debug.h"
 #include "settings.h"
 
-extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
-		unsigned long flags);
+extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq);
 extern void __enable_irq(struct irq_desc *desc, unsigned int irq);
 

commit 0798abeb7eec37dcc20f252c2195fc31c41561f9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:27 2015 +0800

    genirq: Remove the irq argument from check_irq_resend()
    
    It's only used in the software resend case and can be retrieved from
    irq_desc if necessary.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1433391238-19471-18-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 3e03824cdd38..7054947e368e 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -90,7 +90,7 @@ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *act
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 
 /* Resending of interrupts :*/
-void check_irq_resend(struct irq_desc *desc, unsigned int irq);
+void check_irq_resend(struct irq_desc *desc);
 bool irq_wait_for_poll(struct irq_desc *desc);
 void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);
 

commit b51bf95c583bba645974348666e9b5a14c7aa3ea
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:25 2015 +0800

    genirq: Remove the parameter 'irq' of kstat_incr_irqs_this_cpu()
    
    The first parameter 'irq' is never used by
    kstat_incr_irqs_this_cpu(). Remove it.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/1433391238-19471-16-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 4834ee828c41..3e03824cdd38 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -191,7 +191,7 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 	return __irqd_to_state(d) & mask;
 }
 
-static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *desc)
+static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 {
 	__this_cpu_inc(*desc->kstat_irqs);
 	__this_cpu_inc(kstat.irqs_sum);

commit a899418167264c7bac574b1a0f1b2c26c5b0995a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 5 17:12:30 2015 +0000

    hotplug: Prevent alloc/free of irq descriptors during cpu up/down
    
    When a cpu goes up some architectures (e.g. x86) have to walk the irq
    space to set up the vector space for the cpu. While this needs extra
    protection at the architecture level we can avoid a few race
    conditions by preventing the concurrent allocation/free of irq
    descriptors and the associated data.
    
    When a cpu goes down it moves the interrupts which are targeted to
    this cpu away by reassigning the affinities. While this happens
    interrupts can be allocated and freed, which opens a can of race
    conditions in the code which reassignes the affinities because
    interrupt descriptors might be freed underneath.
    
    Example:
    
    CPU1                            CPU2
    cpu_up/down
     irq_desc = irq_to_desc(irq);
                                    remove_from_radix_tree(desc);
     raw_spin_lock(&desc->lock);
                                    free(desc);
    
    We could protect the irq descriptors with RCU, but that would require
    a full tree change of all accesses to interrupt descriptors. But
    fortunately these kind of race conditions are rather limited to a few
    things like cpu hotplug. The normal setup/teardown is very well
    serialized. So the simpler and obvious solution is:
    
    Prevent allocation and freeing of interrupt descriptors accross cpu
    hotplug.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: xiao jin <jin.xiao@intel.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Yanmin Zhang <yanmin_zhang@linux.intel.com>
    Link: http://lkml.kernel.org/r/20150705171102.063519515@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 4834ee828c41..61008b8433ab 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -76,12 +76,8 @@ extern void unmask_threaded_irq(struct irq_desc *desc);
 
 #ifdef CONFIG_SPARSE_IRQ
 static inline void irq_mark_irq(unsigned int irq) { }
-extern void irq_lock_sparse(void);
-extern void irq_unlock_sparse(void);
 #else
 extern void irq_mark_irq(unsigned int irq);
-static inline void irq_lock_sparse(void) { }
-static inline void irq_unlock_sparse(void) { }
 #endif
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);

commit 6783011b48096b9a0c239d0f7645f93070b6eefd
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:13 2015 +0800

    genirq: Introduce helper function irq_data_get_node()
    
    Introduce helper function irq_data_get_node() and variants thereof to
    hide struct irq_data implementation details.
    
    Convert the core code to use them.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433145945-789-5-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a1ed80d11800..4834ee828c41 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -197,6 +197,11 @@ static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *d
 	__this_cpu_inc(kstat.irqs_sum);
 }
 
+static inline int irq_desc_get_node(struct irq_desc *desc)
+{
+	return irq_data_get_node(&desc->irq_data);
+}
+
 #ifdef CONFIG_PM_SLEEP
 bool irq_pm_check_wakeup(struct irq_desc *desc);
 void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action);

commit 0d0b4c866bcce647f40d73efe5e90aeeb079050a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:12 2015 +0800

    genirq: Introduce struct irq_common_data to host shared irq data
    
    With the introduction of hierarchy irqdomain, struct irq_data becomes
    per-chip instead of per-irq and there may be multiple irq_datas
    associated with the same irq. Some per-irq data stored in struct
    irq_data now may get duplicated into multiple irq_datas, and causes
    inconsistent view.
    
    So introduce struct irq_common_data to host per-irq common data and to
    achieve consistent view among irq_chips.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b93d434e70bd..a1ed80d11800 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -168,27 +168,27 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
  */
 static inline void irqd_set_move_pending(struct irq_data *d)
 {
-	d->state_use_accessors |= IRQD_SETAFFINITY_PENDING;
+	__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;
 }
 
 static inline void irqd_clr_move_pending(struct irq_data *d)
 {
-	d->state_use_accessors &= ~IRQD_SETAFFINITY_PENDING;
+	__irqd_to_state(d) &= ~IRQD_SETAFFINITY_PENDING;
 }
 
 static inline void irqd_clear(struct irq_data *d, unsigned int mask)
 {
-	d->state_use_accessors &= ~mask;
+	__irqd_to_state(d) &= ~mask;
 }
 
 static inline void irqd_set(struct irq_data *d, unsigned int mask)
 {
-	d->state_use_accessors |= mask;
+	__irqd_to_state(d) |= mask;
 }
 
 static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 {
-	return d->state_use_accessors & mask;
+	return __irqd_to_state(d) & mask;
 }
 
 static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *desc)

commit 7bbf1dd24b17b9ec4f47c43ce4e05bf190745553
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:10 2015 +0800

    genirq: Enhance irq_data_to_desc() to support hierarchy irqdomain
    
    For irq associated with hierarchy irqdomains, there will be multiple
    irq_datas for one irq_desc. So enhance irq_data_to_desc() to support
    hierarchy irqdomain. Also export irq_data_to_desc() as an inline
    function for later reuse.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-2-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index df553b0af936..b93d434e70bd 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -59,8 +59,6 @@ enum {
 #include "debug.h"
 #include "settings.h"
 
-#define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
-
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq);

commit c291ee622165cb2c8d4e7af63fffd499354a23be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 11 23:01:41 2014 +0100

    genirq: Prevent proc race against freeing of irq descriptors
    
    Since the rework of the sparse interrupt code to actually free the
    unused interrupt descriptors there exists a race between the /proc
    interfaces to the irq subsystem and the code which frees the interrupt
    descriptor.
    
    CPU0                            CPU1
                                    show_interrupts()
                                      desc = irq_to_desc(X);
    free_desc(desc)
      remove_from_radix_tree();
      kfree(desc);
                                      raw_spinlock_irq(&desc->lock);
    
    /proc/interrupts is the only interface which can actively corrupt
    kernel memory via the lock access. /proc/stat can only read from freed
    memory. Extremly hard to trigger, but possible.
    
    The interfaces in /proc/irq/N/ are not affected by this because the
    removal of the proc file is serialized in procfs against concurrent
    readers/writers. The removal happens before the descriptor is freed.
    
    For architectures which have CONFIG_SPARSE_IRQ=n this is a non issue
    as the descriptor is never freed. It's merely cleared out with the irq
    descriptor lock held. So any concurrent proc access will either see
    the old correct value or the cleared out ones.
    
    Protect the lookup and access to the irq descriptor in
    show_interrupts() with the sparse_irq_lock.
    
    Provide kstat_irqs_usr() which is protecting the lookup and access
    with sparse_irq_lock and switch /proc/stat to use it.
    
    Document the existing kstat_irqs interfaces so it's clear that the
    caller needs to take care about protection. The users of these
    interfaces are either not affected due to SPARSE_IRQ=n or already
    protected against removal.
    
    Fixes: 1f5a5b87f78f "genirq: Implement a sane sparse_irq allocator"
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 4332d766619d..df553b0af936 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -78,8 +78,12 @@ extern void unmask_threaded_irq(struct irq_desc *desc);
 
 #ifdef CONFIG_SPARSE_IRQ
 static inline void irq_mark_irq(unsigned int irq) { }
+extern void irq_lock_sparse(void);
+extern void irq_unlock_sparse(void);
 #else
 extern void irq_mark_irq(unsigned int irq);
+static inline void irq_lock_sparse(void) { }
+static inline void irq_unlock_sparse(void) { }
 #endif
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);

commit 9ce7a25849e80cfb264f4995f832b932c1987e1a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 29 14:00:16 2014 +0200

    genirq: Simplify wakeup mechanism
    
    Currently we suspend wakeup interrupts by lazy disabling them and
    check later whether the interrupt has fired, but that's not sufficient
    for suspend to idle as there is no way to check that once we
    transitioned into the CPU idle state.
    
    So we change the mechanism in the following way:
    
    1) Leave the wakeup interrupts enabled across suspend
    
    2) Add a check to irq_may_run() which is called at the beginning of
       each flow handler whether the interrupt is an armed wakeup source.
    
       This check is basically free as it just extends the existing check
       for IRQD_IRQ_INPROGRESS. So no new conditional in the hot path.
    
       If the IRQD_WAKEUP_ARMED flag is set, then the interrupt is
       disabled, marked as pending/suspended and the pm core is notified
       about the wakeup event.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ rjw: syscore.c and put irq_pm_check_wakeup() into pm.c ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c402502a5111..4332d766619d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -196,9 +196,11 @@ static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *d
 }
 
 #ifdef CONFIG_PM_SLEEP
+bool irq_pm_check_wakeup(struct irq_desc *desc);
 void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action);
 void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action);
 #else
+static inline bool irq_pm_check_wakeup(struct irq_desc *desc) { return false; }
 static inline void
 irq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }
 static inline void

commit cab303be91dc47942bc25de33dc1140123540800
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 11:44:31 2014 +0200

    genirq: Add sanity checks for PM options on shared interrupt lines
    
    Account the IRQF_NO_SUSPEND and IRQF_RESUME_EARLY actions on shared
    interrupt lines and yell loudly if there is a mismatch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index af2821178900..c402502a5111 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -194,3 +194,13 @@ static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *d
 	__this_cpu_inc(*desc->kstat_irqs);
 	__this_cpu_inc(kstat.irqs_sum);
 }
+
+#ifdef CONFIG_PM_SLEEP
+void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action);
+void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action);
+#else
+static inline void
+irq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }
+static inline void
+irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }
+#endif

commit 8df2e02c5c4de9e65ee60153dd9c442356534ad9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 11:49:28 2014 +0200

    genirq: Move suspend/resume logic into irq/pm code
    
    No functional change. Preparatory patch for cleaning up the suspend
    abort functionality. Update the comments while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 099ea2e0eb88..af2821178900 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -63,8 +63,8 @@ enum {
 
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
-extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
-extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
+extern void __disable_irq(struct irq_desc *desc, unsigned int irq);
+extern void __enable_irq(struct irq_desc *desc, unsigned int irq);
 
 extern int irq_startup(struct irq_desc *desc, bool resend);
 extern void irq_shutdown(struct irq_desc *desc);

commit a257954bb38ab23dbf93df812b4b2c01cae29d8b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue May 27 16:07:37 2014 +0800

    genirq: Improve documentation to match current implementation
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Jiri Kosina <trivial@kernel.org>
    Link: http://lkml.kernel.org/r/1401178092-1228-3-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c4065e3edbc3..099ea2e0eb88 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -33,7 +33,7 @@ enum {
 };
 
 /*
- * Bit masks for desc->state
+ * Bit masks for desc->core_internal_state__do_not_mess_with_it
  *
  * IRQS_AUTODETECT		- autodetection in progress
  * IRQS_SPURIOUS_DISABLED	- was disabled due to spurious interrupt

commit f63b6a05f2b11537612266a8b27a61f412344a1d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:21 2014 +0000

    genirq: Replace reserve_irqs in core code
    
    We want to get rid of the public interface.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140507154340.061990194@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ddf1ffeb79f1..c4065e3edbc3 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -76,6 +76,12 @@ extern void mask_irq(struct irq_desc *desc);
 extern void unmask_irq(struct irq_desc *desc);
 extern void unmask_threaded_irq(struct irq_desc *desc);
 
+#ifdef CONFIG_SPARSE_IRQ
+static inline void irq_mark_irq(unsigned int irq) { }
+#else
+extern void irq_mark_irq(unsigned int irq);
+#endif
+
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
 irqreturn_t handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action);

commit 328a4978df833249b099c9875738d7b72042ffe1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 13 19:03:51 2014 +0100

    genirq: Add a new IRQCHIP_EOI_THREADED flag
    
    The flag is necessary for interrupt chips which require an ACK/EOI
    after the handler has run. In case of threaded handlers this needs to
    happen after the threaded handler has completed before the unmask of
    the interrupt.
    
    The flag is only unseful in combination with the handle_fasteoi_irq
    flow control handler.
    
    It can be combined with the flag IRQCHIP_EOI_IF_HANDLED, so the EOI is
    not issued when the interrupt is disabled or in progress.
    
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-sunxi@googlegroups.com
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://lkml.kernel.org/r/1394733834-26839-2-git-send-email-hdegoede@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 17b671713d5f..ddf1ffeb79f1 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -74,6 +74,7 @@ extern void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu);
 extern void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu);
 extern void mask_irq(struct irq_desc *desc);
 extern void unmask_irq(struct irq_desc *desc);
+extern void unmask_threaded_irq(struct irq_desc *desc);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 

commit 8f945a3325bbe0dd651e2f496a53df9b06fc6d07
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Feb 23 21:40:23 2014 +0000

    genirq: Move kstat_incr_irqs_this_cpu() to core
    
    No more users outside the core code. Put it into the poison
    cabinet. That also gets rid of the linux/irq.h include in
    kernel_stat.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140223212739.124207133@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index d61ac29e32d0..17b671713d5f 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -6,6 +6,7 @@
  * of this file for your non core code.
  */
 #include <linux/irqdesc.h>
+#include <linux/kernel_stat.h>
 
 #ifdef CONFIG_SPARSE_IRQ
 # define IRQ_BITMAP_BITS	(NR_IRQS + 8196)
@@ -180,3 +181,9 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 {
 	return d->state_use_accessors & mask;
 }
+
+static inline void kstat_incr_irqs_this_cpu(unsigned int irq, struct irq_desc *desc)
+{
+	__this_cpu_inc(*desc->kstat_irqs);
+	__this_cpu_inc(kstat.irqs_sum);
+}

commit a92444c6b2225a9115d661c950cb48a22aeace20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 15 00:55:19 2014 +0000

    genirq: Provide irq_wake_thread()
    
    In course of the sdhci/sdio discussion with Russell about killing the
    sdio kthread hackery we discovered the need to be able to wake an
    interrupt thread from software.
    
    The rationale for this is, that sdio hardware can lack proper
    interrupt support for certain features. So the driver needs to poll
    the status registers, but at the same time it needs to be woken up by
    an hardware interrupt.
    
    To be able to get rid of the home brewn kthread construct of sdio we
    need a way to wake an irq thread independent of an actual hardware
    interrupt.
    
    Provide an irq_wake_thread() function which wakes up the thread which
    is associated to a given dev_id. This allows sdio to invoke the irq
    thread from the hardware irq handler via the IRQ_WAKE_THREAD return
    value and provides a possibility to wake it via a timer for the
    polling scenarios. That allows to simplify the sdio logic
    significantly.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Chris Ball <chris@printf.net>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140215003823.772565780@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 001fa5bab490..d61ac29e32d0 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -82,6 +82,7 @@ irqreturn_t handle_irq_event(struct irq_desc *desc);
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 bool irq_wait_for_poll(struct irq_desc *desc);
+void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);
 
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);

commit 818b0f3bfb236ae66cac3ff38e86b9e47f24b7aa
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Mar 30 23:11:34 2012 +0800

    genirq: Introduce irq_do_set_affinity() to reduce duplicated code
    
    All invocations of chip->irq_set_affinity() are doing the same return
    value checks. Let them all use a common function.
    
    [ tglx: removed the silly likely while at it ]
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Cc: Jiang Liu <liuj97@gmail.com>
    Cc: Keping Chen <chenkeping@huawei.com>
    Link: http://lkml.kernel.org/r/1333120296-13563-3-git-send-email-jiang.liu@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8e5c56b3b7d9..001fa5bab490 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -101,6 +101,9 @@ extern int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
+extern int irq_do_set_affinity(struct irq_data *data,
+			       const struct cpumask *dest, bool force);
+
 /* Inline functions for support of irq chips on slow busses */
 static inline void chip_bus_lock(struct irq_desc *desc)
 {

commit df8d291f28aa1e8437c8f7816328a6516379c71b
Merge: 5234ffb9f74c fde7d9049e55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 13 16:34:48 2012 +0100

    Merge branch 'linus' into irq/core
    
    Reason: Get upstream fixes integrated before further modifications.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 5234ffb9f74cfa8993d174782bc861dd9b7b5bfb
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Fri Mar 9 14:59:59 2012 +0100

    genirq: Get rid of unnecessary IRQTF_DIED flag
    
    Currently IRQTF_DIED flag is set when a IRQ thread handler calls do_exit()
    But also PF_EXITING per process flag gets set when a thread exits. This
    fix eliminates the duplicate by using PF_EXITING flag.
    
    Also, there is a race condition in exit_irq_thread(). In case a thread's
    bit is cleared in desc->threads_oneshot (and the IRQ line gets unmasked),
    but before IRQTF_DIED flag is set, a new interrupt might come in and set
    just cleared bit again, this time forever. This fix throws IRQTF_DIED flag
    away, eliminating the race as a result.
    
    [ tglx: Test THREAD_EXITING first as suggested by Oleg ]
    
    Reported-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Link: http://lkml.kernel.org/r/20120309135958.GD2114@dhcp-26-207.brq.redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b7952316016a..5c233e0ea2c3 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -20,14 +20,12 @@ extern bool noirqdebug;
 /*
  * Bits used by threaded handlers:
  * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
- * IRQTF_DIED      - handler thread died
  * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
  * IRQTF_AFFINITY  - irq thread is requested to adjust affinity
  * IRQTF_FORCED_THREAD  - irq action is force threaded
  */
 enum {
 	IRQTF_RUNTHREAD,
-	IRQTF_DIED,
 	IRQTF_WARNED,
 	IRQTF_AFFINITY,
 	IRQTF_FORCED_THREAD,

commit b4bc724e82e80478cba5fe9825b62e71ddf78757
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 8 11:57:52 2012 +0100

    genirq: Handle pending irqs in irq_startup()
    
    An interrupt might be pending when irq_startup() is called, but the
    startup code does not invoke the resend logic. In some cases this
    prevents the device from issuing another interrupt which renders the
    device non functional.
    
    Call the resend function in irq_startup() to keep things going.
    
    Reported-and-tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b7952316016a..40378ff877e7 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -67,7 +67,7 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
 extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
-extern int irq_startup(struct irq_desc *desc);
+extern int irq_startup(struct irq_desc *desc, bool resend);
 extern void irq_shutdown(struct irq_desc *desc);
 extern void irq_enable(struct irq_desc *desc);
 extern void irq_disable(struct irq_desc *desc);

commit 2329abfa344a9a824bc4c71f2415528777265510
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:18 2012 +1030

    module_param: make bool parameters really bool (core code)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a73dd6c7372d..b7952316016a 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -15,7 +15,7 @@
 
 #define istate core_internal_state__do_not_mess_with_it
 
-extern int noirqdebug;
+extern bool noirqdebug;
 
 /*
  * Bits used by threaded handlers:

commit 31d9d9b6d83030f748d013e61502fa5477e2ac0e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 23 17:03:06 2011 +0100

    genirq: Add support for per-cpu dev_id interrupts
    
    The ARM GIC interrupt controller offers per CPU interrupts (PPIs),
    which are usually used to connect local timers to each core. Each CPU
    has its own private interface to the GIC, and only sees the PPIs that
    are directly connect to it.
    
    While these timers are separate devices and have a separate interrupt
    line to a core, they all use the same IRQ number.
    
    For these devices, request_irq() is not the right API as it assumes
    that an IRQ number is visible by a number of CPUs (through the
    affinity setting), but makes it very awkward to express that an IRQ
    number can be handled by all CPUs, and yet be a different interrupt
    line on each CPU, requiring a different dev_id cookie to be passed
    back to the handler.
    
    The *_percpu_irq() functions is designed to overcome these
    limitations, by providing a per-cpu dev_id vector:
    
    int request_percpu_irq(unsigned int irq, irq_handler_t handler,
                       const char *devname, void __percpu *percpu_dev_id);
    void free_percpu_irq(unsigned int, void __percpu *);
    int setup_percpu_irq(unsigned int irq, struct irqaction *new);
    void remove_percpu_irq(unsigned int irq, struct irqaction *act);
    void enable_percpu_irq(unsigned int irq);
    void disable_percpu_irq(unsigned int irq);
    
    The API has a number of limitations:
    - no interrupt sharing
    - no threading
    - common handler across all the CPUs
    
    Once the interrupt is requested using setup_percpu_irq() or
    request_percpu_irq(), it must be enabled by each core that wishes its
    local interrupt to be delivered.
    
    Based on an initial patch by Thomas Gleixner.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1316793788-14500-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 6546431447d7..a73dd6c7372d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -71,6 +71,8 @@ extern int irq_startup(struct irq_desc *desc);
 extern void irq_shutdown(struct irq_desc *desc);
 extern void irq_enable(struct irq_desc *desc);
 extern void irq_disable(struct irq_desc *desc);
+extern void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu);
+extern void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu);
 extern void mask_irq(struct irq_desc *desc);
 extern void unmask_irq(struct irq_desc *desc);
 
@@ -114,14 +116,21 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 		desc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);
 }
 
+#define _IRQ_DESC_CHECK		(1 << 0)
+#define _IRQ_DESC_PERCPU	(1 << 1)
+
+#define IRQ_GET_DESC_CHECK_GLOBAL	(_IRQ_DESC_CHECK)
+#define IRQ_GET_DESC_CHECK_PERCPU	(_IRQ_DESC_CHECK | _IRQ_DESC_PERCPU)
+
 struct irq_desc *
-__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus);
+__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,
+		    unsigned int check);
 void __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus);
 
 static inline struct irq_desc *
-irq_get_desc_buslock(unsigned int irq, unsigned long *flags)
+irq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)
 {
-	return __irq_get_desc_lock(irq, flags, true);
+	return __irq_get_desc_lock(irq, flags, true, check);
 }
 
 static inline void
@@ -131,9 +140,9 @@ irq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)
 }
 
 static inline struct irq_desc *
-irq_get_desc_lock(unsigned int irq, unsigned long *flags)
+irq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)
 {
-	return __irq_get_desc_lock(irq, flags, false);
+	return __irq_get_desc_lock(irq, flags, false, check);
 }
 
 static inline void

commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 13:32:20 2011 +0200

    genirq: Remove compat code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 6b8b9713e28d..6546431447d7 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -15,10 +15,6 @@
 
 #define istate core_internal_state__do_not_mess_with_it
 
-#ifdef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-# define status status_use_accessors
-#endif
-
 extern int noirqdebug;
 
 /*
@@ -61,15 +57,11 @@ enum {
 	IRQS_SUSPENDED		= 0x00000800,
 };
 
-#include "compat.h"
 #include "debug.h"
 #include "settings.h"
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
 
-/* Set default functions for irq_chip structures: */
-extern void irq_chip_set_defaults(struct irq_chip *chip);
-
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
@@ -156,13 +148,11 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
 static inline void irqd_set_move_pending(struct irq_data *d)
 {
 	d->state_use_accessors |= IRQD_SETAFFINITY_PENDING;
-	irq_compat_set_move_pending(irq_data_to_desc(d));
 }
 
 static inline void irqd_clr_move_pending(struct irq_data *d)
 {
 	d->state_use_accessors &= ~IRQD_SETAFFINITY_PENDING;
-	irq_compat_clr_move_pending(irq_data_to_desc(d));
 }
 
 static inline void irqd_clear(struct irq_data *d, unsigned int mask)

commit 32f4125ebffee4f3c4dbc6a437fc656129eb9e60
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 14:10:52 2011 +0200

    genirq: Move INPROGRESS, MASKED and DISABLED state flags to irq_data
    
    We really need these flags for some of the interrupt chips. Move it
    from internal state to irq_data and provide proper accessors.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Daney <ddaney@caviumnetworks.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 6c6ec9a49027..6b8b9713e28d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -44,26 +44,20 @@ enum {
  * IRQS_SPURIOUS_DISABLED	- was disabled due to spurious interrupt
  *				  detection
  * IRQS_POLL_INPROGRESS		- polling in progress
- * IRQS_INPROGRESS		- Interrupt in progress
  * IRQS_ONESHOT			- irq is not unmasked in primary handler
  * IRQS_REPLAY			- irq is replayed
  * IRQS_WAITING			- irq is waiting
- * IRQS_DISABLED		- irq is disabled
  * IRQS_PENDING			- irq is pending and replayed later
- * IRQS_MASKED			- irq is masked
  * IRQS_SUSPENDED		- irq is suspended
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
 	IRQS_SPURIOUS_DISABLED	= 0x00000002,
 	IRQS_POLL_INPROGRESS	= 0x00000008,
-	IRQS_INPROGRESS		= 0x00000010,
 	IRQS_ONESHOT		= 0x00000020,
 	IRQS_REPLAY		= 0x00000040,
 	IRQS_WAITING		= 0x00000080,
-	IRQS_DISABLED		= 0x00000100,
 	IRQS_PENDING		= 0x00000200,
-	IRQS_MASKED		= 0x00000400,
 	IRQS_SUSPENDED		= 0x00000800,
 };
 

commit 8d32a307e4faa8b123dc8a9cd56d1a7525f69ad3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 23 23:52:23 2011 +0000

    genirq: Provide forced interrupt threading
    
    Add a commandline parameter "threadirqs" which forces all interrupts except
    those marked IRQF_NO_THREAD to run threaded. That's mostly a debug option to
    allow retrieving better debug data from crashing interrupt handlers. If
    "threadirqs" is not enabled on the kernel command line, then there is no
    impact in the interrupt hotpath.
    
    Architecture code needs to select CONFIG_IRQ_FORCED_THREADING after
    marking the interrupts which cant be threaded IRQF_NO_THREAD. All
    interrupts which have IRQF_TIMER set are implict marked
    IRQF_NO_THREAD. Also all PER_CPU interrupts are excluded.
    
    Forced threading hard interrupts also forces all soft interrupt
    handling into thread context.
    
    When enabled it might slow down things a bit, but for debugging problems in
    interrupt code it's a reasonable penalty as it does not immediately
    crash and burn the machine when an interrupt handler is buggy.
    
    Some test results on a Core2Duo machine:
    
    Cache cold run of:
     # time git grep irq_desc
    
          non-threaded       threaded
     real 1m18.741s          1m19.061s
     user 0m1.874s           0m1.757s
     sys  0m5.843s           0m5.427s
    
     # iperf -c server
    non-threaded
    [  3]  0.0-10.0 sec  1.09 GBytes   933 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   934 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   933 Mbits/sec
    threaded
    [  3]  0.0-10.0 sec  1.09 GBytes   939 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   934 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   937 Mbits/sec
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110223234956.772668648@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 935bec4bfa87..6c6ec9a49027 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -27,12 +27,14 @@ extern int noirqdebug;
  * IRQTF_DIED      - handler thread died
  * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
  * IRQTF_AFFINITY  - irq thread is requested to adjust affinity
+ * IRQTF_FORCED_THREAD  - irq action is force threaded
  */
 enum {
 	IRQTF_RUNTHREAD,
 	IRQTF_DIED,
 	IRQTF_WARNED,
 	IRQTF_AFFINITY,
+	IRQTF_FORCED_THREAD,
 };
 
 /*

commit d5eb4ad2dfb2dfae43fd51bc8630b4fc3ef00e92
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 12 12:16:16 2011 +0100

    genirq: Implement irq_get/put_desc_[bus]locked/unlock()
    
    Most of the managing functions get the irq descriptor and lock it -
    either with or without buslock. Instead of open coding this over and
    over provide a common function to do that.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index f80a77471617..935bec4bfa87 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -126,6 +126,34 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 		desc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);
 }
 
+struct irq_desc *
+__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus);
+void __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus);
+
+static inline struct irq_desc *
+irq_get_desc_buslock(unsigned int irq, unsigned long *flags)
+{
+	return __irq_get_desc_lock(irq, flags, true);
+}
+
+static inline void
+irq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)
+{
+	__irq_put_desc_unlock(desc, flags, true);
+}
+
+static inline struct irq_desc *
+irq_get_desc_lock(unsigned int irq, unsigned long *flags)
+{
+	return __irq_get_desc_lock(irq, flags, false);
+}
+
+static inline void
+irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
+{
+	__irq_put_desc_unlock(desc, flags, false);
+}
+
 /*
  * Manipulation functions for irq_data.state
  */

commit 091738a266fc74329ae186f22ff2b3f01319112d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 14 20:16:43 2011 +0100

    genirq: Remove real old transition functions
    
    These transition helpers are stale for years now. Remove them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fd5777ab2d34..f80a77471617 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -74,9 +74,6 @@ enum {
 /* Set default functions for irq_chip structures: */
 extern void irq_chip_set_defaults(struct irq_chip *chip);
 
-/* Set default handler: */
-extern void compat_irq_chip_set_default_handler(struct irq_desc *desc);
-
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);

commit a6967caf00ebbb2d4acdebcb72a25f2e9ba43fd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 22:01:25 2011 +0100

    genirq: Remove desc->status when GENERIC_HARDIRQS_NO_COMPAT=y
    
    If everything uses the right accessors, then enabling
    GENERIC_HARDIRQS_NO_COMPAT should just work. If not it will tell you.
    
    Don't be lazy and use the trick which I use in the core code!
    
    git grep status_use_accessors
    
    will unearth it in a split second. Offenders are tracked down and not
    slapped with stinking trouts. This time we use frozen shark for a
    better educational value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 5e2366da9f38..fd5777ab2d34 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -15,6 +15,10 @@
 
 #define istate core_internal_state__do_not_mess_with_it
 
+#ifdef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+# define status status_use_accessors
+#endif
+
 extern int noirqdebug;
 
 /*

commit 7f94226f03299f1ca32f118f02f2a0295e0e5e93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 19:46:26 2011 +0100

    genirq: Move wakeup state to irq_data
    
    Some irq_chips need to know the state of wakeup mode for
    setting the trigger type etc. Reflect it in irq_data state.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 1d500fbde0d4..5e2366da9f38 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -46,7 +46,6 @@ enum {
  * IRQS_PENDING			- irq is pending and replayed later
  * IRQS_MASKED			- irq is masked
  * IRQS_SUSPENDED		- irq is suspended
- * IRQS_WAKEUP			- irq triggers system wakeup from suspend
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -60,7 +59,6 @@ enum {
 	IRQS_PENDING		= 0x00000200,
 	IRQS_MASKED		= 0x00000400,
 	IRQS_SUSPENDED		= 0x00000800,
-	IRQS_WAKEUP		= 0x00001000,
 };
 
 #include "compat.h"

commit d4d5e08960844a062da8387ee5f16ca7a33200d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 13:16:14 2011 +0100

    genirq: Add IRQCHIP_SET_TYPE_MASKED flag
    
    irq_chips, which require to mask the chip before changing the trigger
    type should set this flag. So the core takes care of it and the
    requirement for looking into desc->status in the chip goes away.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 6776453c454c..1d500fbde0d4 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -84,6 +84,8 @@ extern int irq_startup(struct irq_desc *desc);
 extern void irq_shutdown(struct irq_desc *desc);
 extern void irq_enable(struct irq_desc *desc);
 extern void irq_disable(struct irq_desc *desc);
+extern void mask_irq(struct irq_desc *desc);
+extern void unmask_irq(struct irq_desc *desc);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 

commit 2bdd10558c8d93009cb6c32ce9e30800fbb08add
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:22:00 2011 +0100

    genirq: Move IRQ_AFFINITY_SET to core
    
    Keep status in sync until last abuser is gone.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a80b44d2735e..6776453c454c 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -150,3 +150,7 @@ static inline void irqd_set(struct irq_data *d, unsigned int mask)
 	d->state_use_accessors |= mask;
 }
 
+static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
+{
+	return d->state_use_accessors & mask;
+}

commit a005677b3dd05decdd8880cf3044ae709856f58f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:11:03 2011 +0100

    genirq: Mirror IRQ_PER_CPU and IRQ_NO_BALANCING in irq_data.state
    
    That's the right data structure to look at for arch code.
    
    Accessor functions are provided.
    
             irqd_is_per_cpu(irqdata);
             irqd_can_balance(irqdata);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b2ba59e73f21..a80b44d2735e 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -139,3 +139,14 @@ static inline void irqd_clr_move_pending(struct irq_data *d)
 	d->state_use_accessors &= ~IRQD_SETAFFINITY_PENDING;
 	irq_compat_clr_move_pending(irq_data_to_desc(d));
 }
+
+static inline void irqd_clear(struct irq_data *d, unsigned int mask)
+{
+	d->state_use_accessors &= ~mask;
+}
+
+static inline void irqd_set(struct irq_data *d, unsigned int mask)
+{
+	d->state_use_accessors |= mask;
+}
+

commit 1ce6068dac1924f7095be5850481e790cbf1b3c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 20:44:21 2011 +0100

    genirq: Move debug code to separate header
    
    It'll break when I'm going to undefine the constants.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 9e32b3d35d35..b2ba59e73f21 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -13,9 +13,6 @@
 # define IRQ_BITMAP_BITS	NR_IRQS
 #endif
 
-#include "compat.h"
-#include "settings.h"
-
 #define istate core_internal_state__do_not_mess_with_it
 
 extern int noirqdebug;
@@ -66,6 +63,10 @@ enum {
 	IRQS_WAKEUP		= 0x00001000,
 };
 
+#include "compat.h"
+#include "debug.h"
+#include "settings.h"
+
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
 
 /* Set default functions for irq_chip structures: */
@@ -138,44 +139,3 @@ static inline void irqd_clr_move_pending(struct irq_data *d)
 	d->state_use_accessors &= ~IRQD_SETAFFINITY_PENDING;
 	irq_compat_clr_move_pending(irq_data_to_desc(d));
 }
-
-/*
- * Debugging printout:
- */
-
-#include <linux/kallsyms.h>
-
-#define P(f) if (desc->status & f) printk("%14s set\n", #f)
-#define PS(f) if (desc->istate & f) printk("%14s set\n", #f)
-
-static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
-{
-	printk("irq %d, desc: %p, depth: %d, count: %d, unhandled: %d\n",
-		irq, desc, desc->depth, desc->irq_count, desc->irqs_unhandled);
-	printk("->handle_irq():  %p, ", desc->handle_irq);
-	print_symbol("%s\n", (unsigned long)desc->handle_irq);
-	printk("->irq_data.chip(): %p, ", desc->irq_data.chip);
-	print_symbol("%s\n", (unsigned long)desc->irq_data.chip);
-	printk("->action(): %p\n", desc->action);
-	if (desc->action) {
-		printk("->action->handler(): %p, ", desc->action->handler);
-		print_symbol("%s\n", (unsigned long)desc->action->handler);
-	}
-
-	P(IRQ_LEVEL);
-	P(IRQ_PER_CPU);
-	P(IRQ_NOPROBE);
-	P(IRQ_NOREQUEST);
-	P(IRQ_NOAUTOEN);
-
-	PS(IRQS_AUTODETECT);
-	PS(IRQS_INPROGRESS);
-	PS(IRQS_REPLAY);
-	PS(IRQS_WAITING);
-	PS(IRQS_DISABLED);
-	PS(IRQS_PENDING);
-	PS(IRQS_MASKED);
-}
-
-#undef P
-#undef PS

commit 6a58fb3bad099076f36f0f30f44507bc3275cdb6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 15:40:05 2011 +0100

    genirq: Remove CONFIG_IRQ_PER_CPU
    
    The saving of this switch is minimal versus the ifdef mess it
    creates. Simple enable PER_CPU unconditionally and remove the config
    switch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e93e6090cd47..9e32b3d35d35 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -163,9 +163,7 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	}
 
 	P(IRQ_LEVEL);
-#ifdef CONFIG_IRQ_PER_CPU
 	P(IRQ_PER_CPU);
-#endif
 	P(IRQ_NOPROBE);
 	P(IRQ_NOREQUEST);
 	P(IRQ_NOAUTOEN);

commit f230b6d5c48f8d12f4dfa1f8b5ab0b0320076d21
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 5 15:20:04 2011 +0100

    genirq: Add IRQ_MOVE_PENDING to irq_data.state
    
    chip implementations need to know about it. Keep status in sync until
    all users are fixed.
    
    Accessor function: irqd_is_setaffinity_pending(irqdata)
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index cef0849dcfa5..e93e6090cd47 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -124,6 +124,21 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 		desc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);
 }
 
+/*
+ * Manipulation functions for irq_data.state
+ */
+static inline void irqd_set_move_pending(struct irq_data *d)
+{
+	d->state_use_accessors |= IRQD_SETAFFINITY_PENDING;
+	irq_compat_set_move_pending(irq_data_to_desc(d));
+}
+
+static inline void irqd_clr_move_pending(struct irq_data *d)
+{
+	d->state_use_accessors &= ~IRQD_SETAFFINITY_PENDING;
+	irq_compat_clr_move_pending(irq_data_to_desc(d));
+}
+
 /*
  * Debugging printout:
  */

commit 6d2cd17fde1fc3e93302815f049f255bb2b3123e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 14:34:18 2011 +0100

    genirq: Move IRQ_WAKEUP to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 46889119e6a6..cef0849dcfa5 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -49,6 +49,7 @@ enum {
  * IRQS_PENDING			- irq is pending and replayed later
  * IRQS_MASKED			- irq is masked
  * IRQS_SUSPENDED		- irq is suspended
+ * IRQS_WAKEUP			- irq triggers system wakeup from suspend
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -62,6 +63,7 @@ enum {
 	IRQS_PENDING		= 0x00000200,
 	IRQS_MASKED		= 0x00000400,
 	IRQS_SUSPENDED		= 0x00000800,
+	IRQS_WAKEUP		= 0x00001000,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit c531e8361f1968d664e6e97fbd3bfa4cf0e62e42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:44:58 2011 +0100

    genirq: Move IRQ_SUSPENDED to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 3f2fcc194dcc..46889119e6a6 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -48,6 +48,7 @@ enum {
  * IRQS_DISABLED		- irq is disabled
  * IRQS_PENDING			- irq is pending and replayed later
  * IRQS_MASKED			- irq is masked
+ * IRQS_SUSPENDED		- irq is suspended
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -60,6 +61,7 @@ enum {
 	IRQS_DISABLED		= 0x00000100,
 	IRQS_PENDING		= 0x00000200,
 	IRQS_MASKED		= 0x00000400,
+	IRQS_SUSPENDED		= 0x00000800,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit 6e40262ea43c4b0e3f435b3a083e4461ef921c17
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:36:06 2011 +0100

    genirq: Move IRQ_MASKED to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fdf2524437eb..3f2fcc194dcc 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -47,6 +47,7 @@ enum {
  * IRQS_WAITING			- irq is waiting
  * IRQS_DISABLED		- irq is disabled
  * IRQS_PENDING			- irq is pending and replayed later
+ * IRQS_MASKED			- irq is masked
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -58,6 +59,7 @@ enum {
 	IRQS_WAITING		= 0x00000080,
 	IRQS_DISABLED		= 0x00000100,
 	IRQS_PENDING		= 0x00000200,
+	IRQS_MASKED		= 0x00000400,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
@@ -142,7 +144,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	}
 
 	P(IRQ_LEVEL);
-	P(IRQ_MASKED);
 #ifdef CONFIG_IRQ_PER_CPU
 	P(IRQ_PER_CPU);
 #endif
@@ -156,6 +157,7 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	PS(IRQS_WAITING);
 	PS(IRQS_DISABLED);
 	PS(IRQS_PENDING);
+	PS(IRQS_MASKED);
 }
 
 #undef P

commit 2a0d6fb335d4428285dab2d254911748e6040807
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:17:57 2011 +0100

    genirq: Move IRQ_PENDING flag to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 919d2dd0bb33..fdf2524437eb 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -46,6 +46,7 @@ enum {
  * IRQS_REPLAY			- irq is replayed
  * IRQS_WAITING			- irq is waiting
  * IRQS_DISABLED		- irq is disabled
+ * IRQS_PENDING			- irq is pending and replayed later
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -56,6 +57,7 @@ enum {
 	IRQS_REPLAY		= 0x00000040,
 	IRQS_WAITING		= 0x00000080,
 	IRQS_DISABLED		= 0x00000100,
+	IRQS_PENDING		= 0x00000200,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
@@ -139,7 +141,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 		print_symbol("%s\n", (unsigned long)desc->action->handler);
 	}
 
-	P(IRQ_PENDING);
 	P(IRQ_LEVEL);
 	P(IRQ_MASKED);
 #ifdef CONFIG_IRQ_PER_CPU
@@ -154,6 +155,7 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	PS(IRQS_REPLAY);
 	PS(IRQS_WAITING);
 	PS(IRQS_DISABLED);
+	PS(IRQS_PENDING);
 }
 
 #undef P

commit c1594b77e46124bb462f961e536120e471c67446
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 22:11:30 2011 +0100

    genirq: Move IRQ_DISABLED to core
    
    Keep status in sync until all abusers are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 54037533af7a..919d2dd0bb33 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -45,6 +45,7 @@ enum {
  * IRQS_ONESHOT			- irq is not unmasked in primary handler
  * IRQS_REPLAY			- irq is replayed
  * IRQS_WAITING			- irq is waiting
+ * IRQS_DISABLED		- irq is disabled
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -54,6 +55,7 @@ enum {
 	IRQS_ONESHOT		= 0x00000020,
 	IRQS_REPLAY		= 0x00000040,
 	IRQS_WAITING		= 0x00000080,
+	IRQS_DISABLED		= 0x00000100,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
@@ -137,7 +139,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 		print_symbol("%s\n", (unsigned long)desc->action->handler);
 	}
 
-	P(IRQ_DISABLED);
 	P(IRQ_PENDING);
 	P(IRQ_LEVEL);
 	P(IRQ_MASKED);
@@ -152,6 +153,7 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	PS(IRQS_INPROGRESS);
 	PS(IRQS_REPLAY);
 	PS(IRQS_WAITING);
+	PS(IRQS_DISABLED);
 }
 
 #undef P

commit 163ef3091195f514a06f064b12914597d2644c55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 11:39:15 2011 +0100

    genirq: Move IRQ_REPLAY and IRQ_WAITING to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 36563f731ff8..54037533af7a 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -43,6 +43,8 @@ enum {
  * IRQS_POLL_INPROGRESS		- polling in progress
  * IRQS_INPROGRESS		- Interrupt in progress
  * IRQS_ONESHOT			- irq is not unmasked in primary handler
+ * IRQS_REPLAY			- irq is replayed
+ * IRQS_WAITING			- irq is waiting
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
@@ -50,6 +52,8 @@ enum {
 	IRQS_POLL_INPROGRESS	= 0x00000008,
 	IRQS_INPROGRESS		= 0x00000010,
 	IRQS_ONESHOT		= 0x00000020,
+	IRQS_REPLAY		= 0x00000040,
+	IRQS_WAITING		= 0x00000080,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
@@ -135,8 +139,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 
 	P(IRQ_DISABLED);
 	P(IRQ_PENDING);
-	P(IRQ_REPLAY);
-	P(IRQ_WAITING);
 	P(IRQ_LEVEL);
 	P(IRQ_MASKED);
 #ifdef CONFIG_IRQ_PER_CPU
@@ -148,6 +150,8 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 
 	PS(IRQS_AUTODETECT);
 	PS(IRQS_INPROGRESS);
+	PS(IRQS_REPLAY);
+	PS(IRQS_WAITING);
 }
 
 #undef P

commit 3d67baec7f1b01fc289ac1a2f1a7e6d5e43391c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 21:02:10 2011 +0100

    genirq: Move IRQ_ONESHOT to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index d1cb1f8df6fe..36563f731ff8 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -42,12 +42,14 @@ enum {
  *				  detection
  * IRQS_POLL_INPROGRESS		- polling in progress
  * IRQS_INPROGRESS		- Interrupt in progress
+ * IRQS_ONESHOT			- irq is not unmasked in primary handler
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
 	IRQS_SPURIOUS_DISABLED	= 0x00000002,
 	IRQS_POLL_INPROGRESS	= 0x00000008,
 	IRQS_INPROGRESS		= 0x00000010,
+	IRQS_ONESHOT		= 0x00000020,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit 009b4c3b8ad584b3462734127a5bec680d5d6af4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 21:48:49 2011 +0100

    genirq: Add IRQ_INPROGRESS to core
    
    We need to maintain the flag for now in both fields status and istate.
    Add a CONFIG_GENERIC_HARDIRQS_NO_COMPAT switch to allow testing w/o
    the status one. Wrap the access to status IRQ_INPROGRESS in a inline
    which can be turned of with CONFIG_GENERIC_HARDIRQS_NO_COMPAT along
    with the define.
    
    There is no reason that anything outside of core looks at this. That
    needs some modifications, but we'll get there.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index f5d28e1e1eda..d1cb1f8df6fe 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -13,6 +13,7 @@
 # define IRQ_BITMAP_BITS	NR_IRQS
 #endif
 
+#include "compat.h"
 #include "settings.h"
 
 #define istate core_internal_state__do_not_mess_with_it
@@ -40,11 +41,13 @@ enum {
  * IRQS_SPURIOUS_DISABLED	- was disabled due to spurious interrupt
  *				  detection
  * IRQS_POLL_INPROGRESS		- polling in progress
+ * IRQS_INPROGRESS		- Interrupt in progress
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
 	IRQS_SPURIOUS_DISABLED	= 0x00000002,
 	IRQS_POLL_INPROGRESS	= 0x00000008,
+	IRQS_INPROGRESS		= 0x00000010,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
@@ -128,7 +131,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 		print_symbol("%s\n", (unsigned long)desc->action->handler);
 	}
 
-	P(IRQ_INPROGRESS);
 	P(IRQ_DISABLED);
 	P(IRQ_PENDING);
 	P(IRQ_REPLAY);
@@ -143,6 +145,7 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	P(IRQ_NOAUTOEN);
 
 	PS(IRQS_AUTODETECT);
+	PS(IRQS_INPROGRESS);
 }
 
 #undef P

commit 6954b75b488dd740950573f244ddd66fd28620aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:55:35 2011 +0100

    genirq: Move IRQ_POLL_INPROGRESS to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index dc5e21b84f9e..f5d28e1e1eda 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -39,10 +39,12 @@ enum {
  * IRQS_AUTODETECT		- autodetection in progress
  * IRQS_SPURIOUS_DISABLED	- was disabled due to spurious interrupt
  *				  detection
+ * IRQS_POLL_INPROGRESS		- polling in progress
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
 	IRQS_SPURIOUS_DISABLED	= 0x00000002,
+	IRQS_POLL_INPROGRESS	= 0x00000008,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit 7acdd53e5b2c55b6f7e3427e85e2f91fa814a4f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:40:54 2011 +0100

    genirq: Move IRQ_SPURIOUS_DISABLED to core state
    
    No users outside.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 7ffd4f439b92..dc5e21b84f9e 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -37,9 +37,12 @@ enum {
  * Bit masks for desc->state
  *
  * IRQS_AUTODETECT		- autodetection in progress
+ * IRQS_SPURIOUS_DISABLED	- was disabled due to spurious interrupt
+ *				  detection
  */
 enum {
 	IRQS_AUTODETECT		= 0x00000001,
+	IRQS_SPURIOUS_DISABLED	= 0x00000002,
 };
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit bd062e7667ac173afef57fbfe9327f3b914a9d4c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:25:25 2011 +0100

    genirq: Move IRQ_AUTODETECT to internal state
    
    No users outside of core
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8f200310a952..7ffd4f439b92 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -33,6 +33,15 @@ enum {
 	IRQTF_AFFINITY,
 };
 
+/*
+ * Bit masks for desc->state
+ *
+ * IRQS_AUTODETECT		- autodetection in progress
+ */
+enum {
+	IRQS_AUTODETECT		= 0x00000001,
+};
+
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
 
 /* Set default functions for irq_chip structures: */
@@ -98,6 +107,7 @@ static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 #include <linux/kallsyms.h>
 
 #define P(f) if (desc->status & f) printk("%14s set\n", #f)
+#define PS(f) if (desc->istate & f) printk("%14s set\n", #f)
 
 static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 {
@@ -117,7 +127,6 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	P(IRQ_DISABLED);
 	P(IRQ_PENDING);
 	P(IRQ_REPLAY);
-	P(IRQ_AUTODETECT);
 	P(IRQ_WAITING);
 	P(IRQ_LEVEL);
 	P(IRQ_MASKED);
@@ -127,7 +136,9 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 	P(IRQ_NOPROBE);
 	P(IRQ_NOREQUEST);
 	P(IRQ_NOAUTOEN);
+
+	PS(IRQS_AUTODETECT);
 }
 
 #undef P
-
+#undef PS

commit e6bea9c404699223322d7411c6f2ceaec02fa83c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 13:16:52 2011 +0100

    genirq: Protect tglx from tripping over his own feet
    
    The irq_desc.status field will either go away or renamed to
    settings. Anyway we need to maintain compatibility to avoid breaking
    the world and some more. While moving bits into the core, I need to
    avoid that I use any of the still existing IRQ_ bits in the core code
    by typos. So that file will hold the inline wrappers and some nasty
    CPP tricks to break the build when typoed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ae96e688f4e1..8f200310a952 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -13,6 +13,8 @@
 # define IRQ_BITMAP_BITS	NR_IRQS
 #endif
 
+#include "settings.h"
+
 #define istate core_internal_state__do_not_mess_with_it
 
 extern int noirqdebug;

commit dbec07bac614a61e3392c1e7c08cc6a49ad43f7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:19:55 2011 +0100

    genirq: Add internal state field to irq_desc
    
    That field will contain internal state information which is not going
    to be exposed to anything outside the core code - except via accessor
    functions. I'm tired of everyone fiddling in irq_desc.status.
    
    core_internal_state__do_not_mess_with_it is clear enough, annoying to
    type and easy to grep for. Offenders will be tracked down and slapped
    with stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b61824cdadc6..ae96e688f4e1 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -1,5 +1,9 @@
 /*
  * IRQ subsystem internal functions and variables:
+ *
+ * Do not ever include this file from anything else than
+ * kernel/irq/. Do not even think about using any information outside
+ * of this file for your non core code.
  */
 #include <linux/irqdesc.h>
 
@@ -9,6 +13,8 @@
 # define IRQ_BITMAP_BITS	NR_IRQS
 #endif
 
+#define istate core_internal_state__do_not_mess_with_it
+
 extern int noirqdebug;
 
 /*

commit 4912609f228da4a3d2bfbdf0f31de3d9eab2b7f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 01:08:49 2011 +0100

    genirq: Implement handle_irq_event()
    
    Core code replacement for the ugly camel case. It contains all the
    code which is shared in all handlers.
    
         clear status flags
         set INPROGRESS flag
         unlock
         call action chain
         note_interrupt
         lock
         clr INPROGRESS flag
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c71fc4de0371..b61824cdadc6 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -45,6 +45,9 @@ extern void irq_disable(struct irq_desc *desc);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
+irqreturn_t handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action);
+irqreturn_t handle_irq_event(struct irq_desc *desc);
+
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 bool irq_wait_for_poll(struct irq_desc *desc);

commit 87923470c712dff00b101ffb6b6fbc27bd7a6df5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 3 12:27:44 2011 +0100

    genirq: Consolidate disable/enable
    
    Create irq_disable/enable and use them to keep the flags consistent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 5cbfc93ed7b1..c71fc4de0371 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -40,6 +40,8 @@ extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
 extern int irq_startup(struct irq_desc *desc);
 extern void irq_shutdown(struct irq_desc *desc);
+extern void irq_enable(struct irq_desc *desc);
+extern void irq_disable(struct irq_desc *desc);
 
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 

commit 4699923861513671d3f6ade8efb4e56a9a7ecadf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 2 21:41:14 2011 +0000

    genirq: Consolidate startup/shutdown of interrupts
    
    Aside of duplicated code some of the startup/shutdown sites do not
    handle the MASKED/DISABLED flags and the depth field at all. Move that
    to a helper function and take care of it there.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110202212551.787481468@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b17c98440400..5cbfc93ed7b1 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -38,6 +38,9 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
 extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
+extern int irq_startup(struct irq_desc *desc);
+extern void irq_shutdown(struct irq_desc *desc);
+
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
 /* Resending of interrupts :*/

commit 1535dfacbf21c4da1b73fcf07c39913da5bd5581
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 01:55:43 2011 +0100

    genirq: Move irq thread flags to core
    
    Soleley used in core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 0eff7e92b1a9..b17c98440400 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -11,6 +11,20 @@
 
 extern int noirqdebug;
 
+/*
+ * Bits used by threaded handlers:
+ * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
+ * IRQTF_DIED      - handler thread died
+ * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
+ * IRQTF_AFFINITY  - irq thread is requested to adjust affinity
+ */
+enum {
+	IRQTF_RUNTHREAD,
+	IRQTF_DIED,
+	IRQTF_WARNED,
+	IRQTF_AFFINITY,
+};
+
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
 
 /* Set default functions for irq_chip structures: */

commit fe200ae48ef5c79bf7941fe8046ff9505c570ff6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 10:34:30 2011 +0100

    genirq: Mark polled irqs and defer the real handler
    
    With the chip.end() function gone we might run into a situation where
    a poll call runs and the real interrupt comes in, sees IRQ_INPROGRESS
    and disables the line. That might be a perfect working one, which will
    then be masked forever.
    
    So mark them polled while the poll runs. When the real handler sees
    IRQ_INPROGRESS it checks the poll flag and waits for the polling to
    complete. Add the necessary amount of sanity checks to it to avoid
    deadlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b5bfa24aa6a6..0eff7e92b1a9 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -28,6 +28,7 @@ extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
+bool irq_wait_for_poll(struct irq_desc *desc);
 
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);
@@ -47,16 +48,6 @@ extern int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
-static inline void irq_end(unsigned int irq, struct irq_desc *desc)
-{
-	if (desc->irq_data.chip && desc->irq_data.chip->end)
-		desc->irq_data.chip->end(irq);
-}
-#else
-static inline void irq_end(unsigned int irq, struct irq_desc *desc) { }
-#endif
-
 /* Inline functions for support of irq chips on slow busses */
 static inline void chip_bus_lock(struct irq_desc *desc)
 {

commit 3b8249e759c701c4a82f99d957be651a7657bf6f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 16:02:20 2011 +0100

    genirq: Do not copy affinity before set
    
    While rumaging through arch code I found that there are a few
    workarounds which deal with the fact that the initial affinity setting
    from request_irq() copies the mask into irq_data->affinity before the
    chip code is called. In the normal path we unconditionally copy the
    mask when the chip code returns 0.
    
    Copy after the code is called and add a return code
    IRQ_SET_MASK_OK_NOCOPY for the chip functions, which prevents the
    copy. That way we see the real mask when the chip function decided to
    truncate it further as some arches do. IRQ_SET_MASK_OK is 0, which is
    the current behaviour.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 99c3bc8a6fb4..b5bfa24aa6a6 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -43,7 +43,7 @@ static inline void unregister_handler_proc(unsigned int irq,
 					   struct irqaction *action) { }
 #endif
 
-extern int irq_select_affinity_usr(unsigned int irq);
+extern int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 

commit c1ee6264280e740a9d3ff3feef38642cf0a57013
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 17 17:45:15 2011 +0100

    genirq: Prevent access beyond allocated_irqs bitmap
    
    Lars-Peter Clausen pointed out:
    
       I stumbled upon this while looking through the existing archs using
       SPARSE_IRQ.  Even with SPARSE_IRQ the NR_IRQS is still the upper
       limit for the number of IRQs.
    
       Both PXA and MMP set NR_IRQS to IRQ_BOARD_START, with
       IRQ_BOARD_START being the number of IRQs used by the core.
    
       In various machine files the nr_irqs field of the ARM machine
       defintion struct is then set to "IRQ_BOARD_START + NR_BOARD_IRQS".
    
       As a result "nr_irqs" will greater then NR_IRQS which then again
       causes the "allocated_irqs" bitmap in the core irq code to be
       accessed beyond its size overwriting unrelated data.
    
    The core code really misses a sanity check there.
    
    This went unnoticed so far as by chance the compiler/linker places
    data behind that bitmap which gets initialized later on those affected
    platforms.
    
    So the obvious fix would be to add a sanity check in early_irq_init()
    and break all affected platforms. Though that check wants to be
    backported to stable as well, which will require to fix all known
    problematic platforms and probably some more yet not known ones as
    well. Lots of churn.
    
    A way simpler solution is to allocate a slightly larger bitmap and
    avoid the whole churn w/o breaking anything. Add a few warnings when
    an arch returns utter crap.
    
    Reported-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org # .37
    Cc: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 4571ae7e085a..99c3bc8a6fb4 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -3,6 +3,12 @@
  */
 #include <linux/irqdesc.h>
 
+#ifdef CONFIG_SPARSE_IRQ
+# define IRQ_BITMAP_BITS	(NR_IRQS + 8196)
+#else
+# define IRQ_BITMAP_BITS	NR_IRQS
+#endif
+
 extern int noirqdebug;
 
 #define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)

commit 78f90d91f395cd0dc1ef3f21e0c5cd6fd50d202c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 29 17:18:47 2010 +0200

    genirq: Remove the now unused sparse irq leftovers
    
    The move_irq_desc() function was only used due to the problem that the
    allocator did not free the old descriptors. So the descriptors had to
    be moved in create_irq_nr(). That's history.
    
    The code would have never been able to move active interrupt
    descriptors on affinity settings. That can be done in a completely
    different way w/o all this horror.
    
    Remove all of it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index f444203a772d..4571ae7e085a 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -18,17 +18,11 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
 extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
-extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
-extern raw_spinlock_t sparse_irq_lock;
 
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 
-#ifdef CONFIG_SPARSE_IRQ
-void replace_irq_desc(unsigned int irq, struct irq_desc *desc);
-#endif
-
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);
 extern void unregister_irq_proc(unsigned int irq, struct irq_desc *desc);
@@ -110,99 +104,3 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 
 #undef P
 
-/* Stuff below will be cleaned up after the sparse allocator is done */
-
-#ifdef CONFIG_SMP
-/**
- * alloc_desc_masks - allocate cpumasks for irq_desc
- * @desc:	pointer to irq_desc struct
- * @node:	node which will be handling the cpumasks
- * @boot:	true if need bootmem
- *
- * Allocates affinity and pending_mask cpumask if required.
- * Returns true if successful (or not required).
- */
-static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
-							bool boot)
-{
-	gfp_t gfp = GFP_ATOMIC;
-
-	if (boot)
-		gfp = GFP_NOWAIT;
-
-#ifdef CONFIG_CPUMASK_OFFSTACK
-	if (!alloc_cpumask_var_node(&desc->irq_data.affinity, gfp, node))
-		return false;
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	if (!alloc_cpumask_var_node(&desc->pending_mask, gfp, node)) {
-		free_cpumask_var(desc->irq_data.affinity);
-		return false;
-	}
-#endif
-#endif
-	return true;
-}
-
-static inline void init_desc_masks(struct irq_desc *desc)
-{
-	cpumask_setall(desc->irq_data.affinity);
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_clear(desc->pending_mask);
-#endif
-}
-
-/**
- * init_copy_desc_masks - copy cpumasks for irq_desc
- * @old_desc:	pointer to old irq_desc struct
- * @new_desc:	pointer to new irq_desc struct
- *
- * Insures affinity and pending_masks are copied to new irq_desc.
- * If !CONFIG_CPUMASKS_OFFSTACK the cpumasks are embedded in the
- * irq_desc struct so the copy is redundant.
- */
-
-static inline void init_copy_desc_masks(struct irq_desc *old_desc,
-					struct irq_desc *new_desc)
-{
-#ifdef CONFIG_CPUMASK_OFFSTACK
-	cpumask_copy(new_desc->irq_data.affinity, old_desc->irq_data.affinity);
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_copy(new_desc->pending_mask, old_desc->pending_mask);
-#endif
-#endif
-}
-
-static inline void free_desc_masks(struct irq_desc *old_desc,
-				   struct irq_desc *new_desc)
-{
-	free_cpumask_var(old_desc->irq_data.affinity);
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	free_cpumask_var(old_desc->pending_mask);
-#endif
-}
-
-#else /* !CONFIG_SMP */
-
-static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
-								bool boot)
-{
-	return true;
-}
-
-static inline void init_desc_masks(struct irq_desc *desc)
-{
-}
-
-static inline void init_copy_desc_masks(struct irq_desc *old_desc,
-					struct irq_desc *new_desc)
-{
-}
-
-static inline void free_desc_masks(struct irq_desc *old_desc,
-				   struct irq_desc *new_desc)
-{
-}
-#endif	/* CONFIG_SMP */

commit b7b29338dc7111ed8bd4d6555d84afae13ebe752
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 29 18:46:55 2010 +0200

    genirq: Sanitize dynamic irq handling
    
    Use the cleanup functions of the dynamic allocator. No need to have
    separate implementations.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8eb01e379ccc..f444203a772d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -20,7 +20,6 @@ extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
 extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
-extern void clear_kstat_irqs(struct irq_desc *desc);
 extern raw_spinlock_t sparse_irq_lock;
 
 /* Resending of interrupts :*/

commit 13bfe99e09123ef5edb6acb81ba337d2db600b53
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 30 02:46:07 2010 +0200

    genirq: Prepare proc for real sparse irq support
    
    /proc/irq never removes any entries, but when irq descriptors can be
    freed for real this is necessary. Otherwise we'd reference a freed
    descriptor in /proc/irq/N
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e281e45fbb55..8eb01e379ccc 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -32,10 +32,12 @@ void replace_irq_desc(unsigned int irq, struct irq_desc *desc);
 
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);
+extern void unregister_irq_proc(unsigned int irq, struct irq_desc *desc);
 extern void register_handler_proc(unsigned int irq, struct irqaction *action);
 extern void unregister_handler_proc(unsigned int irq, struct irqaction *action);
 #else
 static inline void register_irq_proc(unsigned int irq, struct irq_desc *desc) { }
+static inline void unregister_irq_proc(unsigned int irq, struct irq_desc *desc) { }
 static inline void register_handler_proc(unsigned int irq,
 					 struct irqaction *action) { }
 static inline void unregister_handler_proc(unsigned int irq,

commit e144710b302525de5b90b9c3ba43562458d8957f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 16:03:45 2010 +0200

    genirq: Distangle irq.h
    
    Move irq_desc and internal functions out of irq.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b905f0ab1bb2..e281e45fbb55 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -1,6 +1,7 @@
 /*
  * IRQ subsystem internal functions and variables:
  */
+#include <linux/irqdesc.h>
 
 extern int noirqdebug;
 
@@ -22,6 +23,9 @@ extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 extern void clear_kstat_irqs(struct irq_desc *desc);
 extern raw_spinlock_t sparse_irq_lock;
 
+/* Resending of interrupts :*/
+void check_irq_resend(struct irq_desc *desc, unsigned int irq);
+
 #ifdef CONFIG_SPARSE_IRQ
 void replace_irq_desc(unsigned int irq, struct irq_desc *desc);
 #endif
@@ -105,3 +109,99 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 
 #undef P
 
+/* Stuff below will be cleaned up after the sparse allocator is done */
+
+#ifdef CONFIG_SMP
+/**
+ * alloc_desc_masks - allocate cpumasks for irq_desc
+ * @desc:	pointer to irq_desc struct
+ * @node:	node which will be handling the cpumasks
+ * @boot:	true if need bootmem
+ *
+ * Allocates affinity and pending_mask cpumask if required.
+ * Returns true if successful (or not required).
+ */
+static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
+							bool boot)
+{
+	gfp_t gfp = GFP_ATOMIC;
+
+	if (boot)
+		gfp = GFP_NOWAIT;
+
+#ifdef CONFIG_CPUMASK_OFFSTACK
+	if (!alloc_cpumask_var_node(&desc->irq_data.affinity, gfp, node))
+		return false;
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	if (!alloc_cpumask_var_node(&desc->pending_mask, gfp, node)) {
+		free_cpumask_var(desc->irq_data.affinity);
+		return false;
+	}
+#endif
+#endif
+	return true;
+}
+
+static inline void init_desc_masks(struct irq_desc *desc)
+{
+	cpumask_setall(desc->irq_data.affinity);
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	cpumask_clear(desc->pending_mask);
+#endif
+}
+
+/**
+ * init_copy_desc_masks - copy cpumasks for irq_desc
+ * @old_desc:	pointer to old irq_desc struct
+ * @new_desc:	pointer to new irq_desc struct
+ *
+ * Insures affinity and pending_masks are copied to new irq_desc.
+ * If !CONFIG_CPUMASKS_OFFSTACK the cpumasks are embedded in the
+ * irq_desc struct so the copy is redundant.
+ */
+
+static inline void init_copy_desc_masks(struct irq_desc *old_desc,
+					struct irq_desc *new_desc)
+{
+#ifdef CONFIG_CPUMASK_OFFSTACK
+	cpumask_copy(new_desc->irq_data.affinity, old_desc->irq_data.affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	cpumask_copy(new_desc->pending_mask, old_desc->pending_mask);
+#endif
+#endif
+}
+
+static inline void free_desc_masks(struct irq_desc *old_desc,
+				   struct irq_desc *new_desc)
+{
+	free_cpumask_var(old_desc->irq_data.affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	free_cpumask_var(old_desc->pending_mask);
+#endif
+}
+
+#else /* !CONFIG_SMP */
+
+static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
+								bool boot)
+{
+	return true;
+}
+
+static inline void init_desc_masks(struct irq_desc *desc)
+{
+}
+
+static inline void init_copy_desc_masks(struct irq_desc *old_desc,
+					struct irq_desc *new_desc)
+{
+}
+
+static inline void free_desc_masks(struct irq_desc *old_desc,
+				   struct irq_desc *new_desc)
+{
+}
+#endif	/* CONFIG_SMP */

commit bd151412263a67b5321e9dd1d5b4bf6d96fdebf3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 15:17:14 2010 +0200

    genirq: Provide config option to disable deprecated code
    
    This option covers now the old chip functions and the irq_desc data
    fields which are moving to struct irq_data. More stuff will follow.
    
    Pretty handy for testing a conversion, whether something broke or not.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ecafbfee5b12..b905f0ab1bb2 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -42,6 +42,16 @@ extern int irq_select_affinity_usr(unsigned int irq);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
+static inline void irq_end(unsigned int irq, struct irq_desc *desc)
+{
+	if (desc->irq_data.chip && desc->irq_data.chip->end)
+		desc->irq_data.chip->end(irq);
+}
+#else
+static inline void irq_end(unsigned int irq, struct irq_desc *desc) { }
+#endif
+
 /* Inline functions for support of irq chips on slow busses */
 static inline void chip_bus_lock(struct irq_desc *desc)
 {

commit 3876ec9ef3775d062345b3760d3271ecb8cd3fea
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 12:44:35 2010 +0000

    genirq: Provide compat handling for bus_lock/bus_sync_unlock
    
    Wrap the old chip functions for bus_lock/bus_sync_unlock until the
    migration is complete and the old chip functions are removed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20100927121841.842536121@linutronix.de>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 562fc7eeabec..ecafbfee5b12 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -43,16 +43,16 @@ extern int irq_select_affinity_usr(unsigned int irq);
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
 /* Inline functions for support of irq chips on slow busses */
-static inline void chip_bus_lock(unsigned int irq, struct irq_desc *desc)
+static inline void chip_bus_lock(struct irq_desc *desc)
 {
-	if (unlikely(desc->irq_data.chip->bus_lock))
-		desc->irq_data.chip->bus_lock(irq);
+	if (unlikely(desc->irq_data.chip->irq_bus_lock))
+		desc->irq_data.chip->irq_bus_lock(&desc->irq_data);
 }
 
-static inline void chip_bus_sync_unlock(unsigned int irq, struct irq_desc *desc)
+static inline void chip_bus_sync_unlock(struct irq_desc *desc)
 {
-	if (unlikely(desc->irq_data.chip->bus_sync_unlock))
-		desc->irq_data.chip->bus_sync_unlock(irq);
+	if (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))
+		desc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);
 }
 
 /*

commit a77c4635915021c646cc017f22239e66d1aab4d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 14:44:58 2010 +0200

    genirq: Add new functions to dummy chips
    
    The compat functions go away when the core code is converted.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index a805a00cfd28..562fc7eeabec 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -4,6 +4,8 @@
 
 extern int noirqdebug;
 
+#define irq_data_to_desc(data)	container_of(data, struct irq_desc, irq_data)
+
 /* Set default functions for irq_chip structures: */
 extern void irq_chip_set_defaults(struct irq_chip *chip);
 

commit 6b8ff3120c758340505dddf08ad685ebb841d5d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 12:58:38 2010 +0200

    genirq: Convert core code to irq_data
    
    Convert all references in the core code to orq, chip, handler_data,
    chip_data, msi_desc, affinity to irq_data.*
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c63f3bc88f0b..a805a00cfd28 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -43,14 +43,14 @@ extern void irq_set_thread_affinity(struct irq_desc *desc);
 /* Inline functions for support of irq chips on slow busses */
 static inline void chip_bus_lock(unsigned int irq, struct irq_desc *desc)
 {
-	if (unlikely(desc->chip->bus_lock))
-		desc->chip->bus_lock(irq);
+	if (unlikely(desc->irq_data.chip->bus_lock))
+		desc->irq_data.chip->bus_lock(irq);
 }
 
 static inline void chip_bus_sync_unlock(unsigned int irq, struct irq_desc *desc)
 {
-	if (unlikely(desc->chip->bus_sync_unlock))
-		desc->chip->bus_sync_unlock(irq);
+	if (unlikely(desc->irq_data.chip->bus_sync_unlock))
+		desc->irq_data.chip->bus_sync_unlock(irq);
 }
 
 /*
@@ -67,8 +67,8 @@ static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
 		irq, desc, desc->depth, desc->irq_count, desc->irqs_unhandled);
 	printk("->handle_irq():  %p, ", desc->handle_irq);
 	print_symbol("%s\n", (unsigned long)desc->handle_irq);
-	printk("->chip(): %p, ", desc->chip);
-	print_symbol("%s\n", (unsigned long)desc->chip);
+	printk("->irq_data.chip(): %p, ", desc->irq_data.chip);
+	print_symbol("%s\n", (unsigned long)desc->irq_data.chip);
 	printk("->action(): %p\n", desc->action);
 	if (desc->action) {
 		printk("->action->handler(): %p, ", desc->action->handler);

commit 99558f0bbe68cb09799ec38adbaa3f3b2dc7ba63
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 10 01:20:34 2010 -0800

    sparseirq: Change irq_desc_ptrs to static
    
    Add replace_irq_desc() instead of poking at the array directly.
    
    -v2: remove unneeded boundary check in replace_irq_desc
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-31-git-send-email-yinghai@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index b2821f070a3d..c63f3bc88f0b 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -21,11 +21,7 @@ extern void clear_kstat_irqs(struct irq_desc *desc);
 extern raw_spinlock_t sparse_irq_lock;
 
 #ifdef CONFIG_SPARSE_IRQ
-/* irq_desc_ptrs allocated at boot time */
-extern struct irq_desc **irq_desc_ptrs;
-#else
-/* irq_desc_ptrs is a fixed size array */
-extern struct irq_desc *irq_desc_ptrs[NR_IRQS];
+void replace_irq_desc(unsigned int irq, struct irq_desc *desc);
 #endif
 
 #ifdef CONFIG_PROC_FS

commit 239007b8440abff689632f50cdf0f2b9e895b534
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 17 16:46:45 2009 +0100

    genirq: Convert irq_desc.lock to raw_spinlock
    
    Convert locks which cannot be sleeping locks in preempt-rt to
    raw_spinlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 1b5d742c6a77..b2821f070a3d 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -18,7 +18,7 @@ extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 extern void clear_kstat_irqs(struct irq_desc *desc);
-extern spinlock_t sparse_irq_lock;
+extern raw_spinlock_t sparse_irq_lock;
 
 #ifdef CONFIG_SPARSE_IRQ
 /* irq_desc_ptrs allocated at boot time */

commit 70aedd24d20e75198f5a0b11750faabbb56924e2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 13 12:17:48 2009 +0200

    genirq: Add buslock support
    
    Some interrupt chips are connected to a "slow" bus (i2c, spi ...). The
    bus access needs to sleep and therefor cannot be called in atomic
    contexts.
    
    Some of the generic interrupt management functions like disable_irq(),
    enable_irq() ... call interrupt chip functions with the irq_desc->lock
    held and interrupts disabled. This does not work for such devices.
    
    Provide a separate synchronization mechanism for such interrupt
    chips. The irq_chip structure is extended by two optional functions
    (bus_lock and bus_sync_and_unlock).
    
    The idea is to serialize the bus access for those operations in the
    core code so that drivers which are behind that bus operated interrupt
    controller do not have to worry about it and just can use the normal
    interfaces. To achieve this we add two function pointers to the
    irq_chip: bus_lock and bus_sync_unlock.
    
    bus_lock() is called to serialize access to the interrupt controller
    bus.
    
    Now the core code can issue chip->mask/unmask ... commands without
    changing the fast path code at all. The chip implementation merily
    stores that information in a chip private data structure and
    returns. No bus interaction as these functions are called from atomic
    context.
    
    After that bus_sync_unlock() is called outside the atomic context. Now
    the chip implementation issues the bus commands, waits for completion
    and unlocks the interrupt controller bus.
    
    The irq_chip implementation as pseudo code:
    
    struct irq_chip_data {
           struct mutex   mutex;
           unsigned int   irq_offset;
           unsigned long  mask;
           unsigned long  mask_status;
    }
    
    static void bus_lock(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            mutex_lock(&data->mutex);
    }
    
    static void mask(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            irq -= data->irq_offset;
            data->mask |= (1 << irq);
    }
    
    static void unmask(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            irq -= data->irq_offset;
            data->mask &= ~(1 << irq);
    }
    
    static void bus_sync_unlock(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            if (data->mask != data->mask_status) {
                    do_bus_magic_to_set_mask(data->mask);
                    data->mask_status = data->mask;
            }
            mutex_unlock(&data->mutex);
    }
    
    The device drivers can use request_threaded_irq, free_irq, disable_irq
    and enable_irq as usual with the only restriction that the calls need
    to come from non atomic context.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Trilok Soni <soni.trilok@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Brian Swetland <swetland@google.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: m.szyprowski@samsung.com
    Cc: t.fujak@samsung.com
    Cc: kyungmin.park@samsung.com,
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: arve@android.com
    Cc: Barry Song <21cnbao@gmail.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e70ed5592eb9..1b5d742c6a77 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -44,6 +44,19 @@ extern int irq_select_affinity_usr(unsigned int irq);
 
 extern void irq_set_thread_affinity(struct irq_desc *desc);
 
+/* Inline functions for support of irq chips on slow busses */
+static inline void chip_bus_lock(unsigned int irq, struct irq_desc *desc)
+{
+	if (unlikely(desc->chip->bus_lock))
+		desc->chip->bus_lock(irq);
+}
+
+static inline void chip_bus_sync_unlock(unsigned int irq, struct irq_desc *desc)
+{
+	if (unlikely(desc->chip->bus_sync_unlock))
+		desc->chip->bus_sync_unlock(irq);
+}
+
 /*
  * Debugging printout:
  */

commit 591d2fb02ea80472d846c0b8507007806bdd69cc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 21 11:09:39 2009 +0200

    genirq: Delegate irq affinity setting to the irq thread
    
    irq_set_thread_affinity() calls set_cpus_allowed_ptr() which might
    sleep, but irq_set_thread_affinity() is called with desc->lock held
    and can be called from hard interrupt context as well. The code has
    another bug as it does not hold a ref on the task struct as required
    by set_cpus_allowed_ptr().
    
    Just set the IRQTF_AFFINITY bit in action->thread_flags. The next time
    the thread runs it migrates itself. Solves all of the above problems
    nicely.
    
    Add kerneldoc to irq_set_thread_affinity() while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <new-submission>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 73468253143b..e70ed5592eb9 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -42,8 +42,7 @@ static inline void unregister_handler_proc(unsigned int irq,
 
 extern int irq_select_affinity_usr(unsigned int irq);
 
-extern void
-irq_set_thread_affinity(struct irq_desc *desc, const struct cpumask *cpumask);
+extern void irq_set_thread_affinity(struct irq_desc *desc);
 
 /*
  * Debugging printout:

commit 85ac16d033370caf6f48d743c8dc8103700f5cc5
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 18:00:38 2009 -0700

    x86/irq: change irq_desc_alloc() to take node instead of cpu
    
    This simplifies the node awareness of the code. All our allocators
    only deal with a NUMA node ID locality not with CPU ids anyway - so
    there's no need to maintain (and transform) a CPU id all across the
    IRq layer.
    
    v2: keep move_irq_desc related
    
    [ Impact: cleanup, prepare IRQ code to be NUMA-aware ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    LKML-Reference: <49F65536.2020300@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index de5f412f6a92..73468253143b 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -16,7 +16,7 @@ extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
 extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
 extern struct lock_class_key irq_desc_lock_class;
-extern void init_kstat_irqs(struct irq_desc *desc, int cpu, int nr);
+extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
 extern void clear_kstat_irqs(struct irq_desc *desc);
 extern spinlock_t sparse_irq_lock;
 

commit 57b150cce8e004ddd36330490a68bfb59b7271e9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 17:59:53 2009 -0700

    irq: only update affinity if ->set_affinity() is sucessfull
    
    irq_set_affinity() and move_masked_irq() try to assign affinity
    before calling chip set_affinity(). Some archs are assigning it
    in ->set_affinity() again.
    
    We do something like:
    
     cpumask_cpy(desc->affinity, mask);
     desc->chip->set_affinity(mask);
    
    But in the failure path, affinity should not be touched - otherwise
    we'll end up with a different affinity mask despite the failure to
    migrate the IRQ.
    
    So try to update the afffinity only if set_affinity returns with 0.
    Also call irq_set_thread_affinity accordingly.
    
    v2: update after "irq, x86: Remove IRQ_DISABLED check in process context IRQ move"
    v3: according to Ingo, change set_affinity() in irq_chip should return int.
    v4: update comments by removing moving irq_desc code.
    
    [ Impact: fix /proc/irq/*/smp_affinity setting corner case bug ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49F65509.60307@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 01ce20eab38f..de5f412f6a92 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -42,6 +42,9 @@ static inline void unregister_handler_proc(unsigned int irq,
 
 extern int irq_select_affinity_usr(unsigned int irq);
 
+extern void
+irq_set_thread_affinity(struct irq_desc *desc, const struct cpumask *cpumask);
+
 /*
  * Debugging printout:
  */

commit 0a0c5168df270a50e3518e4f12bddb31f8f5f38f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:33:49 2009 +0100

    PM: Introduce functions for suspending and resuming device interrupts
    
    Introduce helper functions allowing us to prevent device drivers from
    getting any interrupts (without disabling interrupts on the CPU)
    during suspend (or hibernation) and to make them start to receive
    interrupts again during the subsequent resume.  These functions make it
    possible to keep timer interrupts enabled while the "late" suspend and
    "early" resume callbacks provided by device drivers are being
    executed.  In turn, this allows device drivers' "late" suspend and
    "early" resume callbacks to sleep, execute ACPI callbacks etc.
    
    The functions introduced here will be used to rework the handling of
    interrupts during suspend (hibernation) and resume.  Namely,
    interrupts will only be disabled on the CPU right before suspending
    sysdevs, while device drivers will be prevented from receiving
    interrupts, with the help of the new helper function, before their
    "late" suspend callbacks run (and analogously during resume).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index ee1aa9f8e8b9..01ce20eab38f 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -12,6 +12,8 @@ extern void compat_irq_chip_set_default_handler(struct irq_desc *desc);
 
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
+extern void __disable_irq(struct irq_desc *desc, unsigned int irq, bool susp);
+extern void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume);
 
 extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int cpu, int nr);

commit 6e15cf04860074ad032e88c306bea656bbdd0f22
Merge: be0ea69674ed 60db56422043
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 26 21:39:17 2009 +0100

    Merge branch 'core/percpu' into percpu-cpumask-x86-for-linus-2
    
    Conflicts:
            arch/parisc/kernel/irq.c
            arch/x86/include/asm/fixmap_64.h
            arch/x86/include/asm/setup.h
            kernel/irq/handle.c
    
    Semantic merge:
            arch/x86/include/asm/fixmap.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 0f3c2a89c1451cdf6328f99977bd9decd4f708e1
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Feb 8 16:18:03 2009 -0800

    irq: clear kstat_irqs
    
    Impact: get correct kstat_irqs [/proc/interrupts] for msi/msi-x etc
    
    need to call clear_kstat_irqs(), so when we reuse that irq_desc,
    we get correct kstat in /proc/interrupts.
    
    This makes /proc/interrupts not have <NULL> entries.
    
    Don't need to worry about arch that doesn't support genirq, because they
    will not call dynamic_irq_cleanup().
    
    v2: simplify and make clear_kstat_irqs more robust
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e6d0a43cc125..b60950bf5a16 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -15,6 +15,7 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 
 extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int cpu, int nr);
+extern void clear_kstat_irqs(struct irq_desc *desc);
 extern spinlock_t sparse_irq_lock;
 extern struct irq_desc *irq_desc_ptrs[NR_IRQS];
 

commit 0fa0ebbf15addc1be8f73325d809c8547a9de304
Author: Mike Travis <travis@sgi.com>
Date:   Sat Jan 10 22:24:06 2009 -0800

    irq: allocate irq_desc_ptrs array based on nr_irqs
    
    Impact: allocate irq_desc_ptrs in preparation for making it variable-sized.
    
    This addresses this memory usage bump when NR_CPUS bumped from 128 to 4096:
    
        34816   +229376    264192  +658%  irq_desc_ptrs(.data.read_mostly)
    
    The patch is split into two parts, the first simply allocates the
    irq_desc_ptrs array.  Then next will deal with making it variable.
    This is only when CONFIG_SPARSE_IRQS=y.
    
    Signed-off-by: Mike Travis <travis@sgi.com>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index e6d0a43cc125..40416a81a0f5 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -16,7 +16,14 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 extern struct lock_class_key irq_desc_lock_class;
 extern void init_kstat_irqs(struct irq_desc *desc, int cpu, int nr);
 extern spinlock_t sparse_irq_lock;
+
+#ifdef CONFIG_SPARSE_IRQ
+/* irq_desc_ptrs allocated at boot time */
+extern struct irq_desc **irq_desc_ptrs;
+#else
+/* irq_desc_ptrs is a fixed size array */
 extern struct irq_desc *irq_desc_ptrs[NR_IRQS];
+#endif
 
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);

commit 48a1b10aff588833b73994704c47bbd0deb73e9c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Dec 11 00:15:01 2008 -0800

    x86, sparseirq: move irq_desc according to smp_affinity, v7
    
    Impact: improve NUMA handling by migrating irq_desc on smp_affinity changes
    
    if CONFIG_NUMA_MIGRATE_IRQ_DESC is set:
    
    -  make irq_desc to go with affinity aka irq_desc moving etc
    -  call move_irq_desc in irq_complete_move()
    -  legacy irq_desc is not moved, because they are allocated via static array
    
    for logical apic mode, need to add move_desc_in_progress_in_same_domain,
    otherwise it will not be moved ==> also could need two phases to get
    irq_desc moved.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 64c1c7253dae..e6d0a43cc125 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -13,6 +13,11 @@ extern void compat_irq_chip_set_default_handler(struct irq_desc *desc);
 extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
 
+extern struct lock_class_key irq_desc_lock_class;
+extern void init_kstat_irqs(struct irq_desc *desc, int cpu, int nr);
+extern spinlock_t sparse_irq_lock;
+extern struct irq_desc *irq_desc_ptrs[NR_IRQS];
+
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);
 extern void register_handler_proc(unsigned int irq, struct irqaction *action);

commit f6d87f4bd259cf33e092cd1a8fde05f291c47af1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Nov 7 13:18:30 2008 +0100

    genirq: keep affinities set from userspace across free/request_irq()
    
    Impact: preserve user-modified affinities on interrupts
    
    Kumar Galak noticed that commit
    18404756765c713a0be4eb1082920c04822ce588 (genirq: Expose default irq
    affinity mask (take 3))
    
    overrides an already set affinity setting across a free /
    request_irq(). Happens e.g. with ifdown/ifup of a network device.
    
    Change the logic to mark the affinities as set and keep them
    intact. This also fixes the unlocked access to irq_desc in
    irq_select_affinity() when called from irq_affinity_proc_write()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index c9767e641980..64c1c7253dae 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -25,6 +25,8 @@ static inline void unregister_handler_proc(unsigned int irq,
 					   struct irqaction *action) { }
 #endif
 
+extern int irq_select_affinity_usr(unsigned int irq);
+
 /*
  * Debugging printout:
  */

commit 2c6927a38f65b53b62f86158fba29a068c4e8b6a
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:11 2008 -0700

    irq: replace loop with nr_irqs with for_each_irq_desc
    
    There are a handful of loops that go from 0 to nr_irqs and use
    get_irq_desc() on them. These would allocate all the irq_desc
    entries, regardless of the need for them.
    
    Use the smarter for_each_irq_desc() iterator that will only iterate
    over the present ones.
    
    v2: make sure arch without GENERIC_HARDIRQS work too
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 422dd00c8bd3..c9767e641980 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -14,11 +14,11 @@ extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
 		unsigned long flags);
 
 #ifdef CONFIG_PROC_FS
-extern void register_irq_proc(unsigned int irq);
+extern void register_irq_proc(unsigned int irq, struct irq_desc *desc);
 extern void register_handler_proc(unsigned int irq, struct irqaction *action);
 extern void unregister_handler_proc(unsigned int irq, struct irqaction *action);
 #else
-static inline void register_irq_proc(unsigned int irq) { }
+static inline void register_irq_proc(unsigned int irq, struct irq_desc *desc) { }
 static inline void register_handler_proc(unsigned int irq,
 					 struct irqaction *action) { }
 static inline void unregister_handler_proc(unsigned int irq,

commit 0c5d1eb77a8be917b638344a22afe1398236482b
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Oct 1 14:46:18 2008 -0700

    genirq: record trigger type
    
    Genirq hasn't previously recorded the trigger type used by any given IRQ,
    although some irq_chip support has done so.  That data can be useful when
    troubleshooting.  This patch records it in the relevant irq_desc.status
    bits, and improves consistency between the two driver-visible calls
    affected:
    
     - Make set_irq_type() usage match request_irq() usage:
        * IRQ_TYPE_NONE should be a NOP; succeed, so irq_chip methods
          won't have to handle that case any more (many do it wrong).
        * IRQ_TYPE_PROBE is ignored; any buggy out-of-tree callers
          might need to switch over to the real IRQ probing code.
        * emit the same diagnostics (from shared utility code)
    
     - Their kerneldoc now reflects usage:
        * request_irq() flags include IRQF_TRIGGER_* to specify
          active edge(s)/level ... docs previously omitted that
        * set_irq_type() is declared in <linux/irq.h> so callers
          should use the (bit-equivalent) IRQ_TYPE_* symbols there
    
    Also: adds a warning about shared IRQs that don't end up using the
    requested trigger mode; and fix an unrelated "sparse" warning.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 08a849a22447..422dd00c8bd3 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -10,6 +10,9 @@ extern void irq_chip_set_defaults(struct irq_chip *chip);
 /* Set default handler: */
 extern void compat_irq_chip_set_default_handler(struct irq_desc *desc);
 
+extern int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,
+		unsigned long flags);
+
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq);
 extern void register_handler_proc(unsigned int irq, struct irqaction *action);

commit 43f7775944e40221827e4b3aec43824aa4c4e4a9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:58 2006 -0700

    [PATCH] genirq: more verbose debugging on unexpected IRQ vectors
    
    One frequent sign of IRQ handling bugs is the appearance of unexpected
    vectors.  Print out all the IRQ state in that case.  We dont want this patch
    upstream, but it is useful during initial testing.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 2ba8ae3c8e96..08a849a22447 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -22,3 +22,43 @@ static inline void unregister_handler_proc(unsigned int irq,
 					   struct irqaction *action) { }
 #endif
 
+/*
+ * Debugging printout:
+ */
+
+#include <linux/kallsyms.h>
+
+#define P(f) if (desc->status & f) printk("%14s set\n", #f)
+
+static inline void print_irq_desc(unsigned int irq, struct irq_desc *desc)
+{
+	printk("irq %d, desc: %p, depth: %d, count: %d, unhandled: %d\n",
+		irq, desc, desc->depth, desc->irq_count, desc->irqs_unhandled);
+	printk("->handle_irq():  %p, ", desc->handle_irq);
+	print_symbol("%s\n", (unsigned long)desc->handle_irq);
+	printk("->chip(): %p, ", desc->chip);
+	print_symbol("%s\n", (unsigned long)desc->chip);
+	printk("->action(): %p\n", desc->action);
+	if (desc->action) {
+		printk("->action->handler(): %p, ", desc->action->handler);
+		print_symbol("%s\n", (unsigned long)desc->action->handler);
+	}
+
+	P(IRQ_INPROGRESS);
+	P(IRQ_DISABLED);
+	P(IRQ_PENDING);
+	P(IRQ_REPLAY);
+	P(IRQ_AUTODETECT);
+	P(IRQ_WAITING);
+	P(IRQ_LEVEL);
+	P(IRQ_MASKED);
+#ifdef CONFIG_IRQ_PER_CPU
+	P(IRQ_PER_CPU);
+#endif
+	P(IRQ_NOPROBE);
+	P(IRQ_NOREQUEST);
+	P(IRQ_NOAUTOEN);
+}
+
+#undef P
+

commit 6a6de9ef5850d063c3d3fb50784bfe3a6d0712c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:51 2006 -0700

    [PATCH] genirq: core
    
    Core genirq support: add the irq-chip and irq-flow abstractions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 46feba630266..2ba8ae3c8e96 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -4,6 +4,12 @@
 
 extern int noirqdebug;
 
+/* Set default functions for irq_chip structures: */
+extern void irq_chip_set_defaults(struct irq_chip *chip);
+
+/* Set default handler: */
+extern void compat_irq_chip_set_default_handler(struct irq_desc *desc);
+
 #ifdef CONFIG_PROC_FS
 extern void register_irq_proc(unsigned int irq);
 extern void register_handler_proc(unsigned int irq, struct irqaction *action);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
new file mode 100644
index 000000000000..46feba630266
--- /dev/null
+++ b/kernel/irq/internals.h
@@ -0,0 +1,18 @@
+/*
+ * IRQ subsystem internal functions and variables:
+ */
+
+extern int noirqdebug;
+
+#ifdef CONFIG_PROC_FS
+extern void register_irq_proc(unsigned int irq);
+extern void register_handler_proc(unsigned int irq, struct irqaction *action);
+extern void unregister_handler_proc(unsigned int irq, struct irqaction *action);
+#else
+static inline void register_irq_proc(unsigned int irq) { }
+static inline void register_handler_proc(unsigned int irq,
+					 struct irqaction *action) { }
+static inline void unregister_handler_proc(unsigned int irq,
+					   struct irqaction *action) { }
+#endif
+
