commit 3a79bc63d90750f737ab9d7219bd3091d2fd6d84
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 13:03:20 2019 +0200

    PCI: irq: Introduce rearm_wake_irq()
    
    Introduce a new function, rearm_wake_irq(), allowing a wakeup IRQ
    to be armed for systen wakeup detection again without running any
    action handlers associated with it after it has been armed for
    wakeup detection and triggered.
    
    That is useful for IRQs, like ACPI SCI, that may deliver wakeup
    as well as non-wakeup interrupts when armed for systen wakeup
    detection.  In those cases, it may be possible to determine whether
    or not the delivered interrupt is a systen wakeup one without
    running the entire action handler (or handlers, if the IRQ is
    shared) for the IRQ, and if the interrupt turns out to be a
    non-wakeup one, the IRQ can be rearmed with the help of the
    new function.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index d6961d3c6f9e..8f557fa1f4fe 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -176,6 +176,26 @@ static void resume_irqs(bool want_early)
 	}
 }
 
+/**
+ * rearm_wake_irq - rearm a wakeup interrupt line after signaling wakeup
+ * @irq: Interrupt to rearm
+ */
+void rearm_wake_irq(unsigned int irq)
+{
+	unsigned long flags;
+	struct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);
+
+	if (!desc || !(desc->istate & IRQS_SUSPENDED) ||
+	    !irqd_is_wakeup_set(&desc->irq_data))
+		return;
+
+	desc->istate &= ~IRQS_SUSPENDED;
+	irqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);
+	__enable_irq(desc);
+
+	irq_put_desc_busunlock(desc, flags);
+}
+
 /**
  * irq_pm_syscore_ops - enable interrupt lines early
  *

commit 52a65ff5603e685e9b19c2e108b3f0826dc7a86b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 14 22:15:19 2018 +0100

    genirq: Add missing SPDX identifiers
    
    Add SPDX identifiers to files
    
     - which contain an explicit license boiler plate or reference
    
     - which do not contain a license reference and were not updated in the
       initial SPDX conversion because the license was deduced by the scanners
       via EXPORT_SYMBOL_GPL as GPL2.0 only.
    
    [ tglx: Moved adding identifiers from the patch which removes the
            references/boilerplate ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Link: https://lkml.kernel.org/r/20180314212030.668321222@linutronix.de

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 474d3fa32a28..d6961d3c6f9e 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  *

commit 99bfce5db9c071800bdc7e9658a68e6d11aeecf6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 14 22:15:16 2018 +0100

    genirq: Cleanup top of file comments
    
    Remove pointless references to the file name itself and condense the
    information so it wastes less space.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Link: https://lkml.kernel.org/r/20180314212030.412095827@linutronix.de

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 6bd9b58429cc..474d3fa32a28 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -1,6 +1,4 @@
 /*
- * linux/kernel/irq/pm.c
- *
  * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  *
  * This file contains power management functions related to interrupts.

commit a696712c3dd54eb58d2c5a807b4aaa27782d80d6
Author: Juergen Gross <jgross@suse.com>
Date:   Mon Jul 17 19:47:02 2017 +0200

    genirq/PM: Properly pretend disabled state when force resuming interrupts
    
    Interrupts with the IRQF_FORCE_RESUME flag set have also the
    IRQF_NO_SUSPEND flag set. They are not disabled in the suspend path, but
    must be forcefully resumed. That's used by XEN to keep IPIs enabled beyond
    the suspension of device irqs. Force resume works by pretending that the
    interrupt was disabled and then calling __irq_enable().
    
    Incrementing the disabled depth counter was enough to do that, but with the
    recent changes which use state flags to avoid unnecessary hardware access,
    this is not longer sufficient. If the state flags are not set, then the
    hardware callbacks are not invoked and the interrupt line stays disabled in
    "hardware".
    
    Set the disabled and masked state when pretending that an interrupt got
    disabled by suspend.
    
    Fixes: bf22ff45bed6 ("genirq: Avoid unnecessary low level irq function calls")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: xen-devel@lists.xenproject.org
    Cc: boris.ostrovsky@oracle.com
    Link: http://lkml.kernel.org/r/20170717174703.4603-2-jgross@suse.com

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index cea1de0161f1..6bd9b58429cc 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -149,6 +149,8 @@ static void resume_irq(struct irq_desc *desc)
 
 	/* Pretend that it got disabled ! */
 	desc->depth++;
+	irq_state_set_disabled(desc);
+	irq_state_set_masked(desc);
 resume:
 	desc->istate &= ~IRQS_SUSPENDED;
 	__enable_irq(desc);

commit 511601bdbcacd3ab615564941409bf012435b23d
Merge: b84da9fa47cf 4717f133736d 22b886dd1018
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 15 09:30:48 2015 -0800

    Merge branches 'irq-urgent-for-linus' and 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq and timer fixes from Thomas Gleixner:
    
     - An irq regression fix to restore the wakeup behaviour of chained
       interrupts.
    
     - A timer fix for a long standing race versus timers scheduled on a
       target cpu which got exposed by recent changes in the workqueue
       implementation.
    
    * 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      genirq/PM: Restore system wake up from chained interrupts
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers: Use proper base migration in add_timer_on()

commit 4717f133736dec10605da9e29e707144c8d486df
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Nov 10 11:58:12 2015 +0200

    genirq/PM: Restore system wake up from chained interrupts
    
    Commit e509bd7da149 ("genirq: Allow migration of chained interrupts
    by installing default action") breaks PCS wake up IRQ behaviour on
    TI OMAP based platforms (dra7-evm).
    
    TI OMAP IRQ wake up configuration:
    GIC-irqchip->PCM_IRQ
      |- omap_prcm_register_chain_handler
         |- PRCM-irqchip -> PRCM_IO_IRQ
            |- pcs_irq_chain_handler
               |- pinctrl-irqchip -> PCS_uart1_wakeup_irq
    
    This happens because IRQ PM code (irq/pm.c) is expected to ignore
    chained interrupts by default:
      static bool suspend_device_irq(struct irq_desc *desc)
      {
            if (!desc->action || desc->no_suspend_depth)
                    return false;
     - it's expected !desc->action = true for chained interrupts;
    
    but, after above change, all chained interrupt descriptors will
    have default action handler installed - chained_action.
    As result, chained interrupts will be silently disabled during system
    suspend.
    
    Hence, fix it by introducing helper function irq_desc_is_chained() and
    use it in suspend_device_irq() for chained interrupts identification
    and skip them, once detected.
    
    Fixes: e509bd7da149 ("genirq: Allow migration of chained interrupts..")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: <nsekhar@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/1447149492-20699-1-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 21c62617a35a..84ab239a00e2 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -70,7 +70,8 @@ void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
 
 static bool suspend_device_irq(struct irq_desc *desc)
 {
-	if (!desc->action || desc->no_suspend_depth)
+	if (!desc->action || irq_desc_is_chained(desc) ||
+	    desc->no_suspend_depth)
 		return false;
 
 	if (irqd_is_wakeup_set(&desc->irq_data)) {

commit a6f5f0dd4e21191ce35030dd4d6421e1cca10ee4
Author: Alexandra Yates <alexandra.yates@linux.intel.com>
Date:   Tue Sep 15 10:32:46 2015 -0700

    PM / sleep: Report interrupt that caused system wakeup
    
    Add a sysfs attribute, /sys/power/pm_wakeup_irq, reporting the IRQ
    number of the first wakeup interrupt (that is, the first interrupt
    from an IRQ line armed for system wakeup) seen by the kernel during
    the most recent system suspend/resume cycle.
    
    This feature will be useful for system wakeup diagnostics of
    spurious wakeup interrupts.
    
    Signed-off-by: Alexandra Yates <alexandra.yates@linux.intel.com>
    [ rjw: Fixed up pm_wakeup_irq definition ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 21c62617a35a..e80c4400118a 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -21,7 +21,7 @@ bool irq_pm_check_wakeup(struct irq_desc *desc)
 		desc->istate |= IRQS_SUSPENDED | IRQS_PENDING;
 		desc->depth++;
 		irq_disable(desc);
-		pm_system_wakeup();
+		pm_system_irq_wakeup(irq_desc_get_irq(desc));
 		return true;
 	}
 	return false;

commit b80f5f3fc0dc5362eac19585c31a1cc414a6cf95
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jun 23 19:58:45 2015 +0200

    genirq: Remove irq argument from suspend/resume_irq()
    
    Unused argument in both functions.
    
    [ tglx: Split out from combo patch ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 0e1c617f8d5f..21c62617a35a 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -68,7 +68,7 @@ void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
 		desc->cond_suspend_depth--;
 }
 
-static bool suspend_device_irq(struct irq_desc *desc, int irq)
+static bool suspend_device_irq(struct irq_desc *desc)
 {
 	if (!desc->action || desc->no_suspend_depth)
 		return false;
@@ -126,7 +126,7 @@ void suspend_device_irqs(void)
 		if (irq_settings_is_nested_thread(desc))
 			continue;
 		raw_spin_lock_irqsave(&desc->lock, flags);
-		sync = suspend_device_irq(desc, irq);
+		sync = suspend_device_irq(desc);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
 
 		if (sync)
@@ -135,7 +135,7 @@ void suspend_device_irqs(void)
 }
 EXPORT_SYMBOL_GPL(suspend_device_irqs);
 
-static void resume_irq(struct irq_desc *desc, int irq)
+static void resume_irq(struct irq_desc *desc)
 {
 	irqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);
 
@@ -169,7 +169,7 @@ static void resume_irqs(bool want_early)
 			continue;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
-		resume_irq(desc, irq);
+		resume_irq(desc);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 }

commit 79ff1cda320b81dfe5feae0c5da52f029561ce93
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jun 23 19:52:36 2015 +0200

    genirq: Remove irq argument from __enable/__disable_irq()
    
    Solely used for debug output. Can be retrieved from irq descriptor if
    necessary.
    
    [ tglx: Split out from combo patch ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index d22786a6dbde..0e1c617f8d5f 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -85,7 +85,7 @@ static bool suspend_device_irq(struct irq_desc *desc, int irq)
 	}
 
 	desc->istate |= IRQS_SUSPENDED;
-	__disable_irq(desc, irq);
+	__disable_irq(desc);
 
 	/*
 	 * Hardware which has no wakeup source configuration facility
@@ -150,7 +150,7 @@ static void resume_irq(struct irq_desc *desc, int irq)
 	desc->depth++;
 resume:
 	desc->istate &= ~IRQS_SUSPENDED;
-	__enable_irq(desc, irq);
+	__enable_irq(desc);
 }
 
 static void resume_irqs(bool want_early)

commit 3c646f2c6aa9e918d7fc77867df7f430059f9ccc
Author: NeilBrown <neilb@suse.de>
Date:   Sun May 17 15:19:34 2015 +1000

    genirq: Don't suspend nested_thread irqs over system suspend
    
    Nested IRQs can only fire when the parent irq fires.  So when the
    parent is suspended, there is no need to suspend the child irq.
    
    Suspending nested irqs can cause a problem is they are suspended or
    resumed in the wrong order.  If an interrupt fires while the parent is
    active but the child is suspended, then the interrupt will not be
    acknowledged properly and so an interrupt storm can result.  This is
    particularly likely if the parent is resumed before the child, and the
    interrupt was raised during suspend.
    
    Ensuring correct ordering would be possible, but it is simpler to just
    never suspend nested interrupts.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Cc: GTA04 owners <gta04-owner@goldelico.com>
    Cc: Kalle Jokiniemi <kalle.jokiniemi@jollamobile.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/20150517151934.2393e8f8@notabene.brown
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 5204a6d1b985..d22786a6dbde 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -123,6 +123,8 @@ void suspend_device_irqs(void)
 		unsigned long flags;
 		bool sync;
 
+		if (irq_settings_is_nested_thread(desc))
+			continue;
 		raw_spin_lock_irqsave(&desc->lock, flags);
 		sync = suspend_device_irq(desc, irq);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
@@ -163,6 +165,8 @@ static void resume_irqs(bool want_early)
 
 		if (!is_early && want_early)
 			continue;
+		if (irq_settings_is_nested_thread(desc))
+			continue;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
 		resume_irq(desc, irq);

commit 17f480342026e54000731acaa69bf32787ce46cb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 27 00:07:55 2015 +0100

    genirq / PM: Add flag for shared NO_SUSPEND interrupt lines
    
    It currently is required that all users of NO_SUSPEND interrupt
    lines pass the IRQF_NO_SUSPEND flag when requesting the IRQ or the
    WARN_ON_ONCE() in irq_pm_install_action() will trigger.  That is
    done to warn about situations in which unprepared interrupt handlers
    may be run unnecessarily for suspended devices and may attempt to
    access those devices by mistake.  However, it may cause drivers
    that have no technical reasons for using IRQF_NO_SUSPEND to set
    that flag just because they happen to share the interrupt line
    with something like a timer.
    
    Moreover, the generic handling of wakeup interrupts introduced by
    commit 9ce7a25849e8 (genirq: Simplify wakeup mechanism) only works
    for IRQs without any NO_SUSPEND users, so the drivers of wakeup
    devices needing to use shared NO_SUSPEND interrupt lines for
    signaling system wakeup generally have to detect wakeup in their
    interrupt handlers.  Thus if they happen to share an interrupt line
    with a NO_SUSPEND user, they also need to request that their
    interrupt handlers be run after suspend_device_irqs().
    
    In both cases the reason for using IRQF_NO_SUSPEND is not because
    the driver in question has a genuine need to run its interrupt
    handler after suspend_device_irqs(), but because it happens to
    share the line with some other NO_SUSPEND user.  Otherwise, the
    driver would do without IRQF_NO_SUSPEND just fine.
    
    To make it possible to specify that condition explicitly, introduce
    a new IRQ action handler flag for shared IRQs, IRQF_COND_SUSPEND,
    that, when set, will indicate to the IRQ core that the interrupt
    user is generally fine with suspending the IRQ, but it also can
    tolerate handler invocations after suspend_device_irqs() and, in
    particular, it is capable of detecting system wakeup and triggering
    it as appropriate from its interrupt handler.
    
    That will allow us to work around a problem with a shared timer
    interrupt line on at91 platforms.
    
    Link: http://marc.info/?l=linux-kernel&m=142252777602084&w=2
    Link: http://marc.info/?t=142252775300011&r=1&w=2
    Link: https://lkml.org/lkml/2014/12/15/552
    Reported-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 3ca532592704..5204a6d1b985 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -43,9 +43,12 @@ void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)
 
 	if (action->flags & IRQF_NO_SUSPEND)
 		desc->no_suspend_depth++;
+	else if (action->flags & IRQF_COND_SUSPEND)
+		desc->cond_suspend_depth++;
 
 	WARN_ON_ONCE(desc->no_suspend_depth &&
-		     desc->no_suspend_depth != desc->nr_actions);
+		     (desc->no_suspend_depth +
+			desc->cond_suspend_depth) != desc->nr_actions);
 }
 
 /*
@@ -61,6 +64,8 @@ void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
 
 	if (action->flags & IRQF_NO_SUSPEND)
 		desc->no_suspend_depth--;
+	else if (action->flags & IRQF_COND_SUSPEND)
+		desc->cond_suspend_depth--;
 }
 
 static bool suspend_device_irq(struct irq_desc *desc, int irq)

commit 9ce7a25849e80cfb264f4995f832b932c1987e1a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 29 14:00:16 2014 +0200

    genirq: Simplify wakeup mechanism
    
    Currently we suspend wakeup interrupts by lazy disabling them and
    check later whether the interrupt has fired, but that's not sufficient
    for suspend to idle as there is no way to check that once we
    transitioned into the CPU idle state.
    
    So we change the mechanism in the following way:
    
    1) Leave the wakeup interrupts enabled across suspend
    
    2) Add a check to irq_may_run() which is called at the beginning of
       each flow handler whether the interrupt is an armed wakeup source.
    
       This check is basically free as it just extends the existing check
       for IRQD_IRQ_INPROGRESS. So no new conditional in the hot path.
    
       If the IRQD_WAKEUP_ARMED flag is set, then the interrupt is
       disabled, marked as pending/suspended and the pm core is notified
       about the wakeup event.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ rjw: syscore.c and put irq_pm_check_wakeup() into pm.c ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 766930eaeed9..3ca532592704 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -9,10 +9,24 @@
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include <linux/suspend.h>
 #include <linux/syscore_ops.h>
 
 #include "internals.h"
 
+bool irq_pm_check_wakeup(struct irq_desc *desc)
+{
+	if (irqd_is_wakeup_armed(&desc->irq_data)) {
+		irqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);
+		desc->istate |= IRQS_SUSPENDED | IRQS_PENDING;
+		desc->depth++;
+		irq_disable(desc);
+		pm_system_wakeup();
+		return true;
+	}
+	return false;
+}
+
 /*
  * Called from __setup_irq() with desc->lock held after @action has
  * been installed in the action chain.
@@ -54,8 +68,16 @@ static bool suspend_device_irq(struct irq_desc *desc, int irq)
 	if (!desc->action || desc->no_suspend_depth)
 		return false;
 
-	if (irqd_is_wakeup_set(&desc->irq_data))
+	if (irqd_is_wakeup_set(&desc->irq_data)) {
 		irqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);
+		/*
+		 * We return true here to force the caller to issue
+		 * synchronize_irq(). We need to make sure that the
+		 * IRQD_WAKEUP_ARMED is visible before we return from
+		 * suspend_device_irqs().
+		 */
+		return true;
+	}
 
 	desc->istate |= IRQS_SUSPENDED;
 	__disable_irq(desc, irq);
@@ -79,9 +101,13 @@ static bool suspend_device_irq(struct irq_desc *desc, int irq)
  * for this purpose.
  *
  * So we disable all interrupts and mark them IRQS_SUSPENDED except
- * for those which are unused and those which are marked as not
+ * for those which are unused, those which are marked as not
  * suspendable via an interrupt request with the flag IRQF_NO_SUSPEND
- * set.
+ * set and those which are marked as active wakeup sources.
+ *
+ * The active wakeup sources are handled by the flow handler entry
+ * code which checks for the IRQD_WAKEUP_ARMED flag, suspends the
+ * interrupt and notifies the pm core about the wakeup.
  */
 void suspend_device_irqs(void)
 {
@@ -173,26 +199,3 @@ void resume_device_irqs(void)
 	resume_irqs(false);
 }
 EXPORT_SYMBOL_GPL(resume_device_irqs);
-
-/**
- * check_wakeup_irqs - check if any wake-up interrupts are pending
- */
-int check_wakeup_irqs(void)
-{
-	struct irq_desc *desc;
-	int irq;
-
-	for_each_irq_desc(irq, desc) {
-		/*
-		 * Only interrupts which are marked as wakeup source
-		 * and have not been disabled before the suspend check
-		 * can abort suspend.
-		 */
-		if (irqd_is_wakeup_set(&desc->irq_data)) {
-			if (desc->depth == 1 && desc->istate & IRQS_PENDING)
-				return -EBUSY;
-		}
-	}
-
-	return 0;
-}

commit b76f16748fa61801b1a1fd3ffb6f25ee228a35e0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 29 13:54:09 2014 +0200

    genirq: Mark wakeup sources as armed on suspend
    
    This allows us to utilize this information in the irq_may_run() check
    without adding another conditional to the fast path.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index cf0ce0163db9..766930eaeed9 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -54,6 +54,9 @@ static bool suspend_device_irq(struct irq_desc *desc, int irq)
 	if (!desc->action || desc->no_suspend_depth)
 		return false;
 
+	if (irqd_is_wakeup_set(&desc->irq_data))
+		irqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);
+
 	desc->istate |= IRQS_SUSPENDED;
 	__disable_irq(desc, irq);
 
@@ -101,6 +104,8 @@ EXPORT_SYMBOL_GPL(suspend_device_irqs);
 
 static void resume_irq(struct irq_desc *desc, int irq)
 {
+	irqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);
+
 	if (desc->istate & IRQS_SUSPENDED)
 		goto resume;
 

commit c4df606c40c3ac8ba76ad11fdbb10139f7fbb261
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 22:50:43 2014 +0200

    genirq: Avoid double loop on suspend
    
    We can synchronize the suspended interrupts right away. No need for an
    extra loop.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index a21b3dc9825a..cf0ce0163db9 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -49,10 +49,10 @@ void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
 		desc->no_suspend_depth--;
 }
 
-static void suspend_device_irq(struct irq_desc *desc, int irq)
+static bool suspend_device_irq(struct irq_desc *desc, int irq)
 {
 	if (!desc->action || desc->no_suspend_depth)
-		return;
+		return false;
 
 	desc->istate |= IRQS_SUSPENDED;
 	__disable_irq(desc, irq);
@@ -65,6 +65,7 @@ static void suspend_device_irq(struct irq_desc *desc, int irq)
 	 */
 	if (irq_desc_get_chip(desc)->flags & IRQCHIP_MASK_ON_SUSPEND)
 		mask_irq(desc);
+	return true;
 }
 
 /**
@@ -86,15 +87,15 @@ void suspend_device_irqs(void)
 
 	for_each_irq_desc(irq, desc) {
 		unsigned long flags;
+		bool sync;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
-		suspend_device_irq(desc, irq);
+		sync = suspend_device_irq(desc, irq);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
-	}
 
-	for_each_irq_desc(irq, desc)
-		if (desc->istate & IRQS_SUSPENDED)
+		if (sync)
 			synchronize_irq(irq);
+	}
 }
 EXPORT_SYMBOL_GPL(suspend_device_irqs);
 

commit 092fadd59b50208f6859f89dd7ea84e03955b544
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 16:49:43 2014 +0200

    genirq: Move MASK_ON_SUSPEND handling into suspend_device_irqs()
    
    There is no reason why we should delay the masking of interrupts whose
    interrupt chip requests MASK_ON_SUSPEND to the point where we check
    the wakeup interrupts. We can do it right at the point where we mark
    the interrupt as suspended.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 74ca6bb541d5..a21b3dc9825a 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -56,6 +56,15 @@ static void suspend_device_irq(struct irq_desc *desc, int irq)
 
 	desc->istate |= IRQS_SUSPENDED;
 	__disable_irq(desc, irq);
+
+	/*
+	 * Hardware which has no wakeup source configuration facility
+	 * requires that the non wakeup interrupts are masked at the
+	 * chip level. The chip implementation indicates that with
+	 * IRQCHIP_MASK_ON_SUSPEND.
+	 */
+	if (irq_desc_get_chip(desc)->flags & IRQCHIP_MASK_ON_SUSPEND)
+		mask_irq(desc);
 }
 
 /**
@@ -176,19 +185,7 @@ int check_wakeup_irqs(void)
 		if (irqd_is_wakeup_set(&desc->irq_data)) {
 			if (desc->depth == 1 && desc->istate & IRQS_PENDING)
 				return -EBUSY;
-			continue;
 		}
-		/*
-		 * Check the non wakeup interrupts whether they need
-		 * to be masked before finally going into suspend
-		 * state. That's for hardware which has no wakeup
-		 * source configuration facility. The chip
-		 * implementation indicates that with
-		 * IRQCHIP_MASK_ON_SUSPEND.
-		 */
-		if (desc->istate & IRQS_SUSPENDED &&
-		    irq_desc_get_chip(desc)->flags & IRQCHIP_MASK_ON_SUSPEND)
-			mask_irq(desc);
 	}
 
 	return 0;

commit 5417de222393164b87b2d142b6ec332be40a2564
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 15:48:59 2014 +0200

    genirq: Make use of pm misfeature accounting
    
    Use the accounting fields which got introduced for snity checking for
    the various PM options.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 1b1b67a73218..74ca6bb541d5 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -51,7 +51,7 @@ void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
 
 static void suspend_device_irq(struct irq_desc *desc, int irq)
 {
-	if (!desc->action || (desc->action->flags & IRQF_NO_SUSPEND))
+	if (!desc->action || desc->no_suspend_depth)
 		return;
 
 	desc->istate |= IRQS_SUSPENDED;
@@ -94,11 +94,8 @@ static void resume_irq(struct irq_desc *desc, int irq)
 	if (desc->istate & IRQS_SUSPENDED)
 		goto resume;
 
-	if (!desc->action)
-		return;
-
-	/* Interrupts marked with that flag are force reenabled */
-	if (!(desc->action->flags & IRQF_FORCE_RESUME))
+	/* Force resume the interrupt? */
+	if (!desc->force_resume_depth)
 		return;
 
 	/* Pretend that it got disabled ! */

commit cab303be91dc47942bc25de33dc1140123540800
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 11:44:31 2014 +0200

    genirq: Add sanity checks for PM options on shared interrupt lines
    
    Account the IRQF_NO_SUSPEND and IRQF_RESUME_EARLY actions on shared
    interrupt lines and yell loudly if there is a mismatch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index b84141dcee5e..1b1b67a73218 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -13,6 +13,42 @@
 
 #include "internals.h"
 
+/*
+ * Called from __setup_irq() with desc->lock held after @action has
+ * been installed in the action chain.
+ */
+void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)
+{
+	desc->nr_actions++;
+
+	if (action->flags & IRQF_FORCE_RESUME)
+		desc->force_resume_depth++;
+
+	WARN_ON_ONCE(desc->force_resume_depth &&
+		     desc->force_resume_depth != desc->nr_actions);
+
+	if (action->flags & IRQF_NO_SUSPEND)
+		desc->no_suspend_depth++;
+
+	WARN_ON_ONCE(desc->no_suspend_depth &&
+		     desc->no_suspend_depth != desc->nr_actions);
+}
+
+/*
+ * Called from __free_irq() with desc->lock held after @action has
+ * been removed from the action chain.
+ */
+void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)
+{
+	desc->nr_actions--;
+
+	if (action->flags & IRQF_FORCE_RESUME)
+		desc->force_resume_depth--;
+
+	if (action->flags & IRQF_NO_SUSPEND)
+		desc->no_suspend_depth--;
+}
+
 static void suspend_device_irq(struct irq_desc *desc, int irq)
 {
 	if (!desc->action || (desc->action->flags & IRQF_NO_SUSPEND))

commit 8df2e02c5c4de9e65ee60153dd9c442356534ad9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 11:49:28 2014 +0200

    genirq: Move suspend/resume logic into irq/pm code
    
    No functional change. Preparatory patch for cleaning up the suspend
    abort functionality. Update the comments while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index abcd6ca86cb7..b84141dcee5e 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -13,13 +13,26 @@
 
 #include "internals.h"
 
+static void suspend_device_irq(struct irq_desc *desc, int irq)
+{
+	if (!desc->action || (desc->action->flags & IRQF_NO_SUSPEND))
+		return;
+
+	desc->istate |= IRQS_SUSPENDED;
+	__disable_irq(desc, irq);
+}
+
 /**
  * suspend_device_irqs - disable all currently enabled interrupt lines
  *
- * During system-wide suspend or hibernation device drivers need to be prevented
- * from receiving interrupts and this function is provided for this purpose.
- * It marks all interrupt lines in use, except for the timer ones, as disabled
- * and sets the IRQS_SUSPENDED flag for each of them.
+ * During system-wide suspend or hibernation device drivers need to be
+ * prevented from receiving interrupts and this function is provided
+ * for this purpose.
+ *
+ * So we disable all interrupts and mark them IRQS_SUSPENDED except
+ * for those which are unused and those which are marked as not
+ * suspendable via an interrupt request with the flag IRQF_NO_SUSPEND
+ * set.
  */
 void suspend_device_irqs(void)
 {
@@ -30,7 +43,7 @@ void suspend_device_irqs(void)
 		unsigned long flags;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
-		__disable_irq(desc, irq, true);
+		suspend_device_irq(desc, irq);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 
@@ -40,6 +53,25 @@ void suspend_device_irqs(void)
 }
 EXPORT_SYMBOL_GPL(suspend_device_irqs);
 
+static void resume_irq(struct irq_desc *desc, int irq)
+{
+	if (desc->istate & IRQS_SUSPENDED)
+		goto resume;
+
+	if (!desc->action)
+		return;
+
+	/* Interrupts marked with that flag are force reenabled */
+	if (!(desc->action->flags & IRQF_FORCE_RESUME))
+		return;
+
+	/* Pretend that it got disabled ! */
+	desc->depth++;
+resume:
+	desc->istate &= ~IRQS_SUSPENDED;
+	__enable_irq(desc, irq);
+}
+
 static void resume_irqs(bool want_early)
 {
 	struct irq_desc *desc;
@@ -54,7 +86,7 @@ static void resume_irqs(bool want_early)
 			continue;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
-		__enable_irq(desc, irq, true);
+		resume_irq(desc, irq);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 }

commit ac01810c9d2814238f08a227062e66a35a0e1ea2
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Mon Nov 25 19:39:47 2013 +0530

    irq: Enable all irqs unconditionally in irq_resume
    
    When the system enters suspend, it disables all interrupts in
    suspend_device_irqs(), including the interrupts marked EARLY_RESUME.
    
    On the resume side things are different. The EARLY_RESUME interrupts
    are reenabled in sys_core_ops->resume and the non EARLY_RESUME
    interrupts are reenabled in the normal system resume path.
    
    When suspend_noirq() failed or suspend is aborted for any other
    reason, we might omit the resume side call to sys_core_ops->resume()
    and therefor the interrupts marked EARLY_RESUME are not reenabled and
    stay disabled forever.
    
    To solve this, enable all irqs unconditionally in irq_resume()
    regardless whether interrupts marked EARLY_RESUMEhave been already
    enabled or not.
    
    This might try to reenable already enabled interrupts in the non
    failure case, but the only affected platform is XEN and it has been
    confirmed that it does not cause any side effects.
    
    [ tglx: Massaged changelog. ]
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Acked-by-and-tested-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Pavel Machek <pavel@ucw.cz>
    Cc: <ian.campbell@citrix.com>
    Cc: <rjw@rjwysocki.net>
    Cc: <len.brown@intel.com>
    Cc: <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1385388587-16442-1-git-send-email-ldewangan@nvidia.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index cb228bf21760..abcd6ca86cb7 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -50,7 +50,7 @@ static void resume_irqs(bool want_early)
 		bool is_early = desc->action &&
 			desc->action->flags & IRQF_EARLY_RESUME;
 
-		if (is_early != want_early)
+		if (!is_early && want_early)
 			continue;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);

commit 9c6079aa1bfcf7e14de10b824779ce39b679bcb8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 4 17:56:16 2012 +0200

    genirq: Do not consider disabled wakeup irqs
    
    If an wakeup interrupt has been disabled before the suspend code
    disables all interrupts then we have to ignore the pending flag.
    
    Otherwise we would abort suspend over and over as nothing clears the
    pending flag because the interrupt is disabled.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: NeilBrown <neilb@suse.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 15e53b1766a6..cb228bf21760 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -103,8 +103,13 @@ int check_wakeup_irqs(void)
 	int irq;
 
 	for_each_irq_desc(irq, desc) {
+		/*
+		 * Only interrupts which are marked as wakeup source
+		 * and have not been disabled before the suspend check
+		 * can abort suspend.
+		 */
 		if (irqd_is_wakeup_set(&desc->irq_data)) {
-			if (desc->istate & IRQS_PENDING)
+			if (desc->depth == 1 && desc->istate & IRQS_PENDING)
 				return -EBUSY;
 			continue;
 		}

commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Cc: stable@kernel.org (at least to 2.6.32.y)
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index f76fc00c9877..15e53b1766a6 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -9,6 +9,7 @@
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include <linux/syscore_ops.h>
 
 #include "internals.h"
 
@@ -39,25 +40,58 @@ void suspend_device_irqs(void)
 }
 EXPORT_SYMBOL_GPL(suspend_device_irqs);
 
-/**
- * resume_device_irqs - enable interrupt lines disabled by suspend_device_irqs()
- *
- * Enable all interrupt lines previously disabled by suspend_device_irqs() that
- * have the IRQS_SUSPENDED flag set.
- */
-void resume_device_irqs(void)
+static void resume_irqs(bool want_early)
 {
 	struct irq_desc *desc;
 	int irq;
 
 	for_each_irq_desc(irq, desc) {
 		unsigned long flags;
+		bool is_early = desc->action &&
+			desc->action->flags & IRQF_EARLY_RESUME;
+
+		if (is_early != want_early)
+			continue;
 
 		raw_spin_lock_irqsave(&desc->lock, flags);
 		__enable_irq(desc, irq, true);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 }
+
+/**
+ * irq_pm_syscore_ops - enable interrupt lines early
+ *
+ * Enable all interrupt lines with %IRQF_EARLY_RESUME set.
+ */
+static void irq_pm_syscore_resume(void)
+{
+	resume_irqs(true);
+}
+
+static struct syscore_ops irq_pm_syscore_ops = {
+	.resume		= irq_pm_syscore_resume,
+};
+
+static int __init irq_pm_init_ops(void)
+{
+	register_syscore_ops(&irq_pm_syscore_ops);
+	return 0;
+}
+
+device_initcall(irq_pm_init_ops);
+
+/**
+ * resume_device_irqs - enable interrupt lines disabled by suspend_device_irqs()
+ *
+ * Enable all non-%IRQF_EARLY_RESUME interrupt lines previously
+ * disabled by suspend_device_irqs() that have the IRQS_SUSPENDED flag
+ * set as well as those with %IRQF_FORCE_RESUME.
+ */
+void resume_device_irqs(void)
+{
+	resume_irqs(false);
+}
 EXPORT_SYMBOL_GPL(resume_device_irqs);
 
 /**

commit d209a699a0b975ad47f399d70ddc3791f1b84496
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 11 21:22:14 2011 +0100

    genirq: Add chip flag to force mask on suspend
    
    On suspend we disable all interrupts in the core code, but this does
    not mask the interrupt line in the default implementation as we use a
    lazy disable approach. That means we mark the interrupt disabled, but
    leave the hardware unmasked. That's an optimization because we avoid
    the hardware access for the common case where no interrupt happens
    after we marked it disabled. If an interrupt happens, then the
    interrupt flow handler masks the line at the hardware level and marks
    it pending.
    
    Suspend makes use of this delayed disable as it "disables" all
    interrupts when preparing the suspend transition. Right before the
    system goes into hardware suspend state it checks whether one of the
    interrupts which is marked as a wakeup interrupt came in after
    disabling it.
    
    Most interrupt chips have a separate register which selects the
    interrupts which can wake up the system from suspend, so we don't have
    to mask any on the non wakeup interrupts.
    
    But now we have to deal with brilliant designed hardware which lacks
    such a wakeup configuration facility. For such hardware it's necessary
    to mask all non wakeup interrupts before going into suspend in order
    to avoid the wakeup from random interrupts.
    
    Rather than working around this in the affected interrupt chip
    implementations we can solve this elegant in the core code itself.
    
    Add a flag IRQCHIP_MASK_ON_SUSPEND which can be set by the irq chip
    implementation to indicate, that the interrupts which are not selected
    as wakeup sources must be masked in the suspend path. Mask them in the
    loop which checks the wakeup interrupts pending flag.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    LKML-Reference: <alpine.LFD.2.00.1103112112310.2787@localhost6.localdomain6>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 1329f0eff49e..f76fc00c9877 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -68,10 +68,24 @@ int check_wakeup_irqs(void)
 	struct irq_desc *desc;
 	int irq;
 
-	for_each_irq_desc(irq, desc)
-		if (irqd_is_wakeup_set(&desc->irq_data) &&
-		    (desc->istate & IRQS_PENDING))
-			return -EBUSY;
+	for_each_irq_desc(irq, desc) {
+		if (irqd_is_wakeup_set(&desc->irq_data)) {
+			if (desc->istate & IRQS_PENDING)
+				return -EBUSY;
+			continue;
+		}
+		/*
+		 * Check the non wakeup interrupts whether they need
+		 * to be masked before finally going into suspend
+		 * state. That's for hardware which has no wakeup
+		 * source configuration facility. The chip
+		 * implementation indicates that with
+		 * IRQCHIP_MASK_ON_SUSPEND.
+		 */
+		if (desc->istate & IRQS_SUSPENDED &&
+		    irq_desc_get_chip(desc)->flags & IRQCHIP_MASK_ON_SUSPEND)
+			mask_irq(desc);
+	}
 
 	return 0;
 }

commit 7f94226f03299f1ca32f118f02f2a0295e0e5e93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 19:46:26 2011 +0100

    genirq: Move wakeup state to irq_data
    
    Some irq_chips need to know the state of wakeup mode for
    setting the trigger type etc. Reflect it in irq_data state.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index f39383d8672d..1329f0eff49e 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -69,7 +69,7 @@ int check_wakeup_irqs(void)
 	int irq;
 
 	for_each_irq_desc(irq, desc)
-		if ((desc->istate & IRQS_WAKEUP) &&
+		if (irqd_is_wakeup_set(&desc->irq_data) &&
 		    (desc->istate & IRQS_PENDING))
 			return -EBUSY;
 

commit 6d2cd17fde1fc3e93302815f049f255bb2b3123e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 14:34:18 2011 +0100

    genirq: Move IRQ_WAKEUP to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index d81337fc1cff..f39383d8672d 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -69,7 +69,7 @@ int check_wakeup_irqs(void)
 	int irq;
 
 	for_each_irq_desc(irq, desc)
-		if ((desc->status & IRQ_WAKEUP) &&
+		if ((desc->istate & IRQS_WAKEUP) &&
 		    (desc->istate & IRQS_PENDING))
 			return -EBUSY;
 

commit c531e8361f1968d664e6e97fbd3bfa4cf0e62e42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:44:58 2011 +0100

    genirq: Move IRQ_SUSPENDED to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index d7389418e91a..d81337fc1cff 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -18,7 +18,7 @@
  * During system-wide suspend or hibernation device drivers need to be prevented
  * from receiving interrupts and this function is provided for this purpose.
  * It marks all interrupt lines in use, except for the timer ones, as disabled
- * and sets the IRQ_SUSPENDED flag for each of them.
+ * and sets the IRQS_SUSPENDED flag for each of them.
  */
 void suspend_device_irqs(void)
 {
@@ -34,7 +34,7 @@ void suspend_device_irqs(void)
 	}
 
 	for_each_irq_desc(irq, desc)
-		if (desc->status & IRQ_SUSPENDED)
+		if (desc->istate & IRQS_SUSPENDED)
 			synchronize_irq(irq);
 }
 EXPORT_SYMBOL_GPL(suspend_device_irqs);
@@ -43,7 +43,7 @@ EXPORT_SYMBOL_GPL(suspend_device_irqs);
  * resume_device_irqs - enable interrupt lines disabled by suspend_device_irqs()
  *
  * Enable all interrupt lines previously disabled by suspend_device_irqs() that
- * have the IRQ_SUSPENDED flag set.
+ * have the IRQS_SUSPENDED flag set.
  */
 void resume_device_irqs(void)
 {

commit 2a0d6fb335d4428285dab2d254911748e6040807
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:17:57 2011 +0100

    genirq: Move IRQ_PENDING flag to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index d6bfb89cce91..d7389418e91a 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -69,7 +69,8 @@ int check_wakeup_irqs(void)
 	int irq;
 
 	for_each_irq_desc(irq, desc)
-		if ((desc->status & IRQ_WAKEUP) && (desc->status & IRQ_PENDING))
+		if ((desc->status & IRQ_WAKEUP) &&
+		    (desc->istate & IRQS_PENDING))
 			return -EBUSY;
 
 	return 0;

commit dc5f219e88294b93009eef946251251ffffb6d60
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 4 13:19:20 2011 +0100

    genirq: Add IRQF_FORCE_RESUME
    
    Xen needs to reenable interrupts which are marked IRQF_NO_SUSPEND in the
    resume path. Add a flag to force the reenabling in the resume code.
    
    Tested-and-acked-by: Ian Campbell <Ian.Campbell@eu.citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 0d4005d85b03..d6bfb89cce91 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -53,9 +53,6 @@ void resume_device_irqs(void)
 	for_each_irq_desc(irq, desc) {
 		unsigned long flags;
 
-		if (!(desc->status & IRQ_SUSPENDED))
-			continue;
-
 		raw_spin_lock_irqsave(&desc->lock, flags);
 		__enable_irq(desc, irq, true);
 		raw_spin_unlock_irqrestore(&desc->lock, flags);

commit 239007b8440abff689632f50cdf0f2b9e895b534
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 17 16:46:45 2009 +0100

    genirq: Convert irq_desc.lock to raw_spinlock
    
    Convert locks which cannot be sleeping locks in preempt-rt to
    raw_spinlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index a0bb09e79867..0d4005d85b03 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -28,9 +28,9 @@ void suspend_device_irqs(void)
 	for_each_irq_desc(irq, desc) {
 		unsigned long flags;
 
-		spin_lock_irqsave(&desc->lock, flags);
+		raw_spin_lock_irqsave(&desc->lock, flags);
 		__disable_irq(desc, irq, true);
-		spin_unlock_irqrestore(&desc->lock, flags);
+		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 
 	for_each_irq_desc(irq, desc)
@@ -56,9 +56,9 @@ void resume_device_irqs(void)
 		if (!(desc->status & IRQ_SUSPENDED))
 			continue;
 
-		spin_lock_irqsave(&desc->lock, flags);
+		raw_spin_lock_irqsave(&desc->lock, flags);
 		__enable_irq(desc, irq, true);
-		spin_unlock_irqrestore(&desc->lock, flags);
+		raw_spin_unlock_irqrestore(&desc->lock, flags);
 	}
 }
 EXPORT_SYMBOL_GPL(resume_device_irqs);

commit c71320d0c445e01555a86fa6523609db47eeaef6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 5 00:22:34 2009 +0200

    genirq: Fix comment describing suspend_device_irqs()
    
    The kerneldoc comment describing suspend_device_irqs() is currently
    misleading, because generally the function doesn't really disable
    interrupt lines at the chip level.  Replace it with a more accurate
    one.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    LKML-Reference: <200907050022.35117.rjw@sisk.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
index 638d8bedec14..a0bb09e79867 100644
--- a/kernel/irq/pm.c
+++ b/kernel/irq/pm.c
@@ -15,10 +15,10 @@
 /**
  * suspend_device_irqs - disable all currently enabled interrupt lines
  *
- * During system-wide suspend or hibernation device interrupts need to be
- * disabled at the chip level and this function is provided for this purpose.
- * It disables all interrupt lines that are enabled at the moment and sets the
- * IRQ_SUSPENDED flag for them.
+ * During system-wide suspend or hibernation device drivers need to be prevented
+ * from receiving interrupts and this function is provided for this purpose.
+ * It marks all interrupt lines in use, except for the timer ones, as disabled
+ * and sets the IRQ_SUSPENDED flag for each of them.
  */
 void suspend_device_irqs(void)
 {

commit 0a0c5168df270a50e3518e4f12bddb31f8f5f38f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:33:49 2009 +0100

    PM: Introduce functions for suspending and resuming device interrupts
    
    Introduce helper functions allowing us to prevent device drivers from
    getting any interrupts (without disabling interrupts on the CPU)
    during suspend (or hibernation) and to make them start to receive
    interrupts again during the subsequent resume.  These functions make it
    possible to keep timer interrupts enabled while the "late" suspend and
    "early" resume callbacks provided by device drivers are being
    executed.  In turn, this allows device drivers' "late" suspend and
    "early" resume callbacks to sleep, execute ACPI callbacks etc.
    
    The functions introduced here will be used to rework the handling of
    interrupts during suspend (hibernation) and resume.  Namely,
    interrupts will only be disabled on the CPU right before suspending
    sysdevs, while device drivers will be prevented from receiving
    interrupts, with the help of the new helper function, before their
    "late" suspend callbacks run (and analogously during resume).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/irq/pm.c b/kernel/irq/pm.c
new file mode 100644
index 000000000000..638d8bedec14
--- /dev/null
+++ b/kernel/irq/pm.c
@@ -0,0 +1,79 @@
+/*
+ * linux/kernel/irq/pm.c
+ *
+ * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
+ *
+ * This file contains power management functions related to interrupts.
+ */
+
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+#include "internals.h"
+
+/**
+ * suspend_device_irqs - disable all currently enabled interrupt lines
+ *
+ * During system-wide suspend or hibernation device interrupts need to be
+ * disabled at the chip level and this function is provided for this purpose.
+ * It disables all interrupt lines that are enabled at the moment and sets the
+ * IRQ_SUSPENDED flag for them.
+ */
+void suspend_device_irqs(void)
+{
+	struct irq_desc *desc;
+	int irq;
+
+	for_each_irq_desc(irq, desc) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&desc->lock, flags);
+		__disable_irq(desc, irq, true);
+		spin_unlock_irqrestore(&desc->lock, flags);
+	}
+
+	for_each_irq_desc(irq, desc)
+		if (desc->status & IRQ_SUSPENDED)
+			synchronize_irq(irq);
+}
+EXPORT_SYMBOL_GPL(suspend_device_irqs);
+
+/**
+ * resume_device_irqs - enable interrupt lines disabled by suspend_device_irqs()
+ *
+ * Enable all interrupt lines previously disabled by suspend_device_irqs() that
+ * have the IRQ_SUSPENDED flag set.
+ */
+void resume_device_irqs(void)
+{
+	struct irq_desc *desc;
+	int irq;
+
+	for_each_irq_desc(irq, desc) {
+		unsigned long flags;
+
+		if (!(desc->status & IRQ_SUSPENDED))
+			continue;
+
+		spin_lock_irqsave(&desc->lock, flags);
+		__enable_irq(desc, irq, true);
+		spin_unlock_irqrestore(&desc->lock, flags);
+	}
+}
+EXPORT_SYMBOL_GPL(resume_device_irqs);
+
+/**
+ * check_wakeup_irqs - check if any wake-up interrupts are pending
+ */
+int check_wakeup_irqs(void)
+{
+	struct irq_desc *desc;
+	int irq;
+
+	for_each_irq_desc(irq, desc)
+		if ((desc->status & IRQ_WAKEUP) && (desc->status & IRQ_PENDING))
+			return -EBUSY;
+
+	return 0;
+}
