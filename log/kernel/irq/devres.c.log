commit 2d65c42b43e53d61f1fd6b8d0a097451a4cffa24
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Apr 10 12:09:14 2019 -0500

    genirq/devres: Use struct_size() in devm_kzalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        struct boo entry[];
    };
    
    size = sizeof(struct foo) + count * sizeof(struct boo);
    instance = devm_kzalloc(dev, size, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper.
    
    instance = devm_kzalloc(dev, struct_size(instance, entry, count), GFP_KERNEL);
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190410170914.GA16161@embeddedor

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index f808c6a97dcc..f6e5515ee077 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -220,9 +220,8 @@ devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
 			    irq_flow_handler_t handler)
 {
 	struct irq_chip_generic *gc;
-	unsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);
 
-	gc = devm_kzalloc(dev, sz, GFP_KERNEL);
+	gc = devm_kzalloc(dev, struct_size(gc, chip_types, num_ct), GFP_KERNEL);
 	if (gc)
 		irq_init_generic_chip(gc, name, num_ct,
 				      irq_base, reg_base, handler);

commit bb2e320565f997273fe04035bb6c17f643da6f8a
Author: Valdis Kletnieks <valdis.kletnieks@vt.edu>
Date:   Tue Mar 12 04:17:56 2019 -0400

    genirq/devres: Remove excess parameter from kernel doc
    
    Building with 'make W=1' complains:
    
      CC      kernel/irq/devres.o
    kernel/irq/devres.c:104: warning: Excess function parameter 'thread_fn'
                             description in 'devm_request_any_context_irq'
    
    Remove it.
    
    Signed-off-by: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/31207.1552378676@turing-police

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 5d5378ea0afe..f808c6a97dcc 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -84,8 +84,6 @@ EXPORT_SYMBOL(devm_request_threaded_irq);
  *	@dev: device to request interrupt for
  *	@irq: Interrupt line to allocate
  *	@handler: Function to be called when the IRQ occurs
- *	@thread_fn: function to be called in a threaded interrupt context. NULL
- *		    for devices which handle everything in @handler
  *	@irqflags: Interrupt type flags
  *	@devname: An ascii name for the claiming device, dev_name(dev) if NULL
  *	@dev_id: A cookie passed back to the handler function

commit bec04037e4e484f41ee4d9409e40616874169d20
Author: Dou Liyang <douliyangs@gmail.com>
Date:   Tue Dec 4 23:51:20 2018 +0800

    genirq/core: Introduce struct irq_affinity_desc
    
    The interrupt affinity management uses straight cpumask pointers to convey
    the automatically assigned affinity masks for managed interrupts. The core
    interrupt descriptor allocation also decides based on the pointer being non
    NULL whether an interrupt is managed or not.
    
    Devices which use managed interrupts usually have two classes of
    interrupts:
    
      - Interrupts for multiple device queues
      - Interrupts for general device management
    
    Currently both classes are treated the same way, i.e. as managed
    interrupts. The general interrupts get the default affinity mask assigned
    while the device queue interrupts are spread out over the possible CPUs.
    
    Treating the general interrupts as managed is both a limitation and under
    certain circumstances a bug. Assume the following situation:
    
     default_irq_affinity = 4..7
    
    So if CPUs 4-7 are offlined, then the core code will shut down the device
    management interrupts because the last CPU in their affinity mask went
    offline.
    
    It's also a limitation because it's desired to allow manual placement of
    the general device interrupts for various reasons. If they are marked
    managed then the interrupt affinity setting from both user and kernel space
    is disabled.
    
    To remedy that situation it's required to convey more information than the
    cpumasks through various interfaces related to interrupt descriptor
    allocation.
    
    Instead of adding yet another argument, create a new data structure
    'irq_affinity_desc' which for now just contains the cpumask. This struct
    can be expanded to convey auxilliary information in the next step.
    
    No functional change, just preparatory work.
    
    [ tglx: Simplified logic and clarified changelog ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Dou Liyang <douliyangs@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: kashyap.desai@broadcom.com
    Cc: shivasharan.srikanteshwara@broadcom.com
    Cc: sumit.saxena@broadcom.com
    Cc: ming.lei@redhat.com
    Cc: hch@lst.de
    Cc: douliyang1@huawei.com
    Link: https://lkml.kernel.org/r/20181204155122.6327-2-douliyangs@gmail.com

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 6a682c229e10..5d5378ea0afe 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -169,7 +169,7 @@ static void devm_irq_desc_release(struct device *dev, void *res)
  * @cnt:	Number of consecutive irqs to allocate
  * @node:	Preferred node on which the irq descriptor should be allocated
  * @owner:	Owning module (can be NULL)
- * @affinity:	Optional pointer to an affinity mask array of size @cnt
+ * @affinity:	Optional pointer to an irq_affinity_desc array of size @cnt
  *		which hints where the irq descriptors should be allocated
  *		and which default affinities to use
  *
@@ -179,7 +179,7 @@ static void devm_irq_desc_release(struct device *dev, void *res)
  */
 int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
 			   unsigned int cnt, int node, struct module *owner,
-			   const struct cpumask *affinity)
+			   const struct irq_affinity_desc *affinity)
 {
 	struct irq_desc_devres *dr;
 	int base;

commit 52a65ff5603e685e9b19c2e108b3f0826dc7a86b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 14 22:15:19 2018 +0100

    genirq: Add missing SPDX identifiers
    
    Add SPDX identifiers to files
    
     - which contain an explicit license boiler plate or reference
    
     - which do not contain a license reference and were not updated in the
       initial SPDX conversion because the license was deduced by the scanners
       via EXPORT_SYMBOL_GPL as GPL2.0 only.
    
    [ tglx: Moved adding identifiers from the patch which removes the
            references/boilerplate ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Link: https://lkml.kernel.org/r/20180314212030.668321222@linutronix.de

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 194c506d9d20..6a682c229e10 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>

commit 30fd8fc5c91973485705f83c7efe9588b8e6f371
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:07:00 2017 +0200

    irq/generic-chip: Provide devm_irq_setup_generic_chip()
    
    Provide a resource managed variant of irq_setup_generic_chip().
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-6-git-send-email-brgl@bgdev.pl

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 21ee0aebccfb..194c506d9d20 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -231,4 +231,56 @@ devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
 	return gc;
 }
 EXPORT_SYMBOL_GPL(devm_irq_alloc_generic_chip);
+
+struct irq_generic_chip_devres {
+	struct irq_chip_generic *gc;
+	u32 msk;
+	unsigned int clr;
+	unsigned int set;
+};
+
+static void devm_irq_remove_generic_chip(struct device *dev, void *res)
+{
+	struct irq_generic_chip_devres *this = res;
+
+	irq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);
+}
+
+/**
+ * devm_irq_setup_generic_chip - Setup a range of interrupts with a generic
+ *                               chip for a managed device
+ *
+ * @dev:	Device to setup the generic chip for
+ * @gc:		Generic irq chip holding all data
+ * @msk:	Bitmask holding the irqs to initialize relative to gc->irq_base
+ * @flags:	Flags for initialization
+ * @clr:	IRQ_* bits to clear
+ * @set:	IRQ_* bits to set
+ *
+ * Set up max. 32 interrupts starting from gc->irq_base. Note, this
+ * initializes all interrupts to the primary irq_chip_type and its
+ * associated handler.
+ */
+int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,
+				u32 msk, enum irq_gc_flags flags,
+				unsigned int clr, unsigned int set)
+{
+	struct irq_generic_chip_devres *dr;
+
+	dr = devres_alloc(devm_irq_remove_generic_chip,
+			  sizeof(*dr), GFP_KERNEL);
+	if (!dr)
+		return -ENOMEM;
+
+	irq_setup_generic_chip(gc, msk, flags, clr, set);
+
+	dr->gc = gc;
+	dr->msk = msk;
+	dr->clr = clr;
+	dr->set = set;
+	devres_add(dev, dr);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_irq_setup_generic_chip);
 #endif /* CONFIG_GENERIC_IRQ_CHIP */

commit 1c3e36309fe2e94b8a889fa32cb5c871434f8ed6
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:06:59 2017 +0200

    irq/generic-chip: Provide devm_irq_alloc_generic_chip()
    
    Provide a resource managed variant of irq_alloc_generic_chip().
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-5-git-send-email-brgl@bgdev.pl

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 1613bfd48365..21ee0aebccfb 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -4,6 +4,8 @@
 #include <linux/gfp.h>
 #include <linux/irq.h>
 
+#include "internals.h"
+
 /*
  * Device resource management aware IRQ request/free implementation.
  */
@@ -198,3 +200,35 @@ int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
 	return base;
 }
 EXPORT_SYMBOL_GPL(__devm_irq_alloc_descs);
+
+#ifdef CONFIG_GENERIC_IRQ_CHIP
+/**
+ * devm_irq_alloc_generic_chip - Allocate and initialize a generic chip
+ *                               for a managed device
+ * @dev:	Device to allocate the generic chip for
+ * @name:	Name of the irq chip
+ * @num_ct:	Number of irq_chip_type instances associated with this
+ * @irq_base:	Interrupt base nr for this chip
+ * @reg_base:	Register base address (virtual)
+ * @handler:	Default flow handler associated with this chip
+ *
+ * Returns an initialized irq_chip_generic structure. The chip defaults
+ * to the primary (index 0) irq_chip_type and @handler
+ */
+struct irq_chip_generic *
+devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
+			    unsigned int irq_base, void __iomem *reg_base,
+			    irq_flow_handler_t handler)
+{
+	struct irq_chip_generic *gc;
+	unsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);
+
+	gc = devm_kzalloc(dev, sz, GFP_KERNEL);
+	if (gc)
+		irq_init_generic_chip(gc, name, num_ct,
+				      irq_base, reg_base, handler);
+
+	return gc;
+}
+EXPORT_SYMBOL_GPL(devm_irq_alloc_generic_chip);
+#endif /* CONFIG_GENERIC_IRQ_CHIP */

commit 899b5fbf9d3fcb721690b4d58cf58cc018517003
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Feb 12 16:31:44 2017 +0100

    genirq/devres: Use dev_name(dev) as default for devname
    
    Allow the devname parameter to be NULL and use dev_name(dev) in this case.
    This should be an appropriate default for most use cases.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Link: http://lkml.kernel.org/r/05c63d67-30b4-7026-02d5-ce7fb7bc185f@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 18babef39361..1613bfd48365 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -34,7 +34,7 @@ static int devm_irq_match(struct device *dev, void *res, void *data)
  *	@thread_fn: function to be called in a threaded interrupt context. NULL
  *		    for devices which handle everything in @handler
  *	@irqflags: Interrupt type flags
- *	@devname: An ascii name for the claiming device
+ *	@devname: An ascii name for the claiming device, dev_name(dev) if NULL
  *	@dev_id: A cookie passed back to the handler function
  *
  *	Except for the extra @dev argument, this function takes the
@@ -58,6 +58,9 @@ int devm_request_threaded_irq(struct device *dev, unsigned int irq,
 	if (!dr)
 		return -ENOMEM;
 
+	if (!devname)
+		devname = dev_name(dev);
+
 	rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,
 				  dev_id);
 	if (rc) {
@@ -81,7 +84,7 @@ EXPORT_SYMBOL(devm_request_threaded_irq);
  *	@thread_fn: function to be called in a threaded interrupt context. NULL
  *		    for devices which handle everything in @handler
  *	@irqflags: Interrupt type flags
- *	@devname: An ascii name for the claiming device
+ *	@devname: An ascii name for the claiming device, dev_name(dev) if NULL
  *	@dev_id: A cookie passed back to the handler function
  *
  *	Except for the extra @dev argument, this function takes the
@@ -104,6 +107,9 @@ int devm_request_any_context_irq(struct device *dev, unsigned int irq,
 	if (!dr)
 		return -ENOMEM;
 
+	if (!devname)
+		devname = dev_name(dev);
+
 	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
 	if (rc < 0) {
 		devres_free(dr);

commit 2b5e77308f3356faad640b24af6dc5aa7233eb2d
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Feb 10 13:23:23 2017 +0100

    irqdesc: Add a resource managed version of irq_alloc_descs()
    
    Add a devres flavor of __devm_irq_alloc_descs() and corresponding
    helper macros.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1486729403-21132-1-git-send-email-bgolaszewski@baylibre.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 74d90a754268..18babef39361 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -2,6 +2,7 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/gfp.h>
+#include <linux/irq.h>
 
 /*
  * Device resource management aware IRQ request/free implementation.
@@ -137,3 +138,57 @@ void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 	free_irq(irq, dev_id);
 }
 EXPORT_SYMBOL(devm_free_irq);
+
+struct irq_desc_devres {
+	unsigned int from;
+	unsigned int cnt;
+};
+
+static void devm_irq_desc_release(struct device *dev, void *res)
+{
+	struct irq_desc_devres *this = res;
+
+	irq_free_descs(this->from, this->cnt);
+}
+
+/**
+ * __devm_irq_alloc_descs - Allocate and initialize a range of irq descriptors
+ *			    for a managed device
+ * @dev:	Device to allocate the descriptors for
+ * @irq:	Allocate for specific irq number if irq >= 0
+ * @from:	Start the search from this irq number
+ * @cnt:	Number of consecutive irqs to allocate
+ * @node:	Preferred node on which the irq descriptor should be allocated
+ * @owner:	Owning module (can be NULL)
+ * @affinity:	Optional pointer to an affinity mask array of size @cnt
+ *		which hints where the irq descriptors should be allocated
+ *		and which default affinities to use
+ *
+ * Returns the first irq number or error code.
+ *
+ * Note: Use the provided wrappers (devm_irq_alloc_desc*) for simplicity.
+ */
+int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
+			   unsigned int cnt, int node, struct module *owner,
+			   const struct cpumask *affinity)
+{
+	struct irq_desc_devres *dr;
+	int base;
+
+	dr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);
+	if (!dr)
+		return -ENOMEM;
+
+	base = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);
+	if (base < 0) {
+		devres_free(dr);
+		return base;
+	}
+
+	dr->from = base;
+	dr->cnt = cnt;
+	devres_add(dev, dr);
+
+	return base;
+}
+EXPORT_SYMBOL_GPL(__devm_irq_alloc_descs);

commit 63781394c540dd9e666a6b21d70b64dd52bce76e
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon May 11 17:02:58 2015 +0800

    genirq: devres: Fix testing return value of request_any_context_irq()
    
    request_any_context_irq() returns a negative value on failure.
    It returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED on success.
    So fix testing return value of request_any_context_irq().
    
    Also fixup the return value of devm_request_any_context_irq() to make it
    consistent with request_any_context_irq().
    
    Fixes: 0668d3065128 ("genirq: Add devm_request_any_context_irq()")
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1431334978.17783.4.camel@ingics.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index d5d0f7345c54..74d90a754268 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -104,7 +104,7 @@ int devm_request_any_context_irq(struct device *dev, unsigned int irq,
 		return -ENOMEM;
 
 	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
-	if (rc) {
+	if (rc < 0) {
 		devres_free(dr);
 		return rc;
 	}
@@ -113,7 +113,7 @@ int devm_request_any_context_irq(struct device *dev, unsigned int irq,
 	dr->dev_id = dev_id;
 	devres_add(dev, dr);
 
-	return 0;
+	return rc;
 }
 EXPORT_SYMBOL(devm_request_any_context_irq);
 

commit 307b28b95ce9717680b5980d67ef0b060c8fde3b
Author: Emilio López <emilio@elopez.com.ar>
Date:   Tue Jul 1 16:47:35 2014 -0300

    genirq: fix reference in devm_request_threaded_irq comment
    
    It should be request_threaded_irq, not request_irq
    
    [jkosina@suse.cz: not that it would matter, as both have the same
     set of arguments anyway, but for sake of consistency ...]
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 1ef0606797c9..d5d0f7345c54 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -38,7 +38,7 @@ static int devm_irq_match(struct device *dev, void *res, void *data)
  *
  *	Except for the extra @dev argument, this function takes the
  *	same arguments and performs the same function as
- *	request_irq().  IRQs requested with this function will be
+ *	request_threaded_irq().  IRQs requested with this function will be
  *	automatically freed on driver detach.
  *
  *	If an IRQ allocated with this function needs to be freed

commit 0668d3065128d39449c097e62dbdb5707820137d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jan 2 16:37:32 2014 -0800

    genirq: Add devm_request_any_context_irq()
    
    Some drivers use request_any_context_irq() but there isn't a
    devm_* function for it. Add one so that these drivers don't need
    to explicitly free the irq on driver detach.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Link: http://lkml.kernel.org/r/1388709460-19222-3-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index bd8e788d71e0..1ef0606797c9 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -72,6 +72,51 @@ int devm_request_threaded_irq(struct device *dev, unsigned int irq,
 }
 EXPORT_SYMBOL(devm_request_threaded_irq);
 
+/**
+ *	devm_request_any_context_irq - allocate an interrupt line for a managed device
+ *	@dev: device to request interrupt for
+ *	@irq: Interrupt line to allocate
+ *	@handler: Function to be called when the IRQ occurs
+ *	@thread_fn: function to be called in a threaded interrupt context. NULL
+ *		    for devices which handle everything in @handler
+ *	@irqflags: Interrupt type flags
+ *	@devname: An ascii name for the claiming device
+ *	@dev_id: A cookie passed back to the handler function
+ *
+ *	Except for the extra @dev argument, this function takes the
+ *	same arguments and performs the same function as
+ *	request_any_context_irq().  IRQs requested with this function will be
+ *	automatically freed on driver detach.
+ *
+ *	If an IRQ allocated with this function needs to be freed
+ *	separately, devm_free_irq() must be used.
+ */
+int devm_request_any_context_irq(struct device *dev, unsigned int irq,
+			      irq_handler_t handler, unsigned long irqflags,
+			      const char *devname, void *dev_id)
+{
+	struct irq_devres *dr;
+	int rc;
+
+	dr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),
+			  GFP_KERNEL);
+	if (!dr)
+		return -ENOMEM;
+
+	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
+	if (rc) {
+		devres_free(dr);
+		return rc;
+	}
+
+	dr->irq = irq;
+	dr->dev_id = dev_id;
+	devres_add(dev, dr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_request_any_context_irq);
+
 /**
  *	devm_free_irq - free an interrupt
  *	@dev: device to free interrupt for

commit ae891a1b93bf62e9aaa116a7a71312375047fc9f
Author: Maxin B John <maxin.john@gmail.com>
Date:   Mon Jul 25 17:12:59 2011 -0700

    devres: fix possible use after free
    
    devres uses the pointer value as key after it's freed, which is safe but
    triggers spurious use-after-free warnings on some static analysis tools.
    Rearrange code to avoid such warnings.
    
    Signed-off-by: Maxin B. John <maxin.john@gmail.com>
    Reviewed-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 1ef4ffcdfa55..bd8e788d71e0 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -87,8 +87,8 @@ void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 {
 	struct irq_devres match_data = { irq, dev_id };
 
-	free_irq(irq, dev_id);
 	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
 			       &match_data));
+	free_irq(irq, dev_id);
 }
 EXPORT_SYMBOL(devm_free_irq);

commit 5c42dc7070c94622ca914b5a2e227f3744e857e7
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Feb 11 15:04:36 2010 +0100

    devres/irq: Fix devm_irq_match comment
    
    Fix the reference (in comment).
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 30d56bafc9c2..1ef4ffcdfa55 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -42,7 +42,7 @@ static int devm_irq_match(struct device *dev, void *res, void *data)
  *	automatically freed on driver detach.
  *
  *	If an IRQ allocated with this function needs to be freed
- *	separately, dev_free_irq() must be used.
+ *	separately, devm_free_irq() must be used.
  */
 int devm_request_threaded_irq(struct device *dev, unsigned int irq,
 			      irq_handler_t handler, irq_handler_t thread_fn,

commit 9ce8e498ee58bb8a866a6c3c08fcb385ed66e9d2
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Tue Feb 2 08:54:51 2010 +0200

    devres: typo fix s/dev/devm/
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index d06df9c41cba..30d56bafc9c2 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -81,7 +81,7 @@ EXPORT_SYMBOL(devm_request_threaded_irq);
  *	Except for the extra @dev argument, this function takes the
  *	same arguments and performs the same function as free_irq().
  *	This function instead of free_irq() should be used to manually
- *	free IRQs allocated with dev_request_irq().
+ *	free IRQs allocated with devm_request_irq().
  */
 void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 {

commit 935bd5b971f0df7c06d214d022cf8392e2f37952
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Mar 23 18:28:16 2009 +0100

    genirq: add support for threaded interrupts to devres
    
    Some devices use devres_request_irq() for to install their interrupt
    handler. Add support for threaded interrupts to devres as well.
    
    [tglx - simplified and adapted to latest threadirq version]
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 38a25b8d8bff..d06df9c41cba 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -26,10 +26,12 @@ static int devm_irq_match(struct device *dev, void *res, void *data)
 }
 
 /**
- *	devm_request_irq - allocate an interrupt line for a managed device
+ *	devm_request_threaded_irq - allocate an interrupt line for a managed device
  *	@dev: device to request interrupt for
  *	@irq: Interrupt line to allocate
  *	@handler: Function to be called when the IRQ occurs
+ *	@thread_fn: function to be called in a threaded interrupt context. NULL
+ *		    for devices which handle everything in @handler
  *	@irqflags: Interrupt type flags
  *	@devname: An ascii name for the claiming device
  *	@dev_id: A cookie passed back to the handler function
@@ -42,9 +44,10 @@ static int devm_irq_match(struct device *dev, void *res, void *data)
  *	If an IRQ allocated with this function needs to be freed
  *	separately, dev_free_irq() must be used.
  */
-int devm_request_irq(struct device *dev, unsigned int irq,
-		     irq_handler_t handler, unsigned long irqflags,
-		     const char *devname, void *dev_id)
+int devm_request_threaded_irq(struct device *dev, unsigned int irq,
+			      irq_handler_t handler, irq_handler_t thread_fn,
+			      unsigned long irqflags, const char *devname,
+			      void *dev_id)
 {
 	struct irq_devres *dr;
 	int rc;
@@ -54,7 +57,8 @@ int devm_request_irq(struct device *dev, unsigned int irq,
 	if (!dr)
 		return -ENOMEM;
 
-	rc = request_irq(irq, handler, irqflags, devname, dev_id);
+	rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,
+				  dev_id);
 	if (rc) {
 		devres_free(dr);
 		return rc;
@@ -66,7 +70,7 @@ int devm_request_irq(struct device *dev, unsigned int irq,
 
 	return 0;
 }
-EXPORT_SYMBOL(devm_request_irq);
+EXPORT_SYMBOL(devm_request_threaded_irq);
 
 /**
  *	devm_free_irq - free an interrupt

commit 1aeb272cf09f9e2cbc62163b9f37a9b4d1c7e81d
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Tue Apr 29 00:59:25 2008 -0700

    kernel: explicitly include required header files under kernel/
    
    Following an experimental deletion of the unnecessary directive
    
     #include <linux/slab.h>
    
    from the header file <linux/percpu.h>, these files under kernel/ were exposed
    as needing to include one of <linux/slab.h> or <linux/gfp.h>, so explicit
    includes were added where necessary.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 6d9204f3a370..38a25b8d8bff 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -1,6 +1,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
+#include <linux/gfp.h>
 
 /*
  * Device resource management aware IRQ request/free implementation.

commit 0af3678f7c5872836d1cc8d7c659abd62c3c5ae7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 27 14:24:33 2007 +0100

    rip some includes from linux/interrupt.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index d8ee241115f5..6d9204f3a370 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -1,5 +1,6 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include <linux/device.h>
 
 /*
  * Device resource management aware IRQ request/free implementation.

commit 7f30e49ee1c2c1e95ce9d2ccce5221ddb793dd60
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Apr 7 14:59:41 2007 +0900

    [PATCH] irq-devres: fix failure path of devm_request_irq()
    
    devres should be deallocated with devres_free() not kfree().  This bug
    corrupts slab on IRQ request failure.  Fix it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg KH <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 85a430da0fb6..d8ee241115f5 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -54,7 +54,7 @@ int devm_request_irq(struct device *dev, unsigned int irq,
 
 	rc = request_irq(irq, handler, irqflags, devname, dev_id);
 	if (rc) {
-		kfree(dr);
+		devres_free(dr);
 		return rc;
 	}
 

commit 5ea8176994003483a18c8fed580901e2125f8a83
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Feb 11 15:41:31 2007 +0000

    [PATCH] sort the devres mess out
    
    * Split the implementation-agnostic stuff in separate files.
    * Make sure that targets using non-default request_irq() pull
      kernel/irq/devres.o
    * Introduce new symbols (HAS_IOPORT and HAS_IOMEM) defaulting to positive;
      allow architectures to turn them off (we needed these symbols anyway for
      dependencies of quite a few drivers).
    * protect the ioport-related parts of lib/devres.o with CONFIG_HAS_IOPORT.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
new file mode 100644
index 000000000000..85a430da0fb6
--- /dev/null
+++ b/kernel/irq/devres.c
@@ -0,0 +1,88 @@
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+/*
+ * Device resource management aware IRQ request/free implementation.
+ */
+struct irq_devres {
+	unsigned int irq;
+	void *dev_id;
+};
+
+static void devm_irq_release(struct device *dev, void *res)
+{
+	struct irq_devres *this = res;
+
+	free_irq(this->irq, this->dev_id);
+}
+
+static int devm_irq_match(struct device *dev, void *res, void *data)
+{
+	struct irq_devres *this = res, *match = data;
+
+	return this->irq == match->irq && this->dev_id == match->dev_id;
+}
+
+/**
+ *	devm_request_irq - allocate an interrupt line for a managed device
+ *	@dev: device to request interrupt for
+ *	@irq: Interrupt line to allocate
+ *	@handler: Function to be called when the IRQ occurs
+ *	@irqflags: Interrupt type flags
+ *	@devname: An ascii name for the claiming device
+ *	@dev_id: A cookie passed back to the handler function
+ *
+ *	Except for the extra @dev argument, this function takes the
+ *	same arguments and performs the same function as
+ *	request_irq().  IRQs requested with this function will be
+ *	automatically freed on driver detach.
+ *
+ *	If an IRQ allocated with this function needs to be freed
+ *	separately, dev_free_irq() must be used.
+ */
+int devm_request_irq(struct device *dev, unsigned int irq,
+		     irq_handler_t handler, unsigned long irqflags,
+		     const char *devname, void *dev_id)
+{
+	struct irq_devres *dr;
+	int rc;
+
+	dr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),
+			  GFP_KERNEL);
+	if (!dr)
+		return -ENOMEM;
+
+	rc = request_irq(irq, handler, irqflags, devname, dev_id);
+	if (rc) {
+		kfree(dr);
+		return rc;
+	}
+
+	dr->irq = irq;
+	dr->dev_id = dev_id;
+	devres_add(dev, dr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_request_irq);
+
+/**
+ *	devm_free_irq - free an interrupt
+ *	@dev: device to free interrupt for
+ *	@irq: Interrupt line to free
+ *	@dev_id: Device identity to free
+ *
+ *	Except for the extra @dev argument, this function takes the
+ *	same arguments and performs the same function as free_irq().
+ *	This function instead of free_irq() should be used to manually
+ *	free IRQs allocated with dev_request_irq().
+ */
+void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
+{
+	struct irq_devres match_data = { irq, dev_id };
+
+	free_irq(irq, dev_id);
+	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
+			       &match_data));
+}
+EXPORT_SYMBOL(devm_free_irq);
