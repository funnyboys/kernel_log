commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 320579d89091..e43795cd2ccf 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Internal header to deal with irq_desc->status which will be renamed
  * to irq_desc->settings.

commit e9849777d0e27cdd2902805be51da73e7c79578c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 9 23:28:58 2015 +0200

    genirq: Add flag to force mask in disable_irq[_nosync]()
    
    If an irq chip does not implement the irq_disable callback, then we
    use a lazy approach for disabling the interrupt. That means that the
    interrupt is marked disabled, but the interrupt line is not
    immediately masked in the interrupt chip. It only becomes masked if
    the interrupt is raised while it's marked disabled. We use this to avoid
    possibly expensive mask/unmask operations for common case operations.
    
    Unfortunately there are devices which do not allow the interrupt to be
    disabled easily at the device level. They are forced to use
    disable_irq_nosync(). This can result in taking each interrupt twice.
    
    Instead of enforcing the non lazy mode on all interrupts of a irq
    chip, provide a settings flag, which can be set by the driver for that
    particular interrupt line.
    
    Reported-and-tested-by: Duc Dang <dhdang@apm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1510092348370.6097@nanos

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 3320b84cc60f..320579d89091 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -15,6 +15,7 @@ enum {
 	_IRQ_NESTED_THREAD	= IRQ_NESTED_THREAD,
 	_IRQ_PER_CPU_DEVID	= IRQ_PER_CPU_DEVID,
 	_IRQ_IS_POLLED		= IRQ_IS_POLLED,
+	_IRQ_DISABLE_UNLAZY	= IRQ_DISABLE_UNLAZY,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
@@ -28,6 +29,7 @@ enum {
 #define IRQ_NESTED_THREAD	GOT_YOU_MORON
 #define IRQ_PER_CPU_DEVID	GOT_YOU_MORON
 #define IRQ_IS_POLLED		GOT_YOU_MORON
+#define IRQ_DISABLE_UNLAZY	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 
@@ -154,3 +156,13 @@ static inline bool irq_settings_is_polled(struct irq_desc *desc)
 {
 	return desc->status_use_accessors & _IRQ_IS_POLLED;
 }
+
+static inline bool irq_settings_disable_unlazy(struct irq_desc *desc)
+{
+	return desc->status_use_accessors & _IRQ_DISABLE_UNLAZY;
+}
+
+static inline void irq_settings_clr_disable_unlazy(struct irq_desc *desc)
+{
+	desc->status_use_accessors &= ~_IRQ_DISABLE_UNLAZY;
+}

commit b39898cd4077f4b6ec706e717c938751c34e1dc4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 6 12:30:07 2013 +0100

    genirq: Prevent spurious detection for unconditionally polled interrupts
    
    On a 68k platform a couple of interrupts are demultiplexed and
    "polled" from a top level interrupt. Unfortunately there is no way to
    determine which of the sub interrupts raised the top level interrupt,
    so all of the demultiplexed interrupt handlers need to be
    invoked. Given a high enough frequency this can trigger the spurious
    interrupt detection mechanism, if one of the demultiplex interrupts
    returns IRQ_NONE continuously. But this is a false positive as the
    polling causes this behaviour and not buggy hardware/software.
    
    Introduce IRQ_POLLED which can be set at interrupt chip setup time via
    irq_set_status_flags(). The flag excludes the interrupt from the
    spurious detector and from all core polling activities.
    
    Reported-and-tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@vger.kernel.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1311061149250.23353@ionos.tec.linutronix.de

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 1162f1030f18..3320b84cc60f 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -14,6 +14,7 @@ enum {
 	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
 	_IRQ_NESTED_THREAD	= IRQ_NESTED_THREAD,
 	_IRQ_PER_CPU_DEVID	= IRQ_PER_CPU_DEVID,
+	_IRQ_IS_POLLED		= IRQ_IS_POLLED,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
@@ -26,6 +27,7 @@ enum {
 #define IRQ_NOAUTOEN		GOT_YOU_MORON
 #define IRQ_NESTED_THREAD	GOT_YOU_MORON
 #define IRQ_PER_CPU_DEVID	GOT_YOU_MORON
+#define IRQ_IS_POLLED		GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 
@@ -147,3 +149,8 @@ static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
 {
 	return desc->status_use_accessors & _IRQ_NESTED_THREAD;
 }
+
+static inline bool irq_settings_is_polled(struct irq_desc *desc)
+{
+	return desc->status_use_accessors & _IRQ_IS_POLLED;
+}

commit 31d9d9b6d83030f748d013e61502fa5477e2ac0e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 23 17:03:06 2011 +0100

    genirq: Add support for per-cpu dev_id interrupts
    
    The ARM GIC interrupt controller offers per CPU interrupts (PPIs),
    which are usually used to connect local timers to each core. Each CPU
    has its own private interface to the GIC, and only sees the PPIs that
    are directly connect to it.
    
    While these timers are separate devices and have a separate interrupt
    line to a core, they all use the same IRQ number.
    
    For these devices, request_irq() is not the right API as it assumes
    that an IRQ number is visible by a number of CPUs (through the
    affinity setting), but makes it very awkward to express that an IRQ
    number can be handled by all CPUs, and yet be a different interrupt
    line on each CPU, requiring a different dev_id cookie to be passed
    back to the handler.
    
    The *_percpu_irq() functions is designed to overcome these
    limitations, by providing a per-cpu dev_id vector:
    
    int request_percpu_irq(unsigned int irq, irq_handler_t handler,
                       const char *devname, void __percpu *percpu_dev_id);
    void free_percpu_irq(unsigned int, void __percpu *);
    int setup_percpu_irq(unsigned int irq, struct irqaction *new);
    void remove_percpu_irq(unsigned int irq, struct irqaction *act);
    void enable_percpu_irq(unsigned int irq);
    void disable_percpu_irq(unsigned int irq);
    
    The API has a number of limitations:
    - no interrupt sharing
    - no threading
    - common handler across all the CPUs
    
    Once the interrupt is requested using setup_percpu_irq() or
    request_percpu_irq(), it must be enabled by each core that wishes its
    local interrupt to be delivered.
    
    Based on an initial patch by Thomas Gleixner.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1316793788-14500-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index f1667833d444..1162f1030f18 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -13,6 +13,7 @@ enum {
 	_IRQ_MOVE_PCNTXT	= IRQ_MOVE_PCNTXT,
 	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
 	_IRQ_NESTED_THREAD	= IRQ_NESTED_THREAD,
+	_IRQ_PER_CPU_DEVID	= IRQ_PER_CPU_DEVID,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
@@ -24,6 +25,7 @@ enum {
 #define IRQ_NOTHREAD		GOT_YOU_MORON
 #define IRQ_NOAUTOEN		GOT_YOU_MORON
 #define IRQ_NESTED_THREAD	GOT_YOU_MORON
+#define IRQ_PER_CPU_DEVID	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 
@@ -39,6 +41,11 @@ static inline bool irq_settings_is_per_cpu(struct irq_desc *desc)
 	return desc->status_use_accessors & _IRQ_PER_CPU;
 }
 
+static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)
+{
+	return desc->status_use_accessors & _IRQ_PER_CPU_DEVID;
+}
+
 static inline void irq_settings_set_per_cpu(struct irq_desc *desc)
 {
 	desc->status_use_accessors |= _IRQ_PER_CPU;

commit 7f1b1244e159a8490d7fb13667c6cb7e1e75046b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 7 06:01:44 2011 +0900

    genirq: Support per-IRQ thread disabling.
    
    This adds support for disabling threading on a per-IRQ basis via the IRQ
    status instead of the IRQ flow, which is necessary for interrupts that
    don't follow the natural IRQ flow channels, such as those that are
    virtually created.
    
    The new APIs added are simply:
    
            irq_set_thread()
            irq_set_nothread()
    
    which follow the rest of the IRQ status routines.
    
    Chained handlers also have IRQ_NOTHREAD set on them automatically, making
    the lack of threading explicit rather than implicit. Subsequently, the
    nothread flag can be viewed through the standard genirq debugging
    facilities.
    
    [ tglx: Fixed cleanup fallout ]
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Link: http://lkml.kernel.org/r/%3C20110406210135.GF18426%40linux-sh.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 0d91730b6330..f1667833d444 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -8,6 +8,7 @@ enum {
 	_IRQ_LEVEL		= IRQ_LEVEL,
 	_IRQ_NOPROBE		= IRQ_NOPROBE,
 	_IRQ_NOREQUEST		= IRQ_NOREQUEST,
+	_IRQ_NOTHREAD		= IRQ_NOTHREAD,
 	_IRQ_NOAUTOEN		= IRQ_NOAUTOEN,
 	_IRQ_MOVE_PCNTXT	= IRQ_MOVE_PCNTXT,
 	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
@@ -20,6 +21,7 @@ enum {
 #define IRQ_LEVEL		GOT_YOU_MORON
 #define IRQ_NOPROBE		GOT_YOU_MORON
 #define IRQ_NOREQUEST		GOT_YOU_MORON
+#define IRQ_NOTHREAD		GOT_YOU_MORON
 #define IRQ_NOAUTOEN		GOT_YOU_MORON
 #define IRQ_NESTED_THREAD	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
@@ -94,6 +96,21 @@ static inline void irq_settings_set_norequest(struct irq_desc *desc)
 	desc->status_use_accessors |= _IRQ_NOREQUEST;
 }
 
+static inline bool irq_settings_can_thread(struct irq_desc *desc)
+{
+	return !(desc->status_use_accessors & _IRQ_NOTHREAD);
+}
+
+static inline void irq_settings_clr_nothread(struct irq_desc *desc)
+{
+	desc->status_use_accessors &= ~_IRQ_NOTHREAD;
+}
+
+static inline void irq_settings_set_nothread(struct irq_desc *desc)
+{
+	desc->status_use_accessors |= _IRQ_NOTHREAD;
+}
+
 static inline bool irq_settings_can_probe(struct irq_desc *desc)
 {
 	return !(desc->status_use_accessors & _IRQ_NOPROBE);

commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 13:32:20 2011 +0200

    genirq: Remove compat code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 0227ad358272..0d91730b6330 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -15,17 +15,8 @@ enum {
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
-#define IRQ_INPROGRESS		GOT_YOU_MORON
-#define IRQ_REPLAY		GOT_YOU_MORON
-#define IRQ_WAITING		GOT_YOU_MORON
-#define IRQ_DISABLED		GOT_YOU_MORON
-#define IRQ_PENDING		GOT_YOU_MORON
-#define IRQ_MASKED		GOT_YOU_MORON
-#define IRQ_WAKEUP		GOT_YOU_MORON
-#define IRQ_MOVE_PENDING	GOT_YOU_MORON
 #define IRQ_PER_CPU		GOT_YOU_MORON
 #define IRQ_NO_BALANCING	GOT_YOU_MORON
-#define IRQ_AFFINITY_SET	GOT_YOU_MORON
 #define IRQ_LEVEL		GOT_YOU_MORON
 #define IRQ_NOPROBE		GOT_YOU_MORON
 #define IRQ_NOREQUEST		GOT_YOU_MORON
@@ -37,102 +28,98 @@ enum {
 static inline void
 irq_settings_clr_and_set(struct irq_desc *desc, u32 clr, u32 set)
 {
-	desc->status &= ~(clr & _IRQF_MODIFY_MASK);
-	desc->status |= (set & _IRQF_MODIFY_MASK);
+	desc->status_use_accessors &= ~(clr & _IRQF_MODIFY_MASK);
+	desc->status_use_accessors |= (set & _IRQF_MODIFY_MASK);
 }
 
 static inline bool irq_settings_is_per_cpu(struct irq_desc *desc)
 {
-	return desc->status & _IRQ_PER_CPU;
+	return desc->status_use_accessors & _IRQ_PER_CPU;
 }
 
 static inline void irq_settings_set_per_cpu(struct irq_desc *desc)
 {
-	desc->status |= _IRQ_PER_CPU;
+	desc->status_use_accessors |= _IRQ_PER_CPU;
 }
 
 static inline void irq_settings_set_no_balancing(struct irq_desc *desc)
 {
-	desc->status |= _IRQ_NO_BALANCING;
+	desc->status_use_accessors |= _IRQ_NO_BALANCING;
 }
 
 static inline bool irq_settings_has_no_balance_set(struct irq_desc *desc)
 {
-	return desc->status & _IRQ_NO_BALANCING;
+	return desc->status_use_accessors & _IRQ_NO_BALANCING;
 }
 
 static inline u32 irq_settings_get_trigger_mask(struct irq_desc *desc)
 {
-	return desc->status & IRQ_TYPE_SENSE_MASK;
+	return desc->status_use_accessors & IRQ_TYPE_SENSE_MASK;
 }
 
 static inline void
 irq_settings_set_trigger_mask(struct irq_desc *desc, u32 mask)
 {
-	desc->status &= ~IRQ_TYPE_SENSE_MASK;
-	desc->status |= mask & IRQ_TYPE_SENSE_MASK;
+	desc->status_use_accessors &= ~IRQ_TYPE_SENSE_MASK;
+	desc->status_use_accessors |= mask & IRQ_TYPE_SENSE_MASK;
 }
 
 static inline bool irq_settings_is_level(struct irq_desc *desc)
 {
-	return desc->status & _IRQ_LEVEL;
+	return desc->status_use_accessors & _IRQ_LEVEL;
 }
 
 static inline void irq_settings_clr_level(struct irq_desc *desc)
 {
-	desc->status &= ~_IRQ_LEVEL;
+	desc->status_use_accessors &= ~_IRQ_LEVEL;
 }
 
 static inline void irq_settings_set_level(struct irq_desc *desc)
 {
-	desc->status |= _IRQ_LEVEL;
+	desc->status_use_accessors |= _IRQ_LEVEL;
 }
 
 static inline bool irq_settings_can_request(struct irq_desc *desc)
 {
-	return !(desc->status & _IRQ_NOREQUEST);
+	return !(desc->status_use_accessors & _IRQ_NOREQUEST);
 }
 
 static inline void irq_settings_clr_norequest(struct irq_desc *desc)
 {
-	desc->status &= ~_IRQ_NOREQUEST;
+	desc->status_use_accessors &= ~_IRQ_NOREQUEST;
 }
 
 static inline void irq_settings_set_norequest(struct irq_desc *desc)
 {
-	desc->status |= _IRQ_NOREQUEST;
+	desc->status_use_accessors |= _IRQ_NOREQUEST;
 }
 
 static inline bool irq_settings_can_probe(struct irq_desc *desc)
 {
-	return !(desc->status & _IRQ_NOPROBE);
+	return !(desc->status_use_accessors & _IRQ_NOPROBE);
 }
 
 static inline void irq_settings_clr_noprobe(struct irq_desc *desc)
 {
-	desc->status &= ~_IRQ_NOPROBE;
+	desc->status_use_accessors &= ~_IRQ_NOPROBE;
 }
 
 static inline void irq_settings_set_noprobe(struct irq_desc *desc)
 {
-	desc->status |= _IRQ_NOPROBE;
+	desc->status_use_accessors |= _IRQ_NOPROBE;
 }
 
 static inline bool irq_settings_can_move_pcntxt(struct irq_desc *desc)
 {
-	return desc->status & _IRQ_MOVE_PCNTXT;
+	return desc->status_use_accessors & _IRQ_MOVE_PCNTXT;
 }
 
 static inline bool irq_settings_can_autoenable(struct irq_desc *desc)
 {
-	return !(desc->status & _IRQ_NOAUTOEN);
+	return !(desc->status_use_accessors & _IRQ_NOAUTOEN);
 }
 
 static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
 {
-	return desc->status & _IRQ_NESTED_THREAD;
+	return desc->status_use_accessors & _IRQ_NESTED_THREAD;
 }
-
-/* Nothing should touch desc->status from now on */
-#undef status
-#define status		USE_THE_PROPER_WRAPPERS_YOU_MORON

commit a6967caf00ebbb2d4acdebcb72a25f2e9ba43fd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 22:01:25 2011 +0100

    genirq: Remove desc->status when GENERIC_HARDIRQS_NO_COMPAT=y
    
    If everything uses the right accessors, then enabling
    GENERIC_HARDIRQS_NO_COMPAT should just work. If not it will tell you.
    
    Don't be lazy and use the trick which I use in the core code!
    
    git grep status_use_accessors
    
    will unearth it in a split second. Offenders are tracked down and not
    slapped with stinking trouts. This time we use frozen shark for a
    better educational value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 55ebe1e09da4..0227ad358272 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -134,4 +134,5 @@ static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
 }
 
 /* Nothing should touch desc->status from now on */
+#undef status
 #define status		USE_THE_PROPER_WRAPPERS_YOU_MORON

commit 5d4d8fc9ac3e9a90bbdf90bae6864cb2c01f2208
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:27:18 2011 +0100

    genirq: Cleanup irq.h
    
    Put the constants into an enum and document them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 47bcd3b9f399..55ebe1e09da4 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -15,37 +15,21 @@ enum {
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
-#undef IRQ_INPROGRESS
 #define IRQ_INPROGRESS		GOT_YOU_MORON
-#undef IRQ_REPLAY
 #define IRQ_REPLAY		GOT_YOU_MORON
-#undef IRQ_WAITING
 #define IRQ_WAITING		GOT_YOU_MORON
-#undef IRQ_DISABLED
 #define IRQ_DISABLED		GOT_YOU_MORON
-#undef IRQ_PENDING
 #define IRQ_PENDING		GOT_YOU_MORON
-#undef IRQ_MASKED
 #define IRQ_MASKED		GOT_YOU_MORON
-#undef IRQ_WAKEUP
 #define IRQ_WAKEUP		GOT_YOU_MORON
-#undef IRQ_MOVE_PENDING
 #define IRQ_MOVE_PENDING	GOT_YOU_MORON
-#undef IRQ_PER_CPU
 #define IRQ_PER_CPU		GOT_YOU_MORON
-#undef IRQ_NO_BALANCING
 #define IRQ_NO_BALANCING	GOT_YOU_MORON
-#undef IRQ_AFFINITY_SET
 #define IRQ_AFFINITY_SET	GOT_YOU_MORON
-#undef IRQ_LEVEL
 #define IRQ_LEVEL		GOT_YOU_MORON
-#undef IRQ_NOPROBE
 #define IRQ_NOPROBE		GOT_YOU_MORON
-#undef IRQ_NOREQUEST
 #define IRQ_NOREQUEST		GOT_YOU_MORON
-#undef IRQ_NOAUTOEN
 #define IRQ_NOAUTOEN		GOT_YOU_MORON
-#undef IRQ_NESTED_THREAD
 #define IRQ_NESTED_THREAD	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON

commit f9e4989eb8183a1f33581fa1b99274287b0639d2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 14:54:49 2011 +0100

    genirq: Force wrapped access to desc->status in core code
    
    Force the usage of wrappers by another nasty CPP substitution.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 216b6f200e7c..47bcd3b9f399 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -148,3 +148,6 @@ static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
 {
 	return desc->status & _IRQ_NESTED_THREAD;
 }
+
+/* Nothing should touch desc->status from now on */
+#define status		USE_THE_PROPER_WRAPPERS_YOU_MORON

commit 1ccb4e612f68ceefb888c2c6c1def6294ea8666d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 14:44:17 2011 +0100

    genirq: Wrap the remaning IRQ_* flags
    
    Use wrappers to keep them away from the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 2201f2aaa9a0..216b6f200e7c 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -6,7 +6,12 @@ enum {
 	_IRQ_DEFAULT_INIT_FLAGS	= IRQ_DEFAULT_INIT_FLAGS,
 	_IRQ_PER_CPU		= IRQ_PER_CPU,
 	_IRQ_LEVEL		= IRQ_LEVEL,
+	_IRQ_NOPROBE		= IRQ_NOPROBE,
+	_IRQ_NOREQUEST		= IRQ_NOREQUEST,
+	_IRQ_NOAUTOEN		= IRQ_NOAUTOEN,
+	_IRQ_MOVE_PCNTXT	= IRQ_MOVE_PCNTXT,
 	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
+	_IRQ_NESTED_THREAD	= IRQ_NESTED_THREAD,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
@@ -34,6 +39,14 @@ enum {
 #define IRQ_AFFINITY_SET	GOT_YOU_MORON
 #undef IRQ_LEVEL
 #define IRQ_LEVEL		GOT_YOU_MORON
+#undef IRQ_NOPROBE
+#define IRQ_NOPROBE		GOT_YOU_MORON
+#undef IRQ_NOREQUEST
+#define IRQ_NOREQUEST		GOT_YOU_MORON
+#undef IRQ_NOAUTOEN
+#define IRQ_NOAUTOEN		GOT_YOU_MORON
+#undef IRQ_NESTED_THREAD
+#define IRQ_NESTED_THREAD	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 
@@ -90,3 +103,48 @@ static inline void irq_settings_set_level(struct irq_desc *desc)
 {
 	desc->status |= _IRQ_LEVEL;
 }
+
+static inline bool irq_settings_can_request(struct irq_desc *desc)
+{
+	return !(desc->status & _IRQ_NOREQUEST);
+}
+
+static inline void irq_settings_clr_norequest(struct irq_desc *desc)
+{
+	desc->status &= ~_IRQ_NOREQUEST;
+}
+
+static inline void irq_settings_set_norequest(struct irq_desc *desc)
+{
+	desc->status |= _IRQ_NOREQUEST;
+}
+
+static inline bool irq_settings_can_probe(struct irq_desc *desc)
+{
+	return !(desc->status & _IRQ_NOPROBE);
+}
+
+static inline void irq_settings_clr_noprobe(struct irq_desc *desc)
+{
+	desc->status &= ~_IRQ_NOPROBE;
+}
+
+static inline void irq_settings_set_noprobe(struct irq_desc *desc)
+{
+	desc->status |= _IRQ_NOPROBE;
+}
+
+static inline bool irq_settings_can_move_pcntxt(struct irq_desc *desc)
+{
+	return desc->status & _IRQ_MOVE_PCNTXT;
+}
+
+static inline bool irq_settings_can_autoenable(struct irq_desc *desc)
+{
+	return !(desc->status & _IRQ_NOAUTOEN);
+}
+
+static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
+{
+	return desc->status & _IRQ_NESTED_THREAD;
+}

commit 876dbd4cc1b35c1a4cb96a2be1d43ea0eabce3b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:28:12 2011 +0100

    genirq: Mirror irq trigger type bits in irq_data.state
    
    That's the data structure chip functions get provided. Also allow them
    to signal the core code that they updated the flags in irq_data.state
    by returning IRQ_SET_MASK_OK_NOCOPY. The default is unchanged.
    
    The type bits should be accessed via:
    
    val = irqd_get_trigger_type(irqdata);
    and
    irqd_set_trigger_type(irqdata, val);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index da5acb446b1c..2201f2aaa9a0 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -5,6 +5,7 @@
 enum {
 	_IRQ_DEFAULT_INIT_FLAGS	= IRQ_DEFAULT_INIT_FLAGS,
 	_IRQ_PER_CPU		= IRQ_PER_CPU,
+	_IRQ_LEVEL		= IRQ_LEVEL,
 	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
@@ -31,6 +32,8 @@ enum {
 #define IRQ_NO_BALANCING	GOT_YOU_MORON
 #undef IRQ_AFFINITY_SET
 #define IRQ_AFFINITY_SET	GOT_YOU_MORON
+#undef IRQ_LEVEL
+#define IRQ_LEVEL		GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 
@@ -60,3 +63,30 @@ static inline bool irq_settings_has_no_balance_set(struct irq_desc *desc)
 {
 	return desc->status & _IRQ_NO_BALANCING;
 }
+
+static inline u32 irq_settings_get_trigger_mask(struct irq_desc *desc)
+{
+	return desc->status & IRQ_TYPE_SENSE_MASK;
+}
+
+static inline void
+irq_settings_set_trigger_mask(struct irq_desc *desc, u32 mask)
+{
+	desc->status &= ~IRQ_TYPE_SENSE_MASK;
+	desc->status |= mask & IRQ_TYPE_SENSE_MASK;
+}
+
+static inline bool irq_settings_is_level(struct irq_desc *desc)
+{
+	return desc->status & _IRQ_LEVEL;
+}
+
+static inline void irq_settings_clr_level(struct irq_desc *desc)
+{
+	desc->status &= ~_IRQ_LEVEL;
+}
+
+static inline void irq_settings_set_level(struct irq_desc *desc)
+{
+	desc->status |= _IRQ_LEVEL;
+}

commit 2bdd10558c8d93009cb6c32ce9e30800fbb08add
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:22:00 2011 +0100

    genirq: Move IRQ_AFFINITY_SET to core
    
    Keep status in sync until last abuser is gone.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index ba0fffe410ad..da5acb446b1c 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -29,6 +29,8 @@ enum {
 #define IRQ_PER_CPU		GOT_YOU_MORON
 #undef IRQ_NO_BALANCING
 #define IRQ_NO_BALANCING	GOT_YOU_MORON
+#undef IRQ_AFFINITY_SET
+#define IRQ_AFFINITY_SET	GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
 

commit a005677b3dd05decdd8880cf3044ae709856f58f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:11:03 2011 +0100

    genirq: Mirror IRQ_PER_CPU and IRQ_NO_BALANCING in irq_data.state
    
    That's the right data structure to look at for arch code.
    
    Accessor functions are provided.
    
             irqd_is_per_cpu(irqdata);
             irqd_can_balance(irqdata);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index bb104a2dce73..ba0fffe410ad 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -4,6 +4,9 @@
  */
 enum {
 	_IRQ_DEFAULT_INIT_FLAGS	= IRQ_DEFAULT_INIT_FLAGS,
+	_IRQ_PER_CPU		= IRQ_PER_CPU,
+	_IRQ_NO_BALANCING	= IRQ_NO_BALANCING,
+	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
 };
 
 #undef IRQ_INPROGRESS
@@ -22,3 +25,36 @@ enum {
 #define IRQ_WAKEUP		GOT_YOU_MORON
 #undef IRQ_MOVE_PENDING
 #define IRQ_MOVE_PENDING	GOT_YOU_MORON
+#undef IRQ_PER_CPU
+#define IRQ_PER_CPU		GOT_YOU_MORON
+#undef IRQ_NO_BALANCING
+#define IRQ_NO_BALANCING	GOT_YOU_MORON
+#undef IRQF_MODIFY_MASK
+#define IRQF_MODIFY_MASK	GOT_YOU_MORON
+
+static inline void
+irq_settings_clr_and_set(struct irq_desc *desc, u32 clr, u32 set)
+{
+	desc->status &= ~(clr & _IRQF_MODIFY_MASK);
+	desc->status |= (set & _IRQF_MODIFY_MASK);
+}
+
+static inline bool irq_settings_is_per_cpu(struct irq_desc *desc)
+{
+	return desc->status & _IRQ_PER_CPU;
+}
+
+static inline void irq_settings_set_per_cpu(struct irq_desc *desc)
+{
+	desc->status |= _IRQ_PER_CPU;
+}
+
+static inline void irq_settings_set_no_balancing(struct irq_desc *desc)
+{
+	desc->status |= _IRQ_NO_BALANCING;
+}
+
+static inline bool irq_settings_has_no_balance_set(struct irq_desc *desc)
+{
+	return desc->status & _IRQ_NO_BALANCING;
+}

commit f230b6d5c48f8d12f4dfa1f8b5ab0b0320076d21
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 5 15:20:04 2011 +0100

    genirq: Add IRQ_MOVE_PENDING to irq_data.state
    
    chip implementations need to know about it. Keep status in sync until
    all users are fixed.
    
    Accessor function: irqd_is_setaffinity_pending(irqdata)
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index ef09824e4b32..bb104a2dce73 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -20,3 +20,5 @@ enum {
 #define IRQ_MASKED		GOT_YOU_MORON
 #undef IRQ_WAKEUP
 #define IRQ_WAKEUP		GOT_YOU_MORON
+#undef IRQ_MOVE_PENDING
+#define IRQ_MOVE_PENDING	GOT_YOU_MORON

commit 6d2cd17fde1fc3e93302815f049f255bb2b3123e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 14:34:18 2011 +0100

    genirq: Move IRQ_WAKEUP to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 2cd45fd5ec8a..ef09824e4b32 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -18,3 +18,5 @@ enum {
 #define IRQ_PENDING		GOT_YOU_MORON
 #undef IRQ_MASKED
 #define IRQ_MASKED		GOT_YOU_MORON
+#undef IRQ_WAKEUP
+#define IRQ_WAKEUP		GOT_YOU_MORON

commit 6e40262ea43c4b0e3f435b3a083e4461ef921c17
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:36:06 2011 +0100

    genirq: Move IRQ_MASKED to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 623fcf83e7de..2cd45fd5ec8a 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -16,3 +16,5 @@ enum {
 #define IRQ_DISABLED		GOT_YOU_MORON
 #undef IRQ_PENDING
 #define IRQ_PENDING		GOT_YOU_MORON
+#undef IRQ_MASKED
+#define IRQ_MASKED		GOT_YOU_MORON

commit 2a0d6fb335d4428285dab2d254911748e6040807
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:17:57 2011 +0100

    genirq: Move IRQ_PENDING flag to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 5e3411c7c62b..623fcf83e7de 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -14,3 +14,5 @@ enum {
 #define IRQ_WAITING		GOT_YOU_MORON
 #undef IRQ_DISABLED
 #define IRQ_DISABLED		GOT_YOU_MORON
+#undef IRQ_PENDING
+#define IRQ_PENDING		GOT_YOU_MORON

commit c1594b77e46124bb462f961e536120e471c67446
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 22:11:30 2011 +0100

    genirq: Move IRQ_DISABLED to core
    
    Keep status in sync until all abusers are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 2e7d08fff0ce..5e3411c7c62b 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -12,3 +12,5 @@ enum {
 #define IRQ_REPLAY		GOT_YOU_MORON
 #undef IRQ_WAITING
 #define IRQ_WAITING		GOT_YOU_MORON
+#undef IRQ_DISABLED
+#define IRQ_DISABLED		GOT_YOU_MORON

commit 163ef3091195f514a06f064b12914597d2644c55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 11:39:15 2011 +0100

    genirq: Move IRQ_REPLAY and IRQ_WAITING to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index a96140eea409..2e7d08fff0ce 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -8,3 +8,7 @@ enum {
 
 #undef IRQ_INPROGRESS
 #define IRQ_INPROGRESS		GOT_YOU_MORON
+#undef IRQ_REPLAY
+#define IRQ_REPLAY		GOT_YOU_MORON
+#undef IRQ_WAITING
+#define IRQ_WAITING		GOT_YOU_MORON

commit 009b4c3b8ad584b3462734127a5bec680d5d6af4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 21:48:49 2011 +0100

    genirq: Add IRQ_INPROGRESS to core
    
    We need to maintain the flag for now in both fields status and istate.
    Add a CONFIG_GENERIC_HARDIRQS_NO_COMPAT switch to allow testing w/o
    the status one. Wrap the access to status IRQ_INPROGRESS in a inline
    which can be turned of with CONFIG_GENERIC_HARDIRQS_NO_COMPAT along
    with the define.
    
    There is no reason that anything outside of core looks at this. That
    needs some modifications, but we'll get there.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 610f55597ce7..a96140eea409 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -5,3 +5,6 @@
 enum {
 	_IRQ_DEFAULT_INIT_FLAGS	= IRQ_DEFAULT_INIT_FLAGS,
 };
+
+#undef IRQ_INPROGRESS
+#define IRQ_INPROGRESS		GOT_YOU_MORON

commit e6bea9c404699223322d7411c6f2ceaec02fa83c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 13:16:52 2011 +0100

    genirq: Protect tglx from tripping over his own feet
    
    The irq_desc.status field will either go away or renamed to
    settings. Anyway we need to maintain compatibility to avoid breaking
    the world and some more. While moving bits into the core, I need to
    avoid that I use any of the still existing IRQ_ bits in the core code
    by typos. So that file will hold the inline wrappers and some nasty
    CPP tricks to break the build when typoed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
new file mode 100644
index 000000000000..610f55597ce7
--- /dev/null
+++ b/kernel/irq/settings.h
@@ -0,0 +1,7 @@
+/*
+ * Internal header to deal with irq_desc->status which will be renamed
+ * to irq_desc->settings.
+ */
+enum {
+	_IRQ_DEFAULT_INIT_FLAGS	= IRQ_DEFAULT_INIT_FLAGS,
+};
