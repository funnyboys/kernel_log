commit 625d3449788f85569096780592549d0340e9c0c7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jun 21 21:02:22 2020 -0600

    Revert "kernel/printk: add kmsg SEEK_CUR handling"
    
    This reverts commit 8ece3b3eb576a78d2e67ad4c3a80a39fa6708809.
    
    This commit broke userspace. Bash uses ESPIPE to determine whether or
    not the file should be read using "unbuffered I/O", which means reading
    1 byte at a time instead of 128 bytes at a time. I used to use bash to
    read through kmsg in a really quite nasty way:
    
        while read -t 0.1 -r line 2>/dev/null || [[ $? -ne 142 ]]; do
           echo "SARU $line"
        done < /dev/kmsg
    
    This will show all lines that can fit into the 128 byte buffer, and skip
    lines that don't. That's pretty awful, but at least it worked.
    
    With this change, bash now tries to do 1-byte reads, which means it
    skips all the lines, which is worse than before.
    
    Now, I don't really care very much about this, and I'm already look for
    a workaround. But I did just spend an hour trying to figure out why my
    scripts were broken. Either way, it makes no difference to me personally
    whether this is reverted, but it might be something to consider. If you
    declare that "trying to read /dev/kmsg with bash is terminally stupid
    anyway," I might be inclined to agree with you. But do note that bash
    uses lseek(fd, 0, SEEK_CUR)==>ESPIPE to determine whether or not it's
    reading from a pipe.
    
    Cc: Bruno Meneguele <bmeneg@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8c14835be46c..b71eaf5f5a86 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -974,16 +974,6 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 		user->idx = log_next_idx;
 		user->seq = log_next_seq;
 		break;
-	case SEEK_CUR:
-		/*
-		 * It isn't supported due to the record nature of this
-		 * interface: _SET _DATA and _END point to very specific
-		 * record positions, while _CUR would be more useful in case
-		 * of a byte-based log. Because of that, return the default
-		 * errno value for invalid seek operation.
-		 */
-		ret = -ESPIPE;
-		break;
 	default:
 		ret = -EINVAL;
 	}

commit 5c2fb57af0f42550eb718a3b0b445c81ec923895
Merge: 923ea1631e94 2a9e5ded9543
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 12 12:13:36 2020 -0700

    Merge tag 'printk-for-5.8-kdb-nmi' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux
    
    Pull printk fix from Petr Mladek:
     "One more printk change for 5.8: make sure that messages printed from
      KDB context are redirected to KDB console handlers. It did not work
      when KDB interrupted NMI or printk_safe contexts.
    
      Arm people started hitting this problem more often recently. I forgot
      to add the fix into the previous pull request by mistake"
    
    * tag 'printk-for-5.8-kdb-nmi' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux:
      printk/kdb: Redirect printk messages into kdb in any context

commit 2a9e5ded9543436620a7fbc9329ddcc32bf97bc7
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed May 20 12:22:33 2020 +0200

    printk/kdb: Redirect printk messages into kdb in any context
    
    kdb has to get messages on consoles even when the system is stopped.
    It uses kdb_printf() internally and calls console drivers on its own.
    
    It uses a hack to reuse an existing code. It sets "kdb_trap_printk"
    global variable to redirect even the normal printk() into the
    kdb_printf() variant.
    
    The variable "kdb_trap_printk" is checked in printk_default() and
    it is ignored when printk is redirected to printk_safe in NMI context.
    Solve this by moving the check into printk_func().
    
    It is obvious that it is not fully safe. But it does not make things
    worse. The console drivers are already called in this context by
    db_printf() direct calls.
    
    Reported-by: Sumit Garg <sumit.garg@linaro.org>
    Tested-by: Sumit Garg <sumit.garg@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Link: https://lore.kernel.org/r/20200520102233.GC3464@linux-b0ei

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9fdd6a42ad6a..2167bb528dd3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -35,7 +35,6 @@
 #include <linux/memblock.h>
 #include <linux/syscalls.h>
 #include <linux/crash_core.h>
-#include <linux/kdb.h>
 #include <linux/ratelimit.h>
 #include <linux/kmsg_dump.h>
 #include <linux/syslog.h>
@@ -2047,18 +2046,7 @@ EXPORT_SYMBOL(vprintk);
 
 int vprintk_default(const char *fmt, va_list args)
 {
-	int r;
-
-#ifdef CONFIG_KGDB_KDB
-	/* Allow to pass printk() to kdb but avoid a recursion. */
-	if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {
-		r = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
-		return r;
-	}
-#endif
-	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
-
-	return r;
+	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
 }
 EXPORT_SYMBOL_GPL(vprintk_default);
 

commit cb8e59cc87201af93dfbb6c3dccc8fcad72a09c2
Merge: 2e63f6ce7ed2 065fcfd49763
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 3 16:27:18 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next
    
    Pull networking updates from David Miller:
    
     1) Allow setting bluetooth L2CAP modes via socket option, from Luiz
        Augusto von Dentz.
    
     2) Add GSO partial support to igc, from Sasha Neftin.
    
     3) Several cleanups and improvements to r8169 from Heiner Kallweit.
    
     4) Add IF_OPER_TESTING link state and use it when ethtool triggers a
        device self-test. From Andrew Lunn.
    
     5) Start moving away from custom driver versions, use the globally
        defined kernel version instead, from Leon Romanovsky.
    
     6) Support GRO vis gro_cells in DSA layer, from Alexander Lobakin.
    
     7) Allow hard IRQ deferral during NAPI, from Eric Dumazet.
    
     8) Add sriov and vf support to hinic, from Luo bin.
    
     9) Support Media Redundancy Protocol (MRP) in the bridging code, from
        Horatiu Vultur.
    
    10) Support netmap in the nft_nat code, from Pablo Neira Ayuso.
    
    11) Allow UDPv6 encapsulation of ESP in the ipsec code, from Sabrina
        Dubroca. Also add ipv6 support for espintcp.
    
    12) Lots of ReST conversions of the networking documentation, from Mauro
        Carvalho Chehab.
    
    13) Support configuration of ethtool rxnfc flows in bcmgenet driver,
        from Doug Berger.
    
    14) Allow to dump cgroup id and filter by it in inet_diag code, from
        Dmitry Yakunin.
    
    15) Add infrastructure to export netlink attribute policies to
        userspace, from Johannes Berg.
    
    16) Several optimizations to sch_fq scheduler, from Eric Dumazet.
    
    17) Fallback to the default qdisc if qdisc init fails because otherwise
        a packet scheduler init failure will make a device inoperative. From
        Jesper Dangaard Brouer.
    
    18) Several RISCV bpf jit optimizations, from Luke Nelson.
    
    19) Correct the return type of the ->ndo_start_xmit() method in several
        drivers, it's netdev_tx_t but many drivers were using
        'int'. From Yunjian Wang.
    
    20) Add an ethtool interface for PHY master/slave config, from Oleksij
        Rempel.
    
    21) Add BPF iterators, from Yonghang Song.
    
    22) Add cable test infrastructure, including ethool interfaces, from
        Andrew Lunn. Marvell PHY driver is the first to support this
        facility.
    
    23) Remove zero-length arrays all over, from Gustavo A. R. Silva.
    
    24) Calculate and maintain an explicit frame size in XDP, from Jesper
        Dangaard Brouer.
    
    25) Add CAP_BPF, from Alexei Starovoitov.
    
    26) Support terse dumps in the packet scheduler, from Vlad Buslov.
    
    27) Support XDP_TX bulking in dpaa2 driver, from Ioana Ciornei.
    
    28) Add devm_register_netdev(), from Bartosz Golaszewski.
    
    29) Minimize qdisc resets, from Cong Wang.
    
    30) Get rid of kernel_getsockopt and kernel_setsockopt in order to
        eliminate set_fs/get_fs calls. From Christoph Hellwig.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next: (2517 commits)
      selftests: net: ip_defrag: ignore EPERM
      net_failover: fixed rollback in net_failover_open()
      Revert "tipc: Fix potential tipc_aead refcnt leak in tipc_crypto_rcv"
      Revert "tipc: Fix potential tipc_node refcnt leak in tipc_rcv"
      vmxnet3: allow rx flow hash ops only when rss is enabled
      hinic: add set_channels ethtool_ops support
      selftests/bpf: Add a default $(CXX) value
      tools/bpf: Don't use $(COMPILE.c)
      bpf, selftests: Use bpf_probe_read_kernel
      s390/bpf: Use bcr 0,%0 as tail call nop filler
      s390/bpf: Maintain 8-byte stack alignment
      selftests/bpf: Fix verifier test
      selftests/bpf: Fix sample_cnt shared between two threads
      bpf, selftests: Adapt cls_redirect to call csum_level helper
      bpf: Add csum_level helper for fixing up csum levels
      bpf: Fix up bpf_skb_adjust_room helper's skb csum setting
      sfc: add missing annotation for efx_ef10_try_update_nic_stats_vf()
      crypto/chtls: IPv6 support for inline TLS
      Crypto/chcr: Fixes a coccinile check error
      Crypto/chcr: Fixes compilations warnings
      ...

commit ca1f5df23f28228c46aa45d934abad38c6b6ff2e
Merge: 4d67829e1186 8b390ab725fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 1 12:13:30 2020 -0700

    Merge tag 'printk-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux
    
    Pull printk updates from Petr Mladek:
    
     - Benjamin Herrenschmidt solved a problem with non-matched console
       aliases by first checking consoles defined on the command line. It is
       a more conservative approach than the previous attempts.
    
     - Benjamin also made sure that the console accessible via /dev/console
       always has CON_CONSDEV flag.
    
     - Andy Shevchenko added the %ptT modifier for printing struct time64_t.
       It extends the existing %ptR handling for struct rtc_time.
    
     - Bruno Meneguele fixed /dev/kmsg error value returned by unsupported
       SEEK_CUR.
    
     - Tetsuo Handa removed unused pr_cont_once().
    
    ... and a few small fixes.
    
    * tag 'printk-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux:
      printk: Remove pr_cont_once()
      printk: handle blank console arguments passed in.
      kernel/printk: add kmsg SEEK_CUR handling
      printk: Fix a typo in comment "interator"->"iterator"
      usb: pulse8-cec: Switch to use %ptT
      ARM: bcm2835: Switch to use %ptT
      lib/vsprintf: Print time64_t in human readable format
      lib/vsprintf: update comment about simple_strto<foo>() functions
      printk: Correctly set CON_CONSDEV even when preferred console was not registered
      printk: Fix preferred console selection with multiple matches
      printk: Move console matching logic into a separate function
      printk: Convert a use of sprintf to snprintf in console_unlock

commit d053cf0d771f6547cb0537759a9af63cf402908d
Merge: 6a0af9fc8cce eb012d125a24
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Jun 1 10:15:16 2020 +0200

    Merge branch 'for-5.8' into for-linus

commit 6a0af9fc8ccef5304ef88dc7e27362732e047076
Merge: e8cc2b97ca5a 33225d7b0ac9
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Jun 1 10:13:51 2020 +0200

    Merge branch 'for-5.7-preferred-console' into for-linus

commit fb13cb8a0482105a415e24042209d02a684255e2
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 7 19:36:22 2020 -0700

    printk: Introduce kmsg_dump_reason_str()
    
    The pstore subsystem already had a private version of this function.
    With the coming addition of the pstore/zone driver, this needs to be
    shared. As it really should live with printk, move it there instead.
    
    Link: https://lore.kernel.org/lkml/20200515184434.8470-4-keescook@chromium.org/
    Acked-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a121c2255737..14ca4d05d902 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3144,6 +3144,23 @@ EXPORT_SYMBOL_GPL(kmsg_dump_unregister);
 static bool always_kmsg_dump;
 module_param_named(always_kmsg_dump, always_kmsg_dump, bool, S_IRUGO | S_IWUSR);
 
+const char *kmsg_dump_reason_str(enum kmsg_dump_reason reason)
+{
+	switch (reason) {
+	case KMSG_DUMP_PANIC:
+		return "Panic";
+	case KMSG_DUMP_OOPS:
+		return "Oops";
+	case KMSG_DUMP_EMERG:
+		return "Emergency";
+	case KMSG_DUMP_SHUTDOWN:
+		return "Shutdown";
+	default:
+		return "Unknown";
+	}
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_reason_str);
+
 /**
  * kmsg_dump - dump kernel log to kernel message dumpers.
  * @reason: the reason (oops, panic etc) for dumping

commit b1f6f161b236d0e5a9222fb8b482e65aaff13689
Author: Pavel Tatashin <pasha.tatashin@soleen.com>
Date:   Tue May 5 11:45:06 2020 -0400

    printk: honor the max_reason field in kmsg_dumper
    
    kmsg_dump() allows to dump kmesg buffer for various system events: oops,
    panic, reboot, etc. It provides an interface to register a callback
    call for clients, and in that callback interface there is a field
    "max_reason", but it was getting ignored when set to any "reason"
    higher than KMSG_DUMP_OOPS unless "always_kmsg_dump" was passed as
    kernel parameter.
    
    Allow clients to actually control their "max_reason", and keep the
    current behavior when "max_reason" is not set.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Link: https://lore.kernel.org/lkml/20200515184434.8470-3-keescook@chromium.org/
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9a9b6156270b..a121c2255737 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3157,12 +3157,19 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 	struct kmsg_dumper *dumper;
 	unsigned long flags;
 
-	if ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)
-		return;
-
 	rcu_read_lock();
 	list_for_each_entry_rcu(dumper, &dump_list, list) {
-		if (dumper->max_reason && reason > dumper->max_reason)
+		enum kmsg_dump_reason max_reason = dumper->max_reason;
+
+		/*
+		 * If client has not provided a specific max_reason, default
+		 * to KMSG_DUMP_OOPS, unless always_kmsg_dump was set.
+		 */
+		if (max_reason == KMSG_DUMP_UNDEF) {
+			max_reason = always_kmsg_dump ? KMSG_DUMP_MAX :
+							KMSG_DUMP_OOPS;
+		}
+		if (reason > max_reason)
 			continue;
 
 		/* initialize iterator with data about the stored records */

commit 48021f98130880dd74286459a1ef48b5e9bc374f
Author: Shreyas Joshi <shreyas.joshi@biamp.com>
Date:   Fri May 22 16:53:06 2020 +1000

    printk: handle blank console arguments passed in.
    
    If uboot passes a blank string to console_setup then it results in
    a trashed memory. Ultimately, the kernel crashes during freeing up
    the memory.
    
    This fix checks if there is a blank parameter being
    passed to console_setup from uboot. In case it detects that
    the console parameter is blank then it doesn't setup the serial
    device and it gracefully exits.
    
    Link: https://lore.kernel.org/r/20200522065306.83-1-shreyas.joshi@biamp.com
    Signed-off-by: Shreyas Joshi <shreyas.joshi@biamp.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: Better format the commit message and code, remove unnecessary brackets.]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 35cc5f548860..a3990505abdf 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2200,6 +2200,9 @@ static int __init console_setup(char *str)
 	char *s, *options, *brl_options = NULL;
 	int idx;
 
+	if (str[0] == 0)
+		return 1;
+
 	if (_braille_console_setup(&str, &brl_options))
 		return 1;
 

commit 8ece3b3eb576a78d2e67ad4c3a80a39fa6708809
Author: Bruno Meneguele <bmeneg@redhat.com>
Date:   Tue Mar 17 07:33:44 2020 -0300

    kernel/printk: add kmsg SEEK_CUR handling
    
    Userspace libraries, e.g. glibc's dprintf(), perform a SEEK_CUR operation
    over any file descriptor requested to make sure the current position isn't
    pointing to junk due to previous manipulation of that same fd. And whenever
    that fd doesn't have support for such operation, the userspace code expects
    -ESPIPE to be returned.
    
    However, when the fd in question references the /dev/kmsg interface, the
    current kernel code state returns -EINVAL instead, causing an unexpected
    behavior in userspace: in the case of glibc, when -ESPIPE is returned it
    gets ignored and the call completes successfully, while returning -EINVAL
    forces dprintf to fail without performing any action over that fd:
    
      if (_IO_SEEKOFF (fp, (off64_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT) ==
      _IO_pos_BAD && errno != ESPIPE)
        return NULL;
    
    With this patch we make sure to return the correct value when SEEK_CUR is
    requested over kmsg and also add some kernel doc information to formalize
    this behavior.
    
    Link: https://lore.kernel.org/r/20200317103344.574277-1-bmeneg@redhat.com
    Cc: linux-kernel@vger.kernel.org
    Cc: rostedt@goodmis.org,
    Cc: David.Laight@ACULAB.COM
    Signed-off-by: Bruno Meneguele <bmeneg@redhat.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 525038745a14..35cc5f548860 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -974,6 +974,16 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 		user->idx = log_next_idx;
 		user->seq = log_next_seq;
 		break;
+	case SEEK_CUR:
+		/*
+		 * It isn't supported due to the record nature of this
+		 * interface: _SET _DATA and _END point to very specific
+		 * record positions, while _CUR would be more useful in case
+		 * of a byte-based log. Because of that, return the default
+		 * errno value for invalid seek operation.
+		 */
+		ret = -ESPIPE;
+		break;
 	default:
 		ret = -EINVAL;
 	}

commit 325606af573152e02f44d791f152b7f9564bcb30
Author: Ethon Paul <ethp@qq.com>
Date:   Sat Apr 18 19:35:36 2020 +0800

    printk: Fix a typo in comment "interator"->"iterator"
    
    There is a typo in comment, fix it.
    
    Signed-off-by: Ethon Paul <ethp@qq.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9a9b6156270b..525038745a14 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3360,7 +3360,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 EXPORT_SYMBOL_GPL(kmsg_dump_get_buffer);
 
 /**
- * kmsg_dump_rewind_nolock - reset the interator (unlocked version)
+ * kmsg_dump_rewind_nolock - reset the iterator (unlocked version)
  * @dumper: registered kmsg dumper
  *
  * Reset the dumper's iterator so that kmsg_dump_get_line() and
@@ -3378,7 +3378,7 @@ void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
 }
 
 /**
- * kmsg_dump_rewind - reset the interator
+ * kmsg_dump_rewind - reset the iterator
  * @dumper: registered kmsg dumper
  *
  * Reset the dumper's iterator so that kmsg_dump_get_line() and

commit 32927393dc1ccd60fb2bdc05b9e8e88753761469
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 24 08:43:38 2020 +0200

    sysctl: pass kernel pointers to ->proc_handler
    
    Instead of having all the sysctl handlers deal with user pointers, which
    is rather hairy in terms of the BPF interaction, copy the input to and
    from  userspace in common code.  This also means that the strings are
    always NUL-terminated by the common code, making the API a little bit
    safer.
    
    As most handler just pass through the data to one of the common handlers
    a lot of the changes are mechnical.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9a9b6156270b..471f649b5868 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -173,7 +173,7 @@ __setup("printk.devkmsg=", control_devkmsg);
 char devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = "ratelimit";
 
 int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,
-			      void __user *buffer, size_t *lenp, loff_t *ppos)
+			      void *buffer, size_t *lenp, loff_t *ppos)
 {
 	char old_str[DEVKMSG_STR_MAX_SIZE];
 	unsigned int old;

commit ab6f762f0f53162d41497708b33c9a3236d3609e
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Mar 3 20:30:02 2020 +0900

    printk: queue wake_up_klogd irq_work only if per-CPU areas are ready
    
    printk_deferred(), similarly to printk_safe/printk_nmi, does not
    immediately attempt to print a new message on the consoles, avoiding
    calls into non-reentrant kernel paths, e.g. scheduler or timekeeping,
    which potentially can deadlock the system.
    
    Those printk() flavors, instead, rely on per-CPU flush irq_work to print
    messages from safer contexts.  For same reasons (recursive scheduler or
    timekeeping calls) printk() uses per-CPU irq_work in order to wake up
    user space syslog/kmsg readers.
    
    However, only printk_safe/printk_nmi do make sure that per-CPU areas
    have been initialised and that it's safe to modify per-CPU irq_work.
    This means that, for instance, should printk_deferred() be invoked "too
    early", that is before per-CPU areas are initialised, printk_deferred()
    will perform illegal per-CPU access.
    
    Lech Perczak [0] reports that after commit 1b710b1b10ef ("char/random:
    silence a lockdep splat with printk()") user-space syslog/kmsg readers
    are not able to read new kernel messages.
    
    The reason is printk_deferred() being called too early (as was pointed
    out by Petr and John).
    
    Fix printk_deferred() and do not queue per-CPU irq_work before per-CPU
    areas are initialized.
    
    Link: https://lore.kernel.org/lkml/aa0732c6-5c4e-8a8b-a1c1-75ebe3dca05b@camlintechnologies.com/
    Reported-by: Lech Perczak <l.perczak@camlintechnologies.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Jann Horn <jannh@google.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 633f41a11d75..9a9b6156270b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -460,6 +460,18 @@ static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
 
+/*
+ * We cannot access per-CPU data (e.g. per-CPU flush irq_work) before
+ * per_cpu_areas are initialised. This variable is set to true when
+ * it's safe to access per-CPU data.
+ */
+static bool __printk_percpu_data_ready __read_mostly;
+
+bool printk_percpu_data_ready(void)
+{
+	return __printk_percpu_data_ready;
+}
+
 /* Return log buffer address */
 char *log_buf_addr_get(void)
 {
@@ -1146,12 +1158,28 @@ static void __init log_buf_add_cpu(void)
 static inline void log_buf_add_cpu(void) {}
 #endif /* CONFIG_SMP */
 
+static void __init set_percpu_data_ready(void)
+{
+	printk_safe_init();
+	/* Make sure we set this flag only after printk_safe() init is done */
+	barrier();
+	__printk_percpu_data_ready = true;
+}
+
 void __init setup_log_buf(int early)
 {
 	unsigned long flags;
 	char *new_log_buf;
 	unsigned int free;
 
+	/*
+	 * Some archs call setup_log_buf() multiple times - first is very
+	 * early, e.g. from setup_arch(), and second - when percpu_areas
+	 * are initialised.
+	 */
+	if (!early)
+		set_percpu_data_ready();
+
 	if (log_buf != __log_buf)
 		return;
 
@@ -2975,6 +3003,9 @@ static DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) = {
 
 void wake_up_klogd(void)
 {
+	if (!printk_percpu_data_ready())
+		return;
+
 	preempt_disable();
 	if (waitqueue_active(&log_wait)) {
 		this_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);
@@ -2985,6 +3016,9 @@ void wake_up_klogd(void)
 
 void defer_console_output(void)
 {
+	if (!printk_percpu_data_ready())
+		return;
+
 	preempt_disable();
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
 	irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));

commit 33225d7b0ac9903c5701bbede7dfdaeba74ad6c3
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Feb 13 10:51:33 2020 +0100

    printk: Correctly set CON_CONSDEV even when preferred console was not registered
    
    CON_CONSDEV flag was historically used to put/keep the preferred console
    first in console_drivers list. Where the preferred console is the last
    on the command line.
    
    The ordering is important only when opening /dev/console:
    
      + tty_kopen()
        + tty_lookup_driver()
          + console_device()
    
    The flag was originally an implementation detail. But it was later
    made accessible from userspace via /proc/consoles. It was used,
    for example, by the tool "showconsole" to show the real tty
    accessible via /dev/console, see
    https://github.com/bitstreamout/showconsole
    
    Now, the current code sets CON_CONSDEV only for the preferred
    console or when a fallback console is added. The flag is not
    set when the preferred console is defined on the command line
    but it is not registered from some reasons.
    
    Simple solution is to set CON_CONSDEV flag for the first
    registered console. It will work most of the time because:
    
      + Most real consoles have console->device defined.
    
      + Boot consoles are removed in printk_late_init().
    
      + unregister_console() moves CON_CONSDEV flag to the next
        console.
    
    Clean solution would require checking con->device when the
    preferred console is registered and in unregister_console().
    
    Conclusion:
    
    Use the simple solution for now. It is better than the current
    state and good enough.
    
    The clean solution is not worth it. It would complicate the already
    complicated code without too much gain. Instead the code would deserve
    a complete rewrite.
    
    Link: https://lore.kernel.org/r/20200213095133.23176-4-pmladek@suse.com
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [pmladek@suse.com: Correct reasoning in the commit message, comment update.]
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f76ef3f0efca..cf0ceacdae2f 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2788,6 +2788,8 @@ void register_console(struct console *newcon)
 		console_drivers = newcon;
 		if (newcon->next)
 			newcon->next->flags &= ~CON_CONSDEV;
+		/* Ensure this flag is always set for the head of the list */
+		newcon->flags |= CON_CONSDEV;
 	} else {
 		newcon->next = console_drivers->next;
 		console_drivers->next = newcon;

commit e369d8227fd211be36242fc44a9dc2209e246b9a
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Feb 13 10:51:32 2020 +0100

    printk: Fix preferred console selection with multiple matches
    
    In the following circumstances, the rule of selecting the console
    corresponding to the last "console=" entry on the command line as
    the preferred console (CON_CONSDEV, ie, /dev/console) fails. This
    is a specific example, but it could happen with different consoles
    that have a similar name aliasing mechanism.
    
      - The kernel command line has both console=tty0 and console=ttyS0
        in that order (the latter with speed etc... arguments).
        This is common with some cloud setups such as Amazon Linux.
    
      - add_preferred_console is called early to register "uart0". In
        our case that happens from acpi_parse_spcr() on arm64 since the
        "enable_console" argument is true on that architecture. This causes
        "uart0" to become entry 0 of the console_cmdline array.
    
    Now, because of the above, what happens is:
    
      - add_preferred_console is called by the cmdline parsing for tty0
        and ttyS0 respectively, thus occupying entries 1 and 2 of the
        console_cmdline array (since this happens after ACPI SPCR parsing).
        At that point preferred_console is set to 2 as expected.
    
      - When the tty layer kicks in, it will call register_console for tty0.
        This will match entry 1 in console_cmdline array. It isn't our
        preferred console but because it's our only console at this point,
        it will end up "first" in the consoles list.
    
      - When 8250 probes the actual serial port later on, it calls
        register_console for ttyS0. At that point the loop in register_console
        tries to match it with the entries in the console_cmdline array.
        Ideally this should match ttyS0 in entry 2, which is preferred, causing
        it to be inserted first and to replace tty0 as CONSDEV. However, 8250
        provides a "match" hook in its struct console, and that hook will match
        "uart" as an alias to "ttyS". So we match uart0 at entry 0 in the array
        which is not the preferred console and will not match entry 2 which is
        since we break out of the loop on the first match. As a result,
        we don't set CONSDEV and don't insert it first, but second in
        the console list.
    
        As a result, we end up with tty0 remaining first in the array, and thus
        /dev/console going there instead of the last user specified one which
        is ttyS0.
    
    This tentative fix register_console() to scan first for consoles
    specified on the command line, and only if none is found, to then
    scan for consoles specified by the architecture.
    
    Link: https://lore.kernel.org/r/20200213095133.23176-3-pmladek@suse.com
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 0ebcdf53e75d..f76ef3f0efca 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2116,7 +2116,7 @@ asmlinkage __visible void early_printk(const char *fmt, ...)
 #endif
 
 static int __add_preferred_console(char *name, int idx, char *options,
-				   char *brl_options)
+				   char *brl_options, bool user_specified)
 {
 	struct console_cmdline *c;
 	int i;
@@ -2131,6 +2131,8 @@ static int __add_preferred_console(char *name, int idx, char *options,
 		if (strcmp(c->name, name) == 0 && c->index == idx) {
 			if (!brl_options)
 				preferred_console = i;
+			if (user_specified)
+				c->user_specified = true;
 			return 0;
 		}
 	}
@@ -2140,6 +2142,7 @@ static int __add_preferred_console(char *name, int idx, char *options,
 		preferred_console = i;
 	strlcpy(c->name, name, sizeof(c->name));
 	c->options = options;
+	c->user_specified = user_specified;
 	braille_set_options(c, brl_options);
 
 	c->index = idx;
@@ -2194,7 +2197,7 @@ static int __init console_setup(char *str)
 	idx = simple_strtoul(s, NULL, 10);
 	*s = 0;
 
-	__add_preferred_console(buf, idx, options, brl_options);
+	__add_preferred_console(buf, idx, options, brl_options, true);
 	console_set_on_cmdline = 1;
 	return 1;
 }
@@ -2215,7 +2218,7 @@ __setup("console=", console_setup);
  */
 int add_preferred_console(char *name, int idx, char *options)
 {
-	return __add_preferred_console(name, idx, options, NULL);
+	return __add_preferred_console(name, idx, options, NULL, false);
 }
 
 bool console_suspend_enabled = true;
@@ -2636,7 +2639,7 @@ early_param("keep_bootcon", keep_bootcon_setup);
  * Care need to be taken with consoles that are statically
  * enabled such as netconsole
  */
-static int try_enable_new_console(struct console *newcon)
+static int try_enable_new_console(struct console *newcon, bool user_specified)
 {
 	struct console_cmdline *c;
 	int i;
@@ -2644,6 +2647,8 @@ static int try_enable_new_console(struct console *newcon)
 	for (i = 0, c = console_cmdline;
 	     i < MAX_CMDLINECONSOLES && c->name[0];
 	     i++, c++) {
+		if (c->user_specified != user_specified)
+			continue;
 		if (!newcon->match ||
 		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
 			/* default matching */
@@ -2673,9 +2678,10 @@ static int try_enable_new_console(struct console *newcon)
 
 	/*
 	 * Some consoles, such as pstore and netconsole, can be enabled even
-	 * without matching.
+	 * without matching. Accept the pre-enabled consoles only when match()
+	 * and setup() had a change to be called.
 	 */
-	if (newcon->flags & CON_ENABLED)
+	if (newcon->flags & CON_ENABLED && c->user_specified ==	user_specified)
 		return 0;
 
 	return -ENOENT;
@@ -2752,11 +2758,12 @@ void register_console(struct console *newcon)
 		}
 	}
 
-	/*
-	 * See if this console matches one we selected on
-	 * the command line or if it was statically enabled
-	 */
-	err = try_enable_new_console(newcon);
+	/* See if this console matches one we selected on the command line */
+	err = try_enable_new_console(newcon, true);
+
+	/* If not, try to match against the platform default(s) */
+	if (err == -ENOENT)
+		err = try_enable_new_console(newcon, false);
 
 	/* printk() messages are not printed to the Braille console. */
 	if (err || newcon->flags & CON_BRL)

commit ad8cd1db80cc33337bdbee63c453ef6d5132474b
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Feb 13 10:51:31 2020 +0100

    printk: Move console matching logic into a separate function
    
    This moves the loop that tries to match a newly registered console
    with the command line or add_preferred_console list into a separate
    helper, in order to be able to call it multiple times in subsequent
    patches.
    
    Link: https://lore.kernel.org/r/20200213095133.23176-2-pmladek@suse.com
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fada22dc4ab6..0ebcdf53e75d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -280,6 +280,7 @@ static struct console *exclusive_console;
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
 
 static int preferred_console = -1;
+static bool has_preferred_console;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
@@ -2626,6 +2627,60 @@ static int __init keep_bootcon_setup(char *str)
 
 early_param("keep_bootcon", keep_bootcon_setup);
 
+/*
+ * This is called by register_console() to try to match
+ * the newly registered console with any of the ones selected
+ * by either the command line or add_preferred_console() and
+ * setup/enable it.
+ *
+ * Care need to be taken with consoles that are statically
+ * enabled such as netconsole
+ */
+static int try_enable_new_console(struct console *newcon)
+{
+	struct console_cmdline *c;
+	int i;
+
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++) {
+		if (!newcon->match ||
+		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
+			/* default matching */
+			BUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));
+			if (strcmp(c->name, newcon->name) != 0)
+				continue;
+			if (newcon->index >= 0 &&
+			    newcon->index != c->index)
+				continue;
+			if (newcon->index < 0)
+				newcon->index = c->index;
+
+			if (_braille_register_console(newcon, c))
+				return 0;
+
+			if (newcon->setup &&
+			    newcon->setup(newcon, c->options) != 0)
+				return -EIO;
+		}
+		newcon->flags |= CON_ENABLED;
+		if (i == preferred_console) {
+			newcon->flags |= CON_CONSDEV;
+			has_preferred_console = true;
+		}
+		return 0;
+	}
+
+	/*
+	 * Some consoles, such as pstore and netconsole, can be enabled even
+	 * without matching.
+	 */
+	if (newcon->flags & CON_ENABLED)
+		return 0;
+
+	return -ENOENT;
+}
+
 /*
  * The console driver calls this routine during kernel initialization
  * to register the console printing procedure with printk() and to
@@ -2647,11 +2702,9 @@ early_param("keep_bootcon", keep_bootcon_setup);
  */
 void register_console(struct console *newcon)
 {
-	int i;
 	unsigned long flags;
 	struct console *bcon = NULL;
-	struct console_cmdline *c;
-	static bool has_preferred;
+	int err;
 
 	if (console_drivers)
 		for_each_console(bcon)
@@ -2678,15 +2731,15 @@ void register_console(struct console *newcon)
 	if (console_drivers && console_drivers->flags & CON_BOOT)
 		bcon = console_drivers;
 
-	if (!has_preferred || bcon || !console_drivers)
-		has_preferred = preferred_console >= 0;
+	if (!has_preferred_console || bcon || !console_drivers)
+		has_preferred_console = preferred_console >= 0;
 
 	/*
 	 *	See if we want to use this console driver. If we
 	 *	didn't select a console we take the first one
 	 *	that registers here.
 	 */
-	if (!has_preferred) {
+	if (!has_preferred_console) {
 		if (newcon->index < 0)
 			newcon->index = 0;
 		if (newcon->setup == NULL ||
@@ -2694,47 +2747,19 @@ void register_console(struct console *newcon)
 			newcon->flags |= CON_ENABLED;
 			if (newcon->device) {
 				newcon->flags |= CON_CONSDEV;
-				has_preferred = true;
+				has_preferred_console = true;
 			}
 		}
 	}
 
 	/*
-	 *	See if this console matches one we selected on
-	 *	the command line.
+	 * See if this console matches one we selected on
+	 * the command line or if it was statically enabled
 	 */
-	for (i = 0, c = console_cmdline;
-	     i < MAX_CMDLINECONSOLES && c->name[0];
-	     i++, c++) {
-		if (!newcon->match ||
-		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
-			/* default matching */
-			BUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));
-			if (strcmp(c->name, newcon->name) != 0)
-				continue;
-			if (newcon->index >= 0 &&
-			    newcon->index != c->index)
-				continue;
-			if (newcon->index < 0)
-				newcon->index = c->index;
-
-			if (_braille_register_console(newcon, c))
-				return;
-
-			if (newcon->setup &&
-			    newcon->setup(newcon, c->options) != 0)
-				break;
-		}
-
-		newcon->flags |= CON_ENABLED;
-		if (i == preferred_console) {
-			newcon->flags |= CON_CONSDEV;
-			has_preferred = true;
-		}
-		break;
-	}
+	err = try_enable_new_console(newcon);
 
-	if (!(newcon->flags & CON_ENABLED))
+	/* printk() messages are not printed to the Braille console. */
+	if (err || newcon->flags & CON_BRL)
 		return;
 
 	/*

commit 5661dd95a2958634485bb1a53f90a6ab621d4b0c
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Jan 30 15:16:44 2020 -0700

    printk: Convert a use of sprintf to snprintf in console_unlock
    
    When CONFIG_PRINTK is disabled (e.g. when building allnoconfig), clang
    warns:
    
    ../kernel/printk/printk.c:2416:10: warning: 'sprintf' will always
    overflow; destination buffer has size 0, but format string expands to at
    least 33 [-Wfortify-source]
                            len = sprintf(text,
                                  ^
    1 warning generated.
    
    It is not wrong; text has a zero size when CONFIG_PRINTK is disabled
    because LOG_LINE_MAX and PREFIX_MAX are both zero. Change to snprintf so
    that this case is explicitly handled without any risk of overflow.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/846
    Link: https://github.com/llvm/llvm-project/commit/6d485ff455ea2b37fef9e06e426dae6c1241b231
    Link: http://lkml.kernel.org/r/20200130221644.2273-1-natechancellor@gmail.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: clang-built-linux@googlegroups.com
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fada22dc4ab6..a44094727a5c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2413,9 +2413,9 @@ void console_unlock(void)
 		printk_safe_enter_irqsave(flags);
 		raw_spin_lock(&logbuf_lock);
 		if (console_seq < log_first_seq) {
-			len = sprintf(text,
-				      "** %llu printk messages dropped **\n",
-				      log_first_seq - console_seq);
+			len = snprintf(text, sizeof(text),
+				       "** %llu printk messages dropped **\n",
+				       log_first_seq - console_seq);
 
 			/* messages are gone, move to first one */
 			console_seq = log_first_seq;

commit ed31685c96e18f773ca11dd1a637974d62130673
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:30 2020 +0200

    console: Introduce ->exit() callback
    
    Some consoles might require special operations on unregistering.
    For instance, serial console, when registered in the kernel,
    keeps power on for entire time, until it gets unregistered.
    Example of use:
    
            ->setup(console):
                    pm_runtime_get(...);
    
            ->exit(console):
                    pm_runtime_put(...);
    
    For such cases to have a balance we would provide ->exit() callback.
    
    Link: http://lkml.kernel.org/r/20200203133130.11591-7-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f435a17ef988..633f41a11d75 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2853,6 +2853,9 @@ int unregister_console(struct console *console)
 	console_unlock();
 	console_sysfs_notify();
 
+	if (console->exit)
+		res = console->exit(console);
+
 	return res;
 
 out_disable_unlock:

commit e78bedbd42b7caa65551f3d56cbff451ccbd0aee
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:29 2020 +0200

    console: Don't notify user space when unregister non-listed console
    
    If console is not on the list then there is nothing for us to do
    and sysfs notify is pointless.
    
    Note, that nr_ext_console_drivers is being changed only for listed
    consoles.
    
    Suggested-by: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Link: http://lkml.kernel.org/r/20200203133130.11591-6-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 61d188f4c672..f435a17ef988 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2836,7 +2836,10 @@ int unregister_console(struct console *console)
 		}
 	}
 
-	if (!res && (console->flags & CON_EXTENDED))
+	if (res)
+		goto out_disable_unlock;
+
+	if (console->flags & CON_EXTENDED)
 		nr_ext_console_drivers--;
 
 	/*
@@ -2849,6 +2852,13 @@ int unregister_console(struct console *console)
 	console->flags &= ~CON_ENABLED;
 	console_unlock();
 	console_sysfs_notify();
+
+	return res;
+
+out_disable_unlock:
+	console->flags &= ~CON_ENABLED;
+	console_unlock();
+
 	return res;
 }
 EXPORT_SYMBOL(unregister_console);

commit bb72e3981d8e7bb80db7cebc57a4e10769a509c9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:28 2020 +0200

    console: Avoid positive return code from unregister_console()
    
    There are only two callers that use the returned code from
    unregister_console():
    
      - unregister_early_console() in arch/m68k/kernel/early_printk.c
      - kgdb_unregister_nmi_console() in drivers/tty/serial/kgdb_nmi.c
    
    They both expect to get "0" on success and a non-zero value on error.
    But the current behavior is confusing and buggy:
    
      - _braille_unregister_console() returns "1" on success
      - unregister_console() returns "1" on error
    
    Fix and clean up the behavior:
    
      - Return success when _braille_unregister_console() succeeded
      - Return a meaningful error code when the console was
        not registered before
    
    Link: http://lkml.kernel.org/r/20200203133130.11591-5-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b0c12c08cac4..61d188f4c672 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2816,10 +2816,12 @@ int unregister_console(struct console *console)
 		console->name, console->index);
 
 	res = _braille_unregister_console(console);
-	if (res)
+	if (res < 0)
 		return res;
+	if (res > 0)
+		return 0;
 
-	res = 1;
+	res = -ENODEV;
 	console_lock();
 	if (console_drivers == console) {
 		console_drivers=console->next;

commit d58ad10122e6f8f84b1ef60227233b7c5de2bc02
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:27 2020 +0200

    console: Drop misleading comment
    
            /* find the last or real console */
    
    This comment is misleading. The purpose of the loop is to check
    if we are trying to register boot console after a real one has
    already been registered. This is already mentioned in a comment
    above.
    
    Link: http://lkml.kernel.org/r/20200203133130.11591-4-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Suggested-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [pmladek@suse.com: Updated commit message.]
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d40a316908da..b0c12c08cac4 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2661,7 +2661,6 @@ void register_console(struct console *newcon)
 	 * already have a valid console
 	 */
 	if (newcon->flags & CON_BOOT) {
-		/* find the last or real console */
 		for_each_console(bcon) {
 			if (!(bcon->flags & CON_BOOT)) {
 				pr_info("Too late to register bootconsole %s%d\n",

commit 12825e6ba8ea8efbb6d81363b0cf6b5bf84c051a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:26 2020 +0200

    console: Use for_each_console() helper in unregister_console()
    
    We have rather open coded single linked list manipulations where we may
    simple use for_each_console() helper with properly set exit conditions.
    
    Replace open coded single-linked list handling with for_each_console()
    helper in use.
    
    Link: http://lkml.kernel.org/r/20200203133130.11591-3-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 51337ed426e0..d40a316908da 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2809,7 +2809,7 @@ EXPORT_SYMBOL(register_console);
 
 int unregister_console(struct console *console)
 {
-        struct console *a, *b;
+	struct console *con;
 	int res;
 
 	pr_info("%sconsole [%s%d] disabled\n",
@@ -2825,11 +2825,10 @@ int unregister_console(struct console *console)
 	if (console_drivers == console) {
 		console_drivers=console->next;
 		res = 0;
-	} else if (console_drivers) {
-		for (a=console_drivers->next, b=console_drivers ;
-		     a; b=a, a=b->next) {
-			if (a == console) {
-				b->next = a->next;
+	} else {
+		for_each_console(con) {
+			if (con->next == console) {
+				con->next = console->next;
 				res = 0;
 				break;
 			}

commit caa72c3bc584bc28b557bcf1a47532a7a6f37e6f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 3 15:31:25 2020 +0200

    console: Drop double check for console_drivers being non-NULL
    
    There is no need to explicitly check for console_drivers to be non-NULL
    since for_each_console() does this.
    
    Link: http://lkml.kernel.org/r/20200203133130.11591-2-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fada22dc4ab6..51337ed426e0 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1772,9 +1772,6 @@ static void call_console_drivers(const char *ext_text, size_t ext_len,
 
 	trace_console_rcuidle(text, len);
 
-	if (!console_drivers)
-		return;
-
 	for_each_console(con) {
 		if (exclusive_console && con != exclusive_console)
 			continue;
@@ -2653,18 +2650,17 @@ void register_console(struct console *newcon)
 	struct console_cmdline *c;
 	static bool has_preferred;
 
-	if (console_drivers)
-		for_each_console(bcon)
-			if (WARN(bcon == newcon,
-					"console '%s%d' already registered\n",
-					bcon->name, bcon->index))
-				return;
+	for_each_console(bcon) {
+		if (WARN(bcon == newcon, "console '%s%d' already registered\n",
+					 bcon->name, bcon->index))
+			return;
+	}
 
 	/*
 	 * before we register a new CON_BOOT console, make sure we don't
 	 * already have a valid console
 	 */
-	if (console_drivers && newcon->flags & CON_BOOT) {
+	if (newcon->flags & CON_BOOT) {
 		/* find the last or real console */
 		for_each_console(bcon) {
 			if (!(bcon->flags & CON_BOOT)) {

commit def97da136515cb289a14729292c193e0a93bc64
Author: John Ogness <john.ogness@linutronix.de>
Date:   Thu Dec 19 12:59:22 2019 +0106

    printk: fix exclusive_console replaying
    
    Commit f92b070f2dc8 ("printk: Do not miss new messages when replaying
    the log") introduced a new variable @exclusive_console_stop_seq to
    store when an exclusive console should stop printing. It should be
    set to the @console_seq value at registration. However, @console_seq
    is previously set to @syslog_seq so that the exclusive console knows
    where to begin. This results in the exclusive console immediately
    reactivating all the other consoles and thus repeating the messages
    for those consoles.
    
    Set @console_seq after @exclusive_console_stop_seq has stored the
    current @console_seq value.
    
    Fixes: f92b070f2dc8 ("printk: Do not miss new messages when replaying the log")
    Link: http://lkml.kernel.org/r/20191219115322.31160-1-john.ogness@linutronix.de
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: John Ogness <john.ogness@linutronix.de>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1ef6f75d92f1..fada22dc4ab6 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2770,8 +2770,6 @@ void register_console(struct console *newcon)
 		 * for us.
 		 */
 		logbuf_lock_irqsave(flags);
-		console_seq = syslog_seq;
-		console_idx = syslog_idx;
 		/*
 		 * We're about to replay the log buffer.  Only do this to the
 		 * just-registered console to avoid excessive message spam to
@@ -2783,6 +2781,8 @@ void register_console(struct console *newcon)
 		 */
 		exclusive_console = newcon;
 		exclusive_console_stop_seq = console_seq;
+		console_seq = syslog_seq;
+		console_idx = syslog_idx;
 		logbuf_unlock_irqrestore(flags);
 	}
 	console_unlock();

commit b22bfea7f16cda6e08918a3e9c7b4b99eb95ea70
Merge: 2dff2a1c9b7c 407e62f52aad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 3 09:29:50 2019 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Ingo Molnar:
     "Most of the IRQ subsystem changes in this cycle were irq-chip driver
      updates:
    
       - Qualcomm PDC wakeup interrupt support
    
       - Layerscape external IRQ support
    
       - Broadcom bcm7038 PM and wakeup support
    
       - Ingenic driver cleanup and modernization
    
       - GICv3 ITS preparation for GICv4.1 updates
    
       - GICv4 fixes
    
      There's also the series from Frederic Weisbecker that fixes memory
      ordering bugs for the irq-work logic, whose primary fix is to turn
      work->irq_work.flags into an atomic variable and then convert the
      complex (and buggy) atomic_cmpxchg() loop in irq_work_claim() into a
      much simpler atomic_fetch_or() call.
    
      There are also various smaller cleanups"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (44 commits)
      pinctrl/sdm845: Add PDC wakeup interrupt map for GPIOs
      pinctrl/msm: Setup GPIO chip in hierarchy
      irqchip/qcom-pdc: Add irqchip set/get state calls
      irqchip/qcom-pdc: Add irqdomain for wakeup capable GPIOs
      irqchip/qcom-pdc: Do not toggle IRQ_ENABLE during mask/unmask
      irqchip/qcom-pdc: Update max PDC interrupts
      of/irq: Document properties for wakeup interrupt parent
      genirq: Introduce irq_chip_get/set_parent_state calls
      irqdomain: Add bus token DOMAIN_BUS_WAKEUP
      genirq: Fix function documentation of __irq_alloc_descs()
      irq_work: Fix IRQ_WORK_BUSY bit clearing
      irqchip/ti-sci-inta: Use ERR_CAST inlined function instead of ERR_PTR(PTR_ERR(...))
      irq_work: Slightly simplify IRQ_WORK_PENDING clearing
      irq_work: Fix irq_work_claim() memory ordering
      irq_work: Convert flags to atomic_t
      irqchip: Ingenic: Add process for more than one irq at the same time.
      irqchip: ingenic: Alloc generic chips from IRQ domain
      irqchip: ingenic: Get virq number from IRQ domain
      irqchip: ingenic: Error out if IRQ domain creation failed
      irqchip: ingenic: Drop redundant irq_suspend / irq_resume functions
      ...

commit 153bedbac2ebd475e1c7c2d2fa0c042f5525927d
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Fri Nov 8 17:08:55 2019 +0100

    irq_work: Convert flags to atomic_t
    
    We need to convert flags to atomic_t in order to later fix an ordering
    issue on atomic_cmpxchg() failure. This will allow us to use atomic_fetch_or().
    
    Also clarify the nature of those flags.
    
    [ mingo: Converted two more usage site the original patch missed. ]
    
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E . McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191108160858.31665-2-frederic@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ca65327a6de8..865727373a3b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2961,7 +2961,7 @@ static void wake_up_klogd_work_func(struct irq_work *irq_work)
 
 static DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) = {
 	.func = wake_up_klogd_work_func,
-	.flags = IRQ_WORK_LAZY,
+	.flags = ATOMIC_INIT(IRQ_WORK_LAZY),
 };
 
 void wake_up_klogd(void)

commit 5facae4f3549b5cf7c0e10ec312a65ffd43b5726
Author: Qian Cai <cai@lca.pw>
Date:   Thu Sep 19 12:09:40 2019 -0400

    locking/lockdep: Remove unused @nested argument from lock_release()
    
    Since the following commit:
    
      b4adfe8e05f1 ("locking/lockdep: Remove unused argument in __lock_release")
    
    @nested is no longer used in lock_release(), so remove it from all
    lock_release() calls and friends.
    
    Signed-off-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Will Deacon <will@kernel.org>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: airlied@linux.ie
    Cc: akpm@linux-foundation.org
    Cc: alexander.levin@microsoft.com
    Cc: daniel@iogearbox.net
    Cc: davem@davemloft.net
    Cc: dri-devel@lists.freedesktop.org
    Cc: duyuyang@gmail.com
    Cc: gregkh@linuxfoundation.org
    Cc: hannes@cmpxchg.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: jack@suse.com
    Cc: jlbec@evilplan.or
    Cc: joonas.lahtinen@linux.intel.com
    Cc: joseph.qi@linux.alibaba.com
    Cc: jslaby@suse.com
    Cc: juri.lelli@redhat.com
    Cc: maarten.lankhorst@linux.intel.com
    Cc: mark@fasheh.com
    Cc: mhocko@kernel.org
    Cc: mripard@kernel.org
    Cc: ocfs2-devel@oss.oracle.com
    Cc: rodrigo.vivi@intel.com
    Cc: sean@poorly.run
    Cc: st@kernel.org
    Cc: tj@kernel.org
    Cc: tytso@mit.edu
    Cc: vdavydov.dev@gmail.com
    Cc: vincent.guittot@linaro.org
    Cc: viro@zeniv.linux.org.uk
    Link: https://lkml.kernel.org/r/1568909380-32199-1-git-send-email-cai@lca.pw
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ca65327a6de8..c8be5a0f5259 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -248,7 +248,7 @@ static void __up_console_sem(unsigned long ip)
 {
 	unsigned long flags;
 
-	mutex_release(&console_lock_dep_map, 1, ip);
+	mutex_release(&console_lock_dep_map, ip);
 
 	printk_safe_enter_irqsave(flags);
 	up(&console_sem);
@@ -1679,20 +1679,20 @@ static int console_lock_spinning_disable_and_check(void)
 	raw_spin_unlock(&console_owner_lock);
 
 	if (!waiter) {
-		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+		spin_release(&console_owner_dep_map, _THIS_IP_);
 		return 0;
 	}
 
 	/* The waiter is now free to continue */
 	WRITE_ONCE(console_waiter, false);
 
-	spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+	spin_release(&console_owner_dep_map, _THIS_IP_);
 
 	/*
 	 * Hand off console_lock to waiter. The waiter will perform
 	 * the up(). After this, the waiter is the console_lock owner.
 	 */
-	mutex_release(&console_lock_dep_map, 1, _THIS_IP_);
+	mutex_release(&console_lock_dep_map, _THIS_IP_);
 	return 1;
 }
 
@@ -1746,7 +1746,7 @@ static int console_trylock_spinning(void)
 	/* Owner will clear console_waiter on hand off */
 	while (READ_ONCE(console_waiter))
 		cpu_relax();
-	spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+	spin_release(&console_owner_dep_map, _THIS_IP_);
 
 	printk_safe_exit_irqrestore(flags);
 	/*

commit ae88de56a1893bdccc7b5af8c12556de649d675e
Merge: c9dccacfccc7 085a3a8fdf3e
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Sep 16 12:54:25 2019 +0200

    Merge branch 'for-5.4' into for-linus

commit 35c35493b0e3343522256f6054516f4e2161a6d4
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Fri Aug 9 15:10:34 2019 +0800

    printk: Replace strncmp() with str_has_prefix()
    
    strncmp(str, const, len) is error-prone because len is easy to have typo.
    An example is the hard-coded len has counting error or sizeof(const)
    forgets - 1.
    
    So we prefer using newly introduced str_has_prefix() to substitute
    such strncmp() to make code better.
    
    Link: http://lkml.kernel.org/r/20190809071034.17279-1-hslester96@gmail.com
    Cc: "Steven Rostedt" <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Reviewed-by:  Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: Slightly updated and reformatted the commit message.]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1888f6a3b694..43a31015ec93 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -118,19 +118,29 @@ static unsigned int __read_mostly devkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;
 
 static int __control_devkmsg(char *str)
 {
+	size_t len;
+
 	if (!str)
 		return -EINVAL;
 
-	if (!strncmp(str, "on", 2)) {
+	len = str_has_prefix(str, "on");
+	if (len) {
 		devkmsg_log = DEVKMSG_LOG_MASK_ON;
-		return 2;
-	} else if (!strncmp(str, "off", 3)) {
+		return len;
+	}
+
+	len = str_has_prefix(str, "off");
+	if (len) {
 		devkmsg_log = DEVKMSG_LOG_MASK_OFF;
-		return 3;
-	} else if (!strncmp(str, "ratelimit", 9)) {
+		return len;
+	}
+
+	len = str_has_prefix(str, "ratelimit");
+	if (len) {
 		devkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;
-		return 9;
+		return len;
 	}
+
 	return -EINVAL;
 }
 

commit c9dccacfccc72c32692eedff4a27a4b0833a2afd
Author: Vincent Whitchurch <vincent.whitchurch@axis.com>
Date:   Thu Jul 11 16:29:37 2019 +0200

    printk: Do not lose last line in kmsg buffer dump
    
    kmsg_dump_get_buffer() is supposed to select all the youngest log
    messages which fit into the provided buffer.  It determines the correct
    start index by using msg_print_text() with a NULL buffer to calculate
    the size of each entry.  However, when performing the actual writes,
    msg_print_text() only writes the entry to the buffer if the written len
    is lesser than the size of the buffer.  So if the lengths of the
    selected youngest log messages happen to precisely fill up the provided
    buffer, the last log message is not included.
    
    We don't want to modify msg_print_text() to fill up the buffer and start
    returning a length which is equal to the size of the buffer, since
    callers of its other users, such as kmsg_dump_get_line(), depend upon
    the current behaviour.
    
    Instead, fix kmsg_dump_get_buffer() to compensate for this.
    
    For example, with the following two final prints:
    
    [    6.427502] AAAAAAAAAAAAA
    [    6.427769] BBBBBBBB12345
    
    A dump of a 64-byte buffer filled by kmsg_dump_get_buffer(), before this
    patch:
    
     00000000: 3c 30 3e 5b 20 20 20 20 36 2e 35 32 32 31 39 37  <0>[    6.522197
     00000010: 5d 20 41 41 41 41 41 41 41 41 41 41 41 41 41 0a  ] AAAAAAAAAAAAA.
     00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
     00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    
    After this patch:
    
     00000000: 3c 30 3e 5b 20 20 20 20 36 2e 34 35 36 36 37 38  <0>[    6.456678
     00000010: 5d 20 42 42 42 42 42 42 42 42 31 32 33 34 35 0a  ] BBBBBBBB12345.
     00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
     00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    
    Link: http://lkml.kernel.org/r/20190711142937.4083-1-vincent.whitchurch@axis.com
    Fixes: e2ae715d66bf4bec ("kmsg - kmsg_dump() use iterator to receive log buffer content")
    To: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v3.5+
    Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1888f6a3b694..424abf802f02 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3274,7 +3274,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	/* move first record forward until length fits into the buffer */
 	seq = dumper->cur_seq;
 	idx = dumper->cur_idx;
-	while (l > size && seq < dumper->next_seq) {
+	while (l >= size && seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
 		l -= msg_print_text(msg, true, time, NULL, 0);

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a6e06fe38e41..1888f6a3b694 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/kernel/printk.c
  *

commit de6da1e8bcf0dd2058b950b127491821207679dc
Author: Feng Tang <feng.tang@intel.com>
Date:   Fri May 17 14:31:50 2019 -0700

    panic: add an option to replay all the printk message in buffer
    
    Currently on panic, kernel will lower the loglevel and print out pending
    printk msg only with console_flush_on_panic().
    
    Add an option for users to configure the "panic_print" to replay all
    dmesg in buffer, some of which they may have never seen due to the
    loglevel setting, which will help panic debugging .
    
    [feng.tang@intel.com: keep the original console_flush_on_panic() inside panic()]
      Link: http://lkml.kernel.org/r/1556199137-14163-1-git-send-email-feng.tang@intel.com
    [feng.tang@intel.com: use logbuf lock to protect the console log index]
      Link: http://lkml.kernel.org/r/1556269868-22654-1-git-send-email-feng.tang@intel.com
    Link: http://lkml.kernel.org/r/1556095872-36838-1-git-send-email-feng.tang@intel.com
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 17102fd4c136..a6e06fe38e41 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2535,10 +2535,11 @@ void console_unblank(void)
 
 /**
  * console_flush_on_panic - flush console content on panic
+ * @mode: flush all messages in buffer or just the pending ones
  *
  * Immediately output all pending messages no matter what.
  */
-void console_flush_on_panic(void)
+void console_flush_on_panic(enum con_flush_mode mode)
 {
 	/*
 	 * If someone else is holding the console lock, trylock will fail
@@ -2549,6 +2550,15 @@ void console_flush_on_panic(void)
 	 */
 	console_trylock();
 	console_may_schedule = 0;
+
+	if (mode == CONSOLE_REPLAY_ALL) {
+		unsigned long flags;
+
+		logbuf_lock_irqsave(flags);
+		console_seq = log_first_seq;
+		console_idx = log_first_idx;
+		logbuf_unlock_irqrestore(flags);
+	}
 	console_unlock();
 }
 

commit c39ea0b9dd24bf1bf2baa5cdbfa1905f3065347b
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue May 14 15:45:34 2019 -0700

    panic: avoid the extra noise dmesg
    
    When kernel panic happens, it will first print the panic call stack,
    then the ending msg like:
    
    [   35.743249] ---[ end Kernel panic - not syncing: Fatal exception
    [   35.749975] ------------[ cut here ]------------
    
    The above message are very useful for debugging.
    
    But if system is configured to not reboot on panic, say the
    "panic_timeout" parameter equals 0, it will likely print out many noisy
    message like WARN() call stack for each and every CPU except the panic
    one, messages like below:
    
            WARNING: CPU: 1 PID: 280 at kernel/sched/core.c:1198 set_task_cpu+0x183/0x190
            Call Trace:
            <IRQ>
            try_to_wake_up
            default_wake_function
            autoremove_wake_function
            __wake_up_common
            __wake_up_common_lock
            __wake_up
            wake_up_klogd_work_func
            irq_work_run_list
            irq_work_tick
            update_process_times
            tick_sched_timer
            __hrtimer_run_queues
            hrtimer_interrupt
            smp_apic_timer_interrupt
            apic_timer_interrupt
    
    For people working in console mode, the screen will first show the panic
    call stack, but immediately overridden by these noisy extra messages,
    which makes debugging much more difficult, as the original context gets
    lost on screen.
    
    Also these noisy messages will confuse some users, as I have seen many bug
    reporters posted the noisy message into bugzilla, instead of the real
    panic call stack and context.
    
    Adding a flag "suppress_printk" which gets set in panic() to avoid those
    noisy messages, without changing current kernel behavior that both panic
    blinking and sysrq magic key can work as is, suggested by Petr Mladek.
    
    To verify this, make sure kernel is not configured to reboot on panic and
    in console
     # echo c > /proc/sysrq-trigger
    to see if console only prints out the panic call stack.
    
    Link: http://lkml.kernel.org/r/1551430186-24169-1-git-send-email-feng.tang@intel.com
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Suggested-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 02ca827b8fac..17102fd4c136 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -86,6 +86,12 @@ static DEFINE_SEMAPHORE(console_sem);
 struct console *console_drivers;
 EXPORT_SYMBOL_GPL(console_drivers);
 
+/*
+ * System may need to suppress printk message under certain
+ * circumstances, like after kernel panic happens.
+ */
+int __read_mostly suppress_printk;
+
 #ifdef CONFIG_LOCKDEP
 static struct lockdep_map console_lock_dep_map = {
 	.name = "console_lock"
@@ -1943,6 +1949,10 @@ asmlinkage int vprintk_emit(int facility, int level,
 	unsigned long flags;
 	u64 curr_log_seq;
 
+	/* Suppress unimportant messages after panic happens */
+	if (unlikely(suppress_printk))
+		return 0;
+
 	if (level == LOGLEVEL_SCHED) {
 		level = LOGLEVEL_DEFAULT;
 		in_sched = true;

commit 2b9c272cf5cd81708e51b4ce3e432ce9566cfa47
Merge: 51b1ac0fa240 9a9f1d1a81a9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 15 14:22:59 2019 -0700

    Merge tag 'fbdev-v5.1' of git://github.com/bzolnier/linux
    
    Pull fbdev updates from Bartlomiej Zolnierkiewicz:
     "Just a couple of small fixes and cleanups:
    
       - fix memory access if logo is bigger than the screen (Manfred
         Schlaegl)
    
       - silence fbcon logo on 'quiet' boots (Prarit Bhargava)
    
       - use kvmalloc() for scrollback buffer in fbcon (Konstantin Khorenko)
    
       - misc fixes (Colin Ian King, YueHaibing, Matteo Croce, Mathieu
         Malaterre, Anders Roxell, Arnd Bergmann)
    
       - misc cleanups (Rob Herring, Lubomir Rintel, Greg Kroah-Hartman,
         Jani Nikula, Michal Vokáč)"
    
    * tag 'fbdev-v5.1' of git://github.com/bzolnier/linux:
      fbdev: mbx: fix a misspelled variable name
      fbdev: omap2: fix warnings in dss core
      video: fbdev: Fix potential NULL pointer dereference
      fbcon: Silence fbcon logo on 'quiet' boots
      printk: Export console_printk
      ARM: dts: imx28-cfa10036: Fix the reset gpio signal polarity
      video: ssd1307fb: Do not hard code active-low reset sequence
      dt-bindings: display: ssd1307fb: Remove reset-active-low from examples
      fbdev: fbmem: fix memory access if logo is bigger than the screen
      video/fbdev: refactor video= cmdline parsing
      fbdev: mbx: fix up debugfs file creation
      fbdev: omap2: no need to check return value of debugfs_create functions
      video: fbdev: geode: remove ifdef OLPC noise
      video: offb: annotate implicit fall throughs
      omapfb: fix typo
      fbdev: Use of_node_name_eq for node name comparisons
      fbcon: use kvmalloc() for scrollback buffer
      fbdev: chipsfb: remove set but not used variable 'size'
      fbdev/via: fix spelling mistake "Expandsion" -> "Expansion"

commit 26fb3dae0a1ec78bdde4b5b72e0e709503e8c596
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:42 2019 -0700

    memblock: drop memblock_alloc_*_nopanic() variants
    
    As all the memblock allocation functions return NULL in case of error
    rather than panic(), the duplicates with _nopanic suffix can be removed.
    
    Link: http://lkml.kernel.org/r/1548057848-15136-22-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Petr Mladek <pmladek@suse.com>             [printk]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Guo Ren <ren_guo@c-sky.com>                         [c-sky]
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Juergen Gross <jgross@suse.com>                     [Xen]
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8eee85bb2687..6b7654b8001f 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1143,14 +1143,7 @@ void __init setup_log_buf(int early)
 	if (!new_log_buf_len)
 		return;
 
-	if (early) {
-		new_log_buf =
-			memblock_alloc(new_log_buf_len, LOG_ALIGN);
-	} else {
-		new_log_buf = memblock_alloc_nopanic(new_log_buf_len,
-							  LOG_ALIGN);
-	}
-
+	new_log_buf = memblock_alloc(new_log_buf_len, LOG_ALIGN);
 	if (unlikely(!new_log_buf)) {
 		pr_err("log_buf_len: %lu bytes not available\n",
 			new_log_buf_len);

commit c4703acd6d4a58dc4b31ad2a8f8b14becb898d25
Merge: a448c643bc49 943ca6ad81e5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 9 09:22:42 2019 -0800

    Merge tag 'printk-for-5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow to sort mixed lines by an extra information about the caller
    
     - Remove no longer used LOG_PREFIX.
    
     - Some clean up and documentation update.
    
    * tag 'printk-for-5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk/docs: Add extra integer types to printk-formats
      printk: Remove no longer used LOG_PREFIX.
      lib/vsprintf: Remove %pCr remnant in comment
      printk: Pass caller information to log_store().
      printk: Add caller information to printk() output.

commit e36202a844d4eff2ab07bcef998d7b4beda9761f
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri Feb 22 18:59:40 2019 +0900

    printk: Remove no longer used LOG_PREFIX.
    
    When commit 5becfb1df5ac8e49 ("kmsg: merge continuation records while
    printing") introduced LOG_PREFIX, we used KERN_DEFAULT etc. as a flag
    for setting LOG_PREFIX in order to tell whether to call cont_add()
    (i.e. whether to append the message to "struct cont").
    
    But since commit 4bcc595ccd80decb ("printk: reinstate KERN_CONT for
    printing continuation lines") inverted the behavior (i.e. don't append
    the message to "struct cont" unless KERN_CONT is specified) and commit
    5aa068ea4082b39e ("printk: remove games with previous record flags")
    removed the last LOG_PREFIX check, setting LOG_PREFIX via KERN_DEFAULT
    etc. is no longer meaningful.
    
    Therefore, we can remove LOG_PREFIX and make KERN_DEFAULT empty string.
    
    Link: http://lkml.kernel.org/r/1550829580-9189-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp
    To: Steven Rostedt <rostedt@goodmis.org>
    To: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b4d26388bc62..9b6783c158f9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -345,7 +345,6 @@ static int console_msg_format = MSG_FORMAT_DEFAULT;
 
 enum log_flags {
 	LOG_NEWLINE	= 2,	/* text ended with a newline */
-	LOG_PREFIX	= 4,	/* text started with a prefix */
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
 };
 
@@ -1922,9 +1921,6 @@ int vprintk_store(int facility, int level,
 			case '0' ... '7':
 				if (level == LOGLEVEL_DEFAULT)
 					level = kern_level - '0';
-				/* fallthrough */
-			case 'd':	/* KERN_DEFAULT */
-				lflags |= LOG_PREFIX;
 				break;
 			case 'c':	/* KERN_CONT */
 				lflags |= LOG_CONT;
@@ -1939,7 +1935,7 @@ int vprintk_store(int facility, int level,
 		level = default_message_loglevel;
 
 	if (dict)
-		lflags |= LOG_PREFIX|LOG_NEWLINE;
+		lflags |= LOG_NEWLINE;
 
 	return log_output(facility, level, lflags,
 			  dict, dictlen, text, text_len);

commit cbae05d32ff68233f00cbad9fda0382cc982d821
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sat Feb 16 19:59:33 2019 +0900

    printk: Pass caller information to log_store().
    
    When thread1 called printk() which did not end with '\n', and then thread2
    called printk() which ends with '\n' before thread1 calls pr_cont(), the
    partial content saved into "struct cont" is flushed by thread2 despite the
    partial content was generated by thread1. This leads to confusing output
    as if the partial content was generated by thread2. Fix this problem by
    passing correct caller information to log_store().
    
    Before:
    
      [ T8533] abcdefghijklm
      [ T8533] ABCDEFGHIJKLMNOPQRSTUVWXYZ
      [ T8532] nopqrstuvwxyz
      [ T8532] abcdefghijklmnopqrstuvwxyz
      [ T8533] abcdefghijklm
      [ T8533] ABCDEFGHIJKLMNOPQRSTUVWXYZ
      [ T8532] nopqrstuvwxyz
    
    After:
    
      [ T8507] abcdefghijklm
      [ T8508] ABCDEFGHIJKLMNOPQRSTUVWXYZ
      [ T8507] nopqrstuvwxyz
      [ T8507] abcdefghijklmnopqrstuvwxyz
      [ T8507] abcdefghijklm
      [ T8508] ABCDEFGHIJKLMNOPQRSTUVWXYZ
      [ T8507] nopqrstuvwxyz
    
    Link: http://lkml.kernel.org/r/1550314773-8607-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp
    To: Dmitry Vyukov <dvyukov@google.com>
    To: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek: broke 80-column rule where it made more harm than good]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e3d977bbc7ab..b4d26388bc62 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -585,7 +585,7 @@ static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,
 }
 
 /* insert record into the buffer, discard old ones, update heads */
-static int log_store(int facility, int level,
+static int log_store(u32 caller_id, int facility, int level,
 		     enum log_flags flags, u64 ts_nsec,
 		     const char *dict, u16 dict_len,
 		     const char *text, u16 text_len)
@@ -634,10 +634,7 @@ static int log_store(int facility, int level,
 	else
 		msg->ts_nsec = local_clock();
 #ifdef CONFIG_PRINTK_CALLER
-	if (in_task())
-		msg->caller_id = task_pid_nr(current);
-	else
-		msg->caller_id = 0x80000000 + raw_smp_processor_id();
+	msg->caller_id = caller_id;
 #endif
 	memset(log_dict(msg) + dict_len, 0, pad_len);
 	msg->len = size;
@@ -1800,6 +1797,12 @@ static inline void printk_delay(void)
 	}
 }
 
+static inline u32 printk_caller_id(void)
+{
+	return in_task() ? task_pid_nr(current) :
+		0x80000000 + raw_smp_processor_id();
+}
+
 /*
  * Continuation lines are buffered, and not committed to the record buffer
  * until the line is complete, or a race forces it. The line fragments
@@ -1809,7 +1812,7 @@ static inline void printk_delay(void)
 static struct cont {
 	char buf[LOG_LINE_MAX];
 	size_t len;			/* length == 0 means unused buffer */
-	struct task_struct *owner;	/* task of first print*/
+	u32 caller_id;			/* printk_caller_id() of first print */
 	u64 ts_nsec;			/* time of first print */
 	u8 level;			/* log level of first message */
 	u8 facility;			/* log facility of first message */
@@ -1821,12 +1824,13 @@ static void cont_flush(void)
 	if (cont.len == 0)
 		return;
 
-	log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,
-		  NULL, 0, cont.buf, cont.len);
+	log_store(cont.caller_id, cont.facility, cont.level, cont.flags,
+		  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
 	cont.len = 0;
 }
 
-static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)
+static bool cont_add(u32 caller_id, int facility, int level,
+		     enum log_flags flags, const char *text, size_t len)
 {
 	/* If the line gets too long, split it up in separate records. */
 	if (cont.len + len > sizeof(cont.buf)) {
@@ -1837,7 +1841,7 @@ static bool cont_add(int facility, int level, enum log_flags flags, const char *
 	if (!cont.len) {
 		cont.facility = facility;
 		cont.level = level;
-		cont.owner = current;
+		cont.caller_id = caller_id;
 		cont.ts_nsec = local_clock();
 		cont.flags = flags;
 	}
@@ -1857,13 +1861,15 @@ static bool cont_add(int facility, int level, enum log_flags flags, const char *
 
 static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
 {
+	const u32 caller_id = printk_caller_id();
+
 	/*
 	 * If an earlier line was buffered, and we're a continuation
-	 * write from the same process, try to add it to the buffer.
+	 * write from the same context, try to add it to the buffer.
 	 */
 	if (cont.len) {
-		if (cont.owner == current && (lflags & LOG_CONT)) {
-			if (cont_add(facility, level, lflags, text, text_len))
+		if (cont.caller_id == caller_id && (lflags & LOG_CONT)) {
+			if (cont_add(caller_id, facility, level, lflags, text, text_len))
 				return text_len;
 		}
 		/* Otherwise, make sure it's flushed */
@@ -1876,12 +1882,13 @@ static size_t log_output(int facility, int level, enum log_flags lflags, const c
 
 	/* If it doesn't end in a newline, try to buffer the current line */
 	if (!(lflags & LOG_NEWLINE)) {
-		if (cont_add(facility, level, lflags, text, text_len))
+		if (cont_add(caller_id, facility, level, lflags, text, text_len))
 			return text_len;
 	}
 
 	/* Store it in the record log */
-	return log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);
+	return log_store(caller_id, facility, level, lflags, 0,
+			 dict, dictlen, text, text_len);
 }
 
 /* Must be called under logbuf_lock. */

commit a1939185c7a907f91b40da259a610ce2e2da9e18
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Fri Feb 8 19:24:49 2019 +0100

    printk: Export console_printk
    
    The fbcon can be built as a module and requires console_printk.
    
    Export console_printk.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d3d170374ceb..8201019d1fff 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -65,6 +65,7 @@ int console_printk[4] = {
 	CONSOLE_LOGLEVEL_MIN,		/* minimum_console_loglevel */
 	CONSOLE_LOGLEVEL_DEFAULT,	/* default_console_loglevel */
 };
+EXPORT_SYMBOL_GPL(console_printk);
 
 atomic_t ignore_console_lock_warning __read_mostly = ATOMIC_INIT(0);
 EXPORT_SYMBOL(ignore_console_lock_warning);

commit 96d4f267e40f9509e8a66e2b39e8b95655617693
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 18:57:57 2019 -0800

    Remove 'type' argument from access_ok() function
    
    Nobody has actually used the type (VERIFY_READ vs VERIFY_WRITE) argument
    of the user address range verification function since we got rid of the
    old racy i386-only code to walk page tables by hand.
    
    It existed because the original 80386 would not honor the write protect
    bit when in kernel mode, so you had to do COW by hand before doing any
    user access.  But we haven't supported that in a long time, and these
    days the 'type' argument is a purely historical artifact.
    
    A discussion about extending 'user_access_begin()' to do the range
    checking resulted this patch, because there is no way we're going to
    move the old VERIFY_xyz interface to that model.  And it's best done at
    the end of the merge window when I've done most of my merges, so let's
    just get this done once and for all.
    
    This patch was mostly done with a sed-script, with manual fix-ups for
    the cases that weren't of the trivial 'access_ok(VERIFY_xyz' form.
    
    There were a couple of notable cases:
    
     - csky still had the old "verify_area()" name as an alias.
    
     - the iter_iov code had magical hardcoded knowledge of the actual
       values of VERIFY_{READ,WRITE} (not that they mattered, since nothing
       really used it)
    
     - microblaze used the type argument for a debug printout
    
    but other than those oddities this should be a total no-op patch.
    
    I tried to fix up all architectures, did fairly extensive grepping for
    access_ok() uses, and the changes are trivial, but I may have missed
    something.  Any missed conversion should be trivially fixable, though.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1306fe0c1dc6..d3d170374ceb 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1466,7 +1466,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			return -EINVAL;
 		if (!len)
 			return 0;
-		if (!access_ok(VERIFY_WRITE, buf, len))
+		if (!access_ok(buf, len))
 			return -EFAULT;
 		error = wait_event_interruptible(log_wait,
 						 syslog_seq != log_next_seq);
@@ -1484,7 +1484,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			return -EINVAL;
 		if (!len)
 			return 0;
-		if (!access_ok(VERIFY_WRITE, buf, len))
+		if (!access_ok(buf, len))
 			return -EFAULT;
 		error = syslog_print_all(buf, len, clear);
 		break;

commit a3b5c1065f3fb934a87dd07d23def99916023d6f
Merge: c6f1b355d451 07c17732bd68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 27 11:24:43 2018 -0800

    Merge tag 'printk-for-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Keep spinlocks busted until the end of panic()
    
     - Fix races between calculating number of messages that would fit into
       user space buffers, filling the buffers, and switching printk.time
       parameter
    
     - Some code clean up
    
    * tag 'printk-for-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: Remove print_prefix() calls with NULL buffer.
      printk: fix printk_time race.
      printk: Make printk_emit() local function.
      panic: avoid deadlocks in re-entrant console drivers

commit 15ff2069cb7f967dae6a8f8c176ba51447c75f00
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Tue Dec 18 06:05:04 2018 +0900

    printk: Add caller information to printk() output.
    
    Sometimes we want to print a series of printk() messages to consoles
    without being disturbed by concurrent printk() from interrupts and/or
    other threads. But we can't enforce printk() callers to use their local
    buffers because we need to ask them to make too much changes. Also, even
    buffering up to one line inside printk() might cause failing to emit
    an important clue under critical situation.
    
    Therefore, instead of trying to help buffering, let's try to help
    reconstructing messages by saving caller information as of calling
    log_store() and adding it as "[T$thread_id]" or "[C$processor_id]"
    upon printing to consoles.
    
    Some examples for console output:
    
      [    1.222773][    T1] x86: Booting SMP configuration:
      [    2.779635][    T1] pci 0000:00:01.0: PCI bridge to [bus 01]
      [    5.069193][  T268] Fusion MPT base driver 3.04.20
      [    9.316504][    C2] random: fast init done
      [   13.413336][ T3355] Initialized host personality
    
    Some examples for /dev/kmsg output:
    
      6,496,1222773,-,caller=T1;x86: Booting SMP configuration:
      6,968,2779635,-,caller=T1;pci 0000:00:01.0: PCI bridge to [bus 01]
       SUBSYSTEM=pci
       DEVICE=+pci:0000:00:01.0
      6,1353,5069193,-,caller=T268;Fusion MPT base driver 3.04.20
      5,1526,9316504,-,caller=C2;random: fast init done
      6,1575,13413336,-,caller=T3355;Initialized host personality
    
    Note that this patch changes max length of messages which can be printed
    by printk() or written to /dev/kmsg interface from 992 bytes to 976 bytes,
    based on an assumption that userspace won't try to write messages hitting
    that border line to /dev/kmsg interface.
    
    Link: http://lkml.kernel.org/r/93f19e57-5051-c67d-9af4-b17624062d44@i-love.sakura.ne.jp
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: syzkaller <syzkaller@googlegroups.com>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 91db332ccf4d..e3d977bbc7ab 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -357,6 +357,9 @@ struct printk_log {
 	u8 facility;		/* syslog facility */
 	u8 flags:5;		/* internal record flags */
 	u8 level:3;		/* syslog level */
+#ifdef CONFIG_PRINTK_CALLER
+	u32 caller_id;            /* thread id or processor id */
+#endif
 }
 #ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
 __packed __aligned(4)
@@ -423,7 +426,11 @@ static u64 exclusive_console_stop_seq;
 static u64 clear_seq;
 static u32 clear_idx;
 
+#ifdef CONFIG_PRINTK_CALLER
+#define PREFIX_MAX		48
+#else
 #define PREFIX_MAX		32
+#endif
 #define LOG_LINE_MAX		(1024 - PREFIX_MAX)
 
 #define LOG_LEVEL(v)		((v) & 0x07)
@@ -626,6 +633,12 @@ static int log_store(int facility, int level,
 		msg->ts_nsec = ts_nsec;
 	else
 		msg->ts_nsec = local_clock();
+#ifdef CONFIG_PRINTK_CALLER
+	if (in_task())
+		msg->caller_id = task_pid_nr(current);
+	else
+		msg->caller_id = 0x80000000 + raw_smp_processor_id();
+#endif
 	memset(log_dict(msg) + dict_len, 0, pad_len);
 	msg->len = size;
 
@@ -689,12 +702,21 @@ static ssize_t msg_print_ext_header(char *buf, size_t size,
 				    struct printk_log *msg, u64 seq)
 {
 	u64 ts_usec = msg->ts_nsec;
+	char caller[20];
+#ifdef CONFIG_PRINTK_CALLER
+	u32 id = msg->caller_id;
+
+	snprintf(caller, sizeof(caller), ",caller=%c%u",
+		 id & 0x80000000 ? 'C' : 'T', id & ~0x80000000);
+#else
+	caller[0] = '\0';
+#endif
 
 	do_div(ts_usec, 1000);
 
-	return scnprintf(buf, size, "%u,%llu,%llu,%c;",
-		       (msg->facility << 3) | msg->level, seq, ts_usec,
-		       msg->flags & LOG_CONT ? 'c' : '-');
+	return scnprintf(buf, size, "%u,%llu,%llu,%c%s;",
+			 (msg->facility << 3) | msg->level, seq, ts_usec,
+			 msg->flags & LOG_CONT ? 'c' : '-', caller);
 }
 
 static ssize_t msg_print_ext_body(char *buf, size_t size,
@@ -1039,6 +1061,9 @@ void log_buf_vmcoreinfo_setup(void)
 	VMCOREINFO_OFFSET(printk_log, len);
 	VMCOREINFO_OFFSET(printk_log, text_len);
 	VMCOREINFO_OFFSET(printk_log, dict_len);
+#ifdef CONFIG_PRINTK_CALLER
+	VMCOREINFO_OFFSET(printk_log, caller_id);
+#endif
 }
 #endif
 
@@ -1237,10 +1262,23 @@ static size_t print_time(u64 ts, char *buf)
 {
 	unsigned long rem_nsec = do_div(ts, 1000000000);
 
-	return sprintf(buf, "[%5lu.%06lu] ",
+	return sprintf(buf, "[%5lu.%06lu]",
 		       (unsigned long)ts, rem_nsec / 1000);
 }
 
+#ifdef CONFIG_PRINTK_CALLER
+static size_t print_caller(u32 id, char *buf)
+{
+	char caller[12];
+
+	snprintf(caller, sizeof(caller), "%c%u",
+		 id & 0x80000000 ? 'C' : 'T', id & ~0x80000000);
+	return sprintf(buf, "[%6s]", caller);
+}
+#else
+#define print_caller(id, buf) 0
+#endif
+
 static size_t print_prefix(const struct printk_log *msg, bool syslog,
 			   bool time, char *buf)
 {
@@ -1248,8 +1286,17 @@ static size_t print_prefix(const struct printk_log *msg, bool syslog,
 
 	if (syslog)
 		len = print_syslog((msg->facility << 3) | msg->level, buf);
+
 	if (time)
 		len += print_time(msg->ts_nsec, buf + len);
+
+	len += print_caller(msg->caller_id, buf + len);
+
+	if (IS_ENABLED(CONFIG_PRINTK_CALLER) || time) {
+		buf[len++] = ' ';
+		buf[len] = '\0';
+	}
+
 	return len;
 }
 

commit 07c17732bd687567802aaa5fa5c101c2776565d1
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Tue Dec 11 18:49:05 2018 +0900

    printk: Remove print_prefix() calls with NULL buffer.
    
    We can save lines/size by removing print_prefix() with buf == NULL.
    This patch makes no functional change.
    
    Link: http://lkml.kernel.org/r/1544521745-11925-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index c7d217764db3..91db332ccf4d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1228,13 +1228,15 @@ static inline void boot_delay_msec(int level)
 static bool printk_time = IS_ENABLED(CONFIG_PRINTK_TIME);
 module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
 
+static size_t print_syslog(unsigned int level, char *buf)
+{
+	return sprintf(buf, "<%u>", level);
+}
+
 static size_t print_time(u64 ts, char *buf)
 {
 	unsigned long rem_nsec = do_div(ts, 1000000000);
 
-	if (!buf)
-		return snprintf(NULL, 0, "[%5lu.000000] ", (unsigned long)ts);
-
 	return sprintf(buf, "[%5lu.%06lu] ",
 		       (unsigned long)ts, rem_nsec / 1000);
 }
@@ -1243,24 +1245,11 @@ static size_t print_prefix(const struct printk_log *msg, bool syslog,
 			   bool time, char *buf)
 {
 	size_t len = 0;
-	unsigned int prefix = (msg->facility << 3) | msg->level;
-
-	if (syslog) {
-		if (buf) {
-			len += sprintf(buf, "<%u>", prefix);
-		} else {
-			len += 3;
-			if (prefix > 999)
-				len += 3;
-			else if (prefix > 99)
-				len += 2;
-			else if (prefix > 9)
-				len++;
-		}
-	}
 
+	if (syslog)
+		len = print_syslog((msg->facility << 3) | msg->level, buf);
 	if (time)
-		len += print_time(msg->ts_nsec, buf ? buf + len : NULL);
+		len += print_time(msg->ts_nsec, buf + len);
 	return len;
 }
 
@@ -1270,6 +1259,8 @@ static size_t msg_print_text(const struct printk_log *msg, bool syslog,
 	const char *text = log_text(msg);
 	size_t text_size = msg->text_len;
 	size_t len = 0;
+	char prefix[PREFIX_MAX];
+	const size_t prefix_len = print_prefix(msg, syslog, time, prefix);
 
 	do {
 		const char *next = memchr(text, '\n', text_size);
@@ -1284,19 +1275,17 @@ static size_t msg_print_text(const struct printk_log *msg, bool syslog,
 		}
 
 		if (buf) {
-			if (print_prefix(msg, syslog, time, NULL) +
-			    text_len + 1 >= size - len)
+			if (prefix_len + text_len + 1 >= size - len)
 				break;
 
-			len += print_prefix(msg, syslog, time, buf + len);
+			memcpy(buf + len, prefix, prefix_len);
+			len += prefix_len;
 			memcpy(buf + len, text, text_len);
 			len += text_len;
 			buf[len++] = '\n';
 		} else {
 			/* SYSLOG_ACTION_* buffer size only calculation */
-			len += print_prefix(msg, syslog, time, NULL);
-			len += text_len;
-			len++;
+			len += prefix_len + text_len + 1;
 		}
 
 		text = next;

commit e80c1a9d5f514ce5134c6c4263a11607341466c9
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Tue Dec 4 19:00:01 2018 +0900

    printk: fix printk_time race.
    
    Since printk_time can be toggled via /sys/module/printk/parameters/time ,
    it is not safe to assume that output length does not change across
    multiple msg_print_text() calls. If we hit this race, we can observe
    failures such as SYSLOG_ACTION_READ_ALL writes more bytes than userspace
    has supplied, SYSLOG_ACTION_SIZE_UNREAD returns -EFAULT when succeeded,
    SYSLOG_ACTION_READ reads garbage memory or even triggers an kernel oops
    at _copy_to_user() due to integer overflow.
    
    To close this race, get a snapshot value of printk_time and pass it to
    SYSLOG_ACTION_READ, SYSLOG_ACTION_READ_ALL, SYSLOG_ACTION_SIZE_UNREAD and
    kmsg_dump_get_buffer().
    
    Link: http://lkml.kernel.org/r/555af37c-b9e0-f940-cb73-a78eba2d4944@i-love.sakura.ne.jp
    To: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a1d88212a5d2..c7d217764db3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -404,6 +404,7 @@ DECLARE_WAIT_QUEUE_HEAD(log_wait);
 static u64 syslog_seq;
 static u32 syslog_idx;
 static size_t syslog_partial;
+static bool syslog_time;
 
 /* index and sequence number of the first record stored in the buffer */
 static u64 log_first_seq;
@@ -1229,12 +1230,7 @@ module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
 
 static size_t print_time(u64 ts, char *buf)
 {
-	unsigned long rem_nsec;
-
-	if (!printk_time)
-		return 0;
-
-	rem_nsec = do_div(ts, 1000000000);
+	unsigned long rem_nsec = do_div(ts, 1000000000);
 
 	if (!buf)
 		return snprintf(NULL, 0, "[%5lu.000000] ", (unsigned long)ts);
@@ -1243,7 +1239,8 @@ static size_t print_time(u64 ts, char *buf)
 		       (unsigned long)ts, rem_nsec / 1000);
 }
 
-static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)
+static size_t print_prefix(const struct printk_log *msg, bool syslog,
+			   bool time, char *buf)
 {
 	size_t len = 0;
 	unsigned int prefix = (msg->facility << 3) | msg->level;
@@ -1262,11 +1259,13 @@ static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)
 		}
 	}
 
-	len += print_time(msg->ts_nsec, buf ? buf + len : NULL);
+	if (time)
+		len += print_time(msg->ts_nsec, buf ? buf + len : NULL);
 	return len;
 }
 
-static size_t msg_print_text(const struct printk_log *msg, bool syslog, char *buf, size_t size)
+static size_t msg_print_text(const struct printk_log *msg, bool syslog,
+			     bool time, char *buf, size_t size)
 {
 	const char *text = log_text(msg);
 	size_t text_size = msg->text_len;
@@ -1285,17 +1284,17 @@ static size_t msg_print_text(const struct printk_log *msg, bool syslog, char *bu
 		}
 
 		if (buf) {
-			if (print_prefix(msg, syslog, NULL) +
+			if (print_prefix(msg, syslog, time, NULL) +
 			    text_len + 1 >= size - len)
 				break;
 
-			len += print_prefix(msg, syslog, buf + len);
+			len += print_prefix(msg, syslog, time, buf + len);
 			memcpy(buf + len, text, text_len);
 			len += text_len;
 			buf[len++] = '\n';
 		} else {
 			/* SYSLOG_ACTION_* buffer size only calculation */
-			len += print_prefix(msg, syslog, NULL);
+			len += print_prefix(msg, syslog, time, NULL);
 			len += text_len;
 			len++;
 		}
@@ -1332,9 +1331,17 @@ static int syslog_print(char __user *buf, int size)
 			break;
 		}
 
+		/*
+		 * To keep reading/counting partial line consistent,
+		 * use printk_time value as of the beginning of a line.
+		 */
+		if (!syslog_partial)
+			syslog_time = printk_time;
+
 		skip = syslog_partial;
 		msg = log_from_idx(syslog_idx);
-		n = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);
+		n = msg_print_text(msg, true, syslog_time, text,
+				   LOG_LINE_MAX + PREFIX_MAX);
 		if (n - syslog_partial <= size) {
 			/* message fits into buffer, move forward */
 			syslog_idx = log_next(syslog_idx);
@@ -1374,11 +1381,13 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	u64 next_seq;
 	u64 seq;
 	u32 idx;
+	bool time;
 
 	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
+	time = printk_time;
 	logbuf_lock_irq();
 	/*
 	 * Find first record that fits, including all following records,
@@ -1389,7 +1398,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	while (seq < log_next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		len += msg_print_text(msg, true, NULL, 0);
+		len += msg_print_text(msg, true, time, NULL, 0);
 		idx = log_next(idx);
 		seq++;
 	}
@@ -1400,7 +1409,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	while (len > size && seq < log_next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		len -= msg_print_text(msg, true, NULL, 0);
+		len -= msg_print_text(msg, true, time, NULL, 0);
 		idx = log_next(idx);
 		seq++;
 	}
@@ -1411,14 +1420,9 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	len = 0;
 	while (len >= 0 && seq < next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
-		int textlen;
+		int textlen = msg_print_text(msg, true, time, text,
+					     LOG_LINE_MAX + PREFIX_MAX);
 
-		textlen = msg_print_text(msg, true, text,
-					 LOG_LINE_MAX + PREFIX_MAX);
-		if (textlen < 0) {
-			len = textlen;
-			break;
-		}
 		idx = log_next(idx);
 		seq++;
 
@@ -1542,11 +1546,14 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		} else {
 			u64 seq = syslog_seq;
 			u32 idx = syslog_idx;
+			bool time = syslog_partial ? syslog_time : printk_time;
 
 			while (seq < log_next_seq) {
 				struct printk_log *msg = log_from_idx(idx);
 
-				error += msg_print_text(msg, true, NULL, 0);
+				error += msg_print_text(msg, true, time, NULL,
+							0);
+				time = printk_time;
 				idx = log_next(idx);
 				seq++;
 			}
@@ -2004,6 +2011,7 @@ EXPORT_SYMBOL(printk);
 
 #define LOG_LINE_MAX		0
 #define PREFIX_MAX		0
+#define printk_time		false
 
 static u64 syslog_seq;
 static u32 syslog_idx;
@@ -2027,8 +2035,8 @@ static void console_lock_spinning_enable(void) { }
 static int console_lock_spinning_disable_and_check(void) { return 0; }
 static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
-static size_t msg_print_text(const struct printk_log *msg,
-			     bool syslog, char *buf, size_t size) { return 0; }
+static size_t msg_print_text(const struct printk_log *msg, bool syslog,
+			     bool time, char *buf, size_t size) { return 0; }
 static bool suppress_message_printing(int level) { return false; }
 
 #endif /* CONFIG_PRINTK */
@@ -2386,8 +2394,7 @@ void console_unlock(void)
 
 		len += msg_print_text(msg,
 				console_msg_format & MSG_FORMAT_SYSLOG,
-				text + len,
-				sizeof(text) - len);
+				printk_time, text + len, sizeof(text) - len);
 		if (nr_ext_console_drivers) {
 			ext_len = msg_print_ext_header(ext_text,
 						sizeof(ext_text),
@@ -3111,7 +3118,7 @@ bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 		goto out;
 
 	msg = log_from_idx(dumper->cur_idx);
-	l = msg_print_text(msg, syslog, line, size);
+	l = msg_print_text(msg, syslog, printk_time, line, size);
 
 	dumper->cur_idx = log_next(dumper->cur_idx);
 	dumper->cur_seq++;
@@ -3182,6 +3189,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	u32 next_idx;
 	size_t l = 0;
 	bool ret = false;
+	bool time = printk_time;
 
 	if (!dumper->active)
 		goto out;
@@ -3205,7 +3213,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	while (seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l += msg_print_text(msg, true, NULL, 0);
+		l += msg_print_text(msg, true, time, NULL, 0);
 		idx = log_next(idx);
 		seq++;
 	}
@@ -3216,7 +3224,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	while (l > size && seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l -= msg_print_text(msg, true, NULL, 0);
+		l -= msg_print_text(msg, true, time, NULL, 0);
 		idx = log_next(idx);
 		seq++;
 	}
@@ -3229,7 +3237,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	while (seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l += msg_print_text(msg, syslog, buf + l, size - l);
+		l += msg_print_text(msg, syslog, time, buf + l, size - l);
 		idx = log_next(idx);
 		seq++;
 	}

commit 9adcfaffc34d53e498637237fb3701560359d50b
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Sat Nov 24 13:10:25 2018 +0900

    printk: Make printk_emit() local function.
    
    printk_emit() is called from only devkmsg_write() in the same file.
    Save object size by making it a local function.
    
    Link: http://lkml.kernel.org/r/5cc99d2c-c408-34f7-d1fc-e1cd2a9e31da@i-love.sakura.ne.jp
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b77150ad1965..a1d88212a5d2 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -753,6 +753,19 @@ struct devkmsg_user {
 	char buf[CONSOLE_EXT_LOG_MAX];
 };
 
+static __printf(3, 4) __cold
+int devkmsg_emit(int facility, int level, const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+	va_start(args, fmt);
+	r = vprintk_emit(facility, level, NULL, 0, fmt, args);
+	va_end(args);
+
+	return r;
+}
+
 static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	char *buf, *line;
@@ -811,7 +824,7 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 		}
 	}
 
-	printk_emit(facility, level, NULL, 0, "%s", line);
+	devkmsg_emit(facility, level, "%s", line);
 	kfree(buf);
 	return ret;
 }
@@ -1936,21 +1949,6 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 }
 EXPORT_SYMBOL(vprintk);
 
-asmlinkage int printk_emit(int facility, int level,
-			   const char *dict, size_t dictlen,
-			   const char *fmt, ...)
-{
-	va_list args;
-	int r;
-
-	va_start(args, fmt);
-	r = vprintk_emit(facility, level, dict, dictlen, fmt, args);
-	va_end(args);
-
-	return r;
-}
-EXPORT_SYMBOL(printk_emit);
-
 int vprintk_default(const char *fmt, va_list args)
 {
 	int r;

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 429e4a3833ca..1b2a029360b7 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -31,7 +31,6 @@
 #include <linux/delay.h>
 #include <linux/smp.h>
 #include <linux/security.h>
-#include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/syscalls.h>
 #include <linux/crash_core.h>

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b77150ad1965..429e4a3833ca 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1111,9 +1111,9 @@ void __init setup_log_buf(int early)
 
 	if (early) {
 		new_log_buf =
-			memblock_virt_alloc(new_log_buf_len, LOG_ALIGN);
+			memblock_alloc(new_log_buf_len, LOG_ALIGN);
 	} else {
-		new_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len,
+		new_log_buf = memblock_alloc_nopanic(new_log_buf_len,
 							  LOG_ALIGN);
 	}
 

commit d2130e82e9454304e9b91ba9da551b5989af8c27
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Wed Oct 10 20:33:08 2018 +0900

    printk: fix integer overflow in setup_log_buf()
    
    The way we calculate logbuf free space percentage overflows signed
    integer:
    
            int free;
    
            free = __LOG_BUF_LEN - log_next_idx;
            pr_info("early log buf free: %u(%u%%)\n",
                    free, (free * 100) / __LOG_BUF_LEN);
    
    We support LOG_BUF_LEN of up to 1<<25 bytes. Since setup_log_buf() is
    called during early init, logbuf is mostly empty, so
    
            __LOG_BUF_LEN - log_next_idx
    
    is close to 1<<25. Thus when we multiply it by 100, we overflow signed
    integer value range: 100 is 2^6 + 2^5 + 2^2.
    
    Example, booting with LOG_BUF_LEN 1<<25 and log_buf_len=2G
    boot param:
    
    [    0.075317] log_buf_len: -2147483648 bytes
    [    0.075319] early log buf free: 33549896(-28%)
    
    Make "free" unsigned integer and use appropriate printk() specifier.
    
    Link: http://lkml.kernel.org/r/20181010113308.9337-1-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 505663bb4f1f..b77150ad1965 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1098,7 +1098,7 @@ void __init setup_log_buf(int early)
 {
 	unsigned long flags;
 	char *new_log_buf;
-	int free;
+	unsigned int free;
 
 	if (log_buf != __log_buf)
 		return;

commit 0e96a19c4450253c3ddcff69140b1096f2c2adaf
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Oct 2 11:38:36 2018 +0900

    printk: do not preliminary split up cont buffer
    
    We have a proper 'overflow' check which tells us that we need to
    split up existing cont buffer in separate records:
    
            if (cont.len + len > sizeof(cont.buf))
                    cont_flush();
    
    At the same time we also have one extra flush: "if cont buffer is
    80% full then split it up" in cont_add():
    
            if (cont.len > (sizeof(cont.buf) * 80) / 100)
                    cont_flush();
    
    This looks to be redundant, since the existing "overflow" check
    should work just fine, so remove this 80% check and wait for either
    a normal cont termination \n, for preliminary flush due to
    possible buffer overflow or for preliminary flush due to cont race.
    
    Link: http://lkml.kernel.org/r/20181002023836.4487-4-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dmitriy Vyukov <dvyukov@google.com>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e9a7e50ed60a..505663bb4f1f 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1796,9 +1796,6 @@ static bool cont_add(int facility, int level, enum log_flags flags, const char *
 		cont_flush();
 	}
 
-	if (cont.len > (sizeof(cont.buf) * 80) / 100)
-		cont_flush();
-
 	return true;
 }
 

commit 3ac37a93fa9217e576bebfd4ba3e80edaaeb2289
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Oct 2 11:38:35 2018 +0900

    printk: lock/unlock console only for new logbuf entries
    
    Prior to commit 5c2992ee7fd8a29 ("printk: remove console flushing special
    cases for partial buffered lines") we would do console_cont_flush()
    for each pr_cont() to print cont fragments, so console_unlock() would
    actually print data:
    
            pr_cont();
             console_lock();
             console_unlock()
              console_cont_flush(); // print cont fragment
            ...
            pr_cont();
             console_lock();
             console_unlock()
              console_cont_flush(); // print cont fragment
    
    We don't do console_cont_flush() anymore, so when we do pr_cont()
    console_unlock() does nothing (unless we flushed the cont buffer):
    
            pr_cont();
             console_lock();
             console_unlock();      // noop
            ...
            pr_cont();
             console_lock();
             console_unlock();      // noop
            ...
            pr_cont();
              cont_flush();
                console_lock();
                console_unlock();   // print data
    
    We also wakeup klogd purposelessly for pr_cont() output - un-flushed
    cont buffer is not stored in log_buf; there is nothing to pull.
    
    Thus we can console_lock()/console_unlock()/wake_up_klogd() only when
    we know that we log_store()-ed a message and there is something to
    print to the consoles/syslog.
    
    Link: http://lkml.kernel.org/r/20181002023836.4487-3-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dmitriy Vyukov <dvyukov@google.com>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f717656c0fac..e9a7e50ed60a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1890,8 +1890,9 @@ asmlinkage int vprintk_emit(int facility, int level,
 			    const char *fmt, va_list args)
 {
 	int printed_len;
-	bool in_sched = false;
+	bool in_sched = false, pending_output;
 	unsigned long flags;
+	u64 curr_log_seq;
 
 	if (level == LOGLEVEL_SCHED) {
 		level = LOGLEVEL_DEFAULT;
@@ -1903,11 +1904,13 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	/* This stops the holder of console_sem just where we want him */
 	logbuf_lock_irqsave(flags);
+	curr_log_seq = log_next_seq;
 	printed_len = vprintk_store(facility, level, dict, dictlen, fmt, args);
+	pending_output = (curr_log_seq != log_next_seq);
 	logbuf_unlock_irqrestore(flags);
 
 	/* If called from the scheduler, we can not call up(). */
-	if (!in_sched) {
+	if (!in_sched && pending_output) {
 		/*
 		 * Disable preemption to avoid being preempted while holding
 		 * console_sem which would prevent anyone from printing to
@@ -1924,7 +1927,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 		preempt_enable();
 	}
 
-	wake_up_klogd();
+	if (pending_output)
+		wake_up_klogd();
 	return printed_len;
 }
 EXPORT_SYMBOL(vprintk_emit);

commit 9627808d2d409279cea3fb334212d04a83ff6371
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Oct 2 11:38:34 2018 +0900

    printk: keep kernel cont support always enabled
    
    Since commit 5c2992ee7fd8a29 ("printk: remove console flushing special
    cases for partial buffered lines") we don't print cont fragments
    to the consoles; cont lines are now proper log_buf entries and
    there is no "consecutive continuation flag" anymore: we either
    have 'c' entries that mark continuation lines without fragments;
    or '-' entries that mark normal logbuf entries. There are no '+'
    entries anymore.
    
    However, we still have a small leftover - presence of ext_console
    drivers disables kernel cont support and we flush each pr_cont()
    and store it as a separate log_buf entry. Previously, it worked
    because msg_print_ext_header() had that "an optional external merge
    of the records" functionality:
    
            if (msg->flags & LOG_CONT)
                    cont = (prev_flags & LOG_CONT) ? '+' : 'c';
    
    We don't do this as of now, so keep kernel cont always enabled.
    
    Note from pmladek:
    
    The original purpose was to get full information including
    the metadata and dictionary via extended console drivers,
    see commit 6fe29354befe4c46e ("printk: implement support
    for extended console drivers").
    
    The dictionary probably was the most important part but
    it was actually lost:
    
      static void cont_flush(void)
      {
      [...]
            log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,
                      NULL, 0, cont.buf, cont.len);
    
    Nobody noticed because the only dictionary user is dev_printk()
    and dev_cont() is _not_ defined.
    
    Link: http://lkml.kernel.org/r/20181002023836.4487-2-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dmitriy Vyukov <dvyukov@google.com>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: Updated commit message]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fce696d80e09..f717656c0fac 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -194,16 +194,7 @@ int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,
 	return 0;
 }
 
-/*
- * Number of registered extended console drivers.
- *
- * If extended consoles are present, in-kernel cont reassembly is disabled
- * and each fragment is stored as a separate log entry with proper
- * continuation flag so that every emitted message has full metadata.  This
- * doesn't change the result for regular consoles or /proc/kmsg.  For
- * /dev/kmsg, as long as the reader concatenates messages according to
- * consecutive continuation flags, the end result should be the same too.
- */
+/* Number of registered extended console drivers. */
 static int nr_ext_console_drivers;
 
 /*
@@ -1781,12 +1772,8 @@ static void cont_flush(void)
 
 static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)
 {
-	/*
-	 * If ext consoles are present, flush and skip in-kernel
-	 * continuation.  See nr_ext_console_drivers definition.  Also, if
-	 * the line gets too long, split it up in separate records.
-	 */
-	if (nr_ext_console_drivers || cont.len + len > sizeof(cont.buf)) {
+	/* If the line gets too long, split it up in separate records. */
+	if (cont.len + len > sizeof(cont.buf)) {
 		cont_flush();
 		return false;
 	}
@@ -2706,8 +2693,7 @@ void register_console(struct console *newcon)
 	}
 
 	if (newcon->flags & CON_EXTENDED)
-		if (!nr_ext_console_drivers++)
-			pr_info("continuation disabled due to ext consoles, expect more fragments in /dev/kmsg\n");
+		nr_ext_console_drivers++;
 
 	if (newcon->flags & CON_PRINTBUFFER) {
 		/*

commit e6fe3e5b7d16e8f146a4ae7fe481bc6e97acde1e
Author: He Zhe <zhe.he@windriver.com>
Date:   Sun Sep 30 00:45:53 2018 +0800

    printk: Give error on attempt to set log buffer length to over 2G
    
    The current printk() is ready to handle log buffer size up to 2G.
    Give an explicit error for users who want to use larger log buffer.
    
    Also fix printk formatting to show the 2G as a positive number.
    
    Link: http://lkml.kernel.org/r/20181008135916.gg4kkmoki5bgtco5@pathway.suse.cz
    Cc: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Suggested-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: He Zhe <zhe.he@windriver.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek: Fixed to the really safe limit 2GB.]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 15f3e70be448..fce696d80e09 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -440,6 +440,7 @@ static u32 clear_idx;
 /* record buffer */
 #define LOG_ALIGN __alignof__(struct printk_log)
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
+#define LOG_BUF_LEN_MAX (u32)(1 << 31)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
@@ -1040,18 +1041,23 @@ void log_buf_vmcoreinfo_setup(void)
 static unsigned long __initdata new_log_buf_len;
 
 /* we practice scaling the ring buffer by powers of 2 */
-static void __init log_buf_len_update(unsigned size)
+static void __init log_buf_len_update(u64 size)
 {
+	if (size > (u64)LOG_BUF_LEN_MAX) {
+		size = (u64)LOG_BUF_LEN_MAX;
+		pr_err("log_buf over 2G is not supported.\n");
+	}
+
 	if (size)
 		size = roundup_pow_of_two(size);
 	if (size > log_buf_len)
-		new_log_buf_len = size;
+		new_log_buf_len = (unsigned long)size;
 }
 
 /* save requested log_buf_len since it's too early to process it */
 static int __init log_buf_len_setup(char *str)
 {
-	unsigned int size;
+	u64 size;
 
 	if (!str)
 		return -EINVAL;
@@ -1121,7 +1127,7 @@ void __init setup_log_buf(int early)
 	}
 
 	if (unlikely(!new_log_buf)) {
-		pr_err("log_buf_len: %ld bytes not available\n",
+		pr_err("log_buf_len: %lu bytes not available\n",
 			new_log_buf_len);
 		return;
 	}
@@ -1134,8 +1140,8 @@ void __init setup_log_buf(int early)
 	memcpy(log_buf, __log_buf, __LOG_BUF_LEN);
 	logbuf_unlock_irqrestore(flags);
 
-	pr_info("log_buf_len: %d bytes\n", log_buf_len);
-	pr_info("early log buf free: %d(%d%%)\n",
+	pr_info("log_buf_len: %u bytes\n", log_buf_len);
+	pr_info("early log buf free: %u(%u%%)\n",
 		free, (free * 100) / __LOG_BUF_LEN);
 }
 

commit dd5adbfbfc50ff998909660c6158c0488f7b6a2b
Author: He Zhe <zhe.he@windriver.com>
Date:   Sun Sep 30 00:45:52 2018 +0800

    printk: Add KBUILD_MODNAME and remove a redundant print prefix
    
    Add KBUILD_MODNAME to make prints more clear.
    
    Link: http://lkml.kernel.org/r/1538239553-81805-3-git-send-email-zhe.he@windriver.com
    Cc: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: He Zhe <zhe.he@windriver.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d4704baf6aaf..15f3e70be448 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -16,6 +16,8 @@
  *	01Mar01 Andrew Morton
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/tty.h>
@@ -2699,7 +2701,7 @@ void register_console(struct console *newcon)
 
 	if (newcon->flags & CON_EXTENDED)
 		if (!nr_ext_console_drivers++)
-			pr_info("printk: continuation disabled due to ext consoles, expect more fragments in /dev/kmsg\n");
+			pr_info("continuation disabled due to ext consoles, expect more fragments in /dev/kmsg\n");
 
 	if (newcon->flags & CON_PRINTBUFFER) {
 		/*

commit 51a72ab7372d85c96104e58036f1b49ba11e5d2b
Author: He Zhe <zhe.he@windriver.com>
Date:   Sun Sep 30 00:45:51 2018 +0800

    printk: Correct wrong casting
    
    log_first_seq and console_seq are 64-bit unsigned integers.
    Correct a wrong casting that might cut off the output.
    
    Link: http://lkml.kernel.org/r/1538239553-81805-2-git-send-email-zhe.he@windriver.com
    Cc: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: He Zhe <zhe.he@windriver.com>
    [sergey.senozhatsky@gmail.com: More descriptive commit message]
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a14f15ad0f35..d4704baf6aaf 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2358,8 +2358,9 @@ void console_unlock(void)
 		printk_safe_enter_irqsave(flags);
 		raw_spin_lock(&logbuf_lock);
 		if (console_seq < log_first_seq) {
-			len = sprintf(text, "** %u printk messages dropped **\n",
-				      (unsigned)(log_first_seq - console_seq));
+			len = sprintf(text,
+				      "** %llu printk messages dropped **\n",
+				      log_first_seq - console_seq);
 
 			/* messages are gone, move to first one */
 			console_seq = log_first_seq;

commit 277fcdb2cfee38ccdbe07e705dbd4896ba0c9930
Author: He Zhe <zhe.he@windriver.com>
Date:   Sun Sep 30 00:45:50 2018 +0800

    printk: Fix panic caused by passing log_buf_len to command line
    
    log_buf_len_setup does not check input argument before passing it to
    simple_strtoull. The argument would be a NULL pointer if "log_buf_len",
    without its value, is set in command line and thus causes the following
    panic.
    
    PANIC: early exception 0xe3 IP 10:ffffffffaaeacd0d error 0 cr2 0x0
    [    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 4.19.0-rc4-yocto-standard+ #1
    [    0.000000] RIP: 0010:_parse_integer_fixup_radix+0xd/0x70
    ...
    [    0.000000] Call Trace:
    [    0.000000]  simple_strtoull+0x29/0x70
    [    0.000000]  memparse+0x26/0x90
    [    0.000000]  log_buf_len_setup+0x17/0x22
    [    0.000000]  do_early_param+0x57/0x8e
    [    0.000000]  parse_args+0x208/0x320
    [    0.000000]  ? rdinit_setup+0x30/0x30
    [    0.000000]  parse_early_options+0x29/0x2d
    [    0.000000]  ? rdinit_setup+0x30/0x30
    [    0.000000]  parse_early_param+0x36/0x4d
    [    0.000000]  setup_arch+0x336/0x99e
    [    0.000000]  start_kernel+0x6f/0x4ee
    [    0.000000]  x86_64_start_reservations+0x24/0x26
    [    0.000000]  x86_64_start_kernel+0x6f/0x72
    [    0.000000]  secondary_startup_64+0xa4/0xb0
    
    This patch adds a check to prevent the panic.
    
    Link: http://lkml.kernel.org/r/1538239553-81805-1-git-send-email-zhe.he@windriver.com
    Cc: stable@vger.kernel.org
    Cc: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: He Zhe <zhe.he@windriver.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index c5b568c2d167..a14f15ad0f35 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1049,7 +1049,12 @@ static void __init log_buf_len_update(unsigned size)
 /* save requested log_buf_len since it's too early to process it */
 static int __init log_buf_len_setup(char *str)
 {
-	unsigned size = memparse(str, &str);
+	unsigned int size;
+
+	if (!str)
+		return -EINVAL;
+
+	size = memparse(str, &str);
 
 	log_buf_len_update(size);
 

commit 884e370ea88c109a3b982f4eb9ecd82510a3a1fe
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Fri Sep 28 18:53:04 2018 +0900

    printk: CON_PRINTBUFFER console registration is a bit racy
    
    CON_PRINTBUFFER console registration requires us to do several
    preparation steps:
    - Rollback console_seq to replay logbuf messages which were already
      seen on other consoles;
    - Set exclusive_console flag so console_unlock() will ->write() logbuf
      messages only to the exclusive_console driver.
    
    The way we do it, however, is a bit racy
    
            logbuf_lock_irqsave(flags);
            console_seq = syslog_seq;
            console_idx = syslog_idx;
            logbuf_unlock_irqrestore(flags);
                                                    << preemption enabled
                                                    << irqs enabled
            exclusive_console = newcon;
            console_unlock();
    
    We rollback console_seq under logbuf_lock with IRQs disabled, but
    we set exclusive_console with local IRQs enabled and logbuf unlocked.
    If the system oops-es or panic-s before we set exclusive_console - and
    given that we have IRQs and preemption enabled there is such a
    possibility - we will re-play all logbuf messages to every registered
    console, which may be a bit annoying and time consuming.
    
    Move exclusive_console assignment to the same IRQs-disabled and
    logbuf_lock-protected section where we rollback console_seq.
    
    Link: http://lkml.kernel.org/r/20180928095304.9972-1-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index cfaa211a8b54..c5b568c2d167 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2703,14 +2703,18 @@ void register_console(struct console *newcon)
 		logbuf_lock_irqsave(flags);
 		console_seq = syslog_seq;
 		console_idx = syslog_idx;
-		logbuf_unlock_irqrestore(flags);
 		/*
 		 * We're about to replay the log buffer.  Only do this to the
 		 * just-registered console to avoid excessive message spam to
 		 * the already-registered consoles.
+		 *
+		 * Set exclusive_console with disabled interrupts to reduce
+		 * race window with eventual console_flush_on_panic() that
+		 * ignores console_lock.
 		 */
 		exclusive_console = newcon;
 		exclusive_console_stop_seq = console_seq;
+		logbuf_unlock_irqrestore(flags);
 	}
 	console_unlock();
 	console_sysfs_notify();

commit f92b070f2dc89a8ff1a0cc8b608e20abef894c7d
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Sep 13 14:34:06 2018 +0200

    printk: Do not miss new messages when replaying the log
    
    The variable "exclusive_console" is used to reply all existing messages
    on a newly registered console. It is cleared when all messages are out.
    
    The problem is that new messages might appear in the meantime. These
    are then visible only on the exclusive console.
    
    The obvious solution is to clear "exclusive_console" after we replay
    all messages that were already proceed before we started the reply.
    
    Reported-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Link: http://lkml.kernel.org/r/20180913123406.14378-1-pmladek@suse.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9bf5404397e0..cfaa211a8b54 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -423,6 +423,7 @@ static u32 log_next_idx;
 /* the next printk record to write to the console */
 static u64 console_seq;
 static u32 console_idx;
+static u64 exclusive_console_stop_seq;
 
 /* the next printk record to read after the last 'clear' command */
 static u64 clear_seq;
@@ -2009,6 +2010,7 @@ static u64 syslog_seq;
 static u32 syslog_idx;
 static u64 console_seq;
 static u32 console_idx;
+static u64 exclusive_console_stop_seq;
 static u64 log_first_seq;
 static u32 log_first_idx;
 static u64 log_next_seq;
@@ -2376,6 +2378,12 @@ void console_unlock(void)
 			goto skip;
 		}
 
+		/* Output to all consoles once old messages replayed. */
+		if (unlikely(exclusive_console &&
+			     console_seq >= exclusive_console_stop_seq)) {
+			exclusive_console = NULL;
+		}
+
 		len += msg_print_text(msg,
 				console_msg_format & MSG_FORMAT_SYSLOG,
 				text + len,
@@ -2418,10 +2426,6 @@ void console_unlock(void)
 
 	console_locked = 0;
 
-	/* Release the exclusive_console once it is used */
-	if (unlikely(exclusive_console))
-		exclusive_console = NULL;
-
 	raw_spin_unlock(&logbuf_lock);
 
 	up_console_sem();
@@ -2706,6 +2710,7 @@ void register_console(struct console *newcon)
 		 * the already-registered consoles.
 		 */
 		exclusive_console = newcon;
+		exclusive_console_stop_seq = console_seq;
 	}
 	console_unlock();
 	console_sysfs_notify();

commit a06b0c82a049d34d4dc273e8692ed0894458c468
Merge: 48751b562bce a6ae928c2583
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 13 19:37:08 2018 -1000

    Merge tag 'printk-for-4.19-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk fix from Petr Mladek:
     "Revert a commit that caused "quiet", "debug", and "loglevel" early
      parameters to be ignored for early boot messages"
    
    * tag 'printk-for-4.19-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      Revert "printk: make sure to print log on console."

commit a6ae928c25835ca18deb4a527079f169b68ed292
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Sep 10 15:52:06 2018 +0200

    Revert "printk: make sure to print log on console."
    
    This reverts commit 375899cddcbb26881b03cb3fbdcfd600e4e67f4a.
    
    The visibility of early messages did not longer take into account
    "quiet", "debug", and "loglevel" early parameters.
    
    It would be possible to invalidate and recompute LOG_NOCONS flag
    for the affected messages. But it would be hairy.
    
    Instead this patch just reverts the problematic commit. We could
    come up with a better solution for the original problem. For example,
    we could simplify the logic and just mark messages that should always
    be visible or always invisible on the console.
    
    Also this patch reverts the related build fix commit ffaa619af1b06
    ("printk: Fix warning about unused suppress_message_printing").
    
    Finally, this patch does not put back the unused LOG_NOCONS flag.
    
    Link: http://lkml.kernel.org/r/20180910145747.emvfzv4mzlk5dfqk@pathway.suse.cz
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H . Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Maninder Singh <maninder1.s@samsung.com>
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9a63aeeaaf5d..e30e5023511b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -349,7 +349,6 @@ static int console_msg_format = MSG_FORMAT_DEFAULT;
  */
 
 enum log_flags {
-	LOG_NOCONS	= 1,	/* suppress print, do not print to console */
 	LOG_NEWLINE	= 2,	/* text ended with a newline */
 	LOG_PREFIX	= 4,	/* text started with a prefix */
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
@@ -1879,9 +1878,6 @@ int vprintk_store(int facility, int level,
 	if (dict)
 		lflags |= LOG_PREFIX|LOG_NEWLINE;
 
-	if (suppress_message_printing(level))
-		lflags |= LOG_NOCONS;
-
 	return log_output(facility, level, lflags,
 			  dict, dictlen, text, text_len);
 }
@@ -2030,6 +2026,7 @@ static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
+static bool suppress_message_printing(int level) { return false; }
 
 #endif /* CONFIG_PRINTK */
 
@@ -2365,10 +2362,11 @@ void console_unlock(void)
 			break;
 
 		msg = log_from_idx(console_idx);
-		if (msg->flags & LOG_NOCONS) {
+		if (suppress_message_printing(msg->level)) {
 			/*
-			 * Skip record if !ignore_loglevel, and
-			 * record has level above the console loglevel.
+			 * Skip record we have buffered and already printed
+			 * directly to the console when we received it, and
+			 * record that has level above the console loglevel.
 			 */
 			console_idx = log_next(console_idx);
 			console_seq++;

commit 13ba17bee18e321b073b49a88dcab10881f757da
Author: Mukesh Ojha <mojha@codeaurora.org>
Date:   Fri Aug 24 18:03:53 2018 +0530

    notifier: Remove notifier header file wherever not used
    
    The conversion of the hotplug notifiers to a state machine left the
    notifier.h includes around in some places. Remove them.
    
    Signed-off-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/1535114033-4605-1-git-send-email-mojha@codeaurora.org

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 924e37fb1620..fd6f8ed28e01 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -38,7 +38,6 @@
 #include <linux/kmsg_dump.h>
 #include <linux/syslog.h>
 #include <linux/cpu.h>
-#include <linux/notifier.h>
 #include <linux/rculist.h>
 #include <linux/poll.h>
 #include <linux/irq_work.h>

commit 06e386a1db54ab6a671e103e929b590f7a88f0e3
Merge: 99897b1e9931 f39684524b39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 23 15:44:58 2018 -0700

    Merge tag 'fbdev-v4.19' of https://github.com/bzolnier/linux
    
    Pull fbdev updates from Bartlomiej Zolnierkiewicz:
     "Mostly small fixes and cleanups for fb drivers (the biggest updates
      are for udlfb and pxafb drivers). This also adds deferred console
      takeover support to the console code and efifb driver.
    
      Summary:
    
       - add support for deferred console takeover, when enabled defers
         fbcon taking over the console from the dummy console until the
         first text is displayed on the console - together with the "quiet"
         kernel commandline option this allows fbcon to still be used
         together with a smooth graphical bootup (Hans de Goede)
    
       - improve console locking debugging code (Thomas Zimmermann)
    
       - copy the ACPI BGRT boot graphics to the framebuffer when deferred
         console takeover support is used in efifb driver (Hans de Goede)
    
       - update udlfb driver - fix lost console when the user unplugs a USB
         adapter, fix the screen corruption issue, fix locking and add some
         performance optimizations (Mikulas Patocka)
    
       - update pxafb driver - fix using uninitialized memory, switch to
         devm_* API, handle initialization errors and add support for
         lcd-supply regulator (Daniel Mack)
    
       - add support for boards booted with a DeviceTree in pxa3xx_gcu
         driver (Daniel Mack)
    
       - rename omap2 module to omap2fb.ko to avoid conflicts with omap1
         driver (Arnd Bergmann)
    
       - enable ACPI-based enumeration for goldfishfb driver (Yu Ning)
    
       - fix goldfishfb driver to make user space Android code use 60 fps
         (Christoffer Dall)
    
       - print big fat warning when nomodeset kernel parameter is used in
         vgacon driver (Lyude Paul)
    
       - remove VLA usage from fsl-diu-fb driver (Kees Cook)
    
       - misc fixes (Julia Lawall, Geert Uytterhoeven, Fredrik Noring,
         Yisheng Xie, Dan Carpenter, Daniel Vetter, Anton Vasilyev, Randy
         Dunlap, Gustavo A. R. Silva, Colin Ian King, Fengguang Wu)
    
       - misc cleanups (Roman Kiryanov, Yisheng Xie, Colin Ian King)"
    
    * tag 'fbdev-v4.19' of https://github.com/bzolnier/linux: (54 commits)
      Documentation/fb: corrections for fbcon.txt
      fbcon: Do not takeover the console from atomic context
      dummycon: Stop exporting dummycon_[un]register_output_notifier
      fbcon: Only defer console takeover if the current console driver is the dummycon
      fbcon: Only allow FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER if fbdev is builtin
      fbdev: omap2: omapfb: fix ifnullfree.cocci warnings
      fbdev: omap2: omapfb: fix bugon.cocci warnings
      fbdev: omap2: omapfb: fix boolreturn.cocci warnings
      fb: amifb: fix build warnings when not builtin
      fbdev/core: Disable console-lock warnings when fb.lockless_register_fb is set
      console: Replace #if 0 with atomic var 'ignore_console_lock_warning'
      udlfb: use spin_lock_irq instead of spin_lock_irqsave
      udlfb: avoid prefetch
      udlfb: optimization - test the backing buffer
      udlfb: allow reallocating the framebuffer
      udlfb: set line_length in dlfb_ops_set_par
      udlfb: handle allocation failure
      udlfb: set optimal write delay
      udlfb: make a local copy of fb_ops
      udlfb: don't switch if we are switching to the same videomode
      ...

commit 1b1eeca7e4c19fa76d409d4c7b338dba21f2df45
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:13 2018 -0700

    init: allow initcall tables to be emitted using relative references
    
    Allow the initcall tables to be emitted using relative references that
    are only half the size on 64-bit architectures and don't require fixups
    at runtime on relocatable kernels.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-5-ard.biesheuvel@linaro.org
    Acked-by: James Morris <james.morris@microsoft.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 90b6ab01db59..918f386b2f6e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2788,7 +2788,8 @@ EXPORT_SYMBOL(unregister_console);
 void __init console_init(void)
 {
 	int ret;
-	initcall_t *call;
+	initcall_t call;
+	initcall_entry_t *ce;
 
 	/* Setup the default TTY line discipline. */
 	n_tty_init();
@@ -2797,13 +2798,14 @@ void __init console_init(void)
 	 * set up the console device so that later boot sequences can
 	 * inform about problems etc..
 	 */
-	call = __con_initcall_start;
+	ce = __con_initcall_start;
 	trace_initcall_level("console");
-	while (call < __con_initcall_end) {
-		trace_initcall_start((*call));
-		ret = (*call)();
-		trace_initcall_finish((*call), ret);
-		call++;
+	while (ce < __con_initcall_end) {
+		call = initcall_from_entry(ce);
+		trace_initcall_start(call);
+		ret = call();
+		trace_initcall_finish(call, ret);
+		ce++;
 	}
 }
 

commit 54dbe75bbf1e189982516de179147208e90b5e45
Merge: dafa5f6577a9 557ce95051c8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 17:39:07 2018 -0700

    Merge tag 'drm-next-2018-08-15' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for 4.19.
    
      Rob has some new hardware support for new qualcomm hw that I'll send
      along separately. This has the display part of it, the remaining pull
      is for the acceleration engine.
    
      This also contains a wound-wait/wait-die mutex rework, Peter has acked
      it for merging via my tree.
    
      Otherwise mostly the usual level of activity. Summary:
    
      core:
       - Wound-wait/wait-die mutex rework
       - Add writeback connector type
       - Add "content type" property for HDMI
       - Move GEM bo to drm_framebuffer
       - Initial gpu scheduler documentation
       - GPU scheduler fixes for dying processes
       - Console deferred fbcon takeover support
       - Displayport support for CEC tunneling over AUX
    
      panel:
       - otm8009a panel driver fixes
       - Innolux TV123WAM and G070Y2-L01 panel driver
       - Ilitek ILI9881c panel driver
       - Rocktech RK070ER9427 LCD
       - EDT ETM0700G0EDH6 and EDT ETM0700G0BDH6
       - DLC DLC0700YZG-1
       - BOE HV070WSA-100
       - newhaven, nhd-4.3-480272ef-atxl LCD
       - DataImage SCF0700C48GGU18
       - Sharp LQ035Q7DB03
       - p079zca: Refactor to support multiple panels
    
      tinydrm:
       - ILI9341 display panel
    
      New driver:
       - vkms - virtual kms driver to testing.
    
      i915:
       - Icelake:
            Display enablement
            DSI support
            IRQ support
            Powerwell support
       - GPU reset fixes and improvements
       - Full ppgtt support refactoring
       - PSR fixes and improvements
       - Execlist improvments
       - GuC related fixes
    
      amdgpu:
       - Initial amdgpu documentation
       - JPEG engine support on VCN
       - CIK uses powerplay by default
       - Move to using core PCIE functionality for gens/lanes
       - DC/Powerplay interface rework
       - Stutter mode support for RV
       - Vega12 Powerplay updates
       - GFXOFF fixes
       - GPUVM fault debugging
       - Vega12 GFXOFF
       - DC improvements
       - DC i2c/aux changes
       - UVD 7.2 fixes
       - Powerplay fixes for Polaris12, CZ/ST
       - command submission bo_list fixes
    
      amdkfd:
       - Raven support
       - Power management fixes
    
      udl:
       - Cleanups and fixes
    
      nouveau:
       - misc fixes and cleanups.
    
      msm:
       - DPU1 support display controller in sdm845
       - GPU coredump support.
    
      vmwgfx:
       - Atomic modesetting validation fixes
       - Support for multisample surfaces
    
      armada:
       - Atomic modesetting support completed.
    
      exynos:
       - IPPv2 fixes
       - Move g2d to component framework
       - Suspend/resume support cleanups
       - Driver cleanups
    
      imx:
       - CSI configuration improvements
       - Driver cleanups
       - Use atomic suspend/resume helpers
       - ipu-v3 V4L2 XRGB32/XBGR32 support
    
      pl111:
       - Add Nomadik LCDC variant
    
      v3d:
       - GPU scheduler jobs management
    
      sun4i:
       - R40 display engine support
       - TCON TOP driver
    
      mediatek:
       - MT2712 SoC support
    
      rockchip:
       - vop fixes
    
      omapdrm:
       - Workaround for DRA7 errata i932
       - Fix mm_list locking
    
      mali-dp:
       - Writeback implementation
            PM improvements
       - Internal error reporting debugfs
    
      tilcdc:
       - Single fix for deferred probing
    
      hdlcd:
       - Teardown fixes
    
      tda998x:
       - Converted to a bridge driver.
    
      etnaviv:
       - Misc fixes"
    
    * tag 'drm-next-2018-08-15' of git://anongit.freedesktop.org/drm/drm: (1506 commits)
      drm/amdgpu/sriov: give 8s for recover vram under RUNTIME
      drm/scheduler: fix param documentation
      drm/i2c: tda998x: correct PLL divider calculation
      drm/i2c: tda998x: get rid of private fill_modes function
      drm/i2c: tda998x: move mode_valid() to bridge
      drm/i2c: tda998x: register bridge outside of component helper
      drm/i2c: tda998x: cleanup from previous changes
      drm/i2c: tda998x: allocate tda998x_priv inside tda998x_create()
      drm/i2c: tda998x: convert to bridge driver
      drm/scheduler: fix timeout worker setup for out of order job completions
      drm/amd/display: display connected to dp-1 does not light up
      drm/amd/display: update clk for various HDMI color depths
      drm/amd/display: program display clock on cache match
      drm/amd/display: Add NULL check for enabling dp ss
      drm/amd/display: add vbios table check for enabling dp ss
      drm/amd/display: Don't share clk source between DP and HDMI
      drm/amd/display: Fix DP HBR2 Eye Diagram Pattern on Carrizo
      drm/amd/display: Use calculated disp_clk_khz value for dce110
      drm/amd/display: Implement custom degamma lut on dcn
      drm/amd/display: Destroy aux_engines only once
      ...

commit 9f68cb579115faa211ae067b4628cf11162783fb
Merge: 554ec5086536 03fc7f9c99c1
Author: Petr Mladek <pmladek@suse.com>
Date:   Tue Aug 14 13:36:15 2018 +0200

    Merge branch 'for-4.19-nmi' into for-linus

commit 56e6c104e4f151e19eb410004405ec52b4f8605a
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Tue Jul 31 13:06:57 2018 +0200

    console: Replace #if 0 with atomic var 'ignore_console_lock_warning'
    
    The macro WARN_CONSOLE_UNLOCKED prints a warning when a thread enters
    the console's critical section without having acquired the console
    lock. The console lock can be ignored when debugging the console using
    printk, but this makes WARN_CONSOLE_UNLOCKED generate unnecessary
    warnings.
    
    The variable ignore_console_lock_warning temporarily disables
    WARN_CONSOLE_UNLOCKED. Developers interested in debugging the console's
    critical sections should increment it before entering the CS and
    decrement it after leaving the CS. Setting ignore_console_lock_warning
    is only for debugging. Regular operation should not manipulate it.
    
    Acknoledgements: This patch is based on an earlier version by Steven
    Rostedt. The use of atomic increment/decrement was suggested by Petr
    Mladek.
    
    Link: http://lkml.kernel.org/r/717e6337-e7a6-7a92-1c1b-8929a25696b5@suse.de
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    [b.zolnierkie: use <linux/atomic.h>]
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 3f041e7cbfc9..7d32a86758cd 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -66,6 +66,9 @@ int console_printk[4] = {
 	CONSOLE_LOGLEVEL_DEFAULT,	/* default_console_loglevel */
 };
 
+atomic_t ignore_console_lock_warning __read_mostly = ATOMIC_INIT(0);
+EXPORT_SYMBOL(ignore_console_lock_warning);
+
 /*
  * Low level drivers may need that to know if they can schedule in
  * their unblank() callback or not. So let's export it.

commit ffaa619af1b062d5a37871df6363aa52356007a7
Author: Petr Mladek <pmladek@suse.com>
Date:   Tue Jul 10 10:44:53 2018 +0200

    printk: Fix warning about unused suppress_message_printing
    
    suppress_message_printing() is not longer called in console_unlock().
    Therefore it is not longer needed with disabled CONFIG_PRINTK.
    
    This fixes the warning:
    
    kernel/printk/printk.c:2033:13: warning: ‘suppress_message_printing’ defined but not used [-Wunused-function]
     static bool suppress_message_printing(int level) { return false; }
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Suggested-by: Maninder Singh <maninder1.s@samsung.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fcc1992c040a..e2cb0fc18e2d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2021,7 +2021,6 @@ static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
-static bool suppress_message_printing(int level) { return false; }
 
 #endif /* CONFIG_PRINTK */
 

commit a338f84dc196f44b63ba0863d2f34fd9b1613572
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jun 27 16:08:16 2018 +0200

    printk: Create helper function to queue deferred console handling
    
    It is just a preparation step. The patch does not change
    the existing behavior.
    
    Link: http://lkml.kernel.org/r/20180627140817.27764-3-pmladek@suse.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: stable@vger.kernel.org
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a844c611b17c..1d1513215c22 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2887,16 +2887,20 @@ void wake_up_klogd(void)
 	preempt_enable();
 }
 
-int vprintk_deferred(const char *fmt, va_list args)
+void defer_console_output(void)
 {
-	int r;
-
-	r = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);
-
 	preempt_disable();
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
 	irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));
 	preempt_enable();
+}
+
+int vprintk_deferred(const char *fmt, va_list args)
+{
+	int r;
+
+	r = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);
+	defer_console_output();
 
 	return r;
 }

commit ba552399954dde1b388f7749fecad5c349216981
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jun 27 16:08:15 2018 +0200

    printk: Split the code for storing a message into the log buffer
    
    It is just a preparation step. The patch does not change
    the existing behavior.
    
    Link: http://lkml.kernel.org/r/20180627140817.27764-2-pmladek@suse.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: stable@vger.kernel.org
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 247808333ba4..a844c611b17c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1824,28 +1824,16 @@ static size_t log_output(int facility, int level, enum log_flags lflags, const c
 	return log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);
 }
 
-asmlinkage int vprintk_emit(int facility, int level,
-			    const char *dict, size_t dictlen,
-			    const char *fmt, va_list args)
+/* Must be called under logbuf_lock. */
+int vprintk_store(int facility, int level,
+		  const char *dict, size_t dictlen,
+		  const char *fmt, va_list args)
 {
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
 	size_t text_len;
 	enum log_flags lflags = 0;
-	unsigned long flags;
-	int printed_len;
-	bool in_sched = false;
-
-	if (level == LOGLEVEL_SCHED) {
-		level = LOGLEVEL_DEFAULT;
-		in_sched = true;
-	}
-
-	boot_delay_msec(level);
-	printk_delay();
 
-	/* This stops the holder of console_sem just where we want him */
-	logbuf_lock_irqsave(flags);
 	/*
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.
@@ -1886,8 +1874,29 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (dict)
 		lflags |= LOG_PREFIX|LOG_NEWLINE;
 
-	printed_len = log_output(facility, level, lflags, dict, dictlen, text, text_len);
+	return log_output(facility, level, lflags,
+			  dict, dictlen, text, text_len);
+}
 
+asmlinkage int vprintk_emit(int facility, int level,
+			    const char *dict, size_t dictlen,
+			    const char *fmt, va_list args)
+{
+	int printed_len;
+	bool in_sched = false;
+	unsigned long flags;
+
+	if (level == LOGLEVEL_SCHED) {
+		level = LOGLEVEL_DEFAULT;
+		in_sched = true;
+	}
+
+	boot_delay_msec(level);
+	printk_delay();
+
+	/* This stops the holder of console_sem just where we want him */
+	logbuf_lock_irqsave(flags);
+	printed_len = vprintk_store(facility, level, dict, dictlen, fmt, args);
 	logbuf_unlock_irqrestore(flags);
 
 	/* If called from the scheduler, we can not call up(). */

commit 8599dc7dec874b137384714bfe3ddbbf5d4a614e
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jun 27 17:06:41 2018 +0200

    printk: Clean up syslog_print_all()
    
    syslog_print_all() is called twice. Once with a valid buffer
    and once just to set the indexes.
    
    Both variants are already handled separately. This patch just
    makes it more obvious. It does not change the existing behavior.
    
    Link: http://lkml.kernel.org/r/20180627150641.p56xyy6mdzvnfpig@pathway.suse.cz
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Namit Gupta <gupta.namit@samsung.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: pankaj.m@samsung.com
    Cc: a.sahrawat@samsung.com
    Cc: himanshu.m@samsung.com
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 16b02cc51a14..fcc1992c040a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1356,16 +1356,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	u64 seq;
 	u32 idx;
 
-	if (!buf) {
-		if (clear) {
-			logbuf_lock_irq();
-			clear_seq = log_next_seq;
-			clear_idx = log_next_idx;
-			logbuf_unlock_irq();
-		}
-		return 0;
-	}
-
 	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
@@ -1437,6 +1427,14 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	return len;
 }
 
+static void syslog_clear(void)
+{
+	logbuf_lock_irq();
+	clear_seq = log_next_seq;
+	clear_idx = log_next_idx;
+	logbuf_unlock_irq();
+}
+
 int do_syslog(int type, char __user *buf, int len, int source)
 {
 	bool clear = false;
@@ -1481,7 +1479,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		break;
 	/* Clear ring buffer */
 	case SYSLOG_ACTION_CLEAR:
-		syslog_print_all(NULL, 0, true);
+		syslog_clear();
 		break;
 	/* Disable logging to console */
 	case SYSLOG_ACTION_CONSOLE_OFF:

commit d48de54a9dab5370edd2e991f78cc7996cf5483e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jun 28 15:20:27 2018 +0200

    printk: Export is_console_locked
    
    This is a preparation patch for adding a number of WARN_CONSOLE_UNLOCKED()
    calls to the fbcon code, which may be built as a module (event though
    usually it is not).
    
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 247808333ba4..3f041e7cbfc9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2243,6 +2243,7 @@ int is_console_locked(void)
 {
 	return console_locked;
 }
+EXPORT_SYMBOL(is_console_locked);
 
 /*
  * Check if we have any console that is capable of printing while cpu is

commit 63842c21347ecf4685d6ec008e667e61b0ead6e5
Author: Namit Gupta <gupta.namit@samsung.com>
Date:   Wed Jun 20 19:26:19 2018 +0530

    printk: Remove unnecessary kmalloc() from syslog during clear
    
    When the request is only for clearing logs, there is no need for
    allocation/deallocation. Only the indexes need to be reset and returned.
    Rest of the patch is mostly made up of changes because of indention.
    
    Link: http://lkml.kernel.org/r/20180620135951epcas5p3bd2a8f25ec689ca333bce861b527dba2~54wyKcT0_3155531555epcas5p3y@epcas5p3.samsung.com
    Cc: linux-kernel@vger.kernel.org
    Cc: pankaj.m@samsung.com
    Cc: a.sahrawat@samsung.com
    Signed-off-by: Namit Gupta <gupta.namit@samsung.com>
    Signed-off-by: Himanshu Maithani <himanshu.m@samsung.com>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 3999c295d6f7..16b02cc51a14 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1352,71 +1352,78 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 {
 	char *text;
 	int len = 0;
+	u64 next_seq;
+	u64 seq;
+	u32 idx;
+
+	if (!buf) {
+		if (clear) {
+			logbuf_lock_irq();
+			clear_seq = log_next_seq;
+			clear_idx = log_next_idx;
+			logbuf_unlock_irq();
+		}
+		return 0;
+	}
 
 	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
 	logbuf_lock_irq();
-	if (buf) {
-		u64 next_seq;
-		u64 seq;
-		u32 idx;
+	/*
+	 * Find first record that fits, including all following records,
+	 * into the user-provided buffer for this dump.
+	 */
+	seq = clear_seq;
+	idx = clear_idx;
+	while (seq < log_next_seq) {
+		struct printk_log *msg = log_from_idx(idx);
 
-		/*
-		 * Find first record that fits, including all following records,
-		 * into the user-provided buffer for this dump.
-		 */
-		seq = clear_seq;
-		idx = clear_idx;
-		while (seq < log_next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
-
-			len += msg_print_text(msg, true, NULL, 0);
-			idx = log_next(idx);
-			seq++;
-		}
+		len += msg_print_text(msg, true, NULL, 0);
+		idx = log_next(idx);
+		seq++;
+	}
 
-		/* move first record forward until length fits into the buffer */
-		seq = clear_seq;
-		idx = clear_idx;
-		while (len > size && seq < log_next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
+	/* move first record forward until length fits into the buffer */
+	seq = clear_seq;
+	idx = clear_idx;
+	while (len > size && seq < log_next_seq) {
+		struct printk_log *msg = log_from_idx(idx);
 
-			len -= msg_print_text(msg, true, NULL, 0);
-			idx = log_next(idx);
-			seq++;
-		}
+		len -= msg_print_text(msg, true, NULL, 0);
+		idx = log_next(idx);
+		seq++;
+	}
 
-		/* last message fitting into this dump */
-		next_seq = log_next_seq;
+	/* last message fitting into this dump */
+	next_seq = log_next_seq;
 
-		len = 0;
-		while (len >= 0 && seq < next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
-			int textlen;
+	len = 0;
+	while (len >= 0 && seq < next_seq) {
+		struct printk_log *msg = log_from_idx(idx);
+		int textlen;
 
-			textlen = msg_print_text(msg, true, text,
-						 LOG_LINE_MAX + PREFIX_MAX);
-			if (textlen < 0) {
-				len = textlen;
-				break;
-			}
-			idx = log_next(idx);
-			seq++;
+		textlen = msg_print_text(msg, true, text,
+					 LOG_LINE_MAX + PREFIX_MAX);
+		if (textlen < 0) {
+			len = textlen;
+			break;
+		}
+		idx = log_next(idx);
+		seq++;
 
-			logbuf_unlock_irq();
-			if (copy_to_user(buf + len, text, textlen))
-				len = -EFAULT;
-			else
-				len += textlen;
-			logbuf_lock_irq();
+		logbuf_unlock_irq();
+		if (copy_to_user(buf + len, text, textlen))
+			len = -EFAULT;
+		else
+			len += textlen;
+		logbuf_lock_irq();
 
-			if (seq < log_first_seq) {
-				/* messages are gone, move to next one */
-				seq = log_first_seq;
-				idx = log_first_idx;
-			}
+		if (seq < log_first_seq) {
+			/* messages are gone, move to next one */
+			seq = log_first_seq;
+			idx = log_first_idx;
 		}
 	}
 

commit 375899cddcbb26881b03cb3fbdcfd600e4e67f4a
Author: Maninder Singh <maninder1.s@samsung.com>
Date:   Fri Jun 1 14:26:42 2018 +0530

    printk: make sure to print log on console.
    
    This patch make sure printing of log on console if loglevel
    at time of storing log is less than current console loglevel.
    
    @why
    In SMP printk can work asynchronously, logs can be missed on console
    because it checks current log level at time of console_unlock,
    not at time of storing logs.
    
    func()
    {
    ....
    ....
            console_verbose();  // user wants to have all the logs on console.
            pr_alert();
            dump_backtrace(); //prints with default loglevel.
            ...
            console_silent(); // stop all logs from printing on console.
    }
    
    Now if console_lock was owned by another process, the messages might
    be handled after the consoles were silenced.
    
    Reused flag LOG_NOCONS as its usage is gone long back by the commit
    5c2992ee7fd8a29d0412 ("printk: remove console flushing special cases
    for partial buffered lines").
    
    Note that there are still some corner cases where this patch is not enough.
    For example, when the messages are flushed later from printk_safe buffers
    or when there are races between console_verbose() and console_silent()
    callers.
    
    Link: http://lkml.kernel.org/r/20180601090029epcas5p3cc93d4bfbebb3199f0a2684058da7e26~z-a_jkmrI2993329933epcas5p3q@epcas5p3.samsung.com
    Cc: linux-kernel@vger.kernel.org
    Cc: a.sahrawat@samsung.com
    Cc: pankaj.m@samsung.com
    Cc: v.narang@samsung.com
    Cc: <maninder1.s@samsung.com>
    Signed-off-by: Vaneet Narang <v.narang@samsung.com>
    Signed-off-by: Maninder Singh <maninder1.s@samsung.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 247808333ba4..3999c295d6f7 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -349,7 +349,7 @@ static int console_msg_format = MSG_FORMAT_DEFAULT;
  */
 
 enum log_flags {
-	LOG_NOCONS	= 1,	/* already flushed, do not print to console */
+	LOG_NOCONS	= 1,	/* suppress print, do not print to console */
 	LOG_NEWLINE	= 2,	/* text ended with a newline */
 	LOG_PREFIX	= 4,	/* text started with a prefix */
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
@@ -1886,6 +1886,9 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (dict)
 		lflags |= LOG_PREFIX|LOG_NEWLINE;
 
+	if (suppress_message_printing(level))
+		lflags |= LOG_NOCONS;
+
 	printed_len = log_output(facility, level, lflags, dict, dictlen, text, text_len);
 
 	logbuf_unlock_irqrestore(flags);
@@ -2349,11 +2352,10 @@ void console_unlock(void)
 			break;
 
 		msg = log_from_idx(console_idx);
-		if (suppress_message_printing(msg->level)) {
+		if (msg->flags & LOG_NOCONS) {
 			/*
-			 * Skip record we have buffered and already printed
-			 * directly to the console when we received it, and
-			 * record that has level above the console loglevel.
+			 * Skip record if !ignore_loglevel, and
+			 * record has level above the console loglevel.
 			 */
 			console_idx = log_next(console_idx);
 			console_seq++;

commit d75ae5bdf2353e5c6a1f83da5f6f2d31582f09a3
Merge: 0eb0061381b2 8bafa2a44ff3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 6 16:04:55 2018 -0700

    Merge tag 'printk-for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Help userspace log daemons to catch up with a flood of messages. They
       will get woken after each message even if the console is far behind
       and handled by another process.
    
     - Flush printk safe buffers safely even when panic() happens in the
       normal context.
    
     - Fix possible va_list reuse when race happened in printk_safe().
    
     - Remove %pCr printf format to prevent sleeping in the atomic context.
    
     - Misc vsprintf code cleanup.
    
    * tag 'printk-for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: drop in_nmi check from printk_safe_flush_on_panic()
      lib/vsprintf: Remove atomic-unsafe support for %pCr
      serial: sh-sci: Stop using printk format %pCr
      thermal: bcm2835: Stop using printk format %pCr
      clk: renesas: cpg-mssr: Stop using printk format %pCr
      printk: fix possible reuse of va_list variable
      printk: wake up klogd in vprintk_emit
      vsprintf: Tweak pF/pf comment
      lib/vsprintf: Mark expected switch fall-through
      lib/vsprintf: Replace space with '_' before crng is ready
      lib/vsprintf: Deduplicate pointer_string()
      lib/vsprintf: Move pointer_string() upper
      lib/vsprintf: Make flag_spec global
      lib/vsprintf: Make strspec global
      lib/vsprintf: Make dec_spec global
      lib/test_printf: Mark big constant with UL

commit 43a17111c2553925f65e7be9b9c3f9d90cf29a8b
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Thu Apr 19 10:42:50 2018 +0900

    printk: wake up klogd in vprintk_emit
    
    We wake up klogd very late - only when current console_sem owner
    is done pushing pending kernel messages to the serial/net consoles.
    In some cases this results in lost syslog messages, because kernel
    log buffer is a circular buffer and if we don't wakeup syslog long
    enough there are chances that logbuf simply will wrap around.
    
    The patch moves the klogd wake up call to vprintk_emit(), which is
    the only legit way for a kernel message to appear in the logbuf,
    right after the attempt to handle consoles. As a result, klogd
    will get waken either after flushing the new message to consoles
    or immediately when consoles are still busy with older messages.
    
    Link: http://lkml.kernel.org/r/20180419014250.5692-1-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 704e55129c3a..fba995b305b1 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1907,6 +1907,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		preempt_enable();
 	}
 
+	wake_up_klogd();
 	return printed_len;
 }
 EXPORT_SYMBOL(vprintk_emit);
@@ -2288,9 +2289,7 @@ void console_unlock(void)
 {
 	static char ext_text[CONSOLE_EXT_LOG_MAX];
 	static char text[LOG_LINE_MAX + PREFIX_MAX];
-	static u64 seen_seq;
 	unsigned long flags;
-	bool wake_klogd = false;
 	bool do_cond_resched, retry;
 
 	if (console_suspended) {
@@ -2334,11 +2333,6 @@ void console_unlock(void)
 
 		printk_safe_enter_irqsave(flags);
 		raw_spin_lock(&logbuf_lock);
-		if (seen_seq != log_next_seq) {
-			wake_klogd = true;
-			seen_seq = log_next_seq;
-		}
-
 		if (console_seq < log_first_seq) {
 			len = sprintf(text, "** %u printk messages dropped **\n",
 				      (unsigned)(log_first_seq - console_seq));
@@ -2396,7 +2390,7 @@ void console_unlock(void)
 
 		if (console_lock_spinning_disable_and_check()) {
 			printk_safe_exit_irqrestore(flags);
-			goto out;
+			return;
 		}
 
 		printk_safe_exit_irqrestore(flags);
@@ -2428,10 +2422,6 @@ void console_unlock(void)
 
 	if (retry && console_trylock())
 		goto again;
-
-out:
-	if (wake_klogd)
-		wake_up_klogd();
 }
 EXPORT_SYMBOL(console_unlock);
 

commit 2a56bb596b2c1fb612f9988afda9655c8c872a6e
Merge: 9f3a0941fb5e b0dc52f15e7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 10 11:27:30 2018 -0700

    Merge tag 'trace-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing updates from Steven Rostedt:
     "New features:
    
       - Tom Zanussi's extended histogram work.
    
         This adds the synthetic events to have histograms from multiple
         event data Adds triggers "onmatch" and "onmax" to call the
         synthetic events Several updates to the histogram code from this
    
       - Allow way to nest ring buffer calls in the same context
    
       - Allow absolute time stamps in ring buffer
    
       - Rewrite of filter code parsing based on Al Viro's suggestions
    
       - Setting of trace_clock to global if TSC is unstable (on boot)
    
       - Better OOM handling when allocating large ring buffers
    
       - Added initcall tracepoints (consolidated initcall_debug code with
         them)
    
      And other various fixes and clean ups"
    
    * tag 'trace-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace: (68 commits)
      init: Have initcall_debug still work without CONFIG_TRACEPOINTS
      init, tracing: Have printk come through the trace events for initcall_debug
      init, tracing: instrument security and console initcall trace events
      init, tracing: Add initcall trace events
      tracing: Add rcu dereference annotation for test func that touches filter->prog
      tracing: Add rcu dereference annotation for filter->prog
      tracing: Fixup logic inversion on setting trace_global_clock defaults
      tracing: Hide global trace clock from lockdep
      ring-buffer: Add set/clear_current_oom_origin() during allocations
      ring-buffer: Check if memory is available before allocation
      lockdep: Add print_irqtrace_events() to __warn
      vsprintf: Do not preprocess non-dereferenced pointers for bprintf (%px and %pK)
      tracing: Uninitialized variable in create_tracing_map_fields()
      tracing: Make sure variable string fields are NULL-terminated
      tracing: Add action comparisons when testing matching hist triggers
      tracing: Don't add flag strings when displaying variable references
      tracing: Fix display of hist trigger expressions containing timestamps
      ftrace: Drop a VLA in module_exists()
      tracing: Mention trace_clock=global when warning about unstable clocks
      tracing: Default to using trace_global_clock if sched_clock is unstable
      ...

commit 58eacfffc41735c9155becc73cb7f4dcc60a46a9
Author: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
Date:   Thu Mar 22 20:33:28 2018 -0400

    init, tracing: instrument security and console initcall trace events
    
    Trace events have been added around the initcall functions defined in
    init/main.c. But console and security have their own initcalls. This adds
    the trace events associated for those initcall functions.
    
    Link: http://lkml.kernel.org/r/1521765208.19745.2.camel@polymtl.ca
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f274fbef821d..cb5b35341d69 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -52,6 +52,7 @@
 #include <linux/uaccess.h>
 #include <asm/sections.h>
 
+#include <trace/events/initcall.h>
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
 
@@ -2781,6 +2782,7 @@ EXPORT_SYMBOL(unregister_console);
  */
 void __init console_init(void)
 {
+	int ret;
 	initcall_t *call;
 
 	/* Setup the default TTY line discipline. */
@@ -2791,8 +2793,11 @@ void __init console_init(void)
 	 * inform about problems etc..
 	 */
 	call = __con_initcall_start;
+	trace_initcall_level("console");
 	while (call < __con_initcall_end) {
-		(*call)();
+		trace_initcall_start((*call));
+		ret = (*call)();
+		trace_initcall_finish((*call), ret);
 		call++;
 	}
 }

commit 357aa6aefebe888c712152cb83c9e700f98eebd1
Merge: be88751f320a 47319f7186b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 19:53:30 2018 -0700

    Merge branch 'for-4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Add info about loaded kdump kernel into the dump stack header
    
     - Move dump-stack related code from printk.c to lib/dump_stack.c
    
     - Write message about suspending consoles in KERN_INFO log level
    
    * 'for-4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: change message to pr_info
      printk: move dump stack related code to lib/dump_stack.c
      print kdump kernel loaded status in stack dump

commit 47319f7186b8746521b0ee674054b29d7b35578b
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Mar 22 14:58:33 2018 +0100

    printk: change message to pr_info
    
    To allow userspace to prevent this message from appearing in the
    console by changing the log priority.
    
    This matches other informative messages that the power subsystem emits
    when the system changes power states.
    
    Link: http://lkml.kernel.org/r/20180322135833.16602-1-tomeu.vizoso@collabora.com
    To: linux-kernel@vger.kernel.org
    Cc: kernel@collabora.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index dc663f288463..333f58eac420 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2161,7 +2161,7 @@ void suspend_console(void)
 {
 	if (!console_suspend_enabled)
 		return;
-	printk("Suspending console(s) (use no_console_suspend to debug)\n");
+	pr_info("Suspending console(s) (use no_console_suspend to debug)\n");
 	console_lock();
 	console_suspended = 1;
 	up_console_sem();

commit e36df28f532f882965404d58e240f2e058b61f45
Author: Dave Young <dyoung@redhat.com>
Date:   Tue Feb 13 15:28:34 2018 +0800

    printk: move dump stack related code to lib/dump_stack.c
    
    dump_stack related stuff should belong to lib/dump_stack.c thus move them
    there. Also conditionally compile lib/dump_stack.c since dump_stack code
    does not make sense if printk is disabled.
    
    Link: http://lkml.kernel.org/r/20180213072834.GA24784@dhcp-128-65.nay.redhat.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: akpm@linux-foundation.org
    Cc: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Suggested-by: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fa3de5f10e0e..dc663f288463 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -42,13 +42,11 @@
 #include <linux/rculist.h>
 #include <linux/poll.h>
 #include <linux/irq_work.h>
-#include <linux/utsname.h>
 #include <linux/ctype.h>
 #include <linux/uio.h>
 #include <linux/sched/clock.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
-#include <linux/kexec.h>
 
 #include <linux/uaccess.h>
 #include <asm/sections.h>
@@ -3257,62 +3255,4 @@ void kmsg_dump_rewind(struct kmsg_dumper *dumper)
 }
 EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
 
-static char dump_stack_arch_desc_str[128];
-
-/**
- * dump_stack_set_arch_desc - set arch-specific str to show with task dumps
- * @fmt: printf-style format string
- * @...: arguments for the format string
- *
- * The configured string will be printed right after utsname during task
- * dumps.  Usually used to add arch-specific system identifiers.  If an
- * arch wants to make use of such an ID string, it should initialize this
- * as soon as possible during boot.
- */
-void __init dump_stack_set_arch_desc(const char *fmt, ...)
-{
-	va_list args;
-
-	va_start(args, fmt);
-	vsnprintf(dump_stack_arch_desc_str, sizeof(dump_stack_arch_desc_str),
-		  fmt, args);
-	va_end(args);
-}
-
-/**
- * dump_stack_print_info - print generic debug info for dump_stack()
- * @log_lvl: log level
- *
- * Arch-specific dump_stack() implementations can use this function to
- * print out the same debug information as the generic dump_stack().
- */
-void dump_stack_print_info(const char *log_lvl)
-{
-	printk("%sCPU: %d PID: %d Comm: %.20s %s%s %s %.*s\n",
-	       log_lvl, raw_smp_processor_id(), current->pid, current->comm,
-	       kexec_crash_loaded() ? "Kdump: loaded " : "",
-	       print_tainted(),
-	       init_utsname()->release,
-	       (int)strcspn(init_utsname()->version, " "),
-	       init_utsname()->version);
-
-	if (dump_stack_arch_desc_str[0] != '\0')
-		printk("%sHardware name: %s\n",
-		       log_lvl, dump_stack_arch_desc_str);
-
-	print_worker_info(log_lvl, current);
-}
-
-/**
- * show_regs_print_info - print generic debug info for show_regs()
- * @log_lvl: log level
- *
- * show_regs() implementations can use this function to print out generic
- * debug information.
- */
-void show_regs_print_info(const char *log_lvl)
-{
-	dump_stack_print_info(log_lvl);
-}
-
 #endif

commit 7bec4a96466286b0ad00e6394bbb94c1b3fd98f3
Merge: 16453c9cf855 c14376de3a1b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 1 10:06:39 2018 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk fix from Petr Mladek:
     "Make sure that we wake up userspace loggers. This fixes a race
      introduced by the console waiter logic during this merge window"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: Wake klogd when passing console_lock owner

commit c14376de3a1befa70d9811ca2872d47367b48767
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Feb 26 15:44:20 2018 +0100

    printk: Wake klogd when passing console_lock owner
    
    wake_klogd is a local variable in console_unlock(). The information
    is lost when the console_lock owner using the busy wait added by
    the commit dbdda842fe96f8932 ("printk: Add console owner and waiter
    logic to load balance console writes"). The following race is
    possible:
    
    CPU0                            CPU1
    console_unlock()
    
      for (;;)
         /* calling console for last message */
    
                                    printk()
                                      log_store()
                                        log_next_seq++;
    
         /* see new message */
         if (seen_seq != log_next_seq) {
            wake_klogd = true;
            seen_seq = log_next_seq;
         }
    
         console_lock_spinning_enable();
    
                                      if (console_trylock_spinning())
                                         /* spinning */
    
         if (console_lock_spinning_disable_and_check()) {
            printk_safe_exit_irqrestore(flags);
            return;
    
                                      console_unlock()
                                        if (seen_seq != log_next_seq) {
                                        /* already seen */
                                        /* nothing to do */
    
    Result: Nobody would wakeup klogd.
    
    One solution would be to make a global variable from wake_klogd.
    But then we would need to manipulate it under a lock or so.
    
    This patch wakes klogd also when console_lock is passed to the
    spinning waiter. It looks like the right way to go. Also userspace
    should have a chance to see and store any "flood" of messages.
    
    Note that the very late klogd wake up was a historic solution.
    It made sense on single CPU systems or when sys_syslog() operations
    were synchronized using the big kernel lock like in v2.1.113.
    But it is questionable these days.
    
    Fixes: dbdda842fe96f8932 ("printk: Add console owner and waiter logic to load balance console writes")
    Link: http://lkml.kernel.org/r/20180226155734.dzwg3aovqnwtvkoy@pathway.suse.cz
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: Tejun Heo <tj@kernel.org>
    Suggested-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index db4b9b8929eb..4d818642ac0e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2397,7 +2397,7 @@ void console_unlock(void)
 
 		if (console_lock_spinning_disable_and_check()) {
 			printk_safe_exit_irqrestore(flags);
-			return;
+			goto out;
 		}
 
 		printk_safe_exit_irqrestore(flags);
@@ -2430,6 +2430,7 @@ void console_unlock(void)
 	if (retry && console_trylock())
 		goto again;
 
+out:
 	if (wake_klogd)
 		wake_up_klogd();
 }

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index db4b9b8929eb..fc1123583fa6 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -930,7 +930,7 @@ static __poll_t devkmsg_poll(struct file *file, poll_table *wait)
 	__poll_t ret = 0;
 
 	if (!user)
-		return POLLERR|POLLNVAL;
+		return EPOLLERR|EPOLLNVAL;
 
 	poll_wait(file, &log_wait, wait);
 
@@ -938,9 +938,9 @@ static __poll_t devkmsg_poll(struct file *file, poll_table *wait)
 	if (user->seq < log_next_seq) {
 		/* return error when data has vanished underneath us */
 		if (user->seq < log_first_seq)
-			ret = POLLIN|POLLRDNORM|POLLERR|POLLPRI;
+			ret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;
 		else
-			ret = POLLIN|POLLRDNORM;
+			ret = EPOLLIN|EPOLLRDNORM;
 	}
 	logbuf_unlock_irq();
 

commit 097114aa6eb2aa206c8cf136de77ebffe424234c
Author: Dave Young <dyoung@redhat.com>
Date:   Sat Jan 27 12:11:29 2018 +0800

    print kdump kernel loaded status in stack dump
    
    It is useful to print kdump kernel loaded status in dump_stack()
    especially when panic happens so that we can differenciate
    kdump kernel early hang and a normal panic in a bug report.
    
    Link: http://lkml.kernel.org/r/20180127041129.GA29016@dhcp-128-65.nay.redhat.com
    To: Steven Rostedt <rostedt@goodmis.org>
    To: Andi Kleen <ak@linux.intel.com>
    To: kexec@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: akpm@linux-foundation.org
    Cc: kexec@lists.infradead.org
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index db4b9b8929eb..fa3de5f10e0e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -48,6 +48,7 @@
 #include <linux/sched/clock.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
+#include <linux/kexec.h>
 
 #include <linux/uaccess.h>
 #include <asm/sections.h>
@@ -3287,9 +3288,11 @@ void __init dump_stack_set_arch_desc(const char *fmt, ...)
  */
 void dump_stack_print_info(const char *log_lvl)
 {
-	printk("%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n",
+	printk("%sCPU: %d PID: %d Comm: %.20s %s%s %s %.*s\n",
 	       log_lvl, raw_smp_processor_id(), current->pid, current->comm,
-	       print_tainted(), init_utsname()->release,
+	       kexec_crash_loaded() ? "Kdump: loaded " : "",
+	       print_tainted(),
+	       init_utsname()->release,
 	       (int)strcspn(init_utsname()->version, " "),
 	       init_utsname()->version);
 

commit ab486bc9a591689f3ac2b6ebc072309371f8f451
Merge: 34b1cf60abb0 bb4f552a598d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 13:36:15 2018 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Add a console_msg_format command line option:
    
         The value "default" keeps the old "[time stamp] text\n" format. The
         value "syslog" allows to see the syslog-like "<log
         level>[timestamp] text" format.
    
         This feature was requested by people doing regression tests, for
         example, 0day robot. They want to have both filtered and full logs
         at hands.
    
     - Reduce the risk of softlockup:
    
         Pass the console owner in a busy loop.
    
         This is a new approach to the old problem. It was first proposed by
         Steven Rostedt on Kernel Summit 2017. It marks a context in which
         the console_lock owner calls console drivers and could not sleep.
         On the other side, printk() callers could detect this state and use
         a busy wait instead of a simple console_trylock(). Finally, the
         console_lock owner checks if there is a busy waiter at the end of
         the special context and eventually passes the console_lock to the
         waiter.
    
         The hand-off works surprisingly well and helps in many situations.
         Well, there is still a possibility of the softlockup, for example,
         when the flood of messages stops and the last owner still has too
         much to flush.
    
         There is increasing number of people having problems with
         printk-related softlockups. We might eventually need to get better
         solution. Anyway, this looks like a good start and promising
         direction.
    
     - Do not allow to schedule in console_unlock() called from printk():
    
         This reverts an older controversial commit. The reschedule helped
         to avoid softlockups. But it also slowed down the console output.
         This patch is obsoleted by the new console waiter logic described
         above. In fact, the reschedule made the hand-off less effective.
    
     - Deprecate "%pf" and "%pF" format specifier:
    
         It was needed on ia64, ppc64 and parisc64 to dereference function
         descriptors and show the real function address. It is done
         transparently by "%ps" and "pS" format specifier now.
    
         Sergey Senozhatsky found that all the function descriptors were in
         a special elf section and could be easily detected.
    
     - Remove printk_symbol() API:
    
         It has been obsoleted by "%pS" format specifier, and this change
         helped to remove few continuous lines and a less intuitive old API.
    
     - Remove redundant memsets:
    
         Sergey removed unnecessary memset when processing printk.devkmsg
         command line option.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk: (27 commits)
      printk: drop redundant devkmsg_log_str memsets
      printk: Never set console_may_schedule in console_trylock()
      printk: Hide console waiter logic into helpers
      printk: Add console owner and waiter logic to load balance console writes
      kallsyms: remove print_symbol() function
      checkpatch: add pF/pf deprecation warning
      symbol lookup: introduce dereference_symbol_descriptor()
      parisc64: Add .opd based function descriptor dereference
      powerpc64: Add .opd based function descriptor dereference
      ia64: Add .opd based function descriptor dereference
      sections: split dereference_function_descriptor()
      openrisc: Fix conflicting types for _exext and _stext
      lib: do not use print_symbol()
      irq debug: do not use print_symbol()
      sysfs: do not use print_symbol()
      drivers: do not use print_symbol()
      x86: do not use print_symbol()
      unicore32: do not use print_symbol()
      sh: do not use print_symbol()
      mn10300: do not use print_symbol()
      ...

commit 168fe32a072a4b8dc81a3aebf0e5e588d38e2955
Merge: 13ddd1667e7f c71d227fc413
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 17:58:07 2018 -0800

    Merge branch 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull poll annotations from Al Viro:
     "This introduces a __bitwise type for POLL### bitmap, and propagates
      the annotations through the tree. Most of that stuff is as simple as
      'make ->poll() instances return __poll_t and do the same to local
      variables used to hold the future return value'.
    
      Some of the obvious brainos found in process are fixed (e.g. POLLIN
      misspelled as POLL_IN). At that point the amount of sparse warnings is
      low and most of them are for genuine bugs - e.g. ->poll() instance
      deciding to return -EINVAL instead of a bitmap. I hadn't touched those
      in this series - it's large enough as it is.
    
      Another problem it has caught was eventpoll() ABI mess; select.c and
      eventpoll.c assumed that corresponding POLL### and EPOLL### were
      equal. That's true for some, but not all of them - EPOLL### are
      arch-independent, but POLL### are not.
    
      The last commit in this series separates userland POLL### values from
      the (now arch-independent) kernel-side ones, converting between them
      in the few places where they are copied to/from userland. AFAICS, this
      is the least disruptive fix preserving poll(2) ABI and making epoll()
      work on all architectures.
    
      As it is, it's simply broken on sparc - try to give it EPOLLWRNORM and
      it will trigger only on what would've triggered EPOLLWRBAND on other
      architectures. EPOLLWRBAND and EPOLLRDHUP, OTOH, are never triggered
      at all on sparc. With this patch they should work consistently on all
      architectures"
    
    * 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (37 commits)
      make kernel-side POLL... arch-independent
      eventpoll: no need to mask the result of epi_item_poll() again
      eventpoll: constify struct epoll_event pointers
      debugging printk in sg_poll() uses %x to print POLL... bitmap
      annotate poll(2) guts
      9p: untangle ->poll() mess
      ->si_band gets POLL... bitmap stored into a user-visible long field
      ring_buffer_poll_wait() return value used as return value of ->poll()
      the rest of drivers/*: annotate ->poll() instances
      media: annotate ->poll() instances
      fs: annotate ->poll() instances
      ipc, kernel, mm: annotate ->poll() instances
      net: annotate ->poll() instances
      apparmor: annotate ->poll() instances
      tomoyo: annotate ->poll() instances
      sound: annotate ->poll() instances
      acpi: annotate ->poll() instances
      crypto: annotate ->poll() instances
      block: annotate ->poll() instances
      x86: annotate ->poll() instances
      ...

commit bb4f552a598d40624343bc0815e594efd4d6ec3d
Merge: 51ccbb0ae865 fd5f7cde1b85
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Jan 22 10:40:59 2018 +0100

    Merge branch 'for-4.16-console-waiter-logic' into for-4.16

commit 6fd78a1a99c9580da49ee8f951fdce9846256375
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Fri Jan 19 13:39:01 2018 +0900

    printk: drop redundant devkmsg_log_str memsets
    
    We copy in null terminated strings "on" and "off", no
    need to zero out devkmsg_log_str in control_devkmsg().
    
    Link: http://lkml.kernel.org/r/20180119043901.1728-1-sergey.senozhatsky@gmail.com
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 568729e0dc2c..bf2e6741ec12 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -131,13 +131,10 @@ static int __init control_devkmsg(char *str)
 	/*
 	 * Set sysctl string accordingly:
 	 */
-	if (devkmsg_log == DEVKMSG_LOG_MASK_ON) {
-		memset(devkmsg_log_str, 0, DEVKMSG_STR_MAX_SIZE);
-		strncpy(devkmsg_log_str, "on", 2);
-	} else if (devkmsg_log == DEVKMSG_LOG_MASK_OFF) {
-		memset(devkmsg_log_str, 0, DEVKMSG_STR_MAX_SIZE);
-		strncpy(devkmsg_log_str, "off", 3);
-	}
+	if (devkmsg_log == DEVKMSG_LOG_MASK_ON)
+		strcpy(devkmsg_log_str, "on");
+	else if (devkmsg_log == DEVKMSG_LOG_MASK_OFF)
+		strcpy(devkmsg_log_str, "off");
 	/* else "ratelimit" which is set by default. */
 
 	/*

commit fd5f7cde1b85d4c8e09ca46ce948e008a2377f64
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Tue Jan 16 13:47:16 2018 +0900

    printk: Never set console_may_schedule in console_trylock()
    
    This patch, basically, reverts commit 6b97a20d3a79 ("printk:
    set may_schedule for some of console_trylock() callers").
    That commit was a mistake, it introduced a big dependency
    on the scheduler, by enabling preemption under console_sem
    in printk()->console_unlock() path, which is rather too
    critical. The patch did not significantly reduce the
    possibilities of printk() lockups, but made it possible to
    stall printk(), as has been reported by Tetsuo Handa [1].
    
    Another issues is that preemption under console_sem also
    messes up with Steven Rostedt's hand off scheme, by making
    it possible to sleep with console_sem both in console_unlock()
    and in vprintk_emit(), after acquiring the console_sem
    ownership (anywhere between printk_safe_exit_irqrestore() in
    console_trylock_spinning() and printk_safe_enter_irqsave()
    in console_unlock()). This makes hand off less likely and,
    at the same time, may result in a significant amount of
    pending logbuf messages. Preempted console_sem owner makes
    it impossible for other CPUs to emit logbuf messages, but
    does not make it impossible for other CPUs to append new
    messages to the logbuf.
    
    Reinstate the old behavior and make printk() non-preemptible.
    Should any printk() lockup reports arrive they must be handled
    in a different way.
    
    [1] http://lkml.kernel.org/r/201603022101.CAH73907.OVOOMFHFFtQJSL%20()%20I-love%20!%20SAKURA%20!%20ne%20!%20jp
    Fixes: 6b97a20d3a79 ("printk: set may_schedule for some of console_trylock() callers")
    Link: http://lkml.kernel.org/r/20180116044716.GE6607@jagdpanzerIV
    To: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: akpm@linux-foundation.org
    Cc: linux-mm@kvack.org
    Cc: Cong Wang <xiyou.wangcong@gmail.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Byungchul Park <byungchul.park@lge.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 3a475f58b749..6b9d8d56e0e2 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1888,6 +1888,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
+		/*
+		 * Disable preemption to avoid being preempted while holding
+		 * console_sem which would prevent anyone from printing to
+		 * console
+		 */
+		preempt_disable();
 		/*
 		 * Try to acquire and then immediately release the console
 		 * semaphore.  The release will print out buffers and wake up
@@ -1895,6 +1901,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (console_trylock_spinning())
 			console_unlock();
+		preempt_enable();
 	}
 
 	return printed_len;
@@ -2211,20 +2218,7 @@ int console_trylock(void)
 		return 0;
 	}
 	console_locked = 1;
-	/*
-	 * When PREEMPT_COUNT disabled we can't reliably detect if it's
-	 * safe to schedule (e.g. calling printk while holding a spin_lock),
-	 * because preempt_disable()/preempt_enable() are just barriers there
-	 * and preempt_count() is always 0.
-	 *
-	 * RCU read sections have a separate preemption counter when
-	 * PREEMPT_RCU enabled thus we must take extra care and check
-	 * rcu_preempt_depth(), otherwise RCU read sections modify
-	 * preempt_count().
-	 */
-	console_may_schedule = !oops_in_progress &&
-			preemptible() &&
-			!rcu_preempt_depth();
+	console_may_schedule = 0;
 	return 1;
 }
 EXPORT_SYMBOL(console_trylock);

commit c162d5b4338d72deed61aa65ed0f2f4ba2bbc8ab
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri Jan 12 17:08:37 2018 +0100

    printk: Hide console waiter logic into helpers
    
    The commit ("printk: Add console owner and waiter logic to load balance
    console writes") made vprintk_emit() and console_unlock() even more
    complicated.
    
    This patch extracts the new code into 3 helper functions. They should
    help to keep it rather self-contained. It will be easier to use and
    maintain.
    
    This patch just shuffles the existing code. It does not change
    the functionality.
    
    Link: http://lkml.kernel.org/r/20180112160837.GD24497@linux.suse
    Cc: akpm@linux-foundation.org
    Cc: linux-mm@kvack.org
    Cc: Cong Wang <xiyou.wangcong@gmail.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: rostedt@home.goodmis.org
    Cc: Byungchul Park <byungchul.park@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 040fb948924e..3a475f58b749 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -86,15 +86,8 @@ EXPORT_SYMBOL_GPL(console_drivers);
 static struct lockdep_map console_lock_dep_map = {
 	.name = "console_lock"
 };
-static struct lockdep_map console_owner_dep_map = {
-	.name = "console_owner"
-};
 #endif
 
-static DEFINE_RAW_SPINLOCK(console_owner_lock);
-static struct task_struct *console_owner;
-static bool console_waiter;
-
 enum devkmsg_log_bits {
 	__DEVKMSG_LOG_BIT_ON = 0,
 	__DEVKMSG_LOG_BIT_OFF,
@@ -1550,6 +1543,146 @@ SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)
 	return do_syslog(type, buf, len, SYSLOG_FROM_READER);
 }
 
+/*
+ * Special console_lock variants that help to reduce the risk of soft-lockups.
+ * They allow to pass console_lock to another printk() call using a busy wait.
+ */
+
+#ifdef CONFIG_LOCKDEP
+static struct lockdep_map console_owner_dep_map = {
+	.name = "console_owner"
+};
+#endif
+
+static DEFINE_RAW_SPINLOCK(console_owner_lock);
+static struct task_struct *console_owner;
+static bool console_waiter;
+
+/**
+ * console_lock_spinning_enable - mark beginning of code where another
+ *	thread might safely busy wait
+ *
+ * This basically converts console_lock into a spinlock. This marks
+ * the section where the console_lock owner can not sleep, because
+ * there may be a waiter spinning (like a spinlock). Also it must be
+ * ready to hand over the lock at the end of the section.
+ */
+static void console_lock_spinning_enable(void)
+{
+	raw_spin_lock(&console_owner_lock);
+	console_owner = current;
+	raw_spin_unlock(&console_owner_lock);
+
+	/* The waiter may spin on us after setting console_owner */
+	spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+}
+
+/**
+ * console_lock_spinning_disable_and_check - mark end of code where another
+ *	thread was able to busy wait and check if there is a waiter
+ *
+ * This is called at the end of the section where spinning is allowed.
+ * It has two functions. First, it is a signal that it is no longer
+ * safe to start busy waiting for the lock. Second, it checks if
+ * there is a busy waiter and passes the lock rights to her.
+ *
+ * Important: Callers lose the lock if there was a busy waiter.
+ *	They must not touch items synchronized by console_lock
+ *	in this case.
+ *
+ * Return: 1 if the lock rights were passed, 0 otherwise.
+ */
+static int console_lock_spinning_disable_and_check(void)
+{
+	int waiter;
+
+	raw_spin_lock(&console_owner_lock);
+	waiter = READ_ONCE(console_waiter);
+	console_owner = NULL;
+	raw_spin_unlock(&console_owner_lock);
+
+	if (!waiter) {
+		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+		return 0;
+	}
+
+	/* The waiter is now free to continue */
+	WRITE_ONCE(console_waiter, false);
+
+	spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+
+	/*
+	 * Hand off console_lock to waiter. The waiter will perform
+	 * the up(). After this, the waiter is the console_lock owner.
+	 */
+	mutex_release(&console_lock_dep_map, 1, _THIS_IP_);
+	return 1;
+}
+
+/**
+ * console_trylock_spinning - try to get console_lock by busy waiting
+ *
+ * This allows to busy wait for the console_lock when the current
+ * owner is running in specially marked sections. It means that
+ * the current owner is running and cannot reschedule until it
+ * is ready to lose the lock.
+ *
+ * Return: 1 if we got the lock, 0 othrewise
+ */
+static int console_trylock_spinning(void)
+{
+	struct task_struct *owner = NULL;
+	bool waiter;
+	bool spin = false;
+	unsigned long flags;
+
+	if (console_trylock())
+		return 1;
+
+	printk_safe_enter_irqsave(flags);
+
+	raw_spin_lock(&console_owner_lock);
+	owner = READ_ONCE(console_owner);
+	waiter = READ_ONCE(console_waiter);
+	if (!waiter && owner && owner != current) {
+		WRITE_ONCE(console_waiter, true);
+		spin = true;
+	}
+	raw_spin_unlock(&console_owner_lock);
+
+	/*
+	 * If there is an active printk() writing to the
+	 * consoles, instead of having it write our data too,
+	 * see if we can offload that load from the active
+	 * printer, and do some printing ourselves.
+	 * Go into a spin only if there isn't already a waiter
+	 * spinning, and there is an active printer, and
+	 * that active printer isn't us (recursive printk?).
+	 */
+	if (!spin) {
+		printk_safe_exit_irqrestore(flags);
+		return 0;
+	}
+
+	/* We spin waiting for the owner to release us */
+	spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+	/* Owner will clear console_waiter on hand off */
+	while (READ_ONCE(console_waiter))
+		cpu_relax();
+	spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+
+	printk_safe_exit_irqrestore(flags);
+	/*
+	 * The owner passed the console lock to us.
+	 * Since we did not spin on console lock, annotate
+	 * this as a trylock. Otherwise lockdep will
+	 * complain.
+	 */
+	mutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);
+
+	return 1;
+}
+
 /*
  * Call the console drivers, asking them to write out
  * log_buf[start] to log_buf[end - 1].
@@ -1760,56 +1893,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * semaphore.  The release will print out buffers and wake up
 		 * /dev/kmsg and syslog() users.
 		 */
-		if (console_trylock()) {
+		if (console_trylock_spinning())
 			console_unlock();
-		} else {
-			struct task_struct *owner = NULL;
-			bool waiter;
-			bool spin = false;
-
-			printk_safe_enter_irqsave(flags);
-
-			raw_spin_lock(&console_owner_lock);
-			owner = READ_ONCE(console_owner);
-			waiter = READ_ONCE(console_waiter);
-			if (!waiter && owner && owner != current) {
-				WRITE_ONCE(console_waiter, true);
-				spin = true;
-			}
-			raw_spin_unlock(&console_owner_lock);
-
-			/*
-			 * If there is an active printk() writing to the
-			 * consoles, instead of having it write our data too,
-			 * see if we can offload that load from the active
-			 * printer, and do some printing ourselves.
-			 * Go into a spin only if there isn't already a waiter
-			 * spinning, and there is an active printer, and
-			 * that active printer isn't us (recursive printk?).
-			 */
-			if (spin) {
-				/* We spin waiting for the owner to release us */
-				spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
-				/* Owner will clear console_waiter on hand off */
-				while (READ_ONCE(console_waiter))
-					cpu_relax();
-
-				spin_release(&console_owner_dep_map, 1, _THIS_IP_);
-				printk_safe_exit_irqrestore(flags);
-
-				/*
-				 * The owner passed the console lock to us.
-				 * Since we did not spin on console lock, annotate
-				 * this as a trylock. Otherwise lockdep will
-				 * complain.
-				 */
-				mutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);
-				console_unlock();
-				printk_safe_enter_irqsave(flags);
-			}
-			printk_safe_exit_irqrestore(flags);
-
-		}
 	}
 
 	return printed_len;
@@ -1910,6 +1995,8 @@ static ssize_t msg_print_ext_header(char *buf, size_t size,
 static ssize_t msg_print_ext_body(char *buf, size_t size,
 				  char *dict, size_t dict_len,
 				  char *text, size_t text_len) { return 0; }
+static void console_lock_spinning_enable(void) { }
+static int console_lock_spinning_disable_and_check(void) { return 0; }
 static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg,
@@ -2196,7 +2283,6 @@ void console_unlock(void)
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
-	bool waiter = false;
 	bool do_cond_resched, retry;
 
 	if (console_suspended) {
@@ -2291,31 +2377,16 @@ void console_unlock(void)
 		 * finish. This task can not be preempted if there is a
 		 * waiter waiting to take over.
 		 */
-		raw_spin_lock(&console_owner_lock);
-		console_owner = current;
-		raw_spin_unlock(&console_owner_lock);
-
-		/* The waiter may spin on us after setting console_owner */
-		spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+		console_lock_spinning_enable();
 
 		stop_critical_timings();	/* don't trace print latency */
 		call_console_drivers(ext_text, ext_len, text, len);
 		start_critical_timings();
 
-		raw_spin_lock(&console_owner_lock);
-		waiter = READ_ONCE(console_waiter);
-		console_owner = NULL;
-		raw_spin_unlock(&console_owner_lock);
-
-		/*
-		 * If there is a waiter waiting for us, then pass the
-		 * rest of the work load over to that waiter.
-		 */
-		if (waiter)
-			break;
-
-		/* There was no waiter, and nothing will spin on us here */
-		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+		if (console_lock_spinning_disable_and_check()) {
+			printk_safe_exit_irqrestore(flags);
+			return;
+		}
 
 		printk_safe_exit_irqrestore(flags);
 
@@ -2323,26 +2394,6 @@ void console_unlock(void)
 			cond_resched();
 	}
 
-	/*
-	 * If there is an active waiter waiting on the console_lock.
-	 * Pass off the printing to the waiter, and the waiter
-	 * will continue printing on its CPU, and when all writing
-	 * has finished, the last printer will wake up klogd.
-	 */
-	if (waiter) {
-		WRITE_ONCE(console_waiter, false);
-		/* The waiter is now free to continue */
-		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
-		/*
-		 * Hand off console_lock to waiter. The waiter will perform
-		 * the up(). After this, the waiter is the console_lock owner.
-		 */
-		mutex_release(&console_lock_dep_map, 1, _THIS_IP_);
-		printk_safe_exit_irqrestore(flags);
-		/* Note, if waiter is set, logbuf_lock is not held */
-		return;
-	}
-
 	console_locked = 0;
 
 	/* Release the exclusive_console once it is used */

commit dbdda842fe96f8932bae554f0adf463c27c42bc7
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Wed Jan 10 14:24:17 2018 +0100

    printk: Add console owner and waiter logic to load balance console writes
    
    This patch implements what I discussed in Kernel Summit. I added
    lockdep annotation (hopefully correctly), and it hasn't had any splats
    (since I fixed some bugs in the first iterations). It did catch
    problems when I had the owner covering too much. But now that the owner
    is only set when actively calling the consoles, lockdep has stayed
    quiet.
    
    Here's the design again:
    
    I added a "console_owner" which is set to a task that is actively
    writing to the consoles. It is *not* the same as the owner of the
    console_lock. It is only set when doing the calls to the console
    functions. It is protected by a console_owner_lock which is a raw spin
    lock.
    
    There is a console_waiter. This is set when there is an active console
    owner that is not current, and waiter is not set. This too is protected
    by console_owner_lock.
    
    In printk() when it tries to write to the consoles, we have:
    
            if (console_trylock())
                    console_unlock();
    
    Now I added an else, which will check if there is an active owner, and
    no current waiter. If that is the case, then console_waiter is set, and
    the task goes into a spin until it is no longer set.
    
    When the active console owner finishes writing the current message to
    the consoles, it grabs the console_owner_lock and sees if there is a
    waiter, and clears console_owner.
    
    If there is a waiter, then it breaks out of the loop, clears the waiter
    flag (because that will release the waiter from its spin), and exits.
    Note, it does *not* release the console semaphore. Because it is a
    semaphore, there is no owner. Another task may release it. This means
    that the waiter is guaranteed to be the new console owner! Which it
    becomes.
    
    Then the waiter calls console_unlock() and continues to write to the
    consoles.
    
    If another task comes along and does a printk() it too can become the
    new waiter, and we wash rinse and repeat!
    
    By Petr Mladek about possible new deadlocks:
    
    The thing is that we move console_sem only to printk() call
    that normally calls console_unlock() as well. It means that
    the transferred owner should not bring new type of dependencies.
    As Steven said somewhere: "If there is a deadlock, it was
    there even before."
    
    We could look at it from this side. The possible deadlock would
    look like:
    
    CPU0                            CPU1
    
    console_unlock()
    
      console_owner = current;
    
                                    spin_lockA()
                                      printk()
                                        spin = true;
                                        while (...)
    
        call_console_drivers()
          spin_lockA()
    
    This would be a deadlock. CPU0 would wait for the lock A.
    While CPU1 would own the lockA and would wait for CPU0
    to finish calling the console drivers and pass the console_sem
    owner.
    
    But if the above is true than the following scenario was
    already possible before:
    
    CPU0
    
    spin_lockA()
      printk()
        console_unlock()
          call_console_drivers()
            spin_lockA()
    
    By other words, this deadlock was there even before. Such
    deadlocks are prevented by using printk_deferred() in
    the sections guarded by the lock A.
    
    By Steven Rostedt:
    
    To demonstrate the issue, this module has been shown to lock up a
    system with 4 CPUs and a slow console (like a serial console). It is
    also able to lock up a 8 CPU system with only a fast (VGA) console, by
    passing in "loops=100". The changes in this commit prevent this module
    from locking up the system.
    
     #include <linux/module.h>
     #include <linux/delay.h>
     #include <linux/sched.h>
     #include <linux/mutex.h>
     #include <linux/workqueue.h>
     #include <linux/hrtimer.h>
    
     static bool stop_testing;
     static unsigned int loops = 1;
    
     static void preempt_printk_workfn(struct work_struct *work)
     {
            int i;
    
            while (!READ_ONCE(stop_testing)) {
                    for (i = 0; i < loops && !READ_ONCE(stop_testing); i++) {
                            preempt_disable();
                            pr_emerg("%5d%-75s\n", smp_processor_id(),
                                     " XXX NOPREEMPT");
                            preempt_enable();
                    }
                    msleep(1);
            }
     }
    
     static struct work_struct __percpu *works;
    
     static void finish(void)
     {
            int cpu;
    
            WRITE_ONCE(stop_testing, true);
            for_each_online_cpu(cpu)
                    flush_work(per_cpu_ptr(works, cpu));
            free_percpu(works);
     }
    
     static int __init test_init(void)
     {
            int cpu;
    
            works = alloc_percpu(struct work_struct);
            if (!works)
                    return -ENOMEM;
    
            /*
             * This is just a test module. This will break if you
             * do any CPU hot plugging between loading and
             * unloading the module.
             */
    
            for_each_online_cpu(cpu) {
                    struct work_struct *work = per_cpu_ptr(works, cpu);
    
                    INIT_WORK(work, &preempt_printk_workfn);
                    schedule_work_on(cpu, work);
            }
    
            return 0;
     }
    
     static void __exit test_exit(void)
     {
            finish();
     }
    
     module_param(loops, uint, 0);
     module_init(test_init);
     module_exit(test_exit);
     MODULE_LICENSE("GPL");
    
    Link: http://lkml.kernel.org/r/20180110132418.7080-2-pmladek@suse.com
    Cc: akpm@linux-foundation.org
    Cc: linux-mm@kvack.org
    Cc: Cong Wang <xiyou.wangcong@gmail.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Byungchul Park <byungchul.park@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    [pmladek@suse.com: Commit message about possible deadlocks]
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5d81206a572d..040fb948924e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -86,8 +86,15 @@ EXPORT_SYMBOL_GPL(console_drivers);
 static struct lockdep_map console_lock_dep_map = {
 	.name = "console_lock"
 };
+static struct lockdep_map console_owner_dep_map = {
+	.name = "console_owner"
+};
 #endif
 
+static DEFINE_RAW_SPINLOCK(console_owner_lock);
+static struct task_struct *console_owner;
+static bool console_waiter;
+
 enum devkmsg_log_bits {
 	__DEVKMSG_LOG_BIT_ON = 0,
 	__DEVKMSG_LOG_BIT_OFF,
@@ -1753,8 +1760,56 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * semaphore.  The release will print out buffers and wake up
 		 * /dev/kmsg and syslog() users.
 		 */
-		if (console_trylock())
+		if (console_trylock()) {
 			console_unlock();
+		} else {
+			struct task_struct *owner = NULL;
+			bool waiter;
+			bool spin = false;
+
+			printk_safe_enter_irqsave(flags);
+
+			raw_spin_lock(&console_owner_lock);
+			owner = READ_ONCE(console_owner);
+			waiter = READ_ONCE(console_waiter);
+			if (!waiter && owner && owner != current) {
+				WRITE_ONCE(console_waiter, true);
+				spin = true;
+			}
+			raw_spin_unlock(&console_owner_lock);
+
+			/*
+			 * If there is an active printk() writing to the
+			 * consoles, instead of having it write our data too,
+			 * see if we can offload that load from the active
+			 * printer, and do some printing ourselves.
+			 * Go into a spin only if there isn't already a waiter
+			 * spinning, and there is an active printer, and
+			 * that active printer isn't us (recursive printk?).
+			 */
+			if (spin) {
+				/* We spin waiting for the owner to release us */
+				spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+				/* Owner will clear console_waiter on hand off */
+				while (READ_ONCE(console_waiter))
+					cpu_relax();
+
+				spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+				printk_safe_exit_irqrestore(flags);
+
+				/*
+				 * The owner passed the console lock to us.
+				 * Since we did not spin on console lock, annotate
+				 * this as a trylock. Otherwise lockdep will
+				 * complain.
+				 */
+				mutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);
+				console_unlock();
+				printk_safe_enter_irqsave(flags);
+			}
+			printk_safe_exit_irqrestore(flags);
+
+		}
 	}
 
 	return printed_len;
@@ -2141,6 +2196,7 @@ void console_unlock(void)
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
+	bool waiter = false;
 	bool do_cond_resched, retry;
 
 	if (console_suspended) {
@@ -2229,14 +2285,64 @@ void console_unlock(void)
 		console_seq++;
 		raw_spin_unlock(&logbuf_lock);
 
+		/*
+		 * While actively printing out messages, if another printk()
+		 * were to occur on another CPU, it may wait for this one to
+		 * finish. This task can not be preempted if there is a
+		 * waiter waiting to take over.
+		 */
+		raw_spin_lock(&console_owner_lock);
+		console_owner = current;
+		raw_spin_unlock(&console_owner_lock);
+
+		/* The waiter may spin on us after setting console_owner */
+		spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
+
 		stop_critical_timings();	/* don't trace print latency */
 		call_console_drivers(ext_text, ext_len, text, len);
 		start_critical_timings();
+
+		raw_spin_lock(&console_owner_lock);
+		waiter = READ_ONCE(console_waiter);
+		console_owner = NULL;
+		raw_spin_unlock(&console_owner_lock);
+
+		/*
+		 * If there is a waiter waiting for us, then pass the
+		 * rest of the work load over to that waiter.
+		 */
+		if (waiter)
+			break;
+
+		/* There was no waiter, and nothing will spin on us here */
+		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+
 		printk_safe_exit_irqrestore(flags);
 
 		if (do_cond_resched)
 			cond_resched();
 	}
+
+	/*
+	 * If there is an active waiter waiting on the console_lock.
+	 * Pass off the printing to the waiter, and the waiter
+	 * will continue printing on its CPU, and when all writing
+	 * has finished, the last printer will wake up klogd.
+	 */
+	if (waiter) {
+		WRITE_ONCE(console_waiter, false);
+		/* The waiter is now free to continue */
+		spin_release(&console_owner_dep_map, 1, _THIS_IP_);
+		/*
+		 * Hand off console_lock to waiter. The waiter will perform
+		 * the up(). After this, the waiter is the console_lock owner.
+		 */
+		mutex_release(&console_lock_dep_map, 1, _THIS_IP_);
+		printk_safe_exit_irqrestore(flags);
+		/* Note, if waiter is set, logbuf_lock is not held */
+		return;
+	}
+
 	console_locked = 0;
 
 	/* Release the exclusive_console once it is used */

commit cca10d58d25d271f05e1115132b4c2d913bb652e
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Thu Dec 21 14:41:49 2017 +0900

    printk: add console_msg_format command line option
    
    0day and kernelCI automatically parse kernel log - basically some sort
    of grepping using the pre-defined text patterns - in order to detect
    and report regressions/errors. There are several sources they get the
    kernel logs from:
    
    a) dmesg or /proc/ksmg
    
       This is the preferred way. Because `dmesg --raw' (see later Note)
       and /proc/kmsg output contains facility and log level, which greatly
       simplifies grepping for EMERG/ALERT/CRIT/ERR messages.
    
    b) serial consoles
    
       This option is harder to maintain, because serial console messages
       don't contain facility and log level.
    
    This patch introduces a `console_msg_format=' command line option,
    to switch between different message formatting on serial consoles.
    For the time being we have just two options - default and syslog.
    The "default" option just keeps the existing format. While the
    "syslog" option makes serial console messages to appear in syslog
    format [syslog() syscall], matching the `dmesg -S --raw' and
    `cat /proc/kmsg' output formats:
    
    - facility and log level
    - time stamp (depends on printk_time/PRINTK_TIME)
    - message
    
            <%u>[time stamp] text\n
    
    NOTE: while Kevin and Fengguang talk about "dmesg --raw", it's actually
    "dmesg -S --raw" that always prints messages in syslog format [per
    Petr Mladek]. Running "dmesg --raw" may produce output in non-syslog
    format sometimes. console_msg_format=syslog enables syslog format,
    thus in documentation we mention "dmesg -S --raw", not "dmesg --raw".
    
    Per Kevin Hilman:
    
    : Right now we can get this info from a "dmesg --raw" after bootup,
    : but it would be really nice in certain automation frameworks to
    : have a kernel command-line option to enable printing of loglevels
    : in default boot log.
    :
    : This is especially useful when ingesting kernel logs into advanced
    : search/analytics frameworks (I'm playing with and ELK stack: Elastic
    : Search, Logstash, Kibana).
    :
    : The other important reason for having this on the command line is that
    : for testing linux-next (and other bleeding edge developer branches),
    : it's common that we never make it to userspace, so can't even run
    : "dmesg --raw" (or equivalent.)  So we really want this on the primary
    : boot (serial) console.
    
    Per Fengguang Wu, 0day scripts should quickly benefit from that
    feature, because they will be able to switch to a more reliable
    parsing, based on messages' facility and log levels [1]:
    
    `#{grep} -a -E -e '^<[0123]>' -e '^kern  :(err   |crit  |alert |emerg )'
    
    instead of doing text pattern matching
    
    `#{grep} -a -F -f /lkp/printk-error-messages #{kmsg_file} |
          grep -a -v -E -f #{LKP_SRC}/etc/oops-pattern |
          grep -a -v -F -f #{LKP_SRC}/etc/kmsg-blacklist`
    
    [1] https://github.com/fengguang/lkp-tests/blob/master/lib/dmesg.rb
    
    Link: http://lkml.kernel.org/r/20171221054149.4398-1-sergey.senozhatsky@gmail.com
    To: Steven Rostedt <rostedt@goodmis.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Fengguang Wu <fengguang.wu@intel.com>
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Tested-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5d81206a572d..568729e0dc2c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -277,6 +277,13 @@ EXPORT_SYMBOL(console_set_on_cmdline);
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
+enum con_msg_format_flags {
+	MSG_FORMAT_DEFAULT	= 0,
+	MSG_FORMAT_SYSLOG	= (1 << 0),
+};
+
+static int console_msg_format = MSG_FORMAT_DEFAULT;
+
 /*
  * The printk log buffer consists of a chain of concatenated variable
  * length records. Every record starts with a record header, containing
@@ -1913,6 +1920,17 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	c->index = idx;
 	return 0;
 }
+
+static int __init console_msg_format_setup(char *str)
+{
+	if (!strcmp(str, "syslog"))
+		console_msg_format = MSG_FORMAT_SYSLOG;
+	if (!strcmp(str, "default"))
+		console_msg_format = MSG_FORMAT_DEFAULT;
+	return 1;
+}
+__setup("console_msg_format=", console_msg_format_setup);
+
 /*
  * Set up a console.  Called via do_early_param() in init/main.c
  * for each "console=" parameter in the boot command line.
@@ -2215,7 +2233,10 @@ void console_unlock(void)
 			goto skip;
 		}
 
-		len += msg_print_text(msg, false, text + len, sizeof(text) - len);
+		len += msg_print_text(msg,
+				console_msg_format & MSG_FORMAT_SYSLOG,
+				text + len,
+				sizeof(text) - len);
 		if (nr_ext_console_drivers) {
 			ext_len = msg_print_ext_header(ext_text,
 						sizeof(ext_text),

commit b7ad7ef742a99c148631d38a98da72e7db8f6fd0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 5 08:23:20 2017 -0800

    remove task and stack pointer printout from oops dump
    
    Geert Uytterhoeven reported a NFS oops, and pointed out that some of the
    numbers were hashed and useless.
    
    We could just turn them from '%p' into '%px', but those numbers are
    really just legacy, and useless even when not hashed.
    
    So just remove them entirely.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5d81206a572d..b9006617710f 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3141,9 +3141,6 @@ void dump_stack_print_info(const char *log_lvl)
 void show_regs_print_info(const char *log_lvl)
 {
 	dump_stack_print_info(log_lvl);
-
-	printk("%stask: %p task.stack: %p\n",
-	       log_lvl, current, task_stack_page(current));
 }
 
 #endif

commit 9dd957485d7d896ec18d8e2f9dd410efe71eca34
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 00:42:43 2017 -0400

    ipc, kernel, mm: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5d81206a572d..8aa27be96012 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -920,10 +920,10 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 	return ret;
 }
 
-static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
+static __poll_t devkmsg_poll(struct file *file, poll_table *wait)
 {
 	struct devkmsg_user *user = file->private_data;
-	int ret = 0;
+	__poll_t ret = 0;
 
 	if (!user)
 		return POLLERR|POLLNVAL;

commit 9afe77ed849de6af8532b4c1b9310102eed9edf7
Author: Maxim Akristiniy <maksim.akristiniy@yotadevices.com>
Date:   Mon Oct 23 19:51:48 2017 +0300

    added new line symbol after warning about dropped messages
    
    so this message will not mess with the next one
    
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Maxim Akristiniy <maksim.akristiniy@yotadevices.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 512f7c2baedd..5d81206a572d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2190,7 +2190,7 @@ void console_unlock(void)
 		}
 
 		if (console_seq < log_first_seq) {
-			len = sprintf(text, "** %u printk messages dropped ** ",
+			len = sprintf(text, "** %u printk messages dropped **\n",
 				      (unsigned)(log_first_seq - console_seq));
 
 			/* messages are gone, move to first one */

commit cef5d0f952a03d42051141742632078d488b0c6b
Merge: 0fb02e718f5f 077a1cc06f72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 21:00:52 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Do not allow use of freed init data and code even when boot consoles
       are forced to stay. Also check for the init memory more precisely.
    
     - Some code clean up by starting contributors.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: Clean up do_syslog() error handling
      printk/console: Enhance the check for consoles using init memory
      printk/console: Always disable boot consoles that use init memory before it is freed
      printk: Modify operators of printed_len and text_len

commit c71b02e4d207cbcf097f9746d5f7967b22905e70
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Aug 9 21:11:00 2017 -0700

    Revert "pstore: Honor dmesg_restrict sysctl on dmesg dumps"
    
    This reverts commit 68c4a4f8abc60c9440ede9cd123d48b78325f7a3, with
    various conflict clean-ups.
    
    The capability check required too much privilege compared to simple DAC
    controls. A system builder was forced to have crash handler processes
    run with CAP_SYSLOG which would give it the ability to read (and wipe)
    the _current_ dmesg, which is much more access than being given access
    only to the historical log stored in pstorefs.
    
    With the prior commit to make the root directory 0750, the files are
    protected by default but a system builder can now opt to give access
    to a specific group (via chgrp on the pstorefs root directory) without
    being forced to also give away CAP_SYSLOG.
    
    Suggested-by: Nick Kralevich <nnk@google.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fc47863f629c..97bda7b0655b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -649,7 +649,7 @@ static int syslog_action_restricted(int type)
 	       type != SYSLOG_ACTION_SIZE_BUFFER;
 }
 
-int check_syslog_permissions(int type, int source)
+static int check_syslog_permissions(int type, int source)
 {
 	/*
 	 * If this is from /proc/kmsg and we've already opened it, then we've
@@ -677,7 +677,6 @@ int check_syslog_permissions(int type, int source)
 ok:
 	return security_syslog(type);
 }
-EXPORT_SYMBOL_GPL(check_syslog_permissions);
 
 static void append_char(char **pp, char *e, char c)
 {

commit 077a1cc06f72f95efd077d433993c16191008e47
Author: Nikitas Angelinas <nikitas.angelinas@gmail.com>
Date:   Sat Jul 29 20:36:36 2017 -0700

    printk: Clean up do_syslog() error handling
    
    The error variable in do_syslog() is preemptively set to the error code
    before the error condition is checked, and then set to 0 if the error
    condition is not encountered. This is not necessary, as it is likely
    simpler to return immediately upon encountering the error condition. A
    redundant set of the error variable to 0 is also removed.
    
    This patch has been build-tested on x86_64, but not tested for
    functionality.
    
    Link: http://lkml.kernel.org/r/20170730033636.GA935@vostro
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Nikitas Angelinas <nikitas.angelinas@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 87f1a8f4e0f9..cfd9ab1b80c5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1435,7 +1435,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 
 	error = check_syslog_permissions(type, source);
 	if (error)
-		goto out;
+		return error;
 
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
@@ -1443,20 +1443,16 @@ int do_syslog(int type, char __user *buf, int len, int source)
 	case SYSLOG_ACTION_OPEN:	/* Open log */
 		break;
 	case SYSLOG_ACTION_READ:	/* Read from log */
-		error = -EINVAL;
 		if (!buf || len < 0)
-			goto out;
-		error = 0;
+			return -EINVAL;
 		if (!len)
-			goto out;
-		if (!access_ok(VERIFY_WRITE, buf, len)) {
-			error = -EFAULT;
-			goto out;
-		}
+			return 0;
+		if (!access_ok(VERIFY_WRITE, buf, len))
+			return -EFAULT;
 		error = wait_event_interruptible(log_wait,
 						 syslog_seq != log_next_seq);
 		if (error)
-			goto out;
+			return error;
 		error = syslog_print(buf, len);
 		break;
 	/* Read/clear last kernel messages */
@@ -1465,16 +1461,12 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		/* FALL THRU */
 	/* Read last kernel messages */
 	case SYSLOG_ACTION_READ_ALL:
-		error = -EINVAL;
 		if (!buf || len < 0)
-			goto out;
-		error = 0;
+			return -EINVAL;
 		if (!len)
-			goto out;
-		if (!access_ok(VERIFY_WRITE, buf, len)) {
-			error = -EFAULT;
-			goto out;
-		}
+			return 0;
+		if (!access_ok(VERIFY_WRITE, buf, len))
+			return -EFAULT;
 		error = syslog_print_all(buf, len, clear);
 		break;
 	/* Clear ring buffer */
@@ -1496,15 +1488,13 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		break;
 	/* Set level of messages printed to console */
 	case SYSLOG_ACTION_CONSOLE_LEVEL:
-		error = -EINVAL;
 		if (len < 1 || len > 8)
-			goto out;
+			return -EINVAL;
 		if (len < minimum_console_loglevel)
 			len = minimum_console_loglevel;
 		console_loglevel = len;
 		/* Implicitly re-enable logging to console */
 		saved_console_loglevel = LOGLEVEL_DEFAULT;
-		error = 0;
 		break;
 	/* Number of chars in the log buffer */
 	case SYSLOG_ACTION_SIZE_UNREAD:
@@ -1526,7 +1516,6 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			u64 seq = syslog_seq;
 			u32 idx = syslog_idx;
 
-			error = 0;
 			while (seq < log_next_seq) {
 				struct printk_log *msg = log_from_idx(idx);
 
@@ -1546,7 +1535,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		error = -EINVAL;
 		break;
 	}
-out:
+
 	return error;
 }
 

commit 5a814231ae3d4f248a8ecb668a072a1da471c656
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri Jul 14 14:51:13 2017 +0200

    printk/console: Enhance the check for consoles using init memory
    
    printk_late_init() is responsible for disabling boot consoles that
    use init memory. It checks the address of struct console for this.
    
    But this is not enough. For example, there are several early
    consoles that have write() method in the init section and
    struct console in the normal section. They are not disabled
    and could cause fancy and hard to debug system states.
    
    It is even more complicated by the macros EARLYCON_DECLARE() and
    OF_EARLYCON_DECLARE() where various struct members are set at
    runtime by the provided setup() function.
    
    I have tried to reproduce this problem and forced the classic uart
    early console to stay using keep_bootcon parameter. In particular
    I used earlycon=uart,io,0x3f8 keep_bootcon console=ttyS0,115200.
    The system did not boot:
    
    [    1.570496] PM: Image not found (code -22)
    [    1.570496] PM: Image not found (code -22)
    [    1.571886] PM: Hibernation image not present or could not be loaded.
    [    1.571886] PM: Hibernation image not present or could not be loaded.
    [    1.576407] Freeing unused kernel memory: 2528K
    [    1.577244] kernel tried to execute NX-protected page - exploit attempt? (uid: 0)
    
    The double lines are caused by having both early uart console and
    ttyS0 console enabled at the same time. The early console stopped
    working when the init memory was freed. Fortunately, the invalid
    call was caught by the NX-protexted page check and did not cause
    any silent fancy problems.
    
    This patch adds a check for many other addresses stored in
    struct console. It omits setup() and match() that are used
    only when the console is registered. Therefore they have
    already been used at this point and there is no reason
    to use them again.
    
    Link: http://lkml.kernel.org/r/1500036673-7122-3-git-send-email-pmladek@suse.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: "Fabio M. Di Nitto" <fdinitto@redhat.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 76985ee3dfff..87f1a8f4e0f9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2659,8 +2659,16 @@ static int __init printk_late_init(void)
 	int ret;
 
 	for_each_console(con) {
-		if ((con->flags & CON_BOOT) &&
-		    init_section_intersects(con, sizeof(*con))) {
+		if (!(con->flags & CON_BOOT))
+			continue;
+
+		/* Check addresses that might be used for enabled consoles. */
+		if (init_section_intersects(con, sizeof(*con)) ||
+		    init_section_contains(con->write, 0) ||
+		    init_section_contains(con->read, 0) ||
+		    init_section_contains(con->device, 0) ||
+		    init_section_contains(con->unblank, 0) ||
+		    init_section_contains(con->data, 0)) {
 			/*
 			 * Please, consider moving the reported consoles out
 			 * of the init section.

commit 2b1be689f3aadcfe0a768314c80e43483c784659
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Fri Jul 14 14:51:12 2017 +0200

    printk/console: Always disable boot consoles that use init memory before it is freed
    
    Commit 4c30c6f566c0 ("kernel/printk: do not turn off bootconsole in
    printk_late_init() if keep_bootcon") added a check on keep_bootcon to
    ensure that boot consoles were kept around until the real console is
    registered.
    
    This can lead to problems if the boot console data and code are in the
    init section, since it can be freed before the boot console is
    unregistered.
    
    Commit 81cc26f2bd11 ("printk: only unregister boot consoles when
    necessary") fixed this a better way. It allowed to keep boot consoles
    that did not use init data. Unfortunately it did not remove the check
    of keep_bootcon.
    
    This can lead to crashes and weird panics when the bootconsole is
    accessed after free, especially if page poisoning is in use and the
    code / data have been overwritten with a poison value.
    
    To prevent this, always free the boot console if it is within the init
    section. In addition, print a warning about that the console is removed
    prematurely.
    
    Finally there is a new comment how to avoid the warning. It replaced
    an explanation that duplicated a more comprehensive function
    description few lines above.
    
    Fixes: 4c30c6f566c0 ("kernel/printk: do not turn off bootconsole in printk_late_init() if keep_bootcon")
    Link: http://lkml.kernel.org/r/1500036673-7122-2-git-send-email-pmladek@suse.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: "Fabio M. Di Nitto" <fdinitto@redhat.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    [pmladek@suse.com: print the warning, code and comments clean up]
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 229fbdcbe6ef..76985ee3dfff 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2650,9 +2650,8 @@ void __init console_init(void)
  * makes it difficult to diagnose problems that occur during this time.
  *
  * To mitigate this problem somewhat, only unregister consoles whose memory
- * intersects with the init section. Note that code exists elsewhere to get
- * rid of the boot console as soon as the proper console shows up, so there
- * won't be side-effects from postponing the removal.
+ * intersects with the init section. Note that all other boot consoles will
+ * get unregistred when the real preferred console is registered.
  */
 static int __init printk_late_init(void)
 {
@@ -2660,16 +2659,15 @@ static int __init printk_late_init(void)
 	int ret;
 
 	for_each_console(con) {
-		if (!keep_bootcon && con->flags & CON_BOOT) {
+		if ((con->flags & CON_BOOT) &&
+		    init_section_intersects(con, sizeof(*con))) {
 			/*
-			 * Make sure to unregister boot consoles whose data
-			 * resides in the init section before the init section
-			 * is discarded. Boot consoles whose data will stick
-			 * around will automatically be unregistered when the
-			 * proper console replaces them.
+			 * Please, consider moving the reported consoles out
+			 * of the init section.
 			 */
-			if (init_section_intersects(con, sizeof(*con)))
-				unregister_console(con);
+			pr_warn("bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\n",
+				con->name, con->index);
+			unregister_console(con);
 		}
 	}
 	ret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, "printk:dead", NULL,

commit aec47caa747e1e15a3363dc0b0db37e51b8d4f15
Author: Pierre Kuo <vichy.kuo@gmail.com>
Date:   Tue Jul 11 14:40:55 2017 +0800

    printk: Modify operators of printed_len and text_len
    
    With commit <ddb9baa82226> ("printk: report lost messages in printk
    safe/nmi contexts") and commit <8b1742c9c207> ("printk: remove zap_locks()
    function"), it seems we can remove initialization, "=0", of text_len and
    directly assign result of log_output to printed_len.
    
    Link: http://lkml.kernel.org/r/1499755255-6258-1-git-send-email-vichy.kuo@gmail.com
    Cc: rostedt@goodmis.org
    Cc: linux-kernel@vger.kernel.org
    Cc: joe@perches.com
    Signed-off-by: Pierre Kuo <vichy.kuo@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index fc47863f629c..229fbdcbe6ef 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1698,10 +1698,10 @@ asmlinkage int vprintk_emit(int facility, int level,
 {
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
-	size_t text_len = 0;
+	size_t text_len;
 	enum log_flags lflags = 0;
 	unsigned long flags;
-	int printed_len = 0;
+	int printed_len;
 	bool in_sched = false;
 
 	if (level == LOGLEVEL_SCHED) {
@@ -1754,7 +1754,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (dict)
 		lflags |= LOG_PREFIX|LOG_NEWLINE;
 
-	printed_len += log_output(facility, level, lflags, dict, dictlen, text, text_len);
+	printed_len = log_output(facility, level, lflags, dict, dictlen, text, text_len);
 
 	logbuf_unlock_irqrestore(flags);
 

commit eed1fc87795362fd868bdc960d7b96d25f81eae3
Merge: 19964541c231 a5707eef798b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 11:11:26 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Store printk() messages into the main log buffer directly even in NMI
       when the lock is available. It is the best effort to print even large
       chunk of text. It is handy, for example, when all ftrace messages are
       printed during the system panic in NMI.
    
     - Add missing annotations to calm down compiler warnings
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: add __printf attributes to internal functions
      printk: Use the main logbuf in NMI when logbuf_lock is available

commit a5707eef798b57ff5a2e56fca435dff616019b7e
Merge: dc0cf5a77db9 f4e981cba2de
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Jul 3 15:33:39 2017 +0200

    Merge branch 'for-4.13' into for-linus

commit 902b31941327a0e9c0ca9eb7750414ae41bf8a89
Merge: c5ae366e12b2 2055da97389a
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:28:21 2017 +0200

    Merge branch 'WIP.sched/core' into sched/core
    
     Conflicts:
            kernel/sched/Makefile
    
    Pick up the waitqueue related renames - it didn't get much feedback,
    so it appears to be uncontroversial. Famous last words? ;-)
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit dc0cf5a77db9d200284f54a60994c1f6d2fbfc5f
Merge: d0aab7d4e93e dac8bbbae1d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 8 10:50:04 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk fix from Petr Mladek:
     "This reverts a fix added into 4.12-rc1. It caused the kernel log to be
      printed on another console when two consoles of the same type were
      defined, e.g. console=ttyS0 console=ttyS1.
    
      This configuration was never supported by kernel itself, but it
      started to make sense with systemd. In other words, the commit broke
      userspace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      Revert "printk: fix double printing with earlycon"

commit dac8bbbae1d0ccba96402d25deeed3a2e87992c6
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 8 12:01:30 2017 +0200

    Revert "printk: fix double printing with earlycon"
    
    This reverts commit cf39bf58afdaabc0b86f141630fb3fd18190294e.
    
    The commit regression to users that define both console=ttyS1
    and console=ttyS0 on the command line, see
    https://lkml.kernel.org/r/20170509082915.GA13236@bistromath.localdomain
    
    The kernel log messages always appeared only on one serial port. It is
    even documented in Documentation/admin-guide/serial-console.rst:
    
    "Note that you can only define one console per device type (serial,
    video)."
    
    The above mentioned commit changed the order in which the command line
    parameters are searched. As a result, the kernel log messages go to
    the last mentioned ttyS* instead of the first one.
    
    We long thought that using two console=ttyS* on the command line
    did not make sense. But then we realized that console= parameters
    were handled also by systemd, see
    http://0pointer.de/blog/projects/serial-console.html
    
    "By default systemd will instantiate one serial-getty@.service on
    the main kernel console, if it is not a virtual terminal."
    
    where
    
    "[4] If multiple kernel consoles are used simultaneously, the main
    console is the one listed first in /sys/class/tty/console/active,
    which is the last one listed on the kernel command line."
    
    This puts the original report into another light. The system is running
    in qemu. The first serial port is used to store the messages into a file.
    The second one is used to login to the system via a socket. It depends
    on systemd and the historic kernel behavior.
    
    By other words, systemd causes that it makes sense to define both
    console=ttyS1 console=ttyS0 on the command line. The kernel fix
    caused regression related to userspace (systemd) and need to be
    reverted.
    
    In addition, it went out that the fix helped only partially.
    The messages still were duplicated when the boot console was
    removed early by late_initcall(printk_late_init). Then the entire
    log was replayed when the same console was registered as a normal one.
    
    Link: 20170606160339.GC7604@pathway.suse.cz
    Cc: Aleksey Makarov <aleksey.makarov@linaro.org>
    Cc: Sabrina Dubroca <sd@queasysnail.net>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Robin Murphy <robin.murphy@arm.com>,
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: "Nair, Jayachandran" <Jayachandran.Nair@cavium.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reported-by: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 779479ac9f57..9dbceb76e6bc 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -269,7 +269,6 @@ static struct console *exclusive_console;
 #define MAX_CMDLINECONSOLES 8
 
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
-static int console_cmdline_cnt;
 
 static int preferred_console = -1;
 int console_set_on_cmdline;
@@ -1906,25 +1905,12 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	 *	See if this tty is not yet registered, and
 	 *	if we have a slot free.
 	 */
-	for (i = 0, c = console_cmdline; i < console_cmdline_cnt; i++, c++) {
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++) {
 		if (strcmp(c->name, name) == 0 && c->index == idx) {
-			if (brl_options)
-				return 0;
-
-			/*
-			 * Maintain an invariant that will help to find if
-			 * the matching console is preferred, see
-			 * register_console():
-			 *
-			 * The last non-braille console is always
-			 * the preferred one.
-			 */
-			if (i != console_cmdline_cnt - 1)
-				swap(console_cmdline[i],
-				     console_cmdline[console_cmdline_cnt - 1]);
-
-			preferred_console = console_cmdline_cnt - 1;
-
+			if (!brl_options)
+				preferred_console = i;
 			return 0;
 		}
 	}
@@ -1937,7 +1923,6 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	braille_set_options(c, brl_options);
 
 	c->index = idx;
-	console_cmdline_cnt++;
 	return 0;
 }
 /*
@@ -2477,23 +2462,12 @@ void register_console(struct console *newcon)
 	}
 
 	/*
-	 * See if this console matches one we selected on the command line.
-	 *
-	 * There may be several entries in the console_cmdline array matching
-	 * with the same console, one with newcon->match(), another by
-	 * name/index:
-	 *
-	 *	pl011,mmio,0x87e024000000,115200 -- added from SPCR
-	 *	ttyAMA0 -- added from command line
-	 *
-	 * Traverse the console_cmdline array in reverse order to be
-	 * sure that if this console is preferred then it will be the first
-	 * matching entry.  We use the invariant that is maintained in
-	 * __add_preferred_console().
+	 *	See if this console matches one we selected on
+	 *	the command line.
 	 */
-	for (i = console_cmdline_cnt - 1; i >= 0; i--) {
-		c = console_cmdline + i;
-
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++) {
 		if (!newcon->match ||
 		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
 			/* default matching */

commit ff48cd26fc4889b9deb5f9333d3c61746e450b7f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 16 20:42:45 2017 +0200

    printk: Adjust system_state checks
    
    To enable smp_processor_id() and might_sleep() debug checks earlier, it's
    required to add system states between SYSTEM_BOOTING and SYSTEM_RUNNING.
    
    Adjust the system_state check in boot_delay_msec() to handle the extra
    states.
    
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170516184736.027534895@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a1aecf44ab07..32fac391ac2a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1176,7 +1176,7 @@ static void boot_delay_msec(int level)
 	unsigned long long k;
 	unsigned long timeout;
 
-	if ((boot_delay == 0 || system_state != SYSTEM_BOOTING)
+	if ((boot_delay == 0 || system_state >= SYSTEM_RUNNING)
 		|| suppress_message_printing(level)) {
 		return;
 	}

commit 719f6a7040f1bdaf96fcc709d272548facb88e90
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Apr 20 10:52:31 2017 +0200

    printk: Use the main logbuf in NMI when logbuf_lock is available
    
    The commit 42a0bb3f71383b457a7d ("printk/nmi: generic solution for safe
    printk in NMI") caused that printk stores messages into a temporary
    buffer in NMI context.
    
    The buffer is per-CPU and therefore the size is rather limited.
    It works quite well for NMI backtraces. But there are longer logs
    that might get printed in NMI context, for example, lockdep
    warnings, ftrace_dump_on_oops.
    
    The temporary buffer is used to avoid deadlocks caused by
    logbuf_lock. Also it is needed to avoid races with the other
    temporary buffer that is used when PRINTK_SAFE_CONTEXT is entered.
    But the main buffer can be used in NMI if the lock is available
    and we did not interrupt PRINTK_SAFE_CONTEXT.
    
    The lock is checked using raw_spin_is_locked(). It might cause
    false negatives when the lock is taken on another CPU and
    this CPU is in the safe context from other reasons. Note that
    the safe context is used also to get console semaphore or when
    calling console drivers. For this reason, we do the check in
    printk_nmi_enter(). It makes the handling consistent for
    the entire NMI handler and avoids reshuffling of the messages.
    
    The patch also defines special printk context that allows
    to use printk_deferred() in NMI. Note that we could not flush
    the messages to the consoles because console drivers might use
    many other internal locks.
    
    The newly created vprintk_deferred() disables the preemption
    only around the irq work handling. It is needed there to keep
    the consistency between the two per-CPU variables. But there
    is no reason to disable preemption around vprintk_emit().
    
    Finally, the patch puts back explicit serialization of the NMI
    backtraces from different CPUs. It was removed by the
    commit a9edc88093287183ac934b ("x86/nmi: Perform a safe
    NMI stack trace on all CPUs"). It was not needed because
    the flushing of the temporary per-CPU buffers was serialized.
    
    Link: http://lkml.kernel.org/r/1493912763-24873-1-git-send-email-pmladek@suse.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <rack+kernel@arm.linux.org.uk>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: x86@kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Suggested-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 779479ac9f57..e5278e7d1922 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2722,16 +2722,13 @@ void wake_up_klogd(void)
 	preempt_enable();
 }
 
-int printk_deferred(const char *fmt, ...)
+int vprintk_deferred(const char *fmt, va_list args)
 {
-	va_list args;
 	int r;
 
-	preempt_disable();
-	va_start(args, fmt);
 	r = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);
-	va_end(args);
 
+	preempt_disable();
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
 	irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));
 	preempt_enable();
@@ -2739,6 +2736,18 @@ int printk_deferred(const char *fmt, ...)
 	return r;
 }
 
+int printk_deferred(const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+	va_start(args, fmt);
+	r = vprintk_deferred(fmt, args);
+	va_end(args);
+
+	return r;
+}
+
 /*
  * printk rate limiting, lifted from the networking subsystem.
  *

commit 8f3207c7eab9d885cc64c778416537034a7d9c5b
Merge: bf5f89463f5b 8e1c21f48694
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 8 18:49:23 2017 -0700

    Merge tag 'tty-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the "big" TTY/Serial patch updates for 4.12-rc1
    
      Not a lot of new things here, the normal number of serial driver
      updates and additions, tiny bugs fixed, and some core files split up
      to make future changes a bit easier for Nicolas's "tiny-tty" work.
    
      All of these have been in linux-next for a while"
    
    * tag 'tty-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (62 commits)
      serial: small Makefile reordering
      tty: split job control support into a file of its own
      tty: move baudrate handling code to a file of its own
      console: move console_init() out of tty_io.c
      serial: 8250_early: Add earlycon support for Palmchip UART
      tty: pl011: use "qdf2400_e44" as the earlycon name for QDF2400 E44
      vt: make mouse selection of non-ASCII consistent
      vt: set mouse selection word-chars to gpm's default
      imx-serial: Reduce RX DMA startup latency when opening for reading
      serial: omap: suspend device on probe errors
      serial: omap: fix runtime-pm handling on unbind
      tty: serial: omap: add UPF_BOOT_AUTOCONF flag for DT init
      serial: samsung: Remove useless spinlock
      serial: samsung: Add missing checks for dma_map_single failure
      serial: samsung: Use right device for DMA-mapping calls
      serial: imx: setup DCEDTE early and ensure DCD and RI irqs to be off
      tty: fix comment typo s/repsonsible/responsible/
      tty: amba-pl011: Fix spurious TX interrupts
      serial: xuartps: Enable clocks in the pm disable case also
      serial: core: Re-use struct uart_port {name} field
      ...

commit 692f66f26a4c19d73249736aa973c13a1521b387
Author: Hari Bathini <hbathini@linux.vnet.ibm.com>
Date:   Mon May 8 15:56:18 2017 -0700

    crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE
    
    Patch series "kexec/fadump: remove dependency with CONFIG_KEXEC and
    reuse crashkernel parameter for fadump", v4.
    
    Traditionally, kdump is used to save vmcore in case of a crash.  Some
    architectures like powerpc can save vmcore using architecture specific
    support instead of kexec/kdump mechanism.  Such architecture specific
    support also needs to reserve memory, to be used by dump capture kernel.
    crashkernel parameter can be a reused, for memory reservation, by such
    architecture specific infrastructure.
    
    This patchset removes dependency with CONFIG_KEXEC for crashkernel
    parameter and vmcoreinfo related code as it can be reused without kexec
    support.  Also, crashkernel parameter is reused instead of
    fadump_reserve_mem to reserve memory for fadump.
    
    The first patch moves crashkernel parameter parsing and vmcoreinfo
    related code under CONFIG_CRASH_CORE instead of CONFIG_KEXEC_CORE.  The
    second patch reuses the definitions of append_elf_note() & final_note()
    functions under CONFIG_CRASH_CORE in IA64 arch code.  The third patch
    removes dependency on CONFIG_KEXEC for firmware-assisted dump (fadump)
    in powerpc.  The next patch reuses crashkernel parameter for reserving
    memory for fadump, instead of the fadump_reserve_mem parameter.  This
    has the advantage of using all syntaxes crashkernel parameter supports,
    for fadump as well.  The last patch updates fadump kernel documentation
    about use of crashkernel parameter.
    
    This patch (of 5):
    
    Traditionally, kdump is used to save vmcore in case of a crash.  Some
    architectures like powerpc can save vmcore using architecture specific
    support instead of kexec/kdump mechanism.  Such architecture specific
    support also needs to reserve memory, to be used by dump capture kernel.
    crashkernel parameter can be a reused, for memory reservation, by such
    architecture specific infrastructure.
    
    But currently, code related to vmcoreinfo and parsing of crashkernel
    parameter is built under CONFIG_KEXEC_CORE.  This patch introduces
    CONFIG_CRASH_CORE and moves the above mentioned code under this config,
    allowing code reuse without dependency on CONFIG_KEXEC.  There is no
    functional change with this patch.
    
    Link: http://lkml.kernel.org/r/149035338104.6881.4550894432615189948.stgit@hbathini.in.ibm.com
    Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
    Acked-by: Dave Young <dyoung@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 779479ac9f57..fb2d1591f671 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -32,7 +32,7 @@
 #include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/syscalls.h>
-#include <linux/kexec.h>
+#include <linux/crash_core.h>
 #include <linux/kdb.h>
 #include <linux/ratelimit.h>
 #include <linux/kmsg_dump.h>
@@ -1002,7 +1002,7 @@ const struct file_operations kmsg_fops = {
 	.release = devkmsg_release,
 };
 
-#ifdef CONFIG_KEXEC_CORE
+#ifdef CONFIG_CRASH_CORE
 /*
  * This appends the listed symbols to /proc/vmcore
  *
@@ -1011,7 +1011,7 @@ const struct file_operations kmsg_fops = {
  * symbols are specifically used so that utilities can access and extract the
  * dmesg log from a vmcore file after a crash.
  */
-void log_buf_kexec_setup(void)
+void log_buf_vmcoreinfo_setup(void)
 {
 	VMCOREINFO_SYMBOL(log_buf);
 	VMCOREINFO_SYMBOL(log_buf_len);

commit 9c35baf6cee9a5745d55de6f9995916dde642517
Merge: dd23f273d9a7 cf39bf58afda
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 3 18:29:28 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - There is a situation when early console is not deregistered because
       the preferred one matches a wrong entry. It caused messages to appear
       twice.
    
       This is the 2nd attempt to fix it. The first one was wrong, see the
       commit c6c7d83b9c9e ('Revert "console: don't prefer first registered
       if DT specifies stdout-path"').
    
       The fix is coupled with some small code clean up. Well, the console
       registration code would deserve a big one. We need to think about it.
    
     - Do not lose information about the preemtive context when the console
       semaphore is re-taken.
    
     - Do not block CPU hotplug when someone else is already pushing
       messages to the console.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: fix double printing with earlycon
      printk: rename selected_console -> preferred_console
      printk: fix name/type/scope of preferred_console var
      printk: Correctly handle preemption in console_unlock()
      printk: use console_trylock() in console_cpu_notify()

commit 0c688614dcce84dfdbb305fd1c399c06cecea745
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Apr 12 18:37:14 2017 -0400

    console: move console_init() out of tty_io.c
    
    All the console driver handling code lives in printk.c.
    Move console_init() there as well so console support can still be used
    when the TTY code is configured out. No logical changes from this patch.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 2984fb0f0257..3a0940652660 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2610,6 +2610,30 @@ int unregister_console(struct console *console)
 }
 EXPORT_SYMBOL(unregister_console);
 
+/*
+ * Initialize the console device. This is called *early*, so
+ * we can't necessarily depend on lots of kernel help here.
+ * Just do some early initializations, and do the complex setup
+ * later.
+ */
+void __init console_init(void)
+{
+	initcall_t *call;
+
+	/* Setup the default TTY line discipline. */
+	n_tty_init();
+
+	/*
+	 * set up the console device so that later boot sequences can
+	 * inform about problems etc..
+	 */
+	call = __con_initcall_start;
+	while (call < __con_initcall_end) {
+		(*call)();
+		call++;
+	}
+}
+
 /*
  * Some boot consoles access data that is in the init section and which will
  * be discarded after the initcalls have been run. To make sure that no code

commit cf39bf58afdaabc0b86f141630fb3fd18190294e
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Wed Apr 5 23:20:00 2017 +0300

    printk: fix double printing with earlycon
    
    If a console was specified by ACPI SPCR table _and_ command line
    parameters like "console=ttyAMA0" _and_ "earlycon" were specified,
    then log messages appear twice.
    
    The root cause is that the code traverses the list of specified
    consoles (the `console_cmdline` array) and stops at the first match.
    But it may happen that the same console is referred by the elements
    of this array twice:
    
            pl011,mmio,0x87e024000000,115200 -- from SPCR
            ttyAMA0 -- from command line
    
    but in this case `preferred_console` points to the second entry and
    the flag CON_CONSDEV is not set, so bootconsole is not deregistered.
    
    To fix that, introduce an invariant "The last non-braille console
    is always the preferred one" on the entries of the console_cmdline
    array.  Then traverse it in reverse order to be sure that if
    the console is preferred then it will be the first matching entry.
    Introduce variable console_cmdline_cnt that keeps the number
    of elements of the console_cmdline array (Petr Mladek).  It helps
    to get rid of the loop that searches for the end of this array.
    
    Link: http://lkml.kernel.org/r/20170405202006.18234-1-aleksey.makarov@linaro.org
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: "Nair, Jayachandran" <Jayachandran.Nair@cavium.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Reported-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 82927ca04849..06051926dfde 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -266,6 +266,7 @@ static struct console *exclusive_console;
 #define MAX_CMDLINECONSOLES 8
 
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
+static int console_cmdline_cnt;
 
 static int preferred_console = -1;
 int console_set_on_cmdline;
@@ -1902,12 +1903,25 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	 *	See if this tty is not yet registered, and
 	 *	if we have a slot free.
 	 */
-	for (i = 0, c = console_cmdline;
-	     i < MAX_CMDLINECONSOLES && c->name[0];
-	     i++, c++) {
+	for (i = 0, c = console_cmdline; i < console_cmdline_cnt; i++, c++) {
 		if (strcmp(c->name, name) == 0 && c->index == idx) {
-			if (!brl_options)
-				preferred_console = i;
+			if (brl_options)
+				return 0;
+
+			/*
+			 * Maintain an invariant that will help to find if
+			 * the matching console is preferred, see
+			 * register_console():
+			 *
+			 * The last non-braille console is always
+			 * the preferred one.
+			 */
+			if (i != console_cmdline_cnt - 1)
+				swap(console_cmdline[i],
+				     console_cmdline[console_cmdline_cnt - 1]);
+
+			preferred_console = console_cmdline_cnt - 1;
+
 			return 0;
 		}
 	}
@@ -1920,6 +1934,7 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	braille_set_options(c, brl_options);
 
 	c->index = idx;
+	console_cmdline_cnt++;
 	return 0;
 }
 /*
@@ -2459,12 +2474,23 @@ void register_console(struct console *newcon)
 	}
 
 	/*
-	 *	See if this console matches one we selected on
-	 *	the command line.
+	 * See if this console matches one we selected on the command line.
+	 *
+	 * There may be several entries in the console_cmdline array matching
+	 * with the same console, one with newcon->match(), another by
+	 * name/index:
+	 *
+	 *	pl011,mmio,0x87e024000000,115200 -- added from SPCR
+	 *	ttyAMA0 -- added from command line
+	 *
+	 * Traverse the console_cmdline array in reverse order to be
+	 * sure that if this console is preferred then it will be the first
+	 * matching entry.  We use the invariant that is maintained in
+	 * __add_preferred_console().
 	 */
-	for (i = 0, c = console_cmdline;
-	     i < MAX_CMDLINECONSOLES && c->name[0];
-	     i++, c++) {
+	for (i = console_cmdline_cnt - 1; i >= 0; i--) {
+		c = console_cmdline + i;
+
 		if (!newcon->match ||
 		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
 			/* default matching */

commit ad86ee2b8a47590f62a4f3bc1d25dc126d121cb9
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Wed Mar 15 13:28:51 2017 +0300

    printk: rename selected_console -> preferred_console
    
    The variable selected_console is set in __add_preferred_console()
    to point to the last console parameter that was added to the
    console_cmdline array.
    
    Rename it to preferred_console so that the name reflects the usage.
    
    Petr Mladek:
    "[..] the selected_console/preferred_console
    value is used to keep the console first in the console_drivers list.
    IMHO, the main effect is that each line will first appear on this
    console, see call_console_drivers(). But the message will still
    appear also on all other enabled consoles. From this point,
    the name "preferred" sounds better to me. More consoles
    are selected (enabled) and only one is preferred (first)."
    
    Link: http://lkml.kernel.org/r/20170315102854.1763-3-aleksey.makarov@linaro.org
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: "Nair, Jayachandran" <Jayachandran.Nair@cavium.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Suggested-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1afc2d69b21f..82927ca04849 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -267,7 +267,7 @@ static struct console *exclusive_console;
 
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
 
-static int selected_console = -1;
+static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
@@ -1907,14 +1907,14 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	     i++, c++) {
 		if (strcmp(c->name, name) == 0 && c->index == idx) {
 			if (!brl_options)
-				selected_console = i;
+				preferred_console = i;
 			return 0;
 		}
 	}
 	if (i == MAX_CMDLINECONSOLES)
 		return -E2BIG;
 	if (!brl_options)
-		selected_console = i;
+		preferred_console = i;
 	strlcpy(c->name, name, sizeof(c->name));
 	c->options = options;
 	braille_set_options(c, brl_options);
@@ -2438,7 +2438,7 @@ void register_console(struct console *newcon)
 		bcon = console_drivers;
 
 	if (!has_preferred || bcon || !console_drivers)
-		has_preferred = selected_console >= 0;
+		has_preferred = preferred_console >= 0;
 
 	/*
 	 *	See if we want to use this console driver. If we
@@ -2486,7 +2486,7 @@ void register_console(struct console *newcon)
 		}
 
 		newcon->flags |= CON_ENABLED;
-		if (i == selected_console) {
+		if (i == preferred_console) {
 			newcon->flags |= CON_CONSDEV;
 			has_preferred = true;
 		}

commit b077bafa2f3848ddfcef2ef3a4a61a867f9113b5
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Wed Mar 15 13:28:50 2017 +0300

    printk: fix name/type/scope of preferred_console var
    
    The variable preferred_console is used only inside register_console()
    and its semantics is boolean.  It is negative when no console has been
    made preferred.
    
    Make it static bool and rename to has_preferred.
    
    Renaming was suggested by Peter Hurley
    
    Link: http://lkml.kernel.org/r/20170315102854.1763-2-aleksey.makarov@linaro.org
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: "Nair, Jayachandran" <Jayachandran.Nair@cavium.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1252068300e5..1afc2d69b21f 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -268,7 +268,6 @@ static struct console *exclusive_console;
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
 
 static int selected_console = -1;
-static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
@@ -2411,6 +2410,7 @@ void register_console(struct console *newcon)
 	unsigned long flags;
 	struct console *bcon = NULL;
 	struct console_cmdline *c;
+	static bool has_preferred;
 
 	if (console_drivers)
 		for_each_console(bcon)
@@ -2437,15 +2437,15 @@ void register_console(struct console *newcon)
 	if (console_drivers && console_drivers->flags & CON_BOOT)
 		bcon = console_drivers;
 
-	if (preferred_console < 0 || bcon || !console_drivers)
-		preferred_console = selected_console;
+	if (!has_preferred || bcon || !console_drivers)
+		has_preferred = selected_console >= 0;
 
 	/*
 	 *	See if we want to use this console driver. If we
 	 *	didn't select a console we take the first one
 	 *	that registers here.
 	 */
-	if (preferred_console < 0) {
+	if (!has_preferred) {
 		if (newcon->index < 0)
 			newcon->index = 0;
 		if (newcon->setup == NULL ||
@@ -2453,7 +2453,7 @@ void register_console(struct console *newcon)
 			newcon->flags |= CON_ENABLED;
 			if (newcon->device) {
 				newcon->flags |= CON_CONSDEV;
-				preferred_console = 0;
+				has_preferred = true;
 			}
 		}
 	}
@@ -2488,7 +2488,7 @@ void register_console(struct console *newcon)
 		newcon->flags |= CON_ENABLED;
 		if (i == selected_console) {
 			newcon->flags |= CON_CONSDEV;
-			preferred_console = selected_console;
+			has_preferred = true;
 		}
 		break;
 	}

commit 257ab443118bffc7fdcef38f49cf59be68a3e362
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri Mar 24 17:14:05 2017 +0100

    printk: Correctly handle preemption in console_unlock()
    
    Some console drivers code calls console_conditional_schedule()
    that looks at @console_may_schedule. The value must be cleared
    when the drivers are called from console_unlock() with
    interrupts disabled. But rescheduling is fine when the same
    code is called, for example, from tty operations where the
    console semaphore is taken via console_lock().
    
    This is why @console_may_schedule is cleared before calling console
    drivers. The original value is stored to decide if we could sleep
    between lines.
    
    Now, @console_may_schedule is not cleared when we call
    console_trylock() and jump back to the "again" goto label.
    This has become a problem, since the commit 6b97a20d3a7909daa066
    ("printk: set may_schedule for some of console_trylock() callers").
    @console_may_schedule might get enabled now.
    
    There is also the opposite problem. console_lock() can be called
    only from preemptive context. It can always enable scheduling in
    the console code. But console_trylock() is not able to detect it
    when CONFIG_PREEMPT_COUNT is disabled. Therefore we should use the
    original @console_may_schedule value after re-acquiring
    the console semaphore in console_unlock().
    
    This patch solves both problems by moving the "again" goto label.
    
    Alternative solution was to clear and restore the value around
    call_console_drivers(). Then console_conditional_schedule() could
    be used also inside console_unlock(). But there was a potential race
    with console_flush_on_panic() as reported by Sergey Senozhatsky.
    That function should be called only where there is only one CPU
    and with interrupts disabled. But better be on the safe side
    because stopping CPUs might fail.
    
    Fixes: 6b97a20d3a7909 ("printk: set may_schedule for some of console_trylock() callers")
    Link: http://lkml.kernel.org/r/1490372045-22288-1-git-send-email-pmladek@suse.com
    Suggested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-fbdev@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 94e2b104cdaa..1252068300e5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2159,7 +2159,7 @@ void console_unlock(void)
 	}
 
 	/*
-	 * Console drivers are called under logbuf_lock, so
+	 * Console drivers are called with interrupts disabled, so
 	 * @console_may_schedule should be cleared before; however, we may
 	 * end up dumping a lot of lines, for example, if called from
 	 * console registration path, and should invoke cond_resched()
@@ -2167,11 +2167,15 @@ void console_unlock(void)
 	 * scheduling stall on a slow console leading to RCU stall and
 	 * softlockup warnings which exacerbate the issue with more
 	 * messages practically incapacitating the system.
+	 *
+	 * console_trylock() is not able to detect the preemptive
+	 * context reliably. Therefore the value must be stored before
+	 * and cleared after the the "again" goto label.
 	 */
 	do_cond_resched = console_may_schedule;
+again:
 	console_may_schedule = 0;
 
-again:
 	/*
 	 * We released the console_sem lock, so we need to recheck if
 	 * cpu is online and (if not) is there at least one CON_ANYTIME

commit 64ca752dcbc018054bfea53b784d4c85d3ec896c
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Sat Jan 21 19:47:29 2017 +0900

    printk: use console_trylock() in console_cpu_notify()
    
    There is no need to always call blocking console_lock() in
    console_cpu_notify(), it's quite possible that console_sem can
    be locked by other CPU on the system, either already printing
    or soon to begin printing the messages. console_lock() in this
    case can simply block CPU hotplug for unknown period of time
    (console_unlock() is time unbound). Not that hotplug is very
    fast, but still, with other CPUs being online and doing
    printk() console_cpu_notify() can stuck.
    
    Use console_trylock() instead and opt-out if console_sem is
    already acquired from another CPU, since that CPU will do
    the printing for us.
    
    Link: http://lkml.kernel.org/r/20170121104729.8585-1-sergey.senozhatsky@gmail.com
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 34da86e73d00..94e2b104cdaa 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2028,15 +2028,16 @@ void resume_console(void)
  * @cpu: unused
  *
  * If printk() is called from a CPU that is not online yet, the messages
- * will be spooled but will not show up on the console.  This function is
- * called when a new CPU comes online (or fails to come up), and ensures
- * that any such output gets printed.
+ * will be printed on the console only if there are CON_ANYTIME consoles.
+ * This function is called when a new CPU comes online (or fails to come
+ * up) or goes offline.
  */
 static int console_cpu_notify(unsigned int cpu)
 {
 	if (!cpuhp_tasks_frozen) {
-		console_lock();
-		console_unlock();
+		/* If trylock fails, someone else is doing the printing */
+		if (console_trylock())
+			console_unlock();
 	}
 	return 0;
 }

commit 68db0cf10678630d286f4bbbbdfa102951a35faa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:37 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task_stack.h>
    
    We are going to split <linux/sched/task_stack.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task_stack.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 3caaaa04b92e..2984fb0f0257 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -47,6 +47,7 @@
 #include <linux/uio.h>
 #include <linux/sched/clock.h>
 #include <linux/sched/debug.h>
+#include <linux/sched/task_stack.h>
 
 #include <linux/uaccess.h>
 #include <asm/sections.h>

commit b17b01533b719e9949e437abf66436a875739b40
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:35 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/debug.h>
    
    We are going to split <linux/sched/debug.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/debug.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 47050eedc206..3caaaa04b92e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -46,6 +46,7 @@
 #include <linux/ctype.h>
 #include <linux/uio.h>
 #include <linux/sched/clock.h>
+#include <linux/sched/debug.h>
 
 #include <linux/uaccess.h>
 #include <asm/sections.h>

commit e601757102cfd3eeae068f53b3bc1234f3a2b2e9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 1 16:36:40 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/clock.h>
    
    We are going to split <linux/sched/clock.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and .c files.
    
    Create a trivial placeholder <linux/sched/clock.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 34da86e73d00..47050eedc206 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -45,6 +45,7 @@
 #include <linux/utsname.h>
 #include <linux/ctype.h>
 #include <linux/uio.h>
+#include <linux/sched/clock.h>
 
 #include <linux/uaccess.h>
 #include <asm/sections.h>

commit 7d91de74436a69c2b78a7a72f1e7f97f8b4396fa
Merge: 6ef192f2259e d9c23523ed98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 17:33:34 2017 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Add Petr Mladek, Sergey Senozhatsky as printk maintainers, and Steven
       Rostedt as the printk reviewer. This idea came up after the
       discussion about printk issues at Kernel Summit. It was formulated
       and discussed at lkml[1].
    
     - Extend a lock-less NMI per-cpu buffers idea to handle recursive
       printk() calls by Sergey Senozhatsky[2]. It is the first step in
       sanitizing printk as discussed at Kernel Summit.
    
       The change allows to see messages that would normally get ignored or
       would cause a deadlock.
    
       Also it allows to enable lockdep in printk(). This already paid off.
       The testing in linux-next helped to discover two old problems that
       were hidden before[3][4].
    
     - Remove unused parameter by Sergey Senozhatsky. Clean up after a past
       change.
    
    [1] http://lkml.kernel.org/r/1481798878-31898-1-git-send-email-pmladek@suse.com
    [2] http://lkml.kernel.org/r/20161227141611.940-1-sergey.senozhatsky@gmail.com
    [3] http://lkml.kernel.org/r/20170215044332.30449-1-sergey.senozhatsky@gmail.com
    [4] http://lkml.kernel.org/r/20170217015932.11898-1-sergey.senozhatsky@gmail.com
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      printk: drop call_console_drivers() unused param
      printk: convert the rest to printk-safe
      printk: remove zap_locks() function
      printk: use printk_safe buffers in printk
      printk: report lost messages in printk safe/nmi contexts
      printk: always use deferred printk when flush printk_safe lines
      printk: introduce per-cpu safe_print seq buffer
      printk: rename nmi.c and exported api
      printk: use vprintk_func in vprintk()
      MAINTAINERS: Add printk maintainers

commit fc98c3c8c9dcafd67adcce69e6ce3191d5306c9c
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Sat Feb 18 03:42:54 2017 -0800

    printk: use rcuidle console tracepoint
    
    Use rcuidle console tracepoint because, apparently, it may be issued
    from an idle CPU:
    
      hw-breakpoint: Failed to enable monitor mode on CPU 0.
      hw-breakpoint: CPU 0 failed to disable vector catch
    
      ===============================
      [ ERR: suspicious RCU usage.  ]
      4.10.0-rc8-next-20170215+ #119 Not tainted
      -------------------------------
      ./include/trace/events/printk.h:32 suspicious rcu_dereference_check() usage!
    
      other info that might help us debug this:
    
      RCU used illegally from idle CPU!
      rcu_scheduler_active = 2, debug_locks = 0
      RCU used illegally from extended quiescent state!
      2 locks held by swapper/0/0:
       #0:  (cpu_pm_notifier_lock){......}, at: [<c0237e2c>] cpu_pm_exit+0x10/0x54
       #1:  (console_lock){+.+.+.}, at: [<c01ab350>] vprintk_emit+0x264/0x474
    
      stack backtrace:
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.10.0-rc8-next-20170215+ #119
      Hardware name: Generic OMAP4 (Flattened Device Tree)
        console_unlock
        vprintk_emit
        vprintk_default
        printk
        reset_ctrl_regs
        dbg_cpu_pm_notify
        notifier_call_chain
        cpu_pm_exit
        omap_enter_idle_coupled
        cpuidle_enter_state
        cpuidle_enter_state_coupled
        do_idle
        cpu_startup_entry
        start_kernel
    
    This RCU warning, however, is suppressed by lockdep_off() in printk().
    lockdep_off() increments the ->lockdep_recursion counter and thus
    disables RCU_LOCKDEP_WARN() and debug_lockdep_rcu_enabled(), which want
    lockdep to be enabled "current->lockdep_recursion == 0".
    
    Link: http://lkml.kernel.org/r/20170217015932.11898-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reported-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Russell King <rmk@armlinux.org.uk>
    Cc: <stable@vger.kernel.org> [3.4+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8b2696420abb..4ba3d34938c0 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1516,7 +1516,7 @@ static void call_console_drivers(int level,
 {
 	struct console *con;
 
-	trace_console(text, len);
+	trace_console_rcuidle(text, len);
 
 	if (!console_drivers)
 		return;

commit d9c23523ed98a3acaa0bfd8fef143595d6aa631d
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Sat Dec 24 23:09:01 2016 +0900

    printk: drop call_console_drivers() unused param
    
    We do suppress_message_printing() check before we call
    call_console_drivers() now, so `level' param is not needed
    anymore.
    
    Link: http://lkml.kernel.org/r/20161224140902.1962-2-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 080843148e8d..7180088cbb23 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1558,8 +1558,7 @@ SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)
  * log_buf[start] to log_buf[end - 1].
  * The console_lock must be held.
  */
-static void call_console_drivers(int level,
-				 const char *ext_text, size_t ext_len,
+static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len)
 {
 	struct console *con;
@@ -1866,8 +1865,7 @@ static ssize_t msg_print_ext_header(char *buf, size_t size,
 static ssize_t msg_print_ext_body(char *buf, size_t size,
 				  char *dict, size_t dict_len,
 				  char *text, size_t text_len) { return 0; }
-static void call_console_drivers(int level,
-				 const char *ext_text, size_t ext_len,
+static void call_console_drivers(const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
@@ -2188,7 +2186,6 @@ void console_unlock(void)
 		struct printk_log *msg;
 		size_t ext_len = 0;
 		size_t len;
-		int level;
 
 		printk_safe_enter_irqsave(flags);
 		raw_spin_lock(&logbuf_lock);
@@ -2212,8 +2209,7 @@ void console_unlock(void)
 			break;
 
 		msg = log_from_idx(console_idx);
-		level = msg->level;
-		if (suppress_message_printing(level)) {
+		if (suppress_message_printing(msg->level)) {
 			/*
 			 * Skip record we have buffered and already printed
 			 * directly to the console when we received it, and
@@ -2239,7 +2235,7 @@ void console_unlock(void)
 		raw_spin_unlock(&logbuf_lock);
 
 		stop_critical_timings();	/* don't trace print latency */
-		call_console_drivers(level, ext_text, ext_len, text, len);
+		call_console_drivers(ext_text, ext_len, text, len);
 		start_critical_timings();
 		printk_safe_exit_irqrestore(flags);
 

commit de6fcbdb68b29b475f4e6368cd465fd778ea421f
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:11 2016 +0900

    printk: convert the rest to printk-safe
    
    This patch converts the rest of logbuf users (which are
    out of printk recursion case, but can deadlock in printk).
    To make printk-safe usage easier the patch introduces 4
    helper macros:
    - logbuf_lock_irq()/logbuf_unlock_irq()
      lock/unlock the logbuf lock and disable/enable local IRQ
    
    - logbuf_lock_irqsave(flags)/logbuf_unlock_irqrestore(flags)
      lock/unlock the logbuf lock and saves/restores local IRQ state
    
    Link: http://lkml.kernel.org/r/20161227141611.940-9-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e17d384f8c6b..080843148e8d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -370,6 +370,34 @@ __packed __aligned(4)
  */
 DEFINE_RAW_SPINLOCK(logbuf_lock);
 
+/*
+ * Helper macros to lock/unlock logbuf_lock and switch between
+ * printk-safe/unsafe modes.
+ */
+#define logbuf_lock_irq()				\
+	do {						\
+		printk_safe_enter_irq();		\
+		raw_spin_lock(&logbuf_lock);		\
+	} while (0)
+
+#define logbuf_unlock_irq()				\
+	do {						\
+		raw_spin_unlock(&logbuf_lock);		\
+		printk_safe_exit_irq();			\
+	} while (0)
+
+#define logbuf_lock_irqsave(flags)			\
+	do {						\
+		printk_safe_enter_irqsave(flags);	\
+		raw_spin_lock(&logbuf_lock);		\
+	} while (0)
+
+#define logbuf_unlock_irqrestore(flags)		\
+	do {						\
+		raw_spin_unlock(&logbuf_lock);		\
+		printk_safe_exit_irqrestore(flags);	\
+	} while (0)
+
 #ifdef CONFIG_PRINTK
 DECLARE_WAIT_QUEUE_HEAD(log_wait);
 /* the next printk record to read by syslog(READ) or /proc/kmsg */
@@ -801,20 +829,21 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	ret = mutex_lock_interruptible(&user->lock);
 	if (ret)
 		return ret;
-	raw_spin_lock_irq(&logbuf_lock);
+
+	logbuf_lock_irq();
 	while (user->seq == log_next_seq) {
 		if (file->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
-			raw_spin_unlock_irq(&logbuf_lock);
+			logbuf_unlock_irq();
 			goto out;
 		}
 
-		raw_spin_unlock_irq(&logbuf_lock);
+		logbuf_unlock_irq();
 		ret = wait_event_interruptible(log_wait,
 					       user->seq != log_next_seq);
 		if (ret)
 			goto out;
-		raw_spin_lock_irq(&logbuf_lock);
+		logbuf_lock_irq();
 	}
 
 	if (user->seq < log_first_seq) {
@@ -822,7 +851,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 		user->idx = log_first_idx;
 		user->seq = log_first_seq;
 		ret = -EPIPE;
-		raw_spin_unlock_irq(&logbuf_lock);
+		logbuf_unlock_irq();
 		goto out;
 	}
 
@@ -835,7 +864,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 
 	user->idx = log_next(user->idx);
 	user->seq++;
-	raw_spin_unlock_irq(&logbuf_lock);
+	logbuf_unlock_irq();
 
 	if (len > count) {
 		ret = -EINVAL;
@@ -862,7 +891,7 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 	if (offset)
 		return -ESPIPE;
 
-	raw_spin_lock_irq(&logbuf_lock);
+	logbuf_lock_irq();
 	switch (whence) {
 	case SEEK_SET:
 		/* the first record */
@@ -886,7 +915,7 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 	default:
 		ret = -EINVAL;
 	}
-	raw_spin_unlock_irq(&logbuf_lock);
+	logbuf_unlock_irq();
 	return ret;
 }
 
@@ -900,7 +929,7 @@ static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &log_wait, wait);
 
-	raw_spin_lock_irq(&logbuf_lock);
+	logbuf_lock_irq();
 	if (user->seq < log_next_seq) {
 		/* return error when data has vanished underneath us */
 		if (user->seq < log_first_seq)
@@ -908,7 +937,7 @@ static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
 		else
 			ret = POLLIN|POLLRDNORM;
 	}
-	raw_spin_unlock_irq(&logbuf_lock);
+	logbuf_unlock_irq();
 
 	return ret;
 }
@@ -938,10 +967,10 @@ static int devkmsg_open(struct inode *inode, struct file *file)
 
 	mutex_init(&user->lock);
 
-	raw_spin_lock_irq(&logbuf_lock);
+	logbuf_lock_irq();
 	user->idx = log_first_idx;
 	user->seq = log_first_seq;
-	raw_spin_unlock_irq(&logbuf_lock);
+	logbuf_unlock_irq();
 
 	file->private_data = user;
 	return 0;
@@ -1083,13 +1112,13 @@ void __init setup_log_buf(int early)
 		return;
 	}
 
-	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	logbuf_lock_irqsave(flags);
 	log_buf_len = new_log_buf_len;
 	log_buf = new_log_buf;
 	new_log_buf_len = 0;
 	free = __LOG_BUF_LEN - log_next_idx;
 	memcpy(log_buf, __log_buf, __LOG_BUF_LEN);
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+	logbuf_unlock_irqrestore(flags);
 
 	pr_info("log_buf_len: %d bytes\n", log_buf_len);
 	pr_info("early log buf free: %d(%d%%)\n",
@@ -1267,7 +1296,7 @@ static int syslog_print(char __user *buf, int size)
 		size_t n;
 		size_t skip;
 
-		raw_spin_lock_irq(&logbuf_lock);
+		logbuf_lock_irq();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -1275,7 +1304,7 @@ static int syslog_print(char __user *buf, int size)
 			syslog_partial = 0;
 		}
 		if (syslog_seq == log_next_seq) {
-			raw_spin_unlock_irq(&logbuf_lock);
+			logbuf_unlock_irq();
 			break;
 		}
 
@@ -1294,7 +1323,7 @@ static int syslog_print(char __user *buf, int size)
 			syslog_partial += n;
 		} else
 			n = 0;
-		raw_spin_unlock_irq(&logbuf_lock);
+		logbuf_unlock_irq();
 
 		if (!n)
 			break;
@@ -1323,7 +1352,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	if (!text)
 		return -ENOMEM;
 
-	raw_spin_lock_irq(&logbuf_lock);
+	logbuf_lock_irq();
 	if (buf) {
 		u64 next_seq;
 		u64 seq;
@@ -1371,12 +1400,12 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 			idx = log_next(idx);
 			seq++;
 
-			raw_spin_unlock_irq(&logbuf_lock);
+			logbuf_unlock_irq();
 			if (copy_to_user(buf + len, text, textlen))
 				len = -EFAULT;
 			else
 				len += textlen;
-			raw_spin_lock_irq(&logbuf_lock);
+			logbuf_lock_irq();
 
 			if (seq < log_first_seq) {
 				/* messages are gone, move to next one */
@@ -1390,7 +1419,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		clear_seq = log_next_seq;
 		clear_idx = log_next_idx;
 	}
-	raw_spin_unlock_irq(&logbuf_lock);
+	logbuf_unlock_irq();
 
 	kfree(text);
 	return len;
@@ -1477,7 +1506,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		break;
 	/* Number of chars in the log buffer */
 	case SYSLOG_ACTION_SIZE_UNREAD:
-		raw_spin_lock_irq(&logbuf_lock);
+		logbuf_lock_irq();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -1505,7 +1534,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			}
 			error -= syslog_partial;
 		}
-		raw_spin_unlock_irq(&logbuf_lock);
+		logbuf_unlock_irq();
 		break;
 	/* Size of the log buffer */
 	case SYSLOG_ACTION_SIZE_BUFFER:
@@ -1682,9 +1711,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 	boot_delay_msec(level);
 	printk_delay();
 
-	printk_safe_enter_irqsave(flags);
 	/* This stops the holder of console_sem just where we want him */
-	raw_spin_lock(&logbuf_lock);
+	logbuf_lock_irqsave(flags);
 	/*
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.
@@ -1727,8 +1755,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	printed_len += log_output(facility, level, lflags, dict, dictlen, text, text_len);
 
-	raw_spin_unlock(&logbuf_lock);
-	printk_safe_exit_irqrestore(flags);
+	logbuf_unlock_irqrestore(flags);
 
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
@@ -2501,10 +2528,10 @@ void register_console(struct console *newcon)
 		 * console_unlock(); will print out the buffered messages
 		 * for us.
 		 */
-		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		logbuf_lock_irqsave(flags);
 		console_seq = syslog_seq;
 		console_idx = syslog_idx;
-		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		logbuf_unlock_irqrestore(flags);
 		/*
 		 * We're about to replay the log buffer.  Only do this to the
 		 * just-registered console to avoid excessive message spam to
@@ -2803,12 +2830,12 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 		/* initialize iterator with data about the stored records */
 		dumper->active = true;
 
-		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		logbuf_lock_irqsave(flags);
 		dumper->cur_seq = clear_seq;
 		dumper->cur_idx = clear_idx;
 		dumper->next_seq = log_next_seq;
 		dumper->next_idx = log_next_idx;
-		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		logbuf_unlock_irqrestore(flags);
 
 		/* invoke dumper which will iterate over records */
 		dumper->dump(dumper, reason);
@@ -2893,9 +2920,9 @@ bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
 	unsigned long flags;
 	bool ret;
 
-	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	logbuf_lock_irqsave(flags);
 	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+	logbuf_unlock_irqrestore(flags);
 
 	return ret;
 }
@@ -2934,7 +2961,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	if (!dumper->active)
 		goto out;
 
-	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	logbuf_lock_irqsave(flags);
 	if (dumper->cur_seq < log_first_seq) {
 		/* messages are gone, move to first available one */
 		dumper->cur_seq = log_first_seq;
@@ -2943,7 +2970,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 
 	/* last entry */
 	if (dumper->cur_seq >= dumper->next_seq) {
-		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		logbuf_unlock_irqrestore(flags);
 		goto out;
 	}
 
@@ -2985,7 +3012,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	dumper->next_seq = next_seq;
 	dumper->next_idx = next_idx;
 	ret = true;
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+	logbuf_unlock_irqrestore(flags);
 out:
 	if (len)
 		*len = l;
@@ -3023,9 +3050,9 @@ void kmsg_dump_rewind(struct kmsg_dumper *dumper)
 {
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	logbuf_lock_irqsave(flags);
 	kmsg_dump_rewind_nolock(dumper);
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+	logbuf_unlock_irqrestore(flags);
 }
 EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
 

commit 8b1742c9c2071520efacf44e974dc03421360471
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:10 2016 +0900

    printk: remove zap_locks() function
    
    We use printk-safe now which makes printk-recursion detection code
    in vprintk_emit() unreachable. The tricky thing here is that, apart
    from detecting and reporting printk recursions, that code also used
    to zap_locks() in case of panic() from the same CPU. However,
    zap_locks() does not look to be needed anymore:
    
    1) Since commit 08d78658f393 ("panic: release stale console lock to
       always get the logbuf printed out") panic flushing of `logbuf' to
       console ignores the state of `console_sem' by doing
            panic()
                    console_trylock();
                    console_unlock();
    
    2) Since commit cf9b1106c81c ("printk/nmi: flush NMI messages on the
       system panic") panic attempts to zap the `logbuf_lock' spin_lock to
       successfully flush nmi messages to `logbuf'.
    
    Basically, it seems that we either already do what zap_locks() used to
    do but in other places or we ignore the state of the lock. The only
    reaming difference is that we don't re-init the console semaphore in
    printk_safe_flush_on_panic(), but this is not necessary because we
    don't call console drivers from printk_safe_flush_on_panic() due to
    the fact that we are using a deferred printk() version (as was
    suggested by Petr Mladek).
    
    Link: http://lkml.kernel.org/r/20161227141611.940-8-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f426a2b12a9b..e17d384f8c6b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1557,28 +1557,6 @@ static void call_console_drivers(int level,
 	}
 }
 
-/*
- * Zap console related locks when oopsing.
- * To leave time for slow consoles to print a full oops,
- * only zap at most once every 30 seconds.
- */
-static void zap_locks(void)
-{
-	static unsigned long oops_timestamp;
-
-	if (time_after_eq(jiffies, oops_timestamp) &&
-	    !time_after(jiffies, oops_timestamp + 30 * HZ))
-		return;
-
-	oops_timestamp = jiffies;
-
-	debug_locks_off();
-	/* If a crash is occurring, make sure we can't deadlock */
-	raw_spin_lock_init(&logbuf_lock);
-	/* And make sure that we print immediately */
-	sema_init(&console_sem, 1);
-}
-
 int printk_delay_msec __read_mostly;
 
 static inline void printk_delay(void)
@@ -1688,17 +1666,13 @@ asmlinkage int vprintk_emit(int facility, int level,
 			    const char *dict, size_t dictlen,
 			    const char *fmt, va_list args)
 {
-	static bool recursion_bug;
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
 	size_t text_len = 0;
 	enum log_flags lflags = 0;
 	unsigned long flags;
-	int this_cpu;
 	int printed_len = 0;
 	bool in_sched = false;
-	/* cpu currently holding logbuf_lock in this function */
-	static unsigned int logbuf_cpu = UINT_MAX;
 
 	if (level == LOGLEVEL_SCHED) {
 		level = LOGLEVEL_DEFAULT;
@@ -1709,42 +1683,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 	printk_delay();
 
 	printk_safe_enter_irqsave(flags);
-	this_cpu = smp_processor_id();
-
-	/*
-	 * Ouch, printk recursed into itself!
-	 */
-	if (unlikely(logbuf_cpu == this_cpu)) {
-		/*
-		 * If a crash is occurring during printk() on this CPU,
-		 * then try to get the crash message out but make sure
-		 * we can't deadlock. Otherwise just return to avoid the
-		 * recursion and return - but flag the recursion so that
-		 * it can be printed at the next appropriate moment:
-		 */
-		if (!oops_in_progress && !lockdep_recursing(current)) {
-			recursion_bug = true;
-			printk_safe_exit_irqrestore(flags);
-			return 0;
-		}
-		zap_locks();
-	}
-
 	/* This stops the holder of console_sem just where we want him */
 	raw_spin_lock(&logbuf_lock);
-	logbuf_cpu = this_cpu;
-
-	if (unlikely(recursion_bug)) {
-		static const char recursion_msg[] =
-			"BUG: recent printk recursion!";
-
-		recursion_bug = false;
-		/* emit KERN_CRIT message */
-		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
-					 NULL, 0, recursion_msg,
-					 strlen(recursion_msg));
-	}
-
 	/*
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.
@@ -1787,7 +1727,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	printed_len += log_output(facility, level, lflags, dict, dictlen, text, text_len);
 
-	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);
 	printk_safe_exit_irqrestore(flags);
 

commit f975237b76827956fe13ecfe993a319158e2c303
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:09 2016 +0900

    printk: use printk_safe buffers in printk
    
    Use printk_safe per-CPU buffers in printk recursion-prone blocks:
    -- around logbuf_lock protected sections in vprintk_emit() and
       console_unlock()
    -- around down_trylock_console_sem() and up_console_sem()
    
    Note that this solution addresses deadlocks caused by printk()
    recursive calls only. That is vprintk_emit() and console_unlock().
    The rest will be converted in a followup patch.
    
    Another thing to note is that we now keep lockdep enabled in printk,
    because we are protected against the printk recursion caused by
    lockdep in vprintk_emit() by the printk-safe mechanism - we first
    switch to per-CPU buffers and only then access the deadlock-prone
    locks.
    
    Examples:
    
    1) printk() from logbuf_lock spin_lock section
    
    Assume the following code:
      printk()
        raw_spin_lock(&logbuf_lock);
        WARN_ON(1);
        raw_spin_unlock(&logbuf_lock);
    
    which now produces:
    
     ------------[ cut here ]------------
     WARNING: CPU: 0 PID: 366 at kernel/printk/printk.c:1811 vprintk_emit
     CPU: 0 PID: 366 Comm: bash
     Call Trace:
       warn_slowpath_null+0x1d/0x1f
       vprintk_emit+0x1cd/0x438
       vprintk_default+0x1d/0x1f
       printk+0x48/0x50
      [..]
    
    2) printk() from semaphore sem->lock spin_lock section
    
    Assume the following code
    
      printk()
        console_trylock()
          down_trylock()
            raw_spin_lock_irqsave(&sem->lock, flags);
            WARN_ON(1);
            raw_spin_unlock_irqrestore(&sem->lock, flags);
    
    which now produces:
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 363 at kernel/locking/semaphore.c:141 down_trylock
     CPU: 1 PID: 363 Comm: bash
     Call Trace:
       warn_slowpath_null+0x1d/0x1f
       down_trylock+0x3d/0x62
       ? vprintk_emit+0x3f9/0x414
       console_trylock+0x31/0xeb
       vprintk_emit+0x3f9/0x414
       vprintk_default+0x1d/0x1f
       printk+0x48/0x50
      [..]
    
    3) printk() from console_unlock()
    
    Assume the following code:
    
      printk()
        console_unlock()
          raw_spin_lock(&logbuf_lock);
          WARN_ON(1);
          raw_spin_unlock(&logbuf_lock);
    
    which now produces:
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 329 at kernel/printk/printk.c:2384 console_unlock
     CPU: 1 PID: 329 Comm: bash
     Call Trace:
       warn_slowpath_null+0x18/0x1a
       console_unlock+0x12d/0x559
       ? trace_hardirqs_on_caller+0x16d/0x189
       ? trace_hardirqs_on+0xd/0xf
       vprintk_emit+0x363/0x374
       vprintk_default+0x18/0x1a
       printk+0x43/0x4b
      [..]
    
    4) printk() from try_to_wake_up()
    
    Assume the following code:
    
      printk()
        console_unlock()
          up()
            try_to_wake_up()
              raw_spin_lock_irqsave(&p->pi_lock, flags);
              WARN_ON(1);
              raw_spin_unlock_irqrestore(&p->pi_lock, flags);
    
    which now produces:
    
     ------------[ cut here ]------------
     WARNING: CPU: 3 PID: 363 at kernel/sched/core.c:2028 try_to_wake_up
     CPU: 3 PID: 363 Comm: bash
     Call Trace:
       warn_slowpath_null+0x1d/0x1f
       try_to_wake_up+0x7f/0x4f7
       wake_up_process+0x15/0x17
       __up.isra.0+0x56/0x63
       up+0x32/0x42
       __up_console_sem+0x37/0x55
       console_unlock+0x21e/0x4c2
       vprintk_emit+0x41c/0x462
       vprintk_default+0x1d/0x1f
       printk+0x48/0x50
      [..]
    
    5) printk() from call_console_drivers()
    
    Assume the following code:
      printk()
        console_unlock()
          call_console_drivers()
          ...
              WARN_ON(1);
    
    which now produces:
    
     ------------[ cut here ]------------
     WARNING: CPU: 2 PID: 305 at kernel/printk/printk.c:1604 call_console_drivers
     CPU: 2 PID: 305 Comm: bash
     Call Trace:
       warn_slowpath_null+0x18/0x1a
       call_console_drivers.isra.6.constprop.16+0x3a/0xb0
       console_unlock+0x471/0x48e
       vprintk_emit+0x1f4/0x206
       vprintk_default+0x18/0x1a
       vprintk_func+0x6e/0x70
       printk+0x3e/0x46
      [..]
    
    6) unsupported placeholder in printk() format now prints an actual
       warning from vscnprintf(), instead of
            'BUG: recent printk recursion!'.
    
     ------------[ cut here ]------------
     WARNING: CPU: 5 PID: 337 at lib/vsprintf.c:1900 format_decode
     Please remove unsupported %
      in format string
     CPU: 5 PID: 337 Comm: bash
     Call Trace:
       dump_stack+0x4f/0x65
       __warn+0xc2/0xdd
       warn_slowpath_fmt+0x4b/0x53
       format_decode+0x22c/0x308
       vsnprintf+0x89/0x3b7
       vscnprintf+0xd/0x26
       vprintk_emit+0xb4/0x238
       vprintk_default+0x1d/0x1f
       vprintk_func+0x6c/0x73
       printk+0x43/0x4b
      [..]
    
    Link: http://lkml.kernel.org/r/20161227141611.940-7-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 6bb77eff502d..f426a2b12a9b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -213,17 +213,36 @@ static int nr_ext_console_drivers;
 
 static int __down_trylock_console_sem(unsigned long ip)
 {
-	if (down_trylock(&console_sem))
+	int lock_failed;
+	unsigned long flags;
+
+	/*
+	 * Here and in __up_console_sem() we need to be in safe mode,
+	 * because spindump/WARN/etc from under console ->lock will
+	 * deadlock in printk()->down_trylock_console_sem() otherwise.
+	 */
+	printk_safe_enter_irqsave(flags);
+	lock_failed = down_trylock(&console_sem);
+	printk_safe_exit_irqrestore(flags);
+
+	if (lock_failed)
 		return 1;
 	mutex_acquire(&console_lock_dep_map, 0, 1, ip);
 	return 0;
 }
 #define down_trylock_console_sem() __down_trylock_console_sem(_RET_IP_)
 
-#define up_console_sem() do { \
-	mutex_release(&console_lock_dep_map, 1, _RET_IP_);\
-	up(&console_sem);\
-} while (0)
+static void __up_console_sem(unsigned long ip)
+{
+	unsigned long flags;
+
+	mutex_release(&console_lock_dep_map, 1, ip);
+
+	printk_safe_enter_irqsave(flags);
+	up(&console_sem);
+	printk_safe_exit_irqrestore(flags);
+}
+#define up_console_sem() __up_console_sem(_RET_IP_)
 
 /*
  * This is used for debugging the mess that is the VT code by
@@ -1689,7 +1708,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	boot_delay_msec(level);
 	printk_delay();
 
-	local_irq_save(flags);
+	printk_safe_enter_irqsave(flags);
 	this_cpu = smp_processor_id();
 
 	/*
@@ -1705,13 +1724,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (!oops_in_progress && !lockdep_recursing(current)) {
 			recursion_bug = true;
-			local_irq_restore(flags);
+			printk_safe_exit_irqrestore(flags);
 			return 0;
 		}
 		zap_locks();
 	}
 
-	lockdep_off();
 	/* This stops the holder of console_sem just where we want him */
 	raw_spin_lock(&logbuf_lock);
 	logbuf_cpu = this_cpu;
@@ -1771,12 +1789,10 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);
-	lockdep_on();
-	local_irq_restore(flags);
+	printk_safe_exit_irqrestore(flags);
 
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
-		lockdep_off();
 		/*
 		 * Try to acquire and then immediately release the console
 		 * semaphore.  The release will print out buffers and wake up
@@ -1784,7 +1800,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (console_trylock())
 			console_unlock();
-		lockdep_on();
 	}
 
 	return printed_len;
@@ -2209,7 +2224,8 @@ void console_unlock(void)
 		size_t len;
 		int level;
 
-		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		printk_safe_enter_irqsave(flags);
+		raw_spin_lock(&logbuf_lock);
 		if (seen_seq != log_next_seq) {
 			wake_klogd = true;
 			seen_seq = log_next_seq;
@@ -2259,7 +2275,7 @@ void console_unlock(void)
 		stop_critical_timings();	/* don't trace print latency */
 		call_console_drivers(level, ext_text, ext_len, text, len);
 		start_critical_timings();
-		local_irq_restore(flags);
+		printk_safe_exit_irqrestore(flags);
 
 		if (do_cond_resched)
 			cond_resched();
@@ -2282,7 +2298,8 @@ void console_unlock(void)
 	 */
 	raw_spin_lock(&logbuf_lock);
 	retry = console_seq != log_next_seq;
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+	raw_spin_unlock(&logbuf_lock);
+	printk_safe_exit_irqrestore(flags);
 
 	if (retry && console_trylock())
 		goto again;

commit ddb9baa822265b55afffd9815a2758a4b70006c1
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:08 2016 +0900

    printk: report lost messages in printk safe/nmi contexts
    
    Account lost messages in pritk-safe and printk-safe-nmi
    contexts and report those numbers during printk_safe_flush().
    
    The patch also moves lost message counter to struct
    `printk_safe_seq_buf' instead of having dedicated static
    counters - this simplifies the code.
    
    Link: http://lkml.kernel.org/r/20161227141611.940-6-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f73046f7a6df..6bb77eff502d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1677,7 +1677,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 	unsigned long flags;
 	int this_cpu;
 	int printed_len = 0;
-	int nmi_message_lost;
 	bool in_sched = false;
 	/* cpu currently holding logbuf_lock in this function */
 	static unsigned int logbuf_cpu = UINT_MAX;
@@ -1728,15 +1727,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 					 strlen(recursion_msg));
 	}
 
-	nmi_message_lost = get_nmi_message_lost();
-	if (unlikely(nmi_message_lost)) {
-		text_len = scnprintf(textbuf, sizeof(textbuf),
-				     "BAD LUCK: lost %d message(s) from NMI context!",
-				     nmi_message_lost);
-		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
-					 NULL, 0, textbuf, text_len);
-	}
-
 	/*
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.

commit 099f1c84c0052ec1b27f1c3942eed5830d86bdbb
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:06 2016 +0900

    printk: introduce per-cpu safe_print seq buffer
    
    This patch extends the idea of NMI per-cpu buffers to regions
    that may cause recursive printk() calls and possible deadlocks.
    Namely, printk() can't handle printk calls from schedule code
    or printk() calls from lock debugging code (spin_dump() for instance);
    because those may be called with `sem->lock' already taken or any
    other `critical' locks (p->pi_lock, etc.). An example of deadlock
    can be
    
     vprintk_emit()
      console_unlock()
       up()                        << raw_spin_lock_irqsave(&sem->lock, flags);
        wake_up_process()
         try_to_wake_up()
          ttwu_queue()
           ttwu_activate()
            activate_task()
             enqueue_task()
              enqueue_task_fair()
               cfs_rq_of()
                task_of()
                 WARN_ON_ONCE(!entity_is_task(se))
                  vprintk_emit()
                   console_trylock()
                    down_trylock()
                     raw_spin_lock_irqsave(&sem->lock, flags)
                     ^^^^ deadlock
    
    and some other cases.
    
    Just like in NMI implementation, the solution uses a per-cpu
    `printk_func' pointer to 'redirect' printk() calls to a 'safe'
    callback, that store messages in a per-cpu buffer and flushes
    them back to logbuf buffer later.
    
    Usage example:
    
     printk()
      printk_safe_enter_irqsave(flags)
      //
      //  any printk() call from here will endup in vprintk_safe(),
      //  that stores messages in a special per-CPU buffer.
      //
      printk_safe_exit_irqrestore(flags)
    
    The 'redirection' mechanism, though, has been reworked, as suggested
    by Petr Mladek. Instead of using a per-cpu @print_func callback we now
    keep a per-cpu printk-context variable and call either default or nmi
    vprintk function depending on its value. printk_nmi_entrer/exit and
    printk_safe_enter/exit, thus, just set/celar corresponding bits in
    printk-context functions.
    
    The patch only adds printk_safe support, we don't use it yet.
    
    Link: http://lkml.kernel.org/r/20161227141611.940-4-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 106843a83b63..f73046f7a6df 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1902,9 +1902,6 @@ static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static bool suppress_message_printing(int level) { return false; }
 
-/* Still needs to be defined for users */
-DEFINE_PER_CPU(printk_func_t, printk_func);
-
 #endif /* CONFIG_PRINTK */
 
 #ifdef CONFIG_EARLY_PRINTK

commit bd66a89249892acc9d938ba4956066b21403fa5f
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Dec 27 23:16:04 2016 +0900

    printk: use vprintk_func in vprintk()
    
    vprintk(), just like printk(), better be using per-cpu printk_func
    instead of direct vprintk_emit() call. Just in case if vprintk()
    will ever be called from NMI, or from any other context that can
    deadlock in printk().
    
    Link: http://lkml.kernel.org/r/20161227141611.940-2-sergey.senozhatsky@gmail.com
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Calvin Owens <calvinowens@fb.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8b2696420abb..106843a83b63 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1803,7 +1803,7 @@ EXPORT_SYMBOL(vprintk_emit);
 
 asmlinkage int vprintk(const char *fmt, va_list args)
 {
-	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
+	return vprintk_func(fmt, args);
 }
 EXPORT_SYMBOL(vprintk);
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e2cdd87e7a63..8b2696420abb 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -46,7 +46,7 @@
 #include <linux/ctype.h>
 #include <linux/uio.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/sections.h>
 
 #define CREATE_TRACE_POINTS

commit 9a19a6db37ee0b7a6db796b3dcd6bb6e7237d6ea
Merge: bd9999cd6a5e c4364f837caf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:24:44 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
    
     - more ->d_init() stuff (work.dcache)
    
     - pathname resolution cleanups (work.namei)
    
     - a few missing iov_iter primitives - copy_from_iter_full() and
       friends. Either copy the full requested amount, advance the iterator
       and return true, or fail, return false and do _not_ advance the
       iterator. Quite a few open-coded callers converted (and became more
       readable and harder to fuck up that way) (work.iov_iter)
    
     - several assorted patches, the big one being logfs removal
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      logfs: remove from tree
      vfs: fix put_compat_statfs64() does not handle errors
      namei: fold should_follow_link() with the step into not-followed link
      namei: pass both WALK_GET and WALK_MORE to should_follow_link()
      namei: invert WALK_PUT logics
      namei: shift interpretation of LOOKUP_FOLLOW inside should_follow_link()
      namei: saner calling conventions for mountpoint_last()
      namei.c: get rid of user_path_parent()
      switch getfrag callbacks to ..._full() primitives
      make skb_add_data,{_nocache}() and skb_copy_to_page_nocache() advance only on success
      [iov_iter] new primitives - copy_from_iter_full() and friends
      don't open-code file_inode()
      ceph: switch to use of ->d_init()
      ceph: unify dentry_operations instances
      lustre: switch to use of ->d_init()

commit 8fa9a697ab083af0f4a2807869752685ed8a7a6a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Dec 15 13:53:58 2016 +0100

    printk: Remove no longer used second struct cont
    
    If CONFIG_PRINTK=n:
    
        kernel/printk/printk.c:1893: warning: ‘cont’ defined but not used
    
    Note that there are actually two different struct cont definitions and
    objects: the first one is used if CONFIG_PRINTK=y, the second one became
    unused by removing console_cont_flush().
    
    Fixes: 5c2992ee7fd8 ("printk: remove console flushing special cases for partial buffered lines")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Petr Mladek <pmladek@suse.com>
    [ I do the occasional "allnoconfig" builds, but apparently not often
      enough  - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b3c454b733da..bc2e220ed2b0 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1885,12 +1885,6 @@ static u32 console_idx;
 static u64 log_first_seq;
 static u32 log_first_idx;
 static u64 log_next_seq;
-static struct cont {
-	size_t len;
-	size_t cons;
-	u8 level;
-	bool flushed:1;
-} cont;
 static char *log_text(const struct printk_log *msg) { return NULL; }
 static char *log_dict(const struct printk_log *msg) { return NULL; }
 static struct printk_log *log_from_idx(u32 idx) { return NULL; }

commit 5c2992ee7fd8a29d04125dc0aa3522784c5fa5eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 11:27:31 2016 -0700

    printk: remove console flushing special cases for partial buffered lines
    
    It actively hurts proper merging, and makes for a lot of special cases.
    There was a good(ish) reason for doing it originally, but it's getting
    too painful to maintain.  And most of the original reasons for it are
    long gone.
    
    So instead of having special code to flush partial lines to the console
    (as opposed to the record buffers), do _all_ the console writing from
    the record buffer, and be done with it.
    
    If an oops happens (or some other synchronous event), we will flush the
    partial lines due to the oops printing activity, so this does not affect
    that.  It does mean that if you have a completely hung machine, a
    partial preceding line may not have been printed out.
    
    That was some of the original reason for this complexity, in fact, back
    when we used to test for the historical i386 "halt" instruction problem
    by doing
    
            pr_info("Checking 'hlt' instruction... ");
    
            if (!boot_cpu_data.hlt_works_ok) {
                    pr_cont("disabled\n");
                    return;
            }
            halt();
            halt();
            halt();
            halt();
            pr_cont("OK\n");
    
    and that model no longer works (it the 'hlt' instruction kills the
    machine, the partial line won't have been flushed, so you won't even see
    it).
    
    Of course, that was also back in the days when people actually had
    textual console output rather than a graphical splash-screen at bootup.
    How times change..
    
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Tested-by: Petr Mladek <pmladek@suse.com>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 50b2703d6d6a..b3c454b733da 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1583,46 +1583,25 @@ static inline void printk_delay(void)
 static struct cont {
 	char buf[LOG_LINE_MAX];
 	size_t len;			/* length == 0 means unused buffer */
-	size_t cons;			/* bytes written to console */
 	struct task_struct *owner;	/* task of first print*/
 	u64 ts_nsec;			/* time of first print */
 	u8 level;			/* log level of first message */
 	u8 facility;			/* log facility of first message */
 	enum log_flags flags;		/* prefix, newline flags */
-	bool flushed:1;			/* buffer sealed and committed */
 } cont;
 
 static void cont_flush(void)
 {
-	if (cont.flushed)
-		return;
 	if (cont.len == 0)
 		return;
-	if (cont.cons) {
-		/*
-		 * If a fragment of this line was directly flushed to the
-		 * console; wait for the console to pick up the rest of the
-		 * line. LOG_NOCONS suppresses a duplicated output.
-		 */
-		log_store(cont.facility, cont.level, cont.flags | LOG_NOCONS,
-			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
-		cont.flushed = true;
-	} else {
-		/*
-		 * If no fragment of this line ever reached the console,
-		 * just submit it to the store and free the buffer.
-		 */
-		log_store(cont.facility, cont.level, cont.flags, 0,
-			  NULL, 0, cont.buf, cont.len);
-		cont.len = 0;
-	}
+
+	log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,
+		  NULL, 0, cont.buf, cont.len);
+	cont.len = 0;
 }
 
 static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)
 {
-	if (cont.len && cont.flushed)
-		return false;
-
 	/*
 	 * If ext consoles are present, flush and skip in-kernel
 	 * continuation.  See nr_ext_console_drivers definition.  Also, if
@@ -1639,8 +1618,6 @@ static bool cont_add(int facility, int level, enum log_flags flags, const char *
 		cont.owner = current;
 		cont.ts_nsec = local_clock();
 		cont.flags = flags;
-		cont.cons = 0;
-		cont.flushed = false;
 	}
 
 	memcpy(cont.buf + cont.len, text, len);
@@ -1659,34 +1636,6 @@ static bool cont_add(int facility, int level, enum log_flags flags, const char *
 	return true;
 }
 
-static size_t cont_print_text(char *text, size_t size)
-{
-	size_t textlen = 0;
-	size_t len;
-
-	if (cont.cons == 0) {
-		textlen += print_time(cont.ts_nsec, text);
-		size -= textlen;
-	}
-
-	len = cont.len - cont.cons;
-	if (len > 0) {
-		if (len+1 > size)
-			len = size-1;
-		memcpy(text + textlen, cont.buf + cont.cons, len);
-		textlen += len;
-		cont.cons = cont.len;
-	}
-
-	if (cont.flushed) {
-		if (cont.flags & LOG_NEWLINE)
-			text[textlen++] = '\n';
-		/* got everything, release buffer */
-		cont.len = 0;
-	}
-	return textlen;
-}
-
 static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
 {
 	/*
@@ -1957,7 +1906,6 @@ static void call_console_drivers(int level,
 				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
-static size_t cont_print_text(char *text, size_t size) { return 0; }
 static bool suppress_message_printing(int level) { return false; }
 
 /* Still needs to be defined for users */
@@ -2221,42 +2169,6 @@ static inline int can_use_console(void)
 	return cpu_online(raw_smp_processor_id()) || have_callable_console();
 }
 
-static void console_cont_flush(char *text, size_t size)
-{
-	unsigned long flags;
-	size_t len;
-
-	raw_spin_lock_irqsave(&logbuf_lock, flags);
-
-	if (!cont.len)
-		goto out;
-
-	if (suppress_message_printing(cont.level)) {
-		cont.cons = cont.len;
-		if (cont.flushed)
-			cont.len = 0;
-		goto out;
-	}
-
-	/*
-	 * We still queue earlier records, likely because the console was
-	 * busy. The earlier ones need to be printed before this one, we
-	 * did not flush any fragment so far, so just let it queue up.
-	 */
-	if (console_seq < log_next_seq && !cont.cons)
-		goto out;
-
-	len = cont_print_text(text, size);
-	raw_spin_unlock(&logbuf_lock);
-	stop_critical_timings();
-	call_console_drivers(cont.level, NULL, 0, text, len);
-	start_critical_timings();
-	local_irq_restore(flags);
-	return;
-out:
-	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
-}
-
 /**
  * console_unlock - unlock the console system
  *
@@ -2310,9 +2222,6 @@ void console_unlock(void)
 		return;
 	}
 
-	/* flush buffered message fragment immediately to console */
-	console_cont_flush(text, sizeof(text));
-
 	for (;;) {
 		struct printk_log *msg;
 		size_t ext_len = 0;
@@ -2341,8 +2250,7 @@ void console_unlock(void)
 
 		msg = log_from_idx(console_idx);
 		level = msg->level;
-		if ((msg->flags & LOG_NOCONS) ||
-				suppress_message_printing(level)) {
+		if (suppress_message_printing(level)) {
 			/*
 			 * Skip record we have buffered and already printed
 			 * directly to the console when we received it, and
@@ -2350,12 +2258,6 @@ void console_unlock(void)
 			 */
 			console_idx = log_next(console_idx);
 			console_seq++;
-			/*
-			 * We will get here again when we register a new
-			 * CON_PRINTBUFFER console. Clear the flag so we
-			 * will properly dump everything later.
-			 */
-			msg->flags &= ~LOG_NOCONS;
 			goto skip;
 		}
 

commit 5aa068ea4082b39eafc356c27c9ecd155b0895f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 11:27:31 2016 -0700

    printk: remove games with previous record flags
    
    The record logging code looks at the previous record flags in various
    ways, and they are all wrong.
    
    You can't use the previous record flags to determine anything about the
    next record, because they may simply not be related.  In particular, the
    reason the previous record was a continuation record may well be exactly
    _because_ the new record was printed by a different process, which is
    why the previous record was flushed.
    
    So all those games are simply wrong, and make the code hard to
    understand (because the code fundamentally cdoes not make sense).
    
    So remove it.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a3ce35e0fa1e..50b2703d6d6a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -356,7 +356,6 @@ DECLARE_WAIT_QUEUE_HEAD(log_wait);
 /* the next printk record to read by syslog(READ) or /proc/kmsg */
 static u64 syslog_seq;
 static u32 syslog_idx;
-static enum log_flags syslog_prev;
 static size_t syslog_partial;
 
 /* index and sequence number of the first record stored in the buffer */
@@ -370,7 +369,6 @@ static u32 log_next_idx;
 /* the next printk record to write to the console */
 static u64 console_seq;
 static u32 console_idx;
-static enum log_flags console_prev;
 
 /* the next printk record to read after the last 'clear' command */
 static u64 clear_seq;
@@ -639,27 +637,15 @@ static void append_char(char **pp, char *e, char c)
 }
 
 static ssize_t msg_print_ext_header(char *buf, size_t size,
-				    struct printk_log *msg, u64 seq,
-				    enum log_flags prev_flags)
+				    struct printk_log *msg, u64 seq)
 {
 	u64 ts_usec = msg->ts_nsec;
-	char cont = '-';
 
 	do_div(ts_usec, 1000);
 
-	/*
-	 * If we couldn't merge continuation line fragments during the print,
-	 * export the stored flags to allow an optional external merge of the
-	 * records. Merging the records isn't always neccessarily correct, like
-	 * when we hit a race during printing. In most cases though, it produces
-	 * better readable output. 'c' in the record flags mark the first
-	 * fragment of a line, '+' the following.
-	 */
-	if (msg->flags & LOG_CONT)
-		cont = (prev_flags & LOG_CONT) ? '+' : 'c';
-
 	return scnprintf(buf, size, "%u,%llu,%llu,%c;",
-		       (msg->facility << 3) | msg->level, seq, ts_usec, cont);
+		       (msg->facility << 3) | msg->level, seq, ts_usec,
+		       msg->flags & LOG_CONT ? 'c' : '-');
 }
 
 static ssize_t msg_print_ext_body(char *buf, size_t size,
@@ -714,7 +700,6 @@ static ssize_t msg_print_ext_body(char *buf, size_t size,
 struct devkmsg_user {
 	u64 seq;
 	u32 idx;
-	enum log_flags prev;
 	struct ratelimit_state rs;
 	struct mutex lock;
 	char buf[CONSOLE_EXT_LOG_MAX];
@@ -824,12 +809,11 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 
 	msg = log_from_idx(user->idx);
 	len = msg_print_ext_header(user->buf, sizeof(user->buf),
-				   msg, user->seq, user->prev);
+				   msg, user->seq);
 	len += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,
 				  log_dict(msg), msg->dict_len,
 				  log_text(msg), msg->text_len);
 
-	user->prev = msg->flags;
 	user->idx = log_next(user->idx);
 	user->seq++;
 	raw_spin_unlock_irq(&logbuf_lock);
@@ -1210,26 +1194,12 @@ static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)
 	return len;
 }
 
-static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
-			     bool syslog, char *buf, size_t size)
+static size_t msg_print_text(const struct printk_log *msg, bool syslog, char *buf, size_t size)
 {
 	const char *text = log_text(msg);
 	size_t text_size = msg->text_len;
-	bool prefix = true;
-	bool newline = true;
 	size_t len = 0;
 
-	if ((prev & LOG_CONT) && !(msg->flags & LOG_PREFIX))
-		prefix = false;
-
-	if (msg->flags & LOG_CONT) {
-		if ((prev & LOG_CONT) && !(prev & LOG_NEWLINE))
-			prefix = false;
-
-		if (!(msg->flags & LOG_NEWLINE))
-			newline = false;
-	}
-
 	do {
 		const char *next = memchr(text, '\n', text_size);
 		size_t text_len;
@@ -1247,22 +1217,17 @@ static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			    text_len + 1 >= size - len)
 				break;
 
-			if (prefix)
-				len += print_prefix(msg, syslog, buf + len);
+			len += print_prefix(msg, syslog, buf + len);
 			memcpy(buf + len, text, text_len);
 			len += text_len;
-			if (next || newline)
-				buf[len++] = '\n';
+			buf[len++] = '\n';
 		} else {
 			/* SYSLOG_ACTION_* buffer size only calculation */
-			if (prefix)
-				len += print_prefix(msg, syslog, NULL);
+			len += print_prefix(msg, syslog, NULL);
 			len += text_len;
-			if (next || newline)
-				len++;
+			len++;
 		}
 
-		prefix = true;
 		text = next;
 	} while (text);
 
@@ -1288,7 +1253,6 @@ static int syslog_print(char __user *buf, int size)
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
 			syslog_idx = log_first_idx;
-			syslog_prev = 0;
 			syslog_partial = 0;
 		}
 		if (syslog_seq == log_next_seq) {
@@ -1298,13 +1262,11 @@ static int syslog_print(char __user *buf, int size)
 
 		skip = syslog_partial;
 		msg = log_from_idx(syslog_idx);
-		n = msg_print_text(msg, syslog_prev, true, text,
-				   LOG_LINE_MAX + PREFIX_MAX);
+		n = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);
 		if (n - syslog_partial <= size) {
 			/* message fits into buffer, move forward */
 			syslog_idx = log_next(syslog_idx);
 			syslog_seq++;
-			syslog_prev = msg->flags;
 			n -= syslog_partial;
 			syslog_partial = 0;
 		} else if (!len){
@@ -1347,7 +1309,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		u64 next_seq;
 		u64 seq;
 		u32 idx;
-		enum log_flags prev;
 
 		/*
 		 * Find first record that fits, including all following records,
@@ -1355,12 +1316,10 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		 */
 		seq = clear_seq;
 		idx = clear_idx;
-		prev = 0;
 		while (seq < log_next_seq) {
 			struct printk_log *msg = log_from_idx(idx);
 
-			len += msg_print_text(msg, prev, true, NULL, 0);
-			prev = msg->flags;
+			len += msg_print_text(msg, true, NULL, 0);
 			idx = log_next(idx);
 			seq++;
 		}
@@ -1368,12 +1327,10 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		/* move first record forward until length fits into the buffer */
 		seq = clear_seq;
 		idx = clear_idx;
-		prev = 0;
 		while (len > size && seq < log_next_seq) {
 			struct printk_log *msg = log_from_idx(idx);
 
-			len -= msg_print_text(msg, prev, true, NULL, 0);
-			prev = msg->flags;
+			len -= msg_print_text(msg, true, NULL, 0);
 			idx = log_next(idx);
 			seq++;
 		}
@@ -1386,7 +1343,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 			struct printk_log *msg = log_from_idx(idx);
 			int textlen;
 
-			textlen = msg_print_text(msg, prev, true, text,
+			textlen = msg_print_text(msg, true, text,
 						 LOG_LINE_MAX + PREFIX_MAX);
 			if (textlen < 0) {
 				len = textlen;
@@ -1394,7 +1351,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 			}
 			idx = log_next(idx);
 			seq++;
-			prev = msg->flags;
 
 			raw_spin_unlock_irq(&logbuf_lock);
 			if (copy_to_user(buf + len, text, textlen))
@@ -1407,7 +1363,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 				/* messages are gone, move to next one */
 				seq = log_first_seq;
 				idx = log_first_idx;
-				prev = 0;
 			}
 		}
 	}
@@ -1508,7 +1463,6 @@ int do_syslog(int type, char __user *buf, int len, int source)
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
 			syslog_idx = log_first_idx;
-			syslog_prev = 0;
 			syslog_partial = 0;
 		}
 		if (source == SYSLOG_FROM_PROC) {
@@ -1521,16 +1475,14 @@ int do_syslog(int type, char __user *buf, int len, int source)
 		} else {
 			u64 seq = syslog_seq;
 			u32 idx = syslog_idx;
-			enum log_flags prev = syslog_prev;
 
 			error = 0;
 			while (seq < log_next_seq) {
 				struct printk_log *msg = log_from_idx(idx);
 
-				error += msg_print_text(msg, prev, true, NULL, 0);
+				error += msg_print_text(msg, true, NULL, 0);
 				idx = log_next(idx);
 				seq++;
-				prev = msg->flags;
 			}
 			error -= syslog_partial;
 		}
@@ -1712,7 +1664,7 @@ static size_t cont_print_text(char *text, size_t size)
 	size_t textlen = 0;
 	size_t len;
 
-	if (cont.cons == 0 && (console_prev & LOG_NEWLINE)) {
+	if (cont.cons == 0) {
 		textlen += print_time(cont.ts_nsec, text);
 		size -= textlen;
 	}
@@ -1981,11 +1933,9 @@ static u64 syslog_seq;
 static u32 syslog_idx;
 static u64 console_seq;
 static u32 console_idx;
-static enum log_flags syslog_prev;
 static u64 log_first_seq;
 static u32 log_first_idx;
 static u64 log_next_seq;
-static enum log_flags console_prev;
 static struct cont {
 	size_t len;
 	size_t cons;
@@ -1997,15 +1947,15 @@ static char *log_dict(const struct printk_log *msg) { return NULL; }
 static struct printk_log *log_from_idx(u32 idx) { return NULL; }
 static u32 log_next(u32 idx) { return 0; }
 static ssize_t msg_print_ext_header(char *buf, size_t size,
-				    struct printk_log *msg, u64 seq,
-				    enum log_flags prev_flags) { return 0; }
+				    struct printk_log *msg,
+				    u64 seq) { return 0; }
 static ssize_t msg_print_ext_body(char *buf, size_t size,
 				  char *dict, size_t dict_len,
 				  char *text, size_t text_len) { return 0; }
 static void call_console_drivers(int level,
 				 const char *ext_text, size_t ext_len,
 				 const char *text, size_t len) {}
-static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
+static size_t msg_print_text(const struct printk_log *msg,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static size_t cont_print_text(char *text, size_t size) { return 0; }
 static bool suppress_message_printing(int level) { return false; }
@@ -2382,7 +2332,6 @@ void console_unlock(void)
 			/* messages are gone, move to first one */
 			console_seq = log_first_seq;
 			console_idx = log_first_idx;
-			console_prev = 0;
 		} else {
 			len = 0;
 		}
@@ -2407,16 +2356,14 @@ void console_unlock(void)
 			 * will properly dump everything later.
 			 */
 			msg->flags &= ~LOG_NOCONS;
-			console_prev = msg->flags;
 			goto skip;
 		}
 
-		len += msg_print_text(msg, console_prev, false,
-				      text + len, sizeof(text) - len);
+		len += msg_print_text(msg, false, text + len, sizeof(text) - len);
 		if (nr_ext_console_drivers) {
 			ext_len = msg_print_ext_header(ext_text,
 						sizeof(ext_text),
-						msg, console_seq, console_prev);
+						msg, console_seq);
 			ext_len += msg_print_ext_body(ext_text + ext_len,
 						sizeof(ext_text) - ext_len,
 						log_dict(msg), msg->dict_len,
@@ -2424,7 +2371,6 @@ void console_unlock(void)
 		}
 		console_idx = log_next(console_idx);
 		console_seq++;
-		console_prev = msg->flags;
 		raw_spin_unlock(&logbuf_lock);
 
 		stop_critical_timings();	/* don't trace print latency */
@@ -2719,7 +2665,6 @@ void register_console(struct console *newcon)
 		raw_spin_lock_irqsave(&logbuf_lock, flags);
 		console_seq = syslog_seq;
 		console_idx = syslog_idx;
-		console_prev = syslog_prev;
 		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
 		/*
 		 * We're about to replay the log buffer.  Only do this to the
@@ -3075,7 +3020,7 @@ bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 		goto out;
 
 	msg = log_from_idx(dumper->cur_idx);
-	l = msg_print_text(msg, 0, syslog, line, size);
+	l = msg_print_text(msg, syslog, line, size);
 
 	dumper->cur_idx = log_next(dumper->cur_idx);
 	dumper->cur_seq++;
@@ -3144,7 +3089,6 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	u32 idx;
 	u64 next_seq;
 	u32 next_idx;
-	enum log_flags prev;
 	size_t l = 0;
 	bool ret = false;
 
@@ -3167,27 +3111,23 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	/* calculate length of entire buffer */
 	seq = dumper->cur_seq;
 	idx = dumper->cur_idx;
-	prev = 0;
 	while (seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l += msg_print_text(msg, prev, true, NULL, 0);
+		l += msg_print_text(msg, true, NULL, 0);
 		idx = log_next(idx);
 		seq++;
-		prev = msg->flags;
 	}
 
 	/* move first record forward until length fits into the buffer */
 	seq = dumper->cur_seq;
 	idx = dumper->cur_idx;
-	prev = 0;
 	while (l > size && seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l -= msg_print_text(msg, prev, true, NULL, 0);
+		l -= msg_print_text(msg, true, NULL, 0);
 		idx = log_next(idx);
 		seq++;
-		prev = msg->flags;
 	}
 
 	/* last message in next interation */
@@ -3198,10 +3138,9 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	while (seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 
-		l += msg_print_text(msg, prev, syslog, buf + l, size - l);
+		l += msg_print_text(msg, syslog, buf + l, size - l);
 		idx = log_next(idx);
 		seq++;
-		prev = msg->flags;
 	}
 
 	dumper->next_seq = next_seq;

commit 34aaff40b42148b23dcde40152480e25c7d2d759
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Dec 14 15:05:58 2016 -0800

    kdb: call vkdb_printf() from vprintk_default() only when wanted
    
    kdb_trap_printk allows to pass normal printk() messages to kdb via
    vkdb_printk().  For example, it is used to get backtrace using the
    classic show_stack(), see kdb_show_stack().
    
    vkdb_printf() tries to avoid a potential infinite loop by disabling the
    trap.  But this approach is racy, for example:
    
    CPU1                                    CPU2
    
    vkdb_printf()
      // assume that kdb_trap_printk == 0
      saved_trap_printk = kdb_trap_printk;
      kdb_trap_printk = 0;
    
                                            kdb_show_stack()
                                              kdb_trap_printk++;
    
    Problem1: Now, a nested printk() on CPU0 calls vkdb_printf()
              even when it should have been disabled. It will not
              cause a deadlock but...
    
       // using the outdated saved value: 0
       kdb_trap_printk = saved_trap_printk;
    
                                              kdb_trap_printk--;
    
    Problem2: Now, kdb_trap_printk == -1 and will stay like this.
       It means that all messages will get passed to kdb from
       now on.
    
    This patch removes the racy saved_trap_printk handling.  Instead, the
    recursion is prevented by a check for the locked CPU.
    
    The solution is still kind of racy.  A non-related printk(), from
    another process, might get trapped by vkdb_printf().  And the wanted
    printk() might not get trapped because kdb_printf_cpu is assigned.  But
    this problem existed even with the original code.
    
    A proper solution would be to get_cpu() before setting kdb_trap_printk
    and trap messages only from this CPU.  I am not sure if it is worth the
    effort, though.
    
    In fact, the race is very theoretical.  When kdb is running any of the
    commands that use kdb_trap_printk there is a single active CPU and the
    other CPUs should be in a holding pen inside kgdb_cpu_enter().
    
    The only time this is violated is when there is a timeout waiting for
    the other CPUs to report to the holding pen.
    
    Finally, note that the situation is a bit schizophrenic.  vkdb_printf()
    explicitly allows recursion but only from KDB code that calls
    kdb_printf() directly.  On the other hand, the generic printk()
    recursion is not allowed because it might cause an infinite loop.  This
    is why we could not hide the decision inside vkdb_printf() easily.
    
    Link: http://lkml.kernel.org/r/1480412276-16690-4-git-send-email-pmladek@suse.com
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 577f2288d19f..a3ce35e0fa1e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1926,7 +1926,8 @@ int vprintk_default(const char *fmt, va_list args)
 	int r;
 
 #ifdef CONFIG_KGDB_KDB
-	if (unlikely(kdb_trap_printk)) {
+	/* Allow to pass printk() to kdb but avoid a recursion. */
+	if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {
 		r = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
 		return r;
 	}

commit e71c3978d6f97659f6c3ee942c3e581299e4adf2
Merge: f797484c2630 b18cc3de00ec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 12 19:25:04 2016 -0800

    Merge branch 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull smp hotplug updates from Thomas Gleixner:
     "This is the final round of converting the notifier mess to the state
      machine. The removal of the notifiers and the related infrastructure
      will happen around rc1, as there are conversions outstanding in other
      trees.
    
      The whole exercise removed about 2000 lines of code in total and in
      course of the conversion several dozen bugs got fixed. The new
      mechanism allows to test almost every hotplug step standalone, so
      usage sites can exercise all transitions extensively.
    
      There is more room for improvement, like integrating all the
      pointlessly different architecture mechanisms of synchronizing,
      setting cpus online etc into the core code"
    
    * 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (60 commits)
      tracing/rb: Init the CPU mask on allocation
      soc/fsl/qbman: Convert to hotplug state machine
      soc/fsl/qbman: Convert to hotplug state machine
      zram: Convert to hotplug state machine
      KVM/PPC/Book3S HV: Convert to hotplug state machine
      arm64/cpuinfo: Convert to hotplug state machine
      arm64/cpuinfo: Make hotplug notifier symmetric
      mm/compaction: Convert to hotplug state machine
      iommu/vt-d: Convert to hotplug state machine
      mm/zswap: Convert pool to hotplug state machine
      mm/zswap: Convert dst-mem to hotplug state machine
      mm/zsmalloc: Convert to hotplug state machine
      mm/vmstat: Convert to hotplug state machine
      mm/vmstat: Avoid on each online CPU loops
      mm/vmstat: Drop get_online_cpus() from init_cpu_node_state/vmstat_cpu_dead()
      tracing/rb: Convert to hotplug state machine
      oprofile/nmi timer: Convert to hotplug state machine
      net/iucv: Use explicit clean up labels in iucv_init()
      x86/pci/amd-bus: Convert to hotplug state machine
      x86/oprofile/nmi: Convert to hotplug state machine
      ...

commit cbbd26b8b1a6af9c02e2b6523e12bd50cc765059
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 1 22:09:04 2016 -0400

    [iov_iter] new primitives - copy_from_iter_full() and friends
    
    copy_from_iter_full(), copy_from_iter_full_nocache() and
    csum_and_copy_from_iter_full() - counterparts of copy_from_iter()
    et.al., advancing iterator only in case of successful full copy
    and returning whether it had been successful or not.
    
    Convert some obvious users.  *NOTE* - do not blindly assume that
    something is a good candidate for those unless you are sure that
    not advancing iov_iter in failure case is the right thing in
    this case.  Anything that does short read/short write kind of
    stuff (or is in a loop, etc.) is unlikely to be a good one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f7a55e9ff2f7..f6bda15396df 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -748,7 +748,7 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 		return -ENOMEM;
 
 	buf[len] = '\0';
-	if (copy_from_iter(buf, len, from) != len) {
+	if (!copy_from_iter_full(buf, len, from)) {
 		kfree(buf);
 		return -EFAULT;
 	}

commit f97960fbddd98e1b7bfba469b8510b49a62b4bc5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 17 17:31:55 2016 +0100

    kernel/printk: Block cpuhotplug callback when tasks are frozen
    
    The recent conversion of the console hotplug notifier to the state machine
    missed the fact, that the notifier only operated on the non frozen
    transitions. As a consequence the console_lock/unlock() pair is also
    invoked during suspend, which results in a lockdep warning.
    
    Restore the previous state by making the lock/unlock conditional on
    !tasks_frozen.
    
    Fixes: 90b14889d2f9 ("kernel/printk: Convert to hotplug state machine")
    Reported-and-tested-by: Borislav Petkov <bp@alien8.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1611171729320.3645@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4487ffcd42d5..37893da9bae8 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2194,8 +2194,10 @@ void resume_console(void)
  */
 static int console_cpu_notify(unsigned int cpu)
 {
-	console_lock();
-	console_unlock();
+	if (!cpuhp_tasks_frozen) {
+		console_lock();
+		console_unlock();
+	}
 	return 0;
 }
 

commit f5c9f9c72395c3291c2e35c905dedae2b98475a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 14 09:31:52 2016 -0800

    Revert "printk: make reading the kernel log flush pending lines"
    
    This reverts commit bfd8d3f23b51018388be0411ccbc2d56277fe294.
    
    It turns out that this flushes things much too aggressiverly, and causes
    lines to break up when the system logger races with new continuation
    lines being printed.
    
    There's a pending patch to make printk() flushing much more
    straightforward, but it's too invasive for 4.9, so in the meantime let's
    just not make the system message logging flush continuation lines.
    They'll be flushed by the final newline anyway.
    
    Suggested-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5028f4fd504a..f7a55e9ff2f7 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -783,8 +783,6 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 	return ret;
 }
 
-static void cont_flush(void);
-
 static ssize_t devkmsg_read(struct file *file, char __user *buf,
 			    size_t count, loff_t *ppos)
 {
@@ -800,7 +798,6 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	if (ret)
 		return ret;
 	raw_spin_lock_irq(&logbuf_lock);
-	cont_flush();
 	while (user->seq == log_next_seq) {
 		if (file->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
@@ -863,7 +860,6 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 		return -ESPIPE;
 
 	raw_spin_lock_irq(&logbuf_lock);
-	cont_flush();
 	switch (whence) {
 	case SEEK_SET:
 		/* the first record */
@@ -902,7 +898,6 @@ static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
 	poll_wait(file, &log_wait, wait);
 
 	raw_spin_lock_irq(&logbuf_lock);
-	cont_flush();
 	if (user->seq < log_next_seq) {
 		/* return error when data has vanished underneath us */
 		if (user->seq < log_first_seq)
@@ -1289,7 +1284,6 @@ static int syslog_print(char __user *buf, int size)
 		size_t skip;
 
 		raw_spin_lock_irq(&logbuf_lock);
-		cont_flush();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -1349,7 +1343,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		return -ENOMEM;
 
 	raw_spin_lock_irq(&logbuf_lock);
-	cont_flush();
 	if (buf) {
 		u64 next_seq;
 		u64 seq;
@@ -1511,7 +1504,6 @@ int do_syslog(int type, char __user *buf, int len, int source)
 	/* Number of chars in the log buffer */
 	case SYSLOG_ACTION_SIZE_UNREAD:
 		raw_spin_lock_irq(&logbuf_lock);
-		cont_flush();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -3028,7 +3020,6 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 		dumper->active = true;
 
 		raw_spin_lock_irqsave(&logbuf_lock, flags);
-		cont_flush();
 		dumper->cur_seq = clear_seq;
 		dumper->cur_idx = clear_idx;
 		dumper->next_seq = log_next_seq;
@@ -3119,7 +3110,6 @@ bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
 	bool ret;
 
 	raw_spin_lock_irqsave(&logbuf_lock, flags);
-	cont_flush();
 	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
 	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
 
@@ -3162,7 +3152,6 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 		goto out;
 
 	raw_spin_lock_irqsave(&logbuf_lock, flags);
-	cont_flush();
 	if (dumper->cur_seq < log_first_seq) {
 		/* messages are gone, move to first available one */
 		dumper->cur_seq = log_first_seq;

commit c6c7d83b9c9e6a8b3e6d84c820ac61fbffc9e396
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Nov 10 10:46:26 2016 -0800

    Revert "console: don't prefer first registered if DT specifies stdout-path"
    
    This reverts commit 05fd007e4629 ("console: don't prefer first
    registered if DT specifies stdout-path").
    
    The reverted commit changes existing behavior on which many ARM boards
    rely.  Many ARM small-board-computers, like e.g.  the Raspberry Pi have
    both a video output and a serial console.  Depending on whether the user
    is using the device as a more regular computer; or as a headless device
    we need to have the console on either one or the other.
    
    Many users rely on the kernel behavior of the console being present on
    both outputs, before the reverted commit the console setup with no
    console= kernel arguments on an ARM board which sets stdout-path in dt
    would look like this:
    
      [root@localhost ~]# cat /proc/consoles
      ttyS0                -W- (EC p a)    4:64
      tty0                 -WU (E  p  )    4:1
    
    Where as after the reverted commit, it looks like this:
    
      [root@localhost ~]# cat /proc/consoles
      ttyS0                -W- (EC p a)    4:64
    
    This commit reverts commit 05fd007e4629 ("console: don't prefer first
    registered if DT specifies stdout-path") restoring the original
    behavior.
    
    Fixes: 05fd007e4629 ("console: don't prefer first registered if DT specifies stdout-path")
    Link: http://lkml.kernel.org/r/20161104121135.4780-2-hdegoede@redhat.com
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Thorsten Leemhuis <regressions@leemhuis.info>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index de08fc90baaf..5028f4fd504a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -253,17 +253,6 @@ static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
-#ifdef CONFIG_OF
-static bool of_specified_console;
-
-void console_set_by_of(void)
-{
-	of_specified_console = true;
-}
-#else
-# define of_specified_console false
-#endif
-
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
@@ -2657,7 +2646,7 @@ void register_console(struct console *newcon)
 	 *	didn't select a console we take the first one
 	 *	that registers here.
 	 */
-	if (preferred_console < 0 && !of_specified_console) {
+	if (preferred_console < 0) {
 		if (newcon->index < 0)
 			newcon->index = 0;
 		if (newcon->setup == NULL ||

commit 90b14889d2f9b29d7e5b4b2d36251c13ce3dd13f
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Nov 3 15:49:58 2016 +0100

    kernel/printk: Convert to hotplug state machine
    
    Install the callbacks via the state machine.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20161103145021.28528-3-bigeasy@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index de08fc90baaf..4487ffcd42d5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2185,27 +2185,18 @@ void resume_console(void)
 
 /**
  * console_cpu_notify - print deferred console messages after CPU hotplug
- * @self: notifier struct
- * @action: CPU hotplug event
- * @hcpu: unused
+ * @cpu: unused
  *
  * If printk() is called from a CPU that is not online yet, the messages
  * will be spooled but will not show up on the console.  This function is
  * called when a new CPU comes online (or fails to come up), and ensures
  * that any such output gets printed.
  */
-static int console_cpu_notify(struct notifier_block *self,
-	unsigned long action, void *hcpu)
-{
-	switch (action) {
-	case CPU_ONLINE:
-	case CPU_DEAD:
-	case CPU_DOWN_FAILED:
-	case CPU_UP_CANCELED:
-		console_lock();
-		console_unlock();
-	}
-	return NOTIFY_OK;
+static int console_cpu_notify(unsigned int cpu)
+{
+	console_lock();
+	console_unlock();
+	return 0;
 }
 
 /**
@@ -2843,6 +2834,7 @@ EXPORT_SYMBOL(unregister_console);
 static int __init printk_late_init(void)
 {
 	struct console *con;
+	int ret;
 
 	for_each_console(con) {
 		if (!keep_bootcon && con->flags & CON_BOOT) {
@@ -2857,7 +2849,12 @@ static int __init printk_late_init(void)
 				unregister_console(con);
 		}
 	}
-	hotcpu_notifier(console_cpu_notify, 0);
+	ret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, "printk:dead", NULL,
+					console_cpu_notify);
+	WARN_ON(ret < 0);
+	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, "printk:online",
+					console_cpu_notify, NULL);
+	WARN_ON(ret < 0);
 	return 0;
 }
 late_initcall(printk_late_init);

commit 8835ca59dac2bc1e0136791abf3ccd51588803ce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 19 09:11:24 2016 -0700

    printk: suppress empty continuation lines
    
    We have a fairly common pattern where you print several things as
    continuations on one single line in a loop, and then at the end you do
    
            printk(KERN_CONT "\n");
    
    to flush the buffered output.
    
    But if the output was flushed by something else (concurrent printk
    activity, or just system logging), we don't want that final flushing to
    just print an empty line.
    
    So just suppress empty continuation lines when they couldn't be merged
    into the line they are a continuation of.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d5e397315473..de08fc90baaf 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1769,6 +1769,10 @@ static size_t log_output(int facility, int level, enum log_flags lflags, const c
 		cont_flush();
 	}
 
+	/* Skip empty continuation lines that couldn't be added - they just flush */
+	if (!text_len && (lflags & LOG_CONT))
+		return 0;
+
 	/* If it doesn't end in a newline, try to buffer the current line */
 	if (!(lflags & LOG_NEWLINE)) {
 		if (cont_add(facility, level, lflags, text, text_len))

commit 563873318d328d9bbab4b00dfd835ac7c7e28697
Merge: 24532f768121 bfd8d3f23b51
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 09:29:50 2016 -0700

    Merge branch 'printk-cleanups'
    
    Merge my system logging cleanups, triggered by the broken '\n' patches.
    
    The line continuation handling has been broken basically forever, and
    the code to handle the system log records was both confusing and
    dubious.  And it would do entirely the wrong thing unless you always had
    a terminating newline, partly because it couldn't actually see whether a
    message was marked KERN_CONT or not (but partly because the LOG_CONT
    handling in the recording code was rather confusing too).
    
    This re-introduces a real semantically meaningful KERN_CONT, and fixes
    the few places I noticed where it was missing.  There are probably more
    missing cases, since KERN_CONT hasn't actually had any semantic meaning
    for at least four years (other than the checkpatch meaning of "no log
    level necessary, this is a continuation line").
    
    This also allows the combination of KERN_CONT and a log level.  In that
    case the log level will be ignored if the merging with a previous line
    is successful, but if a new record is needed, that new record will now
    get the right log level.
    
    That also means that you can at least in theory combine KERN_CONT with
    the "pr_info()" style helpers, although any use of pr_fmt() prefixing
    would make that just result in a mess, of course (the prefix would end
    up in the middle of a continuing line).
    
    * printk-cleanups:
      printk: make reading the kernel log flush pending lines
      printk: re-organize log_output() to be more legible
      printk: split out core logging code into helper function
      printk: reinstate KERN_CONT for printing continuation lines

commit bfd8d3f23b51018388be0411ccbc2d56277fe294
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 9 12:16:57 2016 -0700

    printk: make reading the kernel log flush pending lines
    
    That will mean that any possible subsequent continuation will now be
    broken up onto a line of its own (since reading the log has finalized
    the beginning og the line), but if user space has activated system
    logging (or if there's a kernel message dump going on) that is the right
    thing to do.
    
    And now that we actually get the continuation flags _right_ for this
    all, the user space logger that is reading the kernel messages can
    actually see the continuation marker.  Not that anybody seems to really
    bother with it (or care), but in theory user space can do its own
    message stitching.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f6fe60d725dd..170d3a8040f4 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -783,6 +783,8 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 	return ret;
 }
 
+static void cont_flush(void);
+
 static ssize_t devkmsg_read(struct file *file, char __user *buf,
 			    size_t count, loff_t *ppos)
 {
@@ -798,6 +800,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	if (ret)
 		return ret;
 	raw_spin_lock_irq(&logbuf_lock);
+	cont_flush();
 	while (user->seq == log_next_seq) {
 		if (file->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
@@ -860,6 +863,7 @@ static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
 		return -ESPIPE;
 
 	raw_spin_lock_irq(&logbuf_lock);
+	cont_flush();
 	switch (whence) {
 	case SEEK_SET:
 		/* the first record */
@@ -898,6 +902,7 @@ static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
 	poll_wait(file, &log_wait, wait);
 
 	raw_spin_lock_irq(&logbuf_lock);
+	cont_flush();
 	if (user->seq < log_next_seq) {
 		/* return error when data has vanished underneath us */
 		if (user->seq < log_first_seq)
@@ -1284,6 +1289,7 @@ static int syslog_print(char __user *buf, int size)
 		size_t skip;
 
 		raw_spin_lock_irq(&logbuf_lock);
+		cont_flush();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -1343,6 +1349,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		return -ENOMEM;
 
 	raw_spin_lock_irq(&logbuf_lock);
+	cont_flush();
 	if (buf) {
 		u64 next_seq;
 		u64 seq;
@@ -1504,6 +1511,7 @@ int do_syslog(int type, char __user *buf, int len, int source)
 	/* Number of chars in the log buffer */
 	case SYSLOG_ACTION_SIZE_UNREAD:
 		raw_spin_lock_irq(&logbuf_lock);
+		cont_flush();
 		if (syslog_seq < log_first_seq) {
 			/* messages are gone, move to first one */
 			syslog_seq = log_first_seq;
@@ -3016,6 +3024,7 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 		dumper->active = true;
 
 		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		cont_flush();
 		dumper->cur_seq = clear_seq;
 		dumper->cur_idx = clear_idx;
 		dumper->next_seq = log_next_seq;
@@ -3106,6 +3115,7 @@ bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
 	bool ret;
 
 	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	cont_flush();
 	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
 	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
 
@@ -3148,6 +3158,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 		goto out;
 
 	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	cont_flush();
 	if (dumper->cur_seq < log_first_seq) {
 		/* messages are gone, move to first available one */
 		dumper->cur_seq = log_first_seq;

commit 5e467652ffefb84b1159d5d8fda665c48e5fd840
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 9 11:53:00 2016 -0700

    printk: re-organize log_output() to be more legible
    
    Avoid some duplicate logic now that we can return early, and update the
    comments for the new LOG_CONT world order.
    
    This also stops the continuation flushing from just using random record
    flags for the flushing action, instead taking the flags from the proper
    original line and updating them as we add continuations to it.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 090e201244d8..f6fe60d725dd 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1640,35 +1640,33 @@ static struct cont {
 	bool flushed:1;			/* buffer sealed and committed */
 } cont;
 
-static void cont_flush(enum log_flags flags)
+static void cont_flush(void)
 {
 	if (cont.flushed)
 		return;
 	if (cont.len == 0)
 		return;
-
 	if (cont.cons) {
 		/*
 		 * If a fragment of this line was directly flushed to the
 		 * console; wait for the console to pick up the rest of the
 		 * line. LOG_NOCONS suppresses a duplicated output.
 		 */
-		log_store(cont.facility, cont.level, flags | LOG_NOCONS,
+		log_store(cont.facility, cont.level, cont.flags | LOG_NOCONS,
 			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
-		cont.flags = flags;
 		cont.flushed = true;
 	} else {
 		/*
 		 * If no fragment of this line ever reached the console,
 		 * just submit it to the store and free the buffer.
 		 */
-		log_store(cont.facility, cont.level, flags, 0,
+		log_store(cont.facility, cont.level, cont.flags, 0,
 			  NULL, 0, cont.buf, cont.len);
 		cont.len = 0;
 	}
 }
 
-static bool cont_add(int facility, int level, const char *text, size_t len)
+static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)
 {
 	if (cont.len && cont.flushed)
 		return false;
@@ -1679,7 +1677,7 @@ static bool cont_add(int facility, int level, const char *text, size_t len)
 	 * the line gets too long, split it up in separate records.
 	 */
 	if (nr_ext_console_drivers || cont.len + len > sizeof(cont.buf)) {
-		cont_flush(LOG_CONT);
+		cont_flush();
 		return false;
 	}
 
@@ -1688,7 +1686,7 @@ static bool cont_add(int facility, int level, const char *text, size_t len)
 		cont.level = level;
 		cont.owner = current;
 		cont.ts_nsec = local_clock();
-		cont.flags = 0;
+		cont.flags = flags;
 		cont.cons = 0;
 		cont.flushed = false;
 	}
@@ -1696,8 +1694,15 @@ static bool cont_add(int facility, int level, const char *text, size_t len)
 	memcpy(cont.buf + cont.len, text, len);
 	cont.len += len;
 
+	// The original flags come from the first line,
+	// but later continuations can add a newline.
+	if (flags & LOG_NEWLINE) {
+		cont.flags |= LOG_NEWLINE;
+		cont_flush();
+	}
+
 	if (cont.len > (sizeof(cont.buf) * 80) / 100)
-		cont_flush(LOG_CONT);
+		cont_flush();
 
 	return true;
 }
@@ -1732,39 +1737,26 @@ static size_t cont_print_text(char *text, size_t size)
 
 static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
 {
-	if (!(lflags & LOG_NEWLINE)) {
-		/*
-		 * Flush the conflicting buffer. An earlier newline was missing,
-		 * or another task also prints continuation lines.
-		 */
-		if (cont.len && (!(lflags & LOG_CONT) || cont.owner != current))
-			cont_flush(LOG_NEWLINE);
-
-		/* buffer line if possible, otherwise store it right away */
-		if (cont_add(facility, level, text, text_len))
-			return text_len;
-
-		return log_store(facility, level, lflags | LOG_CONT, 0, dict, dictlen, text, text_len);
-	}
-
 	/*
-	 * If an earlier newline was missing and it was the same task,
-	 * either merge it with the current buffer and flush, or if
-	 * there was a race with interrupts (prefix == true) then just
-	 * flush it out and store this line separately.
-	 * If the preceding printk was from a different task and missed
-	 * a newline, flush and append the newline.
+	 * If an earlier line was buffered, and we're a continuation
+	 * write from the same process, try to add it to the buffer.
 	 */
 	if (cont.len) {
-		bool stored = false;
+		if (cont.owner == current && (lflags & LOG_CONT)) {
+			if (cont_add(facility, level, lflags, text, text_len))
+				return text_len;
+		}
+		/* Otherwise, make sure it's flushed */
+		cont_flush();
+	}
 
-		if (cont.owner == current && (lflags & LOG_CONT))
-			stored = cont_add(facility, level, text, text_len);
-		cont_flush(LOG_NEWLINE);
-		if (stored)
+	/* If it doesn't end in a newline, try to buffer the current line */
+	if (!(lflags & LOG_NEWLINE)) {
+		if (cont_add(facility, level, lflags, text, text_len))
 			return text_len;
 	}
 
+	/* Store it in the record log */
 	return log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);
 }
 

commit c362c7ff84634390b44cc1ae7808519596de162d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 8 22:02:09 2016 -0700

    printk: split out core logging code into helper function
    
    The code that actually decides how to log the message (whether to put it
    directly into the record log, whether to append it to an existing
    buffered log, or whether to start a new buffered log) is fairly
    non-obvious code in the middle of the vprintk_emit() function.
    
    Splitting that code up into a helper function makes it easier to
    understand, but perhaps more importantly also allows for the code to
    just return early out of the helper function once it has made the
    decision about where the new log content goes.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 7b449802089a..090e201244d8 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1730,6 +1730,44 @@ static size_t cont_print_text(char *text, size_t size)
 	return textlen;
 }
 
+static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
+{
+	if (!(lflags & LOG_NEWLINE)) {
+		/*
+		 * Flush the conflicting buffer. An earlier newline was missing,
+		 * or another task also prints continuation lines.
+		 */
+		if (cont.len && (!(lflags & LOG_CONT) || cont.owner != current))
+			cont_flush(LOG_NEWLINE);
+
+		/* buffer line if possible, otherwise store it right away */
+		if (cont_add(facility, level, text, text_len))
+			return text_len;
+
+		return log_store(facility, level, lflags | LOG_CONT, 0, dict, dictlen, text, text_len);
+	}
+
+	/*
+	 * If an earlier newline was missing and it was the same task,
+	 * either merge it with the current buffer and flush, or if
+	 * there was a race with interrupts (prefix == true) then just
+	 * flush it out and store this line separately.
+	 * If the preceding printk was from a different task and missed
+	 * a newline, flush and append the newline.
+	 */
+	if (cont.len) {
+		bool stored = false;
+
+		if (cont.owner == current && (lflags & LOG_CONT))
+			stored = cont_add(facility, level, text, text_len);
+		cont_flush(LOG_NEWLINE);
+		if (stored)
+			return text_len;
+	}
+
+	return log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);
+}
+
 asmlinkage int vprintk_emit(int facility, int level,
 			    const char *dict, size_t dictlen,
 			    const char *fmt, va_list args)
@@ -1842,45 +1880,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (dict)
 		lflags |= LOG_PREFIX|LOG_NEWLINE;
 
-	if (!(lflags & LOG_NEWLINE)) {
-		/*
-		 * Flush the conflicting buffer. An earlier newline was missing,
-		 * or another task also prints continuation lines.
-		 */
-		if (cont.len && (!(lflags & LOG_CONT) || cont.owner != current))
-			cont_flush(LOG_NEWLINE);
-
-		/* buffer line if possible, otherwise store it right away */
-		if (cont_add(facility, level, text, text_len))
-			printed_len += text_len;
-		else
-			printed_len += log_store(facility, level,
-						 lflags | LOG_CONT, 0,
-						 dict, dictlen, text, text_len);
-	} else {
-		bool stored = false;
-
-		/*
-		 * If an earlier newline was missing and it was the same task,
-		 * either merge it with the current buffer and flush, or if
-		 * there was a race with interrupts (prefix == true) then just
-		 * flush it out and store this line separately.
-		 * If the preceding printk was from a different task and missed
-		 * a newline, flush and append the newline.
-		 */
-		if (cont.len) {
-			if (cont.owner == current && (lflags & LOG_CONT))
-				stored = cont_add(facility, level, text,
-						  text_len);
-			cont_flush(LOG_NEWLINE);
-		}
-
-		if (stored)
-			printed_len += text_len;
-		else
-			printed_len += log_store(facility, level, lflags, 0,
-						 dict, dictlen, text, text_len);
-	}
+	printed_len += log_output(facility, level, lflags, dict, dictlen, text, text_len);
 
 	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);

commit 4bcc595ccd80decb4245096e3d1258989c50ed41
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 8 20:32:40 2016 -0700

    printk: reinstate KERN_CONT for printing continuation lines
    
    Long long ago the kernel log buffer was a buffered stream of bytes, very
    much like stdio in user space.  It supported log levels by scanning the
    stream and noticing the log level markers at the beginning of each line,
    but if you wanted to print a partial line in multiple chunks, you just
    did multiple printk() calls, and it just automatically worked.
    
    Except when it didn't, and you had very confusing output when different
    lines got all mixed up with each other.  Then you got fragment lines
    mixing with each other, or with non-fragment lines, because it was
    traditionally impossible to tell whether a printk() call was a
    continuation or not.
    
    To at least help clarify the issue of continuation lines, we added a
    KERN_CONT marker back in 2007 to mark continuation lines:
    
      474925277671 ("printk: add KERN_CONT annotation").
    
    That continuation marker was initially an empty string, and didn't
    actuall make any semantic difference.  But it at least made it possible
    to annotate the source code, and have check-patch notice that a printk()
    didn't need or want a log level marker, because it was a continuation of
    a previous line.
    
    To avoid the ambiguity between a continuation line that had that
    KERN_CONT marker, and a printk with no level information at all, we then
    in 2009 made KERN_CONT be a real log level marker which meant that we
    could now reliably tell the difference between the two cases.
    
      5fd29d6ccbc9 ("printk: clean up handling of log-levels and newlines")
    
    and we could take advantage of that to make sure we didn't mix up
    continuation lines with lines that just didn't have any loglevel at all.
    
    Then, in 2012, the kernel log buffer was changed to be a "record" based
    log, where each line was a record that has a loglevel and a timestamp.
    
    You can see the beginning of that conversion in commits
    
      e11fea92e13f ("kmsg: export printk records to the /dev/kmsg interface")
      7ff9554bb578 ("printk: convert byte-buffer to variable-length record buffer")
    
    with a number of follow-up commits to fix some painful fallout from that
    conversion.  Over all, it took a couple of months to sort out most of
    it.  But the upside was that you could have concurrent readers (and
    writers) of the kernel log and not have lines with mixed output in them.
    
    And one particular pain-point for the record-based kernel logging was
    exactly the fragmentary lines that are generated in smaller chunks.  In
    order to still log them as one recrod, the continuation lines need to be
    attached to the previous record properly.
    
    However the explicit continuation record marker that is actually useful
    for this exact case was actually removed in aroundm the same time by commit
    
      61e99ab8e35a ("printk: remove the now unnecessary "C" annotation for KERN_CONT")
    
    due to the incorrect belief that KERN_CONT wasn't meaningful.  The
    ambiguity between "is this a continuation line" or "is this a plain
    printk with no log level information" was reintroduced, and in fact
    became an even bigger pain point because there was now the whole
    record-level merging of kernel messages going on.
    
    This patch reinstates the KERN_CONT as a real non-empty string marker,
    so that the ambiguity is fixed once again.
    
    But it's not a plain revert of that original removal: in the four years
    since we made KERN_CONT an empty string again, not only has the format
    of the log level markers changed, we've also had some usage changes in
    this area.
    
    For example, some ACPI code seems to use KERN_CONT _together_ with a log
    level, and now uses both the KERN_CONT marker and (for example) a
    KERN_INFO marker to show that it's an informational continuation of a
    line.
    
    Which is actually not a bad idea - if the continuation line cannot be
    attached to its predecessor, without the log level information we don't
    know what log level to assign to it (and we traditionally just assigned
    it the default loglevel).  So having both a log level and the KERN_CONT
    marker is not necessarily a bad idea, but it does mean that we need to
    actually iterate over potentially multiple markers, rather than just a
    single one.
    
    Also, since KERN_CONT was still conceptually needed, and encouraged, but
    didn't actually _do_ anything, we've also had the reverse problem:
    rather than having too many annotations it has too few, and there is bit
    rot with code that no longer marks the continuation lines with the
    KERN_CONT marker.
    
    So this patch not only re-instates the non-empty KERN_CONT marker, it
    also fixes up the cases of bit-rot I noticed in my own logs.
    
    There are probably other cases where KERN_CONT will be needed to be
    added, either because it is new code that never dealt with the need for
    KERN_CONT, or old code that has bitrotted without anybody noticing.
    
    That said, we should strive to avoid the need for KERN_CONT.  It does
    result in real problems for logging, and should generally not be seen as
    a good feature.  If we some day can get rid of the feature entirely,
    because nobody does any fragmented printk calls, that would be lovely.
    
    But until that point, let's at mark the code that relies on the hacky
    multi-fragment kernel printk's.  Not only does it avoid the ambiguity,
    it also annotates code as "maybe this would be good to fix some day".
    
    (That said, particularly during single-threaded bootup, the downsides of
    KERN_CONT are very limited.  Things get much hairier when you have
    multiple threads going on and user level reading and writing logs too).
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index eea6dbc2d8cf..7b449802089a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -655,11 +655,8 @@ static ssize_t msg_print_ext_header(char *buf, size_t size,
 	 * better readable output. 'c' in the record flags mark the first
 	 * fragment of a line, '+' the following.
 	 */
-	if (msg->flags & LOG_CONT && !(prev_flags & LOG_CONT))
-		cont = 'c';
-	else if ((msg->flags & LOG_CONT) ||
-		 ((prev_flags & LOG_CONT) && !(msg->flags & LOG_PREFIX)))
-		cont = '+';
+	if (msg->flags & LOG_CONT)
+		cont = (prev_flags & LOG_CONT) ? '+' : 'c';
 
 	return scnprintf(buf, size, "%u,%llu,%llu,%c;",
 		       (msg->facility << 3) | msg->level, seq, ts_usec, cont);
@@ -1819,10 +1816,9 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	/* strip kernel syslog prefix and extract log level or control flags */
 	if (facility == 0) {
-		int kern_level = printk_get_level(text);
+		int kern_level;
 
-		if (kern_level) {
-			const char *end_of_header = printk_skip_level(text);
+		while ((kern_level = printk_get_level(text)) != 0) {
 			switch (kern_level) {
 			case '0' ... '7':
 				if (level == LOGLEVEL_DEFAULT)
@@ -1830,14 +1826,13 @@ asmlinkage int vprintk_emit(int facility, int level,
 				/* fallthrough */
 			case 'd':	/* KERN_DEFAULT */
 				lflags |= LOG_PREFIX;
+				break;
+			case 'c':	/* KERN_CONT */
+				lflags |= LOG_CONT;
 			}
-			/*
-			 * No need to check length here because vscnprintf
-			 * put '\0' at the end of the string. Only valid and
-			 * newly printed level is detected.
-			 */
-			text_len -= end_of_header - text;
-			text = (char *)end_of_header;
+
+			text_len -= 2;
+			text += 2;
 		}
 	}
 
@@ -1852,7 +1847,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * Flush the conflicting buffer. An earlier newline was missing,
 		 * or another task also prints continuation lines.
 		 */
-		if (cont.len && (lflags & LOG_PREFIX || cont.owner != current))
+		if (cont.len && (!(lflags & LOG_CONT) || cont.owner != current))
 			cont_flush(LOG_NEWLINE);
 
 		/* buffer line if possible, otherwise store it right away */
@@ -1874,7 +1869,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * a newline, flush and append the newline.
 		 */
 		if (cont.len) {
-			if (cont.owner == current && !(lflags & LOG_PREFIX))
+			if (cont.owner == current && (lflags & LOG_CONT))
 				stored = cont_add(facility, level, text,
 						  text_len);
 			cont_flush(LOG_NEWLINE);

commit 05fd007e46296afb24d15c7d589d535e5a5b9d5c
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Oct 7 17:03:15 2016 -0700

    console: don't prefer first registered if DT specifies stdout-path
    
    If a device tree specifies a preferred device for kernel console output
    via the stdout-path or linux,stdout-path chosen node properties or the
    stdout alias then the kernel ought to honor it & output the kernel
    console to that device.  As it stands, this isn't the case.  Whilst we
    parse the stdout-path properties & set an of_stdout variable from
    of_alias_scan(), and use that from of_console_check() to determine
    whether to add a console device as a preferred console whilst
    registering it, we also prefer the first registered console if no other
    has been selected at the time of its registration.
    
    This means that if a console other than the one the device tree selects
    via stdout-path is registered first, we will switch to using it & when
    the stdout-path console is later registered the call to
    add_preferred_console() via of_console_check() is too late to do
    anything useful.  In practice this seems to mean that we switch to the
    dummy console device fairly early & see no further console output:
    
        Console: colour dummy device 80x25
        console [tty0] enabled
        bootconsole [ns16550a0] disabled
    
    Fix this by not automatically preferring the first registered console if
    one is specified by the device tree.  This allows consoles to be
    registered but not enabled, and once the driver for the console selected
    by stdout-path calls of_console_check() the driver will be added to the
    list of preferred consoles before any other console has been enabled.
    When that console is then registered via register_console() it will be
    enabled as expected.
    
    Link: http://lkml.kernel.org/r/20160809151937.26118-1-paul.burton@imgtec.com
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ivan Delalande <colona@arista.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jan Kara <jack@suse.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index eea6dbc2d8cf..8019cc0d3a73 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -253,6 +253,17 @@ static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
+#ifdef CONFIG_OF
+static bool of_specified_console;
+
+void console_set_by_of(void)
+{
+	of_specified_console = true;
+}
+#else
+# define of_specified_console false
+#endif
+
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
@@ -2647,7 +2658,7 @@ void register_console(struct console *newcon)
 	 *	didn't select a console we take the first one
 	 *	that registers here.
 	 */
-	if (preferred_console < 0) {
+	if (preferred_console < 0 && !of_specified_console) {
 		if (newcon->index < 0)
 			newcon->index = 0;
 		if (newcon->setup == NULL ||

commit a0cba2179ea4c1820fce2ee046b6ed90ecc56196
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 9 10:48:18 2016 -0700

    Revert "printk: create pr_<level> functions"
    
    This reverts commit 874f9c7da9a4acbc1b9e12ca722579fb50e4d142.
    
    Geert Uytterhoeven reports:
     "This change seems to have an (unintendent?) side-effect.
    
      Before, pr_*() calls without a trailing newline characters would be
      printed with a newline character appended, both on the console and in
      the output of the dmesg command.
    
      After this commit, no new line character is appended, and the output
      of the next pr_*() call of the same type may be appended, like in:
    
        - Truncating RAM at 0x0000000040000000-0x00000000c0000000 to -0x0000000070000000
        - Ignoring RAM at 0x0000000200000000-0x0000000240000000 (!CONFIG_HIGHMEM)
        + Truncating RAM at 0x0000000040000000-0x00000000c0000000 to -0x0000000070000000Ignoring RAM at 0x0000000200000000-0x0000000240000000 (!CONFIG_HIGHMEM)"
    
    Joe Perches says:
     "No, that is not intentional.
    
      The newline handling code inside vprintk_emit is a bit involved and
      for now I suggest a revert until this has all the same behavior as
      earlier"
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Requested-by: Joe Perches <joe@perches.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a37fc8cf8e84..eea6dbc2d8cf 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1930,26 +1930,7 @@ asmlinkage int printk_emit(int facility, int level,
 }
 EXPORT_SYMBOL(printk_emit);
 
-#define define_pr_level(func, loglevel)				\
-asmlinkage __visible void func(const char *fmt, ...)		\
-{								\
-	va_list args;						\
-								\
-	va_start(args, fmt);					\
-	vprintk_default(loglevel, fmt, args);			\
-	va_end(args);						\
-}								\
-EXPORT_SYMBOL(func)
-
-define_pr_level(__pr_emerg, LOGLEVEL_EMERG);
-define_pr_level(__pr_alert, LOGLEVEL_ALERT);
-define_pr_level(__pr_crit, LOGLEVEL_CRIT);
-define_pr_level(__pr_err, LOGLEVEL_ERR);
-define_pr_level(__pr_warn, LOGLEVEL_WARNING);
-define_pr_level(__pr_notice, LOGLEVEL_NOTICE);
-define_pr_level(__pr_info, LOGLEVEL_INFO);
-
-int vprintk_default(int level, const char *fmt, va_list args)
+int vprintk_default(const char *fmt, va_list args)
 {
 	int r;
 
@@ -1959,7 +1940,7 @@ int vprintk_default(int level, const char *fmt, va_list args)
 		return r;
 	}
 #endif
-	r = vprintk_emit(0, level, NULL, 0, fmt, args);
+	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
 
 	return r;
 }
@@ -1992,7 +1973,7 @@ asmlinkage __visible int printk(const char *fmt, ...)
 	int r;
 
 	va_start(args, fmt);
-	r = vprintk_func(LOGLEVEL_DEFAULT, fmt, args);
+	r = vprintk_func(fmt, args);
 	va_end(args);
 
 	return r;

commit 574673c231a5fad1560249cc3a598907acb36cf9
Author: Andreas Ziegler <andreas.ziegler@fau.de>
Date:   Thu Aug 4 09:52:09 2016 +0200

    printk: Remove unnecessary #ifdef CONFIG_PRINTK
    
    In commit 874f9c7da9a4 ("printk: create pr_<level> functions"), new
    pr_level defines were added to printk.c.
    
    These new defines are guarded by an #ifdef CONFIG_PRINTK - however,
    there is already a surrounding #ifdef CONFIG_PRINTK starting a lot
    earlier in line 249 which means the newly introduced #ifdef is
    unnecessary.
    
    Let's remove it to avoid confusion.
    
    Signed-off-by: Andreas Ziegler <andreas.ziegler@fau.de>
    Cc: Joe Perches <joe@perches.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a5ef95ca18c9..a37fc8cf8e84 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1930,7 +1930,6 @@ asmlinkage int printk_emit(int facility, int level,
 }
 EXPORT_SYMBOL(printk_emit);
 
-#ifdef CONFIG_PRINTK
 #define define_pr_level(func, loglevel)				\
 asmlinkage __visible void func(const char *fmt, ...)		\
 {								\
@@ -1949,7 +1948,6 @@ define_pr_level(__pr_err, LOGLEVEL_ERR);
 define_pr_level(__pr_warn, LOGLEVEL_WARNING);
 define_pr_level(__pr_notice, LOGLEVEL_NOTICE);
 define_pr_level(__pr_info, LOGLEVEL_INFO);
-#endif
 
 int vprintk_default(int level, const char *fmt, va_list args)
 {

commit 750afe7babd117daabebf4855da18e4418ea845e
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Aug 2 14:04:07 2016 -0700

    printk: add kernel parameter to control writes to /dev/kmsg
    
    Add a "printk.devkmsg" kernel command line parameter which controls how
    userspace writes into /dev/kmsg.  It has three options:
    
     * ratelimit - ratelimit logging from userspace.
     * on  - unlimited logging from userspace
     * off - logging from userspace gets ignored
    
    The default setting is to ratelimit the messages written to it.
    
    This changes the kernel default setting of "on" to "ratelimit" and we do
    that because we want to keep userspace spamming /dev/kmsg to sane
    levels.  This is especially moot when a small kernel log buffer wraps
    around and messages get lost.  So the ratelimiting setting should be a
    sane setting where kernel messages should have a bit higher chance of
    survival from all the spamming.
    
    It additionally does not limit logging to /dev/kmsg while the system is
    booting if we haven't disabled it on the command line.
    
    Furthermore, we can control the logging from a lower priority sysctl
    interface - kernel.printk_devkmsg.
    
    That interface will succeed only if printk.devkmsg *hasn't* been
    supplied on the command line.  If it has, then printk.devkmsg is a
    one-time setting which remains for the duration of the system lifetime.
    This "locking" of the setting is to prevent userspace from changing the
    logging on us through sysctl(2).
    
    This patch is based on previous patches from Linus and Steven.
    
    [bp@suse.de: fixes]
      Link: http://lkml.kernel.org/r/20160719072344.GC25563@nazgul.tnic
    Link: http://lkml.kernel.org/r/20160716061745.15795-3-bp@alien8.de
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Franck Bui <fbui@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 70c66c5ba212..a5ef95ca18c9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -85,6 +85,111 @@ static struct lockdep_map console_lock_dep_map = {
 };
 #endif
 
+enum devkmsg_log_bits {
+	__DEVKMSG_LOG_BIT_ON = 0,
+	__DEVKMSG_LOG_BIT_OFF,
+	__DEVKMSG_LOG_BIT_LOCK,
+};
+
+enum devkmsg_log_masks {
+	DEVKMSG_LOG_MASK_ON             = BIT(__DEVKMSG_LOG_BIT_ON),
+	DEVKMSG_LOG_MASK_OFF            = BIT(__DEVKMSG_LOG_BIT_OFF),
+	DEVKMSG_LOG_MASK_LOCK           = BIT(__DEVKMSG_LOG_BIT_LOCK),
+};
+
+/* Keep both the 'on' and 'off' bits clear, i.e. ratelimit by default: */
+#define DEVKMSG_LOG_MASK_DEFAULT	0
+
+static unsigned int __read_mostly devkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;
+
+static int __control_devkmsg(char *str)
+{
+	if (!str)
+		return -EINVAL;
+
+	if (!strncmp(str, "on", 2)) {
+		devkmsg_log = DEVKMSG_LOG_MASK_ON;
+		return 2;
+	} else if (!strncmp(str, "off", 3)) {
+		devkmsg_log = DEVKMSG_LOG_MASK_OFF;
+		return 3;
+	} else if (!strncmp(str, "ratelimit", 9)) {
+		devkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;
+		return 9;
+	}
+	return -EINVAL;
+}
+
+static int __init control_devkmsg(char *str)
+{
+	if (__control_devkmsg(str) < 0)
+		return 1;
+
+	/*
+	 * Set sysctl string accordingly:
+	 */
+	if (devkmsg_log == DEVKMSG_LOG_MASK_ON) {
+		memset(devkmsg_log_str, 0, DEVKMSG_STR_MAX_SIZE);
+		strncpy(devkmsg_log_str, "on", 2);
+	} else if (devkmsg_log == DEVKMSG_LOG_MASK_OFF) {
+		memset(devkmsg_log_str, 0, DEVKMSG_STR_MAX_SIZE);
+		strncpy(devkmsg_log_str, "off", 3);
+	}
+	/* else "ratelimit" which is set by default. */
+
+	/*
+	 * Sysctl cannot change it anymore. The kernel command line setting of
+	 * this parameter is to force the setting to be permanent throughout the
+	 * runtime of the system. This is a precation measure against userspace
+	 * trying to be a smarta** and attempting to change it up on us.
+	 */
+	devkmsg_log |= DEVKMSG_LOG_MASK_LOCK;
+
+	return 0;
+}
+__setup("printk.devkmsg=", control_devkmsg);
+
+char devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = "ratelimit";
+
+int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,
+			      void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	char old_str[DEVKMSG_STR_MAX_SIZE];
+	unsigned int old;
+	int err;
+
+	if (write) {
+		if (devkmsg_log & DEVKMSG_LOG_MASK_LOCK)
+			return -EINVAL;
+
+		old = devkmsg_log;
+		strncpy(old_str, devkmsg_log_str, DEVKMSG_STR_MAX_SIZE);
+	}
+
+	err = proc_dostring(table, write, buffer, lenp, ppos);
+	if (err)
+		return err;
+
+	if (write) {
+		err = __control_devkmsg(devkmsg_log_str);
+
+		/*
+		 * Do not accept an unknown string OR a known string with
+		 * trailing crap...
+		 */
+		if (err < 0 || (err + 1 != *lenp)) {
+
+			/* ... and restore old setting. */
+			devkmsg_log = old;
+			strncpy(devkmsg_log_str, old_str, DEVKMSG_STR_MAX_SIZE);
+
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * Number of registered extended console drivers.
  *
@@ -613,6 +718,7 @@ struct devkmsg_user {
 	u64 seq;
 	u32 idx;
 	enum log_flags prev;
+	struct ratelimit_state rs;
 	struct mutex lock;
 	char buf[CONSOLE_EXT_LOG_MAX];
 };
@@ -622,11 +728,24 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 	char *buf, *line;
 	int level = default_message_loglevel;
 	int facility = 1;	/* LOG_USER */
+	struct file *file = iocb->ki_filp;
+	struct devkmsg_user *user = file->private_data;
 	size_t len = iov_iter_count(from);
 	ssize_t ret = len;
 
-	if (len > LOG_LINE_MAX)
+	if (!user || len > LOG_LINE_MAX)
 		return -EINVAL;
+
+	/* Ignore when user logging is disabled. */
+	if (devkmsg_log & DEVKMSG_LOG_MASK_OFF)
+		return len;
+
+	/* Ratelimit when not explicitly enabled. */
+	if (!(devkmsg_log & DEVKMSG_LOG_MASK_ON)) {
+		if (!___ratelimit(&user->rs, current->comm))
+			return ret;
+	}
+
 	buf = kmalloc(len+1, GFP_KERNEL);
 	if (buf == NULL)
 		return -ENOMEM;
@@ -799,19 +918,24 @@ static int devkmsg_open(struct inode *inode, struct file *file)
 	struct devkmsg_user *user;
 	int err;
 
-	/* write-only does not need any file context */
-	if ((file->f_flags & O_ACCMODE) == O_WRONLY)
-		return 0;
+	if (devkmsg_log & DEVKMSG_LOG_MASK_OFF)
+		return -EPERM;
 
-	err = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,
-				       SYSLOG_FROM_READER);
-	if (err)
-		return err;
+	/* write-only does not need any file context */
+	if ((file->f_flags & O_ACCMODE) != O_WRONLY) {
+		err = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,
+					       SYSLOG_FROM_READER);
+		if (err)
+			return err;
+	}
 
 	user = kmalloc(sizeof(struct devkmsg_user), GFP_KERNEL);
 	if (!user)
 		return -ENOMEM;
 
+	ratelimit_default_init(&user->rs);
+	ratelimit_set_flags(&user->rs, RATELIMIT_MSG_ON_RELEASE);
+
 	mutex_init(&user->lock);
 
 	raw_spin_lock_irq(&logbuf_lock);
@@ -830,6 +954,8 @@ static int devkmsg_release(struct inode *inode, struct file *file)
 	if (!user)
 		return 0;
 
+	ratelimit_state_exit(&user->rs);
+
 	mutex_destroy(&user->lock);
 	kfree(user);
 	return 0;

commit 40a7d9f5f90681c6d7890b6a07f230bb4afe7e39
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 2 14:03:59 2016 -0700

    printk: include <asm/sections.h> instead of <asm-generic/sections.h>
    
    asm-generic headers are generic implementations for architecture
    specific code and should not be included by common code.  Thus use the
    asm/ version of sections.h to get at the linker sections.
    
    Link: http://lkml.kernel.org/r/1468285008-7331-1-git-send-email-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8bdce14254f4..70c66c5ba212 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -47,7 +47,7 @@
 #include <linux/uio.h>
 
 #include <asm/uaccess.h>
-#include <asm-generic/sections.h>
+#include <asm/sections.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>

commit cf7754441c563230ed74096fcd4b8cca49910550
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Aug 2 14:03:56 2016 -0700

    printk: introduce suppress_message_printing()
    
    Messages' levels and console log level are inspected when the actual
    printing occurs, which may provoke console_unlock() and
    console_cont_flush() to waste CPU cycles on every message that has
    loglevel above the current console_loglevel.
    
    Schematically, console_unlock() does the following:
    
    console_unlock()
    {
            ...
            for (;;) {
                    ...
                    raw_spin_lock_irqsave(&logbuf_lock, flags);
    skip:
                    msg = log_from_idx(console_idx);
    
                    if (msg->flags & LOG_NOCONS) {
                            ...
                            goto skip;
                    }
    
                    level = msg->level;
                    len += msg_print_text();                        >> sprintfs
                                                                       memcpy,
                                                                       etc.
    
                    if (nr_ext_console_drivers) {
                            ext_len = msg_print_ext_header();       >> scnprintf
                            ext_len += msg_print_ext_body();        >> scnprintfs
                                                                       etc.
                    }
                    ...
                    raw_spin_unlock(&logbuf_lock);
    
                    call_console_drivers(level, ext_text, ext_len, text, len)
                    {
                            if (level >= console_loglevel &&        >> drop the message
                                            !ignore_loglevel)
                                    return;
    
                            console->write(...);
                    }
    
                    local_irq_restore(flags);
            }
            ...
    }
    
    The thing here is this deferred `level >= console_loglevel' check.  We
    are wasting CPU cycles on sprintfs/memcpy/etc.  preparing the messages
    that we will eventually drop.
    
    This can be huge when we register a new CON_PRINTBUFFER console, for
    instance.  For every such a console register_console() resets the
    
            console_seq, console_idx, console_prev
    
    and sets a `exclusive console' pointer to replay the log buffer to that
    just-registered console.  And there can be a lot of messages to replay,
    in the worst case most of which can be dropped after console_loglevel
    test.
    
    We know messages' levels long before we call msg_print_text() and
    friends, so we can just move console_loglevel check out of
    call_console_drivers() and format a new message only if we are sure that
    it won't be dropped.
    
    The patch factors out loglevel check into suppress_message_printing()
    function and tests message->level and console_loglevel before formatting
    functions in console_unlock() and console_cont_flush() are getting
    executed.  This improves things not only for exclusive CON_PRINTBUFFER
    consoles, but for every console_unlock() that attempts to print a
    message of level above the console_loglevel.
    
    Link: http://lkml.kernel.org/r/20160627135012.8229-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Calvin Owens <calvinowens@fb.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d2accf2f4448..8bdce14254f4 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -985,6 +985,11 @@ module_param(ignore_loglevel, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(ignore_loglevel,
 		 "ignore loglevel setting (prints all kernel messages to the console)");
 
+static bool suppress_message_printing(int level)
+{
+	return (level >= console_loglevel && !ignore_loglevel);
+}
+
 #ifdef CONFIG_BOOT_PRINTK_DELAY
 
 static int boot_delay; /* msecs delay after each printk during bootup */
@@ -1014,7 +1019,7 @@ static void boot_delay_msec(int level)
 	unsigned long timeout;
 
 	if ((boot_delay == 0 || system_state != SYSTEM_BOOTING)
-		|| (level >= console_loglevel && !ignore_loglevel)) {
+		|| suppress_message_printing(level)) {
 		return;
 	}
 
@@ -1438,8 +1443,6 @@ static void call_console_drivers(int level,
 
 	trace_console(text, len);
 
-	if (level >= console_loglevel && !ignore_loglevel)
-		return;
 	if (!console_drivers)
 		return;
 
@@ -1908,6 +1911,7 @@ static void call_console_drivers(int level,
 static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static size_t cont_print_text(char *text, size_t size) { return 0; }
+static bool suppress_message_printing(int level) { return false; }
 
 /* Still needs to be defined for users */
 DEFINE_PER_CPU(printk_func_t, printk_func);
@@ -2187,6 +2191,13 @@ static void console_cont_flush(char *text, size_t size)
 	if (!cont.len)
 		goto out;
 
+	if (suppress_message_printing(cont.level)) {
+		cont.cons = cont.len;
+		if (cont.flushed)
+			cont.len = 0;
+		goto out;
+	}
+
 	/*
 	 * We still queue earlier records, likely because the console was
 	 * busy. The earlier ones need to be printed before this one, we
@@ -2290,10 +2301,13 @@ void console_unlock(void)
 			break;
 
 		msg = log_from_idx(console_idx);
-		if (msg->flags & LOG_NOCONS) {
+		level = msg->level;
+		if ((msg->flags & LOG_NOCONS) ||
+				suppress_message_printing(level)) {
 			/*
 			 * Skip record we have buffered and already printed
-			 * directly to the console when we received it.
+			 * directly to the console when we received it, and
+			 * record that has level above the console loglevel.
 			 */
 			console_idx = log_next(console_idx);
 			console_seq++;
@@ -2307,7 +2321,6 @@ void console_unlock(void)
 			goto skip;
 		}
 
-		level = msg->level;
 		len += msg_print_text(msg, console_prev, false,
 				      text + len, sizeof(text) - len);
 		if (nr_ext_console_drivers) {

commit 874f9c7da9a4acbc1b9e12ca722579fb50e4d142
Author: Joe Perches <joe@perches.com>
Date:   Tue Aug 2 14:03:53 2016 -0700

    printk: create pr_<level> functions
    
    Using functions instead of macros can reduce overall code size by
    eliminating unnecessary "KERN_SOH<digit>" prefixes from format strings.
    
      defconfig x86-64:
    
      $ size vmlinux*
         text    data     bss      dec     hex  filename
      10193570 4331464 1105920 15630954  ee826a vmlinux.new
      10192623 4335560 1105920 15634103  ee8eb7 vmlinux.old
    
    As the return value are unimportant and unused in the kernel tree, these
    new functions return void.
    
    Miscellanea:
    
     - change pr_<level> macros to call new __pr_<level> functions
     - change vprintk_nmi and vprintk_default to add LOGLEVEL_<level> argument
    
    [akpm@linux-foundation.org: fix LOGLEVEL_INFO, per Joe]
    Link: http://lkml.kernel.org/r/e16cc34479dfefcae37c98b481e6646f0f69efc3.1466718827.git.joe@perches.com
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 09af62e71fee..d2accf2f4448 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1801,7 +1801,28 @@ asmlinkage int printk_emit(int facility, int level,
 }
 EXPORT_SYMBOL(printk_emit);
 
-int vprintk_default(const char *fmt, va_list args)
+#ifdef CONFIG_PRINTK
+#define define_pr_level(func, loglevel)				\
+asmlinkage __visible void func(const char *fmt, ...)		\
+{								\
+	va_list args;						\
+								\
+	va_start(args, fmt);					\
+	vprintk_default(loglevel, fmt, args);			\
+	va_end(args);						\
+}								\
+EXPORT_SYMBOL(func)
+
+define_pr_level(__pr_emerg, LOGLEVEL_EMERG);
+define_pr_level(__pr_alert, LOGLEVEL_ALERT);
+define_pr_level(__pr_crit, LOGLEVEL_CRIT);
+define_pr_level(__pr_err, LOGLEVEL_ERR);
+define_pr_level(__pr_warn, LOGLEVEL_WARNING);
+define_pr_level(__pr_notice, LOGLEVEL_NOTICE);
+define_pr_level(__pr_info, LOGLEVEL_INFO);
+#endif
+
+int vprintk_default(int level, const char *fmt, va_list args)
 {
 	int r;
 
@@ -1811,7 +1832,7 @@ int vprintk_default(const char *fmt, va_list args)
 		return r;
 	}
 #endif
-	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
+	r = vprintk_emit(0, level, NULL, 0, fmt, args);
 
 	return r;
 }
@@ -1844,7 +1865,7 @@ asmlinkage __visible int printk(const char *fmt, ...)
 	int r;
 
 	va_start(args, fmt);
-	r = vprintk_func(fmt, args);
+	r = vprintk_func(LOGLEVEL_DEFAULT, fmt, args);
 	va_end(args);
 
 	return r;

commit bebca05281d039e4144e1c51f402fd1d5f54b5e2
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Aug 2 14:03:50 2016 -0700

    printk: do not include interrupt.h
    
    A trivial cosmetic change: interrupt.h header is redundant since commit
    6b898c07cb1d ("console: use might_sleep in console_lock").
    
    Link: http://lkml.kernel.org/r/20160620132847.21930-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d4de33934dac..09af62e71fee 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -26,7 +26,6 @@
 #include <linux/nmi.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/delay.h>
 #include <linux/smp.h>
 #include <linux/security.h>

commit 8b70ca65616b3588ea1907e87f0df6d2530350df
Author: Andy Lutomirski <luto@kernel.org>
Date:   Thu Jul 28 15:48:23 2016 -0700

    printk: when dumping regs, show the stack, not thread_info
    
    We currently show:
    
      task: <current> ti: <current_thread_info()> task.ti: <task_thread_info(current)>"
    
    "ti" and "task.ti" are redundant, and neither is actually what we want
    to show, which the the base of the thread stack.  Change the display to
    show the stack pointer explicitly.
    
    Link: http://lkml.kernel.org/r/543ac5bd66ff94000a57a02e11af7239571a3055.1468523549.git.luto@kernel.org
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 60cdf6386763..d4de33934dac 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -3177,9 +3177,8 @@ void show_regs_print_info(const char *log_lvl)
 {
 	dump_stack_print_info(log_lvl);
 
-	printk("%stask: %p ti: %p task.ti: %p\n",
-	       log_lvl, current, current_thread_info(),
-	       task_thread_info(current));
+	printk("%stask: %p task.stack: %p\n",
+	       log_lvl, current, task_stack_page(current));
 }
 
 #endif

commit cf9b1106c81c45cde02208fca49d3f3e4ab6ee74
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri May 20 17:00:42 2016 -0700

    printk/nmi: flush NMI messages on the system panic
    
    In NMI context, printk() messages are stored into per-CPU buffers to
    avoid a possible deadlock.  They are normally flushed to the main ring
    buffer via an IRQ work.  But the work is never called when the system
    calls panic() in the very same NMI handler.
    
    This patch tries to flush NMI buffers before the crash dump is
    generated.  In this case it does not risk a double release and bails out
    when the logbuf_lock is already taken.  The aim is to get the messages
    into the main ring buffer when possible.  It makes them better
    accessible in the vmcore.
    
    Then the patch tries to flush the buffers second time when other CPUs
    are down.  It might be more aggressive and reset logbuf_lock.  The aim
    is to get the messages available for the consequent kmsg_dump() and
    console_flush_on_panic() calls.
    
    The patch causes vprintk_emit() to be called even in NMI context again.
    But it is done via printk_deferred() so that the console handling is
    skipped.  Consoles use internal locks and we could not prevent a
    deadlock easily.  They are explicitly called later when the crash dump
    is not generated, see console_flush_on_panic().
    
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e38579d730f4..60cdf6386763 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -245,7 +245,7 @@ __packed __aligned(4)
  * within the scheduler's rq lock. It must be released before calling
  * console_unlock() or anything else that might wake up a process.
  */
-static DEFINE_RAW_SPINLOCK(logbuf_lock);
+DEFINE_RAW_SPINLOCK(logbuf_lock);
 
 #ifdef CONFIG_PRINTK
 DECLARE_WAIT_QUEUE_HEAD(log_wait);

commit b522deabc6f18e4f938d93a84f345f2cbf3347d1
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri May 20 17:00:36 2016 -0700

    printk/nmi: warn when some message has been lost in NMI context
    
    We could not resize the temporary buffer in NMI context.  Let's warn if
    a message is lost.
    
    This is rather theoretical.  printk() should not be used in NMI.  The
    only sensible use is when we want to print backtrace from all CPUs.  The
    current buffer should be enough for this purpose.
    
    [akpm@linux-foundation.org: whitespace fixlet]
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Jiri Kosina <jkosina@suse.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 71eba0607034..e38579d730f4 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1617,6 +1617,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	unsigned long flags;
 	int this_cpu;
 	int printed_len = 0;
+	int nmi_message_lost;
 	bool in_sched = false;
 	/* cpu currently holding logbuf_lock in this function */
 	static unsigned int logbuf_cpu = UINT_MAX;
@@ -1667,6 +1668,15 @@ asmlinkage int vprintk_emit(int facility, int level,
 					 strlen(recursion_msg));
 	}
 
+	nmi_message_lost = get_nmi_message_lost();
+	if (unlikely(nmi_message_lost)) {
+		text_len = scnprintf(textbuf, sizeof(textbuf),
+				     "BAD LUCK: lost %d message(s) from NMI context!",
+				     nmi_message_lost);
+		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
+					 NULL, 0, textbuf, text_len);
+	}
+
 	/*
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.

commit 42a0bb3f71383b457a7db362f1c69e7afb96732b
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri May 20 17:00:33 2016 -0700

    printk/nmi: generic solution for safe printk in NMI
    
    printk() takes some locks and could not be used a safe way in NMI
    context.
    
    The chance of a deadlock is real especially when printing stacks from
    all CPUs.  This particular problem has been addressed on x86 by the
    commit a9edc8809328 ("x86/nmi: Perform a safe NMI stack trace on all
    CPUs").
    
    The patchset brings two big advantages.  First, it makes the NMI
    backtraces safe on all architectures for free.  Second, it makes all NMI
    messages almost safe on all architectures (the temporary buffer is
    limited.  We still should keep the number of messages in NMI context at
    minimum).
    
    Note that there already are several messages printed in NMI context:
    WARN_ON(in_nmi()), BUG_ON(in_nmi()), anything being printed out from MCE
    handlers.  These are not easy to avoid.
    
    This patch reuses most of the code and makes it generic.  It is useful
    for all messages and architectures that support NMI.
    
    The alternative printk_func is set when entering and is reseted when
    leaving NMI context.  It queues IRQ work to copy the messages into the
    main ring buffer in a safe context.
    
    __printk_nmi_flush() copies all available messages and reset the buffer.
    Then we could use a simple cmpxchg operations to get synchronized with
    writers.  There is also used a spinlock to get synchronized with other
    flushers.
    
    We do not longer use seq_buf because it depends on external lock.  It
    would be hard to make all supported operations safe for a lockless use.
    It would be confusing and error prone to make only some operations safe.
    
    The code is put into separate printk/nmi.c as suggested by Steven
    Rostedt.  It needs a per-CPU buffer and is compiled only on
    architectures that call nmi_enter().  This is achieved by the new
    HAVE_NMI Kconfig flag.
    
    The are MN10300 and Xtensa architectures.  We need to clean up NMI
    handling there first.  Let's do it separately.
    
    The patch is heavily based on the draft from Peter Zijlstra, see
    
      https://lkml.org/lkml/2015/6/10/327
    
    [arnd@arndb.de: printk-nmi: use %zu format string for size_t]
    [akpm@linux-foundation.org: min_t->min - all types are size_t here]
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>    [arm part]
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Jiri Kosina <jkosina@suse.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index bfbf284e4218..71eba0607034 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -55,6 +55,7 @@
 
 #include "console_cmdline.h"
 #include "braille.h"
+#include "internal.h"
 
 int console_printk[4] = {
 	CONSOLE_LOGLEVEL_DEFAULT,	/* console_loglevel */
@@ -1807,14 +1808,6 @@ int vprintk_default(const char *fmt, va_list args)
 }
 EXPORT_SYMBOL_GPL(vprintk_default);
 
-/*
- * This allows printk to be diverted to another function per cpu.
- * This is useful for calling printk functions from within NMI
- * without worrying about race conditions that can lock up the
- * box.
- */
-DEFINE_PER_CPU(printk_func_t, printk_func) = vprintk_default;
-
 /**
  * printk - print a kernel message
  * @fmt: format string
@@ -1838,21 +1831,11 @@ DEFINE_PER_CPU(printk_func_t, printk_func) = vprintk_default;
  */
 asmlinkage __visible int printk(const char *fmt, ...)
 {
-	printk_func_t vprintk_func;
 	va_list args;
 	int r;
 
 	va_start(args, fmt);
-
-	/*
-	 * If a caller overrides the per_cpu printk_func, then it needs
-	 * to disable preemption when calling printk(). Otherwise
-	 * the printk_func should be set to the default. No need to
-	 * disable preemption here.
-	 */
-	vprintk_func = this_cpu_read(printk_func);
 	r = vprintk_func(fmt, args);
-
 	va_end(args);
 
 	return r;

commit f468908bb55a0b01d9424c74f8ec8eb906835150
Author: Ivan Delalande <colona@arista.com>
Date:   Thu Mar 17 14:21:30 2016 -0700

    printk: add clear_idx symbol to vmcoreinfo
    
    This allows us to extract from the vmcore only the messages emitted
    since the last time the ring buffer was cleared.  We just have to make
    sure its value is always up-to-date, when old messages are discarded to
    free space in log_make_free_space() for example.
    
    Signed-off-by: Zeyu Zhao <zzy8200@gmail.com>
    Signed-off-by: Ivan Delalande <colona@arista.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index d5fd844e5b08..bfbf284e4218 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -367,16 +367,20 @@ static int logbuf_has_space(u32 msg_size, bool empty)
 
 static int log_make_free_space(u32 msg_size)
 {
-	while (log_first_seq < log_next_seq) {
-		if (logbuf_has_space(msg_size, false))
-			return 0;
+	while (log_first_seq < log_next_seq &&
+	       !logbuf_has_space(msg_size, false)) {
 		/* drop old messages until we have enough contiguous space */
 		log_first_idx = log_next(log_first_idx);
 		log_first_seq++;
 	}
 
+	if (clear_seq < log_first_seq) {
+		clear_seq = log_first_seq;
+		clear_idx = log_first_idx;
+	}
+
 	/* sequence numbers are equal, so the log buffer is empty */
-	if (logbuf_has_space(msg_size, true))
+	if (logbuf_has_space(msg_size, log_first_seq == log_next_seq))
 		return 0;
 
 	return -ENOMEM;
@@ -854,6 +858,7 @@ void log_buf_kexec_setup(void)
 	VMCOREINFO_SYMBOL(log_buf);
 	VMCOREINFO_SYMBOL(log_buf_len);
 	VMCOREINFO_SYMBOL(log_first_idx);
+	VMCOREINFO_SYMBOL(clear_idx);
 	VMCOREINFO_SYMBOL(log_next_idx);
 	/*
 	 * Export struct printk_log size and field offsets. User space tools can
@@ -1216,12 +1221,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		u32 idx;
 		enum log_flags prev;
 
-		if (clear_seq < log_first_seq) {
-			/* messages are gone, move to first available one */
-			clear_seq = log_first_seq;
-			clear_idx = log_first_idx;
-		}
-
 		/*
 		 * Find first record that fits, including all following records,
 		 * into the user-provided buffer for this dump.

commit adaf6590ee7db23c3a124fb9f213c90c15cecf96
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Thu Mar 17 14:21:27 2016 -0700

    printk: check CON_ENABLED in have_callable_console()
    
    have_callable_console() must also test CON_ENABLED bit, not just
    CON_ANYTIME.  We may have disabled CON_ANYTIME console so printk can
    wrongly assume that it's safe to call_console_drivers().
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Jan Kara <jack@suse.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Calvin Owens <calvinowens@fb.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a6d023c3b852..d5fd844e5b08 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2146,7 +2146,8 @@ static int have_callable_console(void)
 	struct console *con;
 
 	for_each_console(con)
-		if (con->flags & CON_ANYTIME)
+		if ((con->flags & CON_ENABLED) &&
+				(con->flags & CON_ANYTIME))
 			return 1;
 
 	return 0;

commit 6b97a20d3a7909daa06625d4440c2c52d7bf08d7
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Thu Mar 17 14:21:23 2016 -0700

    printk: set may_schedule for some of console_trylock() callers
    
    console_unlock() allows to cond_resched() if its caller has set
    `console_may_schedule' to 1, since 8d91f8b15361 ("printk: do
    cond_resched() between lines while outputting to consoles").
    
    The rules are:
    -- console_lock() always sets `console_may_schedule' to 1
    -- console_trylock() always sets `console_may_schedule' to 0
    
    However, console_trylock() callers (among them is printk()) do not
    always call printk() from atomic contexts, and some of them can
    cond_resched() in console_unlock(), so console_trylock() can set
    `console_may_schedule' to 1 for such processes.
    
    For !CONFIG_PREEMPT_COUNT kernels, however, console_trylock() always
    sets `console_may_schedule' to 0.
    
    It's possible to drop explicit preempt_disable()/preempt_enable() in
    vprintk_emit(), because console_unlock() and console_trylock() are now
    smart enough:
     a) console_unlock() does not cond_resched() when it's unsafe
        (console_trylock() takes care of that)
     b) console_unlock() does can_use_console() check.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Jan Kara <jack@suse.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Calvin Owens <calvinowens@fb.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 2523332bd998..a6d023c3b852 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1757,13 +1757,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
 		lockdep_off();
-		/*
-		 * Disable preemption to avoid being preempted while holding
-		 * console_sem which would prevent anyone from printing to
-		 * console
-		 */
-		preempt_disable();
-
 		/*
 		 * Try to acquire and then immediately release the console
 		 * semaphore.  The release will print out buffers and wake up
@@ -1771,7 +1764,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (console_trylock())
 			console_unlock();
-		preempt_enable();
 		lockdep_on();
 	}
 
@@ -2122,7 +2114,20 @@ int console_trylock(void)
 		return 0;
 	}
 	console_locked = 1;
-	console_may_schedule = 0;
+	/*
+	 * When PREEMPT_COUNT disabled we can't reliably detect if it's
+	 * safe to schedule (e.g. calling printk while holding a spin_lock),
+	 * because preempt_disable()/preempt_enable() are just barriers there
+	 * and preempt_count() is always 0.
+	 *
+	 * RCU read sections have a separate preemption counter when
+	 * PREEMPT_RCU enabled thus we must take extra care and check
+	 * rcu_preempt_depth(), otherwise RCU read sections modify
+	 * preempt_count().
+	 */
+	console_may_schedule = !oops_in_progress &&
+			preemptible() &&
+			!rcu_preempt_depth();
 	return 1;
 }
 EXPORT_SYMBOL(console_trylock);

commit a8199371afc27946d72f0d53e938e78d2ea0bae3
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Thu Mar 17 14:21:20 2016 -0700

    printk: move can_use_console() out of console_trylock_for_printk()
    
    console_unlock() allows to cond_resched() if its caller has set
    `console_may_schedule' to 1 (this functionality is present since
    8d91f8b15361 ("printk: do cond_resched() between lines while outputting
    to consoles").
    
    The rules are:
    -- console_lock() always sets `console_may_schedule' to 1
    -- console_trylock() always sets `console_may_schedule' to 0
    
    printk() calls console_unlock() with preemption desabled, which
    basically can lead to RCU stalls, watchdog soft lockups, etc.  if
    something is simultaneously calling printk() frequent enough (IOW,
    console_sem owner always has new data to send to console divers and
    can't leave console_unlock() for a long time).
    
    printk()->console_trylock() callers do not necessarily execute in atomic
    contexts, and some of them can cond_resched() in console_unlock().
    console_trylock() can set `console_may_schedule' to 1 (allow
    cond_resched() later in consoe_unlock()) when it's safe.
    
    This patch (of 3):
    
    vprintk_emit() disables preemption around console_trylock_for_printk()
    and console_unlock() calls for a strong reason -- can_use_console()
    check.  The thing is that vprintl_emit() can be called on a CPU that is
    not fully brought up yet (!cpu_online()), which potentially can cause
    problems if console driver wants to access per-cpu data.  A console
    driver can explicitly state that it's safe to call it from !online cpu
    by setting CON_ANYTIME bit in console ->flags.  That's why for
    !cpu_online() can_use_console() iterates all the console to find out if
    there is a CON_ANYTIME console, otherwise console_unlock() must be
    avoided.
    
    can_use_console() ensures that console_unlock() call is safe in
    vprintk_emit() only; console_lock() and console_trylock() are not
    covered by this check.  Even though call_console_drivers(), invoked from
    console_cont_flush() and console_unlock(), tests `!cpu_online() &&
    CON_ANYTIME' for_each_console(), it may be too late, which can result in
    messages loss.
    
    Assume that we have 2 cpus -- CPU0 is online, CPU1 is !online, and no
    CON_ANYTIME consoles available.
    
    CPU0 online                        CPU1 !online
                                     console_trylock()
                                     ...
                                     console_unlock()
                                       console_cont_flush
                                         spin_lock logbuf_lock
                                         if (!cont.len) {
                                            spin_unlock logbuf_lock
                                            return
                                         }
                                       for (;;) {
    vprintk_emit
      spin_lock logbuf_lock
      log_store
      spin_unlock logbuf_lock
                                         spin_lock logbuf_lock
      !console_trylock_for_printk        msg_print_text
     return                              console_idx = log_next()
                                         console_seq++
                                         console_prev = msg->flags
                                         spin_unlock logbuf_lock
    
                                         call_console_drivers()
                                           for_each_console(con) {
                                             if (!cpu_online() &&
                                                 !(con->flags & CON_ANYTIME))
                                                     continue;
                                             }
                                       /*
                                        * no message printed, we lost it
                                        */
    vprintk_emit
      spin_lock logbuf_lock
      log_store
      spin_unlock logbuf_lock
      !console_trylock_for_printk
     return
                                       /*
                                        * go to the beginning of the loop,
                                        * find out there are new messages,
                                        * lose it
                                        */
                                       }
    
    console_trylock()/console_lock() call on CPU1 may come from cpu
    notifiers registered on that CPU.  Since notifiers are not getting
    unregistered when CPU is going DOWN, all of the notifiers receive
    notifications during CPU UP.  For example, on my x86_64, I see around 50
    notification sent from offline CPU to itself
    
     [swapper/2] from cpu:2 to:2 action:CPU_STARTING hotplug_hrtick
     [swapper/2] from cpu:2 to:2 action:CPU_STARTING blk_mq_main_cpu_notify
     [swapper/2] from cpu:2 to:2 action:CPU_STARTING blk_mq_queue_reinit_notify
     [swapper/2] from cpu:2 to:2 action:CPU_STARTING console_cpu_notify
    
    while doing
      echo 0 > /sys/devices/system/cpu/cpu2/online
      echo 1 > /sys/devices/system/cpu/cpu2/online
    
    So grabbing the console_sem lock while CPU is !online is possible,
    in theory.
    
    This patch moves can_use_console() check out of
    console_trylock_for_printk().  Instead it calls it in console_unlock(),
    so now console_lock()/console_unlock() are also 'protected' by
    can_use_console().  This also means that console_trylock_for_printk() is
    not really needed anymore and can be removed.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Jan Kara <jack@suse.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Calvin Owens <calvinowens@fb.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index c963ba534a78..2523332bd998 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1483,58 +1483,6 @@ static void zap_locks(void)
 	sema_init(&console_sem, 1);
 }
 
-/*
- * Check if we have any console that is capable of printing while cpu is
- * booting or shutting down. Requires console_sem.
- */
-static int have_callable_console(void)
-{
-	struct console *con;
-
-	for_each_console(con)
-		if (con->flags & CON_ANYTIME)
-			return 1;
-
-	return 0;
-}
-
-/*
- * Can we actually use the console at this time on this cpu?
- *
- * Console drivers may assume that per-cpu resources have been allocated. So
- * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
- * call them until this CPU is officially up.
- */
-static inline int can_use_console(unsigned int cpu)
-{
-	return cpu_online(cpu) || have_callable_console();
-}
-
-/*
- * Try to get console ownership to actually show the kernel
- * messages from a 'printk'. Return true (and with the
- * console_lock held, and 'console_locked' set) if it
- * is successful, false otherwise.
- */
-static int console_trylock_for_printk(void)
-{
-	unsigned int cpu = smp_processor_id();
-
-	if (!console_trylock())
-		return 0;
-	/*
-	 * If we can't use the console, we need to release the console
-	 * semaphore by hand to avoid flushing the buffer. We need to hold the
-	 * console semaphore in order to do this test safely.
-	 */
-	if (!can_use_console(cpu)) {
-		console_locked = 0;
-		up_console_sem();
-		return 0;
-	}
-	return 1;
-}
-
 int printk_delay_msec __read_mostly;
 
 static inline void printk_delay(void)
@@ -1681,7 +1629,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 	boot_delay_msec(level);
 	printk_delay();
 
-	/* This stops the holder of console_sem just where we want him */
 	local_irq_save(flags);
 	this_cpu = smp_processor_id();
 
@@ -1705,6 +1652,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	}
 
 	lockdep_off();
+	/* This stops the holder of console_sem just where we want him */
 	raw_spin_lock(&logbuf_lock);
 	logbuf_cpu = this_cpu;
 
@@ -1821,7 +1769,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * semaphore.  The release will print out buffers and wake up
 		 * /dev/kmsg and syslog() users.
 		 */
-		if (console_trylock_for_printk())
+		if (console_trylock())
 			console_unlock();
 		preempt_enable();
 		lockdep_on();
@@ -2184,6 +2132,33 @@ int is_console_locked(void)
 	return console_locked;
 }
 
+/*
+ * Check if we have any console that is capable of printing while cpu is
+ * booting or shutting down. Requires console_sem.
+ */
+static int have_callable_console(void)
+{
+	struct console *con;
+
+	for_each_console(con)
+		if (con->flags & CON_ANYTIME)
+			return 1;
+
+	return 0;
+}
+
+/*
+ * Can we actually use the console at this time on this cpu?
+ *
+ * Console drivers may assume that per-cpu resources have been allocated. So
+ * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
+ * call them until this CPU is officially up.
+ */
+static inline int can_use_console(void)
+{
+	return cpu_online(raw_smp_processor_id()) || have_callable_console();
+}
+
 static void console_cont_flush(char *text, size_t size)
 {
 	unsigned long flags;
@@ -2254,9 +2229,21 @@ void console_unlock(void)
 	do_cond_resched = console_may_schedule;
 	console_may_schedule = 0;
 
+again:
+	/*
+	 * We released the console_sem lock, so we need to recheck if
+	 * cpu is online and (if not) is there at least one CON_ANYTIME
+	 * console.
+	 */
+	if (!can_use_console()) {
+		console_locked = 0;
+		up_console_sem();
+		return;
+	}
+
 	/* flush buffered message fragment immediately to console */
 	console_cont_flush(text, sizeof(text));
-again:
+
 	for (;;) {
 		struct printk_log *msg;
 		size_t ext_len = 0;

commit 5c9cf8af2e77388f1da81c39237fb4f20c2f85d5
Author: Andrey Ryabinin <aryabinin@virtuozzo.com>
Date:   Wed Jan 20 15:00:48 2016 -0800

    kernel: printk: specify alignment for struct printk_log
    
    On architectures that have support for efficient unaligned access struct
    printk_log has 4-byte alignment.  Specify alignment attribute in type
    declaration.
    
    The whole point of this patch is to fix deadlock which happening when
    UBSAN detects unaligned access in printk() thus UBSAN recursively calls
    printk() with logbuf_lock held by top printk() call.
    
    Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Yury Gribov <y.gribov@samsung.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e79439134978..c963ba534a78 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -233,7 +233,11 @@ struct printk_log {
 	u8 facility;		/* syslog facility */
 	u8 flags:5;		/* internal record flags */
 	u8 level:3;		/* syslog level */
-};
+}
+#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+__packed __aligned(4)
+#endif
+;
 
 /*
  * The logbuf_lock protects kmsg buffer, indices, counters.  This can be taken
@@ -274,11 +278,7 @@ static u32 clear_idx;
 #define LOG_FACILITY(v)		((v) >> 3 & 0xff)
 
 /* record buffer */
-#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
-#define LOG_ALIGN 4
-#else
 #define LOG_ALIGN __alignof__(struct printk_log)
-#endif
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;

commit 06b031de22d28ae76b2e5bfaf22c56a265a1e106
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Fri Jan 15 16:59:23 2016 -0800

    printk: change recursion_bug type to bool
    
    `recursion_bug' is used as recursion_bug toggle, so make it `bool'.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 08934a395c1a..e79439134978 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1661,7 +1661,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 			    const char *dict, size_t dictlen,
 			    const char *fmt, va_list args)
 {
-	static int recursion_bug;
+	static bool recursion_bug;
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
 	size_t text_len = 0;
@@ -1697,7 +1697,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * it can be printed at the next appropriate moment:
 		 */
 		if (!oops_in_progress && !lockdep_recursing(current)) {
-			recursion_bug = 1;
+			recursion_bug = true;
 			local_irq_restore(flags);
 			return 0;
 		}
@@ -1712,7 +1712,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		static const char recursion_msg[] =
 			"BUG: recent printk recursion!";
 
-		recursion_bug = 0;
+		recursion_bug = false;
 		/* emit KERN_CRIT message */
 		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
 					 NULL, 0, recursion_msg,

commit 8d91f8b15361dfb438ab6eb3b319e2ded43458ff
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 15 16:58:24 2016 -0800

    printk: do cond_resched() between lines while outputting to consoles
    
    @console_may_schedule tracks whether console_sem was acquired through
    lock or trylock.  If the former, we're inside a sleepable context and
    console_conditional_schedule() performs cond_resched().  This allows
    console drivers which use console_lock for synchronization to yield
    while performing time-consuming operations such as scrolling.
    
    However, the actual console outputting is performed while holding
    irq-safe logbuf_lock, so console_unlock() clears @console_may_schedule
    before starting outputting lines.  Also, only a few drivers call
    console_conditional_schedule() to begin with.  This means that when a
    lot of lines need to be output by console_unlock(), for example on a
    console registration, the task doing console_unlock() may not yield for
    a long time on a non-preemptible kernel.
    
    If this happens with a slow console devices, for example a serial
    console, the outputting task may occupy the cpu for a very long time.
    Long enough to trigger softlockup and/or RCU stall warnings, which in
    turn pile more messages, sometimes enough to trigger the next cycle of
    warnings incapacitating the system.
    
    Fix it by making console_unlock() insert cond_resched() between lines if
    @console_may_schedule.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Calvin Owens <calvinowens@fb.com>
    Acked-by: Jan Kara <jack@suse.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 0c9f02506169..08934a395c1a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2234,13 +2234,24 @@ void console_unlock(void)
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
-	bool retry;
+	bool do_cond_resched, retry;
 
 	if (console_suspended) {
 		up_console_sem();
 		return;
 	}
 
+	/*
+	 * Console drivers are called under logbuf_lock, so
+	 * @console_may_schedule should be cleared before; however, we may
+	 * end up dumping a lot of lines, for example, if called from
+	 * console registration path, and should invoke cond_resched()
+	 * between lines if allowable.  Not doing so can cause a very long
+	 * scheduling stall on a slow console leading to RCU stall and
+	 * softlockup warnings which exacerbate the issue with more
+	 * messages practically incapacitating the system.
+	 */
+	do_cond_resched = console_may_schedule;
 	console_may_schedule = 0;
 
 	/* flush buffered message fragment immediately to console */
@@ -2312,6 +2323,9 @@ void console_unlock(void)
 		call_console_drivers(level, ext_text, ext_len, text, len);
 		start_critical_timings();
 		local_irq_restore(flags);
+
+		if (do_cond_resched)
+			cond_resched();
 	}
 	console_locked = 0;
 
@@ -2379,6 +2393,25 @@ void console_unblank(void)
 	console_unlock();
 }
 
+/**
+ * console_flush_on_panic - flush console content on panic
+ *
+ * Immediately output all pending messages no matter what.
+ */
+void console_flush_on_panic(void)
+{
+	/*
+	 * If someone else is holding the console lock, trylock will fail
+	 * and may_schedule may be set.  Ignore and proceed to unlock so
+	 * that messages are flushed out.  As this can be called from any
+	 * context and we don't want to get preempted while flushing,
+	 * ensure may_schedule is cleared.
+	 */
+	console_trylock();
+	console_may_schedule = 0;
+	console_unlock();
+}
+
 /*
  * Return the console tty driver structure and its associated index
  */

commit 81cc26f2bd11ba4421a17a2d5cebe4bba206c239
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jan 15 16:58:21 2016 -0800

    printk: only unregister boot consoles when necessary
    
    Boot consoles are typically replaced by proper consoles during the boot
    process.  This can be problematic if the boot console data is part of
    the init section that is reclaimed late during boot.  If the proper
    console does not register before this point in time, the boot console
    will need to be removed (so that the freed memory is not accessed),
    leaving the system without output for some time.
    
    There are various reasons why the proper console may not register early
    enough, such as deferred probe or the driver being a loadable module.
    If that happens, there is some amount of time where no console messages
    are visible to the user, which in turn can mean that they won't see
    crashes or other potentially useful information.
    
    To avoid this situation, only remove the boot console when it resides in
    the init section.  Code exists to replace the boot console by the proper
    console when it is registered, keeping a seamless transition between the
    boot and proper consoles.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 2ce8826f1053..0c9f02506169 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -48,6 +48,7 @@
 #include <linux/uio.h>
 
 #include <asm/uaccess.h>
+#include <asm-generic/sections.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
@@ -2658,13 +2659,36 @@ int unregister_console(struct console *console)
 }
 EXPORT_SYMBOL(unregister_console);
 
+/*
+ * Some boot consoles access data that is in the init section and which will
+ * be discarded after the initcalls have been run. To make sure that no code
+ * will access this data, unregister the boot consoles in a late initcall.
+ *
+ * If for some reason, such as deferred probe or the driver being a loadable
+ * module, the real console hasn't registered yet at this point, there will
+ * be a brief interval in which no messages are logged to the console, which
+ * makes it difficult to diagnose problems that occur during this time.
+ *
+ * To mitigate this problem somewhat, only unregister consoles whose memory
+ * intersects with the init section. Note that code exists elsewhere to get
+ * rid of the boot console as soon as the proper console shows up, so there
+ * won't be side-effects from postponing the removal.
+ */
 static int __init printk_late_init(void)
 {
 	struct console *con;
 
 	for_each_console(con) {
 		if (!keep_bootcon && con->flags & CON_BOOT) {
-			unregister_console(con);
+			/*
+			 * Make sure to unregister boot consoles whose data
+			 * resides in the init section before the init section
+			 * is discarded. Boot consoles whose data will stick
+			 * around will automatically be unregistered when the
+			 * proper console replaces them.
+			 */
+			if (init_section_intersects(con, sizeof(*con)))
+				unregister_console(con);
 		}
 	}
 	hotcpu_notifier(console_cpu_notify, 0);

commit 3824657c522f19f85a76bd932821174a5557a382
Author: Mathias Krause <minipli@googlemail.com>
Date:   Fri Nov 6 16:30:38 2015 -0800

    printk: prevent userland from spoofing kernel messages
    
    The following statement of ABI/testing/dev-kmsg is not quite right:
    
       It is not possible to inject messages from userspace with the
       facility number LOG_KERN (0), to make sure that the origin of the
       messages can always be reliably determined.
    
    Userland actually can inject messages with a facility of 0 by abusing the
    fact that the facility is stored in a u8 data type.  By using a facility
    which is a multiple of 256 the assignment of msg->facility in log_store()
    implicitly truncates it to 0, i.e.  LOG_KERN, allowing users of /dev/kmsg
    to spoof kernel messages as shown below:
    
    The following call...
       # printf '<%d>Kernel panic - not syncing: beer empty\n' 0 >/dev/kmsg
    ...leads to the following log entry (dmesg -x | tail -n 1):
       user  :emerg : [   66.137758] Kernel panic - not syncing: beer empty
    
    However, this call...
       # printf '<%d>Kernel panic - not syncing: beer empty\n' 0x800 >/dev/kmsg
    ...leads to the slightly different log entry (note the kernel facility):
       kern  :emerg : [   74.177343] Kernel panic - not syncing: beer empty
    
    Fix that by limiting the user provided facility to 8 bit right from the
    beginning and catch the truncation early.
    
    Fixes: 7ff9554bb578 ("printk: convert byte-buffer to variable-length...")
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Alex Elder <elder@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b16f35487b67..2ce8826f1053 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -269,6 +269,9 @@ static u32 clear_idx;
 #define PREFIX_MAX		32
 #define LOG_LINE_MAX		(1024 - PREFIX_MAX)
 
+#define LOG_LEVEL(v)		((v) & 0x07)
+#define LOG_FACILITY(v)		((v) >> 3 & 0xff)
+
 /* record buffer */
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
 #define LOG_ALIGN 4
@@ -612,7 +615,6 @@ struct devkmsg_user {
 static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	char *buf, *line;
-	int i;
 	int level = default_message_loglevel;
 	int facility = 1;	/* LOG_USER */
 	size_t len = iov_iter_count(from);
@@ -642,12 +644,13 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 	line = buf;
 	if (line[0] == '<') {
 		char *endp = NULL;
+		unsigned int u;
 
-		i = simple_strtoul(line+1, &endp, 10);
+		u = simple_strtoul(line + 1, &endp, 10);
 		if (endp && endp[0] == '>') {
-			level = i & 7;
-			if (i >> 3)
-				facility = i >> 3;
+			level = LOG_LEVEL(u);
+			if (LOG_FACILITY(u) != 0)
+				facility = LOG_FACILITY(u);
 			endp++;
 			len -= endp - line;
 			line = endp;

commit ee1d267423a1f8041e2b1a33fc23e4393c67677e
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Oct 20 00:39:03 2015 -0700

    pstore: add pstore unregister
    
    pstore doesn't support unregistering yet. It was marked as TODO.
    This patch adds some code to fix it:
     1) Add functions to unregister kmsg/console/ftrace/pmsg.
     2) Add a function to free compression buffer.
     3) Unmap the memory and free it.
     4) Add a function to unregister pstore filesystem.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    [Removed __exit annotation from ramoops_remove(). Reported by Arnd Bergmann]
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8f0324ef72ab..b16f35487b67 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -517,6 +517,7 @@ int check_syslog_permissions(int type, int source)
 ok:
 	return security_syslog(type);
 }
+EXPORT_SYMBOL_GPL(check_syslog_permissions);
 
 static void append_char(char **pp, char *e, char c)
 {

commit 2965faa5e03d1e71e9ff9aa143fff39e0a77543a
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Sep 9 15:38:55 2015 -0700

    kexec: split kexec_load syscall from kexec core code
    
    There are two kexec load syscalls, kexec_load another and kexec_file_load.
     kexec_file_load has been splited as kernel/kexec_file.c.  In this patch I
    split kexec_load syscall code to kernel/kexec.c.
    
    And add a new kconfig option KEXEC_CORE, so we can disable kexec_load and
    use kexec_file_load only, or vice verse.
    
    The original requirement is from Ted Ts'o, he want kexec kernel signature
    being checked with CONFIG_KEXEC_VERIFY_SIG enabled.  But kexec-tools use
    kexec_load syscall can bypass the checking.
    
    Vivek Goyal proposed to create a common kconfig option so user can compile
    in only one syscall for loading kexec kernel.  KEXEC/KEXEC_FILE selects
    KEXEC_CORE so that old config files still work.
    
    Because there's general code need CONFIG_KEXEC_CORE, so I updated all the
    architecture Kconfig with a new option KEXEC_CORE, and let KEXEC selects
    KEXEC_CORE in arch Kconfig.  Also updated general kernel code with to
    kexec_load syscall.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Petr Tesarik <ptesarik@suse.cz>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index cf8c24203368..8f0324ef72ab 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -835,7 +835,7 @@ const struct file_operations kmsg_fops = {
 	.release = devkmsg_release,
 };
 
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 /*
  * This appends the listed symbols to /proc/vmcore
  *

commit b389645f041a9fc650819b1c1ce7abbef7f4912d
Author: Antonio Ospite <ao2@ao2.it>
Date:   Tue Jun 30 14:59:03 2015 -0700

    printk: improve the description of /dev/kmsg line format
    
    The comment about /dev/kmsg does not mention the additional values which
    may actually be exported, fix that.
    
    Also move up the part of the comment instructing the users to ignore these
    additional values, this way the reading is more fluent and logically
    compact.
    
    Signed-off-by: Antonio Ospite <ao2@ao2.it>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index de553849f3ac..cf8c24203368 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -207,14 +207,14 @@ static int console_may_schedule;
  * need to be changed in the future, when the requirements change.
  *
  * /dev/kmsg exports the structured data in the following line format:
- *   "<level>,<sequnum>,<timestamp>,<contflag>;<message text>\n"
+ *   "<level>,<sequnum>,<timestamp>,<contflag>[,additional_values, ... ];<message text>\n"
+ *
+ * Users of the export format should ignore possible additional values
+ * separated by ',', and find the message after the ';' character.
  *
  * The optional key/value pairs are attached as continuation lines starting
  * with a space character and terminated by a newline. All possible
  * non-prinatable characters are escaped in the "\xff" notation.
- *
- * Users of the export format should ignore possible additional values
- * separated by ',', and find the message after the ';' character.
  */
 
 enum log_flags {

commit 3ea4331c60be3eee4c97e5ddabad95399f879b76
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Thu Jun 25 15:01:47 2015 -0700

    check_syslog_permissions() cleanup
    
    Patch fixes drawbacks in heck_syslog_permissions() noticed by AKPM:
    "from_file handling makes me cry.
    
    That's not a boolean - it's an enumerated value with two values
    currently defined.
    
    But the code in check_syslog_permissions() treats it as a boolean and
    also hardwires the knowledge that SYSLOG_FROM_PROC == 1 (or == `true`).
    
    And the name is wrong: it should be called from_proc to match
    SYSLOG_FROM_PROC."
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Josh Boyer <jwboyer@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 45fa8c88ac47..de553849f3ac 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -489,13 +489,13 @@ static int syslog_action_restricted(int type)
 	       type != SYSLOG_ACTION_SIZE_BUFFER;
 }
 
-int check_syslog_permissions(int type, bool from_file)
+int check_syslog_permissions(int type, int source)
 {
 	/*
 	 * If this is from /proc/kmsg and we've already opened it, then we've
 	 * already done the capabilities checks at open time.
 	 */
-	if (from_file && type != SYSLOG_ACTION_OPEN)
+	if (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)
 		goto ok;
 
 	if (syslog_action_restricted(type)) {
@@ -1290,13 +1290,13 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 	return len;
 }
 
-int do_syslog(int type, char __user *buf, int len, bool from_file)
+int do_syslog(int type, char __user *buf, int len, int source)
 {
 	bool clear = false;
 	static int saved_console_loglevel = LOGLEVEL_DEFAULT;
 	int error;
 
-	error = check_syslog_permissions(type, from_file);
+	error = check_syslog_permissions(type, source);
 	if (error)
 		goto out;
 
@@ -1379,7 +1379,7 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 			syslog_prev = 0;
 			syslog_partial = 0;
 		}
-		if (from_file) {
+		if (source == SYSLOG_FROM_PROC) {
 			/*
 			 * Short-cut for poll(/"proc/kmsg") which simply checks
 			 * for pending data, not the size; return the count of

commit d194e5d666225b04c7754471df0948f645b6ab3a
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Thu Jun 25 15:01:44 2015 -0700

    security_syslog() should be called once only
    
    The final version of commit 637241a900cb ("kmsg: honor dmesg_restrict
    sysctl on /dev/kmsg") lost few hooks, as result security_syslog() are
    processed incorrectly:
    
    - open of /dev/kmsg checks syslog access permissions by using
      check_syslog_permissions() where security_syslog() is not called if
      dmesg_restrict is set.
    
    - syslog syscall and /proc/kmsg calls do_syslog() where security_syslog
      can be executed twice (inside check_syslog_permissions() and then
      directly in do_syslog())
    
    With this patch security_syslog() is called once only in all
    syslog-related operations regardless of dmesg_restrict value.
    
    Fixes: 637241a900cb ("kmsg: honor dmesg_restrict sysctl on /dev/kmsg")
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Josh Boyer <jwboyer@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ae980dc3ac1e..45fa8c88ac47 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -496,11 +496,11 @@ int check_syslog_permissions(int type, bool from_file)
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file && type != SYSLOG_ACTION_OPEN)
-		return 0;
+		goto ok;
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
-			return 0;
+			goto ok;
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
@@ -510,10 +510,11 @@ int check_syslog_permissions(int type, bool from_file)
 				     "CAP_SYS_ADMIN but no CAP_SYSLOG "
 				     "(deprecated).\n",
 				 current->comm, task_pid_nr(current));
-			return 0;
+			goto ok;
 		}
 		return -EPERM;
 	}
+ok:
 	return security_syslog(type);
 }
 
@@ -1299,10 +1300,6 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 	if (error)
 		goto out;
 
-	error = security_syslog(type);
-	if (error)
-		return error;
-
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;

commit 6fe29354befe4c46eb308b662155d4d8017358e1
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 25 15:01:30 2015 -0700

    printk: implement support for extended console drivers
    
    printk log_buf keeps various metadata for each message including its
    sequence number and timestamp.  The metadata is currently available only
    through /dev/kmsg and stripped out before passed onto console drivers.  We
    want this metadata to be available to console drivers too so that console
    consumers can get full information including the metadata and dictionary,
    which among other things can be used to detect whether messages got lost
    in transit.
    
    This patch implements support for extended console drivers.  Consoles can
    indicate that they want extended messages by setting the new CON_EXTENDED
    flag and they'll be fed messages formatted the same way as /dev/kmsg.
    
     "<level>,<sequnum>,<timestamp>,<contflag>;<message text>\n"
    
    If extended consoles exist, in-kernel fragment assembly is disabled.  This
    ensures that all messages emitted to consoles have full metadata including
    sequence number.  The contflag carries enough information to reassemble
    the fragments from the reader side trivially.  Note that this only affects
    /dev/kmsg.  Regular console and /proc/kmsg outputs are not affected by
    this change.
    
    * Extended message formatting for console drivers is enabled iff there
      are registered extended consoles.
    
    * Comment describing /dev/kmsg message format updated to add missing
      contflag field and help distinguishing variable from verbatim terms.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Kay Sievers <kay@vrfy.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 51ce4f1838b3..ae980dc3ac1e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -84,6 +84,18 @@ static struct lockdep_map console_lock_dep_map = {
 };
 #endif
 
+/*
+ * Number of registered extended console drivers.
+ *
+ * If extended consoles are present, in-kernel cont reassembly is disabled
+ * and each fragment is stored as a separate log entry with proper
+ * continuation flag so that every emitted message has full metadata.  This
+ * doesn't change the result for regular consoles or /proc/kmsg.  For
+ * /dev/kmsg, as long as the reader concatenates messages according to
+ * consecutive continuation flags, the end result should be the same too.
+ */
+static int nr_ext_console_drivers;
+
 /*
  * Helper macros to handle lockdep when locking/unlocking console_sem. We use
  * macros instead of functions so that _RET_IP_ contains useful information.
@@ -195,7 +207,7 @@ static int console_may_schedule;
  * need to be changed in the future, when the requirements change.
  *
  * /dev/kmsg exports the structured data in the following line format:
- *   "level,sequnum,timestamp;<message text>\n"
+ *   "<level>,<sequnum>,<timestamp>,<contflag>;<message text>\n"
  *
  * The optional key/value pairs are attached as continuation lines starting
  * with a space character and terminated by a newline. All possible
@@ -1417,7 +1429,9 @@ SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)
  * log_buf[start] to log_buf[end - 1].
  * The console_lock must be held.
  */
-static void call_console_drivers(int level, const char *text, size_t len)
+static void call_console_drivers(int level,
+				 const char *ext_text, size_t ext_len,
+				 const char *text, size_t len)
 {
 	struct console *con;
 
@@ -1438,7 +1452,10 @@ static void call_console_drivers(int level, const char *text, size_t len)
 		if (!cpu_online(smp_processor_id()) &&
 		    !(con->flags & CON_ANYTIME))
 			continue;
-		con->write(con, text, len);
+		if (con->flags & CON_EXTENDED)
+			con->write(con, ext_text, ext_len);
+		else
+			con->write(con, text, len);
 	}
 }
 
@@ -1581,8 +1598,12 @@ static bool cont_add(int facility, int level, const char *text, size_t len)
 	if (cont.len && cont.flushed)
 		return false;
 
-	if (cont.len + len > sizeof(cont.buf)) {
-		/* the line gets too long, split it up in separate records */
+	/*
+	 * If ext consoles are present, flush and skip in-kernel
+	 * continuation.  See nr_ext_console_drivers definition.  Also, if
+	 * the line gets too long, split it up in separate records.
+	 */
+	if (nr_ext_console_drivers || cont.len + len > sizeof(cont.buf)) {
 		cont_flush(LOG_CONT);
 		return false;
 	}
@@ -1917,9 +1938,19 @@ static struct cont {
 	u8 level;
 	bool flushed:1;
 } cont;
+static char *log_text(const struct printk_log *msg) { return NULL; }
+static char *log_dict(const struct printk_log *msg) { return NULL; }
 static struct printk_log *log_from_idx(u32 idx) { return NULL; }
 static u32 log_next(u32 idx) { return 0; }
-static void call_console_drivers(int level, const char *text, size_t len) {}
+static ssize_t msg_print_ext_header(char *buf, size_t size,
+				    struct printk_log *msg, u64 seq,
+				    enum log_flags prev_flags) { return 0; }
+static ssize_t msg_print_ext_body(char *buf, size_t size,
+				  char *dict, size_t dict_len,
+				  char *text, size_t text_len) { return 0; }
+static void call_console_drivers(int level,
+				 const char *ext_text, size_t ext_len,
+				 const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static size_t cont_print_text(char *text, size_t size) { return 0; }
@@ -2172,7 +2203,7 @@ static void console_cont_flush(char *text, size_t size)
 	len = cont_print_text(text, size);
 	raw_spin_unlock(&logbuf_lock);
 	stop_critical_timings();
-	call_console_drivers(cont.level, text, len);
+	call_console_drivers(cont.level, NULL, 0, text, len);
 	start_critical_timings();
 	local_irq_restore(flags);
 	return;
@@ -2196,6 +2227,7 @@ static void console_cont_flush(char *text, size_t size)
  */
 void console_unlock(void)
 {
+	static char ext_text[CONSOLE_EXT_LOG_MAX];
 	static char text[LOG_LINE_MAX + PREFIX_MAX];
 	static u64 seen_seq;
 	unsigned long flags;
@@ -2214,6 +2246,7 @@ void console_unlock(void)
 again:
 	for (;;) {
 		struct printk_log *msg;
+		size_t ext_len = 0;
 		size_t len;
 		int level;
 
@@ -2259,13 +2292,22 @@ void console_unlock(void)
 		level = msg->level;
 		len += msg_print_text(msg, console_prev, false,
 				      text + len, sizeof(text) - len);
+		if (nr_ext_console_drivers) {
+			ext_len = msg_print_ext_header(ext_text,
+						sizeof(ext_text),
+						msg, console_seq, console_prev);
+			ext_len += msg_print_ext_body(ext_text + ext_len,
+						sizeof(ext_text) - ext_len,
+						log_dict(msg), msg->dict_len,
+						log_text(msg), msg->text_len);
+		}
 		console_idx = log_next(console_idx);
 		console_seq++;
 		console_prev = msg->flags;
 		raw_spin_unlock(&logbuf_lock);
 
 		stop_critical_timings();	/* don't trace print latency */
-		call_console_drivers(level, text, len);
+		call_console_drivers(level, ext_text, ext_len, text, len);
 		start_critical_timings();
 		local_irq_restore(flags);
 	}
@@ -2521,6 +2563,11 @@ void register_console(struct console *newcon)
 		newcon->next = console_drivers->next;
 		console_drivers->next = newcon;
 	}
+
+	if (newcon->flags & CON_EXTENDED)
+		if (!nr_ext_console_drivers++)
+			pr_info("printk: continuation disabled due to ext consoles, expect more fragments in /dev/kmsg\n");
+
 	if (newcon->flags & CON_PRINTBUFFER) {
 		/*
 		 * console_unlock(); will print out the buffered messages
@@ -2593,6 +2640,9 @@ int unregister_console(struct console *console)
 		}
 	}
 
+	if (!res && (console->flags & CON_EXTENDED))
+		nr_ext_console_drivers--;
+
 	/*
 	 * If this isn't the last console and it has CON_CONSDEV set, we
 	 * need to set it on the next preferred console.

commit 0a295e67ec19d59bdb146e0b60ac9659104f2215
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 25 15:01:27 2015 -0700

    printk: factor out message formatting from devkmsg_read()
    
    The extended message formatting used for /dev/kmsg will be used implement
    extended consoles.  Factor out msg_print_ext_header() and
    msg_print_ext_body() from devkmsg_read().
    
    This is pure restructuring.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Kay Sievers <kay@vrfy.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a11549034e07..51ce4f1838b3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -511,6 +511,81 @@ static void append_char(char **pp, char *e, char c)
 		*(*pp)++ = c;
 }
 
+static ssize_t msg_print_ext_header(char *buf, size_t size,
+				    struct printk_log *msg, u64 seq,
+				    enum log_flags prev_flags)
+{
+	u64 ts_usec = msg->ts_nsec;
+	char cont = '-';
+
+	do_div(ts_usec, 1000);
+
+	/*
+	 * If we couldn't merge continuation line fragments during the print,
+	 * export the stored flags to allow an optional external merge of the
+	 * records. Merging the records isn't always neccessarily correct, like
+	 * when we hit a race during printing. In most cases though, it produces
+	 * better readable output. 'c' in the record flags mark the first
+	 * fragment of a line, '+' the following.
+	 */
+	if (msg->flags & LOG_CONT && !(prev_flags & LOG_CONT))
+		cont = 'c';
+	else if ((msg->flags & LOG_CONT) ||
+		 ((prev_flags & LOG_CONT) && !(msg->flags & LOG_PREFIX)))
+		cont = '+';
+
+	return scnprintf(buf, size, "%u,%llu,%llu,%c;",
+		       (msg->facility << 3) | msg->level, seq, ts_usec, cont);
+}
+
+static ssize_t msg_print_ext_body(char *buf, size_t size,
+				  char *dict, size_t dict_len,
+				  char *text, size_t text_len)
+{
+	char *p = buf, *e = buf + size;
+	size_t i;
+
+	/* escape non-printable characters */
+	for (i = 0; i < text_len; i++) {
+		unsigned char c = text[i];
+
+		if (c < ' ' || c >= 127 || c == '\\')
+			p += scnprintf(p, e - p, "\\x%02x", c);
+		else
+			append_char(&p, e, c);
+	}
+	append_char(&p, e, '\n');
+
+	if (dict_len) {
+		bool line = true;
+
+		for (i = 0; i < dict_len; i++) {
+			unsigned char c = dict[i];
+
+			if (line) {
+				append_char(&p, e, ' ');
+				line = false;
+			}
+
+			if (c == '\0') {
+				append_char(&p, e, '\n');
+				line = true;
+				continue;
+			}
+
+			if (c < ' ' || c >= 127 || c == '\\') {
+				p += scnprintf(p, e - p, "\\x%02x", c);
+				continue;
+			}
+
+			append_char(&p, e, c);
+		}
+		append_char(&p, e, '\n');
+	}
+
+	return p - buf;
+}
+
 /* /dev/kmsg - userspace message inject/listen interface */
 struct devkmsg_user {
 	u64 seq;
@@ -575,19 +650,12 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 {
 	struct devkmsg_user *user = file->private_data;
 	struct printk_log *msg;
-	char *p, *e;
-	u64 ts_usec;
-	size_t i;
-	char cont = '-';
 	size_t len;
 	ssize_t ret;
 
 	if (!user)
 		return -EBADF;
 
-	p = user->buf;
-	e = user->buf + sizeof(user->buf);
-
 	ret = mutex_lock_interruptible(&user->lock);
 	if (ret)
 		return ret;
@@ -617,71 +685,17 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	}
 
 	msg = log_from_idx(user->idx);
-	ts_usec = msg->ts_nsec;
-	do_div(ts_usec, 1000);
+	len = msg_print_ext_header(user->buf, sizeof(user->buf),
+				   msg, user->seq, user->prev);
+	len += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,
+				  log_dict(msg), msg->dict_len,
+				  log_text(msg), msg->text_len);
 
-	/*
-	 * If we couldn't merge continuation line fragments during the print,
-	 * export the stored flags to allow an optional external merge of the
-	 * records. Merging the records isn't always neccessarily correct, like
-	 * when we hit a race during printing. In most cases though, it produces
-	 * better readable output. 'c' in the record flags mark the first
-	 * fragment of a line, '+' the following.
-	 */
-	if (msg->flags & LOG_CONT && !(user->prev & LOG_CONT))
-		cont = 'c';
-	else if ((msg->flags & LOG_CONT) ||
-		 ((user->prev & LOG_CONT) && !(msg->flags & LOG_PREFIX)))
-		cont = '+';
-
-	p += scnprintf(p, e - p, "%u,%llu,%llu,%c;",
-		       (msg->facility << 3) | msg->level,
-		       user->seq, ts_usec, cont);
 	user->prev = msg->flags;
-
-	/* escape non-printable characters */
-	for (i = 0; i < msg->text_len; i++) {
-		unsigned char c = log_text(msg)[i];
-
-		if (c < ' ' || c >= 127 || c == '\\')
-			p += scnprintf(p, e - p, "\\x%02x", c);
-		else
-			append_char(&p, e, c);
-	}
-	append_char(&p, e, '\n');
-
-	if (msg->dict_len) {
-		bool line = true;
-
-		for (i = 0; i < msg->dict_len; i++) {
-			unsigned char c = log_dict(msg)[i];
-
-			if (line) {
-				append_char(&p, e, ' ');
-				line = false;
-			}
-
-			if (c == '\0') {
-				append_char(&p, e, '\n');
-				line = true;
-				continue;
-			}
-
-			if (c < ' ' || c >= 127 || c == '\\') {
-				p += scnprintf(p, e - p, "\\x%02x", c);
-				continue;
-			}
-
-			append_char(&p, e, c);
-		}
-		append_char(&p, e, '\n');
-	}
-
 	user->idx = log_next(user->idx);
 	user->seq++;
 	raw_spin_unlock_irq(&logbuf_lock);
 
-	len = p - user->buf;
 	if (len > count) {
 		ret = -EINVAL;
 		goto out;

commit d43ff430f434d862db59582c0f1f02382a678036
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 25 15:01:24 2015 -0700

    printk: guard the amount written per line by devkmsg_read()
    
    This patchset updates netconsole so that it can emit messages with the
    same header as used in /dev/kmsg which gives neconsole receiver full log
    information which enables things like structured logging and detection
    of lost messages.
    
    This patch (of 7):
    
    devkmsg_read() uses 8k buffer and assumes that the formatted output
    message won't overrun which seems safe given LOG_LINE_MAX, the current use
    of dict and the escaping method being used; however, we're planning to use
    devkmsg formatting wider and accounting for the buffer size properly isn't
    that complicated.
    
    This patch defines CONSOLE_EXT_LOG_MAX as 8192 and updates devkmsg_read()
    so that it limits output accordingly.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Kay Sievers <kay@vrfy.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index c099b082cd02..a11549034e07 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -505,6 +505,11 @@ int check_syslog_permissions(int type, bool from_file)
 	return security_syslog(type);
 }
 
+static void append_char(char **pp, char *e, char c)
+{
+	if (*pp < e)
+		*(*pp)++ = c;
+}
 
 /* /dev/kmsg - userspace message inject/listen interface */
 struct devkmsg_user {
@@ -512,7 +517,7 @@ struct devkmsg_user {
 	u32 idx;
 	enum log_flags prev;
 	struct mutex lock;
-	char buf[8192];
+	char buf[CONSOLE_EXT_LOG_MAX];
 };
 
 static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
@@ -570,6 +575,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 {
 	struct devkmsg_user *user = file->private_data;
 	struct printk_log *msg;
+	char *p, *e;
 	u64 ts_usec;
 	size_t i;
 	char cont = '-';
@@ -579,6 +585,9 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 	if (!user)
 		return -EBADF;
 
+	p = user->buf;
+	e = user->buf + sizeof(user->buf);
+
 	ret = mutex_lock_interruptible(&user->lock);
 	if (ret)
 		return ret;
@@ -625,9 +634,9 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 		 ((user->prev & LOG_CONT) && !(msg->flags & LOG_PREFIX)))
 		cont = '+';
 
-	len = sprintf(user->buf, "%u,%llu,%llu,%c;",
-		      (msg->facility << 3) | msg->level,
-		      user->seq, ts_usec, cont);
+	p += scnprintf(p, e - p, "%u,%llu,%llu,%c;",
+		       (msg->facility << 3) | msg->level,
+		       user->seq, ts_usec, cont);
 	user->prev = msg->flags;
 
 	/* escape non-printable characters */
@@ -635,11 +644,11 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 		unsigned char c = log_text(msg)[i];
 
 		if (c < ' ' || c >= 127 || c == '\\')
-			len += sprintf(user->buf + len, "\\x%02x", c);
+			p += scnprintf(p, e - p, "\\x%02x", c);
 		else
-			user->buf[len++] = c;
+			append_char(&p, e, c);
 	}
-	user->buf[len++] = '\n';
+	append_char(&p, e, '\n');
 
 	if (msg->dict_len) {
 		bool line = true;
@@ -648,30 +657,31 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 			unsigned char c = log_dict(msg)[i];
 
 			if (line) {
-				user->buf[len++] = ' ';
+				append_char(&p, e, ' ');
 				line = false;
 			}
 
 			if (c == '\0') {
-				user->buf[len++] = '\n';
+				append_char(&p, e, '\n');
 				line = true;
 				continue;
 			}
 
 			if (c < ' ' || c >= 127 || c == '\\') {
-				len += sprintf(user->buf + len, "\\x%02x", c);
+				p += scnprintf(p, e - p, "\\x%02x", c);
 				continue;
 			}
 
-			user->buf[len++] = c;
+			append_char(&p, e, c);
 		}
-		user->buf[len++] = '\n';
+		append_char(&p, e, '\n');
 	}
 
 	user->idx = log_next(user->idx);
 	user->seq++;
 	raw_spin_unlock_irq(&logbuf_lock);
 
+	len = p - user->buf;
 	if (len > count) {
 		ret = -EINVAL;
 		goto out;

commit 41d5e08ea86af3359239d5a6f7021cdc61beaa49
Merge: 8d582b94291b 5dbc32a88f1e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 21 09:33:10 2015 -0700

    Merge tag 'tty-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here's the big tty/serial driver update for 4.1-rc1.
    
      It was delayed for a bit due to some questions surrounding some of the
      console command line parsing changes that are in here.  There's still
      one tiny regression for people who were previously putting multiple
      console command lines and expecting them all to be ignored for some
      odd reason, but Peter is working on fixing that.  If not, I'll send a
      revert for the offending patch, but I have faith that Peter can
      address it.
    
      Other than the console work here, there's the usual serial driver
      updates and changes, and a buch of 8250 reworks to try to make that
      driver easier to maintain over time, and have it support more devices
      in the future.
    
      All of these have been in linux-next for a while"
    
    * tag 'tty-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (119 commits)
      n_gsm: Drop unneeded cast on netdev_priv
      sc16is7xx: expose RTS inversion in RS-485 mode
      serial: 8250_pci: port failed after wakeup from S3
      earlycon: 8250: Document kernel command line options
      earlycon: 8250: Fix command line regression
      earlycon: Fix __earlycon_table stride
      tty: clean up the tty time logic a bit
      serial: 8250_dw: only get the clock rate in one place
      serial: 8250_dw: remove useless ACPI ID check
      dmaengine: hsu: move memory allocation to GFP_NOWAIT
      dmaengine: hsu: remove redundant pieces of code
      serial: 8250_pci: add Intel Tangier support
      dmaengine: hsu: add Intel Tangier PCI ID
      serial: 8250_pci: replace switch-case by formula for Intel MID
      serial: 8250_pci: replace switch-case by formula
      tty: cpm_uart: replace CONFIG_8xx by CONFIG_CPM1
      serial: jsm: some off by one bugs
      serial: xuartps: Fix check in console_setup().
      serial: xuartps: Get rid of register access macros.
      serial: xuartps: Fix iobase use.
      ...

commit c0fec3a98bd6c4d992f191ee1aa0b3599213f3d4
Merge: c1b8940b42bb e2e40f2c1ed4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:24:41 2015 -0400

    Merge branch 'iocb' into for-next

commit c7cef0a84912cab3c9df8949b034e4aa62982ec9
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Mar 9 16:27:12 2015 -0400

    console: Add extensible console matching
    
    Add match() method to struct console which allows the console to
    perform console command line matching instead of (or in addition to)
    default console matching (ie., by fixed name and index).
    
    The match() method returns 0 to indicate a successful match; normal
    console matching occurs if no match() method is defined or the
    match() method returns non-zero. The match() method is expected to set
    the console index if required.
    
    Re-implement earlycon-to-console-handoff with direct matching of
    "console=uart|uart8250,..." to the 8250 ttyS console.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 26f899809539..dda959221086 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2017,24 +2017,6 @@ int add_preferred_console(char *name, int idx, char *options)
 	return __add_preferred_console(name, idx, options, NULL);
 }
 
-int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, char *options)
-{
-	struct console_cmdline *c;
-	int i;
-
-	for (i = 0, c = console_cmdline;
-	     i < MAX_CMDLINECONSOLES && c->name[0];
-	     i++, c++)
-		if (strcmp(c->name, name) == 0 && c->index == idx) {
-			strlcpy(c->name, name_new, sizeof(c->name));
-			c->options = options;
-			c->index = idx_new;
-			return i;
-		}
-	/* not found */
-	return -1;
-}
-
 bool console_suspend_enabled = true;
 EXPORT_SYMBOL(console_suspend_enabled);
 
@@ -2436,9 +2418,6 @@ void register_console(struct console *newcon)
 	if (preferred_console < 0 || bcon || !console_drivers)
 		preferred_console = selected_console;
 
-	if (newcon->early_setup)
-		newcon->early_setup();
-
 	/*
 	 *	See if we want to use this console driver. If we
 	 *	didn't select a console we take the first one
@@ -2464,21 +2443,26 @@ void register_console(struct console *newcon)
 	for (i = 0, c = console_cmdline;
 	     i < MAX_CMDLINECONSOLES && c->name[0];
 	     i++, c++) {
-		BUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));
-		if (strcmp(c->name, newcon->name) != 0)
-			continue;
-		if (newcon->index >= 0 &&
-		    newcon->index != c->index)
-			continue;
-		if (newcon->index < 0)
-			newcon->index = c->index;
+		if (!newcon->match ||
+		    newcon->match(newcon, c->name, c->index, c->options) != 0) {
+			/* default matching */
+			BUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));
+			if (strcmp(c->name, newcon->name) != 0)
+				continue;
+			if (newcon->index >= 0 &&
+			    newcon->index != c->index)
+				continue;
+			if (newcon->index < 0)
+				newcon->index = c->index;
 
-		if (_braille_register_console(newcon, c))
-			return;
+			if (_braille_register_console(newcon, c))
+				return;
+
+			if (newcon->setup &&
+			    newcon->setup(newcon, c->options) != 0)
+				break;
+		}
 
-		if (newcon->setup &&
-		    newcon->setup(newcon, console_cmdline[i].options) != 0)
-			break;
 		newcon->flags |= CON_ENABLED;
 		if (i == selected_console) {
 			newcon->flags |= CON_CONSDEV;

commit e2e40f2c1ed433c5e224525c8c862fd32e5d3df2
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Feb 22 08:58:50 2015 -0800

    fs: move struct kiocb to fs.h
    
    struct kiocb now is a generic I/O container, so move it to fs.h.
    Also do a #include diet for aio.h while we're at it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 60b2aa2a2da9..40d50cc4c686 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -32,7 +32,6 @@
 #include <linux/security.h>
 #include <linux/bootmem.h>
 #include <linux/memblock.h>
-#include <linux/aio.h>
 #include <linux/syscalls.h>
 #include <linux/kexec.h>
 #include <linux/kdb.h>
@@ -46,6 +45,7 @@
 #include <linux/irq_work.h>
 #include <linux/utsname.h>
 #include <linux/ctype.h>
+#include <linux/uio.h>
 
 #include <asm/uaccess.h>
 

commit 66ee59af630fd8d5f4f56fb28162857e629aa0ab
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 11 19:56:46 2015 +0100

    fs: remove ki_nbytes
    
    There is no need to pass the total request length in the kiocb, as
    we already get passed in through the iov_iter argument.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index c06df7de0963..60b2aa2a2da9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -521,7 +521,7 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 	int i;
 	int level = default_message_loglevel;
 	int facility = 1;	/* LOG_USER */
-	size_t len = iocb->ki_nbytes;
+	size_t len = iov_iter_count(from);
 	ssize_t ret = len;
 
 	if (len > LOG_LINE_MAX)

commit becba85f0e1ca8ab97bd7e836a7129a94ace1ff2
Merge: 9eccca084320 3372ec286220
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 9 07:08:37 2015 +0100

    Merge 4.0-rc3 into tty-testing
    
    This resolves a merge issue in drivers/tty/serial/8250/8250_pci.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f427c990e2d0fd30336b0c252aa7e38e4cffdea2
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 11:05:47 2015 -0500

    console: Preserve index after console setup()
    
    Before register_console() calls the setup() method of the matched
    console, the registering console index is already equal to the index
    from the console command line; ie. newcon->index == c->index.
    
    This change is also required to support extensible console matching;
    (the command line index may have no relation to the console index
    assigned by the console-defined match() function).
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 01cfd69c54c6..d261a7e5f51a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2479,7 +2479,6 @@ void register_console(struct console *newcon)
 		    newcon->setup(newcon, console_cmdline[i].options) != 0)
 			break;
 		newcon->flags |= CON_ENABLED;
-		newcon->index = c->index;
 		if (i == selected_console) {
 			newcon->flags |= CON_CONSDEV;
 			preferred_console = selected_console;

commit 30a22c215a0007603ffc08021f2e8b64018517dd
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 10:11:05 2015 -0500

    console: Fix console name size mismatch
    
    commit 6ae9200f2cab7 ("enlarge console.name") increased the storage
    for the console name to 16 bytes, but not the corresponding
    struct console_cmdline::name storage. Console names longer than
    8 bytes cause read beyond end-of-string and failure to match
    console; I'm not sure if there are other unexpected consequences.
    
    Cc: <stable@vger.kernel.org> # 2.6.22+
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 01cfd69c54c6..bb0635bd74f2 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2464,6 +2464,7 @@ void register_console(struct console *newcon)
 	for (i = 0, c = console_cmdline;
 	     i < MAX_CMDLINECONSOLES && c->name[0];
 	     i++, c++) {
+		BUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));
 		if (strcmp(c->name, newcon->name) != 0)
 			continue;
 		if (newcon->index >= 0 &&

commit 4fbd0a81a0059f22d06780de96e73f9ddbccd8a4
Merge: 7bad2227f639 dd8f30cc0550
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 20 15:13:29 2015 -0800

    Merge tag 'for_linux-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/kgdb
    
    Pull kgdb/kdb updates from Jason Wessel:
     "KGDB/KDB New:
       - KDB: improved searching
       - No longer enter debug core on panic if panic timeout is set
    
      KGDB/KDB regressions / cleanups
       - fix pdf doc build errors
       - prevent junk characters on kdb console from printk levels"
    
    * tag 'for_linux-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/kgdb:
      kgdb, docs: Fix <para> pdfdocs build errors
      debug: prevent entering debug mode on panic/exception.
      kdb: Const qualifier for kdb_getstr's prompt argument
      kdb: Provide forward search at more prompt
      kdb: Fix a prompt management bug when using | grep
      kdb: Remove stack dump when entering kgdb due to NMI
      kdb: Avoid printing KERN_ levels to consoles
      kdb: Fix off by one error in kdb_cpu()
      kdb: fix incorrect counts in KDB summary command output

commit f7d4ca8bbfda23b4f1eae9b6757ff64166b093d5
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Fri Nov 7 18:37:57 2014 +0000

    kdb: Avoid printing KERN_ levels to consoles
    
    Currently when kdb traps printk messages then the raw log level prefix
    (consisting of '\001' followed by a numeral) does not get stripped off
    before the message is issued to the various I/O handlers supported by
    kdb. This causes annoying visual noise as well as causing problems
    grepping for ^. It is also a change of behaviour compared to normal usage
    of printk() usage. For example <SysRq>-h ends up with different output to
    that of kdb's "sr h".
    
    This patch addresses the problem by stripping log levels from messages
    before they are issued to the I/O handlers. printk() which can also
    act as an i/o handler in some cases is special cased; if the caller
    provided a log level then the prefix will be preserved when sent to
    printk().
    
    The addition of non-printable characters to the output of kdb commands is a
    regression, albeit and extremely elderly one, introduced by commit
    04d2c8c83d0e ("printk: convert the format for KERN_<LEVEL> to a 2 byte
    pattern"). Note also that this patch does *not* restore the original
    behaviour from v3.5. Instead it makes printk() from within a kdb command
    display the message without any prefix (i.e. like printk() normally does).
    
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 02d6b6d28796..fae29e3ffbf0 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1811,7 +1811,7 @@ int vprintk_default(const char *fmt, va_list args)
 
 #ifdef CONFIG_KGDB_KDB
 	if (unlikely(kdb_trap_printk)) {
-		r = vkdb_printf(fmt, args);
+		r = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
 		return r;
 	}
 #endif

commit 205bd3d23e938530cb89ff9e14afda389ac85dc3
Author: Joe Perches <joe@perches.com>
Date:   Thu Feb 12 15:01:34 2015 -0800

    printk: correct timeout comment, neaten MODULE_PARM_DESC
    
    Neaten the MODULE_PARAM_DESC message.
    Use 30 seconds in the comment for the zap console locks timeout.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 02d6b6d28796..c06df7de0963 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -935,8 +935,8 @@ static int __init ignore_loglevel_setup(char *str)
 
 early_param("ignore_loglevel", ignore_loglevel_setup);
 module_param(ignore_loglevel, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(ignore_loglevel, "ignore loglevel setting, to"
-	"print all kernel messages to the console.");
+MODULE_PARM_DESC(ignore_loglevel,
+		 "ignore loglevel setting (prints all kernel messages to the console)");
 
 #ifdef CONFIG_BOOT_PRINTK_DELAY
 
@@ -1419,16 +1419,16 @@ static void call_console_drivers(int level, const char *text, size_t len)
 }
 
 /*
- * Zap console related locks when oopsing. Only zap at most once
- * every 10 seconds, to leave time for slow consoles to print a
- * full oops.
+ * Zap console related locks when oopsing.
+ * To leave time for slow consoles to print a full oops,
+ * only zap at most once every 30 seconds.
  */
 static void zap_locks(void)
 {
 	static unsigned long oops_timestamp;
 
 	if (time_after_eq(jiffies, oops_timestamp) &&
-			!time_after(jiffies, oops_timestamp + 30 * HZ))
+	    !time_after(jiffies, oops_timestamp + 30 * HZ))
 		return;
 
 	oops_timestamp = jiffies;

commit 8f4385d590d4296ec38e228d17b1d002f6031dd2
Merge: 52bb452558a4 1fb8915b9876
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 13 14:04:41 2014 -0800

    Merge tag 'trace-seq-buf-3.19-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing fixlet from Steven Rostedt:
     "Remove unnecessary preempt_disable in printk()"
    
    * tag 'trace-seq-buf-3.19-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace:
      printk: Do not disable preemption for accessing printk_func

commit 1fb8915b9876a80f43732980208b39d013f8da9d
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Thu Dec 11 09:12:01 2014 -0500

    printk: Do not disable preemption for accessing printk_func
    
    As printk_func will either be the default function, or a per_cpu function
    for the current CPU, there's no reason to disable preemption to access
    it from printk. That's because if the printk_func is not the default
    then the caller had better disabled preemption as they were the one to
    change it.
    
    Link: http://lkml.kernel.org/r/CA+55aFz5-_LKW4JHEBoWinN9_ouNcGRWAF2FUA35u46FRN-Kxw@mail.gmail.com
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5af2b8bc88f0..9b896e7a50a9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1859,10 +1859,16 @@ asmlinkage __visible int printk(const char *fmt, ...)
 	int r;
 
 	va_start(args, fmt);
-	preempt_disable();
+
+	/*
+	 * If a caller overrides the per_cpu printk_func, then it needs
+	 * to disable preemption when calling printk(). Otherwise
+	 * the printk_func should be set to the default. No need to
+	 * disable preemption here.
+	 */
 	vprintk_func = this_cpu_read(printk_func);
 	r = vprintk_func(fmt, args);
-	preempt_enable();
+
 	va_end(args);
 
 	return r;

commit 350e4f4985472e29091b899bc227d75d2a66fb4c
Merge: c32809521de5 db0865543739
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 20:35:41 2014 -0800

    Merge tag 'trace-seq-buf-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull nmi-safe seq_buf printk update from Steven Rostedt:
     "This code is a fork from the trace-3.19 pull as it needed the
      trace_seq clean ups from that branch.
    
      This code solves the issue of performing stack dumps from NMI context.
      The issue is that printk() is not safe from NMI context as if the NMI
      were to trigger when a printk() was being performed, the NMI could
      deadlock from the printk() internal locks.  This has been seen in
      practice.
    
      With lots of review from Petr Mladek, this code went through several
      iterations, and we feel that it is now at a point of quality to be
      accepted into mainline.
    
      Here's what is contained in this patch set:
    
       - Creates a "seq_buf" generic buffer utility that allows a descriptor
         to be passed around where functions can write their own "printk()"
         formatted strings into it.  The generic version was pulled out of
         the trace_seq() code that was made specifically for tracing.
    
       - The seq_buf code was change to model the seq_file code.  I have a
         patch (not included for 3.19) that converts the seq_file.c code
         over to use seq_buf.c like the trace_seq.c code does.  This was
         done to make sure that seq_buf.c is compatible with seq_file.c.  I
         may try to get that patch in for 3.20.
    
       - The seq_buf.c file was moved to lib/ to remove it from being
         dependent on CONFIG_TRACING.
    
       - The printk() was updated to allow for a per_cpu "override" of the
         internal calls.  That is, instead of writing to the console, a call
         to printk() may do something else.  This made it easier to allow
         the NMI to change what printk() does in order to call dump_stack()
         without needing to update that code as well.
    
       - Finally, the dump_stack from all CPUs via NMI code was converted to
         use the seq_buf code.  The caller to trigger the NMI code would
         wait till all the NMIs finished, and then it would print the
         seq_buf data to the console safely from a non NMI context
    
      One added bonus is that this code also makes the NMI dump stack work
      on PREEMPT_RT kernels.  As printk() includes sleeping locks on
      PREEMPT_RT, printk() only writes to console if the console does not
      use any rt_mutex converted spin locks.  Which a lot do"
    
    * tag 'trace-seq-buf-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace:
      x86/nmi: Fix use of unallocated cpumask_var_t
      printk/percpu: Define printk_func when printk is not defined
      x86/nmi: Perform a safe NMI stack trace on all CPUs
      printk: Add per_cpu printk func to allow printk to be diverted
      seq_buf: Move the seq_buf code to lib/
      seq-buf: Make seq_buf_bprintf() conditional on CONFIG_BINARY_PRINTF
      tracing: Add seq_buf_get_buf() and seq_buf_commit() helper functions
      tracing: Have seq_buf use full buffer
      seq_buf: Add seq_buf_can_fit() helper function
      tracing: Add paranoid size check in trace_printk_seq()
      tracing: Use trace_seq_used() and seq_buf_used() instead of len
      tracing: Clean up tracing_fill_pipe_page()
      seq_buf: Create seq_buf_used() to find out how much was written
      tracing: Add a seq_buf_clear() helper and clear len and readpos in init
      tracing: Convert seq_buf fields to be like seq_file fields
      tracing: Convert seq_buf_path() to be like seq_path()
      tracing: Create seq_buf layer in trace_seq

commit b6da0076bab5a12afb19312ffee41c95490af2a0
Merge: cbfe0de303a5 a53b83154914
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 18:34:42 2014 -0800

    Merge branch 'akpm' (patchbomb from Andrew)
    
    Merge first patchbomb from Andrew Morton:
     - a few minor cifs fixes
     - dma-debug upadtes
     - ocfs2
     - slab
     - about half of MM
     - procfs
     - kernel/exit.c
     - panic.c tweaks
     - printk upates
     - lib/ updates
     - checkpatch updates
     - fs/binfmt updates
     - the drivers/rtc tree
     - nilfs
     - kmod fixes
     - more kernel/exit.c
     - various other misc tweaks and fixes
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (190 commits)
      exit: pidns: fix/update the comments in zap_pid_ns_processes()
      exit: pidns: alloc_pid() leaks pid_namespace if child_reaper is exiting
      exit: exit_notify: re-use "dead" list to autoreap current
      exit: reparent: call forget_original_parent() under tasklist_lock
      exit: reparent: avoid find_new_reaper() if no children
      exit: reparent: introduce find_alive_thread()
      exit: reparent: introduce find_child_reaper()
      exit: reparent: document the ->has_child_subreaper checks
      exit: reparent: s/while_each_thread/for_each_thread/ in find_new_reaper()
      exit: reparent: fix the cross-namespace PR_SET_CHILD_SUBREAPER reparenting
      exit: reparent: fix the dead-parent PR_SET_CHILD_SUBREAPER reparenting
      exit: proc: don't try to flush /proc/tgid/task/tgid
      exit: release_task: fix the comment about group leader accounting
      exit: wait: drop tasklist_lock before psig->c* accounting
      exit: wait: don't use zombie->real_parent
      exit: wait: cleanup the ptrace_reparented() checks
      usermodehelper: kill the kmod_thread_locker logic
      usermodehelper: don't use CLONE_VFORK for ____call_usermodehelper()
      fs/hfs/catalog.c: fix comparison bug in hfs_cat_keycmp
      nilfs2: fix the nilfs_iget() vs. nilfs_new_inode() races
      ...

commit f099755d4c8523d72b45f13f02d3fc375d080e18
Author: Alex Elder <elder@linaro.org>
Date:   Wed Dec 10 15:51:21 2014 -0800

    printk: drop logbuf_cpu volatile qualifier
    
    Pranith Kumar posted a patch in which removed the "volatile"
    qualifier for the "logbuf_cpu" variable in vprintk_emit().
        https://lkml.org/lkml/2014/11/13/894
    In his patch, he used ACCESS_ONCE() for all references to
    that symbol to provide whatever protection was intended.
    
    There was some discussion that followed, and in the end Steven Rostedt
    concluded that not only was "volatile" not needed, neither was it
    required to use ACCESS_ONCE().  I offered an elaborate description that
    concluded Steven was right, and Pranith asked me to submit an
    alternative patch.  And this is it.
    
    The basic reason "volatile" is not needed is that "logbuf_cpu" has
    static storage duration, and vprintk_emit() is an exported
    interface.  This means that the value of logbuf_cpu must be read
    from memory the first time it is used in a particular call of
    vprintk_emit().  The variable's value is read only once in that
    function, when it's read it'll be the copy from memory (or cache).
    
    In addition, the value of "logbuf_cpu" is only ever written under
    protection of a spinlock.  So the value that is read is the "real"
    value (and not an out-of-date cached one).  If its value is not
    UINT_MAX, it is the current CPU's processor id, and it will have
    been last written by the running CPU.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reported-by: Pranith Kumar <bobby.prani@gmail.com>
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1b7092dbb590..218ea26d75b8 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1624,7 +1624,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	int printed_len = 0;
 	bool in_sched = false;
 	/* cpu currently holding logbuf_lock in this function */
-	static volatile unsigned int logbuf_cpu = UINT_MAX;
+	static unsigned int logbuf_cpu = UINT_MAX;
 
 	if (level == LOGLEVEL_SCHED) {
 		level = LOGLEVEL_DEFAULT;

commit a39d4a857d4bb0a62d6655c0d69f7387fe1ad160
Author: Joe Perches <joe@perches.com>
Date:   Wed Dec 10 15:50:15 2014 -0800

    printk: add and use LOGLEVEL_<level> defines for KERN_<LEVEL> equivalents
    
    Use #defines instead of magic values.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jason Baron <jbaron@akamai.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4815c98ae175..1b7092dbb590 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -62,9 +62,6 @@ int console_printk[4] = {
 	CONSOLE_LOGLEVEL_DEFAULT,	/* default_console_loglevel */
 };
 
-/* Deferred messaged from sched code are marked by this special level */
-#define SCHED_MESSAGE_LOGLEVEL -2
-
 /*
  * Low level drivers may need that to know if they can schedule in
  * their unblank() callback or not. So let's export it.
@@ -1259,7 +1256,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 int do_syslog(int type, char __user *buf, int len, bool from_file)
 {
 	bool clear = false;
-	static int saved_console_loglevel = -1;
+	static int saved_console_loglevel = LOGLEVEL_DEFAULT;
 	int error;
 
 	error = check_syslog_permissions(type, from_file);
@@ -1316,15 +1313,15 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 		break;
 	/* Disable logging to console */
 	case SYSLOG_ACTION_CONSOLE_OFF:
-		if (saved_console_loglevel == -1)
+		if (saved_console_loglevel == LOGLEVEL_DEFAULT)
 			saved_console_loglevel = console_loglevel;
 		console_loglevel = minimum_console_loglevel;
 		break;
 	/* Enable logging to console */
 	case SYSLOG_ACTION_CONSOLE_ON:
-		if (saved_console_loglevel != -1) {
+		if (saved_console_loglevel != LOGLEVEL_DEFAULT) {
 			console_loglevel = saved_console_loglevel;
-			saved_console_loglevel = -1;
+			saved_console_loglevel = LOGLEVEL_DEFAULT;
 		}
 		break;
 	/* Set level of messages printed to console */
@@ -1336,7 +1333,7 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 			len = minimum_console_loglevel;
 		console_loglevel = len;
 		/* Implicitly re-enable logging to console */
-		saved_console_loglevel = -1;
+		saved_console_loglevel = LOGLEVEL_DEFAULT;
 		error = 0;
 		break;
 	/* Number of chars in the log buffer */
@@ -1629,8 +1626,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 	/* cpu currently holding logbuf_lock in this function */
 	static volatile unsigned int logbuf_cpu = UINT_MAX;
 
-	if (level == SCHED_MESSAGE_LOGLEVEL) {
-		level = -1;
+	if (level == LOGLEVEL_SCHED) {
+		level = LOGLEVEL_DEFAULT;
 		in_sched = true;
 	}
 
@@ -1695,8 +1692,9 @@ asmlinkage int vprintk_emit(int facility, int level,
 			const char *end_of_header = printk_skip_level(text);
 			switch (kern_level) {
 			case '0' ... '7':
-				if (level == -1)
+				if (level == LOGLEVEL_DEFAULT)
 					level = kern_level - '0';
+				/* fallthrough */
 			case 'd':	/* KERN_DEFAULT */
 				lflags |= LOG_PREFIX;
 			}
@@ -1710,7 +1708,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		}
 	}
 
-	if (level == -1)
+	if (level == LOGLEVEL_DEFAULT)
 		level = default_message_loglevel;
 
 	if (dict)
@@ -1788,7 +1786,7 @@ EXPORT_SYMBOL(vprintk_emit);
 
 asmlinkage int vprintk(const char *fmt, va_list args)
 {
-	return vprintk_emit(0, -1, NULL, 0, fmt, args);
+	return vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
 }
 EXPORT_SYMBOL(vprintk);
 
@@ -1842,7 +1840,7 @@ asmlinkage __visible int printk(const char *fmt, ...)
 	}
 #endif
 	va_start(args, fmt);
-	r = vprintk_emit(0, -1, NULL, 0, fmt, args);
+	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
 	va_end(args);
 
 	return r;
@@ -2631,7 +2629,7 @@ int printk_deferred(const char *fmt, ...)
 
 	preempt_disable();
 	va_start(args, fmt);
-	r = vprintk_emit(0, SCHED_MESSAGE_LOGLEVEL, NULL, 0, fmt, args);
+	r = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);
 	va_end(args);
 
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);

commit 1dc6244bd6d4f62239487fb0befc41c63e117290
Author: Joe Perches <joe@perches.com>
Date:   Wed Dec 10 15:45:53 2014 -0800

    printk: remove used-once early_vprintk
    
    Eliminate the unlikely possibility of message interleaving for
    early_printk/early_vprintk use.
    
    early_vprintk can be done via the %pV extension so remove this
    unnecessary function and change early_printk to have the equivalent
    vprintk code.
    
    All uses of early_printk already end with a newline so also remove the
    unnecessary newline from the early_printk function.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ced2b84b1cb7..4815c98ae175 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1881,23 +1881,20 @@ static size_t cont_print_text(char *text, size_t size) { return 0; }
 #ifdef CONFIG_EARLY_PRINTK
 struct console *early_console;
 
-void early_vprintk(const char *fmt, va_list ap)
-{
-	if (early_console) {
-		char buf[512];
-		int n = vscnprintf(buf, sizeof(buf), fmt, ap);
-
-		early_console->write(early_console, buf, n);
-	}
-}
-
 asmlinkage __visible void early_printk(const char *fmt, ...)
 {
 	va_list ap;
+	char buf[512];
+	int n;
+
+	if (!early_console)
+		return;
 
 	va_start(ap, fmt);
-	early_vprintk(fmt, ap);
+	n = vscnprintf(buf, sizeof(buf), fmt, ap);
 	va_end(ap);
+
+	early_console->write(early_console, buf, n);
 }
 #endif
 

commit 04b74b27c2941e5d62120f6fee3a0a9388a30613
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Fri Nov 21 09:16:58 2014 -0500

    printk/percpu: Define printk_func when printk is not defined
    
    To avoid include hell, the per_cpu variable printk_func was declared
    in percpu.h. But it is only defined if printk is defined.
    
    As users of printk may also use the printk_func variable, it needs to
    be defined even if CONFIG_PRINTK is not.
    
    Also add a printk.h include in percpu.h just to be safe.
    
    Link: http://lkml.kernel.org/r/20141121183215.01ba539c@canb.auug.org.au
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f7b723f98cb9..5af2b8bc88f0 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1896,6 +1896,9 @@ static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static size_t cont_print_text(char *text, size_t size) { return 0; }
 
+/* Still needs to be defined for users */
+DEFINE_PER_CPU(printk_func_t, printk_func);
+
 #endif /* CONFIG_PRINTK */
 
 #ifdef CONFIG_EARLY_PRINTK

commit afdc34a3d3b823a12a93b822ee1efb566f884032
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Thu Jun 19 17:33:31 2014 -0400

    printk: Add per_cpu printk func to allow printk to be diverted
    
    Being able to divert printk to call another function besides the normal
    logging is useful for such things like NMI handling. If some functions
    are to be called from NMI that does printk() it is possible to lock up
    the box if the nmi handler triggers when another printk is happening.
    
    One example of this use is to perform a stack trace on all CPUs via NMI.
    But if the NMI is to do the printk() it can cause the system to lock up.
    By allowing the printk to be diverted to another function that can safely
    record the printk output and then print it when it in a safe context
    then NMIs will be safe to call these functions like show_regs().
    
    Link: http://lkml.kernel.org/p/20140619213952.209176403@goodmis.org
    
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ced2b84b1cb7..f7b723f98cb9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1807,6 +1807,30 @@ asmlinkage int printk_emit(int facility, int level,
 }
 EXPORT_SYMBOL(printk_emit);
 
+int vprintk_default(const char *fmt, va_list args)
+{
+	int r;
+
+#ifdef CONFIG_KGDB_KDB
+	if (unlikely(kdb_trap_printk)) {
+		r = vkdb_printf(fmt, args);
+		return r;
+	}
+#endif
+	r = vprintk_emit(0, -1, NULL, 0, fmt, args);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(vprintk_default);
+
+/*
+ * This allows printk to be diverted to another function per cpu.
+ * This is useful for calling printk functions from within NMI
+ * without worrying about race conditions that can lock up the
+ * box.
+ */
+DEFINE_PER_CPU(printk_func_t, printk_func) = vprintk_default;
+
 /**
  * printk - print a kernel message
  * @fmt: format string
@@ -1830,19 +1854,15 @@ EXPORT_SYMBOL(printk_emit);
  */
 asmlinkage __visible int printk(const char *fmt, ...)
 {
+	printk_func_t vprintk_func;
 	va_list args;
 	int r;
 
-#ifdef CONFIG_KGDB_KDB
-	if (unlikely(kdb_trap_printk)) {
-		va_start(args, fmt);
-		r = vkdb_printf(fmt, args);
-		va_end(args);
-		return r;
-	}
-#endif
 	va_start(args, fmt);
-	r = vprintk_emit(0, -1, NULL, 0, fmt, args);
+	preempt_disable();
+	vprintk_func = this_cpu_read(printk_func);
+	r = vprintk_func(fmt, args);
+	preempt_enable();
 	va_end(args);
 
 	return r;

commit 68c4a4f8abc60c9440ede9cd123d48b78325f7a3
Author: Sebastian Schmidt <yath@yath.de>
Date:   Sun Oct 19 20:05:15 2014 +0200

    pstore: Honor dmesg_restrict sysctl on dmesg dumps
    
    When the kernel.dmesg_restrict restriction is in place, only users with
    CAP_SYSLOG should be able to access crash dumps (like: attacker is
    trying to exploit a bug, watchdog reboots, attacker can happily read
    crash dumps and logs).
    
    This puts the restriction on console-* types as well as sensitive
    information could have been leaked there.
    
    Other log types are unaffected.
    
    Signed-off-by: Sebastian Schmidt <yath@yath.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ced2b84b1cb7..c8755e7e1dba 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -480,7 +480,7 @@ static int syslog_action_restricted(int type)
 	       type != SYSLOG_ACTION_SIZE_BUFFER;
 }
 
-static int check_syslog_permissions(int type, bool from_file)
+int check_syslog_permissions(int type, bool from_file)
 {
 	/*
 	 * If this is from /proc/kmsg and we've already opened it, then we've

commit 0429fbc0bdc297d64188483ba029a23773ae07b0
Merge: 6929c358972f 513d1a2884a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 15 07:48:18 2014 +0200

    Merge branch 'for-3.18-consistent-ops' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/percpu
    
    Pull percpu consistent-ops changes from Tejun Heo:
     "Way back, before the current percpu allocator was implemented, static
      and dynamic percpu memory areas were allocated and handled separately
      and had their own accessors.  The distinction has been gone for many
      years now; however, the now duplicate two sets of accessors remained
      with the pointer based ones - this_cpu_*() - evolving various other
      operations over time.  During the process, we also accumulated other
      inconsistent operations.
    
      This pull request contains Christoph's patches to clean up the
      duplicate accessor situation.  __get_cpu_var() uses are replaced with
      with this_cpu_ptr() and __this_cpu_ptr() with raw_cpu_ptr().
    
      Unfortunately, the former sometimes is tricky thanks to C being a bit
      messy with the distinction between lvalues and pointers, which led to
      a rather ugly solution for cpumask_var_t involving the introduction of
      this_cpu_cpumask_var_ptr().
    
      This converts most of the uses but not all.  Christoph will follow up
      with the remaining conversions in this merge window and hopefully
      remove the obsolete accessors"
    
    * 'for-3.18-consistent-ops' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/percpu: (38 commits)
      irqchip: Properly fetch the per cpu offset
      percpu: Resolve ambiguities in __get_cpu_var/cpumask_var_t -fix
      ia64: sn_nodepda cannot be assigned to after this_cpu conversion. Use __this_cpu_write.
      percpu: Resolve ambiguities in __get_cpu_var/cpumask_var_t
      Revert "powerpc: Replace __get_cpu_var uses"
      percpu: Remove __this_cpu_ptr
      clocksource: Replace __this_cpu_ptr with raw_cpu_ptr
      sparc: Replace __get_cpu_var uses
      avr32: Replace __get_cpu_var with __this_cpu_write
      blackfin: Replace __get_cpu_var uses
      tile: Use this_cpu_ptr() for hardware counters
      tile: Replace __get_cpu_var uses
      powerpc: Replace __get_cpu_var uses
      alpha: Replace __get_cpu_var
      ia64: Replace __get_cpu_var uses
      s390: cio driver &__get_cpu_var replacements
      s390: Replace __get_cpu_var uses
      mips: Replace __get_cpu_var uses
      MIPS: Replace __get_cpu_var uses in FPU emulator.
      arm: Replace __this_cpu_ptr with raw_cpu_ptr
      ...

commit 98e35f5894cf208084688ec0c7bb7b713efc997f
Author: Markus Trippelsdorf <markus@trippelsdorf.de>
Date:   Mon Oct 13 15:51:13 2014 -0700

    printk: git rid of [sched_delayed] message for printk_deferred
    
    Commit 458df9fd4815 ("printk: remove separate printk_sched buffers and use
    printk buf instead") hardcodes printk_deferred() to KERN_WARNING and
    inserts the string "[sched_delayed] " before the actual message.  However
    it doesn't take into account the KERN_* prefix of the message, that now
    ends up in the middle of the output:
    
     [sched_delayed] ^a4CE: hpet increased min_delta_ns to 20115 nsec
    
    Fix this by just getting rid of the "[sched_delayed] " scnprintf().  The
    prefix is useless since 458df9fd4815 anyway since from that moment
    printk_deferred() inserts the message into the kernel printk buffer
    immediately.  So if the message eventually gets printed to console, it is
    printed in the correct order with other messages and there's no need for
    any special prefix.  And if the kernel crashes before the message makes it
    to console, then prefix in the printk buffer doesn't make the situation
    any better.
    
    Link: http://lkml.org/lkml/2014/9/14/4
    
    Signed-off-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Acked-by: Jan Kara <jack@suse.cz>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a4436b0cf769..e3962d63e368 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1679,12 +1679,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.
 	 */
-	if (in_sched)
-		text_len = scnprintf(text, sizeof(textbuf),
-				     KERN_WARNING "[sched_delayed] ");
-
-	text_len += vscnprintf(text + text_len,
-			       sizeof(textbuf) - text_len, fmt, args);
+	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
 
 	/* mark and strip a trailing newline */
 	if (text_len && text[text_len-1] == '\n') {

commit 2240a31db67582468e2f7a5a5962b7d0ffaaa6a4
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 13 15:51:11 2014 -0700

    printk: don't bother using LOG_CPU_MAX_BUF_SHIFT on !SMP
    
    When configuring a uniprocessor kernel, don't bother the user with an
    irrelevant LOG_CPU_MAX_BUF_SHIFT question, and don't build the unused
    code.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 7a6e69441f75..a4436b0cf769 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -267,7 +267,6 @@ static u32 clear_idx;
 #define LOG_ALIGN __alignof__(struct printk_log)
 #endif
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
-#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
@@ -852,6 +851,9 @@ static int __init log_buf_len_setup(char *str)
 }
 early_param("log_buf_len", log_buf_len_setup);
 
+#ifdef CONFIG_SMP
+#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)
+
 static void __init log_buf_add_cpu(void)
 {
 	unsigned int cpu_extra;
@@ -878,6 +880,9 @@ static void __init log_buf_add_cpu(void)
 
 	log_buf_len_update(cpu_extra + __LOG_BUF_LEN);
 }
+#else /* !CONFIG_SMP */
+static inline void log_buf_add_cpu(void) {}
+#endif /* CONFIG_SMP */
 
 void __init setup_log_buf(int early)
 {

commit 849f3127bb46ef75a66dffc1b9b0d3f5f43fa395
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Aug 23 12:23:53 2014 -0400

    switch /dev/kmsg to ->write_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 1ce770687ea8..7a6e69441f75 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -519,14 +519,13 @@ struct devkmsg_user {
 	char buf[8192];
 };
 
-static ssize_t devkmsg_writev(struct kiocb *iocb, const struct iovec *iv,
-			      unsigned long count, loff_t pos)
+static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	char *buf, *line;
 	int i;
 	int level = default_message_loglevel;
 	int facility = 1;	/* LOG_USER */
-	size_t len = iov_length(iv, count);
+	size_t len = iocb->ki_nbytes;
 	ssize_t ret = len;
 
 	if (len > LOG_LINE_MAX)
@@ -535,13 +534,10 @@ static ssize_t devkmsg_writev(struct kiocb *iocb, const struct iovec *iv,
 	if (buf == NULL)
 		return -ENOMEM;
 
-	line = buf;
-	for (i = 0; i < count; i++) {
-		if (copy_from_user(line, iv[i].iov_base, iv[i].iov_len)) {
-			ret = -EFAULT;
-			goto out;
-		}
-		line += iv[i].iov_len;
+	buf[len] = '\0';
+	if (copy_from_iter(buf, len, from) != len) {
+		kfree(buf);
+		return -EFAULT;
 	}
 
 	/*
@@ -567,10 +563,8 @@ static ssize_t devkmsg_writev(struct kiocb *iocb, const struct iovec *iv,
 			line = endp;
 		}
 	}
-	line[len] = '\0';
 
 	printk_emit(facility, level, NULL, 0, "%s", line);
-out:
 	kfree(buf);
 	return ret;
 }
@@ -802,7 +796,7 @@ static int devkmsg_release(struct inode *inode, struct file *file)
 const struct file_operations kmsg_fops = {
 	.open = devkmsg_open,
 	.read = devkmsg_read,
-	.aio_write = devkmsg_writev,
+	.write_iter = devkmsg_write,
 	.llseek = devkmsg_llseek,
 	.poll = devkmsg_poll,
 	.release = devkmsg_release,

commit 000a7d66ec30898f46869be01ab8205b056385d0
Author: Patrick Palka <patrick@parcs.ath.cx>
Date:   Tue Sep 9 14:50:48 2014 -0700

    kernel/printk/printk.c: fix faulty logic in the case of recursive printk
    
    We shouldn't set text_len in the code path that detects printk recursion
    because text_len corresponds to the length of the string inside textbuf.
    A few lines down from the line
    
        text_len = strlen(recursion_msg);
    
    is the line
    
        text_len += vscnprintf(text + text_len, ...);
    
    So if printk detects recursion, it sets text_len to 29 (the length of
    recursion_msg) and logs an error.  Then the message supplied by the
    caller of printk is stored inside textbuf but offset by 29 bytes.  This
    means that the output of the recursive call to printk will contain 29
    bytes of garbage in front of it.
    
    This defect is caused by commit 458df9fd4815 ("printk: remove separate
    printk_sched buffers and use printk buf instead") which turned the line
    
        text_len = vscnprintf(text, ...);
    
    into
    
        text_len += vscnprintf(text + text_len, ...);
    
    To fix this, this patch avoids setting text_len when logging the printk
    recursion error.  This patch also marks unlikely() the branch leading up
    to this code.
    
    Fixes: 458df9fd4815b478 ("printk: remove separate printk_sched buffers and use printk buf instead")
    Signed-off-by: Patrick Palka <patrick@parcs.ath.cx>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e04c455a0e38..1ce770687ea8 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1665,15 +1665,15 @@ asmlinkage int vprintk_emit(int facility, int level,
 	raw_spin_lock(&logbuf_lock);
 	logbuf_cpu = this_cpu;
 
-	if (recursion_bug) {
+	if (unlikely(recursion_bug)) {
 		static const char recursion_msg[] =
 			"BUG: recent printk recursion!";
 
 		recursion_bug = 0;
-		text_len = strlen(recursion_msg);
 		/* emit KERN_CRIT message */
 		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
-					 NULL, 0, recursion_msg, text_len);
+					 NULL, 0, recursion_msg,
+					 strlen(recursion_msg));
 	}
 
 	/*

commit bb964a92ce70ac2039115edd019aa5eef8faa6bb
Author: Christoph Lameter <cl@linux.com>
Date:   Sun Aug 17 12:30:24 2014 -0500

    kernel misc: Replace __get_cpu_var uses
    
    Replace uses of __get_cpu_var for address calculation with this_cpu_ptr.
    
    Cc: akpm@linux-foundation.org
    Signed-off-by: Christoph Lameter <cl@linux.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e04c455a0e38..960fbfc6cd0a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2628,7 +2628,7 @@ void wake_up_klogd(void)
 	preempt_disable();
 	if (waitqueue_active(&log_wait)) {
 		this_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);
-		irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+		irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));
 	}
 	preempt_enable();
 }
@@ -2644,7 +2644,7 @@ int printk_deferred(const char *fmt, ...)
 	va_end(args);
 
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
-	irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+	irq_work_queue(this_cpu_ptr(&wake_up_klogd_work));
 	preempt_enable();
 
 	return r;

commit 14c4000a88afaaa2d0877cc86d42a74fde0f35e0
Author: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>
Date:   Sat Aug 9 11:15:30 2014 +0530

    printk: Add function to return log buffer address and size
    
    Platforms like IBM Power Systems supports service processor
    assisted dump. It provides interface to add memory region to
    be captured when system is crashed.
    
    During initialization/running we can add kernel memory region
    to be collected.
    
    Presently we don't have a way to get the log buffer base address
    and size. This patch adds support to return log buffer address
    and size.
    
    Signed-off-by: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index de1a6bb6861d..e04c455a0e38 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -272,6 +272,18 @@ static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
 
+/* Return log buffer address */
+char *log_buf_addr_get(void)
+{
+	return log_buf;
+}
+
+/* Return log buffer size */
+u32 log_buf_len_get(void)
+{
+	return log_buf_len;
+}
+
 /* human readable text of the record */
 static char *log_text(const struct printk_log *msg)
 {

commit d25d9feced6c94398979a035868f03e8e8d49ce8
Author: Neil Zhang <zhangwm@marvell.com>
Date:   Wed Aug 6 16:09:12 2014 -0700

    kernel/printk/printk.c: fix bool assignements
    
    Fix coccinelle warnings.
    
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index df202fe0974a..de1a6bb6861d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -919,7 +919,7 @@ static bool __read_mostly ignore_loglevel;
 
 static int __init ignore_loglevel_setup(char *str)
 {
-	ignore_loglevel = 1;
+	ignore_loglevel = true;
 	pr_info("debug: ignoring loglevel setting.\n");
 
 	return 0;
@@ -2005,12 +2005,12 @@ int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, cha
 	return -1;
 }
 
-bool console_suspend_enabled = 1;
+bool console_suspend_enabled = true;
 EXPORT_SYMBOL(console_suspend_enabled);
 
 static int __init console_suspend_disable(char *str)
 {
-	console_suspend_enabled = 0;
+	console_suspend_enabled = false;
 	return 1;
 }
 __setup("no_console_suspend", console_suspend_disable);

commit 5874af2003b1aaaa053128d655710140e3187226
Author: Jan Kara <jack@suse.cz>
Date:   Wed Aug 6 16:09:10 2014 -0700

    printk: enable interrupts before calling console_trylock_for_printk()
    
    We need interrupts disabled when calling console_trylock_for_printk()
    only so that cpu id we pass to can_use_console() remains valid (for
    other things console_sem provides all the exclusion we need and
    deadlocks on console_sem due to interrupts are impossible because we use
    down_trylock()).  However if we are rescheduled, we are guaranteed to
    run on an online cpu so we can easily just get the cpu id in
    can_use_console().
    
    We can lose a bit of performance when we enable interrupts in
    vprintk_emit() and then disable them again in console_unlock() but OTOH
    it can somewhat reduce interrupt latency caused by console_unlock().
    
    We differ from (reverted) commit 939f04bec1a4 in that we avoid calling
    console_unlock() from vprintk_emit() with lockdep enabled as that has
    unveiled quite some bugs leading to system freezes during boot (e.g.
      https://lkml.org/lkml/2014/5/30/242,
      https://lkml.org/lkml/2014/6/28/521).
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Tested-by: Andreas Bombe <aeb@debian.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5eb0e6c800bb..df202fe0974a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1450,10 +1450,9 @@ static int have_callable_console(void)
 /*
  * Can we actually use the console at this time on this cpu?
  *
- * Console drivers may assume that per-cpu resources have
- * been allocated. So unless they're explicitly marked as
- * being able to cope (CON_ANYTIME) don't call them until
- * this CPU is officially up.
+ * Console drivers may assume that per-cpu resources have been allocated. So
+ * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
+ * call them until this CPU is officially up.
  */
 static inline int can_use_console(unsigned int cpu)
 {
@@ -1466,8 +1465,10 @@ static inline int can_use_console(unsigned int cpu)
  * console_lock held, and 'console_locked' set) if it
  * is successful, false otherwise.
  */
-static int console_trylock_for_printk(unsigned int cpu)
+static int console_trylock_for_printk(void)
 {
+	unsigned int cpu = smp_processor_id();
+
 	if (!console_trylock())
 		return 0;
 	/*
@@ -1642,7 +1643,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (!oops_in_progress && !lockdep_recursing(current)) {
 			recursion_bug = 1;
-			goto out_restore_irqs;
+			local_irq_restore(flags);
+			return 0;
 		}
 		zap_locks();
 	}
@@ -1750,21 +1752,30 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);
+	lockdep_on();
+	local_irq_restore(flags);
 
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
+		lockdep_off();
+		/*
+		 * Disable preemption to avoid being preempted while holding
+		 * console_sem which would prevent anyone from printing to
+		 * console
+		 */
+		preempt_disable();
+
 		/*
 		 * Try to acquire and then immediately release the console
 		 * semaphore.  The release will print out buffers and wake up
 		 * /dev/kmsg and syslog() users.
 		 */
-		if (console_trylock_for_printk(this_cpu))
+		if (console_trylock_for_printk())
 			console_unlock();
+		preempt_enable();
+		lockdep_on();
 	}
 
-	lockdep_on();
-out_restore_irqs:
-	local_irq_restore(flags);
 	return printed_len;
 }
 EXPORT_SYMBOL(vprintk_emit);

commit 249771b8307e7a91659d8b273f8b70d48c3a7bfc
Author: Alex Elder <elder@linaro.org>
Date:   Wed Aug 6 16:09:08 2014 -0700

    printk: miscellaneous cleanups
    
    Some small cleanups to kernel/printk/printk.c.  None of them should
    cause any change in behavior.
    
      - When CONFIG_PRINTK is defined, parenthesize the value of LOG_LINE_MAX.
      - When CONFIG_PRINTK is *not* defined, there is an extra LOG_LINE_MAX
        definition; delete it.
      - Pull an assignment out of a conditional expression in console_setup().
      - Use isdigit() in console_setup() rather than open coding it.
      - In update_console_cmdline(), drop a NUL-termination assignment;
        the strlcpy() call that precedes it guarantees it's not needed.
      - Simplify some logic in printk_timed_ratelimit().
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jan Kara <jack@suse.cz>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ac86838227ed..5eb0e6c800bb 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -45,6 +45,7 @@
 #include <linux/poll.h>
 #include <linux/irq_work.h>
 #include <linux/utsname.h>
+#include <linux/ctype.h>
 
 #include <asm/uaccess.h>
 
@@ -257,7 +258,7 @@ static u64 clear_seq;
 static u32 clear_idx;
 
 #define PREFIX_MAX		32
-#define LOG_LINE_MAX		1024 - PREFIX_MAX
+#define LOG_LINE_MAX		(1024 - PREFIX_MAX)
 
 /* record buffer */
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
@@ -1835,7 +1836,7 @@ EXPORT_SYMBOL(printk);
 
 #define LOG_LINE_MAX		0
 #define PREFIX_MAX		0
-#define LOG_LINE_MAX 0
+
 static u64 syslog_seq;
 static u32 syslog_idx;
 static u64 console_seq;
@@ -1936,7 +1937,8 @@ static int __init console_setup(char *str)
 		strncpy(buf, str, sizeof(buf) - 1);
 	}
 	buf[sizeof(buf) - 1] = 0;
-	if ((options = strchr(str, ',')) != NULL)
+	options = strchr(str, ',');
+	if (options)
 		*(options++) = 0;
 #ifdef __sparc__
 	if (!strcmp(str, "ttya"))
@@ -1945,7 +1947,7 @@ static int __init console_setup(char *str)
 		strcpy(buf, "ttyS1");
 #endif
 	for (s = buf; *s; s++)
-		if ((*s >= '0' && *s <= '9') || *s == ',')
+		if (isdigit(*s) || *s == ',')
 			break;
 	idx = simple_strtoul(s, NULL, 10);
 	*s = 0;
@@ -1984,7 +1986,6 @@ int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, cha
 	     i++, c++)
 		if (strcmp(c->name, name) == 0 && c->index == idx) {
 			strlcpy(c->name, name_new, sizeof(c->name));
-			c->name[sizeof(c->name) - 1] = 0;
 			c->options = options;
 			c->index = idx_new;
 			return i;
@@ -2652,14 +2653,13 @@ EXPORT_SYMBOL(__printk_ratelimit);
 bool printk_timed_ratelimit(unsigned long *caller_jiffies,
 			unsigned int interval_msecs)
 {
-	if (*caller_jiffies == 0
-			|| !time_in_range(jiffies, *caller_jiffies,
-					*caller_jiffies
-					+ msecs_to_jiffies(interval_msecs))) {
-		*caller_jiffies = jiffies;
-		return true;
-	}
-	return false;
+	unsigned long elapsed = jiffies - *caller_jiffies;
+
+	if (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))
+		return false;
+
+	*caller_jiffies = jiffies;
+	return true;
 }
 EXPORT_SYMBOL(printk_timed_ratelimit);
 

commit e99aa461660a6413b11da887fb499e04a0f46803
Author: Alex Elder <elder@linaro.org>
Date:   Wed Aug 6 16:09:05 2014 -0700

    printk: use a clever macro
    
    Use the IS_ENABLED() macro rather than #ifdef blocks to set certain
    global values.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Acked-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4bae344c1ec3..ac86838227ed 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -454,11 +454,7 @@ static int log_store(int facility, int level,
 	return msg->text_len;
 }
 
-#ifdef CONFIG_SECURITY_DMESG_RESTRICT
-int dmesg_restrict = 1;
-#else
-int dmesg_restrict;
-#endif
+int dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
 
 static int syslog_action_restricted(int type)
 {
@@ -988,11 +984,7 @@ static inline void boot_delay_msec(int level)
 }
 #endif
 
-#if defined(CONFIG_PRINTK_TIME)
-static bool printk_time = 1;
-#else
-static bool printk_time;
-#endif
+static bool printk_time = IS_ENABLED(CONFIG_PRINTK_TIME);
 module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
 
 static size_t print_time(u64 ts, char *buf)

commit 0b90fec3b990b50d77944bc73c1ba4b031dfa52f
Author: Alex Elder <elder@linaro.org>
Date:   Wed Aug 6 16:09:03 2014 -0700

    printk: fix some comments
    
    Fix a few comments that don't accurately describe their corresponding
    code.  It also fixes some minor typographical errors.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jan Kara <jack@suse.cz>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 770ed4821ba9..4bae344c1ec3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -113,9 +113,9 @@ static int __down_trylock_console_sem(unsigned long ip)
  * This is used for debugging the mess that is the VT code by
  * keeping track if we have the console semaphore held. It's
  * definitely not the perfect debug tool (we don't know if _WE_
- * hold it are racing, but it helps tracking those weird code
- * path in the console code where we end up in places I want
- * locked without the console sempahore held
+ * hold it and are racing, but it helps tracking those weird code
+ * paths in the console code where we end up in places I want
+ * locked without the console sempahore held).
  */
 static int console_locked, console_suspended;
 
@@ -146,8 +146,8 @@ static int console_may_schedule;
  * the overall length of the record.
  *
  * The heads to the first and last entry in the buffer, as well as the
- * sequence numbers of these both entries are maintained when messages
- * are stored..
+ * sequence numbers of these entries are maintained when messages are
+ * stored.
  *
  * If the heads indicate available messages, the length in the header
  * tells the start next message. A length == 0 for the next message
@@ -345,7 +345,7 @@ static int log_make_free_space(u32 msg_size)
 	while (log_first_seq < log_next_seq) {
 		if (logbuf_has_space(msg_size, false))
 			return 0;
-		/* drop old messages until we have enough continuous space */
+		/* drop old messages until we have enough contiguous space */
 		log_first_idx = log_next(log_first_idx);
 		log_first_seq++;
 	}
@@ -1517,7 +1517,7 @@ static struct cont {
 	struct task_struct *owner;	/* task of first print*/
 	u64 ts_nsec;			/* time of first print */
 	u8 level;			/* log level of first message */
-	u8 facility;			/* log level of first message */
+	u8 facility;			/* log facility of first message */
 	enum log_flags flags;		/* prefix, newline flags */
 	bool flushed:1;			/* buffer sealed and committed */
 } cont;
@@ -1922,11 +1922,12 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	return 0;
 }
 /*
- * Set up a list of consoles.  Called from init/main.c
+ * Set up a console.  Called via do_early_param() in init/main.c
+ * for each "console=" parameter in the boot command line.
  */
 static int __init console_setup(char *str)
 {
-	char buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for index */
+	char buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for "ttyS" */
 	char *s, *options, *brl_options = NULL;
 	int idx;
 
@@ -2086,8 +2087,8 @@ EXPORT_SYMBOL(console_lock);
 /**
  * console_trylock - try to lock the console system for exclusive use.
  *
- * Tried to acquire a lock which guarantees that the caller has
- * exclusive access to the console system and the console_drivers list.
+ * Try to acquire a lock which guarantees that the caller has exclusive
+ * access to the console system and the console_drivers list.
  *
  * returns 1 on success, and 0 on failure to acquire the lock.
  */

commit 42a9dc0b3d0f749375c767c7d5cab56e89160576
Author: Alex Elder <elder@linaro.org>
Date:   Wed Aug 6 16:09:01 2014 -0700

    printk: rename DEFAULT_MESSAGE_LOGLEVEL
    
    Commit a8fe19ebfbfd ("kernel/printk: use symbolic defines for console
    loglevels") makes consistent use of symbolic values for printk() log
    levels.
    
    The naming scheme used is different from the one used for
    DEFAULT_MESSAGE_LOGLEVEL though.  Change that symbol name to be
    MESSAGE_LOGLEVEL_DEFAULT for consistency.  And because the value of that
    symbol comes from a similarly-named config option, rename
    CONFIG_DEFAULT_MESSAGE_LOGLEVEL as well.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jan Kara <jack@suse.cz>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ec3bfb0b1f62..770ed4821ba9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -56,7 +56,7 @@
 
 int console_printk[4] = {
 	CONSOLE_LOGLEVEL_DEFAULT,	/* console_loglevel */
-	DEFAULT_MESSAGE_LOGLEVEL,	/* default_message_loglevel */
+	MESSAGE_LOGLEVEL_DEFAULT,	/* default_message_loglevel */
 	CONSOLE_LOGLEVEL_MIN,		/* minimum_console_loglevel */
 	CONSOLE_LOGLEVEL_DEFAULT,	/* default_console_loglevel */
 };

commit e97e1267e9faa6480898a1fc34c8e40d74d702f2
Author: Alex Elder <elder@linaro.org>
Date:   Wed Aug 6 16:08:59 2014 -0700

    printk: tweak do_syslog() to match comments
    
    In do_syslog() there's a path used by kmsg_poll() and kmsg_read() that
    only needs to know whether there's any data available to read (and not
    its size).  These callers only check for non-zero return.  As a
    shortcut, do_syslog() returns the difference between what has been
    logged and what has been "seen."
    
    The comments say that the "count of records" should be returned but it's
    not.  Instead it returns (log_next_idx - syslog_idx), which is a
    difference between buffer offsets--and the result could be negative.
    
    The behavior is the same (it'll be zero or not in the same cases), but
    the count of records is more meaningful and it matches what the comments
    say.  So change the code to return that.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f855ec36dff9..ec3bfb0b1f62 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1351,7 +1351,7 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 			 * for pending data, not the size; return the count of
 			 * records, not the length.
 			 */
-			error = log_next_idx - syslog_idx;
+			error = log_next_seq - syslog_seq;
 		} else {
 			u64 seq = syslog_seq;
 			u32 idx = syslog_idx;

commit 23b2899f7f194f06e09b52a1f46f027a21fae17c
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed Aug 6 16:08:56 2014 -0700

    printk: allow increasing the ring buffer depending on the number of CPUs
    
    The default size of the ring buffer is too small for machines with a
    large amount of CPUs under heavy load.  What ends up happening when
    debugging is the ring buffer overlaps and chews up old messages making
    debugging impossible unless the size is passed as a kernel parameter.
    An idle system upon boot up will on average spew out only about one or
    two extra lines but where this really matters is on heavy load and that
    will vary widely depending on the system and environment.
    
    There are mechanisms to help increase the kernel ring buffer for tracing
    through debugfs, and those interfaces even allow growing the kernel ring
    buffer per CPU.  We also have a static value which can be passed upon
    boot.  Relying on debugfs however is not ideal for production, and
    relying on the value passed upon bootup is can only used *after* an
    issue has creeped up.  Instead of being reactive this adds a proactive
    measure which lets you scale the amount of contributions you'd expect to
    the kernel ring buffer under load by each CPU in the worst case
    scenario.
    
    We use num_possible_cpus() to avoid complexities which could be
    introduced by dynamically changing the ring buffer size at run time,
    num_possible_cpus() lets us use the upper limit on possible number of
    CPUs therefore avoiding having to deal with hotplugging CPUs on and off.
    This introduces the kernel configuration option LOG_CPU_MAX_BUF_SHIFT
    which is used to specify the maximum amount of contributions to the
    kernel ring buffer in the worst case before the kernel ring buffer flips
    over, the size is specified as a power of 2.  The total amount of
    contributions made by each CPU must be greater than half of the default
    kernel ring buffer size (1 << LOG_BUF_SHIFT bytes) in order to trigger
    an increase upon bootup.  The kernel ring buffer is increased to the
    next power of two that would fit the required minimum kernel ring buffer
    size plus the additional CPU contribution.  For example if LOG_BUF_SHIFT
    is 18 (256 KB) you'd require at least 128 KB contributions by other CPUs
    in order to trigger an increase of the kernel ring buffer.  With a
    LOG_CPU_BUF_SHIFT of 12 (4 KB) you'd require at least anything over > 64
    possible CPUs to trigger an increase.  If you had 128 possible CPUs the
    amount of minimum required kernel ring buffer bumps to:
    
       ((1 << 18) + ((128 - 1) * (1 << 12))) / 1024 = 764 KB
    
    Since we require the ring buffer to be a power of two the new required
    size would be 1024 KB.
    
    This CPU contributions are ignored when the "log_buf_len" kernel
    parameter is used as it forces the exact size of the ring buffer to an
    expected power of two value.
    
    [pmladek@suse.cz: fix build]
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Tested-by: Davidlohr Bueso <davidlohr@hp.com>
    Tested-by: Petr Mladek <pmladek@suse.cz>
    Reviewed-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Arun KS <arunks.linux@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index db290be32984..f855ec36dff9 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -266,6 +266,7 @@ static u32 clear_idx;
 #define LOG_ALIGN __alignof__(struct printk_log)
 #endif
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
+#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
@@ -848,12 +849,45 @@ static int __init log_buf_len_setup(char *str)
 }
 early_param("log_buf_len", log_buf_len_setup);
 
+static void __init log_buf_add_cpu(void)
+{
+	unsigned int cpu_extra;
+
+	/*
+	 * archs should set up cpu_possible_bits properly with
+	 * set_cpu_possible() after setup_arch() but just in
+	 * case lets ensure this is valid.
+	 */
+	if (num_possible_cpus() == 1)
+		return;
+
+	cpu_extra = (num_possible_cpus() - 1) * __LOG_CPU_MAX_BUF_LEN;
+
+	/* by default this will only continue through for large > 64 CPUs */
+	if (cpu_extra <= __LOG_BUF_LEN / 2)
+		return;
+
+	pr_info("log_buf_len individual max cpu contribution: %d bytes\n",
+		__LOG_CPU_MAX_BUF_LEN);
+	pr_info("log_buf_len total cpu_extra contributions: %d bytes\n",
+		cpu_extra);
+	pr_info("log_buf_len min size: %d bytes\n", __LOG_BUF_LEN);
+
+	log_buf_len_update(cpu_extra + __LOG_BUF_LEN);
+}
+
 void __init setup_log_buf(int early)
 {
 	unsigned long flags;
 	char *new_log_buf;
 	int free;
 
+	if (log_buf != __log_buf)
+		return;
+
+	if (!early && !new_log_buf_len)
+		log_buf_add_cpu();
+
 	if (!new_log_buf_len)
 		return;
 

commit f54051722e5715d24cd4469606ebdf488b6d5779
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed Aug 6 16:08:54 2014 -0700

    printk: make dynamic units clear for the kernel ring buffer
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Suggested-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Arun KS <arunks.linux@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 32ad0c7a0cd3..db290be32984 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -879,7 +879,7 @@ void __init setup_log_buf(int early)
 	memcpy(log_buf, __log_buf, __LOG_BUF_LEN);
 	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
 
-	pr_info("log_buf_len: %d\n", log_buf_len);
+	pr_info("log_buf_len: %d bytes\n", log_buf_len);
 	pr_info("early log buf free: %d(%d%%)\n",
 		free, (free * 100) / __LOG_BUF_LEN);
 }

commit c0a318a361e7652b8c4f7b91d3a31c771cf34e4f
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed Aug 6 16:08:52 2014 -0700

    printk: move power of 2 practice of ring buffer size to a helper
    
    In practice the power of 2 practice of the size of the kernel ring
    buffer remains purely historical but not a requirement, specially now
    that we have LOG_ALIGN and use it for both static and dynamic
    allocations.  It could have helped with implicit alignment back in the
    days given the even the dynamically sized ring buffer was guaranteed to
    be aligned so long as CONFIG_LOG_BUF_SHIFT was set to produce a
    __LOG_BUF_LEN which is architecture aligned, since log_buf_len=n would
    be allowed only if it was > __LOG_BUF_LEN and we always ended up
    rounding the log_buf_len=n to the next power of 2 with
    roundup_pow_of_two(), any multiple of 2 then should be also architecture
    aligned.  These assumptions of course relied heavily on
    CONFIG_LOG_BUF_SHIFT producing an aligned value but users can always
    change this.
    
    We now have precise alignment requirements set for the log buffer size
    for both static and dynamic allocations, but lets upkeep the old
    practice of using powers of 2 for its size to help with easy expected
    scalable values and the allocators for dynamic allocations.  We'll reuse
    this later so move this into a helper.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Arun KS <arunks.linux@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 6f598f92f2a1..32ad0c7a0cd3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -828,15 +828,21 @@ void log_buf_kexec_setup(void)
 /* requested log_buf_len from kernel cmdline */
 static unsigned long __initdata new_log_buf_len;
 
-/* save requested log_buf_len since it's too early to process it */
-static int __init log_buf_len_setup(char *str)
+/* we practice scaling the ring buffer by powers of 2 */
+static void __init log_buf_len_update(unsigned size)
 {
-	unsigned size = memparse(str, &str);
-
 	if (size)
 		size = roundup_pow_of_two(size);
 	if (size > log_buf_len)
 		new_log_buf_len = size;
+}
+
+/* save requested log_buf_len since it's too early to process it */
+static int __init log_buf_len_setup(char *str)
+{
+	unsigned size = memparse(str, &str);
+
+	log_buf_len_update(size);
 
 	return 0;
 }

commit 7030017752437cebc3ec5590735bd89ead1e4cb8
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed Aug 6 16:08:49 2014 -0700

    printk: make dynamic kernel ring buffer alignment explicit
    
    We have to consider alignment for the ring buffer both for the default
    static size, and then also for when an dynamic allocation is made when
    the log_buf_len=n kernel parameter is passed to set the size
    specifically to a size larger than the default size set by the
    architecture through CONFIG_LOG_BUF_SHIFT.
    
    The default static kernel ring buffer can be aligned properly if
    architectures set CONFIG_LOG_BUF_SHIFT properly, we provide ranges for
    the size though so even if CONFIG_LOG_BUF_SHIFT has a sensible aligned
    value it can be reduced to a non aligned value.  Commit 6ebb017de9
    ("printk: Fix alignment of buf causing crash on ARM EABI") by Andrew
    Lunn ensures the static buffer is always aligned and the decision of
    alignment is done by the compiler by using __alignof__(struct log).
    
    When log_buf_len=n is used we allocate the ring buffer dynamically.
    Dynamic allocation varies, for the early allocation called before
    setup_arch() memblock_virt_alloc() requests a page aligment and for the
    default kernel allocation memblock_virt_alloc_nopanic() requests no
    special alignment, which in turn ends up aligning the allocation to
    SMP_CACHE_BYTES, which is L1 cache aligned.
    
    Since we already have the required alignment for the kernel ring buffer
    though we can do better and request explicit alignment for LOG_ALIGN.
    This does that to be safe and make dynamic allocation alignment
    explicit.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Tested-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Petr Mladek <pmladek@suse.cz>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Petr Mladek <pmladek@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Arun KS <arunks.linux@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 13e839dbca07..6f598f92f2a1 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -853,9 +853,10 @@ void __init setup_log_buf(int early)
 
 	if (early) {
 		new_log_buf =
-			memblock_virt_alloc(new_log_buf_len, PAGE_SIZE);
+			memblock_virt_alloc(new_log_buf_len, LOG_ALIGN);
 	} else {
-		new_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len, 0);
+		new_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len,
+							  LOG_ALIGN);
 	}
 
 	if (unlikely(!new_log_buf)) {

commit d18bbc215f81710e1eab7120becafa910554d68d
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Jul 2 15:22:38 2014 -0700

    kernel/printk/printk.c: revert "printk: enable interrupts before calling console_trylock_for_printk()"
    
    Revert commit 939f04bec1a4 ("printk: enable interrupts before calling
    console_trylock_for_printk()").
    
    Andreas reported:
    
    : None of the post 3.15 kernel boot for me. They all hang at the GRUB
    : screen telling me it loaded and started the kernel, but the kernel
    : itself stops before it prints anything (or even replaces the GRUB
    : background graphics).
    
    939f04bec1a4 is modest latency reduction.  Revert it until we understand
    the reason for these failures.
    
    Reported-by: Andreas Bombe <aeb@debian.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ea2d5f6962ed..13e839dbca07 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1416,9 +1416,10 @@ static int have_callable_console(void)
 /*
  * Can we actually use the console at this time on this cpu?
  *
- * Console drivers may assume that per-cpu resources have been allocated. So
- * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
- * call them until this CPU is officially up.
+ * Console drivers may assume that per-cpu resources have
+ * been allocated. So unless they're explicitly marked as
+ * being able to cope (CON_ANYTIME) don't call them until
+ * this CPU is officially up.
  */
 static inline int can_use_console(unsigned int cpu)
 {
@@ -1431,10 +1432,8 @@ static inline int can_use_console(unsigned int cpu)
  * console_lock held, and 'console_locked' set) if it
  * is successful, false otherwise.
  */
-static int console_trylock_for_printk(void)
+static int console_trylock_for_printk(unsigned int cpu)
 {
-	unsigned int cpu = smp_processor_id();
-
 	if (!console_trylock())
 		return 0;
 	/*
@@ -1609,8 +1608,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (!oops_in_progress && !lockdep_recursing(current)) {
 			recursion_bug = 1;
-			local_irq_restore(flags);
-			return 0;
+			goto out_restore_irqs;
 		}
 		zap_locks();
 	}
@@ -1718,27 +1716,21 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);
-	lockdep_on();
-	local_irq_restore(flags);
 
 	/* If called from the scheduler, we can not call up(). */
-	if (in_sched)
-		return printed_len;
-
-	/*
-	 * Disable preemption to avoid being preempted while holding
-	 * console_sem which would prevent anyone from printing to console
-	 */
-	preempt_disable();
-	/*
-	 * Try to acquire and then immediately release the console semaphore.
-	 * The release will print out buffers and wake up /dev/kmsg and syslog()
-	 * users.
-	 */
-	if (console_trylock_for_printk())
-		console_unlock();
-	preempt_enable();
+	if (!in_sched) {
+		/*
+		 * Try to acquire and then immediately release the console
+		 * semaphore.  The release will print out buffers and wake up
+		 * /dev/kmsg and syslog() users.
+		 */
+		if (console_trylock_for_printk(this_cpu))
+			console_unlock();
+	}
 
+	lockdep_on();
+out_restore_irqs:
+	local_irq_restore(flags);
 	return printed_len;
 }
 EXPORT_SYMBOL(vprintk_emit);

commit a8fe19ebfbfd90ec17c02284717238b02efb9580
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Jun 4 16:11:46 2014 -0700

    kernel/printk: use symbolic defines for console loglevels
    
    ... instead of naked numbers.
    
    Stuff in sysrq.c used to set it to 8 which is supposed to mean above
    default level so set it to DEBUG instead as we're terminating/killing all
    tasks and we want to be verbose there.
    
    Also, correct the check in x86_64_start_kernel which should be >= as
    we're clearly issuing the string there for all debug levels, not only
    the magical 10.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 923c5d4e4202..ea2d5f6962ed 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -54,18 +54,11 @@
 #include "console_cmdline.h"
 #include "braille.h"
 
-/* printk's without a loglevel use this.. */
-#define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
-
-/* We show everything that is MORE important than this.. */
-#define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
-#define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */
-
 int console_printk[4] = {
-	DEFAULT_CONSOLE_LOGLEVEL,	/* console_loglevel */
+	CONSOLE_LOGLEVEL_DEFAULT,	/* console_loglevel */
 	DEFAULT_MESSAGE_LOGLEVEL,	/* default_message_loglevel */
-	MINIMUM_CONSOLE_LOGLEVEL,	/* minimum_console_loglevel */
-	DEFAULT_CONSOLE_LOGLEVEL,	/* default_console_loglevel */
+	CONSOLE_LOGLEVEL_MIN,		/* minimum_console_loglevel */
+	CONSOLE_LOGLEVEL_DEFAULT,	/* default_console_loglevel */
 };
 
 /* Deferred messaged from sched code are marked by this special level */

commit 84b5ec8a9df86f3dcaaaf912715db35e4852d1da
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Jun 4 16:11:45 2014 -0700

    printk: report dropping of messages from logbuf
    
    If the log ring buffer becomes full, we silently overwrite old messages
    with new data.  console_unlock will detect this case and fast-forward the
    console_* pointers to skip over the corrupted data, but nothing will be
    reported to the user.
    
    This patch hijacks the first valid log message after detecting that we
    dropped messages and prefixes it with a note detailing how many messages
    were dropped.  For long (~1000 char) messages, this will result in some
    truncation of the real message, but given that we're dropping things
    anyway, that doesn't seem to be the end of the world.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 35d9db251903..923c5d4e4202 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2157,10 +2157,15 @@ void console_unlock(void)
 		}
 
 		if (console_seq < log_first_seq) {
+			len = sprintf(text, "** %u printk messages dropped ** ",
+				      (unsigned)(log_first_seq - console_seq));
+
 			/* messages are gone, move to first one */
 			console_seq = log_first_seq;
 			console_idx = log_first_idx;
 			console_prev = 0;
+		} else {
+			len = 0;
 		}
 skip:
 		if (console_seq == log_next_seq)
@@ -2185,8 +2190,8 @@ void console_unlock(void)
 		}
 
 		level = msg->level;
-		len = msg_print_text(msg, console_prev, false,
-				     text, sizeof(text));
+		len += msg_print_text(msg, console_prev, false,
+				      text + len, sizeof(text) - len);
 		console_idx = log_next(console_idx);
 		console_seq++;
 		console_prev = msg->flags;

commit aac74dc495456412c4130a1167ce4beb6c1f0b38
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index dc2b8bd9bc1e..35d9db251903 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2585,7 +2585,7 @@ void wake_up_klogd(void)
 	preempt_enable();
 }
 
-int printk_sched(const char *fmt, ...)
+int printk_deferred(const char *fmt, ...)
 {
 	va_list args;
 	int r;

commit 81954606265ab8f04b41154bd00576013affcf5b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:39 2014 -0700

    printk: disable preemption for printk_sched
    
    An earlier change in -mm (printk: remove separate printk_sched
    buffers...), removed the printk_sched irqsave/restore lines since it was
    safe for current users.  Since we may be expanding usage of
    printk_sched(), disable preepmtion for this function to make it more
    generally safe to call.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 247b0c1fadfc..dc2b8bd9bc1e 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2590,12 +2590,14 @@ int printk_sched(const char *fmt, ...)
 	va_list args;
 	int r;
 
+	preempt_disable();
 	va_start(args, fmt);
 	r = vprintk_emit(0, SCHED_MESSAGE_LOGLEVEL, NULL, 0, fmt, args);
 	va_end(args);
 
 	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
 	irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+	preempt_enable();
 
 	return r;
 }

commit 458df9fd4815b47809875d57f42e16401674b621
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Wed Jun 4 16:11:38 2014 -0700

    printk: remove separate printk_sched buffers and use printk buf instead
    
    To prevent deadlocks with doing a printk inside the scheduler,
    printk_sched() was created.  The issue is that printk has a console_sem
    that it can grab and release.  The release does a wake up if there's a
    task pending on the sem, and this wake up grabs the rq locks that is
    held in the scheduler.  This leads to a possible deadlock if the wake up
    uses the same rq as the one with the rq lock held already.
    
    What printk_sched() does is to save the printk write in a per cpu buffer
    and sets the PRINTK_PENDING_SCHED flag.  On a timer tick, if this flag is
    set, the printk() is done against the buffer.
    
    There's a couple of issues with this approach.
    
    1) If two printk_sched()s are called before the tick, the second one
       will overwrite the first one.
    
    2) The temporary buffer is 512 bytes and is per cpu.  This is a quite a
       bit of space wasted for something that is seldom used.
    
    In order to remove this, the printk_sched() can use the printk buffer
    instead, and delay the console_trylock()/console_unlock() to the queued
    work.
    
    Because printk_sched() would then be taking the logbuf_lock, the
    logbuf_lock must not be held while doing anything that may call into the
    scheduler functions, which includes wake ups.  Unfortunately, printk()
    also has a console_sem that it uses, and on release, the up(&console_sem)
    may do a wake up of any pending waiters.  This must be avoided while
    holding the logbuf_lock.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4e22230f1f6c..247b0c1fadfc 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -68,6 +68,9 @@ int console_printk[4] = {
 	DEFAULT_CONSOLE_LOGLEVEL,	/* default_console_loglevel */
 };
 
+/* Deferred messaged from sched code are marked by this special level */
+#define SCHED_MESSAGE_LOGLEVEL -2
+
 /*
  * Low level drivers may need that to know if they can schedule in
  * their unblank() callback or not. So let's export it.
@@ -229,7 +232,9 @@ struct printk_log {
 };
 
 /*
- * The logbuf_lock protects kmsg buffer, indices, counters.
+ * The logbuf_lock protects kmsg buffer, indices, counters.  This can be taken
+ * within the scheduler's rq lock. It must be released before calling
+ * console_unlock() or anything else that might wake up a process.
  */
 static DEFINE_RAW_SPINLOCK(logbuf_lock);
 
@@ -1577,14 +1582,19 @@ asmlinkage int vprintk_emit(int facility, int level,
 	static int recursion_bug;
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
-	size_t text_len;
+	size_t text_len = 0;
 	enum log_flags lflags = 0;
 	unsigned long flags;
 	int this_cpu;
 	int printed_len = 0;
+	bool in_sched = false;
 	/* cpu currently holding logbuf_lock in this function */
 	static volatile unsigned int logbuf_cpu = UINT_MAX;
 
+	if (level == SCHED_MESSAGE_LOGLEVEL) {
+		level = -1;
+		in_sched = true;
+	}
 
 	boot_delay_msec(level);
 	printk_delay();
@@ -1631,7 +1641,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 	 * The printf needs to come first; we need the syslog
 	 * prefix which might be passed-in as a parameter.
 	 */
-	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
+	if (in_sched)
+		text_len = scnprintf(text, sizeof(textbuf),
+				     KERN_WARNING "[sched_delayed] ");
+
+	text_len += vscnprintf(text + text_len,
+			       sizeof(textbuf) - text_len, fmt, args);
 
 	/* mark and strip a trailing newline */
 	if (text_len && text[text_len-1] == '\n') {
@@ -1713,6 +1728,10 @@ asmlinkage int vprintk_emit(int facility, int level,
 	lockdep_on();
 	local_irq_restore(flags);
 
+	/* If called from the scheduler, we can not call up(). */
+	if (in_sched)
+		return printed_len;
+
 	/*
 	 * Disable preemption to avoid being preempted while holding
 	 * console_sem which would prevent anyone from printing to console
@@ -2532,21 +2551,19 @@ late_initcall(printk_late_init);
 /*
  * Delayed printk version, for scheduler-internal messages:
  */
-#define PRINTK_BUF_SIZE		512
-
 #define PRINTK_PENDING_WAKEUP	0x01
-#define PRINTK_PENDING_SCHED	0x02
+#define PRINTK_PENDING_OUTPUT	0x02
 
 static DEFINE_PER_CPU(int, printk_pending);
-static DEFINE_PER_CPU(char [PRINTK_BUF_SIZE], printk_sched_buf);
 
 static void wake_up_klogd_work_func(struct irq_work *irq_work)
 {
 	int pending = __this_cpu_xchg(printk_pending, 0);
 
-	if (pending & PRINTK_PENDING_SCHED) {
-		char *buf = __get_cpu_var(printk_sched_buf);
-		pr_warn("[sched_delayed] %s", buf);
+	if (pending & PRINTK_PENDING_OUTPUT) {
+		/* If trylock fails, someone else is doing the printing */
+		if (console_trylock())
+			console_unlock();
 	}
 
 	if (pending & PRINTK_PENDING_WAKEUP)
@@ -2570,21 +2587,15 @@ void wake_up_klogd(void)
 
 int printk_sched(const char *fmt, ...)
 {
-	unsigned long flags;
 	va_list args;
-	char *buf;
 	int r;
 
-	local_irq_save(flags);
-	buf = __get_cpu_var(printk_sched_buf);
-
 	va_start(args, fmt);
-	r = vsnprintf(buf, PRINTK_BUF_SIZE, fmt, args);
+	r = vprintk_emit(0, SCHED_MESSAGE_LOGLEVEL, NULL, 0, fmt, args);
 	va_end(args);
 
-	__this_cpu_or(printk_pending, PRINTK_PENDING_SCHED);
+	__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
 	irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
-	local_irq_restore(flags);
 
 	return r;
 }

commit 939f04bec1a4ef6ba4370b0f34b01decc844b1b1
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jun 4 16:11:37 2014 -0700

    printk: enable interrupts before calling console_trylock_for_printk()
    
    We need interrupts disabled when calling console_trylock_for_printk()
    only so that cpu id we pass to can_use_console() remains valid (for
    other things console_sem provides all the exclusion we need and
    deadlocks on console_sem due to interrupts are impossible because we use
    down_trylock()).  However if we are rescheduled, we are guaranteed to
    run on an online cpu so we can easily just get the cpu id in
    can_use_console().
    
    We can lose a bit of performance when we enable interrupts in
    vprintk_emit() and then disable them again in console_unlock() but OTOH
    it can somewhat reduce interrupt latency caused by console_unlock()
    especially since later in the patch series we will want to spin on
    console_sem in console_trylock_for_printk().
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5ba37f813723..4e22230f1f6c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1418,10 +1418,9 @@ static int have_callable_console(void)
 /*
  * Can we actually use the console at this time on this cpu?
  *
- * Console drivers may assume that per-cpu resources have
- * been allocated. So unless they're explicitly marked as
- * being able to cope (CON_ANYTIME) don't call them until
- * this CPU is officially up.
+ * Console drivers may assume that per-cpu resources have been allocated. So
+ * unless they're explicitly marked as being able to cope (CON_ANYTIME) don't
+ * call them until this CPU is officially up.
  */
 static inline int can_use_console(unsigned int cpu)
 {
@@ -1434,8 +1433,10 @@ static inline int can_use_console(unsigned int cpu)
  * console_lock held, and 'console_locked' set) if it
  * is successful, false otherwise.
  */
-static int console_trylock_for_printk(unsigned int cpu)
+static int console_trylock_for_printk(void)
 {
+	unsigned int cpu = smp_processor_id();
+
 	if (!console_trylock())
 		return 0;
 	/*
@@ -1605,7 +1606,8 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 */
 		if (!oops_in_progress && !lockdep_recursing(current)) {
 			recursion_bug = 1;
-			goto out_restore_irqs;
+			local_irq_restore(flags);
+			return 0;
 		}
 		zap_locks();
 	}
@@ -1708,17 +1710,22 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	logbuf_cpu = UINT_MAX;
 	raw_spin_unlock(&logbuf_lock);
+	lockdep_on();
+	local_irq_restore(flags);
+
+	/*
+	 * Disable preemption to avoid being preempted while holding
+	 * console_sem which would prevent anyone from printing to console
+	 */
+	preempt_disable();
 	/*
 	 * Try to acquire and then immediately release the console semaphore.
 	 * The release will print out buffers and wake up /dev/kmsg and syslog()
 	 * users.
 	 */
-	if (console_trylock_for_printk(this_cpu))
+	if (console_trylock_for_printk())
 		console_unlock();
-
-	lockdep_on();
-out_restore_irqs:
-	local_irq_restore(flags);
+	preempt_enable();
 
 	return printed_len;
 }

commit bd8d7cf5b8410fe98eba06a9aaa90efe88815d8a
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jun 4 16:11:36 2014 -0700

    printk: fix lockdep instrumentation of console_sem
    
    Printk calls mutex_acquire() / mutex_release() by hand to instrument
    lockdep about console_sem.  However in some corner cases the
    instrumentation is missing.  Fix the problem by creating helper functions
    for locking / unlocking console_sem which take care of lockdep
    instrumentation as well.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reported-by: Fabio Estevam <festevam@gmail.com>
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
    Tested-By: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 6e1b21a8a497..5ba37f813723 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -90,6 +90,29 @@ static struct lockdep_map console_lock_dep_map = {
 };
 #endif
 
+/*
+ * Helper macros to handle lockdep when locking/unlocking console_sem. We use
+ * macros instead of functions so that _RET_IP_ contains useful information.
+ */
+#define down_console_sem() do { \
+	down(&console_sem);\
+	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);\
+} while (0)
+
+static int __down_trylock_console_sem(unsigned long ip)
+{
+	if (down_trylock(&console_sem))
+		return 1;
+	mutex_acquire(&console_lock_dep_map, 0, 1, ip);
+	return 0;
+}
+#define down_trylock_console_sem() __down_trylock_console_sem(_RET_IP_)
+
+#define up_console_sem() do { \
+	mutex_release(&console_lock_dep_map, 1, _RET_IP_);\
+	up(&console_sem);\
+} while (0)
+
 /*
  * This is used for debugging the mess that is the VT code by
  * keeping track if we have the console semaphore held. It's
@@ -1422,7 +1445,7 @@ static int console_trylock_for_printk(unsigned int cpu)
 	 */
 	if (!can_use_console(cpu)) {
 		console_locked = 0;
-		up(&console_sem);
+		up_console_sem();
 		return 0;
 	}
 	return 1;
@@ -1951,16 +1974,14 @@ void suspend_console(void)
 	printk("Suspending console(s) (use no_console_suspend to debug)\n");
 	console_lock();
 	console_suspended = 1;
-	up(&console_sem);
-	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
+	up_console_sem();
 }
 
 void resume_console(void)
 {
 	if (!console_suspend_enabled)
 		return;
-	down(&console_sem);
-	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
+	down_console_sem();
 	console_suspended = 0;
 	console_unlock();
 }
@@ -2002,12 +2023,11 @@ void console_lock(void)
 {
 	might_sleep();
 
-	down(&console_sem);
+	down_console_sem();
 	if (console_suspended)
 		return;
 	console_locked = 1;
 	console_may_schedule = 1;
-	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
 }
 EXPORT_SYMBOL(console_lock);
 
@@ -2021,15 +2041,14 @@ EXPORT_SYMBOL(console_lock);
  */
 int console_trylock(void)
 {
-	if (down_trylock(&console_sem))
+	if (down_trylock_console_sem())
 		return 0;
 	if (console_suspended) {
-		up(&console_sem);
+		up_console_sem();
 		return 0;
 	}
 	console_locked = 1;
 	console_may_schedule = 0;
-	mutex_acquire(&console_lock_dep_map, 0, 1, _RET_IP_);
 	return 1;
 }
 EXPORT_SYMBOL(console_trylock);
@@ -2091,7 +2110,7 @@ void console_unlock(void)
 	bool retry;
 
 	if (console_suspended) {
-		up(&console_sem);
+		up_console_sem();
 		return;
 	}
 
@@ -2153,7 +2172,6 @@ void console_unlock(void)
 		local_irq_restore(flags);
 	}
 	console_locked = 0;
-	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
 
 	/* Release the exclusive_console once it is used */
 	if (unlikely(exclusive_console))
@@ -2161,7 +2179,7 @@ void console_unlock(void)
 
 	raw_spin_unlock(&logbuf_lock);
 
-	up(&console_sem);
+	up_console_sem();
 
 	/*
 	 * Someone could have filled up the buffer again, so re-check if there's
@@ -2206,7 +2224,7 @@ void console_unblank(void)
 	 * oops_in_progress is set to 1..
 	 */
 	if (oops_in_progress) {
-		if (down_trylock(&console_sem) != 0)
+		if (down_trylock_console_sem() != 0)
 			return;
 	} else
 		console_lock();

commit 608873cacb9d0d2811586fcc79a38b64eabd6d32
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jun 4 16:11:35 2014 -0700

    printk: release lockbuf_lock before calling console_trylock_for_printk()
    
    There's no reason to hold lockbuf_lock when entering
    console_trylock_for_printk().
    
    The first thing this function does is to call down_trylock(console_sem)
    and if that fails it immediately unlocks lockbuf_lock.  So lockbuf_lock
    isn't needed for that branch.  When down_trylock() succeeds, the rest of
    console_trylock() is OK without lockbuf_lock (it is called without it
    from other places), and the only remaining thing in
    console_trylock_for_printk() is can_use_console() call.  For that call
    console_sem is enough (it iterates all consoles and checks CON_ANYTIME
    flag).
    
    So we drop logbuf_lock before entering console_trylock_for_printk() which
    simplifies the code.
    
    [akpm@linux-foundation.org: fix have_callable_console() comment]
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5bc54478c963..6e1b21a8a497 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -249,9 +249,6 @@ static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
 
-/* cpu currently holding logbuf_lock */
-static volatile unsigned int logbuf_cpu = UINT_MAX;
-
 /* human readable text of the record */
 static char *log_text(const struct printk_log *msg)
 {
@@ -1380,7 +1377,10 @@ static void zap_locks(void)
 	sema_init(&console_sem, 1);
 }
 
-/* Check if we have any console registered that can be called early in boot. */
+/*
+ * Check if we have any console that is capable of printing while cpu is
+ * booting or shutting down. Requires console_sem.
+ */
 static int have_callable_console(void)
 {
 	struct console *con;
@@ -1410,36 +1410,22 @@ static inline int can_use_console(unsigned int cpu)
  * messages from a 'printk'. Return true (and with the
  * console_lock held, and 'console_locked' set) if it
  * is successful, false otherwise.
- *
- * This gets called with the 'logbuf_lock' spinlock held and
- * interrupts disabled. It should return with 'lockbuf_lock'
- * released but interrupts still disabled.
  */
 static int console_trylock_for_printk(unsigned int cpu)
-	__releases(&logbuf_lock)
 {
-	int retval = 0, wake = 0;
-
-	if (console_trylock()) {
-		retval = 1;
-
-		/*
-		 * If we can't use the console, we need to release
-		 * the console semaphore by hand to avoid flushing
-		 * the buffer. We need to hold the console semaphore
-		 * in order to do this test safely.
-		 */
-		if (!can_use_console(cpu)) {
-			console_locked = 0;
-			wake = 1;
-			retval = 0;
-		}
-	}
-	logbuf_cpu = UINT_MAX;
-	raw_spin_unlock(&logbuf_lock);
-	if (wake)
+	if (!console_trylock())
+		return 0;
+	/*
+	 * If we can't use the console, we need to release the console
+	 * semaphore by hand to avoid flushing the buffer. We need to hold the
+	 * console semaphore in order to do this test safely.
+	 */
+	if (!can_use_console(cpu)) {
+		console_locked = 0;
 		up(&console_sem);
-	return retval;
+		return 0;
+	}
+	return 1;
 }
 
 int printk_delay_msec __read_mostly;
@@ -1572,6 +1558,9 @@ asmlinkage int vprintk_emit(int facility, int level,
 	unsigned long flags;
 	int this_cpu;
 	int printed_len = 0;
+	/* cpu currently holding logbuf_lock in this function */
+	static volatile unsigned int logbuf_cpu = UINT_MAX;
+
 
 	boot_delay_msec(level);
 	printk_delay();
@@ -1694,13 +1683,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 						 dict, dictlen, text, text_len);
 	}
 
+	logbuf_cpu = UINT_MAX;
+	raw_spin_unlock(&logbuf_lock);
 	/*
 	 * Try to acquire and then immediately release the console semaphore.
 	 * The release will print out buffers and wake up /dev/kmsg and syslog()
 	 * users.
-	 *
-	 * The console_trylock_for_printk() function will release 'logbuf_lock'
-	 * regardless of whether it actually gets the console semaphore or not.
 	 */
 	if (console_trylock_for_printk(this_cpu))
 		console_unlock();

commit ca1d432ad8a527fabc5c7ceed8526e3a28de121c
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jun 4 16:11:34 2014 -0700

    printk: remove outdated comment
    
    Comment about interesting interlocking between lockbuf_lock and
    console_sem is outdated.
    
    It was added in 2002 by commit a880f45a48be during conversion of
    console_lock to console_sem + lockbuf_lock.
    
    At that time release_console_sem() (today's equivalent is
    console_unlock()) was indeed using lockbuf_lock to avoid races between
    trylock on console_sem in printk() and unlock of console_sem.  However
    these days the interlocking is gone and the races are avoided by
    rechecking logbuf state after releasing console_sem.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 7476a53bc378..5bc54478c963 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -206,8 +206,7 @@ struct printk_log {
 };
 
 /*
- * The logbuf_lock protects kmsg buffer, indices, counters. It is also
- * used in interesting ways to provide interlocking in console_unlock();
+ * The logbuf_lock protects kmsg buffer, indices, counters.
  */
 static DEFINE_RAW_SPINLOCK(logbuf_lock);
 

commit 034633ccb24d675850f99bf85c1c5880c831e4b6
Author: Petr Mladek <pmladek@suse.cz>
Date:   Wed Jun 4 16:11:33 2014 -0700

    printk: return really stored message length
    
    I wonder if anyone uses printk return value but it is there and should be
    counted correctly.
    
    This patch modifies log_store() to return the number of really stored
    bytes from the 'text' part.  Also it handles the return value in
    vprintk_emit().
    
    Note that log_store() is used also in cont_flush() but we could ignore the
    return value there.  The function works with characters that were already
    counted earlier.  In addition, the store could newer fail here because the
    length of the printed text is limited by the "cont" buffer and "dict" is
    NULL.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 7131dd4d0e3a..7476a53bc378 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -378,10 +378,10 @@ static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,
 }
 
 /* insert record into the buffer, discard old ones, update heads */
-static void log_store(int facility, int level,
-		      enum log_flags flags, u64 ts_nsec,
-		      const char *dict, u16 dict_len,
-		      const char *text, u16 text_len)
+static int log_store(int facility, int level,
+		     enum log_flags flags, u64 ts_nsec,
+		     const char *dict, u16 dict_len,
+		     const char *text, u16 text_len)
 {
 	struct printk_log *msg;
 	u32 size, pad_len;
@@ -396,7 +396,7 @@ static void log_store(int facility, int level,
 				    &dict_len, &pad_len);
 		/* survive when the log buffer is too small for trunc_msg */
 		if (log_make_free_space(size))
-			return;
+			return 0;
 	}
 
 	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
@@ -432,6 +432,8 @@ static void log_store(int facility, int level,
 	/* insert message */
 	log_next_idx += msg->len;
 	log_next_seq++;
+
+	return msg->text_len;
 }
 
 #ifdef CONFIG_SECURITY_DMESG_RESTRICT
@@ -1606,10 +1608,10 @@ asmlinkage int vprintk_emit(int facility, int level,
 			"BUG: recent printk recursion!";
 
 		recursion_bug = 0;
-		printed_len += strlen(recursion_msg);
+		text_len = strlen(recursion_msg);
 		/* emit KERN_CRIT message */
-		log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
-			  NULL, 0, recursion_msg, printed_len);
+		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
+					 NULL, 0, recursion_msg, text_len);
 	}
 
 	/*
@@ -1662,9 +1664,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 			cont_flush(LOG_NEWLINE);
 
 		/* buffer line if possible, otherwise store it right away */
-		if (!cont_add(facility, level, text, text_len))
-			log_store(facility, level, lflags | LOG_CONT, 0,
-				  dict, dictlen, text, text_len);
+		if (cont_add(facility, level, text, text_len))
+			printed_len += text_len;
+		else
+			printed_len += log_store(facility, level,
+						 lflags | LOG_CONT, 0,
+						 dict, dictlen, text, text_len);
 	} else {
 		bool stored = false;
 
@@ -1683,11 +1688,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 			cont_flush(LOG_NEWLINE);
 		}
 
-		if (!stored)
-			log_store(facility, level, lflags, 0,
-				  dict, dictlen, text, text_len);
+		if (stored)
+			printed_len += text_len;
+		else
+			printed_len += log_store(facility, level, lflags, 0,
+						 dict, dictlen, text, text_len);
 	}
-	printed_len += text_len;
 
 	/*
 	 * Try to acquire and then immediately release the console semaphore.

commit 55bd53a4eb3dd18be8744f8b4d026068fc801a62
Author: Petr Mladek <pmladek@suse.cz>
Date:   Wed Jun 4 16:11:32 2014 -0700

    printk: shrink too long messages
    
    We might want to print at least part of too long messages and add some
    warning for debugging purpose.
    
    The question is how long the shrunken message should be.  If we use the
    whole buffer, it might get rotated too soon.  Let's try to use only 1/4 of
    the buffer for now.
    
    Also shrink the whole dictionary.  We do not want to parse it or break it
    in the middle of some pair of values.  It would not cause any real harm
    but still.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9f088ed8404b..7131dd4d0e3a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -351,6 +351,32 @@ static u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)
 	return size;
 }
 
+/*
+ * Define how much of the log buffer we could take at maximum. The value
+ * must be greater than two. Note that only half of the buffer is available
+ * when the index points to the middle.
+ */
+#define MAX_LOG_TAKE_PART 4
+static const char trunc_msg[] = "<truncated>";
+
+static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,
+			u16 *dict_len, u32 *pad_len)
+{
+	/*
+	 * The message should not take the whole buffer. Otherwise, it might
+	 * get removed too soon.
+	 */
+	u32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;
+	if (*text_len > max_text_len)
+		*text_len = max_text_len;
+	/* enable the warning message */
+	*trunc_msg_len = strlen(trunc_msg);
+	/* disable the "dict" completely */
+	*dict_len = 0;
+	/* compute the size again, count also the warning message */
+	return msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);
+}
+
 /* insert record into the buffer, discard old ones, update heads */
 static void log_store(int facility, int level,
 		      enum log_flags flags, u64 ts_nsec,
@@ -359,13 +385,19 @@ static void log_store(int facility, int level,
 {
 	struct printk_log *msg;
 	u32 size, pad_len;
+	u16 trunc_msg_len = 0;
 
 	/* number of '\0' padding bytes to next message */
 	size = msg_used_size(text_len, dict_len, &pad_len);
 
-	/* if message does not fit empty log buffer, ignore it */
-	if (log_make_free_space(size))
-		return;
+	if (log_make_free_space(size)) {
+		/* truncate the message if it is too long for empty buffer */
+		size = truncate_msg(&text_len, &trunc_msg_len,
+				    &dict_len, &pad_len);
+		/* survive when the log buffer is too small for trunc_msg */
+		if (log_make_free_space(size))
+			return;
+	}
 
 	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 		/*
@@ -381,6 +413,10 @@ static void log_store(int facility, int level,
 	msg = (struct printk_log *)(log_buf + log_next_idx);
 	memcpy(log_text(msg), text, text_len);
 	msg->text_len = text_len;
+	if (trunc_msg_len) {
+		memcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);
+		msg->text_len += trunc_msg_len;
+	}
 	memcpy(log_dict(msg), dict, dict_len);
 	msg->dict_len = dict_len;
 	msg->facility = facility;

commit 85c87043023b7e5535f975bbee12a4f5399df520
Author: Petr Mladek <pmladek@suse.cz>
Date:   Wed Jun 4 16:11:31 2014 -0700

    printk: split message size computation
    
    We will want to recompute the message size when shrinking too long
    messages.  Let's put the code into separate function.
    
    The side effect of setting "pad_len" is not nice but it is worth removing
    the code duplication.  Note that I will probably have one more usage for
    this function when handling messages safe way in NMI context.
    
    This patch does not change the existing behavior.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8fbbab1771eb..9f088ed8404b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -339,6 +339,18 @@ static int log_make_free_space(u32 msg_size)
 	return -ENOMEM;
 }
 
+/* compute the message size including the padding bytes */
+static u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)
+{
+	u32 size;
+
+	size = sizeof(struct printk_log) + text_len + dict_len;
+	*pad_len = (-size) & (LOG_ALIGN - 1);
+	size += *pad_len;
+
+	return size;
+}
+
 /* insert record into the buffer, discard old ones, update heads */
 static void log_store(int facility, int level,
 		      enum log_flags flags, u64 ts_nsec,
@@ -349,9 +361,7 @@ static void log_store(int facility, int level,
 	u32 size, pad_len;
 
 	/* number of '\0' padding bytes to next message */
-	size = sizeof(struct printk_log) + text_len + dict_len;
-	pad_len = (-size) & (LOG_ALIGN - 1);
-	size += pad_len;
+	size = msg_used_size(text_len, dict_len, &pad_len);
 
 	/* if message does not fit empty log buffer, ignore it */
 	if (log_make_free_space(size))

commit f40e4b9f70d48eb08f443642283fdd9d05b27c6d
Author: Petr Mladek <pmladek@suse.cz>
Date:   Wed Jun 4 16:11:30 2014 -0700

    printk: ignore too long messages
    
    There was no check for too long messages.  The check for free space always
    passed when first_seq and next_seq were equal.  Enough free space was not
    guaranteed, though.
    
    log_store() might be called to store messages up to 64kB + 64kB + 16B.
    This is sum of maximal text_len, dict_len values, and the size of the
    structure printk_log.
    
    On the other hand, the minimal size for the main log buffer currently is
    4kB and it is enforced only by Kconfig.
    
    The good news is that the usage looks safe right now.  log_store() is
    called only from vprintk_emit() and cont_flush().  Here the "text" part is
    always passed via a static buffer and the length is limited to
    LOG_LINE_MAX which is 1024.  The "dict" part is NULL in most cases.  The
    only exceptions is when vprintk_emit() is called from printk_emit() and
    dev_vprintk_emit().  But printk_emit() is currently used only in
    devkmsg_writev() and here "dict" is NULL as well.  In dev_vprintk_emit(),
    "dict" is limited by the static buffer "hdr" of the size 128 bytes.  It
    meas that the current maximal printed text is 1024B + 128B + 16B and it
    always fit the log buffer.
    
    But it is only matter of time when someone calls printk_emit() with unsafe
    parameters, especially the "dict" one.
    
    This patch adds a check for the free space when the buffer is empty.  It
    reuses the already existing log_has_space() function but it has to add an
    extra parameter.  It defines whether the buffer is empty.  Note that the
    same values of "first_idx" and "next_idx" might also mean that the buffer
    is full.
    
    If the buffer is empty, we must respect the current position of the
    indexes.  We cannot reset them to the beginning of the buffer.  Otherwise,
    the functions reading the buffer would get crazy.
    
    The question is what to do when the message is too long.  This patch uses
    the easiest solution and just ignores the problematic message.  Let's do
    something better in a followup patch.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 99b7a2d87b6a..8fbbab1771eb 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -297,12 +297,20 @@ static u32 log_next(u32 idx)
 	return idx + msg->len;
 }
 
-/* check whether there is enough free space for the given message */
-static int logbuf_has_space(u32 msg_size)
+/*
+ * Check whether there is enough free space for the given message.
+ *
+ * The same values of first_idx and next_idx mean that the buffer
+ * is either empty or full.
+ *
+ * If the buffer is empty, we must respect the position of the indexes.
+ * They cannot be reset to the beginning of the buffer.
+ */
+static int logbuf_has_space(u32 msg_size, bool empty)
 {
 	u32 free;
 
-	if (log_next_idx > log_first_idx)
+	if (log_next_idx > log_first_idx || empty)
 		free = max(log_buf_len - log_next_idx, log_first_idx);
 	else
 		free = log_first_idx - log_next_idx;
@@ -314,15 +322,21 @@ static int logbuf_has_space(u32 msg_size)
 	return free >= msg_size + sizeof(struct printk_log);
 }
 
-static void log_make_free_space(u32 msg_size)
+static int log_make_free_space(u32 msg_size)
 {
 	while (log_first_seq < log_next_seq) {
-		if (logbuf_has_space(msg_size))
-			return;
+		if (logbuf_has_space(msg_size, false))
+			return 0;
 		/* drop old messages until we have enough continuous space */
 		log_first_idx = log_next(log_first_idx);
 		log_first_seq++;
 	}
+
+	/* sequence numbers are equal, so the log buffer is empty */
+	if (logbuf_has_space(msg_size, true))
+		return 0;
+
+	return -ENOMEM;
 }
 
 /* insert record into the buffer, discard old ones, update heads */
@@ -339,7 +353,9 @@ static void log_store(int facility, int level,
 	pad_len = (-size) & (LOG_ALIGN - 1);
 	size += pad_len;
 
-	log_make_free_space(size);
+	/* if message does not fit empty log buffer, ignore it */
+	if (log_make_free_space(size))
+		return;
 
 	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 		/*

commit 0a581694ab7a5bc083d710df8a552a6a055b005f
Author: Petr Mladek <pmladek@suse.cz>
Date:   Wed Jun 4 16:11:28 2014 -0700

    printk: split code for making free space in the log buffer
    
    The check for free space in the log buffer always passes when "first_seq"
    and "next_seq" are equal.  In theory, it might cause writing outside of
    the log buffer.
    
    Fortunately, the current usage looks safe because the used "text" and
    "dict" buffers are quite limited.  See the second patch for more details.
    
    Anyway, it is better to be on the safe side and add a check.  An easy
    solution is done in the 2nd patch and it is improved in the 4th patch.
    
    5th patch fixes the computation of the printed message length.
    
    1st and 3rd patches just do some code refactoring to make the other
    patches easier.
    
    This patch (of 5):
    
    There will be needed some fixes in the check for free space.  They will be
    easier if the code is moved outside of the quite long log_store()
    function.
    
    This patch does not change the existing behavior.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 221229cf0190..99b7a2d87b6a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -297,6 +297,34 @@ static u32 log_next(u32 idx)
 	return idx + msg->len;
 }
 
+/* check whether there is enough free space for the given message */
+static int logbuf_has_space(u32 msg_size)
+{
+	u32 free;
+
+	if (log_next_idx > log_first_idx)
+		free = max(log_buf_len - log_next_idx, log_first_idx);
+	else
+		free = log_first_idx - log_next_idx;
+
+	/*
+	 * We need space also for an empty header that signalizes wrapping
+	 * of the buffer.
+	 */
+	return free >= msg_size + sizeof(struct printk_log);
+}
+
+static void log_make_free_space(u32 msg_size)
+{
+	while (log_first_seq < log_next_seq) {
+		if (logbuf_has_space(msg_size))
+			return;
+		/* drop old messages until we have enough continuous space */
+		log_first_idx = log_next(log_first_idx);
+		log_first_seq++;
+	}
+}
+
 /* insert record into the buffer, discard old ones, update heads */
 static void log_store(int facility, int level,
 		      enum log_flags flags, u64 ts_nsec,
@@ -311,21 +339,7 @@ static void log_store(int facility, int level,
 	pad_len = (-size) & (LOG_ALIGN - 1);
 	size += pad_len;
 
-	while (log_first_seq < log_next_seq) {
-		u32 free;
-
-		if (log_next_idx > log_first_idx)
-			free = max(log_buf_len - log_next_idx, log_first_idx);
-		else
-			free = log_first_idx - log_next_idx;
-
-		if (free >= size + sizeof(struct printk_log))
-			break;
-
-		/* drop old messages until we have enough contiuous space */
-		log_first_idx = log_next(log_first_idx);
-		log_first_seq++;
-	}
+	log_make_free_space(size);
 
 	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 		/*

commit 49eb7b0750d9483c74e9c14ae6ea1e9d62481c3c
Merge: 5142c33ed86a 9ce4f8f3f454
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 3 09:01:02 2014 -0700

    Merge tag 'tty-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty into next
    
    Pull tty/serial driver updates from Greg KH:
     "Here is the big tty / serial driver pull request for 3.16-rc1.
    
      A variety of different serial driver fixes and updates and additions,
      nothing huge, and no real major core tty changes at all.
    
      All have been in linux-next for a while"
    
    * tag 'tty-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (84 commits)
      Revert "serial: imx: remove the DMA wait queue"
      serial: kgdb_nmi: Improve console integration with KDB I/O
      serial: kgdb_nmi: Switch from tasklets to real timers
      serial: kgdb_nmi: Use container_of() to locate private data
      serial: cpm_uart: No LF conversion in put_poll_char()
      serial: sirf: Fix compilation failure
      console: Remove superfluous readonly check
      console: Use explicit pointer type for vc_uni_pagedir* fields
      vgacon: Fix & cleanup refcounting
      ARM: tty: Move HVC DCC assembly to arch/arm
      tty/hvc/hvc_console: Fix wakeup of HVC thread on hvc_kick()
      drivers/tty/n_hdlc.c: replace kmalloc/memset by kzalloc
      vt: emulate 8- and 24-bit colour codes.
      printk/of_serial: fix serial console cessation part way through boot.
      serial: 8250_dma: check the result of TX buffer mapping
      serial: uart: add hw flow control support configuration
      tty/serial: at91: add interrupts for modem control lines
      tty/serial: at91: use mctrl_gpio helpers
      tty/serial: Add GPIOLIB helpers for controlling modem lines
      ARM: at91: gpio: implement get_direction
      ...

commit 7fa21dd8bd191564a195291161d6b43db5d9c350
Author: Stephen Chivers <schivers@csc.com>
Date:   Wed May 14 08:04:39 2014 +1000

    printk/of_serial: fix serial console cessation part way through boot.
    
    Commit 5f5c9ae56c38942623f69c3e6dc6ec78e4da2076
    "serial_core: Unregister console in uart_remove_one_port()"
    fixed a crash where a serial port was removed but
    not deregistered as a console.
    
    There is a side effect of that commit for platforms having serial consoles
    and of_serial configured (CONFIG_SERIAL_OF_PLATFORM). The serial console
    is disabled midway through the boot process.
    
    This cessation of the serial console affects PowerPC computers
    such as the MVME5100 and SAM440EP.
    
    The sequence is:
    
            bootconsole [udbg0] enabled
            ....
            serial8250/16550 driver initialises and registers its UARTS,
            one of these is the serial console.
            console [ttyS0] enabled
            ....
            of_serial probes "platform" devices, registering them as it goes.
            One of these is the serial console.
            console [ttyS0] disabled.
    
    The disabling of the serial console is due to:
    
            a.  unregister_console in printk not clearing the
                CONS_ENABLED bit in the console flags,
                even though it has announced that the console is disabled; and
    
            b.  of_platform_serial_probe in of_serial not setting the port type
                before it registers with serial8250_register_8250_port.
    
    This patch ensures that the serial console is re-enabled when of_serial
    registers a serial port that corresponds to the designated console.
    
    Signed-off-by: Stephen Chivers <schivers@csc.com>
    Tested-by: Stephen Chivers <schivers@csc.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> [unregister_console]
    Cc: stable <stable@vger.kernel.org> # 3.15
    
    ===
    The above failure was identified in Linux-3.15-rc2.
    
    Tested using MVME5100 and SAM440EP PowerPC computers with
    kernels built from Linux-3.15-rc5 and tty-next.
    
    The continued operation of the serial console is vital for computers
    such as the MVME5100 as that Single Board Computer does not
    have any grapical/display hardware.
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a45b50962295..81c71617ea28 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2413,6 +2413,7 @@ int unregister_console(struct console *console)
 	if (console_drivers != NULL && console->flags & CON_CONSDEV)
 		console_drivers->flags |= CON_CONSDEV;
 
+	console->flags &= ~CON_ENABLED;
 	console_unlock();
 	console_sysfs_notify();
 	return res;

commit 722a9f9299ca720a3f14660e7c0dce7b76a9cb42
Author: Andi Kleen <ak@linux.intel.com>
Date:   Fri May 2 00:44:38 2014 +0200

    asmlinkage: Add explicit __visible to drivers/*, lib/*, kernel/*
    
    As requested by Linus add explicit __visible to the asmlinkage users.
    This marks functions visible to assembler.
    
    Tree sweep for rest of tree.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1398984278-29319-4-git-send-email-andi@firstfloor.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a45b50962295..7228258b85ec 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1674,7 +1674,7 @@ EXPORT_SYMBOL(printk_emit);
  *
  * See the vsnprintf() documentation for format string extensions over C99.
  */
-asmlinkage int printk(const char *fmt, ...)
+asmlinkage __visible int printk(const char *fmt, ...)
 {
 	va_list args;
 	int r;
@@ -1737,7 +1737,7 @@ void early_vprintk(const char *fmt, va_list ap)
 	}
 }
 
-asmlinkage void early_printk(const char *fmt, ...)
+asmlinkage __visible void early_printk(const char *fmt, ...)
 {
 	va_list ap;
 

commit 72581487a61f6304a7cc32e189eb65fb1c920a53
Author: Jane Li <jiel@marvell.com>
Date:   Thu Apr 3 14:48:45 2014 -0700

    printk: fix one circular lockdep warning about console_lock
    
    Fix a warning about possible circular locking dependency.
    
    If do in following sequence:
    
        enter suspend ->  resume ->  plug-out CPUx (echo 0 > cpux/online)
    
    lockdep will show warning as following:
    
      ======================================================
      [ INFO: possible circular locking dependency detected ]
      3.10.0 #2 Tainted: G           O
      -------------------------------------------------------
      sh/1271 is trying to acquire lock:
      (console_lock){+.+.+.}, at: console_cpu_notify+0x20/0x2c
      but task is already holding lock:
      (cpu_hotplug.lock){+.+.+.}, at: cpu_hotplug_begin+0x2c/0x58
      which lock already depends on the new lock.
    
      the existing dependency chain (in reverse order) is:
      -> #2 (cpu_hotplug.lock){+.+.+.}:
        lock_acquire+0x98/0x12c
        mutex_lock_nested+0x50/0x3d8
        cpu_hotplug_begin+0x2c/0x58
        _cpu_up+0x24/0x154
        cpu_up+0x64/0x84
        smp_init+0x9c/0xd4
        kernel_init_freeable+0x78/0x1c8
        kernel_init+0x8/0xe4
        ret_from_fork+0x14/0x2c
    
      -> #1 (cpu_add_remove_lock){+.+.+.}:
        lock_acquire+0x98/0x12c
        mutex_lock_nested+0x50/0x3d8
        disable_nonboot_cpus+0x8/0xe8
        suspend_devices_and_enter+0x214/0x448
        pm_suspend+0x1e4/0x284
        try_to_suspend+0xa4/0xbc
        process_one_work+0x1c4/0x4fc
        worker_thread+0x138/0x37c
        kthread+0xa4/0xb0
        ret_from_fork+0x14/0x2c
    
      -> #0 (console_lock){+.+.+.}:
        __lock_acquire+0x1b38/0x1b80
        lock_acquire+0x98/0x12c
        console_lock+0x54/0x68
        console_cpu_notify+0x20/0x2c
        notifier_call_chain+0x44/0x84
        __cpu_notify+0x2c/0x48
        cpu_notify_nofail+0x8/0x14
        _cpu_down+0xf4/0x258
        cpu_down+0x24/0x40
        store_online+0x30/0x74
        dev_attr_store+0x18/0x24
        sysfs_write_file+0x16c/0x19c
        vfs_write+0xb4/0x190
        SyS_write+0x3c/0x70
        ret_fast_syscall+0x0/0x48
    
      Chain exists of:
         console_lock --> cpu_add_remove_lock --> cpu_hotplug.lock
    
      Possible unsafe locking scenario:
             CPU0                    CPU1
             ----                    ----
      lock(cpu_hotplug.lock);
                                     lock(cpu_add_remove_lock);
                                     lock(cpu_hotplug.lock);
      lock(console_lock);
        *** DEADLOCK ***
    
    There are three locks involved in two sequence:
    a) pm suspend:
            console_lock (@suspend_console())
            cpu_add_remove_lock (@disable_nonboot_cpus())
            cpu_hotplug.lock (@_cpu_down())
    b) Plug-out CPUx:
            cpu_add_remove_lock (@(cpu_down())
            cpu_hotplug.lock (@_cpu_down())
            console_lock (@console_cpu_notify()) => Lockdeps prints warning log.
    
    There should be not real deadlock, as flag of console_suspended can
    protect this.
    
    Although console_suspend() releases console_sem, it doesn't tell lockdep
    about it.  That results in the lockdep warning about circular locking
    when doing the following: enter suspend -> resume -> plug-out CPUx (echo
    0 > cpux/online)
    
    Fix the problem by telling lockdep we actually released the semaphore in
    console_suspend() and acquired it again in console_resume().
    
    Signed-off-by: Jane Li <jiel@marvell.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ff9faf4e3cd5..a45b50962295 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1883,6 +1883,7 @@ void suspend_console(void)
 	console_lock();
 	console_suspended = 1;
 	up(&console_sem);
+	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
 }
 
 void resume_console(void)
@@ -1890,6 +1891,7 @@ void resume_console(void)
 	if (!console_suspend_enabled)
 		return;
 	down(&console_sem);
+	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
 	console_suspended = 0;
 	console_unlock();
 }

commit fce6e0338abe910ba6d4db0657ae8adc6aa1a72b
Author: Petr Mladek <pmladek@suse.cz>
Date:   Thu Apr 3 14:48:43 2014 -0700

    printk: do not compute the size of the message twice
    
    This is just a tiny optimization.  It removes duplicate computation of
    the message size.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b3a1790f9e05..ff9faf4e3cd5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -351,7 +351,7 @@ static void log_store(int facility, int level,
 	else
 		msg->ts_nsec = local_clock();
 	memset(log_dict(msg) + dict_len, 0, pad_len);
-	msg->len = sizeof(struct printk_log) + text_len + dict_len + pad_len;
+	msg->len = size;
 
 	/* insert message */
 	log_next_idx += msg->len;

commit 39b25109b400ea397e64c417d8b965a53e2ee0f0
Author: Petr Mladek <pmladek@suse.cz>
Date:   Thu Apr 3 14:48:42 2014 -0700

    printk: use also the last bytes in the ring buffer
    
    It seems that we have newer used the last byte in the ring buffer.  In
    fact, we have newer used the last 4 bytes because of padding.
    
    First problem is in the check for free space.  The exact number of free
    bytes is enough to store the length of data.
    
    Second problem is in the check where the ring buffer is rotated.  The
    left side counts the first unused index.  It is unused, so it might be
    the same as the size of the buffer.
    
    Note that the first problem has to be fixed together with the second
    one.  Otherwise, the buffer is rotated even when there is enough space
    on the end of the buffer.  Then the beginning of the buffer is rewritten
    and valid entries get corrupted.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 012f3e40671d..b3a1790f9e05 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -319,7 +319,7 @@ static void log_store(int facility, int level,
 		else
 			free = log_first_idx - log_next_idx;
 
-		if (free > size + sizeof(struct printk_log))
+		if (free >= size + sizeof(struct printk_log))
 			break;
 
 		/* drop old messages until we have enough contiuous space */
@@ -327,7 +327,7 @@ static void log_store(int facility, int level,
 		log_first_seq++;
 	}
 
-	if (log_next_idx + size + sizeof(struct printk_log) >= log_buf_len) {
+	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 		/*
 		 * This message + an additional empty header does not fit
 		 * at the end of the buffer. Add an empty header with len == 0

commit e8c42d36ab86cf45f88c3a0e344233b1032fbf3d
Author: Petr Mladek <pmladek@suse.cz>
Date:   Thu Apr 3 14:48:41 2014 -0700

    printk: add comment about tricky check for text buffer size
    
    There is no check for potential "text_len" overflow.  It is not needed
    because only valid level is detected.  It took me some time to
    understand why.  It would deserve a comment ;-)
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index db7a02e05241..012f3e40671d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1561,6 +1561,11 @@ asmlinkage int vprintk_emit(int facility, int level,
 			case 'd':	/* KERN_DEFAULT */
 				lflags |= LOG_PREFIX;
 			}
+			/*
+			 * No need to check length here because vscnprintf
+			 * put '\0' at the end of the string. Only valid and
+			 * newly printed level is detected.
+			 */
 			text_len -= end_of_header - text;
 			text = (char *)end_of_header;
 		}

commit c64730b26f08cccfbc8fcbf169c304b4bd71dcac
Author: Petr Mladek <pmladek@suse.cz>
Date:   Thu Apr 3 14:48:39 2014 -0700

    printk: remove obsolete check for log level "c"
    
    The kernel log level "c" was removed in commit 61e99ab8e35a ("printk:
    remove the now unnecessary "C" annotation for KERN_CONT").  It is no
    longer detected in printk_get_level().  Hence we do not need to check it
    in vprintk_emit.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4dae9cbe9259..db7a02e05241 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1560,8 +1560,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 					level = kern_level - '0';
 			case 'd':	/* KERN_DEFAULT */
 				lflags |= LOG_PREFIX;
-			case 'c':	/* KERN_CONT */
-				break;
 			}
 			text_len -= end_of_header - text;
 			text = (char *)end_of_header;

commit e4178d809fdaee32a56833fff1f5056c99e90a1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 17 12:24:45 2014 -0800

    printk: fix syslog() overflowing user buffer
    
    This is not a buffer overflow in the traditional sense: we don't
    overflow any *kernel* buffers, but we do mis-count the amount of data we
    copy back to user space for the SYSLOG_ACTION_READ_ALL case.
    
    In particular, if the user buffer is too small to hold everything, and
    *if* there is a continuation line at just the right place, we can end up
    giving the user more data than he asked for.
    
    The reason is that we first count up the number of bytes all the log
    records contains, then we walk the records again until we've skipped the
    records at the beginning that won't fit, and then we walk the rest of
    the records and copy them to the user space buffer.
    
    And in between that "skip the initial records that won't fit" and the
    "copy the records that *will* fit to user space", we reset the 'prev'
    variable that contained the record information for the last record not
    copied.  That meant that when we started copying to user space, we now
    had a different character count than what we had originally calculated
    in the first record walk-through.
    
    The fix is to simply not clear the 'prev' flags value (in both cases
    where we had the same logic: syslog_print_all and kmsg_dump_get_buffer:
    the latter is used for pstore-like dumping)
    
    Reported-and-tested-by: Debabrata Banerjee <dbanerje@akamai.com>
    Acked-by: Kay Sievers <kay@vrfy.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b1d255f04135..4dae9cbe9259 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1076,7 +1076,6 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		next_seq = log_next_seq;
 
 		len = 0;
-		prev = 0;
 		while (len >= 0 && seq < next_seq) {
 			struct printk_log *msg = log_from_idx(idx);
 			int textlen;
@@ -2788,7 +2787,6 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	next_idx = idx;
 
 	l = 0;
-	prev = 0;
 	while (seq < dumper->next_seq) {
 		struct printk_log *msg = log_from_idx(idx);
 

commit 1d3fa370346d9d96ab0efb84e3312aed3aeb35ea
Author: Arun KS <arunks.linux@gmail.com>
Date:   Thu Jan 23 15:54:19 2014 -0800

    printk: flush conflicting continuation line
    
    An earlier newline was missing and current print is from different task.
    In this scenario flush the continuation line and store this line
    seperatly.
    
    This patch fix the below scenario of timestamp interleaving,
       [   28.154370 ] read_word_reg : reg[0x 3], reg[0x 4]  data [0x 642]
       [   28.155428 ] uart disconnect
       [   31.947341 ] dvfs[cpufreq.c<275>]:plug-in cpu<1> done
       [   28.155445 ] UART detached : send switch state 201
       [   32.014112 ] read_reg : reg[0x 3] data[0x21]
    
    [akpm@linux-foundation.org: simplify and condense the code]
    Signed-off-by: Arun KS <getarunks@gmail.com>
    Signed-off-by: Arun KS <arun.ks@broadcom.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index f8b41bddc6dc..b1d255f04135 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1595,10 +1595,13 @@ asmlinkage int vprintk_emit(int facility, int level,
 		 * either merge it with the current buffer and flush, or if
 		 * there was a race with interrupts (prefix == true) then just
 		 * flush it out and store this line separately.
+		 * If the preceding printk was from a different task and missed
+		 * a newline, flush and append the newline.
 		 */
-		if (cont.len && cont.owner == current) {
-			if (!(lflags & LOG_PREFIX))
-				stored = cont_add(facility, level, text, text_len);
+		if (cont.len) {
+			if (cont.owner == current && !(lflags & LOG_PREFIX))
+				stored = cont_add(facility, level, text,
+						  text_len);
 			cont_flush(LOG_NEWLINE);
 		}
 

commit 9da791dfabc60218c81904c7906b45789466e68e
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Jan 21 15:50:23 2014 -0800

    kernel/printk/printk.c: use memblock apis for early memory allocations
    
    Switch to memblock interfaces for early memory allocator instead of
    bootmem allocator.  No functional change in beahvior than what it is in
    current code from bootmem users points of view.
    
    Archs already converted to NO_BOOTMEM now directly use memblock
    interfaces instead of bootmem wrappers build on top of memblock.  And
    the archs which still uses bootmem, these new apis just fallback to
    exiting bootmem APIs.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index be7c86bae576..f8b41bddc6dc 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -757,14 +757,10 @@ void __init setup_log_buf(int early)
 		return;
 
 	if (early) {
-		unsigned long mem;
-
-		mem = memblock_alloc(new_log_buf_len, PAGE_SIZE);
-		if (!mem)
-			return;
-		new_log_buf = __va(mem);
+		new_log_buf =
+			memblock_virt_alloc(new_log_buf_len, PAGE_SIZE);
 	} else {
-		new_log_buf = alloc_bootmem_nopanic(new_log_buf_len);
+		new_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len, 0);
 	}
 
 	if (unlikely(!new_log_buf)) {

commit 4c1ace6408c83797117621f4c324dfa76259d16e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Tue Nov 12 15:08:54 2013 -0800

    printk.c: comments should refer to /proc/vmcore instead of /proc/vmcoreinfo
    
    In one of those comments a typo was fixed, too.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 9b527d41f8f1..be7c86bae576 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -705,9 +705,9 @@ const struct file_operations kmsg_fops = {
 
 #ifdef CONFIG_KEXEC
 /*
- * This appends the listed symbols to /proc/vmcoreinfo
+ * This appends the listed symbols to /proc/vmcore
  *
- * /proc/vmcoreinfo is used by various utiilties, like crash and makedumpfile to
+ * /proc/vmcore is used by various utilities, like crash and makedumpfile to
  * obtain access to symbols that are otherwise very difficult to locate.  These
  * symbols are specifically used so that utilities can access and extract the
  * dmesg log from a vmcore file after a crash.

commit 29e9d22559065af169bba6f99166eb9ab64c01c6
Author: Dave Young <dyoung@redhat.com>
Date:   Tue Nov 12 15:08:53 2013 -0800

    kernel/printk/printk.c: enable boot delay for earlyprintk
    
    boot_delay does not work for earlyprintk because the kernel cmdline
    parsing is late.
    
    Change to use early_param so early kernel messages can also be delayed.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 78b7c0f38259..9b527d41f8f1 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -820,9 +820,9 @@ static int __init boot_delay_setup(char *str)
 	pr_debug("boot_delay: %u, preset_lpj: %ld, lpj: %lu, "
 		"HZ: %d, loops_per_msec: %llu\n",
 		boot_delay, preset_lpj, lpj, HZ, loops_per_msec);
-	return 1;
+	return 0;
 }
-__setup("boot_delay=", boot_delay_setup);
+early_param("boot_delay", boot_delay_setup);
 
 static void boot_delay_msec(int level)
 {

commit 27083baca51358fe0fba8cf40b7df9bb696c931a
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Nov 12 15:08:50 2013 -0800

    kernel/printk/printk.c: convert to pr_foo()
    
    It was half-and-half.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 555ad2d445b4..78b7c0f38259 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -791,7 +791,7 @@ static bool __read_mostly ignore_loglevel;
 static int __init ignore_loglevel_setup(char *str)
 {
 	ignore_loglevel = 1;
-	printk(KERN_INFO "debug: ignoring loglevel setting.\n");
+	pr_info("debug: ignoring loglevel setting.\n");
 
 	return 0;
 }
@@ -2193,7 +2193,7 @@ static int __read_mostly keep_bootcon;
 static int __init keep_bootcon_setup(char *str)
 {
 	keep_bootcon = 1;
-	printk(KERN_INFO "debug: skip boot console de-registration.\n");
+	pr_info("debug: skip boot console de-registration.\n");
 
 	return 0;
 }
@@ -2241,7 +2241,7 @@ void register_console(struct console *newcon)
 		/* find the last or real console */
 		for_each_console(bcon) {
 			if (!(bcon->flags & CON_BOOT)) {
-				printk(KERN_INFO "Too late to register bootconsole %s%d\n",
+				pr_info("Too late to register bootconsole %s%d\n",
 					newcon->name, newcon->index);
 				return;
 			}
@@ -2358,7 +2358,7 @@ void register_console(struct console *newcon)
 	 * users know there might be something in the kernel's log buffer that
 	 * went to the bootconsole (that they do not see on the real console)
 	 */
-	printk(KERN_INFO "%sconsole [%s%d] enabled\n",
+	pr_info("%sconsole [%s%d] enabled\n",
 		(newcon->flags & CON_BOOT) ? "boot" : "" ,
 		newcon->name, newcon->index);
 	if (bcon &&
@@ -2379,7 +2379,7 @@ int unregister_console(struct console *console)
         struct console *a, *b;
 	int res;
 
-	printk(KERN_INFO "%sconsole [%s%d] disabled\n",
+	pr_info("%sconsole [%s%d] disabled\n",
 		(console->flags & CON_BOOT) ? "boot" : "" ,
 		console->name, console->index);
 
@@ -2448,7 +2448,7 @@ static void wake_up_klogd_work_func(struct irq_work *irq_work)
 
 	if (pending & PRINTK_PENDING_SCHED) {
 		char *buf = __get_cpu_var(printk_sched_buf);
-		printk(KERN_WARNING "[sched_delayed] %s", buf);
+		pr_warn("[sched_delayed] %s", buf);
 	}
 
 	if (pending & PRINTK_PENDING_WAKEUP)

commit 6b80239447f6785b719345e8913af420d8ec0818
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Nov 12 15:08:49 2013 -0800

    printk: report console names during cut-over
    
    This reports the names of consoles as they're being disabled to help
    identify which is which during cut-over.  Helps answer the question
    "which boot console actually got activated?" once the regular console is
    running, mostly when debugging boot console failures.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b4e8500afdb3..555ad2d445b4 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2358,21 +2358,18 @@ void register_console(struct console *newcon)
 	 * users know there might be something in the kernel's log buffer that
 	 * went to the bootconsole (that they do not see on the real console)
 	 */
+	printk(KERN_INFO "%sconsole [%s%d] enabled\n",
+		(newcon->flags & CON_BOOT) ? "boot" : "" ,
+		newcon->name, newcon->index);
 	if (bcon &&
 	    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&
 	    !keep_bootcon) {
-		/* we need to iterate through twice, to make sure we print
-		 * everything out, before we unregister the console(s)
+		/* We need to iterate through all boot consoles, to make
+		 * sure we print everything out, before we unregister them.
 		 */
-		printk(KERN_INFO "console [%s%d] enabled, bootconsole disabled\n",
-			newcon->name, newcon->index);
 		for_each_console(bcon)
 			if (bcon->flags & CON_BOOT)
 				unregister_console(bcon);
-	} else {
-		printk(KERN_INFO "%sconsole [%s%d] enabled\n",
-			(newcon->flags & CON_BOOT) ? "boot" : "" ,
-			newcon->name, newcon->index);
 	}
 }
 EXPORT_SYMBOL(register_console);
@@ -2382,6 +2379,10 @@ int unregister_console(struct console *console)
         struct console *a, *b;
 	int res;
 
+	printk(KERN_INFO "%sconsole [%s%d] disabled\n",
+		(console->flags & CON_BOOT) ? "boot" : "" ,
+		console->name, console->index);
+
 	res = _braille_unregister_console(console);
 	if (res)
 		return res;
@@ -2421,8 +2422,6 @@ static int __init printk_late_init(void)
 
 	for_each_console(con) {
 		if (!keep_bootcon && con->flags & CON_BOOT) {
-			printk(KERN_INFO "turn off boot console %s%d\n",
-				con->name, con->index);
 			unregister_console(con);
 		}
 	}

commit 16cf48a6d3e8f9ebe3c3231c12cbe4b0c4ed4d24
Author: Andreas Bießmann <andreas@biessmann.de>
Date:   Fri Aug 2 12:23:34 2013 +0200

    register_console: prevent adding the same console twice
    
    This patch guards the console_drivers list to be corrupted. The
    for_each_console() macro insist on a strictly forward list ended by NULL:
    
     con0->next->con1->next->NULL
    
    Without this patch it may happen easily to destroy this list for example by
    adding 'earlyprintk' twice, especially on embedded devices where the early
    console is often a single static instance.  This will result in the following
    list:
    
     con0->next->con0
    
    This in turn will result in an endless loop in console_unlock() later on by
    printing the first __log_buf line endlessly.
    
    Signed-off-by: Andreas Bießmann <andreas@biessmann.de>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5b5a7080e2a5..b4e8500afdb3 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2226,6 +2226,13 @@ void register_console(struct console *newcon)
 	struct console *bcon = NULL;
 	struct console_cmdline *c;
 
+	if (console_drivers)
+		for_each_console(bcon)
+			if (WARN(bcon == newcon,
+					"console '%s%d' already registered\n",
+					bcon->name, bcon->index))
+				return;
+
 	/*
 	 * before we register a new CON_BOOT console, make sure we don't
 	 * already have a valid console

commit 62e32ac3505a0cab1c5ef8ea2c0eab3b26ed855f
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 13:53:47 2013 -0700

    printk: rename struct log to struct printk_log
    
    Rename the struct to enable moving portions of
    printk.c to separate files.
    
    The rename changes output of /proc/vmcoreinfo.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 8f1fb50aa3ce..5b5a7080e2a5 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -173,7 +173,7 @@ static int console_may_schedule;
  *         67                           "g"
  *   0032     00 00 00                  padding to next message header
  *
- * The 'struct log' buffer header must never be directly exported to
+ * The 'struct printk_log' buffer header must never be directly exported to
  * userspace, it is a kernel-private implementation detail that might
  * need to be changed in the future, when the requirements change.
  *
@@ -195,7 +195,7 @@ enum log_flags {
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
 };
 
-struct log {
+struct printk_log {
 	u64 ts_nsec;		/* timestamp in nanoseconds */
 	u16 len;		/* length of entire record */
 	u16 text_len;		/* length of text buffer */
@@ -243,7 +243,7 @@ static u32 clear_idx;
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
 #define LOG_ALIGN 4
 #else
-#define LOG_ALIGN __alignof__(struct log)
+#define LOG_ALIGN __alignof__(struct printk_log)
 #endif
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
@@ -254,35 +254,35 @@ static u32 log_buf_len = __LOG_BUF_LEN;
 static volatile unsigned int logbuf_cpu = UINT_MAX;
 
 /* human readable text of the record */
-static char *log_text(const struct log *msg)
+static char *log_text(const struct printk_log *msg)
 {
-	return (char *)msg + sizeof(struct log);
+	return (char *)msg + sizeof(struct printk_log);
 }
 
 /* optional key/value pair dictionary attached to the record */
-static char *log_dict(const struct log *msg)
+static char *log_dict(const struct printk_log *msg)
 {
-	return (char *)msg + sizeof(struct log) + msg->text_len;
+	return (char *)msg + sizeof(struct printk_log) + msg->text_len;
 }
 
 /* get record by index; idx must point to valid msg */
-static struct log *log_from_idx(u32 idx)
+static struct printk_log *log_from_idx(u32 idx)
 {
-	struct log *msg = (struct log *)(log_buf + idx);
+	struct printk_log *msg = (struct printk_log *)(log_buf + idx);
 
 	/*
 	 * A length == 0 record is the end of buffer marker. Wrap around and
 	 * read the message at the start of the buffer.
 	 */
 	if (!msg->len)
-		return (struct log *)log_buf;
+		return (struct printk_log *)log_buf;
 	return msg;
 }
 
 /* get next record; idx must point to valid msg */
 static u32 log_next(u32 idx)
 {
-	struct log *msg = (struct log *)(log_buf + idx);
+	struct printk_log *msg = (struct printk_log *)(log_buf + idx);
 
 	/* length == 0 indicates the end of the buffer; wrap */
 	/*
@@ -291,7 +291,7 @@ static u32 log_next(u32 idx)
 	 * return the one after that.
 	 */
 	if (!msg->len) {
-		msg = (struct log *)log_buf;
+		msg = (struct printk_log *)log_buf;
 		return msg->len;
 	}
 	return idx + msg->len;
@@ -303,11 +303,11 @@ static void log_store(int facility, int level,
 		      const char *dict, u16 dict_len,
 		      const char *text, u16 text_len)
 {
-	struct log *msg;
+	struct printk_log *msg;
 	u32 size, pad_len;
 
 	/* number of '\0' padding bytes to next message */
-	size = sizeof(struct log) + text_len + dict_len;
+	size = sizeof(struct printk_log) + text_len + dict_len;
 	pad_len = (-size) & (LOG_ALIGN - 1);
 	size += pad_len;
 
@@ -319,7 +319,7 @@ static void log_store(int facility, int level,
 		else
 			free = log_first_idx - log_next_idx;
 
-		if (free > size + sizeof(struct log))
+		if (free > size + sizeof(struct printk_log))
 			break;
 
 		/* drop old messages until we have enough contiuous space */
@@ -327,18 +327,18 @@ static void log_store(int facility, int level,
 		log_first_seq++;
 	}
 
-	if (log_next_idx + size + sizeof(struct log) >= log_buf_len) {
+	if (log_next_idx + size + sizeof(struct printk_log) >= log_buf_len) {
 		/*
 		 * This message + an additional empty header does not fit
 		 * at the end of the buffer. Add an empty header with len == 0
 		 * to signify a wrap around.
 		 */
-		memset(log_buf + log_next_idx, 0, sizeof(struct log));
+		memset(log_buf + log_next_idx, 0, sizeof(struct printk_log));
 		log_next_idx = 0;
 	}
 
 	/* fill message */
-	msg = (struct log *)(log_buf + log_next_idx);
+	msg = (struct printk_log *)(log_buf + log_next_idx);
 	memcpy(log_text(msg), text, text_len);
 	msg->text_len = text_len;
 	memcpy(log_dict(msg), dict, dict_len);
@@ -351,7 +351,7 @@ static void log_store(int facility, int level,
 	else
 		msg->ts_nsec = local_clock();
 	memset(log_dict(msg) + dict_len, 0, pad_len);
-	msg->len = sizeof(struct log) + text_len + dict_len + pad_len;
+	msg->len = sizeof(struct printk_log) + text_len + dict_len + pad_len;
 
 	/* insert message */
 	log_next_idx += msg->len;
@@ -474,7 +474,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 			    size_t count, loff_t *ppos)
 {
 	struct devkmsg_user *user = file->private_data;
-	struct log *msg;
+	struct printk_log *msg;
 	u64 ts_usec;
 	size_t i;
 	char cont = '-';
@@ -719,14 +719,14 @@ void log_buf_kexec_setup(void)
 	VMCOREINFO_SYMBOL(log_first_idx);
 	VMCOREINFO_SYMBOL(log_next_idx);
 	/*
-	 * Export struct log size and field offsets. User space tools can
+	 * Export struct printk_log size and field offsets. User space tools can
 	 * parse it and detect any changes to structure down the line.
 	 */
-	VMCOREINFO_STRUCT_SIZE(log);
-	VMCOREINFO_OFFSET(log, ts_nsec);
-	VMCOREINFO_OFFSET(log, len);
-	VMCOREINFO_OFFSET(log, text_len);
-	VMCOREINFO_OFFSET(log, dict_len);
+	VMCOREINFO_STRUCT_SIZE(printk_log);
+	VMCOREINFO_OFFSET(printk_log, ts_nsec);
+	VMCOREINFO_OFFSET(printk_log, len);
+	VMCOREINFO_OFFSET(printk_log, text_len);
+	VMCOREINFO_OFFSET(printk_log, dict_len);
 }
 #endif
 
@@ -879,7 +879,7 @@ static size_t print_time(u64 ts, char *buf)
 		       (unsigned long)ts, rem_nsec / 1000);
 }
 
-static size_t print_prefix(const struct log *msg, bool syslog, char *buf)
+static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)
 {
 	size_t len = 0;
 	unsigned int prefix = (msg->facility << 3) | msg->level;
@@ -902,7 +902,7 @@ static size_t print_prefix(const struct log *msg, bool syslog, char *buf)
 	return len;
 }
 
-static size_t msg_print_text(const struct log *msg, enum log_flags prev,
+static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size)
 {
 	const char *text = log_text(msg);
@@ -964,7 +964,7 @@ static size_t msg_print_text(const struct log *msg, enum log_flags prev,
 static int syslog_print(char __user *buf, int size)
 {
 	char *text;
-	struct log *msg;
+	struct printk_log *msg;
 	int len = 0;
 
 	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
@@ -1055,7 +1055,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		idx = clear_idx;
 		prev = 0;
 		while (seq < log_next_seq) {
-			struct log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(idx);
 
 			len += msg_print_text(msg, prev, true, NULL, 0);
 			prev = msg->flags;
@@ -1068,7 +1068,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		idx = clear_idx;
 		prev = 0;
 		while (len > size && seq < log_next_seq) {
-			struct log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(idx);
 
 			len -= msg_print_text(msg, prev, true, NULL, 0);
 			prev = msg->flags;
@@ -1082,7 +1082,7 @@ static int syslog_print_all(char __user *buf, int size, bool clear)
 		len = 0;
 		prev = 0;
 		while (len >= 0 && seq < next_seq) {
-			struct log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(idx);
 			int textlen;
 
 			textlen = msg_print_text(msg, prev, true, text,
@@ -1228,7 +1228,7 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 
 			error = 0;
 			while (seq < log_next_seq) {
-				struct log *msg = log_from_idx(idx);
+				struct printk_log *msg = log_from_idx(idx);
 
 				error += msg_print_text(msg, prev, true, NULL, 0);
 				idx = log_next(idx);
@@ -1714,10 +1714,10 @@ static struct cont {
 	u8 level;
 	bool flushed:1;
 } cont;
-static struct log *log_from_idx(u32 idx) { return NULL; }
+static struct printk_log *log_from_idx(u32 idx) { return NULL; }
 static u32 log_next(u32 idx) { return 0; }
 static void call_console_drivers(int level, const char *text, size_t len) {}
-static size_t msg_print_text(const struct log *msg, enum log_flags prev,
+static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size) { return 0; }
 static size_t cont_print_text(char *text, size_t size) { return 0; }
 
@@ -2029,7 +2029,7 @@ void console_unlock(void)
 	console_cont_flush(text, sizeof(text));
 again:
 	for (;;) {
-		struct log *msg;
+		struct printk_log *msg;
 		size_t len;
 		int level;
 
@@ -2645,7 +2645,7 @@ void kmsg_dump(enum kmsg_dump_reason reason)
 bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 			       char *line, size_t size, size_t *len)
 {
-	struct log *msg;
+	struct printk_log *msg;
 	size_t l = 0;
 	bool ret = false;
 
@@ -2757,7 +2757,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	idx = dumper->cur_idx;
 	prev = 0;
 	while (seq < dumper->next_seq) {
-		struct log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(idx);
 
 		l += msg_print_text(msg, prev, true, NULL, 0);
 		idx = log_next(idx);
@@ -2770,7 +2770,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	idx = dumper->cur_idx;
 	prev = 0;
 	while (l > size && seq < dumper->next_seq) {
-		struct log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(idx);
 
 		l -= msg_print_text(msg, prev, true, NULL, 0);
 		idx = log_next(idx);
@@ -2785,7 +2785,7 @@ bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 	l = 0;
 	prev = 0;
 	while (seq < dumper->next_seq) {
-		struct log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(idx);
 
 		l += msg_print_text(msg, prev, syslog, buf + l, size - l);
 		idx = log_next(idx);

commit 23475408c618ecd5b44b7e069fd65ec73d17d9f0
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 13:53:46 2013 -0700

    printk: use pointer for console_cmdline indexing
    
    Make the code a bit more compact by always using a pointer for the active
    console_cmdline.
    
    Move overly indented code to correct indent level.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 5a022e0c654c..8f1fb50aa3ce 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1756,18 +1756,19 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	 *	See if this tty is not yet registered, and
 	 *	if we have a slot free.
 	 */
-	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++)
-		if (strcmp(console_cmdline[i].name, name) == 0 &&
-			  console_cmdline[i].index == idx) {
-				if (!brl_options)
-					selected_console = i;
-				return 0;
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++) {
+		if (strcmp(c->name, name) == 0 && c->index == idx) {
+			if (!brl_options)
+				selected_console = i;
+			return 0;
 		}
+	}
 	if (i == MAX_CMDLINECONSOLES)
 		return -E2BIG;
 	if (!brl_options)
 		selected_console = i;
-	c = &console_cmdline[i];
 	strlcpy(c->name, name, sizeof(c->name));
 	c->options = options;
 	braille_set_options(c, brl_options);
@@ -1840,15 +1841,15 @@ int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, cha
 	struct console_cmdline *c;
 	int i;
 
-	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++)
-		if (strcmp(console_cmdline[i].name, name) == 0 &&
-			  console_cmdline[i].index == idx) {
-				c = &console_cmdline[i];
-				strlcpy(c->name, name_new, sizeof(c->name));
-				c->name[sizeof(c->name) - 1] = 0;
-				c->options = options;
-				c->index = idx_new;
-				return i;
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++)
+		if (strcmp(c->name, name) == 0 && c->index == idx) {
+			strlcpy(c->name, name_new, sizeof(c->name));
+			c->name[sizeof(c->name) - 1] = 0;
+			c->options = options;
+			c->index = idx_new;
+			return i;
 		}
 	/* not found */
 	return -1;
@@ -2223,6 +2224,7 @@ void register_console(struct console *newcon)
 	int i;
 	unsigned long flags;
 	struct console *bcon = NULL;
+	struct console_cmdline *c;
 
 	/*
 	 * before we register a new CON_BOOT console, make sure we don't
@@ -2270,24 +2272,25 @@ void register_console(struct console *newcon)
 	 *	See if this console matches one we selected on
 	 *	the command line.
 	 */
-	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];
-			i++) {
-		if (strcmp(console_cmdline[i].name, newcon->name) != 0)
+	for (i = 0, c = console_cmdline;
+	     i < MAX_CMDLINECONSOLES && c->name[0];
+	     i++, c++) {
+		if (strcmp(c->name, newcon->name) != 0)
 			continue;
 		if (newcon->index >= 0 &&
-		    newcon->index != console_cmdline[i].index)
+		    newcon->index != c->index)
 			continue;
 		if (newcon->index < 0)
-			newcon->index = console_cmdline[i].index;
+			newcon->index = c->index;
 
-		if (_braille_register_console(newcon, &console_cmdline[i]))
+		if (_braille_register_console(newcon, c))
 			return;
 
 		if (newcon->setup &&
 		    newcon->setup(newcon, console_cmdline[i].options) != 0)
 			break;
 		newcon->flags |= CON_ENABLED;
-		newcon->index = console_cmdline[i].index;
+		newcon->index = c->index;
 		if (i == selected_console) {
 			newcon->flags |= CON_CONSDEV;
 			preferred_console = selected_console;

commit bbeddf52adc1b4207674ab88686cbbe58c24f721
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 13:53:45 2013 -0700

    printk: move braille console support into separate braille.[ch] files
    
    Create files with prototypes and static inlines for braille support.  Make
    braille_console functions return 1 on success.
    
    Corrected CONFIG_A11Y_BRAILLE_CONSOLE=n _braille_console_setup
    return value to NULL.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 4da2b2c7f67d..5a022e0c654c 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -52,6 +52,7 @@
 #include <trace/events/printk.h>
 
 #include "console_cmdline.h"
+#include "braille.h"
 
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
@@ -1769,9 +1770,8 @@ static int __add_preferred_console(char *name, int idx, char *options,
 	c = &console_cmdline[i];
 	strlcpy(c->name, name, sizeof(c->name));
 	c->options = options;
-#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
-	c->brl_options = brl_options;
-#endif
+	braille_set_options(c, brl_options);
+
 	c->index = idx;
 	return 0;
 }
@@ -1784,20 +1784,8 @@ static int __init console_setup(char *str)
 	char *s, *options, *brl_options = NULL;
 	int idx;
 
-#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
-	if (!memcmp(str, "brl,", 4)) {
-		brl_options = "";
-		str += 4;
-	} else if (!memcmp(str, "brl=", 4)) {
-		brl_options = str + 4;
-		str = strchr(brl_options, ',');
-		if (!str) {
-			printk(KERN_ERR "need port name after brl=\n");
-			return 1;
-		}
-		*(str++) = 0;
-	}
-#endif
+	if (_braille_console_setup(&str, &brl_options))
+		return 1;
 
 	/*
 	 * Decode str into name, index, options.
@@ -2291,16 +2279,10 @@ void register_console(struct console *newcon)
 			continue;
 		if (newcon->index < 0)
 			newcon->index = console_cmdline[i].index;
-#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
-		if (console_cmdline[i].brl_options) {
-			newcon->flags |= CON_BRL;
-			braille_register_console(newcon,
-					console_cmdline[i].index,
-					console_cmdline[i].options,
-					console_cmdline[i].brl_options);
+
+		if (_braille_register_console(newcon, &console_cmdline[i]))
 			return;
-		}
-#endif
+
 		if (newcon->setup &&
 		    newcon->setup(newcon, console_cmdline[i].options) != 0)
 			break;
@@ -2388,13 +2370,13 @@ EXPORT_SYMBOL(register_console);
 int unregister_console(struct console *console)
 {
         struct console *a, *b;
-	int res = 1;
+	int res;
 
-#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
-	if (console->flags & CON_BRL)
-		return braille_unregister_console(console);
-#endif
+	res = _braille_unregister_console(console);
+	if (res)
+		return res;
 
+	res = 1;
 	console_lock();
 	if (console_drivers == console) {
 		console_drivers=console->next;

commit d197c43d04decb6b1298fa3ef26ea04a9ca7c977
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 13:53:44 2013 -0700

    printk: add console_cmdline.h
    
    Add an include file for the console_cmdline struct so that the braille
    console driver can be separated.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 69b0890ed7e5..4da2b2c7f67d 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -51,6 +51,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
 
+#include "console_cmdline.h"
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
 
@@ -105,19 +107,11 @@ static struct console *exclusive_console;
 /*
  *	Array of consoles built from command line options (console=)
  */
-struct console_cmdline
-{
-	char	name[8];			/* Name of the driver	    */
-	int	index;				/* Minor dev. to use	    */
-	char	*options;			/* Options for the driver   */
-#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
-	char	*brl_options;			/* Options for braille driver */
-#endif
-};
 
 #define MAX_CMDLINECONSOLES 8
 
 static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
+
 static int selected_console = -1;
 static int preferred_console = -1;
 int console_set_on_cmdline;

commit b9ee979e9d770dc10f94936ef6ff9efddc23c911
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 13:53:42 2013 -0700

    printk: move to separate directory for easier modification
    
    Make it easier to break up printk into bite-sized chunks.
    
    Remove printk path/filename from comment.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
new file mode 100644
index 000000000000..69b0890ed7e5
--- /dev/null
+++ b/kernel/printk/printk.c
@@ -0,0 +1,2924 @@
+/*
+ *  linux/kernel/printk.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ * Modified to make sys_syslog() more flexible: added commands to
+ * return the last 4k of kernel messages, regardless of whether
+ * they've been read or not.  Added option to suppress kernel printk's
+ * to the console.  Added hook for sending the console messages
+ * elsewhere, in preparation for a serial line console (someday).
+ * Ted Ts'o, 2/11/93.
+ * Modified for sysctl support, 1/8/97, Chris Horn.
+ * Fixed SMP synchronization, 08/08/99, Manfred Spraul
+ *     manfred@colorfullife.com
+ * Rewrote bits to get rid of console_lock
+ *	01Mar01 Andrew Morton
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/nmi.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>			/* For in_interrupt() */
+#include <linux/delay.h>
+#include <linux/smp.h>
+#include <linux/security.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <linux/aio.h>
+#include <linux/syscalls.h>
+#include <linux/kexec.h>
+#include <linux/kdb.h>
+#include <linux/ratelimit.h>
+#include <linux/kmsg_dump.h>
+#include <linux/syslog.h>
+#include <linux/cpu.h>
+#include <linux/notifier.h>
+#include <linux/rculist.h>
+#include <linux/poll.h>
+#include <linux/irq_work.h>
+#include <linux/utsname.h>
+
+#include <asm/uaccess.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/printk.h>
+
+/* printk's without a loglevel use this.. */
+#define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
+
+/* We show everything that is MORE important than this.. */
+#define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
+#define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */
+
+int console_printk[4] = {
+	DEFAULT_CONSOLE_LOGLEVEL,	/* console_loglevel */
+	DEFAULT_MESSAGE_LOGLEVEL,	/* default_message_loglevel */
+	MINIMUM_CONSOLE_LOGLEVEL,	/* minimum_console_loglevel */
+	DEFAULT_CONSOLE_LOGLEVEL,	/* default_console_loglevel */
+};
+
+/*
+ * Low level drivers may need that to know if they can schedule in
+ * their unblank() callback or not. So let's export it.
+ */
+int oops_in_progress;
+EXPORT_SYMBOL(oops_in_progress);
+
+/*
+ * console_sem protects the console_drivers list, and also
+ * provides serialisation for access to the entire console
+ * driver system.
+ */
+static DEFINE_SEMAPHORE(console_sem);
+struct console *console_drivers;
+EXPORT_SYMBOL_GPL(console_drivers);
+
+#ifdef CONFIG_LOCKDEP
+static struct lockdep_map console_lock_dep_map = {
+	.name = "console_lock"
+};
+#endif
+
+/*
+ * This is used for debugging the mess that is the VT code by
+ * keeping track if we have the console semaphore held. It's
+ * definitely not the perfect debug tool (we don't know if _WE_
+ * hold it are racing, but it helps tracking those weird code
+ * path in the console code where we end up in places I want
+ * locked without the console sempahore held
+ */
+static int console_locked, console_suspended;
+
+/*
+ * If exclusive_console is non-NULL then only this console is to be printed to.
+ */
+static struct console *exclusive_console;
+
+/*
+ *	Array of consoles built from command line options (console=)
+ */
+struct console_cmdline
+{
+	char	name[8];			/* Name of the driver	    */
+	int	index;				/* Minor dev. to use	    */
+	char	*options;			/* Options for the driver   */
+#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
+	char	*brl_options;			/* Options for braille driver */
+#endif
+};
+
+#define MAX_CMDLINECONSOLES 8
+
+static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];
+static int selected_console = -1;
+static int preferred_console = -1;
+int console_set_on_cmdline;
+EXPORT_SYMBOL(console_set_on_cmdline);
+
+/* Flag: console code may call schedule() */
+static int console_may_schedule;
+
+/*
+ * The printk log buffer consists of a chain of concatenated variable
+ * length records. Every record starts with a record header, containing
+ * the overall length of the record.
+ *
+ * The heads to the first and last entry in the buffer, as well as the
+ * sequence numbers of these both entries are maintained when messages
+ * are stored..
+ *
+ * If the heads indicate available messages, the length in the header
+ * tells the start next message. A length == 0 for the next message
+ * indicates a wrap-around to the beginning of the buffer.
+ *
+ * Every record carries the monotonic timestamp in microseconds, as well as
+ * the standard userspace syslog level and syslog facility. The usual
+ * kernel messages use LOG_KERN; userspace-injected messages always carry
+ * a matching syslog facility, by default LOG_USER. The origin of every
+ * message can be reliably determined that way.
+ *
+ * The human readable log message directly follows the message header. The
+ * length of the message text is stored in the header, the stored message
+ * is not terminated.
+ *
+ * Optionally, a message can carry a dictionary of properties (key/value pairs),
+ * to provide userspace with a machine-readable message context.
+ *
+ * Examples for well-defined, commonly used property names are:
+ *   DEVICE=b12:8               device identifier
+ *                                b12:8         block dev_t
+ *                                c127:3        char dev_t
+ *                                n8            netdev ifindex
+ *                                +sound:card0  subsystem:devname
+ *   SUBSYSTEM=pci              driver-core subsystem name
+ *
+ * Valid characters in property names are [a-zA-Z0-9.-_]. The plain text value
+ * follows directly after a '=' character. Every property is terminated by
+ * a '\0' character. The last property is not terminated.
+ *
+ * Example of a message structure:
+ *   0000  ff 8f 00 00 00 00 00 00      monotonic time in nsec
+ *   0008  34 00                        record is 52 bytes long
+ *   000a        0b 00                  text is 11 bytes long
+ *   000c              1f 00            dictionary is 23 bytes long
+ *   000e                    03 00      LOG_KERN (facility) LOG_ERR (level)
+ *   0010  69 74 27 73 20 61 20 6c      "it's a l"
+ *         69 6e 65                     "ine"
+ *   001b           44 45 56 49 43      "DEVIC"
+ *         45 3d 62 38 3a 32 00 44      "E=b8:2\0D"
+ *         52 49 56 45 52 3d 62 75      "RIVER=bu"
+ *         67                           "g"
+ *   0032     00 00 00                  padding to next message header
+ *
+ * The 'struct log' buffer header must never be directly exported to
+ * userspace, it is a kernel-private implementation detail that might
+ * need to be changed in the future, when the requirements change.
+ *
+ * /dev/kmsg exports the structured data in the following line format:
+ *   "level,sequnum,timestamp;<message text>\n"
+ *
+ * The optional key/value pairs are attached as continuation lines starting
+ * with a space character and terminated by a newline. All possible
+ * non-prinatable characters are escaped in the "\xff" notation.
+ *
+ * Users of the export format should ignore possible additional values
+ * separated by ',', and find the message after the ';' character.
+ */
+
+enum log_flags {
+	LOG_NOCONS	= 1,	/* already flushed, do not print to console */
+	LOG_NEWLINE	= 2,	/* text ended with a newline */
+	LOG_PREFIX	= 4,	/* text started with a prefix */
+	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
+};
+
+struct log {
+	u64 ts_nsec;		/* timestamp in nanoseconds */
+	u16 len;		/* length of entire record */
+	u16 text_len;		/* length of text buffer */
+	u16 dict_len;		/* length of dictionary buffer */
+	u8 facility;		/* syslog facility */
+	u8 flags:5;		/* internal record flags */
+	u8 level:3;		/* syslog level */
+};
+
+/*
+ * The logbuf_lock protects kmsg buffer, indices, counters. It is also
+ * used in interesting ways to provide interlocking in console_unlock();
+ */
+static DEFINE_RAW_SPINLOCK(logbuf_lock);
+
+#ifdef CONFIG_PRINTK
+DECLARE_WAIT_QUEUE_HEAD(log_wait);
+/* the next printk record to read by syslog(READ) or /proc/kmsg */
+static u64 syslog_seq;
+static u32 syslog_idx;
+static enum log_flags syslog_prev;
+static size_t syslog_partial;
+
+/* index and sequence number of the first record stored in the buffer */
+static u64 log_first_seq;
+static u32 log_first_idx;
+
+/* index and sequence number of the next record to store in the buffer */
+static u64 log_next_seq;
+static u32 log_next_idx;
+
+/* the next printk record to write to the console */
+static u64 console_seq;
+static u32 console_idx;
+static enum log_flags console_prev;
+
+/* the next printk record to read after the last 'clear' command */
+static u64 clear_seq;
+static u32 clear_idx;
+
+#define PREFIX_MAX		32
+#define LOG_LINE_MAX		1024 - PREFIX_MAX
+
+/* record buffer */
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+#define LOG_ALIGN 4
+#else
+#define LOG_ALIGN __alignof__(struct log)
+#endif
+#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
+static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
+static char *log_buf = __log_buf;
+static u32 log_buf_len = __LOG_BUF_LEN;
+
+/* cpu currently holding logbuf_lock */
+static volatile unsigned int logbuf_cpu = UINT_MAX;
+
+/* human readable text of the record */
+static char *log_text(const struct log *msg)
+{
+	return (char *)msg + sizeof(struct log);
+}
+
+/* optional key/value pair dictionary attached to the record */
+static char *log_dict(const struct log *msg)
+{
+	return (char *)msg + sizeof(struct log) + msg->text_len;
+}
+
+/* get record by index; idx must point to valid msg */
+static struct log *log_from_idx(u32 idx)
+{
+	struct log *msg = (struct log *)(log_buf + idx);
+
+	/*
+	 * A length == 0 record is the end of buffer marker. Wrap around and
+	 * read the message at the start of the buffer.
+	 */
+	if (!msg->len)
+		return (struct log *)log_buf;
+	return msg;
+}
+
+/* get next record; idx must point to valid msg */
+static u32 log_next(u32 idx)
+{
+	struct log *msg = (struct log *)(log_buf + idx);
+
+	/* length == 0 indicates the end of the buffer; wrap */
+	/*
+	 * A length == 0 record is the end of buffer marker. Wrap around and
+	 * read the message at the start of the buffer as *this* one, and
+	 * return the one after that.
+	 */
+	if (!msg->len) {
+		msg = (struct log *)log_buf;
+		return msg->len;
+	}
+	return idx + msg->len;
+}
+
+/* insert record into the buffer, discard old ones, update heads */
+static void log_store(int facility, int level,
+		      enum log_flags flags, u64 ts_nsec,
+		      const char *dict, u16 dict_len,
+		      const char *text, u16 text_len)
+{
+	struct log *msg;
+	u32 size, pad_len;
+
+	/* number of '\0' padding bytes to next message */
+	size = sizeof(struct log) + text_len + dict_len;
+	pad_len = (-size) & (LOG_ALIGN - 1);
+	size += pad_len;
+
+	while (log_first_seq < log_next_seq) {
+		u32 free;
+
+		if (log_next_idx > log_first_idx)
+			free = max(log_buf_len - log_next_idx, log_first_idx);
+		else
+			free = log_first_idx - log_next_idx;
+
+		if (free > size + sizeof(struct log))
+			break;
+
+		/* drop old messages until we have enough contiuous space */
+		log_first_idx = log_next(log_first_idx);
+		log_first_seq++;
+	}
+
+	if (log_next_idx + size + sizeof(struct log) >= log_buf_len) {
+		/*
+		 * This message + an additional empty header does not fit
+		 * at the end of the buffer. Add an empty header with len == 0
+		 * to signify a wrap around.
+		 */
+		memset(log_buf + log_next_idx, 0, sizeof(struct log));
+		log_next_idx = 0;
+	}
+
+	/* fill message */
+	msg = (struct log *)(log_buf + log_next_idx);
+	memcpy(log_text(msg), text, text_len);
+	msg->text_len = text_len;
+	memcpy(log_dict(msg), dict, dict_len);
+	msg->dict_len = dict_len;
+	msg->facility = facility;
+	msg->level = level & 7;
+	msg->flags = flags & 0x1f;
+	if (ts_nsec > 0)
+		msg->ts_nsec = ts_nsec;
+	else
+		msg->ts_nsec = local_clock();
+	memset(log_dict(msg) + dict_len, 0, pad_len);
+	msg->len = sizeof(struct log) + text_len + dict_len + pad_len;
+
+	/* insert message */
+	log_next_idx += msg->len;
+	log_next_seq++;
+}
+
+#ifdef CONFIG_SECURITY_DMESG_RESTRICT
+int dmesg_restrict = 1;
+#else
+int dmesg_restrict;
+#endif
+
+static int syslog_action_restricted(int type)
+{
+	if (dmesg_restrict)
+		return 1;
+	/*
+	 * Unless restricted, we allow "read all" and "get buffer size"
+	 * for everybody.
+	 */
+	return type != SYSLOG_ACTION_READ_ALL &&
+	       type != SYSLOG_ACTION_SIZE_BUFFER;
+}
+
+static int check_syslog_permissions(int type, bool from_file)
+{
+	/*
+	 * If this is from /proc/kmsg and we've already opened it, then we've
+	 * already done the capabilities checks at open time.
+	 */
+	if (from_file && type != SYSLOG_ACTION_OPEN)
+		return 0;
+
+	if (syslog_action_restricted(type)) {
+		if (capable(CAP_SYSLOG))
+			return 0;
+		/*
+		 * For historical reasons, accept CAP_SYS_ADMIN too, with
+		 * a warning.
+		 */
+		if (capable(CAP_SYS_ADMIN)) {
+			pr_warn_once("%s (%d): Attempt to access syslog with "
+				     "CAP_SYS_ADMIN but no CAP_SYSLOG "
+				     "(deprecated).\n",
+				 current->comm, task_pid_nr(current));
+			return 0;
+		}
+		return -EPERM;
+	}
+	return security_syslog(type);
+}
+
+
+/* /dev/kmsg - userspace message inject/listen interface */
+struct devkmsg_user {
+	u64 seq;
+	u32 idx;
+	enum log_flags prev;
+	struct mutex lock;
+	char buf[8192];
+};
+
+static ssize_t devkmsg_writev(struct kiocb *iocb, const struct iovec *iv,
+			      unsigned long count, loff_t pos)
+{
+	char *buf, *line;
+	int i;
+	int level = default_message_loglevel;
+	int facility = 1;	/* LOG_USER */
+	size_t len = iov_length(iv, count);
+	ssize_t ret = len;
+
+	if (len > LOG_LINE_MAX)
+		return -EINVAL;
+	buf = kmalloc(len+1, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	line = buf;
+	for (i = 0; i < count; i++) {
+		if (copy_from_user(line, iv[i].iov_base, iv[i].iov_len)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		line += iv[i].iov_len;
+	}
+
+	/*
+	 * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace
+	 * the decimal value represents 32bit, the lower 3 bit are the log
+	 * level, the rest are the log facility.
+	 *
+	 * If no prefix or no userspace facility is specified, we
+	 * enforce LOG_USER, to be able to reliably distinguish
+	 * kernel-generated messages from userspace-injected ones.
+	 */
+	line = buf;
+	if (line[0] == '<') {
+		char *endp = NULL;
+
+		i = simple_strtoul(line+1, &endp, 10);
+		if (endp && endp[0] == '>') {
+			level = i & 7;
+			if (i >> 3)
+				facility = i >> 3;
+			endp++;
+			len -= endp - line;
+			line = endp;
+		}
+	}
+	line[len] = '\0';
+
+	printk_emit(facility, level, NULL, 0, "%s", line);
+out:
+	kfree(buf);
+	return ret;
+}
+
+static ssize_t devkmsg_read(struct file *file, char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	struct devkmsg_user *user = file->private_data;
+	struct log *msg;
+	u64 ts_usec;
+	size_t i;
+	char cont = '-';
+	size_t len;
+	ssize_t ret;
+
+	if (!user)
+		return -EBADF;
+
+	ret = mutex_lock_interruptible(&user->lock);
+	if (ret)
+		return ret;
+	raw_spin_lock_irq(&logbuf_lock);
+	while (user->seq == log_next_seq) {
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			raw_spin_unlock_irq(&logbuf_lock);
+			goto out;
+		}
+
+		raw_spin_unlock_irq(&logbuf_lock);
+		ret = wait_event_interruptible(log_wait,
+					       user->seq != log_next_seq);
+		if (ret)
+			goto out;
+		raw_spin_lock_irq(&logbuf_lock);
+	}
+
+	if (user->seq < log_first_seq) {
+		/* our last seen message is gone, return error and reset */
+		user->idx = log_first_idx;
+		user->seq = log_first_seq;
+		ret = -EPIPE;
+		raw_spin_unlock_irq(&logbuf_lock);
+		goto out;
+	}
+
+	msg = log_from_idx(user->idx);
+	ts_usec = msg->ts_nsec;
+	do_div(ts_usec, 1000);
+
+	/*
+	 * If we couldn't merge continuation line fragments during the print,
+	 * export the stored flags to allow an optional external merge of the
+	 * records. Merging the records isn't always neccessarily correct, like
+	 * when we hit a race during printing. In most cases though, it produces
+	 * better readable output. 'c' in the record flags mark the first
+	 * fragment of a line, '+' the following.
+	 */
+	if (msg->flags & LOG_CONT && !(user->prev & LOG_CONT))
+		cont = 'c';
+	else if ((msg->flags & LOG_CONT) ||
+		 ((user->prev & LOG_CONT) && !(msg->flags & LOG_PREFIX)))
+		cont = '+';
+
+	len = sprintf(user->buf, "%u,%llu,%llu,%c;",
+		      (msg->facility << 3) | msg->level,
+		      user->seq, ts_usec, cont);
+	user->prev = msg->flags;
+
+	/* escape non-printable characters */
+	for (i = 0; i < msg->text_len; i++) {
+		unsigned char c = log_text(msg)[i];
+
+		if (c < ' ' || c >= 127 || c == '\\')
+			len += sprintf(user->buf + len, "\\x%02x", c);
+		else
+			user->buf[len++] = c;
+	}
+	user->buf[len++] = '\n';
+
+	if (msg->dict_len) {
+		bool line = true;
+
+		for (i = 0; i < msg->dict_len; i++) {
+			unsigned char c = log_dict(msg)[i];
+
+			if (line) {
+				user->buf[len++] = ' ';
+				line = false;
+			}
+
+			if (c == '\0') {
+				user->buf[len++] = '\n';
+				line = true;
+				continue;
+			}
+
+			if (c < ' ' || c >= 127 || c == '\\') {
+				len += sprintf(user->buf + len, "\\x%02x", c);
+				continue;
+			}
+
+			user->buf[len++] = c;
+		}
+		user->buf[len++] = '\n';
+	}
+
+	user->idx = log_next(user->idx);
+	user->seq++;
+	raw_spin_unlock_irq(&logbuf_lock);
+
+	if (len > count) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (copy_to_user(buf, user->buf, len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = len;
+out:
+	mutex_unlock(&user->lock);
+	return ret;
+}
+
+static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)
+{
+	struct devkmsg_user *user = file->private_data;
+	loff_t ret = 0;
+
+	if (!user)
+		return -EBADF;
+	if (offset)
+		return -ESPIPE;
+
+	raw_spin_lock_irq(&logbuf_lock);
+	switch (whence) {
+	case SEEK_SET:
+		/* the first record */
+		user->idx = log_first_idx;
+		user->seq = log_first_seq;
+		break;
+	case SEEK_DATA:
+		/*
+		 * The first record after the last SYSLOG_ACTION_CLEAR,
+		 * like issued by 'dmesg -c'. Reading /dev/kmsg itself
+		 * changes no global state, and does not clear anything.
+		 */
+		user->idx = clear_idx;
+		user->seq = clear_seq;
+		break;
+	case SEEK_END:
+		/* after the last record */
+		user->idx = log_next_idx;
+		user->seq = log_next_seq;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	raw_spin_unlock_irq(&logbuf_lock);
+	return ret;
+}
+
+static unsigned int devkmsg_poll(struct file *file, poll_table *wait)
+{
+	struct devkmsg_user *user = file->private_data;
+	int ret = 0;
+
+	if (!user)
+		return POLLERR|POLLNVAL;
+
+	poll_wait(file, &log_wait, wait);
+
+	raw_spin_lock_irq(&logbuf_lock);
+	if (user->seq < log_next_seq) {
+		/* return error when data has vanished underneath us */
+		if (user->seq < log_first_seq)
+			ret = POLLIN|POLLRDNORM|POLLERR|POLLPRI;
+		else
+			ret = POLLIN|POLLRDNORM;
+	}
+	raw_spin_unlock_irq(&logbuf_lock);
+
+	return ret;
+}
+
+static int devkmsg_open(struct inode *inode, struct file *file)
+{
+	struct devkmsg_user *user;
+	int err;
+
+	/* write-only does not need any file context */
+	if ((file->f_flags & O_ACCMODE) == O_WRONLY)
+		return 0;
+
+	err = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,
+				       SYSLOG_FROM_READER);
+	if (err)
+		return err;
+
+	user = kmalloc(sizeof(struct devkmsg_user), GFP_KERNEL);
+	if (!user)
+		return -ENOMEM;
+
+	mutex_init(&user->lock);
+
+	raw_spin_lock_irq(&logbuf_lock);
+	user->idx = log_first_idx;
+	user->seq = log_first_seq;
+	raw_spin_unlock_irq(&logbuf_lock);
+
+	file->private_data = user;
+	return 0;
+}
+
+static int devkmsg_release(struct inode *inode, struct file *file)
+{
+	struct devkmsg_user *user = file->private_data;
+
+	if (!user)
+		return 0;
+
+	mutex_destroy(&user->lock);
+	kfree(user);
+	return 0;
+}
+
+const struct file_operations kmsg_fops = {
+	.open = devkmsg_open,
+	.read = devkmsg_read,
+	.aio_write = devkmsg_writev,
+	.llseek = devkmsg_llseek,
+	.poll = devkmsg_poll,
+	.release = devkmsg_release,
+};
+
+#ifdef CONFIG_KEXEC
+/*
+ * This appends the listed symbols to /proc/vmcoreinfo
+ *
+ * /proc/vmcoreinfo is used by various utiilties, like crash and makedumpfile to
+ * obtain access to symbols that are otherwise very difficult to locate.  These
+ * symbols are specifically used so that utilities can access and extract the
+ * dmesg log from a vmcore file after a crash.
+ */
+void log_buf_kexec_setup(void)
+{
+	VMCOREINFO_SYMBOL(log_buf);
+	VMCOREINFO_SYMBOL(log_buf_len);
+	VMCOREINFO_SYMBOL(log_first_idx);
+	VMCOREINFO_SYMBOL(log_next_idx);
+	/*
+	 * Export struct log size and field offsets. User space tools can
+	 * parse it and detect any changes to structure down the line.
+	 */
+	VMCOREINFO_STRUCT_SIZE(log);
+	VMCOREINFO_OFFSET(log, ts_nsec);
+	VMCOREINFO_OFFSET(log, len);
+	VMCOREINFO_OFFSET(log, text_len);
+	VMCOREINFO_OFFSET(log, dict_len);
+}
+#endif
+
+/* requested log_buf_len from kernel cmdline */
+static unsigned long __initdata new_log_buf_len;
+
+/* save requested log_buf_len since it's too early to process it */
+static int __init log_buf_len_setup(char *str)
+{
+	unsigned size = memparse(str, &str);
+
+	if (size)
+		size = roundup_pow_of_two(size);
+	if (size > log_buf_len)
+		new_log_buf_len = size;
+
+	return 0;
+}
+early_param("log_buf_len", log_buf_len_setup);
+
+void __init setup_log_buf(int early)
+{
+	unsigned long flags;
+	char *new_log_buf;
+	int free;
+
+	if (!new_log_buf_len)
+		return;
+
+	if (early) {
+		unsigned long mem;
+
+		mem = memblock_alloc(new_log_buf_len, PAGE_SIZE);
+		if (!mem)
+			return;
+		new_log_buf = __va(mem);
+	} else {
+		new_log_buf = alloc_bootmem_nopanic(new_log_buf_len);
+	}
+
+	if (unlikely(!new_log_buf)) {
+		pr_err("log_buf_len: %ld bytes not available\n",
+			new_log_buf_len);
+		return;
+	}
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	log_buf_len = new_log_buf_len;
+	log_buf = new_log_buf;
+	new_log_buf_len = 0;
+	free = __LOG_BUF_LEN - log_next_idx;
+	memcpy(log_buf, __log_buf, __LOG_BUF_LEN);
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+
+	pr_info("log_buf_len: %d\n", log_buf_len);
+	pr_info("early log buf free: %d(%d%%)\n",
+		free, (free * 100) / __LOG_BUF_LEN);
+}
+
+static bool __read_mostly ignore_loglevel;
+
+static int __init ignore_loglevel_setup(char *str)
+{
+	ignore_loglevel = 1;
+	printk(KERN_INFO "debug: ignoring loglevel setting.\n");
+
+	return 0;
+}
+
+early_param("ignore_loglevel", ignore_loglevel_setup);
+module_param(ignore_loglevel, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(ignore_loglevel, "ignore loglevel setting, to"
+	"print all kernel messages to the console.");
+
+#ifdef CONFIG_BOOT_PRINTK_DELAY
+
+static int boot_delay; /* msecs delay after each printk during bootup */
+static unsigned long long loops_per_msec;	/* based on boot_delay */
+
+static int __init boot_delay_setup(char *str)
+{
+	unsigned long lpj;
+
+	lpj = preset_lpj ? preset_lpj : 1000000;	/* some guess */
+	loops_per_msec = (unsigned long long)lpj / 1000 * HZ;
+
+	get_option(&str, &boot_delay);
+	if (boot_delay > 10 * 1000)
+		boot_delay = 0;
+
+	pr_debug("boot_delay: %u, preset_lpj: %ld, lpj: %lu, "
+		"HZ: %d, loops_per_msec: %llu\n",
+		boot_delay, preset_lpj, lpj, HZ, loops_per_msec);
+	return 1;
+}
+__setup("boot_delay=", boot_delay_setup);
+
+static void boot_delay_msec(int level)
+{
+	unsigned long long k;
+	unsigned long timeout;
+
+	if ((boot_delay == 0 || system_state != SYSTEM_BOOTING)
+		|| (level >= console_loglevel && !ignore_loglevel)) {
+		return;
+	}
+
+	k = (unsigned long long)loops_per_msec * boot_delay;
+
+	timeout = jiffies + msecs_to_jiffies(boot_delay);
+	while (k) {
+		k--;
+		cpu_relax();
+		/*
+		 * use (volatile) jiffies to prevent
+		 * compiler reduction; loop termination via jiffies
+		 * is secondary and may or may not happen.
+		 */
+		if (time_after(jiffies, timeout))
+			break;
+		touch_nmi_watchdog();
+	}
+}
+#else
+static inline void boot_delay_msec(int level)
+{
+}
+#endif
+
+#if defined(CONFIG_PRINTK_TIME)
+static bool printk_time = 1;
+#else
+static bool printk_time;
+#endif
+module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
+
+static size_t print_time(u64 ts, char *buf)
+{
+	unsigned long rem_nsec;
+
+	if (!printk_time)
+		return 0;
+
+	rem_nsec = do_div(ts, 1000000000);
+
+	if (!buf)
+		return snprintf(NULL, 0, "[%5lu.000000] ", (unsigned long)ts);
+
+	return sprintf(buf, "[%5lu.%06lu] ",
+		       (unsigned long)ts, rem_nsec / 1000);
+}
+
+static size_t print_prefix(const struct log *msg, bool syslog, char *buf)
+{
+	size_t len = 0;
+	unsigned int prefix = (msg->facility << 3) | msg->level;
+
+	if (syslog) {
+		if (buf) {
+			len += sprintf(buf, "<%u>", prefix);
+		} else {
+			len += 3;
+			if (prefix > 999)
+				len += 3;
+			else if (prefix > 99)
+				len += 2;
+			else if (prefix > 9)
+				len++;
+		}
+	}
+
+	len += print_time(msg->ts_nsec, buf ? buf + len : NULL);
+	return len;
+}
+
+static size_t msg_print_text(const struct log *msg, enum log_flags prev,
+			     bool syslog, char *buf, size_t size)
+{
+	const char *text = log_text(msg);
+	size_t text_size = msg->text_len;
+	bool prefix = true;
+	bool newline = true;
+	size_t len = 0;
+
+	if ((prev & LOG_CONT) && !(msg->flags & LOG_PREFIX))
+		prefix = false;
+
+	if (msg->flags & LOG_CONT) {
+		if ((prev & LOG_CONT) && !(prev & LOG_NEWLINE))
+			prefix = false;
+
+		if (!(msg->flags & LOG_NEWLINE))
+			newline = false;
+	}
+
+	do {
+		const char *next = memchr(text, '\n', text_size);
+		size_t text_len;
+
+		if (next) {
+			text_len = next - text;
+			next++;
+			text_size -= next - text;
+		} else {
+			text_len = text_size;
+		}
+
+		if (buf) {
+			if (print_prefix(msg, syslog, NULL) +
+			    text_len + 1 >= size - len)
+				break;
+
+			if (prefix)
+				len += print_prefix(msg, syslog, buf + len);
+			memcpy(buf + len, text, text_len);
+			len += text_len;
+			if (next || newline)
+				buf[len++] = '\n';
+		} else {
+			/* SYSLOG_ACTION_* buffer size only calculation */
+			if (prefix)
+				len += print_prefix(msg, syslog, NULL);
+			len += text_len;
+			if (next || newline)
+				len++;
+		}
+
+		prefix = true;
+		text = next;
+	} while (text);
+
+	return len;
+}
+
+static int syslog_print(char __user *buf, int size)
+{
+	char *text;
+	struct log *msg;
+	int len = 0;
+
+	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	if (!text)
+		return -ENOMEM;
+
+	while (size > 0) {
+		size_t n;
+		size_t skip;
+
+		raw_spin_lock_irq(&logbuf_lock);
+		if (syslog_seq < log_first_seq) {
+			/* messages are gone, move to first one */
+			syslog_seq = log_first_seq;
+			syslog_idx = log_first_idx;
+			syslog_prev = 0;
+			syslog_partial = 0;
+		}
+		if (syslog_seq == log_next_seq) {
+			raw_spin_unlock_irq(&logbuf_lock);
+			break;
+		}
+
+		skip = syslog_partial;
+		msg = log_from_idx(syslog_idx);
+		n = msg_print_text(msg, syslog_prev, true, text,
+				   LOG_LINE_MAX + PREFIX_MAX);
+		if (n - syslog_partial <= size) {
+			/* message fits into buffer, move forward */
+			syslog_idx = log_next(syslog_idx);
+			syslog_seq++;
+			syslog_prev = msg->flags;
+			n -= syslog_partial;
+			syslog_partial = 0;
+		} else if (!len){
+			/* partial read(), remember position */
+			n = size;
+			syslog_partial += n;
+		} else
+			n = 0;
+		raw_spin_unlock_irq(&logbuf_lock);
+
+		if (!n)
+			break;
+
+		if (copy_to_user(buf, text + skip, n)) {
+			if (!len)
+				len = -EFAULT;
+			break;
+		}
+
+		len += n;
+		size -= n;
+		buf += n;
+	}
+
+	kfree(text);
+	return len;
+}
+
+static int syslog_print_all(char __user *buf, int size, bool clear)
+{
+	char *text;
+	int len = 0;
+
+	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	if (!text)
+		return -ENOMEM;
+
+	raw_spin_lock_irq(&logbuf_lock);
+	if (buf) {
+		u64 next_seq;
+		u64 seq;
+		u32 idx;
+		enum log_flags prev;
+
+		if (clear_seq < log_first_seq) {
+			/* messages are gone, move to first available one */
+			clear_seq = log_first_seq;
+			clear_idx = log_first_idx;
+		}
+
+		/*
+		 * Find first record that fits, including all following records,
+		 * into the user-provided buffer for this dump.
+		 */
+		seq = clear_seq;
+		idx = clear_idx;
+		prev = 0;
+		while (seq < log_next_seq) {
+			struct log *msg = log_from_idx(idx);
+
+			len += msg_print_text(msg, prev, true, NULL, 0);
+			prev = msg->flags;
+			idx = log_next(idx);
+			seq++;
+		}
+
+		/* move first record forward until length fits into the buffer */
+		seq = clear_seq;
+		idx = clear_idx;
+		prev = 0;
+		while (len > size && seq < log_next_seq) {
+			struct log *msg = log_from_idx(idx);
+
+			len -= msg_print_text(msg, prev, true, NULL, 0);
+			prev = msg->flags;
+			idx = log_next(idx);
+			seq++;
+		}
+
+		/* last message fitting into this dump */
+		next_seq = log_next_seq;
+
+		len = 0;
+		prev = 0;
+		while (len >= 0 && seq < next_seq) {
+			struct log *msg = log_from_idx(idx);
+			int textlen;
+
+			textlen = msg_print_text(msg, prev, true, text,
+						 LOG_LINE_MAX + PREFIX_MAX);
+			if (textlen < 0) {
+				len = textlen;
+				break;
+			}
+			idx = log_next(idx);
+			seq++;
+			prev = msg->flags;
+
+			raw_spin_unlock_irq(&logbuf_lock);
+			if (copy_to_user(buf + len, text, textlen))
+				len = -EFAULT;
+			else
+				len += textlen;
+			raw_spin_lock_irq(&logbuf_lock);
+
+			if (seq < log_first_seq) {
+				/* messages are gone, move to next one */
+				seq = log_first_seq;
+				idx = log_first_idx;
+				prev = 0;
+			}
+		}
+	}
+
+	if (clear) {
+		clear_seq = log_next_seq;
+		clear_idx = log_next_idx;
+	}
+	raw_spin_unlock_irq(&logbuf_lock);
+
+	kfree(text);
+	return len;
+}
+
+int do_syslog(int type, char __user *buf, int len, bool from_file)
+{
+	bool clear = false;
+	static int saved_console_loglevel = -1;
+	int error;
+
+	error = check_syslog_permissions(type, from_file);
+	if (error)
+		goto out;
+
+	error = security_syslog(type);
+	if (error)
+		return error;
+
+	switch (type) {
+	case SYSLOG_ACTION_CLOSE:	/* Close log */
+		break;
+	case SYSLOG_ACTION_OPEN:	/* Open log */
+		break;
+	case SYSLOG_ACTION_READ:	/* Read from log */
+		error = -EINVAL;
+		if (!buf || len < 0)
+			goto out;
+		error = 0;
+		if (!len)
+			goto out;
+		if (!access_ok(VERIFY_WRITE, buf, len)) {
+			error = -EFAULT;
+			goto out;
+		}
+		error = wait_event_interruptible(log_wait,
+						 syslog_seq != log_next_seq);
+		if (error)
+			goto out;
+		error = syslog_print(buf, len);
+		break;
+	/* Read/clear last kernel messages */
+	case SYSLOG_ACTION_READ_CLEAR:
+		clear = true;
+		/* FALL THRU */
+	/* Read last kernel messages */
+	case SYSLOG_ACTION_READ_ALL:
+		error = -EINVAL;
+		if (!buf || len < 0)
+			goto out;
+		error = 0;
+		if (!len)
+			goto out;
+		if (!access_ok(VERIFY_WRITE, buf, len)) {
+			error = -EFAULT;
+			goto out;
+		}
+		error = syslog_print_all(buf, len, clear);
+		break;
+	/* Clear ring buffer */
+	case SYSLOG_ACTION_CLEAR:
+		syslog_print_all(NULL, 0, true);
+		break;
+	/* Disable logging to console */
+	case SYSLOG_ACTION_CONSOLE_OFF:
+		if (saved_console_loglevel == -1)
+			saved_console_loglevel = console_loglevel;
+		console_loglevel = minimum_console_loglevel;
+		break;
+	/* Enable logging to console */
+	case SYSLOG_ACTION_CONSOLE_ON:
+		if (saved_console_loglevel != -1) {
+			console_loglevel = saved_console_loglevel;
+			saved_console_loglevel = -1;
+		}
+		break;
+	/* Set level of messages printed to console */
+	case SYSLOG_ACTION_CONSOLE_LEVEL:
+		error = -EINVAL;
+		if (len < 1 || len > 8)
+			goto out;
+		if (len < minimum_console_loglevel)
+			len = minimum_console_loglevel;
+		console_loglevel = len;
+		/* Implicitly re-enable logging to console */
+		saved_console_loglevel = -1;
+		error = 0;
+		break;
+	/* Number of chars in the log buffer */
+	case SYSLOG_ACTION_SIZE_UNREAD:
+		raw_spin_lock_irq(&logbuf_lock);
+		if (syslog_seq < log_first_seq) {
+			/* messages are gone, move to first one */
+			syslog_seq = log_first_seq;
+			syslog_idx = log_first_idx;
+			syslog_prev = 0;
+			syslog_partial = 0;
+		}
+		if (from_file) {
+			/*
+			 * Short-cut for poll(/"proc/kmsg") which simply checks
+			 * for pending data, not the size; return the count of
+			 * records, not the length.
+			 */
+			error = log_next_idx - syslog_idx;
+		} else {
+			u64 seq = syslog_seq;
+			u32 idx = syslog_idx;
+			enum log_flags prev = syslog_prev;
+
+			error = 0;
+			while (seq < log_next_seq) {
+				struct log *msg = log_from_idx(idx);
+
+				error += msg_print_text(msg, prev, true, NULL, 0);
+				idx = log_next(idx);
+				seq++;
+				prev = msg->flags;
+			}
+			error -= syslog_partial;
+		}
+		raw_spin_unlock_irq(&logbuf_lock);
+		break;
+	/* Size of the log buffer */
+	case SYSLOG_ACTION_SIZE_BUFFER:
+		error = log_buf_len;
+		break;
+	default:
+		error = -EINVAL;
+		break;
+	}
+out:
+	return error;
+}
+
+SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)
+{
+	return do_syslog(type, buf, len, SYSLOG_FROM_READER);
+}
+
+/*
+ * Call the console drivers, asking them to write out
+ * log_buf[start] to log_buf[end - 1].
+ * The console_lock must be held.
+ */
+static void call_console_drivers(int level, const char *text, size_t len)
+{
+	struct console *con;
+
+	trace_console(text, len);
+
+	if (level >= console_loglevel && !ignore_loglevel)
+		return;
+	if (!console_drivers)
+		return;
+
+	for_each_console(con) {
+		if (exclusive_console && con != exclusive_console)
+			continue;
+		if (!(con->flags & CON_ENABLED))
+			continue;
+		if (!con->write)
+			continue;
+		if (!cpu_online(smp_processor_id()) &&
+		    !(con->flags & CON_ANYTIME))
+			continue;
+		con->write(con, text, len);
+	}
+}
+
+/*
+ * Zap console related locks when oopsing. Only zap at most once
+ * every 10 seconds, to leave time for slow consoles to print a
+ * full oops.
+ */
+static void zap_locks(void)
+{
+	static unsigned long oops_timestamp;
+
+	if (time_after_eq(jiffies, oops_timestamp) &&
+			!time_after(jiffies, oops_timestamp + 30 * HZ))
+		return;
+
+	oops_timestamp = jiffies;
+
+	debug_locks_off();
+	/* If a crash is occurring, make sure we can't deadlock */
+	raw_spin_lock_init(&logbuf_lock);
+	/* And make sure that we print immediately */
+	sema_init(&console_sem, 1);
+}
+
+/* Check if we have any console registered that can be called early in boot. */
+static int have_callable_console(void)
+{
+	struct console *con;
+
+	for_each_console(con)
+		if (con->flags & CON_ANYTIME)
+			return 1;
+
+	return 0;
+}
+
+/*
+ * Can we actually use the console at this time on this cpu?
+ *
+ * Console drivers may assume that per-cpu resources have
+ * been allocated. So unless they're explicitly marked as
+ * being able to cope (CON_ANYTIME) don't call them until
+ * this CPU is officially up.
+ */
+static inline int can_use_console(unsigned int cpu)
+{
+	return cpu_online(cpu) || have_callable_console();
+}
+
+/*
+ * Try to get console ownership to actually show the kernel
+ * messages from a 'printk'. Return true (and with the
+ * console_lock held, and 'console_locked' set) if it
+ * is successful, false otherwise.
+ *
+ * This gets called with the 'logbuf_lock' spinlock held and
+ * interrupts disabled. It should return with 'lockbuf_lock'
+ * released but interrupts still disabled.
+ */
+static int console_trylock_for_printk(unsigned int cpu)
+	__releases(&logbuf_lock)
+{
+	int retval = 0, wake = 0;
+
+	if (console_trylock()) {
+		retval = 1;
+
+		/*
+		 * If we can't use the console, we need to release
+		 * the console semaphore by hand to avoid flushing
+		 * the buffer. We need to hold the console semaphore
+		 * in order to do this test safely.
+		 */
+		if (!can_use_console(cpu)) {
+			console_locked = 0;
+			wake = 1;
+			retval = 0;
+		}
+	}
+	logbuf_cpu = UINT_MAX;
+	raw_spin_unlock(&logbuf_lock);
+	if (wake)
+		up(&console_sem);
+	return retval;
+}
+
+int printk_delay_msec __read_mostly;
+
+static inline void printk_delay(void)
+{
+	if (unlikely(printk_delay_msec)) {
+		int m = printk_delay_msec;
+
+		while (m--) {
+			mdelay(1);
+			touch_nmi_watchdog();
+		}
+	}
+}
+
+/*
+ * Continuation lines are buffered, and not committed to the record buffer
+ * until the line is complete, or a race forces it. The line fragments
+ * though, are printed immediately to the consoles to ensure everything has
+ * reached the console in case of a kernel crash.
+ */
+static struct cont {
+	char buf[LOG_LINE_MAX];
+	size_t len;			/* length == 0 means unused buffer */
+	size_t cons;			/* bytes written to console */
+	struct task_struct *owner;	/* task of first print*/
+	u64 ts_nsec;			/* time of first print */
+	u8 level;			/* log level of first message */
+	u8 facility;			/* log level of first message */
+	enum log_flags flags;		/* prefix, newline flags */
+	bool flushed:1;			/* buffer sealed and committed */
+} cont;
+
+static void cont_flush(enum log_flags flags)
+{
+	if (cont.flushed)
+		return;
+	if (cont.len == 0)
+		return;
+
+	if (cont.cons) {
+		/*
+		 * If a fragment of this line was directly flushed to the
+		 * console; wait for the console to pick up the rest of the
+		 * line. LOG_NOCONS suppresses a duplicated output.
+		 */
+		log_store(cont.facility, cont.level, flags | LOG_NOCONS,
+			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
+		cont.flags = flags;
+		cont.flushed = true;
+	} else {
+		/*
+		 * If no fragment of this line ever reached the console,
+		 * just submit it to the store and free the buffer.
+		 */
+		log_store(cont.facility, cont.level, flags, 0,
+			  NULL, 0, cont.buf, cont.len);
+		cont.len = 0;
+	}
+}
+
+static bool cont_add(int facility, int level, const char *text, size_t len)
+{
+	if (cont.len && cont.flushed)
+		return false;
+
+	if (cont.len + len > sizeof(cont.buf)) {
+		/* the line gets too long, split it up in separate records */
+		cont_flush(LOG_CONT);
+		return false;
+	}
+
+	if (!cont.len) {
+		cont.facility = facility;
+		cont.level = level;
+		cont.owner = current;
+		cont.ts_nsec = local_clock();
+		cont.flags = 0;
+		cont.cons = 0;
+		cont.flushed = false;
+	}
+
+	memcpy(cont.buf + cont.len, text, len);
+	cont.len += len;
+
+	if (cont.len > (sizeof(cont.buf) * 80) / 100)
+		cont_flush(LOG_CONT);
+
+	return true;
+}
+
+static size_t cont_print_text(char *text, size_t size)
+{
+	size_t textlen = 0;
+	size_t len;
+
+	if (cont.cons == 0 && (console_prev & LOG_NEWLINE)) {
+		textlen += print_time(cont.ts_nsec, text);
+		size -= textlen;
+	}
+
+	len = cont.len - cont.cons;
+	if (len > 0) {
+		if (len+1 > size)
+			len = size-1;
+		memcpy(text + textlen, cont.buf + cont.cons, len);
+		textlen += len;
+		cont.cons = cont.len;
+	}
+
+	if (cont.flushed) {
+		if (cont.flags & LOG_NEWLINE)
+			text[textlen++] = '\n';
+		/* got everything, release buffer */
+		cont.len = 0;
+	}
+	return textlen;
+}
+
+asmlinkage int vprintk_emit(int facility, int level,
+			    const char *dict, size_t dictlen,
+			    const char *fmt, va_list args)
+{
+	static int recursion_bug;
+	static char textbuf[LOG_LINE_MAX];
+	char *text = textbuf;
+	size_t text_len;
+	enum log_flags lflags = 0;
+	unsigned long flags;
+	int this_cpu;
+	int printed_len = 0;
+
+	boot_delay_msec(level);
+	printk_delay();
+
+	/* This stops the holder of console_sem just where we want him */
+	local_irq_save(flags);
+	this_cpu = smp_processor_id();
+
+	/*
+	 * Ouch, printk recursed into itself!
+	 */
+	if (unlikely(logbuf_cpu == this_cpu)) {
+		/*
+		 * If a crash is occurring during printk() on this CPU,
+		 * then try to get the crash message out but make sure
+		 * we can't deadlock. Otherwise just return to avoid the
+		 * recursion and return - but flag the recursion so that
+		 * it can be printed at the next appropriate moment:
+		 */
+		if (!oops_in_progress && !lockdep_recursing(current)) {
+			recursion_bug = 1;
+			goto out_restore_irqs;
+		}
+		zap_locks();
+	}
+
+	lockdep_off();
+	raw_spin_lock(&logbuf_lock);
+	logbuf_cpu = this_cpu;
+
+	if (recursion_bug) {
+		static const char recursion_msg[] =
+			"BUG: recent printk recursion!";
+
+		recursion_bug = 0;
+		printed_len += strlen(recursion_msg);
+		/* emit KERN_CRIT message */
+		log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
+			  NULL, 0, recursion_msg, printed_len);
+	}
+
+	/*
+	 * The printf needs to come first; we need the syslog
+	 * prefix which might be passed-in as a parameter.
+	 */
+	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
+
+	/* mark and strip a trailing newline */
+	if (text_len && text[text_len-1] == '\n') {
+		text_len--;
+		lflags |= LOG_NEWLINE;
+	}
+
+	/* strip kernel syslog prefix and extract log level or control flags */
+	if (facility == 0) {
+		int kern_level = printk_get_level(text);
+
+		if (kern_level) {
+			const char *end_of_header = printk_skip_level(text);
+			switch (kern_level) {
+			case '0' ... '7':
+				if (level == -1)
+					level = kern_level - '0';
+			case 'd':	/* KERN_DEFAULT */
+				lflags |= LOG_PREFIX;
+			case 'c':	/* KERN_CONT */
+				break;
+			}
+			text_len -= end_of_header - text;
+			text = (char *)end_of_header;
+		}
+	}
+
+	if (level == -1)
+		level = default_message_loglevel;
+
+	if (dict)
+		lflags |= LOG_PREFIX|LOG_NEWLINE;
+
+	if (!(lflags & LOG_NEWLINE)) {
+		/*
+		 * Flush the conflicting buffer. An earlier newline was missing,
+		 * or another task also prints continuation lines.
+		 */
+		if (cont.len && (lflags & LOG_PREFIX || cont.owner != current))
+			cont_flush(LOG_NEWLINE);
+
+		/* buffer line if possible, otherwise store it right away */
+		if (!cont_add(facility, level, text, text_len))
+			log_store(facility, level, lflags | LOG_CONT, 0,
+				  dict, dictlen, text, text_len);
+	} else {
+		bool stored = false;
+
+		/*
+		 * If an earlier newline was missing and it was the same task,
+		 * either merge it with the current buffer and flush, or if
+		 * there was a race with interrupts (prefix == true) then just
+		 * flush it out and store this line separately.
+		 */
+		if (cont.len && cont.owner == current) {
+			if (!(lflags & LOG_PREFIX))
+				stored = cont_add(facility, level, text, text_len);
+			cont_flush(LOG_NEWLINE);
+		}
+
+		if (!stored)
+			log_store(facility, level, lflags, 0,
+				  dict, dictlen, text, text_len);
+	}
+	printed_len += text_len;
+
+	/*
+	 * Try to acquire and then immediately release the console semaphore.
+	 * The release will print out buffers and wake up /dev/kmsg and syslog()
+	 * users.
+	 *
+	 * The console_trylock_for_printk() function will release 'logbuf_lock'
+	 * regardless of whether it actually gets the console semaphore or not.
+	 */
+	if (console_trylock_for_printk(this_cpu))
+		console_unlock();
+
+	lockdep_on();
+out_restore_irqs:
+	local_irq_restore(flags);
+
+	return printed_len;
+}
+EXPORT_SYMBOL(vprintk_emit);
+
+asmlinkage int vprintk(const char *fmt, va_list args)
+{
+	return vprintk_emit(0, -1, NULL, 0, fmt, args);
+}
+EXPORT_SYMBOL(vprintk);
+
+asmlinkage int printk_emit(int facility, int level,
+			   const char *dict, size_t dictlen,
+			   const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+	va_start(args, fmt);
+	r = vprintk_emit(facility, level, dict, dictlen, fmt, args);
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(printk_emit);
+
+/**
+ * printk - print a kernel message
+ * @fmt: format string
+ *
+ * This is printk(). It can be called from any context. We want it to work.
+ *
+ * We try to grab the console_lock. If we succeed, it's easy - we log the
+ * output and call the console drivers.  If we fail to get the semaphore, we
+ * place the output into the log buffer and return. The current holder of
+ * the console_sem will notice the new output in console_unlock(); and will
+ * send it to the consoles before releasing the lock.
+ *
+ * One effect of this deferred printing is that code which calls printk() and
+ * then changes console_loglevel may break. This is because console_loglevel
+ * is inspected when the actual printing occurs.
+ *
+ * See also:
+ * printf(3)
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
+ */
+asmlinkage int printk(const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+#ifdef CONFIG_KGDB_KDB
+	if (unlikely(kdb_trap_printk)) {
+		va_start(args, fmt);
+		r = vkdb_printf(fmt, args);
+		va_end(args);
+		return r;
+	}
+#endif
+	va_start(args, fmt);
+	r = vprintk_emit(0, -1, NULL, 0, fmt, args);
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(printk);
+
+#else /* CONFIG_PRINTK */
+
+#define LOG_LINE_MAX		0
+#define PREFIX_MAX		0
+#define LOG_LINE_MAX 0
+static u64 syslog_seq;
+static u32 syslog_idx;
+static u64 console_seq;
+static u32 console_idx;
+static enum log_flags syslog_prev;
+static u64 log_first_seq;
+static u32 log_first_idx;
+static u64 log_next_seq;
+static enum log_flags console_prev;
+static struct cont {
+	size_t len;
+	size_t cons;
+	u8 level;
+	bool flushed:1;
+} cont;
+static struct log *log_from_idx(u32 idx) { return NULL; }
+static u32 log_next(u32 idx) { return 0; }
+static void call_console_drivers(int level, const char *text, size_t len) {}
+static size_t msg_print_text(const struct log *msg, enum log_flags prev,
+			     bool syslog, char *buf, size_t size) { return 0; }
+static size_t cont_print_text(char *text, size_t size) { return 0; }
+
+#endif /* CONFIG_PRINTK */
+
+#ifdef CONFIG_EARLY_PRINTK
+struct console *early_console;
+
+void early_vprintk(const char *fmt, va_list ap)
+{
+	if (early_console) {
+		char buf[512];
+		int n = vscnprintf(buf, sizeof(buf), fmt, ap);
+
+		early_console->write(early_console, buf, n);
+	}
+}
+
+asmlinkage void early_printk(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	early_vprintk(fmt, ap);
+	va_end(ap);
+}
+#endif
+
+static int __add_preferred_console(char *name, int idx, char *options,
+				   char *brl_options)
+{
+	struct console_cmdline *c;
+	int i;
+
+	/*
+	 *	See if this tty is not yet registered, and
+	 *	if we have a slot free.
+	 */
+	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++)
+		if (strcmp(console_cmdline[i].name, name) == 0 &&
+			  console_cmdline[i].index == idx) {
+				if (!brl_options)
+					selected_console = i;
+				return 0;
+		}
+	if (i == MAX_CMDLINECONSOLES)
+		return -E2BIG;
+	if (!brl_options)
+		selected_console = i;
+	c = &console_cmdline[i];
+	strlcpy(c->name, name, sizeof(c->name));
+	c->options = options;
+#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
+	c->brl_options = brl_options;
+#endif
+	c->index = idx;
+	return 0;
+}
+/*
+ * Set up a list of consoles.  Called from init/main.c
+ */
+static int __init console_setup(char *str)
+{
+	char buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for index */
+	char *s, *options, *brl_options = NULL;
+	int idx;
+
+#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
+	if (!memcmp(str, "brl,", 4)) {
+		brl_options = "";
+		str += 4;
+	} else if (!memcmp(str, "brl=", 4)) {
+		brl_options = str + 4;
+		str = strchr(brl_options, ',');
+		if (!str) {
+			printk(KERN_ERR "need port name after brl=\n");
+			return 1;
+		}
+		*(str++) = 0;
+	}
+#endif
+
+	/*
+	 * Decode str into name, index, options.
+	 */
+	if (str[0] >= '0' && str[0] <= '9') {
+		strcpy(buf, "ttyS");
+		strncpy(buf + 4, str, sizeof(buf) - 5);
+	} else {
+		strncpy(buf, str, sizeof(buf) - 1);
+	}
+	buf[sizeof(buf) - 1] = 0;
+	if ((options = strchr(str, ',')) != NULL)
+		*(options++) = 0;
+#ifdef __sparc__
+	if (!strcmp(str, "ttya"))
+		strcpy(buf, "ttyS0");
+	if (!strcmp(str, "ttyb"))
+		strcpy(buf, "ttyS1");
+#endif
+	for (s = buf; *s; s++)
+		if ((*s >= '0' && *s <= '9') || *s == ',')
+			break;
+	idx = simple_strtoul(s, NULL, 10);
+	*s = 0;
+
+	__add_preferred_console(buf, idx, options, brl_options);
+	console_set_on_cmdline = 1;
+	return 1;
+}
+__setup("console=", console_setup);
+
+/**
+ * add_preferred_console - add a device to the list of preferred consoles.
+ * @name: device name
+ * @idx: device index
+ * @options: options for this console
+ *
+ * The last preferred console added will be used for kernel messages
+ * and stdin/out/err for init.  Normally this is used by console_setup
+ * above to handle user-supplied console arguments; however it can also
+ * be used by arch-specific code either to override the user or more
+ * commonly to provide a default console (ie from PROM variables) when
+ * the user has not supplied one.
+ */
+int add_preferred_console(char *name, int idx, char *options)
+{
+	return __add_preferred_console(name, idx, options, NULL);
+}
+
+int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, char *options)
+{
+	struct console_cmdline *c;
+	int i;
+
+	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++)
+		if (strcmp(console_cmdline[i].name, name) == 0 &&
+			  console_cmdline[i].index == idx) {
+				c = &console_cmdline[i];
+				strlcpy(c->name, name_new, sizeof(c->name));
+				c->name[sizeof(c->name) - 1] = 0;
+				c->options = options;
+				c->index = idx_new;
+				return i;
+		}
+	/* not found */
+	return -1;
+}
+
+bool console_suspend_enabled = 1;
+EXPORT_SYMBOL(console_suspend_enabled);
+
+static int __init console_suspend_disable(char *str)
+{
+	console_suspend_enabled = 0;
+	return 1;
+}
+__setup("no_console_suspend", console_suspend_disable);
+module_param_named(console_suspend, console_suspend_enabled,
+		bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(console_suspend, "suspend console during suspend"
+	" and hibernate operations");
+
+/**
+ * suspend_console - suspend the console subsystem
+ *
+ * This disables printk() while we go into suspend states
+ */
+void suspend_console(void)
+{
+	if (!console_suspend_enabled)
+		return;
+	printk("Suspending console(s) (use no_console_suspend to debug)\n");
+	console_lock();
+	console_suspended = 1;
+	up(&console_sem);
+}
+
+void resume_console(void)
+{
+	if (!console_suspend_enabled)
+		return;
+	down(&console_sem);
+	console_suspended = 0;
+	console_unlock();
+}
+
+/**
+ * console_cpu_notify - print deferred console messages after CPU hotplug
+ * @self: notifier struct
+ * @action: CPU hotplug event
+ * @hcpu: unused
+ *
+ * If printk() is called from a CPU that is not online yet, the messages
+ * will be spooled but will not show up on the console.  This function is
+ * called when a new CPU comes online (or fails to come up), and ensures
+ * that any such output gets printed.
+ */
+static int console_cpu_notify(struct notifier_block *self,
+	unsigned long action, void *hcpu)
+{
+	switch (action) {
+	case CPU_ONLINE:
+	case CPU_DEAD:
+	case CPU_DOWN_FAILED:
+	case CPU_UP_CANCELED:
+		console_lock();
+		console_unlock();
+	}
+	return NOTIFY_OK;
+}
+
+/**
+ * console_lock - lock the console system for exclusive use.
+ *
+ * Acquires a lock which guarantees that the caller has
+ * exclusive access to the console system and the console_drivers list.
+ *
+ * Can sleep, returns nothing.
+ */
+void console_lock(void)
+{
+	might_sleep();
+
+	down(&console_sem);
+	if (console_suspended)
+		return;
+	console_locked = 1;
+	console_may_schedule = 1;
+	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
+}
+EXPORT_SYMBOL(console_lock);
+
+/**
+ * console_trylock - try to lock the console system for exclusive use.
+ *
+ * Tried to acquire a lock which guarantees that the caller has
+ * exclusive access to the console system and the console_drivers list.
+ *
+ * returns 1 on success, and 0 on failure to acquire the lock.
+ */
+int console_trylock(void)
+{
+	if (down_trylock(&console_sem))
+		return 0;
+	if (console_suspended) {
+		up(&console_sem);
+		return 0;
+	}
+	console_locked = 1;
+	console_may_schedule = 0;
+	mutex_acquire(&console_lock_dep_map, 0, 1, _RET_IP_);
+	return 1;
+}
+EXPORT_SYMBOL(console_trylock);
+
+int is_console_locked(void)
+{
+	return console_locked;
+}
+
+static void console_cont_flush(char *text, size_t size)
+{
+	unsigned long flags;
+	size_t len;
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+
+	if (!cont.len)
+		goto out;
+
+	/*
+	 * We still queue earlier records, likely because the console was
+	 * busy. The earlier ones need to be printed before this one, we
+	 * did not flush any fragment so far, so just let it queue up.
+	 */
+	if (console_seq < log_next_seq && !cont.cons)
+		goto out;
+
+	len = cont_print_text(text, size);
+	raw_spin_unlock(&logbuf_lock);
+	stop_critical_timings();
+	call_console_drivers(cont.level, text, len);
+	start_critical_timings();
+	local_irq_restore(flags);
+	return;
+out:
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+}
+
+/**
+ * console_unlock - unlock the console system
+ *
+ * Releases the console_lock which the caller holds on the console system
+ * and the console driver list.
+ *
+ * While the console_lock was held, console output may have been buffered
+ * by printk().  If this is the case, console_unlock(); emits
+ * the output prior to releasing the lock.
+ *
+ * If there is output waiting, we wake /dev/kmsg and syslog() users.
+ *
+ * console_unlock(); may be called from any context.
+ */
+void console_unlock(void)
+{
+	static char text[LOG_LINE_MAX + PREFIX_MAX];
+	static u64 seen_seq;
+	unsigned long flags;
+	bool wake_klogd = false;
+	bool retry;
+
+	if (console_suspended) {
+		up(&console_sem);
+		return;
+	}
+
+	console_may_schedule = 0;
+
+	/* flush buffered message fragment immediately to console */
+	console_cont_flush(text, sizeof(text));
+again:
+	for (;;) {
+		struct log *msg;
+		size_t len;
+		int level;
+
+		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		if (seen_seq != log_next_seq) {
+			wake_klogd = true;
+			seen_seq = log_next_seq;
+		}
+
+		if (console_seq < log_first_seq) {
+			/* messages are gone, move to first one */
+			console_seq = log_first_seq;
+			console_idx = log_first_idx;
+			console_prev = 0;
+		}
+skip:
+		if (console_seq == log_next_seq)
+			break;
+
+		msg = log_from_idx(console_idx);
+		if (msg->flags & LOG_NOCONS) {
+			/*
+			 * Skip record we have buffered and already printed
+			 * directly to the console when we received it.
+			 */
+			console_idx = log_next(console_idx);
+			console_seq++;
+			/*
+			 * We will get here again when we register a new
+			 * CON_PRINTBUFFER console. Clear the flag so we
+			 * will properly dump everything later.
+			 */
+			msg->flags &= ~LOG_NOCONS;
+			console_prev = msg->flags;
+			goto skip;
+		}
+
+		level = msg->level;
+		len = msg_print_text(msg, console_prev, false,
+				     text, sizeof(text));
+		console_idx = log_next(console_idx);
+		console_seq++;
+		console_prev = msg->flags;
+		raw_spin_unlock(&logbuf_lock);
+
+		stop_critical_timings();	/* don't trace print latency */
+		call_console_drivers(level, text, len);
+		start_critical_timings();
+		local_irq_restore(flags);
+	}
+	console_locked = 0;
+	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
+
+	/* Release the exclusive_console once it is used */
+	if (unlikely(exclusive_console))
+		exclusive_console = NULL;
+
+	raw_spin_unlock(&logbuf_lock);
+
+	up(&console_sem);
+
+	/*
+	 * Someone could have filled up the buffer again, so re-check if there's
+	 * something to flush. In case we cannot trylock the console_sem again,
+	 * there's a new owner and the console_unlock() from them will do the
+	 * flush, no worries.
+	 */
+	raw_spin_lock(&logbuf_lock);
+	retry = console_seq != log_next_seq;
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+
+	if (retry && console_trylock())
+		goto again;
+
+	if (wake_klogd)
+		wake_up_klogd();
+}
+EXPORT_SYMBOL(console_unlock);
+
+/**
+ * console_conditional_schedule - yield the CPU if required
+ *
+ * If the console code is currently allowed to sleep, and
+ * if this CPU should yield the CPU to another task, do
+ * so here.
+ *
+ * Must be called within console_lock();.
+ */
+void __sched console_conditional_schedule(void)
+{
+	if (console_may_schedule)
+		cond_resched();
+}
+EXPORT_SYMBOL(console_conditional_schedule);
+
+void console_unblank(void)
+{
+	struct console *c;
+
+	/*
+	 * console_unblank can no longer be called in interrupt context unless
+	 * oops_in_progress is set to 1..
+	 */
+	if (oops_in_progress) {
+		if (down_trylock(&console_sem) != 0)
+			return;
+	} else
+		console_lock();
+
+	console_locked = 1;
+	console_may_schedule = 0;
+	for_each_console(c)
+		if ((c->flags & CON_ENABLED) && c->unblank)
+			c->unblank();
+	console_unlock();
+}
+
+/*
+ * Return the console tty driver structure and its associated index
+ */
+struct tty_driver *console_device(int *index)
+{
+	struct console *c;
+	struct tty_driver *driver = NULL;
+
+	console_lock();
+	for_each_console(c) {
+		if (!c->device)
+			continue;
+		driver = c->device(c, index);
+		if (driver)
+			break;
+	}
+	console_unlock();
+	return driver;
+}
+
+/*
+ * Prevent further output on the passed console device so that (for example)
+ * serial drivers can disable console output before suspending a port, and can
+ * re-enable output afterwards.
+ */
+void console_stop(struct console *console)
+{
+	console_lock();
+	console->flags &= ~CON_ENABLED;
+	console_unlock();
+}
+EXPORT_SYMBOL(console_stop);
+
+void console_start(struct console *console)
+{
+	console_lock();
+	console->flags |= CON_ENABLED;
+	console_unlock();
+}
+EXPORT_SYMBOL(console_start);
+
+static int __read_mostly keep_bootcon;
+
+static int __init keep_bootcon_setup(char *str)
+{
+	keep_bootcon = 1;
+	printk(KERN_INFO "debug: skip boot console de-registration.\n");
+
+	return 0;
+}
+
+early_param("keep_bootcon", keep_bootcon_setup);
+
+/*
+ * The console driver calls this routine during kernel initialization
+ * to register the console printing procedure with printk() and to
+ * print any messages that were printed by the kernel before the
+ * console driver was initialized.
+ *
+ * This can happen pretty early during the boot process (because of
+ * early_printk) - sometimes before setup_arch() completes - be careful
+ * of what kernel features are used - they may not be initialised yet.
+ *
+ * There are two types of consoles - bootconsoles (early_printk) and
+ * "real" consoles (everything which is not a bootconsole) which are
+ * handled differently.
+ *  - Any number of bootconsoles can be registered at any time.
+ *  - As soon as a "real" console is registered, all bootconsoles
+ *    will be unregistered automatically.
+ *  - Once a "real" console is registered, any attempt to register a
+ *    bootconsoles will be rejected
+ */
+void register_console(struct console *newcon)
+{
+	int i;
+	unsigned long flags;
+	struct console *bcon = NULL;
+
+	/*
+	 * before we register a new CON_BOOT console, make sure we don't
+	 * already have a valid console
+	 */
+	if (console_drivers && newcon->flags & CON_BOOT) {
+		/* find the last or real console */
+		for_each_console(bcon) {
+			if (!(bcon->flags & CON_BOOT)) {
+				printk(KERN_INFO "Too late to register bootconsole %s%d\n",
+					newcon->name, newcon->index);
+				return;
+			}
+		}
+	}
+
+	if (console_drivers && console_drivers->flags & CON_BOOT)
+		bcon = console_drivers;
+
+	if (preferred_console < 0 || bcon || !console_drivers)
+		preferred_console = selected_console;
+
+	if (newcon->early_setup)
+		newcon->early_setup();
+
+	/*
+	 *	See if we want to use this console driver. If we
+	 *	didn't select a console we take the first one
+	 *	that registers here.
+	 */
+	if (preferred_console < 0) {
+		if (newcon->index < 0)
+			newcon->index = 0;
+		if (newcon->setup == NULL ||
+		    newcon->setup(newcon, NULL) == 0) {
+			newcon->flags |= CON_ENABLED;
+			if (newcon->device) {
+				newcon->flags |= CON_CONSDEV;
+				preferred_console = 0;
+			}
+		}
+	}
+
+	/*
+	 *	See if this console matches one we selected on
+	 *	the command line.
+	 */
+	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];
+			i++) {
+		if (strcmp(console_cmdline[i].name, newcon->name) != 0)
+			continue;
+		if (newcon->index >= 0 &&
+		    newcon->index != console_cmdline[i].index)
+			continue;
+		if (newcon->index < 0)
+			newcon->index = console_cmdline[i].index;
+#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
+		if (console_cmdline[i].brl_options) {
+			newcon->flags |= CON_BRL;
+			braille_register_console(newcon,
+					console_cmdline[i].index,
+					console_cmdline[i].options,
+					console_cmdline[i].brl_options);
+			return;
+		}
+#endif
+		if (newcon->setup &&
+		    newcon->setup(newcon, console_cmdline[i].options) != 0)
+			break;
+		newcon->flags |= CON_ENABLED;
+		newcon->index = console_cmdline[i].index;
+		if (i == selected_console) {
+			newcon->flags |= CON_CONSDEV;
+			preferred_console = selected_console;
+		}
+		break;
+	}
+
+	if (!(newcon->flags & CON_ENABLED))
+		return;
+
+	/*
+	 * If we have a bootconsole, and are switching to a real console,
+	 * don't print everything out again, since when the boot console, and
+	 * the real console are the same physical device, it's annoying to
+	 * see the beginning boot messages twice
+	 */
+	if (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))
+		newcon->flags &= ~CON_PRINTBUFFER;
+
+	/*
+	 *	Put this console in the list - keep the
+	 *	preferred driver at the head of the list.
+	 */
+	console_lock();
+	if ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {
+		newcon->next = console_drivers;
+		console_drivers = newcon;
+		if (newcon->next)
+			newcon->next->flags &= ~CON_CONSDEV;
+	} else {
+		newcon->next = console_drivers->next;
+		console_drivers->next = newcon;
+	}
+	if (newcon->flags & CON_PRINTBUFFER) {
+		/*
+		 * console_unlock(); will print out the buffered messages
+		 * for us.
+		 */
+		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		console_seq = syslog_seq;
+		console_idx = syslog_idx;
+		console_prev = syslog_prev;
+		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		/*
+		 * We're about to replay the log buffer.  Only do this to the
+		 * just-registered console to avoid excessive message spam to
+		 * the already-registered consoles.
+		 */
+		exclusive_console = newcon;
+	}
+	console_unlock();
+	console_sysfs_notify();
+
+	/*
+	 * By unregistering the bootconsoles after we enable the real console
+	 * we get the "console xxx enabled" message on all the consoles -
+	 * boot consoles, real consoles, etc - this is to ensure that end
+	 * users know there might be something in the kernel's log buffer that
+	 * went to the bootconsole (that they do not see on the real console)
+	 */
+	if (bcon &&
+	    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&
+	    !keep_bootcon) {
+		/* we need to iterate through twice, to make sure we print
+		 * everything out, before we unregister the console(s)
+		 */
+		printk(KERN_INFO "console [%s%d] enabled, bootconsole disabled\n",
+			newcon->name, newcon->index);
+		for_each_console(bcon)
+			if (bcon->flags & CON_BOOT)
+				unregister_console(bcon);
+	} else {
+		printk(KERN_INFO "%sconsole [%s%d] enabled\n",
+			(newcon->flags & CON_BOOT) ? "boot" : "" ,
+			newcon->name, newcon->index);
+	}
+}
+EXPORT_SYMBOL(register_console);
+
+int unregister_console(struct console *console)
+{
+        struct console *a, *b;
+	int res = 1;
+
+#ifdef CONFIG_A11Y_BRAILLE_CONSOLE
+	if (console->flags & CON_BRL)
+		return braille_unregister_console(console);
+#endif
+
+	console_lock();
+	if (console_drivers == console) {
+		console_drivers=console->next;
+		res = 0;
+	} else if (console_drivers) {
+		for (a=console_drivers->next, b=console_drivers ;
+		     a; b=a, a=b->next) {
+			if (a == console) {
+				b->next = a->next;
+				res = 0;
+				break;
+			}
+		}
+	}
+
+	/*
+	 * If this isn't the last console and it has CON_CONSDEV set, we
+	 * need to set it on the next preferred console.
+	 */
+	if (console_drivers != NULL && console->flags & CON_CONSDEV)
+		console_drivers->flags |= CON_CONSDEV;
+
+	console_unlock();
+	console_sysfs_notify();
+	return res;
+}
+EXPORT_SYMBOL(unregister_console);
+
+static int __init printk_late_init(void)
+{
+	struct console *con;
+
+	for_each_console(con) {
+		if (!keep_bootcon && con->flags & CON_BOOT) {
+			printk(KERN_INFO "turn off boot console %s%d\n",
+				con->name, con->index);
+			unregister_console(con);
+		}
+	}
+	hotcpu_notifier(console_cpu_notify, 0);
+	return 0;
+}
+late_initcall(printk_late_init);
+
+#if defined CONFIG_PRINTK
+/*
+ * Delayed printk version, for scheduler-internal messages:
+ */
+#define PRINTK_BUF_SIZE		512
+
+#define PRINTK_PENDING_WAKEUP	0x01
+#define PRINTK_PENDING_SCHED	0x02
+
+static DEFINE_PER_CPU(int, printk_pending);
+static DEFINE_PER_CPU(char [PRINTK_BUF_SIZE], printk_sched_buf);
+
+static void wake_up_klogd_work_func(struct irq_work *irq_work)
+{
+	int pending = __this_cpu_xchg(printk_pending, 0);
+
+	if (pending & PRINTK_PENDING_SCHED) {
+		char *buf = __get_cpu_var(printk_sched_buf);
+		printk(KERN_WARNING "[sched_delayed] %s", buf);
+	}
+
+	if (pending & PRINTK_PENDING_WAKEUP)
+		wake_up_interruptible(&log_wait);
+}
+
+static DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) = {
+	.func = wake_up_klogd_work_func,
+	.flags = IRQ_WORK_LAZY,
+};
+
+void wake_up_klogd(void)
+{
+	preempt_disable();
+	if (waitqueue_active(&log_wait)) {
+		this_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);
+		irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+	}
+	preempt_enable();
+}
+
+int printk_sched(const char *fmt, ...)
+{
+	unsigned long flags;
+	va_list args;
+	char *buf;
+	int r;
+
+	local_irq_save(flags);
+	buf = __get_cpu_var(printk_sched_buf);
+
+	va_start(args, fmt);
+	r = vsnprintf(buf, PRINTK_BUF_SIZE, fmt, args);
+	va_end(args);
+
+	__this_cpu_or(printk_pending, PRINTK_PENDING_SCHED);
+	irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+	local_irq_restore(flags);
+
+	return r;
+}
+
+/*
+ * printk rate limiting, lifted from the networking subsystem.
+ *
+ * This enforces a rate limit: not more than 10 kernel messages
+ * every 5s to make a denial-of-service attack impossible.
+ */
+DEFINE_RATELIMIT_STATE(printk_ratelimit_state, 5 * HZ, 10);
+
+int __printk_ratelimit(const char *func)
+{
+	return ___ratelimit(&printk_ratelimit_state, func);
+}
+EXPORT_SYMBOL(__printk_ratelimit);
+
+/**
+ * printk_timed_ratelimit - caller-controlled printk ratelimiting
+ * @caller_jiffies: pointer to caller's state
+ * @interval_msecs: minimum interval between prints
+ *
+ * printk_timed_ratelimit() returns true if more than @interval_msecs
+ * milliseconds have elapsed since the last time printk_timed_ratelimit()
+ * returned true.
+ */
+bool printk_timed_ratelimit(unsigned long *caller_jiffies,
+			unsigned int interval_msecs)
+{
+	if (*caller_jiffies == 0
+			|| !time_in_range(jiffies, *caller_jiffies,
+					*caller_jiffies
+					+ msecs_to_jiffies(interval_msecs))) {
+		*caller_jiffies = jiffies;
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(printk_timed_ratelimit);
+
+static DEFINE_SPINLOCK(dump_list_lock);
+static LIST_HEAD(dump_list);
+
+/**
+ * kmsg_dump_register - register a kernel log dumper.
+ * @dumper: pointer to the kmsg_dumper structure
+ *
+ * Adds a kernel log dumper to the system. The dump callback in the
+ * structure will be called when the kernel oopses or panics and must be
+ * set. Returns zero on success and %-EINVAL or %-EBUSY otherwise.
+ */
+int kmsg_dump_register(struct kmsg_dumper *dumper)
+{
+	unsigned long flags;
+	int err = -EBUSY;
+
+	/* The dump callback needs to be set */
+	if (!dumper->dump)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dump_list_lock, flags);
+	/* Don't allow registering multiple times */
+	if (!dumper->registered) {
+		dumper->registered = 1;
+		list_add_tail_rcu(&dumper->list, &dump_list);
+		err = 0;
+	}
+	spin_unlock_irqrestore(&dump_list_lock, flags);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_register);
+
+/**
+ * kmsg_dump_unregister - unregister a kmsg dumper.
+ * @dumper: pointer to the kmsg_dumper structure
+ *
+ * Removes a dump device from the system. Returns zero on success and
+ * %-EINVAL otherwise.
+ */
+int kmsg_dump_unregister(struct kmsg_dumper *dumper)
+{
+	unsigned long flags;
+	int err = -EINVAL;
+
+	spin_lock_irqsave(&dump_list_lock, flags);
+	if (dumper->registered) {
+		dumper->registered = 0;
+		list_del_rcu(&dumper->list);
+		err = 0;
+	}
+	spin_unlock_irqrestore(&dump_list_lock, flags);
+	synchronize_rcu();
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_unregister);
+
+static bool always_kmsg_dump;
+module_param_named(always_kmsg_dump, always_kmsg_dump, bool, S_IRUGO | S_IWUSR);
+
+/**
+ * kmsg_dump - dump kernel log to kernel message dumpers.
+ * @reason: the reason (oops, panic etc) for dumping
+ *
+ * Call each of the registered dumper's dump() callback, which can
+ * retrieve the kmsg records with kmsg_dump_get_line() or
+ * kmsg_dump_get_buffer().
+ */
+void kmsg_dump(enum kmsg_dump_reason reason)
+{
+	struct kmsg_dumper *dumper;
+	unsigned long flags;
+
+	if ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)
+		return;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(dumper, &dump_list, list) {
+		if (dumper->max_reason && reason > dumper->max_reason)
+			continue;
+
+		/* initialize iterator with data about the stored records */
+		dumper->active = true;
+
+		raw_spin_lock_irqsave(&logbuf_lock, flags);
+		dumper->cur_seq = clear_seq;
+		dumper->cur_idx = clear_idx;
+		dumper->next_seq = log_next_seq;
+		dumper->next_idx = log_next_idx;
+		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+
+		/* invoke dumper which will iterate over records */
+		dumper->dump(dumper, reason);
+
+		/* reset iterator */
+		dumper->active = false;
+	}
+	rcu_read_unlock();
+}
+
+/**
+ * kmsg_dump_get_line_nolock - retrieve one kmsg log line (unlocked version)
+ * @dumper: registered kmsg dumper
+ * @syslog: include the "<4>" prefixes
+ * @line: buffer to copy the line to
+ * @size: maximum size of the buffer
+ * @len: length of line placed into buffer
+ *
+ * Start at the beginning of the kmsg buffer, with the oldest kmsg
+ * record, and copy one record into the provided buffer.
+ *
+ * Consecutive calls will return the next available record moving
+ * towards the end of the buffer with the youngest messages.
+ *
+ * A return value of FALSE indicates that there are no more records to
+ * read.
+ *
+ * The function is similar to kmsg_dump_get_line(), but grabs no locks.
+ */
+bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
+			       char *line, size_t size, size_t *len)
+{
+	struct log *msg;
+	size_t l = 0;
+	bool ret = false;
+
+	if (!dumper->active)
+		goto out;
+
+	if (dumper->cur_seq < log_first_seq) {
+		/* messages are gone, move to first available one */
+		dumper->cur_seq = log_first_seq;
+		dumper->cur_idx = log_first_idx;
+	}
+
+	/* last entry */
+	if (dumper->cur_seq >= log_next_seq)
+		goto out;
+
+	msg = log_from_idx(dumper->cur_idx);
+	l = msg_print_text(msg, 0, syslog, line, size);
+
+	dumper->cur_idx = log_next(dumper->cur_idx);
+	dumper->cur_seq++;
+	ret = true;
+out:
+	if (len)
+		*len = l;
+	return ret;
+}
+
+/**
+ * kmsg_dump_get_line - retrieve one kmsg log line
+ * @dumper: registered kmsg dumper
+ * @syslog: include the "<4>" prefixes
+ * @line: buffer to copy the line to
+ * @size: maximum size of the buffer
+ * @len: length of line placed into buffer
+ *
+ * Start at the beginning of the kmsg buffer, with the oldest kmsg
+ * record, and copy one record into the provided buffer.
+ *
+ * Consecutive calls will return the next available record moving
+ * towards the end of the buffer with the youngest messages.
+ *
+ * A return value of FALSE indicates that there are no more records to
+ * read.
+ */
+bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
+			char *line, size_t size, size_t *len)
+{
+	unsigned long flags;
+	bool ret;
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_get_line);
+
+/**
+ * kmsg_dump_get_buffer - copy kmsg log lines
+ * @dumper: registered kmsg dumper
+ * @syslog: include the "<4>" prefixes
+ * @buf: buffer to copy the line to
+ * @size: maximum size of the buffer
+ * @len: length of line placed into buffer
+ *
+ * Start at the end of the kmsg buffer and fill the provided buffer
+ * with as many of the the *youngest* kmsg records that fit into it.
+ * If the buffer is large enough, all available kmsg records will be
+ * copied with a single call.
+ *
+ * Consecutive calls will fill the buffer with the next block of
+ * available older records, not including the earlier retrieved ones.
+ *
+ * A return value of FALSE indicates that there are no more records to
+ * read.
+ */
+bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
+			  char *buf, size_t size, size_t *len)
+{
+	unsigned long flags;
+	u64 seq;
+	u32 idx;
+	u64 next_seq;
+	u32 next_idx;
+	enum log_flags prev;
+	size_t l = 0;
+	bool ret = false;
+
+	if (!dumper->active)
+		goto out;
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	if (dumper->cur_seq < log_first_seq) {
+		/* messages are gone, move to first available one */
+		dumper->cur_seq = log_first_seq;
+		dumper->cur_idx = log_first_idx;
+	}
+
+	/* last entry */
+	if (dumper->cur_seq >= dumper->next_seq) {
+		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		goto out;
+	}
+
+	/* calculate length of entire buffer */
+	seq = dumper->cur_seq;
+	idx = dumper->cur_idx;
+	prev = 0;
+	while (seq < dumper->next_seq) {
+		struct log *msg = log_from_idx(idx);
+
+		l += msg_print_text(msg, prev, true, NULL, 0);
+		idx = log_next(idx);
+		seq++;
+		prev = msg->flags;
+	}
+
+	/* move first record forward until length fits into the buffer */
+	seq = dumper->cur_seq;
+	idx = dumper->cur_idx;
+	prev = 0;
+	while (l > size && seq < dumper->next_seq) {
+		struct log *msg = log_from_idx(idx);
+
+		l -= msg_print_text(msg, prev, true, NULL, 0);
+		idx = log_next(idx);
+		seq++;
+		prev = msg->flags;
+	}
+
+	/* last message in next interation */
+	next_seq = seq;
+	next_idx = idx;
+
+	l = 0;
+	prev = 0;
+	while (seq < dumper->next_seq) {
+		struct log *msg = log_from_idx(idx);
+
+		l += msg_print_text(msg, prev, syslog, buf + l, size - l);
+		idx = log_next(idx);
+		seq++;
+		prev = msg->flags;
+	}
+
+	dumper->next_seq = next_seq;
+	dumper->next_idx = next_idx;
+	ret = true;
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+out:
+	if (len)
+		*len = l;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_get_buffer);
+
+/**
+ * kmsg_dump_rewind_nolock - reset the interator (unlocked version)
+ * @dumper: registered kmsg dumper
+ *
+ * Reset the dumper's iterator so that kmsg_dump_get_line() and
+ * kmsg_dump_get_buffer() can be called again and used multiple
+ * times within the same dumper.dump() callback.
+ *
+ * The function is similar to kmsg_dump_rewind(), but grabs no locks.
+ */
+void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
+{
+	dumper->cur_seq = clear_seq;
+	dumper->cur_idx = clear_idx;
+	dumper->next_seq = log_next_seq;
+	dumper->next_idx = log_next_idx;
+}
+
+/**
+ * kmsg_dump_rewind - reset the interator
+ * @dumper: registered kmsg dumper
+ *
+ * Reset the dumper's iterator so that kmsg_dump_get_line() and
+ * kmsg_dump_get_buffer() can be called again and used multiple
+ * times within the same dumper.dump() callback.
+ */
+void kmsg_dump_rewind(struct kmsg_dumper *dumper)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+	kmsg_dump_rewind_nolock(dumper);
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+}
+EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
+
+static char dump_stack_arch_desc_str[128];
+
+/**
+ * dump_stack_set_arch_desc - set arch-specific str to show with task dumps
+ * @fmt: printf-style format string
+ * @...: arguments for the format string
+ *
+ * The configured string will be printed right after utsname during task
+ * dumps.  Usually used to add arch-specific system identifiers.  If an
+ * arch wants to make use of such an ID string, it should initialize this
+ * as soon as possible during boot.
+ */
+void __init dump_stack_set_arch_desc(const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	vsnprintf(dump_stack_arch_desc_str, sizeof(dump_stack_arch_desc_str),
+		  fmt, args);
+	va_end(args);
+}
+
+/**
+ * dump_stack_print_info - print generic debug info for dump_stack()
+ * @log_lvl: log level
+ *
+ * Arch-specific dump_stack() implementations can use this function to
+ * print out the same debug information as the generic dump_stack().
+ */
+void dump_stack_print_info(const char *log_lvl)
+{
+	printk("%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n",
+	       log_lvl, raw_smp_processor_id(), current->pid, current->comm,
+	       print_tainted(), init_utsname()->release,
+	       (int)strcspn(init_utsname()->version, " "),
+	       init_utsname()->version);
+
+	if (dump_stack_arch_desc_str[0] != '\0')
+		printk("%sHardware name: %s\n",
+		       log_lvl, dump_stack_arch_desc_str);
+
+	print_worker_info(log_lvl, current);
+}
+
+/**
+ * show_regs_print_info - print generic debug info for show_regs()
+ * @log_lvl: log level
+ *
+ * show_regs() implementations can use this function to print out generic
+ * debug information.
+ */
+void show_regs_print_info(const char *log_lvl)
+{
+	dump_stack_print_info(log_lvl);
+
+	printk("%stask: %p ti: %p task.ti: %p\n",
+	       log_lvl, current, current_thread_info(),
+	       task_thread_info(current));
+}
+
+#endif
