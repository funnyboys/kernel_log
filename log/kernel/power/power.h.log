commit ab7e9b067f3d9cbec28cfca51d341efb421b7a51
Author: Domenico Andreoli <domenico.andreoli@linux.com>
Date:   Thu May 7 09:19:52 2020 +0200

    PM: hibernate: Incorporate concurrency handling
    
    Hibernation concurrency handling is currently delegated to user.c,
    where it's also used for regulating the access to the snapshot device.
    
    In the prospective of making user.c a separate configuration option,
    such mutual exclusion is brought into hibernate.c and made available
    through accessor helpers hereby introduced.
    
    Signed-off-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7cdc64dc2373..ba2094db6294 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -154,8 +154,8 @@ extern int snapshot_write_next(struct snapshot_handle *handle);
 extern void snapshot_write_finalize(struct snapshot_handle *handle);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
 
-/* If unset, the snapshot device cannot be open. */
-extern atomic_t snapshot_device_available;
+extern bool hibernate_acquire(void);
+extern void hibernate_release(void);
 
 extern sector_t alloc_swapdev_block(int swap);
 extern void free_all_swap_pages(int swap);

commit 75d319c06e6a76f67549c0ae1007dc3167804f4e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Oct 25 22:56:17 2019 +0200

    y2038: syscalls: change remaining timeval to __kernel_old_timeval
    
    All of the remaining syscalls that pass a timeval (gettimeofday, utime,
    futimesat) can trivially be changed to pass a __kernel_old_timeval
    instead, which has a compatible layout, but avoids ambiguity with
    the timeval type in user space.
    
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 44bee462ff57..7cdc64dc2373 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -179,7 +179,7 @@ extern void swsusp_close(fmode_t);
 extern int swsusp_unmark(void);
 #endif
 
-struct timeval;
+struct __kernel_old_timeval;
 /* kernel/power/swsusp.c */
 extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);
 

commit 1ec0cd8286f35988134e05367ab5e66213b84e7c
Author: Mathieu Malaterre <malat@debian.org>
Date:   Fri May 24 12:44:18 2019 +0200

    PM: hibernate: powerpc: Expose pfn_is_nosave() prototype
    
    The declaration for pfn_is_nosave is only available in
    kernel/power/power.h. Since this function can be override in arch,
    expose it globally. Having a prototype will make sure to avoid warning
    (sometime treated as error with W=1) such as:
    
      arch/powerpc/kernel/suspend.c:18:5: error: no previous prototype for 'pfn_is_nosave' [-Werror=missing-prototypes]
    
    This moves the declaration into a globally visible header file and add
    missing include to avoid a warning on powerpc.
    
    Also remove the duplicated prototypes since not required anymore.
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9e58bdc8a562..44bee462ff57 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -75,8 +75,6 @@ static inline void hibernate_reserved_size_init(void) {}
 static inline void hibernate_image_size_init(void) {}
 #endif /* !CONFIG_HIBERNATION */
 
-extern int pfn_is_nosave(unsigned long);
-
 #define power_attr(_name) \
 static struct kobj_attribute _name##_attr = {	\
 	.attr	= {				\

commit 328008a72d38b5bde6491e463405c34a81a65d3e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 2 15:56:18 2018 +0100

    x86/power: Fix swsusp_arch_resume prototype
    
    The declaration for swsusp_arch_resume marks it as 'asmlinkage', but the
    definition in x86-32 does not, and it fails to include the header with the
    declaration. This leads to a warning when building with
    link-time-optimizations:
    
    kernel/power/power.h:108:23: error: type of 'swsusp_arch_resume' does not match original declaration [-Werror=lto-type-mismatch]
     extern asmlinkage int swsusp_arch_resume(void);
                           ^
    arch/x86/power/hibernate_32.c:148:0: note: 'swsusp_arch_resume' was previously declared here
     int swsusp_arch_resume(void)
    
    This moves the declaration into a globally visible header file and fixes up
    both x86 definitions to match it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    Link: https://lkml.kernel.org/r/20180202145634.200291-2-arnd@arndb.de

diff --git a/kernel/power/power.h b/kernel/power/power.h
index f29cd178df90..9e58bdc8a562 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -104,9 +104,6 @@ extern int in_suspend;
 extern dev_t swsusp_resume_device;
 extern sector_t swsusp_resume_block;
 
-extern asmlinkage int swsusp_arch_suspend(void);
-extern asmlinkage int swsusp_arch_resume(void);
-
 extern int create_basic_memory_bitmaps(void);
 extern void free_basic_memory_bitmaps(void);
 extern int hibernate_preallocate_memory(void);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1d2d761e3c25..f29cd178df90 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/suspend.h>
 #include <linux/suspend_ioctls.h>
 #include <linux/utsname.h>

commit e870c6c87cf9484090d28f2a68aa29e008960c93
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 31 23:43:18 2017 +0200

    ACPI / PM: Prefer suspend-to-idle over S3 on some systems
    
    Modify the ACPI system sleep support setup code to select
    suspend-to-idle as the default system sleep state if
    (1) the ACPI_FADT_LOW_POWER_S0 flag is set in the FADT and
    (2) the Low Power Idle S0 _DSM interface has been discovered and
    (3) the default sleep state was not selected from the kernel command
    line.
    
    The main motivation for this change is that systems where the (1) and
    (2) conditions are met typically ship with OSes that don't exercise
    the S3 path in the platform firmware which remains untested and turns
    out to be non-functional at least in some cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 268c1b0afc28..1d2d761e3c25 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -192,7 +192,6 @@ extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);
 extern const char * const pm_labels[];
 extern const char *pm_states[];
 extern const char *mem_sleep_states[];
-extern suspend_state_t mem_sleep_current;
 
 extern int suspend_devices_and_enter(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */

commit e516a1db43cea397cf63d395534236d9869f0310
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 14:44:02 2017 +0200

    PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
    
    The pm_test sysfs attribute is under CONFIG_PM_DEBUG, but it doesn't
    make sense to provide it if CONFIG_PM_SLEEP is unset, so put it under
    CONFIG_PM_SLEEP_DEBUG instead.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 6e3ac6a73d65..268c1b0afc28 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -245,7 +245,7 @@ enum {
 #define TEST_FIRST	TEST_NONE
 #define TEST_MAX	(__TEST_AFTER_LAST - 1)
 
-#ifdef CONFIG_PM_DEBUG
+#ifdef CONFIG_PM_SLEEP_DEBUG
 extern int pm_test_level;
 #else
 #define pm_test_level	(TEST_NONE)

commit 8e6bcd9f7eac47104ce6c5d82c554c9b244b38e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 02:07:54 2017 +0200

    PM / s2idle: Rearrange the main suspend-to-idle loop
    
    As a preparation for subsequent changes, rearrange the core
    suspend-to-idle code by moving the initial invocation of
    dpm_suspend_noirq() into s2idle_loop().
    
    This also causes debug messages from that code to appear in
    a less confusing order.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7fdc40d31b7d..6e3ac6a73d65 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -245,7 +245,11 @@ enum {
 #define TEST_FIRST	TEST_NONE
 #define TEST_MAX	(__TEST_AFTER_LAST - 1)
 
+#ifdef CONFIG_PM_DEBUG
 extern int pm_test_level;
+#else
+#define pm_test_level	(TEST_NONE)
+#endif
 
 #ifdef CONFIG_SUSPEND_FREEZER
 static inline int suspend_freeze_processes(void)

commit 0f5bf6d0afe4be6e1391908ff2d6dc9730e91550
Author: Laura Abbott <labbott@redhat.com>
Date:   Mon Feb 6 16:31:58 2017 -0800

    arch: Rename CONFIG_DEBUG_RODATA and CONFIG_DEBUG_MODULE_RONX
    
    Both of these options are poorly named. The features they provide are
    necessary for system security and should not be considered debug only.
    Change the names to CONFIG_STRICT_KERNEL_RWX and
    CONFIG_STRICT_MODULE_RWX to better describe what these options do.
    
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Acked-by: Jessica Yu <jeyu@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1dfa0da827d3..7fdc40d31b7d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -61,12 +61,12 @@ extern int hibernation_snapshot(int platform_mode);
 extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);
 
-#ifdef CONFIG_DEBUG_RODATA
+#ifdef CONFIG_STRICT_KERNEL_RWX
 /* kernel/power/snapshot.c */
 extern void enable_restore_image_protection(void);
 #else
 static inline void enable_restore_image_protection(void) {}
-#endif /* CONFIG_DEBUG_RODATA */
+#endif /* CONFIG_STRICT_KERNEL_RWX */
 
 #else /* !CONFIG_HIBERNATION */
 

commit 406e79385f3223d82272cf2be86bc95cd000a258
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 21 22:45:40 2016 +0100

    PM / sleep: System sleep state selection interface rework
    
    There are systems in which the platform doesn't support any special
    sleep states, so suspend-to-idle (PM_SUSPEND_FREEZE) is the only
    available system sleep state.  However, some user space frameworks
    only use the "mem" and (sometimes) "standby" sleep state labels, so
    the users of those systems need to modify user space in order to be
    able to use system suspend at all and that may be a pain in practice.
    
    Commit 0399d4db3edf (PM / sleep: Introduce command line argument for
    sleep state enumeration) attempted to address this problem by adding
    a command line argument to change the meaning of the "mem" string in
    /sys/power/state to make it trigger suspend-to-idle (instead of
    suspend-to-RAM).
    
    However, there also are systems in which the platform does support
    special sleep states, but suspend-to-idle is the preferred one anyway
    (it even may save more energy than the platform-provided sleep states
    in some cases) and the above commit doesn't help in those cases.
    
    For this reason, rework the system sleep state selection interface
    again (but preserve backwards compatibiliby).  Namely, add a new
    sysfs file, /sys/power/mem_sleep, that will control the system
    suspend mode triggered by writing "mem" to /sys/power/state (in
    analogy with what /sys/power/disk does for hibernation).  Make it
    select suspend-to-RAM ("deep" sleep) by default (if supported) and
    fall back to suspend-to-idle ("s2idle") otherwise and add a new
    command line argument, mem_sleep_default, allowing that default to
    be overridden if need be.
    
    At the same time, drop the relative_sleep_states command line
    argument that doesn't make sense any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 56d1d0dedf76..1dfa0da827d3 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -189,11 +189,15 @@ extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);
 
 #ifdef CONFIG_SUSPEND
 /* kernel/power/suspend.c */
-extern const char *pm_labels[];
+extern const char * const pm_labels[];
 extern const char *pm_states[];
+extern const char *mem_sleep_states[];
+extern suspend_state_t mem_sleep_current;
 
 extern int suspend_devices_and_enter(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
+#define mem_sleep_current	PM_SUSPEND_ON
+
 static inline int suspend_devices_and_enter(suspend_state_t state)
 {
 	return -ENOSYS;

commit 1ad1410f632d4141221634308a5e56f339f92009
Author: Anisse Astier <anisse@astier.eu>
Date:   Fri Sep 9 10:43:32 2016 +0200

    PM / Hibernate: allow hibernation with PAGE_POISONING_ZERO
    
    PAGE_POISONING_ZERO disables zeroing new pages on alloc, they are
    poisoned (zeroed) as they become available.
    In the hibernate use case, free pages will appear in the system without
    being cleared, left there by the loading kernel.
    
    This patch will make sure free pages are cleared on resume when
    PAGE_POISONING_ZERO is enabled. We free the pages just after resume
    because we can't do it later: going through any device resume code might
    allocate some memory and invalidate the free pages bitmap.
    
    Thus we don't need to disable hibernation when PAGE_POISONING_ZERO is
    enabled.
    
    Signed-off-by: Anisse Astier <anisse@astier.eu>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 242d8b827dd5..56d1d0dedf76 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -110,6 +110,8 @@ extern int create_basic_memory_bitmaps(void);
 extern void free_basic_memory_bitmaps(void);
 extern int hibernate_preallocate_memory(void);
 
+extern void clear_free_pages(void);
+
 /**
  *	Auxiliary structure used for reading the snapshot image data and
  *	metadata from and writing them to the list of page backup entries

commit 406f992e4a372dafbe3c2cff7efbb2002a5c8ebd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 14 03:55:23 2016 +0200

    x86 / hibernate: Use hlt_play_dead() when resuming from hibernation
    
    On Intel hardware, native_play_dead() uses mwait_play_dead() by
    default and only falls back to the other methods if that fails.
    That also happens during resume from hibernation, when the restore
    (boot) kernel runs disable_nonboot_cpus() to take all of the CPUs
    except for the boot one offline.
    
    However, that is problematic, because the address passed to
    __monitor() in mwait_play_dead() is likely to be written to in the
    last phase of hibernate image restoration and that causes the "dead"
    CPU to start executing instructions again.  Unfortunately, the page
    containing the address in that CPU's instruction pointer may not be
    valid any more at that point.
    
    First, that page may have been overwritten with image kernel memory
    contents already, so the instructions the CPU attempts to execute may
    simply be invalid.  Second, the page tables previously used by that
    CPU may have been overwritten by image kernel memory contents, so the
    address in its instruction pointer is impossible to resolve then.
    
    A report from Varun Koyyalagunta and investigation carried out by
    Chen Yu show that the latter sometimes happens in practice.
    
    To prevent it from happening, temporarily change the smp_ops.play_dead
    pointer during resume from hibernation so that it points to a special
    "play dead" routine which uses hlt_play_dead() and avoids the
    inadvertent "revivals" of "dead" CPUs this way.
    
    A slightly unpleasant consequence of this change is that if the
    system is hibernated with one or more CPUs offline, it will generally
    draw more power after resume than it did before hibernation, because
    the physical state entered by CPUs via hlt_play_dead() is higher-power
    than the mwait_play_dead() one in the majority of cases.  It is
    possible to work around this, but it is unclear how much of a problem
    that's going to be in practice, so the workaround will be implemented
    later if it turns out to be necessary.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=106371
    Reported-by: Varun Koyyalagunta <cpudebug@centtech.com>
    Original-by: Chen Yu <yu.c.chen@intel.com>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 064963e89194..242d8b827dd5 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -38,6 +38,8 @@ static inline char *check_image_kernel(struct swsusp_info *info)
 }
 #endif /* CONFIG_ARCH_HIBERNATION_HEADER */
 
+extern int hibernate_resume_nonboot_cpu_disable(void);
+
 /*
  * Keep some memory free so that I/O operations can succeed without paging
  * [Might this be more than 4 MB?]

commit 4c0b6c10fbaf0c82efe2a7ba6c236c633d4f2ed7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 10 02:12:10 2016 +0200

    PM / hibernate: Image data protection during restoration
    
    Make it possible to protect all pages holding image data during
    hibernate image restoration by setting them read-only (so as to
    catch attempts to write to those pages after image data have been
    stored in them).
    
    This adds overhead to image restoration code (it may cause large
    page mappings to be split as a result of page flags changes) and
    the errors it protects against should never happen in theory, so
    the feature is only active after passing hibernate=protect_image
    to the command line of the restore kernel.
    
    Also it only is built if CONFIG_DEBUG_RODATA is set.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 51f02ecaf125..064963e89194 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -59,6 +59,13 @@ extern int hibernation_snapshot(int platform_mode);
 extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);
 
+#ifdef CONFIG_DEBUG_RODATA
+/* kernel/power/snapshot.c */
+extern void enable_restore_image_protection(void);
+#else
+static inline void enable_restore_image_protection(void) {}
+#endif /* CONFIG_DEBUG_RODATA */
+
 #else /* !CONFIG_HIBERNATION */
 
 static inline void hibernate_reserved_size_init(void) {}

commit ea00f4f4f00cc2bc3b63ad512a4e6df3b20832b9
Author: Lianwei Wang <lianwei.wang@gmail.com>
Date:   Sun Jun 19 23:52:27 2016 -0700

    PM / sleep: make PM notifiers called symmetrically
    
    This makes pm notifier PREPARE/POST symmetrical: if PREPARE
    fails, we will only undo what ever happened on PREPARE.
    
    It fixes the unbalanced CPU hotplug enable in CPU PM notifier.
    
    Signed-off-by: Lianwei Wang <lianwei.wang@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index efe1b3b17c88..51f02ecaf125 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -200,6 +200,8 @@ static inline void suspend_test_finish(const char *label) {}
 
 #ifdef CONFIG_PM_SLEEP
 /* kernel/power/main.c */
+extern int __pm_notifier_call_chain(unsigned long val, int nr_to_call,
+				    int *nr_calls);
 extern int pm_notifier_call_chain(unsigned long val);
 #endif
 

commit a1e9ca6967d68209c70e616a224efa89a6b86ca6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 2 03:09:16 2016 +0100

    PM / sleep: Add support for read-only sysfs attributes
    
    Some sysfs attributes in /sys/power/ should really be read-only,
    so add support for that, convert those attributes to read-only
    and drop the stub .show() routines from them.
    
    Original-by: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index caadb566e82b..efe1b3b17c88 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -77,6 +77,15 @@ static struct kobj_attribute _name##_attr = {	\
 	.store	= _name##_store,		\
 }
 
+#define power_attr_ro(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = S_IRUGO,		\
+	},					\
+	.show	= _name##_show,			\
+}
+
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
 /* Size of memory reserved for drivers (default SPARE_PAGES x PAGE_SIZE) */

commit 343df3c79c62b644ce6ff5dff96c9e0be1ecb242
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 19 09:23:23 2015 +0200

    suspend: simplify block I/O handling
    
    Stop abusing struct page functionality and the swap end_io handler, and
    instead add a modified version of the blk-lib.c bio_batch helpers.
    
    Also move the block I/O code into swap.c as they are directly tied into
    each other.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Ming Lin <mlin@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index ce9b8328a689..caadb566e82b 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -163,15 +163,6 @@ extern void swsusp_close(fmode_t);
 extern int swsusp_unmark(void);
 #endif
 
-/* kernel/power/block_io.c */
-extern struct block_device *hib_resume_bdev;
-
-extern int hib_bio_read_page(pgoff_t page_off, void *addr,
-		struct bio **bio_chain);
-extern int hib_bio_write_page(pgoff_t page_off, void *addr,
-		struct bio **bio_chain);
-extern int hib_wait_on_bio_chain(struct bio **bio_chain);
-
 struct timeval;
 /* kernel/power/swsusp.c */
 extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);

commit db597605821fccc49876705aea5db5443d67e53e
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Thu Oct 30 11:04:53 2014 -0700

    PM / Hibernate: Migrate to ktime_t
    
    This patch migrates swsusp_show_speed and its callers to using ktime_t instead
    of 'struct timeval' which suffers from the y2038 problem.
    
    Changes to swsusp_show_speed:
            - use ktime_t for start and stop times
            - pass start and stop times by value
    Calling functions affected:
            - load_image
            - load_image_lzo
            - save_image
            - save_image_lzo
            - hibernate_preallocate_memory
    Design decisions:
            - use ktime_t to preserve same granularity of reporting as before
            - use centisecs logic as before to avoid 'div by zero' issues caused by
              using seconds and nanoseconds directly
            - use monotonic time (ktime_get()) since we only care about elapsed time.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 2df883a9d3cb..ce9b8328a689 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -174,8 +174,7 @@ extern int hib_wait_on_bio_chain(struct bio **bio_chain);
 
 struct timeval;
 /* kernel/power/swsusp.c */
-extern void swsusp_show_speed(struct timeval *, struct timeval *,
-				unsigned int, char *);
+extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);
 
 #ifdef CONFIG_SUSPEND
 /* kernel/power/suspend.c */

commit 62109b43176b87e78b2b6d91bcfe16128c30229b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Sep 3 01:21:03 2014 +0200

    PM / sleep: Fix test_suspend= command line option
    
    After commit d431cbc53cb7 (PM / sleep: Simplify sleep states sysfs
    interface code) the pm_states[] array is not populated initially,
    which causes setup_test_suspend() to always fail and the suspend
    testing during boot doesn't work any more.
    
    Fix the problem by using pm_labels[] instead of pm_states[] in
    setup_test_suspend() and storing a pointer to the label of the
    sleep state to test rather than the number representing it,
    because the connection between the state numbers and labels is
    only established by suspend_set_ops().
    
    Fixes: d431cbc53cb7 (PM / sleep: Simplify sleep states sysfs interface code)
    Reported-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 5d49dcac2537..2df883a9d3cb 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -179,6 +179,7 @@ extern void swsusp_show_speed(struct timeval *, struct timeval *,
 
 #ifdef CONFIG_SUSPEND
 /* kernel/power/suspend.c */
+extern const char *pm_labels[];
 extern const char *pm_states[];
 
 extern int suspend_devices_and_enter(suspend_state_t state);

commit d431cbc53cb787a7f82d7d2fe0af65156db4d27a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 15 22:02:11 2014 +0200

    PM / sleep: Simplify sleep states sysfs interface code
    
    Simplify the sleep states sysfs interface /sys/power/state code by
    redefining pm_states[] as an array of pointers to constant strings
    such that only the entries corresponding to valid states are set.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index c60f13b5270a..5d49dcac2537 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -178,13 +178,8 @@ extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
 
 #ifdef CONFIG_SUSPEND
-struct pm_sleep_state {
-	const char *label;
-	suspend_state_t state;
-};
-
 /* kernel/power/suspend.c */
-extern struct pm_sleep_state pm_states[];
+extern const char *pm_states[];
 
 extern int suspend_devices_and_enter(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */

commit 43e8317b0bba1d6eb85f38a4a233d82d7c20d732
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 26 13:40:53 2014 +0200

    PM / sleep: Use valid_state() for platform-dependent sleep states only
    
    Use the observation that, for platform-dependent sleep states
    (PM_SUSPEND_STANDBY, PM_SUSPEND_MEM), a given state is either
    always supported or always unsupported and store that information
    in pm_states[] instead of calling valid_state() every time we
    need to check it.
    
    Also do not use valid_state() for PM_SUSPEND_FREEZE, which is always
    valid, and move the pm_test_level validity check for PM_SUSPEND_FREEZE
    directly into enter_state().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 99539c5da844..c60f13b5270a 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -186,14 +186,12 @@ struct pm_sleep_state {
 /* kernel/power/suspend.c */
 extern struct pm_sleep_state pm_states[];
 
-extern bool valid_state(suspend_state_t state);
 extern int suspend_devices_and_enter(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 static inline int suspend_devices_and_enter(suspend_state_t state)
 {
 	return -ENOSYS;
 }
-static inline bool valid_state(suspend_state_t state) { return false; }
 #endif /* !CONFIG_SUSPEND */
 
 #ifdef CONFIG_PM_TEST_SUSPEND

commit 27ddcc6596e50cb8f03d2e83248897667811d8f6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 26 13:40:47 2014 +0200

    PM / sleep: Add state field to pm_states[] entries
    
    To allow sleep states corresponding to the "mem", "standby" and
    "freeze" lables to be different from the pm_states[] indexes of
    those strings, introduce struct pm_sleep_state, consisting of
    a string label and a state number, and turn pm_states[] into an
    array of objects of that type.
    
    This modification should not lead to any functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 15f37ea08719..99539c5da844 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -178,8 +178,13 @@ extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
 
 #ifdef CONFIG_SUSPEND
+struct pm_sleep_state {
+	const char *label;
+	suspend_state_t state;
+};
+
 /* kernel/power/suspend.c */
-extern const char *const pm_states[];
+extern struct pm_sleep_state pm_states[];
 
 extern bool valid_state(suspend_state_t state);
 extern int suspend_devices_and_enter(suspend_state_t state);

commit 52f5684c8e1ec7463192aba8e2916df49807511a
Author: Gideon Israel Dsouza <gidisrael@gmail.com>
Date:   Mon Apr 7 15:39:20 2014 -0700

    kernel: use macros from compiler.h instead of __attribute__((...))
    
    To increase compiler portability there is <linux/compiler.h> which
    provides convenience macros for various gcc constructs.  Eg: __weak for
    __attribute__((weak)).  I've replaced all instances of gcc attributes
    with the right macro in the kernel subsystem.
    
    Signed-off-by: Gideon Israel Dsouza <gidisrael@gmail.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1ca753106557..15f37ea08719 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -2,6 +2,7 @@
 #include <linux/suspend_ioctls.h>
 #include <linux/utsname.h>
 #include <linux/freezer.h>
+#include <linux/compiler.h>
 
 struct swsusp_info {
 	struct new_utsname	uts;
@@ -11,7 +12,7 @@ struct swsusp_info {
 	unsigned long		image_pages;
 	unsigned long		pages;
 	unsigned long		size;
-} __attribute__((aligned(PAGE_SIZE)));
+} __aligned(PAGE_SIZE);
 
 #ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */

commit 04b73469750050290cb0a773e7ecf2358d65f6d5
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Feb 27 17:13:53 2014 +0530

    PM / sleep: Move prototype declaration to header file kernel/power/power.h
    
    Move prototype declaration of function to header file
    kernel/power/power.h because it is used by more than one file.
    
    This eliminates the following warning in kernel/power/snapshot.c:
    
    kernel/power/snapshot.c:1588:16: warning: no previous prototype for ‘swsusp_save’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7d4b7ffb3c1d..1ca753106557 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -49,6 +49,8 @@ static inline char *check_image_kernel(struct swsusp_info *info)
  */
 #define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
+asmlinkage int swsusp_save(void);
+
 /* kernel/power/hibernate.c */
 extern bool freezer_test_done;
 

commit 62c552ccc3eda1198632a4f344aa32623d226bab
Author: Bojan Smojver <bojan@rexursive.com>
Date:   Sat Jun 16 00:09:58 2012 +0200

    PM / Hibernate: Enable suspend to both for in-kernel hibernation.
    
    It is often useful to suspend to memory after hibernation image has been
    written to disk. If the battery runs out or power is otherwise lost, the
    computer will resume from the hibernated image. If not, it will resume
    from memory and hibernation image will be discarded.
    
    Signed-off-by: Bojan Smojver <bojan@rexursive.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index b0bd4beaebfe..7d4b7ffb3c1d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -156,6 +156,9 @@ extern void swsusp_free(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
 extern void swsusp_close(fmode_t);
+#ifdef CONFIG_SUSPEND
+extern int swsusp_unmark(void);
+#endif
 
 /* kernel/power/block_io.c */
 extern struct block_device *hib_resume_bdev;

commit b86ff9820fd5df69295273b9aa68e58786ffc23f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:42 2012 +0200

    PM / Sleep: Add user space interface for manipulating wakeup sources, v3
    
    Android allows user space to manipulate wakelocks using two
    sysfs file located in /sys/power/, wake_lock and wake_unlock.
    Writing a wakelock name and optionally a timeout to the wake_lock
    file causes the wakelock whose name was written to be acquired (it
    is created before is necessary), optionally with the given timeout.
    Writing the name of a wakelock to wake_unlock causes that wakelock
    to be released.
    
    Implement an analogous interface for user space using wakeup sources.
    Add the /sys/power/wake_lock and /sys/power/wake_unlock files
    allowing user space to create, activate and deactivate wakeup
    sources, such that writing a name and optionally a timeout to
    wake_lock causes the wakeup source of that name to be activated,
    optionally with the given timeout.  If that wakeup source doesn't
    exist, it will be created and then activated.  Writing a name to
    wake_unlock causes the wakeup source of that name, if there is one,
    to be deactivated.  Wakeup sources created with the help of
    wake_lock that haven't been used for more than 5 minutes are garbage
    collected and destroyed.  Moreover, there can be only WL_NUMBER_LIMIT
    wakeup sources created with the help of wake_lock present at a time.
    
    The data type used to track wakeup sources created by user space is
    called "struct wakelock" to indicate the origins of this feature.
    
    This version of the patch includes an rbtree manipulation fix from John Stultz.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 4cf80fa115d9..b0bd4beaebfe 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -282,3 +282,12 @@ static inline void pm_autosleep_unlock(void) {}
 static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
 
 #endif /* !CONFIG_PM_AUTOSLEEP */
+
+#ifdef CONFIG_PM_WAKELOCKS
+
+/* kernel/power/wakelock.c */
+extern ssize_t pm_show_wakelocks(char *buf, bool show_active);
+extern int pm_wake_lock(const char *buf);
+extern int pm_wake_unlock(const char *buf);
+
+#endif /* !CONFIG_PM_WAKELOCKS */

commit 7483b4a4d9abf9dcf1ffe6e805ead2847ec3264e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:22 2012 +0200

    PM / Sleep: Implement opportunistic sleep, v2
    
    Introduce a mechanism by which the kernel can trigger global
    transitions to a sleep state chosen by user space if there are no
    active wakeup sources.
    
    It consists of a new sysfs attribute, /sys/power/autosleep, that
    can be written one of the strings returned by reads from
    /sys/power/state, an ordered workqueue and a work item carrying out
    the "suspend" operations.  If a string representing the system's
    sleep state is written to /sys/power/autosleep, the work item
    triggering transitions to that state is queued up and it requeues
    itself after every execution until user space writes "off" to
    /sys/power/autosleep.
    
    That work item enables the detection of wakeup events using the
    functions already defined in drivers/base/power/wakeup.c (with one
    small modification) and calls either pm_suspend(), or hibernate() to
    put the system into a sleep state.  If a wakeup event is reported
    while the transition is in progress, it will abort the transition and
    the "system suspend" work item will be queued up again.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 98f3622d7407..4cf80fa115d9 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -264,3 +264,21 @@ static inline void suspend_thaw_processes(void)
 {
 }
 #endif
+
+#ifdef CONFIG_PM_AUTOSLEEP
+
+/* kernel/power/autosleep.c */
+extern int pm_autosleep_init(void);
+extern int pm_autosleep_lock(void);
+extern void pm_autosleep_unlock(void);
+extern suspend_state_t pm_autosleep_state(void);
+extern int pm_autosleep_set_state(suspend_state_t state);
+
+#else /* !CONFIG_PM_AUTOSLEEP */
+
+static inline int pm_autosleep_init(void) { return 0; }
+static inline int pm_autosleep_lock(void) { return 0; }
+static inline void pm_autosleep_unlock(void) {}
+static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
+
+#endif /* !CONFIG_PM_AUTOSLEEP */

commit 93e1ee43a72b11e1b50aab87046c131a836a4456
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:24 2012 +0100

    PM / Sleep: Make enter_state() in kernel/power/suspend.c static
    
    The enter_state() function in kernel/power/suspend.c should be
    static and state_store() in kernel/power/suspend.c should call
    pm_suspend() instead of it, so make that happen (which also reduces
    code duplication related to suspend statistics).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 398d42b48e9e..98f3622d7407 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -177,13 +177,11 @@ extern const char *const pm_states[];
 
 extern bool valid_state(suspend_state_t state);
 extern int suspend_devices_and_enter(suspend_state_t state);
-extern int enter_state(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 static inline int suspend_devices_and_enter(suspend_state_t state)
 {
 	return -ENOSYS;
 }
-static inline int enter_state(suspend_state_t state) { return -ENOSYS; }
 static inline bool valid_state(suspend_state_t state) { return false; }
 #endif /* !CONFIG_SUSPEND */
 

commit 6f585f750d792652f33b6e85b1ee205be4b5e572
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 11 22:40:23 2012 +0100

    PM / Sleep: Remove unnecessary label from suspend_freeze_processes()
    
    The Finish label in suspend_freeze_processes() is in fact unnecessary
    and makes the function look more complicated than it really is, so
    remove that label (along with a few empty lines).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 21724eee5206..398d42b48e9e 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -234,16 +234,14 @@ static inline int suspend_freeze_processes(void)
 	int error;
 
 	error = freeze_processes();
-
 	/*
 	 * freeze_processes() automatically thaws every task if freezing
 	 * fails. So we need not do anything extra upon error.
 	 */
 	if (error)
-		goto Finish;
+		return error;
 
 	error = freeze_kernel_threads();
-
 	/*
 	 * freeze_kernel_threads() thaws only kernel threads upon freezing
 	 * failure. So we have to thaw the userspace tasks ourselves.
@@ -251,7 +249,6 @@ static inline int suspend_freeze_processes(void)
 	if (error)
 		thaw_processes();
 
- Finish:
 	return error;
 }
 

commit 379e0be812ab8a2a351e784b0c987788f5123090
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Fri Feb 3 22:22:41 2012 +0100

    PM / Freezer: Thaw only kernel threads if freezing of kernel threads fails
    
    If freezing of kernel threads fails, we are expected to automatically
    thaw tasks in the error recovery path. However, at times, we encounter
    situations in which we would like the automatic error recovery path
    to thaw only the kernel threads, because we want to be able to do
    some more cleanup before we thaw userspace. Something like:
    
    error = freeze_kernel_threads();
    if (error) {
            /* Do some cleanup */
    
            /* Only then thaw userspace tasks*/
            thaw_processes();
    }
    
    An example of such a situation is where we freeze/thaw filesystems
    during suspend/hibernation. There, if freezing of kernel threads
    fails, we would like to thaw the frozen filesystems before thawing
    the userspace tasks.
    
    So, modify freeze_kernel_threads() to thaw only kernel threads in
    case of freezing failure. And change suspend_freeze_processes()
    accordingly. (At the same time, let us also get rid of the rather
    cryptic usage of the conditional operator (:?) in that function.)
    
    [rjw: In fact, this patch fixes a regression introduced during the
     3.3 merge window, because without it thaw_processes() may be called
     before swsusp_free() in some situations and that may lead to massive
     memory allocation failures.]
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Nigel Cunningham <nigel@tuxonice.net>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 0c4defe6d3b8..21724eee5206 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -231,8 +231,28 @@ extern int pm_test_level;
 #ifdef CONFIG_SUSPEND_FREEZER
 static inline int suspend_freeze_processes(void)
 {
-	int error = freeze_processes();
-	return error ? : freeze_kernel_threads();
+	int error;
+
+	error = freeze_processes();
+
+	/*
+	 * freeze_processes() automatically thaws every task if freezing
+	 * fails. So we need not do anything extra upon error.
+	 */
+	if (error)
+		goto Finish;
+
+	error = freeze_kernel_threads();
+
+	/*
+	 * freeze_kernel_threads() thaws only kernel threads upon freezing
+	 * failure. So we have to thaw the userspace tasks ourselves.
+	 */
+	if (error)
+		thaw_processes();
+
+ Finish:
+	return error;
 }
 
 static inline void suspend_thaw_processes(void)

commit 97819a26224f019e73d88bb2fd4eb5a614860461
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Thu Dec 1 22:33:10 2011 +0100

    PM / Hibernate: Thaw processes in SNAPSHOT_CREATE_IMAGE ioctl test path
    
    Commit 2aede851ddf08666f68ffc17be446420e9d2a056 (PM / Hibernate: Freeze
    kernel threads after preallocating memory) moved the freezing of kernel
    threads to hibernation_snapshot() function.
    
    So now, if the call to hibernation_snapshot() returns early due to a
    successful hibernation test, the caller has to thaw processes to ensure
    that the system gets back to its original state.
    
    But in SNAPSHOT_CREATE_IMAGE hibernation ioctl, the caller does not thaw
    processes in case hibernation_snapshot() returned due to a successful
    freezer test. Fix this issue. But note we still send the value of 'in_suspend'
    (which is now 0) to userspace, because we are not in an error path per-se,
    and moreover, the value of in_suspend correctly depicts the situation here.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 23a2db1ec442..0c4defe6d3b8 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -50,6 +50,8 @@ static inline char *check_image_kernel(struct swsusp_info *info)
 #define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
 /* kernel/power/hibernate.c */
+extern bool freezer_test_done;
+
 extern int hibernation_snapshot(int platform_mode);
 extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);

commit 081a9d043c983f161b78fdc4671324d1342b86bc
Author: Bojan Smojver <bojan@rexursive.com>
Date:   Thu Oct 13 23:58:07 2011 +0200

    PM / Hibernate: Improve performance of LZO/plain hibernation, checksum image
    
    Use threads for LZO compression/decompression on hibernate/thaw.
    Improve buffering on hibernate/thaw.
    Calculate/verify CRC32 of the image pages on hibernate/thaw.
    
    In my testing, this improved write/read speed by a factor of about two.
    
    Signed-off-by: Bojan Smojver <bojan@rexursive.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index e6206397ce67..23a2db1ec442 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -146,6 +146,7 @@ extern int swsusp_swap_in_use(void);
  */
 #define SF_PLATFORM_MODE	1
 #define SF_NOCOMPRESS_MODE	2
+#define SF_CRC32_MODE	        4
 
 /* kernel/power/hibernate.c */
 extern int swsusp_check(void);

commit 2aede851ddf08666f68ffc17be446420e9d2a056
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 26 20:32:27 2011 +0200

    PM / Hibernate: Freeze kernel threads after preallocating memory
    
    There is a problem with the current ordering of hibernate code which
    leads to deadlocks in some filesystems' memory shrinkers.  Namely,
    some filesystems use freezable kernel threads that are inactive when
    the hibernate memory preallocation is carried out.  Those same
    filesystems use memory shrinkers that may be triggered by the
    hibernate memory preallocation.  If those memory shrinkers wait for
    the frozen kernel threads, the hibernate process deadlocks (this
    happens with XFS, for one example).
    
    Apparently, it is not technically viable to redesign the filesystems
    in question to avoid the situation described above, so the only
    possible solution of this issue is to defer the freezing of kernel
    threads until the hibernate memory preallocation is done, which is
    implemented by this change.
    
    Unfortunately, this requires the memory preallocation to be done
    before the "prepare" stage of device freeze, so after this change the
    only way drivers can allocate additional memory for their freeze
    routines in a clean way is to use PM notifiers.
    
    Reported-by: Christoph <cr2005@u-club.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9a00a0a26280..e6206397ce67 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -228,7 +228,8 @@ extern int pm_test_level;
 #ifdef CONFIG_SUSPEND_FREEZER
 static inline int suspend_freeze_processes(void)
 {
-	return freeze_processes();
+	int error = freeze_processes();
+	return error ? : freeze_kernel_threads();
 }
 
 static inline void suspend_thaw_processes(void)

commit ddeb648708108091a641adad0a438ec4fd8bf190
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 15 11:38:48 2011 +0200

    PM / Hibernate: Add sysfs knob to control size of memory for drivers
    
    Martin reports that on his system hibernation occasionally fails due
    to the lack of memory, because the radeon driver apparently allocates
    too much of it during the device freeze stage.  It turns out that the
    amount of memory allocated by radeon during hibernation (and
    presumably during system suspend too) depends on the utilization of
    the GPU (e.g. hibernating while there are two KDE 4 sessions with
    compositing enabled causes radeon to allocate more memory than for
    one KDE 4 session).
    
    In principle it should be possible to use image_size to make the
    memory preallocation mechanism free enough memory for the radeon
    driver, but in practice it is not easy to guess the right value
    because of the way the preallocation code uses image_size.  For this
    reason, it seems reasonable to allow users to control the amount of
    memory reserved for driver allocations made after the hibernate
    preallocation, which currently is constant and amounts to 1 MB.
    
    Introduce a new sysfs file, /sys/power/reserved_size, whose value
    will be used as the amount of memory to reserve for the
    post-preallocation reservations made by device drivers, in bytes.
    For backwards compatibility, set its default (and initial) value to
    the currently used number (1 MB).
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=34102
    Reported-and-tested-by: Martin Steigerwald <Martin@Lichtvoll.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 03634be55f62..9a00a0a26280 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -15,6 +15,7 @@ struct swsusp_info {
 
 #ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */
+extern void __init hibernate_reserved_size_init(void);
 extern void __init hibernate_image_size_init(void);
 
 #ifdef CONFIG_ARCH_HIBERNATION_HEADER
@@ -55,6 +56,7 @@ extern int hibernation_platform_enter(void);
 
 #else /* !CONFIG_HIBERNATION */
 
+static inline void hibernate_reserved_size_init(void) {}
 static inline void hibernate_image_size_init(void) {}
 #endif /* !CONFIG_HIBERNATION */
 
@@ -72,6 +74,8 @@ static struct kobj_attribute _name##_attr = {	\
 
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
+/* Size of memory reserved for drivers (default SPARE_PAGES x PAGE_SIZE) */
+extern unsigned long reserved_size;
 extern int in_suspend;
 extern dev_t swsusp_resume_device;
 extern sector_t swsusp_resume_block;

commit ac5c24ec1e983313ef0015258fba6f630e54e7cf
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 20 19:44:56 2010 +0200

    PM / Hibernate: Make default image size depend on total RAM size
    
    The default hibernation image size is currently hard coded and euqal
    to 500 MB, which is not a reasonable default on many contemporary
    systems.  Make it equal 2/5 of the total RAM size (this is slightly
    below the maximum, i.e. 1/2 of the total RAM size, and seems to be
    generally suitable).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: M. Vefa Bicakci <bicave@superonline.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index c7e42e47eb0b..03634be55f62 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -14,6 +14,9 @@ struct swsusp_info {
 } __attribute__((aligned(PAGE_SIZE)));
 
 #ifdef CONFIG_HIBERNATION
+/* kernel/power/snapshot.c */
+extern void __init hibernate_image_size_init(void);
+
 #ifdef CONFIG_ARCH_HIBERNATION_HEADER
 /* Maximum size of architecture specific data in a hibernation header */
 #define MAX_ARCH_HEADER_SIZE	(sizeof(struct new_utsname) + 4)
@@ -49,7 +52,11 @@ static inline char *check_image_kernel(struct swsusp_info *info)
 extern int hibernation_snapshot(int platform_mode);
 extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);
-#endif
+
+#else /* !CONFIG_HIBERNATION */
+
+static inline void hibernate_image_size_init(void) {}
+#endif /* !CONFIG_HIBERNATION */
 
 extern int pfn_is_nosave(unsigned long);
 

commit f996fc9671d088bd5f52a70f18c64bfe3d0e418f
Author: Bojan Smojver <bojan@rexursive.com>
Date:   Thu Sep 9 23:06:23 2010 +0200

    PM / Hibernate: Compress hibernation image with LZO
    
    Compress hibernation image with LZO in order to save on I/O and
    therefore time to hibernate/thaw.
    
    [rjw: Added hibernate=nocompress command line option instead of just
     nocompress which would be confusing, fixed a couple of compiler
     warnings, fixed kerneldoc comments, minor cleanups.]
    
    Signed-off-by: Bojan Smojver <bojan@rexursive.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 006270fe382d..c7e42e47eb0b 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -134,6 +134,7 @@ extern int swsusp_swap_in_use(void);
  * the image header.
  */
 #define SF_PLATFORM_MODE	1
+#define SF_NOCOMPRESS_MODE	2
 
 /* kernel/power/hibernate.c */
 extern int swsusp_check(void);

commit 8a0d613fa12e1b7f7f71ca88ed7dc2a3de95121a
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Sat May 1 23:52:34 2010 +0200

    PM / Hibernate: Separate block_io
    
    Move block I/O operations to a separate file. It is because it will
    be used later not only by the swap writer.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index b1e207dde1c2..006270fe382d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -142,6 +142,15 @@ extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
 extern void swsusp_close(fmode_t);
 
+/* kernel/power/block_io.c */
+extern struct block_device *hib_resume_bdev;
+
+extern int hib_bio_read_page(pgoff_t page_off, void *addr,
+		struct bio **bio_chain);
+extern int hib_bio_write_page(pgoff_t page_off, void *addr,
+		struct bio **bio_chain);
+extern int hib_wait_on_bio_chain(struct bio **bio_chain);
+
 struct timeval;
 /* kernel/power/swsusp.c */
 extern void swsusp_show_speed(struct timeval *, struct timeval *,

commit d3c1b24c50e8b2bbc840322caf26c7eada594d21
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Sat May 1 23:52:02 2010 +0200

    PM / Hibernate: Snapshot cleanup
    
    Remove support of reads with offset. This means snapshot_read/write_next
    now does not accept count parameter. It allows to clean up the functions
    and snapshot handle which no longer needs to care about offsets.
    
    /dev/snapshot handler is converted to simple_{read_from,write_to}_buffer
    which take care of offsets.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 46c5a26630a3..b1e207dde1c2 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -97,24 +97,12 @@ extern int hibernate_preallocate_memory(void);
  */
 
 struct snapshot_handle {
-	loff_t		offset;	/* number of the last byte ready for reading
-				 * or writing in the sequence
-				 */
 	unsigned int	cur;	/* number of the block of PAGE_SIZE bytes the
 				 * next operation will refer to (ie. current)
 				 */
-	unsigned int	cur_offset;	/* offset with respect to the current
-					 * block (for the next operation)
-					 */
-	unsigned int	prev;	/* number of the block of PAGE_SIZE bytes that
-				 * was the current one previously
-				 */
 	void		*buffer;	/* address of the block to read from
 					 * or write to
 					 */
-	unsigned int	buf_offset;	/* location to read from or write to,
-					 * given as a displacement from 'buffer'
-					 */
 	int		sync_read;	/* Set to one to notify the caller of
 					 * snapshot_write_next() that it may
 					 * need to call wait_on_bio_chain()
@@ -125,12 +113,12 @@ struct snapshot_handle {
  * snapshot_read_next()/snapshot_write_next() is allowed to
  * read/write data after the function returns
  */
-#define data_of(handle)	((handle).buffer + (handle).buf_offset)
+#define data_of(handle)	((handle).buffer)
 
 extern unsigned int snapshot_additional_pages(struct zone *zone);
 extern unsigned long snapshot_get_image_size(void);
-extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
-extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
+extern int snapshot_read_next(struct snapshot_handle *handle);
+extern int snapshot_write_next(struct snapshot_handle *handle);
 extern void snapshot_write_finalize(struct snapshot_handle *handle);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
 

commit 64a473cb74a88cb4991edf985d55a266e65292e1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 8 13:24:05 2009 +0200

    PM/Hibernate: Do not release preallocated memory unnecessarily (rev. 2)
    
    Since the hibernation code is now going to use allocations of memory
    to make enough room for the image, it can also use the page frames
    allocated at this stage as image page frames.  The low-level
    hibernation code needs to be rearranged for this purpose, but it
    allows us to avoid freeing a great number of pages and allocating
    these same pages once again later, so it generally is worth doing.
    
    [rev. 2: Take highmem into account correctly.]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 26d5a26f82e3..46c5a26630a3 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -74,7 +74,7 @@ extern asmlinkage int swsusp_arch_resume(void);
 
 extern int create_basic_memory_bitmaps(void);
 extern void free_basic_memory_bitmaps(void);
-extern int swsusp_shrink_memory(void);
+extern int hibernate_preallocate_memory(void);
 
 /**
  *	Auxiliary structure used for reading the snapshot image data and

commit 8b759b84c8b3c27ccc8dd787294636297b3ebb40
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 10 01:27:49 2009 +0200

    PM/Hibernate: Rename disk.c to hibernate.c
    
    Change the name of kernel/power/disk.c to kernel/power/hibernate.c
    in analogy with the file names introduced by the changes that
    separated the suspend to RAM and standby funtionality from the
    common PM functions.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 2bd98d9fc19e..26d5a26f82e3 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -45,7 +45,7 @@ static inline char *check_image_kernel(struct swsusp_info *info)
  */
 #define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
-/* kernel/power/disk.c */
+/* kernel/power/hibernate.c */
 extern int hibernation_snapshot(int platform_mode);
 extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);
@@ -147,7 +147,7 @@ extern int swsusp_swap_in_use(void);
  */
 #define SF_PLATFORM_MODE	1
 
-/* kernel/power/disk.c */
+/* kernel/power/hibernate.c */
 extern int swsusp_check(void);
 extern void swsusp_free(void);
 extern int swsusp_read(unsigned int *flags_p);

commit a9d7052363a6e06bb623ed1876c56c7ca5b2c6d8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 10 01:27:12 2009 +0200

    PM: Separate suspend to RAM functionality from core
    
    Move the suspend to RAM and standby code from kernel/power/main.c
    to two separate files, kernel/power/suspend.c containing the basic
    functions and kernel/power/suspend_test.c containing the automatic
    suspend test facility based on the RTC clock alarm.
    
    There are no changes in functionality related to these modifications.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index ec4dbdfb07b4..2bd98d9fc19e 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -160,15 +160,30 @@ extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
 
 #ifdef CONFIG_SUSPEND
-/* kernel/power/main.c */
+/* kernel/power/suspend.c */
+extern const char *const pm_states[];
+
+extern bool valid_state(suspend_state_t state);
 extern int suspend_devices_and_enter(suspend_state_t state);
+extern int enter_state(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 static inline int suspend_devices_and_enter(suspend_state_t state)
 {
 	return -ENOSYS;
 }
+static inline int enter_state(suspend_state_t state) { return -ENOSYS; }
+static inline bool valid_state(suspend_state_t state) { return false; }
 #endif /* !CONFIG_SUSPEND */
 
+#ifdef CONFIG_PM_TEST_SUSPEND
+/* kernel/power/suspend_test.c */
+extern void suspend_test_start(void);
+extern void suspend_test_finish(const char *label);
+#else /* !CONFIG_PM_TEST_SUSPEND */
+static inline void suspend_test_start(void) {}
+static inline void suspend_test_finish(const char *label) {}
+#endif /* !CONFIG_PM_TEST_SUSPEND */
+
 #ifdef CONFIG_PM_SLEEP
 /* kernel/power/main.c */
 extern int pm_notifier_call_chain(unsigned long val);

commit fe419535d82724314bbf1244a0e740e4ea1bd3ae
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 11 23:11:17 2009 +0200

    PM/Hibernate: Move memory shrinking to snapshot.c (rev. 2)
    
    A future patch is going to modify the memory shrinking code so that
    it will make memory allocations to free memory instead of using an
    artificial memory shrinking mechanism for that.  For this purpose it
    is convenient to move swsusp_shrink_memory() from
    kernel/power/swsusp.c to kernel/power/snapshot.c, because the new
    memory-shrinking code is going to use things that are local to
    kernel/power/snapshot.c .
    
    [rev. 2: Make some functions static and remove their headers from
     kernel/power/power.h]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Wu Fengguang <fengguang.wu@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 46b5ec7a3afb..ec4dbdfb07b4 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -74,7 +74,7 @@ extern asmlinkage int swsusp_arch_resume(void);
 
 extern int create_basic_memory_bitmaps(void);
 extern void free_basic_memory_bitmaps(void);
-extern unsigned int count_data_pages(void);
+extern int swsusp_shrink_memory(void);
 
 /**
  *	Auxiliary structure used for reading the snapshot image data and
@@ -149,7 +149,6 @@ extern int swsusp_swap_in_use(void);
 
 /* kernel/power/disk.c */
 extern int swsusp_check(void);
-extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
@@ -176,7 +175,6 @@ extern int pm_notifier_call_chain(unsigned long val);
 #endif
 
 #ifdef CONFIG_HIGHMEM
-unsigned int count_highmem_pages(void);
 int restore_highmem(void);
 #else
 static inline unsigned int count_highmem_pages(void) { return 0; }

commit c2dd0dae185423fb243b13d490c3fcfaa18ff333
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 8 13:21:10 2007 -0400

    [PATCH] propagate mode through swsusp_close()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index acc0c101dbd5..46b5ec7a3afb 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -153,7 +153,7 @@ extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
-extern void swsusp_close(void);
+extern void swsusp_close(fmode_t);
 
 struct timeval;
 /* kernel/power/swsusp.c */

commit 89081d17f7bb81d89fa1aa9b70f821c5cf4d39e9
Author: Huang Ying <ying.huang@intel.com>
Date:   Fri Jul 25 19:45:10 2008 -0700

    kexec jump: save/restore device state
    
    This patch implements devices state save/restore before after kexec.
    
    This patch together with features in kexec_jump patch can be used for
    following:
    
    - A simple hibernation implementation without ACPI support.  You can kexec a
      hibernating kernel, save the memory image of original system and shutdown
      the system.  When resuming, you restore the memory image of original system
      via ordinary kexec load then jump back.
    
    - Kernel/system debug through making system snapshot.  You can make system
      snapshot, jump back, do some thing and make another system snapshot.
    
    - Cooperative multi-kernel/system.  With kexec jump, you can switch between
      several kernels/systems quickly without boot process except the first time.
      This appears like swap a whole kernel/system out/in.
    
    - A general method to call program in physical mode (paging turning
      off). This can be used to invoke BIOS code under Linux.
    
    The following user-space tools can be used with kexec jump:
    
    - kexec-tools needs to be patched to support kexec jump. The patches
      and the precompiled kexec can be download from the following URL:
           source: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec-tools-src_git_kh10.tar.bz2
           patches: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec-tools-patches_git_kh10.tar.bz2
           binary: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec_git_kh10
    
    - makedumpfile with patches are used as memory image saving tool, it
      can exclude free pages from original kernel memory image file. The
      patches and the precompiled makedumpfile can be download from the
      following URL:
           source: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile-src_cvs_kh10.tar.bz2
           patches: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile-patches_cvs_kh10.tar.bz2
           binary: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile_cvs_kh10
    
    - An initramfs image can be used as the root file system of kexeced
      kernel. An initramfs image built with "BuildRoot" can be downloaded
      from the following URL:
           initramfs image: http://khibernation.sourceforge.net/download/release_v10/initramfs/rootfs_cvs_kh10.gz
      All user space tools above are included in the initramfs image.
    
    Usage example of simple hibernation:
    
    1. Compile and install patched kernel with following options selected:
    
    CONFIG_X86_32=y
    CONFIG_RELOCATABLE=y
    CONFIG_KEXEC=y
    CONFIG_CRASH_DUMP=y
    CONFIG_PM=y
    CONFIG_HIBERNATION=y
    CONFIG_KEXEC_JUMP=y
    
    2. Build an initramfs image contains kexec-tool and makedumpfile, or
       download the pre-built initramfs image, called rootfs.gz in
       following text.
    
    3. Prepare a partition to save memory image of original kernel, called
       hibernating partition in following text.
    
    4. Boot kernel compiled in step 1 (kernel A).
    
    5. In the kernel A, load kernel compiled in step 1 (kernel B) with
       /sbin/kexec. The shell command line can be as follow:
    
       /sbin/kexec --load-preserve-context /boot/bzImage --mem-min=0x100000
         --mem-max=0xffffff --initrd=rootfs.gz
    
    6. Boot the kernel B with following shell command line:
    
       /sbin/kexec -e
    
    7. The kernel B will boot as normal kexec. In kernel B the memory
       image of kernel A can be saved into hibernating partition as
       follow:
    
       jump_back_entry=`cat /proc/cmdline | tr ' ' '\n' | grep kexec_jump_back_entry | cut -d '='`
       echo $jump_back_entry > kexec_jump_back_entry
       cp /proc/vmcore dump.elf
    
       Then you can shutdown the machine as normal.
    
    8. Boot kernel compiled in step 1 (kernel C). Use the rootfs.gz as
       root file system.
    
    9. In kernel C, load the memory image of kernel A as follow:
    
       /sbin/kexec -l --args-none --entry=`cat kexec_jump_back_entry` dump.elf
    
    10. Jump back to the kernel A as follow:
    
       /sbin/kexec -e
    
       Then, kernel A is resumed.
    
    Implementation point:
    
    To support jumping between two kernels, before jumping to (executing)
    the new kernel and jumping back to the original kernel, the devices
    are put into quiescent state, and the state of devices and CPU is
    saved. After jumping back from kexeced kernel and jumping to the new
    kernel, the state of devices and CPU are restored accordingly. The
    devices/CPU state save/restore code of software suspend is called to
    implement corresponding function.
    
    Known issues:
    
    - Because the segment number supported by sys_kexec_load is limited,
      hibernation image with many segments may not be load. This is
      planned to be eliminated by adding a new flag to sys_kexec_load to
      make a image can be loaded with multiple sys_kexec_load invoking.
    
    Now, only the i386 architecture is supported.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 700f44ec8406..acc0c101dbd5 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -53,8 +53,6 @@ extern int hibernation_platform_enter(void);
 
 extern int pfn_is_nosave(unsigned long);
 
-extern struct mutex pm_mutex;
-
 #define power_attr(_name) \
 static struct kobj_attribute _name##_attr = {	\
 	.attr	= {				\

commit b28f508112c584cdfbb4d8a9489cc4b79dac68ee
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jan 15 23:17:00 2008 -0500

    Suspend: Add config option to disable the freezer if architecture wants that
    
    This patch makes the freezer optional for suspend to allow the
    system to work (or not work) like the original PMU suspend.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 8ec5499c5ce1..700f44ec8406 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -1,6 +1,7 @@
 #include <linux/suspend.h>
 #include <linux/suspend_ioctls.h>
 #include <linux/utsname.h>
+#include <linux/freezer.h>
 
 struct swsusp_info {
 	struct new_utsname	uts;
@@ -203,3 +204,24 @@ enum {
 #define TEST_MAX	(__TEST_AFTER_LAST - 1)
 
 extern int pm_test_level;
+
+#ifdef CONFIG_SUSPEND_FREEZER
+static inline int suspend_freeze_processes(void)
+{
+	return freeze_processes();
+}
+
+static inline void suspend_thaw_processes(void)
+{
+	thaw_processes();
+}
+#else
+static inline int suspend_freeze_processes(void)
+{
+	return 0;
+}
+
+static inline void suspend_thaw_processes(void)
+{
+}
+#endif

commit 72df68ca8e006a0107933c4fb13c741a0a48163f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 8 02:04:21 2007 +0100

    Hibernation: Move low level resume to disk.c
    
    Move the low level restore code to kernel/power/disk.c , since the
    corresponding low level hibernation code is already there.
    
    Make restore fail if device_power_down(PMSG_PRETHAW) returns an
    error.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index a9732fd12239..8ec5499c5ce1 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -152,7 +152,6 @@ extern int swsusp_swap_in_use(void);
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);
-extern int swsusp_resume(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
 extern void swsusp_close(void);

commit 825257569350e913bee3bc918508c0aa6e3398cd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 19 23:49:18 2007 +0100

    PM: Convert PM notifiers to out-of-line code
    
    This patch (as1008b) converts the PM notifier routines from inline
    calls to out-of-line code.  It also prevents pm_chain_head from
    being created when CONFIG_PM_SLEEP isn't enabled, and EXPORTs the
    notifier registration and unregistration routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index f9f0d4d26c50..a9732fd12239 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -172,14 +172,10 @@ static inline int suspend_devices_and_enter(suspend_state_t state)
 }
 #endif /* !CONFIG_SUSPEND */
 
-/* kernel/power/common.c */
-extern struct blocking_notifier_head pm_chain_head;
-
-static inline int pm_notifier_call_chain(unsigned long val)
-{
-	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
-			== NOTIFY_BAD) ? -EINVAL : 0;
-}
+#ifdef CONFIG_PM_SLEEP
+/* kernel/power/main.c */
+extern int pm_notifier_call_chain(unsigned long val);
+#endif
 
 #ifdef CONFIG_HIGHMEM
 unsigned int count_highmem_pages(void);

commit 4cc79776c9ea431790e04fcacbebb30d28eb1570
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Nov 19 23:42:31 2007 +0100

    Hibernation: New testing facility (rev. 2)
    
    Make it possible to test the hibernation core code with the help of the
    /sys/power/pm_test attribute introduced for suspend testing in the previous
    patch.
    
    Writing an appropriate string to this file causes the hibernation code to work
    in one of the test modes defined as follows:
    
    freezer
    - test the freezing of processes
    
    devices
    - test the freezing of processes and suspending of devices
    
    platform
    - test the freezing of processes, suspending of devices and platform global
      control methods(*)
    
    processors
    - test the freezing of processes, suspending of devices, platform global
      control methods(*) and the disabling of nonboot CPUs
    
    core
    - test the freezing of processes, suspending of devices, platform global
      control methods(*), the disabling of nonboot CPUs and suspending of
      platform/system devices
    
    (*) - the platform global control methods are only available on ACPI systems
          and are only tested if the hibernation mode is set to "platform"
    
    Then, if a hibernation is started by normal means, the hibernation core will
    perform its normal operations up to the point indicated by given test level.
    Next, it will wait for 5 seconds and carry out the resume operations needed to
    transition the system back to the fully functional state.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9f9e16e33962..f9f0d4d26c50 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -206,3 +206,5 @@ enum {
 
 #define TEST_FIRST	TEST_NONE
 #define TEST_MAX	(__TEST_AFTER_LAST - 1)
+
+extern int pm_test_level;

commit 0e7d56e3d9d7e37c79d0e05ffb3994e34beb3bbc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Nov 19 23:41:19 2007 +0100

    Suspend: Testing facility (rev. 2)
    
    Introduce sysfs attribute /sys/power/pm_test allowing one to test the suspend
    core code.  Namely, writing one of the strings:
    
    freezer
    devices
    platform
    processors
    core
    
    to this file causes the suspend code to work in one of the test modes defined as
    follows:
    
    freezer
    - test the freezing of processes
    
    devices
    - test the freezing of processes and suspending of devices
    
    platform
    - test the freezing of processes, suspending of devices and platform global
      control methods(*)
    
    processors
    - test the freezing of processes, suspending of devices, platform global
      control methods and the disabling of nonboot CPUs
    
    core
    - test the freezing of processes, suspending of devices, platform global
      control methods, the disabling of nonboot CPUs and suspending of
      platform/system devices
    
    (*) These are ACPI global control methods on ACPI systems
    
    Then, if a suspend is started by normal means, the suspend core will perform
    its normal operations up to the point indicated by given test level.  Next, it
    will wait for 5 seconds and carry out the resume operations needed to transition
    the system back to the fully functional state.
    
    Writing "none" to /sys/power/pm_test turns the testing off.
    
    When open for reading, /sys/power/pm_test contains a space-separated list of all
    available tests (including "none" that represents the normal functionality) in
    which the current test level is indicated by square brackets.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index c5321eb1f7c8..9f9e16e33962 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -188,3 +188,21 @@ int restore_highmem(void);
 static inline unsigned int count_highmem_pages(void) { return 0; }
 static inline int restore_highmem(void) { return 0; }
 #endif
+
+/*
+ * Suspend test levels
+ */
+enum {
+	/* keep first */
+	TEST_NONE,
+	TEST_CORE,
+	TEST_CPUS,
+	TEST_PLATFORM,
+	TEST_DEVICES,
+	TEST_FREEZER,
+	/* keep last */
+	__TEST_AFTER_LAST
+};
+
+#define TEST_FIRST	TEST_NONE
+#define TEST_MAX	(__TEST_AFTER_LAST - 1)

commit 2f8ed1c60b06b797bf79a1dc540f0bed8c9d75a0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Nov 19 23:36:20 2007 +0100

    Hibernation: Move function prototypes to header
    
    This patch moves the prototypes of count_highmem_pages() and
    restore_highmem() to kernel/power/power.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index ef9060576a40..c5321eb1f7c8 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -180,3 +180,11 @@ static inline int pm_notifier_call_chain(unsigned long val)
 	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
 			== NOTIFY_BAD) ? -EINVAL : 0;
 }
+
+#ifdef CONFIG_HIGHMEM
+unsigned int count_highmem_pages(void);
+int restore_highmem(void);
+#else
+static inline unsigned int count_highmem_pages(void) { return 0; }
+static inline int restore_highmem(void) { return 0; }
+#endif

commit 3010f8caa48ed38679cc32b0d8e84b82cb8d9980
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 26 01:05:05 2007 +0200

    Hibernation: Introduce exportable suspend ioctls header (rev. 2)
    
    Move the definitions of hibernation ioctls to a separate header file in
    include/linux, which can be exported to the user space.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 0dd66fabd393..ef9060576a40 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -1,4 +1,5 @@
 #include <linux/suspend.h>
+#include <linux/suspend_ioctls.h>
 #include <linux/utsname.h>
 
 struct swsusp_info {
@@ -134,34 +135,6 @@ extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 extern void snapshot_write_finalize(struct snapshot_handle *handle);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
 
-/*
- * This structure is used to pass the values needed for the identification
- * of the resume swap area from a user space to the kernel via the
- * SNAPSHOT_SET_SWAP_AREA ioctl
- */
-struct resume_swap_area {
-	loff_t offset;
-	u_int32_t dev;
-} __attribute__((packed));
-
-#define SNAPSHOT_IOC_MAGIC	'3'
-#define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)
-#define SNAPSHOT_UNFREEZE		_IO(SNAPSHOT_IOC_MAGIC, 2)
-#define SNAPSHOT_ATOMIC_RESTORE		_IO(SNAPSHOT_IOC_MAGIC, 4)
-#define SNAPSHOT_FREE			_IO(SNAPSHOT_IOC_MAGIC, 5)
-#define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
-#define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
-#define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
-							struct resume_swap_area)
-#define SNAPSHOT_GET_IMAGE_SIZE		_IOR(SNAPSHOT_IOC_MAGIC, 14, loff_t)
-#define SNAPSHOT_PLATFORM_SUPPORT	_IO(SNAPSHOT_IOC_MAGIC, 15)
-#define SNAPSHOT_POWER_OFF		_IO(SNAPSHOT_IOC_MAGIC, 16)
-#define SNAPSHOT_CREATE_IMAGE		_IOW(SNAPSHOT_IOC_MAGIC, 17, int)
-#define SNAPSHOT_PREF_IMAGE_SIZE	_IO(SNAPSHOT_IOC_MAGIC, 18)
-#define SNAPSHOT_AVAIL_SWAP_SIZE	_IOR(SNAPSHOT_IOC_MAGIC, 19, loff_t)
-#define SNAPSHOT_ALLOC_SWAP_PAGE	_IOR(SNAPSHOT_IOC_MAGIC, 20, loff_t)
-#define SNAPSHOT_IOC_MAXNR	20
-
 /* If unset, the snapshot device cannot be open. */
 extern atomic_t snapshot_device_available;
 

commit cc5d207c85b9a6fafebe2856ead0a9360978c8cd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 26 01:03:33 2007 +0200

    Hibernation: Correct definitions of some ioctls (rev. 2)
    
    Three ioctl numbers belonging to the hibernation userland interface,
    SNAPSHOT_ATOMIC_SNAPSHOT, SNAPSHOT_AVAIL_SWAP, SNAPSHOT_GET_SWAP_PAGE,
    are defined in a wrong way (eg. not portable).  Provide new ioctl numbers for
    these ioctls and mark the existing ones as deprecated.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 8837ea334e33..0dd66fabd393 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -147,12 +147,8 @@ struct resume_swap_area {
 #define SNAPSHOT_IOC_MAGIC	'3'
 #define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)
 #define SNAPSHOT_UNFREEZE		_IO(SNAPSHOT_IOC_MAGIC, 2)
-#define SNAPSHOT_ATOMIC_SNAPSHOT	_IOW(SNAPSHOT_IOC_MAGIC, 3, void *)
 #define SNAPSHOT_ATOMIC_RESTORE		_IO(SNAPSHOT_IOC_MAGIC, 4)
 #define SNAPSHOT_FREE			_IO(SNAPSHOT_IOC_MAGIC, 5)
-#define SNAPSHOT_SET_IMAGE_SIZE		_IOW(SNAPSHOT_IOC_MAGIC, 6, unsigned long)
-#define SNAPSHOT_AVAIL_SWAP		_IOR(SNAPSHOT_IOC_MAGIC, 7, void *)
-#define SNAPSHOT_GET_SWAP_PAGE		_IOR(SNAPSHOT_IOC_MAGIC, 8, void *)
 #define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
 #define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
 #define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
@@ -160,7 +156,11 @@ struct resume_swap_area {
 #define SNAPSHOT_GET_IMAGE_SIZE		_IOR(SNAPSHOT_IOC_MAGIC, 14, loff_t)
 #define SNAPSHOT_PLATFORM_SUPPORT	_IO(SNAPSHOT_IOC_MAGIC, 15)
 #define SNAPSHOT_POWER_OFF		_IO(SNAPSHOT_IOC_MAGIC, 16)
-#define SNAPSHOT_IOC_MAXNR	16
+#define SNAPSHOT_CREATE_IMAGE		_IOW(SNAPSHOT_IOC_MAGIC, 17, int)
+#define SNAPSHOT_PREF_IMAGE_SIZE	_IO(SNAPSHOT_IOC_MAGIC, 18)
+#define SNAPSHOT_AVAIL_SWAP_SIZE	_IOR(SNAPSHOT_IOC_MAGIC, 19, loff_t)
+#define SNAPSHOT_ALLOC_SWAP_PAGE	_IOR(SNAPSHOT_IOC_MAGIC, 20, loff_t)
+#define SNAPSHOT_IOC_MAXNR	20
 
 /* If unset, the snapshot device cannot be open. */
 extern atomic_t snapshot_device_available;

commit 96f737490cfc368fdafe49769f52fc8460f9349f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 26 01:02:15 2007 +0200

    Hibernation: Mark SNAPSHOT_SET_SWAP_FILE ioctl as deprecated (rev. 2)
    
    Mark the SNAPSHOT_SET_SWAP_FILE ioctl belonging to the hibernation userland
    interface as deprecated.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 6ca85fd4975f..8837ea334e33 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -154,7 +154,6 @@ struct resume_swap_area {
 #define SNAPSHOT_AVAIL_SWAP		_IOR(SNAPSHOT_IOC_MAGIC, 7, void *)
 #define SNAPSHOT_GET_SWAP_PAGE		_IOR(SNAPSHOT_IOC_MAGIC, 8, void *)
 #define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
-#define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
 #define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
 #define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
 							struct resume_swap_area)

commit eb57c1cf059630454b40fb8bb124e3f318d241f8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 26 01:01:10 2007 +0200

    Hibernation: Rework platform support ioctls (rev. 2)
    
    Modify the hibernation userland interface by adding two new ioctls to it,
    SNAPSHOT_PLATFORM_SUPPORT and SNAPSHOT_POWER_OFF, that can be used,
    respectively, to switch the hibernation platform support on/off and to make the
    kernel transition the system to the hibernation state (eg. ACPI S4) using the
    platform (eg. ACPI) driver.
    
    These ioctls are intended to replace the misdesigned SNAPSHOT_PMOPS ioctl,
    which from now is regarded as obsolete and will be removed in the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 23c17031ed21..6ca85fd4975f 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -156,15 +156,12 @@ struct resume_swap_area {
 #define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
 #define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
 #define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
-#define SNAPSHOT_PMOPS			_IOW(SNAPSHOT_IOC_MAGIC, 12, unsigned int)
 #define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
 							struct resume_swap_area)
 #define SNAPSHOT_GET_IMAGE_SIZE		_IOR(SNAPSHOT_IOC_MAGIC, 14, loff_t)
-#define SNAPSHOT_IOC_MAXNR	14
-
-#define PMOPS_PREPARE	1
-#define PMOPS_ENTER	2
-#define PMOPS_FINISH	3
+#define SNAPSHOT_PLATFORM_SUPPORT	_IO(SNAPSHOT_IOC_MAGIC, 15)
+#define SNAPSHOT_POWER_OFF		_IO(SNAPSHOT_IOC_MAGIC, 16)
+#define SNAPSHOT_IOC_MAXNR	16
 
 /* If unset, the snapshot device cannot be open. */
 extern atomic_t snapshot_device_available;

commit af508b34d27e3341287d89e0eae6752fdb1b873f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 26 00:59:31 2007 +0200

    Hibernation: Introduce SNAPSHOT_GET_IMAGE_SIZE ioctl
    
    Add a new ioctl, SNAPSHOT_GET_IMAGE_SIZE, returning the size of the (just
    created) hibernation image, to the hibernation userland interface.
    
    This ioctl is necessary so that the userland utilities using the interface need
    not access the hibernation image header, owned by the kernel, in order to obtain
    the size of the image.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 2093c3a9a994..23c17031ed21 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -128,6 +128,7 @@ struct snapshot_handle {
 #define data_of(handle)	((handle).buffer + (handle).buf_offset)
 
 extern unsigned int snapshot_additional_pages(struct zone *zone);
+extern unsigned long snapshot_get_image_size(void);
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 extern void snapshot_write_finalize(struct snapshot_handle *handle);
@@ -158,7 +159,8 @@ struct resume_swap_area {
 #define SNAPSHOT_PMOPS			_IOW(SNAPSHOT_IOC_MAGIC, 12, unsigned int)
 #define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
 							struct resume_swap_area)
-#define SNAPSHOT_IOC_MAXNR	13
+#define SNAPSHOT_GET_IMAGE_SIZE		_IOR(SNAPSHOT_IOC_MAGIC, 14, loff_t)
+#define SNAPSHOT_IOC_MAXNR	14
 
 #define PMOPS_PREPARE	1
 #define PMOPS_ENTER	2

commit 386f275f5d097758f867bc99ddeaeb7a03b6b190
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 2 13:47:53 2007 +0100

    Driver Core: switch all dynamic ksets to kobj_sysfs_ops
    
    Switch all dynamically created ksets, that export simple attributes,
    to kobj_attribute from subsys_attribute. Struct subsys_attribute will
    be removed.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mike Halcrow <mhalcrow@us.ibm.com>
    Cc: Phillip Hellewell <phillip@hellewell.homeip.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1083e6b188ab..2093c3a9a994 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -54,7 +54,7 @@ extern int pfn_is_nosave(unsigned long);
 extern struct mutex pm_mutex;
 
 #define power_attr(_name) \
-static struct subsys_attribute _name##_attr = {	\
+static struct kobj_attribute _name##_attr = {	\
 	.attr	= {				\
 		.name = __stringify(_name),	\
 		.mode = 0644,			\

commit 039a5dcd2fc45188a2d522df630db4f7ef903a0f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 10:39:50 2007 -0700

    kset: convert /sys/power to use kset_create
    
    Dynamically create the kset instead of declaring it statically.  We also
    rename power_subsys to power_kset to catch all users of the variable and
    we properly export it so that people don't have to guess that it really
    is present in the system.
    
    The pseries code is wierd, why is it createing /sys/power if CONFIG_PM
    is disabled?  Oh well, stupid big boxes ignoring config options...
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 195dc4611764..1083e6b188ab 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -63,8 +63,6 @@ static struct subsys_attribute _name##_attr = {	\
 	.store	= _name##_store,		\
 }
 
-extern struct kset power_subsys;
-
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
 extern int in_suspend;

commit c7e0831d385d620a58d95b25e4afa9b643f9a411
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:55 2007 -0700

    Hibernation: Check if ACPI is enabled during restore in the right place
    
    The following scenario leads to total confusion of the platform firmware on
    some boxes (eg. HPC nx6325):
    * Hibernate with ACPI enabled
    * Resume passing "acpi=off" to the boot kernel
    
    To prevent this from happening it's necessary to check if ACPI is enabled (and
    enable it if that's not the case) _right_ _after_ control has been transfered
    from the boot kernel to the image kernel, before device_power_up() is called
    (ie.  with interrupts disabled).   Enabling ACPI after calling
    device_power_up() turns out to be insufficient.
    
    For this reason, introduce new hibernation callback ->leave() that will be
    executed before device_power_up() by the restored image kernel.   To make it
    work, it also is necessary to move swsusp_suspend() from swsusp.c to disk.c
    (it's name is changed to "create_image", which is more up to the point).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index a0204dfc6c4c..195dc4611764 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -183,7 +183,6 @@ extern int swsusp_swap_in_use(void);
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);
-extern int swsusp_suspend(void);
 extern int swsusp_resume(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);

commit d307c4a8e826c44f9633bd3f7e60d0491e7d885a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:52 2007 -0700

    Hibernation: Arbitrary boot kernel support - generic code
    
    Add the bits needed for supporting arbitrary boot kernels to the common
    hibernation code.
    
    To support arbitrary boot kernels, make it possible to replace the 'struct
    new_utsname' and the kernel version in the hibernation image header by some
    architecture specific data that will be used to verify if the image is valid
    and to restore the image.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 95fbf2dd3fe3..a0204dfc6c4c 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -11,14 +11,32 @@ struct swsusp_info {
 	unsigned long		size;
 } __attribute__((aligned(PAGE_SIZE)));
 
+#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_ARCH_HIBERNATION_HEADER
+/* Maximum size of architecture specific data in a hibernation header */
+#define MAX_ARCH_HEADER_SIZE	(sizeof(struct new_utsname) + 4)
 
+extern int arch_hibernation_header_save(void *addr, unsigned int max_size);
+extern int arch_hibernation_header_restore(void *addr);
+
+static inline int init_header_complete(struct swsusp_info *info)
+{
+	return arch_hibernation_header_save(info, MAX_ARCH_HEADER_SIZE);
+}
+
+static inline char *check_image_kernel(struct swsusp_info *info)
+{
+	return arch_hibernation_header_restore(info) ?
+			"architecture specific data" : NULL;
+}
+#endif /* CONFIG_ARCH_HIBERNATION_HEADER */
 
-#ifdef CONFIG_HIBERNATION
 /*
  * Keep some memory free so that I/O operations can succeed without paging
  * [Might this be more than 4 MB?]
  */
 #define PAGES_FOR_IO	((4096 * 1024) >> PAGE_SHIFT)
+
 /*
  * Keep 1 MB of memory free so that device drivers can allocate some pages in
  * their .suspend() routines without breaking the suspend to disk.

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9080914796f5..95fbf2dd3fe3 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -176,9 +176,17 @@ struct timeval;
 extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
 
+#ifdef CONFIG_SUSPEND
 /* kernel/power/main.c */
-extern int suspend_enter(suspend_state_t state);
 extern int suspend_devices_and_enter(suspend_state_t state);
+#else /* !CONFIG_SUSPEND */
+static inline int suspend_devices_and_enter(suspend_state_t state)
+{
+	return -ENOSYS;
+}
+#endif /* !CONFIG_SUSPEND */
+
+/* kernel/power/common.c */
 extern struct blocking_notifier_head pm_chain_head;
 
 static inline int pm_notifier_call_chain(unsigned long val)

commit b0cb1a19d05b8ea8611a9ef48a17fe417f1832e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:24:36 2007 +0200

    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION
    
    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION to avoid
    confusion (among other things, with CONFIG_SUSPEND introduced in the
    next patch).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 5f24c786f8ec..9080914796f5 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -13,7 +13,7 @@ struct swsusp_info {
 
 
 
-#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef CONFIG_HIBERNATION
 /*
  * Keep some memory free so that I/O operations can succeed without paging
  * [Might this be more than 4 MB?]

commit 6c961dfb7c903cfd1cd71b506863894038fd704f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:38 2007 -0700

    PM: Reduce code duplication between main.c and user.c
    
    The SNAPSHOT_S2RAM ioctl code is outdated and it should not duplicate the
    suspend code in kernel/power/main.c.  Fix that.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 01c2275b15b2..5f24c786f8ec 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -170,7 +170,6 @@ extern int swsusp_resume(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
 extern void swsusp_close(void);
-extern int suspend_enter(suspend_state_t state);
 
 struct timeval;
 /* kernel/power/swsusp.c */
@@ -178,6 +177,8 @@ extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
 
 /* kernel/power/main.c */
+extern int suspend_enter(suspend_state_t state);
+extern int suspend_devices_and_enter(suspend_state_t state);
 extern struct blocking_notifier_head pm_chain_head;
 
 static inline int pm_notifier_call_chain(unsigned long val)

commit b10d911749d37dccfa5873d2088aea3f074b9e45
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:36 2007 -0700

    PM: introduce hibernation and suspend notifiers
    
    Make it possible to register hibernation and suspend notifiers, so that
    subsystems can perform hibernation-related or suspend-related operations that
    should not be carried out by device drivers' .suspend() and .resume()
    routines.
    
    [akpm@linux-foundation.org: build fixes]
    [akpm@linux-foundation.org: cleanups]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index eab3603b7caf..01c2275b15b2 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -173,5 +173,15 @@ extern void swsusp_close(void);
 extern int suspend_enter(suspend_state_t state);
 
 struct timeval;
+/* kernel/power/swsusp.c */
 extern void swsusp_show_speed(struct timeval *, struct timeval *,
 				unsigned int, char *);
+
+/* kernel/power/main.c */
+extern struct blocking_notifier_head pm_chain_head;
+
+static inline int pm_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
+			== NOTIFY_BAD) ? -EINVAL : 0;
+}

commit a634cc10164d1c229fbeca33923e6a0ed939e894
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:30 2007 -0700

    swsusp: introduce restore platform operations
    
    At least on some machines it is necessary to prepare the ACPI firmware for the
    restoration of the system memory state from the hibernation image if the
    "platform" mode of hibernation has been used.  Namely, in that cases we need
    to disable the GPEs before replacing the "boot" kernel with the "frozen"
    kernel (cf.  http://bugzilla.kernel.org/show_bug.cgi?id=7887).  After the
    restore they will be re-enabled by hibernation_ops->finish(), but if the
    restore fails, they have to be re-enabled by the restore code explicitly.
    
    For this purpose we can introduce two additional hibernation operations,
    called pre_restore() and restore_cleanup() and call them from the restore code
    path.  Still, they should be called if the "platform" mode of hibernation has
    been used, so we need to pass the information about the hibernation mode from
    the "frozen" kernel to the "boot" kernel in the image header.
    
    Apparently, we can't drop the disabling of GPEs before the restore because of
    Bug #7887 .   We also can't do it unconditionally, because the GPEs wouldn't
    have been enabled after a successful restore if the suspend had been done in
    the 'shutdown' or 'reboot' mode.
    
    In principle we could (and probably should) unconditionally disable the GPEs
    before each snapshot creation *and* before the restore, but then we'd have to
    unconditionally enable them after the snapshot creation as well as after the
    restore (or restore failure)   Still, for this purpose we'd need to modify
    acpi_enter_sleep_state_prep() and acpi_leave_sleep_state() and we'd have to
    introduce some mechanism synchronizing the disablind/enabling of the GPEs with
    the device drivers' .suspend()/.resume() routines and with
    disable_/enable_nonboot_cpus().   However, this would have affected the
    suspend (ie.  s2ram) code as well as the hibernation, which I'd like to avoid
    in this patch series.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 70c378b3f85a..eab3603b7caf 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -27,7 +27,7 @@ struct swsusp_info {
 
 /* kernel/power/disk.c */
 extern int hibernation_snapshot(int platform_mode);
-extern int hibernation_restore(void);
+extern int hibernation_restore(int platform_mode);
 extern int hibernation_platform_enter(void);
 #endif
 
@@ -155,13 +155,20 @@ extern sector_t alloc_swapdev_block(int swap);
 extern void free_all_swap_pages(int swap);
 extern int swsusp_swap_in_use(void);
 
+/*
+ * Flags that can be passed from the hibernatig hernel to the "boot" kernel in
+ * the image header.
+ */
+#define SF_PLATFORM_MODE	1
+
+/* kernel/power/disk.c */
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);
 extern int swsusp_suspend(void);
 extern int swsusp_resume(void);
-extern int swsusp_read(void);
-extern int swsusp_write(void);
+extern int swsusp_read(unsigned int *flags_p);
+extern int swsusp_write(unsigned int flags);
 extern void swsusp_close(void);
 extern int suspend_enter(suspend_state_t state);
 

commit 7777fab989b5d006903188c966058ebcd2d6342a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:29 2007 -0700

    swsusp: remove code duplication between disk.c and user.c
    
    Currently, much of the code in kernel/power/disk.c is duplicated in
    kernel/power/user.c , mainly for historical reasons.  By eliminating this code
    duplication we can reduce the size of user.c quite substantially and remove
    the maintenance difficulty resulting from it.
    
    [bunk@stusta.de: kernel/power/disk.c: make code static]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 51381487103f..70c378b3f85a 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -25,7 +25,10 @@ struct swsusp_info {
  */
 #define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
-extern struct hibernation_ops *hibernation_ops;
+/* kernel/power/disk.c */
+extern int hibernation_snapshot(int platform_mode);
+extern int hibernation_restore(void);
+extern int hibernation_platform_enter(void);
 #endif
 
 extern int pfn_is_nosave(unsigned long);

commit a3d25c275d383975504dc53c25b691df59bd3c48
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 9 02:33:18 2007 -0700

    PM: Separate hibernation code from suspend code
    
    [ With Johannes Berg <johannes@sipsolutions.net> ]
    
    Separate the hibernation (aka suspend to disk code) from the other suspend
    code.  In particular:
    
     * Remove the definitions related to hibernation from include/linux/pm.h
     * Introduce struct hibernation_ops and a new hibernate() function to hibernate
       the system, defined in include/linux/suspend.h
     * Separate suspend code in kernel/power/main.c from hibernation-related code
       in kernel/power/disk.c and kernel/power/user.c (with the help of
       hibernation_ops)
     * Switch ACPI (the only user of pm_ops.pm_disk_mode) to hibernation_ops
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 34b43542785a..51381487103f 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -25,12 +25,7 @@ struct swsusp_info {
  */
 #define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
-extern int pm_suspend_disk(void);
-#else
-static inline int pm_suspend_disk(void)
-{
-	return -EPERM;
-}
+extern struct hibernation_ops *hibernation_ops;
 #endif
 
 extern int pfn_is_nosave(unsigned long);

commit 56f99bcb52d64d70078b41cc176dd8b6f5763108
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:52 2007 -0700

    swsusp: free more memory
    
    Move the definition of PAGES_FOR_IO to kernel/power/power.h and introduce
    SPARE_PAGES representing the number of pages that should be freed by the
    swsusp's memory shrinker in addition to PAGES_FOR_IO so that device drivers
    can allocate some memory (up to 1 MB total) in their .suspend() routines
    without causing the suspend to fail.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index a3e47cbdaf31..34b43542785a 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -14,8 +14,18 @@ struct swsusp_info {
 
 
 #ifdef CONFIG_SOFTWARE_SUSPEND
-extern int pm_suspend_disk(void);
+/*
+ * Keep some memory free so that I/O operations can succeed without paging
+ * [Might this be more than 4 MB?]
+ */
+#define PAGES_FOR_IO	((4096 * 1024) >> PAGE_SHIFT)
+/*
+ * Keep 1 MB of memory free so that device drivers can allocate some pages in
+ * their .suspend() routines without breaking the suspend to disk.
+ */
+#define SPARE_PAGES	((1024 * 1024) >> PAGE_SHIFT)
 
+extern int pm_suspend_disk(void);
 #else
 static inline int pm_suspend_disk(void)
 {

commit d1d241cc2c5feec057c370aa71637380b1b945d5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:47 2007 -0700

    swsusp: use rbtree for tracking allocated swap
    
    Make swsusp use extents instead of a bitmap to trace swap pages allocated
    for saving the image (the tracking is only needed in case there's an error,
    so that the allocated swap pages can be released).
    
    This should allow us to reduce the memory usage, practically always, and
    improve performance.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index a64d3f22de97..a3e47cbdaf31 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -143,30 +143,9 @@ struct resume_swap_area {
 /* If unset, the snapshot device cannot be open. */
 extern atomic_t snapshot_device_available;
 
-/**
- *	The bitmap is used for tracing allocated swap pages
- *
- *	The entire bitmap consists of a number of bitmap_page
- *	structures linked with the help of the .next member.
- *	Thus each page can be allocated individually, so we only
- *	need to make 0-order memory allocations to create
- *	the bitmap.
- */
-
-#define BITMAP_PAGE_SIZE	(PAGE_SIZE - sizeof(void *))
-#define BITMAP_PAGE_CHUNKS	(BITMAP_PAGE_SIZE / sizeof(long))
-#define BITS_PER_CHUNK		(sizeof(long) * 8)
-#define BITMAP_PAGE_BITS	(BITMAP_PAGE_CHUNKS * BITS_PER_CHUNK)
-
-struct bitmap_page {
-	unsigned long		chunks[BITMAP_PAGE_CHUNKS];
-	struct bitmap_page	*next;
-};
-
-extern void free_bitmap(struct bitmap_page *bitmap);
-extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
-extern sector_t alloc_swapdev_block(int swap, struct bitmap_page *bitmap);
-extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
+extern sector_t alloc_swapdev_block(int swap);
+extern void free_all_swap_pages(int swap);
+extern int swsusp_swap_in_use(void);
 
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);

commit 0709db6072c2e799eba1aa61bd19e0d7f38aa2cd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:45 2007 -0700

    swsusp: use GFP_KERNEL for creating basic data structures
    
    Make swsusp call create_basic_memory_bitmaps() before processes are frozen, so
    that GFP_KERNEL allocations can be made in it.  Additionally, ensure that the
    swsusp's userland interface won't be used while either pm_suspend_disk() or
    software_resume() is being executed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1f8052bda0f7..a64d3f22de97 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -140,6 +140,9 @@ struct resume_swap_area {
 #define PMOPS_ENTER	2
 #define PMOPS_FINISH	3
 
+/* If unset, the snapshot device cannot be open. */
+extern atomic_t snapshot_device_available;
+
 /**
  *	The bitmap is used for tracing allocated swap pages
  *

commit 74dfd666de861c97d47bdbd892f6d21b801d0247
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:43 2007 -0700

    swsusp: do not use page flags
    
    Make swsusp use memory bitmaps instead of page flags for marking 'nosave' and
    free pages.  This allows us to 'recycle' two page flags that can be used for
    other purposes.  Also, the memory needed to store the bitmaps is allocated
    when necessary (ie.  before the suspend) and freed after the resume which is
    more reasonable.
    
    The patch is designed to minimize the amount of changes and there are some
    nice simplifications and optimizations possible on top of it.  I am going to
    implement them separately in the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 33bd94ceba32..1f8052bda0f7 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -48,6 +48,8 @@ extern sector_t swsusp_resume_block;
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
+extern int create_basic_memory_bitmaps(void);
+extern void free_basic_memory_bitmaps(void);
 extern unsigned int count_data_pages(void);
 
 /**

commit ea62ccd00fd0b6720b033adfc9984f31130ce195
Merge: 886a0768affe 35060b6a9a4e
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sat May 5 14:55:20 2007 -0700

    Merge branch 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6
    
    * 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6: (231 commits)
      [PATCH] i386: Don't delete cpu_devs data to identify different x86 types in late_initcall
      [PATCH] i386: type may be unused
      [PATCH] i386: Some additional chipset register values validation.
      [PATCH] i386: Add missing !X86_PAE dependincy to the 2G/2G split.
      [PATCH] x86-64: Don't exclude asm-offsets.c in Documentation/dontdiff
      [PATCH] i386: avoid redundant preempt_disable in __unlazy_fpu
      [PATCH] i386: white space fixes in i387.h
      [PATCH] i386: Drop noisy e820 debugging printks
      [PATCH] x86-64: Fix allnoconfig error in genapic_flat.c
      [PATCH] x86-64: Shut up warnings for vfat compat ioctls on other file systems
      [PATCH] x86-64: Share identical video.S between i386 and x86-64
      [PATCH] x86-64: Remove CONFIG_REORDER
      [PATCH] x86-64: Print type and size correctly for unknown compat ioctls
      [PATCH] i386: Remove copy_*_user BUG_ONs for (size < 0)
      [PATCH] i386: Little cleanups in smpboot.c
      [PATCH] x86-64: Don't enable NUMA for a single node in K8 NUMA scanning
      [PATCH] x86: Use RDTSCP for synchronous get_cycles if possible
      [PATCH] i386: Add X86_FEATURE_RDTSCP
      [PATCH] i386: Implement X86_FEATURE_SYNC_RDTSC on i386
      [PATCH] i386: Implement alternative_io for i386
      ...
    
    Fix up trivial conflict in include/linux/highmem.h manually.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index eb461b816bf4..5f842c3efc4b 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -35,7 +35,7 @@ static struct subsys_attribute _name##_attr = {	\
 	.store	= _name##_store,		\
 }
 
-extern struct subsystem power_subsys;
+extern struct kset power_subsys;
 
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;

commit 49c3df6aaa6a51071fc135273d1a2515d019099f
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Wed May 2 19:27:07 2007 +0200

    [PATCH] x86: Move swsusp __pa() dependent code to arch portion
    
    o __pa() should be used only on kernel linearly mapped virtual addresses
      and not on kernel text and data addresses.
    
    o Hibernation code needs to determine the physical address associated
      with kernel symbol to mark a section boundary which contains pages which
      don't have to be saved and restored during hibernate/resume operation.
    
    o Move this piece of code in arch dependent section. So that architectures
      which don't have kernel text/data mapped into kernel linearly mapped
      region can come up with their own ways of determining physical addresses
      associated with a kernel text.
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index eb461b816bf4..1c6eef8df4ad 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -23,6 +23,8 @@ static inline int pm_suspend_disk(void)
 }
 #endif
 
+extern int pfn_is_nosave(unsigned long);
+
 extern struct mutex pm_mutex;
 
 #define power_attr(_name) \
@@ -37,9 +39,6 @@ static struct subsys_attribute _name##_attr = {	\
 
 extern struct subsystem power_subsys;
 
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
-
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
 extern int in_suspend;

commit a6d70980602e6f1869ebcdcbfaf55a0a5941583e
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Dec 6 20:34:35 2006 -0800

    [PATCH] convert pm_sem to a mutex
    
    The power management semaphore is only used as mutex, so convert it.
    
    [akpm@osdl.org: fix rotten bug]
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 3afa5dbe6bc5..eb461b816bf4 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -22,7 +22,9 @@ static inline int pm_suspend_disk(void)
 	return -EPERM;
 }
 #endif
-extern struct semaphore pm_sem;
+
+extern struct mutex pm_mutex;
+
 #define power_attr(_name) \
 static struct subsys_attribute _name##_attr = {	\
 	.attr	= {				\

commit 0d3a9abe8ae055e1052295698bcd0722c92eff47
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:32 2006 -0800

    [PATCH] swsusp: Measure memory shrinking time
    
    Make swsusp measure and print the time needed to shrink memory during the
    suspend.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 3763343bde2f..3afa5dbe6bc5 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -171,3 +171,7 @@ extern int swsusp_read(void);
 extern int swsusp_write(void);
 extern void swsusp_close(void);
 extern int suspend_enter(suspend_state_t state);
+
+struct timeval;
+extern void swsusp_show_speed(struct timeval *, struct timeval *,
+				unsigned int, char *);

commit 8357376d3df21b7d6f857931a57ac50da9c66e26
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:18 2006 -0800

    [PATCH] swsusp: Improve handling of highmem
    
    Currently swsusp saves the contents of highmem pages by copying them to the
    normal zone which is quite inefficient (eg.  it requires two normal pages
    to be used for saving one highmem page).  This may be improved by using
    highmem for saving the contents of saveable highmem pages.
    
    Namely, during the suspend phase of the suspend-resume cycle we try to
    allocate as many free highmem pages as there are saveable highmem pages.
    If there are not enough highmem image pages to store the contents of all of
    the saveable highmem pages, some of them will be stored in the "normal"
    memory.  Next, we allocate as many free "normal" pages as needed to store
    the (remaining) image data.  We use a memory bitmap to mark the allocated
    free pages (ie.  highmem as well as "normal" image pages).
    
    Now, we use another memory bitmap to mark all of the saveable pages
    (highmem as well as "normal") and the contents of the saveable pages are
    copied into the image pages.  Then, the second bitmap is used to save the
    pfns corresponding to the saveable pages and the first one is used to save
    their data.
    
    During the resume phase the pfns of the pages that were saveable during the
    suspend are loaded from the image and used to mark the "unsafe" page
    frames.  Next, we try to allocate as many free highmem page frames as to
    load all of the image data that had been in the highmem before the suspend
    and we allocate so many free "normal" page frames that the total number of
    allocated free pages (highmem and "normal") is equal to the size of the
    image.  While doing this we have to make sure that there will be some extra
    free "normal" and "safe" page frames for two lists of PBEs constructed
    later.
    
    Now, the image data are loaded, if possible, into their "original" page
    frames.  The image data that cannot be written into their "original" page
    frames are loaded into "safe" page frames and their "original" kernel
    virtual addresses, as well as the addresses of the "safe" pages containing
    their copies, are stored in one of two lists of PBEs.
    
    One list of PBEs is for the copies of "normal" suspend pages (ie.  "normal"
    pages that were saveable during the suspend) and it is used in the same way
    as previously (ie.  by the architecture-dependent parts of swsusp).  The
    other list of PBEs is for the copies of highmem suspend pages.  The pages
    in this list are restored (in a reversible way) right before the
    arch-dependent code is called.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7dbfd9f67e1c..3763343bde2f 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -103,8 +103,8 @@ struct snapshot_handle {
 extern unsigned int snapshot_additional_pages(struct zone *zone);
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
+extern void snapshot_write_finalize(struct snapshot_handle *handle);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
-extern void snapshot_free_unused_memory(struct snapshot_handle *handle);
 
 /*
  * This structure is used to pass the values needed for the identification

commit 37b2ba12df88f0e29f2d52aaf1ab22789377d5b5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:15 2006 -0800

    [PATCH] swsusp: add ioctl for swap files support
    
    To be able to use swap files as suspend storage from the userland suspend
    tools we need an additional ioctl() that will allow us to provide the kernel
    with both the swap header's offset and the identification of the resume
    partition.
    
    The new ioctl() should be regarded as a replacement for the
    SNAPSHOT_SET_SWAP_FILE ioctl() that from now on will be considered as
    obsolete, but has to stay for backwards compatibility of the interface.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index adaf7d4fbdaf..7dbfd9f67e1c 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -106,6 +106,16 @@ extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
 extern void snapshot_free_unused_memory(struct snapshot_handle *handle);
 
+/*
+ * This structure is used to pass the values needed for the identification
+ * of the resume swap area from a user space to the kernel via the
+ * SNAPSHOT_SET_SWAP_AREA ioctl
+ */
+struct resume_swap_area {
+	loff_t offset;
+	u_int32_t dev;
+} __attribute__((packed));
+
 #define SNAPSHOT_IOC_MAGIC	'3'
 #define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)
 #define SNAPSHOT_UNFREEZE		_IO(SNAPSHOT_IOC_MAGIC, 2)
@@ -119,7 +129,9 @@ extern void snapshot_free_unused_memory(struct snapshot_handle *handle);
 #define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
 #define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
 #define SNAPSHOT_PMOPS			_IOW(SNAPSHOT_IOC_MAGIC, 12, unsigned int)
-#define SNAPSHOT_IOC_MAXNR	12
+#define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
+							struct resume_swap_area)
+#define SNAPSHOT_IOC_MAXNR	13
 
 #define PMOPS_PREPARE	1
 #define PMOPS_ENTER	2

commit 9a154d9d95b7b9845938242f5c62505b3cab5bcd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:12 2006 -0800

    [PATCH] swsusp: add resume_offset command line parameter
    
    Add the kernel command line parameter "resume_offset=" allowing us to specify
    the offset, in <PAGE_SIZE> units, from the beginning of the partition pointed
    to by the "resume=" parameter at which the swap header is located.
    
    This offset can be determined, for example, by an application using the FIBMAP
    ioctl to obtain the swap header's block number for given file.
    
    [akpm@osdl.org: we don't know what type sector_t is]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 210ebba26020..adaf7d4fbdaf 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -42,6 +42,7 @@ extern const void __nosave_begin, __nosave_end;
 extern unsigned long image_size;
 extern int in_suspend;
 extern dev_t swsusp_resume_device;
+extern sector_t swsusp_resume_block;
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);

commit 3aef83e0ef1ffb8ea3bea97be46821a45c952173
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:10 2006 -0800

    [PATCH] swsusp: use block device offsets to identify swap locations
    
    Make swsusp use block device offsets instead of swap offsets to identify swap
    locations and make it use the same code paths for writing as well as for
    reading data.
    
    This allows us to use the same code for handling swap files and swap
    partitions and to simplify the code, eg.  by dropping rw_swap_page_sync().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 87ecb1856ee8..210ebba26020 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -146,7 +146,7 @@ struct bitmap_page {
 
 extern void free_bitmap(struct bitmap_page *bitmap);
 extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
-extern unsigned long alloc_swap_page(int swap, struct bitmap_page *bitmap);
+extern sector_t alloc_swapdev_block(int swap, struct bitmap_page *bitmap);
 extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
 
 extern int swsusp_check(void);

commit 3592695c363c3f3119621bdcf5ed852d6b9d1a5c
Author: Stefan Seyfried <seife@suse.de>
Date:   Wed Dec 6 20:34:06 2006 -0800

    [PATCH] uswsusp: add pmops->{prepare,enter,finish} support (aka "platform mode")
    
    Add an ioctl to the userspace swsusp code that enables the usage of the
    pmops->prepare, pmops->enter and pmops->finish methods (the in-kernel
    suspend knows these as "platform method").  These are needed on many
    machines to (among others) speed up resuming by letting the BIOS skip some
    steps or let my hp nx5000 recognise the correct ac_adapter state after
    resume again.
    
    It also ensures on many machines, that changed hardware (unplugged AC
    adapters) gets correctly detected and that kacpid does not run wild after
    resume.
    
    Signed-off-by: Stefan Seyfried <seife@suse.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index bfe999f7b272..87ecb1856ee8 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -117,7 +117,12 @@ extern void snapshot_free_unused_memory(struct snapshot_handle *handle);
 #define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
 #define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
 #define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
-#define SNAPSHOT_IOC_MAXNR	11
+#define SNAPSHOT_PMOPS			_IOW(SNAPSHOT_IOC_MAGIC, 12, unsigned int)
+#define SNAPSHOT_IOC_MAXNR	12
+
+#define PMOPS_PREPARE	1
+#define PMOPS_ENTER	2
+#define PMOPS_FINISH	3
 
 /**
  *	The bitmap is used for tracing allocated swap pages

commit 940864ddabdb180e02041c4dcd46ba6f9eee732f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:55 2006 -0700

    [PATCH] swsusp: Use memory bitmaps during resume
    
    Make swsusp use memory bitmaps to store its internal information during the
    resume phase of the suspend-resume cycle.
    
    If the pfns of saveable pages are saved during the suspend phase instead of
    the kernel virtual addresses of these pages, we can use them during the resume
    phase directly to set the corresponding bits in a memory bitmap.  Then, this
    bitmap is used to mark the page frames corresponding to the pages that were
    saveable before the suspend (aka "unsafe" page frames).
    
    Next, we allocate as many page frames as needed to store the entire suspend
    image and make sure that there will be some extra free "safe" page frames for
    the list of PBEs constructed later.  Subsequently, the image is loaded and, if
    possible, the data loaded from it are written into their "original" page
    frames (ie.  the ones they had occupied before the suspend).
    
    The image data that cannot be written into their "original" page frames are
    loaded into "safe" page frames and their "original" kernel virtual addresses,
    as well as the addresses of the "safe" pages containing their copies, are
    stored in a list of PBEs.  Finally, the list of PBEs is used to copy the
    remaining image data into their "original" page frames (this is done
    atomically, by the architecture-dependent parts of swsusp).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 6e9e2acc34f8..bfe999f7b272 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -81,16 +81,6 @@ struct snapshot_handle {
 	unsigned int	prev;	/* number of the block of PAGE_SIZE bytes that
 				 * was the current one previously
 				 */
-	struct pbe	*pbe;	/* PBE that corresponds to 'buffer' */
-	struct pbe	*last_pbe;	/* When the image is restored (eg. read
-					 * from disk) we can store some image
-					 * data directly in the page frames
-					 * in which they were before suspend.
-					 * In such a case the PBEs that
-					 * correspond to them will be unused.
-					 * This is the last PBE, so far, that
-					 * does not correspond to such data.
-					 */
 	void		*buffer;	/* address of the block to read from
 					 * or write to
 					 */
@@ -113,6 +103,7 @@ extern unsigned int snapshot_additional_pages(struct zone *zone);
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_image_loaded(struct snapshot_handle *handle);
+extern void snapshot_free_unused_memory(struct snapshot_handle *handle);
 
 #define SNAPSHOT_IOC_MAGIC	'3'
 #define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)

commit b788db79896ef2a5817b9395ad63573b254a6d93
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:54 2006 -0700

    [PATCH] swsusp: Introduce memory bitmaps
    
    Introduce the memory bitmap data structure and make swsusp use in the suspend
    phase.
    
    The current swsusp's internal data structure is not very efficient from the
    memory usage point of view, so it seems reasonable to replace it with a data
    structure that will require less memory, such as a pair of bitmaps.
    
    The idea is to use bitmaps that may be allocated as sets of individual pages,
    so that we can avoid making allocations of order greater than 0.  For this
    reason the memory bitmap structure consists of several linked lists of objects
    that contain pointers to memory pages with the actual bitmap data.  Still, for
    a typical system all of these lists fit in a single page, so it's reasonable
    to introduce an additional mechanism allowing us to allocate all of them
    efficiently without sacrificing the generality of the design.  This is done
    with the help of the chain_allocator structure and associated functions.
    
    We need to use two memory bitmaps during the suspend phase of the
    suspend-resume cycle.  One of them is necessary for marking the saveable
    pages, and the second is used to mark the pages in which to store the copies
    of them (aka image pages).
    
    First, the bitmaps are created and we allocate as many image pages as needed
    (the corresponding bits in the second bitmap are set as soon as the pages are
    allocated).  Second, the bits corresponding to the saveable pages are set in
    the first bitmap and the saveable pages are copied to the image pages.
    Finally, the first bitmap is used to save the kernel virtual addresses of the
    saveable pages and the second one is used to save the contents of the image
    pages.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index e18ba207e784..6e9e2acc34f8 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -109,9 +109,10 @@ struct snapshot_handle {
  */
 #define data_of(handle)	((handle).buffer + (handle).buf_offset)
 
+extern unsigned int snapshot_additional_pages(struct zone *zone);
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
-int snapshot_image_loaded(struct snapshot_handle *handle);
+extern int snapshot_image_loaded(struct snapshot_handle *handle);
 
 #define SNAPSHOT_IOC_MAGIC	'3'
 #define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)

commit 75534b50cc658e951bcb213c2763c81e9f7b0b48
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:52 2006 -0700

    [PATCH] Change the name of pagedir_nosave
    
    The name of the pagedir_nosave variable does not make sense any more, so it
    seems reasonable to change it to something more meaningful.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 1cefcf87a694..e18ba207e784 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -38,8 +38,6 @@ extern struct subsystem power_subsys;
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;
 
-extern struct pbe *pagedir_nosave;
-
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
 extern int in_suspend;

commit fb13a28b0f5ada60861868c4fa48a12bd0cb8dea
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:46 2006 -0700

    [PATCH] swsusp: struct snapshot_handle cleanup
    
    Add comments describing struct snapshot_handle and its members, change the
    confusing name of its member 'page' to 'cur'.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 59ce712f082d..1cefcf87a694 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -50,17 +50,65 @@ extern asmlinkage int swsusp_arch_resume(void);
 
 extern unsigned int count_data_pages(void);
 
+/**
+ *	Auxiliary structure used for reading the snapshot image data and
+ *	metadata from and writing them to the list of page backup entries
+ *	(PBEs) which is the main data structure of swsusp.
+ *
+ *	Using struct snapshot_handle we can transfer the image, including its
+ *	metadata, as a continuous sequence of bytes with the help of
+ *	snapshot_read_next() and snapshot_write_next().
+ *
+ *	The code that writes the image to a storage or transfers it to
+ *	the user land is required to use snapshot_read_next() for this
+ *	purpose and it should not make any assumptions regarding the internal
+ *	structure of the image.  Similarly, the code that reads the image from
+ *	a storage or transfers it from the user land is required to use
+ *	snapshot_write_next().
+ *
+ *	This may allow us to change the internal structure of the image
+ *	in the future with considerably less effort.
+ */
+
 struct snapshot_handle {
-	loff_t		offset;
-	unsigned int	page;
-	unsigned int	page_offset;
-	unsigned int	prev;
-	struct pbe	*pbe, *last_pbe;
-	void		*buffer;
-	unsigned int	buf_offset;
-	int		sync_read;
+	loff_t		offset;	/* number of the last byte ready for reading
+				 * or writing in the sequence
+				 */
+	unsigned int	cur;	/* number of the block of PAGE_SIZE bytes the
+				 * next operation will refer to (ie. current)
+				 */
+	unsigned int	cur_offset;	/* offset with respect to the current
+					 * block (for the next operation)
+					 */
+	unsigned int	prev;	/* number of the block of PAGE_SIZE bytes that
+				 * was the current one previously
+				 */
+	struct pbe	*pbe;	/* PBE that corresponds to 'buffer' */
+	struct pbe	*last_pbe;	/* When the image is restored (eg. read
+					 * from disk) we can store some image
+					 * data directly in the page frames
+					 * in which they were before suspend.
+					 * In such a case the PBEs that
+					 * correspond to them will be unused.
+					 * This is the last PBE, so far, that
+					 * does not correspond to such data.
+					 */
+	void		*buffer;	/* address of the block to read from
+					 * or write to
+					 */
+	unsigned int	buf_offset;	/* location to read from or write to,
+					 * given as a displacement from 'buffer'
+					 */
+	int		sync_read;	/* Set to one to notify the caller of
+					 * snapshot_write_next() that it may
+					 * need to call wait_on_bio_chain()
+					 */
 };
 
+/* This macro returns the address from/to which the caller of
+ * snapshot_read_next()/snapshot_write_next() is allowed to
+ * read/write data after the function returns
+ */
 #define data_of(handle)	((handle).buffer + (handle).buf_offset)
 
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);

commit 546e0d271941dd1ff6961e2a1f7eac75f1fc277e
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Sep 25 23:32:44 2006 -0700

    [PATCH] swsusp: read speedup
    
    Implement async reads for swsusp resuming.
    
    Crufty old PIII testbox:
            15.7 MB/s -> 20.3 MB/s
    
    Sony Vaio:
            14.6 MB/s -> 33.3 MB/s
    
    I didn't implement the post-resume bio_set_pages_dirty().  I don't really
    understand why resume needs to run set_page_dirty() against these pages.
    
    It might be a worry that this code modifies PG_Uptodate, PG_Error and
    PG_Locked against the image pages.  Can this possibly affect the resumed-into
    kernel?  Hopefully not, if we're atomically restoring its mem_map?
    
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 57a792982fb9..59ce712f082d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -58,6 +58,7 @@ struct snapshot_handle {
 	struct pbe	*pbe, *last_pbe;
 	void		*buffer;
 	unsigned int	buf_offset;
+	int		sync_read;
 };
 
 #define data_of(handle)	((handle).buffer + (handle).buf_offset)

commit 3448097fccdce4ea8f0fcad4f37f502a8cd72e68
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jun 25 18:41:00 2006 -0700

    Revert "swsusp special saveable pages support" commits
    
    This reverts commits
    
      3e3318dee0878d42ed62a19c292a2ac284135db3 [PATCH] swsusp: x86_64 mark special saveable/unsaveable pages
      b6370d96e09944c6e3ae8d5743ca8a8ab1f79f6c [PATCH] swsusp: i386 mark special saveable/unsaveable pages
      ce4ab0012b32c1a4a1d6e934aeb73bf3151c48d9 [PATCH] swsusp: add architecture special saveable pages support
    
    because not only do they apparently cause page faults on x86, the
    infrastructure doesn't compile on powerpc.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 98c41423f3b1..57a792982fb9 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -105,10 +105,6 @@ extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
 extern unsigned long alloc_swap_page(int swap, struct bitmap_page *bitmap);
 extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
 
-extern unsigned int count_special_pages(void);
-extern int save_special_mem(void);
-extern int restore_special_mem(void);
-
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);

commit 968808b8956e332e556b1eae9b4f7df77518f53b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jun 23 02:04:48 2006 -0700

    [PATCH] swsusp: use less memory during resume
    
    Make swsusp allocate only as much memory as needed to store the image data
    and metadata during resume.
    
    Without this patch swsusp additionally allocates many page frames that will
    conflict with the "original" locations of the image data and are considered
    as "unsafe", treating them as "eaten" pages (ie.  allocated but unusable).
    
    The patch makes swsusp allocate as many pages as it'll need to store the
    data read from the image in one shot, creating a list of allocated "safe"
    pages, and use the observation that all pages allocated by it are marked
    with the PG_nosave and PG_nosave_free flags set.   Namely, when it's about
    to load an image page, swsusp can check whether the page frame
    corresponding to the "original" location of this page has been allocated
    (ie.  if the page frame has the PG_nosave and PG_nosave_free flags set) and
    if so, it can load the page directly into this page frame.   Otherwise it
    uses an allocated "safe" page from the list to store the data that will be
    copied to their "original" location later on.
    
    This allows us to save many page copyings and page allocations during
    resume and in the future it may allow us to load images greater than 50% of
    the normal zone.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: "Pavel Machek" <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index c81f0ed3eeba..98c41423f3b1 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -55,7 +55,7 @@ struct snapshot_handle {
 	unsigned int	page;
 	unsigned int	page_offset;
 	unsigned int	prev;
-	struct pbe	*pbe;
+	struct pbe	*pbe, *last_pbe;
 	void		*buffer;
 	unsigned int	buf_offset;
 };

commit ce4ab0012b32c1a4a1d6e934aeb73bf3151c48d9
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jun 23 02:04:44 2006 -0700

    [PATCH] swsusp: add architecture special saveable pages support
    
    1. Add architecture specific pages save/restore support.  Next two patches
       will use this to save/restore 'ACPI NVS' pages.
    
    2. Allow reserved pages 'nosave'.  This could avoid save/restore BIOS
       reserved pages.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index f06f12f21767..c81f0ed3eeba 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -105,6 +105,10 @@ extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
 extern unsigned long alloc_swap_page(int swap, struct bitmap_page *bitmap);
 extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
 
+extern unsigned int count_special_pages(void);
+extern int save_special_mem(void);
+extern int restore_special_mem(void);
+
 extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
 extern void swsusp_free(void);

commit 9b238205ba5d79a8a242d7a5ddb82b89e4dc4e48
Author: Luca Tettamanti <kronos.it@gmail.com>
Date:   Thu Mar 23 03:00:09 2006 -0800

    [PATCH] swsusp: add s2ram ioctl to userland interface
    
    Add the SNAPSHOT_S2RAM ioctl to the snapshot device.
    
    This ioctl allows a userland application to make the system (previously frozen
    with the SNAPSHOT_FREE ioctl) enter the S3 state without freezing processes
    and disabling nonboot CPUs for the second time.
    
    This will allow us to implement the suspend-to-disk-and-RAM (STDR)
    functionality in the userland suspend tools.
    
    Signed-off-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 42c431c8bdde..f06f12f21767 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -77,7 +77,8 @@ int snapshot_image_loaded(struct snapshot_handle *handle);
 #define SNAPSHOT_GET_SWAP_PAGE		_IOR(SNAPSHOT_IOC_MAGIC, 8, void *)
 #define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
 #define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
-#define SNAPSHOT_IOC_MAXNR	10
+#define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
+#define SNAPSHOT_IOC_MAXNR	11
 
 /**
  *	The bitmap is used for tracing allocated swap pages
@@ -112,3 +113,4 @@ extern int swsusp_resume(void);
 extern int swsusp_read(void);
 extern int swsusp_write(void);
 extern void swsusp_close(void);
+extern int suspend_enter(suspend_state_t state);

commit 6e1819d615f24ce0726a7d0bd3dd0152d7b21654
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 23 03:00:03 2006 -0800

    [PATCH] swsusp: userland interface
    
    This patch introduces a user space interface for swsusp.
    
    The interface is based on a special character device, called the snapshot
    device, that allows user space processes to perform suspend and resume-related
    operations with the help of some ioctls and the read()/write() functions.
     Additionally it allows these processes to allocate free swap pages from a
    selected swap partition, called the resume partition, so that they know which
    sectors of the resume partition are available to them.
    
    The interface uses the same low-level system memory snapshot-handling
    functions that are used by the built-it swap-writing/reading code of swsusp.
    
    The interface documentation is included in the patch.
    
    The patch assumes that the major and minor numbers of the snapshot device will
    be 10 (ie.  misc device) and 231, the registration of which has already been
    requested.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 5d1abffbb9ce..42c431c8bdde 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -8,6 +8,7 @@ struct swsusp_info {
 	int			cpus;
 	unsigned long		image_pages;
 	unsigned long		pages;
+	unsigned long		size;
 } __attribute__((aligned(PAGE_SIZE)));
 
 
@@ -65,6 +66,19 @@ extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 int snapshot_image_loaded(struct snapshot_handle *handle);
 
+#define SNAPSHOT_IOC_MAGIC	'3'
+#define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)
+#define SNAPSHOT_UNFREEZE		_IO(SNAPSHOT_IOC_MAGIC, 2)
+#define SNAPSHOT_ATOMIC_SNAPSHOT	_IOW(SNAPSHOT_IOC_MAGIC, 3, void *)
+#define SNAPSHOT_ATOMIC_RESTORE		_IO(SNAPSHOT_IOC_MAGIC, 4)
+#define SNAPSHOT_FREE			_IO(SNAPSHOT_IOC_MAGIC, 5)
+#define SNAPSHOT_SET_IMAGE_SIZE		_IOW(SNAPSHOT_IOC_MAGIC, 6, unsigned long)
+#define SNAPSHOT_AVAIL_SWAP		_IOR(SNAPSHOT_IOC_MAGIC, 7, void *)
+#define SNAPSHOT_GET_SWAP_PAGE		_IOR(SNAPSHOT_IOC_MAGIC, 8, void *)
+#define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
+#define SNAPSHOT_SET_SWAP_FILE		_IOW(SNAPSHOT_IOC_MAGIC, 10, unsigned int)
+#define SNAPSHOT_IOC_MAXNR	10
+
 /**
  *	The bitmap is used for tracing allocated swap pages
  *

commit 74c7e2efbe37378026f00ad9e7253796d7b2fc99
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Mar 23 03:00:01 2006 -0800

    [PATCH] kernel/power: move externs to header files
    
    Move externs from C source files to header files.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 089c84bed895..5d1abffbb9ce 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -48,7 +48,6 @@ extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
 extern unsigned int count_data_pages(void);
-extern void swsusp_free(void);
 
 struct snapshot_handle {
 	loff_t		offset;
@@ -91,6 +90,11 @@ extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
 extern unsigned long alloc_swap_page(int swap, struct bitmap_page *bitmap);
 extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
 
+extern int swsusp_check(void);
 extern int swsusp_shrink_memory(void);
+extern void swsusp_free(void);
 extern int swsusp_suspend(void);
 extern int swsusp_resume(void);
+extern int swsusp_read(void);
+extern int swsusp_write(void);
+extern void swsusp_close(void);

commit 61159a314bca6408320c3173c1282c64f5cdaa76
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 23 03:00:00 2006 -0800

    [PATCH] swsusp: separate swap-writing/reading code
    
    Move the swap-writing/reading code of swsusp to a separate file.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index ea7132ed029b..089c84bed895 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -41,8 +41,8 @@ extern struct pbe *pagedir_nosave;
 
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
-
 extern int in_suspend;
+extern dev_t swsusp_resume_device;
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
@@ -65,3 +65,32 @@ struct snapshot_handle {
 extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
 extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
 int snapshot_image_loaded(struct snapshot_handle *handle);
+
+/**
+ *	The bitmap is used for tracing allocated swap pages
+ *
+ *	The entire bitmap consists of a number of bitmap_page
+ *	structures linked with the help of the .next member.
+ *	Thus each page can be allocated individually, so we only
+ *	need to make 0-order memory allocations to create
+ *	the bitmap.
+ */
+
+#define BITMAP_PAGE_SIZE	(PAGE_SIZE - sizeof(void *))
+#define BITMAP_PAGE_CHUNKS	(BITMAP_PAGE_SIZE / sizeof(long))
+#define BITS_PER_CHUNK		(sizeof(long) * 8)
+#define BITMAP_PAGE_BITS	(BITMAP_PAGE_CHUNKS * BITS_PER_CHUNK)
+
+struct bitmap_page {
+	unsigned long		chunks[BITMAP_PAGE_CHUNKS];
+	struct bitmap_page	*next;
+};
+
+extern void free_bitmap(struct bitmap_page *bitmap);
+extern struct bitmap_page *alloc_bitmap(unsigned int nr_bits);
+extern unsigned long alloc_swap_page(int swap, struct bitmap_page *bitmap);
+extern void free_all_swap_pages(int swap, struct bitmap_page *bitmap);
+
+extern int swsusp_shrink_memory(void);
+extern int swsusp_suspend(void);
+extern int swsusp_resume(void);

commit f577eb30afdc68233f25d4d82b04102129262365
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 23 02:59:59 2006 -0800

    [PATCH] swsusp: low level interface
    
    Introduce the low level interface that can be used for handling the
    snapshot of the system memory by the in-kernel swap-writing/reading code of
    swsusp and the userland interface code (to be introduced shortly).
    
    Also change the way in which swsusp records the allocated swap pages and,
    consequently, simplifies the in-kernel swap-writing/reading code (this is
    necessary for the userland interface too).  To this end, it introduces two
    helper functions in mm/swapfile.c, so that the swsusp code does not refer
    directly to the swap internals.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 388dba680841..ea7132ed029b 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -37,21 +37,31 @@ extern struct subsystem power_subsys;
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;
 
-extern unsigned int nr_copy_pages;
 extern struct pbe *pagedir_nosave;
 
 /* Preferred image size in bytes (default 500 MB) */
 extern unsigned long image_size;
 
+extern int in_suspend;
+
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
 extern unsigned int count_data_pages(void);
-extern void free_pagedir(struct pbe *pblist);
-extern void release_eaten_pages(void);
-extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
 extern void swsusp_free(void);
-extern int alloc_data_pages(struct pbe *pblist, gfp_t gfp_mask, int safe_needed);
-extern unsigned int snapshot_nr_pages(void);
-extern struct pbe *snapshot_pblist(void);
-extern void snapshot_pblist_set(struct pbe *pblist);
+
+struct snapshot_handle {
+	loff_t		offset;
+	unsigned int	page;
+	unsigned int	page_offset;
+	unsigned int	prev;
+	struct pbe	*pbe;
+	void		*buffer;
+	unsigned int	buf_offset;
+};
+
+#define data_of(handle)	((handle).buffer + (handle).buf_offset)
+
+extern int snapshot_read_next(struct snapshot_handle *handle, size_t count);
+extern int snapshot_write_next(struct snapshot_handle *handle, size_t count);
+int snapshot_image_loaded(struct snapshot_handle *handle);

commit 46cd2f32baf181b74b16cceb123bab6fe1f61f85
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 7 12:58:50 2006 -0800

    [PATCH] Fix build failure in recent pm_prepare_* changes.
    
    Fix compilation problem in PM headers.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index d8f0d1a76bae..388dba680841 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -1,14 +1,6 @@
 #include <linux/suspend.h>
 #include <linux/utsname.h>
 
-/* With SUSPEND_CONSOLE defined suspend looks *really* cool, but
-   we probably do not take enough locks for switching consoles, etc,
-   so bad things might happen.
-*/
-#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
-#define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
-#endif
-
 struct swsusp_info {
 	struct new_utsname	uts;
 	u32			version_code;
@@ -42,14 +34,6 @@ static struct subsys_attribute _name##_attr = {	\
 
 extern struct subsystem power_subsys;
 
-#ifdef SUSPEND_CONSOLE
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
-#else
-static int pm_prepare_console(void) { return 0; }
-static void pm_restore_console(void) {}
-#endif
-
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;
 

commit f7b8988ff50d99c99746f65f420364e91362c065
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 1 03:05:21 2006 -0800

    [PATCH] swsusp: do not change log level during suspend/resume
    
    Prevent the kernel from setting the log level to 10 unconditionally during
    suspend/resume which was needed in the past for debugging, but generally is
    undesirable.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 61beb5e0e927..d8f0d1a76bae 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -42,8 +42,13 @@ static struct subsys_attribute _name##_attr = {	\
 
 extern struct subsystem power_subsys;
 
+#ifdef SUSPEND_CONSOLE
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
+#else
+static int pm_prepare_console(void) { return 0; }
+static void pm_restore_console(void) {}
+#endif
 
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;

commit 853609b61ef88b414ffd1613741aa59894334320
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 1 03:05:07 2006 -0800

    [PATCH] swsusp: use bytes as image size units
    
    Make swsusp use bytes as the image size units, which is needed for future
    compatibility.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7e8492fd1423..61beb5e0e927 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -51,8 +51,8 @@ extern const void __nosave_begin, __nosave_end;
 extern unsigned int nr_copy_pages;
 extern struct pbe *pagedir_nosave;
 
-/* Preferred image size in MB (default 500) */
-extern unsigned int image_size;
+/* Preferred image size in bytes (default 500 MB) */
+extern unsigned long image_size;
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);

commit 277c6e2ad7369558dbd7ffbcc6dcbe16458bf723
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:17:58 2006 -0800

    [PATCH] swsusp: save image header first
    
    This makes the swsusp_info structure become the header of the image in the
    literal sense (ie.  it is saved to the swap and read before any other image
    data with the help of the swsusp's swap map structure, so generally it is
    treated in the same way as the rest of the image).
    
    The main thing it does is to make swsusp_header contain the offset of the swap
    map used to track the image data pages rather than the offset of swsusp_info.
     Simultaneously, swsusp_info becomes the first image page written to the swap.
    
    The other changes are generally consequences of the above with a few
    exceptions (there's some consolidation in the image reading part as a few
    functions turn into trivial wrappers around something else).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 273a5b1d70be..7e8492fd1423 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -16,7 +16,6 @@ struct swsusp_info {
 	int			cpus;
 	unsigned long		image_pages;
 	unsigned long		pages;
-	swp_entry_t		start;
 } __attribute__((aligned(PAGE_SIZE)));
 
 

commit ca0aec0f7a94bf9f07fefa8bfd23282d4e8ceb8a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:15:56 2006 -0800

    [PATCH] swsusp: make image size limit tunable
    
    Make the suspend image size limit tunable via /sys/power/image_size.
    
    It is necessary for systems on which there is a limited amount of swap
    available for suspend.  It can also be useful for optimizing performance of
    swsusp on systems with 1 GB of RAM or more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9b0459903613..273a5b1d70be 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -52,11 +52,8 @@ extern const void __nosave_begin, __nosave_end;
 extern unsigned int nr_copy_pages;
 extern struct pbe *pagedir_nosave;
 
-/*
- * Preferred image size in MB (set it to zero to get the smallest
- * image possible)
- */
-#define IMAGE_SIZE	500
+/* Preferred image size in MB (default 500) */
+extern unsigned int image_size;
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);

commit b3a93a255ec33a04776ec50efb30b7a99168dda2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:15:22 2006 -0800

    [PATCH] swsusp: limit image size
    
    Limit the size of the suspend image to approx.  500 MB, which should
    improve the overall performance of swsusp on systems with more than 1 GB of
    RAM.
    
    It introduces the constant IMAGE_SIZE that can be set to the preferred size
    of the image (in MB) and modifies the memory-shrinking part of swsusp to
    take this constant into account (500 is the default value of IMAGE_SIZE).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index e521e61e0d95..9b0459903613 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -53,12 +53,10 @@ extern unsigned int nr_copy_pages;
 extern struct pbe *pagedir_nosave;
 
 /*
- * This compilation switch determines the way in which memory will be freed
- * during suspend.  If defined, only as much memory will be freed as needed
- * to complete the suspend, which will make it go faster.  Otherwise, the
- * largest possible amount of memory will be freed.
+ * Preferred image size in MB (set it to zero to get the smallest
+ * image possible)
  */
-#define FAST_FREE	1
+#define IMAGE_SIZE	500
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);

commit c050ca78705592d440c22055865bf4de40fe2a4c
Author: Pavel Machek <pavel@ucw.cz>
Date:   Fri Jan 6 00:15:21 2006 -0800

    [PATCH] swsusp: Drop duplicate prototypes
    
    These two prototypes are already present in sched.h, remove duplicate
    version.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index acdc83b3d890..e521e61e0d95 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -43,9 +43,6 @@ static struct subsys_attribute _name##_attr = {	\
 
 extern struct subsystem power_subsys;
 
-extern int freeze_processes(void);
-extern void thaw_processes(void);
-
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
 

commit 72a97e08394a3b2e75481ff680ec2a0591e3cba4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:13:46 2006 -0800

    [PATCH] swsusp: improve freeing of memory
    
    This patch makes swsusp free only as much memory as needed to complete the
    suspend and not as much as possible.   In the most of cases this should speed
    up the suspend and make the system much more responsive after resume,
    especially if a GUI (eg.  X Windows) is used.
    
    If needed, the old behavior (ie to free as much memory as possible during
    suspend) can be restored by unsetting FAST_FREE in power.h
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 977877c6dcfc..acdc83b3d890 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -49,18 +49,26 @@ extern void thaw_processes(void);
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
 
-
 /* References to section boundaries */
 extern const void __nosave_begin, __nosave_end;
 
 extern unsigned int nr_copy_pages;
-extern suspend_pagedir_t *pagedir_nosave;
-extern suspend_pagedir_t *pagedir_save;
+extern struct pbe *pagedir_nosave;
+
+/*
+ * This compilation switch determines the way in which memory will be freed
+ * during suspend.  If defined, only as much memory will be freed as needed
+ * to complete the suspend, which will make it go faster.  Otherwise, the
+ * largest possible amount of memory will be freed.
+ */
+#define FAST_FREE	1
 
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
+extern unsigned int count_data_pages(void);
 extern void free_pagedir(struct pbe *pblist);
+extern void release_eaten_pages(void);
 extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
 extern void swsusp_free(void);
 extern int alloc_data_pages(struct pbe *pblist, gfp_t gfp_mask, int safe_needed);

commit 7088a5c00103ef48782d6c359cd12b13a10666e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:13:05 2006 -0800

    [PATCH] swsusp: introduce the swap map structure
    
    This patch introduces the swap map structure that can be used by swsusp for
    keeping tracks of data pages written to the swap.   The structure itself is
    described in a comment within the patch.
    
    The overall idea is to reduce the amount of metadata written to the swap and
    to write and read the image pages sequentially, in a file-alike way.  This
    makes the swap-handling part of swsusp fairly independent of its
    snapshot-handling part and will hopefully allow us to completely separate
    these two parts in the future.
    
    This patch is needed to remove the suspend image size limit imposed by the
    limited size of the swsusp_info structure, which is essential for x86-64
    systems with more than 512 MB of RAM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 6c042b5ee14b..977877c6dcfc 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -9,19 +9,14 @@
 #define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
 #endif
 
-#define MAX_PBES	((PAGE_SIZE - sizeof(struct new_utsname) \
-			- 4 - 3*sizeof(unsigned long) - sizeof(int) \
-			- sizeof(void *)) / sizeof(swp_entry_t))
-
 struct swsusp_info {
 	struct new_utsname	uts;
 	u32			version_code;
 	unsigned long		num_physpages;
 	int			cpus;
 	unsigned long		image_pages;
-	unsigned long		pagedir_pages;
-	suspend_pagedir_t	* suspend_pagedir;
-	swp_entry_t		pagedir[MAX_PBES];
+	unsigned long		pages;
+	swp_entry_t		start;
 } __attribute__((aligned(PAGE_SIZE)));
 
 
@@ -67,6 +62,8 @@ extern asmlinkage int swsusp_arch_resume(void);
 
 extern void free_pagedir(struct pbe *pblist);
 extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
-extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
 extern void swsusp_free(void);
 extern int alloc_data_pages(struct pbe *pblist, gfp_t gfp_mask, int safe_needed);
+extern unsigned int snapshot_nr_pages(void);
+extern struct pbe *snapshot_pblist(void);
+extern void snapshot_pblist_set(struct pbe *pblist);

commit 0fbeb5a45dccd493c35a68a5548e6a9d9882a791
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Nov 8 21:34:41 2005 -0800

    [PATCH] swsusp: rework swsusp_suspend
    
    This patch makes only the functions in swsusp.c call functions in snapshot.c
    and not both ways.  It also moves the check for available swap out of
    swsusp_suspend() which is necessary for separating the swap-handling functions
    in swsusp from the core code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 893ee655085c..6c042b5ee14b 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -65,10 +65,8 @@ extern suspend_pagedir_t *pagedir_save;
 extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
-extern int restore_highmem(void);
 extern void free_pagedir(struct pbe *pblist);
 extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
 extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
 extern void swsusp_free(void);
 extern int alloc_data_pages(struct pbe *pblist, gfp_t gfp_mask, int safe_needed);
-extern int enough_swap(unsigned nr_pages);

commit ed14b52701e6ef5a5aaf7bdb75932d5ea5dd7387
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Nov 8 21:34:40 2005 -0800

    [PATCH] swsusp: simplify pagedir relocation
    
    This patch simplifies the relocation of the page backup list (aka pagedir)
    during resume.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index c98923e13e75..893ee655085c 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -66,6 +66,7 @@ extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
 extern int restore_highmem(void);
+extern void free_pagedir(struct pbe *pblist);
 extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
 extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
 extern void swsusp_free(void);

commit 054bd4c18853f3a3851bd97aa90e11022a69dc42
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Nov 8 21:34:39 2005 -0800

    [PATCH] swsusp: reduce code duplication
    
    The changes made by this patch are necessary for the pagedir relocation
    simplification in the next patch.  Additionally, these changes allow us to
    drop check_pagedir() and make get_safe_page() be a one-line wrapper around
    alloc_image_page() (get_safe_page() goes to snapshot.c, because
    alloc_image_page() is static and it does not make sense to export it).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index d4fd96a135ab..c98923e13e75 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -66,7 +66,8 @@ extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
 extern int restore_highmem(void);
-extern struct pbe * alloc_pagedir(unsigned nr_pages);
+extern struct pbe *alloc_pagedir(unsigned nr_pages, gfp_t gfp_mask, int safe_needed);
 extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
 extern void swsusp_free(void);
+extern int alloc_data_pages(struct pbe *pblist, gfp_t gfp_mask, int safe_needed);
 extern int enough_swap(unsigned nr_pages);

commit 2c1b4a5ca48831595979a850f40ced8e7da026f8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 14:59:58 2005 -0800

    [PATCH] swsusp: rework memory freeing on resume
    
    The following patch makes swsusp use the PG_nosave and PG_nosave_free flags to
    mark pages that should be freed in case of an error during resume.
    
    This allows us to simplify the code and to use swsusp_free() in all of the
    swsusp's resume error paths, which makes them actually work.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 28afcb090149..d4fd96a135ab 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -66,7 +66,7 @@ extern asmlinkage int swsusp_arch_suspend(void);
 extern asmlinkage int swsusp_arch_resume(void);
 
 extern int restore_highmem(void);
-extern void free_pagedir(struct pbe *pblist);
 extern struct pbe * alloc_pagedir(unsigned nr_pages);
 extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
+extern void swsusp_free(void);
 extern int enough_swap(unsigned nr_pages);

commit a0f496517f3e28d651d0cbbcf2d4fb701ed6957e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 14:59:57 2005 -0800

    [PATCH] swsusp: reduce the use of global variables
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index e54dd8435de7..28afcb090149 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -69,4 +69,4 @@ extern int restore_highmem(void);
 extern void free_pagedir(struct pbe *pblist);
 extern struct pbe * alloc_pagedir(unsigned nr_pages);
 extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
-extern int enough_swap(void);
+extern int enough_swap(unsigned nr_pages);

commit 25761b6eb7b33823bcfff6bfe2a015badcd76fb8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 14:59:56 2005 -0800

    [PATCH] swsusp: move snapshot functionality to separate file
    
    The following patch moves the functionality of swsusp related to creating and
    handling the snapshot of memory to a separate file, snapshot.c
    
    This should enable us to untangle the code in the future and eventually to
    implement some parts of swsusp.c in the user space.
    
    The patch does not change the code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 6748de23e83c..e54dd8435de7 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -53,3 +53,20 @@ extern void thaw_processes(void);
 
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
+
+
+/* References to section boundaries */
+extern const void __nosave_begin, __nosave_end;
+
+extern unsigned int nr_copy_pages;
+extern suspend_pagedir_t *pagedir_nosave;
+extern suspend_pagedir_t *pagedir_save;
+
+extern asmlinkage int swsusp_arch_suspend(void);
+extern asmlinkage int swsusp_arch_resume(void);
+
+extern int restore_highmem(void);
+extern void free_pagedir(struct pbe *pblist);
+extern struct pbe * alloc_pagedir(unsigned nr_pages);
+extern void create_pbe_list(struct pbe *pblist, unsigned nr_pages);
+extern int enough_swap(void);

commit 0f7347c20c410c300be0db4c132945fd02e54110
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 27 21:45:43 2005 -0700

    [PATCH] swsusp: avoid problems if there are too many pages to save
    
    The following patch makes swsusp avoid problems during resume if there are
    too many pages to save on suspend.  It adds a constant that allows us to
    verify if we are going to save too many pages and implements the check
    (this is done as early as we can tell that the check will trigger, which is
    in swsusp_alloc()).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index 9c9167d910dd..6748de23e83c 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -9,6 +9,9 @@
 #define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
 #endif
 
+#define MAX_PBES	((PAGE_SIZE - sizeof(struct new_utsname) \
+			- 4 - 3*sizeof(unsigned long) - sizeof(int) \
+			- sizeof(void *)) / sizeof(swp_entry_t))
 
 struct swsusp_info {
 	struct new_utsname	uts;
@@ -18,7 +21,7 @@ struct swsusp_info {
 	unsigned long		image_pages;
 	unsigned long		pagedir_pages;
 	suspend_pagedir_t	* suspend_pagedir;
-	swp_entry_t		pagedir[768];
+	swp_entry_t		pagedir[MAX_PBES];
 } __attribute__((aligned(PAGE_SIZE)));
 
 

commit 8686bcd0a5f5e3f599ed9f1028ec9e449e7b87e3
Author: Pavel Machek <pavel@ucw.cz>
Date:   Thu Sep 22 21:44:11 2005 -0700

    [PATCH] swsusp: fix comments
    
    Fix comments in swsusp.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/power.h b/kernel/power/power.h
index cd6a3493cc0d..9c9167d910dd 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -1,7 +1,7 @@
 #include <linux/suspend.h>
 #include <linux/utsname.h>
 
-/* With SUSPEND_CONSOLE defined, it suspend looks *really* cool, but
+/* With SUSPEND_CONSOLE defined suspend looks *really* cool, but
    we probably do not take enough locks for switching consoles, etc,
    so bad things might happen.
 */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/kernel/power/power.h b/kernel/power/power.h
new file mode 100644
index 000000000000..cd6a3493cc0d
--- /dev/null
+++ b/kernel/power/power.h
@@ -0,0 +1,52 @@
+#include <linux/suspend.h>
+#include <linux/utsname.h>
+
+/* With SUSPEND_CONSOLE defined, it suspend looks *really* cool, but
+   we probably do not take enough locks for switching consoles, etc,
+   so bad things might happen.
+*/
+#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
+#endif
+
+
+struct swsusp_info {
+	struct new_utsname	uts;
+	u32			version_code;
+	unsigned long		num_physpages;
+	int			cpus;
+	unsigned long		image_pages;
+	unsigned long		pagedir_pages;
+	suspend_pagedir_t	* suspend_pagedir;
+	swp_entry_t		pagedir[768];
+} __attribute__((aligned(PAGE_SIZE)));
+
+
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+extern int pm_suspend_disk(void);
+
+#else
+static inline int pm_suspend_disk(void)
+{
+	return -EPERM;
+}
+#endif
+extern struct semaphore pm_sem;
+#define power_attr(_name) \
+static struct subsys_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = 0644,			\
+	},					\
+	.show	= _name##_show,			\
+	.store	= _name##_store,		\
+}
+
+extern struct subsystem power_subsys;
+
+extern int freeze_processes(void);
+extern void thaw_processes(void);
+
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
