commit db96a75946d3a2a41092c83992e65f727cd35529
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Thu Apr 2 15:56:52 2020 +0800

    PM: sleep: Add pm_debug_messages kernel command line option
    
    Debug messages from the system suspend/hibernation infrastructure
    are disabled by default, and can only be enabled after the system
    has boot up via /sys/power/pm_debug_messages.
    
    This makes the hibernation resume hard to track as it involves system
    boot up across hibernation.  There's no chance for software_resume()
    to track the resume process, for example.
    
    Add a kernel command line option to set pm_debug_messages during
    boot up.
    
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 69b7a8aeca3b..40f86ec4ab30 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -535,6 +535,13 @@ static ssize_t pm_debug_messages_store(struct kobject *kobj,
 
 power_attr(pm_debug_messages);
 
+static int __init pm_debug_messages_setup(char *str)
+{
+	pm_debug_messages_on = true;
+	return 1;
+}
+__setup("pm_debug_messages", pm_debug_messages_setup);
+
 /**
  * __pm_pr_dbg - Print a suspend debug message to the kernel log.
  * @defer: Whether or not to use printk_deferred() to print the message.

commit c052bf82c6b00ca27aab0859addc4b3159dfd3a4
Author: Jonas Meurer <jonas@freesources.org>
Date:   Thu Jan 16 12:53:54 2020 +0100

    PM: suspend: Add sysfs attribute to control the "sync on suspend" behavior
    
    The sysfs attribute `/sys/power/sync_on_suspend` controls, whether or not
    filesystems are synced by the kernel before system suspend.
    
    Congruously, the behaviour of build-time switch CONFIG_SUSPEND_SKIP_SYNC
    is slightly changed: It now defines the run-tim default for the new sysfs
    attribute `/sys/power/sync_on_suspend`.
    
    The run-time attribute is added because the existing corresponding
    build-time Kconfig flag for (`CONFIG_SUSPEND_SKIP_SYNC`) is not flexible
    enough. E.g. Linux distributions that provide pre-compiled kernels
    usually want to stick with the default (sync filesystems before suspend)
    but under special conditions this needs to be changed.
    
    One example for such a special condition is user-space handling of
    suspending block devices (e.g. using `cryptsetup luksSuspend` or `dmsetup
    suspend`) before system suspend. The Kernel trying to sync filesystems
    after the underlying block device already got suspended obviously leads
    to dead-locks. Be aware that you have to take care of the filesystem sync
    yourself before suspending the system in those scenarios.
    
    Signed-off-by: Jonas Meurer <jonas@freesources.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index e26de7af520b..69b7a8aeca3b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -190,6 +190,38 @@ static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr
 }
 
 power_attr(mem_sleep);
+
+/*
+ * sync_on_suspend: invoke ksys_sync_helper() before suspend.
+ *
+ * show() returns whether ksys_sync_helper() is invoked before suspend.
+ * store() accepts 0 or 1.  0 disables ksys_sync_helper() and 1 enables it.
+ */
+bool sync_on_suspend_enabled = !IS_ENABLED(CONFIG_SUSPEND_SKIP_SYNC);
+
+static ssize_t sync_on_suspend_show(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sync_on_suspend_enabled);
+}
+
+static ssize_t sync_on_suspend_store(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 1)
+		return -EINVAL;
+
+	sync_on_suspend_enabled = !!val;
+	return n;
+}
+
+power_attr(sync_on_suspend);
 #endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_PM_SLEEP_DEBUG
@@ -855,6 +887,7 @@ static struct attribute * g[] = {
 	&wakeup_count_attr.attr,
 #ifdef CONFIG_SUSPEND
 	&mem_sleep_attr.attr,
+	&sync_on_suspend_attr.attr,
 #endif
 #ifdef CONFIG_PM_AUTOSLEEP
 	&autosleep_attr.attr,

commit f49249d58abdc12067d69f15d509487171148b30
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 8 11:46:46 2019 +0100

    PM: sleep: include <linux/pm_runtime.h> for pm_wq
    
    Include the <linux/runtime_pm.h> for the definition of
    pm_wq to avoid the following warning:
    
    kernel/power/main.c:890:25: warning: symbol 'pm_wq' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index e8710d179b35..e26de7af520b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -15,6 +15,7 @@
 #include <linux/seq_file.h>
 #include <linux/suspend.h>
 #include <linux/syscalls.h>
+#include <linux/pm_runtime.h>
 
 #include "power.h"
 

commit d30bdfc0ecf885ca0495bdee522cb9d7ee005cf8
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Fri Aug 9 15:10:23 2019 +0800

    PM: sleep: Replace strncmp() with str_has_prefix()
    
    Use str_has_prefix() instead of strncmp() which is less
    straightforward in decode_state().
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 938dc53a8b94..e8710d179b35 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -580,7 +580,7 @@ static suspend_state_t decode_state(const char *buf, size_t n)
 	len = p ? p - buf : n;
 
 	/* Check hibernation first. */
-	if (len == 4 && !strncmp(buf, "disk", len))
+	if (len == 4 && str_has_prefix(buf, "disk"))
 		return PM_SUSPEND_MAX;
 
 #ifdef CONFIG_SUSPEND

commit 2c8db5bef9fb442a5a0d2fee28aed20100362ce3
Author: Kalesh Singh <kaleshsingh@google.com>
Date:   Wed Jul 31 14:29:33 2019 -0700

    PM/sleep: Expose suspend stats in sysfs
    
    Userspace can get suspend stats from the suspend stats debugfs node.
    Since debugfs doesn't have stable ABI, expose suspend stats in
    sysfs under /sys/power/suspend_stats.
    
    Signed-off-by: Kalesh Singh <kaleshsingh@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index bdbd605c4215..938dc53a8b94 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -254,7 +254,6 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 power_attr(pm_test);
 #endif /* CONFIG_PM_SLEEP_DEBUG */
 
-#ifdef CONFIG_DEBUG_FS
 static char *suspend_step_name(enum suspend_stat_step step)
 {
 	switch (step) {
@@ -275,6 +274,92 @@ static char *suspend_step_name(enum suspend_stat_step step)
 	}
 }
 
+#define suspend_attr(_name)					\
+static ssize_t _name##_show(struct kobject *kobj,		\
+		struct kobj_attribute *attr, char *buf)		\
+{								\
+	return sprintf(buf, "%d\n", suspend_stats._name);	\
+}								\
+static struct kobj_attribute _name = __ATTR_RO(_name)
+
+suspend_attr(success);
+suspend_attr(fail);
+suspend_attr(failed_freeze);
+suspend_attr(failed_prepare);
+suspend_attr(failed_suspend);
+suspend_attr(failed_suspend_late);
+suspend_attr(failed_suspend_noirq);
+suspend_attr(failed_resume);
+suspend_attr(failed_resume_early);
+suspend_attr(failed_resume_noirq);
+
+static ssize_t last_failed_dev_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	int index;
+	char *last_failed_dev = NULL;
+
+	index = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;
+	index %= REC_FAILED_NUM;
+	last_failed_dev = suspend_stats.failed_devs[index];
+
+	return sprintf(buf, "%s\n", last_failed_dev);
+}
+static struct kobj_attribute last_failed_dev = __ATTR_RO(last_failed_dev);
+
+static ssize_t last_failed_errno_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	int index;
+	int last_failed_errno;
+
+	index = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;
+	index %= REC_FAILED_NUM;
+	last_failed_errno = suspend_stats.errno[index];
+
+	return sprintf(buf, "%d\n", last_failed_errno);
+}
+static struct kobj_attribute last_failed_errno = __ATTR_RO(last_failed_errno);
+
+static ssize_t last_failed_step_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	int index;
+	enum suspend_stat_step step;
+	char *last_failed_step = NULL;
+
+	index = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;
+	index %= REC_FAILED_NUM;
+	step = suspend_stats.failed_steps[index];
+	last_failed_step = suspend_step_name(step);
+
+	return sprintf(buf, "%s\n", last_failed_step);
+}
+static struct kobj_attribute last_failed_step = __ATTR_RO(last_failed_step);
+
+static struct attribute *suspend_attrs[] = {
+	&success.attr,
+	&fail.attr,
+	&failed_freeze.attr,
+	&failed_prepare.attr,
+	&failed_suspend.attr,
+	&failed_suspend_late.attr,
+	&failed_suspend_noirq.attr,
+	&failed_resume.attr,
+	&failed_resume_early.attr,
+	&failed_resume_noirq.attr,
+	&last_failed_dev.attr,
+	&last_failed_errno.attr,
+	&last_failed_step.attr,
+	NULL,
+};
+
+static struct attribute_group suspend_attr_group = {
+	.name = "suspend_stats",
+	.attrs = suspend_attrs,
+};
+
+#ifdef CONFIG_DEBUG_FS
 static int suspend_stats_show(struct seq_file *s, void *unused)
 {
 	int i, index, last_dev, last_errno, last_step;
@@ -794,6 +879,14 @@ static const struct attribute_group attr_group = {
 	.attrs = g,
 };
 
+static const struct attribute_group *attr_groups[] = {
+	&attr_group,
+#ifdef CONFIG_PM_SLEEP
+	&suspend_attr_group,
+#endif
+	NULL,
+};
+
 struct workqueue_struct *pm_wq;
 EXPORT_SYMBOL_GPL(pm_wq);
 
@@ -815,7 +908,7 @@ static int __init pm_init(void)
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;
-	error = sysfs_create_group(power_kobj, &attr_group);
+	error = sysfs_create_groups(power_kobj, attr_groups);
 	if (error)
 		return error;
 	pm_print_times_init();

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 4f43e724f6eb..bdbd605c4215 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * kernel/power/main.c - PM subsystem core functionality.
  *
  * Copyright (c) 2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
- *
- * This file is released under the GPLv2
- *
  */
 
 #include <linux/export.h>

commit c64546b17bc940643545dd34eac21f51764d633c
Author: Harry Pan <harry.pan@intel.com>
Date:   Mon Feb 25 20:36:43 2019 +0800

    PM / sleep: Measure the time of filesystems syncing
    
    Measure the filesystems sync time during system sleep more precisely.
    
    Among other things, this allows the pr_cont() to be dropped from
    ksys_sync_helper() and makes automatic system suspend and hibernation
    profiling somewhat more straightforward.
    
    Signed-off-by: Harry Pan <harry.pan@intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 40472a7c5536..4f43e724f6eb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -54,9 +54,14 @@ EXPORT_SYMBOL_GPL(unlock_system_sleep);
 
 void ksys_sync_helper(void)
 {
-	pr_info("Syncing filesystems ... ");
+	ktime_t start;
+	long elapsed_msecs;
+
+	start = ktime_get();
 	ksys_sync();
-	pr_cont("done.\n");
+	elapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));
+	pr_info("Filesystems sync: %ld.%03ld seconds\n",
+		elapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);
 }
 EXPORT_SYMBOL_GPL(ksys_sync_helper);
 

commit b5dee3130bb4014511f5d0dd46855ed843e3fdc8
Author: Harry Pan <harry.pan@intel.com>
Date:   Mon Feb 25 20:36:41 2019 +0800

    PM / sleep: Refactor filesystems sync to reduce duplication
    
    Create a common helper to sync filesystems for system suspend and
    hibernation.
    
    Signed-off-by: Harry Pan <harry.pan@intel.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 98e76cad128b..40472a7c5536 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -16,6 +16,7 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/suspend.h>
+#include <linux/syscalls.h>
 
 #include "power.h"
 
@@ -51,6 +52,14 @@ void unlock_system_sleep(void)
 }
 EXPORT_SYMBOL_GPL(unlock_system_sleep);
 
+void ksys_sync_helper(void)
+{
+	pr_info("Syncing filesystems ... ");
+	ksys_sync();
+	pr_cont("done.\n");
+}
+EXPORT_SYMBOL_GPL(ksys_sync_helper);
+
 /* Routines for PM-transition notifications */
 
 static BLOCKING_NOTIFIER_HEAD(pm_chain_head);

commit 943a10f85265d4c14753d445003b6f5d8e3d959a
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Tue Dec 11 11:20:48 2018 -0500

    PM / sleep: convert to DEFINE_SHOW_ATTRIBUTE
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 35b50823d83b..98e76cad128b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -318,23 +318,12 @@ static int suspend_stats_show(struct seq_file *s, void *unused)
 
 	return 0;
 }
-
-static int suspend_stats_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, suspend_stats_show, NULL);
-}
-
-static const struct file_operations suspend_stats_operations = {
-	.open           = suspend_stats_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(suspend_stats);
 
 static int __init pm_debugfs_init(void)
 {
 	debugfs_create_file("suspend_stats", S_IFREG | S_IRUGO,
-			NULL, NULL, &suspend_stats_operations);
+			NULL, NULL, &suspend_stats_fops);
 	return 0;
 }
 

commit 55f2503c3b69328735e88031ff8d6ba291bd952b
Author: Pingfan Liu <kernelfans@gmail.com>
Date:   Tue Jul 31 16:51:32 2018 +0800

    PM / reboot: Eliminate race between reboot and suspend
    
    At present, "systemctl suspend" and "shutdown" can run in parrallel. A
    system can suspend after devices_shutdown(), and resume. Then the shutdown
    task goes on to power off. This causes many devices are not really shut
    off. Hence replacing reboot_mutex with system_transition_mutex (renamed
    from pm_mutex) to achieve the exclusion. The renaming of pm_mutex as
    system_transition_mutex can be better to reflect the purpose of the mutex.
    
    Signed-off-by: Pingfan Liu <kernelfans@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d9706da10930..35b50823d83b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -15,17 +15,16 @@
 #include <linux/workqueue.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/suspend.h>
 
 #include "power.h"
 
-DEFINE_MUTEX(pm_mutex);
-
 #ifdef CONFIG_PM_SLEEP
 
 void lock_system_sleep(void)
 {
 	current->flags |= PF_FREEZER_SKIP;
-	mutex_lock(&pm_mutex);
+	mutex_lock(&system_transition_mutex);
 }
 EXPORT_SYMBOL_GPL(lock_system_sleep);
 
@@ -37,8 +36,9 @@ void unlock_system_sleep(void)
 	 *
 	 * Reason:
 	 * Fundamentally, we just don't need it, because freezing condition
-	 * doesn't come into effect until we release the pm_mutex lock,
-	 * since the freezer always works with pm_mutex held.
+	 * doesn't come into effect until we release the
+	 * system_transition_mutex lock, since the freezer always works with
+	 * system_transition_mutex held.
 	 *
 	 * More importantly, in the case of hibernation,
 	 * unlock_system_sleep() gets called in snapshot_read() and
@@ -47,7 +47,7 @@ void unlock_system_sleep(void)
 	 * enter the refrigerator, thus causing hibernation to lockup.
 	 */
 	current->flags &= ~PF_FREEZER_SKIP;
-	mutex_unlock(&pm_mutex);
+	mutex_unlock(&system_transition_mutex);
 }
 EXPORT_SYMBOL_GPL(unlock_system_sleep);
 

commit 44348e8ac145d78171c5a6f4a8bdb01b70969fc2
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jun 14 12:34:32 2018 -0300

    fix a series of Documentation/ broken file name references
    
    As files move around, their previous links break. Fix the
    references for them.
    
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 705c2366dafe..d9706da10930 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -455,8 +455,9 @@ struct kobject *power_kobj;
  * state - control system sleep states.
  *
  * show() returns available sleep state labels, which may be "mem", "standby",
- * "freeze" and "disk" (hibernation).  See Documentation/power/states.txt for a
- * description of what they mean.
+ * "freeze" and "disk" (hibernation).
+ * See Documentation/admin-guide/pm/sleep-states.rst for a description of
+ * what they mean.
  *
  * store() accepts one of those strings, translates it into the proper
  * enumerated value, and initiates a suspend transition.

commit 4bf236a3330e97d275e5848420f7e31948fef07a
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Jan 5 09:19:08 2018 -0800

    PM / sleep: Make lock/unlock_system_sleep() available to kernel modules
    
    Since pm_mutex is not exported using lock/unlock_system_sleep() from
    inside a kernel module causes a "pm_mutex undefined" linker error.
    Hence move lock/unlock_system_sleep() into kernel/power/main.c and
    export these.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3a2ca9066583..705c2366dafe 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -22,6 +22,35 @@ DEFINE_MUTEX(pm_mutex);
 
 #ifdef CONFIG_PM_SLEEP
 
+void lock_system_sleep(void)
+{
+	current->flags |= PF_FREEZER_SKIP;
+	mutex_lock(&pm_mutex);
+}
+EXPORT_SYMBOL_GPL(lock_system_sleep);
+
+void unlock_system_sleep(void)
+{
+	/*
+	 * Don't use freezer_count() because we don't want the call to
+	 * try_to_freeze() here.
+	 *
+	 * Reason:
+	 * Fundamentally, we just don't need it, because freezing condition
+	 * doesn't come into effect until we release the pm_mutex lock,
+	 * since the freezer always works with pm_mutex held.
+	 *
+	 * More importantly, in the case of hibernation,
+	 * unlock_system_sleep() gets called in snapshot_read() and
+	 * snapshot_write() when the freezing condition is still in effect.
+	 * Which means, if we use try_to_freeze() here, it would make them
+	 * enter the refrigerator, thus causing hibernation to lockup.
+	 */
+	current->flags &= ~PF_FREEZER_SKIP;
+	mutex_unlock(&pm_mutex);
+}
+EXPORT_SYMBOL_GPL(unlock_system_sleep);
+
 /* Routines for PM-transition notifications */
 
 static BLOCKING_NOTIFIER_HEAD(pm_chain_head);

commit 726fb6b4f2a82a14a906f39bdabac4863b87c01a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Aug 15 18:16:59 2017 -0700

    ACPI / PM: Check low power idle constraints for debug only
    
    For SoC to achieve its lowest power platform idle state a set of hardware
    preconditions must be met. These preconditions or constraints can be
    obtained by issuing a device specific method (_DSM) with function "1".
    Refer to the document provided in the link below.
    
    Here during initialization (from attach() callback of LPS0 device), invoke
    function 1 to get the device constraints. Each enabled constraint is
    stored in a table.
    
    The devices in this table are used to check whether they were in required
    minimum state, while entering suspend. This check is done from platform
    freeze wake() callback, only when /sys/power/pm_debug_messages attribute
    is non zero.
    
    If any constraint is not met and device is ACPI power managed then it
    prints the device information to kernel logs.
    
    Also if debug is enabled in acpi/sleep.c, the constraint table and state
    of each device on wake is dumped in kernel logs.
    
    Since pm_debug_messages_on setting is used as condition to check
    constraints outside kernel/power/main.c, pm_debug_messages_on is changed
    to a global variable.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3074ea4cec0a..3a2ca9066583 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -361,7 +361,7 @@ static ssize_t pm_wakeup_irq_show(struct kobject *kobj,
 
 power_attr_ro(pm_wakeup_irq);
 
-static bool pm_debug_messages_on __read_mostly;
+bool pm_debug_messages_on __read_mostly;
 
 static ssize_t pm_debug_messages_show(struct kobject *kobj,
 				      struct kobj_attribute *attr, char *buf)

commit e516a1db43cea397cf63d395534236d9869f0310
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 14:44:02 2017 +0200

    PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
    
    The pm_test sysfs attribute is under CONFIG_PM_DEBUG, but it doesn't
    make sense to provide it if CONFIG_PM_SLEEP is unset, so put it under
    CONFIG_PM_SLEEP_DEBUG instead.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b7876eaf83f3..3074ea4cec0a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -150,7 +150,7 @@ static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr
 power_attr(mem_sleep);
 #endif /* CONFIG_SUSPEND */
 
-#ifdef CONFIG_PM_DEBUG
+#ifdef CONFIG_PM_SLEEP_DEBUG
 int pm_test_level = TEST_NONE;
 
 static const char * const pm_tests[__TEST_AFTER_LAST] = {
@@ -211,7 +211,7 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_test);
-#endif /* CONFIG_PM_DEBUG */
+#endif /* CONFIG_PM_SLEEP_DEBUG */
 
 #ifdef CONFIG_DEBUG_FS
 static char *suspend_step_name(enum suspend_stat_step step)
@@ -746,10 +746,8 @@ static struct attribute * g[] = {
 	&wake_lock_attr.attr,
 	&wake_unlock_attr.attr,
 #endif
-#ifdef CONFIG_PM_DEBUG
-	&pm_test_attr.attr,
-#endif
 #ifdef CONFIG_PM_SLEEP_DEBUG
+	&pm_test_attr.attr,
 	&pm_print_times_attr.attr,
 	&pm_wakeup_irq_attr.attr,
 	&pm_debug_messages_attr.attr,

commit cb08e0353c249a27aed10c6f60a13871ae449d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 23 00:03:43 2017 +0200

    PM / timekeeping: Print debug messages when requested
    
    The messages printed by tk_debug_account_sleep_time() are basically
    useful for system sleep debugging, so print them only when the other
    debug messages from the core suspend/hibernate code are enabled.
    
    While at it, make it clear that the messages from
    tk_debug_account_sleep_time() are about timekeeping suspend
    duration, because in general timekeeping may be suspeded and
    resumed for multiple times during one system suspend-resume cycle.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 5ce00902c7e3..b7876eaf83f3 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -388,13 +388,14 @@ static ssize_t pm_debug_messages_store(struct kobject *kobj,
 power_attr(pm_debug_messages);
 
 /**
- * pm_pr_dbg - Print a suspend debug message to the kernel log.
+ * __pm_pr_dbg - Print a suspend debug message to the kernel log.
+ * @defer: Whether or not to use printk_deferred() to print the message.
  * @fmt: Message format.
  *
  * The message will be emitted if enabled through the pm_debug_messages
  * sysfs attribute.
  */
-void pm_pr_dbg(const char *fmt, ...)
+void __pm_pr_dbg(bool defer, const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
@@ -407,7 +408,10 @@ void pm_pr_dbg(const char *fmt, ...)
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	printk(KERN_DEBUG "PM: %pV", &vaf);
+	if (defer)
+		printk_deferred(KERN_DEBUG "PM: %pV", &vaf);
+	else
+		printk(KERN_DEBUG "PM: %pV", &vaf);
 
 	va_end(args);
 }

commit 8d8b2441db9647890251538f60b75a4e45fdef8d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 19 02:38:44 2017 +0200

    PM / sleep: Do not print debug messages by default
    
    Debug messages from the system suspend/hibernation infrastructure can
    fill up the entire kernel log buffer in some cases and anyway they
    are only useful for debugging.  They depend on CONFIG_PM_DEBUG, but
    that is set as a rule as some generally useful diagnostic facilities
    depend on it too.
    
    For this reason, avoid printing those messages by default, but make
    it possible to turn them on as needed with the help of a new sysfs
    attribute under /sys/power/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 42bd800a6755..5ce00902c7e3 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -361,6 +361,57 @@ static ssize_t pm_wakeup_irq_show(struct kobject *kobj,
 
 power_attr_ro(pm_wakeup_irq);
 
+static bool pm_debug_messages_on __read_mostly;
+
+static ssize_t pm_debug_messages_show(struct kobject *kobj,
+				      struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pm_debug_messages_on);
+}
+
+static ssize_t pm_debug_messages_store(struct kobject *kobj,
+				       struct kobj_attribute *attr,
+				       const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 1)
+		return -EINVAL;
+
+	pm_debug_messages_on = !!val;
+	return n;
+}
+
+power_attr(pm_debug_messages);
+
+/**
+ * pm_pr_dbg - Print a suspend debug message to the kernel log.
+ * @fmt: Message format.
+ *
+ * The message will be emitted if enabled through the pm_debug_messages
+ * sysfs attribute.
+ */
+void pm_pr_dbg(const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	if (!pm_debug_messages_on)
+		return;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	printk(KERN_DEBUG "PM: %pV", &vaf);
+
+	va_end(args);
+}
+
 #else /* !CONFIG_PM_SLEEP_DEBUG */
 static inline void pm_print_times_init(void) {}
 #endif /* CONFIG_PM_SLEEP_DEBUG */
@@ -697,6 +748,7 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_SLEEP_DEBUG
 	&pm_print_times_attr.attr,
 	&pm_wakeup_irq_attr.attr,
+	&pm_debug_messages_attr.attr,
 #endif
 #endif
 #ifdef CONFIG_FREEZER

commit 1d0c6e593023ac5dafc2ea2b3f23d96f1c1f2fa2
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 30 10:22:14 2017 +0530

    PM / sleep: constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       3802     624      32    4458    116a kernel/power/main.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       3866     560      32    4458    116a kernel/power/main.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d401c21136d1..42bd800a6755 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -705,7 +705,7 @@ static struct attribute * g[] = {
 	NULL,
 };
 
-static struct attribute_group attr_group = {
+static const struct attribute_group attr_group = {
 	.attrs = g,
 };
 

commit 406e79385f3223d82272cf2be86bc95cd000a258
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 21 22:45:40 2016 +0100

    PM / sleep: System sleep state selection interface rework
    
    There are systems in which the platform doesn't support any special
    sleep states, so suspend-to-idle (PM_SUSPEND_FREEZE) is the only
    available system sleep state.  However, some user space frameworks
    only use the "mem" and (sometimes) "standby" sleep state labels, so
    the users of those systems need to modify user space in order to be
    able to use system suspend at all and that may be a pain in practice.
    
    Commit 0399d4db3edf (PM / sleep: Introduce command line argument for
    sleep state enumeration) attempted to address this problem by adding
    a command line argument to change the meaning of the "mem" string in
    /sys/power/state to make it trigger suspend-to-idle (instead of
    suspend-to-RAM).
    
    However, there also are systems in which the platform does support
    special sleep states, but suspend-to-idle is the preferred one anyway
    (it even may save more energy than the platform-provided sleep states
    in some cases) and the above commit doesn't help in those cases.
    
    For this reason, rework the system sleep state selection interface
    again (but preserve backwards compatibiliby).  Namely, add a new
    sysfs file, /sys/power/mem_sleep, that will control the system
    suspend mode triggered by writing "mem" to /sys/power/state (in
    analogy with what /sys/power/disk does for hibernation).  Make it
    select suspend-to-RAM ("deep" sleep) by default (if supported) and
    fall back to suspend-to-idle ("s2idle") otherwise and add a new
    command line argument, mem_sleep_default, allowing that default to
    be overridden if need be.
    
    At the same time, drop the relative_sleep_states command line
    argument that doesn't make sense any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 281a697fd458..d401c21136d1 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -78,6 +78,78 @@ static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 power_attr(pm_async);
 
+#ifdef CONFIG_SUSPEND
+static ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	char *s = buf;
+	suspend_state_t i;
+
+	for (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)
+		if (mem_sleep_states[i]) {
+			const char *label = mem_sleep_states[i];
+
+			if (mem_sleep_current == i)
+				s += sprintf(s, "[%s] ", label);
+			else
+				s += sprintf(s, "%s ", label);
+		}
+
+	/* Convert the last space to a newline if needed. */
+	if (s != buf)
+		*(s-1) = '\n';
+
+	return (s - buf);
+}
+
+static suspend_state_t decode_suspend_state(const char *buf, size_t n)
+{
+	suspend_state_t state;
+	char *p;
+	int len;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	for (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {
+		const char *label = mem_sleep_states[state];
+
+		if (label && len == strlen(label) && !strncmp(buf, label, len))
+			return state;
+	}
+
+	return PM_SUSPEND_ON;
+}
+
+static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,
+			       const char *buf, size_t n)
+{
+	suspend_state_t state;
+	int error;
+
+	error = pm_autosleep_lock();
+	if (error)
+		return error;
+
+	if (pm_autosleep_state() > PM_SUSPEND_ON) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	state = decode_suspend_state(buf, n);
+	if (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)
+		mem_sleep_current = state;
+	else
+		error = -EINVAL;
+
+ out:
+	pm_autosleep_unlock();
+	return error ? error : n;
+}
+
+power_attr(mem_sleep);
+#endif /* CONFIG_SUSPEND */
+
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 
@@ -368,12 +440,16 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 	}
 
 	state = decode_state(buf, n);
-	if (state < PM_SUSPEND_MAX)
+	if (state < PM_SUSPEND_MAX) {
+		if (state == PM_SUSPEND_MEM)
+			state = mem_sleep_current;
+
 		error = pm_suspend(state);
-	else if (state == PM_SUSPEND_MAX)
+	} else if (state == PM_SUSPEND_MAX) {
 		error = hibernate();
-	else
+	} else {
 		error = -EINVAL;
+	}
 
  out:
 	pm_autosleep_unlock();
@@ -485,6 +561,9 @@ static ssize_t autosleep_store(struct kobject *kobj,
 	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
 		return -EINVAL;
 
+	if (state == PM_SUSPEND_MEM)
+		state = mem_sleep_current;
+
 	error = pm_autosleep_set_state(state);
 	return error ? error : n;
 }
@@ -602,6 +681,9 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,
 	&wakeup_count_attr.attr,
+#ifdef CONFIG_SUSPEND
+	&mem_sleep_attr.attr,
+#endif
 #ifdef CONFIG_PM_AUTOSLEEP
 	&autosleep_attr.attr,
 #endif

commit fa7fd6fa38e36d88bc9f2d0e45e5b9bd0387079f
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Fri Aug 19 14:41:00 2016 +0100

    PM / sleep: enable suspend-to-idle even without registered suspend_ops
    
    Suspend-to-idle (aka the "freeze" sleep state) is a system sleep state
    in which all of the processors enter deepest possible idle state and
    wait for interrupts right after suspending all the devices.
    
    There is no hard requirement for a platform to support and register
    platform specific suspend_ops to enter suspend-to-idle/freeze state.
    Only deeper system sleep states like PM_SUSPEND_STANDBY and
    PM_SUSPEND_MEM rely on such low level support/implementation.
    
    suspend-to-idle can be entered as along as all the devices can be
    suspended. This patch enables the support for suspend-to-idle even on
    systems that don't have any low level support for deeper system sleep
    states and/or don't register any platform specific suspend_ops.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 5ea50b1b7595..281a697fd458 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -644,6 +644,7 @@ static int __init pm_init(void)
 		return error;
 	hibernate_image_size_init();
 	hibernate_reserved_size_init();
+	pm_states_init();
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;

commit ea00f4f4f00cc2bc3b63ad512a4e6df3b20832b9
Author: Lianwei Wang <lianwei.wang@gmail.com>
Date:   Sun Jun 19 23:52:27 2016 -0700

    PM / sleep: make PM notifiers called symmetrically
    
    This makes pm notifier PREPARE/POST symmetrical: if PREPARE
    fails, we will only undo what ever happened on PREPARE.
    
    It fixes the unbalanced CPU hotplug enable in CPU PM notifier.
    
    Signed-off-by: Lianwei Wang <lianwei.wang@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 27946975eff0..5ea50b1b7595 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -38,12 +38,19 @@ int unregister_pm_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL_GPL(unregister_pm_notifier);
 
-int pm_notifier_call_chain(unsigned long val)
+int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)
 {
-	int ret = blocking_notifier_call_chain(&pm_chain_head, val, NULL);
+	int ret;
+
+	ret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,
+						nr_to_call, nr_calls);
 
 	return notifier_to_errno(ret);
 }
+int pm_notifier_call_chain(unsigned long val)
+{
+	return __pm_notifier_call_chain(val, -1, NULL);
+}
 
 /* If set, devices may be suspended and resumed asynchronously. */
 int pm_async_enabled = 1;

commit a1e9ca6967d68209c70e616a224efa89a6b86ca6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 2 03:09:16 2016 +0100

    PM / sleep: Add support for read-only sysfs attributes
    
    Some sysfs attributes in /sys/power/ should really be read-only,
    so add support for that, convert those attributes to read-only
    and drop the stub .show() routines from them.
    
    Original-by: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b2dd4d999900..27946975eff0 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -280,13 +280,7 @@ static ssize_t pm_wakeup_irq_show(struct kobject *kobj,
 	return pm_wakeup_irq ? sprintf(buf, "%u\n", pm_wakeup_irq) : -ENODATA;
 }
 
-static ssize_t pm_wakeup_irq_store(struct kobject *kobj,
-					struct kobj_attribute *attr,
-					const char *buf, size_t n)
-{
-	return -EINVAL;
-}
-power_attr(pm_wakeup_irq);
+power_attr_ro(pm_wakeup_irq);
 
 #else /* !CONFIG_PM_SLEEP_DEBUG */
 static inline void pm_print_times_init(void) {}
@@ -564,14 +558,7 @@ static ssize_t pm_trace_dev_match_show(struct kobject *kobj,
 	return show_trace_dev_match(buf, PAGE_SIZE);
 }
 
-static ssize_t
-pm_trace_dev_match_store(struct kobject *kobj, struct kobj_attribute *attr,
-			 const char *buf, size_t n)
-{
-	return -EINVAL;
-}
-
-power_attr(pm_trace_dev_match);
+power_attr_ro(pm_trace_dev_match);
 
 #endif /* CONFIG_PM_TRACE */
 

commit a6f5f0dd4e21191ce35030dd4d6421e1cca10ee4
Author: Alexandra Yates <alexandra.yates@linux.intel.com>
Date:   Tue Sep 15 10:32:46 2015 -0700

    PM / sleep: Report interrupt that caused system wakeup
    
    Add a sysfs attribute, /sys/power/pm_wakeup_irq, reporting the IRQ
    number of the first wakeup interrupt (that is, the first interrupt
    from an IRQ line armed for system wakeup) seen by the kernel during
    the most recent system suspend/resume cycle.
    
    This feature will be useful for system wakeup diagnostics of
    spurious wakeup interrupts.
    
    Signed-off-by: Alexandra Yates <alexandra.yates@linux.intel.com>
    [ rjw: Fixed up pm_wakeup_irq definition ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 63d395b5df93..b2dd4d999900 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -272,6 +272,22 @@ static inline void pm_print_times_init(void)
 {
 	pm_print_times_enabled = !!initcall_debug;
 }
+
+static ssize_t pm_wakeup_irq_show(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	return pm_wakeup_irq ? sprintf(buf, "%u\n", pm_wakeup_irq) : -ENODATA;
+}
+
+static ssize_t pm_wakeup_irq_store(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t n)
+{
+	return -EINVAL;
+}
+power_attr(pm_wakeup_irq);
+
 #else /* !CONFIG_PM_SLEEP_DEBUG */
 static inline void pm_print_times_init(void) {}
 #endif /* CONFIG_PM_SLEEP_DEBUG */
@@ -604,6 +620,7 @@ static struct attribute * g[] = {
 #endif
 #ifdef CONFIG_PM_SLEEP_DEBUG
 	&pm_print_times_attr.attr,
+	&pm_wakeup_irq_attr.attr,
 #endif
 #endif
 #ifdef CONFIG_FREEZER

commit 819b1bb30d2fb1b3a2b8016e83f02dfc85ada1e0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 13 15:31:12 2015 +0200

    PM / sleep: Fix symbol name in a comment in kernel/power/main.c
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 86e8157a450f..63d395b5df93 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -272,7 +272,7 @@ static inline void pm_print_times_init(void)
 {
 	pm_print_times_enabled = !!initcall_debug;
 }
-#else /* !CONFIG_PP_SLEEP_DEBUG */
+#else /* !CONFIG_PM_SLEEP_DEBUG */
 static inline void pm_print_times_init(void) {}
 #endif /* CONFIG_PM_SLEEP_DEBUG */
 

commit 431d452af13720463dda498999b2e9a08729c03a
Author: Zhonghui Fu <zhonghui.fu@linux.intel.com>
Date:   Wed Mar 18 15:54:27 2015 +0100

    PM / sleep: add pm-trace support for suspending phase
    
    Occasionally, the system can't come back up after suspend/resume
    due to problems of device suspending phase. This patch make
    PM_TRACE infrastructure cover device suspending phase of
    suspend/resume process, and the information in RTC can tell
    developers which device suspending function make system hang.
    
    Signed-off-by: Zhonghui Fu <zhonghui.fu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 9a59d042ea84..86e8157a450f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -11,7 +11,7 @@
 #include <linux/export.h>
 #include <linux/kobject.h>
 #include <linux/string.h>
-#include <linux/resume-trace.h>
+#include <linux/pm-trace.h>
 #include <linux/workqueue.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>

commit bb1c095f7367bbf4983dbee32b2f83f59df3b310
Merge: e5e0243e362c 42062234cb7b 8490fdf923fc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 27 23:56:30 2014 +0200

    Merge branches 'pm-apm' and 'pm-sleep'
    
    * pm-apm:
      x86, apm: Remove unused variable
    
    * pm-sleep:
      PM / sleep: Move platform suspend operations to separate functions
      PM / sleep: Simplify sleep states sysfs interface code

commit 28cb5ef16e578bbca0a562b09f12c8c98ca92720
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:00:36 2014 +0200

    PM: Create PM workqueue if runtime PM is not configured too
    
    The PM workqueue is going to be used by ACPI PM notify handlers
    regardless of whether or not runtime PM is configured, so move
    it out of #ifdef CONFIG_PM_RUNTIME.
    
    Do that in three places in the ACPI device PM code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8e90f330f139..a18efed75fa7 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -615,7 +615,6 @@ static struct attribute_group attr_group = {
 	.attrs = g,
 };
 
-#ifdef CONFIG_PM_RUNTIME
 struct workqueue_struct *pm_wq;
 EXPORT_SYMBOL_GPL(pm_wq);
 
@@ -625,9 +624,6 @@ static int __init pm_start_workqueue(void)
 
 	return pm_wq ? 0 : -ENOMEM;
 }
-#else
-static inline int pm_start_workqueue(void) { return 0; }
-#endif
 
 static int __init pm_init(void)
 {

commit d431cbc53cb787a7f82d7d2fe0af65156db4d27a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 15 22:02:11 2014 +0200

    PM / sleep: Simplify sleep states sysfs interface code
    
    Simplify the sleep states sysfs interface /sys/power/state code by
    redefining pm_states[] as an array of pointers to constant strings
    such that only the entries corresponding to valid states are set.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8e90f330f139..d57f66a367dc 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -296,8 +296,8 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 	suspend_state_t i;
 
 	for (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)
-		if (pm_states[i].state)
-			s += sprintf(s,"%s ", pm_states[i].label);
+		if (pm_states[i])
+			s += sprintf(s,"%s ", pm_states[i]);
 
 #endif
 	if (hibernation_available())
@@ -311,8 +311,7 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 static suspend_state_t decode_state(const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
-	suspend_state_t state = PM_SUSPEND_MIN;
-	struct pm_sleep_state *s;
+	suspend_state_t state;
 #endif
 	char *p;
 	int len;
@@ -325,10 +324,12 @@ static suspend_state_t decode_state(const char *buf, size_t n)
 		return PM_SUSPEND_MAX;
 
 #ifdef CONFIG_SUSPEND
-	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++)
-		if (s->state && len == strlen(s->label)
-		    && !strncmp(buf, s->label, len))
-			return s->state;
+	for (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {
+		const char *label = pm_states[state];
+
+		if (label && len == strlen(label) && !strncmp(buf, label, len))
+			return state;
+	}
 #endif
 
 	return PM_SUSPEND_ON;
@@ -446,8 +447,8 @@ static ssize_t autosleep_show(struct kobject *kobj,
 
 #ifdef CONFIG_SUSPEND
 	if (state < PM_SUSPEND_MAX)
-		return sprintf(buf, "%s\n", pm_states[state].state ?
-					pm_states[state].label : "error");
+		return sprintf(buf, "%s\n", pm_states[state] ?
+					pm_states[state] : "error");
 #endif
 #ifdef CONFIG_HIBERNATION
 	return sprintf(buf, "disk\n");

commit a6e15a39048ec3229b9a53425f4384f55f6cc1b3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jun 13 13:30:35 2014 -0700

    PM / hibernate: introduce "nohibernate" boot parameter
    
    To support using kernel features that are not compatible with hibernation,
    this creates the "nohibernate" kernel boot parameter to disable both
    hibernation and resume. This allows hibernation support to be a boot-time
    choice instead of only a compile-time choice.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 573410d6647e..8e90f330f139 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -300,13 +300,11 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 			s += sprintf(s,"%s ", pm_states[i].label);
 
 #endif
-#ifdef CONFIG_HIBERNATION
-	s += sprintf(s, "%s\n", "disk");
-#else
+	if (hibernation_available())
+		s += sprintf(s, "disk ");
 	if (s != buf)
 		/* convert the last space to a newline */
 		*(s-1) = '\n';
-#endif
 	return (s - buf);
 }
 

commit 0399d4db3edf5c58b6ec7f672f089f5085e49ed5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 26 13:40:59 2014 +0200

    PM / sleep: Introduce command line argument for sleep state enumeration
    
    On some systems the platform doesn't support neither
    PM_SUSPEND_MEM nor PM_SUSPEND_STANDBY, so PM_SUSPEND_FREEZE is the
    only available system sleep state.  However, some user space frameworks
    only use the "mem" and (sometimes) "standby" sleep state labels, so
    the users of those systems need to modify user space in order to be
    able to use system suspend at all and that is not always possible.
    
    For this reason, add a new kernel command line argument,
    relative_sleep_states, allowing the users of those systems to change
    the way in which the kernel assigns labels to system sleep states.
    Namely, for relative_sleep_states=1, the "mem", "standby" and "freeze"
    labels will enumerate the available system sleem states from the
    deepest to the shallowest, respectively, so that "mem" is always
    present in /sys/power/state and the other state strings may or may
    not be presend depending on what is supported by the platform.
    
    Update system sleep states documentation to reflect this change.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 9f51f0ab3d86..573410d6647e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -279,14 +279,14 @@ static inline void pm_print_times_init(void) {}
 struct kobject *power_kobj;
 
 /**
- *	state - control system power state.
+ * state - control system sleep states.
  *
- *	show() returns what states are supported, which is hard-coded to
- *	'freeze' (Low-Power Idle), 'standby' (Power-On Suspend),
- *	'mem' (Suspend-to-RAM), and 'disk' (Suspend-to-Disk).
+ * show() returns available sleep state labels, which may be "mem", "standby",
+ * "freeze" and "disk" (hibernation).  See Documentation/power/states.txt for a
+ * description of what they mean.
  *
- *	store() accepts one of those strings, translates it into the
- *	proper enumerated value, and initiates a suspend transition.
+ * store() accepts one of those strings, translates it into the proper
+ * enumerated value, and initiates a suspend transition.
  */
 static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 			  char *buf)

commit 43e8317b0bba1d6eb85f38a4a233d82d7c20d732
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 26 13:40:53 2014 +0200

    PM / sleep: Use valid_state() for platform-dependent sleep states only
    
    Use the observation that, for platform-dependent sleep states
    (PM_SUSPEND_STANDBY, PM_SUSPEND_MEM), a given state is either
    always supported or always unsupported and store that information
    in pm_states[] instead of calling valid_state() every time we
    need to check it.
    
    Also do not use valid_state() for PM_SUSPEND_FREEZE, which is always
    valid, and move the pm_test_level validity check for PM_SUSPEND_FREEZE
    directly into enter_state().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8e818432253c..9f51f0ab3d86 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -296,7 +296,7 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 	suspend_state_t i;
 
 	for (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)
-		if (valid_state(i))
+		if (pm_states[i].state)
 			s += sprintf(s,"%s ", pm_states[i].label);
 
 #endif
@@ -328,8 +328,9 @@ static suspend_state_t decode_state(const char *buf, size_t n)
 
 #ifdef CONFIG_SUSPEND
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++)
-		if (len == strlen(s->label) && !strncmp(buf, s->label, len))
-			return state;
+		if (s->state && len == strlen(s->label)
+		    && !strncmp(buf, s->label, len))
+			return s->state;
 #endif
 
 	return PM_SUSPEND_ON;
@@ -447,7 +448,7 @@ static ssize_t autosleep_show(struct kobject *kobj,
 
 #ifdef CONFIG_SUSPEND
 	if (state < PM_SUSPEND_MAX)
-		return sprintf(buf, "%s\n", valid_state(state) ?
+		return sprintf(buf, "%s\n", pm_states[state].state ?
 					pm_states[state].label : "error");
 #endif
 #ifdef CONFIG_HIBERNATION

commit 27ddcc6596e50cb8f03d2e83248897667811d8f6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 26 13:40:47 2014 +0200

    PM / sleep: Add state field to pm_states[] entries
    
    To allow sleep states corresponding to the "mem", "standby" and
    "freeze" lables to be different from the pm_states[] indexes of
    those strings, introduce struct pm_sleep_state, consisting of
    a string label and a state number, and turn pm_states[] into an
    array of objects of that type.
    
    This modification should not lead to any functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6271bc4073ef..8e818432253c 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -293,12 +293,12 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 {
 	char *s = buf;
 #ifdef CONFIG_SUSPEND
-	int i;
+	suspend_state_t i;
+
+	for (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)
+		if (valid_state(i))
+			s += sprintf(s,"%s ", pm_states[i].label);
 
-	for (i = 0; i < PM_SUSPEND_MAX; i++) {
-		if (pm_states[i] && valid_state(i))
-			s += sprintf(s,"%s ", pm_states[i]);
-	}
 #endif
 #ifdef CONFIG_HIBERNATION
 	s += sprintf(s, "%s\n", "disk");
@@ -314,7 +314,7 @@ static suspend_state_t decode_state(const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
 	suspend_state_t state = PM_SUSPEND_MIN;
-	const char * const *s;
+	struct pm_sleep_state *s;
 #endif
 	char *p;
 	int len;
@@ -328,7 +328,7 @@ static suspend_state_t decode_state(const char *buf, size_t n)
 
 #ifdef CONFIG_SUSPEND
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++)
-		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
+		if (len == strlen(s->label) && !strncmp(buf, s->label, len))
 			return state;
 #endif
 
@@ -448,7 +448,7 @@ static ssize_t autosleep_show(struct kobject *kobj,
 #ifdef CONFIG_SUSPEND
 	if (state < PM_SUSPEND_MAX)
 		return sprintf(buf, "%s\n", valid_state(state) ?
-						pm_states[state] : "error");
+					pm_states[state].label : "error");
 #endif
 #ifdef CONFIG_HIBERNATION
 	return sprintf(buf, "disk\n");

commit af02b5fdb1fb3c5d5f8d71f7f84e4fb243e1ae31
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Mar 11 12:08:11 2014 +0100

    PM: Add missing "freeze" state
    
    Fix descriptions of /sys/power/state in the documentation and in
    a code comment.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 1d1bf630e6e9..6271bc4073ef 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -282,8 +282,8 @@ struct kobject *power_kobj;
  *	state - control system power state.
  *
  *	show() returns what states are supported, which is hard-coded to
- *	'standby' (Power-On Suspend), 'mem' (Suspend-to-RAM), and
- *	'disk' (Suspend-to-Disk).
+ *	'freeze' (Low-Power Idle), 'standby' (Power-On Suspend),
+ *	'mem' (Suspend-to-RAM), and 'disk' (Suspend-to-Disk).
  *
  *	store() accepts one of those strings, translates it into the
  *	proper enumerated value, and initiates a suspend transition.

commit 9dceefe483d7640ba0bbf3e53d1db880e7469aba
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Wed Jun 26 16:27:35 2013 -0600

    PM / Sleep: Warn about system time after resume with pm_trace
    
    pm_trace uses the system's Real Time Clock (RTC) to save the magic
    number.  The reason for this is that the RTC is the only reliably
    available piece of hardware during resume operations where a value
    can be set that will survive a reboot.
    
    Consequence is that after a resume (even if it is successful) your
    system clock will have a value corresponding to the magic number
    instead of the correct date/time!  It is therefore advisable to use
    a program like ntp-date or rdate to reset the correct date/time from
    an external time source when using this trace option.
    
    There is no run-time message to warn users of the consequences of
    enabling pm_trace.  Adding a warning message to pm_trace_store()
    will serve as a reminder to users to set the system date and time
    after resume.
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0828070d38b4..1d1bf630e6e9 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -530,6 +530,10 @@ pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 	if (sscanf(buf, "%d", &val) == 1) {
 		pm_trace_enabled = !!val;
+		if (pm_trace_enabled) {
+			pr_warn("PM: Enabling pm_trace changes system date and time during resume.\n"
+				"PM: Correct system time has to be restored manually after resume.\n");
+		}
 		return n;
 	}
 	return -EINVAL;

commit bb177fedd348c92c2bea6adc9a2163ebff15272e
Author: Julius Werner <jwerner@chromium.org>
Date:   Wed Jun 12 12:55:22 2013 -0700

    PM / Sleep: Print last wakeup source on failed wakeup_count write
    
    Commit a938da06 introduced a useful little log message to tell
    users/debuggers which wakeup source aborted a suspend.  However,
    this message is only printed if the abort happens during the
    in-kernel suspend path (after writing /sys/power/state).
    
    The full specification of the /sys/power/wakeup_count facility
    allows user-space power managers to double-check if wakeups have
    already happened before it actually tries to suspend (e.g. while it
    was running user-space pre-suspend hooks), by writing the last known
    wakeup_count value to /sys/power/wakeup_count.  This patch changes
    the sysfs handler for that node to also print said log message if
    that write fails, so that we can figure out the offending wakeup
    source for both kinds of suspend aborts.
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d77663bfedeb..0828070d38b4 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -424,6 +424,8 @@ static ssize_t wakeup_count_store(struct kobject *kobj,
 	if (sscanf(buf, "%u", &val) == 1) {
 		if (pm_save_wakeup_count(val))
 			error = n;
+		else
+			pm_print_active_wakeup_sources();
 	}
 
  out:

commit 957d1282bb8c07e682e142b9237cd9fcb8348a0b
Author: Li Fei <fei.li@intel.com>
Date:   Fri Feb 1 08:56:03 2013 +0000

    suspend: enable freeze timeout configuration through sys
    
    At present, the value of timeout for freezing is 20s, which is
    meaningless in case that one thread is frozen with mutex locked
    and another thread is trying to lock the mutex, as this time of
    freezing will fail unavoidably.
    And if there is no new wakeup event registered, the system will
    waste at most 20s for such meaningless trying of freezing.
    
    With this patch, the value of timeout can be configured to smaller
    value, so such meaningless trying of freezing will be aborted in
    earlier time, and later freezing can be also triggered in earlier
    time. And more power will be saved.
    In normal case on mobile phone, it costs real little time to freeze
    processes. On some platform, it only costs about 20ms to freeze
    user space processes and 10ms to freeze kernel freezable threads.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Li Fei <fei.li@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b1c26a92ca9f..d77663bfedeb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -553,6 +553,30 @@ power_attr(pm_trace_dev_match);
 
 #endif /* CONFIG_PM_TRACE */
 
+#ifdef CONFIG_FREEZER
+static ssize_t pm_freeze_timeout_show(struct kobject *kobj,
+				      struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", freeze_timeout_msecs);
+}
+
+static ssize_t pm_freeze_timeout_store(struct kobject *kobj,
+				       struct kobj_attribute *attr,
+				       const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	freeze_timeout_msecs = val;
+	return n;
+}
+
+power_attr(pm_freeze_timeout);
+
+#endif	/* CONFIG_FREEZER*/
+
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
@@ -575,6 +599,9 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_SLEEP_DEBUG
 	&pm_print_times_attr.attr,
 #endif
+#endif
+#ifdef CONFIG_FREEZER
+	&pm_freeze_timeout_attr.attr,
 #endif
 	NULL,
 };

commit 7e73c5ae6e7991a6c01f6d096ff8afaef4458c36
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Feb 6 13:00:36 2013 +0100

    PM: Introduce suspend state PM_SUSPEND_FREEZE
    
    PM_SUSPEND_FREEZE state is a general state that
    does not need any platform specific support, it equals
    frozen processes + suspended devices + idle processors.
    
    Compared with PM_SUSPEND_MEMORY,
    PM_SUSPEND_FREEZE saves less power
    because the system is still in a running state.
    PM_SUSPEND_FREEZE has less resume latency because it does not
    touch BIOS, and the processors are in idle state.
    
    Compared with RTPM/idle,
    PM_SUSPEND_FREEZE saves more power as
    1. the processor has longer sleep time because processes are frozen.
       The deeper c-state the processor supports, more power saving we can get.
    2. PM_SUSPEND_FREEZE uses system suspend code path, thus we can get
       more power saving from the devices that does not have good RTPM support.
    
    This state is useful for
    1) platforms that do not have STR, or have a broken STR.
    2) platforms that have an extremely low power idle state,
       which can be used to replace STR.
    
    The following describes how PM_SUSPEND_FREEZE state works.
    1. echo freeze > /sys/power/state
    2. the processes are frozen.
    3. all the devices are suspended.
    4. all the processors are blocked by a wait queue
    5. all the processors idles and enters (Deep) c-state.
    6. an interrupt fires.
    7. a processor is woken up and handles the irq.
    8. if it is a general event,
       a) the irq handler runs and quites.
       b) goto step 4.
    9. if it is a real wake event, say, power button pressing, keyboard touch, mouse moving,
       a) the irq handler runs and activate the wakeup source
       b) wakeup_source_activate() notifies the wait queue.
       c) system starts resuming from PM_SUSPEND_FREEZE
    10. all the devices are resumed.
    11. all the processes are unfrozen.
    12. system is back to working.
    
    Known Issue:
    The wakeup of this new PM_SUSPEND_FREEZE state may behave differently
    from the previous suspend state.
    Take ACPI platform for example, there are some GPEs that only enabled
    when the system is in sleep state, to wake the system backk from S3/S4.
    But we are not touching these GPEs during transition to PM_SUSPEND_FREEZE.
    This means we may lose some wake event.
    But on the other hand, as we do not disable all the Interrupts during
    PM_SUSPEND_FREEZE, we may get some extra "wakeup" Interrupts, that are
    not available for S3/S4.
    
    The patches has been tested on an old Sony laptop, and here are the results:
    
    Average Power:
    1. RPTM/idle for half an hour:
       14.8W, 12.6W, 14.1W, 12.5W, 14.4W, 13.2W, 12.9W
    2. Freeze for half an hour:
       11W, 10.4W, 9.4W, 11.3W 10.5W
    3. RTPM/idle for three hours:
       11.6W
    4. Freeze for three hours:
       10W
    5. Suspend to Memory:
       0.5~0.9W
    
    Average Resume Latency:
    1. RTPM/idle with a black screen: (From pressing keyboard to screen back)
       Less than 0.2s
    2. Freeze: (From pressing power button to screen back)
       2.50s
    3. Suspend to Memory: (From pressing power button to screen back)
       4.33s
    
    >From the results, we can see that all the platforms should benefit from
    this patch, even if it does not have Low Power S0.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 1c16f9167de1..b1c26a92ca9f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -313,7 +313,7 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 static suspend_state_t decode_state(const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
-	suspend_state_t state = PM_SUSPEND_STANDBY;
+	suspend_state_t state = PM_SUSPEND_MIN;
 	const char * const *s;
 #endif
 	char *p;

commit 883ee4f79d636d13f24c2479c66d42cb652b0239
Author: Daniel Walter <sahne@0x90.at>
Date:   Tue Oct 23 01:20:35 2012 +0200

    PM / sysfs: replace strict_str* with kstrto*
    
    Replace strict_strtoul() with kstrtoul() in pm_async_store() and
    pm_qos_power_write().
    
    [rjw: Modified subject and changelog.]
    
    Signed-off-by: Daniel Walter <sahne@0x90.at>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f458238109cc..1c16f9167de1 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -59,7 +59,7 @@ static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,
 {
 	unsigned long val;
 
-	if (strict_strtoul(buf, 10, &val))
+	if (kstrtoul(buf, 10, &val))
 		return -EINVAL;
 
 	if (val > 1)

commit b2df1d4f8b95d9d1e3f064cef02fc5c5116b05cf
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 21 00:19:33 2012 +0200

    PM / Sleep: Separate printing suspend times from initcall_debug
    
    Change the behavior of the newly introduced
    /sys/power/pm_print_times attribute so that its initial value
    depends on initcall_debug, but setting it to 0 will cause device
    suspend/resume times not to be printed, even if initcall_debug has
    been set.  This way, the people who use initcall_debug for reasons
    other than PM debugging will be able to switch the suspend/resume
    times printing off, if need be.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7beb3fb3670b..f458238109cc 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -132,38 +132,6 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_test);
-
-/*
- * pm_print_times: print time taken by devices to suspend and resume.
- *
- * show() returns whether printing of suspend and resume times is enabled.
- * store() accepts 0 or 1.  0 disables printing and 1 enables it.
- */
-int pm_print_times_enabled;
-
-static ssize_t pm_print_times_show(struct kobject *kobj,
-				   struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", pm_print_times_enabled);
-}
-
-static ssize_t pm_print_times_store(struct kobject *kobj,
-				    struct kobj_attribute *attr,
-				    const char *buf, size_t n)
-{
-	unsigned long val;
-
-	if (kstrtoul(buf, 10, &val))
-		return -EINVAL;
-
-	if (val > 1)
-		return -EINVAL;
-
-	pm_print_times_enabled = val;
-	return n;
-}
-
-power_attr(pm_print_times);
 #endif /* CONFIG_PM_DEBUG */
 
 #ifdef CONFIG_DEBUG_FS
@@ -267,6 +235,47 @@ late_initcall(pm_debugfs_init);
 
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_SLEEP_DEBUG
+/*
+ * pm_print_times: print time taken by devices to suspend and resume.
+ *
+ * show() returns whether printing of suspend and resume times is enabled.
+ * store() accepts 0 or 1.  0 disables printing and 1 enables it.
+ */
+bool pm_print_times_enabled;
+
+static ssize_t pm_print_times_show(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pm_print_times_enabled);
+}
+
+static ssize_t pm_print_times_store(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 1)
+		return -EINVAL;
+
+	pm_print_times_enabled = !!val;
+	return n;
+}
+
+power_attr(pm_print_times);
+
+static inline void pm_print_times_init(void)
+{
+	pm_print_times_enabled = !!initcall_debug;
+}
+#else /* !CONFIG_PP_SLEEP_DEBUG */
+static inline void pm_print_times_init(void) {}
+#endif /* CONFIG_PM_SLEEP_DEBUG */
+
 struct kobject *power_kobj;
 
 /**
@@ -562,6 +571,8 @@ static struct attribute * g[] = {
 #endif
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
+#endif
+#ifdef CONFIG_PM_SLEEP_DEBUG
 	&pm_print_times_attr.attr,
 #endif
 #endif
@@ -599,6 +610,7 @@ static int __init pm_init(void)
 	error = sysfs_create_group(power_kobj, &attr_group);
 	if (error)
 		return error;
+	pm_print_times_init();
 	return pm_autosleep_init();
 }
 

commit 4b7760ba0dd3319f66886ab2335a0fbecdbc808a
Author: Sameer Nanda <snanda@chromium.org>
Date:   Tue Jun 19 22:23:33 2012 +0200

    PM / Sleep: add knob for printing device resume times
    
    Added a new knob called /sys/power/pm_print_times. Setting it to 1
    enables printing of time taken by devices to suspend and resume.
    Setting it to 0 disables this printing (unless overridden by
    initcall_debug kernel command line option).
    
    Signed-off-by: Sameer Nanda <snanda@chromium.org>
    Acked-by: Greg KH <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 428f8a034e96..7beb3fb3670b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -132,6 +132,38 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_test);
+
+/*
+ * pm_print_times: print time taken by devices to suspend and resume.
+ *
+ * show() returns whether printing of suspend and resume times is enabled.
+ * store() accepts 0 or 1.  0 disables printing and 1 enables it.
+ */
+int pm_print_times_enabled;
+
+static ssize_t pm_print_times_show(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pm_print_times_enabled);
+}
+
+static ssize_t pm_print_times_store(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 1)
+		return -EINVAL;
+
+	pm_print_times_enabled = val;
+	return n;
+}
+
+power_attr(pm_print_times);
 #endif /* CONFIG_PM_DEBUG */
 
 #ifdef CONFIG_DEBUG_FS
@@ -530,6 +562,7 @@ static struct attribute * g[] = {
 #endif
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
+	&pm_print_times_attr.attr,
 #endif
 #endif
 	NULL,

commit 040e5bf65e1ee66266bc314c5965518a7c21ff36
Author: Arve Hjnnevg <arve@android.com>
Date:   Fri May 4 00:14:21 2012 +0200

    PM / Sleep: Fix a mistake in a conditional in autosleep_store()
    
    The condition check in autosleep_store() is incorrect and prevents
    /sys/power/autosleep from working as advertised.  Fix that.
    
    [rjw: Added the changelog.]
    
    Signed-off-by: Arve Hjnnevg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 54ec071de337..428f8a034e96 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -422,7 +422,7 @@ static ssize_t autosleep_store(struct kobject *kobj,
 	int error;
 
 	if (state == PM_SUSPEND_ON
-	    && !(strncmp(buf, "off", 3) && strncmp(buf, "off\n", 4)))
+	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
 		return -EINVAL;
 
 	error = pm_autosleep_set_state(state);

commit b86ff9820fd5df69295273b9aa68e58786ffc23f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:42 2012 +0200

    PM / Sleep: Add user space interface for manipulating wakeup sources, v3
    
    Android allows user space to manipulate wakelocks using two
    sysfs file located in /sys/power/, wake_lock and wake_unlock.
    Writing a wakelock name and optionally a timeout to the wake_lock
    file causes the wakelock whose name was written to be acquired (it
    is created before is necessary), optionally with the given timeout.
    Writing the name of a wakelock to wake_unlock causes that wakelock
    to be released.
    
    Implement an analogous interface for user space using wakeup sources.
    Add the /sys/power/wake_lock and /sys/power/wake_unlock files
    allowing user space to create, activate and deactivate wakeup
    sources, such that writing a name and optionally a timeout to
    wake_lock causes the wakeup source of that name to be activated,
    optionally with the given timeout.  If that wakeup source doesn't
    exist, it will be created and then activated.  Writing a name to
    wake_unlock causes the wakeup source of that name, if there is one,
    to be deactivated.  Wakeup sources created with the help of
    wake_lock that haven't been used for more than 5 minutes are garbage
    collected and destroyed.  Moreover, there can be only WL_NUMBER_LIMIT
    wakeup sources created with the help of wake_lock present at a time.
    
    The data type used to track wakeup sources created by user space is
    called "struct wakelock" to indicate the origins of this feature.
    
    This version of the patch includes an rbtree manipulation fix from John Stultz.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index ba6a5645952d..54ec071de337 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -431,6 +431,43 @@ static ssize_t autosleep_store(struct kobject *kobj,
 
 power_attr(autosleep);
 #endif /* CONFIG_PM_AUTOSLEEP */
+
+#ifdef CONFIG_PM_WAKELOCKS
+static ssize_t wake_lock_show(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf)
+{
+	return pm_show_wakelocks(buf, true);
+}
+
+static ssize_t wake_lock_store(struct kobject *kobj,
+			       struct kobj_attribute *attr,
+			       const char *buf, size_t n)
+{
+	int error = pm_wake_lock(buf);
+	return error ? error : n;
+}
+
+power_attr(wake_lock);
+
+static ssize_t wake_unlock_show(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				char *buf)
+{
+	return pm_show_wakelocks(buf, false);
+}
+
+static ssize_t wake_unlock_store(struct kobject *kobj,
+				 struct kobj_attribute *attr,
+				 const char *buf, size_t n)
+{
+	int error = pm_wake_unlock(buf);
+	return error ? error : n;
+}
+
+power_attr(wake_unlock);
+
+#endif /* CONFIG_PM_WAKELOCKS */
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_PM_TRACE
@@ -487,6 +524,10 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_AUTOSLEEP
 	&autosleep_attr.attr,
 #endif
+#ifdef CONFIG_PM_WAKELOCKS
+	&wake_lock_attr.attr,
+	&wake_unlock_attr.attr,
+#endif
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
 #endif

commit 7483b4a4d9abf9dcf1ffe6e805ead2847ec3264e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:22 2012 +0200

    PM / Sleep: Implement opportunistic sleep, v2
    
    Introduce a mechanism by which the kernel can trigger global
    transitions to a sleep state chosen by user space if there are no
    active wakeup sources.
    
    It consists of a new sysfs attribute, /sys/power/autosleep, that
    can be written one of the strings returned by reads from
    /sys/power/state, an ordered workqueue and a work item carrying out
    the "suspend" operations.  If a string representing the system's
    sleep state is written to /sys/power/autosleep, the work item
    triggering transitions to that state is queued up and it requeues
    itself after every execution until user space writes "off" to
    /sys/power/autosleep.
    
    That work item enables the detection of wakeup events using the
    functions already defined in drivers/base/power/wakeup.c (with one
    small modification) and calls either pm_suspend(), or hibernate() to
    put the system into a sleep state.  If a wakeup event is reported
    while the transition is in progress, it will abort the transition and
    the "system suspend" work item will be queued up again.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 1c12581f1c62..ba6a5645952d 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -269,8 +269,7 @@ static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 	return (s - buf);
 }
 
-static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
-			   const char *buf, size_t n)
+static suspend_state_t decode_state(const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
 	suspend_state_t state = PM_SUSPEND_STANDBY;
@@ -278,27 +277,48 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 #endif
 	char *p;
 	int len;
-	int error = -EINVAL;
 
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
 
-	/* First, check if we are requested to hibernate */
-	if (len == 4 && !strncmp(buf, "disk", len)) {
-		error = hibernate();
-		goto Exit;
-	}
+	/* Check hibernation first. */
+	if (len == 4 && !strncmp(buf, "disk", len))
+		return PM_SUSPEND_MAX;
 
 #ifdef CONFIG_SUSPEND
-	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
-		if (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {
-			error = pm_suspend(state);
-			break;
-		}
-	}
+	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++)
+		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
+			return state;
 #endif
 
- Exit:
+	return PM_SUSPEND_ON;
+}
+
+static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t n)
+{
+	suspend_state_t state;
+	int error;
+
+	error = pm_autosleep_lock();
+	if (error)
+		return error;
+
+	if (pm_autosleep_state() > PM_SUSPEND_ON) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	state = decode_state(buf, n);
+	if (state < PM_SUSPEND_MAX)
+		error = pm_suspend(state);
+	else if (state == PM_SUSPEND_MAX)
+		error = hibernate();
+	else
+		error = -EINVAL;
+
+ out:
+	pm_autosleep_unlock();
 	return error ? error : n;
 }
 
@@ -339,7 +359,8 @@ static ssize_t wakeup_count_show(struct kobject *kobj,
 {
 	unsigned int val;
 
-	return pm_get_wakeup_count(&val) ? sprintf(buf, "%u\n", val) : -EINTR;
+	return pm_get_wakeup_count(&val, true) ?
+		sprintf(buf, "%u\n", val) : -EINTR;
 }
 
 static ssize_t wakeup_count_store(struct kobject *kobj,
@@ -347,15 +368,69 @@ static ssize_t wakeup_count_store(struct kobject *kobj,
 				const char *buf, size_t n)
 {
 	unsigned int val;
+	int error;
+
+	error = pm_autosleep_lock();
+	if (error)
+		return error;
 
+	if (pm_autosleep_state() > PM_SUSPEND_ON) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	error = -EINVAL;
 	if (sscanf(buf, "%u", &val) == 1) {
 		if (pm_save_wakeup_count(val))
-			return n;
+			error = n;
 	}
-	return -EINVAL;
+
+ out:
+	pm_autosleep_unlock();
+	return error;
 }
 
 power_attr(wakeup_count);
+
+#ifdef CONFIG_PM_AUTOSLEEP
+static ssize_t autosleep_show(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf)
+{
+	suspend_state_t state = pm_autosleep_state();
+
+	if (state == PM_SUSPEND_ON)
+		return sprintf(buf, "off\n");
+
+#ifdef CONFIG_SUSPEND
+	if (state < PM_SUSPEND_MAX)
+		return sprintf(buf, "%s\n", valid_state(state) ?
+						pm_states[state] : "error");
+#endif
+#ifdef CONFIG_HIBERNATION
+	return sprintf(buf, "disk\n");
+#else
+	return sprintf(buf, "error");
+#endif
+}
+
+static ssize_t autosleep_store(struct kobject *kobj,
+			       struct kobj_attribute *attr,
+			       const char *buf, size_t n)
+{
+	suspend_state_t state = decode_state(buf, n);
+	int error;
+
+	if (state == PM_SUSPEND_ON
+	    && !(strncmp(buf, "off", 3) && strncmp(buf, "off\n", 4)))
+		return -EINVAL;
+
+	error = pm_autosleep_set_state(state);
+	return error ? error : n;
+}
+
+power_attr(autosleep);
+#endif /* CONFIG_PM_AUTOSLEEP */
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_PM_TRACE
@@ -409,6 +484,9 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,
 	&wakeup_count_attr.attr,
+#ifdef CONFIG_PM_AUTOSLEEP
+	&autosleep_attr.attr,
+#endif
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
 #endif
@@ -444,7 +522,10 @@ static int __init pm_init(void)
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;
-	return sysfs_create_group(power_kobj, &attr_group);
+	error = sysfs_create_group(power_kobj, &attr_group);
+	if (error)
+		return error;
+	return pm_autosleep_init();
 }
 
 core_initcall(pm_init);

commit 93e1ee43a72b11e1b50aab87046c131a836a4456
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:24 2012 +0100

    PM / Sleep: Make enter_state() in kernel/power/suspend.c static
    
    The enter_state() function in kernel/power/suspend.c should be
    static and state_store() in kernel/power/suspend.c should call
    pm_suspend() instead of it, so make that happen (which also reduces
    code duplication related to suspend statistics).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b1e324878d5f..1c12581f1c62 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -291,12 +291,10 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 #ifdef CONFIG_SUSPEND
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
-		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
+		if (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {
+			error = pm_suspend(state);
 			break;
-	}
-	if (state < PM_SUSPEND_MAX && *s) {
-		error = enter_state(state);
-		suspend_stats_update(error);
+		}
 	}
 #endif
 

commit 8916e3702ec422b57cc549fbae3986106292100f
Author: Marcos Paulo de Souza <marcos.mage@gmail.com>
Date:   Sat Feb 4 22:26:13 2012 +0100

    PM / Suspend: Avoid code duplication in suspend statistics update
    
    The code
           if (error) {
                   suspend_stats.fail++;
                   dpm_save_failed_errno(error);
           } else
                   suspend_stats.success++;
    
    Appears in the kernel/power/main.c and kernel/power/suspend.c.
    
    This patch just creates a new function to avoid duplicated code.
    
    Suggested-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Marcos Paulo de Souza <marcos.mage@gmail.com>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8c5014a4e052..b1e324878d5f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -296,11 +296,7 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 	}
 	if (state < PM_SUSPEND_MAX && *s) {
 		error = enter_state(state);
-		if (error) {
-			suspend_stats.fail++;
-			dpm_save_failed_errno(error);
-		} else
-			suspend_stats.success++;
+		suspend_stats_update(error);
 	}
 #endif
 

commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:38:29 2012 +0100

    PM / Sleep: Introduce "late suspend" and "early resume" of devices
    
    The current device suspend/resume phases during system-wide power
    transitions appear to be insufficient for some platforms that want
    to use the same callback routines for saving device states and
    related operations during runtime suspend/resume as well as during
    system suspend/resume.  In principle, they could point their
    .suspend_noirq() and .resume_noirq() to the same callback routines
    as their .runtime_suspend() and .runtime_resume(), respectively,
    but at least some of them require device interrupts to be enabled
    while the code in those routines is running.
    
    It also makes sense to have device suspend-resume callbacks that will
    be executed with runtime PM disabled and with device interrupts
    enabled in case someone needs to run some special code in that
    context during system-wide power transitions.
    
    Apart from this, .suspend_noirq() and .resume_noirq() were introduced
    as a workaround for drivers using shared interrupts and failing to
    prevent their interrupt handlers from accessing suspended hardware.
    It appears to be better not to use them for other porposes, or we may
    have to deal with some serious confusion (which seems to be happening
    already).
    
    For the above reasons, introduce new device suspend/resume phases,
    "late suspend" and "early resume" (and analogously for hibernation)
    whose callback will be executed with runtime PM disabled and with
    device interrupts enabled and whose callback pointers generally may
    point to runtime suspend/resume routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 9824b41e5a18..8c5014a4e052 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -165,16 +165,20 @@ static int suspend_stats_show(struct seq_file *s, void *unused)
 	last_errno %= REC_FAILED_NUM;
 	last_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;
 	last_step %= REC_FAILED_NUM;
-	seq_printf(s, "%s: %d\n%s: %d\n%s: %d\n%s: %d\n"
-			"%s: %d\n%s: %d\n%s: %d\n%s: %d\n",
+	seq_printf(s, "%s: %d\n%s: %d\n%s: %d\n%s: %d\n%s: %d\n"
+			"%s: %d\n%s: %d\n%s: %d\n%s: %d\n%s: %d\n",
 			"success", suspend_stats.success,
 			"fail", suspend_stats.fail,
 			"failed_freeze", suspend_stats.failed_freeze,
 			"failed_prepare", suspend_stats.failed_prepare,
 			"failed_suspend", suspend_stats.failed_suspend,
+			"failed_suspend_late",
+				suspend_stats.failed_suspend_late,
 			"failed_suspend_noirq",
 				suspend_stats.failed_suspend_noirq,
 			"failed_resume", suspend_stats.failed_resume,
+			"failed_resume_early",
+				suspend_stats.failed_resume_early,
 			"failed_resume_noirq",
 				suspend_stats.failed_resume_noirq);
 	seq_printf(s,	"failures:\n  last_failed_dev:\t%-s\n",

commit bcda53faf5814c0c6025a0bd47108adfcbe9f199
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Wed Dec 7 22:29:54 2011 +0100

    PM / Sleep: Replace mutex_[un]lock(&pm_mutex) with [un]lock_system_sleep()
    
    Using [un]lock_system_sleep() is safer than directly using mutex_[un]lock()
    on 'pm_mutex', since the latter could lead to freezing failures. Hence convert
    all the present users of mutex_[un]lock(&pm_mutex) to use these safe APIs
    instead.
    
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7d36fb31e4c4..9824b41e5a18 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -116,7 +116,7 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
 
-	mutex_lock(&pm_mutex);
+	lock_system_sleep();
 
 	level = TEST_FIRST;
 	for (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)
@@ -126,7 +126,7 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 			break;
 		}
 
-	mutex_unlock(&pm_mutex);
+	unlock_system_sleep();
 
 	return error ? error : n;
 }

commit 341d4166175e9b7911444f5a33b1c9efb8f15c85
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Sat Nov 19 14:39:01 2011 +0100

    PM: Fix indentation and remove extraneous whitespaces in kernel/power/main.c
    
    Lack of proper indentation of the goto statement decreases the readability
    of code significantly. In fact, this made me look twice at the code to check
    whether it really does what it should be doing. Fix this.
    
    And in the same file, there are some extra whitespaces. Get rid of them too.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 36e0f0903c32..7d36fb31e4c4 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
- * 
+ *
  * This file is released under the GPLv2
  *
  */
@@ -240,7 +240,7 @@ struct kobject *power_kobj;
  *	'standby' (Power-On Suspend), 'mem' (Suspend-to-RAM), and
  *	'disk' (Suspend-to-Disk).
  *
- *	store() accepts one of those strings, translates it into the 
+ *	store() accepts one of those strings, translates it into the
  *	proper enumerated value, and initiates a suspend transition.
  */
 static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
@@ -282,7 +282,7 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 	/* First, check if we are requested to hibernate */
 	if (len == 4 && !strncmp(buf, "disk", len)) {
 		error = hibernate();
-  goto Exit;
+		goto Exit;
 	}
 
 #ifdef CONFIG_SUSPEND

commit 501a708f18ef911328ffd39f39738b8a7862aa8e
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Sat Nov 19 14:37:57 2011 +0100

    PM / Suspend: Fix bug in suspend statistics update
    
    After commit 2a77c46de1e3dace73745015635ebbc648eca69c
    (PM / Suspend: Add statistics debugfs file for suspend to RAM)
    a missing pair of braces inside the state_store() function causes even
    invalid arguments to suspend to be wrongly treated as failed suspend
    attempts. Fix this.
    
    [rjw: Put the hash/subject of the buggy commit into the changelog.]
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 71f49fe4377e..36e0f0903c32 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -290,13 +290,14 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
 			break;
 	}
-	if (state < PM_SUSPEND_MAX && *s)
+	if (state < PM_SUSPEND_MAX && *s) {
 		error = enter_state(state);
 		if (error) {
 			suspend_stats.fail++;
 			dpm_save_failed_errno(error);
 		} else
 			suspend_stats.success++;
+	}
 #endif
 
  Exit:

commit 6e5fdeedca610df600aabc393c4b1f44b128fe49
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu May 26 16:00:52 2011 -0400

    kernel: Fix files explicitly needing EXPORT_SYMBOL infrastructure
    
    These files were getting <linux/module.h> via an implicit non-obvious
    path, but we want to crush those out of existence since they cost
    time during compiles of processing thousands of lines of headers
    for no reason.  Give them the lightweight header that just contains
    the EXPORT_SYMBOL infrastructure.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index a52e88425a31..71f49fe4377e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -8,6 +8,7 @@
  *
  */
 
+#include <linux/export.h>
 #include <linux/kobject.h>
 #include <linux/string.h>
 #include <linux/resume-trace.h>

commit ca123102f69fb260221502ade9bbc069290fae84
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 11 22:38:12 2011 +0200

    PM: Fix build issue in main.c for CONFIG_PM_SLEEP unset
    
    Suspend statistics should depend on CONFIG_PM_SLEEP, so make that
    happen.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 2757acba8e8a..a52e88425a31 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -133,8 +133,6 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 power_attr(pm_test);
 #endif /* CONFIG_PM_DEBUG */
 
-#endif /* CONFIG_PM_SLEEP */
-
 #ifdef CONFIG_DEBUG_FS
 static char *suspend_step_name(enum suspend_stat_step step)
 {
@@ -230,6 +228,8 @@ static int __init pm_debugfs_init(void)
 late_initcall(pm_debugfs_init);
 #endif /* CONFIG_DEBUG_FS */
 
+#endif /* CONFIG_PM_SLEEP */
+
 struct kobject *power_kobj;
 
 /**

commit 2a77c46de1e3dace73745015635ebbc648eca69c
Author: ShuoX Liu <shuox.liu@intel.com>
Date:   Wed Aug 10 23:01:26 2011 +0200

    PM / Suspend: Add statistics debugfs file for suspend to RAM
    
    Record S3 failure time about each reason and the latest two failed
    devices' names in S3 progress.
    We can check it through 'suspend_stats' entry in debugfs.
    
    The motivation of the patch:
    
    We are enabling power features on Medfield. Comparing with PC/notebook,
    a mobile enters/exits suspend-2-ram (we call it s3 on Medfield) far
    more frequently. If it can't enter suspend-2-ram in time, the power
    might be used up soon.
    
    We often find sometimes, a device suspend fails. Then, system retries
    s3 over and over again. As display is off, testers and developers
    don't know what happens.
    
    Some testers and developers complain they don't know if system
    tries suspend-2-ram, and what device fails to suspend. They need
    such info for a quick check. The patch adds suspend_stats under
    debugfs for users to check suspend to RAM statistics quickly.
    
    If not using this patch, we have other methods to get info about
    what device fails. One is to turn on  CONFIG_PM_DEBUG, but users
    would get too much info and testers need recompile the system.
    
    In addition, dynamic debug is another good tool to dump debug info.
    But it still doesn't match our utilization scenario closely.
    1) user need write a user space parser to process the syslog output;
    2) Our testing scenario is we leave the mobile for at least hours.
       Then, check its status. No serial console available during the
       testing. One is because console would be suspended, and the other
       is serial console connecting with spi or HSU devices would consume
       power. These devices are powered off at suspend-2-ram.
    
    Signed-off-by: ShuoX Liu <shuox.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6c601f871964..2757acba8e8a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -12,6 +12,8 @@
 #include <linux/string.h>
 #include <linux/resume-trace.h>
 #include <linux/workqueue.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
 
 #include "power.h"
 
@@ -133,6 +135,101 @@ power_attr(pm_test);
 
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_DEBUG_FS
+static char *suspend_step_name(enum suspend_stat_step step)
+{
+	switch (step) {
+	case SUSPEND_FREEZE:
+		return "freeze";
+	case SUSPEND_PREPARE:
+		return "prepare";
+	case SUSPEND_SUSPEND:
+		return "suspend";
+	case SUSPEND_SUSPEND_NOIRQ:
+		return "suspend_noirq";
+	case SUSPEND_RESUME_NOIRQ:
+		return "resume_noirq";
+	case SUSPEND_RESUME:
+		return "resume";
+	default:
+		return "";
+	}
+}
+
+static int suspend_stats_show(struct seq_file *s, void *unused)
+{
+	int i, index, last_dev, last_errno, last_step;
+
+	last_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;
+	last_dev %= REC_FAILED_NUM;
+	last_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;
+	last_errno %= REC_FAILED_NUM;
+	last_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;
+	last_step %= REC_FAILED_NUM;
+	seq_printf(s, "%s: %d\n%s: %d\n%s: %d\n%s: %d\n"
+			"%s: %d\n%s: %d\n%s: %d\n%s: %d\n",
+			"success", suspend_stats.success,
+			"fail", suspend_stats.fail,
+			"failed_freeze", suspend_stats.failed_freeze,
+			"failed_prepare", suspend_stats.failed_prepare,
+			"failed_suspend", suspend_stats.failed_suspend,
+			"failed_suspend_noirq",
+				suspend_stats.failed_suspend_noirq,
+			"failed_resume", suspend_stats.failed_resume,
+			"failed_resume_noirq",
+				suspend_stats.failed_resume_noirq);
+	seq_printf(s,	"failures:\n  last_failed_dev:\t%-s\n",
+			suspend_stats.failed_devs[last_dev]);
+	for (i = 1; i < REC_FAILED_NUM; i++) {
+		index = last_dev + REC_FAILED_NUM - i;
+		index %= REC_FAILED_NUM;
+		seq_printf(s, "\t\t\t%-s\n",
+			suspend_stats.failed_devs[index]);
+	}
+	seq_printf(s,	"  last_failed_errno:\t%-d\n",
+			suspend_stats.errno[last_errno]);
+	for (i = 1; i < REC_FAILED_NUM; i++) {
+		index = last_errno + REC_FAILED_NUM - i;
+		index %= REC_FAILED_NUM;
+		seq_printf(s, "\t\t\t%-d\n",
+			suspend_stats.errno[index]);
+	}
+	seq_printf(s,	"  last_failed_step:\t%-s\n",
+			suspend_step_name(
+				suspend_stats.failed_steps[last_step]));
+	for (i = 1; i < REC_FAILED_NUM; i++) {
+		index = last_step + REC_FAILED_NUM - i;
+		index %= REC_FAILED_NUM;
+		seq_printf(s, "\t\t\t%-s\n",
+			suspend_step_name(
+				suspend_stats.failed_steps[index]));
+	}
+
+	return 0;
+}
+
+static int suspend_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, suspend_stats_show, NULL);
+}
+
+static const struct file_operations suspend_stats_operations = {
+	.open           = suspend_stats_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int __init pm_debugfs_init(void)
+{
+	debugfs_create_file("suspend_stats", S_IFREG | S_IRUGO,
+			NULL, NULL, &suspend_stats_operations);
+	return 0;
+}
+
+late_initcall(pm_debugfs_init);
+#endif /* CONFIG_DEBUG_FS */
+
 struct kobject *power_kobj;
 
 /**
@@ -194,6 +291,11 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 	}
 	if (state < PM_SUSPEND_MAX && *s)
 		error = enter_state(state);
+		if (error) {
+			suspend_stats.fail++;
+			dpm_save_failed_errno(error);
+		} else
+			suspend_stats.success++;
 #endif
 
  Exit:

commit f0c077a8b7f9dce590c760a7b2f3c417dffa52d1
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Fri Jul 8 20:53:36 2011 +0200

    PM: Improve error code of pm_notifier_call_chain()
    
    This enables pm_notifier_call_chain() to get the actual error code
    in the callback rather than always assume -EINVAL by converting all
    PM notifier calls to return encapsulate error code with
    notifier_from_errno().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 2981af4ce7cb..6c601f871964 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -37,8 +37,9 @@ EXPORT_SYMBOL_GPL(unregister_pm_notifier);
 
 int pm_notifier_call_chain(unsigned long val)
 {
-	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
-			== NOTIFY_BAD) ? -EINVAL : 0;
+	int ret = blocking_notifier_call_chain(&pm_chain_head, val, NULL);
+
+	return notifier_to_errno(ret);
 }
 
 /* If set, devices may be suspended and resumed asynchronously. */

commit ddeb648708108091a641adad0a438ec4fd8bf190
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 15 11:38:48 2011 +0200

    PM / Hibernate: Add sysfs knob to control size of memory for drivers
    
    Martin reports that on his system hibernation occasionally fails due
    to the lack of memory, because the radeon driver apparently allocates
    too much of it during the device freeze stage.  It turns out that the
    amount of memory allocated by radeon during hibernation (and
    presumably during system suspend too) depends on the utilization of
    the GPU (e.g. hibernating while there are two KDE 4 sessions with
    compositing enabled causes radeon to allocate more memory than for
    one KDE 4 session).
    
    In principle it should be possible to use image_size to make the
    memory preallocation mechanism free enough memory for the radeon
    driver, but in practice it is not easy to guess the right value
    because of the way the preallocation code uses image_size.  For this
    reason, it seems reasonable to allow users to control the amount of
    memory reserved for driver allocations made after the hibernate
    preallocation, which currently is constant and amounts to 1 MB.
    
    Introduce a new sysfs file, /sys/power/reserved_size, whose value
    will be used as the amount of memory to reserve for the
    post-preallocation reservations made by device drivers, in bytes.
    For backwards compatibility, set its default (and initial) value to
    the currently used number (1 MB).
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=34102
    Reported-and-tested-by: Martin Steigerwald <Martin@Lichtvoll.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index de9aef8742f4..2981af4ce7cb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -337,6 +337,7 @@ static int __init pm_init(void)
 	if (error)
 		return error;
 	hibernate_image_size_init();
+	hibernate_reserved_size_init();
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8eaba5f27b10..de9aef8742f4 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -224,7 +224,7 @@ power_attr(state);
  * writing to 'state'.  It first should read from 'wakeup_count' and store
  * the read value.  Then, after carrying out its own preparations for the system
  * transition to a sleep state, it should write the stored value to
- * 'wakeup_count'.  If that fails, at least one wakeup event has occured since
+ * 'wakeup_count'.  If that fails, at least one wakeup event has occurred since
  * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it
  * is allowed to write to 'state', but the transition will be aborted if there
  * are any wakeup events detected after 'wakeup_count' was written to.

commit 6831c6edc7b272a08dd2a6c71bb183a48fe98ae6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 15 21:22:24 2011 +0100

    PM: Drop pm_flags that is not necessary
    
    The variable pm_flags is used to prevent APM from being enabled
    along with ACPI, which would lead to problems.  However, acpi_init()
    is always called before apm_init() and after acpi_init() has
    returned, it is known whether or not ACPI will be used.  Namely, if
    acpi_disabled is not set after acpi_init() has returned, this means
    that ACPI is enabled.  Thus, it is sufficient to check acpi_disabled
    in apm_init() to prevent APM from being enabled in parallel with
    ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b5405af48ddb..8eaba5f27b10 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -19,19 +19,6 @@ DEFINE_MUTEX(pm_mutex);
 
 #ifdef CONFIG_PM_SLEEP
 
-unsigned int pm_flags;
-EXPORT_SYMBOL(pm_flags);
-
-bool pm_apm_enabled(void)
-{
-	return !!(pm_flags & PM_APM);
-}
-
-void pm_set_acpi_flag(void)
-{
-	pm_flags |= PM_ACPI;
-}
-
 /* Routines for PM-transition notifications */
 
 static BLOCKING_NOTIFIER_HEAD(pm_chain_head);

commit cd51e61cf4e8b220da37dc35e9c2dc2dc258b4de
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 11 00:04:52 2011 +0100

    PM / ACPI: Remove references to pm_flags from bus.c
    
    If direct references to pm_flags are removed from drivers/acpi/bus.c,
    CONFIG_ACPI will not need to depend on CONFIG_PM any more.  Make that
    happen.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 701853042c28..b5405af48ddb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -17,10 +17,20 @@
 
 DEFINE_MUTEX(pm_mutex);
 
+#ifdef CONFIG_PM_SLEEP
+
 unsigned int pm_flags;
 EXPORT_SYMBOL(pm_flags);
 
-#ifdef CONFIG_PM_SLEEP
+bool pm_apm_enabled(void)
+{
+	return !!(pm_flags & PM_APM);
+}
+
+void pm_set_acpi_flag(void)
+{
+	pm_flags |= PM_ACPI;
+}
 
 /* Routines for PM-transition notifications */
 

commit 58a69cb47ec6991bf006a3e5d202e8571b0327a4
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 16 09:25:31 2011 +0100

    workqueue, freezer: unify spelling of 'freeze' + 'able' to 'freezable'
    
    There are two spellings in use for 'freeze' + 'able' - 'freezable' and
    'freezeable'.  The former is the more prominent one.  The latter is
    mostly used by workqueue and in a few other odd places.  Unify the
    spelling to 'freezable'.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7b5db6a8561e..701853042c28 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -326,7 +326,7 @@ EXPORT_SYMBOL_GPL(pm_wq);
 
 static int __init pm_start_workqueue(void)
 {
-	pm_wq = alloc_workqueue("pm", WQ_FREEZEABLE, 0);
+	pm_wq = alloc_workqueue("pm", WQ_FREEZABLE, 0);
 
 	return pm_wq ? 0 : -ENOMEM;
 }

commit d33ac60beaf2c7dee5cd90aba7c1eb385dd70937
Author: James Hogan <james@albanarts.com>
Date:   Tue Oct 12 00:00:25 2010 +0200

    PM: Add sysfs attr for rechecking dev hash from PM trace
    
    If the device which fails to resume is part of a loadable kernel module
    it won't be checked at startup against the magic number stored in the
    RTC.
    
    Add a read-only sysfs attribute /sys/power/pm_trace_dev_match which
    contains a list of newline separated devices (usually just the one)
    which currently match the last magic number. This allows the device
    which is failing to resume to be found after the modules are loaded
    again.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6b12a0cf4d9f..7b5db6a8561e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -281,12 +281,30 @@ pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_trace);
+
+static ssize_t pm_trace_dev_match_show(struct kobject *kobj,
+				       struct kobj_attribute *attr,
+				       char *buf)
+{
+	return show_trace_dev_match(buf, PAGE_SIZE);
+}
+
+static ssize_t
+pm_trace_dev_match_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t n)
+{
+	return -EINVAL;
+}
+
+power_attr(pm_trace_dev_match);
+
 #endif /* CONFIG_PM_TRACE */
 
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
 	&pm_trace_attr.attr,
+	&pm_trace_dev_match_attr.attr,
 #endif
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f06ad6eff37a..6b12a0cf4d9f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -237,18 +237,18 @@ static ssize_t wakeup_count_show(struct kobject *kobj,
 				struct kobj_attribute *attr,
 				char *buf)
 {
-	unsigned long val;
+	unsigned int val;
 
-	return pm_get_wakeup_count(&val) ? sprintf(buf, "%lu\n", val) : -EINTR;
+	return pm_get_wakeup_count(&val) ? sprintf(buf, "%u\n", val) : -EINTR;
 }
 
 static ssize_t wakeup_count_store(struct kobject *kobj,
 				struct kobj_attribute *attr,
 				const char *buf, size_t n)
 {
-	unsigned long val;
+	unsigned int val;
 
-	if (sscanf(buf, "%lu", &val) == 1) {
+	if (sscanf(buf, "%u", &val) == 1) {
 		if (pm_save_wakeup_count(val))
 			return n;
 	}

commit ac5c24ec1e983313ef0015258fba6f630e54e7cf
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 20 19:44:56 2010 +0200

    PM / Hibernate: Make default image size depend on total RAM size
    
    The default hibernation image size is currently hard coded and euqal
    to 500 MB, which is not a reasonable default on many contemporary
    systems.  Make it equal 2/5 of the total RAM size (this is slightly
    below the maximum, i.e. 1/2 of the total RAM size, and seems to be
    generally suitable).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: M. Vefa Bicakci <bicave@superonline.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0a28d4db3597..f06ad6eff37a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -321,6 +321,7 @@ static int __init pm_init(void)
 	int error = pm_start_workqueue();
 	if (error)
 		return error;
+	hibernate_image_size_init();
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;

commit bcb5ba8b4e8a5ae14b27351bdf499dd4c3bcc944
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 20 19:44:17 2010 +0200

    PM / Runtime: Use alloc_workqueue() for creating the PM workqueue
    
    Although we need the PM workqueue to be freezable, we don't need it
    to be singlethread.  Also, the number of concurrent work items
    running on a single CPU need not be constrained.  For these reasons
    use alloc_workqueue() directly, with suitable arguments, instead of
    create_freezeable_workqueue(), to create the runtime PM workqueue.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 62b0bc6e4983..0a28d4db3597 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -308,7 +308,7 @@ EXPORT_SYMBOL_GPL(pm_wq);
 
 static int __init pm_start_workqueue(void)
 {
-	pm_wq = create_freezeable_workqueue("pm");
+	pm_wq = alloc_workqueue("pm", WQ_FREEZEABLE, 0);
 
 	return pm_wq ? 0 : -ENOMEM;
 }

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b58800b21fc0..62b0bc6e4983 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -204,6 +204,60 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 power_attr(state);
 
+#ifdef CONFIG_PM_SLEEP
+/*
+ * The 'wakeup_count' attribute, along with the functions defined in
+ * drivers/base/power/wakeup.c, provides a means by which wakeup events can be
+ * handled in a non-racy way.
+ *
+ * If a wakeup event occurs when the system is in a sleep state, it simply is
+ * woken up.  In turn, if an event that would wake the system up from a sleep
+ * state occurs when it is undergoing a transition to that sleep state, the
+ * transition should be aborted.  Moreover, if such an event occurs when the
+ * system is in the working state, an attempt to start a transition to the
+ * given sleep state should fail during certain period after the detection of
+ * the event.  Using the 'state' attribute alone is not sufficient to satisfy
+ * these requirements, because a wakeup event may occur exactly when 'state'
+ * is being written to and may be delivered to user space right before it is
+ * frozen, so the event will remain only partially processed until the system is
+ * woken up by another event.  In particular, it won't cause the transition to
+ * a sleep state to be aborted.
+ *
+ * This difficulty may be overcome if user space uses 'wakeup_count' before
+ * writing to 'state'.  It first should read from 'wakeup_count' and store
+ * the read value.  Then, after carrying out its own preparations for the system
+ * transition to a sleep state, it should write the stored value to
+ * 'wakeup_count'.  If that fails, at least one wakeup event has occured since
+ * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it
+ * is allowed to write to 'state', but the transition will be aborted if there
+ * are any wakeup events detected after 'wakeup_count' was written to.
+ */
+
+static ssize_t wakeup_count_show(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				char *buf)
+{
+	unsigned long val;
+
+	return pm_get_wakeup_count(&val) ? sprintf(buf, "%lu\n", val) : -EINTR;
+}
+
+static ssize_t wakeup_count_store(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (sscanf(buf, "%lu", &val) == 1) {
+		if (pm_save_wakeup_count(val))
+			return n;
+	}
+	return -EINVAL;
+}
+
+power_attr(wakeup_count);
+#endif /* CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
@@ -236,6 +290,7 @@ static struct attribute * g[] = {
 #endif
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,
+	&wakeup_count_attr.attr,
 #ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
 #endif

commit 0e06b4a891c6a108412fe24b4500f499da2cf8a1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 23 22:25:15 2010 +0100

    PM: Add a switch for disabling/enabling asynchronous suspend/resume
    
    Add sysfs attribute /sys/power/pm_async allowing the user space to
    disable/enable asynchronous suspend/resume of devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0998c7139053..b58800b21fc0 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -44,6 +44,32 @@ int pm_notifier_call_chain(unsigned long val)
 			== NOTIFY_BAD) ? -EINVAL : 0;
 }
 
+/* If set, devices may be suspended and resumed asynchronously. */
+int pm_async_enabled = 1;
+
+static ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	return sprintf(buf, "%d\n", pm_async_enabled);
+}
+
+static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t n)
+{
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 1)
+		return -EINVAL;
+
+	pm_async_enabled = val;
+	return n;
+}
+
+power_attr(pm_async);
+
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 
@@ -208,8 +234,11 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_TRACE
 	&pm_trace_attr.attr,
 #endif
-#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_PM_DEBUG)
+#ifdef CONFIG_PM_SLEEP
+	&pm_async_attr.attr,
+#ifdef CONFIG_PM_DEBUG
 	&pm_test_attr.attr,
+#endif
 #endif
 	NULL,
 };

commit 7b199ca2025f4756daceec8802f07da636c524c9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Dec 3 20:22:21 2009 +0100

    PM / Runtime: Export the PM runtime workqueue
    
    This patch (as1306) exports the PM runtime workqueue for use by
    loadable modules.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 347d2cc88cd0..0998c7139053 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -220,6 +220,7 @@ static struct attribute_group attr_group = {
 
 #ifdef CONFIG_PM_RUNTIME
 struct workqueue_struct *pm_wq;
+EXPORT_SYMBOL_GPL(pm_wq);
 
 static int __init pm_start_workqueue(void)
 {

commit 5e928f77a09a07f9dd595bb8a489965d69a83458
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 18 23:38:32 2009 +0200

    PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
    
    Introduce a core framework for run-time power management of I/O
    devices.  Add device run-time PM fields to 'struct dev_pm_info'
    and device run-time PM callbacks to 'struct dev_pm_ops'.  Introduce
    a run-time PM workqueue and define some device run-time PM helper
    functions at the core level.  Document all these things.
    
    Special thanks to Alan Stern for his help with the design and
    multiple detailed reviews of the pereceding versions of this patch
    and to Magnus Damm for testing feedback.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@igel.co.jp>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f710e36930cc..347d2cc88cd0 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -11,6 +11,7 @@
 #include <linux/kobject.h>
 #include <linux/string.h>
 #include <linux/resume-trace.h>
+#include <linux/workqueue.h>
 
 #include "power.h"
 
@@ -217,8 +218,24 @@ static struct attribute_group attr_group = {
 	.attrs = g,
 };
 
+#ifdef CONFIG_PM_RUNTIME
+struct workqueue_struct *pm_wq;
+
+static int __init pm_start_workqueue(void)
+{
+	pm_wq = create_freezeable_workqueue("pm");
+
+	return pm_wq ? 0 : -ENOMEM;
+}
+#else
+static inline int pm_start_workqueue(void) { return 0; }
+#endif
+
 static int __init pm_init(void)
 {
+	int error = pm_start_workqueue();
+	if (error)
+		return error;
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;

commit a9d7052363a6e06bb623ed1876c56c7ca5b2c6d8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 10 01:27:12 2009 +0200

    PM: Separate suspend to RAM functionality from core
    
    Move the suspend to RAM and standby code from kernel/power/main.c
    to two separate files, kernel/power/suspend.c containing the basic
    functions and kernel/power/suspend_test.c containing the automatic
    suspend test facility based on the RTC clock alarm.
    
    There are no changes in functionality related to these modifications.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 2a19f347bd8a..f710e36930cc 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -8,20 +8,9 @@
  *
  */
 
-#include <linux/module.h>
-#include <linux/suspend.h>
 #include <linux/kobject.h>
 #include <linux/string.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/kmod.h>
-#include <linux/init.h>
-#include <linux/console.h>
-#include <linux/cpu.h>
 #include <linux/resume-trace.h>
-#include <linux/freezer.h>
-#include <linux/vmstat.h>
-#include <linux/syscalls.h>
 
 #include "power.h"
 
@@ -119,355 +108,6 @@ power_attr(pm_test);
 
 #endif /* CONFIG_PM_SLEEP */
 
-#ifdef CONFIG_SUSPEND
-
-static int suspend_test(int level)
-{
-#ifdef CONFIG_PM_DEBUG
-	if (pm_test_level == level) {
-		printk(KERN_INFO "suspend debug: Waiting for 5 seconds.\n");
-		mdelay(5000);
-		return 1;
-	}
-#endif /* !CONFIG_PM_DEBUG */
-	return 0;
-}
-
-#ifdef CONFIG_PM_TEST_SUSPEND
-
-/*
- * We test the system suspend code by setting an RTC wakealarm a short
- * time in the future, then suspending.  Suspending the devices won't
- * normally take long ... some systems only need a few milliseconds.
- *
- * The time it takes is system-specific though, so when we test this
- * during system bootup we allow a LOT of time.
- */
-#define TEST_SUSPEND_SECONDS	5
-
-static unsigned long suspend_test_start_time;
-
-static void suspend_test_start(void)
-{
-	/* FIXME Use better timebase than "jiffies", ideally a clocksource.
-	 * What we want is a hardware counter that will work correctly even
-	 * during the irqs-are-off stages of the suspend/resume cycle...
-	 */
-	suspend_test_start_time = jiffies;
-}
-
-static void suspend_test_finish(const char *label)
-{
-	long nj = jiffies - suspend_test_start_time;
-	unsigned msec;
-
-	msec = jiffies_to_msecs(abs(nj));
-	pr_info("PM: %s took %d.%03d seconds\n", label,
-			msec / 1000, msec % 1000);
-
-	/* Warning on suspend means the RTC alarm period needs to be
-	 * larger -- the system was sooo slooowwww to suspend that the
-	 * alarm (should have) fired before the system went to sleep!
-	 *
-	 * Warning on either suspend or resume also means the system
-	 * has some performance issues.  The stack dump of a WARN_ON
-	 * is more likely to get the right attention than a printk...
-	 */
-	WARN(msec > (TEST_SUSPEND_SECONDS * 1000), "Component: %s\n", label);
-}
-
-#else
-
-static void suspend_test_start(void)
-{
-}
-
-static void suspend_test_finish(const char *label)
-{
-}
-
-#endif
-
-static struct platform_suspend_ops *suspend_ops;
-
-/**
- *	suspend_set_ops - Set the global suspend method table.
- *	@ops:	Pointer to ops structure.
- */
-
-void suspend_set_ops(struct platform_suspend_ops *ops)
-{
-	mutex_lock(&pm_mutex);
-	suspend_ops = ops;
-	mutex_unlock(&pm_mutex);
-}
-
-/**
- * suspend_valid_only_mem - generic memory-only valid callback
- *
- * Platform drivers that implement mem suspend only and only need
- * to check for that in their .valid callback can use this instead
- * of rolling their own .valid callback.
- */
-int suspend_valid_only_mem(suspend_state_t state)
-{
-	return state == PM_SUSPEND_MEM;
-}
-
-/**
- *	suspend_prepare - Do prep work before entering low-power state.
- *
- *	This is common code that is called for each state that we're entering.
- *	Run suspend notifiers, allocate a console and stop all processes.
- */
-static int suspend_prepare(void)
-{
-	int error;
-
-	if (!suspend_ops || !suspend_ops->enter)
-		return -EPERM;
-
-	pm_prepare_console();
-
-	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);
-	if (error)
-		goto Finish;
-
-	error = usermodehelper_disable();
-	if (error)
-		goto Finish;
-
-	error = suspend_freeze_processes();
-	if (!error)
-		return 0;
-
-	suspend_thaw_processes();
-	usermodehelper_enable();
- Finish:
-	pm_notifier_call_chain(PM_POST_SUSPEND);
-	pm_restore_console();
-	return error;
-}
-
-/* default implementation */
-void __attribute__ ((weak)) arch_suspend_disable_irqs(void)
-{
-	local_irq_disable();
-}
-
-/* default implementation */
-void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
-{
-	local_irq_enable();
-}
-
-/**
- *	suspend_enter - enter the desired system sleep state.
- *	@state:		state to enter
- *
- *	This function should be called after devices have been suspended.
- */
-static int suspend_enter(suspend_state_t state)
-{
-	int error;
-
-	if (suspend_ops->prepare) {
-		error = suspend_ops->prepare();
-		if (error)
-			return error;
-	}
-
-	error = dpm_suspend_noirq(PMSG_SUSPEND);
-	if (error) {
-		printk(KERN_ERR "PM: Some devices failed to power down\n");
-		goto Platfrom_finish;
-	}
-
-	if (suspend_ops->prepare_late) {
-		error = suspend_ops->prepare_late();
-		if (error)
-			goto Power_up_devices;
-	}
-
-	if (suspend_test(TEST_PLATFORM))
-		goto Platform_wake;
-
-	error = disable_nonboot_cpus();
-	if (error || suspend_test(TEST_CPUS))
-		goto Enable_cpus;
-
-	arch_suspend_disable_irqs();
-	BUG_ON(!irqs_disabled());
-
-	error = sysdev_suspend(PMSG_SUSPEND);
-	if (!error) {
-		if (!suspend_test(TEST_CORE))
-			error = suspend_ops->enter(state);
-		sysdev_resume();
-	}
-
-	arch_suspend_enable_irqs();
-	BUG_ON(irqs_disabled());
-
- Enable_cpus:
-	enable_nonboot_cpus();
-
- Platform_wake:
-	if (suspend_ops->wake)
-		suspend_ops->wake();
-
- Power_up_devices:
-	dpm_resume_noirq(PMSG_RESUME);
-
- Platfrom_finish:
-	if (suspend_ops->finish)
-		suspend_ops->finish();
-
-	return error;
-}
-
-/**
- *	suspend_devices_and_enter - suspend devices and enter the desired system
- *				    sleep state.
- *	@state:		  state to enter
- */
-int suspend_devices_and_enter(suspend_state_t state)
-{
-	int error;
-
-	if (!suspend_ops)
-		return -ENOSYS;
-
-	if (suspend_ops->begin) {
-		error = suspend_ops->begin(state);
-		if (error)
-			goto Close;
-	}
-	suspend_console();
-	suspend_test_start();
-	error = dpm_suspend_start(PMSG_SUSPEND);
-	if (error) {
-		printk(KERN_ERR "PM: Some devices failed to suspend\n");
-		goto Recover_platform;
-	}
-	suspend_test_finish("suspend devices");
-	if (suspend_test(TEST_DEVICES))
-		goto Recover_platform;
-
-	suspend_enter(state);
-
- Resume_devices:
-	suspend_test_start();
-	dpm_resume_end(PMSG_RESUME);
-	suspend_test_finish("resume devices");
-	resume_console();
- Close:
-	if (suspend_ops->end)
-		suspend_ops->end();
-	return error;
-
- Recover_platform:
-	if (suspend_ops->recover)
-		suspend_ops->recover();
-	goto Resume_devices;
-}
-
-/**
- *	suspend_finish - Do final work before exiting suspend sequence.
- *
- *	Call platform code to clean up, restart processes, and free the 
- *	console that we've allocated. This is not called for suspend-to-disk.
- */
-static void suspend_finish(void)
-{
-	suspend_thaw_processes();
-	usermodehelper_enable();
-	pm_notifier_call_chain(PM_POST_SUSPEND);
-	pm_restore_console();
-}
-
-
-
-
-static const char * const pm_states[PM_SUSPEND_MAX] = {
-	[PM_SUSPEND_STANDBY]	= "standby",
-	[PM_SUSPEND_MEM]	= "mem",
-};
-
-static inline int valid_state(suspend_state_t state)
-{
-	/* All states need lowlevel support and need to be valid
-	 * to the lowlevel implementation, no valid callback
-	 * implies that none are valid. */
-	if (!suspend_ops || !suspend_ops->valid || !suspend_ops->valid(state))
-		return 0;
-	return 1;
-}
-
-
-/**
- *	enter_state - Do common work of entering low-power state.
- *	@state:		pm_state structure for state we're entering.
- *
- *	Make sure we're the only ones trying to enter a sleep state. Fail
- *	if someone has beat us to it, since we don't want anything weird to
- *	happen when we wake up.
- *	Then, do the setup for suspend, enter the state, and cleaup (after
- *	we've woken up).
- */
-static int enter_state(suspend_state_t state)
-{
-	int error;
-
-	if (!valid_state(state))
-		return -ENODEV;
-
-	if (!mutex_trylock(&pm_mutex))
-		return -EBUSY;
-
-	printk(KERN_INFO "PM: Syncing filesystems ... ");
-	sys_sync();
-	printk("done.\n");
-
-	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
-	error = suspend_prepare();
-	if (error)
-		goto Unlock;
-
-	if (suspend_test(TEST_FREEZER))
-		goto Finish;
-
-	pr_debug("PM: Entering %s sleep\n", pm_states[state]);
-	error = suspend_devices_and_enter(state);
-
- Finish:
-	pr_debug("PM: Finishing wakeup.\n");
-	suspend_finish();
- Unlock:
-	mutex_unlock(&pm_mutex);
-	return error;
-}
-
-
-/**
- *	pm_suspend - Externally visible function for suspending system.
- *	@state:		Enumerated value of state to enter.
- *
- *	Determine whether or not value is within range, get state 
- *	structure, and enter (above).
- */
-
-int pm_suspend(suspend_state_t state)
-{
-	if (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX)
-		return enter_state(state);
-	return -EINVAL;
-}
-
-EXPORT_SYMBOL(pm_suspend);
-
-#endif /* CONFIG_SUSPEND */
-
 struct kobject *power_kobj;
 
 /**
@@ -480,7 +120,6 @@ struct kobject *power_kobj;
  *	store() accepts one of those strings, translates it into the 
  *	proper enumerated value, and initiates a suspend transition.
  */
-
 static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
 			  char *buf)
 {
@@ -578,7 +217,6 @@ static struct attribute_group attr_group = {
 	.attrs = g,
 };
 
-
 static int __init pm_init(void)
 {
 	power_kobj = kobject_create_and_add("power", NULL);
@@ -588,144 +226,3 @@ static int __init pm_init(void)
 }
 
 core_initcall(pm_init);
-
-
-#ifdef CONFIG_PM_TEST_SUSPEND
-
-#include <linux/rtc.h>
-
-/*
- * To test system suspend, we need a hands-off mechanism to resume the
- * system.  RTCs wake alarms are a common self-contained mechanism.
- */
-
-static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
-{
-	static char err_readtime[] __initdata =
-		KERN_ERR "PM: can't read %s time, err %d\n";
-	static char err_wakealarm [] __initdata =
-		KERN_ERR "PM: can't set %s wakealarm, err %d\n";
-	static char err_suspend[] __initdata =
-		KERN_ERR "PM: suspend test failed, error %d\n";
-	static char info_test[] __initdata =
-		KERN_INFO "PM: test RTC wakeup from '%s' suspend\n";
-
-	unsigned long		now;
-	struct rtc_wkalrm	alm;
-	int			status;
-
-	/* this may fail if the RTC hasn't been initialized */
-	status = rtc_read_time(rtc, &alm.time);
-	if (status < 0) {
-		printk(err_readtime, dev_name(&rtc->dev), status);
-		return;
-	}
-	rtc_tm_to_time(&alm.time, &now);
-
-	memset(&alm, 0, sizeof alm);
-	rtc_time_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);
-	alm.enabled = true;
-
-	status = rtc_set_alarm(rtc, &alm);
-	if (status < 0) {
-		printk(err_wakealarm, dev_name(&rtc->dev), status);
-		return;
-	}
-
-	if (state == PM_SUSPEND_MEM) {
-		printk(info_test, pm_states[state]);
-		status = pm_suspend(state);
-		if (status == -ENODEV)
-			state = PM_SUSPEND_STANDBY;
-	}
-	if (state == PM_SUSPEND_STANDBY) {
-		printk(info_test, pm_states[state]);
-		status = pm_suspend(state);
-	}
-	if (status < 0)
-		printk(err_suspend, status);
-
-	/* Some platforms can't detect that the alarm triggered the
-	 * wakeup, or (accordingly) disable it after it afterwards.
-	 * It's supposed to give oneshot behavior; cope.
-	 */
-	alm.enabled = false;
-	rtc_set_alarm(rtc, &alm);
-}
-
-static int __init has_wakealarm(struct device *dev, void *name_ptr)
-{
-	struct rtc_device *candidate = to_rtc_device(dev);
-
-	if (!candidate->ops->set_alarm)
-		return 0;
-	if (!device_may_wakeup(candidate->dev.parent))
-		return 0;
-
-	*(const char **)name_ptr = dev_name(dev);
-	return 1;
-}
-
-/*
- * Kernel options like "test_suspend=mem" force suspend/resume sanity tests
- * at startup time.  They're normally disabled, for faster boot and because
- * we can't know which states really work on this particular system.
- */
-static suspend_state_t test_state __initdata = PM_SUSPEND_ON;
-
-static char warn_bad_state[] __initdata =
-	KERN_WARNING "PM: can't test '%s' suspend state\n";
-
-static int __init setup_test_suspend(char *value)
-{
-	unsigned i;
-
-	/* "=mem" ==> "mem" */
-	value++;
-	for (i = 0; i < PM_SUSPEND_MAX; i++) {
-		if (!pm_states[i])
-			continue;
-		if (strcmp(pm_states[i], value) != 0)
-			continue;
-		test_state = (__force suspend_state_t) i;
-		return 0;
-	}
-	printk(warn_bad_state, value);
-	return 0;
-}
-__setup("test_suspend", setup_test_suspend);
-
-static int __init test_suspend(void)
-{
-	static char		warn_no_rtc[] __initdata =
-		KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n";
-
-	char			*pony = NULL;
-	struct rtc_device	*rtc = NULL;
-
-	/* PM is initialized by now; is that state testable? */
-	if (test_state == PM_SUSPEND_ON)
-		goto done;
-	if (!valid_state(test_state)) {
-		printk(warn_bad_state, pm_states[test_state]);
-		goto done;
-	}
-
-	/* RTCs have initialized by now too ... can we use one? */
-	class_find_device(rtc_class, NULL, &pony, has_wakealarm);
-	if (pony)
-		rtc = rtc_class_open(pony);
-	if (!rtc) {
-		printk(warn_no_rtc);
-		goto done;
-	}
-
-	/* go for it */
-	test_wakealarm(rtc, test_state);
-	rtc_class_close(rtc);
-done:
-	return 0;
-}
-late_initcall(test_suspend);
-
-#endif /* CONFIG_PM_TEST_SUSPEND */

commit c6f37f12197ac3bd2e5a35f2f0e195ae63d437de
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 24 22:16:31 2009 +0200

    PM/Suspend: Do not shrink memory before suspend
    
    Remove the shrinking of memory from the suspend-to-RAM code, where
    it is not really necessary.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@tuxonice.net>
    Acked-by: Wu Fengguang <fengguang.wu@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 46386b9f8dd1..2a19f347bd8a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -188,9 +188,6 @@ static void suspend_test_finish(const char *label)
 
 #endif
 
-/* This is just an arbitrary number */
-#define FREE_PAGE_NUMBER (100)
-
 static struct platform_suspend_ops *suspend_ops;
 
 /**
@@ -226,7 +223,6 @@ int suspend_valid_only_mem(suspend_state_t state)
 static int suspend_prepare(void)
 {
 	int error;
-	unsigned int free_pages;
 
 	if (!suspend_ops || !suspend_ops->enter)
 		return -EPERM;
@@ -241,24 +237,10 @@ static int suspend_prepare(void)
 	if (error)
 		goto Finish;
 
-	if (suspend_freeze_processes()) {
-		error = -EAGAIN;
-		goto Thaw;
-	}
-
-	free_pages = global_page_state(NR_FREE_PAGES);
-	if (free_pages < FREE_PAGE_NUMBER) {
-		pr_debug("PM: free some memory\n");
-		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
-		if (nr_free_pages() < FREE_PAGE_NUMBER) {
-			error = -ENOMEM;
-			printk(KERN_ERR "PM: No enough memory\n");
-		}
-	}
+	error = suspend_freeze_processes();
 	if (!error)
 		return 0;
 
- Thaw:
 	suspend_thaw_processes();
 	usermodehelper_enable();
  Finish:

commit d161630297a20802d01c55847bfcba85d2118a9f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun May 24 22:05:42 2009 +0200

    PM core: rename suspend and resume functions
    
    This patch (as1241) renames a bunch of functions in the PM core.
    Rather than go through a boring list of name changes, suffice it to
    say that in the end we have a bunch of pairs of functions:
    
            device_resume_noirq     dpm_resume_noirq
            device_resume           dpm_resume
            device_complete         dpm_complete
            device_suspend_noirq    dpm_suspend_noirq
            device_suspend          dpm_suspend
            device_prepare          dpm_prepare
    
    in which device_X does the X operation on a single device and dpm_X
    invokes device_X for all devices in the dpm_list.
    
    In addition, the old dpm_power_up and device_resume_noirq have been
    combined into a single function (dpm_resume_noirq).
    
    Lastly, dpm_suspend_start and dpm_resume_end are the renamed versions
    of the former top-level device_suspend and device_resume routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 2f6638ee03c0..46386b9f8dd1 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -295,7 +295,7 @@ static int suspend_enter(suspend_state_t state)
 			return error;
 	}
 
-	error = device_suspend_noirq(PMSG_SUSPEND);
+	error = dpm_suspend_noirq(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
 		goto Platfrom_finish;
@@ -335,7 +335,7 @@ static int suspend_enter(suspend_state_t state)
 		suspend_ops->wake();
 
  Power_up_devices:
-	device_resume_noirq(PMSG_RESUME);
+	dpm_resume_noirq(PMSG_RESUME);
 
  Platfrom_finish:
 	if (suspend_ops->finish)
@@ -363,7 +363,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 	}
 	suspend_console();
 	suspend_test_start();
-	error = device_suspend(PMSG_SUSPEND);
+	error = dpm_suspend_start(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to suspend\n");
 		goto Recover_platform;
@@ -376,7 +376,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 
  Resume_devices:
 	suspend_test_start();
-	device_resume(PMSG_RESUME);
+	dpm_resume_end(PMSG_RESUME);
 	suspend_test_finish("resume devices");
 	resume_console();
  Close:

commit e39a71ef80877f4e30d808af9acceec80f4d2f7c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri May 15 00:53:26 2009 +0200

    PM: Rename device_power_down/up()
    
    Rename the functions performing "_noirq" dev_pm_ops
    operations from device_power_down() and device_power_up()
    to device_suspend_noirq() and device_resume_noirq().
    
    The new function names are chosen to show that the functions
    are responsible for calling the _noirq() versions to finalize
    the suspend/resume operation. The current function names do
    not perform power down/up anymore so the names may be misleading.
    
    Global function renames:
    - device_power_down() -> device_suspend_noirq()
    - device_power_up() -> device_resume_noirq()
    
    Static function renames:
    - suspend_device_noirq() -> __device_suspend_noirq()
    - resume_device_noirq() -> __device_resume_noirq()
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 868028280d13..2f6638ee03c0 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -295,7 +295,7 @@ static int suspend_enter(suspend_state_t state)
 			return error;
 	}
 
-	error = device_power_down(PMSG_SUSPEND);
+	error = device_suspend_noirq(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
 		goto Platfrom_finish;
@@ -335,7 +335,7 @@ static int suspend_enter(suspend_state_t state)
 		suspend_ops->wake();
 
  Power_up_devices:
-	device_power_up(PMSG_RESUME);
+	device_resume_noirq(PMSG_RESUME);
 
  Platfrom_finish:
 	if (suspend_ops->finish)

commit 32bdfac5462d777f35b00838893c4f87baf23efe
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 24 21:15:07 2009 +0200

    PM: Do not hold dpm_list_mtx while disabling/enabling nonboot CPUs
    
    We shouldn't hold dpm_list_mtx while executing
    [disable|enable]_nonboot_cpus(), because theoretically this may lead
    to a deadlock as shown by the following example (provided by Johannes
    Berg):
    
    CPU 3       CPU 2                     CPU 1
                                          suspend/hibernate
                something:
                rtnl_lock()               device_pm_lock()
                                           -> mutex_lock(&dpm_list_mtx)
    
                mutex_lock(&dpm_list_mtx)
    
    linkwatch_work
     -> rtnl_lock()
                                          disable_nonboot_cpus()
                                           -> flush CPU 3 workqueue
    
    Fortunately, device drivers are supposed to stop any activities that
    might lead to the registration of new device objects way before
    disable_nonboot_cpus() is called, so it shouldn't be necessary to
    hold dpm_list_mtx over the entire late part of device suspend and
    early part of device resume.
    
    Thus, during the late suspend and the early resume of devices acquire
    dpm_list_mtx only when dpm_list is going to be traversed and release
    it right after that.
    
    This patch is reported to fix the regressions tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=13245.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Miles Lane <miles.lane@gmail.com>
    Tested-by: Ming Lei <tom.leiming@gmail.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f99ed6a75eac..868028280d13 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -289,12 +289,10 @@ static int suspend_enter(suspend_state_t state)
 {
 	int error;
 
-	device_pm_lock();
-
 	if (suspend_ops->prepare) {
 		error = suspend_ops->prepare();
 		if (error)
-			goto Done;
+			return error;
 	}
 
 	error = device_power_down(PMSG_SUSPEND);
@@ -343,9 +341,6 @@ static int suspend_enter(suspend_state_t state)
 	if (suspend_ops->finish)
 		suspend_ops->finish();
 
- Done:
-	device_pm_unlock();
-
 	return error;
 }
 

commit 6a7c7eaf71b636f197d73b381a2ab729ebdcfb2e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 19 20:08:42 2009 +0200

    PM/Suspend: Introduce two new platform callbacks to avoid breakage
    
    Commit 900af0d973856d6feb6fc088c2d0d3fde57707d3 (PM: Change suspend
    code ordering) changed the ordering of suspend code in such a way
    that the platform .prepare() callback is now executed after the
    device drivers' late suspend callbacks have run.  Unfortunately, this
    turns out to break ARM platforms that need to talk via I2C to power
    control devices during the .prepare() callback.
    
    For this reason introduce two new platform suspend callbacks,
    .prepare_late() and .wake(), that will be called just prior to
    disabling non-boot CPUs and right after bringing them back on line,
    respectively, and use them instead of .prepare() and .finish() for
    ACPI suspend.  Make the PM core execute the .prepare() and .finish()
    platform suspend callbacks where they were executed previously (that
    is, right after calling the regular suspend methods provided by
    device drivers and right before executing their regular resume
    methods, respectively).
    
    It is not necessary to make analogous changes to the hibernation
    code and data structures at the moment, because they are only used
    by ACPI platforms.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f172f41858bb..f99ed6a75eac 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -291,20 +291,26 @@ static int suspend_enter(suspend_state_t state)
 
 	device_pm_lock();
 
+	if (suspend_ops->prepare) {
+		error = suspend_ops->prepare();
+		if (error)
+			goto Done;
+	}
+
 	error = device_power_down(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
-		goto Done;
+		goto Platfrom_finish;
 	}
 
-	if (suspend_ops->prepare) {
-		error = suspend_ops->prepare();
+	if (suspend_ops->prepare_late) {
+		error = suspend_ops->prepare_late();
 		if (error)
 			goto Power_up_devices;
 	}
 
 	if (suspend_test(TEST_PLATFORM))
-		goto Platfrom_finish;
+		goto Platform_wake;
 
 	error = disable_nonboot_cpus();
 	if (error || suspend_test(TEST_CPUS))
@@ -326,13 +332,17 @@ static int suspend_enter(suspend_state_t state)
  Enable_cpus:
 	enable_nonboot_cpus();
 
- Platfrom_finish:
-	if (suspend_ops->finish)
-		suspend_ops->finish();
+ Platform_wake:
+	if (suspend_ops->wake)
+		suspend_ops->wake();
 
  Power_up_devices:
 	device_power_up(PMSG_RESUME);
 
+ Platfrom_finish:
+	if (suspend_ops->finish)
+		suspend_ops->finish();
+
  Done:
 	device_pm_unlock();
 

commit 900af0d973856d6feb6fc088c2d0d3fde57707d3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:34:15 2009 +0100

    PM: Change suspend code ordering
    
    Change the ordering of the suspend core code so that the platform
    "prepare" callback is executed and the nonboot CPUs are disabled
    after calling device drivers' "late suspend" methods.
    
    This change will allow us to rework the PCI PM core so that the power
    state of devices is changed in the "late" phase of suspend (and
    analogously in the "early" phase of resume), which in turn will allow
    us to avoid the race condition where a device using shared interrupts
    is put into a low power state with interrupts enabled and then an
    interrupt (for another device) comes in and confuses its driver.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f0a466736c01..f172f41858bb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -297,6 +297,19 @@ static int suspend_enter(suspend_state_t state)
 		goto Done;
 	}
 
+	if (suspend_ops->prepare) {
+		error = suspend_ops->prepare();
+		if (error)
+			goto Power_up_devices;
+	}
+
+	if (suspend_test(TEST_PLATFORM))
+		goto Platfrom_finish;
+
+	error = disable_nonboot_cpus();
+	if (error || suspend_test(TEST_CPUS))
+		goto Enable_cpus;
+
 	arch_suspend_disable_irqs();
 	BUG_ON(!irqs_disabled());
 
@@ -310,6 +323,14 @@ static int suspend_enter(suspend_state_t state)
 	arch_suspend_enable_irqs();
 	BUG_ON(irqs_disabled());
 
+ Enable_cpus:
+	enable_nonboot_cpus();
+
+ Platfrom_finish:
+	if (suspend_ops->finish)
+		suspend_ops->finish();
+
+ Power_up_devices:
 	device_power_up(PMSG_RESUME);
 
  Done:
@@ -346,23 +367,8 @@ int suspend_devices_and_enter(suspend_state_t state)
 	if (suspend_test(TEST_DEVICES))
 		goto Recover_platform;
 
-	if (suspend_ops->prepare) {
-		error = suspend_ops->prepare();
-		if (error)
-			goto Resume_devices;
-	}
-
-	if (suspend_test(TEST_PLATFORM))
-		goto Finish;
+	suspend_enter(state);
 
-	error = disable_nonboot_cpus();
-	if (!error && !suspend_test(TEST_CPUS))
-		suspend_enter(state);
-
-	enable_nonboot_cpus();
- Finish:
-	if (suspend_ops->finish)
-		suspend_ops->finish();
  Resume_devices:
 	suspend_test_start();
 	device_resume(PMSG_RESUME);

commit 2ed8d2b3a81bdbb0418301628ccdb008ac9f40b7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:34:06 2009 +0100

    PM: Rework handling of interrupts during suspend-resume
    
    Use the functions introduced in by the previous patch,
    suspend_device_irqs(), resume_device_irqs() and check_wakeup_irqs(),
    to rework the handling of interrupts during suspend (hibernation) and
    resume.  Namely, interrupts will only be disabled on the CPU right
    before suspending sysdevs, while device drivers will be prevented
    from receiving interrupts, with the help of the new helper function,
    before their "late" suspend callbacks run (and analogously during
    resume).
    
    In addition, since the device interrups are now disabled before the
    CPU has turned all interrupts off and the CPU will ACK the interrupts
    setting the IRQ_PENDING bit for them, check in sysdev_suspend() if
    any wake-up interrupts are pending and abort suspend if that's the
    case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index c9632f841f64..f0a466736c01 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -287,17 +287,19 @@ void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
  */
 static int suspend_enter(suspend_state_t state)
 {
-	int error = 0;
+	int error;
 
 	device_pm_lock();
-	arch_suspend_disable_irqs();
-	BUG_ON(!irqs_disabled());
 
-	if ((error = device_power_down(PMSG_SUSPEND))) {
+	error = device_power_down(PMSG_SUSPEND);
+	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
 		goto Done;
 	}
 
+	arch_suspend_disable_irqs();
+	BUG_ON(!irqs_disabled());
+
 	error = sysdev_suspend(PMSG_SUSPEND);
 	if (!error) {
 		if (!suspend_test(TEST_CORE))
@@ -305,11 +307,14 @@ static int suspend_enter(suspend_state_t state)
 		sysdev_resume();
 	}
 
-	device_power_up(PMSG_RESUME);
- Done:
 	arch_suspend_enable_irqs();
 	BUG_ON(irqs_disabled());
+
+	device_power_up(PMSG_RESUME);
+
+ Done:
 	device_pm_unlock();
+
 	return error;
 }
 

commit 770824bdc421ff58a64db608294323571c949f4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 22 18:38:50 2009 +0100

    PM: Split up sysdev_[suspend|resume] from device_power_[down|up]
    
    Move the sysdev_suspend/resume from the callee to the callers, with
    no real change in semantics, so that we can rework the disabling of
    interrupts during suspend/hibernation.
    
    This is based on an earlier patch from Linus.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b4d219016b6c..c9632f841f64 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -298,8 +298,12 @@ static int suspend_enter(suspend_state_t state)
 		goto Done;
 	}
 
-	if (!suspend_test(TEST_CORE))
-		error = suspend_ops->enter(state);
+	error = sysdev_suspend(PMSG_SUSPEND);
+	if (!error) {
+		if (!suspend_test(TEST_CORE))
+			error = suspend_ops->enter(state);
+		sysdev_resume();
+	}
 
 	device_power_up(PMSG_RESUME);
  Done:

commit 091d71e023557136e96f0e54f301497a3fc95dc3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 17 00:10:45 2009 +0100

    PM: Fix compilation warning in kernel/power/main.c
    
    Reorder the code in kernel/power/main.c to fix compilation warning
    triggered by unsetting CONFIG_SUSPEND.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 239988873971..b4d219016b6c 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -57,16 +57,6 @@ int pm_notifier_call_chain(unsigned long val)
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 
-static int suspend_test(int level)
-{
-	if (pm_test_level == level) {
-		printk(KERN_INFO "suspend debug: Waiting for 5 seconds.\n");
-		mdelay(5000);
-		return 1;
-	}
-	return 0;
-}
-
 static const char * const pm_tests[__TEST_AFTER_LAST] = {
 	[TEST_NONE] = "none",
 	[TEST_CORE] = "core",
@@ -125,14 +115,24 @@ static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_test);
-#else /* !CONFIG_PM_DEBUG */
-static inline int suspend_test(int level) { return 0; }
-#endif /* !CONFIG_PM_DEBUG */
+#endif /* CONFIG_PM_DEBUG */
 
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
 
+static int suspend_test(int level)
+{
+#ifdef CONFIG_PM_DEBUG
+	if (pm_test_level == level) {
+		printk(KERN_INFO "suspend debug: Waiting for 5 seconds.\n");
+		mdelay(5000);
+		return 1;
+	}
+#endif /* !CONFIG_PM_DEBUG */
+	return 0;
+}
+
 #ifdef CONFIG_PM_TEST_SUSPEND
 
 /*

commit 81ff86a11f54c9e266c6a6bc3ecd2c9a0f1e11cc
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:39 2009 -0800

    pm: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 613f16941b85..239988873971 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -615,7 +615,7 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 	/* this may fail if the RTC hasn't been initialized */
 	status = rtc_read_time(rtc, &alm.time);
 	if (status < 0) {
-		printk(err_readtime, rtc->dev.bus_id, status);
+		printk(err_readtime, dev_name(&rtc->dev), status);
 		return;
 	}
 	rtc_tm_to_time(&alm.time, &now);
@@ -626,7 +626,7 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 
 	status = rtc_set_alarm(rtc, &alm);
 	if (status < 0) {
-		printk(err_wakealarm, rtc->dev.bus_id, status);
+		printk(err_wakealarm, dev_name(&rtc->dev), status);
 		return;
 	}
 
@@ -660,7 +660,7 @@ static int __init has_wakealarm(struct device *dev, void *name_ptr)
 	if (!device_may_wakeup(candidate->dev.parent))
 		return 0;
 
-	*(char **)name_ptr = dev->bus_id;
+	*(const char **)name_ptr = dev_name(dev);
 	return 1;
 }
 

commit cbe2f5a6e84eebb98ab42fc5e58c3cd5b7767349
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Nov 23 10:37:12 2008 +0100

    tracing: allow tracing of suspend/resume & hibernation code again
    
    Impact: widen function-tracing to suspend+resume (and hibernation) sequences
    
    Now that the ftrace kernel thread is gone, we can allow tracing
    during suspend/resume again.
    
    So revert these two commits:
    
      f42ac38c5 "ftrace: disable tracing for suspend to ram"
      41108eb10 "ftrace: disable tracing for hibernation"
    
    This should be tested very carefully, as it could interact with
    altneratives instruction patching, etc.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b8f7ce9473e8..613f16941b85 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -22,7 +22,6 @@
 #include <linux/freezer.h>
 #include <linux/vmstat.h>
 #include <linux/syscalls.h>
-#include <linux/ftrace.h>
 
 #include "power.h"
 
@@ -317,7 +316,7 @@ static int suspend_enter(suspend_state_t state)
  */
 int suspend_devices_and_enter(suspend_state_t state)
 {
-	int error, ftrace_save;
+	int error;
 
 	if (!suspend_ops)
 		return -ENOSYS;
@@ -328,7 +327,6 @@ int suspend_devices_and_enter(suspend_state_t state)
 			goto Close;
 	}
 	suspend_console();
-	ftrace_save = __ftrace_enabled_save();
 	suspend_test_start();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
@@ -360,7 +358,6 @@ int suspend_devices_and_enter(suspend_state_t state)
 	suspend_test_start();
 	device_resume(PMSG_RESUME);
 	suspend_test_finish("resume devices");
-	__ftrace_enabled_restore(ftrace_save);
 	resume_console();
  Close:
 	if (suspend_ops->end)

commit a6a0c4ca7edb378a8a7332501f097089cb1051c4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Tue Nov 18 06:56:51 2008 -0800

    suspend: use WARN not WARN_ON to print the message
    
    By using WARN(), kerneloops.org can collect which component is causing
    the delay and make statistics about that. suspend_test_finish() is
    currently the number 2 item but unless we can collect who's causing
    it we're not going to be able to fix the hot topic ones..
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 19122cf6d827..b8f7ce9473e8 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -174,7 +174,7 @@ static void suspend_test_finish(const char *label)
 	 * has some performance issues.  The stack dump of a WARN_ON
 	 * is more likely to get the right attention than a printk...
 	 */
-	WARN_ON(msec > (TEST_SUSPEND_SECONDS * 1000));
+	WARN(msec > (TEST_SUSPEND_SECONDS * 1000), "Component: %s\n", label);
 }
 
 #else

commit 1bfcf1304ea79c46efc3724e548b13b4b442b418
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Oct 15 22:01:21 2008 -0700

    pm: rework disabling of user mode helpers during suspend/hibernation
    
    We currently use a PM notifier to disable user mode helpers before suspend
    and hibernation and to re-enable them during resume.  However, this is not
    an ideal solution, because if any drivers want to upload firmware into
    memory before suspend, they have to use a PM notifier for this purpose and
    there is no guarantee that the ordering of PM notifiers will be as
    expected (ie.  the notifier that disables user mode helpers has to be run
    after the driver's notifier used for uploading the firmware).
    
    For this reason, it seems better to move the disabling and enabling of
    user mode helpers to separate functions that will be called by the PM core
    as necessary.
    
    [akpm@linux-foundation.org: remove unneeded ifdefs]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 540b16b68565..19122cf6d827 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -14,6 +14,7 @@
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
+#include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/cpu.h>
@@ -237,6 +238,10 @@ static int suspend_prepare(void)
 	if (error)
 		goto Finish;
 
+	error = usermodehelper_disable();
+	if (error)
+		goto Finish;
+
 	if (suspend_freeze_processes()) {
 		error = -EAGAIN;
 		goto Thaw;
@@ -256,6 +261,7 @@ static int suspend_prepare(void)
 
  Thaw:
 	suspend_thaw_processes();
+	usermodehelper_enable();
  Finish:
 	pm_notifier_call_chain(PM_POST_SUSPEND);
 	pm_restore_console();
@@ -376,6 +382,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 static void suspend_finish(void)
 {
 	suspend_thaw_processes();
+	usermodehelper_enable();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
 	pm_restore_console();
 }

commit f42ac38c59e0a03d6da0c24a63fb211393f484b0
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Wed Aug 27 09:14:40 2008 -0400

    ftrace: disable tracing for suspend to ram
    
    I've been painstakingly debugging the issue with suspend to ram and
    ftraced. The 2.6.28 code does not have this issue, but since the mcount
    recording is not going to be in 27, this must be solved for the ftrace
    daemon version.
    
    The resume from suspend to ram would reboot because it was triple
    faulting. Debugging further, I found that calling the mcount function
    itself was not an issue, but it would fault when it incremented
    preempt_count. preempt_count is on the tasks info structure that is on the
    low memory address of the task's stack.  For some reason, it could not
    write to it. Resuming out of suspend to ram does quite a lot of funny
    tricks to get to work, so it is not surprising at all that simply doing a
    preempt_disable() would cause a fault.
    
    Thanks to Rafael for suggesting to add a "while (1);" to find the place in
    resuming that is causing the fault. I would place the loop somewhere in
    the code, compile and reboot and see if it would either reboot (hit the
    fault) or simply hang (hit the loop).  Doing this over and over again, I
    narrowed it down that it was happening in enable_nonboot_cpus.
    
    At this point, I found that it is easier to simply disable tracing around
    the suspend code, instead of searching for the particular function that
    can not handle doing a preempt_disable.
    
    This patch disables the tracer as it suspends and reenables it on resume.
    
    I tested this patch on my Laptop, and it can resume fine with the patch.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0b7476f5d2a6..540b16b68565 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -21,6 +21,7 @@
 #include <linux/freezer.h>
 #include <linux/vmstat.h>
 #include <linux/syscalls.h>
+#include <linux/ftrace.h>
 
 #include "power.h"
 
@@ -310,7 +311,7 @@ static int suspend_enter(suspend_state_t state)
  */
 int suspend_devices_and_enter(suspend_state_t state)
 {
-	int error;
+	int error, ftrace_save;
 
 	if (!suspend_ops)
 		return -ENOSYS;
@@ -321,6 +322,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 			goto Close;
 	}
 	suspend_console();
+	ftrace_save = __ftrace_enabled_save();
 	suspend_test_start();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
@@ -352,6 +354,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 	suspend_test_start();
 	device_resume(PMSG_RESUME);
 	suspend_test_finish("resume devices");
+	__ftrace_enabled_restore(ftrace_save);
 	resume_console();
  Close:
 	if (suspend_ops->end)

commit a2e2e3577c3ef2b5dbb866e97e612aae4adfa32f
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Fri Jul 25 19:44:38 2008 -0700

    pm selftest: rtc paranoia
    
    Cope with a quirk of some RTCs (notably ACPI ones) which aren't guaranteed
    to implement oneshot behavior when they woke the system from sleeep:
    forcibly disable the alarm, just in case.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 95bff23ecdaa..0b7476f5d2a6 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -635,6 +635,13 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 	}
 	if (status < 0)
 		printk(err_suspend, status);
+
+	/* Some platforms can't detect that the alarm triggered the
+	 * wakeup, or (accordingly) disable it after it afterwards.
+	 * It's supposed to give oneshot behavior; cope.
+	 */
+	alm.enabled = false;
+	rtc_set_alarm(rtc, &alm);
 }
 
 static int __init has_wakealarm(struct device *dev, void *name_ptr)

commit 77437fd4e61f87cc94d9314baa5cbf50e3ccdf54
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jul 23 21:28:33 2008 -0700

    pm: boot time suspend selftest
    
    Boot-time test for system suspend states (STR or standby).  The generic
    RTC framework triggers wakeup alarms, which are used to exit those states.
    
      - Measures some aspects of suspend time ... this uses "jiffies" until
        someone converts it to use a timebase that works properly even while
        timer IRQs are disabled.
    
      - Triggered by a command line parameter.  By default nothing even
        vaguely troublesome will happen, but "test_suspend=mem" will give
        you a brief STR test during system boot.  (Or you may need to use
        "test_suspend=standby" instead, if your hardware needs that.)
    
    This isn't without problems.  It fires early enough during boot that for
    example both PCMCIA and MMC stacks have misbehaved.  The workaround in
    those cases was to boot without such media cards inserted.
    
    [matthltc@us.ibm.com: fix compile failure in boot time suspend selftest]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Pavel Machek <pavel@suse.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3398f4651aa1..95bff23ecdaa 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -132,6 +132,61 @@ static inline int suspend_test(int level) { return 0; }
 
 #ifdef CONFIG_SUSPEND
 
+#ifdef CONFIG_PM_TEST_SUSPEND
+
+/*
+ * We test the system suspend code by setting an RTC wakealarm a short
+ * time in the future, then suspending.  Suspending the devices won't
+ * normally take long ... some systems only need a few milliseconds.
+ *
+ * The time it takes is system-specific though, so when we test this
+ * during system bootup we allow a LOT of time.
+ */
+#define TEST_SUSPEND_SECONDS	5
+
+static unsigned long suspend_test_start_time;
+
+static void suspend_test_start(void)
+{
+	/* FIXME Use better timebase than "jiffies", ideally a clocksource.
+	 * What we want is a hardware counter that will work correctly even
+	 * during the irqs-are-off stages of the suspend/resume cycle...
+	 */
+	suspend_test_start_time = jiffies;
+}
+
+static void suspend_test_finish(const char *label)
+{
+	long nj = jiffies - suspend_test_start_time;
+	unsigned msec;
+
+	msec = jiffies_to_msecs(abs(nj));
+	pr_info("PM: %s took %d.%03d seconds\n", label,
+			msec / 1000, msec % 1000);
+
+	/* Warning on suspend means the RTC alarm period needs to be
+	 * larger -- the system was sooo slooowwww to suspend that the
+	 * alarm (should have) fired before the system went to sleep!
+	 *
+	 * Warning on either suspend or resume also means the system
+	 * has some performance issues.  The stack dump of a WARN_ON
+	 * is more likely to get the right attention than a printk...
+	 */
+	WARN_ON(msec > (TEST_SUSPEND_SECONDS * 1000));
+}
+
+#else
+
+static void suspend_test_start(void)
+{
+}
+
+static void suspend_test_finish(const char *label)
+{
+}
+
+#endif
+
 /* This is just an arbitrary number */
 #define FREE_PAGE_NUMBER (100)
 
@@ -266,12 +321,13 @@ int suspend_devices_and_enter(suspend_state_t state)
 			goto Close;
 	}
 	suspend_console();
+	suspend_test_start();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to suspend\n");
 		goto Recover_platform;
 	}
-
+	suspend_test_finish("suspend devices");
 	if (suspend_test(TEST_DEVICES))
 		goto Recover_platform;
 
@@ -293,7 +349,9 @@ int suspend_devices_and_enter(suspend_state_t state)
 	if (suspend_ops->finish)
 		suspend_ops->finish();
  Resume_devices:
+	suspend_test_start();
 	device_resume(PMSG_RESUME);
+	suspend_test_finish("resume devices");
 	resume_console();
  Close:
 	if (suspend_ops->end)
@@ -521,3 +579,137 @@ static int __init pm_init(void)
 }
 
 core_initcall(pm_init);
+
+
+#ifdef CONFIG_PM_TEST_SUSPEND
+
+#include <linux/rtc.h>
+
+/*
+ * To test system suspend, we need a hands-off mechanism to resume the
+ * system.  RTCs wake alarms are a common self-contained mechanism.
+ */
+
+static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
+{
+	static char err_readtime[] __initdata =
+		KERN_ERR "PM: can't read %s time, err %d\n";
+	static char err_wakealarm [] __initdata =
+		KERN_ERR "PM: can't set %s wakealarm, err %d\n";
+	static char err_suspend[] __initdata =
+		KERN_ERR "PM: suspend test failed, error %d\n";
+	static char info_test[] __initdata =
+		KERN_INFO "PM: test RTC wakeup from '%s' suspend\n";
+
+	unsigned long		now;
+	struct rtc_wkalrm	alm;
+	int			status;
+
+	/* this may fail if the RTC hasn't been initialized */
+	status = rtc_read_time(rtc, &alm.time);
+	if (status < 0) {
+		printk(err_readtime, rtc->dev.bus_id, status);
+		return;
+	}
+	rtc_tm_to_time(&alm.time, &now);
+
+	memset(&alm, 0, sizeof alm);
+	rtc_time_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);
+	alm.enabled = true;
+
+	status = rtc_set_alarm(rtc, &alm);
+	if (status < 0) {
+		printk(err_wakealarm, rtc->dev.bus_id, status);
+		return;
+	}
+
+	if (state == PM_SUSPEND_MEM) {
+		printk(info_test, pm_states[state]);
+		status = pm_suspend(state);
+		if (status == -ENODEV)
+			state = PM_SUSPEND_STANDBY;
+	}
+	if (state == PM_SUSPEND_STANDBY) {
+		printk(info_test, pm_states[state]);
+		status = pm_suspend(state);
+	}
+	if (status < 0)
+		printk(err_suspend, status);
+}
+
+static int __init has_wakealarm(struct device *dev, void *name_ptr)
+{
+	struct rtc_device *candidate = to_rtc_device(dev);
+
+	if (!candidate->ops->set_alarm)
+		return 0;
+	if (!device_may_wakeup(candidate->dev.parent))
+		return 0;
+
+	*(char **)name_ptr = dev->bus_id;
+	return 1;
+}
+
+/*
+ * Kernel options like "test_suspend=mem" force suspend/resume sanity tests
+ * at startup time.  They're normally disabled, for faster boot and because
+ * we can't know which states really work on this particular system.
+ */
+static suspend_state_t test_state __initdata = PM_SUSPEND_ON;
+
+static char warn_bad_state[] __initdata =
+	KERN_WARNING "PM: can't test '%s' suspend state\n";
+
+static int __init setup_test_suspend(char *value)
+{
+	unsigned i;
+
+	/* "=mem" ==> "mem" */
+	value++;
+	for (i = 0; i < PM_SUSPEND_MAX; i++) {
+		if (!pm_states[i])
+			continue;
+		if (strcmp(pm_states[i], value) != 0)
+			continue;
+		test_state = (__force suspend_state_t) i;
+		return 0;
+	}
+	printk(warn_bad_state, value);
+	return 0;
+}
+__setup("test_suspend", setup_test_suspend);
+
+static int __init test_suspend(void)
+{
+	static char		warn_no_rtc[] __initdata =
+		KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n";
+
+	char			*pony = NULL;
+	struct rtc_device	*rtc = NULL;
+
+	/* PM is initialized by now; is that state testable? */
+	if (test_state == PM_SUSPEND_ON)
+		goto done;
+	if (!valid_state(test_state)) {
+		printk(warn_bad_state, pm_states[test_state]);
+		goto done;
+	}
+
+	/* RTCs have initialized by now too ... can we use one? */
+	class_find_device(rtc_class, NULL, &pony, has_wakealarm);
+	if (pony)
+		rtc = rtc_class_open(pony);
+	if (!rtc) {
+		printk(warn_no_rtc);
+		goto done;
+	}
+
+	/* go for it */
+	test_wakealarm(rtc, test_state);
+	rtc_class_close(rtc);
+done:
+	return 0;
+}
+late_initcall(test_suspend);
+
+#endif /* CONFIG_PM_TEST_SUSPEND */

commit d8f3de0d2412bb91639cfefc5b3c79dbf3812212
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 12 23:24:06 2008 +0200

    Suspend-related patches for 2.6.27
    
    ACPI PM: Add possibility to change suspend sequence
    
    There are some systems out there that don't work correctly with
    our current suspend/hibernation code ordering.  Provide a workaround
    for these systems allowing them to pass 'acpi_sleep=old_ordering' in
    the kernel command line so that it will use the pre-ACPI 2.0 ("old")
    suspend code ordering.
    
    Unfortunately, this requires us to add a platform hook to the
    resuming of devices for recovering the platform in case one of the
    device drivers' .suspend() routines returns error code.  Namely,
    ACPI 1.0 specifies that _PTS should be called before suspending
    devices, but _WAK still should be called before resuming them in
    order to undo the changes made by _PTS.  However, if there is an
    error during suspending devices, they are automatically resumed
    without returning control to the PM core, so the _WAK has to be
    called from within device_resume() in that cases.
    
    The patch also reorders and refactors the ACPI suspend/hibernation
    code to avoid duplication as far as reasonably possible.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d023b6b584e5..3398f4651aa1 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -269,11 +269,11 @@ int suspend_devices_and_enter(suspend_state_t state)
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to suspend\n");
-		goto Resume_console;
+		goto Recover_platform;
 	}
 
 	if (suspend_test(TEST_DEVICES))
-		goto Resume_devices;
+		goto Recover_platform;
 
 	if (suspend_ops->prepare) {
 		error = suspend_ops->prepare();
@@ -294,12 +294,16 @@ int suspend_devices_and_enter(suspend_state_t state)
 		suspend_ops->finish();
  Resume_devices:
 	device_resume(PMSG_RESUME);
- Resume_console:
 	resume_console();
  Close:
 	if (suspend_ops->end)
 		suspend_ops->end();
 	return error;
+
+ Recover_platform:
+	if (suspend_ops->recover)
+		suspend_ops->recover();
+	goto Resume_devices;
 }
 
 /**

commit 1eede070a59e1cc73da51e1aaa00d9ab86572cfc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 20 23:00:01 2008 +0200

    Introduce new top level suspend and hibernation callbacks
    
    Introduce 'struct pm_ops' and 'struct pm_ext_ops' ('ext' meaning
    'extended') representing suspend and hibernation operations for bus
    types, device classes, device types and device drivers.
    
    Modify the PM core to use 'struct pm_ops' and 'struct pm_ext_ops'
    objects, if defined, instead of the ->suspend(), ->resume(),
    ->suspend_late(), and ->resume_early() callbacks (the old callbacks
    will be considered as legacy and gradually phased out).
    
    The main purpose of doing this is to separate suspend (aka S2RAM and
    standby) callbacks from hibernation callbacks in such a way that the
    new callbacks won't take arguments and the semantics of each of them
    will be clearly specified.  This has been requested for multiple
    times by many people, including Linus himself, and the reason is that
    within the current scheme if ->resume() is called, for example, it's
    difficult to say why it's been called (ie. is it a resume from RAM or
    from hibernation or a suspend/hibernation failure etc.?).
    
    The second purpose is to make the suspend/hibernation callbacks more
    flexible so that device drivers can handle more than they can within
    the current scheme.  For example, some drivers may need to prevent
    new children of the device from being registered before their
    ->suspend() callbacks are executed or they may want to carry out some
    operations requiring the availability of some other devices, not
    directly bound via the parent-child relationship, in order to prepare
    for the execution of ->suspend(), etc.
    
    Ultimately, we'd like to stop using the freezing of tasks for suspend
    and therefore the drivers' suspend/hibernation code will have to take
    care of the handling of the user space during suspend/hibernation.
    That, in turn, would be difficult within the current scheme, without
    the new ->prepare() and ->complete() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6a6d5eb3524e..d023b6b584e5 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -228,6 +228,7 @@ static int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
 
+	device_pm_lock();
 	arch_suspend_disable_irqs();
 	BUG_ON(!irqs_disabled());
 
@@ -239,10 +240,11 @@ static int suspend_enter(suspend_state_t state)
 	if (!suspend_test(TEST_CORE))
 		error = suspend_ops->enter(state);
 
-	device_power_up();
+	device_power_up(PMSG_RESUME);
  Done:
 	arch_suspend_enable_irqs();
 	BUG_ON(irqs_disabled());
+	device_pm_unlock();
 	return error;
 }
 
@@ -291,7 +293,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 	if (suspend_ops->finish)
 		suspend_ops->finish();
  Resume_devices:
-	device_resume();
+	device_resume(PMSG_RESUME);
  Resume_console:
 	resume_console();
  Close:

commit af258f516b3e4e214121f5d6d53cab32ce0d8010
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Jan 11 01:22:23 2008 +0100

    Suspend: Invoke suspend notifications after console switch
    
    In order to fix APM emulation it is necessary to enable apm-emulation
    notifications for suspends triggered in various ways via the suspend
    notifiers.  However, this will cause the systems using APM emulation
    to lock up between X being needed to switch away from the VT and X
    already waiting for resume in the APM ioctl.
    
    This patch moves the console switch (if enabled) before the suspend
    notification (and after the resume notification) to avoid this issue.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index e47214cfeb2d..6a6d5eb3524e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -175,12 +175,12 @@ static int suspend_prepare(void)
 	if (!suspend_ops || !suspend_ops->enter)
 		return -EPERM;
 
+	pm_prepare_console();
+
 	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);
 	if (error)
 		goto Finish;
 
-	pm_prepare_console();
-
 	if (suspend_freeze_processes()) {
 		error = -EAGAIN;
 		goto Thaw;
@@ -200,9 +200,9 @@ static int suspend_prepare(void)
 
  Thaw:
 	suspend_thaw_processes();
-	pm_restore_console();
  Finish:
 	pm_notifier_call_chain(PM_POST_SUSPEND);
+	pm_restore_console();
 	return error;
 }
 
@@ -309,8 +309,8 @@ int suspend_devices_and_enter(suspend_state_t state)
 static void suspend_finish(void)
 {
 	suspend_thaw_processes();
-	pm_restore_console();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
+	pm_restore_console();
 }
 
 

commit b28f508112c584cdfbb4d8a9489cc4b79dac68ee
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jan 15 23:17:00 2008 -0500

    Suspend: Add config option to disable the freezer if architecture wants that
    
    This patch makes the freezer optional for suspend to allow the
    system to work (or not work) like the original PMU suspend.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d9bba452764b..e47214cfeb2d 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -181,7 +181,7 @@ static int suspend_prepare(void)
 
 	pm_prepare_console();
 
-	if (freeze_processes()) {
+	if (suspend_freeze_processes()) {
 		error = -EAGAIN;
 		goto Thaw;
 	}
@@ -199,7 +199,7 @@ static int suspend_prepare(void)
 		return 0;
 
  Thaw:
-	thaw_processes();
+	suspend_thaw_processes();
 	pm_restore_console();
  Finish:
 	pm_notifier_call_chain(PM_POST_SUSPEND);
@@ -308,7 +308,7 @@ int suspend_devices_and_enter(suspend_state_t state)
  */
 static void suspend_finish(void)
 {
-	thaw_processes();
+	suspend_thaw_processes();
 	pm_restore_console();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
 }

commit c697eecebc6cfc0b393afea3c4ff1a5041526ad1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 8 00:04:17 2008 +0100

    Suspend: Introduce begin() and end() callbacks
    
    On ACPI systems the target state set by acpi_pm_set_target() is
    reset by acpi_pm_finish(), but that need not be called if the
    suspend fails. All platforms that use the .set_target() global
    suspend callback are affected by analogous issues.
    
    For this reason, we need an additional global suspend callback that
    will reset the target state regardless of whether or not the suspend
    is successful. Also, it is reasonable to rename the .set_target()
    callback, since it will be used for a different purpose on ACPI
    systems (due to ACPI 1.0x code ordering requirements).
    
    Introduce the global suspend callback .end() to be executed at the
    end of the suspend sequence and rename the .set_target() global
    suspend callback to .begin().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 050a6077ea45..d9bba452764b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -258,10 +258,10 @@ int suspend_devices_and_enter(suspend_state_t state)
 	if (!suspend_ops)
 		return -ENOSYS;
 
-	if (suspend_ops->set_target) {
-		error = suspend_ops->set_target(state);
+	if (suspend_ops->begin) {
+		error = suspend_ops->begin(state);
 		if (error)
-			return error;
+			goto Close;
 	}
 	suspend_console();
 	error = device_suspend(PMSG_SUSPEND);
@@ -294,6 +294,9 @@ int suspend_devices_and_enter(suspend_state_t state)
 	device_resume();
  Resume_console:
 	resume_console();
+ Close:
+	if (suspend_ops->end)
+		suspend_ops->end();
 	return error;
 }
 

commit 7671b8ae5381a504d4c4ef8dd9c47128c2c3fd7e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 14 01:07:13 2007 +0100

    suspend: fix ia64 allmodconfig build
    
    kernel/power/main.c:488: error: pm_test_attr undeclared here (not in a function)
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 56881681f18b..050a6077ea45 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -53,10 +53,6 @@ int pm_notifier_call_chain(unsigned long val)
 			== NOTIFY_BAD) ? -EINVAL : 0;
 }
 
-#endif /* CONFIG_PM_SLEEP */
-
-#ifdef CONFIG_SUSPEND
-
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 
@@ -132,6 +128,7 @@ power_attr(pm_test);
 static inline int suspend_test(int level) { return 0; }
 #endif /* !CONFIG_PM_DEBUG */
 
+#endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
 
@@ -495,7 +492,7 @@ static struct attribute * g[] = {
 #ifdef CONFIG_PM_TRACE
 	&pm_trace_attr.attr,
 #endif
-#ifdef CONFIG_PM_DEBUG
+#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_PM_DEBUG)
 	&pm_test_attr.attr,
 #endif
 	NULL,

commit 465d2b477f6a0ffe01242561a93e7bf81d67c776
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 8 02:08:38 2007 +0100

    Suspend: Use common prefix in messages
    
    Make suspend messages start with one common prefix "PM: ".
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d0cedaa7edf1..56881681f18b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -235,7 +235,7 @@ static int suspend_enter(suspend_state_t state)
 	BUG_ON(!irqs_disabled());
 
 	if ((error = device_power_down(PMSG_SUSPEND))) {
-		printk(KERN_ERR "Some devices failed to power down\n");
+		printk(KERN_ERR "PM: Some devices failed to power down\n");
 		goto Done;
 	}
 
@@ -269,7 +269,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 	suspend_console();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
-		printk(KERN_ERR "Some devices failed to suspend\n");
+		printk(KERN_ERR "PM: Some devices failed to suspend\n");
 		goto Resume_console;
 	}
 
@@ -352,7 +352,7 @@ static int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
-	printk("Syncing filesystems ... ");
+	printk(KERN_INFO "PM: Syncing filesystems ... ");
 	sys_sync();
 	printk("done.\n");
 

commit 9628c0ee6a6d9ef06a77ea25932c00817f9e88a0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 8 02:06:00 2007 +0100

    Suspend: Fix comment in main.c
    
    Fix a comment in kernel/power/main.c so that it doesn't contain lines
    longer that 80 characters.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7fb805de19a8..d0cedaa7edf1 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -250,8 +250,8 @@ static int suspend_enter(suspend_state_t state)
 }
 
 /**
- *	suspend_devices_and_enter - suspend devices and enter the desired system sleep
- *			  state.
+ *	suspend_devices_and_enter - suspend devices and enter the desired system
+ *				    sleep state.
  *	@state:		  state to enter
  */
 int suspend_devices_and_enter(suspend_state_t state)

commit 2ed43b63285c394cb5e1829c199cc94c7b8233b9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 8 02:03:26 2007 +0100

    Suspend: Fix compilation warning for CONFIG_SUSPEND unset
    
    Suspend: Make debug facility depend on CONFIG_SUSPEND
    
    Make the new suspend debug facility code depend on CONFIG_SUSPEND,
    as appropriate, to remove the compiler warning printed when CONFIG_PM is set
    and CONFIG_SUSPEND is not set.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0a9f269075ee..7fb805de19a8 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -55,6 +55,8 @@ int pm_notifier_call_chain(unsigned long val)
 
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_SUSPEND
+
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 

commit 825257569350e913bee3bc918508c0aa6e3398cd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 19 23:49:18 2007 +0100

    PM: Convert PM notifiers to out-of-line code
    
    This patch (as1008b) converts the PM notifier routines from inline
    calls to out-of-line code.  It also prevents pm_chain_head from
    being created when CONFIG_PM_SLEEP isn't enabled, and EXPORTs the
    notifier registration and unregistration routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index fc717b836828..0a9f269075ee 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -24,13 +24,37 @@
 
 #include "power.h"
 
-BLOCKING_NOTIFIER_HEAD(pm_chain_head);
-
 DEFINE_MUTEX(pm_mutex);
 
 unsigned int pm_flags;
 EXPORT_SYMBOL(pm_flags);
 
+#ifdef CONFIG_PM_SLEEP
+
+/* Routines for PM-transition notifications */
+
+static BLOCKING_NOTIFIER_HEAD(pm_chain_head);
+
+int register_pm_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&pm_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(register_pm_notifier);
+
+int unregister_pm_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&pm_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_pm_notifier);
+
+int pm_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
+			== NOTIFY_BAD) ? -EINVAL : 0;
+}
+
+#endif /* CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_PM_DEBUG
 int pm_test_level = TEST_NONE;
 

commit 039a75c6e17ba4ff76998d6ac6ee3d508fff1930
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 29 00:29:06 2008 +0100

    suspend: build fix responding to 2.6.25 kset change
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 84e1ae63bb8c..fc717b836828 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -53,7 +53,8 @@ static const char * const pm_tests[__TEST_AFTER_LAST] = {
 	[TEST_FREEZER] = "freezer",
 };
 
-static ssize_t pm_test_show(struct kset *kset, char *buf)
+static ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,
+				char *buf)
 {
 	char *s = buf;
 	int level;
@@ -73,7 +74,8 @@ static ssize_t pm_test_show(struct kset *kset, char *buf)
 	return (s - buf);
 }
 
-static ssize_t pm_test_store(struct kset *kset, const char *buf, size_t n)
+static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,
+				const char *buf, size_t n)
 {
 	const char * const *s;
 	int level;
@@ -104,6 +106,7 @@ power_attr(pm_test);
 static inline int suspend_test(int level) { return 0; }
 #endif /* !CONFIG_PM_DEBUG */
 
+
 #ifdef CONFIG_SUSPEND
 
 /* This is just an arbitrary number */

commit 0e7d56e3d9d7e37c79d0e05ffb3994e34beb3bbc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Nov 19 23:41:19 2007 +0100

    Suspend: Testing facility (rev. 2)
    
    Introduce sysfs attribute /sys/power/pm_test allowing one to test the suspend
    core code. Namely, writing one of the strings:
    
    freezer
    devices
    platform
    processors
    core
    
    to this file causes the suspend code to work in one of the test modes defined as
    follows:
    
    freezer
    - test the freezing of processes
    
    devices
    - test the freezing of processes and suspending of devices
    
    platform
    - test the freezing of processes, suspending of devices and platform global
     control methods(*)
    
    processors
    - test the freezing of processes, suspending of devices, platform global
     control methods and the disabling of nonboot CPUs
    
    core
    - test the freezing of processes, suspending of devices, platform global
     control methods, the disabling of nonboot CPUs and suspending of
     platform/system devices
    
    (*) These are ACPI global control methods on ACPI systems
    
    Then, if a suspend is started by normal means, the suspend core will perform
    its normal operations up to the point indicated by given test level. Next, it
    will wait for 5 seconds and carry out the resume operations needed to transition
    the system back to the fully functional state.
    
    Writing "none" to /sys/power/pm_test turns the testing off.
    
    When open for reading, /sys/power/pm_test contains a space-separated list of all
    available tests (including "none" that represents the normal functionality) in
    which the current test level is indicated by square brackets.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index efc08360e627..84e1ae63bb8c 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -31,6 +31,79 @@ DEFINE_MUTEX(pm_mutex);
 unsigned int pm_flags;
 EXPORT_SYMBOL(pm_flags);
 
+#ifdef CONFIG_PM_DEBUG
+int pm_test_level = TEST_NONE;
+
+static int suspend_test(int level)
+{
+	if (pm_test_level == level) {
+		printk(KERN_INFO "suspend debug: Waiting for 5 seconds.\n");
+		mdelay(5000);
+		return 1;
+	}
+	return 0;
+}
+
+static const char * const pm_tests[__TEST_AFTER_LAST] = {
+	[TEST_NONE] = "none",
+	[TEST_CORE] = "core",
+	[TEST_CPUS] = "processors",
+	[TEST_PLATFORM] = "platform",
+	[TEST_DEVICES] = "devices",
+	[TEST_FREEZER] = "freezer",
+};
+
+static ssize_t pm_test_show(struct kset *kset, char *buf)
+{
+	char *s = buf;
+	int level;
+
+	for (level = TEST_FIRST; level <= TEST_MAX; level++)
+		if (pm_tests[level]) {
+			if (level == pm_test_level)
+				s += sprintf(s, "[%s] ", pm_tests[level]);
+			else
+				s += sprintf(s, "%s ", pm_tests[level]);
+		}
+
+	if (s != buf)
+		/* convert the last space to a newline */
+		*(s-1) = '\n';
+
+	return (s - buf);
+}
+
+static ssize_t pm_test_store(struct kset *kset, const char *buf, size_t n)
+{
+	const char * const *s;
+	int level;
+	char *p;
+	int len;
+	int error = -EINVAL;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	mutex_lock(&pm_mutex);
+
+	level = TEST_FIRST;
+	for (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)
+		if (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {
+			pm_test_level = level;
+			error = 0;
+			break;
+		}
+
+	mutex_unlock(&pm_mutex);
+
+	return error ? error : n;
+}
+
+power_attr(pm_test);
+#else /* !CONFIG_PM_DEBUG */
+static inline int suspend_test(int level) { return 0; }
+#endif /* !CONFIG_PM_DEBUG */
+
 #ifdef CONFIG_SUSPEND
 
 /* This is just an arbitrary number */
@@ -136,7 +209,10 @@ static int suspend_enter(suspend_state_t state)
 		printk(KERN_ERR "Some devices failed to power down\n");
 		goto Done;
 	}
-	error = suspend_ops->enter(state);
+
+	if (!suspend_test(TEST_CORE))
+		error = suspend_ops->enter(state);
+
 	device_power_up();
  Done:
 	arch_suspend_enable_irqs();
@@ -167,16 +243,25 @@ int suspend_devices_and_enter(suspend_state_t state)
 		printk(KERN_ERR "Some devices failed to suspend\n");
 		goto Resume_console;
 	}
+
+	if (suspend_test(TEST_DEVICES))
+		goto Resume_devices;
+
 	if (suspend_ops->prepare) {
 		error = suspend_ops->prepare();
 		if (error)
 			goto Resume_devices;
 	}
+
+	if (suspend_test(TEST_PLATFORM))
+		goto Finish;
+
 	error = disable_nonboot_cpus();
-	if (!error)
+	if (!error && !suspend_test(TEST_CPUS))
 		suspend_enter(state);
 
 	enable_nonboot_cpus();
+ Finish:
 	if (suspend_ops->finish)
 		suspend_ops->finish();
  Resume_devices:
@@ -243,12 +328,17 @@ static int enter_state(suspend_state_t state)
 	printk("done.\n");
 
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
-	if ((error = suspend_prepare()))
+	error = suspend_prepare();
+	if (error)
 		goto Unlock;
 
+	if (suspend_test(TEST_FREEZER))
+		goto Finish;
+
 	pr_debug("PM: Entering %s sleep\n", pm_states[state]);
 	error = suspend_devices_and_enter(state);
 
+ Finish:
 	pr_debug("PM: Finishing wakeup.\n");
 	suspend_finish();
  Unlock:
@@ -369,18 +459,18 @@ pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
 }
 
 power_attr(pm_trace);
+#endif /* CONFIG_PM_TRACE */
 
 static struct attribute * g[] = {
 	&state_attr.attr,
+#ifdef CONFIG_PM_TRACE
 	&pm_trace_attr.attr,
+#endif
+#ifdef CONFIG_PM_DEBUG
+	&pm_test_attr.attr,
+#endif
 	NULL,
 };
-#else
-static struct attribute * g[] = {
-	&state_attr.attr,
-	NULL,
-};
-#endif /* CONFIG_PM_TRACE */
 
 static struct attribute_group attr_group = {
 	.attrs = g,

commit d76e15fb20eeb7632ef38876a884fe3508b2c01d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 27 11:28:26 2007 -0800

    driver core: make /sys/power a kobject
    
    /sys/power should not be a kset, that's overkill.  This patch renames it
    to power_kset and fixes up all usages of it in the tree.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b8139493b856..efc08360e627 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -276,7 +276,7 @@ EXPORT_SYMBOL(pm_suspend);
 
 #endif /* CONFIG_SUSPEND */
 
-struct kset *power_kset;
+struct kobject *power_kobj;
 
 /**
  *	state - control system power state.
@@ -389,10 +389,10 @@ static struct attribute_group attr_group = {
 
 static int __init pm_init(void)
 {
-	power_kset = kset_create_and_add("power", NULL, NULL);
-	if (!power_kset)
+	power_kobj = kobject_create_and_add("power", NULL);
+	if (!power_kobj)
 		return -ENOMEM;
-	return sysfs_create_group(&power_kset->kobj, &attr_group);
+	return sysfs_create_group(power_kobj, &attr_group);
 }
 
 core_initcall(pm_init);

commit 386f275f5d097758f867bc99ddeaeb7a03b6b190
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 2 13:47:53 2007 +0100

    Driver Core: switch all dynamic ksets to kobj_sysfs_ops
    
    Switch all dynamically created ksets, that export simple attributes,
    to kobj_attribute from subsys_attribute. Struct subsys_attribute will
    be removed.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mike Halcrow <mhalcrow@us.ibm.com>
    Cc: Phillip Hellewell <phillip@hellewell.homeip.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index dce2d76d66de..b8139493b856 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -289,7 +289,8 @@ struct kset *power_kset;
  *	proper enumerated value, and initiates a suspend transition.
  */
 
-static ssize_t state_show(struct kset *kset, char *buf)
+static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
+			  char *buf)
 {
 	char *s = buf;
 #ifdef CONFIG_SUSPEND
@@ -310,7 +311,8 @@ static ssize_t state_show(struct kset *kset, char *buf)
 	return (s - buf);
 }
 
-static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
+static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
 	suspend_state_t state = PM_SUSPEND_STANDBY;
@@ -347,13 +349,15 @@ power_attr(state);
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
-static ssize_t pm_trace_show(struct kset *kset, char *buf)
+static ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
 {
 	return sprintf(buf, "%d\n", pm_trace_enabled);
 }
 
 static ssize_t
-pm_trace_store(struct kset *kset, const char *buf, size_t n)
+pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
+	       const char *buf, size_t n)
 {
 	int val;
 

commit 039a5dcd2fc45188a2d522df630db4f7ef903a0f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 10:39:50 2007 -0700

    kset: convert /sys/power to use kset_create
    
    Dynamically create the kset instead of declaring it statically.  We also
    rename power_subsys to power_kset to catch all users of the variable and
    we properly export it so that people don't have to guess that it really
    is present in the system.
    
    The pseries code is wierd, why is it createing /sys/power if CONFIG_PM
    is disabled?  Oh well, stupid big boxes ignoring config options...
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 1ef31c91ce0e..dce2d76d66de 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -276,8 +276,7 @@ EXPORT_SYMBOL(pm_suspend);
 
 #endif /* CONFIG_SUSPEND */
 
-decl_subsys(power, NULL);
-
+struct kset *power_kset;
 
 /**
  *	state - control system power state.
@@ -386,10 +385,10 @@ static struct attribute_group attr_group = {
 
 static int __init pm_init(void)
 {
-	int error = subsystem_register(&power_subsys);
-	if (!error)
-		error = sysfs_create_group(&power_subsys.kobj,&attr_group);
-	return error;
+	power_kset = kset_create_and_add("power", NULL, NULL);
+	if (!power_kset)
+		return -ENOMEM;
+	return sysfs_create_group(&power_kset->kobj, &attr_group);
 }
 
 core_initcall(pm_init);

commit 3514faca19a6fdc209734431c509631ea92b094e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 16 10:11:44 2007 -0600

    kobject: remove struct kobj_type from struct kset
    
    We don't need a "default" ktype for a kset.  We should set this
    explicitly every time for each kset.  This change is needed so that we
    can make ksets dynamic, and cleans up one of the odd, undocumented
    assumption that the kset/kobject/ktype model has.
    
    This patch is based on a lot of help from Kay Sievers.
    
    Nasty bug in the block code was found by Dave Young
    <hidave.darkstar@gmail.com>
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f71c9504a5c5..1ef31c91ce0e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -276,7 +276,7 @@ EXPORT_SYMBOL(pm_suspend);
 
 #endif /* CONFIG_SUSPEND */
 
-decl_subsys(power,NULL,NULL);
+decl_subsys(power, NULL);
 
 
 /**

commit 9f9adecd2d0e4f88fa0e8cb06c6ec207748df70a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Dec 13 17:38:03 2007 -0500

    PM: ACPI and APM must not be enabled at the same time
    
    ACPI and APM used "pm_active" to guarantee that
    they would not be simultaneously active.
    
    But pm_active was recently moved under CONFIG_PM_LEGACY,
    so that without CONFIG_PM_LEGACY, pm_active became a NOP --
    allowing ACPI and APM to both be simultaneously enabled.
    This caused unpredictable results, including boot hangs.
    
    Further, the code under CONFIG_PM_LEGACY is scheduled
    for removal.
    
    So replace pm_active with pm_flags.
    pm_flags depends only on CONFIG_PM,
    which is present for both CONFIG_APM and CONFIG_ACPI.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9194
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3cdf95b1dc92..f71c9504a5c5 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -28,6 +28,9 @@ BLOCKING_NOTIFIER_HEAD(pm_chain_head);
 
 DEFINE_MUTEX(pm_mutex);
 
+unsigned int pm_flags;
+EXPORT_SYMBOL(pm_flags);
+
 #ifdef CONFIG_SUSPEND
 
 /* This is just an arbitrary number */

commit 232b14328050a4639130b0dec185f43968e72035
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:44 2007 -0700

    freezer: do not sync filesystems from freeze_processes
    
    The syncing of filesystems from within the freezer is generally not needed.
    Also, if there's an ext3 filesystem loopback-mounted from a FUSE one, the
    syncing results in writes to it and deadlocks.  Similarly, it will deadlock if
    FUSE implements sync.
    
    Change freeze_processes() so that it doesn't execute sys_sync() and make the
    suspend and hibernation code path sync filesystems independently of the
    freezer.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index fb2412e7a0ce..3cdf95b1dc92 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -20,6 +20,7 @@
 #include <linux/resume-trace.h>
 #include <linux/freezer.h>
 #include <linux/vmstat.h>
+#include <linux/syscalls.h>
 
 #include "power.h"
 
@@ -230,9 +231,14 @@ static int enter_state(suspend_state_t state)
 
 	if (!valid_state(state))
 		return -ENODEV;
+
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
+	printk("Syncing filesystems ... ");
+	sys_sync();
+	printk("done.\n");
+
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	if ((error = suspend_prepare()))
 		goto Unlock;

commit f242d9196fd1ef4e6bf0e50d2e7f32866fb145c2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:41 2007 -0700

    PM: Make suspend_ops static
    
    The variable suspend_ops representing the set of global platform-specific
    suspend-related operations, used by the PM core, need not be exported outside
    of kernel/power/main.c .  Make it static.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7d09a9894947..fb2412e7a0ce 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -32,7 +32,7 @@ DEFINE_MUTEX(pm_mutex);
 /* This is just an arbitrary number */
 #define FREE_PAGE_NUMBER (100)
 
-struct platform_suspend_ops *suspend_ops;
+static struct platform_suspend_ops *suspend_ops;
 
 /**
  *	suspend_set_ops - Set the global suspend method table.

commit e6c5eb9541f2197a3ffab90b1c7a3250a9b51bf6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:41 2007 -0700

    PM: Rework struct platform_suspend_ops
    
    There is no reason why the .prepare() and .finish() methods in 'struct
    platform_suspend_ops' should take any arguments, since architectures don't use
    these methods' argument in any practically meaningful way (ie.  either the
    target system sleep state is conveyed to the platform by .set_target(), or
    there is only one suspend state supported and it is indicated to the PM core
    by .valid(), or .prepare() and .finish() aren't defined at all).  There also
    is no reason why .finish() should return any result.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 854bf0811d40..7d09a9894947 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -58,13 +58,6 @@ int suspend_valid_only_mem(suspend_state_t state)
 	return state == PM_SUSPEND_MEM;
 }
 
-
-static inline void pm_finish(suspend_state_t state)
-{
-	if (suspend_ops->finish)
-		suspend_ops->finish(state);
-}
-
 /**
  *	suspend_prepare - Do prep work before entering low-power state.
  *
@@ -171,7 +164,7 @@ int suspend_devices_and_enter(suspend_state_t state)
 		goto Resume_console;
 	}
 	if (suspend_ops->prepare) {
-		error = suspend_ops->prepare(state);
+		error = suspend_ops->prepare();
 		if (error)
 			goto Resume_devices;
 	}
@@ -180,7 +173,8 @@ int suspend_devices_and_enter(suspend_state_t state)
 		suspend_enter(state);
 
 	enable_nonboot_cpus();
-	pm_finish(state);
+	if (suspend_ops->finish)
+		suspend_ops->finish();
  Resume_devices:
 	device_resume();
  Resume_console:

commit 26398a70ea35f153feb799fa850c71685667712b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:40 2007 -0700

    PM: Rename struct pm_ops and related things
    
    The name of 'struct pm_ops' suggests that it is related to the power
    management in general, but in fact it is only related to suspend.  Moreover,
    its name should indicate what this structure is used for, so it seems
    reasonable to change it to 'struct platform_suspend_ops'.  In that case, the
    name of the global variable of this type used by the PM core and the names of
    related functions should be changed accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 2a46b6d62f76..854bf0811d40 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -32,28 +32,28 @@ DEFINE_MUTEX(pm_mutex);
 /* This is just an arbitrary number */
 #define FREE_PAGE_NUMBER (100)
 
-struct pm_ops *pm_ops;
+struct platform_suspend_ops *suspend_ops;
 
 /**
- *	pm_set_ops - Set the global power method table. 
+ *	suspend_set_ops - Set the global suspend method table.
  *	@ops:	Pointer to ops structure.
  */
 
-void pm_set_ops(struct pm_ops * ops)
+void suspend_set_ops(struct platform_suspend_ops *ops)
 {
 	mutex_lock(&pm_mutex);
-	pm_ops = ops;
+	suspend_ops = ops;
 	mutex_unlock(&pm_mutex);
 }
 
 /**
- * pm_valid_only_mem - generic memory-only valid callback
+ * suspend_valid_only_mem - generic memory-only valid callback
  *
- * pm_ops drivers that implement mem suspend only and only need
+ * Platform drivers that implement mem suspend only and only need
  * to check for that in their .valid callback can use this instead
  * of rolling their own .valid callback.
  */
-int pm_valid_only_mem(suspend_state_t state)
+int suspend_valid_only_mem(suspend_state_t state)
 {
 	return state == PM_SUSPEND_MEM;
 }
@@ -61,8 +61,8 @@ int pm_valid_only_mem(suspend_state_t state)
 
 static inline void pm_finish(suspend_state_t state)
 {
-	if (pm_ops->finish)
-		pm_ops->finish(state);
+	if (suspend_ops->finish)
+		suspend_ops->finish(state);
 }
 
 /**
@@ -76,7 +76,7 @@ static int suspend_prepare(void)
 	int error;
 	unsigned int free_pages;
 
-	if (!pm_ops || !pm_ops->enter)
+	if (!suspend_ops || !suspend_ops->enter)
 		return -EPERM;
 
 	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);
@@ -139,7 +139,7 @@ static int suspend_enter(suspend_state_t state)
 		printk(KERN_ERR "Some devices failed to power down\n");
 		goto Done;
 	}
-	error = pm_ops->enter(state);
+	error = suspend_ops->enter(state);
 	device_power_up();
  Done:
 	arch_suspend_enable_irqs();
@@ -156,11 +156,11 @@ int suspend_devices_and_enter(suspend_state_t state)
 {
 	int error;
 
-	if (!pm_ops)
+	if (!suspend_ops)
 		return -ENOSYS;
 
-	if (pm_ops->set_target) {
-		error = pm_ops->set_target(state);
+	if (suspend_ops->set_target) {
+		error = suspend_ops->set_target(state);
 		if (error)
 			return error;
 	}
@@ -170,8 +170,8 @@ int suspend_devices_and_enter(suspend_state_t state)
 		printk(KERN_ERR "Some devices failed to suspend\n");
 		goto Resume_console;
 	}
-	if (pm_ops->prepare) {
-		error = pm_ops->prepare(state);
+	if (suspend_ops->prepare) {
+		error = suspend_ops->prepare(state);
 		if (error)
 			goto Resume_devices;
 	}
@@ -214,7 +214,7 @@ static inline int valid_state(suspend_state_t state)
 	/* All states need lowlevel support and need to be valid
 	 * to the lowlevel implementation, no valid callback
 	 * implies that none are valid. */
-	if (!pm_ops || !pm_ops->valid || !pm_ops->valid(state))
+	if (!suspend_ops || !suspend_ops->valid || !suspend_ops->valid(state))
 		return 0;
 	return 1;
 }

commit a065c86e1bfcdd36709025d018965afea3f3a2b6
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Oct 18 03:04:37 2007 -0700

    make kernel/power/main.c:suspend_enter() static
    
    suspend_enter() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 350b485b3b60..2a46b6d62f76 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -128,7 +128,7 @@ void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
  *
  *	This function should be called after devices have been suspended.
  */
-int suspend_enter(suspend_state_t state)
+static int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
 

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index cfba6987ae7d..350b485b3b60 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -25,11 +25,13 @@
 
 BLOCKING_NOTIFIER_HEAD(pm_chain_head);
 
-/*This is just an arbitrary number */
-#define FREE_PAGE_NUMBER (100)
-
 DEFINE_MUTEX(pm_mutex);
 
+#ifdef CONFIG_SUSPEND
+
+/* This is just an arbitrary number */
+#define FREE_PAGE_NUMBER (100)
+
 struct pm_ops *pm_ops;
 
 /**
@@ -269,6 +271,8 @@ int pm_suspend(suspend_state_t state)
 
 EXPORT_SYMBOL(pm_suspend);
 
+#endif /* CONFIG_SUSPEND */
+
 decl_subsys(power,NULL,NULL);
 
 
@@ -285,13 +289,15 @@ decl_subsys(power,NULL,NULL);
 
 static ssize_t state_show(struct kset *kset, char *buf)
 {
+	char *s = buf;
+#ifdef CONFIG_SUSPEND
 	int i;
-	char * s = buf;
 
 	for (i = 0; i < PM_SUSPEND_MAX; i++) {
 		if (pm_states[i] && valid_state(i))
 			s += sprintf(s,"%s ", pm_states[i]);
 	}
+#endif
 #ifdef CONFIG_HIBERNATION
 	s += sprintf(s, "%s\n", "disk");
 #else
@@ -304,11 +310,13 @@ static ssize_t state_show(struct kset *kset, char *buf)
 
 static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 {
+#ifdef CONFIG_SUSPEND
 	suspend_state_t state = PM_SUSPEND_STANDBY;
 	const char * const *s;
+#endif
 	char *p;
-	int error;
 	int len;
+	int error = -EINVAL;
 
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
@@ -316,17 +324,19 @@ static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 	/* First, check if we are requested to hibernate */
 	if (len == 4 && !strncmp(buf, "disk", len)) {
 		error = hibernate();
-		return error ? error : n;
+  goto Exit;
 	}
 
+#ifdef CONFIG_SUSPEND
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
 		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
 			break;
 	}
 	if (state < PM_SUSPEND_MAX && *s)
 		error = enter_state(state);
-	else
-		error = -EINVAL;
+#endif
+
+ Exit:
 	return error ? error : n;
 }
 

commit b0cb1a19d05b8ea8611a9ef48a17fe417f1832e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:24:36 2007 +0200

    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION
    
    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION to avoid
    confusion (among other things, with CONFIG_SUSPEND introduced in the
    next patch).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 32147b57c3bf..cfba6987ae7d 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -292,7 +292,7 @@ static ssize_t state_show(struct kset *kset, char *buf)
 		if (pm_states[i] && valid_state(i))
 			s += sprintf(s,"%s ", pm_states[i]);
 	}
-#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef CONFIG_HIBERNATION
 	s += sprintf(s, "%s\n", "disk");
 #else
 	if (s != buf)

commit 77afcf78a2ded9a91838734234949c0ead5feb12
Author: Pavel Machek <pavel@suse.cz>
Date:   Thu Jul 19 01:47:41 2007 -0700

    PM: Integrate beeping flag with existing acpi_sleep flags
    
    Move "debug during resume from s2ram" into the variable we already use
    for real-mode flags to simplify code. It also closes nasty trap for
    the user in acpi_sleep_setup; order of parameters actually mattered there,
    acpi_sleep=s3_bios,s3_mode doing something different from
    acpi_sleep=s3_mode,s3_bios.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index c74a56436d8b..32147b57c3bf 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -332,27 +332,6 @@ static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 
 power_attr(state);
 
-unsigned long s2ram_beep = 0;
-
-static ssize_t s2ram_beep_show(struct kset *kset, char *buf)
-{
-	return sprintf(buf, "%d\n", s2ram_beep);
-}
-
-static ssize_t
-s2ram_beep_store(struct kset *kset, const char *buf, size_t n)
-{
-	int val;
-
-	if (sscanf(buf, "%d", &val) > 0) {
-		s2ram_beep = val;
-		return n;
-	}
-	return -EINVAL;
-}
-
-power_attr(s2ram_beep);
-
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
@@ -378,13 +357,11 @@ power_attr(pm_trace);
 static struct attribute * g[] = {
 	&state_attr.attr,
 	&pm_trace_attr.attr,
-	&s2ram_beep_attr.attr,
 	NULL,
 };
 #else
 static struct attribute * g[] = {
 	&state_attr.attr,
-	&s2ram_beep_attr.attr,
 	NULL,
 };
 #endif /* CONFIG_PM_TRACE */

commit 5a60d6235c8352ade8f2699e72fcdfe853730456
Author: Nigel Cunningham <nigel@nigel.suspend2.net>
Date:   Thu Jul 19 01:47:41 2007 -0700

    PM: Optional beeping during resume from suspend to RAM
    
    Add a feature allowing the user to make the system beep during a resume from
    suspend to RAM, on x86_64 and i386.
    
    This is useful for the users with broken resume from RAM, so that they can
    verify if the control reaches the kernel after a wake-up event.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 32147b57c3bf..c74a56436d8b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -332,6 +332,27 @@ static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 
 power_attr(state);
 
+unsigned long s2ram_beep = 0;
+
+static ssize_t s2ram_beep_show(struct kset *kset, char *buf)
+{
+	return sprintf(buf, "%d\n", s2ram_beep);
+}
+
+static ssize_t
+s2ram_beep_store(struct kset *kset, const char *buf, size_t n)
+{
+	int val;
+
+	if (sscanf(buf, "%d", &val) > 0) {
+		s2ram_beep = val;
+		return n;
+	}
+	return -EINVAL;
+}
+
+power_attr(s2ram_beep);
+
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
@@ -357,11 +378,13 @@ power_attr(pm_trace);
 static struct attribute * g[] = {
 	&state_attr.attr,
 	&pm_trace_attr.attr,
+	&s2ram_beep_attr.attr,
 	NULL,
 };
 #else
 static struct attribute * g[] = {
 	&state_attr.attr,
+	&s2ram_beep_attr.attr,
 	NULL,
 };
 #endif /* CONFIG_PM_TRACE */

commit 6c961dfb7c903cfd1cd71b506863894038fd704f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:38 2007 -0700

    PM: Reduce code duplication between main.c and user.c
    
    The SNAPSHOT_S2RAM ioctl code is outdated and it should not duplicate the
    suspend code in kernel/power/main.c.  Fix that.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 4d26ad394fb3..32147b57c3bf 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -65,14 +65,11 @@ static inline void pm_finish(suspend_state_t state)
 
 /**
  *	suspend_prepare - Do prep work before entering low-power state.
- *	@state:		State we're entering.
  *
- *	This is common code that is called for each state that we're 
- *	entering. Allocate a console, stop all processes, then make sure
- *	the platform can enter the requested state.
+ *	This is common code that is called for each state that we're entering.
+ *	Run suspend notifiers, allocate a console and stop all processes.
  */
-
-static int suspend_prepare(suspend_state_t state)
+static int suspend_prepare(void)
 {
 	int error;
 	unsigned int free_pages;
@@ -91,43 +88,18 @@ static int suspend_prepare(suspend_state_t state)
 		goto Thaw;
 	}
 
-	if ((free_pages = global_page_state(NR_FREE_PAGES))
-			< FREE_PAGE_NUMBER) {
+	free_pages = global_page_state(NR_FREE_PAGES);
+	if (free_pages < FREE_PAGE_NUMBER) {
 		pr_debug("PM: free some memory\n");
 		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
 		if (nr_free_pages() < FREE_PAGE_NUMBER) {
 			error = -ENOMEM;
 			printk(KERN_ERR "PM: No enough memory\n");
-			goto Thaw;
 		}
 	}
-
-	if (pm_ops->set_target) {
-		error = pm_ops->set_target(state);
-		if (error)
-			goto Thaw;
-	}
-	suspend_console();
-	error = device_suspend(PMSG_SUSPEND);
-	if (error) {
-		printk(KERN_ERR "Some devices failed to suspend\n");
-		goto Resume_console;
-	}
-	if (pm_ops->prepare) {
-		if ((error = pm_ops->prepare(state)))
-			goto Resume_devices;
-	}
-
-	error = disable_nonboot_cpus();
 	if (!error)
 		return 0;
 
-	enable_nonboot_cpus();
-	pm_finish(state);
- Resume_devices:
-	device_resume();
- Resume_console:
-	resume_console();
  Thaw:
 	thaw_processes();
 	pm_restore_console();
@@ -148,6 +120,12 @@ void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
 	local_irq_enable();
 }
 
+/**
+ *	suspend_enter - enter the desired system sleep state.
+ *	@state:		state to enter
+ *
+ *	This function should be called after devices have been suspended.
+ */
 int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
@@ -167,21 +145,55 @@ int suspend_enter(suspend_state_t state)
 	return error;
 }
 
+/**
+ *	suspend_devices_and_enter - suspend devices and enter the desired system sleep
+ *			  state.
+ *	@state:		  state to enter
+ */
+int suspend_devices_and_enter(suspend_state_t state)
+{
+	int error;
+
+	if (!pm_ops)
+		return -ENOSYS;
+
+	if (pm_ops->set_target) {
+		error = pm_ops->set_target(state);
+		if (error)
+			return error;
+	}
+	suspend_console();
+	error = device_suspend(PMSG_SUSPEND);
+	if (error) {
+		printk(KERN_ERR "Some devices failed to suspend\n");
+		goto Resume_console;
+	}
+	if (pm_ops->prepare) {
+		error = pm_ops->prepare(state);
+		if (error)
+			goto Resume_devices;
+	}
+	error = disable_nonboot_cpus();
+	if (!error)
+		suspend_enter(state);
+
+	enable_nonboot_cpus();
+	pm_finish(state);
+ Resume_devices:
+	device_resume();
+ Resume_console:
+	resume_console();
+	return error;
+}
 
 /**
  *	suspend_finish - Do final work before exiting suspend sequence.
- *	@state:		State we're coming out of.
  *
  *	Call platform code to clean up, restart processes, and free the 
  *	console that we've allocated. This is not called for suspend-to-disk.
  */
-
-static void suspend_finish(suspend_state_t state)
+static void suspend_finish(void)
 {
-	enable_nonboot_cpus();
-	pm_finish(state);
-	device_resume();
-	resume_console();
 	thaw_processes();
 	pm_restore_console();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
@@ -216,7 +228,6 @@ static inline int valid_state(suspend_state_t state)
  *	Then, do the setup for suspend, enter the state, and cleaup (after
  *	we've woken up).
  */
-
 static int enter_state(suspend_state_t state)
 {
 	int error;
@@ -227,14 +238,14 @@ static int enter_state(suspend_state_t state)
 		return -EBUSY;
 
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
-	if ((error = suspend_prepare(state)))
+	if ((error = suspend_prepare()))
 		goto Unlock;
 
 	pr_debug("PM: Entering %s sleep\n", pm_states[state]);
-	error = suspend_enter(state);
+	error = suspend_devices_and_enter(state);
 
 	pr_debug("PM: Finishing wakeup.\n");
-	suspend_finish(state);
+	suspend_finish();
  Unlock:
 	mutex_unlock(&pm_mutex);
 	return error;

commit b10d911749d37dccfa5873d2088aea3f074b9e45
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:36 2007 -0700

    PM: introduce hibernation and suspend notifiers
    
    Make it possible to register hibernation and suspend notifiers, so that
    subsystems can perform hibernation-related or suspend-related operations that
    should not be carried out by device drivers' .suspend() and .resume()
    routines.
    
    [akpm@linux-foundation.org: build fixes]
    [akpm@linux-foundation.org: cleanups]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index fc45ed22620f..4d26ad394fb3 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -23,6 +23,8 @@
 
 #include "power.h"
 
+BLOCKING_NOTIFIER_HEAD(pm_chain_head);
+
 /*This is just an arbitrary number */
 #define FREE_PAGE_NUMBER (100)
 
@@ -78,6 +80,10 @@ static int suspend_prepare(suspend_state_t state)
 	if (!pm_ops || !pm_ops->enter)
 		return -EPERM;
 
+	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);
+	if (error)
+		goto Finish;
+
 	pm_prepare_console();
 
 	if (freeze_processes()) {
@@ -125,6 +131,8 @@ static int suspend_prepare(suspend_state_t state)
  Thaw:
 	thaw_processes();
 	pm_restore_console();
+ Finish:
+	pm_notifier_call_chain(PM_POST_SUSPEND);
 	return error;
 }
 
@@ -176,6 +184,7 @@ static void suspend_finish(suspend_state_t state)
 	resume_console();
 	thaw_processes();
 	pm_restore_console();
+	pm_notifier_call_chain(PM_POST_SUSPEND);
 }
 
 

commit 2391dae3e36c19fe668c71eac2eb8344dbaaf46d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 1 12:07:33 2007 -0700

    PM: introduce set_target method in pm_ops
    
    Commit 52ade9b3b97fd3bea42842a056fe0786c28d0555 changed the suspend code
    ordering to execute pm_ops->prepare() after the device model per-device
    .suspend() calls in order to fix some ACPI-related issues.  Unfortunately, it
    broke the at91 platform which assumed that pm_ops->prepare() would be called
    before suspending devices.
    
    at91 used pm_ops->prepare() to get notified of the target system sleep state,
    so that it could use this information while suspending devices.  However, with
    the current suspend code ordering pm_ops->prepare() is called too late for
    this purpose.  Thus, at91 needs an additional method in 'struct pm_ops' that
    will be used for notifying the platform of the target system sleep state.
    Moreover, in the future such a method will also be needed by ACPI.
    
    This patch adds the .set_target() method to 'struct pm_ops' and makes the
    suspend code call it, if implemented, before executing the device model
    per-device .suspend() calls.  It also modifies the at91 code to use
    pm_ops->set_target() instead of pm_ops->prepare().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8812985f3029..fc45ed22620f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -15,7 +15,6 @@
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/pm.h>
 #include <linux/console.h>
 #include <linux/cpu.h>
 #include <linux/resume-trace.h>
@@ -97,6 +96,11 @@ static int suspend_prepare(suspend_state_t state)
 		}
 	}
 
+	if (pm_ops->set_target) {
+		error = pm_ops->set_target(state);
+		if (error)
+			goto Thaw;
+	}
 	suspend_console();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {

commit 8d98a690f58e0d6ecf424b7ca84488475cf87bd9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 16 22:11:19 2007 -0700

    swsusp: fix sysfs interface
    
    The sysfs files /sys/power/disk and /sys/power/state do not work as
    documented, since they allow the user to write only a few initial
    characters of the input string to trigger the option (eg.  'echo pl >
    /sys/power/disk' activates the platform mode of hibernation).  Fix it.
    
    Special thanks to Peter Moulder <Peter.Moulder@infotech.monash.edu.au> for
    pointing out the problem.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b98b80ccf437..8812985f3029 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -290,13 +290,13 @@ static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 	len = p ? p - buf : n;
 
 	/* First, check if we are requested to hibernate */
-	if (!strncmp(buf, "disk", len)) {
+	if (len == 4 && !strncmp(buf, "disk", len)) {
 		error = hibernate();
 		return error ? error : n;
 	}
 
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
-		if (*s && !strncmp(buf, *s, len))
+		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
 			break;
 	}
 	if (state < PM_SUSPEND_MAX && *s)

commit 52ade9b3b97fd3bea42842a056fe0786c28d0555
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed May 16 15:28:14 2007 -0700

    Fix ACPI suspend / device suspend ordering problem
    
    In commit e3c7db621bed4afb8e231cb005057f2feb5db557 we fixed the resume
    ordering, so that the ACPI low-level resume code was called before the
    actual driver resume was called. However, that broke the nesting logic
    of suspend and resume, and we continued to suspend the devices _after_
    we the ACPI device suspend code was called.
    
    That resulted in us saving PCI state for devices that had already been
    changed by ACPI, and in some cases disabled entirely (causing the PCI
    save_state to be all-ones).  Which in turn caused the wrong state to be
    written back on resume.
    
    This moves the ACPI device suspend to after the device model per-device
    suspend() calls. This fixes the bogus state save.
    
    Thanks to Luk Hejtmnek for testing.
    
    Acked-by: Lukas Hejtmanek <xhejtman@ics.muni.cz>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 40d56a31245e..b98b80ccf437 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -97,25 +97,26 @@ static int suspend_prepare(suspend_state_t state)
 		}
 	}
 
-	if (pm_ops->prepare) {
-		if ((error = pm_ops->prepare(state)))
-			goto Thaw;
-	}
-
 	suspend_console();
 	error = device_suspend(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "Some devices failed to suspend\n");
-		goto Resume_devices;
+		goto Resume_console;
 	}
+	if (pm_ops->prepare) {
+		if ((error = pm_ops->prepare(state)))
+			goto Resume_devices;
+	}
+
 	error = disable_nonboot_cpus();
 	if (!error)
 		return 0;
 
 	enable_nonboot_cpus();
- Resume_devices:
 	pm_finish(state);
+ Resume_devices:
 	device_resume();
+ Resume_console:
 	resume_console();
  Thaw:
 	thaw_processes();

commit a3d25c275d383975504dc53c25b691df59bd3c48
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 9 02:33:18 2007 -0700

    PM: Separate hibernation code from suspend code
    
    [ With Johannes Berg <johannes@sipsolutions.net> ]
    
    Separate the hibernation (aka suspend to disk code) from the other suspend
    code.  In particular:
    
     * Remove the definitions related to hibernation from include/linux/pm.h
     * Introduce struct hibernation_ops and a new hibernate() function to hibernate
       the system, defined in include/linux/suspend.h
     * Separate suspend code in kernel/power/main.c from hibernation-related code
       in kernel/power/disk.c and kernel/power/user.c (with the help of
       hibernation_ops)
     * Switch ACPI (the only user of pm_ops.pm_disk_mode) to hibernation_ops
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f6dda685e7e2..40d56a31245e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -30,7 +30,6 @@
 DEFINE_MUTEX(pm_mutex);
 
 struct pm_ops *pm_ops;
-suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
 
 /**
  *	pm_set_ops - Set the global power method table. 
@@ -41,10 +40,6 @@ void pm_set_ops(struct pm_ops * ops)
 {
 	mutex_lock(&pm_mutex);
 	pm_ops = ops;
-	if (ops && ops->pm_disk_mode != PM_DISK_INVALID) {
-		pm_disk_mode = ops->pm_disk_mode;
-	} else
-		pm_disk_mode = PM_DISK_SHUTDOWN;
 	mutex_unlock(&pm_mutex);
 }
 
@@ -184,24 +179,12 @@ static void suspend_finish(suspend_state_t state)
 static const char * const pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
-	[PM_SUSPEND_DISK]	= "disk",
 };
 
 static inline int valid_state(suspend_state_t state)
 {
-	/* Suspend-to-disk does not really need low-level support.
-	 * It can work with shutdown/reboot if needed. If it isn't
-	 * configured, then it cannot be supported.
-	 */
-	if (state == PM_SUSPEND_DISK)
-#ifdef CONFIG_SOFTWARE_SUSPEND
-		return 1;
-#else
-		return 0;
-#endif
-
-	/* all other states need lowlevel support and need to be
-	 * valid to the lowlevel implementation, no valid callback
+	/* All states need lowlevel support and need to be valid
+	 * to the lowlevel implementation, no valid callback
 	 * implies that none are valid. */
 	if (!pm_ops || !pm_ops->valid || !pm_ops->valid(state))
 		return 0;
@@ -229,11 +212,6 @@ static int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
-	if (state == PM_SUSPEND_DISK) {
-		error = pm_suspend_disk();
-		goto Unlock;
-	}
-
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	if ((error = suspend_prepare(state)))
 		goto Unlock;
@@ -251,7 +229,7 @@ static int enter_state(suspend_state_t state)
 
 /**
  *	pm_suspend - Externally visible function for suspending system.
- *	@state:		Enumarted value of state to enter.
+ *	@state:		Enumerated value of state to enter.
  *
  *	Determine whether or not value is within range, get state 
  *	structure, and enter (above).
@@ -289,7 +267,13 @@ static ssize_t state_show(struct kset *kset, char *buf)
 		if (pm_states[i] && valid_state(i))
 			s += sprintf(s,"%s ", pm_states[i]);
 	}
-	s += sprintf(s,"\n");
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	s += sprintf(s, "%s\n", "disk");
+#else
+	if (s != buf)
+		/* convert the last space to a newline */
+		*(s-1) = '\n';
+#endif
 	return (s - buf);
 }
 
@@ -304,6 +288,12 @@ static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
 
+	/* First, check if we are requested to hibernate */
+	if (!strncmp(buf, "disk", len)) {
+		error = hibernate();
+		return error ? error : n;
+	}
+
 	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
 		if (*s && !strncmp(buf, *s, len))
 			break;

commit ab3bfca7abf3fd0fe41d26d839610a787aa7e587
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun May 6 14:50:49 2007 -0700

    remove software_suspend()
    
    Remove software_suspend() and all its users since
    pm_suspend(PM_SUSPEND_DISK) should be equivalent and there's no point in
    having two interfaces for the same thing.
    
    The patch also changes the valid_state function to return 0 (false) for
    PM_SUSPEND_DISK when SOFTWARE_SUSPEND is not configured instead of
    accepting it and having the whole thing fail later.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 5a779270cdbc..f6dda685e7e2 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -184,17 +184,21 @@ static void suspend_finish(suspend_state_t state)
 static const char * const pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
-#ifdef CONFIG_SOFTWARE_SUSPEND
 	[PM_SUSPEND_DISK]	= "disk",
-#endif
 };
 
 static inline int valid_state(suspend_state_t state)
 {
 	/* Suspend-to-disk does not really need low-level support.
-	 * It can work with reboot if needed. */
+	 * It can work with shutdown/reboot if needed. If it isn't
+	 * configured, then it cannot be supported.
+	 */
 	if (state == PM_SUSPEND_DISK)
+#ifdef CONFIG_SOFTWARE_SUSPEND
 		return 1;
+#else
+		return 0;
+#endif
 
 	/* all other states need lowlevel support and need to be
 	 * valid to the lowlevel implementation, no valid callback
@@ -244,17 +248,6 @@ static int enter_state(suspend_state_t state)
 	return error;
 }
 
-#ifdef CONFIG_SOFTWARE_SUSPEND
-/*
- * This is main interface to the outside world. It needs to be
- * called from process context.
- */
-int software_suspend(void)
-{
-	return enter_state(PM_SUSPEND_DISK);
-}
-#endif
-
 
 /**
  *	pm_suspend - Externally visible function for suspending system.

commit 74dfd666de861c97d47bdbd892f6d21b801d0247
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:43 2007 -0700

    swsusp: do not use page flags
    
    Make swsusp use memory bitmaps instead of page flags for marking 'nosave' and
    free pages.  This allows us to 'recycle' two page flags that can be used for
    other purposes.  Also, the memory needed to store the bitmaps is allocated
    when necessary (ie.  before the suspend) and freed after the resume which is
    more reasonable.
    
    The patch is designed to minimize the amount of changes and there are some
    nice simplifications and optimizations possible on top of it.  I am going to
    implement them separately in the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index b21c2a56f960..5a779270cdbc 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -244,6 +244,7 @@ static int enter_state(suspend_state_t state)
 	return error;
 }
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
 /*
  * This is main interface to the outside world. It needs to be
  * called from process context.
@@ -252,6 +253,7 @@ int software_suspend(void)
 {
 	return enter_state(PM_SUSPEND_DISK);
 }
+#endif
 
 
 /**

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 72419a3b1beb..b21c2a56f960 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -285,7 +285,7 @@ decl_subsys(power,NULL,NULL);
  *	proper enumerated value, and initiates a suspend transition.
  */
 
-static ssize_t state_show(struct subsystem * subsys, char * buf)
+static ssize_t state_show(struct kset *kset, char *buf)
 {
 	int i;
 	char * s = buf;
@@ -298,7 +298,7 @@ static ssize_t state_show(struct subsystem * subsys, char * buf)
 	return (s - buf);
 }
 
-static ssize_t state_store(struct subsystem * subsys, const char * buf, size_t n)
+static ssize_t state_store(struct kset *kset, const char *buf, size_t n)
 {
 	suspend_state_t state = PM_SUSPEND_STANDBY;
 	const char * const *s;
@@ -325,13 +325,13 @@ power_attr(state);
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
-static ssize_t pm_trace_show(struct subsystem * subsys, char * buf)
+static ssize_t pm_trace_show(struct kset *kset, char *buf)
 {
 	return sprintf(buf, "%d\n", pm_trace_enabled);
 }
 
 static ssize_t
-pm_trace_store(struct subsystem * subsys, const char * buf, size_t n)
+pm_trace_store(struct kset *kset, const char *buf, size_t n)
 {
 	int val;
 
@@ -365,7 +365,7 @@ static int __init pm_init(void)
 {
 	int error = subsystem_register(&power_subsys);
 	if (!error)
-		error = sysfs_create_group(&power_subsys.kset.kobj,&attr_group);
+		error = sysfs_create_group(&power_subsys.kobj,&attr_group);
 	return error;
 }
 

commit 9684e51cd157607f0727c1550e7df6e31de40808
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:55 2007 -0700

    power management: force pm_ops.valid callback to be assigned
    
    This patch changes the docs and behaviour from "all states valid" to "no
    states valid" if no .valid callback is assigned.  Users of pm_ops that only
    need mem sleep can assign pm_valid_only_mem without any overhead, others
    will require more elaborate callbacks.
    
    Now that all users of pm_ops have a .valid callback this is a safe thing to
    do and prevents things from getting messy again as they were before.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Looks-okay-to: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index f94f4e20115a..72419a3b1beb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -198,8 +198,8 @@ static inline int valid_state(suspend_state_t state)
 
 	/* all other states need lowlevel support and need to be
 	 * valid to the lowlevel implementation, no valid callback
-	 * implies that all are valid. */
-	if (!pm_ops || (pm_ops->valid && !pm_ops->valid(state)))
+	 * implies that none are valid. */
+	if (!pm_ops || !pm_ops->valid || !pm_ops->valid(state))
 		return 0;
 	return 1;
 }

commit e8c9c502690efd24b7055bf608e7a3c34216848b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:54 2007 -0700

    power management: implement pm_ops.valid for everybody
    
    Almost all users of pm_ops only support mem sleep, don't check in .valid and
    don't reject any others in .prepare so users can be confused if they check
    /sys/power/state, especially when new states are added (these would then
    result in s-t-r although they're supposed to be something different).
    
    This patch implements a generic pm_valid_only_mem function that is then
    exported for users and puts it to use in almost all existing pm_ops.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: linux-pm@lists.linux-foundation.org
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 053c0a7d7f57..f94f4e20115a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -48,6 +48,19 @@ void pm_set_ops(struct pm_ops * ops)
 	mutex_unlock(&pm_mutex);
 }
 
+/**
+ * pm_valid_only_mem - generic memory-only valid callback
+ *
+ * pm_ops drivers that implement mem suspend only and only need
+ * to check for that in their .valid callback can use this instead
+ * of rolling their own .valid callback.
+ */
+int pm_valid_only_mem(suspend_state_t state)
+{
+	return state == PM_SUSPEND_MEM;
+}
+
+
 static inline void pm_finish(suspend_state_t state)
 {
 	if (pm_ops->finish)

commit fe0c935a6cbf25d72a27c7a345df8a2151de0b74
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:51 2007 -0700

    rework pm_ops pm_disk_mode, kill misuse
    
    This patch series cleans up some misconceptions about pm_ops.  Some users of
    the pm_ops structure attempt to use it to stop the user from entering suspend
    to disk, this, however, is not possible since the user can always use
    "shutdown" in /sys/power/disk and then the pm_ops are never invoked.  Also,
    platforms that don't support suspend to disk simply should not allow
    configuring SOFTWARE_SUSPEND (read the help text on it, it only selects
    suspend to disk and nothing else, all the other stuff depends on PM).
    
    The pm_ops structure is actually intended to provide a way to enter
    platform-defined sleep states (currently supported states are "standby" and
    "mem" (suspend to ram)) and additionally (if SOFTWARE_SUSPEND is configured)
    allows a platform to support a platform specific way to enter low-power mode
    once everything has been saved to disk.  This is currently only used by ACPI
    (S4).
    
    This patch:
    
    The pm_ops.pm_disk_mode is used in totally bogus ways since nobody really
    seems to understand what it actually does.
    
    This patch clarifies the pm_disk_mode description.
    
    It also removes all the arm and sh users that think they can veto suspend to
    disk via pm_ops; not so since the user can always do echo shutdown >
    /sys/power/disk, they need to find a better way involving Kconfig or such.
    
    ACPI is the only user left with a non-zero pm_disk_mode.
    
    The patch also sets the default mode to shutdown again, but when a new pm_ops
    is registered its pm_disk_mode is selected as default, that way the default
    stays for ACPI where it is apparently required.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3062e940d1fa..053c0a7d7f57 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -30,7 +30,7 @@
 DEFINE_MUTEX(pm_mutex);
 
 struct pm_ops *pm_ops;
-suspend_disk_method_t pm_disk_mode = PM_DISK_PLATFORM;
+suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
 
 /**
  *	pm_set_ops - Set the global power method table. 
@@ -41,6 +41,10 @@ void pm_set_ops(struct pm_ops * ops)
 {
 	mutex_lock(&pm_mutex);
 	pm_ops = ops;
+	if (ops && ops->pm_disk_mode != PM_DISK_INVALID) {
+		pm_disk_mode = ops->pm_disk_mode;
+	} else
+		pm_disk_mode = PM_DISK_SHUTDOWN;
 	mutex_unlock(&pm_mutex);
 }
 

commit a53c46dc8253cc613ad66a2ca7aad6de8b7e61b9
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Apr 26 11:43:58 2007 +0200

    s2ram: add arch irq disable/enable hooks
    
    After some more discussion this patch replaces it:
    
    From: Johannes Berg <johannes@sipsolutions.net>
    Subject: suspend: add arch irq disable/enable hooks
    
    For powermac, we need to do some things between suspending devices and
    device_power_off, for example setting the decrementer. This patch
    allows architectures to define arch_s2ram_{en,dis}able_irqs in their
    asm/suspend.h to have control over this step.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index a064dfd8877a..3062e940d1fa 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -111,13 +111,24 @@ static int suspend_prepare(suspend_state_t state)
 	return error;
 }
 
+/* default implementation */
+void __attribute__ ((weak)) arch_suspend_disable_irqs(void)
+{
+	local_irq_disable();
+}
+
+/* default implementation */
+void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
+{
+	local_irq_enable();
+}
 
 int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
-	unsigned long flags;
 
-	local_irq_save(flags);
+	arch_suspend_disable_irqs();
+	BUG_ON(!irqs_disabled());
 
 	if ((error = device_power_down(PMSG_SUSPEND))) {
 		printk(KERN_ERR "Some devices failed to power down\n");
@@ -126,7 +137,8 @@ int suspend_enter(suspend_state_t state)
 	error = pm_ops->enter(state);
 	device_power_up();
  Done:
-	local_irq_restore(flags);
+	arch_suspend_enable_irqs();
+	BUG_ON(irqs_disabled());
 	return error;
 }
 

commit 9c372d06ce9ddf65e1393f9ea22a6d6bd5f96b42
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Feb 16 01:38:29 2007 -0800

    power management: no valid states w/o pm_ops
    
    Change /sys/power/state to not advertise any valid states (except for disk
    if SOFTWARE_SUSPEND is enabled) when no pm_ops have been set so userspace
    can easily discover what states should be available.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Macheck <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index e1c413120469..a064dfd8877a 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -167,7 +167,10 @@ static inline int valid_state(suspend_state_t state)
 	if (state == PM_SUSPEND_DISK)
 		return 1;
 
-	if (pm_ops && pm_ops->valid && !pm_ops->valid(state))
+	/* all other states need lowlevel support and need to be
+	 * valid to the lowlevel implementation, no valid callback
+	 * implies that all are valid. */
+	if (!pm_ops || (pm_ops->valid && !pm_ops->valid(state)))
 		return 0;
 	return 1;
 }

commit e3c7db621bed4afb8e231cb005057f2feb5db557
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 10 01:43:31 2007 -0800

    [PATCH] PM: Change code ordering in main.c
    
    As indicated in a recent thread on Linux-PM, it's necessary to call
    pm_ops->finish() before devce_resume(), but enable_nonboot_cpus() has to be
    called before pm_ops->finish() (cf.
    http://lists.osdl.org/pipermail/linux-pm/2006-November/004164.html).  For
    consistency, it seems reasonable to call disable_nonboot_cpus() after
    device_suspend().
    
    This way the suspend code will remain symmetrical with respect to the resume
    code and it may allow us to speed up things in the future by suspending and
    resuming devices and/or saving the suspend image in many threads.
    
    The following series of patches reorders the suspend and resume code so that
    nonboot CPUs are disabled after devices have been suspended and enabled before
    the devices are resumed.  It also causes pm_ops->finish() to be called after
    enable_nonboot_cpus() wherever necessary.
    
    This patch:
    
    Change the ordering of code in kernel/power/main.c so that device_suspend()
    is called before disable_nonboot_cpus() and pm_ops->finish() is called after
    enable_nonboot_cpus() and before device_resume(), as indicated by recent
    discussion on Linux-PM
    (cf. http://lists.osdl.org/pipermail/linux-pm/2006-November/004164.html).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Greg KH <greg@kroah.com>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 47ca5a2b653b..e1c413120469 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -44,6 +44,11 @@ void pm_set_ops(struct pm_ops * ops)
 	mutex_unlock(&pm_mutex);
 }
 
+static inline void pm_finish(suspend_state_t state)
+{
+	if (pm_ops->finish)
+		pm_ops->finish(state);
+}
 
 /**
  *	suspend_prepare - Do prep work before entering low-power state.
@@ -64,10 +69,6 @@ static int suspend_prepare(suspend_state_t state)
 
 	pm_prepare_console();
 
-	error = disable_nonboot_cpus();
-	if (error)
-		goto Enable_cpu;
-
 	if (freeze_processes()) {
 		error = -EAGAIN;
 		goto Thaw;
@@ -90,18 +91,22 @@ static int suspend_prepare(suspend_state_t state)
 	}
 
 	suspend_console();
-	if ((error = device_suspend(PMSG_SUSPEND))) {
+	error = device_suspend(PMSG_SUSPEND);
+	if (error) {
 		printk(KERN_ERR "Some devices failed to suspend\n");
-		goto Finish;
+		goto Resume_devices;
 	}
-	return 0;
- Finish:
-	if (pm_ops->finish)
-		pm_ops->finish(state);
+	error = disable_nonboot_cpus();
+	if (!error)
+		return 0;
+
+	enable_nonboot_cpus();
+ Resume_devices:
+	pm_finish(state);
+	device_resume();
+	resume_console();
  Thaw:
 	thaw_processes();
- Enable_cpu:
-	enable_nonboot_cpus();
 	pm_restore_console();
 	return error;
 }
@@ -136,12 +141,11 @@ int suspend_enter(suspend_state_t state)
 
 static void suspend_finish(suspend_state_t state)
 {
+	enable_nonboot_cpus();
+	pm_finish(state);
 	device_resume();
 	resume_console();
 	thaw_processes();
-	enable_nonboot_cpus();
-	if (pm_ops && pm_ops->finish)
-		pm_ops->finish(state);
 	pm_restore_console();
 }
 

commit 96177299416dbccb73b54e6b344260154a445375
Author: Christoph Lameter <clameter@sgi.com>
Date:   Sat Feb 10 01:43:03 2007 -0800

    [PATCH] Drop free_pages()
    
    nr_free_pages is now a simple access to a global variable.  Make it a macro
    instead of a function.
    
    The nr_free_pages now requires vmstat.h to be included.  There is one
    occurrence in power management where we need to add the include.  Directly
    refrer to global_page_state() there to clarify why the #include was added.
    
    [akpm@osdl.org: arm build fix]
    [akpm@osdl.org: sparc64 build fix]
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index ff3a6182f5f0..47ca5a2b653b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -20,6 +20,7 @@
 #include <linux/cpu.h>
 #include <linux/resume-trace.h>
 #include <linux/freezer.h>
+#include <linux/vmstat.h>
 
 #include "power.h"
 
@@ -72,7 +73,8 @@ static int suspend_prepare(suspend_state_t state)
 		goto Thaw;
 	}
 
-	if ((free_pages = nr_free_pages()) < FREE_PAGE_NUMBER) {
+	if ((free_pages = global_page_state(NR_FREE_PAGES))
+			< FREE_PAGE_NUMBER) {
 		pr_debug("PM: free some memory\n");
 		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
 		if (nr_free_pages() < FREE_PAGE_NUMBER) {

commit cfee47f99bc14a6d7c6b0be2284db2cef310a815
Merge: 7e244322cd4e 9185cfa92507
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:01:18 2006 -0500

    Pull bugfix into test branch
    
    Conflicts:
    
            kernel/power/disk.c

commit 4cf303487d5dddaace2daca8437c555f3f0bc1aa
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 6 20:36:06 2006 -0800

    [PATCH] Export pm_suspend for the shared APM emulation
    
    The new shared APM emulation just like its ARM and MIPS predecessors uses
    pm_suspend() which was only exported on SH.  Move export to close to it's
    definition where it really should be anyway.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 751157b7897e..500eb87f643d 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -8,6 +8,7 @@
  *
  */
 
+#include <linux/module.h>
 #include <linux/suspend.h>
 #include <linux/kobject.h>
 #include <linux/string.h>
@@ -230,7 +231,7 @@ int pm_suspend(suspend_state_t state)
 	return -EINVAL;
 }
 
-
+EXPORT_SYMBOL(pm_suspend);
 
 decl_subsys(power,NULL,NULL);
 

commit a6d70980602e6f1869ebcdcbfaf55a0a5941583e
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Dec 6 20:34:35 2006 -0800

    [PATCH] convert pm_sem to a mutex
    
    The power management semaphore is only used as mutex, so convert it.
    
    [akpm@osdl.org: fix rotten bug]
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6096c71b182b..751157b7897e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -25,7 +25,7 @@
 /*This is just an arbitrary number */
 #define FREE_PAGE_NUMBER (100)
 
-DECLARE_MUTEX(pm_sem);
+DEFINE_MUTEX(pm_mutex);
 
 struct pm_ops *pm_ops;
 suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
@@ -37,9 +37,9 @@ suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
 
 void pm_set_ops(struct pm_ops * ops)
 {
-	down(&pm_sem);
+	mutex_lock(&pm_mutex);
 	pm_ops = ops;
-	up(&pm_sem);
+	mutex_unlock(&pm_mutex);
 }
 
 
@@ -183,7 +183,7 @@ static int enter_state(suspend_state_t state)
 
 	if (!valid_state(state))
 		return -ENODEV;
-	if (down_trylock(&pm_sem))
+	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
 	if (state == PM_SUSPEND_DISK) {
@@ -201,7 +201,7 @@ static int enter_state(suspend_state_t state)
 	pr_debug("PM: Finishing wakeup.\n");
 	suspend_finish(state);
  Unlock:
-	up(&pm_sem);
+	mutex_unlock(&pm_mutex);
 	return error;
 }
 

commit 7dfb71030f7636a0d65200158113c37764552f93
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:23 2006 -0800

    [PATCH] Add include/linux/freezer.h and move definitions from sched.h
    
    Move process freezing functions from include/linux/sched.h to freezer.h, so
    that modifications to the freezer or the kernel configuration don't require
    recompiling just about everything.
    
    [akpm@osdl.org: fix ueagle driver]
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 873228c71dab..6096c71b182b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -18,6 +18,7 @@
 #include <linux/console.h>
 #include <linux/cpu.h>
 #include <linux/resume-trace.h>
+#include <linux/freezer.h>
 
 #include "power.h"
 

commit 9185cfa92507d07ac787bc73d06c42222eec7239
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Nov 1 13:23:14 2006 +0100

    ACPI: S4: Use "platform" rather than "shutdown" mode by default
    
    It has been reported that on some systems the functionality after a resume
    from disk is limited if the system is simply powered off during the suspend
    instead of using the ACPI S4 suspend (aka platform mode).
    
    Unfortunately the default is currently to power off the system during the
    suspend so the users of these systems experience problems after the resume
    if they don't switch to the platform mode explicitly.  This patch makes swsusp
    use the platform mode by default to avoid such situations.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Stefan Seyfried <seife@suse.de>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 873228c71dab..1210961a5aa7 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -27,7 +27,7 @@
 DECLARE_MUTEX(pm_sem);
 
 struct pm_ops *pm_ops;
-suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
+suspend_disk_method_t pm_disk_mode = PM_DISK_PLATFORM;
 
 /**
  *	pm_set_ops - Set the global power method table. 

commit c5c6ba4e08ab9c9e390a0f3a7d9a5c332f5cc6ef
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:58 2006 -0700

    [PATCH] PM: Add pm_trace switch
    
    Add the pm_trace attribute in /sys/power which has to be explicitly set to
    one to really enable the "PM tracing" code compiled in when CONFIG_PM_TRACE
    is set (which modifies the machine's CMOS clock in unpredictable ways).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 4d403323a7bb..873228c71dab 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -17,6 +17,7 @@
 #include <linux/pm.h>
 #include <linux/console.h>
 #include <linux/cpu.h>
+#include <linux/resume-trace.h>
 
 #include "power.h"
 
@@ -281,10 +282,39 @@ static ssize_t state_store(struct subsystem * subsys, const char * buf, size_t n
 
 power_attr(state);
 
+#ifdef CONFIG_PM_TRACE
+int pm_trace_enabled;
+
+static ssize_t pm_trace_show(struct subsystem * subsys, char * buf)
+{
+	return sprintf(buf, "%d\n", pm_trace_enabled);
+}
+
+static ssize_t
+pm_trace_store(struct subsystem * subsys, const char * buf, size_t n)
+{
+	int val;
+
+	if (sscanf(buf, "%d", &val) == 1) {
+		pm_trace_enabled = !!val;
+		return n;
+	}
+	return -EINVAL;
+}
+
+power_attr(pm_trace);
+
+static struct attribute * g[] = {
+	&state_attr.attr,
+	&pm_trace_attr.attr,
+	NULL,
+};
+#else
 static struct attribute * g[] = {
 	&state_attr.attr,
 	NULL,
 };
+#endif /* CONFIG_PM_TRACE */
 
 static struct attribute_group attr_group = {
 	.attrs = g,

commit e3920fb42c8ddfe63befb54d95c0e13eabacea9b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:48 2006 -0700

    [PATCH] Disable CPU hotplug during suspend
    
    The current suspend code has to be run on one CPU, so we use the CPU
    hotplug to take the non-boot CPUs offline on SMP machines.  However, we
    should also make sure that these CPUs will not be enabled by someone else
    after we have disabled them.
    
    The functions disable_nonboot_cpus() and enable_nonboot_cpus() are moved to
    kernel/cpu.c, because they now refer to some stuff in there that should
    better be static.  Also it's better if disable_nonboot_cpus() returns an
    error instead of panicking if something goes wrong, and
    enable_nonboot_cpus() has no reason to panic(), because the CPUs may have
    been enabled by the userland before it tries to take them online.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6d295c776794..4d403323a7bb 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/pm.h>
 #include <linux/console.h>
+#include <linux/cpu.h>
 
 #include "power.h"
 
@@ -51,7 +52,7 @@ void pm_set_ops(struct pm_ops * ops)
 
 static int suspend_prepare(suspend_state_t state)
 {
-	int error = 0;
+	int error;
 	unsigned int free_pages;
 
 	if (!pm_ops || !pm_ops->enter)
@@ -59,12 +60,9 @@ static int suspend_prepare(suspend_state_t state)
 
 	pm_prepare_console();
 
-	disable_nonboot_cpus();
-
-	if (num_online_cpus() != 1) {
-		error = -EPERM;
+	error = disable_nonboot_cpus();
+	if (error)
 		goto Enable_cpu;
-	}
 
 	if (freeze_processes()) {
 		error = -EAGAIN;

commit 3b364b8d584b94777f8446a943b3c65e75e758f8
Author: Andreas Mohr <andi@rhlx01.fht-esslingen.de>
Date:   Sun Jun 25 05:47:56 2006 -0700

    [PATCH] constify parts of kernel/power/
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index cdf0f07af92f..6d295c776794 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -145,7 +145,7 @@ static void suspend_finish(suspend_state_t state)
 
 
 
-static char *pm_states[PM_SUSPEND_MAX] = {
+static const char * const pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 #ifdef CONFIG_SOFTWARE_SUSPEND
@@ -262,7 +262,7 @@ static ssize_t state_show(struct subsystem * subsys, char * buf)
 static ssize_t state_store(struct subsystem * subsys, const char * buf, size_t n)
 {
 	suspend_state_t state = PM_SUSPEND_STANDBY;
-	char ** s;
+	const char * const *s;
 	char *p;
 	int error;
 	int len;

commit 6cc0719181a7aa8883855140541e7892250e66af
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Jun 22 14:47:18 2006 -0700

    [PATCH] suspend_console() warning fix
    
    kernel/power/main.c: In function 'suspend_prepare':
    kernel/power/main.c:89: warning: implicit declaration of function 'suspend_console'
    kernel/power/main.c: In function 'suspend_finish':
    kernel/power/main.c:137: warning: implicit declaration of function 'resume_console'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 0a907f0dc56b..cdf0f07af92f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -15,7 +15,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/pm.h>
-
+#include <linux/console.h>
 
 #include "power.h"
 

commit 557240b48e2dc4f6fa878afc3fc767ad745ca7ed
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jun 19 18:16:01 2006 -0700

    Add support for suspending and resuming the whole console subsystem
    
    Trying to suspend/resume with console messages flying all around is
    doomed to failure, when the devices that the messages are trying to
    go to are being shut down.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index a6d9ef46009e..0a907f0dc56b 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -86,6 +86,7 @@ static int suspend_prepare(suspend_state_t state)
 			goto Thaw;
 	}
 
+	suspend_console();
 	if ((error = device_suspend(PMSG_SUSPEND))) {
 		printk(KERN_ERR "Some devices failed to suspend\n");
 		goto Finish;
@@ -133,6 +134,7 @@ int suspend_enter(suspend_state_t state)
 static void suspend_finish(suspend_state_t state)
 {
 	device_resume();
+	resume_console();
 	thaw_processes();
 	enable_nonboot_cpus();
 	if (pm_ops && pm_ops->finish)

commit 47bb789973fed504e4711ec34e63b84e6cbfb4e8
Author: dean gaudet <dean@arctic.org>
Date:   Thu Apr 27 18:39:17 2006 -0700

    [PATCH] off-by-1 in kernel/power/main.c
    
    There's an off-by-1 in kernel/power/main.c:state_store() ...  if your
    kernel just happens to have some non-zero data at pm_states[PM_SUSPEND_MAX]
    (i.e.  one past the end of the array) then it'll let you write anything you
    want to /sys/power/state and in response the box will enter S5.
    
    Signed-off-by: dean gaudet <dean@arctic.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index ee371f50ccaa..a6d9ef46009e 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -272,7 +272,7 @@ static ssize_t state_store(struct subsystem * subsys, const char * buf, size_t n
 		if (*s && !strncmp(buf, *s, len))
 			break;
 	}
-	if (*s)
+	if (state < PM_SUSPEND_MAX && *s)
 		error = enter_state(state);
 	else
 		error = -EINVAL;

commit 9b238205ba5d79a8a242d7a5ddb82b89e4dc4e48
Author: Luca Tettamanti <kronos.it@gmail.com>
Date:   Thu Mar 23 03:00:09 2006 -0800

    [PATCH] swsusp: add s2ram ioctl to userland interface
    
    Add the SNAPSHOT_S2RAM ioctl to the snapshot device.
    
    This ioctl allows a userland application to make the system (previously frozen
    with the SNAPSHOT_FREE ioctl) enter the S3 state without freezing processes
    and disabling nonboot CPUs for the second time.
    
    This will allow us to implement the suspend-to-disk-and-RAM (STDR)
    functionality in the userland suspend tools.
    
    Signed-off-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 9cb235cba4a9..ee371f50ccaa 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -103,7 +103,7 @@ static int suspend_prepare(suspend_state_t state)
 }
 
 
-static int suspend_enter(suspend_state_t state)
+int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
 	unsigned long flags;

commit 1a38416cea8ac801ae8f261074721f35317613dc
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Nov 23 12:36:00 2005 -0500

    [ACPI] SMP S3 resume: evaluate _WAK after INIT
    
    On SMP resume from S3, we reset (INIT) the non-boot
    processors to boot them cleanly.  But the BIOS needs
    to execute _WAK after INIT in order to properly
    initialized these processors upon resume.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5651
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index d253f3ae2fa5..9cb235cba4a9 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -133,10 +133,10 @@ static int suspend_enter(suspend_state_t state)
 static void suspend_finish(suspend_state_t state)
 {
 	device_resume();
-	if (pm_ops && pm_ops->finish)
-		pm_ops->finish(state);
 	thaw_processes();
 	enable_nonboot_cpus();
+	if (pm_ops && pm_ops->finish)
+		pm_ops->finish(state);
 	pm_restore_console();
 }
 

commit 123d3c13e2853a11b4d599d754b356acb12886e2
Author: Pavel Machek <pavel@ucw.cz>
Date:   Tue Nov 29 19:34:37 2005 -0800

    [PATCH] fix swsusp on machines not supporting S4
    
    Fix swsusp on machines not supporting S4.  With recent changes, it is not
    possible to trigger it using /sys filesystem.  Swsusp does not really need
    any support from low-level code, it is possible to reboot or halt at the
    end of suspend.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Cc: "Brown, Len" <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 6ee2cad530e8..d253f3ae2fa5 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -24,7 +24,7 @@
 
 DECLARE_MUTEX(pm_sem);
 
-struct pm_ops * pm_ops = NULL;
+struct pm_ops *pm_ops;
 suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
 
 /**
@@ -151,6 +151,18 @@ static char *pm_states[PM_SUSPEND_MAX] = {
 #endif
 };
 
+static inline int valid_state(suspend_state_t state)
+{
+	/* Suspend-to-disk does not really need low-level support.
+	 * It can work with reboot if needed. */
+	if (state == PM_SUSPEND_DISK)
+		return 1;
+
+	if (pm_ops && pm_ops->valid && !pm_ops->valid(state))
+		return 0;
+	return 1;
+}
+
 
 /**
  *	enter_state - Do common work of entering low-power state.
@@ -167,7 +179,7 @@ static int enter_state(suspend_state_t state)
 {
 	int error;
 
-	if (pm_ops && pm_ops->valid && !pm_ops->valid(state))
+	if (!valid_state(state))
 		return -ENODEV;
 	if (down_trylock(&pm_sem))
 		return -EBUSY;
@@ -238,9 +250,8 @@ static ssize_t state_show(struct subsystem * subsys, char * buf)
 	char * s = buf;
 
 	for (i = 0; i < PM_SUSPEND_MAX; i++) {
-		if (pm_states[i] && pm_ops && (!pm_ops->valid
-			||(pm_ops->valid && pm_ops->valid(i))))
-			s += sprintf(s,"%s ",pm_states[i]);
+		if (pm_states[i] && valid_state(i))
+			s += sprintf(s,"%s ", pm_states[i]);
 	}
 	s += sprintf(s,"\n");
 	return (s - buf);

commit 969e9afd489514252a680914c6d8b9322c713eb4
Author: Pavel Machek <pavel@ucw.cz>
Date:   Tue Nov 8 21:34:30 2005 -0800

    [PATCH] sleep: Fix oops in enter_state
    
    If ACPI sleep is not configured, but someone still wants to run swsusp,
    he'd get oops in enter_state.  This is regression since 2.6.14 and this
    fixes it.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 18d7d693fbba..6ee2cad530e8 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -167,7 +167,7 @@ static int enter_state(suspend_state_t state)
 {
 	int error;
 
-	if (pm_ops->valid && !pm_ops->valid(state))
+	if (pm_ops && pm_ops->valid && !pm_ops->valid(state))
 		return -ENODEV;
 	if (down_trylock(&pm_sem))
 		return -EBUSY;

commit eb9289eb20df6b54214c45ac7c6bf5179a149026
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Sun Oct 30 15:00:01 2005 -0800

    [PATCH] introduce .valid callback for pm_ops
    
    Add pm_ops.valid callback, so only the available pm states show in
    /sys/power/state.  And this also makes an earlier states error report at
    enter_state before we do actual suspend/resume.
    
    Signed-off-by: Shaohua Li<shaohua.li@intel.com>
    Acked-by: Pavel Machek<pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 22bdc93cc038..18d7d693fbba 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -167,6 +167,8 @@ static int enter_state(suspend_state_t state)
 {
 	int error;
 
+	if (pm_ops->valid && !pm_ops->valid(state))
+		return -ENODEV;
 	if (down_trylock(&pm_sem))
 		return -EBUSY;
 
@@ -236,7 +238,8 @@ static ssize_t state_show(struct subsystem * subsys, char * buf)
 	char * s = buf;
 
 	for (i = 0; i < PM_SUSPEND_MAX; i++) {
-		if (pm_states[i])
+		if (pm_states[i] && pm_ops && (!pm_ops->valid
+			||(pm_ops->valid && pm_ops->valid(i))))
 			s += sprintf(s,"%s ",pm_states[i]);
 	}
 	s += sprintf(s,"\n");

commit 57c4ce3cbfba1bb0da7f37b9328a713cbd5d0919
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:57:06 2005 -0700

    [PATCH] pm: clean up /sys/power/disk
    
    Clean code up a bit, and only show suspend to disk as available when
    it is configured in.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 71aa0fd22007..22bdc93cc038 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -143,11 +143,12 @@ static void suspend_finish(suspend_state_t state)
 
 
 
-static char * pm_states[] = {
+static char *pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
+#ifdef CONFIG_SOFTWARE_SUSPEND
 	[PM_SUSPEND_DISK]	= "disk",
-	NULL,
+#endif
 };
 
 

commit 5028770a42e7bc4d15791a44c28f0ad539323807
Merge: 9f02d6b7b43d d8683a0cb5d0
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 12 17:21:56 2005 -0400

    [ACPI] merge acpi-2.6.12 branch into latest Linux 2.6.13-rc...
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5ae947ecc9c1c23834201e5321684a5cb68bdd3f
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Mar 18 16:27:13 2005 -0500

    [ACPI] Suspend to RAM fix
    
    Free some RAM before entering S3 so that upon
    resume we can be sure early allocations will succeed.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index c7eb4a833db5..454434716f35 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -19,6 +19,9 @@
 
 #include "power.h"
 
+/*This is just an arbitrary number */
+#define FREE_PAGE_NUMBER (100)
+
 DECLARE_MUTEX(pm_sem);
 
 struct pm_ops * pm_ops = NULL;
@@ -49,6 +52,7 @@ void pm_set_ops(struct pm_ops * ops)
 static int suspend_prepare(suspend_state_t state)
 {
 	int error = 0;
+	unsigned int free_pages;
 
 	if (!pm_ops || !pm_ops->enter)
 		return -EPERM;
@@ -60,6 +64,16 @@ static int suspend_prepare(suspend_state_t state)
 		goto Thaw;
 	}
 
+	if ((free_pages = nr_free_pages()) < FREE_PAGE_NUMBER) {
+		pr_debug("PM: free some memory\n");
+		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
+		if (nr_free_pages() < FREE_PAGE_NUMBER) {
+			error = -ENOMEM;
+			printk(KERN_ERR "PM: No enough memory\n");
+			goto Thaw;
+		}
+	}
+
 	if (pm_ops->prepare) {
 		if ((error = pm_ops->prepare(state)))
 			goto Thaw;

commit e2a5b420f716cd1a46674b1a90389612eced916f
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Mar 18 16:20:46 2005 -0500

    [ACPI] ACPI poweroff fix
    
    Register an "acpi" system device to be notified of shutdown preparation.
    This depends on CONFIG_PM
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4041
    
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 4cdebc972ff2..c7eb4a833db5 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -190,7 +190,7 @@ int software_suspend(void)
 
 int pm_suspend(suspend_state_t state)
 {
-	if (state > PM_SUSPEND_ON && state < PM_SUSPEND_MAX)
+	if (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX)
 		return enter_state(state);
 	return -EINVAL;
 }

commit 5a72e04df5470df0ec646029d31e5528167ab1a7
Author: Li Shaohua <shaohua.li@intel.com>
Date:   Sat Jun 25 14:55:06 2005 -0700

    [PATCH] suspend/resume SMP support
    
    Using CPU hotplug to support suspend/resume SMP.  Both S3 and S4 use
    disable/enable_nonboot_cpus API.  The S4 part is based on Pavel's original S4
    SMP patch.
    
    Signed-off-by: Li Shaohua<shaohua.li@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 4cdebc972ff2..c94cb9e95090 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -55,6 +55,13 @@ static int suspend_prepare(suspend_state_t state)
 
 	pm_prepare_console();
 
+	disable_nonboot_cpus();
+
+	if (num_online_cpus() != 1) {
+		error = -EPERM;
+		goto Enable_cpu;
+	}
+
 	if (freeze_processes()) {
 		error = -EAGAIN;
 		goto Thaw;
@@ -75,6 +82,8 @@ static int suspend_prepare(suspend_state_t state)
 		pm_ops->finish(state);
  Thaw:
 	thaw_processes();
+ Enable_cpu:
+	enable_nonboot_cpus();
 	pm_restore_console();
 	return error;
 }
@@ -113,6 +122,7 @@ static void suspend_finish(suspend_state_t state)
 	if (pm_ops && pm_ops->finish)
 		pm_ops->finish(state);
 	thaw_processes();
+	enable_nonboot_cpus();
 	pm_restore_console();
 }
 
@@ -150,12 +160,6 @@ static int enter_state(suspend_state_t state)
 		goto Unlock;
 	}
 
-	/* Suspend is hard to get right on SMP. */
-	if (num_online_cpus() != 1) {
-		error = -EPERM;
-		goto Unlock;
-	}
-
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	if ((error = suspend_prepare(state)))
 		goto Unlock;

commit 82428b62aa6294ea640c7e920a9224ecaf46db65
Author: David Brownell <david-b@pacbell.net>
Date:   Mon May 9 08:07:00 2005 -0700

    [PATCH] Driver Core: pm diagnostics update, check for errors
    
    This patch includes various tweaks in the messaging that appears during
    system pm state transitions:
    
      * Warn about certain illegal calls in the device tree, like resuming
        child before parent or suspending parent before child.  This could
        happen easily enough through sysfs, or in some cases when drivers
        use device_pm_set_parent().
    
      * Be more consistent about dev_dbg() tracing ... do it for resume() and
        shutdown() too, and never if the driver doesn't have that method.
    
      * Say which type of system sleep state is being entered.
    
    Except for the warnings, these only affect debug messaging.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 7960ddf04a57..4cdebc972ff2 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -156,14 +156,14 @@ static int enter_state(suspend_state_t state)
 		goto Unlock;
 	}
 
-	pr_debug("PM: Preparing system for suspend\n");
+	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	if ((error = suspend_prepare(state)))
 		goto Unlock;
 
-	pr_debug("PM: Entering state.\n");
+	pr_debug("PM: Entering %s sleep\n", pm_states[state]);
 	error = suspend_enter(state);
 
-	pr_debug("PM: Finishing up.\n");
+	pr_debug("PM: Finishing wakeup.\n");
 	suspend_finish(state);
  Unlock:
 	up(&pm_sem);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/kernel/power/main.c b/kernel/power/main.c
new file mode 100644
index 000000000000..7960ddf04a57
--- /dev/null
+++ b/kernel/power/main.c
@@ -0,0 +1,269 @@
+/*
+ * kernel/power/main.c - PM subsystem core functionality.
+ *
+ * Copyright (c) 2003 Patrick Mochel
+ * Copyright (c) 2003 Open Source Development Lab
+ * 
+ * This file is released under the GPLv2
+ *
+ */
+
+#include <linux/suspend.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+
+
+#include "power.h"
+
+DECLARE_MUTEX(pm_sem);
+
+struct pm_ops * pm_ops = NULL;
+suspend_disk_method_t pm_disk_mode = PM_DISK_SHUTDOWN;
+
+/**
+ *	pm_set_ops - Set the global power method table. 
+ *	@ops:	Pointer to ops structure.
+ */
+
+void pm_set_ops(struct pm_ops * ops)
+{
+	down(&pm_sem);
+	pm_ops = ops;
+	up(&pm_sem);
+}
+
+
+/**
+ *	suspend_prepare - Do prep work before entering low-power state.
+ *	@state:		State we're entering.
+ *
+ *	This is common code that is called for each state that we're 
+ *	entering. Allocate a console, stop all processes, then make sure
+ *	the platform can enter the requested state.
+ */
+
+static int suspend_prepare(suspend_state_t state)
+{
+	int error = 0;
+
+	if (!pm_ops || !pm_ops->enter)
+		return -EPERM;
+
+	pm_prepare_console();
+
+	if (freeze_processes()) {
+		error = -EAGAIN;
+		goto Thaw;
+	}
+
+	if (pm_ops->prepare) {
+		if ((error = pm_ops->prepare(state)))
+			goto Thaw;
+	}
+
+	if ((error = device_suspend(PMSG_SUSPEND))) {
+		printk(KERN_ERR "Some devices failed to suspend\n");
+		goto Finish;
+	}
+	return 0;
+ Finish:
+	if (pm_ops->finish)
+		pm_ops->finish(state);
+ Thaw:
+	thaw_processes();
+	pm_restore_console();
+	return error;
+}
+
+
+static int suspend_enter(suspend_state_t state)
+{
+	int error = 0;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	if ((error = device_power_down(PMSG_SUSPEND))) {
+		printk(KERN_ERR "Some devices failed to power down\n");
+		goto Done;
+	}
+	error = pm_ops->enter(state);
+	device_power_up();
+ Done:
+	local_irq_restore(flags);
+	return error;
+}
+
+
+/**
+ *	suspend_finish - Do final work before exiting suspend sequence.
+ *	@state:		State we're coming out of.
+ *
+ *	Call platform code to clean up, restart processes, and free the 
+ *	console that we've allocated. This is not called for suspend-to-disk.
+ */
+
+static void suspend_finish(suspend_state_t state)
+{
+	device_resume();
+	if (pm_ops && pm_ops->finish)
+		pm_ops->finish(state);
+	thaw_processes();
+	pm_restore_console();
+}
+
+
+
+
+static char * pm_states[] = {
+	[PM_SUSPEND_STANDBY]	= "standby",
+	[PM_SUSPEND_MEM]	= "mem",
+	[PM_SUSPEND_DISK]	= "disk",
+	NULL,
+};
+
+
+/**
+ *	enter_state - Do common work of entering low-power state.
+ *	@state:		pm_state structure for state we're entering.
+ *
+ *	Make sure we're the only ones trying to enter a sleep state. Fail
+ *	if someone has beat us to it, since we don't want anything weird to
+ *	happen when we wake up.
+ *	Then, do the setup for suspend, enter the state, and cleaup (after
+ *	we've woken up).
+ */
+
+static int enter_state(suspend_state_t state)
+{
+	int error;
+
+	if (down_trylock(&pm_sem))
+		return -EBUSY;
+
+	if (state == PM_SUSPEND_DISK) {
+		error = pm_suspend_disk();
+		goto Unlock;
+	}
+
+	/* Suspend is hard to get right on SMP. */
+	if (num_online_cpus() != 1) {
+		error = -EPERM;
+		goto Unlock;
+	}
+
+	pr_debug("PM: Preparing system for suspend\n");
+	if ((error = suspend_prepare(state)))
+		goto Unlock;
+
+	pr_debug("PM: Entering state.\n");
+	error = suspend_enter(state);
+
+	pr_debug("PM: Finishing up.\n");
+	suspend_finish(state);
+ Unlock:
+	up(&pm_sem);
+	return error;
+}
+
+/*
+ * This is main interface to the outside world. It needs to be
+ * called from process context.
+ */
+int software_suspend(void)
+{
+	return enter_state(PM_SUSPEND_DISK);
+}
+
+
+/**
+ *	pm_suspend - Externally visible function for suspending system.
+ *	@state:		Enumarted value of state to enter.
+ *
+ *	Determine whether or not value is within range, get state 
+ *	structure, and enter (above).
+ */
+
+int pm_suspend(suspend_state_t state)
+{
+	if (state > PM_SUSPEND_ON && state < PM_SUSPEND_MAX)
+		return enter_state(state);
+	return -EINVAL;
+}
+
+
+
+decl_subsys(power,NULL,NULL);
+
+
+/**
+ *	state - control system power state.
+ *
+ *	show() returns what states are supported, which is hard-coded to
+ *	'standby' (Power-On Suspend), 'mem' (Suspend-to-RAM), and
+ *	'disk' (Suspend-to-Disk).
+ *
+ *	store() accepts one of those strings, translates it into the 
+ *	proper enumerated value, and initiates a suspend transition.
+ */
+
+static ssize_t state_show(struct subsystem * subsys, char * buf)
+{
+	int i;
+	char * s = buf;
+
+	for (i = 0; i < PM_SUSPEND_MAX; i++) {
+		if (pm_states[i])
+			s += sprintf(s,"%s ",pm_states[i]);
+	}
+	s += sprintf(s,"\n");
+	return (s - buf);
+}
+
+static ssize_t state_store(struct subsystem * subsys, const char * buf, size_t n)
+{
+	suspend_state_t state = PM_SUSPEND_STANDBY;
+	char ** s;
+	char *p;
+	int error;
+	int len;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) {
+		if (*s && !strncmp(buf, *s, len))
+			break;
+	}
+	if (*s)
+		error = enter_state(state);
+	else
+		error = -EINVAL;
+	return error ? error : n;
+}
+
+power_attr(state);
+
+static struct attribute * g[] = {
+	&state_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+
+static int __init pm_init(void)
+{
+	int error = subsystem_register(&power_subsys);
+	if (!error)
+		error = sysfs_create_group(&power_subsys.kset.kobj,&attr_group);
+	return error;
+}
+
+core_initcall(pm_init);
