commit 2277b492582d5525244519f60da6f9daea5ef41a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Sep 25 13:02:20 2019 -0700

    kdb: Fix stack crawling on 'running' CPUs that aren't the master
    
    In kdb when you do 'btc' (back trace on CPU) it doesn't necessarily
    give you the right info.  Specifically on many architectures
    (including arm64, where I tested) you can't dump the stack of a
    "running" process that isn't the process running on the current CPU.
    This can be seen by this:
    
     echo SOFTLOCKUP > /sys/kernel/debug/provoke-crash/DIRECT
     # wait 2 seconds
     <sysrq>g
    
    Here's what I see now on rk3399-gru-kevin.  I see the stack crawl for
    the CPU that handled the sysrq but everything else just shows me stuck
    in __switch_to() which is bogus:
    
    ======
    
    [0]kdb> btc
    btc: cpu status: Currently on cpu 0
    Available cpus: 0, 1-3(I), 4, 5(I)
    Stack traceback for pid 0
    0xffffff801101a9c0        0        0  1    0   R  0xffffff801101b3b0 *swapper/0
    Call trace:
     dump_backtrace+0x0/0x138
     ...
     kgdb_compiled_brk_fn+0x34/0x44
     ...
     sysrq_handle_dbg+0x34/0x5c
    Stack traceback for pid 0
    0xffffffc0f175a040        0        0  1    1   I  0xffffffc0f175aa30  swapper/1
    Call trace:
     __switch_to+0x1e4/0x240
     0xffffffc0f65616c0
    Stack traceback for pid 0
    0xffffffc0f175d040        0        0  1    2   I  0xffffffc0f175da30  swapper/2
    Call trace:
     __switch_to+0x1e4/0x240
     0xffffffc0f65806c0
    Stack traceback for pid 0
    0xffffffc0f175b040        0        0  1    3   I  0xffffffc0f175ba30  swapper/3
    Call trace:
     __switch_to+0x1e4/0x240
     0xffffffc0f659f6c0
    Stack traceback for pid 1474
    0xffffffc0dde8b040     1474      727  1    4   R  0xffffffc0dde8ba30  bash
    Call trace:
     __switch_to+0x1e4/0x240
     __schedule+0x464/0x618
     0xffffffc0dde8b040
    Stack traceback for pid 0
    0xffffffc0f17b0040        0        0  1    5   I  0xffffffc0f17b0a30  swapper/5
    Call trace:
     __switch_to+0x1e4/0x240
     0xffffffc0f65dd6c0
    
    ===
    
    The problem is that 'btc' eventually boils down to
      show_stack(task_struct, NULL);
    
    ...and show_stack() doesn't work for "running" CPUs because their
    registers haven't been stashed.
    
    On x86 things might work better (I haven't tested) because kdb has a
    special case for x86 in kdb_show_stack() where it passes the stack
    pointer to show_stack().  This wouldn't work on arm64 where the stack
    crawling function seems needs the "fp" and "pc", not the "sp" which is
    presumably why arm64's show_stack() function totally ignores the "sp"
    parameter.
    
    NOTE: we _can_ get a good stack dump for all the cpus if we manually
    switch each one to the kdb master and do a back trace.  AKA:
      cpu 4
      bt
    ...will give the expected trace.  That's because now arm64's
    dump_backtrace will now see that "tsk == current" and go through a
    different path.
    
    In this patch I fix the problems by catching a request to stack crawl
    a task that's running on a CPU and then I ask that CPU to do the stack
    crawl.
    
    NOTE: this will (presumably) change what stack crawls are printed for
    x86 machines.  Now kdb functions will show up in the stack crawl.
    Presumably this is OK but if it's not we can go back and add a special
    case for x86 again.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Will Deacon <will@kernel.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 804b0fe5a0ba..cd22b5f68831 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -33,6 +33,7 @@ struct kgdb_state {
 #define DCPU_WANT_MASTER 0x1 /* Waiting to become a master kgdb cpu */
 #define DCPU_NEXT_MASTER 0x2 /* Transition from one master cpu to another */
 #define DCPU_IS_SLAVE    0x4 /* Slave cpu enter exception */
+#define DCPU_WANT_BT     0x8 /* Slave cpu should backtrace then clear flag */
 
 struct debuggerinfo_struct {
 	void			*debuggerinfo;
@@ -75,6 +76,7 @@ extern int kdb_stub(struct kgdb_state *ks);
 extern int kdb_parse(const char *cmdstr);
 extern int kdb_common_init_state(struct kgdb_state *ks);
 extern int kdb_common_deinit_state(void);
+extern void kdb_dump_stack_on_cpu(int cpu);
 #else /* ! CONFIG_KGDB_KDB */
 static inline int kdb_stub(struct kgdb_state *ks)
 {

commit 0f8b5b6d56b5fa4085c06945ea3e1ee5941ecfeb
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Sep 25 13:02:17 2019 -0700

    kgdb: Remove unused DCPU_SSTEP definition
    
    From doing a 'git log --patch kernel/debug', it looks as if DCPU_SSTEP
    has never been used.  Presumably it used to be used back when kgdb was
    out of tree and nobody thought to delete the definition when the usage
    went away.  Delete.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Will Deacon <will@kernel.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index b4a7c326d546..804b0fe5a0ba 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -33,7 +33,6 @@ struct kgdb_state {
 #define DCPU_WANT_MASTER 0x1 /* Waiting to become a master kgdb cpu */
 #define DCPU_NEXT_MASTER 0x2 /* Transition from one master cpu to another */
 #define DCPU_IS_SLAVE    0x4 /* Slave cpu enter exception */
-#define DCPU_SSTEP       0x8 /* CPU is single stepping */
 
 struct debuggerinfo_struct {
 	void			*debuggerinfo;

commit 87b095928584da7d5cb3149016f00b0b139c2292
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 19:38:27 2018 -0800

    kgdb: Don't round up a CPU that failed rounding up before
    
    If we're using the default implementation of kgdb_roundup_cpus() that
    uses smp_call_function_single_async() we can end up hanging
    kgdb_roundup_cpus() if we try to round up a CPU that failed to round
    up before.
    
    Specifically smp_call_function_single_async() will try to wait on the
    csd lock for the CPU that we're trying to round up.  If the previous
    round up never finished then that lock could still be held and we'll
    just sit there hanging.
    
    There's not a lot of use trying to round up a CPU that failed to round
    up before.  Let's keep a flag that indicates whether the CPU started
    but didn't finish to round up before.  If we see that flag set then
    we'll skip the next round up.
    
    In general we have a few goals here:
    - We never want to end up calling smp_call_function_single_async()
      when the csd is still locked.  This is accomplished because
      flush_smp_call_function_queue() unlocks the csd _before_ invoking
      the callback.  That means that when kgdb_nmicallback() runs we know
      for sure the the csd is no longer locked.  Thus when we set
      "rounding_up = false" we know for sure that the csd is unlocked.
    - If there are no timeouts rounding up we should never skip a round
      up.
    
    NOTE #1: In general trying to continue running after failing to round
    up CPUs doesn't appear to be supported in the debugger.  When I
    simulate this I find that kdb reports "Catastrophic error detected"
    when I try to continue.  I can overrule and continue anyway, but it
    should be noted that we may be entering the land of dragons here.
    Possibly the "Catastrophic error detected" was added _because_ of the
    future failure to round up, but even so this is an area of the code
    that hasn't been strongly tested.
    
    NOTE #2: I did a bit of testing before and after this change.  I
    introduced a 10 second hang in the kernel while holding a spinlock
    that I could invoke on a certain CPU with 'taskset -c 3 cat /sys/...".
    
    Before this change if I did:
    - Invoke hang
    - Enter debugger
    - g (which warns about Catastrophic error, g again to go anyway)
    - g
    - Enter debugger
    
    ...I'd hang the rest of the 10 seconds without getting a debugger
    prompt.  After this change I end up in the debugger the 2nd time after
    only 1 second with the standard warning about 'Timed out waiting for
    secondary CPUs.'
    
    I'll also note that once the CPU finished waiting I could actually
    debug it (aka "btc" worked)
    
    I won't promise that everything works perfectly if the errant CPU
    comes back at just the wrong time (like as we're entering or exiting
    the debugger) but it certainly seems like an improvement.
    
    NOTE #3: setting 'kgdb_info[cpu].rounding_up = false' is in
    kgdb_nmicallback() instead of kgdb_call_nmi_hook() because some
    implementations override kgdb_call_nmi_hook().  It shouldn't hurt to
    have it in kgdb_nmicallback() in any case.
    
    NOTE #4: this logic is really only needed because there is no API call
    like "smp_try_call_function_single_async()" or "smp_csd_is_locked()".
    If such an API existed then we'd use it instead, but it seemed a bit
    much to add an API like this just for kgdb.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 127d9bc49fb4..b4a7c326d546 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -42,6 +42,7 @@ struct debuggerinfo_struct {
 	int			ret_state;
 	int			irq_depth;
 	int			enter_kgdb;
+	bool			rounding_up;
 };
 
 extern struct debuggerinfo_struct kgdb_info[];

commit fc8b13740b2978b34872650cc8e928392e3758aa
Author: Mike Travis <travis@sgi.com>
Date:   Tue Jan 14 10:25:52 2014 -0600

    kgdb/kdb: Fix no KDB config problem
    
    Some code added to the debug_core module had KDB dependencies
    that it shouldn't have.  Move the KDB dependent REASON back to
    the caller to remove the dependency in the debug core code.
    
    Update the call from the UV NMI handler to conform to the new
    interface.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Reviewed-by: Hedi Berriche <hedi@sgi.com>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Link: http://lkml.kernel.org/r/20140114162551.318251993@asylum.americas.sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 572aa4f5677c..127d9bc49fb4 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -75,13 +75,11 @@ extern int kdb_stub(struct kgdb_state *ks);
 extern int kdb_parse(const char *cmdstr);
 extern int kdb_common_init_state(struct kgdb_state *ks);
 extern int kdb_common_deinit_state(void);
-#define KGDB_KDB_REASON_SYSTEM_NMI KDB_REASON_SYSTEM_NMI
 #else /* ! CONFIG_KGDB_KDB */
 static inline int kdb_stub(struct kgdb_state *ks)
 {
 	return DBG_PASS_EVENT;
 }
-#define KGDB_KDB_REASON_SYSTEM_NMI 0
 #endif /* CONFIG_KGDB_KDB */
 
 #endif /* _DEBUG_CORE_H_ */

commit 8daaa5f8261bffd2f6217a960f9182d0503a5c44
Author: Mike Travis <travis@sgi.com>
Date:   Wed Oct 2 10:14:18 2013 -0500

    kdb: Add support for external NMI handler to call KGDB/KDB
    
    This patch adds a kgdb_nmicallin() interface that can be used by
    external NMI handlers to call the KGDB/KDB handler.  The primary
    need for this is for those types of NMI interrupts where all the
    CPUs have already received the NMI signal.  Therefore no
    send_IPI(NMI) is required, and in fact it will cause a 2nd
    unhandled NMI to occur. This generates the "Dazed and Confuzed"
    messages.
    
    Since all the CPUs are getting the NMI at roughly the same time,
    it's not guaranteed that the first CPU that hits the NMI handler
    will manage to enter KGDB and set the dbg_master_lock before the
    slaves start entering. The new argument "send_ready" was added
    for KGDB to signal the NMI handler to release the slave CPUs for
    entry into KGDB.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
    Reviewed-by: Hedi Berriche <hedi@sgi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Link: http://lkml.kernel.org/r/20131002151417.928886849@asylum.americas.sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 2235967e78b0..572aa4f5677c 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -26,6 +26,7 @@ struct kgdb_state {
 	unsigned long		threadid;
 	long			kgdb_usethreadid;
 	struct pt_regs		*linux_regs;
+	atomic_t		*send_ready;
 };
 
 /* Exception state values */
@@ -74,11 +75,13 @@ extern int kdb_stub(struct kgdb_state *ks);
 extern int kdb_parse(const char *cmdstr);
 extern int kdb_common_init_state(struct kgdb_state *ks);
 extern int kdb_common_deinit_state(void);
+#define KGDB_KDB_REASON_SYSTEM_NMI KDB_REASON_SYSTEM_NMI
 #else /* ! CONFIG_KGDB_KDB */
 static inline int kdb_stub(struct kgdb_state *ks)
 {
 	return DBG_PASS_EVENT;
 }
+#define KGDB_KDB_REASON_SYSTEM_NMI 0
 #endif /* CONFIG_KGDB_KDB */
 
 #endif /* _DEBUG_CORE_H_ */

commit 00370b8f8dd6e3171b8202f9c5187a5f73e99497
Author: Matt Klein <mklein@twitter.com>
Date:   Wed Jan 2 13:20:49 2013 -0800

    kdb: Setup basic kdb state before invoking commands via kgdb
    
    Although invasive kdb commands are not supported via kgdb, some useful
    non-invasive commands like bt* require basic kdb state to be setup before
    calling into the kdb code. Factor out some of this code and call it before
    and after executing kdb commands via kgdb.
    
    Signed-off-by: Matt Klein <mklein@twitter.com>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 3494c28a7e7a..2235967e78b0 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -72,6 +72,8 @@ extern int dbg_kdb_mode;
 #ifdef CONFIG_KGDB_KDB
 extern int kdb_stub(struct kgdb_state *ks);
 extern int kdb_parse(const char *cmdstr);
+extern int kdb_common_init_state(struct kgdb_state *ks);
+extern int kdb_common_deinit_state(void);
 #else /* ! CONFIG_KGDB_KDB */
 static inline int kdb_stub(struct kgdb_state *ks)
 {

commit dfee3a7b92208b30f77876068aece9ea571270c2
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri May 21 08:46:00 2010 -0500

    debug_core: refactor locking for master/slave cpus
    
    For quite some time there have been problems with memory barriers and
    various races with NMI on multi processor systems using the kernel
    debugger.  The algorithm for entering the kernel debug core and
    resuming kernel execution was racy and had several known edge case
    problems with attempting to debug something on a heavily loaded system
    using breakpoints that are hit repeatedly and quickly.
    
    The prior "locking" design entry worked as follows:
    
      * The atomic counter kgdb_active was used with atomic exchange in
        order to elect a master cpu out of all the cpus that may have
        taken a debug exception.
      * The master cpu increments all elements of passive_cpu_wait[].
      * The master cpu issues the round up cpus message.
      * Each "slave cpu" that enters the debug core increments its own
        element in cpu_in_kgdb[].
      * Each "slave cpu" spins on passive_cpu_wait[] until it becomes 0.
      * The master cpu debugs the system.
    
    The new scheme removes the two arrays of atomic counters and replaces
    them with 2 single counters.  One counter is used to count the number
    of cpus waiting to become a master cpu (because one or more hit an
    exception). The second counter is use to indicate how many cpus have
    entered as slave cpus.
    
    The new entry logic works as follows:
    
      * One or more cpus enters via kgdb_handle_exception() and increments
        the masters_in_kgdb. Each cpu attempts to get the spin lock called
        dbg_master_lock.
      * The master cpu sets kgdb_active to the current cpu.
      * The master cpu takes the spinlock dbg_slave_lock.
      * The master cpu asks to round up all the other cpus.
      * Each slave cpu that is not already in kgdb_handle_exception()
        will enter and increment slaves_in_kgdb.  Each slave will now spin
        try_locking on dbg_slave_lock.
      * The master cpu waits for the sum of masters_in_kgdb and slaves_in_kgdb
        to be equal to the sum of the online cpus.
      * The master cpu debugs the system.
    
    In the new design the kgdb_active can only be changed while holding
    dbg_master_lock.  Stress testing has not turned up any further
    entry/exit races that existed in the prior locking design.  The prior
    locking design suffered from atomic variables not being truly atomic
    (in the capacity as used by kgdb) along with memory barrier races.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Dongdong Deng <dongdong.deng@windriver.com>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index c5d753d80f67..3494c28a7e7a 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -40,6 +40,7 @@ struct debuggerinfo_struct {
 	int			exception_state;
 	int			ret_state;
 	int			irq_depth;
+	int			enter_kgdb;
 };
 
 extern struct debuggerinfo_struct kgdb_info[];

commit a0de055cf61338549b13079a5677ef2e1b6472ef
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:24 2010 -0500

    kgdb: gdb "monitor" -> kdb passthrough
    
    One of the driving forces behind integrating another front end (kdb)
    to the debug core is to allow front end commands to be accessible via
    gdb's monitor command.  It is true that you could write gdb macros to
    get certain data, but you may want to just use gdb to access the
    commands that are available in the kdb front end.
    
    This patch implements the Rcmd gdb stub packet.  In gdb you access
    this with the "monitor" command.  For instance you could type "monitor
    help", "monitor lsmod" or "monitor ps A" etc...
    
    There is no error checking or command restrictions on what you can and
    cannot access at this point.  Doing something like trying to set
    breakpoints with the monitor command is going to cause nothing but
    problems.  Perhaps in the future only the commands that are actually
    known to work with the gdb monitor command will be available.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index 44cf3de8cf9e..c5d753d80f67 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -66,9 +66,11 @@ extern void gdbstub_msg_write(const char *s, int len);
 
 /* gdbstub functions used for kdb <-> gdbstub transition */
 extern int gdbstub_state(struct kgdb_state *ks, char *cmd);
+extern int dbg_kdb_mode;
 
 #ifdef CONFIG_KGDB_KDB
 extern int kdb_stub(struct kgdb_state *ks);
+extern int kdb_parse(const char *cmdstr);
 #else /* ! CONFIG_KGDB_KDB */
 static inline int kdb_stub(struct kgdb_state *ks)
 {

commit dcc7871128e99458ca86186b7bc8bf27ff0c47b5
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:21 2010 -0500

    kgdb: core changes to support kdb
    
    These are the minimum changes to the kgdb core in order to enable an
    API to connect a new front end (kdb) to the debug core.
    
    This patch introduces the dbg_kdb_mode variable controls where the
    user level I/O is routed.  It will be routed to the gdbstub (kgdb) or
    to the kdb front end which is a simple shell available over the kgdboc
    connection.
    
    You can switch back and forth between kdb or the gdb stub mode of
    operation dynamically.  From gdb stub mode you can blindly type
    "$3#33", or from the kdb mode you can enter "kgdb" to switch to the
    gdb stub.
    
    The logic in the debug core depends on kdb to look for the typical gdb
    connection sequences and return immediately with KGDB_PASS_EVENT if a
    gdb serial command sequence is detected.  That should allow a
    reasonably seamless transition between kdb -> gdb without leaving the
    kernel exception state.  The two gdb serial queries that kdb is
    responsible for detecting are the "?" and "qSupported" packets.
    
    CC: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Martin Hicks <mort@sgi.com>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
index db554f9be51d..44cf3de8cf9e 100644
--- a/kernel/debug/debug_core.h
+++ b/kernel/debug/debug_core.h
@@ -38,6 +38,8 @@ struct debuggerinfo_struct {
 	void			*debuggerinfo;
 	struct task_struct	*task;
 	int			exception_state;
+	int			ret_state;
+	int			irq_depth;
 };
 
 extern struct debuggerinfo_struct kgdb_info[];
@@ -47,9 +49,31 @@ extern int dbg_remove_all_break(void);
 extern int dbg_set_sw_break(unsigned long addr);
 extern int dbg_remove_sw_break(unsigned long addr);
 extern int dbg_activate_sw_breakpoints(void);
+extern int dbg_deactivate_sw_breakpoints(void);
+
+/* polled character access to i/o module */
+extern int dbg_io_get_char(void);
+
+/* stub return value for switching between the gdbstub and kdb */
+#define DBG_PASS_EVENT -12345
+/* Switch from one cpu to another */
+#define DBG_SWITCH_CPU_EVENT -123456
+extern int dbg_switch_cpu;
 
 /* gdbstub interface functions */
 extern int gdb_serial_stub(struct kgdb_state *ks);
 extern void gdbstub_msg_write(const char *s, int len);
 
+/* gdbstub functions used for kdb <-> gdbstub transition */
+extern int gdbstub_state(struct kgdb_state *ks, char *cmd);
+
+#ifdef CONFIG_KGDB_KDB
+extern int kdb_stub(struct kgdb_state *ks);
+#else /* ! CONFIG_KGDB_KDB */
+static inline int kdb_stub(struct kgdb_state *ks)
+{
+	return DBG_PASS_EVENT;
+}
+#endif /* CONFIG_KGDB_KDB */
+
 #endif /* _DEBUG_CORE_H_ */

commit 53197fc49549240f6c6a963b2713a4cd9517964b
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri Apr 2 11:48:03 2010 -0500

    Separate the gdbstub from the debug core
    
    Split the former kernel/kgdb.c into debug_core.c which contains the
    kernel debugger exception logic and to the gdbstub.c which contains
    the logic for allowing gdb to talk to the debug core.
    
    This also created a private include file called debug_core.h which
    contains all the definitions to glue the debug_core to any other
    debugger connections.
    
    CC: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/kernel/debug/debug_core.h b/kernel/debug/debug_core.h
new file mode 100644
index 000000000000..db554f9be51d
--- /dev/null
+++ b/kernel/debug/debug_core.h
@@ -0,0 +1,55 @@
+/*
+ * Created by: Jason Wessel <jason.wessel@windriver.com>
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.  All Rights Reserved.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _DEBUG_CORE_H_
+#define _DEBUG_CORE_H_
+/*
+ * These are the private implementation headers between the kernel
+ * debugger core and the debugger front end code.
+ */
+
+/* kernel debug core data structures */
+struct kgdb_state {
+	int			ex_vector;
+	int			signo;
+	int			err_code;
+	int			cpu;
+	int			pass_exception;
+	unsigned long		thr_query;
+	unsigned long		threadid;
+	long			kgdb_usethreadid;
+	struct pt_regs		*linux_regs;
+};
+
+/* Exception state values */
+#define DCPU_WANT_MASTER 0x1 /* Waiting to become a master kgdb cpu */
+#define DCPU_NEXT_MASTER 0x2 /* Transition from one master cpu to another */
+#define DCPU_IS_SLAVE    0x4 /* Slave cpu enter exception */
+#define DCPU_SSTEP       0x8 /* CPU is single stepping */
+
+struct debuggerinfo_struct {
+	void			*debuggerinfo;
+	struct task_struct	*task;
+	int			exception_state;
+};
+
+extern struct debuggerinfo_struct kgdb_info[];
+
+/* kernel debug core break point routines */
+extern int dbg_remove_all_break(void);
+extern int dbg_set_sw_break(unsigned long addr);
+extern int dbg_remove_sw_break(unsigned long addr);
+extern int dbg_activate_sw_breakpoints(void);
+
+/* gdbstub interface functions */
+extern int gdb_serial_stub(struct kgdb_state *ks);
+extern void gdbstub_msg_write(const char *s, int len);
+
+#endif /* _DEBUG_CORE_H_ */
