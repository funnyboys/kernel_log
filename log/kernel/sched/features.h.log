commit b8c96361402aa3e74ad48ceef18aed99153d8da8
Author: Patrick Bellasi <patrick.bellasi@matbug.net>
Date:   Wed Oct 23 21:56:30 2019 +0100

    sched/fair/util_est: Implement faster ramp-up EWMA on utilization increases
    
    The estimated utilization for a task:
    
       util_est = max(util_avg, est.enqueue, est.ewma)
    
    is defined based on:
    
     - util_avg: the PELT defined utilization
     - est.enqueued: the util_avg at the end of the last activation
     - est.ewma:     a exponential moving average on the est.enqueued samples
    
    According to this definition, when a task suddenly changes its bandwidth
    requirements from small to big, the EWMA will need to collect multiple
    samples before converging up to track the new big utilization.
    
    This slow convergence towards bigger utilization values is not
    aligned to the default scheduler behavior, which is to optimize for
    performance. Moreover, the est.ewma component fails to compensate for
    temporarely utilization drops which spans just few est.enqueued samples.
    
    To let util_est do a better job in the scenario depicted above, change
    its definition by making util_est directly follow upward motion and
    only decay the est.ewma on downward.
    
    Signed-off-by: Patrick Bellasi <patrick.bellasi@matbug.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Cc: Douglas Raillard <douglas.raillard@arm.com>
    Cc: Juri Lelli <juri.lelli@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Quentin Perret <qperret@google.com>
    Cc: Rafael J . Wysocki <rafael.j.wysocki@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191023205630.14469-1-patrick.bellasi@matbug.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 2410db5e9a35..7481cd96f391 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -89,3 +89,4 @@ SCHED_FEAT(WA_BIAS, true)
  * UtilEstimation. Use estimated CPU utilization.
  */
 SCHED_FEAT(UTIL_EST, true)
+SCHED_FEAT(UTIL_EST_FASTUP, true)

commit 1c1b8a7b03ef50f80f5d0c871ee261c04a6c967e
Author: Dietmar Eggemann <dietmar.eggemann@arm.com>
Date:   Mon May 27 07:21:11 2019 +0100

    sched/fair: Replace source_load() & target_load() with weighted_cpuload()
    
    With LB_BIAS disabled, source_load() & target_load() return
    weighted_cpuload(). Replace both with calls to weighted_cpuload().
    
    The function to obtain the load index (sd->*_idx) for an sd,
    get_sd_load_idx(), can be removed as well.
    
    Finally, get rid of the sched feature LB_BIAS.
    
    Signed-off-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Rik van Riel <riel@surriel.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Morten Rasmussen <morten.rasmussen@arm.com>
    Cc: Patrick Bellasi <patrick.bellasi@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Quentin Perret <quentin.perret@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Valentin Schneider <valentin.schneider@arm.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Link: https://lkml.kernel.org/r/20190527062116.11512-3-dietmar.eggemann@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 858589b83377..2410db5e9a35 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -39,7 +39,6 @@ SCHED_FEAT(WAKEUP_PREEMPTION, true)
 
 SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)
-SCHED_FEAT(LB_BIAS, false)
 
 /*
  * Decrement CPU capacity based on time not spent running tasks

commit fdf5f315d5cfaefb7bb8a62ec4bf37b9891837aa
Author: Dietmar Eggemann <dietmar.eggemann@arm.com>
Date:   Thu Aug 9 14:57:53 2018 +0100

    sched/fair: Disable LB_BIAS by default
    
    LB_BIAS allows the adjustment on how conservative load should be
    balanced.
    
    The rq->cpu_load[idx] array is used for this functionality. It contains
    weighted CPU load decayed average values over different intervals
    (idx = 1..4). Idx = 0 is the weighted CPU load itself.
    
    The values are updated during scheduler_tick, before idle balance and at
    nohz exit.
    
    There are 5 different types of idx's per sched domain (sd). Each of them
    is used to index into the rq->cpu_load[idx] array in a specific scenario
    (busy, idle and newidle for load balancing, forkexec for wake-up
    slow-path load balancing and wake for affine wakeup based on weight).
    Only the sd idx's for busy and idle load balancing are set to 2,3 or 1,2
    respectively. All the other sd idx's are set to 0.
    
    Conservative load balancing is achieved for sd idx's >= 1 by using the
    min/max (source_load()/target_load()) value between the current weighted
    CPU load and the rq->cpu_load[sd idx -1] for the busiest(idlest)/local
    CPU load in load balancing or vice versa in the wake-up slow-path load
    balancing.
    There is no conservative balancing for sd idx = 0 since only current
    weighted CPU load is used in this case.
    
    It is very likely that LB_BIAS' influence on load balancing can be
    neglected (see test results below). This is further supported by:
    
    (1) Weighted CPU load today is by itself a decayed average value (PELT)
        (cfs_rq->avg->runnable_load_avg) and not the instantaneous load
        (rq->load.weight) it was when LB_BIAS was introduced.
    
    (2) Sd imbalance_pct is used for CPU_NEWLY_IDLE and CPU_NOT_IDLE (relate
        to sd's newidle and busy idx) in find_busiest_group() when comparing
        busiest and local avg load to make load balancing even more
        conservative.
    
    (3) The sd forkexec and newidle idx are always set to 0 so there is no
        adjustment on how conservatively load balancing is done here.
    
    (4) Affine wakeup based on weight (wake_affine_weight()) will not be
        impacted since the sd wake idx is always set to 0.
    
    Let's disable LB_BIAS by default for a few kernel releases to make sure
    that no workload and no scheduler topology is affected. The benefit of
    being able to remove the LB_BIAS dependency from source_load() and
    target_load() is that the entire rq->cpu_load[idx] code could be removed
    in this case.
    
    It is really hard to say if there is no regression w/o testing this with
    a lot of different workloads on a lot of different platforms, especially
    NUMA machines.
    The following 104 LKP (Linux Kernel Performance) tests were run by the
    0-Day guys mostly on multi-socket hosts with a larger number of logical
    cpus (88, 192).
    The base for the test was commit b3dae109fa89 ("sched/swait: Rename to
    exclusive") (tip/sched/core v4.18-rc1).
    Only 2 out of the 104 tests had a significant change in one of the
    metrics (fsmark/1x-1t-1HDD-btrfs-nfsv4-4M-60G-NoSync-performance +7%
    files_per_sec, unixbench/300s-100%-syscall-performance -11% score).
    Tests which showed a change in one of the metrics are marked with a '*'
    and this change is listed as well.
    
    (a) lkp-bdw-ep3:
          88 threads Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz 64G
    
        dd-write/10m-1HDD-cfq-btrfs-100dd-performance
        fsmark/1x-1t-1HDD-xfs-nfsv4-4M-60G-NoSync-performance
      * fsmark/1x-1t-1HDD-btrfs-nfsv4-4M-60G-NoSync-performance
          7.50  7%  8.00  ±  6%  fsmark.files_per_sec
        fsmark/1x-1t-1HDD-btrfs-nfsv4-4M-60G-fsyncBeforeClose-performance
        fsmark/1x-1t-1HDD-btrfs-4M-60G-NoSync-performance
        fsmark/1x-1t-1HDD-btrfs-4M-60G-fsyncBeforeClose-performance
        kbuild/300s-50%-vmlinux_prereq-performance
        kbuild/300s-200%-vmlinux_prereq-performance
        kbuild/300s-50%-vmlinux_prereq-performance-1HDD-ext4
        kbuild/300s-200%-vmlinux_prereq-performance-1HDD-ext4
    
    (b) lkp-skl-4sp1:
          192 threads Intel(R) Xeon(R) Platinum 8160 768G
    
        dbench/100%-performance
        ebizzy/200%-100x-10s-performance
        hackbench/1600%-process-pipe-performance
        iperf/300s-cs-localhost-tcp-performance
        iperf/300s-cs-localhost-udp-performance
        perf-bench-numa-mem/2t-300M-performance
        perf-bench-sched-pipe/10000000ops-process-performance
        perf-bench-sched-pipe/10000000ops-threads-performance
        schbench/2-16-300-30000-30000-performance
        tbench/100%-cs-localhost-performance
    
    (c) lkp-bdw-ep6:
          88 threads Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz 128G
    
        stress-ng/100%-60s-pipe-performance
        unixbench/300s-1-whetstone-double-performance
        unixbench/300s-1-shell1-performance
        unixbench/300s-1-shell8-performance
        unixbench/300s-1-pipe-performance
      * unixbench/300s-1-context1-performance
          312  315  unixbench.score
        unixbench/300s-1-spawn-performance
        unixbench/300s-1-syscall-performance
        unixbench/300s-1-dhry2reg-performance
        unixbench/300s-1-fstime-performance
        unixbench/300s-1-fsbuffer-performance
        unixbench/300s-1-fsdisk-performance
        unixbench/300s-100%-whetstone-double-performance
        unixbench/300s-100%-shell1-performance
        unixbench/300s-100%-shell8-performance
        unixbench/300s-100%-pipe-performance
        unixbench/300s-100%-context1-performance
        unixbench/300s-100%-spawn-performance
      * unixbench/300s-100%-syscall-performance
          3571  ±  3%  -11%  3183  ±  4%  unixbench.score
        unixbench/300s-100%-dhry2reg-performance
        unixbench/300s-100%-fstime-performance
        unixbench/300s-100%-fsbuffer-performance
        unixbench/300s-100%-fsdisk-performance
        unixbench/300s-1-execl-performance
        unixbench/300s-100%-execl-performance
      * will-it-scale/brk1-performance
          365004  360387  will-it-scale.per_thread_ops
      * will-it-scale/dup1-performance
          432401  437596  will-it-scale.per_thread_ops
        will-it-scale/eventfd1-performance
        will-it-scale/futex1-performance
        will-it-scale/futex2-performance
        will-it-scale/futex3-performance
        will-it-scale/futex4-performance
        will-it-scale/getppid1-performance
        will-it-scale/lock1-performance
        will-it-scale/lseek1-performance
        will-it-scale/lseek2-performance
      * will-it-scale/malloc1-performance
          47025  45817  will-it-scale.per_thread_ops
          77499  76529  will-it-scale.per_process_ops
        will-it-scale/malloc2-performance
      * will-it-scale/mmap1-performance
          123399  120815  will-it-scale.per_thread_ops
          152219  149833  will-it-scale.per_process_ops
      * will-it-scale/mmap2-performance
          107327  104714  will-it-scale.per_thread_ops
          136405  133765  will-it-scale.per_process_ops
        will-it-scale/open1-performance
      * will-it-scale/open2-performance
          171570  168805  will-it-scale.per_thread_ops
          532644  526202  will-it-scale.per_process_ops
        will-it-scale/page_fault1-performance
        will-it-scale/page_fault2-performance
        will-it-scale/page_fault3-performance
        will-it-scale/pipe1-performance
        will-it-scale/poll1-performance
      * will-it-scale/poll2-performance
          176134  172848  will-it-scale.per_thread_ops
          281361  275053  will-it-scale.per_process_ops
        will-it-scale/posix_semaphore1-performance
        will-it-scale/pread1-performance
        will-it-scale/pread2-performance
        will-it-scale/pread3-performance
        will-it-scale/pthread_mutex1-performance
        will-it-scale/pthread_mutex2-performance
        will-it-scale/pwrite1-performance
        will-it-scale/pwrite2-performance
        will-it-scale/pwrite3-performance
      * will-it-scale/read1-performance
          1190563  1174833  will-it-scale.per_thread_ops
      * will-it-scale/read2-performance
          1105369  1080427  will-it-scale.per_thread_ops
        will-it-scale/readseek1-performance
      * will-it-scale/readseek2-performance
          261818  259040  will-it-scale.per_thread_ops
        will-it-scale/readseek3-performance
      * will-it-scale/sched_yield-performance
          2408059  2382034  will-it-scale.per_thread_ops
        will-it-scale/signal1-performance
        will-it-scale/unix1-performance
        will-it-scale/unlink1-performance
        will-it-scale/unlink2-performance
      * will-it-scale/write1-performance
          976701  961588  will-it-scale.per_thread_ops
      * will-it-scale/writeseek1-performance
          831898  822448  will-it-scale.per_thread_ops
      * will-it-scale/writeseek2-performance
          228248  225065  will-it-scale.per_thread_ops
      * will-it-scale/writeseek3-performance
          226670  224058  will-it-scale.per_thread_ops
        will-it-scale/context_switch1-performance
        aim7/performance-fork_test-2000
      * aim7/performance-brk_test-3000
          74869  76676  aim7.jobs-per-min
        aim7/performance-disk_cp-3000
        aim7/performance-disk_rd-3000
        aim7/performance-sieve-3000
        aim7/performance-page_test-3000
        aim7/performance-creat-clo-3000
        aim7/performance-mem_rtns_1-8000
        aim7/performance-disk_wrt-8000
        aim7/performance-pipe_cpy-8000
        aim7/performance-ram_copy-8000
    
    (d) lkp-avoton3:
          8 threads Intel(R) Atom(TM) CPU C2750 @ 2.40GHz 16G
    
        netperf/ipv4-900s-200%-cs-localhost-TCP_STREAM-performance
    
    Signed-off-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Li Zhijian <zhijianx.li@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20180809135753.21077-1-dietmar.eggemann@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 85ae8488039c..858589b83377 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -39,7 +39,7 @@ SCHED_FEAT(WAKEUP_PREEMPTION, true)
 
 SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)
-SCHED_FEAT(LB_BIAS, true)
+SCHED_FEAT(LB_BIAS, false)
 
 /*
  * Decrement CPU capacity based on time not spent running tasks

commit d519329f72a6f36bc4f2b85452640cfe583b4f81
Author: Patrick Bellasi <patrick.bellasi@arm.com>
Date:   Fri Mar 9 09:52:45 2018 +0000

    sched/fair: Update util_est only on util_avg updates
    
    The estimated utilization of a task is currently updated every time the
    task is dequeued. However, to keep overheads under control, PELT signals
    are effectively updated at maximum once every 1ms.
    
    Thus, for really short running tasks, it can happen that their util_avg
    value has not been updates since their last enqueue.  If such tasks are
    also frequently running tasks (e.g. the kind of workload generated by
    hackbench) it can also happen that their util_avg is updated only every
    few activations.
    
    This means that updating util_est at every dequeue potentially introduces
    not necessary overheads and it's also conceptually wrong if the util_avg
    signal has never been updated during a task activation.
    
    Let's introduce a throttling mechanism on task's util_est updates
    to sync them with util_avg updates. To make the solution memory
    efficient, both in terms of space and load/store operations, we encode a
    synchronization flag into the LSB of util_est.enqueued.
    This makes util_est an even values only metric, which is still
    considered good enough for its purpose.
    The synchronization bit is (re)set by __update_load_avg_se() once the
    PELT signal of a task has been updated during its last activation.
    
    Such a throttling mechanism allows to keep under control util_est
    overheads in the wakeup hot path, thus making it a suitable mechanism
    which can be enabled also on high-intensity workload systems.
    Thus, this now switches on by default the estimation utilization
    scheduler feature.
    
    Suggested-by: Chris Redpath <chris.redpath@arm.com>
    Signed-off-by: Patrick Bellasi <patrick.bellasi@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Cc: Joel Fernandes <joelaf@google.com>
    Cc: Juri Lelli <juri.lelli@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Morten Rasmussen <morten.rasmussen@arm.com>
    Cc: Paul Turner <pjt@google.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J . Wysocki <rafael.j.wysocki@intel.com>
    Cc: Steve Muckle <smuckle@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Todd Kjos <tkjos@android.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Link: http://lkml.kernel.org/r/20180309095245.11071-5-patrick.bellasi@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index c459a4b61544..85ae8488039c 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -89,4 +89,4 @@ SCHED_FEAT(WA_BIAS, true)
 /*
  * UtilEstimation. Use estimated CPU utilization.
  */
-SCHED_FEAT(UTIL_EST, false)
+SCHED_FEAT(UTIL_EST, true)

commit 7f65ea42eb00bc902f1c37a71e984e4f4064cfa9
Author: Patrick Bellasi <patrick.bellasi@arm.com>
Date:   Fri Mar 9 09:52:42 2018 +0000

    sched/fair: Add util_est on top of PELT
    
    The util_avg signal computed by PELT is too variable for some use-cases.
    For example, a big task waking up after a long sleep period will have its
    utilization almost completely decayed. This introduces some latency before
    schedutil will be able to pick the best frequency to run a task.
    
    The same issue can affect task placement. Indeed, since the task
    utilization is already decayed at wakeup, when the task is enqueued in a
    CPU, this can result in a CPU running a big task as being temporarily
    represented as being almost empty. This leads to a race condition where
    other tasks can be potentially allocated on a CPU which just started to run
    a big task which slept for a relatively long period.
    
    Moreover, the PELT utilization of a task can be updated every [ms], thus
    making it a continuously changing value for certain longer running
    tasks. This means that the instantaneous PELT utilization of a RUNNING
    task is not really meaningful to properly support scheduler decisions.
    
    For all these reasons, a more stable signal can do a better job of
    representing the expected/estimated utilization of a task/cfs_rq.
    Such a signal can be easily created on top of PELT by still using it as
    an estimator which produces values to be aggregated on meaningful
    events.
    
    This patch adds a simple implementation of util_est, a new signal built on
    top of PELT's util_avg where:
    
        util_est(task) = max(task::util_avg, f(task::util_avg@dequeue))
    
    This allows to remember how big a task has been reported by PELT in its
    previous activations via f(task::util_avg@dequeue), which is the new
    _task_util_est(struct task_struct*) function added by this patch.
    
    If a task should change its behavior and it runs longer in a new
    activation, after a certain time its util_est will just track the
    original PELT signal (i.e. task::util_avg).
    
    The estimated utilization of cfs_rq is defined only for root ones.
    That's because the only sensible consumer of this signal are the
    scheduler and schedutil when looking for the overall CPU utilization
    due to FAIR tasks.
    
    For this reason, the estimated utilization of a root cfs_rq is simply
    defined as:
    
        util_est(cfs_rq) = max(cfs_rq::util_avg, cfs_rq::util_est::enqueued)
    
    where:
    
        cfs_rq::util_est::enqueued = sum(_task_util_est(task))
                                     for each RUNNABLE task on that root cfs_rq
    
    It's worth noting that the estimated utilization is tracked only for
    objects of interests, specifically:
    
     - Tasks: to better support tasks placement decisions
     - root cfs_rqs: to better support both tasks placement decisions as
                     well as frequencies selection
    
    Signed-off-by: Patrick Bellasi <patrick.bellasi@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Cc: Joel Fernandes <joelaf@google.com>
    Cc: Juri Lelli <juri.lelli@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Morten Rasmussen <morten.rasmussen@arm.com>
    Cc: Paul Turner <pjt@google.com>
    Cc: Rafael J . Wysocki <rafael.j.wysocki@intel.com>
    Cc: Steve Muckle <smuckle@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Todd Kjos <tkjos@android.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Link: http://lkml.kernel.org/r/20180309095245.11071-2-patrick.bellasi@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 9552fd5854bf..c459a4b61544 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -85,3 +85,8 @@ SCHED_FEAT(ATTACH_AGE_LOAD, true)
 SCHED_FEAT(WA_IDLE, true)
 SCHED_FEAT(WA_WEIGHT, true)
 SCHED_FEAT(WA_BIAS, true)
+
+/*
+ * UtilEstimation. Use estimated CPU utilization.
+ */
+SCHED_FEAT(UTIL_EST, false)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 319ed0e8a347..9552fd5854bf 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Only give sleepers 50% of their service deficit. This allows
  * them to run sooner, but does not allow tons of sleepers to

commit f2cdd9cc6c97e617b95f430f527a6e3165e1bee8
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Oct 6 09:23:24 2017 +0200

    sched/core: Address more wake_affine() regressions
    
    The trivial wake_affine_idle() implementation is very good for a
    number of workloads, but it comes apart at the moment there are no
    idle CPUs left, IOW. the overloaded case.
    
    hackbench:
    
                    NO_WA_WEIGHT            WA_WEIGHT
    
    hackbench-20  : 7.362717561 seconds     6.450509391 seconds
    
    (win)
    
    netperf:
    
                      NO_WA_WEIGHT          WA_WEIGHT
    
    TCP_SENDFILE-1  : Avg: 54524.6          Avg: 52224.3
    TCP_SENDFILE-10 : Avg: 48185.2          Avg: 46504.3
    TCP_SENDFILE-20 : Avg: 29031.2          Avg: 28610.3
    TCP_SENDFILE-40 : Avg: 9819.72          Avg: 9253.12
    TCP_SENDFILE-80 : Avg: 5355.3           Avg: 4687.4
    
    TCP_STREAM-1    : Avg: 41448.3          Avg: 42254
    TCP_STREAM-10   : Avg: 24123.2          Avg: 25847.9
    TCP_STREAM-20   : Avg: 15834.5          Avg: 18374.4
    TCP_STREAM-40   : Avg: 5583.91          Avg: 5599.57
    TCP_STREAM-80   : Avg: 2329.66          Avg: 2726.41
    
    TCP_RR-1        : Avg: 80473.5          Avg: 82638.8
    TCP_RR-10       : Avg: 72660.5          Avg: 73265.1
    TCP_RR-20       : Avg: 52607.1          Avg: 52634.5
    TCP_RR-40       : Avg: 57199.2          Avg: 56302.3
    TCP_RR-80       : Avg: 25330.3          Avg: 26867.9
    
    UDP_RR-1        : Avg: 108266           Avg: 107844
    UDP_RR-10       : Avg: 95480            Avg: 95245.2
    UDP_RR-20       : Avg: 68770.8          Avg: 68673.7
    UDP_RR-40       : Avg: 76231            Avg: 75419.1
    UDP_RR-80       : Avg: 34578.3          Avg: 35639.1
    
    UDP_STREAM-1    : Avg: 64684.3          Avg: 66606
    UDP_STREAM-10   : Avg: 52701.2          Avg: 52959.5
    UDP_STREAM-20   : Avg: 30376.4          Avg: 29704
    UDP_STREAM-40   : Avg: 15685.8          Avg: 15266.5
    UDP_STREAM-80   : Avg: 8415.13          Avg: 7388.97
    
    (wins and losses)
    
    sysbench:
    
                        NO_WA_WEIGHT                WA_WEIGHT
    
    sysbench-mysql-2  :  2135.17 per sec.            2142.51 per sec.
    sysbench-mysql-5  :  4809.68 per sec.            4800.19 per sec.
    sysbench-mysql-10 :  9158.59 per sec.            9157.05 per sec.
    sysbench-mysql-20 : 14570.70 per sec.           14543.55 per sec.
    sysbench-mysql-40 : 22130.56 per sec.           22184.82 per sec.
    sysbench-mysql-80 : 20995.56 per sec.           21904.18 per sec.
    
    sysbench-psql-2   :  1679.58 per sec.            1705.06 per sec.
    sysbench-psql-5   :  3797.69 per sec.            3879.93 per sec.
    sysbench-psql-10  :  7253.22 per sec.            7258.06 per sec.
    sysbench-psql-20  : 11166.75 per sec.           11220.00 per sec.
    sysbench-psql-40  : 17277.28 per sec.           17359.78 per sec.
    sysbench-psql-80  : 17112.44 per sec.           17221.16 per sec.
    
    (increase on the top end)
    
    tbench:
    
    NO_WA_WEIGHT
    
    Throughput 685.211 MB/sec   2 clients   2 procs  max_latency=0.123 ms
    Throughput 1596.64 MB/sec   5 clients   5 procs  max_latency=0.119 ms
    Throughput 2985.47 MB/sec  10 clients  10 procs  max_latency=0.262 ms
    Throughput 4521.15 MB/sec  20 clients  20 procs  max_latency=0.506 ms
    Throughput 9438.1  MB/sec  40 clients  40 procs  max_latency=2.052 ms
    Throughput 8210.5  MB/sec  80 clients  80 procs  max_latency=8.310 ms
    
    WA_WEIGHT
    
    Throughput 697.292 MB/sec   2 clients   2 procs  max_latency=0.127 ms
    Throughput 1596.48 MB/sec   5 clients   5 procs  max_latency=0.080 ms
    Throughput 2975.22 MB/sec  10 clients  10 procs  max_latency=0.254 ms
    Throughput 4575.14 MB/sec  20 clients  20 procs  max_latency=0.502 ms
    Throughput 9468.65 MB/sec  40 clients  40 procs  max_latency=2.069 ms
    Throughput 8631.73 MB/sec  80 clients  80 procs  max_latency=8.605 ms
    
    (increase on the top end)
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 0a519f8c224d..319ed0e8a347 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -82,3 +82,5 @@ SCHED_FEAT(LB_MIN, false)
 SCHED_FEAT(ATTACH_AGE_LOAD, true)
 
 SCHED_FEAT(WA_IDLE, true)
+SCHED_FEAT(WA_WEIGHT, true)
+SCHED_FEAT(WA_BIAS, true)

commit d153b153446f7d8832bb2ebd92309c8a6003b3bb
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Sep 27 11:35:30 2017 +0200

    sched/core: Fix wake_affine() performance regression
    
    Eric reported a sysbench regression against commit:
    
      3fed382b46ba ("sched/numa: Implement NUMA node level wake_affine()")
    
    Similarly, Rik was looking at the NAS-lu.C benchmark, which regressed
    against his v3.10 enterprise kernel.
    
    PRE (current tip/master):
    
     ivb-ep sysbench:
    
       2: [30 secs]     transactions:                        64110  (2136.94 per sec.)
       5: [30 secs]     transactions:                        143644 (4787.99 per sec.)
      10: [30 secs]     transactions:                        274298 (9142.93 per sec.)
      20: [30 secs]     transactions:                        418683 (13955.45 per sec.)
      40: [30 secs]     transactions:                        320731 (10690.15 per sec.)
      80: [30 secs]     transactions:                        355096 (11834.28 per sec.)
    
     hsw-ex NAS:
    
     OMP_PROC_BIND/lu.C.x_threads_144_run_1.log: Time in seconds =                    18.01
     OMP_PROC_BIND/lu.C.x_threads_144_run_2.log: Time in seconds =                    17.89
     OMP_PROC_BIND/lu.C.x_threads_144_run_3.log: Time in seconds =                    17.93
     lu.C.x_threads_144_run_1.log: Time in seconds =                   434.68
     lu.C.x_threads_144_run_2.log: Time in seconds =                   405.36
     lu.C.x_threads_144_run_3.log: Time in seconds =                   433.83
    
    POST (+patch):
    
     ivb-ep sysbench:
    
       2: [30 secs]     transactions:                        64494  (2149.75 per sec.)
       5: [30 secs]     transactions:                        145114 (4836.99 per sec.)
      10: [30 secs]     transactions:                        278311 (9276.69 per sec.)
      20: [30 secs]     transactions:                        437169 (14571.60 per sec.)
      40: [30 secs]     transactions:                        669837 (22326.73 per sec.)
      80: [30 secs]     transactions:                        631739 (21055.88 per sec.)
    
     hsw-ex NAS:
    
     lu.C.x_threads_144_run_1.log: Time in seconds =                    23.36
     lu.C.x_threads_144_run_2.log: Time in seconds =                    22.96
     lu.C.x_threads_144_run_3.log: Time in seconds =                    22.52
    
    This patch takes out all the shiny wake_affine() stuff and goes back to
    utter basics. Between the two CPUs involved with the wakeup (the CPU
    doing the wakeup and the CPU we ran on previously) pick the CPU we can
    run on _now_.
    
    This restores much of the regressions against the older kernels,
    but leaves some ground in the overloaded case. The default-enabled
    WA_WEIGHT (which will be introduced in the next patch) is an attempt
    to address the overloaded situation.
    
    Reported-by: Eric Farman <farman@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Rosato <mjrosato@linux.vnet.ibm.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: jinpuwang@gmail.com
    Cc: vcaputo@pengaru.com
    Fixes: 3fed382b46ba ("sched/numa: Implement NUMA node level wake_affine()")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index d3fb15555291..0a519f8c224d 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -81,3 +81,4 @@ SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
 SCHED_FEAT(ATTACH_AGE_LOAD, true)
 
+SCHED_FEAT(WA_IDLE, true)

commit 1ad3aaf3fcd2444406628a19a9b9e0922b95e2d4
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed May 17 12:53:50 2017 +0200

    sched/core: Implement new approach to scale select_idle_cpu()
    
    Hackbench recently suffered a bunch of pain, first by commit:
    
      4c77b18cf8b7 ("sched/fair: Make select_idle_cpu() more aggressive")
    
    and then by commit:
    
      c743f0a5c50f ("sched/fair, cpumask: Export for_each_cpu_wrap()")
    
    which fixed a bug in the initial for_each_cpu_wrap() implementation
    that made select_idle_cpu() even more expensive. The bug was that it
    would skip over CPUs when bits were consequtive in the bitmask.
    
    This however gave me an idea to fix select_idle_cpu(); where the old
    scheme was a cliff-edge throttle on idle scanning, this introduces a
    more gradual approach. Instead of stopping to scan entirely, we limit
    how many CPUs we scan.
    
    Initial benchmarks show that it mostly recovers hackbench while not
    hurting anything else, except Mason's schbench, but not as bad as the
    old thing.
    
    It also appears to recover the tbench high-end, which also suffered like
    hackbench.
    
    Tested-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Chris Mason <clm@fb.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: hpa@zytor.com
    Cc: kitsunyan <kitsunyan@inbox.ru>
    Cc: linux-kernel@vger.kernel.org
    Cc: lvenanci@redhat.com
    Cc: riel@redhat.com
    Cc: xiaolong.ye@intel.com
    Link: http://lkml.kernel.org/r/20170517105350.hk5m4h4jb6dfr65a@hirez.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index dc4d1483b038..d3fb15555291 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -55,6 +55,7 @@ SCHED_FEAT(TTWU_QUEUE, true)
  * When doing wakeups, attempt to limit superfluous scans of the LLC domain.
  */
 SCHED_FEAT(SIS_AVG_CPU, false)
+SCHED_FEAT(SIS_PROP, true)
 
 /*
  * Issue a WARN when we do multiple update_rq_clock() calls

commit af85596c74de2fd9abb87501ae280038ac28a3f4
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Apr 26 17:36:41 2017 +0200

    sched/topology: Remove FORCE_SD_OVERLAP
    
    Its an obsolete debug mechanism and future code wants to rely on
    properties this undermines.
    
    Namely, it would be good to assume that SD_OVERLAP domains have
    children, but if we build the entire hierarchy with SD_OVERLAP this is
    obviously false.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 11192e0cb122..dc4d1483b038 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -76,7 +76,6 @@ SCHED_FEAT(WARN_DOUBLE_CLOCK, false)
 SCHED_FEAT(RT_PUSH_IPI, true)
 #endif
 
-SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
 SCHED_FEAT(ATTACH_AGE_LOAD, true)

commit 26ae58d23b94a075ae724fd18783a3773131cfbc
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Oct 3 16:53:49 2016 +0200

    sched/core: Add WARNING for multiple update_rq_clock() calls
    
    Now that we have no missing calls, add a warning to find multiple
    calls.
    
    By having only a single update_rq_clock() call per rq-lock section,
    the section appears 'atomic' wrt time.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 1b3c8189b286..11192e0cb122 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -56,6 +56,13 @@ SCHED_FEAT(TTWU_QUEUE, true)
  */
 SCHED_FEAT(SIS_AVG_CPU, false)
 
+/*
+ * Issue a WARN when we do multiple update_rq_clock() calls
+ * in a single rq->lock section. Default disabled because the
+ * annotations are not complete.
+ */
+SCHED_FEAT(WARN_DOUBLE_CLOCK, false)
+
 #ifdef HAVE_RT_PUSH_IPI
 /*
  * In order to avoid a thundering herd attack of CPUs that are

commit 4c77b18cf8b7ab37c7d5737b4609010d2ceec5f0
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Mar 1 11:24:35 2017 +0100

    sched/fair: Make select_idle_cpu() more aggressive
    
    Kitsunyan reported desktop latency issues on his Celeron 887 because
    of commit:
    
      1b568f0aabf2 ("sched/core: Optimize SCHED_SMT")
    
    ... even though his CPU doesn't do SMT.
    
    The effect of running the SMT code on a !SMT part is basically a more
    aggressive select_idle_cpu(). Removing the avg condition fixed things
    for him.
    
    I also know FB likes this test gone, even though other workloads like
    having it.
    
    For now, take it out by default, until we get a better idea.
    
    Reported-by: kitsunyan <kitsunyan@inbox.ru>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Chris Mason <clm@fb.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 69631fa46c2f..1b3c8189b286 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -51,6 +51,11 @@ SCHED_FEAT(NONTASK_CAPACITY, true)
  */
 SCHED_FEAT(TTWU_QUEUE, true)
 
+/*
+ * When doing wakeups, attempt to limit superfluous scans of the LLC domain.
+ */
+SCHED_FEAT(SIS_AVG_CPU, false)
+
 #ifdef HAVE_RT_PUSH_IPI
 /*
  * In order to avoid a thundering herd attack of CPUs that are

commit 8cd5601c50603caa195ce86cc465cb04079ed488
Author: Morten Rasmussen <morten.rasmussen@arm.com>
Date:   Fri Aug 14 17:23:10 2015 +0100

    sched/fair: Convert arch_scale_cpu_capacity() from weak function to #define
    
    Bring arch_scale_cpu_capacity() in line with the recent change of its
    arch_scale_freq_capacity() sibling in commit dfbca41f3479 ("sched:
    Optimize freq invariant accounting") from weak function to #define to
    allow inlining of the function.
    
    While at it, remove the ARCH_CAPACITY sched_feature as well. With the
    change to #define there isn't a straightforward way to allow runtime
    switch between an arch implementation and the default implementation of
    arch_scale_cpu_capacity() using sched_feature. The default was to use
    the arch-specific implementation, but only the arm architecture provides
    one and that is essentially equivalent to the default implementation.
    
    Signed-off-by: Morten Rasmussen <morten.rasmussen@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Dietmar Eggemann <Dietmar.Eggemann@arm.com>
    Cc: Juri Lelli <Juri.Lelli@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: daniel.lezcano@linaro.org
    Cc: mturquette@baylibre.com
    Cc: pang.xunlei@zte.com.cn
    Cc: rjw@rjwysocki.net
    Cc: sgurrappadi@nvidia.com
    Cc: vincent.guittot@linaro.org
    Cc: yuyang.du@intel.com
    Link: http://lkml.kernel.org/r/1439569394-11974-3-git-send-email-morten.rasmussen@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index edf5902d5e57..69631fa46c2f 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -36,11 +36,6 @@ SCHED_FEAT(CACHE_HOT_BUDDY, true)
  */
 SCHED_FEAT(WAKEUP_PREEMPTION, true)
 
-/*
- * Use arch dependent cpu capacity functions
- */
-SCHED_FEAT(ARCH_CAPACITY, true)
-
 SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)
 SCHED_FEAT(LB_BIAS, true)

commit 2b49d84b259fc18e131026e5d38e7855352f71b9
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Tue Aug 11 16:30:13 2015 +0530

    sched/numa: Remove the NUMA sched_feature
    
    Variable sched_numa_balancing is available for both CONFIG_SCHED_DEBUG
    and !CONFIG_SCHED_DEBUG. All code paths now check for
    sched_numa_balancing. Hence remove sched_feat(NUMA).
    
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1439290813-6683-4-git-send-email-srikar@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index e6fd23b7459b..edf5902d5e57 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -72,21 +72,5 @@ SCHED_FEAT(RT_PUSH_IPI, true)
 SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
-
 SCHED_FEAT(ATTACH_AGE_LOAD, true)
 
-/*
- * Apply the automatic NUMA scheduling policy. Enabled automatically
- * at runtime if running on a NUMA machine. Can be controlled via
- * numa_balancing=
- */
-#ifdef CONFIG_NUMA_BALANCING
-
-/*
- * NUMA will favor moving tasks towards nodes where a higher number of
- * hinting faults are recorded during active load balancing. It will
- * resist moving tasks towards nodes where a lower number of hinting
- * faults have been recorded.
- */
-SCHED_FEAT(NUMA,	true)
-#endif

commit a9280514bf1e54775b8d7cd93d87c05c2b5273e6
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Sep 11 16:10:59 2015 +0200

    sched/fair: Make the entity load aging on attaching tunable
    
    In case there are problems with the aging on attach, provide a debug
    knob to turn it off.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Byungchul Park <byungchul.park@lge.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Cc: yuyang.du@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 83a50e7ca533..e6fd23b7459b 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -73,6 +73,8 @@ SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
 
+SCHED_FEAT(ATTACH_AGE_LOAD, true)
+
 /*
  * Apply the automatic NUMA scheduling policy. Enabled automatically
  * at runtime if running on a NUMA machine. Can be controlled via

commit 2a1ed24ce94036d00a7c5d5e99a77a80f0aa556a
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Tue Jun 16 17:25:59 2015 +0530

    sched/numa: Prefer NUMA hotness over cache hotness
    
    The current load balancer may not try to prevent a task from moving
    out of a preferred node to a less preferred node. The reason for this
    being:
    
     - Since sched features NUMA and NUMA_RESIST_LOWER are disabled by
       default, migrate_degrades_locality() always returns false.
    
     - Even if NUMA_RESIST_LOWER were to be enabled, if its cache hot,
       migrate_degrades_locality() never gets called.
    
    The above behaviour can mean that tasks can move out of their
    preferred node but they may be eventually be brought back to their
    preferred node by numa balancer (due to higher numa faults).
    
    To avoid the above, this commit merges migrate_degrades_locality() and
    migrate_improves_locality(). It also replaces 3 sched features NUMA,
    NUMA_FAVOUR_HIGHER and NUMA_RESIST_LOWER by a single sched feature
    NUMA.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mike Galbraith <efault@gmx.de>
    Link: http://lkml.kernel.org/r/1434455762-30857-2-git-send-email-srikar@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 91e33cd485f6..83a50e7ca533 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -79,20 +79,12 @@ SCHED_FEAT(LB_MIN, false)
  * numa_balancing=
  */
 #ifdef CONFIG_NUMA_BALANCING
-SCHED_FEAT(NUMA,	false)
 
 /*
- * NUMA_FAVOUR_HIGHER will favor moving tasks towards nodes where a
- * higher number of hinting faults are recorded during active load
- * balancing.
+ * NUMA will favor moving tasks towards nodes where a higher number of
+ * hinting faults are recorded during active load balancing. It will
+ * resist moving tasks towards nodes where a lower number of hinting
+ * faults have been recorded.
  */
-SCHED_FEAT(NUMA_FAVOUR_HIGHER, true)
-
-/*
- * NUMA_RESIST_LOWER will resist moving tasks towards nodes where a
- * lower number of hinting faults have been recorded. As this has
- * the potential to prevent a task ever migrating to a new node
- * due to CPU overload it is disabled by default.
- */
-SCHED_FEAT(NUMA_RESIST_LOWER, false)
+SCHED_FEAT(NUMA,	true)
 #endif

commit b6366f048e0caff28af5335b7af2031266e1b06b
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Wed Mar 18 14:49:46 2015 -0400

    sched/rt: Use IPI to trigger RT task push migration instead of pulling
    
    When debugging the latencies on a 40 core box, where we hit 300 to
    500 microsecond latencies, I found there was a huge contention on the
    runqueue locks.
    
    Investigating it further, running ftrace, I found that it was due to
    the pulling of RT tasks.
    
    The test that was run was the following:
    
     cyclictest --numa -p95 -m -d0 -i100
    
    This created a thread on each CPU, that would set its wakeup in iterations
    of 100 microseconds. The -d0 means that all the threads had the same
    interval (100us). Each thread sleeps for 100us and wakes up and measures
    its latencies.
    
    cyclictest is maintained at:
     git://git.kernel.org/pub/scm/linux/kernel/git/clrkwllms/rt-tests.git
    
    What happened was another RT task would be scheduled on one of the CPUs
    that was running our test, when the other CPU tests went to sleep and
    scheduled idle. This caused the "pull" operation to execute on all
    these CPUs. Each one of these saw the RT task that was overloaded on
    the CPU of the test that was still running, and each one tried
    to grab that task in a thundering herd way.
    
    To grab the task, each thread would do a double rq lock grab, grabbing
    its own lock as well as the rq of the overloaded CPU. As the sched
    domains on this box was rather flat for its size, I saw up to 12 CPUs
    block on this lock at once. This caused a ripple affect with the
    rq locks especially since the taking was done via a double rq lock, which
    means that several of the CPUs had their own rq locks held while trying
    to take this rq lock. As these locks were blocked, any wakeups or load
    balanceing on these CPUs would also block on these locks, and the wait
    time escalated.
    
    I've tried various methods to lessen the load, but things like an
    atomic counter to only let one CPU grab the task wont work, because
    the task may have a limited affinity, and we may pick the wrong
    CPU to take that lock and do the pull, to only find out that the
    CPU we picked isn't in the task's affinity.
    
    Instead of doing the PULL, I now have the CPUs that want the pull to
    send over an IPI to the overloaded CPU, and let that CPU pick what
    CPU to push the task to. No more need to grab the rq lock, and the
    push/pull algorithm still works fine.
    
    With this patch, the latency dropped to just 150us over a 20 hour run.
    Without the patch, the huge latencies would trigger in seconds.
    
    I've created a new sched feature called RT_PUSH_IPI, which is enabled
    by default.
    
    When RT_PUSH_IPI is not enabled, the old method of grabbing the rq locks
    and having the pulling CPU do the work is implemented. When RT_PUSH_IPI
    is enabled, the IPI is sent to the overloaded CPU to do a push.
    
    To enabled or disable this at run time:
    
     # mount -t debugfs nodev /sys/kernel/debug
     # echo RT_PUSH_IPI > /sys/kernel/debug/sched_features
    or
     # echo NO_RT_PUSH_IPI > /sys/kernel/debug/sched_features
    
    Update: This original patch would send an IPI to all CPUs in the RT overload
    list. But that could theoretically cause the reverse issue. That is, there
    could be lots of overloaded RT queues and one CPU lowers its priority. It would
    then send an IPI to all the overloaded RT queues and they could then all try
    to grab the rq lock of the CPU lowering its priority, and then we have the
    same problem.
    
    The latest design sends out only one IPI to the first overloaded CPU. It tries to
    push any tasks that it can, and then looks for the next overloaded CPU that can
    push to the source CPU. The IPIs stop when all overloaded CPUs that have pushable
    tasks that have priorities greater than the source CPU are covered. In case the
    source CPU lowers its priority again, a flag is set to tell the IPI traversal to
    restart with the first RT overloaded CPU after the source CPU.
    
    Parts-suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Joern Engel <joern@purestorage.com>
    Cc: Clark Williams <williams@redhat.com>
    Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150318144946.2f3cc982@gandalf.local.home
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 90284d117fe6..91e33cd485f6 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -56,6 +56,19 @@ SCHED_FEAT(NONTASK_CAPACITY, true)
  */
 SCHED_FEAT(TTWU_QUEUE, true)
 
+#ifdef HAVE_RT_PUSH_IPI
+/*
+ * In order to avoid a thundering herd attack of CPUs that are
+ * lowering their priorities at the same time, and there being
+ * a single CPU that has an RT task that can migrate and is waiting
+ * to run, where the other CPUs will try to take that CPUs
+ * rq lock and possibly create a large contention, sending an
+ * IPI to that CPU and let that CPU push the RT task to where
+ * it should go may be a better scenario.
+ */
+SCHED_FEAT(RT_PUSH_IPI, true)
+#endif
+
 SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)

commit 5d4dfddd4f02b028d6ddaaa04d75d3b0cad1c9ae
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue May 27 13:50:41 2014 -0400

    sched: Rename capacity related flags
    
    It is better not to think about compute capacity as being equivalent
    to "CPU power".  The upcoming "power aware" scheduler work may create
    confusion with the notion of energy consumption if "power" is used too
    liberally.
    
    Let's rename the following feature flags since they do relate to capacity:
    
            SD_SHARE_CPUPOWER  -> SD_SHARE_CPUCAPACITY
            ARCH_POWER         -> ARCH_CAPACITY
            NONTASK_POWER      -> NONTASK_CAPACITY
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Morten Rasmussen <morten.rasmussen@arm.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Andy Fleming <afleming@freescale.com>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: devicetree@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/n/tip-e93lpnxb87owfievqatey6b5@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 5716929a2e3a..90284d117fe6 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -37,18 +37,18 @@ SCHED_FEAT(CACHE_HOT_BUDDY, true)
 SCHED_FEAT(WAKEUP_PREEMPTION, true)
 
 /*
- * Use arch dependent cpu power functions
+ * Use arch dependent cpu capacity functions
  */
-SCHED_FEAT(ARCH_POWER, true)
+SCHED_FEAT(ARCH_CAPACITY, true)
 
 SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)
 SCHED_FEAT(LB_BIAS, true)
 
 /*
- * Decrement CPU power based on time not spent running tasks
+ * Decrement CPU capacity based on time not spent running tasks
  */
-SCHED_FEAT(NONTASK_POWER, true)
+SCHED_FEAT(NONTASK_CAPACITY, true)
 
 /*
  * Queue remote wakeups on the target CPU and process them

commit 7a0f308337d11fd5caa9f845c6d08cc5d6067988
Author: Mel Gorman <mgorman@suse.de>
Date:   Mon Oct 7 11:29:01 2013 +0100

    sched/numa: Resist moving tasks towards nodes with fewer hinting faults
    
    Just as "sched: Favour moving tasks towards the preferred node" favours
    moving tasks towards nodes with a higher number of recorded NUMA hinting
    faults, this patch resists moving tasks towards nodes with lower faults.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1381141781-10992-24-git-send-email-mgorman@suse.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index d9278ce2c4b4..5716929a2e3a 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -74,4 +74,12 @@ SCHED_FEAT(NUMA,	false)
  * balancing.
  */
 SCHED_FEAT(NUMA_FAVOUR_HIGHER, true)
+
+/*
+ * NUMA_RESIST_LOWER will resist moving tasks towards nodes where a
+ * lower number of hinting faults have been recorded. As this has
+ * the potential to prevent a task ever migrating to a new node
+ * due to CPU overload it is disabled by default.
+ */
+SCHED_FEAT(NUMA_RESIST_LOWER, false)
 #endif

commit 3a7053b3224f4a8b0e8184166190076593621617
Author: Mel Gorman <mgorman@suse.de>
Date:   Mon Oct 7 11:29:00 2013 +0100

    sched/numa: Favour moving tasks towards the preferred node
    
    This patch favours moving tasks towards NUMA node that recorded a higher
    number of NUMA faults during active load balancing.  Ideally this is
    self-reinforcing as the longer the task runs on that node, the more faults
    it should incur causing task_numa_placement to keep the task running on that
    node. In reality a big weakness is that the nodes CPUs can be overloaded
    and it would be more efficient to queue tasks on an idle node and migrate
    to the new node. This would require additional smarts in the balancer so
    for now the balancer will simply prefer to place the task on the preferred
    node for a PTE scans which is controlled by the numa_balancing_settle_count
    sysctl. Once the settle_count number of scans has complete the schedule
    is free to place the task on an alternative node if the load is imbalanced.
    
    [srikar@linux.vnet.ibm.com: Fixed statistics]
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    [ Tunable and use higher faults instead of preferred. ]
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1381141781-10992-23-git-send-email-mgorman@suse.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index cba5c616a157..d9278ce2c4b4 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -67,4 +67,11 @@ SCHED_FEAT(LB_MIN, false)
  */
 #ifdef CONFIG_NUMA_BALANCING
 SCHED_FEAT(NUMA,	false)
+
+/*
+ * NUMA_FAVOUR_HIGHER will favor moving tasks towards nodes where a
+ * higher number of hinting faults are recorded during active load
+ * balancing.
+ */
+SCHED_FEAT(NUMA_FAVOUR_HIGHER, true)
 #endif

commit b726b7dfb400c937546fa91cf8523dcb1aa2fc6e
Author: Mel Gorman <mgorman@suse.de>
Date:   Mon Oct 7 11:28:53 2013 +0100

    Revert "mm: sched: numa: Delay PTE scanning until a task is scheduled on a new node"
    
    PTE scanning and NUMA hinting fault handling is expensive so commit
    5bca2303 ("mm: sched: numa: Delay PTE scanning until a task is scheduled
    on a new node") deferred the PTE scan until a task had been scheduled on
    another node. The problem is that in the purely shared memory case that
    this may never happen and no NUMA hinting fault information will be
    captured. We are not ruling out the possibility that something better
    can be done here but for now, this patch needs to be reverted and depend
    entirely on the scan_delay to avoid punishing short-lived processes.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1381141781-10992-16-git-send-email-mgorman@suse.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 99399f8e4799..cba5c616a157 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -63,10 +63,8 @@ SCHED_FEAT(LB_MIN, false)
 /*
  * Apply the automatic NUMA scheduling policy. Enabled automatically
  * at runtime if running on a NUMA machine. Can be controlled via
- * numa_balancing=. Allow PTE scanning to be forced on UMA machines
- * for debugging the core machinery.
+ * numa_balancing=
  */
 #ifdef CONFIG_NUMA_BALANCING
 SCHED_FEAT(NUMA,	false)
-SCHED_FEAT(NUMA_FORCE,	false)
 #endif

commit 41fcb9f230bf773656d1768b73000ef720bf00c3
Author: Waiman Long <Waiman.Long@hp.com>
Date:   Wed Apr 17 15:23:11 2013 -0400

    mutex: Move mutex spinning code from sched/core.c back to mutex.c
    
    As mentioned by Ingo, the SCHED_FEAT_OWNER_SPIN scheduler
    feature bit was really just an early hack to make with/without
    mutex-spinning testable. So it is no longer necessary.
    
    This patch removes the SCHED_FEAT_OWNER_SPIN feature bit and
    move the mutex spinning code from kernel/sched/core.c back to
    kernel/mutex.c which is where they should belong.
    
    Signed-off-by: Waiman Long <Waiman.Long@hp.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Chandramouleeswaran Aswin <aswin@hp.com>
    Cc: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Norton Scott J <scott.norton@hp.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Clark Williams <williams@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1366226594-5506-2-git-send-email-Waiman.Long@hp.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 1ad1d2b5395f..99399f8e4799 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -45,13 +45,6 @@ SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)
 SCHED_FEAT(LB_BIAS, true)
 
-/*
- * Spin-wait on mutex acquisition when the mutex owner is running on
- * another cpu -- assumes that when the owner is running, it will soon
- * release the lock. Decreases scheduling overhead.
- */
-SCHED_FEAT(OWNER_SPIN, true)
-
 /*
  * Decrement CPU power based on time not spent running tasks
  */

commit 3d59eebc5e137bd89c6351e4c70e90ba1d0dc234
Merge: 11520e5e7c18 4fc3f1d66b1e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 16 14:33:25 2012 -0800

    Merge tag 'balancenuma-v11' of git://git.kernel.org/pub/scm/linux/kernel/git/mel/linux-balancenuma
    
    Pull Automatic NUMA Balancing bare-bones from Mel Gorman:
     "There are three implementations for NUMA balancing, this tree
      (balancenuma), numacore which has been developed in tip/master and
      autonuma which is in aa.git.
    
      In almost all respects balancenuma is the dumbest of the three because
      its main impact is on the VM side with no attempt to be smart about
      scheduling.  In the interest of getting the ball rolling, it would be
      desirable to see this much merged for 3.8 with the view to building
      scheduler smarts on top and adapting the VM where required for 3.9.
    
      The most recent set of comparisons available from different people are
    
        mel:    https://lkml.org/lkml/2012/12/9/108
        mingo:  https://lkml.org/lkml/2012/12/7/331
        tglx:   https://lkml.org/lkml/2012/12/10/437
        srikar: https://lkml.org/lkml/2012/12/10/397
    
      The results are a mixed bag.  In my own tests, balancenuma does
      reasonably well.  It's dumb as rocks and does not regress against
      mainline.  On the other hand, Ingo's tests shows that balancenuma is
      incapable of converging for this workloads driven by perf which is bad
      but is potentially explained by the lack of scheduler smarts.  Thomas'
      results show balancenuma improves on mainline but falls far short of
      numacore or autonuma.  Srikar's results indicate we all suffer on a
      large machine with imbalanced node sizes.
    
      My own testing showed that recent numacore results have improved
      dramatically, particularly in the last week but not universally.
      We've butted heads heavily on system CPU usage and high levels of
      migration even when it shows that overall performance is better.
      There are also cases where it regresses.  Of interest is that for
      specjbb in some configurations it will regress for lower numbers of
      warehouses and show gains for higher numbers which is not reported by
      the tool by default and sometimes missed in treports.  Recently I
      reported for numacore that the JVM was crashing with
      NullPointerExceptions but currently it's unclear what the source of
      this problem is.  Initially I thought it was in how numacore batch
      handles PTEs but I'm no longer think this is the case.  It's possible
      numacore is just able to trigger it due to higher rates of migration.
    
      These reports were quite late in the cycle so I/we would like to start
      with this tree as it contains much of the code we can agree on and has
      not changed significantly over the last 2-3 weeks."
    
    * tag 'balancenuma-v11' of git://git.kernel.org/pub/scm/linux/kernel/git/mel/linux-balancenuma: (50 commits)
      mm/rmap, migration: Make rmap_walk_anon() and try_to_unmap_anon() more scalable
      mm/rmap: Convert the struct anon_vma::mutex to an rwsem
      mm: migrate: Account a transhuge page properly when rate limiting
      mm: numa: Account for failed allocations and isolations as migration failures
      mm: numa: Add THP migration for the NUMA working set scanning fault case build fix
      mm: numa: Add THP migration for the NUMA working set scanning fault case.
      mm: sched: numa: Delay PTE scanning until a task is scheduled on a new node
      mm: sched: numa: Control enabling and disabling of NUMA balancing if !SCHED_DEBUG
      mm: sched: numa: Control enabling and disabling of NUMA balancing
      mm: sched: Adapt the scanning rate if a NUMA hinting fault does not migrate
      mm: numa: Use a two-stage filter to restrict pages being migrated for unlikely task<->node relationships
      mm: numa: migrate: Set last_nid on newly allocated page
      mm: numa: split_huge_page: Transfer last_nid on tail page
      mm: numa: Introduce last_nid to the page frame
      sched: numa: Slowly increase the scanning period as NUMA faults are handled
      mm: numa: Rate limit setting of pte_numa if node is saturated
      mm: numa: Rate limit the amount of memory that is migrated between nodes
      mm: numa: Structures for Migrate On Fault per NUMA migration rate limiting
      mm: numa: Migrate pages handled during a pmd_numa hinting fault
      mm: numa: Migrate on reference policy
      ...

commit 5bca23035391928c4c7301835accca3551b96cc2
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Nov 22 14:40:03 2012 +0000

    mm: sched: numa: Delay PTE scanning until a task is scheduled on a new node
    
    Due to the fact that migrations are driven by the CPU a task is running
    on there is no point tracking NUMA faults until one task runs on a new
    node. This patch tracks the first node used by an address space. Until
    it changes, PTE scanning is disabled and no NUMA hinting faults are
    trapped. This should help workloads that are short-lived, do not care
    about NUMA placement or have bound themselves to a single node.
    
    This takes advantage of the logic in "mm: sched: numa: Implement slow
    start for working set sampling" to delay when the checks are made. This
    will take advantage of processes that set their CPU and node bindings
    early in their lifetime. It will also potentially allow any initial load
    balancing to take place.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index d2373a3e3252..e7c25fff1e94 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -65,8 +65,10 @@ SCHED_FEAT(LB_MIN, false)
 /*
  * Apply the automatic NUMA scheduling policy. Enabled automatically
  * at runtime if running on a NUMA machine. Can be controlled via
- * numa_balancing=
+ * numa_balancing=. Allow PTE scanning to be forced on UMA machines
+ * for debugging the core machinery.
  */
 #ifdef CONFIG_NUMA_BALANCING
 SCHED_FEAT(NUMA,	false)
+SCHED_FEAT(NUMA_FORCE,	false)
 #endif

commit 1a687c2e9a99335c9e77392f050fe607fa18a652
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Nov 22 11:16:36 2012 +0000

    mm: sched: numa: Control enabling and disabling of NUMA balancing
    
    This patch adds Kconfig options and kernel parameters to allow the
    enabling and disabling of automatic NUMA balancing. The existance
    of such a switch was and is very important when debugging problems
    related to transparent hugepages and we should have the same for
    automatic NUMA placement.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 5fb7aefbec80..d2373a3e3252 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -63,8 +63,10 @@ SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
 
 /*
- * Apply the automatic NUMA scheduling policy
+ * Apply the automatic NUMA scheduling policy. Enabled automatically
+ * at runtime if running on a NUMA machine. Can be controlled via
+ * numa_balancing=
  */
 #ifdef CONFIG_NUMA_BALANCING
-SCHED_FEAT(NUMA,	true)
+SCHED_FEAT(NUMA,	false)
 #endif

commit cbee9f88ec1b8dd6b58f25f54e4f52c82ed77690
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Thu Oct 25 14:16:43 2012 +0200

    mm: numa: Add fault driven placement and migration
    
    NOTE: This patch is based on "sched, numa, mm: Add fault driven
            placement and migration policy" but as it throws away all the policy
            to just leave a basic foundation I had to drop the signed-offs-by.
    
    This patch creates a bare-bones method for setting PTEs pte_numa in the
    context of the scheduler that when faulted later will be faulted onto the
    node the CPU is running on.  In itself this does nothing useful but any
    placement policy will fundamentally depend on receiving hints on placement
    from fault context and doing something intelligent about it.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index eebefcad7027..5fb7aefbec80 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -61,3 +61,10 @@ SCHED_FEAT(TTWU_QUEUE, true)
 SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
+
+/*
+ * Apply the automatic NUMA scheduling policy
+ */
+#ifdef CONFIG_NUMA_BALANCING
+SCHED_FEAT(NUMA,	true)
+#endif

commit 8ed92e51f99c2199c64cb33b4ba95ab12940a94c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Oct 14 14:28:50 2012 +0200

    sched: Add WAKEUP_PREEMPTION feature flag, on by default
    
    As per the recent discussion with Mike and Linus, make it easier to
    test with/without this feature. No change in default behavior.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/n/tip-izoxq4haeg4mTognnDbwcevt@git.kernel.org

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index eebefcad7027..e68e69ab917d 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -31,6 +31,11 @@ SCHED_FEAT(LAST_BUDDY, true)
  */
 SCHED_FEAT(CACHE_HOT_BUDDY, true)
 
+/*
+ * Allow wakeup-time preemption of the current task:
+ */
+SCHED_FEAT(WAKEUP_PREEMPTION, true)
+
 /*
  * Use arch dependent cpu power functions
  */

commit bc2a27cd27271c5257989a57f511be86b26f5e54
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Mon Jul 9 11:27:06 2012 +0200

    sched: cpu_power: enable ARCH_POWER
    
    Heteregeneous ARM platform uses arch_scale_freq_power function
    to reflect the relative capacity of each core
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1341826026-6504-6-git-send-email-vincent.guittot@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index c38f52ea53dd..eebefcad7027 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -34,7 +34,7 @@ SCHED_FEAT(CACHE_HOT_BUDDY, true)
 /*
  * Use arch dependent cpu power functions
  */
-SCHED_FEAT(ARCH_POWER, false)
+SCHED_FEAT(ARCH_POWER, true)
 
 SCHED_FEAT(HRTICK, false)
 SCHED_FEAT(DOUBLE_TICK, false)

commit c751134ef8b070070d5f06348286b29d86424677
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Thu Aug 16 13:21:05 2012 +0900

    sched: Remove AFFINE_WAKEUPS feature flag
    
    Commit beac4c7e4a1c ("sched: Remove AFFINE_WAKEUPS feature") removed
    use of the flag but left the definition. Get rid of it.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Link: http://lkml.kernel.org/r/1345090865-20851-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index de00a486c5c6..c38f52ea53dd 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -11,14 +11,6 @@ SCHED_FEAT(GENTLE_FAIR_SLEEPERS, true)
  */
 SCHED_FEAT(START_DEBIT, true)
 
-/*
- * Based on load and program behaviour, see if it makes sense to place
- * a newly woken task on the same cpu as the task that woke it --
- * improve cache locality. Typically used with SYNC wakeups as
- * generated by pipes and the like, see also SYNC_WAKEUPS.
- */
-SCHED_FEAT(AFFINE_WAKEUPS, true)
-
 /*
  * Prefer to schedule the task we woke last (assuming it failed
  * wakeup-preemption), since its likely going to consume data we

commit eb95308ee2a69403909e111837b9068c64cfc349
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Tue Apr 17 13:38:40 2012 +0200

    sched: Fix more load-balancing fallout
    
    Commits 367456c756a6 ("sched: Ditch per cgroup task lists for
    load-balancing") and 5d6523ebd ("sched: Fix load-balance wreckage")
    left some more wreckage.
    
    By setting loop_max unconditionally to ->nr_running load-balancing
    could take a lot of time on very long runqueues (hackbench!). So keep
    the sysctl as max limit of the amount of tasks we'll iterate.
    
    Furthermore, the min load filter for migration completely fails with
    cgroups since inequality in per-cpu state can easily lead to such
    small loads :/
    
    Furthermore the change to add new tasks to the tail of the queue
    instead of the head seems to have some effect.. not quite sure I
    understand why.
    
    Combined these fixes solve the huge hackbench regression reported by
    Tim when hackbench is ran in a cgroup.
    
    Reported-by: Tim Chen <tim.c.chen@linux.intel.com>
    Acked-by: Tim Chen <tim.c.chen@linux.intel.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1335365763.28150.267.camel@twins
    [ got rid of the CONFIG_PREEMPT tuning and made small readability edits ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index e61fd73913d0..de00a486c5c6 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -68,3 +68,4 @@ SCHED_FEAT(TTWU_QUEUE, true)
 
 SCHED_FEAT(FORCE_SD_OVERLAP, false)
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
+SCHED_FEAT(LB_MIN, false)

commit f8b6d1cc7dc15cf3de538b864eefaedad7a84d85
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Wed Jul 6 14:20:14 2011 +0200

    sched: Use jump_labels for sched_feat
    
    Now that we initialize jump_labels before sched_init() we can use them
    for the debug features without having to worry about a window where
    they have the wrong setting.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/n/tip-vpreo4hal9e0kzqmg5y0io2k@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 84802245abd2..e61fd73913d0 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -3,13 +3,13 @@
  * them to run sooner, but does not allow tons of sleepers to
  * rip the spread apart.
  */
-SCHED_FEAT(GENTLE_FAIR_SLEEPERS, 1)
+SCHED_FEAT(GENTLE_FAIR_SLEEPERS, true)
 
 /*
  * Place new tasks ahead so that they do not starve already running
  * tasks
  */
-SCHED_FEAT(START_DEBIT, 1)
+SCHED_FEAT(START_DEBIT, true)
 
 /*
  * Based on load and program behaviour, see if it makes sense to place
@@ -17,54 +17,54 @@ SCHED_FEAT(START_DEBIT, 1)
  * improve cache locality. Typically used with SYNC wakeups as
  * generated by pipes and the like, see also SYNC_WAKEUPS.
  */
-SCHED_FEAT(AFFINE_WAKEUPS, 1)
+SCHED_FEAT(AFFINE_WAKEUPS, true)
 
 /*
  * Prefer to schedule the task we woke last (assuming it failed
  * wakeup-preemption), since its likely going to consume data we
  * touched, increases cache locality.
  */
-SCHED_FEAT(NEXT_BUDDY, 0)
+SCHED_FEAT(NEXT_BUDDY, false)
 
 /*
  * Prefer to schedule the task that ran last (when we did
  * wake-preempt) as that likely will touch the same data, increases
  * cache locality.
  */
-SCHED_FEAT(LAST_BUDDY, 1)
+SCHED_FEAT(LAST_BUDDY, true)
 
 /*
  * Consider buddies to be cache hot, decreases the likelyness of a
  * cache buddy being migrated away, increases cache locality.
  */
-SCHED_FEAT(CACHE_HOT_BUDDY, 1)
+SCHED_FEAT(CACHE_HOT_BUDDY, true)
 
 /*
  * Use arch dependent cpu power functions
  */
-SCHED_FEAT(ARCH_POWER, 0)
+SCHED_FEAT(ARCH_POWER, false)
 
-SCHED_FEAT(HRTICK, 0)
-SCHED_FEAT(DOUBLE_TICK, 0)
-SCHED_FEAT(LB_BIAS, 1)
+SCHED_FEAT(HRTICK, false)
+SCHED_FEAT(DOUBLE_TICK, false)
+SCHED_FEAT(LB_BIAS, true)
 
 /*
  * Spin-wait on mutex acquisition when the mutex owner is running on
  * another cpu -- assumes that when the owner is running, it will soon
  * release the lock. Decreases scheduling overhead.
  */
-SCHED_FEAT(OWNER_SPIN, 1)
+SCHED_FEAT(OWNER_SPIN, true)
 
 /*
  * Decrement CPU power based on time not spent running tasks
  */
-SCHED_FEAT(NONTASK_POWER, 1)
+SCHED_FEAT(NONTASK_POWER, true)
 
 /*
  * Queue remote wakeups on the target CPU and process them
  * using the scheduler IPI. Reduces rq->lock contention/bounces.
  */
-SCHED_FEAT(TTWU_QUEUE, 1)
+SCHED_FEAT(TTWU_QUEUE, true)
 
-SCHED_FEAT(FORCE_SD_OVERLAP, 0)
-SCHED_FEAT(RT_RUNTIME_SHARE, 1)
+SCHED_FEAT(FORCE_SD_OVERLAP, false)
+SCHED_FEAT(RT_RUNTIME_SHARE, true)

commit 391e43da797a96aeb65410281891f6d0b0e9611c
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Tue Nov 15 17:14:39 2011 +0100

    sched: Move all scheduler bits into kernel/sched/
    
    There's too many sched*.[ch] files in kernel/, give them their own
    directory.
    
    (No code changed, other than Makefile glue added.)
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sched/features.h b/kernel/sched/features.h
new file mode 100644
index 000000000000..84802245abd2
--- /dev/null
+++ b/kernel/sched/features.h
@@ -0,0 +1,70 @@
+/*
+ * Only give sleepers 50% of their service deficit. This allows
+ * them to run sooner, but does not allow tons of sleepers to
+ * rip the spread apart.
+ */
+SCHED_FEAT(GENTLE_FAIR_SLEEPERS, 1)
+
+/*
+ * Place new tasks ahead so that they do not starve already running
+ * tasks
+ */
+SCHED_FEAT(START_DEBIT, 1)
+
+/*
+ * Based on load and program behaviour, see if it makes sense to place
+ * a newly woken task on the same cpu as the task that woke it --
+ * improve cache locality. Typically used with SYNC wakeups as
+ * generated by pipes and the like, see also SYNC_WAKEUPS.
+ */
+SCHED_FEAT(AFFINE_WAKEUPS, 1)
+
+/*
+ * Prefer to schedule the task we woke last (assuming it failed
+ * wakeup-preemption), since its likely going to consume data we
+ * touched, increases cache locality.
+ */
+SCHED_FEAT(NEXT_BUDDY, 0)
+
+/*
+ * Prefer to schedule the task that ran last (when we did
+ * wake-preempt) as that likely will touch the same data, increases
+ * cache locality.
+ */
+SCHED_FEAT(LAST_BUDDY, 1)
+
+/*
+ * Consider buddies to be cache hot, decreases the likelyness of a
+ * cache buddy being migrated away, increases cache locality.
+ */
+SCHED_FEAT(CACHE_HOT_BUDDY, 1)
+
+/*
+ * Use arch dependent cpu power functions
+ */
+SCHED_FEAT(ARCH_POWER, 0)
+
+SCHED_FEAT(HRTICK, 0)
+SCHED_FEAT(DOUBLE_TICK, 0)
+SCHED_FEAT(LB_BIAS, 1)
+
+/*
+ * Spin-wait on mutex acquisition when the mutex owner is running on
+ * another cpu -- assumes that when the owner is running, it will soon
+ * release the lock. Decreases scheduling overhead.
+ */
+SCHED_FEAT(OWNER_SPIN, 1)
+
+/*
+ * Decrement CPU power based on time not spent running tasks
+ */
+SCHED_FEAT(NONTASK_POWER, 1)
+
+/*
+ * Queue remote wakeups on the target CPU and process them
+ * using the scheduler IPI. Reduces rq->lock contention/bounces.
+ */
+SCHED_FEAT(TTWU_QUEUE, 1)
+
+SCHED_FEAT(FORCE_SD_OVERLAP, 0)
+SCHED_FEAT(RT_RUNTIME_SHARE, 1)
