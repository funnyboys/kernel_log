commit 69a94abb82eed2789d52b58665ddf4b454d9adb9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Sep 9 19:53:17 2019 +0900

    export.h, genksyms: do not make genksyms calculate CRC of trimmed symbols
    
    Arnd Bergmann reported false-positive modpost warnings detected by his
    randconfig testing of linux-next.
    
    Actually, this happens under the combination of CONFIG_MODVERSIONS
    and CONFIG_TRIM_UNUSED_KSYMS since commit 15bfc2348d54 ("modpost:
    check for static EXPORT_SYMBOL* functions").
    
    For example, arch/arm/config/multi_v7_defconfig + CONFIG_MODVERSIONS
    + CONFIG_TRIM_UNUSED_KSYMS produces the following false-positives:
    
    WARNING: "__lshrdi3" [vmlinux] is a static (unknown)
    WARNING: "__ashrdi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_lasr" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_llsr" [vmlinux] is a static (unknown)
    WARNING: "ftrace_set_clr_event" [vmlinux] is a static (unknown)
    WARNING: "__muldi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_ulcmp" [vmlinux] is a static (unknown)
    WARNING: "__ucmpdi2" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_lmul" [vmlinux] is a static (unknown)
    WARNING: "__bswapsi2" [vmlinux] is a static (unknown)
    WARNING: "__bswapdi2" [vmlinux] is a static (unknown)
    WARNING: "__ashldi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_llsl" [vmlinux] is a static (unknown)
    
    The root cause of the problem is not in the modpost, but in the
    implementation of CONFIG_TRIM_UNUSED_KSYMS.
    
    If there is at least one untrimmed symbol in the file, genksyms is
    invoked to calculate CRC of *all* the exported symbols in that file
    even if some of them have been trimmed due to no caller existing.
    
    As a result, .tmp_*.ver files contain CRC of trimmed symbols, thus
    unneeded, orphan __crc* symbols are added to objects. It had been
    harmless until recently.
    
    With commit 15bfc2348d54 ("modpost: check for static EXPORT_SYMBOL*
    functions"), it is now harmful because the bogus __crc* symbols make
    modpost call sym_update_crc() to add the symbols to the hash table,
    but there is no one that clears the ->is_static member.
    
    I gave Fixes to the first commit that uncovered the issue, but the
    potential problem has long existed since commit f235541699bc
    ("export.h: allow for per-symbol configurable EXPORT_SYMBOL()").
    
    Fixes: 15bfc2348d54 ("modpost: check for static EXPORT_SYMBOL* functions")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/scripts/genksyms/keywords.c b/scripts/genksyms/keywords.c
index c586d32dd2c3..7a85c4e21175 100644
--- a/scripts/genksyms/keywords.c
+++ b/scripts/genksyms/keywords.c
@@ -3,11 +3,7 @@ static struct resword {
 	const char *name;
 	int token;
 } keywords[] = {
-	{ "EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW },
-	{ "EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW },
-	{ "EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW },
-	{ "EXPORT_UNUSED_SYMBOL", EXPORT_SYMBOL_KEYW },
-	{ "EXPORT_UNUSED_SYMBOL_GPL", EXPORT_SYMBOL_KEYW },
+	{ "__GENKSYMS_EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW },
 	{ "__asm", ASM_KEYW },
 	{ "__asm__", ASM_KEYW },
 	{ "__attribute", ATTRIBUTE_KEYW },

commit a222061b85234d8a44486a46bd4df7e2cda52385
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Jun 18 14:10:48 2019 +0100

    genksyms: Teach parser about 128-bit built-in types
    
    __uint128_t crops up in a few files that export symbols to modules, so
    teach genksyms about it and the other GCC built-in 128-bit integer types
    so that we don't end up skipping the CRC generation for some symbols due
    to the parser failing to spot them:
    
      | WARNING: EXPORT symbol "kernel_neon_begin" [vmlinux] version
      |          generation failed, symbol will not be versioned.
      | ld: arch/arm64/kernel/fpsimd.o: relocation R_AARCH64_ABS32 against
      |     `__crc_kernel_neon_begin' can not be used when making a shared
      |     object
      | ld: arch/arm64/kernel/fpsimd.o:(.data+0x0): dangerous relocation:
      |     unsupported relocation
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/genksyms/keywords.c b/scripts/genksyms/keywords.c
index e93336baaaed..c586d32dd2c3 100644
--- a/scripts/genksyms/keywords.c
+++ b/scripts/genksyms/keywords.c
@@ -25,6 +25,10 @@ static struct resword {
 	{ "__volatile__", VOLATILE_KEYW },
 	{ "__builtin_va_list", VA_LIST_KEYW },
 
+	{ "__int128", BUILTIN_INT_KEYW },
+	{ "__int128_t", BUILTIN_INT_KEYW },
+	{ "__uint128_t", BUILTIN_INT_KEYW },
+
 	// According to rth, c99 defines "_Bool", __restrict", __restrict__", "restrict".  KAO
 	{ "_Bool", BOOL_KEYW },
 	{ "_restrict", RESTRICT_KEYW },

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/genksyms/keywords.c b/scripts/genksyms/keywords.c
index 9f40bcd17d07..e93336baaaed 100644
--- a/scripts/genksyms/keywords.c
+++ b/scripts/genksyms/keywords.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 static struct resword {
 	const char *name;
 	int token;

commit bb3290d91695bb1ae78ab86f18fb4d7ad8e5ebcc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 19 10:17:02 2017 -0700

    Remove gperf usage from toolchain
    
    It turns out that gperf-3.1 changed types in the generated code in ways
    that aren't even trivially detectable without having to generate a test-file.
    
    It's just not worth using tools and libraries from clowns that don't
    understand or care about compatibility.  So get rid of gperf.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/genksyms/keywords.c b/scripts/genksyms/keywords.c
new file mode 100644
index 000000000000..9f40bcd17d07
--- /dev/null
+++ b/scripts/genksyms/keywords.c
@@ -0,0 +1,74 @@
+static struct resword {
+	const char *name;
+	int token;
+} keywords[] = {
+	{ "EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW },
+	{ "EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW },
+	{ "EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW },
+	{ "EXPORT_UNUSED_SYMBOL", EXPORT_SYMBOL_KEYW },
+	{ "EXPORT_UNUSED_SYMBOL_GPL", EXPORT_SYMBOL_KEYW },
+	{ "__asm", ASM_KEYW },
+	{ "__asm__", ASM_KEYW },
+	{ "__attribute", ATTRIBUTE_KEYW },
+	{ "__attribute__", ATTRIBUTE_KEYW },
+	{ "__const", CONST_KEYW },
+	{ "__const__", CONST_KEYW },
+	{ "__extension__", EXTENSION_KEYW },
+	{ "__inline", INLINE_KEYW },
+	{ "__inline__", INLINE_KEYW },
+	{ "__signed", SIGNED_KEYW },
+	{ "__signed__", SIGNED_KEYW },
+	{ "__typeof", TYPEOF_KEYW },
+	{ "__typeof__", TYPEOF_KEYW },
+	{ "__volatile", VOLATILE_KEYW },
+	{ "__volatile__", VOLATILE_KEYW },
+	{ "__builtin_va_list", VA_LIST_KEYW },
+
+	// According to rth, c99 defines "_Bool", __restrict", __restrict__", "restrict".  KAO
+	{ "_Bool", BOOL_KEYW },
+	{ "_restrict", RESTRICT_KEYW },
+	{ "__restrict__", RESTRICT_KEYW },
+	{ "restrict", RESTRICT_KEYW },
+	{ "asm", ASM_KEYW },
+
+	// attribute commented out in modutils 2.4.2.  People are using 'attribute' as a
+	// field name which breaks the genksyms parser.  It is not a gcc keyword anyway.
+	// KAO. },
+	// { "attribute", ATTRIBUTE_KEYW },
+
+	{ "auto", AUTO_KEYW },
+	{ "char", CHAR_KEYW },
+	{ "const", CONST_KEYW },
+	{ "double", DOUBLE_KEYW },
+	{ "enum", ENUM_KEYW },
+	{ "extern", EXTERN_KEYW },
+	{ "float", FLOAT_KEYW },
+	{ "inline", INLINE_KEYW },
+	{ "int", INT_KEYW },
+	{ "long", LONG_KEYW },
+	{ "register", REGISTER_KEYW },
+	{ "short", SHORT_KEYW },
+	{ "signed", SIGNED_KEYW },
+	{ "static", STATIC_KEYW },
+	{ "struct", STRUCT_KEYW },
+	{ "typedef", TYPEDEF_KEYW },
+	{ "typeof", TYPEOF_KEYW },
+	{ "union", UNION_KEYW },
+	{ "unsigned", UNSIGNED_KEYW },
+	{ "void", VOID_KEYW },
+	{ "volatile", VOLATILE_KEYW },
+};
+
+#define NR_KEYWORDS (sizeof(keywords)/sizeof(struct resword))
+
+static int is_reserved_word(register const char *str, register unsigned int len)
+{
+	int i;
+	for (i = 0; i < NR_KEYWORDS; i++) {
+		struct resword *r = keywords + i;
+		int l = strlen(r->name);
+		if (len == l && !memcmp(str, r->name, len))
+			return r->token;
+	}
+	return -1;
+}
