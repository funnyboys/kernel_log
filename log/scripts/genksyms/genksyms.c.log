commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index e007840f45b9..23eff234184f 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* Generate kernel symbol version hashes.
    Copyright 1996, 1997 Linux International.
 
@@ -7,19 +8,7 @@
    This file was part of the Linux modutils 2.4.22: moved back into the
    kernel sources by Rusty Russell/Kai Germaschewski.
 
-   This program is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 2 of the License, or (at your
-   option) any later version.
-
-   This program is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ */
 
 #include <stdio.h>
 #include <string.h>

commit 74d9317161513b63ccb2f58eb866d6e91e13df98
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 16:23:46 2018 +0900

    genksyms: remove symbol prefix support
    
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX was selected by BLACKFIN, METAG.
    They were removed by commit 4ba66a976072 ("arch: remove blackfin port"),
    commit bb6fb6dfcc17 ("metag: Remove arch/metag/"), respectively.
    
    No more architecture enables CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX,
    hence the -s (--symbol-prefix) option is unnecessary.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index c9235d8340f1..e007840f45b9 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -45,7 +45,6 @@ int in_source_file;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
 	   flag_preserve, flag_warnings, flag_rel_crcs;
-static const char *mod_prefix = "";
 
 static int errors;
 static int nsyms;
@@ -693,10 +692,10 @@ void export_symbol(const char *name)
 			fputs(">\n", debugfile);
 
 		/* Used as a linker script. */
-		printf(!flag_rel_crcs ? "%s__crc_%s = 0x%08lx;\n" :
+		printf(!flag_rel_crcs ? "__crc_%s = 0x%08lx;\n" :
 		       "SECTIONS { .rodata : ALIGN(4) { "
-		       "%s__crc_%s = .; LONG(0x%08lx); } }\n",
-		       mod_prefix, name, crc);
+		       "__crc_%s = .; LONG(0x%08lx); } }\n",
+		       name, crc);
 	}
 }
 
@@ -769,7 +768,6 @@ int main(int argc, char **argv)
 
 #ifdef __GNU_LIBRARY__
 	struct option long_opts[] = {
-		{"symbol-prefix", 1, 0, 's'},
 		{"debug", 0, 0, 'd'},
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
@@ -789,9 +787,6 @@ int main(int argc, char **argv)
 	while ((o = getopt(argc, argv, "s:dwqVDr:T:phR")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
-		case 's':
-			mod_prefix = optarg;
-			break;
 		case 'd':
 			flag_debug++;
 			break;

commit 56067812d5b0e737ac2063e94a50f76b810d6ca3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:05 2017 +0000

    kbuild: modversions: add infrastructure for emitting relative CRCs
    
    This add the kbuild infrastructure that will allow architectures to emit
    vmlinux symbol CRCs as 32-bit offsets to another location in the kernel
    where the actual value is stored. This works around problems with CRCs
    being mistaken for relocatable symbols on kernels that self relocate at
    runtime (i.e., powerpc with CONFIG_RELOCATABLE=y)
    
    For the kbuild side of things, this comes down to the following:
    
     - introducing a Kconfig symbol MODULE_REL_CRCS
    
     - adding a -R switch to genksyms to instruct it to emit the CRC symbols
       as references into the .rodata section
    
     - making modpost distinguish such references from absolute CRC symbols
       by the section index (SHN_ABS)
    
     - making kallsyms disregard non-absolute symbols with a __crc_ prefix
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 06121ce524a7..c9235d8340f1 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -44,7 +44,7 @@ char *cur_filename, *source_file;
 int in_source_file;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
-	   flag_preserve, flag_warnings;
+	   flag_preserve, flag_warnings, flag_rel_crcs;
 static const char *mod_prefix = "";
 
 static int errors;
@@ -693,7 +693,10 @@ void export_symbol(const char *name)
 			fputs(">\n", debugfile);
 
 		/* Used as a linker script. */
-		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
+		printf(!flag_rel_crcs ? "%s__crc_%s = 0x%08lx;\n" :
+		       "SECTIONS { .rodata : ALIGN(4) { "
+		       "%s__crc_%s = .; LONG(0x%08lx); } }\n",
+		       mod_prefix, name, crc);
 	}
 }
 
@@ -730,7 +733,7 @@ void error_with_pos(const char *fmt, ...)
 
 static void genksyms_usage(void)
 {
-	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
+	fputs("Usage:\n" "genksyms [-adDTwqhVR] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
 	      "  -s, --symbol-prefix   Select symbol prefix\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
@@ -742,6 +745,7 @@ static void genksyms_usage(void)
 	      "  -q, --quiet           Disable warnings (default)\n"
 	      "  -h, --help            Print this message\n"
 	      "  -V, --version         Print the release version\n"
+	      "  -R, --relative-crc    Emit section relative symbol CRCs\n"
 #else				/* __GNU_LIBRARY__ */
 	      "  -s                    Select symbol prefix\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
@@ -753,6 +757,7 @@ static void genksyms_usage(void)
 	      "  -q                    Disable warnings (default)\n"
 	      "  -h                    Print this message\n"
 	      "  -V                    Print the release version\n"
+	      "  -R                    Emit section relative symbol CRCs\n"
 #endif				/* __GNU_LIBRARY__ */
 	      , stderr);
 }
@@ -774,13 +779,14 @@ int main(int argc, char **argv)
 		{"preserve", 0, 0, 'p'},
 		{"version", 0, 0, 'V'},
 		{"help", 0, 0, 'h'},
+		{"relative-crc", 0, 0, 'R'},
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "s:dwqVDr:T:ph",
+	while ((o = getopt_long(argc, argv, "s:dwqVDr:T:phR",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "s:dwqVDr:T:ph")) != EOF)
+	while ((o = getopt(argc, argv, "s:dwqVDr:T:phR")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 's':
@@ -823,6 +829,9 @@ int main(int argc, char **argv)
 		case 'h':
 			genksyms_usage();
 			return 0;
+		case 'R':
+			flag_rel_crcs = 1;
+			break;
 		default:
 			genksyms_usage();
 			return 1;

commit 4deaaa4deb0f9c42452711aa0a4b9c27016ca2f0
Author: Maxim Zhukov <mussitantesmortem@gmail.com>
Date:   Tue Apr 12 23:54:59 2016 +0300

    scripts: genksyms: fix resource leak
    
    This commit fixed resource leak at func main
    
    Signed-off-by: Maxim Zhukov <mussitantesmortem@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index dafaf96e0a34..06121ce524a7 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -873,5 +873,8 @@ int main(int argc, char **argv)
 			(double)nsyms / (double)HASH_BUCKETS);
 	}
 
+	if (dumpfile)
+		fclose(dumpfile);
+
 	return errors != 0;
 }

commit a78f70e8d65e88b9f631d073f68cb26dcd746298
Author: Michal Marek <mmarek@suse.com>
Date:   Wed Dec 9 15:08:21 2015 +0100

    genksyms: Handle string literals with spaces in reference files
    
    The reference files use spaces to separate tokens, however, we must
    preserve spaces inside string literals. Currently the only case in the
    tree is struct edac_raw_error_desc in <linux/edac.h>:
    
    $ KBUILD_SYMTYPES=1 make -s drivers/edac/amd64_edac.symtypes
    $ mv drivers/edac/amd64_edac.{symtypes,symref}
    $ KBUILD_SYMTYPES=1 make -s drivers/edac/amd64_edac.symtypes
    drivers/edac/amd64_edac.c:527: warning: amd64_get_dram_hole_info: modversion changed because of changes in struct edac_raw_error_desc
    
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 88632df4381b..dafaf96e0a34 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -423,13 +423,15 @@ static struct string_list *read_node(FILE *f)
 	struct string_list node = {
 		.string = buffer,
 		.tag = SYM_NORMAL };
-	int c;
+	int c, in_string = 0;
 
 	while ((c = fgetc(f)) != EOF) {
-		if (c == ' ') {
+		if (!in_string && c == ' ') {
 			if (node.string == buffer)
 				continue;
 			break;
+		} else if (c == '"') {
+			in_string = !in_string;
 		} else if (c == '\n') {
 			if (node.string == buffer)
 				return NULL;

commit d70f82acf32affa78ae4957caa0fb2a550d2c6ea
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Mar 18 19:38:56 2013 +1030

    genksyms: pass symbol-prefix instead of arch
    
    Pass symbol-prefix to genksyms instead of arch, so that the decision
    what symbol prefix to use is kept in one place.
    
    Basically genksyms used to take a -a $ARCH argument and it used that to
    determine whether to add an underscore symbol prefix. It's now changed
    to take a -s $SYMBOL_PREFIX argument so that the caller decides whether
    a symbol prefix is required. The build system then uses
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX to determine whether to pass the
    argument.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index d25e4a118d37..88632df4381b 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -45,7 +45,6 @@ int in_source_file;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
 	   flag_preserve, flag_warnings;
-static const char *arch = "";
 static const char *mod_prefix = "";
 
 static int errors;
@@ -731,7 +730,7 @@ static void genksyms_usage(void)
 {
 	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
-	      "  -a, --arch            Select architecture\n"
+	      "  -s, --symbol-prefix   Select symbol prefix\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
 	      "  -r, --reference file  Read reference symbols from a file\n"
@@ -742,7 +741,7 @@ static void genksyms_usage(void)
 	      "  -h, --help            Print this message\n"
 	      "  -V, --version         Print the release version\n"
 #else				/* __GNU_LIBRARY__ */
-	      "  -a                    Select architecture\n"
+	      "  -s                    Select symbol prefix\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
 	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
 	      "  -r file               Read reference symbols from a file\n"
@@ -763,7 +762,7 @@ int main(int argc, char **argv)
 
 #ifdef __GNU_LIBRARY__
 	struct option long_opts[] = {
-		{"arch", 1, 0, 'a'},
+		{"symbol-prefix", 1, 0, 's'},
 		{"debug", 0, 0, 'd'},
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
@@ -776,14 +775,14 @@ int main(int argc, char **argv)
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVDr:T:ph",
+	while ((o = getopt_long(argc, argv, "s:dwqVDr:T:ph",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVDr:T:ph")) != EOF)
+	while ((o = getopt(argc, argv, "s:dwqVDr:T:ph")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
-		case 'a':
-			arch = optarg;
+		case 's':
+			mod_prefix = optarg;
 			break;
 		case 'd':
 			flag_debug++;
@@ -826,9 +825,6 @@ int main(int argc, char **argv)
 			genksyms_usage();
 			return 1;
 		}
-	if ((strcmp(arch, "h8300") == 0) || (strcmp(arch, "blackfin") == 0) ||
-	    (strcmp(arch, "metag") == 0))
-		mod_prefix = "_";
 	{
 		extern int yydebug;
 		extern int yy_flex_debug;

commit 97c3ec63089fdcd2abf66619b913900909841dc0
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 11 15:40:24 2013 +0000

    genksyms: fix metag symbol prefix on crc symbols
    
    Meta uses symbol prefixes, so add "metag" to the list of architectures
    to set the mod_prefix to "_" for. This fixes __crc_* symbols to add the
    extra underscore to match _CRC_SYMBOL macro in <linux/export.h> and so
    that modpost finds them.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 8a106499ec4f..d25e4a118d37 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -826,7 +826,8 @@ int main(int argc, char **argv)
 			genksyms_usage();
 			return 1;
 		}
-	if ((strcmp(arch, "h8300") == 0) || (strcmp(arch, "blackfin") == 0))
+	if ((strcmp(arch, "h8300") == 0) || (strcmp(arch, "blackfin") == 0) ||
+	    (strcmp(arch, "metag") == 0))
 		mod_prefix = "_";
 	{
 		extern int yydebug;

commit 2c5925d6b7fedc8f1c325f4f85451f505ec69aca
Author: Michal Marek <mmarek@suse.cz>
Date:   Sat Oct 8 01:18:35 2011 +0200

    genksyms: Do not expand internal types
    
    Consider structures, unions and enums defined in the source file as
    internal and do not expand them. This way, changes to e.g. struct
    serial_private in drivers/tty/serial/8250_pci.c will not affect the
    checksum of the pciserial_* exports.

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 6d3fda0ce2ae..8a106499ec4f 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -40,7 +40,8 @@ static struct symbol *symtab[HASH_BUCKETS];
 static FILE *debugfile;
 
 int cur_line = 1;
-char *cur_filename;
+char *cur_filename, *source_file;
+int in_source_file;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
 	   flag_preserve, flag_warnings;

commit 1ae14703e76de49e6116296f3b20925f491dbb16
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Tue Jul 12 00:32:04 2011 +0200

    genksyms: Use same type in loop comparison
    
    The ARRAY_SIZE macro in scripts/genksyms/genksyms.c returns a value of
    type size_t. That value is being compared to a variable of type int in
    a loop in read_node(). Change the int variable to size_t type as well,
    so we don't do signed vs unsigned type comparisons with all the
    potential promotion/sign extension trouble that can cause (also
    silences compiler warnings at high levels of warnings).
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index f9e75531ea03..6d3fda0ce2ae 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -448,7 +448,7 @@ static struct string_list *read_node(FILE *f)
 	node.string = buffer;
 
 	if (node.string[1] == '#') {
-		int n;
+		size_t n;
 
 		for (n = 0; n < ARRAY_SIZE(symbol_types); n++) {
 			if (node.string[0] == symbol_types[n].n) {

commit e37ddb82500393cb417c3ab0fe0726d9a8652372
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Feb 3 23:57:09 2011 +0100

    genksyms: Track changes to enum constants
    
    Enum constants can be used as array sizes; if the enum itself does not
    appear in the symbol expansion, a change in the enum constant will go
    unnoticed. Example patch that changes the ABI but does not change the
    checksum with current genksyms:
    
    | enum e {
    |       E1,
    |       E2,
    |+      E3,
    |       E_MAX
    | };
    |
    | struct s {
    |       int a[E_MAX];
    | }
    |
    | int f(struct s *s) { ... }
    | EXPORT_SYMBOL(f)
    
    Therefore, remember the value of each enum constant and
    expand each occurence to <constant> <value>. The value is not actually
    computed, but instead an expression in the form
    (last explicitly assigned value) + N
    is used. This avoids having to parse and semantically understand whole
    of C.
    
    Note: The changes won't take effect until the lexer and parser are
    rebuilt by the next patch.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 4a350816a9e8..f9e75531ea03 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -62,6 +62,7 @@ static const struct {
 	[SYM_ENUM]       = {'e', "enum"},
 	[SYM_STRUCT]     = {'s', "struct"},
 	[SYM_UNION]      = {'u', "union"},
+	[SYM_ENUM_CONST] = {'E', "enum constant"},
 };
 
 static int equal_list(struct string_list *a, struct string_list *b);
@@ -149,10 +150,16 @@ static unsigned long crc32(const char *s)
 
 static enum symbol_type map_to_ns(enum symbol_type t)
 {
-	if (t == SYM_TYPEDEF)
-		t = SYM_NORMAL;
-	else if (t == SYM_UNION)
-		t = SYM_STRUCT;
+	switch (t) {
+	case SYM_ENUM_CONST:
+	case SYM_NORMAL:
+	case SYM_TYPEDEF:
+		return SYM_NORMAL;
+	case SYM_ENUM:
+	case SYM_STRUCT:
+	case SYM_UNION:
+		return SYM_STRUCT;
+	}
 	return t;
 }
 
@@ -191,10 +198,47 @@ static struct symbol *__add_symbol(const char *name, enum symbol_type type,
 			    struct string_list *defn, int is_extern,
 			    int is_reference)
 {
-	unsigned long h = crc32(name) % HASH_BUCKETS;
+	unsigned long h;
 	struct symbol *sym;
 	enum symbol_status status = STATUS_UNCHANGED;
+	/* The parser adds symbols in the order their declaration completes,
+	 * so it is safe to store the value of the previous enum constant in
+	 * a static variable.
+	 */
+	static int enum_counter;
+	static struct string_list *last_enum_expr;
+
+	if (type == SYM_ENUM_CONST) {
+		if (defn) {
+			free_list(last_enum_expr, NULL);
+			last_enum_expr = copy_list_range(defn, NULL);
+			enum_counter = 1;
+		} else {
+			struct string_list *expr;
+			char buf[20];
+
+			snprintf(buf, sizeof(buf), "%d", enum_counter++);
+			if (last_enum_expr) {
+				expr = copy_list_range(last_enum_expr, NULL);
+				defn = concat_list(mk_node("("),
+						   expr,
+						   mk_node(")"),
+						   mk_node("+"),
+						   mk_node(buf), NULL);
+			} else {
+				defn = mk_node(buf);
+			}
+		}
+	} else if (type == SYM_ENUM) {
+		free_list(last_enum_expr, NULL);
+		last_enum_expr = NULL;
+		enum_counter = 0;
+		if (!name)
+			/* Anonymous enum definition, nothing more to do */
+			return NULL;
+	}
 
+	h = crc32(name) % HASH_BUCKETS;
 	for (sym = symtab[h]; sym; sym = sym->hash_next) {
 		if (map_to_ns(sym->type) == map_to_ns(type) &&
 		    strcmp(name, sym->name) == 0) {
@@ -343,6 +387,22 @@ struct string_list *copy_node(struct string_list *node)
 	return newnode;
 }
 
+struct string_list *copy_list_range(struct string_list *start,
+				    struct string_list *end)
+{
+	struct string_list *res, *n;
+
+	if (start == end)
+		return NULL;
+	n = res = copy_node(start);
+	for (start = start->next; start != end; start = start->next) {
+		n->next = copy_node(start);
+		n = n->next;
+	}
+	n->next = NULL;
+	return res;
+}
+
 static int equal_list(struct string_list *a, struct string_list *b)
 {
 	while (a && b) {
@@ -512,6 +572,7 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 			crc = partial_crc32_one(' ', crc);
 			break;
 
+		case SYM_ENUM_CONST:
 		case SYM_TYPEDEF:
 			subsym = find_symbol(cur->string, cur->tag, 0);
 			/* FIXME: Bad reference files can segfault here. */

commit 01762c4ec5f6f62c550304b9c70e824293cefdd0
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Feb 15 15:11:36 2011 +0100

    genksyms: simplify usage of find_symbol()
    
    Allow searching for symbols of an exact type. The lexer does this and a
    subsequent patch will add one more usage.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index d17b7a2b941f..4a350816a9e8 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -156,7 +156,7 @@ static enum symbol_type map_to_ns(enum symbol_type t)
 	return t;
 }
 
-struct symbol *find_symbol(const char *name, enum symbol_type ns)
+struct symbol *find_symbol(const char *name, enum symbol_type ns, int exact)
 {
 	unsigned long h = crc32(name) % HASH_BUCKETS;
 	struct symbol *sym;
@@ -167,6 +167,8 @@ struct symbol *find_symbol(const char *name, enum symbol_type ns)
 		    sym->is_declared)
 			break;
 
+	if (exact && sym && sym->type != ns)
+		return NULL;
 	return sym;
 }
 
@@ -511,7 +513,7 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 			break;
 
 		case SYM_TYPEDEF:
-			subsym = find_symbol(cur->string, cur->tag);
+			subsym = find_symbol(cur->string, cur->tag, 0);
 			/* FIXME: Bad reference files can segfault here. */
 			if (subsym->expansion_trail) {
 				if (flag_dump_defs)
@@ -528,7 +530,7 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 		case SYM_STRUCT:
 		case SYM_UNION:
 		case SYM_ENUM:
-			subsym = find_symbol(cur->string, cur->tag);
+			subsym = find_symbol(cur->string, cur->tag, 0);
 			if (!subsym) {
 				struct string_list *n;
 
@@ -582,7 +584,7 @@ void export_symbol(const char *name)
 {
 	struct symbol *sym;
 
-	sym = find_symbol(name, SYM_NORMAL);
+	sym = find_symbol(name, SYM_NORMAL, 0);
 	if (!sym)
 		error_with_pos("export undefined symbol %s", name);
 	else {

commit 68eb8563a1adf27fae18dde4c95fb796c17563df
Author: Michal Marek <mmarek@suse.cz>
Date:   Wed Feb 2 23:52:13 2011 +0100

    genksyms: Add helpers for building string lists
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 2a1a3b84beba..d17b7a2b941f 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -66,6 +66,8 @@ static const struct {
 
 static int equal_list(struct string_list *a, struct string_list *b);
 static void print_list(FILE * f, struct string_list *list);
+static struct string_list *concat_list(struct string_list *start, ...);
+static struct string_list *mk_node(const char *string);
 static void print_location(void);
 static void print_type_name(enum symbol_type type, const char *name);
 
@@ -299,6 +301,35 @@ void free_list(struct string_list *s, struct string_list *e)
 	}
 }
 
+static struct string_list *mk_node(const char *string)
+{
+	struct string_list *newnode;
+
+	newnode = xmalloc(sizeof(*newnode));
+	newnode->string = xstrdup(string);
+	newnode->tag = SYM_NORMAL;
+	newnode->next = NULL;
+
+	return newnode;
+}
+
+static struct string_list *concat_list(struct string_list *start, ...)
+{
+	va_list ap;
+	struct string_list *n, *n2;
+
+	if (!start)
+		return NULL;
+	for (va_start(ap, start); (n = va_arg(ap, struct string_list *));) {
+		for (n2 = n; n2->next; n2 = n2->next)
+			;
+		n2->next = start;
+		start = n;
+	}
+	va_end(ap);
+	return start;
+}
+
 struct string_list *copy_node(struct string_list *node)
 {
 	struct string_list *newnode;
@@ -499,42 +530,17 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 		case SYM_ENUM:
 			subsym = find_symbol(cur->string, cur->tag);
 			if (!subsym) {
-				struct string_list *n, *t = NULL;
+				struct string_list *n;
 
 				error_with_pos("expand undefined %s %s",
 					       symbol_types[cur->tag].name,
 					       cur->string);
-
-				n = xmalloc(sizeof(*n));
-				n->string = xstrdup(symbol_types[cur->tag].name);
-				n->tag = SYM_NORMAL;
-				n->next = t;
-				t = n;
-
-				n = xmalloc(sizeof(*n));
-				n->string = xstrdup(cur->string);
-				n->tag = SYM_NORMAL;
-				n->next = t;
-				t = n;
-
-				n = xmalloc(sizeof(*n));
-				n->string = xstrdup("{");
-				n->tag = SYM_NORMAL;
-				n->next = t;
-				t = n;
-
-				n = xmalloc(sizeof(*n));
-				n->string = xstrdup("UNKNOWN");
-				n->tag = SYM_NORMAL;
-				n->next = t;
-				t = n;
-
-				n = xmalloc(sizeof(*n));
-				n->string = xstrdup("}");
-				n->tag = SYM_NORMAL;
-				n->next = t;
-				t = n;
-
+				n = concat_list(mk_node
+						(symbol_types[cur->tag].name),
+						mk_node(cur->string),
+						mk_node("{"),
+						mk_node("UNKNOWN"),
+						mk_node("}"), NULL);
 				subsym =
 				    add_symbol(cur->string, cur->tag, n, 0);
 			}

commit 7ec8eda154cbdcabb5305d90fb0952973dcaa560
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Jan 18 16:28:06 2011 +0100

    genksyms: Simplify printing of symbol types
    
    Instead of special-casing SYM_NORMAL, do not map any name to it. Also
    explicitly set the single-letter name of the symbol type, which will be
    needed by a further patch. The only user-visible change is one debug
    printf.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index f99115ebe925..2a1a3b84beba 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -53,8 +53,15 @@ static int nsyms;
 static struct symbol *expansion_trail;
 static struct symbol *visited_symbols;
 
-static const char *const symbol_type_name[] = {
-	"normal", "typedef", "enum", "struct", "union"
+static const struct {
+	int n;
+	const char *name;
+} symbol_types[] = {
+	[SYM_NORMAL]     = { 0, NULL},
+	[SYM_TYPEDEF]    = {'t', "typedef"},
+	[SYM_ENUM]       = {'e', "enum"},
+	[SYM_STRUCT]     = {'s', "struct"},
+	[SYM_UNION]      = {'u', "union"},
 };
 
 static int equal_list(struct string_list *a, struct string_list *b);
@@ -247,8 +254,12 @@ static struct symbol *__add_symbol(const char *name, enum symbol_type type,
 	sym->is_override = 0;
 
 	if (flag_debug) {
-		fprintf(debugfile, "Defn for %s %s == <",
-			symbol_type_name[type], name);
+		if (symbol_types[type].name)
+			fprintf(debugfile, "Defn for %s %s == <",
+				symbol_types[type].name, name);
+		else
+			fprintf(debugfile, "Defn for type%d %s == <",
+				type, name);
 		if (is_extern)
 			fputs("extern ", debugfile);
 		print_list(debugfile, defn);
@@ -346,8 +357,8 @@ static struct string_list *read_node(FILE *f)
 	if (node.string[1] == '#') {
 		int n;
 
-		for (n = 0; n < ARRAY_SIZE(symbol_type_name); n++) {
-			if (node.string[0] == symbol_type_name[n][0]) {
+		for (n = 0; n < ARRAY_SIZE(symbol_types); n++) {
+			if (node.string[0] == symbol_types[n].n) {
 				node.tag = n;
 				node.string += 2;
 				return copy_node(&node);
@@ -397,8 +408,8 @@ static void read_reference(FILE *f)
 
 static void print_node(FILE * f, struct string_list *list)
 {
-	if (list->tag != SYM_NORMAL) {
-		putc(symbol_type_name[list->tag][0], f);
+	if (symbol_types[list->tag].n) {
+		putc(symbol_types[list->tag].n, f);
 		putc('#', f);
 	}
 	fputs(list->string, f);
@@ -491,11 +502,11 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 				struct string_list *n, *t = NULL;
 
 				error_with_pos("expand undefined %s %s",
-					       symbol_type_name[cur->tag],
+					       symbol_types[cur->tag].name,
 					       cur->string);
 
 				n = xmalloc(sizeof(*n));
-				n->string = xstrdup(symbol_type_name[cur->tag]);
+				n->string = xstrdup(symbol_types[cur->tag].name);
 				n->tag = SYM_NORMAL;
 				n->next = t;
 				t = n;
@@ -530,11 +541,11 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 			if (subsym->expansion_trail) {
 				if (flag_dump_defs) {
 					fprintf(debugfile, "%s %s ",
-						symbol_type_name[cur->tag],
+						symbol_types[cur->tag].name,
 						cur->string);
 				}
 
-				crc = partial_crc32(symbol_type_name[cur->tag],
+				crc = partial_crc32(symbol_types[cur->tag].name,
 						    crc);
 				crc = partial_crc32_one(' ', crc);
 				crc = partial_crc32(cur->string, crc);
@@ -624,8 +635,8 @@ static void print_location(void)
 
 static void print_type_name(enum symbol_type type, const char *name)
 {
-	if (type != SYM_NORMAL)
-		fprintf(stderr, "%s %s", symbol_type_name[type], name);
+	if (symbol_types[type].name)
+		fprintf(stderr, "%s %s", symbol_types[type].name, name);
 	else
 		fprintf(stderr, "%s", name);
 }
@@ -771,8 +782,8 @@ int main(int argc, char **argv)
 
 			if (sym->is_override)
 				fputs("override ", dumpfile);
-			if (sym->type != SYM_NORMAL) {
-				putc(symbol_type_name[sym->type][0], dumpfile);
+			if (symbol_types[sym->type].n) {
+				putc(symbol_types[sym->type].n, dumpfile);
 				putc('#', dumpfile);
 			}
 			fputs(sym->name, dumpfile);

commit c64152bfd0106807c8d3ddbe6d0928e14a64f7bb
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Thu Jan 7 05:22:41 2010 +0300

    genksyms: close ref_file after use
    
    It is the last place when the file is read, so close it.
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index af6b8363a2d5..f99115ebe925 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -758,8 +758,10 @@ int main(int argc, char **argv)
 		/* setlinebuf(debugfile); */
 	}
 
-	if (flag_reference)
+	if (flag_reference) {
 		read_reference(ref_file);
+		fclose(ref_file);
+	}
 
 	yyparse();
 

commit b7ed698cc9d556306a4088c238e2ea9311ea2cb3
Author: Ladinu Chandrasinghe <ladinu.pub@gmail.com>
Date:   Tue Sep 22 16:43:42 2009 -0700

    Documentation/: fix warnings from -Wmissing-prototypes in HOSTCFLAGS
    
    Fix up -Wmissing-prototypes in compileable userspace code, mainly under
    Documentation/.
    
    Signed-off-by: Ladinu Chandrasinghe <ladinu.pub@gmail.com>
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 3a8297b5184c..af6b8363a2d5 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -176,7 +176,7 @@ static int is_unknown_symbol(struct symbol *sym)
 			strcmp(defn->string, "{") == 0);
 }
 
-struct symbol *__add_symbol(const char *name, enum symbol_type type,
+static struct symbol *__add_symbol(const char *name, enum symbol_type type,
 			    struct string_list *defn, int is_extern,
 			    int is_reference)
 {
@@ -265,7 +265,7 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 	return __add_symbol(name, type, defn, is_extern, 0);
 }
 
-struct symbol *add_reference_symbol(const char *name, enum symbol_type type,
+static struct symbol *add_reference_symbol(const char *name, enum symbol_type type,
 				    struct string_list *defn, int is_extern)
 {
 	return __add_symbol(name, type, defn, is_extern, 1);
@@ -313,7 +313,7 @@ static int equal_list(struct string_list *a, struct string_list *b)
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
-struct string_list *read_node(FILE *f)
+static struct string_list *read_node(FILE *f)
 {
 	char buffer[256];
 	struct string_list node = {

commit 2ea038917bbdd51a7ae4a898c6a04641324dd033
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jan 14 21:38:20 2009 +0100

    Revert "kbuild: strip generated symbols from *.ko"
    
    This reverts commit ad7a953c522ceb496611d127e51e278bfe0ff483.
    
    And commit: ("allow stripping of generated symbols under CONFIG_KALLSYMS_ALL")
                9bb482476c6c9d1ae033306440c51ceac93ea80c
    
    These stripping patches has caused a set of issues:
    
    1) People have reported compatibility issues with binutils due to
       lack of support for `--strip-unneeded-symbols' with objcopy 2.15.92.0.2
       Reported by: Wenji
    2) ccache and distcc no longer works as expeced
       Reported by: Ted, Roland, + others
    3) The installed modules increased a lot in size
       Reported by: Ted, Davej + others
    
    Reported-by: Wenji Huang <wenji.huang@oracle.com>
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Reported-by: Dave Jones <davej@redhat.com>
    Reported-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index f8bb4cabd62d..3a8297b5184c 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -43,7 +43,7 @@ int cur_line = 1;
 char *cur_filename;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
-	   flag_preserve, flag_warnings, flag_asm;
+	   flag_preserve, flag_warnings;
 static const char *arch = "";
 static const char *mod_prefix = "";
 
@@ -610,11 +610,8 @@ void export_symbol(const char *name)
 		if (flag_dump_defs)
 			fputs(">\n", debugfile);
 
-		/* Used as assembly source or a linker script. */
-		printf(flag_asm
-		       ? ".equiv %s__crc_%s, %#08lx\n"
-		       : "%s__crc_%s = %#08lx ;\n",
-		       mod_prefix, name, crc);
+		/* Used as a linker script. */
+		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
 	}
 }
 
@@ -651,10 +648,9 @@ void error_with_pos(const char *fmt, ...)
 
 static void genksyms_usage(void)
 {
-	fputs("Usage:\n" "genksyms [-aAdDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
+	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
 	      "  -a, --arch            Select architecture\n"
-	      "  -A, --asm             Generate assembly rather than linker script\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
 	      "  -r, --reference file  Read reference symbols from a file\n"
@@ -666,7 +662,6 @@ static void genksyms_usage(void)
 	      "  -V, --version         Print the release version\n"
 #else				/* __GNU_LIBRARY__ */
 	      "  -a                    Select architecture\n"
-	      "  -A                    Generate assembly rather than linker script\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
 	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
 	      "  -r file               Read reference symbols from a file\n"
@@ -688,7 +683,6 @@ int main(int argc, char **argv)
 #ifdef __GNU_LIBRARY__
 	struct option long_opts[] = {
 		{"arch", 1, 0, 'a'},
-		{"asm", 0, 0, 'A'},
 		{"debug", 0, 0, 'd'},
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
@@ -701,10 +695,10 @@ int main(int argc, char **argv)
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVADr:T:ph",
+	while ((o = getopt_long(argc, argv, "a:dwqVDr:T:ph",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVADr:T:ph")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDr:T:ph")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 'a':
@@ -722,9 +716,6 @@ int main(int argc, char **argv)
 		case 'V':
 			fputs("genksyms version 2.5.60\n", stderr);
 			break;
-		case 'A':
-			flag_asm = 1;
-			break;
 		case 'D':
 			flag_dump_defs = 1;
 			break;

commit ad7a953c522ceb496611d127e51e278bfe0ff483
Author: Jan Beulich <jbeulich@novell.com>
Date:   Tue Dec 16 11:28:14 2008 +0000

    kbuild: strip generated symbols from *.ko
    
    This patch changes the way __crc_ symbols are being resolved from
    using ld to do so to using the assembler, thus allowing these symbols
    to be marked local (the linker creates then as global ones) and hence
    allow stripping (for modules) or ignoring (for vmlinux) them. While at
    this, also strip other generated symbols during module installation.
    
    One potentially debatable point is the handling of the flags passeed
    to gcc when translating the intermediate assembly file into an object:
    passing $(c_flags) unchanged doesn't work as gcc passes --gdwarf2 to
    gas whenever is sees any -g* option, even for -g0, and despite the
    fact that the compiler would have already produced all necessary debug
    info in the C->assembly translation phase. I took the approach of just
    filtering out all -g* options, but an alternative to such negative
    filtering might be to have a positive filter which might, in the ideal
    case allow just all the -Wa,* options to pass through.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 3a8297b5184c..f8bb4cabd62d 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -43,7 +43,7 @@ int cur_line = 1;
 char *cur_filename;
 
 static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
-	   flag_preserve, flag_warnings;
+	   flag_preserve, flag_warnings, flag_asm;
 static const char *arch = "";
 static const char *mod_prefix = "";
 
@@ -610,8 +610,11 @@ void export_symbol(const char *name)
 		if (flag_dump_defs)
 			fputs(">\n", debugfile);
 
-		/* Used as a linker script. */
-		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
+		/* Used as assembly source or a linker script. */
+		printf(flag_asm
+		       ? ".equiv %s__crc_%s, %#08lx\n"
+		       : "%s__crc_%s = %#08lx ;\n",
+		       mod_prefix, name, crc);
 	}
 }
 
@@ -648,9 +651,10 @@ void error_with_pos(const char *fmt, ...)
 
 static void genksyms_usage(void)
 {
-	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
+	fputs("Usage:\n" "genksyms [-aAdDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
 	      "  -a, --arch            Select architecture\n"
+	      "  -A, --asm             Generate assembly rather than linker script\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
 	      "  -r, --reference file  Read reference symbols from a file\n"
@@ -662,6 +666,7 @@ static void genksyms_usage(void)
 	      "  -V, --version         Print the release version\n"
 #else				/* __GNU_LIBRARY__ */
 	      "  -a                    Select architecture\n"
+	      "  -A                    Generate assembly rather than linker script\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
 	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
 	      "  -r file               Read reference symbols from a file\n"
@@ -683,6 +688,7 @@ int main(int argc, char **argv)
 #ifdef __GNU_LIBRARY__
 	struct option long_opts[] = {
 		{"arch", 1, 0, 'a'},
+		{"asm", 0, 0, 'A'},
 		{"debug", 0, 0, 'd'},
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
@@ -695,10 +701,10 @@ int main(int argc, char **argv)
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVDr:T:ph",
+	while ((o = getopt_long(argc, argv, "a:dwqVADr:T:ph",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVDr:T:ph")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVADr:T:ph")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 'a':
@@ -716,6 +722,9 @@ int main(int argc, char **argv)
 		case 'V':
 			fputs("genksyms version 2.5.60\n", stderr);
 			break;
+		case 'A':
+			flag_asm = 1;
+			break;
 		case 'D':
 			flag_dump_defs = 1;
 			break;

commit 5dae9a550a7478c8d6a7da2336d3ceeebf90ab84
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Mon Dec 1 14:21:03 2008 -0800

    genksyms: allow to ignore symbol checksum changes
    
    This adds an "override" keyword for use in *.symvers / *.symref files.
    When a symbol is overridden, the symbol's old definition will be used for
    computing checksums instead of the new one, preserving the previous
    checksum.  (Genksyms will still warn about the change.)
    
    This is meant to allow distributions to hide minor actual as well as fake
    ABI changes.  (For example, when extra type information becomes available
    because additional headers are included, this may change checksums even
    though none of the types used have actully changed.)
    
    This approach also allows to get rid of "#ifdef __GENKSYMS__" hacks in the
    code, which are currently used in some vendor kernels to work around
    checksum changes.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index ddac1746908e..3a8297b5184c 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -191,11 +191,26 @@ struct symbol *__add_symbol(const char *name, enum symbol_type type,
 				/* fall through */ ;
 			else if (sym->type == type &&
 				 equal_list(sym->defn, defn)) {
+				if (!sym->is_declared && sym->is_override) {
+					print_location();
+					print_type_name(type, name);
+					fprintf(stderr, " modversion is "
+						"unchanged\n");
+				}
 				sym->is_declared = 1;
 				return sym;
 			} else if (!sym->is_declared) {
-				status = is_unknown_symbol(sym) ?
-					STATUS_DEFINED : STATUS_MODIFIED;
+				if (sym->is_override && flag_preserve) {
+					print_location();
+					fprintf(stderr, "ignoring ");
+					print_type_name(type, name);
+					fprintf(stderr, " modversion change\n");
+					sym->is_declared = 1;
+					return sym;
+				} else {
+					status = is_unknown_symbol(sym) ?
+						STATUS_DEFINED : STATUS_MODIFIED;
+				}
 			} else {
 				error_with_pos("redefinition of %s", name);
 				return sym;
@@ -229,6 +244,7 @@ struct symbol *__add_symbol(const char *name, enum symbol_type type,
 
 	sym->is_declared = !is_reference;
 	sym->status = status;
+	sym->is_override = 0;
 
 	if (flag_debug) {
 		fprintf(debugfile, "Defn for %s %s == <",
@@ -348,9 +364,16 @@ static void read_reference(FILE *f)
 	while (!feof(f)) {
 		struct string_list *defn = NULL;
 		struct string_list *sym, *def;
-		int is_extern = 0;
+		int is_extern = 0, is_override = 0;
+		struct symbol *subsym;
 
 		sym = read_node(f);
+		if (sym && sym->tag == SYM_NORMAL &&
+		    !strcmp(sym->string, "override")) {
+			is_override = 1;
+			free_node(sym);
+			sym = read_node(f);
+		}
 		if (!sym)
 			continue;
 		def = read_node(f);
@@ -365,8 +388,9 @@ static void read_reference(FILE *f)
 			defn = def;
 			def = read_node(f);
 		}
-		add_reference_symbol(xstrdup(sym->string), sym->tag,
+		subsym = add_reference_symbol(xstrdup(sym->string), sym->tag,
 					      defn, is_extern);
+		subsym->is_override = is_override;
 		free_node(sym);
 	}
 }
@@ -743,6 +767,8 @@ int main(int argc, char **argv)
 		while (visited_symbols != (struct symbol *)-1L) {
 			struct symbol *sym = visited_symbols;
 
+			if (sym->is_override)
+				fputs("override ", dumpfile);
 			if (sym->type != SYM_NORMAL) {
 				putc(symbol_type_name[sym->type][0], dumpfile);
 				putc('#', dumpfile);

commit 64e6c1e12372840e7caf8e25325a9e9c5fd370e6
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Mon Dec 1 14:21:01 2008 -0800

    genksyms: track symbol checksum changes
    
    Sometimes it is preferable to avoid changes of exported symbol checksums
    (to avoid breaking externally provided modules).  When a checksum change
    occurs, it can be hard to figure out what caused this change: underlying
    types may have changed, or additional type information may simply have
    become available at the point where a symbol is exported.
    
    Add a new --reference option to genksyms which allows it to report why
    checksums change, based on the type information dumps it creates with the
    --dump-types flag.  Genksyms will read in such a dump from a previous run,
    and report which symbols have changed (and why).
    
    The behavior can be controlled for an entire build as follows: If
    KBUILD_SYMTYPES is set, genksyms uses --dump-types to produce *.symtypes
    dump files.  If any *.symref files exist, those will be used as the
    reference to check against.  If KBUILD_PRESERVE is set, checksum changes
    will fail the build.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index c249274e005a..ddac1746908e 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -42,7 +42,8 @@ static FILE *debugfile;
 int cur_line = 1;
 char *cur_filename;
 
-static int flag_debug, flag_dump_defs, flag_dump_types, flag_warnings;
+static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
+	   flag_preserve, flag_warnings;
 static const char *arch = "";
 static const char *mod_prefix = "";
 
@@ -58,6 +59,8 @@ static const char *const symbol_type_name[] = {
 
 static int equal_list(struct string_list *a, struct string_list *b);
 static void print_list(FILE * f, struct string_list *list);
+static void print_location(void);
+static void print_type_name(enum symbol_type type, const char *name);
 
 /*----------------------------------------------------------------------*/
 
@@ -151,27 +154,68 @@ struct symbol *find_symbol(const char *name, enum symbol_type ns)
 
 	for (sym = symtab[h]; sym; sym = sym->hash_next)
 		if (map_to_ns(sym->type) == map_to_ns(ns) &&
-		    strcmp(name, sym->name) == 0)
+		    strcmp(name, sym->name) == 0 &&
+		    sym->is_declared)
 			break;
 
 	return sym;
 }
 
-struct symbol *add_symbol(const char *name, enum symbol_type type,
-			  struct string_list *defn, int is_extern)
+static int is_unknown_symbol(struct symbol *sym)
+{
+	struct string_list *defn;
+
+	return ((sym->type == SYM_STRUCT ||
+		 sym->type == SYM_UNION ||
+		 sym->type == SYM_ENUM) &&
+		(defn = sym->defn)  && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "}") == 0 &&
+		(defn = defn->next) && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "UNKNOWN") == 0 &&
+		(defn = defn->next) && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "{") == 0);
+}
+
+struct symbol *__add_symbol(const char *name, enum symbol_type type,
+			    struct string_list *defn, int is_extern,
+			    int is_reference)
 {
 	unsigned long h = crc32(name) % HASH_BUCKETS;
 	struct symbol *sym;
+	enum symbol_status status = STATUS_UNCHANGED;
 
 	for (sym = symtab[h]; sym; sym = sym->hash_next) {
-		if (map_to_ns(sym->type) == map_to_ns(type)
-		    && strcmp(name, sym->name) == 0) {
-			if (!equal_list(sym->defn, defn))
+		if (map_to_ns(sym->type) == map_to_ns(type) &&
+		    strcmp(name, sym->name) == 0) {
+			if (is_reference)
+				/* fall through */ ;
+			else if (sym->type == type &&
+				 equal_list(sym->defn, defn)) {
+				sym->is_declared = 1;
+				return sym;
+			} else if (!sym->is_declared) {
+				status = is_unknown_symbol(sym) ?
+					STATUS_DEFINED : STATUS_MODIFIED;
+			} else {
 				error_with_pos("redefinition of %s", name);
-			return sym;
+				return sym;
+			}
+			break;
 		}
 	}
 
+	if (sym) {
+		struct symbol **psym;
+
+		for (psym = &symtab[h]; *psym; psym = &(*psym)->hash_next) {
+			if (*psym == sym) {
+				*psym = sym->hash_next;
+				break;
+			}
+		}
+		--nsyms;
+	}
+
 	sym = xmalloc(sizeof(*sym));
 	sym->name = name;
 	sym->type = type;
@@ -183,6 +227,9 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 	sym->hash_next = symtab[h];
 	symtab[h] = sym;
 
+	sym->is_declared = !is_reference;
+	sym->status = status;
+
 	if (flag_debug) {
 		fprintf(debugfile, "Defn for %s %s == <",
 			symbol_type_name[type], name);
@@ -196,6 +243,18 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 	return sym;
 }
 
+struct symbol *add_symbol(const char *name, enum symbol_type type,
+			  struct string_list *defn, int is_extern)
+{
+	return __add_symbol(name, type, defn, is_extern, 0);
+}
+
+struct symbol *add_reference_symbol(const char *name, enum symbol_type type,
+				    struct string_list *defn, int is_extern)
+{
+	return __add_symbol(name, type, defn, is_extern, 1);
+}
+
 /*----------------------------------------------------------------------*/
 
 void free_node(struct string_list *node)
@@ -236,6 +295,82 @@ static int equal_list(struct string_list *a, struct string_list *b)
 	return !a && !b;
 }
 
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+struct string_list *read_node(FILE *f)
+{
+	char buffer[256];
+	struct string_list node = {
+		.string = buffer,
+		.tag = SYM_NORMAL };
+	int c;
+
+	while ((c = fgetc(f)) != EOF) {
+		if (c == ' ') {
+			if (node.string == buffer)
+				continue;
+			break;
+		} else if (c == '\n') {
+			if (node.string == buffer)
+				return NULL;
+			ungetc(c, f);
+			break;
+		}
+		if (node.string >= buffer + sizeof(buffer) - 1) {
+			fprintf(stderr, "Token too long\n");
+			exit(1);
+		}
+		*node.string++ = c;
+	}
+	if (node.string == buffer)
+		return NULL;
+	*node.string = 0;
+	node.string = buffer;
+
+	if (node.string[1] == '#') {
+		int n;
+
+		for (n = 0; n < ARRAY_SIZE(symbol_type_name); n++) {
+			if (node.string[0] == symbol_type_name[n][0]) {
+				node.tag = n;
+				node.string += 2;
+				return copy_node(&node);
+			}
+		}
+		fprintf(stderr, "Unknown type %c\n", node.string[0]);
+		exit(1);
+	}
+	return copy_node(&node);
+}
+
+static void read_reference(FILE *f)
+{
+	while (!feof(f)) {
+		struct string_list *defn = NULL;
+		struct string_list *sym, *def;
+		int is_extern = 0;
+
+		sym = read_node(f);
+		if (!sym)
+			continue;
+		def = read_node(f);
+		if (def && def->tag == SYM_NORMAL &&
+		    !strcmp(def->string, "extern")) {
+			is_extern = 1;
+			free_node(def);
+			def = read_node(f);
+		}
+		while (def) {
+			def->next = defn;
+			defn = def;
+			def = read_node(f);
+		}
+		add_reference_symbol(xstrdup(sym->string), sym->tag,
+					      defn, is_extern);
+		free_node(sym);
+	}
+}
+
 static void print_node(FILE * f, struct string_list *list)
 {
 	if (list->tag != SYM_NORMAL) {
@@ -311,6 +446,7 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 
 		case SYM_TYPEDEF:
 			subsym = find_symbol(cur->string, cur->tag);
+			/* FIXME: Bad reference files can segfault here. */
 			if (subsym->expansion_trail) {
 				if (flag_dump_defs)
 					fprintf(debugfile, "%s ", cur->string);
@@ -347,9 +483,22 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 				t = n;
 
 				n = xmalloc(sizeof(*n));
-				n->string = xstrdup("{ UNKNOWN }");
+				n->string = xstrdup("{");
 				n->tag = SYM_NORMAL;
 				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("UNKNOWN");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("}");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
 
 				subsym =
 				    add_symbol(cur->string, cur->tag, n, 0);
@@ -397,20 +546,42 @@ void export_symbol(const char *name)
 		error_with_pos("export undefined symbol %s", name);
 	else {
 		unsigned long crc;
+		int has_changed = 0;
 
 		if (flag_dump_defs)
 			fprintf(debugfile, "Export %s == <", name);
 
 		expansion_trail = (struct symbol *)-1L;
 
+		sym->expansion_trail = expansion_trail;
+		expansion_trail = sym;
 		crc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;
 
 		sym = expansion_trail;
 		while (sym != (struct symbol *)-1L) {
 			struct symbol *n = sym->expansion_trail;
+
+			if (sym->status != STATUS_UNCHANGED) {
+				if (!has_changed) {
+					print_location();
+					fprintf(stderr, "%s: %s: modversion "
+						"changed because of changes "
+						"in ", flag_preserve ? "error" :
+						       "warning", name);
+				} else
+					fprintf(stderr, ", ");
+				print_type_name(sym->type, sym->name);
+				if (sym->status == STATUS_DEFINED)
+					fprintf(stderr, " (became defined)");
+				has_changed = 1;
+				if (flag_preserve)
+					errors++;
+			}
 			sym->expansion_trail = 0;
 			sym = n;
 		}
+		if (has_changed)
+			fprintf(stderr, "\n");
 
 		if (flag_dump_defs)
 			fputs(">\n", debugfile);
@@ -421,13 +592,26 @@ void export_symbol(const char *name)
 }
 
 /*----------------------------------------------------------------------*/
+
+static void print_location(void)
+{
+	fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+}
+
+static void print_type_name(enum symbol_type type, const char *name)
+{
+	if (type != SYM_NORMAL)
+		fprintf(stderr, "%s %s", symbol_type_name[type], name);
+	else
+		fprintf(stderr, "%s", name);
+}
+
 void error_with_pos(const char *fmt, ...)
 {
 	va_list args;
 
 	if (flag_warnings) {
-		fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>",
-			cur_line);
+		print_location();
 
 		va_start(args, fmt);
 		vfprintf(stderr, fmt, args);
@@ -445,7 +629,9 @@ static void genksyms_usage(void)
 	      "  -a, --arch            Select architecture\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
-	      "  -T, --dump-types file Dump expanded types into file (for debugging only)\n"
+	      "  -r, --reference file  Read reference symbols from a file\n"
+	      "  -T, --dump-types file Dump expanded types into file\n"
+	      "  -p, --preserve        Preserve reference modversions or fail\n"
 	      "  -w, --warnings        Enable warnings\n"
 	      "  -q, --quiet           Disable warnings (default)\n"
 	      "  -h, --help            Print this message\n"
@@ -454,7 +640,9 @@ static void genksyms_usage(void)
 	      "  -a                    Select architecture\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
 	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
-	      "  -T file               Dump expanded types into file (for debugging only)\n"
+	      "  -r file               Read reference symbols from a file\n"
+	      "  -T file               Dump expanded types into file\n"
+	      "  -p                    Preserve reference modversions or fail\n"
 	      "  -w                    Enable warnings\n"
 	      "  -q                    Disable warnings (default)\n"
 	      "  -h                    Print this message\n"
@@ -465,7 +653,7 @@ static void genksyms_usage(void)
 
 int main(int argc, char **argv)
 {
-	FILE *dumpfile = NULL;
+	FILE *dumpfile = NULL, *ref_file = NULL;
 	int o;
 
 #ifdef __GNU_LIBRARY__
@@ -475,16 +663,18 @@ int main(int argc, char **argv)
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
 		{"dump", 0, 0, 'D'},
+		{"reference", 1, 0, 'r'},
 		{"dump-types", 1, 0, 'T'},
+		{"preserve", 0, 0, 'p'},
 		{"version", 0, 0, 'V'},
 		{"help", 0, 0, 'h'},
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVDT:h",
+	while ((o = getopt_long(argc, argv, "a:dwqVDr:T:ph",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVDT:h")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDr:T:ph")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 'a':
@@ -505,6 +695,14 @@ int main(int argc, char **argv)
 		case 'D':
 			flag_dump_defs = 1;
 			break;
+		case 'r':
+			flag_reference = 1;
+			ref_file = fopen(optarg, "r");
+			if (!ref_file) {
+				perror(optarg);
+				return 1;
+			}
+			break;
 		case 'T':
 			flag_dump_types = 1;
 			dumpfile = fopen(optarg, "w");
@@ -513,6 +711,9 @@ int main(int argc, char **argv)
 				return 1;
 			}
 			break;
+		case 'p':
+			flag_preserve = 1;
+			break;
 		case 'h':
 			genksyms_usage();
 			return 0;
@@ -533,6 +734,9 @@ int main(int argc, char **argv)
 		/* setlinebuf(debugfile); */
 	}
 
+	if (flag_reference)
+		read_reference(ref_file);
+
 	yyparse();
 
 	if (flag_dump_types && visited_symbols) {

commit 3b40d38120c32798a4be8d8052f028deeca9d581
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Mon Jul 21 04:28:25 2008 +0200

    kbuild: genksyms: Include extern information in dumps
    
    The extern flag currently is not included in type dump files
    (genksyms --dump-types). Include that flag there for completeness.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 4f8a3007e457..c249274e005a 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -545,6 +545,8 @@ int main(int argc, char **argv)
 			}
 			fputs(sym->name, dumpfile);
 			putc(' ', dumpfile);
+			if (sym->is_extern)
+				fputs("extern ", dumpfile);
 			print_list(dumpfile, sym->defn);
 			putc('\n', dumpfile);
 

commit f606ddf42fd4edc558eeb48bfee66d2c591571d2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jul 23 21:28:50 2008 -0700

    remove the v850 port
    
    Trying to compile the v850 port brings many compile errors, one of them exists
    since at least kernel 2.6.19.
    
    There also seems to be noone willing to bring this port back into a usable
    state.
    
    This patch therefore removes the v850 port.
    
    If anyone ever decides to revive the v850 port the code will still be
    available from older kernels, and it wouldn't be impossible for the port to
    reenter the kernel if it would become actively maintained again.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index dca5e0dd09bf..4f8a3007e457 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -520,8 +520,7 @@ int main(int argc, char **argv)
 			genksyms_usage();
 			return 1;
 		}
-	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0)
-	    || (strcmp(arch, "blackfin") == 0))
+	if ((strcmp(arch, "h8300") == 0) || (strcmp(arch, "blackfin") == 0))
 		mod_prefix = "_";
 	{
 		extern int yydebug;

commit 36091fd348e79ab703b0766420c0b06ff7662d2d
Author: Mike Frysinger <vapier.adi@gmail.com>
Date:   Sat Nov 10 09:32:20 2007 -0500

    kbuild: fixup genksyms usage/getopt
    
    The usage does not mention the "-a,--arch" or "-T,--dump-types" options, so
    add them.  The calls to getopt() seem to mention options that no longer exist
    (some "k" and "p" thingy) but omits the "h" option which means using '-h'
    actually triggers the error code path, so update those as well.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 511023b430a8..dca5e0dd09bf 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -440,17 +440,21 @@ void error_with_pos(const char *fmt, ...)
 
 static void genksyms_usage(void)
 {
-	fputs("Usage:\n" "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n" "\n"
+	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
+	      "  -a, --arch            Select architecture\n"
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
+	      "  -T, --dump-types file Dump expanded types into file (for debugging only)\n"
 	      "  -w, --warnings        Enable warnings\n"
 	      "  -q, --quiet           Disable warnings (default)\n"
 	      "  -h, --help            Print this message\n"
 	      "  -V, --version         Print the release version\n"
 #else				/* __GNU_LIBRARY__ */
+	      "  -a                    Select architecture\n"
 	      "  -d                    Increment the debug level (repeatable)\n"
 	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
+	      "  -T file               Dump expanded types into file (for debugging only)\n"
 	      "  -w                    Enable warnings\n"
 	      "  -q                    Disable warnings (default)\n"
 	      "  -h                    Print this message\n"
@@ -477,10 +481,10 @@ int main(int argc, char **argv)
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVDT:k:p:",
+	while ((o = getopt_long(argc, argv, "a:dwqVDT:h",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVDT:k:p:")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDT:h")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 'a':

commit 1394f03221790a988afc3e4b3cb79f2e477246a9
Author: Bryan Wu <bryan.wu@analog.com>
Date:   Sun May 6 14:50:22 2007 -0700

    blackfin architecture
    
    This adds support for the Analog Devices Blackfin processor architecture, and
    currently supports the BF533, BF532, BF531, BF537, BF536, BF534, and BF561
    (Dual Core) devices, with a variety of development platforms including those
    avaliable from Analog Devices (BF533-EZKit, BF533-STAMP, BF537-STAMP,
    BF561-EZKIT), and Bluetechnix!  Tinyboards.
    
    The Blackfin architecture was jointly developed by Intel and Analog Devices
    Inc.  (ADI) as the Micro Signal Architecture (MSA) core and introduced it in
    December of 2000.  Since then ADI has put this core into its Blackfin
    processor family of devices.  The Blackfin core has the advantages of a clean,
    orthogonal,RISC-like microprocessor instruction set.  It combines a dual-MAC
    (Multiply/Accumulate), state-of-the-art signal processing engine and
    single-instruction, multiple-data (SIMD) multimedia capabilities into a single
    instruction-set architecture.
    
    The Blackfin architecture, including the instruction set, is described by the
    ADSP-BF53x/BF56x Blackfin Processor Programming Reference
    http://blackfin.uclinux.org/gf/download/frsrelease/29/2549/Blackfin_PRM.pdf
    
    The Blackfin processor is already supported by major releases of gcc, and
    there are binary and source rpms/tarballs for many architectures at:
    http://blackfin.uclinux.org/gf/project/toolchain/frs There is complete
    documentation, including "getting started" guides available at:
    http://docs.blackfin.uclinux.org/ which provides links to the sources and
    patches you will need in order to set up a cross-compiling environment for
    bfin-linux-uclibc
    
    This patch, as well as the other patches (toolchain, distribution,
    uClibc) are actively supported by Analog Devices Inc, at:
    http://blackfin.uclinux.org/
    
    We have tested this on LTP, and our test plan (including pass/fails) can
    be found at:
    http://docs.blackfin.uclinux.org/doku.php?id=testing_the_linux_kernel
    
    [m.kozlowski@tuxland.pl: balance parenthesis in blackfin header files]
    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Aubrey Li <aubrey.li@analog.com>
    Signed-off-by: Jie Zhang <jie.zhang@analog.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index b0381823e404..511023b430a8 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -516,7 +516,8 @@ int main(int argc, char **argv)
 			genksyms_usage();
 			return 1;
 		}
-	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0))
+	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0)
+	    || (strcmp(arch, "blackfin") == 0))
 		mod_prefix = "_";
 	{
 		extern int yydebug;

commit 15fde6751886fd972a64ed65ba49db309919c504
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Tue May 9 20:37:30 2006 +0200

    kbuild: support for %.symtypes files
    
    Here is a patch that adds a new -T option to genksyms for generating dumps of
    the type definition that makes up the symbol version hashes. This allows to
    trace modversion changes back to what caused them. The dump format is the
    name of the type defined, followed by its definition (which is almost C):
    
      s#list_head struct list_head { s#list_head * next , * prev ; }
    
    The s#, u#, e#, and t# prefixes stand for struct, union, enum, and typedef.
    The exported symbols do not define types, and thus do not have an x# prefix:
    
      nfs4_acl_get_whotype int nfs4_acl_get_whotype ( char * , t#u32 )
    
    The symbol type defintion of a single file can be generated with:
    
      make fs/jbd/journal.symtypes
    
    If KBUILD_SYMTYPES is defined, all the *.symtypes of all object files that
    export symbols are generated.
    
    The single *.symtypes files can be combined into a single file after a kernel
    build with a script like the following:
    
    for f in $(find -name '*.symtypes' | sort); do
        f=${f#./}
        echo "/* ${f%.symtypes}.o */"
        cat $f
        echo
    done \
    | sed -e '\:UNKNOWN:d' \
          -e 's:[,;] }:}:g' \
          -e 's:\([[({]\) :\1:g' \
          -e 's: \([])},;]\):\1:g' \
          -e 's: $::' \
          $f \
    | awk '
    /^.#/   { if (defined[$1] == $0) {
                print $1
                next
              }
              defined[$1] = $0
            }
            { print }
    '
    
    When the kernel ABI changes, diffing individual *.symtype files, or the
    combined files, against each other will show which symbol changes caused the
    ABI changes. This can save a tremendous amount of time.
    
    Dump the types that make up modversions
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 5b0344e20d61..b0381823e404 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -42,7 +42,7 @@ static FILE *debugfile;
 int cur_line = 1;
 char *cur_filename;
 
-static int flag_debug, flag_dump_defs, flag_warnings;
+static int flag_debug, flag_dump_defs, flag_dump_types, flag_warnings;
 static const char *arch = "";
 static const char *mod_prefix = "";
 
@@ -50,6 +50,7 @@ static int errors;
 static int nsyms;
 
 static struct symbol *expansion_trail;
+static struct symbol *visited_symbols;
 
 static const char *const symbol_type_name[] = {
 	"normal", "typedef", "enum", "struct", "union"
@@ -176,6 +177,7 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 	sym->type = type;
 	sym->defn = defn;
 	sym->expansion_trail = NULL;
+	sym->visited = NULL;
 	sym->is_extern = is_extern;
 
 	sym->hash_next = symtab[h];
@@ -236,26 +238,11 @@ static int equal_list(struct string_list *a, struct string_list *b)
 
 static void print_node(FILE * f, struct string_list *list)
 {
-	switch (list->tag) {
-	case SYM_STRUCT:
-		putc('s', f);
-		goto printit;
-	case SYM_UNION:
-		putc('u', f);
-		goto printit;
-	case SYM_ENUM:
-		putc('e', f);
-		goto printit;
-	case SYM_TYPEDEF:
-		putc('t', f);
-		goto printit;
-
-	      printit:
+	if (list->tag != SYM_NORMAL) {
+		putc(symbol_type_name[list->tag][0], f);
 		putc('#', f);
-	case SYM_NORMAL:
-		fputs(list->string, f);
-		break;
 	}
+	fputs(list->string, f);
 }
 
 static void print_list(FILE * f, struct string_list *list)
@@ -287,9 +274,9 @@ static void print_list(FILE * f, struct string_list *list)
 	}
 }
 
-static unsigned long expand_and_crc_list(struct string_list *list,
-					 unsigned long crc)
+static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 {
+	struct string_list *list = sym->defn;
 	struct string_list **e, **b;
 	struct string_list *tmp, **tmp2;
 	int elem = 1;
@@ -332,7 +319,7 @@ static unsigned long expand_and_crc_list(struct string_list *list,
 			} else {
 				subsym->expansion_trail = expansion_trail;
 				expansion_trail = subsym;
-				crc = expand_and_crc_list(subsym->defn, crc);
+				crc = expand_and_crc_sym(subsym, crc);
 			}
 			break;
 
@@ -382,12 +369,22 @@ static unsigned long expand_and_crc_list(struct string_list *list,
 			} else {
 				subsym->expansion_trail = expansion_trail;
 				expansion_trail = subsym;
-				crc = expand_and_crc_list(subsym->defn, crc);
+				crc = expand_and_crc_sym(subsym, crc);
 			}
 			break;
 		}
 	}
 
+	{
+		static struct symbol **end = &visited_symbols;
+
+		if (!sym->visited) {
+			*end = sym;
+			end = &sym->visited;
+			sym->visited = (struct symbol *)-1L;
+		}
+	}
+
 	return crc;
 }
 
@@ -406,7 +403,7 @@ void export_symbol(const char *name)
 
 		expansion_trail = (struct symbol *)-1L;
 
-		crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+		crc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;
 
 		sym = expansion_trail;
 		while (sym != (struct symbol *)-1L) {
@@ -464,6 +461,7 @@ static void genksyms_usage(void)
 
 int main(int argc, char **argv)
 {
+	FILE *dumpfile = NULL;
 	int o;
 
 #ifdef __GNU_LIBRARY__
@@ -473,15 +471,16 @@ int main(int argc, char **argv)
 		{"warnings", 0, 0, 'w'},
 		{"quiet", 0, 0, 'q'},
 		{"dump", 0, 0, 'D'},
+		{"dump-types", 1, 0, 'T'},
 		{"version", 0, 0, 'V'},
 		{"help", 0, 0, 'h'},
 		{0, 0, 0, 0}
 	};
 
-	while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
+	while ((o = getopt_long(argc, argv, "a:dwqVDT:k:p:",
 				&long_opts[0], NULL)) != EOF)
 #else				/* __GNU_LIBRARY__ */
-	while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDT:k:p:")) != EOF)
 #endif				/* __GNU_LIBRARY__ */
 		switch (o) {
 		case 'a':
@@ -502,6 +501,14 @@ int main(int argc, char **argv)
 		case 'D':
 			flag_dump_defs = 1;
 			break;
+		case 'T':
+			flag_dump_types = 1;
+			dumpfile = fopen(optarg, "w");
+			if (!dumpfile) {
+				perror(optarg);
+				return 1;
+			}
+			break;
 		case 'h':
 			genksyms_usage();
 			return 0;
@@ -524,6 +531,24 @@ int main(int argc, char **argv)
 
 	yyparse();
 
+	if (flag_dump_types && visited_symbols) {
+		while (visited_symbols != (struct symbol *)-1L) {
+			struct symbol *sym = visited_symbols;
+
+			if (sym->type != SYM_NORMAL) {
+				putc(symbol_type_name[sym->type][0], dumpfile);
+				putc('#', dumpfile);
+			}
+			fputs(sym->name, dumpfile);
+			putc(' ', dumpfile);
+			print_list(dumpfile, sym->defn);
+			putc('\n', dumpfile);
+
+			visited_symbols = sym->visited;
+			sym->visited = NULL;
+		}
+	}
+
 	if (flag_debug) {
 		fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
 			nsyms, HASH_BUCKETS,

commit ce560686947fd50b30eaf42045554797f53949dd
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 12 23:26:29 2006 +0100

    kbuild: clean-up genksyms
    
    o remove all inlines
    o declare everything static which is only used by genksyms.c
    o delete unused functions
    o delete unused variables
    o delete unused stuff in genksyms.h
    o properly ident genksyms.h
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index b798e284e1fc..5b0344e20d61 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -37,14 +37,14 @@
 #define HASH_BUCKETS  4096
 
 static struct symbol *symtab[HASH_BUCKETS];
-FILE *debugfile;
+static FILE *debugfile;
 
 int cur_line = 1;
-char *cur_filename, *output_directory;
+char *cur_filename;
 
-int flag_debug, flag_dump_defs, flag_warnings;
-const char *arch = "";
-const char *mod_prefix = "";
+static int flag_debug, flag_dump_defs, flag_warnings;
+static const char *arch = "";
+static const char *mod_prefix = "";
 
 static int errors;
 static int nsyms;
@@ -55,6 +55,9 @@ static const char *const symbol_type_name[] = {
 	"normal", "typedef", "enum", "struct", "union"
 };
 
+static int equal_list(struct string_list *a, struct string_list *b);
+static void print_list(FILE * f, struct string_list *list);
+
 /*----------------------------------------------------------------------*/
 
 static const unsigned int crctab32[] = {
@@ -112,27 +115,26 @@ static const unsigned int crctab32[] = {
 	0x2d02ef8dU
 };
 
-static inline unsigned long
-partial_crc32_one(unsigned char c, unsigned long crc)
+static unsigned long partial_crc32_one(unsigned char c, unsigned long crc)
 {
 	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
 }
 
-static inline unsigned long partial_crc32(const char *s, unsigned long crc)
+static unsigned long partial_crc32(const char *s, unsigned long crc)
 {
 	while (*s)
 		crc = partial_crc32_one(*s++, crc);
 	return crc;
 }
 
-static inline unsigned long crc32(const char *s)
+static unsigned long crc32(const char *s)
 {
 	return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
 }
 
 /*----------------------------------------------------------------------*/
 
-static inline enum symbol_type map_to_ns(enum symbol_type t)
+static enum symbol_type map_to_ns(enum symbol_type t)
 {
 	if (t == SYM_TYPEDEF)
 		t = SYM_NORMAL;
@@ -147,8 +149,8 @@ struct symbol *find_symbol(const char *name, enum symbol_type ns)
 	struct symbol *sym;
 
 	for (sym = symtab[h]; sym; sym = sym->hash_next)
-		if (map_to_ns(sym->type) == map_to_ns(ns)
-		    && strcmp(name, sym->name) == 0)
+		if (map_to_ns(sym->type) == map_to_ns(ns) &&
+		    strcmp(name, sym->name) == 0)
 			break;
 
 	return sym;
@@ -160,13 +162,14 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 	unsigned long h = crc32(name) % HASH_BUCKETS;
 	struct symbol *sym;
 
-	for (sym = symtab[h]; sym; sym = sym->hash_next)
+	for (sym = symtab[h]; sym; sym = sym->hash_next) {
 		if (map_to_ns(sym->type) == map_to_ns(type)
 		    && strcmp(name, sym->name) == 0) {
 			if (!equal_list(sym->defn, defn))
 				error_with_pos("redefinition of %s", name);
 			return sym;
 		}
+	}
 
 	sym = xmalloc(sizeof(*sym));
 	sym->name = name;
@@ -193,7 +196,7 @@ struct symbol *add_symbol(const char *name, enum symbol_type type,
 
 /*----------------------------------------------------------------------*/
 
-inline void free_node(struct string_list *node)
+void free_node(struct string_list *node)
 {
 	free(node->string);
 	free(node);
@@ -208,7 +211,7 @@ void free_list(struct string_list *s, struct string_list *e)
 	}
 }
 
-inline struct string_list *copy_node(struct string_list *node)
+struct string_list *copy_node(struct string_list *node)
 {
 	struct string_list *newnode;
 
@@ -219,22 +222,7 @@ inline struct string_list *copy_node(struct string_list *node)
 	return newnode;
 }
 
-struct string_list *copy_list(struct string_list *s, struct string_list *e)
-{
-	struct string_list *h, *p;
-
-	if (s == e)
-		return NULL;
-
-	p = h = copy_node(s);
-	while ((s = s->next) != e)
-		p = p->next = copy_node(s);
-	p->next = NULL;
-
-	return h;
-}
-
-int equal_list(struct string_list *a, struct string_list *b)
+static int equal_list(struct string_list *a, struct string_list *b)
 {
 	while (a && b) {
 		if (a->tag != b->tag || strcmp(a->string, b->string))
@@ -246,7 +234,7 @@ int equal_list(struct string_list *a, struct string_list *b)
 	return !a && !b;
 }
 
-static inline void print_node(FILE * f, struct string_list *list)
+static void print_node(FILE * f, struct string_list *list)
 {
 	switch (list->tag) {
 	case SYM_STRUCT:
@@ -270,7 +258,7 @@ static inline void print_node(FILE * f, struct string_list *list)
 	}
 }
 
-void print_list(FILE * f, struct string_list *list)
+static void print_list(FILE * f, struct string_list *list)
 {
 	struct string_list **e, **b;
 	struct string_list *tmp, **tmp2;
@@ -299,8 +287,8 @@ void print_list(FILE * f, struct string_list *list)
 	}
 }
 
-static unsigned long
-expand_and_crc_list(struct string_list *list, unsigned long crc)
+static unsigned long expand_and_crc_list(struct string_list *list,
+					 unsigned long crc)
 {
 	struct string_list **e, **b;
 	struct string_list *tmp, **tmp2;
@@ -386,9 +374,8 @@ expand_and_crc_list(struct string_list *list, unsigned long crc)
 						cur->string);
 				}
 
-				crc =
-				    partial_crc32(symbol_type_name[cur->tag],
-						  crc);
+				crc = partial_crc32(symbol_type_name[cur->tag],
+						    crc);
 				crc = partial_crc32_one(' ', crc);
 				crc = partial_crc32(cur->string, crc);
 				crc = partial_crc32_one(' ', crc);
@@ -437,21 +424,6 @@ void export_symbol(const char *name)
 }
 
 /*----------------------------------------------------------------------*/
-
-void error(const char *fmt, ...)
-{
-	va_list args;
-
-	if (flag_warnings) {
-		va_start(args, fmt);
-		vfprintf(stderr, fmt, args);
-		va_end(args);
-		putc('\n', stderr);
-
-		errors++;
-	}
-}
-
 void error_with_pos(const char *fmt, ...)
 {
 	va_list args;
@@ -469,7 +441,7 @@ void error_with_pos(const char *fmt, ...)
 	}
 }
 
-void genksyms_usage(void)
+static void genksyms_usage(void)
 {
 	fputs("Usage:\n" "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__

commit 78c041530ac2e65c9290137bfe3004340e0840d2
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 12 22:59:36 2006 +0100

    kbuild: Lindent genksyms.c
    
    No fix-ups applied yet. Just the raw Lindent output.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index da8ff4fa5001..b798e284e1fc 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -29,7 +29,7 @@
 #include <stdarg.h>
 #ifdef __GNU_LIBRARY__
 #include <getopt.h>
-#endif /* __GNU_LIBRARY__ */
+#endif				/* __GNU_LIBRARY__ */
 
 #include "genksyms.h"
 /*----------------------------------------------------------------------*/
@@ -51,460 +51,427 @@ static int nsyms;
 
 static struct symbol *expansion_trail;
 
-static const char * const symbol_type_name[] = {
-  "normal", "typedef", "enum", "struct", "union"
+static const char *const symbol_type_name[] = {
+	"normal", "typedef", "enum", "struct", "union"
 };
 
 /*----------------------------------------------------------------------*/
 
-static const unsigned int crctab32[] =
-{
-  0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
-  0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
-  0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
-  0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
-  0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
-  0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
-  0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
-  0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
-  0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
-  0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
-  0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
-  0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
-  0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
-  0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
-  0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
-  0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
-  0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
-  0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
-  0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
-  0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
-  0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
-  0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
-  0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
-  0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
-  0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
-  0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
-  0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
-  0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
-  0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
-  0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
-  0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
-  0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
-  0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
-  0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
-  0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
-  0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
-  0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
-  0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
-  0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
-  0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
-  0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
-  0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
-  0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
-  0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
-  0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
-  0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
-  0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
-  0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
-  0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
-  0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
-  0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
-  0x2d02ef8dU
+static const unsigned int crctab32[] = {
+	0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
+	0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
+	0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
+	0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
+	0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
+	0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
+	0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
+	0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
+	0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
+	0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
+	0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
+	0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
+	0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
+	0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
+	0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
+	0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
+	0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
+	0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
+	0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
+	0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
+	0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
+	0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
+	0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
+	0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
+	0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
+	0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
+	0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
+	0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
+	0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
+	0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
+	0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
+	0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
+	0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
+	0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
+	0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
+	0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
+	0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
+	0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
+	0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
+	0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
+	0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
+	0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
+	0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
+	0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
+	0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
+	0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
+	0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
+	0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
+	0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
+	0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
+	0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
+	0x2d02ef8dU
 };
 
 static inline unsigned long
 partial_crc32_one(unsigned char c, unsigned long crc)
 {
-  return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
+	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
 }
 
-static inline unsigned long
-partial_crc32(const char *s, unsigned long crc)
+static inline unsigned long partial_crc32(const char *s, unsigned long crc)
 {
-  while (*s)
-    crc = partial_crc32_one(*s++, crc);
-  return crc;
+	while (*s)
+		crc = partial_crc32_one(*s++, crc);
+	return crc;
 }
 
-static inline unsigned long
-crc32(const char *s)
+static inline unsigned long crc32(const char *s)
 {
-  return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
+	return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
 }
 
-
 /*----------------------------------------------------------------------*/
 
-static inline enum symbol_type
-map_to_ns(enum symbol_type t)
+static inline enum symbol_type map_to_ns(enum symbol_type t)
 {
-  if (t == SYM_TYPEDEF)
-    t = SYM_NORMAL;
-  else if (t == SYM_UNION)
-    t = SYM_STRUCT;
-  return t;
+	if (t == SYM_TYPEDEF)
+		t = SYM_NORMAL;
+	else if (t == SYM_UNION)
+		t = SYM_STRUCT;
+	return t;
 }
 
-struct symbol *
-find_symbol(const char *name, enum symbol_type ns)
+struct symbol *find_symbol(const char *name, enum symbol_type ns)
 {
-  unsigned long h = crc32(name) % HASH_BUCKETS;
-  struct symbol *sym;
+	unsigned long h = crc32(name) % HASH_BUCKETS;
+	struct symbol *sym;
 
-  for (sym = symtab[h]; sym ; sym = sym->hash_next)
-    if (map_to_ns(sym->type) == map_to_ns(ns) && strcmp(name, sym->name) == 0)
-      break;
+	for (sym = symtab[h]; sym; sym = sym->hash_next)
+		if (map_to_ns(sym->type) == map_to_ns(ns)
+		    && strcmp(name, sym->name) == 0)
+			break;
 
-  return sym;
+	return sym;
 }
 
-struct symbol *
-add_symbol(const char *name, enum symbol_type type, struct string_list *defn, int is_extern)
+struct symbol *add_symbol(const char *name, enum symbol_type type,
+			  struct string_list *defn, int is_extern)
 {
-  unsigned long h = crc32(name) % HASH_BUCKETS;
-  struct symbol *sym;
-
-  for (sym = symtab[h]; sym ; sym = sym->hash_next)
-    if (map_to_ns(sym->type) == map_to_ns(type)
-	&& strcmp(name, sym->name) == 0)
-      {
-	if (!equal_list(sym->defn, defn))
-	  error_with_pos("redefinition of %s", name);
+	unsigned long h = crc32(name) % HASH_BUCKETS;
+	struct symbol *sym;
+
+	for (sym = symtab[h]; sym; sym = sym->hash_next)
+		if (map_to_ns(sym->type) == map_to_ns(type)
+		    && strcmp(name, sym->name) == 0) {
+			if (!equal_list(sym->defn, defn))
+				error_with_pos("redefinition of %s", name);
+			return sym;
+		}
+
+	sym = xmalloc(sizeof(*sym));
+	sym->name = name;
+	sym->type = type;
+	sym->defn = defn;
+	sym->expansion_trail = NULL;
+	sym->is_extern = is_extern;
+
+	sym->hash_next = symtab[h];
+	symtab[h] = sym;
+
+	if (flag_debug) {
+		fprintf(debugfile, "Defn for %s %s == <",
+			symbol_type_name[type], name);
+		if (is_extern)
+			fputs("extern ", debugfile);
+		print_list(debugfile, defn);
+		fputs(">\n", debugfile);
+	}
+
+	++nsyms;
 	return sym;
-      }
-
-  sym = xmalloc(sizeof(*sym));
-  sym->name = name;
-  sym->type = type;
-  sym->defn = defn;
-  sym->expansion_trail = NULL;
-  sym->is_extern = is_extern;
-
-  sym->hash_next = symtab[h];
-  symtab[h] = sym;
-
-  if (flag_debug)
-    {
-      fprintf(debugfile, "Defn for %s %s == <", symbol_type_name[type],  name);
-      if (is_extern)
-        fputs("extern ", debugfile);
-      print_list(debugfile, defn);
-      fputs(">\n", debugfile);
-    }
-
-  ++nsyms;
-  return sym;
 }
 
-
 /*----------------------------------------------------------------------*/
 
-inline void
-free_node(struct string_list *node)
+inline void free_node(struct string_list *node)
 {
-  free(node->string);
-  free(node);
+	free(node->string);
+	free(node);
 }
 
-void
-free_list(struct string_list *s, struct string_list *e)
+void free_list(struct string_list *s, struct string_list *e)
 {
-  while (s != e)
-    {
-      struct string_list *next = s->next;
-      free_node(s);
-      s = next;
-    }
+	while (s != e) {
+		struct string_list *next = s->next;
+		free_node(s);
+		s = next;
+	}
 }
 
-inline struct string_list *
-copy_node(struct string_list *node)
+inline struct string_list *copy_node(struct string_list *node)
 {
-  struct string_list *newnode;
+	struct string_list *newnode;
 
-  newnode = xmalloc(sizeof(*newnode));
-  newnode->string = xstrdup(node->string);
-  newnode->tag = node->tag;
+	newnode = xmalloc(sizeof(*newnode));
+	newnode->string = xstrdup(node->string);
+	newnode->tag = node->tag;
 
-  return newnode;
+	return newnode;
 }
 
-struct string_list *
-copy_list(struct string_list *s, struct string_list *e)
+struct string_list *copy_list(struct string_list *s, struct string_list *e)
 {
-  struct string_list *h, *p;
+	struct string_list *h, *p;
 
-  if (s == e)
-    return NULL;
+	if (s == e)
+		return NULL;
 
-  p = h = copy_node(s);
-  while ((s = s->next) != e)
-    p = p->next = copy_node(s);
-  p->next = NULL;
+	p = h = copy_node(s);
+	while ((s = s->next) != e)
+		p = p->next = copy_node(s);
+	p->next = NULL;
 
-  return h;
+	return h;
 }
 
-int
-equal_list(struct string_list *a, struct string_list *b)
+int equal_list(struct string_list *a, struct string_list *b)
 {
-  while (a && b)
-    {
-      if (a->tag != b->tag || strcmp(a->string, b->string))
-	return 0;
-      a = a->next;
-      b = b->next;
-    }
-
-  return !a && !b;
-}
+	while (a && b) {
+		if (a->tag != b->tag || strcmp(a->string, b->string))
+			return 0;
+		a = a->next;
+		b = b->next;
+	}
 
-static inline void
-print_node(FILE *f, struct string_list *list)
-{
-  switch (list->tag)
-    {
-    case SYM_STRUCT:
-      putc('s', f);
-      goto printit;
-    case SYM_UNION:
-      putc('u', f);
-      goto printit;
-    case SYM_ENUM:
-      putc('e', f);
-      goto printit;
-    case SYM_TYPEDEF:
-      putc('t', f);
-      goto printit;
-
-    printit:
-      putc('#', f);
-    case SYM_NORMAL:
-      fputs(list->string, f);
-      break;
-    }
+	return !a && !b;
 }
 
-void
-print_list(FILE *f, struct string_list *list)
+static inline void print_node(FILE * f, struct string_list *list)
 {
-  struct string_list **e, **b;
-  struct string_list *tmp, **tmp2;
-  int elem = 1;
-
-  if (list == NULL)
-    {
-      fputs("(nil)", f);
-      return;
-    }
-
-  tmp = list;
-  while((tmp = tmp->next) != NULL)
-	  elem++;
-
-  b = alloca(elem * sizeof(*e));
-  e = b + elem;
-  tmp2 = e - 1;
-
-  (*tmp2--) = list;
-  while((list = list->next) != NULL)
-	  *(tmp2--) = list;
-
-  while (b != e)
-    {
-      print_node(f, *b++);
-      putc(' ', f);
-    }
+	switch (list->tag) {
+	case SYM_STRUCT:
+		putc('s', f);
+		goto printit;
+	case SYM_UNION:
+		putc('u', f);
+		goto printit;
+	case SYM_ENUM:
+		putc('e', f);
+		goto printit;
+	case SYM_TYPEDEF:
+		putc('t', f);
+		goto printit;
+
+	      printit:
+		putc('#', f);
+	case SYM_NORMAL:
+		fputs(list->string, f);
+		break;
+	}
 }
 
-static unsigned long
-expand_and_crc_list(struct string_list *list, unsigned long crc)
+void print_list(FILE * f, struct string_list *list)
 {
-  struct string_list **e, **b;
-  struct string_list *tmp, **tmp2;
-  int elem = 1;
-
-  if (!list)
-    return crc;
+	struct string_list **e, **b;
+	struct string_list *tmp, **tmp2;
+	int elem = 1;
 
-  tmp = list;
-  while((tmp = tmp->next) != NULL)
-	  elem++;
-
-  b = alloca(elem * sizeof(*e));
-  e = b + elem;
-  tmp2 = e - 1;
+	if (list == NULL) {
+		fputs("(nil)", f);
+		return;
+	}
 
-  *(tmp2--) = list;
-  while ((list = list->next) != NULL)
-    *(tmp2--) = list;
+	tmp = list;
+	while ((tmp = tmp->next) != NULL)
+		elem++;
 
-  while (b != e)
-    {
-      struct string_list *cur;
-      struct symbol *subsym;
+	b = alloca(elem * sizeof(*e));
+	e = b + elem;
+	tmp2 = e - 1;
 
-      cur = *(b++);
-      switch (cur->tag)
-	{
-	case SYM_NORMAL:
-	  if (flag_dump_defs)
-	    fprintf(debugfile, "%s ", cur->string);
-	  crc = partial_crc32(cur->string, crc);
-	  crc = partial_crc32_one(' ', crc);
-	  break;
+	(*tmp2--) = list;
+	while ((list = list->next) != NULL)
+		*(tmp2--) = list;
 
-	case SYM_TYPEDEF:
-	  subsym = find_symbol(cur->string, cur->tag);
-	  if (subsym->expansion_trail)
-	    {
-	      if (flag_dump_defs)
-		fprintf(debugfile, "%s ", cur->string);
-	      crc = partial_crc32(cur->string, crc);
-	      crc = partial_crc32_one(' ', crc);
-	    }
-	  else
-	    {
-	      subsym->expansion_trail = expansion_trail;
-	      expansion_trail = subsym;
-	      crc = expand_and_crc_list(subsym->defn, crc);
-	    }
-	  break;
+	while (b != e) {
+		print_node(f, *b++);
+		putc(' ', f);
+	}
+}
 
-	case SYM_STRUCT:
-	case SYM_UNION:
-	case SYM_ENUM:
-	  subsym = find_symbol(cur->string, cur->tag);
-	  if (!subsym)
-	    {
-	      struct string_list *n, *t = NULL;
-
-	      error_with_pos("expand undefined %s %s",
-			     symbol_type_name[cur->tag], cur->string);
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup(symbol_type_name[cur->tag]);
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-	      t = n;
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup(cur->string);
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-	      t = n;
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup("{ UNKNOWN }");
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-
-	      subsym = add_symbol(cur->string, cur->tag, n, 0);
-	    }
-	  if (subsym->expansion_trail)
-	    {
-	      if (flag_dump_defs)
-		{
-		  fprintf(debugfile, "%s %s ", symbol_type_name[cur->tag],
-			  cur->string);
+static unsigned long
+expand_and_crc_list(struct string_list *list, unsigned long crc)
+{
+	struct string_list **e, **b;
+	struct string_list *tmp, **tmp2;
+	int elem = 1;
+
+	if (!list)
+		return crc;
+
+	tmp = list;
+	while ((tmp = tmp->next) != NULL)
+		elem++;
+
+	b = alloca(elem * sizeof(*e));
+	e = b + elem;
+	tmp2 = e - 1;
+
+	*(tmp2--) = list;
+	while ((list = list->next) != NULL)
+		*(tmp2--) = list;
+
+	while (b != e) {
+		struct string_list *cur;
+		struct symbol *subsym;
+
+		cur = *(b++);
+		switch (cur->tag) {
+		case SYM_NORMAL:
+			if (flag_dump_defs)
+				fprintf(debugfile, "%s ", cur->string);
+			crc = partial_crc32(cur->string, crc);
+			crc = partial_crc32_one(' ', crc);
+			break;
+
+		case SYM_TYPEDEF:
+			subsym = find_symbol(cur->string, cur->tag);
+			if (subsym->expansion_trail) {
+				if (flag_dump_defs)
+					fprintf(debugfile, "%s ", cur->string);
+				crc = partial_crc32(cur->string, crc);
+				crc = partial_crc32_one(' ', crc);
+			} else {
+				subsym->expansion_trail = expansion_trail;
+				expansion_trail = subsym;
+				crc = expand_and_crc_list(subsym->defn, crc);
+			}
+			break;
+
+		case SYM_STRUCT:
+		case SYM_UNION:
+		case SYM_ENUM:
+			subsym = find_symbol(cur->string, cur->tag);
+			if (!subsym) {
+				struct string_list *n, *t = NULL;
+
+				error_with_pos("expand undefined %s %s",
+					       symbol_type_name[cur->tag],
+					       cur->string);
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup(symbol_type_name[cur->tag]);
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup(cur->string);
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("{ UNKNOWN }");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+
+				subsym =
+				    add_symbol(cur->string, cur->tag, n, 0);
+			}
+			if (subsym->expansion_trail) {
+				if (flag_dump_defs) {
+					fprintf(debugfile, "%s %s ",
+						symbol_type_name[cur->tag],
+						cur->string);
+				}
+
+				crc =
+				    partial_crc32(symbol_type_name[cur->tag],
+						  crc);
+				crc = partial_crc32_one(' ', crc);
+				crc = partial_crc32(cur->string, crc);
+				crc = partial_crc32_one(' ', crc);
+			} else {
+				subsym->expansion_trail = expansion_trail;
+				expansion_trail = subsym;
+				crc = expand_and_crc_list(subsym->defn, crc);
+			}
+			break;
 		}
-
-	      crc = partial_crc32(symbol_type_name[cur->tag], crc);
-	      crc = partial_crc32_one(' ', crc);
-	      crc = partial_crc32(cur->string, crc);
-	      crc = partial_crc32_one(' ', crc);
-	    }
-	  else
-	    {
-	      subsym->expansion_trail = expansion_trail;
-	      expansion_trail = subsym;
-	      crc = expand_and_crc_list(subsym->defn, crc);
-	    }
-	  break;
 	}
-    }
 
-  return crc;
+	return crc;
 }
 
-void
-export_symbol(const char *name)
+void export_symbol(const char *name)
 {
-  struct symbol *sym;
+	struct symbol *sym;
 
-  sym = find_symbol(name, SYM_NORMAL);
-  if (!sym)
-    error_with_pos("export undefined symbol %s", name);
-  else
-    {
-      unsigned long crc;
+	sym = find_symbol(name, SYM_NORMAL);
+	if (!sym)
+		error_with_pos("export undefined symbol %s", name);
+	else {
+		unsigned long crc;
 
-      if (flag_dump_defs)
-	fprintf(debugfile, "Export %s == <", name);
+		if (flag_dump_defs)
+			fprintf(debugfile, "Export %s == <", name);
 
-      expansion_trail = (struct symbol *)-1L;
+		expansion_trail = (struct symbol *)-1L;
 
-      crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+		crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
 
-      sym = expansion_trail;
-      while (sym != (struct symbol *)-1L)
-	{
-	  struct symbol *n = sym->expansion_trail;
-	  sym->expansion_trail = 0;
-	  sym = n;
-	}
+		sym = expansion_trail;
+		while (sym != (struct symbol *)-1L) {
+			struct symbol *n = sym->expansion_trail;
+			sym->expansion_trail = 0;
+			sym = n;
+		}
 
-      if (flag_dump_defs)
-	fputs(">\n", debugfile);
+		if (flag_dump_defs)
+			fputs(">\n", debugfile);
 
-      /* Used as a linker script. */
-      printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
-    }
+		/* Used as a linker script. */
+		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
+	}
 }
 
 /*----------------------------------------------------------------------*/
 
-void
-error(const char *fmt, ...)
+void error(const char *fmt, ...)
 {
-  va_list args;
+	va_list args;
 
-  if (flag_warnings)
-    {
-      va_start(args, fmt);
-      vfprintf(stderr, fmt, args);
-      va_end(args);
-      putc('\n', stderr);
+	if (flag_warnings) {
+		va_start(args, fmt);
+		vfprintf(stderr, fmt, args);
+		va_end(args);
+		putc('\n', stderr);
 
-      errors++;
-    }
+		errors++;
+	}
 }
 
-void
-error_with_pos(const char *fmt, ...)
+void error_with_pos(const char *fmt, ...)
 {
-  va_list args;
+	va_list args;
 
-  if (flag_warnings)
-    {
-      fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+	if (flag_warnings) {
+		fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>",
+			cur_line);
 
-      va_start(args, fmt);
-      vfprintf(stderr, fmt, args);
-      va_end(args);
-      putc('\n', stderr);
+		va_start(args, fmt);
+		vfprintf(stderr, fmt, args);
+		va_end(args);
+		putc('\n', stderr);
 
-      errors++;
-    }
+		errors++;
+	}
 }
 
-
 void genksyms_usage(void)
 {
-	fputs("Usage:\n"
-	      "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n"
-	      "\n"
+	fputs("Usage:\n" "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n" "\n"
 #ifdef __GNU_LIBRARY__
 	      "  -d, --debug           Increment the debug level (repeatable)\n"
 	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
@@ -512,87 +479,84 @@ void genksyms_usage(void)
 	      "  -q, --quiet           Disable warnings (default)\n"
 	      "  -h, --help            Print this message\n"
 	      "  -V, --version         Print the release version\n"
-#else  /* __GNU_LIBRARY__ */
-             "  -d                    Increment the debug level (repeatable)\n"
-             "  -D                    Dump expanded symbol defs (for debugging only)\n"
-             "  -w                    Enable warnings\n"
-             "  -q                    Disable warnings (default)\n"
-             "  -h                    Print this message\n"
-             "  -V                    Print the release version\n"
-#endif /* __GNU_LIBRARY__ */
+#else				/* __GNU_LIBRARY__ */
+	      "  -d                    Increment the debug level (repeatable)\n"
+	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
+	      "  -w                    Enable warnings\n"
+	      "  -q                    Disable warnings (default)\n"
+	      "  -h                    Print this message\n"
+	      "  -V                    Print the release version\n"
+#endif				/* __GNU_LIBRARY__ */
 	      , stderr);
 }
 
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
 {
-  int o;
+	int o;
 
 #ifdef __GNU_LIBRARY__
-  struct option long_opts[] = {
-    {"arch", 1, 0, 'a'},
-    {"debug", 0, 0, 'd'},
-    {"warnings", 0, 0, 'w'},
-    {"quiet", 0, 0, 'q'},
-    {"dump", 0, 0, 'D'},
-    {"version", 0, 0, 'V'},
-    {"help", 0, 0, 'h'},
-    {0, 0, 0, 0}
-  };
-
-  while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
-			  &long_opts[0], NULL)) != EOF)
-#else  /* __GNU_LIBRARY__ */
-  while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
-#endif /* __GNU_LIBRARY__ */
-    switch (o)
-      {
-      case 'a':
-	arch = optarg;
-	break;
-      case 'd':
-	flag_debug++;
-	break;
-      case 'w':
-	flag_warnings = 1;
-	break;
-      case 'q':
-	flag_warnings = 0;
-	break;
-      case 'V':
-	fputs("genksyms version 2.5.60\n", stderr);
-	break;
-      case 'D':
-	flag_dump_defs = 1;
-	break;
-      case 'h':
-	genksyms_usage();
-	return 0;
-      default:
-	genksyms_usage();
-	return 1;
-      }
-    if ((strcmp(arch, "v850") == 0) ||
-        (strcmp(arch, "h8300") == 0))
-      mod_prefix = "_";
-    {
-      extern int yydebug;
-      extern int yy_flex_debug;
-
-      yydebug = (flag_debug > 1);
-      yy_flex_debug = (flag_debug > 2);
-
-      debugfile = stderr;
-      /* setlinebuf(debugfile); */
-    }
-
-  yyparse();
-
-  if (flag_debug)
-    {
-      fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
-	      nsyms, HASH_BUCKETS, (double)nsyms / (double)HASH_BUCKETS);
-    }
-
-  return errors != 0;
+	struct option long_opts[] = {
+		{"arch", 1, 0, 'a'},
+		{"debug", 0, 0, 'd'},
+		{"warnings", 0, 0, 'w'},
+		{"quiet", 0, 0, 'q'},
+		{"dump", 0, 0, 'D'},
+		{"version", 0, 0, 'V'},
+		{"help", 0, 0, 'h'},
+		{0, 0, 0, 0}
+	};
+
+	while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
+				&long_opts[0], NULL)) != EOF)
+#else				/* __GNU_LIBRARY__ */
+	while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
+#endif				/* __GNU_LIBRARY__ */
+		switch (o) {
+		case 'a':
+			arch = optarg;
+			break;
+		case 'd':
+			flag_debug++;
+			break;
+		case 'w':
+			flag_warnings = 1;
+			break;
+		case 'q':
+			flag_warnings = 0;
+			break;
+		case 'V':
+			fputs("genksyms version 2.5.60\n", stderr);
+			break;
+		case 'D':
+			flag_dump_defs = 1;
+			break;
+		case 'h':
+			genksyms_usage();
+			return 0;
+		default:
+			genksyms_usage();
+			return 1;
+		}
+	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0))
+		mod_prefix = "_";
+	{
+		extern int yydebug;
+		extern int yy_flex_debug;
+
+		yydebug = (flag_debug > 1);
+		yy_flex_debug = (flag_debug > 2);
+
+		debugfile = stderr;
+		/* setlinebuf(debugfile); */
+	}
+
+	yyparse();
+
+	if (flag_debug) {
+		fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
+			nsyms, HASH_BUCKETS,
+			(double)nsyms / (double)HASH_BUCKETS);
+	}
+
+	return errors != 0;
 }

commit c79c7b0923ff353d12194e83628bcca5a8606564
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 12 22:54:34 2006 +0100

    kbuild: fix genksyms build error
    
    genksyms needs to know when a symbol must have a "_" prefex as is
    true for a few architectures.
    Pass $(ARCH) as commandline argument and hardcode what architectures that
    needs this info.
    Previous attemt to take it from elfconfig.h was br0ken since elfconfig.h
    is a generated file.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index ef8822e59cda..da8ff4fa5001 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -32,7 +32,6 @@
 #endif /* __GNU_LIBRARY__ */
 
 #include "genksyms.h"
-#include "../mod/elfconfig.h"
 /*----------------------------------------------------------------------*/
 
 #define HASH_BUCKETS  4096
@@ -44,6 +43,8 @@ int cur_line = 1;
 char *cur_filename, *output_directory;
 
 int flag_debug, flag_dump_defs, flag_warnings;
+const char *arch = "";
+const char *mod_prefix = "";
 
 static int errors;
 static int nsyms;
@@ -458,7 +459,7 @@ export_symbol(const char *name)
 	fputs(">\n", debugfile);
 
       /* Used as a linker script. */
-      printf("%s__crc_%s = 0x%08lx ;\n", MODULE_SYMBOL_PREFIX, name, crc);
+      printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
     }
 }
 
@@ -529,6 +530,7 @@ main(int argc, char **argv)
 
 #ifdef __GNU_LIBRARY__
   struct option long_opts[] = {
+    {"arch", 1, 0, 'a'},
     {"debug", 0, 0, 'd'},
     {"warnings", 0, 0, 'w'},
     {"quiet", 0, 0, 'q'},
@@ -538,13 +540,16 @@ main(int argc, char **argv)
     {0, 0, 0, 0}
   };
 
-  while ((o = getopt_long(argc, argv, "dwqVDk:p:",
+  while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
 			  &long_opts[0], NULL)) != EOF)
 #else  /* __GNU_LIBRARY__ */
-  while ((o = getopt(argc, argv, "dwqVDk:p:")) != EOF)
+  while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
 #endif /* __GNU_LIBRARY__ */
     switch (o)
       {
+      case 'a':
+	arch = optarg;
+	break;
       case 'd':
 	flag_debug++;
 	break;
@@ -567,7 +572,9 @@ main(int argc, char **argv)
 	genksyms_usage();
 	return 1;
       }
-
+    if ((strcmp(arch, "v850") == 0) ||
+        (strcmp(arch, "h8300") == 0))
+      mod_prefix = "_";
     {
       extern int yydebug;
       extern int yy_flex_debug;

commit f7b05e64bdb2fcc4b2dc94a4bd9426adc70c9599
Author: Luke Yang <luke.adi@gmail.com>
Date:   Thu Mar 2 18:35:31 2006 +0800

    kbuild: Fix bug in crc symbol generating of kernel and modules
    
    The scripts/genksyms/genksyms.c uses hardcoded "__crc_" prefix for
    crc symbols in kernel and modules. The prefix should be replaced by
    "MODULE_SYMBOL_PREFIX##__crc_" otherwise there will be warnings when
    MODULE_SYMBOL_PREFIX is not NULL.
    
    I am sorry my last patch for this issue is actually wrong. I revert
    it in this patch.
    
    Signed-off-by: Luke Yang <luke.adi@gmail.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 416a694b0998..ef8822e59cda 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -32,7 +32,7 @@
 #endif /* __GNU_LIBRARY__ */
 
 #include "genksyms.h"
-
+#include "../mod/elfconfig.h"
 /*----------------------------------------------------------------------*/
 
 #define HASH_BUCKETS  4096
@@ -458,7 +458,7 @@ export_symbol(const char *name)
 	fputs(">\n", debugfile);
 
       /* Used as a linker script. */
-      printf("__crc_%s = 0x%08lx ;\n", name, crc);
+      printf("%s__crc_%s = 0x%08lx ;\n", MODULE_SYMBOL_PREFIX, name, crc);
     }
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
new file mode 100644
index 000000000000..416a694b0998
--- /dev/null
+++ b/scripts/genksyms/genksyms.c
@@ -0,0 +1,591 @@
+/* Generate kernel symbol version hashes.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   This file was part of the Linux modutils 2.4.22: moved back into the
+   kernel sources by Rusty Russell/Kai Germaschewski.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdarg.h>
+#ifdef __GNU_LIBRARY__
+#include <getopt.h>
+#endif /* __GNU_LIBRARY__ */
+
+#include "genksyms.h"
+
+/*----------------------------------------------------------------------*/
+
+#define HASH_BUCKETS  4096
+
+static struct symbol *symtab[HASH_BUCKETS];
+FILE *debugfile;
+
+int cur_line = 1;
+char *cur_filename, *output_directory;
+
+int flag_debug, flag_dump_defs, flag_warnings;
+
+static int errors;
+static int nsyms;
+
+static struct symbol *expansion_trail;
+
+static const char * const symbol_type_name[] = {
+  "normal", "typedef", "enum", "struct", "union"
+};
+
+/*----------------------------------------------------------------------*/
+
+static const unsigned int crctab32[] =
+{
+  0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
+  0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
+  0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
+  0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
+  0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
+  0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
+  0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
+  0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
+  0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
+  0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
+  0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
+  0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
+  0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
+  0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
+  0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
+  0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
+  0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
+  0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
+  0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
+  0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
+  0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
+  0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
+  0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
+  0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
+  0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
+  0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
+  0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
+  0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
+  0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
+  0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
+  0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
+  0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
+  0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
+  0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
+  0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
+  0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
+  0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
+  0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
+  0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
+  0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
+  0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
+  0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
+  0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
+  0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
+  0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
+  0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
+  0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
+  0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
+  0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
+  0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
+  0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
+  0x2d02ef8dU
+};
+
+static inline unsigned long
+partial_crc32_one(unsigned char c, unsigned long crc)
+{
+  return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
+}
+
+static inline unsigned long
+partial_crc32(const char *s, unsigned long crc)
+{
+  while (*s)
+    crc = partial_crc32_one(*s++, crc);
+  return crc;
+}
+
+static inline unsigned long
+crc32(const char *s)
+{
+  return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+static inline enum symbol_type
+map_to_ns(enum symbol_type t)
+{
+  if (t == SYM_TYPEDEF)
+    t = SYM_NORMAL;
+  else if (t == SYM_UNION)
+    t = SYM_STRUCT;
+  return t;
+}
+
+struct symbol *
+find_symbol(const char *name, enum symbol_type ns)
+{
+  unsigned long h = crc32(name) % HASH_BUCKETS;
+  struct symbol *sym;
+
+  for (sym = symtab[h]; sym ; sym = sym->hash_next)
+    if (map_to_ns(sym->type) == map_to_ns(ns) && strcmp(name, sym->name) == 0)
+      break;
+
+  return sym;
+}
+
+struct symbol *
+add_symbol(const char *name, enum symbol_type type, struct string_list *defn, int is_extern)
+{
+  unsigned long h = crc32(name) % HASH_BUCKETS;
+  struct symbol *sym;
+
+  for (sym = symtab[h]; sym ; sym = sym->hash_next)
+    if (map_to_ns(sym->type) == map_to_ns(type)
+	&& strcmp(name, sym->name) == 0)
+      {
+	if (!equal_list(sym->defn, defn))
+	  error_with_pos("redefinition of %s", name);
+	return sym;
+      }
+
+  sym = xmalloc(sizeof(*sym));
+  sym->name = name;
+  sym->type = type;
+  sym->defn = defn;
+  sym->expansion_trail = NULL;
+  sym->is_extern = is_extern;
+
+  sym->hash_next = symtab[h];
+  symtab[h] = sym;
+
+  if (flag_debug)
+    {
+      fprintf(debugfile, "Defn for %s %s == <", symbol_type_name[type],  name);
+      if (is_extern)
+        fputs("extern ", debugfile);
+      print_list(debugfile, defn);
+      fputs(">\n", debugfile);
+    }
+
+  ++nsyms;
+  return sym;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+inline void
+free_node(struct string_list *node)
+{
+  free(node->string);
+  free(node);
+}
+
+void
+free_list(struct string_list *s, struct string_list *e)
+{
+  while (s != e)
+    {
+      struct string_list *next = s->next;
+      free_node(s);
+      s = next;
+    }
+}
+
+inline struct string_list *
+copy_node(struct string_list *node)
+{
+  struct string_list *newnode;
+
+  newnode = xmalloc(sizeof(*newnode));
+  newnode->string = xstrdup(node->string);
+  newnode->tag = node->tag;
+
+  return newnode;
+}
+
+struct string_list *
+copy_list(struct string_list *s, struct string_list *e)
+{
+  struct string_list *h, *p;
+
+  if (s == e)
+    return NULL;
+
+  p = h = copy_node(s);
+  while ((s = s->next) != e)
+    p = p->next = copy_node(s);
+  p->next = NULL;
+
+  return h;
+}
+
+int
+equal_list(struct string_list *a, struct string_list *b)
+{
+  while (a && b)
+    {
+      if (a->tag != b->tag || strcmp(a->string, b->string))
+	return 0;
+      a = a->next;
+      b = b->next;
+    }
+
+  return !a && !b;
+}
+
+static inline void
+print_node(FILE *f, struct string_list *list)
+{
+  switch (list->tag)
+    {
+    case SYM_STRUCT:
+      putc('s', f);
+      goto printit;
+    case SYM_UNION:
+      putc('u', f);
+      goto printit;
+    case SYM_ENUM:
+      putc('e', f);
+      goto printit;
+    case SYM_TYPEDEF:
+      putc('t', f);
+      goto printit;
+
+    printit:
+      putc('#', f);
+    case SYM_NORMAL:
+      fputs(list->string, f);
+      break;
+    }
+}
+
+void
+print_list(FILE *f, struct string_list *list)
+{
+  struct string_list **e, **b;
+  struct string_list *tmp, **tmp2;
+  int elem = 1;
+
+  if (list == NULL)
+    {
+      fputs("(nil)", f);
+      return;
+    }
+
+  tmp = list;
+  while((tmp = tmp->next) != NULL)
+	  elem++;
+
+  b = alloca(elem * sizeof(*e));
+  e = b + elem;
+  tmp2 = e - 1;
+
+  (*tmp2--) = list;
+  while((list = list->next) != NULL)
+	  *(tmp2--) = list;
+
+  while (b != e)
+    {
+      print_node(f, *b++);
+      putc(' ', f);
+    }
+}
+
+static unsigned long
+expand_and_crc_list(struct string_list *list, unsigned long crc)
+{
+  struct string_list **e, **b;
+  struct string_list *tmp, **tmp2;
+  int elem = 1;
+
+  if (!list)
+    return crc;
+
+  tmp = list;
+  while((tmp = tmp->next) != NULL)
+	  elem++;
+
+  b = alloca(elem * sizeof(*e));
+  e = b + elem;
+  tmp2 = e - 1;
+
+  *(tmp2--) = list;
+  while ((list = list->next) != NULL)
+    *(tmp2--) = list;
+
+  while (b != e)
+    {
+      struct string_list *cur;
+      struct symbol *subsym;
+
+      cur = *(b++);
+      switch (cur->tag)
+	{
+	case SYM_NORMAL:
+	  if (flag_dump_defs)
+	    fprintf(debugfile, "%s ", cur->string);
+	  crc = partial_crc32(cur->string, crc);
+	  crc = partial_crc32_one(' ', crc);
+	  break;
+
+	case SYM_TYPEDEF:
+	  subsym = find_symbol(cur->string, cur->tag);
+	  if (subsym->expansion_trail)
+	    {
+	      if (flag_dump_defs)
+		fprintf(debugfile, "%s ", cur->string);
+	      crc = partial_crc32(cur->string, crc);
+	      crc = partial_crc32_one(' ', crc);
+	    }
+	  else
+	    {
+	      subsym->expansion_trail = expansion_trail;
+	      expansion_trail = subsym;
+	      crc = expand_and_crc_list(subsym->defn, crc);
+	    }
+	  break;
+
+	case SYM_STRUCT:
+	case SYM_UNION:
+	case SYM_ENUM:
+	  subsym = find_symbol(cur->string, cur->tag);
+	  if (!subsym)
+	    {
+	      struct string_list *n, *t = NULL;
+
+	      error_with_pos("expand undefined %s %s",
+			     symbol_type_name[cur->tag], cur->string);
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup(symbol_type_name[cur->tag]);
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+	      t = n;
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup(cur->string);
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+	      t = n;
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup("{ UNKNOWN }");
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+
+	      subsym = add_symbol(cur->string, cur->tag, n, 0);
+	    }
+	  if (subsym->expansion_trail)
+	    {
+	      if (flag_dump_defs)
+		{
+		  fprintf(debugfile, "%s %s ", symbol_type_name[cur->tag],
+			  cur->string);
+		}
+
+	      crc = partial_crc32(symbol_type_name[cur->tag], crc);
+	      crc = partial_crc32_one(' ', crc);
+	      crc = partial_crc32(cur->string, crc);
+	      crc = partial_crc32_one(' ', crc);
+	    }
+	  else
+	    {
+	      subsym->expansion_trail = expansion_trail;
+	      expansion_trail = subsym;
+	      crc = expand_and_crc_list(subsym->defn, crc);
+	    }
+	  break;
+	}
+    }
+
+  return crc;
+}
+
+void
+export_symbol(const char *name)
+{
+  struct symbol *sym;
+
+  sym = find_symbol(name, SYM_NORMAL);
+  if (!sym)
+    error_with_pos("export undefined symbol %s", name);
+  else
+    {
+      unsigned long crc;
+
+      if (flag_dump_defs)
+	fprintf(debugfile, "Export %s == <", name);
+
+      expansion_trail = (struct symbol *)-1L;
+
+      crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+
+      sym = expansion_trail;
+      while (sym != (struct symbol *)-1L)
+	{
+	  struct symbol *n = sym->expansion_trail;
+	  sym->expansion_trail = 0;
+	  sym = n;
+	}
+
+      if (flag_dump_defs)
+	fputs(">\n", debugfile);
+
+      /* Used as a linker script. */
+      printf("__crc_%s = 0x%08lx ;\n", name, crc);
+    }
+}
+
+/*----------------------------------------------------------------------*/
+
+void
+error(const char *fmt, ...)
+{
+  va_list args;
+
+  if (flag_warnings)
+    {
+      va_start(args, fmt);
+      vfprintf(stderr, fmt, args);
+      va_end(args);
+      putc('\n', stderr);
+
+      errors++;
+    }
+}
+
+void
+error_with_pos(const char *fmt, ...)
+{
+  va_list args;
+
+  if (flag_warnings)
+    {
+      fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+
+      va_start(args, fmt);
+      vfprintf(stderr, fmt, args);
+      va_end(args);
+      putc('\n', stderr);
+
+      errors++;
+    }
+}
+
+
+void genksyms_usage(void)
+{
+	fputs("Usage:\n"
+	      "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n"
+	      "\n"
+#ifdef __GNU_LIBRARY__
+	      "  -d, --debug           Increment the debug level (repeatable)\n"
+	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
+	      "  -w, --warnings        Enable warnings\n"
+	      "  -q, --quiet           Disable warnings (default)\n"
+	      "  -h, --help            Print this message\n"
+	      "  -V, --version         Print the release version\n"
+#else  /* __GNU_LIBRARY__ */
+             "  -d                    Increment the debug level (repeatable)\n"
+             "  -D                    Dump expanded symbol defs (for debugging only)\n"
+             "  -w                    Enable warnings\n"
+             "  -q                    Disable warnings (default)\n"
+             "  -h                    Print this message\n"
+             "  -V                    Print the release version\n"
+#endif /* __GNU_LIBRARY__ */
+	      , stderr);
+}
+
+int
+main(int argc, char **argv)
+{
+  int o;
+
+#ifdef __GNU_LIBRARY__
+  struct option long_opts[] = {
+    {"debug", 0, 0, 'd'},
+    {"warnings", 0, 0, 'w'},
+    {"quiet", 0, 0, 'q'},
+    {"dump", 0, 0, 'D'},
+    {"version", 0, 0, 'V'},
+    {"help", 0, 0, 'h'},
+    {0, 0, 0, 0}
+  };
+
+  while ((o = getopt_long(argc, argv, "dwqVDk:p:",
+			  &long_opts[0], NULL)) != EOF)
+#else  /* __GNU_LIBRARY__ */
+  while ((o = getopt(argc, argv, "dwqVDk:p:")) != EOF)
+#endif /* __GNU_LIBRARY__ */
+    switch (o)
+      {
+      case 'd':
+	flag_debug++;
+	break;
+      case 'w':
+	flag_warnings = 1;
+	break;
+      case 'q':
+	flag_warnings = 0;
+	break;
+      case 'V':
+	fputs("genksyms version 2.5.60\n", stderr);
+	break;
+      case 'D':
+	flag_dump_defs = 1;
+	break;
+      case 'h':
+	genksyms_usage();
+	return 0;
+      default:
+	genksyms_usage();
+	return 1;
+      }
+
+    {
+      extern int yydebug;
+      extern int yy_flex_debug;
+
+      yydebug = (flag_debug > 1);
+      yy_flex_debug = (flag_debug > 2);
+
+      debugfile = stderr;
+      /* setlinebuf(debugfile); */
+    }
+
+  yyparse();
+
+  if (flag_debug)
+    {
+      fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
+	      nsyms, HASH_BUCKETS, (double)nsyms / (double)HASH_BUCKETS);
+    }
+
+  return errors != 0;
+}
