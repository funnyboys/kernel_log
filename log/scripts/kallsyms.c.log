commit 9d82973e032e246ff5663c9805fbb5407ae932e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 4 09:16:37 2020 -0700

    gcc-10 warnings: fix low-hanging fruit
    
    Due to a bug-report that was compiler-dependent, I updated one of my
    machines to gcc-10.  That shows a lot of new warnings.  Happily they
    seem to be mostly the valid kind, but it's going to cause a round of
    churn for getting rid of them..
    
    This is the really low-hanging fruit of removing a couple of zero-sized
    arrays in some core code.  We have had a round of these patches before,
    and we'll have many more coming, and there is nothing special about
    these except that they were particularly trivial, and triggered more
    warnings than most.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 3e8dea6e0a95..6dc3078649fa 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -34,7 +34,7 @@ struct sym_entry {
 	unsigned int len;
 	unsigned int start_pos;
 	unsigned int percpu_absolute;
-	unsigned char sym[0];
+	unsigned char sym[];
 };
 
 struct addr_range {

commit 7883a14339299773b2ce08dcfd97c63c199a9289
Author: Mikhail Petrov <Mikhail.Petrov@mir.dev>
Date:   Wed Mar 11 23:37:09 2020 +0300

    scripts/kallsyms: fix wrong kallsyms_relative_base
    
    There is the code in the read_symbol function in 'scripts/kallsyms.c':
    
            if (is_ignored_symbol(name, type))
                    return NULL;
    
            /* Ignore most absolute/undefined (?) symbols. */
            if (strcmp(name, "_text") == 0)
                    _text = addr;
    
    But the is_ignored_symbol function returns true for name="_text" and
    type='A'. So the next condition is not executed and the _text variable
    is always zero.
    
    It makes the wrong kallsyms_relative_base symbol as a result of the code
    (CONFIG_KALLSYMS_BASE_RELATIVE is defined):
    
            if (base_relative) {
                    output_label("kallsyms_relative_base");
                    output_address(relative_base);
                    printf("\n");
            }
    
    Because the output_address function uses the _text variable.
    
    So the kallsyms_lookup function and all related functions in the kernel
    do not work properly. For example, the stack trace in oops:
    
     Call Trace:
     [aa095e58] [809feab8] kobj_ns_ops_tbl+0x7ff09ac8/0x7ff1c1c4 (unreliable)
     [aa095e98] [80002b64] kobj_ns_ops_tbl+0x7f50db74/0x80000010
     [aa095ef8] [809c3d24] kobj_ns_ops_tbl+0x7feced34/0x7ff1c1c4
     [aa095f28] [80002ed0] kobj_ns_ops_tbl+0x7f50dee0/0x80000010
     [aa095f38] [8000f238] kobj_ns_ops_tbl+0x7f51a248/0x80000010
    
    The right stack trace:
    
     Call Trace:
     [aa095e58] [809feab8] module_vdu_video_init+0x2fc/0x3bc (unreliable)
     [aa095e98] [80002b64] do_one_initcall+0x40/0x1f0
     [aa095ef8] [809c3d24] kernel_init_freeable+0x164/0x1d8
     [aa095f28] [80002ed0] kernel_init+0x14/0x124
     [aa095f38] [8000f238] ret_from_kernel_thread+0x14/0x1c
    
    [masahiroy@kernel.org:
    
    This issue happens on binutils <= 2.22
    The following commit fixed it:
    https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=d2667025dd30611514810c28bee9709e4623012a
    
    The symbol type of _text is 'T' on binutils >= 2.23
    The minimal supported binutils version for the kernel build is 2.21
    ]
    
    Signed-off-by: Mikhail Petrov <Mikhail.Petrov@mir.dev>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 0133dfaaf352..3e8dea6e0a95 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -195,13 +195,13 @@ static struct sym_entry *read_symbol(FILE *in)
 		return NULL;
 	}
 
-	if (is_ignored_symbol(name, type))
-		return NULL;
-
-	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(name, "_text") == 0)
 		_text = addr;
 
+	/* Ignore most absolute/undefined (?) symbols. */
+	if (is_ignored_symbol(name, type))
+		return NULL;
+
 	check_symbol_range(name, addr, text_ranges, ARRAY_SIZE(text_ranges));
 	check_symbol_range(name, addr, &percpu_range, 1);
 

commit 9d1b38958b077f6c8d4bd196a115b643d7bd6717
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Feb 11 01:18:52 2020 +0900

    scripts/kallsyms: fix memory corruption caused by write over-run
    
    memcpy() writes one more byte than allocated.
    
    Fixes: 8d60526999aa ("scripts/kallsyms: change table to store (strcut sym_entry *)")
    Reported-by: youling257 <youling257@gmail.com>
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Tested-by: Pavel Machek <pavel@ucw.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index a566d8201b56..0133dfaaf352 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -210,7 +210,7 @@ static struct sym_entry *read_symbol(FILE *in)
 
 	len = strlen(name) + 1;
 
-	sym = malloc(sizeof(*sym) + len);
+	sym = malloc(sizeof(*sym) + len + 1);
 	if (!sym) {
 		fprintf(stderr, "kallsyms failure: "
 			"unable to allocate required amount of memory\n");
@@ -219,7 +219,7 @@ static struct sym_entry *read_symbol(FILE *in)
 	sym->addr = addr;
 	sym->len = len;
 	sym->sym[0] = type;
-	memcpy(sym_name(sym), name, len);
+	strcpy(sym_name(sym), name);
 	sym->percpu_absolute = 0;
 
 	return sym;

commit 8d60526999aace135de37220ec94ba40bc792234
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Feb 2 14:09:21 2020 +0900

    scripts/kallsyms: change table to store (strcut sym_entry *)
    
    The symbol table is extended every 10000 addition by using realloc(),
    where data copy might occur to the new buffer.
    
    To decrease the amount of possible data copy, let's change the table
    to store the pointer.
    
    The symbol type + symbol name part is appended at the end of
    (struct sym_entry), and allocated together with the struct body.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 5c34edd98b3e..a566d8201b56 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -33,8 +33,8 @@ struct sym_entry {
 	unsigned long long addr;
 	unsigned int len;
 	unsigned int start_pos;
-	unsigned char *sym;
 	unsigned int percpu_absolute;
+	unsigned char sym[0];
 };
 
 struct addr_range {
@@ -55,7 +55,7 @@ static struct addr_range percpu_range = {
 	"__per_cpu_start", "__per_cpu_end", -1ULL, 0
 };
 
-static struct sym_entry *table;
+static struct sym_entry **table;
 static unsigned int table_size, table_cnt;
 static int all_symbols;
 static int absolute_percpu;
@@ -174,49 +174,55 @@ static void check_symbol_range(const char *sym, unsigned long long addr,
 	}
 }
 
-static int read_symbol(FILE *in, struct sym_entry *s)
+static struct sym_entry *read_symbol(FILE *in)
 {
 	char name[500], type;
+	unsigned long long addr;
+	unsigned int len;
+	struct sym_entry *sym;
 	int rc;
 
-	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &type, name);
+	rc = fscanf(in, "%llx %c %499s\n", &addr, &type, name);
 	if (rc != 3) {
 		if (rc != EOF && fgets(name, 500, in) == NULL)
 			fprintf(stderr, "Read error or end of file.\n");
-		return -1;
+		return NULL;
 	}
 	if (strlen(name) >= KSYM_NAME_LEN) {
 		fprintf(stderr, "Symbol %s too long for kallsyms (%zu >= %d).\n"
 				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
 			name, strlen(name), KSYM_NAME_LEN);
-		return -1;
+		return NULL;
 	}
 
 	if (is_ignored_symbol(name, type))
-		return -1;
+		return NULL;
 
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(name, "_text") == 0)
-		_text = s->addr;
+		_text = addr;
 
-	check_symbol_range(name, s->addr, text_ranges, ARRAY_SIZE(text_ranges));
-	check_symbol_range(name, s->addr, &percpu_range, 1);
+	check_symbol_range(name, addr, text_ranges, ARRAY_SIZE(text_ranges));
+	check_symbol_range(name, addr, &percpu_range, 1);
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
-	s->len = strlen(name) + 1;
-	s->sym = malloc(s->len + 1);
-	if (!s->sym) {
+
+	len = strlen(name) + 1;
+
+	sym = malloc(sizeof(*sym) + len);
+	if (!sym) {
 		fprintf(stderr, "kallsyms failure: "
 			"unable to allocate required amount of memory\n");
 		exit(EXIT_FAILURE);
 	}
-	strcpy(sym_name(s), name);
-	s->sym[0] = type;
-
-	s->percpu_absolute = 0;
+	sym->addr = addr;
+	sym->len = len;
+	sym->sym[0] = type;
+	memcpy(sym_name(sym), name, len);
+	sym->percpu_absolute = 0;
 
-	return 0;
+	return sym;
 }
 
 static int symbol_in_range(const struct sym_entry *s,
@@ -268,12 +274,12 @@ static void shrink_table(void)
 
 	pos = 0;
 	for (i = 0; i < table_cnt; i++) {
-		if (symbol_valid(&table[i])) {
+		if (symbol_valid(table[i])) {
 			if (pos != i)
 				table[pos] = table[i];
 			pos++;
 		} else {
-			free(table[i].sym);
+			free(table[i]);
 		}
 	}
 	table_cnt = pos;
@@ -287,7 +293,15 @@ static void shrink_table(void)
 
 static void read_map(FILE *in)
 {
+	struct sym_entry *sym;
+
 	while (!feof(in)) {
+		sym = read_symbol(in);
+		if (!sym)
+			continue;
+
+		sym->start_pos = table_cnt;
+
 		if (table_cnt >= table_size) {
 			table_size += 10000;
 			table = realloc(table, sizeof(*table) * table_size);
@@ -296,10 +310,8 @@ static void read_map(FILE *in)
 				exit (1);
 			}
 		}
-		if (read_symbol(in, &table[table_cnt]) == 0) {
-			table[table_cnt].start_pos = table_cnt;
-			table_cnt++;
-		}
+
+		table[table_cnt++] = sym;
 	}
 }
 
@@ -387,27 +399,27 @@ static void write_src(void)
 			int overflow;
 
 			if (!absolute_percpu) {
-				offset = table[i].addr - relative_base;
+				offset = table[i]->addr - relative_base;
 				overflow = (offset < 0 || offset > UINT_MAX);
-			} else if (symbol_absolute(&table[i])) {
-				offset = table[i].addr;
+			} else if (symbol_absolute(table[i])) {
+				offset = table[i]->addr;
 				overflow = (offset < 0 || offset > INT_MAX);
 			} else {
-				offset = relative_base - table[i].addr - 1;
+				offset = relative_base - table[i]->addr - 1;
 				overflow = (offset < INT_MIN || offset >= 0);
 			}
 			if (overflow) {
 				fprintf(stderr, "kallsyms failure: "
 					"%s symbol value %#llx out of range in relative mode\n",
-					symbol_absolute(&table[i]) ? "absolute" : "relative",
-					table[i].addr);
+					symbol_absolute(table[i]) ? "absolute" : "relative",
+					table[i]->addr);
 				exit(EXIT_FAILURE);
 			}
 			printf("\t.long\t%#x\n", (int)offset);
-		} else if (!symbol_absolute(&table[i])) {
-			output_address(table[i].addr);
+		} else if (!symbol_absolute(table[i])) {
+			output_address(table[i]->addr);
 		} else {
-			printf("\tPTR\t%#llx\n", table[i].addr);
+			printf("\tPTR\t%#llx\n", table[i]->addr);
 		}
 	}
 	printf("\n");
@@ -437,12 +449,12 @@ static void write_src(void)
 		if ((i & 0xFF) == 0)
 			markers[i >> 8] = off;
 
-		printf("\t.byte 0x%02x", table[i].len);
-		for (k = 0; k < table[i].len; k++)
-			printf(", 0x%02x", table[i].sym[k]);
+		printf("\t.byte 0x%02x", table[i]->len);
+		for (k = 0; k < table[i]->len; k++)
+			printf(", 0x%02x", table[i]->sym[k]);
 		printf("\n");
 
-		off += table[i].len + 1;
+		off += table[i]->len + 1;
 	}
 	printf("\n");
 
@@ -496,7 +508,7 @@ static void build_initial_tok_table(void)
 	unsigned int i;
 
 	for (i = 0; i < table_cnt; i++)
-		learn_symbol(table[i].sym, table[i].len);
+		learn_symbol(table[i]->sym, table[i]->len);
 }
 
 static unsigned char *find_token(unsigned char *str, int len,
@@ -520,15 +532,15 @@ static void compress_symbols(const unsigned char *str, int idx)
 
 	for (i = 0; i < table_cnt; i++) {
 
-		len = table[i].len;
-		p1 = table[i].sym;
+		len = table[i]->len;
+		p1 = table[i]->sym;
 
 		/* find the token on the symbol */
 		p2 = find_token(p1, len, str);
 		if (!p2) continue;
 
 		/* decrease the counts for this symbol's tokens */
-		forget_symbol(table[i].sym, len);
+		forget_symbol(table[i]->sym, len);
 
 		size = len;
 
@@ -547,10 +559,10 @@ static void compress_symbols(const unsigned char *str, int idx)
 
 		} while (p2);
 
-		table[i].len = len;
+		table[i]->len = len;
 
 		/* increase the counts for this symbol's new tokens */
-		learn_symbol(table[i].sym, len);
+		learn_symbol(table[i]->sym, len);
 	}
 }
 
@@ -606,8 +618,8 @@ static void insert_real_symbols_in_table(void)
 	unsigned int i, j, c;
 
 	for (i = 0; i < table_cnt; i++) {
-		for (j = 0; j < table[i].len; j++) {
-			c = table[i].sym[j];
+		for (j = 0; j < table[i]->len; j++) {
+			c = table[i]->sym[j];
 			best_table[c][0]=c;
 			best_table_len[c]=1;
 		}
@@ -660,13 +672,10 @@ static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
 
 static int compare_symbols(const void *a, const void *b)
 {
-	const struct sym_entry *sa;
-	const struct sym_entry *sb;
+	const struct sym_entry *sa = *(const struct sym_entry **)a;
+	const struct sym_entry *sb = *(const struct sym_entry **)b;
 	int wa, wb;
 
-	sa = a;
-	sb = b;
-
 	/* sort by address first */
 	if (sa->addr > sb->addr)
 		return 1;
@@ -697,7 +706,7 @@ static int compare_symbols(const void *a, const void *b)
 
 static void sort_symbols(void)
 {
-	qsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);
+	qsort(table, table_cnt, sizeof(table[0]), compare_symbols);
 }
 
 static void make_percpus_absolute(void)
@@ -705,14 +714,14 @@ static void make_percpus_absolute(void)
 	unsigned int i;
 
 	for (i = 0; i < table_cnt; i++)
-		if (symbol_in_range(&table[i], &percpu_range, 1)) {
+		if (symbol_in_range(table[i], &percpu_range, 1)) {
 			/*
 			 * Keep the 'A' override for percpu symbols to
 			 * ensure consistent behavior compared to older
 			 * versions of this tool.
 			 */
-			table[i].sym[0] = 'A';
-			table[i].percpu_absolute = 1;
+			table[i]->sym[0] = 'A';
+			table[i]->percpu_absolute = 1;
 		}
 }
 
@@ -722,12 +731,12 @@ static void record_relative_base(void)
 	unsigned int i;
 
 	for (i = 0; i < table_cnt; i++)
-		if (!symbol_absolute(&table[i])) {
+		if (!symbol_absolute(table[i])) {
 			/*
 			 * The table is sorted by address.
 			 * Take the first non-absolute symbol value.
 			 */
-			relative_base = table[i].addr;
+			relative_base = table[i]->addr;
 			return;
 		}
 }

commit be9f6133f8770bb9c5f4a3cb3df6d30d7d3f7e5b
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Feb 2 14:09:20 2020 +0900

    scripts/kallsyms: rename local variables in read_symbol()
    
    I will use 'sym' for the point to struce sym_entry in the next commit.
    Rename 'sym', 'stype' to 'name', 'type', which are more intuitive.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 94153732ec00..5c34edd98b3e 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -176,43 +176,43 @@ static void check_symbol_range(const char *sym, unsigned long long addr,
 
 static int read_symbol(FILE *in, struct sym_entry *s)
 {
-	char sym[500], stype;
+	char name[500], type;
 	int rc;
 
-	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, sym);
+	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &type, name);
 	if (rc != 3) {
-		if (rc != EOF && fgets(sym, 500, in) == NULL)
+		if (rc != EOF && fgets(name, 500, in) == NULL)
 			fprintf(stderr, "Read error or end of file.\n");
 		return -1;
 	}
-	if (strlen(sym) >= KSYM_NAME_LEN) {
+	if (strlen(name) >= KSYM_NAME_LEN) {
 		fprintf(stderr, "Symbol %s too long for kallsyms (%zu >= %d).\n"
 				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
-			sym, strlen(sym), KSYM_NAME_LEN);
+			name, strlen(name), KSYM_NAME_LEN);
 		return -1;
 	}
 
-	if (is_ignored_symbol(sym, stype))
+	if (is_ignored_symbol(name, type))
 		return -1;
 
 	/* Ignore most absolute/undefined (?) symbols. */
-	if (strcmp(sym, "_text") == 0)
+	if (strcmp(name, "_text") == 0)
 		_text = s->addr;
 
-	check_symbol_range(sym, s->addr, text_ranges, ARRAY_SIZE(text_ranges));
-	check_symbol_range(sym, s->addr, &percpu_range, 1);
+	check_symbol_range(name, s->addr, text_ranges, ARRAY_SIZE(text_ranges));
+	check_symbol_range(name, s->addr, &percpu_range, 1);
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
-	s->len = strlen(sym) + 1;
+	s->len = strlen(name) + 1;
 	s->sym = malloc(s->len + 1);
 	if (!s->sym) {
 		fprintf(stderr, "kallsyms failure: "
 			"unable to allocate required amount of memory\n");
 		exit(EXIT_FAILURE);
 	}
-	strcpy(sym_name(s), sym);
-	s->sym[0] = stype;
+	strcpy(sym_name(s), name);
+	s->sym[0] = type;
 
 	s->percpu_absolute = 0;
 

commit fd2ab2f6610b2bec70e626c38de8a4242fa88e48
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Dec 9 12:51:48 2019 +0900

    scripts/kallsyms: fix offset overflow of kallsyms_relative_base
    
    Since commit 5e5c4fa78745 ("scripts/kallsyms: shrink table before
    sorting it"), kallsyms_relative_base can be larger than _text, which
    causes overflow when building the 32-bit kernel.
    
    https://lkml.org/lkml/2019/12/7/156
    
    This is because _text is, unless --all-symbols is specified, now
    trimmed from the symbol table before record_relative_base() is called.
    
    Handle the offset signedness also for kallsyms_relative_base. Introduce
    a new helper, output_address(), to reduce the code duplication.
    
    Fixes: 5e5c4fa78745 ("scripts/kallsyms: shrink table before sorting it")
    Reported-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index fb55f262f42d..94153732ec00 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -310,6 +310,15 @@ static void output_label(const char *label)
 	printf("%s:\n", label);
 }
 
+/* Provide proper symbols relocatability by their '_text' relativeness. */
+static void output_address(unsigned long long addr)
+{
+	if (_text <= addr)
+		printf("\tPTR\t_text + %#llx\n", addr - _text);
+	else
+		printf("\tPTR\t_text - %#llx\n", _text - addr);
+}
+
 /* uncompress a compressed symbol. When this function is called, the best table
  * might still be compressed itself, so the function needs to be recursive */
 static int expand_symbol(const unsigned char *data, int len, char *result)
@@ -360,19 +369,6 @@ static void write_src(void)
 
 	printf("\t.section .rodata, \"a\"\n");
 
-	/* Provide proper symbols relocatability by their relativeness
-	 * to a fixed anchor point in the runtime image, either '_text'
-	 * for absolute address tables, in which case the linker will
-	 * emit the final addresses at build time. Otherwise, use the
-	 * offset relative to the lowest value encountered of all relative
-	 * symbols, and emit non-relocatable fixed offsets that will be fixed
-	 * up at runtime.
-	 *
-	 * The symbol names cannot be used to construct normal symbol
-	 * references as the list of symbols contains symbols that are
-	 * declared static and are private to their .o files.  This prevents
-	 * .tmp_kallsyms.o or any other object from referencing them.
-	 */
 	if (!base_relative)
 		output_label("kallsyms_addresses");
 	else
@@ -380,6 +376,13 @@ static void write_src(void)
 
 	for (i = 0; i < table_cnt; i++) {
 		if (base_relative) {
+			/*
+			 * Use the offset relative to the lowest value
+			 * encountered of all relative symbols, and emit
+			 * non-relocatable fixed offsets that will be fixed
+			 * up at runtime.
+			 */
+
 			long long offset;
 			int overflow;
 
@@ -402,12 +405,7 @@ static void write_src(void)
 			}
 			printf("\t.long\t%#x\n", (int)offset);
 		} else if (!symbol_absolute(&table[i])) {
-			if (_text <= table[i].addr)
-				printf("\tPTR\t_text + %#llx\n",
-					table[i].addr - _text);
-			else
-				printf("\tPTR\t_text - %#llx\n",
-					_text - table[i].addr);
+			output_address(table[i].addr);
 		} else {
 			printf("\tPTR\t%#llx\n", table[i].addr);
 		}
@@ -416,7 +414,7 @@ static void write_src(void)
 
 	if (base_relative) {
 		output_label("kallsyms_relative_base");
-		printf("\tPTR\t_text - %#llx\n", _text - relative_base);
+		output_address(relative_base);
 		printf("\n");
 	}
 

commit 831362fc317ae60413879deacdcc9617d9ce9e20
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:44 2019 +0900

    scripts/kallsyms: remove redundant initializers
    
    These are set to zero without the explicit initializers.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index b9b1a4cf1c65..fb55f262f42d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -57,9 +57,9 @@ static struct addr_range percpu_range = {
 
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
-static int all_symbols = 0;
-static int absolute_percpu = 0;
-static int base_relative = 0;
+static int all_symbols;
+static int absolute_percpu;
+static int base_relative;
 
 static int token_profit[0x10000];
 

commit d44270fc976b6c3b9e742e398580e4af8c69f7bd
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:43 2019 +0900

    scripts/kallsyms: put check_symbol_range() calls close together
    
    Put the relevant code close together.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index f4d5f131556d..b9b1a4cf1c65 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -200,6 +200,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		_text = s->addr;
 
 	check_symbol_range(sym, s->addr, text_ranges, ARRAY_SIZE(text_ranges));
+	check_symbol_range(sym, s->addr, &percpu_range, 1);
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
@@ -215,9 +216,6 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 
 	s->percpu_absolute = 0;
 
-	/* Record if we've found __per_cpu_start/end. */
-	check_symbol_range(sym, s->addr, &percpu_range, 1);
-
 	return 0;
 }
 

commit b6233d0ded3391a33bb0047edafe15169131eadb
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:42 2019 +0900

    scripts/kallsyms: make check_symbol_range() void function
    
    There is no more reason to check the return value of
    check_symbol_range().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index d90a6133d7b8..f4d5f131556d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -155,8 +155,8 @@ static bool is_ignored_symbol(const char *name, char type)
 	return false;
 }
 
-static int check_symbol_range(const char *sym, unsigned long long addr,
-			      struct addr_range *ranges, int entries)
+static void check_symbol_range(const char *sym, unsigned long long addr,
+			       struct addr_range *ranges, int entries)
 {
 	size_t i;
 	struct addr_range *ar;
@@ -166,14 +166,12 @@ static int check_symbol_range(const char *sym, unsigned long long addr,
 
 		if (strcmp(sym, ar->start_sym) == 0) {
 			ar->start = addr;
-			return 0;
+			return;
 		} else if (strcmp(sym, ar->end_sym) == 0) {
 			ar->end = addr;
-			return 0;
+			return;
 		}
 	}
-
-	return 1;
 }
 
 static int read_symbol(FILE *in, struct sym_entry *s)
@@ -200,9 +198,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(sym, "_text") == 0)
 		_text = s->addr;
-	else if (check_symbol_range(sym, s->addr, text_ranges,
-				    ARRAY_SIZE(text_ranges)) == 0)
-		/* nothing to do */;
+
+	check_symbol_range(sym, s->addr, text_ranges, ARRAY_SIZE(text_ranges));
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit 887df76de67f5a6dd423e5763c22ff07f0e50048
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:41 2019 +0900

    scripts/kallsyms: move ignored symbol types to is_ignored_symbol()
    
    Collect the ignored patterns to is_ignored_symbol().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 04a1dd16edcf..d90a6133d7b8 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -137,6 +137,21 @@ static bool is_ignored_symbol(const char *name, char type)
 			return true;
 	}
 
+	if (type == 'U' || type == 'u')
+		return true;
+	/* exclude debugging symbols */
+	if (type == 'N' || type == 'n')
+		return true;
+
+	if (toupper(type) == 'A') {
+		/* Keep these useful absolute symbols */
+		if (strcmp(name, "__kernel_syscall_via_break") &&
+		    strcmp(name, "__kernel_syscall_via_epc") &&
+		    strcmp(name, "__kernel_sigtramp") &&
+		    strcmp(name, "__gp"))
+			return true;
+	}
+
 	return false;
 }
 
@@ -188,21 +203,6 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	else if (check_symbol_range(sym, s->addr, text_ranges,
 				    ARRAY_SIZE(text_ranges)) == 0)
 		/* nothing to do */;
-	else if (toupper(stype) == 'A')
-	{
-		/* Keep these useful absolute symbols */
-		if (strcmp(sym, "__kernel_syscall_via_break") &&
-		    strcmp(sym, "__kernel_syscall_via_epc") &&
-		    strcmp(sym, "__kernel_sigtramp") &&
-		    strcmp(sym, "__gp"))
-			return -1;
-
-	}
-	else if (toupper(stype) == 'U')
-		return -1;
-	/* exclude debugging symbols */
-	else if (stype == 'N' || stype == 'n')
-		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit 97261e1e2240f627e27e93f7e410be1a7c97c80a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:40 2019 +0900

    scripts/kallsyms: move more patterns to the ignored_prefixes array
    
    Refactoring for shortening the code.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 843615c1d384..04a1dd16edcf 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -105,6 +105,8 @@ static bool is_ignored_symbol(const char *name, char type)
 	};
 
 	static const char * const ignored_prefixes[] = {
+		"$",			/* local symbols for ARM, MIPS, etc. */
+		".LASANPC",		/* s390 kasan local symbols */
 		"__crc_",		/* modversions */
 		"__efistub_",		/* arm64 EFI stub namespace */
 		NULL
@@ -198,19 +200,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	}
 	else if (toupper(stype) == 'U')
 		return -1;
-	/*
-	 * Ignore generated symbols such as:
-	 *  - mapping symbols in ARM ELF files ($a, $t, and $d)
-	 *  - MIPS ELF local symbols ($L123 instead of .L123)
-	 */
-	else if (sym[0] == '$')
-		return -1;
 	/* exclude debugging symbols */
 	else if (stype == 'N' || stype == 'n')
 		return -1;
-	/* exclude s390 kasan local symbols */
-	else if (!strncmp(sym, ".LASANPC", 8))
-		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit a41333e06acd1b37f3a3248fb90cd417218f9439
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:39 2019 +0900

    scripts/kallsyms: skip ignored symbols very early
    
    Unless the address range matters, symbols can be ignored earlier,
    which avoids unneeded memory allocation.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 056bde436540..843615c1d384 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -18,6 +18,7 @@
  *
  */
 
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -79,6 +80,64 @@ static char *sym_name(const struct sym_entry *s)
 	return (char *)s->sym + 1;
 }
 
+static bool is_ignored_symbol(const char *name, char type)
+{
+	static const char * const ignored_symbols[] = {
+		/*
+		 * Symbols which vary between passes. Passes 1 and 2 must have
+		 * identical symbol lists. The kallsyms_* symbols below are
+		 * only added after pass 1, they would be included in pass 2
+		 * when --all-symbols is specified so exclude them to get a
+		 * stable symbol list.
+		 */
+		"kallsyms_addresses",
+		"kallsyms_offsets",
+		"kallsyms_relative_base",
+		"kallsyms_num_syms",
+		"kallsyms_names",
+		"kallsyms_markers",
+		"kallsyms_token_table",
+		"kallsyms_token_index",
+		/* Exclude linker generated symbols which vary between passes */
+		"_SDA_BASE_",		/* ppc */
+		"_SDA2_BASE_",		/* ppc */
+		NULL
+	};
+
+	static const char * const ignored_prefixes[] = {
+		"__crc_",		/* modversions */
+		"__efistub_",		/* arm64 EFI stub namespace */
+		NULL
+	};
+
+	static const char * const ignored_suffixes[] = {
+		"_from_arm",		/* arm */
+		"_from_thumb",		/* arm */
+		"_veneer",		/* arm */
+		NULL
+	};
+
+	const char * const *p;
+
+	/* Exclude symbols which vary between passes. */
+	for (p = ignored_symbols; *p; p++)
+		if (!strcmp(name, *p))
+			return true;
+
+	for (p = ignored_prefixes; *p; p++)
+		if (!strncmp(name, *p, strlen(*p)))
+			return true;
+
+	for (p = ignored_suffixes; *p; p++) {
+		int l = strlen(name) - strlen(*p);
+
+		if (l >= 0 && !strcmp(name + l, *p))
+			return true;
+	}
+
+	return false;
+}
+
 static int check_symbol_range(const char *sym, unsigned long long addr,
 			      struct addr_range *ranges, int entries)
 {
@@ -118,6 +177,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		return -1;
 	}
 
+	if (is_ignored_symbol(sym, stype))
+		return -1;
+
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(sym, "_text") == 0)
 		_text = s->addr;
@@ -188,38 +250,6 @@ static int symbol_in_range(const struct sym_entry *s,
 
 static int symbol_valid(const struct sym_entry *s)
 {
-	/* Symbols which vary between passes.  Passes 1 and 2 must have
-	 * identical symbol lists.  The kallsyms_* symbols below are only added
-	 * after pass 1, they would be included in pass 2 when --all-symbols is
-	 * specified so exclude them to get a stable symbol list.
-	 */
-	static const char * const special_symbols[] = {
-		"kallsyms_addresses",
-		"kallsyms_offsets",
-		"kallsyms_relative_base",
-		"kallsyms_num_syms",
-		"kallsyms_names",
-		"kallsyms_markers",
-		"kallsyms_token_table",
-		"kallsyms_token_index",
-
-	/* Exclude linker generated symbols which vary between passes */
-		"_SDA_BASE_",		/* ppc */
-		"_SDA2_BASE_",		/* ppc */
-		NULL };
-
-	static const char * const special_prefixes[] = {
-		"__crc_",		/* modversions */
-		"__efistub_",		/* arm64 EFI stub namespace */
-		NULL };
-
-	static const char * const special_suffixes[] = {
-		"_veneer",		/* arm */
-		"_from_arm",		/* arm */
-		"_from_thumb",		/* arm */
-		NULL };
-
-	int i;
 	const char *name = sym_name(s);
 
 	/* if --all-symbols is not specified, then symbols outside the text
@@ -241,25 +271,6 @@ static int symbol_valid(const struct sym_entry *s)
 			return 0;
 	}
 
-	/* Exclude symbols which vary between passes. */
-	for (i = 0; special_symbols[i]; i++)
-		if (strcmp(name, special_symbols[i]) == 0)
-			return 0;
-
-	for (i = 0; special_prefixes[i]; i++) {
-		int l = strlen(special_prefixes[i]);
-
-		if (strncmp(name, special_prefixes[i], l) == 0)
-			return 0;
-	}
-
-	for (i = 0; special_suffixes[i]; i++) {
-		int l = strlen(name) - strlen(special_suffixes[i]);
-
-		if (l >= 0 && strcmp(name + l, special_suffixes[i]) == 0)
-			return 0;
-	}
-
 	return 1;
 }
 

commit 4bfe2b7816a6e97fba7b4125166b33db4b31d29d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:38 2019 +0900

    scripts/kallsyms: add const qualifiers where possible
    
    Add 'const' where a function does not write to the pointer dereferenes.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 274a77bfbd63..056bde436540 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -170,11 +170,11 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	return 0;
 }
 
-static int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,
-			   int entries)
+static int symbol_in_range(const struct sym_entry *s,
+			   const struct addr_range *ranges, int entries)
 {
 	size_t i;
-	struct addr_range *ar;
+	const struct addr_range *ar;
 
 	for (i = 0; i < entries; ++i) {
 		ar = &ranges[i];
@@ -186,14 +186,14 @@ static int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,
 	return 0;
 }
 
-static int symbol_valid(struct sym_entry *s)
+static int symbol_valid(const struct sym_entry *s)
 {
 	/* Symbols which vary between passes.  Passes 1 and 2 must have
 	 * identical symbol lists.  The kallsyms_* symbols below are only added
 	 * after pass 1, they would be included in pass 2 when --all-symbols is
 	 * specified so exclude them to get a stable symbol list.
 	 */
-	static char *special_symbols[] = {
+	static const char * const special_symbols[] = {
 		"kallsyms_addresses",
 		"kallsyms_offsets",
 		"kallsyms_relative_base",
@@ -208,12 +208,12 @@ static int symbol_valid(struct sym_entry *s)
 		"_SDA2_BASE_",		/* ppc */
 		NULL };
 
-	static char *special_prefixes[] = {
+	static const char * const special_prefixes[] = {
 		"__crc_",		/* modversions */
 		"__efistub_",		/* arm64 EFI stub namespace */
 		NULL };
 
-	static char *special_suffixes[] = {
+	static const char * const special_suffixes[] = {
 		"_veneer",		/* arm */
 		"_from_arm",		/* arm */
 		"_from_thumb",		/* arm */
@@ -305,7 +305,7 @@ static void read_map(FILE *in)
 	}
 }
 
-static void output_label(char *label)
+static void output_label(const char *label)
 {
 	printf(".globl %s\n", label);
 	printf("\tALGN\n");
@@ -314,7 +314,7 @@ static void output_label(char *label)
 
 /* uncompress a compressed symbol. When this function is called, the best table
  * might still be compressed itself, so the function needs to be recursive */
-static int expand_symbol(unsigned char *data, int len, char *result)
+static int expand_symbol(const unsigned char *data, int len, char *result)
 {
 	int c, rlen, total=0;
 
@@ -339,7 +339,7 @@ static int expand_symbol(unsigned char *data, int len, char *result)
 	return total;
 }
 
-static int symbol_absolute(struct sym_entry *s)
+static int symbol_absolute(const struct sym_entry *s)
 {
 	return s->percpu_absolute;
 }
@@ -477,7 +477,7 @@ static void write_src(void)
 /* table lookup compression functions */
 
 /* count all the possible tokens in a symbol */
-static void learn_symbol(unsigned char *symbol, int len)
+static void learn_symbol(const unsigned char *symbol, int len)
 {
 	int i;
 
@@ -486,7 +486,7 @@ static void learn_symbol(unsigned char *symbol, int len)
 }
 
 /* decrease the count for all the possible tokens in a symbol */
-static void forget_symbol(unsigned char *symbol, int len)
+static void forget_symbol(const unsigned char *symbol, int len)
 {
 	int i;
 
@@ -504,7 +504,7 @@ static void build_initial_tok_table(void)
 }
 
 static unsigned char *find_token(unsigned char *str, int len,
-				 unsigned char *token)
+				 const unsigned char *token)
 {
 	int i;
 
@@ -517,7 +517,7 @@ static unsigned char *find_token(unsigned char *str, int len,
 
 /* replace a given token in all the valid symbols. Use the sampled symbols
  * to update the counts */
-static void compress_symbols(unsigned char *str, int idx)
+static void compress_symbols(const unsigned char *str, int idx)
 {
 	unsigned int i, len, size;
 	unsigned char *p1, *p2;

commit 2558c138aca75e5fc435e20fd37f0b0eea61bb65
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:37 2019 +0900

    scripts/kallsyms: make find_token() return (unsigned char *)
    
    The callers of this function expect (unsigned char *). I do not see
    a good reason to make this function return (void *).
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 89cc7c098c51..274a77bfbd63 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -503,7 +503,8 @@ static void build_initial_tok_table(void)
 		learn_symbol(table[i].sym, table[i].len);
 }
 
-static void *find_token(unsigned char *str, int len, unsigned char *token)
+static unsigned char *find_token(unsigned char *str, int len,
+				 unsigned char *token)
 {
 	int i;
 

commit aa915245005bdb45ccbc96964853b4a27646390f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:36 2019 +0900

    scripts/kallsyms: replace prefix_underscores_count() with strspn()
    
    You can do equivalent things with strspn(). I do not see noticeable
    performance difference.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index baa2fa5692b0..89cc7c098c51 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -661,16 +661,6 @@ static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
 	return 0;
 }
 
-static int prefix_underscores_count(const char *str)
-{
-	const char *tail = str;
-
-	while (*tail == '_')
-		tail++;
-
-	return tail - str;
-}
-
 static int compare_symbols(const void *a, const void *b)
 {
 	const struct sym_entry *sa;
@@ -699,8 +689,8 @@ static int compare_symbols(const void *a, const void *b)
 		return wa - wb;
 
 	/* sort by the number of prefix underscores */
-	wa = prefix_underscores_count(sym_name(sa));
-	wb = prefix_underscores_count(sym_name(sb));
+	wa = strspn(sym_name(sa), "_");
+	wb = strspn(sym_name(sb), "_");
 	if (wa != wb)
 		return wa - wb;
 

commit 29e55ad3d5f50eca6f8762749da85d6fa1250061
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:35 2019 +0900

    scripts/kallsyms: add sym_name() to mitigate cast ugliness
    
    sym_entry::sym is (unsigned char *) instead of (char *) because
    kallsyms exploits the MSB for compression, and the characters are
    used as the index of token_profit array.
    
    However, it requires casting (unsigned char *) to (char *) in some
    places since standard library functions such as strcmp(), strlen()
    expect (char *).
    
    Introduce a new helper, sym_name(), which advances the given pointer
    by 1 and casts it to (char *).
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index a57636c6f84f..baa2fa5692b0 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -74,6 +74,11 @@ static void usage(void)
 	exit(1);
 }
 
+static char *sym_name(const struct sym_entry *s)
+{
+	return (char *)s->sym + 1;
+}
+
 static int check_symbol_range(const char *sym, unsigned long long addr,
 			      struct addr_range *ranges, int entries)
 {
@@ -154,7 +159,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 			"unable to allocate required amount of memory\n");
 		exit(EXIT_FAILURE);
 	}
-	strcpy((char *)s->sym + 1, sym);
+	strcpy(sym_name(s), sym);
 	s->sym[0] = stype;
 
 	s->percpu_absolute = 0;
@@ -215,7 +220,7 @@ static int symbol_valid(struct sym_entry *s)
 		NULL };
 
 	int i;
-	char *sym_name = (char *)s->sym + 1;
+	const char *name = sym_name(s);
 
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
@@ -230,30 +235,28 @@ static int symbol_valid(struct sym_entry *s)
 		 * rules.
 		 */
 		if ((s->addr == text_range_text->end &&
-				strcmp(sym_name,
-				       text_range_text->end_sym)) ||
+		     strcmp(name, text_range_text->end_sym)) ||
 		    (s->addr == text_range_inittext->end &&
-				strcmp(sym_name,
-				       text_range_inittext->end_sym)))
+		     strcmp(name, text_range_inittext->end_sym)))
 			return 0;
 	}
 
 	/* Exclude symbols which vary between passes. */
 	for (i = 0; special_symbols[i]; i++)
-		if (strcmp(sym_name, special_symbols[i]) == 0)
+		if (strcmp(name, special_symbols[i]) == 0)
 			return 0;
 
 	for (i = 0; special_prefixes[i]; i++) {
 		int l = strlen(special_prefixes[i]);
 
-		if (strncmp(sym_name, special_prefixes[i], l) == 0)
+		if (strncmp(name, special_prefixes[i], l) == 0)
 			return 0;
 	}
 
 	for (i = 0; special_suffixes[i]; i++) {
-		int l = strlen(sym_name) - strlen(special_suffixes[i]);
+		int l = strlen(name) - strlen(special_suffixes[i]);
 
-		if (l >= 0 && strcmp(sym_name + l, special_suffixes[i]) == 0)
+		if (l >= 0 && strcmp(name + l, special_suffixes[i]) == 0)
 			return 0;
 	}
 
@@ -626,7 +629,7 @@ static void optimize_token_table(void)
 /* guess for "linker script provide" symbol */
 static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
 {
-	const char *symbol = (char *)se->sym + 1;
+	const char *symbol = sym_name(se);
 	int len = se->len - 1;
 
 	if (len < 8)
@@ -696,8 +699,8 @@ static int compare_symbols(const void *a, const void *b)
 		return wa - wb;
 
 	/* sort by the number of prefix underscores */
-	wa = prefix_underscores_count((const char *)sa->sym + 1);
-	wb = prefix_underscores_count((const char *)sb->sym + 1);
+	wa = prefix_underscores_count(sym_name(sa));
+	wb = prefix_underscores_count(sym_name(sb));
 	if (wa != wb)
 		return wa - wb;
 

commit c5e5002f3603e01f50d8d61878a4ca8ffca7bd15
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:34 2019 +0900

    scripts/kallsyms: remove unneeded length check for prefix matching
    
    l <= strlen(sym_name) is unnecessary for prefix matching.
    strncmp() will do.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 14a50c8d3f34..a57636c6f84f 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -246,8 +246,7 @@ static int symbol_valid(struct sym_entry *s)
 	for (i = 0; special_prefixes[i]; i++) {
 		int l = strlen(special_prefixes[i]);
 
-		if (l <= strlen(sym_name) &&
-		    strncmp(sym_name, special_prefixes[i], l) == 0)
+		if (strncmp(sym_name, special_prefixes[i], l) == 0)
 			return 0;
 	}
 

commit e0109042cc4ee12b3689e29c872c1436e0424c69
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:33 2019 +0900

    scripts/kallsyms: remove redundant is_arm_mapping_symbol()
    
    Since commit 6f00df24ee39 ("[PATCH] Strip local symbols from kallsyms"),
    all symbols starting '$' are ignored.
    
    is_arm_mapping_symbol() particularly ignores $a, $t, etc. but it is
    redundant.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index c9efb67c6ecb..14a50c8d3f34 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -74,16 +74,6 @@ static void usage(void)
 	exit(1);
 }
 
-/*
- * This ignores the intensely annoying "mapping symbols" found
- * in ARM ELF files: $a, $t and $d.
- */
-static int is_arm_mapping_symbol(const char *str)
-{
-	return str[0] == '$' && strchr("axtd", str[1])
-	       && (str[2] == '\0' || str[2] == '.');
-}
-
 static int check_symbol_range(const char *sym, unsigned long long addr,
 			      struct addr_range *ranges, int entries)
 {
@@ -139,10 +129,13 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 			return -1;
 
 	}
-	else if (toupper(stype) == 'U' ||
-		 is_arm_mapping_symbol(sym))
+	else if (toupper(stype) == 'U')
 		return -1;
-	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
+	/*
+	 * Ignore generated symbols such as:
+	 *  - mapping symbols in ARM ELF files ($a, $t, and $d)
+	 *  - MIPS ELF local symbols ($L123 instead of .L123)
+	 */
 	else if (sym[0] == '$')
 		return -1;
 	/* exclude debugging symbols */

commit f34ea0291029781810ca4c213713dc6b4a686322
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:32 2019 +0900

    scripts/kallsyms: set relative_base more effectively
    
    Currently, record_relative_base() iterates over the entire table to
    find the minimum address, but it is not efficient because we sort
    the table anyway.
    
    After sort_symbol(), the table is sorted by address. (kallsyms parses
    the 'nm -n' output, so the data is already sorted by address, but this
    commit does not rely on it.)
    
    Move record_relative_base() after sort_symbols(), and take the first
    non-absolute symbol value.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index de986eda41a6..c9efb67c6ecb 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -739,11 +739,15 @@ static void record_relative_base(void)
 {
 	unsigned int i;
 
-	relative_base = -1ULL;
 	for (i = 0; i < table_cnt; i++)
-		if (!symbol_absolute(&table[i]) &&
-		    table[i].addr < relative_base)
+		if (!symbol_absolute(&table[i])) {
+			/*
+			 * The table is sorted by address.
+			 * Take the first non-absolute symbol value.
+			 */
 			relative_base = table[i].addr;
+			return;
+		}
 }
 
 int main(int argc, char **argv)
@@ -767,9 +771,9 @@ int main(int argc, char **argv)
 	shrink_table();
 	if (absolute_percpu)
 		make_percpus_absolute();
+	sort_symbols();
 	if (base_relative)
 		record_relative_base();
-	sort_symbols();
 	optimize_token_table();
 	write_src();
 

commit 5e5c4fa787453292d3deefd59129384d391b7f45
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:31 2019 +0900

    scripts/kallsyms: shrink table before sorting it
    
    Currently, build_initial_tok_table() trims unused symbols, but it is
    called after sort_symbols().
    
    It is not efficient to sort the huge table that contains unused entries.
    Shrink the table before sorting it.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 79641874d860..de986eda41a6 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -268,6 +268,30 @@ static int symbol_valid(struct sym_entry *s)
 	return 1;
 }
 
+/* remove all the invalid symbols from the table */
+static void shrink_table(void)
+{
+	unsigned int i, pos;
+
+	pos = 0;
+	for (i = 0; i < table_cnt; i++) {
+		if (symbol_valid(&table[i])) {
+			if (pos != i)
+				table[pos] = table[i];
+			pos++;
+		} else {
+			free(table[i].sym);
+		}
+	}
+	table_cnt = pos;
+
+	/* When valid symbol is not registered, exit to error */
+	if (!table_cnt) {
+		fprintf(stderr, "No valid symbol.\n");
+		exit(1);
+	}
+}
+
 static void read_map(FILE *in)
 {
 	while (!feof(in)) {
@@ -475,23 +499,13 @@ static void forget_symbol(unsigned char *symbol, int len)
 		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;
 }
 
-/* remove all the invalid symbols from the table and do the initial token count */
+/* do the initial token count */
 static void build_initial_tok_table(void)
 {
-	unsigned int i, pos;
+	unsigned int i;
 
-	pos = 0;
-	for (i = 0; i < table_cnt; i++) {
-		if ( symbol_valid(&table[i]) ) {
-			if (pos != i)
-				table[pos] = table[i];
-			learn_symbol(table[pos].sym, table[pos].len);
-			pos++;
-		} else {
-			free(table[i].sym);
-		}
-	}
-	table_cnt = pos;
+	for (i = 0; i < table_cnt; i++)
+		learn_symbol(table[i].sym, table[i].len);
 }
 
 static void *find_token(unsigned char *str, int len, unsigned char *token)
@@ -614,12 +628,6 @@ static void optimize_token_table(void)
 
 	insert_real_symbols_in_table();
 
-	/* When valid symbol is not registered, exit to error */
-	if (!table_cnt) {
-		fprintf(stderr, "No valid symbol.\n");
-		exit(1);
-	}
-
 	optimize_result();
 }
 
@@ -756,6 +764,7 @@ int main(int argc, char **argv)
 		usage();
 
 	read_map(stdin);
+	shrink_table();
 	if (absolute_percpu)
 		make_percpus_absolute();
 	if (base_relative)

commit 21915eca088dc271c970e8351290e83d938114ac
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:30 2019 +0900

    scripts/kallsyms: fix definitely-lost memory leak
    
    build_initial_tok_table() overwrites unused sym_entry to shrink the
    table size. Before the entry is overwritten, table[i].sym must be freed
    since it is malloc'ed data.
    
    This fixes the 'definitely lost' report from valgrind. I ran valgrind
    against x86_64_defconfig of v5.4-rc8 kernel, and here is the summary:
    
    [Before the fix]
    
      LEAK SUMMARY:
         definitely lost: 53,184 bytes in 2,874 blocks
    
    [After the fix]
    
      LEAK SUMMARY:
         definitely lost: 0 bytes in 0 blocks
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 918c2ba071b5..79641874d860 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -487,6 +487,8 @@ static void build_initial_tok_table(void)
 				table[pos] = table[i];
 			learn_symbol(table[pos].sym, table[pos].len);
 			pos++;
+		} else {
+			free(table[i].sym);
 		}
 	}
 	table_cnt = pos;

commit 1ef26b7c948128dc9240939da06690bfd90f4607
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 24 01:04:29 2019 +0900

    scripts/kallsyms: remove unneeded #ifndef ARRAY_SIZE
    
    This is not defined in the standard headers. #ifndef is unneeded.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index ae6504d07fd6..918c2ba071b5 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -24,9 +24,7 @@
 #include <ctype.h>
 #include <limits.h>
 
-#ifndef ARRAY_SIZE
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
-#endif
 
 #define KSYM_NAME_LEN		128
 

commit 33177f01ca3fe550146bb9001bec2fd806b2f40c
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Fri Jun 28 19:22:47 2019 +0200

    kallsyms: exclude kasan local symbols on s390
    
    gcc asan instrumentation emits the following sequence to store frame pc
    when the kernel is built with CONFIG_RELOCATABLE:
    debug/vsprintf.s:
            .section        .data.rel.ro.local,"aw"
            .align  8
    .LC3:
            .quad   .LASANPC4826@GOTOFF
    .text
            .align  8
            .type   number, @function
    number:
    .LASANPC4826:
    
    and in case reloc is issued for LASANPC label it also gets into .symtab
    with the same address as actual function symbol:
    $ nm -n vmlinux | grep 0000000001397150
    0000000001397150 t .LASANPC4826
    0000000001397150 t number
    
    In the end kernel backtraces are almost unreadable:
    [  143.748476] Call Trace:
    [  143.748484] ([<000000002da3e62c>] .LASANPC2671+0x114/0x190)
    [  143.748492]  [<000000002eca1a58>] .LASANPC2612+0x110/0x160
    [  143.748502]  [<000000002de9d830>] print_address_description+0x80/0x3b0
    [  143.748511]  [<000000002de9dd64>] __kasan_report+0x15c/0x1c8
    [  143.748521]  [<000000002ecb56d4>] strrchr+0x34/0x60
    [  143.748534]  [<000003ff800a9a40>] kasan_strings+0xb0/0x148 [test_kasan]
    [  143.748547]  [<000003ff800a9bba>] kmalloc_tests_init+0xe2/0x528 [test_kasan]
    [  143.748555]  [<000000002da2117c>] .LASANPC4069+0x354/0x748
    [  143.748563]  [<000000002dbfbb16>] do_init_module+0x136/0x3b0
    [  143.748571]  [<000000002dbff3f4>] .LASANPC3191+0x2164/0x25d0
    [  143.748580]  [<000000002dbffc4c>] .LASANPC3196+0x184/0x1b8
    [  143.748587]  [<000000002ecdf2ec>] system_call+0xd8/0x2d8
    
    Since LASANPC labels are not even unique and get into .symtab only due
    to relocs filter them out in kallsyms.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index e17837f1d3f2..ae6504d07fd6 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -150,6 +150,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	/* exclude debugging symbols */
 	else if (stype == 'N' || stype == 'n')
 		return -1;
+	/* exclude s390 kasan local symbols */
+	else if (!strncmp(sym, ".LASANPC", 8))
+		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit ffd602eb4693bbb49b301fa059b109bbdebf9524
Merge: 5af7f115886f 9250d20e9ece
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 10 17:48:21 2019 -0700

    Merge tag 'kbuild-v5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull Kbuild updates from Masahiro Yamada:
    
     - do not generate unneeded top-level built-in.a
    
     - let git ignore O= directory entirely
    
     - optimize scripts/kallsyms slightly
    
     - exclude DWARF info from *.s regardless of config options
    
     - fix GCC toolchain search path for Clang to prepare ld.lld support
    
     - do not generate modules.order when CONFIG_MODULES is disabled
    
     - simplify single target rules and remove VPATH for external module
       build
    
     - allow to add optional flags to dpkg-buildpackage when building
       deb-pkg
    
     - move some compiler option tests from Makefile to Kconfig
    
     - various Makefile cleanups
    
    * tag 'kbuild-v5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild: (40 commits)
      kbuild: remove scripts/basic/% build target
      kbuild: use -Werror=implicit-... instead of -Werror-implicit-...
      kbuild: clean up scripts/gcc-version.sh
      kbuild: remove cc-version macro
      kbuild: update comment block of scripts/clang-version.sh
      kbuild: remove commented-out INITRD_COMPRESS
      kbuild: move -gsplit-dwarf, -gdwarf-4 option tests to Kconfig
      kbuild: [bin]deb-pkg: add DPKG_FLAGS variable
      kbuild: move ".config not found!" message from Kconfig to Makefile
      kbuild: invoke syncconfig if include/config/auto.conf.cmd is missing
      kbuild: simplify single target rules
      kbuild: remove empty rules for makefiles
      kbuild: make -r/-R effective in top Makefile for old Make versions
      kbuild: move tools_silent to a more relevant place
      kbuild: compute false-positive -Wmaybe-uninitialized cases in Kconfig
      kbuild: refactor cc-cross-prefix implementation
      kbuild: hardcode genksyms path and remove GENKSYMS variable
      scripts/gdb: refactor rules for symlink creation
      kbuild: create symlink to vmlinux-gdb.py in scripts_gdb target
      scripts/gdb: do not descend into scripts/gdb from scripts
      ...

commit 500193ec57fddf5e52d64fd7278b37a6afc9f773
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 4 10:53:18 2019 +0900

    kallsyms: include <asm/bitsperlong.h> instead of <asm/types.h>
    
    <asm/bitsperlong.h> is enough to include the definition of
    BITS_PER_LONG.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index f1b57492adef..03ff265fe522 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -331,7 +331,7 @@ static void write_src(void)
 	unsigned int *markers;
 	char buf[KSYM_NAME_LEN];
 
-	printf("#include <asm/types.h>\n");
+	printf("#include <asm/bitsperlong.h>\n");
 	printf("#if BITS_PER_LONG == 64\n");
 	printf("#define PTR .quad\n");
 	printf("#define ALGN .balign 8\n");

commit 52a849ed8896d733de6005993f34407f7512311a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 4 10:53:17 2019 +0900

    kallsyms: remove unneeded memset() calls
    
    Global variables in the .bss section are zeroed out before the program
    starts to run.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index fc00bb01faf0..f1b57492adef 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -596,9 +596,6 @@ static void insert_real_symbols_in_table(void)
 {
 	unsigned int i, j, c;
 
-	memset(best_table, 0, sizeof(best_table));
-	memset(best_table_len, 0, sizeof(best_table_len));
-
 	for (i = 0; i < table_cnt; i++) {
 		for (j = 0; j < table[i].len; j++) {
 			c = table[i].sym[j];

commit f43e9daace4efc146aa653179bdebb478be5de8a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 4 10:53:16 2019 +0900

    kallsyms: add static qualifiers where missing
    
    Fix the following sparse warnings:
    
    scripts/kallsyms.c:65:5: warning: symbol 'token_profit' was not declared. Should it be static?
    scripts/kallsyms.c:68:15: warning: symbol 'best_table' was not declared. Should it be static?
    scripts/kallsyms.c:69:15: warning: symbol 'best_table_len' was not declared. Should it be static?
    
    Also, remove 'inline' from is_arm_mapping_symbol(). The compiler
    will inline it anyway when it is appropriate to do so.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 77cebad0474e..fc00bb01faf0 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -62,11 +62,11 @@ static int all_symbols = 0;
 static int absolute_percpu = 0;
 static int base_relative = 0;
 
-int token_profit[0x10000];
+static int token_profit[0x10000];
 
 /* the table that holds the result of the compression */
-unsigned char best_table[256][2];
-unsigned char best_table_len[256];
+static unsigned char best_table[256][2];
+static unsigned char best_table_len[256];
 
 
 static void usage(void)
@@ -80,7 +80,7 @@ static void usage(void)
  * This ignores the intensely annoying "mapping symbols" found
  * in ARM ELF files: $a, $t and $d.
  */
-static inline int is_arm_mapping_symbol(const char *str)
+static int is_arm_mapping_symbol(const char *str)
 {
 	return str[0] == '$' && strchr("axtd", str[1])
 	       && (str[2] == '\0' || str[2] == '.');

commit 6db2983cd8064808141ccefd75218f5b4345ffae
Author: Eugene Loh <eugene.loh@oracle.com>
Date:   Thu Jan 17 14:46:00 2019 -0800

    kallsyms: Handle too long symbols in kallsyms.c
    
    When checking for symbols with excessively long names,
    account for null terminating character.
    
    Fixes: f3462aa952cf ("Kbuild: Handle longer symbols in kallsyms.c")
    Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 77cebad0474e..f75e7bda4889 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -118,8 +118,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 			fprintf(stderr, "Read error or end of file.\n");
 		return -1;
 	}
-	if (strlen(sym) > KSYM_NAME_LEN) {
-		fprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"
+	if (strlen(sym) >= KSYM_NAME_LEN) {
+		fprintf(stderr, "Symbol %s too long for kallsyms (%zu >= %d).\n"
 				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
 			sym, strlen(sym), KSYM_NAME_LEN);
 		return -1;

commit 72d3ebb929de339f991fc49b58942d2d5ecdb753
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Dec 30 13:36:00 2018 +0100

    kallsyms: lower alignment on ARM
    
    As mentioned in the info pages of gas, the '.align' pseudo op's
    interpretation of the alignment value is architecture specific.
    It might either be a byte value or taken to the power of two.
    
    On ARM it's actually the latter which leads to unnecessary large
    alignments of 16 bytes for 32 bit builds or 256 bytes for 64 bit
    builds.
    
    Fix this by switching to '.balign' instead which is consistent
    across all architectures.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 109a1af7e444..77cebad0474e 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -334,10 +334,10 @@ static void write_src(void)
 	printf("#include <asm/types.h>\n");
 	printf("#if BITS_PER_LONG == 64\n");
 	printf("#define PTR .quad\n");
-	printf("#define ALGN .align 8\n");
+	printf("#define ALGN .balign 8\n");
 	printf("#else\n");
 	printf("#define PTR .long\n");
-	printf("#define ALGN .align 4\n");
+	printf("#define ALGN .balign 4\n");
 	printf("#endif\n");
 
 	printf("\t.section .rodata, \"a\"\n");

commit 36f546a1bdb5d268aec97b2fe4800c91a4f5596a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Sep 4 09:42:24 2018 +0900

    kallsyms: remove left-over Blackfin code
    
    These symbols were added by commit 028f042613c3 ("kallsyms: support
    kernel symbols in Blackfin on-chip memory") for Blackfin.
    
    The Blackfin support was removed by commit 4ba66a976072 ("arch: remove
    blackfin port").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 085b6a584fe0..109a1af7e444 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -48,8 +48,6 @@ static unsigned long long relative_base;
 static struct addr_range text_ranges[] = {
 	{ "_stext",     "_etext"     },
 	{ "_sinittext", "_einittext" },
-	{ "_stext_l1",  "_etext_l1"  },	/* Blackfin on-chip L1 inst SRAM */
-	{ "_stext_l2",  "_etext_l2"  },	/* Blackfin on-chip L2 SRAM */
 };
 #define text_range_text     (&text_ranges[0])
 #define text_range_inittext (&text_ranges[1])

commit 80ffbaa5b1bd98e80e3239a3b8cfda2da433009a
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Sep 3 06:09:34 2018 -0600

    kallsyms: reduce size a little on 64-bit
    
    Both kallsyms_num_syms and kallsyms_markers[] don't really need to use
    unsigned long as their (base) types; unsigned int fully suffices.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index a9186a98a37d..085b6a584fe0 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -405,7 +405,7 @@ static void write_src(void)
 	}
 
 	output_label("kallsyms_num_syms");
-	printf("\tPTR\t%u\n", table_cnt);
+	printf("\t.long\t%u\n", table_cnt);
 	printf("\n");
 
 	/* table of offset markers, that give the offset in the compressed stream
@@ -434,7 +434,7 @@ static void write_src(void)
 
 	output_label("kallsyms_markers");
 	for (i = 0; i < ((table_cnt + 255) >> 8); i++)
-		printf("\tPTR\t%d\n", markers[i]);
+		printf("\t.long\t%u\n", markers[i]);
 	printf("\n");
 
 	free(markers);

commit ac5db1fc89bf84d7479761e0de855e6376fdab1e
Author: nixiaoming <nixiaoming@huawei.com>
Date:   Thu May 24 11:16:12 2018 +0800

    scripts: Fixed printf format mismatch
    
    scripts/kallsyms.c: function write_src:
    "printf", the #1 format specifier "d" need arg type "int",
    but the according arg "table_cnt" has type "unsigned int"
    
    scripts/recordmcount.c: function do_file:
    "fprintf", the #1 format specifier "d" need arg type "int",
    but the according arg "(*w2)(ehdr->e_machine)" has type "unsigned int"
    
    scripts/recordmcount.h: function find_secsym_ndx:
    "fprintf", the #1 format specifier "d" need arg type "int",
    but the according arg "txtndx" has type "unsigned int"
    
    Signed-off-by: nixiaoming <nixiaoming@huawei.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 80417629b246..a9186a98a37d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -405,7 +405,7 @@ static void write_src(void)
 	}
 
 	output_label("kallsyms_num_syms");
-	printf("\tPTR\t%d\n", table_cnt);
+	printf("\tPTR\t%u\n", table_cnt);
 	printf("\n");
 
 	/* table of offset markers, that give the offset in the compressed stream

commit 534c9f2ec4c92adbe8791125e7ba66d5023ad51f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 16:23:47 2018 +0900

    kallsyms: remove symbol prefix support
    
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX was selected by BLACKFIN, METAG.
    They were removed by commit 4ba66a976072 ("arch: remove blackfin port"),
    commit bb6fb6dfcc17 ("metag: Remove arch/metag/"), respectively.
    
    No more architecture enables CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX,
    hence the --symbol-prefix option is unnecessary.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 5abfbf1b8fe2..80417629b246 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -62,7 +62,6 @@ static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
 static int all_symbols = 0;
 static int absolute_percpu = 0;
-static char symbol_prefix_char = '\0';
 static int base_relative = 0;
 
 int token_profit[0x10000];
@@ -75,7 +74,6 @@ unsigned char best_table_len[256];
 static void usage(void)
 {
 	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
-			"[--symbol-prefix=<prefix char>] "
 			"[--base-relative] < in.map > out.S\n");
 	exit(1);
 }
@@ -113,28 +111,22 @@ static int check_symbol_range(const char *sym, unsigned long long addr,
 
 static int read_symbol(FILE *in, struct sym_entry *s)
 {
-	char str[500];
-	char *sym, stype;
+	char sym[500], stype;
 	int rc;
 
-	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
+	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, sym);
 	if (rc != 3) {
-		if (rc != EOF && fgets(str, 500, in) == NULL)
+		if (rc != EOF && fgets(sym, 500, in) == NULL)
 			fprintf(stderr, "Read error or end of file.\n");
 		return -1;
 	}
-	if (strlen(str) > KSYM_NAME_LEN) {
+	if (strlen(sym) > KSYM_NAME_LEN) {
 		fprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"
 				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
-			str, strlen(str), KSYM_NAME_LEN);
+			sym, strlen(sym), KSYM_NAME_LEN);
 		return -1;
 	}
 
-	sym = str;
-	/* skip prefix char */
-	if (symbol_prefix_char && str[0] == symbol_prefix_char)
-		sym++;
-
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(sym, "_text") == 0)
 		_text = s->addr;
@@ -155,7 +147,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		 is_arm_mapping_symbol(sym))
 		return -1;
 	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
-	else if (str[0] == '$')
+	else if (sym[0] == '$')
 		return -1;
 	/* exclude debugging symbols */
 	else if (stype == 'N' || stype == 'n')
@@ -163,14 +155,14 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
-	s->len = strlen(str) + 1;
+	s->len = strlen(sym) + 1;
 	s->sym = malloc(s->len + 1);
 	if (!s->sym) {
 		fprintf(stderr, "kallsyms failure: "
 			"unable to allocate required amount of memory\n");
 		exit(EXIT_FAILURE);
 	}
-	strcpy((char *)s->sym + 1, str);
+	strcpy((char *)s->sym + 1, sym);
 	s->sym[0] = stype;
 
 	s->percpu_absolute = 0;
@@ -233,11 +225,6 @@ static int symbol_valid(struct sym_entry *s)
 	int i;
 	char *sym_name = (char *)s->sym + 1;
 
-	/* skip prefix char */
-	if (symbol_prefix_char && *sym_name == symbol_prefix_char)
-		sym_name++;
-
-
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
@@ -302,15 +289,9 @@ static void read_map(FILE *in)
 
 static void output_label(char *label)
 {
-	if (symbol_prefix_char)
-		printf(".globl %c%s\n", symbol_prefix_char, label);
-	else
-		printf(".globl %s\n", label);
+	printf(".globl %s\n", label);
 	printf("\tALGN\n");
-	if (symbol_prefix_char)
-		printf("%c%s:\n", symbol_prefix_char, label);
-	else
-		printf("%s:\n", label);
+	printf("%s:\n", label);
 }
 
 /* uncompress a compressed symbol. When this function is called, the best table
@@ -768,13 +749,7 @@ int main(int argc, char **argv)
 				all_symbols = 1;
 			else if (strcmp(argv[i], "--absolute-percpu") == 0)
 				absolute_percpu = 1;
-			else if (strncmp(argv[i], "--symbol-prefix=", 16) == 0) {
-				char *p = &argv[i][16];
-				/* skip quote */
-				if ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))
-					p++;
-				symbol_prefix_char = *p;
-			} else if (strcmp(argv[i], "--base-relative") == 0)
+			else if (strcmp(argv[i], "--base-relative") == 0)
 				base_relative = 1;
 			else
 				usage();

commit 23221d997b3d28cb80c4d4d1b4bd36610f8e12fc
Merge: 5b1f3dc927a2 65896545b69f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 4 16:01:43 2018 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Will Deacon:
     "Nothing particularly stands out here, probably because people were
      tied up with spectre/meltdown stuff last time around. Still, the main
      pieces are:
    
       - Rework of our CPU features framework so that we can whitelist CPUs
         that don't require kpti even in a heterogeneous system
    
       - Support for the IDC/DIC architecture extensions, which allow us to
         elide instruction and data cache maintenance when writing out
         instructions
    
       - Removal of the large memory model which resulted in suboptimal
         codegen by the compiler and increased the use of literal pools,
         which could potentially be used as ROP gadgets since they are
         mapped as executable
    
       - Rework of forced signal delivery so that the siginfo_t is
         well-formed and handling of show_unhandled_signals is consolidated
         and made consistent between different fault types
    
       - More siginfo cleanup based on the initial patches from Eric
         Biederman
    
       - Workaround for Cortex-A55 erratum #1024718
    
       - Some small ACPI IORT updates and cleanups from Lorenzo Pieralisi
    
       - Misc cleanups and non-critical fixes"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (70 commits)
      arm64: uaccess: Fix omissions from usercopy whitelist
      arm64: fpsimd: Split cpu field out from struct fpsimd_state
      arm64: tlbflush: avoid writing RES0 bits
      arm64: cmpxchg: Include linux/compiler.h in asm/cmpxchg.h
      arm64: move percpu cmpxchg implementation from cmpxchg.h to percpu.h
      arm64: cmpxchg: Include build_bug.h instead of bug.h for BUILD_BUG
      arm64: lse: Include compiler_types.h and export.h for out-of-line LL/SC
      arm64: fpsimd: include <linux/init.h> in fpsimd.h
      drivers/perf: arm_pmu_platform: do not warn about affinity on uniprocessor
      perf: arm_spe: include linux/vmalloc.h for vmap()
      Revert "arm64: Revert L1_CACHE_SHIFT back to 6 (64-byte cache line size)"
      arm64: cpufeature: Avoid warnings due to unused symbols
      arm64: Add work around for Arm Cortex-A55 Erratum 1024718
      arm64: Delay enabling hardware DBM feature
      arm64: Add MIDR encoding for Arm Cortex-A55 and Cortex-A35
      arm64: capabilities: Handle shared entries
      arm64: capabilities: Add support for checks based on a list of MIDRs
      arm64: Add helpers for checking CPU MIDR against a range
      arm64: capabilities: Clean up midr range helpers
      arm64: capabilities: Change scope of VHE to Boot CPU feature
      ...

commit 1212f7a16af492d59304ba3abccbcc5b5e41423e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Mar 1 17:19:01 2018 +0000

    scripts/kallsyms: filter arm64's __efistub_ symbols
    
    On arm64, the EFI stub and the kernel proper are essentially the same
    binary, although the EFI stub executes at a different virtual address
    as the kernel. For this reason, the EFI stub is restricted in the
    symbols it can link to, which is ensured by prefixing all EFI stub
    symbols with __efistub_ (and emitting __efistub_ prefixed aliases for
    routines that may be shared between the core kernel and the stub)
    
    These symbols are leaking into kallsyms, polluting the namespace, so
    let's filter them explicitly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 9ee9bf7fd1a2..1dd24c5b9b47 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -221,6 +221,7 @@ static int symbol_valid(struct sym_entry *s)
 
 	static char *special_prefixes[] = {
 		"__crc_",		/* modversions */
+		"__efistub_",		/* arm64 EFI stub namespace */
 		NULL };
 
 	static char *special_suffixes[] = {

commit cbf7a90e304c4f2e1a867b2245edd408a7a0ed8b
Author: Cao jin <caoj.fnst@cn.fujitsu.com>
Date:   Tue Feb 27 16:16:19 2018 +0800

    kbuild/kallsyms: trivial typo fix
    
    Signed-off-by: Cao jin <caoj.fnst@cn.fujitsu.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 9ee9bf7fd1a2..65792650c630 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -595,7 +595,7 @@ static void optimize_result(void)
 		 * original char code */
 		if (!best_table_len[i]) {
 
-			/* find the token with the breates profit value */
+			/* find the token with the best profit value */
 			best = find_best_token();
 			if (token_profit[best] == 0)
 				break;

commit 51962a9d437f0d580c04cd2c4abc2bd417200da2
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Oct 13 15:57:58 2017 -0700

    scripts/kallsyms.c: ignore symbol type 'n'
    
    gcc on aarch64 may emit synbols of type 'n' if the kernel is built with
    '-frecord-gcc-switches'.  In most cases, those symbols are reported with
    nm as
    
            000000000000000e n $d
    
    and with objdump as
    
            0000000000000000 l    d  .GCC.command.line      0000000000000000 .GCC.command.line
            000000000000000e l       .GCC.command.line      0000000000000000 $d
    
    Those symbols are detected in is_arm_mapping_symbol() and ignored.
    However, if "--prefix-symbols=<prefix>" is configured as well, the
    situation is different.  For example, in efi/libstub, arm64 images are
    built with
    
            '--prefix-alloc-sections=.init --prefix-symbols=__efistub_'.
    
    In combination with '-frecord-gcc-switches', the symbols are now reported
    by nm as:
    
            000000000000000e n __efistub_$d
    and by objdump as:
            0000000000000000 l    d  .GCC.command.line      0000000000000000 .GCC.command.line
            000000000000000e l       .GCC.command.line      0000000000000000 __efistub_$d
    
    Those symbols are no longer ignored and included in the base address
    calculation.  This results in a base address of 000000000000000e, which
    in turn causes kallsyms to abort with
    
        kallsyms failure:
            relative symbol value 0xffffff900800a000 out of range in relative mode
    
    The problem is seen in little endian arm64 builds with CONFIG_EFI
    enabled and with '-frecord-gcc-switches' set in KCFLAGS.
    
    Explicitly ignore symbols of type 'n' since those are clearly debug
    symbols.
    
    Link: http://lkml.kernel.org/r/1507136063-3139-1-git-send-email-linux@roeck-us.net
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 5d554419170b..9ee9bf7fd1a2 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -158,7 +158,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	else if (str[0] == '$')
 		return -1;
 	/* exclude debugging symbols */
-	else if (stype == 'N')
+	else if (stype == 'N' || stype == 'n')
 		return -1;
 
 	/* include the type field in the symbol name, so that it gets

commit 56067812d5b0e737ac2063e94a50f76b810d6ca3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:05 2017 +0000

    kbuild: modversions: add infrastructure for emitting relative CRCs
    
    This add the kbuild infrastructure that will allow architectures to emit
    vmlinux symbol CRCs as 32-bit offsets to another location in the kernel
    where the actual value is stored. This works around problems with CRCs
    being mistaken for relocatable symbols on kernels that self relocate at
    runtime (i.e., powerpc with CONFIG_RELOCATABLE=y)
    
    For the kbuild side of things, this comes down to the following:
    
     - introducing a Kconfig symbol MODULE_REL_CRCS
    
     - adding a -R switch to genksyms to instruct it to emit the CRC symbols
       as references into the .rodata section
    
     - making modpost distinguish such references from absolute CRC symbols
       by the section index (SHN_ABS)
    
     - making kallsyms disregard non-absolute symbols with a __crc_ prefix
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 299b92ca1ae0..5d554419170b 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -219,6 +219,10 @@ static int symbol_valid(struct sym_entry *s)
 		"_SDA2_BASE_",		/* ppc */
 		NULL };
 
+	static char *special_prefixes[] = {
+		"__crc_",		/* modversions */
+		NULL };
+
 	static char *special_suffixes[] = {
 		"_veneer",		/* arm */
 		"_from_arm",		/* arm */
@@ -259,6 +263,14 @@ static int symbol_valid(struct sym_entry *s)
 		if (strcmp(sym_name, special_symbols[i]) == 0)
 			return 0;
 
+	for (i = 0; special_prefixes[i]; i++) {
+		int l = strlen(special_prefixes[i]);
+
+		if (l <= strlen(sym_name) &&
+		    strncmp(sym_name, special_prefixes[i], l) == 0)
+			return 0;
+	}
+
 	for (i = 0; special_suffixes[i]; i++) {
 		int l = strlen(sym_name) - strlen(special_suffixes[i]);
 

commit 0f66784ae2eb6ac5bc7540b891786ff062bbf630
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Oct 28 18:09:05 2016 +0100

    scripts/kallsyms: remove last remnants of --page-offset option
    
    The implementation of the --page-offset kallsyms command line option has
    been removed, so remove it from the usage string as well.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1f22a186c18c..299b92ca1ae0 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -76,7 +76,6 @@ static void usage(void)
 {
 	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
 			"[--symbol-prefix=<prefix char>] "
-			"[--page-offset=<CONFIG_PAGE_OFFSET>] "
 			"[--base-relative] < in.map > out.S\n");
 	exit(1);
 }

commit 2d9586399932dff4746dc25d6498123959d69762
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Mar 29 08:54:47 2016 +0100

    ARM: 8553/1: kallsyms: remove --page-offset command line option
    
    The --page-offset command line option was only used for ARM, to filter
    symbol addresses below CONFIG_PAGE_OFFSET. This is no longer needed, so
    remove the functionality altogether.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Chris Brandt <chris.brandt@renesas.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index e287ce60bb11..1f22a186c18c 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -63,7 +63,6 @@ static unsigned int table_size, table_cnt;
 static int all_symbols = 0;
 static int absolute_percpu = 0;
 static char symbol_prefix_char = '\0';
-static unsigned long long kernel_start_addr = 0;
 static int base_relative = 0;
 
 int token_profit[0x10000];
@@ -230,10 +229,6 @@ static int symbol_valid(struct sym_entry *s)
 	int i;
 	char *sym_name = (char *)s->sym + 1;
 
-
-	if (s->addr < kernel_start_addr)
-		return 0;
-
 	/* skip prefix char */
 	if (symbol_prefix_char && *sym_name == symbol_prefix_char)
 		sym_name++;
@@ -767,9 +762,6 @@ int main(int argc, char **argv)
 				if ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))
 					p++;
 				symbol_prefix_char = *p;
-			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
-				const char *p = &argv[i][14];
-				kernel_start_addr = strtoull(p, NULL, 16);
 			} else if (strcmp(argv[i], "--base-relative") == 0)
 				base_relative = 1;
 			else

commit b9b74be163a247fcbb3ef18086cc27123539131c
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Apr 1 14:33:48 2016 +0100

    ARM: 8555/1: kallsyms: ignore ARM mode switching veneers
    
    On ARM, the linker may emit veneers to deal with relative branch
    instructions that appear too far away from their targets. Since the
    second kallsyms pass results in an increase of the kernel size, it may
    result in additional veneers to be emitted, potentially affecting the
    output of kallsyms itself if these symbols are visible to it, and for
    that reason, symbols whose names end in '_veneer' are ignored explicitly.
    
    However, when building Thumb2 kernels, such veneers are named differently
    if they also incur a mode switch, and since they are not filtered by
    kallsyms, they may cause the build to fail. So filter symbols whose names
    end in '_from_arm' or '_from_thumb' as well.
    
    Tested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 638b143ee60f..e287ce60bb11 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -223,6 +223,8 @@ static int symbol_valid(struct sym_entry *s)
 
 	static char *special_suffixes[] = {
 		"_veneer",		/* arm */
+		"_from_arm",		/* arm */
+		"_from_thumb",		/* arm */
 		NULL };
 
 	int i;

commit 2213e9a66bb87d8344a1256b4ef568220d9587fb
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Mar 15 14:58:19 2016 -0700

    kallsyms: add support for relative offsets in kallsyms address table
    
    Similar to how relative extables are implemented, it is possible to emit
    the kallsyms table in such a way that it contains offsets relative to
    some anchor point in the kernel image rather than absolute addresses.
    
    On 64-bit architectures, it cuts the size of the kallsyms address table
    in half, since offsets between kernel symbols can typically be expressed
    in 32 bits.  This saves several hundreds of kilobytes of permanent
    .rodata on average.  In addition, the kallsyms address table is no
    longer subject to dynamic relocation when CONFIG_RELOCATABLE is in
    effect, so the relocation work done after decompression now doesn't have
    to do relocation updates for all these values.  This saves up to 24
    bytes (i.e., the size of a ELF64 RELA relocation table entry) per value,
    which easily adds up to a couple of megabytes of uncompressed __init
    data on ppc64 or arm64.  Even if these relocation entries typically
    compress well, the combined size reduction of 2.8 MB uncompressed for a
    ppc64_defconfig build (of which 2.4 MB is __init data) results in a ~500
    KB space saving in the compressed image.
    
    Since it is useful for some architectures (like x86) to retain the
    ability to emit absolute values as well, this patch also adds support
    for capturing both absolute and relative values when
    KALLSYMS_ABSOLUTE_PERCPU is in effect, by emitting absolute per-cpu
    addresses as positive 32-bit values, and addresses relative to the
    lowest encountered relative symbol as negative values, which are
    subtracted from the runtime address of this base symbol to produce the
    actual address.
    
    Support for the above is enabled by default for all architectures except
    IA-64 and Tile-GX, whose symbols are too far apart to capture in this
    manner.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Kees Cook <keescook@chromium.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index d39a1eeb080e..638b143ee60f 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -22,6 +22,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <limits.h>
 
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
@@ -43,6 +44,7 @@ struct addr_range {
 };
 
 static unsigned long long _text;
+static unsigned long long relative_base;
 static struct addr_range text_ranges[] = {
 	{ "_stext",     "_etext"     },
 	{ "_sinittext", "_einittext" },
@@ -62,6 +64,7 @@ static int all_symbols = 0;
 static int absolute_percpu = 0;
 static char symbol_prefix_char = '\0';
 static unsigned long long kernel_start_addr = 0;
+static int base_relative = 0;
 
 int token_profit[0x10000];
 
@@ -75,7 +78,7 @@ static void usage(void)
 	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
 			"[--symbol-prefix=<prefix char>] "
 			"[--page-offset=<CONFIG_PAGE_OFFSET>] "
-			"< in.map > out.S\n");
+			"[--base-relative] < in.map > out.S\n");
 	exit(1);
 }
 
@@ -205,6 +208,8 @@ static int symbol_valid(struct sym_entry *s)
 	 */
 	static char *special_symbols[] = {
 		"kallsyms_addresses",
+		"kallsyms_offsets",
+		"kallsyms_relative_base",
 		"kallsyms_num_syms",
 		"kallsyms_names",
 		"kallsyms_markers",
@@ -349,16 +354,48 @@ static void write_src(void)
 
 	printf("\t.section .rodata, \"a\"\n");
 
-	/* Provide proper symbols relocatability by their '_text'
-	 * relativeness.  The symbol names cannot be used to construct
-	 * normal symbol references as the list of symbols contains
-	 * symbols that are declared static and are private to their
-	 * .o files.  This prevents .tmp_kallsyms.o or any other
-	 * object from referencing them.
+	/* Provide proper symbols relocatability by their relativeness
+	 * to a fixed anchor point in the runtime image, either '_text'
+	 * for absolute address tables, in which case the linker will
+	 * emit the final addresses at build time. Otherwise, use the
+	 * offset relative to the lowest value encountered of all relative
+	 * symbols, and emit non-relocatable fixed offsets that will be fixed
+	 * up at runtime.
+	 *
+	 * The symbol names cannot be used to construct normal symbol
+	 * references as the list of symbols contains symbols that are
+	 * declared static and are private to their .o files.  This prevents
+	 * .tmp_kallsyms.o or any other object from referencing them.
 	 */
-	output_label("kallsyms_addresses");
+	if (!base_relative)
+		output_label("kallsyms_addresses");
+	else
+		output_label("kallsyms_offsets");
+
 	for (i = 0; i < table_cnt; i++) {
-		if (!symbol_absolute(&table[i])) {
+		if (base_relative) {
+			long long offset;
+			int overflow;
+
+			if (!absolute_percpu) {
+				offset = table[i].addr - relative_base;
+				overflow = (offset < 0 || offset > UINT_MAX);
+			} else if (symbol_absolute(&table[i])) {
+				offset = table[i].addr;
+				overflow = (offset < 0 || offset > INT_MAX);
+			} else {
+				offset = relative_base - table[i].addr - 1;
+				overflow = (offset < INT_MIN || offset >= 0);
+			}
+			if (overflow) {
+				fprintf(stderr, "kallsyms failure: "
+					"%s symbol value %#llx out of range in relative mode\n",
+					symbol_absolute(&table[i]) ? "absolute" : "relative",
+					table[i].addr);
+				exit(EXIT_FAILURE);
+			}
+			printf("\t.long\t%#x\n", (int)offset);
+		} else if (!symbol_absolute(&table[i])) {
 			if (_text <= table[i].addr)
 				printf("\tPTR\t_text + %#llx\n",
 					table[i].addr - _text);
@@ -371,6 +408,12 @@ static void write_src(void)
 	}
 	printf("\n");
 
+	if (base_relative) {
+		output_label("kallsyms_relative_base");
+		printf("\tPTR\t_text - %#llx\n", _text - relative_base);
+		printf("\n");
+	}
+
 	output_label("kallsyms_num_syms");
 	printf("\tPTR\t%d\n", table_cnt);
 	printf("\n");
@@ -695,6 +738,18 @@ static void make_percpus_absolute(void)
 		}
 }
 
+/* find the minimum non-absolute symbol address */
+static void record_relative_base(void)
+{
+	unsigned int i;
+
+	relative_base = -1ULL;
+	for (i = 0; i < table_cnt; i++)
+		if (!symbol_absolute(&table[i]) &&
+		    table[i].addr < relative_base)
+			relative_base = table[i].addr;
+}
+
 int main(int argc, char **argv)
 {
 	if (argc >= 2) {
@@ -713,7 +768,9 @@ int main(int argc, char **argv)
 			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
 				const char *p = &argv[i][14];
 				kernel_start_addr = strtoull(p, NULL, 16);
-			} else
+			} else if (strcmp(argv[i], "--base-relative") == 0)
+				base_relative = 1;
+			else
 				usage();
 		}
 	} else if (argc != 1)
@@ -722,6 +779,8 @@ int main(int argc, char **argv)
 	read_map(stdin);
 	if (absolute_percpu)
 		make_percpus_absolute();
+	if (base_relative)
+		record_relative_base();
 	sort_symbols();
 	optimize_token_table();
 	write_src();

commit 8c996940b3be9c3ac40ce558c270817e1722a95b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Mar 15 14:58:15 2016 -0700

    kallsyms: don't overload absolute symbol type for percpu symbols
    
    Commit c6bda7c988a5 ("kallsyms: fix percpu vars on x86-64 with
    relocation") overloaded the 'A' (absolute) symbol type to signify that a
    symbol is not subject to dynamic relocation.  However, the original A
    type does not imply that at all, and depending on the version of the
    toolchain, many A type symbols are emitted that are in fact relative to
    the kernel text, i.e., if the kernel is relocated at runtime, these
    symbols should be updated as well.
    
    For instance, on sparc32, the following symbols are emitted as absolute
    (kindly provided by Guenter Roeck):
    
      f035a420 A _etext
      f03d9000 A _sdata
      f03de8c4 A jiffies
      f03f8860 A _edata
      f03fc000 A __init_begin
      f041bdc8 A __init_text_end
      f0423000 A __bss_start
      f0423000 A __init_end
      f044457d A __bss_stop
      f044457d A _end
    
    On x86_64, similar behavior can be observed:
    
      ffffffff81a00000 A __end_rodata_hpage_align
      ffffffff81b19000 A __vvar_page
      ffffffff81d3d000 A _end
    
    Even if only a couple of them pass the symbol range check that results
    in them to be taken into account for the final kallsyms symbol table, it
    is obvious that 'A' does not mean the symbol does not need to be updated
    at relocation time, and overloading its meaning to signify that is
    perhaps not a good idea.
    
    So instead, add a new percpu_absolute member to struct sym_entry, and
    when --absolute-percpu is in effect, use it to record symbols whose
    addresses should be emitted as final values rather than values that
    still require relocation at runtime.  That way, we can drop the check
    against the 'A' type.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Kees Cook <keescook@chromium.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 8fa81e84e295..d39a1eeb080e 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -34,6 +34,7 @@ struct sym_entry {
 	unsigned int len;
 	unsigned int start_pos;
 	unsigned char *sym;
+	unsigned int percpu_absolute;
 };
 
 struct addr_range {
@@ -171,6 +172,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	strcpy((char *)s->sym + 1, str);
 	s->sym[0] = stype;
 
+	s->percpu_absolute = 0;
+
 	/* Record if we've found __per_cpu_start/end. */
 	check_symbol_range(sym, s->addr, &percpu_range, 1);
 
@@ -325,7 +328,7 @@ static int expand_symbol(unsigned char *data, int len, char *result)
 
 static int symbol_absolute(struct sym_entry *s)
 {
-	return toupper(s->sym[0]) == 'A';
+	return s->percpu_absolute;
 }
 
 static void write_src(void)
@@ -681,8 +684,15 @@ static void make_percpus_absolute(void)
 	unsigned int i;
 
 	for (i = 0; i < table_cnt; i++)
-		if (symbol_in_range(&table[i], &percpu_range, 1))
+		if (symbol_in_range(&table[i], &percpu_range, 1)) {
+			/*
+			 * Keep the 'A' override for percpu symbols to
+			 * ensure consistent behavior compared to older
+			 * versions of this tool.
+			 */
 			table[i].sym[0] = 'A';
+			table[i].percpu_absolute = 1;
+		}
 }
 
 int main(int argc, char **argv)

commit 41b585b2ed793db6f02ec87d0026d73382e8180a
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Mar 30 15:20:32 2015 +0200

    Kbuild: kallsyms: drop special handling of pre-3.0 GCC symbols
    
    Since we have required at least GCC v3.2 for some time now, we
    can drop the special handling of the 'gcc[0-9]_compiled.' label
    which is not emitted anymore since GCC v3.0.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index f4b016782f0d..8fa81e84e295 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -214,7 +214,6 @@ static int symbol_valid(struct sym_entry *s)
 		NULL };
 
 	static char *special_suffixes[] = {
-		"_compiled.",		/* gcc < 3.0: "gcc[0-9]_compiled." */
 		"_veneer",		/* arm */
 		NULL };
 

commit bd8b22d2888e75063c9012b95341d6cb36456434
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Mar 30 15:20:31 2015 +0200

    Kbuild: kallsyms: ignore veneers emitted by the ARM linker
    
    When linking large kernels on ARM, the linker will insert veneers
    (i.e., PLT like stubs) when function symbols are out of reach for
    the ordinary relative branch/branch-and-link instructions.
    
    However, due to the fact that the kallsyms region sits in .rodata,
    which is between .text and .init.text, additional veneers may be
    emitted in the second pass due to the fact that the size of the
    kallsyms region itself has pushed the .init.text section further
    apart, requiring even more veneers.
    
    So ignore the veneers when generating the symbol table. Veneers
    have no corresponding source code, and they will not turn up in
    backtraces anyway.
    
    This patch also lightly refactors the symbol_valid() function
    to use a local 'sym_name' rather than the obfuscated 'sym + 1'
    and 'sym + offset'
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index c6d33bd15b04..f4b016782f0d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -212,15 +212,23 @@ static int symbol_valid(struct sym_entry *s)
 		"_SDA_BASE_",		/* ppc */
 		"_SDA2_BASE_",		/* ppc */
 		NULL };
+
+	static char *special_suffixes[] = {
+		"_compiled.",		/* gcc < 3.0: "gcc[0-9]_compiled." */
+		"_veneer",		/* arm */
+		NULL };
+
 	int i;
-	int offset = 1;
+	char *sym_name = (char *)s->sym + 1;
+
 
 	if (s->addr < kernel_start_addr)
 		return 0;
 
 	/* skip prefix char */
-	if (symbol_prefix_char && *(s->sym + 1) == symbol_prefix_char)
-		offset++;
+	if (symbol_prefix_char && *sym_name == symbol_prefix_char)
+		sym_name++;
+
 
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
@@ -235,22 +243,26 @@ static int symbol_valid(struct sym_entry *s)
 		 * rules.
 		 */
 		if ((s->addr == text_range_text->end &&
-				strcmp((char *)s->sym + offset,
+				strcmp(sym_name,
 				       text_range_text->end_sym)) ||
 		    (s->addr == text_range_inittext->end &&
-				strcmp((char *)s->sym + offset,
+				strcmp(sym_name,
 				       text_range_inittext->end_sym)))
 			return 0;
 	}
 
 	/* Exclude symbols which vary between passes. */
-	if (strstr((char *)s->sym + offset, "_compiled."))
-		return 0;
-
 	for (i = 0; special_symbols[i]; i++)
-		if( strcmp((char *)s->sym + offset, special_symbols[i]) == 0 )
+		if (strcmp(sym_name, special_symbols[i]) == 0)
 			return 0;
 
+	for (i = 0; special_suffixes[i]; i++) {
+		int l = strlen(sym_name) - strlen(special_suffixes[i]);
+
+		if (l >= 0 && strcmp(sym_name + l, special_suffixes[i]) == 0)
+			return 0;
+	}
+
 	return 1;
 }
 

commit 6c34f1f5424395994c125f8c68bed395920ecc58
Author: Kyle McMartin <kyle@redhat.com>
Date:   Tue Sep 16 22:37:18 2014 +0100

    aarch64: filter $x from kallsyms
    
    Similar to ARM, AArch64 is generating $x and $d syms... which isn't
    terribly helpful when looking at %pF output and the like. Filter those
    out in kallsyms, modpost and when looking at module symbols.
    
    Seems simplest since none of these check EM_ARM anyway, to just add it
    to the strchr used, rather than trying to make things overly
    complicated.
    
    initcall_debug improves:
    dmesg_before.txt: initcall $x+0x0/0x154 [sg] returned 0 after 26331 usecs
    dmesg_after.txt: initcall init_sg+0x0/0x154 [sg] returned 0 after 15461 usecs
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index dc7aa45e80ce..c6d33bd15b04 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -84,7 +84,7 @@ static void usage(void)
  */
 static inline int is_arm_mapping_symbol(const char *str)
 {
-	return str[0] == '$' && strchr("atd", str[1])
+	return str[0] == '$' && strchr("axtd", str[1])
 	       && (str[2] == '\0' || str[2] == '.');
 }
 

commit bb66fc67192bbd406fe9c22033f1bbbf3e7ec621
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jun 10 19:08:13 2014 +0900

    kbuild: trivial - use tabs for code indent where possible
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1237dd7fb4ca..dc7aa45e80ce 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -123,7 +123,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	}
 	if (strlen(str) > KSYM_NAME_LEN) {
 		fprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"
-                                "Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
+				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
 			str, strlen(str), KSYM_NAME_LEN);
 		return -1;
 	}

commit c6bda7c988a57958108741cde9b1f12e9727a938
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 17 14:05:46 2014 +1030

    kallsyms: fix percpu vars on x86-64 with relocation.
    
    x86-64 has a problem: per-cpu variables are actually represented by
    their absolute offsets within the per-cpu area, but the symbols are
    not emitted as absolute.  Thus kallsyms naively creates them as offsets
    from _text, meaning their values change if the kernel is relocated
    (especially noticeable with CONFIG_RANDOMIZE_BASE):
    
     $ egrep ' (gdt_|_(stext|_per_cpu_))' /root/kallsyms.nokaslr
     0000000000000000 D __per_cpu_start
     0000000000004000 D gdt_page
     0000000000014280 D __per_cpu_end
     ffffffff810001c8 T _stext
     ffffffff81ee53c0 D __per_cpu_offset
     $ egrep ' (gdt_|_(stext|_per_cpu_))' /root/kallsyms.kaslr1
     000000001f200000 D __per_cpu_start
     000000001f204000 D gdt_page
     000000001f214280 D __per_cpu_end
     ffffffffa02001c8 T _stext
     ffffffffa10e53c0 D __per_cpu_offset
    
    Making them absolute symbols is the Right Thing, but requires fixes to
    the relocs tool.  So for the moment, we add a --absolute-percpu option
    which makes them absolute from a kallsyms perspective:
    
     $ egrep ' (gdt_|_(stext|_per_cpu_))' /proc/kallsyms # no KASLR
     0000000000000000 A __per_cpu_start
     000000000000a000 A gdt_page
     0000000000013040 A __per_cpu_end
     ffffffff802001c8 T _stext
     ffffffff8099b180 D __per_cpu_offset
     ffffffff809a3000 D __per_cpu_load
     $ egrep ' (gdt_|_(stext|_per_cpu_))' /proc/kallsyms # With KASLR
     0000000000000000 A __per_cpu_start
     000000000000a000 A gdt_page
     0000000000013040 A __per_cpu_end
     ffffffff89c001c8 T _stext
     ffffffff8a39d180 D __per_cpu_offset
     ffffffff8a3a5000 D __per_cpu_load
    
    Based-on-the-original-screenplay-by: Andy Honig <ahonig@google.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 3df15f5e7c55..1237dd7fb4ca 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -51,9 +51,14 @@ static struct addr_range text_ranges[] = {
 #define text_range_text     (&text_ranges[0])
 #define text_range_inittext (&text_ranges[1])
 
+static struct addr_range percpu_range = {
+	"__per_cpu_start", "__per_cpu_end", -1ULL, 0
+};
+
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
 static int all_symbols = 0;
+static int absolute_percpu = 0;
 static char symbol_prefix_char = '\0';
 static unsigned long long kernel_start_addr = 0;
 
@@ -166,6 +171,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	strcpy((char *)s->sym + 1, str);
 	s->sym[0] = stype;
 
+	/* Record if we've found __per_cpu_start/end. */
+	check_symbol_range(sym, s->addr, &percpu_range, 1);
+
 	return 0;
 }
 
@@ -657,6 +665,15 @@ static void sort_symbols(void)
 	qsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);
 }
 
+static void make_percpus_absolute(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < table_cnt; i++)
+		if (symbol_in_range(&table[i], &percpu_range, 1))
+			table[i].sym[0] = 'A';
+}
+
 int main(int argc, char **argv)
 {
 	if (argc >= 2) {
@@ -664,6 +681,8 @@ int main(int argc, char **argv)
 		for (i = 1; i < argc; i++) {
 			if(strcmp(argv[i], "--all-symbols") == 0)
 				all_symbols = 1;
+			else if (strcmp(argv[i], "--absolute-percpu") == 0)
+				absolute_percpu = 1;
 			else if (strncmp(argv[i], "--symbol-prefix=", 16) == 0) {
 				char *p = &argv[i][16];
 				/* skip quote */
@@ -680,6 +699,8 @@ int main(int argc, char **argv)
 		usage();
 
 	read_map(stdin);
+	if (absolute_percpu)
+		make_percpus_absolute();
 	sort_symbols();
 	optimize_token_table();
 	write_src();

commit 78eb71594b3265f3cfe871480235be158feebd0f
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Mar 17 13:18:27 2014 +1030

    kallsyms: generalize address range checking
    
    This refactors the address range checks to be generalized instead of
    specific to text range checks, in preparation for other range checks.
    Also extracts logic for "is the symbol absolute" into a function.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 10085de886fe..3df15f5e7c55 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -36,13 +36,13 @@ struct sym_entry {
 	unsigned char *sym;
 };
 
-struct text_range {
-	const char *stext, *etext;
+struct addr_range {
+	const char *start_sym, *end_sym;
 	unsigned long long start, end;
 };
 
 static unsigned long long _text;
-static struct text_range text_ranges[] = {
+static struct addr_range text_ranges[] = {
 	{ "_stext",     "_etext"     },
 	{ "_sinittext", "_einittext" },
 	{ "_stext_l1",  "_etext_l1"  },	/* Blackfin on-chip L1 inst SRAM */
@@ -83,19 +83,20 @@ static inline int is_arm_mapping_symbol(const char *str)
 	       && (str[2] == '\0' || str[2] == '.');
 }
 
-static int read_symbol_tr(const char *sym, unsigned long long addr)
+static int check_symbol_range(const char *sym, unsigned long long addr,
+			      struct addr_range *ranges, int entries)
 {
 	size_t i;
-	struct text_range *tr;
+	struct addr_range *ar;
 
-	for (i = 0; i < ARRAY_SIZE(text_ranges); ++i) {
-		tr = &text_ranges[i];
+	for (i = 0; i < entries; ++i) {
+		ar = &ranges[i];
 
-		if (strcmp(sym, tr->stext) == 0) {
-			tr->start = addr;
+		if (strcmp(sym, ar->start_sym) == 0) {
+			ar->start = addr;
 			return 0;
-		} else if (strcmp(sym, tr->etext) == 0) {
-			tr->end = addr;
+		} else if (strcmp(sym, ar->end_sym) == 0) {
+			ar->end = addr;
 			return 0;
 		}
 	}
@@ -130,7 +131,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(sym, "_text") == 0)
 		_text = s->addr;
-	else if (read_symbol_tr(sym, s->addr) == 0)
+	else if (check_symbol_range(sym, s->addr, text_ranges,
+				    ARRAY_SIZE(text_ranges)) == 0)
 		/* nothing to do */;
 	else if (toupper(stype) == 'A')
 	{
@@ -167,15 +169,16 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	return 0;
 }
 
-static int symbol_valid_tr(struct sym_entry *s)
+static int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,
+			   int entries)
 {
 	size_t i;
-	struct text_range *tr;
+	struct addr_range *ar;
 
-	for (i = 0; i < ARRAY_SIZE(text_ranges); ++i) {
-		tr = &text_ranges[i];
+	for (i = 0; i < entries; ++i) {
+		ar = &ranges[i];
 
-		if (s->addr >= tr->start && s->addr <= tr->end)
+		if (s->addr >= ar->start && s->addr <= ar->end)
 			return 1;
 	}
 
@@ -214,7 +217,8 @@ static int symbol_valid(struct sym_entry *s)
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
-		if (symbol_valid_tr(s) == 0)
+		if (symbol_in_range(s, text_ranges,
+				    ARRAY_SIZE(text_ranges)) == 0)
 			return 0;
 		/* Corner case.  Discard any symbols with the same value as
 		 * _etext _einittext; they can move between pass 1 and 2 when
@@ -223,9 +227,11 @@ static int symbol_valid(struct sym_entry *s)
 		 * rules.
 		 */
 		if ((s->addr == text_range_text->end &&
-				strcmp((char *)s->sym + offset, text_range_text->etext)) ||
+				strcmp((char *)s->sym + offset,
+				       text_range_text->end_sym)) ||
 		    (s->addr == text_range_inittext->end &&
-				strcmp((char *)s->sym + offset, text_range_inittext->etext)))
+				strcmp((char *)s->sym + offset,
+				       text_range_inittext->end_sym)))
 			return 0;
 	}
 
@@ -298,6 +304,11 @@ static int expand_symbol(unsigned char *data, int len, char *result)
 	return total;
 }
 
+static int symbol_absolute(struct sym_entry *s)
+{
+	return toupper(s->sym[0]) == 'A';
+}
+
 static void write_src(void)
 {
 	unsigned int i, k, off;
@@ -325,7 +336,7 @@ static void write_src(void)
 	 */
 	output_label("kallsyms_addresses");
 	for (i = 0; i < table_cnt; i++) {
-		if (toupper(table[i].sym[0]) != 'A') {
+		if (!symbol_absolute(&table[i])) {
 			if (_text <= table[i].addr)
 				printf("\tPTR\t_text + %#llx\n",
 					table[i].addr - _text);

commit 2930ffc7593b64fe00fd7c5a0a7f543078d73ed9
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Mar 10 15:49:48 2014 -0700

    revert "kallsyms: fix absolute addresses for kASLR"
    
    Revert the recently applied 0f55159d091c ("kallsyms: fix absolute
    addresses for kASLR").  Kees said
    
    : This got NAKed, please don't apply -- this patch works for x86 and
    : ARM, but may cause problems for others:
    :
    : https://lkml.org/lkml/2014/2/24/718
    
    It appears that Kees will be fixing all this up for 3.15.
    
    Cc: Andy Honig <ahonig@google.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 276e84b8a8e5..10085de886fe 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -330,7 +330,8 @@ static void write_src(void)
 				printf("\tPTR\t_text + %#llx\n",
 					table[i].addr - _text);
 			else
-				printf("\tPTR\t%#llx\n", table[i].addr);
+				printf("\tPTR\t_text - %#llx\n",
+					_text - table[i].addr);
 		} else {
 			printf("\tPTR\t%#llx\n", table[i].addr);
 		}

commit 0f55159d091cb1e555ee52abc1b2455f301b99a8
Author: Andy Honig <ahonig@google.com>
Date:   Mon Mar 3 15:38:30 2014 -0800

    kallsyms: fix absolute addresses for kASLR
    
    Currently symbols that are absolute addresses are incorrectly displayed
    in /proc/kallsyms if the kernel is loaded with kASLR.
    
    The problem was that the scripts/kallsyms.c file which generates the
    array of symbol names and addresses uses an relocatable value for all
    symbols, even absolute symbols.  This patch fixes that.
    
    Several kallsyms output in different boot states for comparison:
    
      $ egrep '_(stext|_per_cpu_(start|end))' /root/kallsyms.nokaslr
      0000000000000000 D __per_cpu_start
      0000000000014280 D __per_cpu_end
      ffffffff810001c8 T _stext
      $ egrep '_(stext|_per_cpu_(start|end))' /root/kallsyms.kaslr1
      000000001f200000 D __per_cpu_start
      000000001f214280 D __per_cpu_end
      ffffffffa02001c8 T _stext
      $ egrep '_(stext|_per_cpu_(start|end))' /root/kallsyms.kaslr2
      000000000d400000 D __per_cpu_start
      000000000d414280 D __per_cpu_end
      ffffffff8e4001c8 T _stext
      $ egrep '_(stext|_per_cpu_(start|end))' /root/kallsyms.kaslr-fixed
      0000000000000000 D __per_cpu_start
      0000000000014280 D __per_cpu_end
      ffffffffadc001c8 T _stext
    
    Signed-off-by: Andy Honig <ahonig@google.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 10085de886fe..276e84b8a8e5 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -330,8 +330,7 @@ static void write_src(void)
 				printf("\tPTR\t_text + %#llx\n",
 					table[i].addr - _text);
 			else
-				printf("\tPTR\t_text - %#llx\n",
-					_text - table[i].addr);
+				printf("\tPTR\t%#llx\n", table[i].addr);
 		} else {
 			printf("\tPTR\t%#llx\n", table[i].addr);
 		}

commit 762fb1ddd561aac5b14afac19287672b99242811
Merge: f13399f033ae 480f439c3db0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 14:06:38 2013 -0800

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild changes from Michal Marek:
     - LTO fixes, but the kallsyms part had to be reverted
     - Pass -Werror=implicit-int and -Werror=strict-prototypes to the
       compiler by default
     - snprintf fix in modpost
     - remove GREP_OPTIONS from the environment to be immune against exotic
       grep option settings
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      kallsyms: Revert back to 128 max symbol length
      Kbuild: Ignore GREP_OPTIONS env variable
      scripts: kallsyms: Use %zu to print 'size_t'
      scripts/bloat-o-meter: use .startswith rather than fragile slicing
      scripts/bloat-o-meter: ignore changes in the size of linux_banner
      kbuild: replace unbounded sprintf call in modpost
      kbuild, bloat-o-meter: fix static detection
      Kbuild: Handle longer symbols in kallsyms.c
      kbuild: Increase kallsyms max symbol length
      Makefile: enable -Werror=implicit-int and -Werror=strict-prototypes by default

commit 480f439c3db0d45d817d66caf3fa8e81a6fac01a
Author: Michal Marek <mmarek@suse.cz>
Date:   Mon Nov 11 14:23:08 2013 +0100

    kallsyms: Revert back to 128 max symbol length
    
    This reverts commits
    f3462aa (Kbuild: Handle longer symbols in kallsyms.c) and
    eea0e9c (kbuild: Increase kallsyms max symbol length)
    except for the added overflow check. The reason is a regression caused
    by increasing the buffer:
    http://marc.info/?l=linux-kernel&m=138387700415675.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Joe Mario <jmario@redhat.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 48afa2020b00..518da86ce62a 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -27,7 +27,7 @@
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
 #endif
 
-#define KSYM_NAME_LEN		255
+#define KSYM_NAME_LEN		128
 
 struct sym_entry {
 	unsigned long long addr;

commit 6f62259b1a7696a335d5c3f2c89cce1d28912bf2
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Fri Nov 8 00:45:01 2013 -0200

    scripts: kallsyms: Use %zu to print 'size_t'
    
    Commit f3462aa95 (Kbuild: Handle longer symbols in kallsyms.c) introduced the
    following warning on ARM:
    
    scripts/kallsyms.c:121:4: warning: format '%lu' expects argument of type 'long unsigned int', but argument 4 has type 'size_t' [-Wformat]
    
    Use %zu to print 'size_t'.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 967522ab4f39..48afa2020b00 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -112,7 +112,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		return -1;
 	}
 	if (strlen(str) > KSYM_NAME_LEN) {
-		fprintf(stderr, "Symbol %s too long for kallsyms (%lu vs %d).\n"
+		fprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"
                                 "Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
 			str, strlen(str), KSYM_NAME_LEN);
 		return -1;

commit f3462aa952cfc8f4b095103cb9b3d306dd216558
Author: Andi Kleen <andi@firstfloor.org>
Date:   Wed Oct 23 15:07:53 2013 +0200

    Kbuild: Handle longer symbols in kallsyms.c
    
    Also warn for too long symbols
    
    v2: Add missing newline. Use 255 max (Joe Perches)
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 487ac6f37ca2..967522ab4f39 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -27,7 +27,7 @@
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
 #endif
 
-#define KSYM_NAME_LEN		128
+#define KSYM_NAME_LEN		255
 
 struct sym_entry {
 	unsigned long long addr;
@@ -111,6 +111,12 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 			fprintf(stderr, "Read error or end of file.\n");
 		return -1;
 	}
+	if (strlen(str) > KSYM_NAME_LEN) {
+		fprintf(stderr, "Symbol %s too long for kallsyms (%lu vs %d).\n"
+                                "Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
+			str, strlen(str), KSYM_NAME_LEN);
+		return -1;
+	}
 
 	sym = str;
 	/* skip prefix char */

commit f6537f2f0eba4eba3354e48dbe3047db6d8b6254
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sat Nov 2 09:11:33 2013 +1030

    scripts/kallsyms: filter symbols not in kernel address space
    
    This patch uses CONFIG_PAGE_OFFSET to filter symbols which
    are not in kernel address space because these symbols are
    generally for generating code purpose and can't be run at
    kernel mode, so we needn't keep them in /proc/kallsyms.
    
    For example, on ARM there are some symbols which may be
    linked in relocatable code section, then perf can't parse
    symbols any more from /proc/kallsyms, this patch fixes the
    problem (introduced b9b32bf70f2fb710b07c94e13afbc729afe221da)
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: stable@vger.kernel.org

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 487ac6f37ca2..9a11f9f799f4 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -55,6 +55,7 @@ static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
+static unsigned long long kernel_start_addr = 0;
 
 int token_profit[0x10000];
 
@@ -65,7 +66,10 @@ unsigned char best_table_len[256];
 
 static void usage(void)
 {
-	fprintf(stderr, "Usage: kallsyms [--all-symbols] [--symbol-prefix=<prefix char>] < in.map > out.S\n");
+	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
+			"[--symbol-prefix=<prefix char>] "
+			"[--page-offset=<CONFIG_PAGE_OFFSET>] "
+			"< in.map > out.S\n");
 	exit(1);
 }
 
@@ -194,6 +198,9 @@ static int symbol_valid(struct sym_entry *s)
 	int i;
 	int offset = 1;
 
+	if (s->addr < kernel_start_addr)
+		return 0;
+
 	/* skip prefix char */
 	if (symbol_prefix_char && *(s->sym + 1) == symbol_prefix_char)
 		offset++;
@@ -646,6 +653,9 @@ int main(int argc, char **argv)
 				if ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))
 					p++;
 				symbol_prefix_char = *p;
+			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
+				const char *p = &argv[i][14];
+				kernel_start_addr = strtoull(p, NULL, 16);
 			} else
 				usage();
 		}

commit e0a04b11e4059cab033469617c2a3ce2d8cab416
Author: Xiaochen Wang <wangxiaochen0@gmail.com>
Date:   Sun May 1 11:41:41 2011 +0800

    scripts/kallsyms.c: fix potential segfault
    
    Description:
    This bug hardly appears during real kernel compiling,
     because the vmlinux symbols table is huge.
    
    But we can still catch it under strict condition , as follows.
       $ echo "c101b97b T do_fork" | ./scripts/kallsyms --all-symbols
       #include <asm/types.h>
       ......
       ......
       .globl kallsyms_token_table
               ALGN
       kallsyms_token_table:
       Segmentation fault (core dumped)
       $
    
    If symbols table is small, all entries in token_profit[0x10000] may
    decrease to 0 after several calls of compress_symbols() in optimize_result().
    In that case, find_best_token() always return 0 and
    best_table[i] is set to "\0\0" and best_table_len[i] is set to 2.
    
    As a result, expand_symbol(best_table[0]="\0\0", best_table_len[0]=2, buf)
    in write_src() will run in infinite recursion until stack overflows,
    causing segfault.
    
    This patch checks the find_best_token() return value. If all entries in
    token_profit[0x10000] become 0 according to return value, it breaks the loop
    in optimize_result().
    And expand_symbol() works well when best_table_len[i] is 0.
    
    Signed-off-by: Xiaochen Wang <wangxiaochen0@gmail.com>
    Acked-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 60dd3eb9366e..487ac6f37ca2 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -500,6 +500,8 @@ static void optimize_result(void)
 
 			/* find the token with the breates profit value */
 			best = find_best_token();
+			if (token_profit[best] == 0)
+				break;
 
 			/* place it in the "best" table */
 			best_table_len[i] = 2;

commit ef894870c6c38580e540c29cfb22a827d54a950a
Author: Jean Sacren <sakiwit@gmail.com>
Date:   Fri Sep 10 23:13:33 2010 -0600

    scripts/kallsyms: Enable error messages while hush up unnecessary warnings
    
    As no error was handled, we wouldn't be able to know when an error does
    occur. The fix preserves error messages while it doesn't let unnecessary
    compiling warnings show up.
    
    Signed-off-by: Jean Sacren <sakiwit@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index e3902fb39afd..60dd3eb9366e 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -107,12 +107,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 
 	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
 	if (rc != 3) {
-		if (rc != EOF) {
-			/* skip line. sym is used as dummy to
-			 * shut of "warn_unused_result" warning.
-			 */
-			sym = fgets(str, 500, in);
-		}
+		if (rc != EOF && fgets(str, 500, in) == NULL)
+			fprintf(stderr, "Read error or end of file.\n");
 		return -1;
 	}
 

commit 71d41aed9468a1239cff1b2d928954885b09de6c
Author: Himanshu Chauhan <hschauhan@nulltrace.org>
Date:   Wed Jan 27 16:53:20 2010 -0800

    scripts/kallsyms: suppress build warning
    
    Suppress a warn_unused_result warning.
    
    fgets is called as a part of error handling.  It is called just to drop a
    line and return immediately.  read_map is reading the file in a loop and
    read_symbol reads line by line.  So I think there is no point in using
    return value for useful checking.  Other checks like 3 items were returned
    or !EOF have already been done.
    
    Signed-off-by: Himanshu Chauhan <hschauhan@nulltrace.org>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 86c3896a1e01..e3902fb39afd 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -108,8 +108,10 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
 	if (rc != 3) {
 		if (rc != EOF) {
-			/* skip line */
-			fgets(str, 500, in);
+			/* skip line. sym is used as dummy to
+			 * shut of "warn_unused_result" warning.
+			 */
+			sym = fgets(str, 500, in);
 		}
 		return -1;
 	}

commit a9ece53c4089ef23d4002d34c4c7148d94622a40
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 22 16:44:12 2009 -0700

    kallsyms: fix segfault in prefix_underscores_count()
    
    Commit b478b782e110fdb4135caa3062b6d687e989d994 "kallsyms, tracing: output
    more proper symbol name" introduces a "bugfix" that introduces a segfault
    in kallsyms in my configurations.
    
    The cause is the introduction of prefix_underscores_count() which attempts
    to count underscores, even in symbols that do not have them.  As a result,
    it just uselessly runs past the end of the buffer until it crashes:
    
      CC      init/version.o
      LD      init/built-in.o
      LD      .tmp_vmlinux1
      KSYM    .tmp_kallsyms1.S
    /bin/sh: line 1: 16934 Done                    sh-linux-gnu-nm -n .tmp_vmlinux1
         16935 Segmentation fault      | scripts/kallsyms > .tmp_kallsyms1.S
    make: *** [.tmp_kallsyms1.S] Error 139
    
    This simplifies the logic and just does a straightforward count.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Reviewed-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Paulo Marques <pmarques@grupopie.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: <stable@kernel.org>         [2.6.30.x, 2.6.31.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 64343cc084b4..86c3896a1e01 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -585,7 +585,7 @@ static int prefix_underscores_count(const char *str)
 {
 	const char *tail = str;
 
-	while (*tail != '_')
+	while (*tail == '_')
 		tail++;
 
 	return tail - str;

commit ac6ca5c86c63dd95acc6a34dff8d33c23b703a37
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Mon Jun 15 07:52:48 2009 -0400

    kallsyms: fix inverted valid symbol checking
    
    The previous commit (17b1f0de) introduced a slightly broken consolidation
    of the memory text range checking.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 3cb57895c9ea..64343cc084b4 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -167,11 +167,11 @@ static int symbol_valid_tr(struct sym_entry *s)
 	for (i = 0; i < ARRAY_SIZE(text_ranges); ++i) {
 		tr = &text_ranges[i];
 
-		if (s->addr >= tr->start && s->addr < tr->end)
-			return 0;
+		if (s->addr >= tr->start && s->addr <= tr->end)
+			return 1;
 	}
 
-	return 1;
+	return 0;
 }
 
 static int symbol_valid(struct sym_entry *s)

commit 17b1f0de79dbdf5cfb2686b63a7fb9ecc440da7c
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Mon Jun 8 19:12:13 2009 -0400

    kallsyms: generalize text region handling
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index fb82a5b49809..3cb57895c9ea 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -23,6 +23,10 @@
 #include <string.h>
 #include <ctype.h>
 
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
+#endif
+
 #define KSYM_NAME_LEN		128
 
 struct sym_entry {
@@ -32,10 +36,23 @@ struct sym_entry {
 	unsigned char *sym;
 };
 
+struct text_range {
+	const char *stext, *etext;
+	unsigned long long start, end;
+};
+
+static unsigned long long _text;
+static struct text_range text_ranges[] = {
+	{ "_stext",     "_etext"     },
+	{ "_sinittext", "_einittext" },
+	{ "_stext_l1",  "_etext_l1"  },	/* Blackfin on-chip L1 inst SRAM */
+	{ "_stext_l2",  "_etext_l2"  },	/* Blackfin on-chip L2 SRAM */
+};
+#define text_range_text     (&text_ranges[0])
+#define text_range_inittext (&text_ranges[1])
+
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
-static unsigned long long _text, _stext, _etext, _sinittext, _einittext;
-static unsigned long long _stext_l1, _etext_l1, _stext_l2, _etext_l2;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
@@ -62,6 +79,26 @@ static inline int is_arm_mapping_symbol(const char *str)
 	       && (str[2] == '\0' || str[2] == '.');
 }
 
+static int read_symbol_tr(const char *sym, unsigned long long addr)
+{
+	size_t i;
+	struct text_range *tr;
+
+	for (i = 0; i < ARRAY_SIZE(text_ranges); ++i) {
+		tr = &text_ranges[i];
+
+		if (strcmp(sym, tr->stext) == 0) {
+			tr->start = addr;
+			return 0;
+		} else if (strcmp(sym, tr->etext) == 0) {
+			tr->end = addr;
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
 static int read_symbol(FILE *in, struct sym_entry *s)
 {
 	char str[500];
@@ -85,22 +122,8 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	/* Ignore most absolute/undefined (?) symbols. */
 	if (strcmp(sym, "_text") == 0)
 		_text = s->addr;
-	else if (strcmp(sym, "_stext") == 0)
-		_stext = s->addr;
-	else if (strcmp(sym, "_etext") == 0)
-		_etext = s->addr;
-	else if (strcmp(sym, "_sinittext") == 0)
-		_sinittext = s->addr;
-	else if (strcmp(sym, "_einittext") == 0)
-		_einittext = s->addr;
-	else if (strcmp(sym, "_stext_l1") == 0)
-		_stext_l1 = s->addr;
-	else if (strcmp(sym, "_etext_l1") == 0)
-		_etext_l1 = s->addr;
-	else if (strcmp(sym, "_stext_l2") == 0)
-		_stext_l2 = s->addr;
-	else if (strcmp(sym, "_etext_l2") == 0)
-		_etext_l2 = s->addr;
+	else if (read_symbol_tr(sym, s->addr) == 0)
+		/* nothing to do */;
 	else if (toupper(stype) == 'A')
 	{
 		/* Keep these useful absolute symbols */
@@ -136,6 +159,21 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	return 0;
 }
 
+static int symbol_valid_tr(struct sym_entry *s)
+{
+	size_t i;
+	struct text_range *tr;
+
+	for (i = 0; i < ARRAY_SIZE(text_ranges); ++i) {
+		tr = &text_ranges[i];
+
+		if (s->addr >= tr->start && s->addr < tr->end)
+			return 0;
+	}
+
+	return 1;
+}
+
 static int symbol_valid(struct sym_entry *s)
 {
 	/* Symbols which vary between passes.  Passes 1 and 2 must have
@@ -165,10 +203,7 @@ static int symbol_valid(struct sym_entry *s)
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
-		if ((s->addr < _stext || s->addr > _etext)
-		    && (s->addr < _sinittext || s->addr > _einittext)
-		    && (s->addr < _stext_l1 || s->addr > _etext_l1)
-		    && (s->addr < _stext_l2 || s->addr > _etext_l2))
+		if (symbol_valid_tr(s) == 0)
 			return 0;
 		/* Corner case.  Discard any symbols with the same value as
 		 * _etext _einittext; they can move between pass 1 and 2 when
@@ -176,10 +211,10 @@ static int symbol_valid(struct sym_entry *s)
 		 * they may get dropped in pass 2, which breaks the kallsyms
 		 * rules.
 		 */
-		if ((s->addr == _etext &&
-				strcmp((char *)s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext &&
-				strcmp((char *)s->sym + offset, "_einittext")))
+		if ((s->addr == text_range_text->end &&
+				strcmp((char *)s->sym + offset, text_range_text->etext)) ||
+		    (s->addr == text_range_inittext->end &&
+				strcmp((char *)s->sym + offset, text_range_inittext->etext)))
 			return 0;
 	}
 

commit 028f042613c3c99db20dd7f4e4069fbbcea92dd7
Author: Robin Getz <robin.getz@analog.com>
Date:   Mon Jul 10 06:25:40 2006 +0000

    kallsyms: support kernel symbols in Blackfin on-chip memory
    
    The Blackfin arch has a discontiguous .text layout due to having on-chip
    instruction memory and no virtual memory support.  As such, we need to
    add explicit checks for these additional .text regions.
    
    Signed-off-by: Robin Getz <robin.getz@analog.com>
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 6654cbed965b..fb82a5b49809 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -35,6 +35,7 @@ struct sym_entry {
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
 static unsigned long long _text, _stext, _etext, _sinittext, _einittext;
+static unsigned long long _stext_l1, _etext_l1, _stext_l2, _etext_l2;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
@@ -92,6 +93,14 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		_sinittext = s->addr;
 	else if (strcmp(sym, "_einittext") == 0)
 		_einittext = s->addr;
+	else if (strcmp(sym, "_stext_l1") == 0)
+		_stext_l1 = s->addr;
+	else if (strcmp(sym, "_etext_l1") == 0)
+		_etext_l1 = s->addr;
+	else if (strcmp(sym, "_stext_l2") == 0)
+		_stext_l2 = s->addr;
+	else if (strcmp(sym, "_etext_l2") == 0)
+		_etext_l2 = s->addr;
 	else if (toupper(stype) == 'A')
 	{
 		/* Keep these useful absolute symbols */
@@ -157,7 +166,9 @@ static int symbol_valid(struct sym_entry *s)
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
 		if ((s->addr < _stext || s->addr > _etext)
-		    && (s->addr < _sinittext || s->addr > _einittext))
+		    && (s->addr < _sinittext || s->addr > _einittext)
+		    && (s->addr < _stext_l1 || s->addr > _etext_l1)
+		    && (s->addr < _stext_l2 || s->addr > _etext_l2))
 			return 0;
 		/* Corner case.  Discard any symbols with the same value as
 		 * _etext _einittext; they can move between pass 1 and 2 when

commit b478b782e110fdb4135caa3062b6d687e989d994
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Fri Mar 13 15:10:26 2009 +0800

    kallsyms, tracing: output more proper symbol name
    
    Impact: bugfix, output more reliable symbol lookup result
    
    Debug tools(dump_stack(), ftrace...) are like to print out symbols.
    But it is always print out the first aliased symbol.(Aliased symbols
    are symbols with the same address), and the first aliased symbol is
    sometime not proper.
    
     # echo function_graph > current_tracer
     # cat trace
    ......
     1)   1.923 us    |    select_nohz_load_balancer();
     1) + 76.692 us   |  }
     1)               |  default_idle() {
     1)   ==========> |    __irqentry_text_start() {
     1)   0.000 us    |      native_apic_mem_write();
     1)               |      irq_enter() {
     1)   0.000 us    |        idle_cpu();
     1)               |        tick_check_idle() {
     1)   0.000 us    |          tick_check_oneshot_broadcast();
     1)               |          tick_nohz_stop_idle() {
    ......
    
    It's very embarrassing, it ouputs "__irqentry_text_start()",
    actually, it should output "smp_apic_timer_interrupt()".
    (these two symbol are the same address, but "__irqentry_text_start"
    is deemed to the first aliased symbol by scripts/kallsyms)
    
    This patch puts symbols like "__irqentry_text_start" to the second
    aliased symbols. And a more proper symbol name becomes the first.
    
    Aliased symbols mostly come from linker script. The solution is
    guessing "is this symbol defined in linker script", the symbols
    defined in linker script will not become the first aliased symbol.
    
    And if symbols are found to be equal in this "linker script provided"
    criteria, symbols are sorted by the number of prefix underscores.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Paulo Marques <pmarques@grupopie.com>
    LKML-Reference: <49BA06E2.7080807@cn.fujitsu.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index ad2434b26970..6654cbed965b 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -500,6 +500,51 @@ static void optimize_token_table(void)
 	optimize_result();
 }
 
+/* guess for "linker script provide" symbol */
+static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
+{
+	const char *symbol = (char *)se->sym + 1;
+	int len = se->len - 1;
+
+	if (len < 8)
+		return 0;
+
+	if (symbol[0] != '_' || symbol[1] != '_')
+		return 0;
+
+	/* __start_XXXXX */
+	if (!memcmp(symbol + 2, "start_", 6))
+		return 1;
+
+	/* __stop_XXXXX */
+	if (!memcmp(symbol + 2, "stop_", 5))
+		return 1;
+
+	/* __end_XXXXX */
+	if (!memcmp(symbol + 2, "end_", 4))
+		return 1;
+
+	/* __XXXXX_start */
+	if (!memcmp(symbol + len - 6, "_start", 6))
+		return 1;
+
+	/* __XXXXX_end */
+	if (!memcmp(symbol + len - 4, "_end", 4))
+		return 1;
+
+	return 0;
+}
+
+static int prefix_underscores_count(const char *str)
+{
+	const char *tail = str;
+
+	while (*tail != '_')
+		tail++;
+
+	return tail - str;
+}
+
 static int compare_symbols(const void *a, const void *b)
 {
 	const struct sym_entry *sa;
@@ -521,6 +566,18 @@ static int compare_symbols(const void *a, const void *b)
 	if (wa != wb)
 		return wa - wb;
 
+	/* sort by "linker script provide" type */
+	wa = may_be_linker_script_provide_symbol(sa);
+	wb = may_be_linker_script_provide_symbol(sb);
+	if (wa != wb)
+		return wa - wb;
+
+	/* sort by the number of prefix underscores */
+	wa = prefix_underscores_count((const char *)sa->sym + 1);
+	wb = prefix_underscores_count((const char *)sb->sym + 1);
+	if (wa != wb)
+		return wa - wb;
+
 	/* sort by initial order, so that other symbols are left undisturbed */
 	return sa->start_pos - sb->start_pos;
 }

commit 2ea038917bbdd51a7ae4a898c6a04641324dd033
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jan 14 21:38:20 2009 +0100

    Revert "kbuild: strip generated symbols from *.ko"
    
    This reverts commit ad7a953c522ceb496611d127e51e278bfe0ff483.
    
    And commit: ("allow stripping of generated symbols under CONFIG_KALLSYMS_ALL")
                9bb482476c6c9d1ae033306440c51ceac93ea80c
    
    These stripping patches has caused a set of issues:
    
    1) People have reported compatibility issues with binutils due to
       lack of support for `--strip-unneeded-symbols' with objcopy 2.15.92.0.2
       Reported by: Wenji
    2) ccache and distcc no longer works as expeced
       Reported by: Ted, Roland, + others
    3) The installed modules increased a lot in size
       Reported by: Ted, Davej + others
    
    Reported-by: Wenji Huang <wenji.huang@oracle.com>
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Reported-by: Dave Jones <davej@redhat.com>
    Reported-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 92758120a767..ad2434b26970 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -130,9 +130,18 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 static int symbol_valid(struct sym_entry *s)
 {
 	/* Symbols which vary between passes.  Passes 1 and 2 must have
-	 * identical symbol lists.
+	 * identical symbol lists.  The kallsyms_* symbols below are only added
+	 * after pass 1, they would be included in pass 2 when --all-symbols is
+	 * specified so exclude them to get a stable symbol list.
 	 */
 	static char *special_symbols[] = {
+		"kallsyms_addresses",
+		"kallsyms_num_syms",
+		"kallsyms_names",
+		"kallsyms_markers",
+		"kallsyms_token_table",
+		"kallsyms_token_index",
+
 	/* Exclude linker generated symbols which vary between passes */
 		"_SDA_BASE_",		/* ppc */
 		"_SDA2_BASE_",		/* ppc */
@@ -164,9 +173,7 @@ static int symbol_valid(struct sym_entry *s)
 	}
 
 	/* Exclude symbols which vary between passes. */
-	if (strstr((char *)s->sym + offset, "_compiled.") ||
-	    strncmp((char*)s->sym + offset, "__compound_literal.", 19) == 0 ||
-	    strncmp((char*)s->sym + offset, "__compound_literal$", 19) == 0)
+	if (strstr((char *)s->sym + offset, "_compiled."))
 		return 0;
 
 	for (i = 0; special_symbols[i]; i++)
@@ -543,10 +550,8 @@ int main(int argc, char **argv)
 		usage();
 
 	read_map(stdin);
-	if (table_cnt) {
-		sort_symbols();
-		optimize_token_table();
-	}
+	sort_symbols();
+	optimize_token_table();
 	write_src();
 
 	return 0;

commit 9bb482476c6c9d1ae033306440c51ceac93ea80c
Author: Jan Beulich <jbeulich@novell.com>
Date:   Tue Dec 16 11:30:08 2008 +0000

    allow stripping of generated symbols under CONFIG_KALLSYMS_ALL
    
    Building upon parts of the module stripping patch, this patch
    introduces similar stripping for vmlinux when CONFIG_KALLSYMS_ALL=y.
    Using CONFIG_KALLSYMS_STRIP_GENERATED reduces the overhead of
    CONFIG_KALLSYMS_ALL from 245k/310k to 65k/80k for the (i386/x86-64)
    kernels I tested with.
    
    The patch also does away with the need to special case the kallsyms-
    internal symbols by making them available even in the first linking
    stage.
    
    While it is a generated file, the patch includes the changes to
    scripts/genksyms/keywords.c_shipped, as I'm unsure what the procedure
    here is.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index ad2434b26970..92758120a767 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -130,18 +130,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 static int symbol_valid(struct sym_entry *s)
 {
 	/* Symbols which vary between passes.  Passes 1 and 2 must have
-	 * identical symbol lists.  The kallsyms_* symbols below are only added
-	 * after pass 1, they would be included in pass 2 when --all-symbols is
-	 * specified so exclude them to get a stable symbol list.
+	 * identical symbol lists.
 	 */
 	static char *special_symbols[] = {
-		"kallsyms_addresses",
-		"kallsyms_num_syms",
-		"kallsyms_names",
-		"kallsyms_markers",
-		"kallsyms_token_table",
-		"kallsyms_token_index",
-
 	/* Exclude linker generated symbols which vary between passes */
 		"_SDA_BASE_",		/* ppc */
 		"_SDA2_BASE_",		/* ppc */
@@ -173,7 +164,9 @@ static int symbol_valid(struct sym_entry *s)
 	}
 
 	/* Exclude symbols which vary between passes. */
-	if (strstr((char *)s->sym + offset, "_compiled."))
+	if (strstr((char *)s->sym + offset, "_compiled.") ||
+	    strncmp((char*)s->sym + offset, "__compound_literal.", 19) == 0 ||
+	    strncmp((char*)s->sym + offset, "__compound_literal$", 19) == 0)
 		return 0;
 
 	for (i = 0; special_symbols[i]; i++)
@@ -550,8 +543,10 @@ int main(int argc, char **argv)
 		usage();
 
 	read_map(stdin);
-	sort_symbols();
-	optimize_token_table();
+	if (table_cnt) {
+		sort_symbols();
+		optimize_token_table();
+	}
 	write_src();
 
 	return 0;

commit aab34ac8582303ef57b792710fc5dd5991477475
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon May 19 20:07:58 2008 +0200

    kbuild: filter away debug symbols from kernel symbols
    
    Andi Kleen <andi@firstfloor.org>
    reported that he saw a lot of symbols like this:
    
    0000000000000b24 N DW.aio.h.903a6d92.2
    0000000000000bce N DW.task_io_accounting.h.8d8de327.0
    0000000000000bec N DW.hrtimer.h.c23659c6.0
    
    in his System.map / kallsyms output.
    
    Simple solution is to skip all debugging
    symbols (they are marked 'N').
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Paulo Marques <pmarques@grupopie.com>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 5d20a2e24cd1..ad2434b26970 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -108,6 +108,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
 	else if (str[0] == '$')
 		return -1;
+	/* exclude debugging symbols */
+	else if (stype == 'N')
+		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit c6495aaabfaa8256c292c54b48ab081f4d86ad79
Author: Bryan Wu <cooloney@kernel.org>
Date:   Wed Apr 30 00:52:16 2008 -0700

    kallsyms: nuke all ChangeLog, this should be logged by git
    
    Pointed out by Paulo:
      "When I wrote this initially, it was a mistake to add a Changelog in
       the first place, but I didn't know better at the time.
    
       If you're going to make changes to this file, please remove all the
       Changelog, instead of adding more entries to it.  The 'Changelog'
       should be kept by the version control system, and not the source code
       itself."
    
    Cc: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Acked-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index c912137f80e2..5d20a2e24cd1 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -7,12 +7,6 @@
  *
  * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] > symbols.S
  *
- * ChangeLog:
- *
- * (25/Aug/2004) Paulo Marques <pmarques@grupopie.com>
- *      Changed the compression method from stem compression to "table lookup"
- *      compression
- *
  *      Table compression uses all the unused char codes on the symbols and
  *  maps these to the most used substrings (tokens). For instance, it might
  *  map char code 0xF7 to represent "write_" and then in every symbol where

commit f2df3f65d0b4337cfb5b19eab3ee28b177427c49
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Wed Feb 6 01:37:33 2008 -0800

    kallsyms should prefer non weak symbols
    
    When resolving symbol names from addresses with aliased symbol names,
    kallsyms_lookup always returns the first symbol, even if it is a weak
    symbol.
    
    This patch changes this by sorting the symbols with the weak symbols last
    before feeding them to the kernel.  This way the kernel runtime isn't
    changed at all, only the kallsyms build system is changed.
    
    Another side effect is that the symbols get sorted by address, too.  So,
    even if future binutils version have some bug in "nm" that makes it fail to
    correctly sort symbols by address, the kernel won't be affected by this.
    
    Mathieu says:
    
      I created a module in LTTng that uses kallsyms to get the symbol
      corresponding to a specific system call address.  Unfortunately, all the
      unimplemented syscalls were all referring to the (same) weak symbol
      identifying an unrelated system call rather that sys_ni (or whatever
      non-weak symbol would be expected).  Kallsyms was dumbly returning the first
      symbol that matched.
    
      This patch makes sure kallsyms returns the non-weak symbol when there is
      one, which seems to be the expected result.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Looks-great-to: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 8fb87003d5d3..c912137f80e2 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -31,14 +31,13 @@
 
 #define KSYM_NAME_LEN		128
 
-
 struct sym_entry {
 	unsigned long long addr;
 	unsigned int len;
+	unsigned int start_pos;
 	unsigned char *sym;
 };
 
-
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
 static unsigned long long _text, _stext, _etext, _sinittext, _einittext;
@@ -198,8 +197,10 @@ static void read_map(FILE *in)
 				exit (1);
 			}
 		}
-		if (read_symbol(in, &table[table_cnt]) == 0)
+		if (read_symbol(in, &table[table_cnt]) == 0) {
+			table[table_cnt].start_pos = table_cnt;
 			table_cnt++;
+		}
 	}
 }
 
@@ -502,6 +503,35 @@ static void optimize_token_table(void)
 	optimize_result();
 }
 
+static int compare_symbols(const void *a, const void *b)
+{
+	const struct sym_entry *sa;
+	const struct sym_entry *sb;
+	int wa, wb;
+
+	sa = a;
+	sb = b;
+
+	/* sort by address first */
+	if (sa->addr > sb->addr)
+		return 1;
+	if (sa->addr < sb->addr)
+		return -1;
+
+	/* sort by "weakness" type */
+	wa = (sa->sym[0] == 'w') || (sa->sym[0] == 'W');
+	wb = (sb->sym[0] == 'w') || (sb->sym[0] == 'W');
+	if (wa != wb)
+		return wa - wb;
+
+	/* sort by initial order, so that other symbols are left undisturbed */
+	return sa->start_pos - sb->start_pos;
+}
+
+static void sort_symbols(void)
+{
+	qsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);
+}
 
 int main(int argc, char **argv)
 {
@@ -523,6 +553,7 @@ int main(int argc, char **argv)
 		usage();
 
 	read_map(stdin);
+	sort_symbols();
 	optimize_token_table();
 	write_src();
 

commit a3b81113fb6658629f4ebaabf8dd3067cd341020
Author: Robin Getz <rgetz@blackfin.uclinux.org>
Date:   Wed Feb 6 01:36:26 2008 -0800

    remove support for un-needed _extratext section
    
    When passing a zero address to kallsyms_lookup(), the kernel thought it was
    a valid kernel address, even if it is not.  This is because is_ksym_addr()
    called is_kernel_extratext() and checked against labels that don't exist on
    many archs (which default as zero).  Since PPC was the only kernel which
    defines _extra_text, (in 2005), and no longer needs it, this patch removes
    _extra_text support.
    
    For some history (provided by Jon):
     http://ozlabs.org/pipermail/linuxppc-dev/2005-September/019734.html
     http://ozlabs.org/pipermail/linuxppc-dev/2005-September/019736.html
     http://ozlabs.org/pipermail/linuxppc-dev/2005-September/019751.html
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Robin Getz <rgetz@blackfin.uclinux.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jon Loeliger <jdl@freescale.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1f11d848532a..8fb87003d5d3 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -41,7 +41,7 @@ struct sym_entry {
 
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
-static unsigned long long _text, _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
+static unsigned long long _text, _stext, _etext, _sinittext, _einittext;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
@@ -99,10 +99,6 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		_sinittext = s->addr;
 	else if (strcmp(sym, "_einittext") == 0)
 		_einittext = s->addr;
-	else if (strcmp(sym, "_sextratext") == 0)
-		_sextratext = s->addr;
-	else if (strcmp(sym, "_eextratext") == 0)
-		_eextratext = s->addr;
 	else if (toupper(stype) == 'A')
 	{
 		/* Keep these useful absolute symbols */
@@ -165,18 +161,18 @@ static int symbol_valid(struct sym_entry *s)
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
 		if ((s->addr < _stext || s->addr > _etext)
-		    && (s->addr < _sinittext || s->addr > _einittext)
-		    && (s->addr < _sextratext || s->addr > _eextratext))
+		    && (s->addr < _sinittext || s->addr > _einittext))
 			return 0;
 		/* Corner case.  Discard any symbols with the same value as
-		 * _etext _einittext or _eextratext; they can move between pass
-		 * 1 and 2 when the kallsyms data are added.  If these symbols
-		 * move then they may get dropped in pass 2, which breaks the
-		 * kallsyms rules.
+		 * _etext _einittext; they can move between pass 1 and 2 when
+		 * the kallsyms data are added.  If these symbols move then
+		 * they may get dropped in pass 2, which breaks the kallsyms
+		 * rules.
 		 */
-		if ((s->addr == _etext && strcmp((char*)s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext && strcmp((char*)s->sym + offset, "_einittext")) ||
-		    (s->addr == _eextratext && strcmp((char*)s->sym + offset, "_eextratext")))
+		if ((s->addr == _etext &&
+				strcmp((char *)s->sym + offset, "_etext")) ||
+		    (s->addr == _einittext &&
+				strcmp((char *)s->sym + offset, "_einittext")))
 			return 0;
 	}
 

commit efffbeee5bc4168059683714b300d307f5193d69
Merge: 40b42f1ebf65 b824325443bb
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Jul 19 14:28:19 2007 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild: (33 commits)
      xtensa: use DATA_DATA in xtensa
      powerpc: add missing DATA_DATA to powerpc
      cris: use DATA_DATA in cris
      kallsyms: remove usage of memmem and _GNU_SOURCE from scripts/kallsyms.c
      kbuild: use -fno-optimize-sibling-calls unconditionally
      kconfig: reset generated values only if Kconfig and .config agree.
      kbuild: fix the warning when running make tags
      kconfig: strip 'CONFIG_' automatically in kernel configuration search
      kbuild: use POSIX BRE in headers install target
      Whitelist references from __dbe_table to .init
      modpost white list pattern adjustment
      kbuild: do section mismatch check on full vmlinux
      kbuild: whitelist references from variables named _timer to .init.text
      kbuild: remove hardcoded _logo names from modpost
      kbuild: remove hardcoded apic_es7000 from modpost
      kbuild: warn about references from .init.text to .exit.text
      kbuild: consolidate section checks
      kbuild: refactor code in modpost to improve maintainability
      kbuild: ignore section mismatch warnings originating from .note section
      kbuild: .paravirtprobe section is obsolete, so modpost doesn't need to handle it
      ...

commit 9281acea6a3687ff0f262e0be31eac34895b95d7
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jul 17 04:03:51 2007 -0700

    kallsyms: make KSYM_NAME_LEN include space for trailing '\0'
    
    KSYM_NAME_LEN is peculiar in that it does not include the space for the
    trailing '\0', forcing all users to use KSYM_NAME_LEN + 1 when allocating
    buffer.  This is nonsense and error-prone.  Moreover, when the caller
    forgets that it's very likely to subtly bite back by corrupting the stack
    because the last position of the buffer is always cleared to zero.
    
    This patch increments KSYM_NAME_LEN by one and updates code accordingly.
    
    * off-by-one bug in asm-powerpc/kprobes.h::kprobe_lookup_name() macro
      is fixed.
    
    * Where MODULE_NAME_LEN and KSYM_NAME_LEN were used together,
      MODULE_NAME_LEN was treated as if it didn't include space for the
      trailing '\0'.  Fix it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Acked-by: Paulo Marques <pmarques@grupopie.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 8b809b264d18..10b006694e5d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -31,7 +31,7 @@
 #include <string.h>
 #include <ctype.h>
 
-#define KSYM_NAME_LEN		127
+#define KSYM_NAME_LEN		128
 
 
 struct sym_entry {
@@ -254,7 +254,7 @@ static void write_src(void)
 	unsigned int i, k, off;
 	unsigned int best_idx[256];
 	unsigned int *markers;
-	char buf[KSYM_NAME_LEN+1];
+	char buf[KSYM_NAME_LEN];
 
 	printf("#include <asm/types.h>\n");
 	printf("#if BITS_PER_LONG == 64\n");

commit 7c5d249ad3fb6ce3815c1ed5f04bece02a3e7030
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Wed Jun 20 18:09:00 2007 +0100

    kallsyms: remove usage of memmem and _GNU_SOURCE from scripts/kallsyms.c
    
    The only in-kernel user of "memmem" is scripts/kallsyms.c and it only
    uses it to find tokens that are 2 bytes in size. It is trivial to
    replace it with a simple function that finds 2-byte tokens.
    
    This should help users from systems that don't have the memmem GNU
    extension available.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 8b809b264d18..caf4c86c3d0b 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -24,8 +24,6 @@
  *
  */
 
-#define _GNU_SOURCE
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -378,6 +376,17 @@ static void build_initial_tok_table(void)
 	table_cnt = pos;
 }
 
+static void *find_token(unsigned char *str, int len, unsigned char *token)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++) {
+		if (str[i] == token[0] && str[i+1] == token[1])
+			return &str[i];
+	}
+	return NULL;
+}
+
 /* replace a given token in all the valid symbols. Use the sampled symbols
  * to update the counts */
 static void compress_symbols(unsigned char *str, int idx)
@@ -391,7 +400,7 @@ static void compress_symbols(unsigned char *str, int idx)
 		p1 = table[i].sym;
 
 		/* find the token on the symbol */
-		p2 = memmem(p1, len, str, 2);
+		p2 = find_token(p1, len, str);
 		if (!p2) continue;
 
 		/* decrease the counts for this symbol's tokens */
@@ -410,7 +419,7 @@ static void compress_symbols(unsigned char *str, int idx)
 			if (size < 2) break;
 
 			/* find the token on the symbol */
-			p2 = memmem(p1, size, str, 2);
+			p2 = find_token(p1, size, str);
 
 		} while (p2);
 

commit aad094701c6355cb2b3d74a07ec0496f4a48c787
Author: Jan Beulich <jbeulich@novell.com>
Date:   Fri Dec 8 02:35:57 2006 -0800

    [PATCH] move kallsyms data to .rodata
    
    Kallsyms data is never written to, so it can as well benefit from
    CONFIG_DEBUG_RODATA.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index f359b730c2c5..8b809b264d18 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -265,7 +265,7 @@ static void write_src(void)
 	printf("#define ALGN .align 4\n");
 	printf("#endif\n");
 
-	printf(".data\n");
+	printf("\t.section .rodata, \"a\"\n");
 
 	/* Provide proper symbols relocatability by their '_text'
 	 * relativeness.  The symbol names cannot be used to construct

commit 2c22d8baa98a92022acb85b0b7c6f4a60df55f47
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Thu Dec 7 02:14:10 2006 +0100

    [PATCH] relocatable kernel: Fix kallsyms on avr32 after relocatable kernel changes
    
    o On some platforms like avr32, section init comes before .text and
      not necessarily a symbol's relative position w.r.t _text is positive.
      In such cases assembler detects the overflow and emits warning. This
      patch fixes it.
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 4c1ad0acbb4b..f359b730c2c5 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -277,8 +277,12 @@ static void write_src(void)
 	output_label("kallsyms_addresses");
 	for (i = 0; i < table_cnt; i++) {
 		if (toupper(table[i].sym[0]) != 'A') {
-			printf("\tPTR\t_text + %#llx\n",
-				table[i].addr - _text);
+			if (_text <= table[i].addr)
+				printf("\tPTR\t_text + %#llx\n",
+					table[i].addr - _text);
+			else
+				printf("\tPTR\t_text - %#llx\n",
+					_text - table[i].addr);
 		} else {
 			printf("\tPTR\t%#llx\n", table[i].addr);
 		}

commit fd593d12770d4a0d1ff095d44b96436c18479ee8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Dec 7 02:14:04 2006 +0100

    [PATCH] relocatable kernel: Kallsyms generate relocatable symbols
    
    Print the addresses of non-absolute symbols relative to _text
    so that ld will generate relocations.  Allowing a relocatable
    kernel to relocate them.  We can't actually use the symbol names
    because kallsyms includes static symbols that are not exported
    from their object files.
    
    Add the _text symbol definitions to the architectures which don't
    define it otherwise linker will fail.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 22d281c6ec24..4c1ad0acbb4b 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -43,7 +43,7 @@ struct sym_entry {
 
 static struct sym_entry *table;
 static unsigned int table_size, table_cnt;
-static unsigned long long _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
+static unsigned long long _text, _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
@@ -91,7 +91,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		sym++;
 
 	/* Ignore most absolute/undefined (?) symbols. */
-	if (strcmp(sym, "_stext") == 0)
+	if (strcmp(sym, "_text") == 0)
+		_text = s->addr;
+	else if (strcmp(sym, "_stext") == 0)
 		_stext = s->addr;
 	else if (strcmp(sym, "_etext") == 0)
 		_etext = s->addr;
@@ -265,9 +267,21 @@ static void write_src(void)
 
 	printf(".data\n");
 
+	/* Provide proper symbols relocatability by their '_text'
+	 * relativeness.  The symbol names cannot be used to construct
+	 * normal symbol references as the list of symbols contains
+	 * symbols that are declared static and are private to their
+	 * .o files.  This prevents .tmp_kallsyms.o or any other
+	 * object from referencing them.
+	 */
 	output_label("kallsyms_addresses");
 	for (i = 0; i < table_cnt; i++) {
-		printf("\tPTR\t%#llx\n", table[i].addr);
+		if (toupper(table[i].sym[0]) != 'A') {
+			printf("\tPTR\t_text + %#llx\n",
+				table[i].addr - _text);
+		} else {
+			printf("\tPTR\t%#llx\n", table[i].addr);
+		}
 	}
 	printf("\n");
 

commit f1a136e0d098a4478236a1c24f9a57db5abf0755
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Sat Mar 25 03:07:46 2006 -0800

    [PATCH] kallsyms: handle malloc() failure
    
    This fixes coverity bugs #398 and #397
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index d591578bd3b2..22d281c6ec24 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -124,6 +124,11 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	 * compressed together */
 	s->len = strlen(str) + 1;
 	s->sym = malloc(s->len + 1);
+	if (!s->sym) {
+		fprintf(stderr, "kallsyms failure: "
+			"unable to allocate required amount of memory\n");
+		exit(EXIT_FAILURE);
+	}
 	strcpy((char *)s->sym + 1, str);
 	s->sym[0] = stype;
 
@@ -272,7 +277,12 @@ static void write_src(void)
 
 	/* table of offset markers, that give the offset in the compressed stream
 	 * every 256 symbols */
-	markers = (unsigned int *) malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
+	markers = malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
+	if (!markers) {
+		fprintf(stderr, "kallsyms failure: "
+			"unable to allocate required memory\n");
+		exit(EXIT_FAILURE);
+	}
 
 	output_label("kallsyms_names");
 	off = 0;

commit 6f00df24ee394f345a8789d3a2f98fc1d9195b9f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 6 15:16:41 2005 -0700

    [PATCH] Strip local symbols from kallsyms
    
    Local symbols generated by gcc start with a `$'; no point in including them
    in the kernel.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1f53d4fc4c1d..d591578bd3b2 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -116,6 +116,9 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	else if (toupper(stype) == 'U' ||
 		 is_arm_mapping_symbol(sym))
 		return -1;
+	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
+	else if (str[0] == '$')
+		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */

commit b3dbb4ecd46767b621df3dedd28788da93ee0cac
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Tue Sep 6 15:16:31 2005 -0700

    [PATCH] kallsyms: change compression algorithm
    
    This patch changes the way the compression algorithm works.  The base
    algorithm is similiar to the previous but we force the compressed token
    size to 2.
    
    Having a fixed size compressed token allows for a lot of optimizations, and
    that in turn allows this code to run over *all* the symbols faster than it
    did before over just a subset.
    
    Having it work over all the symbols will make it behave better when symbols
    change positions between passes, and the "inconsistent kallsyms" messages
    should become less frequent.
    
    In my tests the compression ratio was degraded by about 0.5%, but the
    results will depend greatly on the number of symbols to compress.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 9be41a9f5aff..1f53d4fc4c1d 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -24,75 +24,37 @@
  *
  */
 
+#define _GNU_SOURCE
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 
-/* maximum token length used. It doesn't pay to increase it a lot, because
- * very long substrings probably don't repeat themselves too often. */
-#define MAX_TOK_SIZE		11
 #define KSYM_NAME_LEN		127
 
-/* we use only a subset of the complete symbol table to gather the token count,
- * to speed up compression, at the expense of a little compression ratio */
-#define WORKING_SET		1024
-
-/* first find the best token only on the list of tokens that would profit more
- * than GOOD_BAD_THRESHOLD. Only if this list is empty go to the "bad" list.
- * Increasing this value will put less tokens on the "good" list, so the search
- * is faster. However, if the good list runs out of tokens, we must painfully
- * search the bad list. */
-#define GOOD_BAD_THRESHOLD	10
-
-/* token hash parameters */
-#define HASH_BITS		18
-#define HASH_TABLE_SIZE		(1 << HASH_BITS)
-#define HASH_MASK		(HASH_TABLE_SIZE - 1)
-#define HASH_BASE_OFFSET	2166136261U
-#define HASH_FOLD(a)		((a)&(HASH_MASK))
-
-/* flags to mark symbols */
-#define SYM_FLAG_VALID		1
-#define SYM_FLAG_SAMPLED	2
 
 struct sym_entry {
 	unsigned long long addr;
-	char type;
-	unsigned char flags;
-	unsigned char len;
+	unsigned int len;
 	unsigned char *sym;
 };
 
 
 static struct sym_entry *table;
-static int size, cnt;
+static unsigned int table_size, table_cnt;
 static unsigned long long _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
-struct token {
-	unsigned char data[MAX_TOK_SIZE];
-	unsigned char len;
-	/* profit: the number of bytes that could be saved by inserting this
-	 * token into the table */
-	int profit;
-	struct token *next;	/* next token on the hash list */
-	struct token *right;	/* next token on the good/bad list */
-	struct token *left;    /* previous token on the good/bad list */
-	struct token *smaller; /* token that is less one letter than this one */
-	};
-
-struct token bad_head, good_head;
-struct token *hash_table[HASH_TABLE_SIZE];
+int token_profit[0x10000];
 
 /* the table that holds the result of the compression */
-unsigned char best_table[256][MAX_TOK_SIZE+1];
+unsigned char best_table[256][2];
 unsigned char best_table_len[256];
 
 
-static void
-usage(void)
+static void usage(void)
 {
 	fprintf(stderr, "Usage: kallsyms [--all-symbols] [--symbol-prefix=<prefix char>] < in.map > out.S\n");
 	exit(1);
@@ -102,21 +64,19 @@ usage(void)
  * This ignores the intensely annoying "mapping symbols" found
  * in ARM ELF files: $a, $t and $d.
  */
-static inline int
-is_arm_mapping_symbol(const char *str)
+static inline int is_arm_mapping_symbol(const char *str)
 {
 	return str[0] == '$' && strchr("atd", str[1])
 	       && (str[2] == '\0' || str[2] == '.');
 }
 
-static int
-read_symbol(FILE *in, struct sym_entry *s)
+static int read_symbol(FILE *in, struct sym_entry *s)
 {
 	char str[500];
-	char *sym;
+	char *sym, stype;
 	int rc;
 
-	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &s->type, str);
+	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
 	if (rc != 3) {
 		if (rc != EOF) {
 			/* skip line */
@@ -143,7 +103,7 @@ read_symbol(FILE *in, struct sym_entry *s)
 		_sextratext = s->addr;
 	else if (strcmp(sym, "_eextratext") == 0)
 		_eextratext = s->addr;
-	else if (toupper(s->type) == 'A')
+	else if (toupper(stype) == 'A')
 	{
 		/* Keep these useful absolute symbols */
 		if (strcmp(sym, "__kernel_syscall_via_break") &&
@@ -153,22 +113,21 @@ read_symbol(FILE *in, struct sym_entry *s)
 			return -1;
 
 	}
-	else if (toupper(s->type) == 'U' ||
+	else if (toupper(stype) == 'U' ||
 		 is_arm_mapping_symbol(sym))
 		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
 	s->len = strlen(str) + 1;
-	s->sym = (char *) malloc(s->len + 1);
-	strcpy(s->sym + 1, str);
-	s->sym[0] = s->type;
+	s->sym = malloc(s->len + 1);
+	strcpy((char *)s->sym + 1, str);
+	s->sym[0] = stype;
 
 	return 0;
 }
 
-static int
-symbol_valid(struct sym_entry *s)
+static int symbol_valid(struct sym_entry *s)
 {
 	/* Symbols which vary between passes.  Passes 1 and 2 must have
 	 * identical symbol lists.  The kallsyms_* symbols below are only added
@@ -214,30 +173,29 @@ symbol_valid(struct sym_entry *s)
 	}
 
 	/* Exclude symbols which vary between passes. */
-	if (strstr(s->sym + offset, "_compiled."))
+	if (strstr((char *)s->sym + offset, "_compiled."))
 		return 0;
 
 	for (i = 0; special_symbols[i]; i++)
-		if( strcmp(s->sym + offset, special_symbols[i]) == 0 )
+		if( strcmp((char *)s->sym + offset, special_symbols[i]) == 0 )
 			return 0;
 
 	return 1;
 }
 
-static void
-read_map(FILE *in)
+static void read_map(FILE *in)
 {
 	while (!feof(in)) {
-		if (cnt >= size) {
-			size += 10000;
-			table = realloc(table, sizeof(*table) * size);
+		if (table_cnt >= table_size) {
+			table_size += 10000;
+			table = realloc(table, sizeof(*table) * table_size);
 			if (!table) {
 				fprintf(stderr, "out of memory\n");
 				exit (1);
 			}
 		}
-		if (read_symbol(in, &table[cnt]) == 0)
-			cnt++;
+		if (read_symbol(in, &table[table_cnt]) == 0)
+			table_cnt++;
 	}
 }
 
@@ -281,10 +239,9 @@ static int expand_symbol(unsigned char *data, int len, char *result)
 	return total;
 }
 
-static void
-write_src(void)
+static void write_src(void)
 {
-	int i, k, off, valid;
+	unsigned int i, k, off;
 	unsigned int best_idx[256];
 	unsigned int *markers;
 	char buf[KSYM_NAME_LEN+1];
@@ -301,33 +258,24 @@ write_src(void)
 	printf(".data\n");
 
 	output_label("kallsyms_addresses");
-	valid = 0;
-	for (i = 0; i < cnt; i++) {
-		if (table[i].flags & SYM_FLAG_VALID) {
-			printf("\tPTR\t%#llx\n", table[i].addr);
-			valid++;
-		}
+	for (i = 0; i < table_cnt; i++) {
+		printf("\tPTR\t%#llx\n", table[i].addr);
 	}
 	printf("\n");
 
 	output_label("kallsyms_num_syms");
-	printf("\tPTR\t%d\n", valid);
+	printf("\tPTR\t%d\n", table_cnt);
 	printf("\n");
 
 	/* table of offset markers, that give the offset in the compressed stream
 	 * every 256 symbols */
-	markers = (unsigned int *) malloc(sizeof(unsigned int)*((valid + 255) / 256));
+	markers = (unsigned int *) malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
 
 	output_label("kallsyms_names");
-	valid = 0;
 	off = 0;
-	for (i = 0; i < cnt; i++) {
-
-		if (!table[i].flags & SYM_FLAG_VALID)
-			continue;
-
-		if ((valid & 0xFF) == 0)
-			markers[valid >> 8] = off;
+	for (i = 0; i < table_cnt; i++) {
+		if ((i & 0xFF) == 0)
+			markers[i >> 8] = off;
 
 		printf("\t.byte 0x%02x", table[i].len);
 		for (k = 0; k < table[i].len; k++)
@@ -335,12 +283,11 @@ write_src(void)
 		printf("\n");
 
 		off += table[i].len + 1;
-		valid++;
 	}
 	printf("\n");
 
 	output_label("kallsyms_markers");
-	for (i = 0; i < ((valid + 255) >> 8); i++)
+	for (i = 0; i < ((table_cnt + 255) >> 8); i++)
 		printf("\tPTR\t%d\n", markers[i]);
 	printf("\n");
 
@@ -350,7 +297,7 @@ write_src(void)
 	off = 0;
 	for (i = 0; i < 256; i++) {
 		best_idx[i] = off;
-		expand_symbol(best_table[i],best_table_len[i],buf);
+		expand_symbol(best_table[i], best_table_len[i], buf);
 		printf("\t.asciz\t\"%s\"\n", buf);
 		off += strlen(buf) + 1;
 	}
@@ -365,153 +312,13 @@ write_src(void)
 
 /* table lookup compression functions */
 
-static inline unsigned int rehash_token(unsigned int hash, unsigned char data)
-{
-	return ((hash * 16777619) ^ data);
-}
-
-static unsigned int hash_token(unsigned char *data, int len)
-{
-	unsigned int hash=HASH_BASE_OFFSET;
-	int i;
-
-	for (i = 0; i < len; i++)
-		hash = rehash_token(hash, data[i]);
-
-	return HASH_FOLD(hash);
-}
-
-/* find a token given its data and hash value */
-static struct token *find_token_hash(unsigned char *data, int len, unsigned int hash)
-{
-	struct token *ptr;
-
-	ptr = hash_table[hash];
-
-	while (ptr) {
-		if ((ptr->len == len) && (memcmp(ptr->data, data, len) == 0))
-			return ptr;
-		ptr=ptr->next;
-	}
-
-	return NULL;
-}
-
-static inline void insert_token_in_group(struct token *head, struct token *ptr)
-{
-	ptr->right = head->right;
-	ptr->right->left = ptr;
-	head->right = ptr;
-	ptr->left = head;
-}
-
-static inline void remove_token_from_group(struct token *ptr)
-{
-	ptr->left->right = ptr->right;
-	ptr->right->left = ptr->left;
-}
-
-
-/* build the counts for all the tokens that start with "data", and have lenghts
- * from 2 to "len" */
-static void learn_token(unsigned char *data, int len)
-{
-	struct token *ptr,*last_ptr;
-	int i, newprofit;
-	unsigned int hash = HASH_BASE_OFFSET;
-	unsigned int hashes[MAX_TOK_SIZE + 1];
-
-	if (len > MAX_TOK_SIZE)
-		len = MAX_TOK_SIZE;
-
-	/* calculate and store the hash values for all the sub-tokens */
-	hash = rehash_token(hash, data[0]);
-	for (i = 2; i <= len; i++) {
-		hash = rehash_token(hash, data[i-1]);
-		hashes[i] = HASH_FOLD(hash);
-	}
-
-	last_ptr = NULL;
-	ptr = NULL;
-
-	for (i = len; i >= 2; i--) {
-		hash = hashes[i];
-
-		if (!ptr) ptr = find_token_hash(data, i, hash);
-
-		if (!ptr) {
-			/* create a new token entry */
-			ptr = (struct token *) malloc(sizeof(*ptr));
-
-			memcpy(ptr->data, data, i);
-			ptr->len = i;
-
-			/* when we create an entry, it's profit is 0 because
-			 * we also take into account the size of the token on
-			 * the compressed table. We then subtract GOOD_BAD_THRESHOLD
-			 * so that the test to see if this token belongs to
-			 * the good or bad list, is a comparison to zero */
-			ptr->profit = -GOOD_BAD_THRESHOLD;
-
-			ptr->next = hash_table[hash];
-			hash_table[hash] = ptr;
-
-			insert_token_in_group(&bad_head, ptr);
-
-			ptr->smaller = NULL;
-		} else {
-			newprofit = ptr->profit + (ptr->len - 1);
-			/* check to see if this token needs to be moved to a
-			 * different list */
-			if((ptr->profit < 0) && (newprofit >= 0)) {
-				remove_token_from_group(ptr);
-				insert_token_in_group(&good_head,ptr);
-			}
-			ptr->profit = newprofit;
-		}
-
-		if (last_ptr) last_ptr->smaller = ptr;
-		last_ptr = ptr;
-
-		ptr = ptr->smaller;
-	}
-}
-
-/* decrease the counts for all the tokens that start with "data", and have lenghts
- * from 2 to "len". This function is much simpler than learn_token because we have
- * more guarantees (tho tokens exist, the ->smaller pointer is set, etc.)
- * The two separate functions exist only because of compression performance */
-static void forget_token(unsigned char *data, int len)
-{
-	struct token *ptr;
-	int i, newprofit;
-	unsigned int hash=0;
-
-	if (len > MAX_TOK_SIZE) len = MAX_TOK_SIZE;
-
-	hash = hash_token(data, len);
-	ptr = find_token_hash(data, len, hash);
-
-	for (i = len; i >= 2; i--) {
-
-		newprofit = ptr->profit - (ptr->len - 1);
-		if ((ptr->profit >= 0) && (newprofit < 0)) {
-			remove_token_from_group(ptr);
-			insert_token_in_group(&bad_head, ptr);
-		}
-		ptr->profit=newprofit;
-
-		ptr=ptr->smaller;
-	}
-}
-
 /* count all the possible tokens in a symbol */
 static void learn_symbol(unsigned char *symbol, int len)
 {
 	int i;
 
 	for (i = 0; i < len - 1; i++)
-		learn_token(symbol + i, len - i);
+		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;
 }
 
 /* decrease the count for all the possible tokens in a symbol */
@@ -520,117 +327,90 @@ static void forget_symbol(unsigned char *symbol, int len)
 	int i;
 
 	for (i = 0; i < len - 1; i++)
-		forget_token(symbol + i, len - i);
+		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;
 }
 
-/* set all the symbol flags and do the initial token count */
+/* remove all the invalid symbols from the table and do the initial token count */
 static void build_initial_tok_table(void)
 {
-	int i, use_it, valid;
+	unsigned int i, pos;
 
-	valid = 0;
-	for (i = 0; i < cnt; i++) {
-		table[i].flags = 0;
+	pos = 0;
+	for (i = 0; i < table_cnt; i++) {
 		if ( symbol_valid(&table[i]) ) {
-			table[i].flags |= SYM_FLAG_VALID;
-			valid++;
-		}
-	}
-
-	use_it = 0;
-	for (i = 0; i < cnt; i++) {
-
-		/* subsample the available symbols. This method is almost like
-		 * a Bresenham's algorithm to get uniformly distributed samples
-		 * across the symbol table */
-		if (table[i].flags & SYM_FLAG_VALID) {
-
-			use_it += WORKING_SET;
-
-			if (use_it >= valid) {
-				table[i].flags |= SYM_FLAG_SAMPLED;
-				use_it -= valid;
-			}
+			if (pos != i)
+				table[pos] = table[i];
+			learn_symbol(table[pos].sym, table[pos].len);
+			pos++;
 		}
-		if (table[i].flags & SYM_FLAG_SAMPLED)
-			learn_symbol(table[i].sym, table[i].len);
 	}
+	table_cnt = pos;
 }
 
 /* replace a given token in all the valid symbols. Use the sampled symbols
  * to update the counts */
-static void compress_symbols(unsigned char *str, int tlen, int idx)
+static void compress_symbols(unsigned char *str, int idx)
 {
-	int i, len, learn, size;
-	unsigned char *p;
+	unsigned int i, len, size;
+	unsigned char *p1, *p2;
 
-	for (i = 0; i < cnt; i++) {
-
-		if (!(table[i].flags & SYM_FLAG_VALID)) continue;
+	for (i = 0; i < table_cnt; i++) {
 
 		len = table[i].len;
-		learn = 0;
-		p = table[i].sym;
+		p1 = table[i].sym;
+
+		/* find the token on the symbol */
+		p2 = memmem(p1, len, str, 2);
+		if (!p2) continue;
+
+		/* decrease the counts for this symbol's tokens */
+		forget_symbol(table[i].sym, len);
+
+		size = len;
 
 		do {
+			*p2 = idx;
+			p2++;
+			size -= (p2 - p1);
+			memmove(p2, p2 + 1, size);
+			p1 = p2;
+			len--;
+
+			if (size < 2) break;
+
 			/* find the token on the symbol */
-			p = (unsigned char *) strstr((char *) p, (char *) str);
-			if (!p) break;
-
-			if (!learn) {
-				/* if this symbol was used to count, decrease it */
-				if (table[i].flags & SYM_FLAG_SAMPLED)
-					forget_symbol(table[i].sym, len);
-				learn = 1;
-			}
+			p2 = memmem(p1, size, str, 2);
 
-			*p = idx;
-			size = (len - (p - table[i].sym)) - tlen + 1;
-			memmove(p + 1, p + tlen, size);
-			p++;
-			len -= tlen - 1;
+		} while (p2);
 
-		} while (size >= tlen);
+		table[i].len = len;
 
-		if(learn) {
-			table[i].len = len;
-			/* if this symbol was used to count, learn it again */
-			if(table[i].flags & SYM_FLAG_SAMPLED)
-				learn_symbol(table[i].sym, len);
-		}
+		/* increase the counts for this symbol's new tokens */
+		learn_symbol(table[i].sym, len);
 	}
 }
 
 /* search the token with the maximum profit */
-static struct token *find_best_token(void)
+static int find_best_token(void)
 {
-	struct token *ptr,*best,*head;
-	int bestprofit;
+	int i, best, bestprofit;
 
 	bestprofit=-10000;
+	best = 0;
 
-	/* failsafe: if the "good" list is empty search from the "bad" list */
-	if(good_head.right == &good_head) head = &bad_head;
-	else head = &good_head;
-
-	ptr = head->right;
-	best = NULL;
-	while (ptr != head) {
-		if (ptr->profit > bestprofit) {
-			bestprofit = ptr->profit;
-			best = ptr;
+	for (i = 0; i < 0x10000; i++) {
+		if (token_profit[i] > bestprofit) {
+			best = i;
+			bestprofit = token_profit[i];
 		}
-		ptr = ptr->right;
 	}
-
 	return best;
 }
 
 /* this is the core of the algorithm: calculate the "best" table */
 static void optimize_result(void)
 {
-	struct token *best;
-	int i;
+	int i, best;
 
 	/* using the '\0' symbol last allows compress_symbols to use standard
 	 * fast string functions */
@@ -644,14 +424,12 @@ static void optimize_result(void)
 			best = find_best_token();
 
 			/* place it in the "best" table */
-			best_table_len[i] = best->len;
-			memcpy(best_table[i], best->data, best_table_len[i]);
-			/* zero terminate the token so that we can use strstr
-			   in compress_symbols */
-			best_table[i][best_table_len[i]]='\0';
+			best_table_len[i] = 2;
+			best_table[i][0] = best & 0xFF;
+			best_table[i][1] = (best >> 8) & 0xFF;
 
 			/* replace this token in all the valid symbols */
-			compress_symbols(best_table[i], best_table_len[i], i);
+			compress_symbols(best_table[i], i);
 		}
 	}
 }
@@ -659,39 +437,28 @@ static void optimize_result(void)
 /* start by placing the symbols that are actually used on the table */
 static void insert_real_symbols_in_table(void)
 {
-	int i, j, c;
+	unsigned int i, j, c;
 
 	memset(best_table, 0, sizeof(best_table));
 	memset(best_table_len, 0, sizeof(best_table_len));
 
-	for (i = 0; i < cnt; i++) {
-		if (table[i].flags & SYM_FLAG_VALID) {
-			for (j = 0; j < table[i].len; j++) {
-				c = table[i].sym[j];
-				best_table[c][0]=c;
-				best_table_len[c]=1;
-			}
+	for (i = 0; i < table_cnt; i++) {
+		for (j = 0; j < table[i].len; j++) {
+			c = table[i].sym[j];
+			best_table[c][0]=c;
+			best_table_len[c]=1;
 		}
 	}
 }
 
 static void optimize_token_table(void)
 {
-	memset(hash_table, 0, sizeof(hash_table));
-
-	good_head.left = &good_head;
-	good_head.right = &good_head;
-
-	bad_head.left = &bad_head;
-	bad_head.right = &bad_head;
-
 	build_initial_tok_table();
 
 	insert_real_symbols_in_table();
 
 	/* When valid symbol is not registered, exit to error */
-	if (good_head.left == good_head.right &&
-	    bad_head.left == bad_head.right) {
+	if (!table_cnt) {
 		fprintf(stderr, "No valid symbol.\n");
 		exit(1);
 	}
@@ -700,8 +467,7 @@ static void optimize_token_table(void)
 }
 
 
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
 {
 	if (argc >= 2) {
 		int i;

commit 61d9cdf2a9ccb9e4770d7723db8b18b8952778ce
Author: J.A. Magallon <jamagallon@able.es>
Date:   Fri Jul 15 22:14:43 2005 +0000

    [PATCH] kbuild: signed char fixes for scripts
    
    This time I did not break anything... and they shut up gcc4 ;)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index d3d2e5341051..9be41a9f5aff 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -207,9 +207,9 @@ symbol_valid(struct sym_entry *s)
 		 * move then they may get dropped in pass 2, which breaks the
 		 * kallsyms rules.
 		 */
-		if ((s->addr == _etext && strcmp(s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext && strcmp(s->sym + offset, "_einittext")) ||
-		    (s->addr == _eextratext && strcmp(s->sym + offset, "_eextratext")))
+		if ((s->addr == _etext && strcmp((char*)s->sym + offset, "_etext")) ||
+		    (s->addr == _einittext && strcmp((char*)s->sym + offset, "_einittext")) ||
+		    (s->addr == _eextratext && strcmp((char*)s->sym + offset, "_eextratext")))
 			return 0;
 	}
 

commit 075d6eb16d273dab7b7b4b83fcee8bce4ee387ed
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu May 5 16:15:09 2005 -0700

    [PATCH] ppc32: platform-specific functions missing from kallsyms.
    
    The PPC32 kernel puts platform-specific functions into separate sections so
    that unneeded parts of it can be freed when we've booted and actually
    worked out what we're running on today.
    
    This makes kallsyms ignore those functions, because they're not between
    _[se]text or _[se]inittext.  Rather than teaching kallsyms about the
    various pmac/chrp/etc sections, this patch adds '_[se]extratext' markers
    for kallsyms.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index fe11df83d1fc..d3d2e5341051 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -67,7 +67,7 @@ struct sym_entry {
 
 static struct sym_entry *table;
 static int size, cnt;
-static unsigned long long _stext, _etext, _sinittext, _einittext;
+static unsigned long long _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
 static int all_symbols = 0;
 static char symbol_prefix_char = '\0';
 
@@ -139,6 +139,10 @@ read_symbol(FILE *in, struct sym_entry *s)
 		_sinittext = s->addr;
 	else if (strcmp(sym, "_einittext") == 0)
 		_einittext = s->addr;
+	else if (strcmp(sym, "_sextratext") == 0)
+		_sextratext = s->addr;
+	else if (strcmp(sym, "_eextratext") == 0)
+		_eextratext = s->addr;
 	else if (toupper(s->type) == 'A')
 	{
 		/* Keep these useful absolute symbols */
@@ -194,16 +198,18 @@ symbol_valid(struct sym_entry *s)
 	 * and inittext sections are discarded */
 	if (!all_symbols) {
 		if ((s->addr < _stext || s->addr > _etext)
-		    && (s->addr < _sinittext || s->addr > _einittext))
+		    && (s->addr < _sinittext || s->addr > _einittext)
+		    && (s->addr < _sextratext || s->addr > _eextratext))
 			return 0;
 		/* Corner case.  Discard any symbols with the same value as
-		 * _etext or _einittext, they can move between pass 1 and 2
-		 * when the kallsyms data is added.  If these symbols move then
-		 * they may get dropped in pass 2, which breaks the kallsyms
-		 * rules.
+		 * _etext _einittext or _eextratext; they can move between pass
+		 * 1 and 2 when the kallsyms data are added.  If these symbols
+		 * move then they may get dropped in pass 2, which breaks the
+		 * kallsyms rules.
 		 */
 		if ((s->addr == _etext && strcmp(s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext && strcmp(s->sym + offset, "_einittext")))
+		    (s->addr == _einittext && strcmp(s->sym + offset, "_einittext")) ||
+		    (s->addr == _eextratext && strcmp(s->sym + offset, "_eextratext")))
 			return 0;
 	}
 

commit 41f11a4fa378201e902892130b11d78cf7cf8e10
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sun May 1 08:59:06 2005 -0700

    [PATCH] kallsyms C_SYMBOL_PREFIX support
    
    kallsyms does not consider SYMBOL_PREFIX of C.  Consequently it does not
    work on architectures using that prefix character (h8300, v850).
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 090ffda4adbc..fe11df83d1fc 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -69,6 +69,7 @@ static struct sym_entry *table;
 static int size, cnt;
 static unsigned long long _stext, _etext, _sinittext, _einittext;
 static int all_symbols = 0;
+static char symbol_prefix_char = '\0';
 
 struct token {
 	unsigned char data[MAX_TOK_SIZE];
@@ -93,7 +94,7 @@ unsigned char best_table_len[256];
 static void
 usage(void)
 {
-	fprintf(stderr, "Usage: kallsyms [--all-symbols] < in.map > out.S\n");
+	fprintf(stderr, "Usage: kallsyms [--all-symbols] [--symbol-prefix=<prefix char>] < in.map > out.S\n");
 	exit(1);
 }
 
@@ -112,6 +113,7 @@ static int
 read_symbol(FILE *in, struct sym_entry *s)
 {
 	char str[500];
+	char *sym;
 	int rc;
 
 	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &s->type, str);
@@ -123,27 +125,32 @@ read_symbol(FILE *in, struct sym_entry *s)
 		return -1;
 	}
 
+	sym = str;
+	/* skip prefix char */
+	if (symbol_prefix_char && str[0] == symbol_prefix_char)
+		sym++;
+
 	/* Ignore most absolute/undefined (?) symbols. */
-	if (strcmp(str, "_stext") == 0)
+	if (strcmp(sym, "_stext") == 0)
 		_stext = s->addr;
-	else if (strcmp(str, "_etext") == 0)
+	else if (strcmp(sym, "_etext") == 0)
 		_etext = s->addr;
-	else if (strcmp(str, "_sinittext") == 0)
+	else if (strcmp(sym, "_sinittext") == 0)
 		_sinittext = s->addr;
-	else if (strcmp(str, "_einittext") == 0)
+	else if (strcmp(sym, "_einittext") == 0)
 		_einittext = s->addr;
 	else if (toupper(s->type) == 'A')
 	{
 		/* Keep these useful absolute symbols */
-		if (strcmp(str, "__kernel_syscall_via_break") &&
-		    strcmp(str, "__kernel_syscall_via_epc") &&
-		    strcmp(str, "__kernel_sigtramp") &&
-		    strcmp(str, "__gp"))
+		if (strcmp(sym, "__kernel_syscall_via_break") &&
+		    strcmp(sym, "__kernel_syscall_via_epc") &&
+		    strcmp(sym, "__kernel_sigtramp") &&
+		    strcmp(sym, "__gp"))
 			return -1;
 
 	}
 	else if (toupper(s->type) == 'U' ||
-		 is_arm_mapping_symbol(str))
+		 is_arm_mapping_symbol(sym))
 		return -1;
 
 	/* include the type field in the symbol name, so that it gets
@@ -177,6 +184,11 @@ symbol_valid(struct sym_entry *s)
 		"_SDA2_BASE_",		/* ppc */
 		NULL };
 	int i;
+	int offset = 1;
+
+	/* skip prefix char */
+	if (symbol_prefix_char && *(s->sym + 1) == symbol_prefix_char)
+		offset++;
 
 	/* if --all-symbols is not specified, then symbols outside the text
 	 * and inittext sections are discarded */
@@ -190,17 +202,17 @@ symbol_valid(struct sym_entry *s)
 		 * they may get dropped in pass 2, which breaks the kallsyms
 		 * rules.
 		 */
-		if ((s->addr == _etext && strcmp(s->sym + 1, "_etext")) ||
-		    (s->addr == _einittext && strcmp(s->sym + 1, "_einittext")))
+		if ((s->addr == _etext && strcmp(s->sym + offset, "_etext")) ||
+		    (s->addr == _einittext && strcmp(s->sym + offset, "_einittext")))
 			return 0;
 	}
 
 	/* Exclude symbols which vary between passes. */
-	if (strstr(s->sym + 1, "_compiled."))
+	if (strstr(s->sym + offset, "_compiled."))
 		return 0;
 
 	for (i = 0; special_symbols[i]; i++)
-		if( strcmp(s->sym + 1, special_symbols[i]) == 0 )
+		if( strcmp(s->sym + offset, special_symbols[i]) == 0 )
 			return 0;
 
 	return 1;
@@ -225,9 +237,15 @@ read_map(FILE *in)
 
 static void output_label(char *label)
 {
-	printf(".globl %s\n",label);
+	if (symbol_prefix_char)
+		printf(".globl %c%s\n", symbol_prefix_char, label);
+	else
+		printf(".globl %s\n", label);
 	printf("\tALGN\n");
-	printf("%s:\n",label);
+	if (symbol_prefix_char)
+		printf("%c%s:\n", symbol_prefix_char, label);
+	else
+		printf("%s:\n", label);
 }
 
 /* uncompress a compressed symbol. When this function is called, the best table
@@ -665,6 +683,13 @@ static void optimize_token_table(void)
 
 	insert_real_symbols_in_table();
 
+	/* When valid symbol is not registered, exit to error */
+	if (good_head.left == good_head.right &&
+	    bad_head.left == bad_head.right) {
+		fprintf(stderr, "No valid symbol.\n");
+		exit(1);
+	}
+
 	optimize_result();
 }
 
@@ -672,9 +697,21 @@ static void optimize_token_table(void)
 int
 main(int argc, char **argv)
 {
-	if (argc == 2 && strcmp(argv[1], "--all-symbols") == 0)
-		all_symbols = 1;
-	else if (argc != 1)
+	if (argc >= 2) {
+		int i;
+		for (i = 1; i < argc; i++) {
+			if(strcmp(argv[i], "--all-symbols") == 0)
+				all_symbols = 1;
+			else if (strncmp(argv[i], "--symbol-prefix=", 16) == 0) {
+				char *p = &argv[i][16];
+				/* skip quote */
+				if ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))
+					p++;
+				symbol_prefix_char = *p;
+			} else
+				usage();
+		}
+	} else if (argc != 1)
 		usage();
 
 	read_map(stdin);
@@ -683,4 +720,3 @@ main(int argc, char **argv)
 
 	return 0;
 }
-

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
new file mode 100644
index 000000000000..090ffda4adbc
--- /dev/null
+++ b/scripts/kallsyms.c
@@ -0,0 +1,686 @@
+/* Generate assembler source containing symbol information
+ *
+ * Copyright 2002       by Kai Germaschewski
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] > symbols.S
+ *
+ * ChangeLog:
+ *
+ * (25/Aug/2004) Paulo Marques <pmarques@grupopie.com>
+ *      Changed the compression method from stem compression to "table lookup"
+ *      compression
+ *
+ *      Table compression uses all the unused char codes on the symbols and
+ *  maps these to the most used substrings (tokens). For instance, it might
+ *  map char code 0xF7 to represent "write_" and then in every symbol where
+ *  "write_" appears it can be replaced by 0xF7, saving 5 bytes.
+ *      The used codes themselves are also placed in the table so that the
+ *  decompresion can work without "special cases".
+ *      Applied to kernel symbols, this usually produces a compression ratio
+ *  of about 50%.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+/* maximum token length used. It doesn't pay to increase it a lot, because
+ * very long substrings probably don't repeat themselves too often. */
+#define MAX_TOK_SIZE		11
+#define KSYM_NAME_LEN		127
+
+/* we use only a subset of the complete symbol table to gather the token count,
+ * to speed up compression, at the expense of a little compression ratio */
+#define WORKING_SET		1024
+
+/* first find the best token only on the list of tokens that would profit more
+ * than GOOD_BAD_THRESHOLD. Only if this list is empty go to the "bad" list.
+ * Increasing this value will put less tokens on the "good" list, so the search
+ * is faster. However, if the good list runs out of tokens, we must painfully
+ * search the bad list. */
+#define GOOD_BAD_THRESHOLD	10
+
+/* token hash parameters */
+#define HASH_BITS		18
+#define HASH_TABLE_SIZE		(1 << HASH_BITS)
+#define HASH_MASK		(HASH_TABLE_SIZE - 1)
+#define HASH_BASE_OFFSET	2166136261U
+#define HASH_FOLD(a)		((a)&(HASH_MASK))
+
+/* flags to mark symbols */
+#define SYM_FLAG_VALID		1
+#define SYM_FLAG_SAMPLED	2
+
+struct sym_entry {
+	unsigned long long addr;
+	char type;
+	unsigned char flags;
+	unsigned char len;
+	unsigned char *sym;
+};
+
+
+static struct sym_entry *table;
+static int size, cnt;
+static unsigned long long _stext, _etext, _sinittext, _einittext;
+static int all_symbols = 0;
+
+struct token {
+	unsigned char data[MAX_TOK_SIZE];
+	unsigned char len;
+	/* profit: the number of bytes that could be saved by inserting this
+	 * token into the table */
+	int profit;
+	struct token *next;	/* next token on the hash list */
+	struct token *right;	/* next token on the good/bad list */
+	struct token *left;    /* previous token on the good/bad list */
+	struct token *smaller; /* token that is less one letter than this one */
+	};
+
+struct token bad_head, good_head;
+struct token *hash_table[HASH_TABLE_SIZE];
+
+/* the table that holds the result of the compression */
+unsigned char best_table[256][MAX_TOK_SIZE+1];
+unsigned char best_table_len[256];
+
+
+static void
+usage(void)
+{
+	fprintf(stderr, "Usage: kallsyms [--all-symbols] < in.map > out.S\n");
+	exit(1);
+}
+
+/*
+ * This ignores the intensely annoying "mapping symbols" found
+ * in ARM ELF files: $a, $t and $d.
+ */
+static inline int
+is_arm_mapping_symbol(const char *str)
+{
+	return str[0] == '$' && strchr("atd", str[1])
+	       && (str[2] == '\0' || str[2] == '.');
+}
+
+static int
+read_symbol(FILE *in, struct sym_entry *s)
+{
+	char str[500];
+	int rc;
+
+	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &s->type, str);
+	if (rc != 3) {
+		if (rc != EOF) {
+			/* skip line */
+			fgets(str, 500, in);
+		}
+		return -1;
+	}
+
+	/* Ignore most absolute/undefined (?) symbols. */
+	if (strcmp(str, "_stext") == 0)
+		_stext = s->addr;
+	else if (strcmp(str, "_etext") == 0)
+		_etext = s->addr;
+	else if (strcmp(str, "_sinittext") == 0)
+		_sinittext = s->addr;
+	else if (strcmp(str, "_einittext") == 0)
+		_einittext = s->addr;
+	else if (toupper(s->type) == 'A')
+	{
+		/* Keep these useful absolute symbols */
+		if (strcmp(str, "__kernel_syscall_via_break") &&
+		    strcmp(str, "__kernel_syscall_via_epc") &&
+		    strcmp(str, "__kernel_sigtramp") &&
+		    strcmp(str, "__gp"))
+			return -1;
+
+	}
+	else if (toupper(s->type) == 'U' ||
+		 is_arm_mapping_symbol(str))
+		return -1;
+
+	/* include the type field in the symbol name, so that it gets
+	 * compressed together */
+	s->len = strlen(str) + 1;
+	s->sym = (char *) malloc(s->len + 1);
+	strcpy(s->sym + 1, str);
+	s->sym[0] = s->type;
+
+	return 0;
+}
+
+static int
+symbol_valid(struct sym_entry *s)
+{
+	/* Symbols which vary between passes.  Passes 1 and 2 must have
+	 * identical symbol lists.  The kallsyms_* symbols below are only added
+	 * after pass 1, they would be included in pass 2 when --all-symbols is
+	 * specified so exclude them to get a stable symbol list.
+	 */
+	static char *special_symbols[] = {
+		"kallsyms_addresses",
+		"kallsyms_num_syms",
+		"kallsyms_names",
+		"kallsyms_markers",
+		"kallsyms_token_table",
+		"kallsyms_token_index",
+
+	/* Exclude linker generated symbols which vary between passes */
+		"_SDA_BASE_",		/* ppc */
+		"_SDA2_BASE_",		/* ppc */
+		NULL };
+	int i;
+
+	/* if --all-symbols is not specified, then symbols outside the text
+	 * and inittext sections are discarded */
+	if (!all_symbols) {
+		if ((s->addr < _stext || s->addr > _etext)
+		    && (s->addr < _sinittext || s->addr > _einittext))
+			return 0;
+		/* Corner case.  Discard any symbols with the same value as
+		 * _etext or _einittext, they can move between pass 1 and 2
+		 * when the kallsyms data is added.  If these symbols move then
+		 * they may get dropped in pass 2, which breaks the kallsyms
+		 * rules.
+		 */
+		if ((s->addr == _etext && strcmp(s->sym + 1, "_etext")) ||
+		    (s->addr == _einittext && strcmp(s->sym + 1, "_einittext")))
+			return 0;
+	}
+
+	/* Exclude symbols which vary between passes. */
+	if (strstr(s->sym + 1, "_compiled."))
+		return 0;
+
+	for (i = 0; special_symbols[i]; i++)
+		if( strcmp(s->sym + 1, special_symbols[i]) == 0 )
+			return 0;
+
+	return 1;
+}
+
+static void
+read_map(FILE *in)
+{
+	while (!feof(in)) {
+		if (cnt >= size) {
+			size += 10000;
+			table = realloc(table, sizeof(*table) * size);
+			if (!table) {
+				fprintf(stderr, "out of memory\n");
+				exit (1);
+			}
+		}
+		if (read_symbol(in, &table[cnt]) == 0)
+			cnt++;
+	}
+}
+
+static void output_label(char *label)
+{
+	printf(".globl %s\n",label);
+	printf("\tALGN\n");
+	printf("%s:\n",label);
+}
+
+/* uncompress a compressed symbol. When this function is called, the best table
+ * might still be compressed itself, so the function needs to be recursive */
+static int expand_symbol(unsigned char *data, int len, char *result)
+{
+	int c, rlen, total=0;
+
+	while (len) {
+		c = *data;
+		/* if the table holds a single char that is the same as the one
+		 * we are looking for, then end the search */
+		if (best_table[c][0]==c && best_table_len[c]==1) {
+			*result++ = c;
+			total++;
+		} else {
+			/* if not, recurse and expand */
+			rlen = expand_symbol(best_table[c], best_table_len[c], result);
+			total += rlen;
+			result += rlen;
+		}
+		data++;
+		len--;
+	}
+	*result=0;
+
+	return total;
+}
+
+static void
+write_src(void)
+{
+	int i, k, off, valid;
+	unsigned int best_idx[256];
+	unsigned int *markers;
+	char buf[KSYM_NAME_LEN+1];
+
+	printf("#include <asm/types.h>\n");
+	printf("#if BITS_PER_LONG == 64\n");
+	printf("#define PTR .quad\n");
+	printf("#define ALGN .align 8\n");
+	printf("#else\n");
+	printf("#define PTR .long\n");
+	printf("#define ALGN .align 4\n");
+	printf("#endif\n");
+
+	printf(".data\n");
+
+	output_label("kallsyms_addresses");
+	valid = 0;
+	for (i = 0; i < cnt; i++) {
+		if (table[i].flags & SYM_FLAG_VALID) {
+			printf("\tPTR\t%#llx\n", table[i].addr);
+			valid++;
+		}
+	}
+	printf("\n");
+
+	output_label("kallsyms_num_syms");
+	printf("\tPTR\t%d\n", valid);
+	printf("\n");
+
+	/* table of offset markers, that give the offset in the compressed stream
+	 * every 256 symbols */
+	markers = (unsigned int *) malloc(sizeof(unsigned int)*((valid + 255) / 256));
+
+	output_label("kallsyms_names");
+	valid = 0;
+	off = 0;
+	for (i = 0; i < cnt; i++) {
+
+		if (!table[i].flags & SYM_FLAG_VALID)
+			continue;
+
+		if ((valid & 0xFF) == 0)
+			markers[valid >> 8] = off;
+
+		printf("\t.byte 0x%02x", table[i].len);
+		for (k = 0; k < table[i].len; k++)
+			printf(", 0x%02x", table[i].sym[k]);
+		printf("\n");
+
+		off += table[i].len + 1;
+		valid++;
+	}
+	printf("\n");
+
+	output_label("kallsyms_markers");
+	for (i = 0; i < ((valid + 255) >> 8); i++)
+		printf("\tPTR\t%d\n", markers[i]);
+	printf("\n");
+
+	free(markers);
+
+	output_label("kallsyms_token_table");
+	off = 0;
+	for (i = 0; i < 256; i++) {
+		best_idx[i] = off;
+		expand_symbol(best_table[i],best_table_len[i],buf);
+		printf("\t.asciz\t\"%s\"\n", buf);
+		off += strlen(buf) + 1;
+	}
+	printf("\n");
+
+	output_label("kallsyms_token_index");
+	for (i = 0; i < 256; i++)
+		printf("\t.short\t%d\n", best_idx[i]);
+	printf("\n");
+}
+
+
+/* table lookup compression functions */
+
+static inline unsigned int rehash_token(unsigned int hash, unsigned char data)
+{
+	return ((hash * 16777619) ^ data);
+}
+
+static unsigned int hash_token(unsigned char *data, int len)
+{
+	unsigned int hash=HASH_BASE_OFFSET;
+	int i;
+
+	for (i = 0; i < len; i++)
+		hash = rehash_token(hash, data[i]);
+
+	return HASH_FOLD(hash);
+}
+
+/* find a token given its data and hash value */
+static struct token *find_token_hash(unsigned char *data, int len, unsigned int hash)
+{
+	struct token *ptr;
+
+	ptr = hash_table[hash];
+
+	while (ptr) {
+		if ((ptr->len == len) && (memcmp(ptr->data, data, len) == 0))
+			return ptr;
+		ptr=ptr->next;
+	}
+
+	return NULL;
+}
+
+static inline void insert_token_in_group(struct token *head, struct token *ptr)
+{
+	ptr->right = head->right;
+	ptr->right->left = ptr;
+	head->right = ptr;
+	ptr->left = head;
+}
+
+static inline void remove_token_from_group(struct token *ptr)
+{
+	ptr->left->right = ptr->right;
+	ptr->right->left = ptr->left;
+}
+
+
+/* build the counts for all the tokens that start with "data", and have lenghts
+ * from 2 to "len" */
+static void learn_token(unsigned char *data, int len)
+{
+	struct token *ptr,*last_ptr;
+	int i, newprofit;
+	unsigned int hash = HASH_BASE_OFFSET;
+	unsigned int hashes[MAX_TOK_SIZE + 1];
+
+	if (len > MAX_TOK_SIZE)
+		len = MAX_TOK_SIZE;
+
+	/* calculate and store the hash values for all the sub-tokens */
+	hash = rehash_token(hash, data[0]);
+	for (i = 2; i <= len; i++) {
+		hash = rehash_token(hash, data[i-1]);
+		hashes[i] = HASH_FOLD(hash);
+	}
+
+	last_ptr = NULL;
+	ptr = NULL;
+
+	for (i = len; i >= 2; i--) {
+		hash = hashes[i];
+
+		if (!ptr) ptr = find_token_hash(data, i, hash);
+
+		if (!ptr) {
+			/* create a new token entry */
+			ptr = (struct token *) malloc(sizeof(*ptr));
+
+			memcpy(ptr->data, data, i);
+			ptr->len = i;
+
+			/* when we create an entry, it's profit is 0 because
+			 * we also take into account the size of the token on
+			 * the compressed table. We then subtract GOOD_BAD_THRESHOLD
+			 * so that the test to see if this token belongs to
+			 * the good or bad list, is a comparison to zero */
+			ptr->profit = -GOOD_BAD_THRESHOLD;
+
+			ptr->next = hash_table[hash];
+			hash_table[hash] = ptr;
+
+			insert_token_in_group(&bad_head, ptr);
+
+			ptr->smaller = NULL;
+		} else {
+			newprofit = ptr->profit + (ptr->len - 1);
+			/* check to see if this token needs to be moved to a
+			 * different list */
+			if((ptr->profit < 0) && (newprofit >= 0)) {
+				remove_token_from_group(ptr);
+				insert_token_in_group(&good_head,ptr);
+			}
+			ptr->profit = newprofit;
+		}
+
+		if (last_ptr) last_ptr->smaller = ptr;
+		last_ptr = ptr;
+
+		ptr = ptr->smaller;
+	}
+}
+
+/* decrease the counts for all the tokens that start with "data", and have lenghts
+ * from 2 to "len". This function is much simpler than learn_token because we have
+ * more guarantees (tho tokens exist, the ->smaller pointer is set, etc.)
+ * The two separate functions exist only because of compression performance */
+static void forget_token(unsigned char *data, int len)
+{
+	struct token *ptr;
+	int i, newprofit;
+	unsigned int hash=0;
+
+	if (len > MAX_TOK_SIZE) len = MAX_TOK_SIZE;
+
+	hash = hash_token(data, len);
+	ptr = find_token_hash(data, len, hash);
+
+	for (i = len; i >= 2; i--) {
+
+		newprofit = ptr->profit - (ptr->len - 1);
+		if ((ptr->profit >= 0) && (newprofit < 0)) {
+			remove_token_from_group(ptr);
+			insert_token_in_group(&bad_head, ptr);
+		}
+		ptr->profit=newprofit;
+
+		ptr=ptr->smaller;
+	}
+}
+
+/* count all the possible tokens in a symbol */
+static void learn_symbol(unsigned char *symbol, int len)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++)
+		learn_token(symbol + i, len - i);
+}
+
+/* decrease the count for all the possible tokens in a symbol */
+static void forget_symbol(unsigned char *symbol, int len)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++)
+		forget_token(symbol + i, len - i);
+}
+
+/* set all the symbol flags and do the initial token count */
+static void build_initial_tok_table(void)
+{
+	int i, use_it, valid;
+
+	valid = 0;
+	for (i = 0; i < cnt; i++) {
+		table[i].flags = 0;
+		if ( symbol_valid(&table[i]) ) {
+			table[i].flags |= SYM_FLAG_VALID;
+			valid++;
+		}
+	}
+
+	use_it = 0;
+	for (i = 0; i < cnt; i++) {
+
+		/* subsample the available symbols. This method is almost like
+		 * a Bresenham's algorithm to get uniformly distributed samples
+		 * across the symbol table */
+		if (table[i].flags & SYM_FLAG_VALID) {
+
+			use_it += WORKING_SET;
+
+			if (use_it >= valid) {
+				table[i].flags |= SYM_FLAG_SAMPLED;
+				use_it -= valid;
+			}
+		}
+		if (table[i].flags & SYM_FLAG_SAMPLED)
+			learn_symbol(table[i].sym, table[i].len);
+	}
+}
+
+/* replace a given token in all the valid symbols. Use the sampled symbols
+ * to update the counts */
+static void compress_symbols(unsigned char *str, int tlen, int idx)
+{
+	int i, len, learn, size;
+	unsigned char *p;
+
+	for (i = 0; i < cnt; i++) {
+
+		if (!(table[i].flags & SYM_FLAG_VALID)) continue;
+
+		len = table[i].len;
+		learn = 0;
+		p = table[i].sym;
+
+		do {
+			/* find the token on the symbol */
+			p = (unsigned char *) strstr((char *) p, (char *) str);
+			if (!p) break;
+
+			if (!learn) {
+				/* if this symbol was used to count, decrease it */
+				if (table[i].flags & SYM_FLAG_SAMPLED)
+					forget_symbol(table[i].sym, len);
+				learn = 1;
+			}
+
+			*p = idx;
+			size = (len - (p - table[i].sym)) - tlen + 1;
+			memmove(p + 1, p + tlen, size);
+			p++;
+			len -= tlen - 1;
+
+		} while (size >= tlen);
+
+		if(learn) {
+			table[i].len = len;
+			/* if this symbol was used to count, learn it again */
+			if(table[i].flags & SYM_FLAG_SAMPLED)
+				learn_symbol(table[i].sym, len);
+		}
+	}
+}
+
+/* search the token with the maximum profit */
+static struct token *find_best_token(void)
+{
+	struct token *ptr,*best,*head;
+	int bestprofit;
+
+	bestprofit=-10000;
+
+	/* failsafe: if the "good" list is empty search from the "bad" list */
+	if(good_head.right == &good_head) head = &bad_head;
+	else head = &good_head;
+
+	ptr = head->right;
+	best = NULL;
+	while (ptr != head) {
+		if (ptr->profit > bestprofit) {
+			bestprofit = ptr->profit;
+			best = ptr;
+		}
+		ptr = ptr->right;
+	}
+
+	return best;
+}
+
+/* this is the core of the algorithm: calculate the "best" table */
+static void optimize_result(void)
+{
+	struct token *best;
+	int i;
+
+	/* using the '\0' symbol last allows compress_symbols to use standard
+	 * fast string functions */
+	for (i = 255; i >= 0; i--) {
+
+		/* if this table slot is empty (it is not used by an actual
+		 * original char code */
+		if (!best_table_len[i]) {
+
+			/* find the token with the breates profit value */
+			best = find_best_token();
+
+			/* place it in the "best" table */
+			best_table_len[i] = best->len;
+			memcpy(best_table[i], best->data, best_table_len[i]);
+			/* zero terminate the token so that we can use strstr
+			   in compress_symbols */
+			best_table[i][best_table_len[i]]='\0';
+
+			/* replace this token in all the valid symbols */
+			compress_symbols(best_table[i], best_table_len[i], i);
+		}
+	}
+}
+
+/* start by placing the symbols that are actually used on the table */
+static void insert_real_symbols_in_table(void)
+{
+	int i, j, c;
+
+	memset(best_table, 0, sizeof(best_table));
+	memset(best_table_len, 0, sizeof(best_table_len));
+
+	for (i = 0; i < cnt; i++) {
+		if (table[i].flags & SYM_FLAG_VALID) {
+			for (j = 0; j < table[i].len; j++) {
+				c = table[i].sym[j];
+				best_table[c][0]=c;
+				best_table_len[c]=1;
+			}
+		}
+	}
+}
+
+static void optimize_token_table(void)
+{
+	memset(hash_table, 0, sizeof(hash_table));
+
+	good_head.left = &good_head;
+	good_head.right = &good_head;
+
+	bad_head.left = &bad_head;
+	bad_head.right = &bad_head;
+
+	build_initial_tok_table();
+
+	insert_real_symbols_in_table();
+
+	optimize_result();
+}
+
+
+int
+main(int argc, char **argv)
+{
+	if (argc == 2 && strcmp(argv[1], "--all-symbols") == 0)
+		all_symbols = 1;
+	else if (argc != 1)
+		usage();
+
+	read_map(stdin);
+	optimize_token_table();
+	write_src();
+
+	return 0;
+}
+
