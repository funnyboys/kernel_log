commit 859c81750130844590a83eff847c6c55e2340ab1
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:56:01 2020 -0500

    modpost,fixdep: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 877ca2c88246..d98540552941 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -160,7 +160,7 @@ struct item {
 	struct item	*next;
 	unsigned int	len;
 	unsigned int	hash;
-	char		name[0];
+	char		name[];
 };
 
 #define HASHSZ 256

commit 3f9070a67a94a2765e99adf0913c30b683a1b840
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Feb 18 19:00:31 2020 +0900

    fixdep: remove redundant null character check
    
    If *q is '\0', the condition (isalnum(*q) || *q == '_') is false anyway.
    
    It is redundant to ensure non-zero *q.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index ad2041817985..877ca2c88246 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -246,7 +246,7 @@ static void parse_config_file(const char *p)
 		}
 		p += 7;
 		q = p;
-		while (*q && (isalnum(*q) || *q == '_'))
+		while (isalnum(*q) || *q == '_')
 			q++;
 		if (str_ends_with(p, q - p, "_MODULE"))
 			r = q - 7;

commit 87d660f08520ccde8569a2202ff346b376011663
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Feb 18 18:58:59 2020 +0900

    fixdep: remove unneeded code and comments about *.ver files
    
    This is probably stale code. In old days (~ Linux 2.5.59), Kbuild made
    genksyms generate include/linux/modules/*.ver files.
    
    The currenct Kbuild does not generate *.ver files at all.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 9ba47b0a47b9..ad2041817985 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -77,11 +77,6 @@
  * dependencies on include/config/my/option.h for every
  * CONFIG_MY_OPTION encountered in any of the prerequisites.
  *
- * It will also filter out all the dependencies on *.ver. We need
- * to make sure that the generated version checksum are globally up
- * to date before even starting the recursive build, so it's too late
- * at this point anyway.
- *
  * We don't even try to really parse the header files, but
  * merely grep, i.e. if CONFIG_FOO is mentioned in a comment, it will
  * be picked up as well. It's not a problem with respect to
@@ -299,8 +294,7 @@ static void *read_file(const char *filename)
 static int is_ignored_file(const char *s, int len)
 {
 	return str_ends_with(s, len, "include/generated/autoconf.h") ||
-	       str_ends_with(s, len, "include/generated/autoksyms.h") ||
-	       str_ends_with(s, len, ".ver");
+	       str_ends_with(s, len, "include/generated/autoksyms.h");
 }
 
 /*

commit 6f9ac9f4427ec0470ccffbf852cfaf326677cc21
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jun 25 15:54:19 2019 +0900

    fixdep: check return value of printf() and putchar()
    
    When there is not enough space on your storage device, the build will
    fail with 'No space left on device' error message.
    
    The reason is obvious from the message, so you will free up some disk
    space, then you will resume the build.
    
    However, sometimes you may still see a mysterious error message:
    
      unterminated call to function 'wildcard': missing ')'.
    
    If you run out of the disk space, fixdep may end up with generating
    incomplete .*.cmd files.
    
    For example, if the disk-full error occurs while fixdep is running
    print_dep(), the .*.cmd might be truncated like this:
    
       $(wildcard include/config/
    
    When you run 'make' next time, this broken .*.cmd will be included,
    then Make will terminate parsing since it is a wrong syntax.
    
    Once this happens, you need to run 'make clean' or delete the broken
    .*.cmd file manually.
    
    Even if you do not see any error message, the .*.cmd files after any
    error could be potentially incomplete, and unreliable. You may miss
    the re-compilation due to missing header dependency.
    
    If printf() cannot output the string for disk shortage or whatever
    reason, it returns a negative value, but currently fixdep does not
    check it at all. Consequently, fixdep *successfully* generates a
    broken .*.cmd file. Make never notices that since fixdep exits with 0,
    which means success.
    
    Given the intended usage of fixdep, it must respect the return value
    of not only malloc(), but also printf() and putchar().
    
    This seems a long-standing issue since the introduction of fixdep.
    
    In old days, Kbuild tried to provide an extra safety by letting fixdep
    output to a temporary file and renaming it after everything is done:
    
      scripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).tmp;\
      rm -f $(depfile);                                                    \
      mv -f $(dot-target).tmp $(dot-target).cmd)
    
    It was no help to avoid the current issue; fixdep successfully created
    a truncated tmp file, which would be renamed to a .*.cmd file.
    
    This problem should be fixed by propagating the error status to the
    build system because:
    
    [1] Since commit 9c2af1c7377a ("kbuild: add .DELETE_ON_ERROR special
        target"), Make will delete the target automatically on any failure
        in the recipe.
    
    [2] Since commit 392885ee82d3 ("kbuild: let fixdep directly write to
        .*.cmd files"), .*.cmd file is included only when the corresponding
        target already exists.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index facbd603adf6..9ba47b0a47b9 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -99,6 +99,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <string.h>
+#include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <ctype.h>
@@ -109,6 +110,36 @@ static void usage(void)
 	exit(1);
 }
 
+/*
+ * In the intended usage of this program, the stdout is redirected to .*.cmd
+ * files. The return value of printf() and putchar() must be checked to catch
+ * any error, e.g. "No space left on device".
+ */
+static void xprintf(const char *format, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, format);
+	ret = vprintf(format, ap);
+	if (ret < 0) {
+		perror("fixdep");
+		exit(1);
+	}
+	va_end(ap);
+}
+
+static void xputchar(int c)
+{
+	int ret;
+
+	ret = putchar(c);
+	if (ret == EOF) {
+		perror("fixdep");
+		exit(1);
+	}
+}
+
 /*
  * Print out a dependency path from a symbol name
  */
@@ -116,7 +147,7 @@ static void print_dep(const char *m, int slen, const char *dir)
 {
 	int c, prev_c = '/', i;
 
-	printf("    $(wildcard %s/", dir);
+	xprintf("    $(wildcard %s/", dir);
 	for (i = 0; i < slen; i++) {
 		c = m[i];
 		if (c == '_')
@@ -124,10 +155,10 @@ static void print_dep(const char *m, int slen, const char *dir)
 		else
 			c = tolower(c);
 		if (c != '/' || prev_c != '/')
-			putchar(c);
+			xputchar(c);
 		prev_c = c;
 	}
-	printf(".h) \\\n");
+	xprintf(".h) \\\n");
 }
 
 struct item {
@@ -324,13 +355,13 @@ static void parse_dep_file(char *m, const char *target)
 				 */
 				if (!saw_any_target) {
 					saw_any_target = 1;
-					printf("source_%s := %s\n\n",
-					       target, m);
-					printf("deps_%s := \\\n", target);
+					xprintf("source_%s := %s\n\n",
+						target, m);
+					xprintf("deps_%s := \\\n", target);
 				}
 				is_first_dep = 0;
 			} else {
-				printf("  %s \\\n", m);
+				xprintf("  %s \\\n", m);
 			}
 
 			buf = read_file(m);
@@ -353,8 +384,8 @@ static void parse_dep_file(char *m, const char *target)
 		exit(1);
 	}
 
-	printf("\n%s: $(deps_%s)\n\n", target, target);
-	printf("$(deps_%s):\n", target);
+	xprintf("\n%s: $(deps_%s)\n\n", target, target);
+	xprintf("$(deps_%s):\n", target);
 }
 
 int main(int argc, char *argv[])
@@ -369,7 +400,7 @@ int main(int argc, char *argv[])
 	target = argv[2];
 	cmdline = argv[3];
 
-	printf("cmd_%s := %s\n\n", target, cmdline);
+	xprintf("cmd_%s := %s\n\n", target, cmdline);
 
 	buf = read_file(depfile);
 	parse_dep_file(buf, target);

commit bbda5ec671d3fe62faefa1cab7270aa586042a4b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 10:05:26 2018 +0900

    kbuild: simplify dependency generation for CONFIG_TRIM_UNUSED_KSYMS
    
    My main motivation of this commit is to clean up scripts/Kbuild.include
    and scripts/Makefile.build.
    
    Currently, CONFIG_TRIM_UNUSED_KSYMS works with a tricky gimmick;
    possibly exported symbols are detected by letting $(CPP) replace
    EXPORT_SYMBOL* with a special string '=== __KSYM_*===', which is
    post-processed by sed, and passed to fixdep. The extra preprocessing
    is costly, and hacking cmd_and_fixdep is ugly.
    
    I came up with a new way to find exported symbols; insert a dummy
    symbol __ksym_marker_* to each potentially exported symbol. Those
    dummy symbols are picked up by $(NM), post-processed by sed, then
    appended to .*.cmd files. I collected the post-process part to a
    new shell script scripts/gen_ksymdeps.sh for readability. The dummy
    symbols are put into the .discard.* section so that the linker
    script rips them off the final vmlinux or modules.
    
    A nice side-effect is building with CONFIG_TRIM_UNUSED_KSYMS will
    be much faster.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 850966f3d602..facbd603adf6 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -105,8 +105,7 @@
 
 static void usage(void)
 {
-	fprintf(stderr, "Usage: fixdep [-e] <depfile> <target> <cmdline>\n");
-	fprintf(stderr, " -e  insert extra dependencies given on stdin\n");
+	fprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");
 	exit(1);
 }
 
@@ -131,21 +130,6 @@ static void print_dep(const char *m, int slen, const char *dir)
 	printf(".h) \\\n");
 }
 
-static void do_extra_deps(void)
-{
-	char buf[80];
-
-	while (fgets(buf, sizeof(buf), stdin)) {
-		int len = strlen(buf);
-
-		if (len < 2 || buf[len - 1] != '\n') {
-			fprintf(stderr, "fixdep: bad data on stdin\n");
-			exit(1);
-		}
-		print_dep(buf, len - 1, "include/ksym");
-	}
-}
-
 struct item {
 	struct item	*next;
 	unsigned int	len;
@@ -293,7 +277,7 @@ static int is_ignored_file(const char *s, int len)
  * assignments are parsed not only by make, but also by the rather simple
  * parser in scripts/mod/sumversion.c.
  */
-static void parse_dep_file(char *m, const char *target, int insert_extra_deps)
+static void parse_dep_file(char *m, const char *target)
 {
 	char *p;
 	int is_last, is_target;
@@ -369,9 +353,6 @@ static void parse_dep_file(char *m, const char *target, int insert_extra_deps)
 		exit(1);
 	}
 
-	if (insert_extra_deps)
-		do_extra_deps();
-
 	printf("\n%s: $(deps_%s)\n\n", target, target);
 	printf("$(deps_%s):\n", target);
 }
@@ -379,13 +360,9 @@ static void parse_dep_file(char *m, const char *target, int insert_extra_deps)
 int main(int argc, char *argv[])
 {
 	const char *depfile, *target, *cmdline;
-	int insert_extra_deps = 0;
 	void *buf;
 
-	if (argc == 5 && !strcmp(argv[1], "-e")) {
-		insert_extra_deps = 1;
-		argv++;
-	} else if (argc != 4)
+	if (argc != 4)
 		usage();
 
 	depfile = argv[1];
@@ -395,7 +372,7 @@ int main(int argc, char *argv[])
 	printf("cmd_%s := %s\n\n", target, cmdline);
 
 	buf = read_file(depfile);
-	parse_dep_file(buf, target, insert_extra_deps);
+	parse_dep_file(buf, target);
 	free(buf);
 
 	return 0;

commit b3aa58d2e85d5253a35a81320ae4d63ba6a482f0
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Apr 16 15:07:57 2018 -0400

    fixdep: suppress consecutive / from file paths in dependency list files
    
    Underscores in symbol names are translated into slashes for path names.
    Filesystems treat consecutive slashes as if there was only one, so
    let's do the same in the dependency list for easier grepping, etc.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index f387538c58bc..850966f3d602 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -115,7 +115,7 @@ static void usage(void)
  */
 static void print_dep(const char *m, int slen, const char *dir)
 {
-	int c, i;
+	int c, prev_c = '/', i;
 
 	printf("    $(wildcard %s/", dir);
 	for (i = 0; i < slen; i++) {
@@ -124,7 +124,9 @@ static void print_dep(const char *m, int slen, const char *dir)
 			c = '/';
 		else
 			c = tolower(c);
-		putchar(c);
+		if (c != '/' || prev_c != '/')
+			putchar(c);
+		prev_c = c;
 	}
 	printf(".h) \\\n");
 }

commit fbfa9be9904e2c0d0c97d860fd071089d21dd9be
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Mar 16 16:37:14 2018 +0900

    kbuild: move include/config/ksym/* to include/ksym/*
    
    The idea of using fixdep was inspired by Kconfig, but autoksyms
    belongs to a different group.  So, I want to move those touched
    files under include/config/ksym/ to include/ksym/.
    
    The directory include/ksym/ can be removed by 'make clean' because
    it is meaningless for the external module building.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 449b68c4c90c..f387538c58bc 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -113,11 +113,11 @@ static void usage(void)
 /*
  * Print out a dependency path from a symbol name
  */
-static void print_config(const char *m, int slen)
+static void print_dep(const char *m, int slen, const char *dir)
 {
 	int c, i;
 
-	printf("    $(wildcard include/config/");
+	printf("    $(wildcard %s/", dir);
 	for (i = 0; i < slen; i++) {
 		c = m[i];
 		if (c == '_')
@@ -140,7 +140,7 @@ static void do_extra_deps(void)
 			fprintf(stderr, "fixdep: bad data on stdin\n");
 			exit(1);
 		}
-		print_config(buf, len - 1);
+		print_dep(buf, len - 1, "include/ksym");
 	}
 }
 
@@ -208,7 +208,7 @@ static void use_config(const char *m, int slen)
 	    return;
 
 	define_config(m, slen, hash);
-	print_config(m, slen);
+	print_dep(m, slen, "include/config");
 }
 
 /* test if s ends in sub */

commit 638e69cf2230737655fcb5ee9879c2fab7679187
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Feb 28 20:17:37 2018 +0100

    fixdep: do not ignore kconfig.h
    
    kconfig.h was excluded from consideration by fixdep by
    6a5be57f0f00 (fixdep: fix extraneous dependencies) to avoid some false
    positive hits
    
    (1) include/config/.h
    (2) include/config/h.h
    (3) include/config/foo.h
    
    (1) occurred because kconfig.h contains the string CONFIG_ in a
    comment. However, since dee81e988674 (fixdep: faster CONFIG_ search), we
    have a check that the part after CONFIG_ is non-empty, so this does not
    happen anymore (and CONFIG_ appears by itself elsewhere, so that check
    is worthwhile).
    
    (2) comes from the include guard, __LINUX_KCONFIG_H. But with the
    previous patch, we no longer match that either.
    
    That leaves (3), which amounts to one [1] false dependency (aka stat() call
    done by make), which I think we can live with:
    
    We've already had one case [2] where the lack of include/linux/kconfig.h in
    the .o.cmd file caused a missing rebuild, and while I originally thought
    we should just put kconfig.h in the dependency list without parsing it
    for the CONFIG_ pattern, we actually do have some real CONFIG_ symbols
    mentioned in it, and one can imagine some translation unit that just
    does '#ifdef __BIG_ENDIAN' but doesn't through some other header
    actually depend on CONFIG_CPU_BIG_ENDIAN - so changing the target
    endianness could end up rebuilding the world, minus that small
    TU. Quoting Linus,
    
      ... when missing dependencies cause a missed re-compile, the resulting
      bugs can be _really_ subtle.
    
    [1] well, two, we now also have CONFIG_BOOGER/booger.h - we could change
    that to FOO if we care
    
    [2] https://lkml.org/lkml/2018/2/22/838
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 1b21870d6e7f..449b68c4c90c 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -283,7 +283,6 @@ static int is_ignored_file(const char *s, int len)
 {
 	return str_ends_with(s, len, "include/generated/autoconf.h") ||
 	       str_ends_with(s, len, "include/generated/autoksyms.h") ||
-	       str_ends_with(s, len, "include/linux/kconfig.h") ||
 	       str_ends_with(s, len, ".ver");
 }
 

commit 5b8ad96d1a4421ffe417e647a65064aad1e84fb4
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Feb 28 20:17:36 2018 +0100

    fixdep: remove some false CONFIG_ matches
    
    The string CONFIG_ quite often appears after other alphanumerics,
    meaning that that instance cannot be referencing a Kconfig
    symbol. Omitting these means make has fewer files to stat() when
    deciding what needs to be rebuilt - for a defconfig build, this seems to
    remove about 2% of the (wildcard ...) lines from the .o.cmd files.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index d7fbe545dd5d..1b21870d6e7f 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -225,8 +225,13 @@ static int str_ends_with(const char *s, int slen, const char *sub)
 static void parse_config_file(const char *p)
 {
 	const char *q, *r;
+	const char *start = p;
 
 	while ((p = strstr(p, "CONFIG_"))) {
+		if (p > start && (isalnum(p[-1]) || p[-1] == '_')) {
+			p += 7;
+			continue;
+		}
 		p += 7;
 		q = p;
 		while (*q && (isalnum(*q) || *q == '_'))

commit 14a596a7e6fd9c5baa6b2cfc57962e2c3bda6c69
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Feb 28 20:17:35 2018 +0100

    fixdep: remove stale references to uml-config.h
    
    uml-config.h hasn't existed in this decade (87e299e5c750 - x86, um: get
    rid of uml-config.h). The few remaining UML_CONFIG instances are defined
    directly in terms of their real CONFIG symbol in common-offsets.h, so
    unlike when the symbols got defined via a sed script, anything that uses
    UML_CONFIG_FOO now should also automatically pick up a dependency on
    CONFIG_FOO via the normal fixdep mechanism (since common-offsets.h
    should at least recursively be a dependency). Hence I believe we should
    actually be able to ignore the HELLO_CONFIG_BOOM cases.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index fa3d39b6f23b..d7fbe545dd5d 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -93,14 +93,6 @@
  * (Note: it'd be easy to port over the complete mkdep state machine,
  *  but I don't think the added complexity is worth it)
  */
-/*
- * Note 2: if somebody writes HELLO_CONFIG_BOOM in a file, it will depend onto
- * CONFIG_BOOM. This could seem a bug (not too hard to fix), but please do not
- * fix it! Some UserModeLinux files (look at arch/um/) call CONFIG_BOOM as
- * UML_CONFIG_BOOM, to avoid conflicts with /usr/include/linux/autoconf.h,
- * through arch/um/include/uml-config.h; this fixdep "bug" makes sure that
- * those files will have correct dependencies.
- */
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -286,7 +278,6 @@ static int is_ignored_file(const char *s, int len)
 {
 	return str_ends_with(s, len, "include/generated/autoconf.h") ||
 	       str_ends_with(s, len, "include/generated/autoksyms.h") ||
-	       str_ends_with(s, len, "arch/um/include/uml-config.h") ||
 	       str_ends_with(s, len, "include/linux/kconfig.h") ||
 	       str_ends_with(s, len, ".ver");
 }

commit ab9ce9feed362f3f51e239f9421b220aaf9211aa
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:46 2018 +0900

    fixdep: use existing helper to check modular CONFIG options
    
    str_ends_with() tests if the given token ends with a particular string.
    Currently, it is used to check file paths without $(srctree).
    
    Actually, we have one more place where this helper is useful.  Use it
    to check if CONFIG option ends with _MODULE.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 0abc15778f56..fa3d39b6f23b 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -219,6 +219,17 @@ static void use_config(const char *m, int slen)
 	print_config(m, slen);
 }
 
+/* test if s ends in sub */
+static int str_ends_with(const char *s, int slen, const char *sub)
+{
+	int sublen = strlen(sub);
+
+	if (sublen > slen)
+		return 0;
+
+	return !memcmp(s + slen - sublen, sub, sublen);
+}
+
 static void parse_config_file(const char *p)
 {
 	const char *q, *r;
@@ -228,7 +239,7 @@ static void parse_config_file(const char *p)
 		q = p;
 		while (*q && (isalnum(*q) || *q == '_'))
 			q++;
-		if (memcmp(q - 7, "_MODULE", 7) == 0)
+		if (str_ends_with(p, q - p, "_MODULE"))
 			r = q - 7;
 		else
 			r = q;
@@ -238,17 +249,6 @@ static void parse_config_file(const char *p)
 	}
 }
 
-/* test if s ends in sub */
-static int str_ends_with(const char *s, int slen, const char *sub)
-{
-	int sublen = strlen(sub);
-
-	if (sublen > slen)
-		return 0;
-
-	return !memcmp(s + slen - sublen, sub, sublen);
-}
-
 static void *read_file(const char *filename)
 {
 	struct stat st;

commit 87b95a81357dd6ec679a786cebfe34d0e797f752
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:45 2018 +0900

    fixdep: refactor parse_dep_file()
    
    parse_dep_file() has too much indentation, and puts the code far to
    the right.  This commit refactors the code and reduces the one level
    of indentation.
    
    strrcmp() computes 'slen' by itself, but the caller already knows the
    length of the token, so 'slen' can be passed via function argument.
    With this, we can swap the order of strrcmp() and "*p = \0;"
    
    Also, strrcmp() is an ambiguous function name.  Flip the logic and
    rename it to str_ends_with().
    
    I added a new helper is_ignored_file() - this returns 1 if the token
    represents a file that should be ignored.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index d33b5a4c9ecb..0abc15778f56 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -239,15 +239,14 @@ static void parse_config_file(const char *p)
 }
 
 /* test if s ends in sub */
-static int strrcmp(const char *s, const char *sub)
+static int str_ends_with(const char *s, int slen, const char *sub)
 {
-	int slen = strlen(s);
 	int sublen = strlen(sub);
 
 	if (sublen > slen)
-		return 1;
+		return 0;
 
-	return memcmp(s + slen - sublen, sub, sublen);
+	return !memcmp(s + slen - sublen, sub, sublen);
 }
 
 static void *read_file(const char *filename)
@@ -282,6 +281,16 @@ static void *read_file(const char *filename)
 	return buf;
 }
 
+/* Ignore certain dependencies */
+static int is_ignored_file(const char *s, int len)
+{
+	return str_ends_with(s, len, "include/generated/autoconf.h") ||
+	       str_ends_with(s, len, "include/generated/autoksyms.h") ||
+	       str_ends_with(s, len, "arch/um/include/uml-config.h") ||
+	       str_ends_with(s, len, "include/linux/kconfig.h") ||
+	       str_ends_with(s, len, ".ver");
+}
+
 /*
  * Important: The below generated source_foo.o and deps_foo.o variable
  * assignments are parsed not only by make, but also by the rather simple
@@ -314,47 +323,38 @@ static void parse_dep_file(char *m, const char *target, int insert_extra_deps)
 		if (is_target) {
 			/* The /next/ file is the first dependency */
 			is_first_dep = 1;
-		} else {
+		} else if (!is_ignored_file(m, p - m)) {
 			*p = '\0';
 
-			/* Ignore certain dependencies */
-			if (strrcmp(m, "include/generated/autoconf.h") &&
-			    strrcmp(m, "include/generated/autoksyms.h") &&
-			    strrcmp(m, "arch/um/include/uml-config.h") &&
-			    strrcmp(m, "include/linux/kconfig.h") &&
-			    strrcmp(m, ".ver")) {
+			/*
+			 * Do not list the source file as dependency, so that
+			 * kbuild is not confused if a .c file is rewritten
+			 * into .S or vice versa. Storing it in source_* is
+			 * needed for modpost to compute srcversions.
+			 */
+			if (is_first_dep) {
 				/*
-				 * Do not list the source file as dependency,
-				 * so that kbuild is not confused if a .c file
-				 * is rewritten into .S or vice versa. Storing
-				 * it in source_* is needed for modpost to
-				 * compute srcversions.
+				 * If processing the concatenation of multiple
+				 * dependency files, only process the first
+				 * target name, which will be the original
+				 * source name, and ignore any other target
+				 * names, which will be intermediate temporary
+				 * files.
 				 */
-				if (is_first_dep) {
-					/*
-					 * If processing the concatenation of
-					 * multiple dependency files, only
-					 * process the first target name, which
-					 * will be the original source name,
-					 * and ignore any other target names,
-					 * which will be intermediate temporary
-					 * files.
-					 */
-					if (!saw_any_target) {
-						saw_any_target = 1;
-						printf("source_%s := %s\n\n",
-							target, m);
-						printf("deps_%s := \\\n",
-							target);
-					}
-					is_first_dep = 0;
-				} else
-					printf("  %s \\\n", m);
-
-				buf = read_file(m);
-				parse_config_file(buf);
-				free(buf);
+				if (!saw_any_target) {
+					saw_any_target = 1;
+					printf("source_%s := %s\n\n",
+					       target, m);
+					printf("deps_%s := \\\n", target);
+				}
+				is_first_dep = 0;
+			} else {
+				printf("  %s \\\n", m);
 			}
+
+			buf = read_file(m);
+			parse_config_file(buf);
+			free(buf);
 		}
 
 		if (is_last)

commit 5d1ef76f5a22ea07120671c5fcddafd365000cc9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:44 2018 +0900

    fixdep: move global variables to local variables of main()
    
    I do not mind global variables where they are useful enough.  In this
    case, I do not see a good reason to use global variables since they
    are just referenced in shallow places.  It is easy to pass them via
    function arguments.
    
    I squashed print_cmdline() into main() since it is just one line code.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index dfba77b5d0c3..d33b5a4c9ecb 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -111,11 +111,6 @@
 #include <stdio.h>
 #include <ctype.h>
 
-int insert_extra_deps;
-char *target;
-char *depfile;
-char *cmdline;
-
 static void usage(void)
 {
 	fprintf(stderr, "Usage: fixdep [-e] <depfile> <target> <cmdline>\n");
@@ -123,14 +118,6 @@ static void usage(void)
 	exit(1);
 }
 
-/*
- * Print out the commandline prefixed with cmd_<target filename> :=
- */
-static void print_cmdline(void)
-{
-	printf("cmd_%s := %s\n\n", target, cmdline);
-}
-
 /*
  * Print out a dependency path from a symbol name
  */
@@ -152,16 +139,16 @@ static void print_config(const char *m, int slen)
 
 static void do_extra_deps(void)
 {
-	if (insert_extra_deps) {
-		char buf[80];
-		while(fgets(buf, sizeof(buf), stdin)) {
-			int len = strlen(buf);
-			if (len < 2 || buf[len-1] != '\n') {
-				fprintf(stderr, "fixdep: bad data on stdin\n");
-				exit(1);
-			}
-			print_config(buf, len-1);
+	char buf[80];
+
+	while (fgets(buf, sizeof(buf), stdin)) {
+		int len = strlen(buf);
+
+		if (len < 2 || buf[len - 1] != '\n') {
+			fprintf(stderr, "fixdep: bad data on stdin\n");
+			exit(1);
 		}
+		print_config(buf, len - 1);
 	}
 }
 
@@ -300,7 +287,7 @@ static void *read_file(const char *filename)
  * assignments are parsed not only by make, but also by the rather simple
  * parser in scripts/mod/sumversion.c.
  */
-static void parse_dep_file(char *m)
+static void parse_dep_file(char *m, const char *target, int insert_extra_deps)
 {
 	char *p;
 	int is_last, is_target;
@@ -385,7 +372,8 @@ static void parse_dep_file(char *m)
 		exit(1);
 	}
 
-	do_extra_deps();
+	if (insert_extra_deps)
+		do_extra_deps();
 
 	printf("\n%s: $(deps_%s)\n\n", target, target);
 	printf("$(deps_%s):\n", target);
@@ -393,6 +381,8 @@ static void parse_dep_file(char *m)
 
 int main(int argc, char *argv[])
 {
+	const char *depfile, *target, *cmdline;
+	int insert_extra_deps = 0;
 	void *buf;
 
 	if (argc == 5 && !strcmp(argv[1], "-e")) {
@@ -405,10 +395,10 @@ int main(int argc, char *argv[])
 	target = argv[2];
 	cmdline = argv[3];
 
-	print_cmdline();
+	printf("cmd_%s := %s\n\n", target, cmdline);
 
 	buf = read_file(depfile);
-	parse_dep_file(buf);
+	parse_dep_file(buf, target, insert_extra_deps);
 	free(buf);
 
 	return 0;

commit ccfe78873c22561d3c514790094dc408e4876077
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:43 2018 +0900

    fixdep: remove unneeded memcpy() in parse_dep_file()
    
    Each token in the depfile is copied to the temporary buffer 's' to
    terminate the token with zero.  We do not need to do this any more
    because the parsed buffer is now writable.  Insert '\0' directly in
    the buffer without calling memcpy().
    
    <limits.h> is no longer necessary. (It was needed for PATH_MAX).
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 9f9238eaec19..dfba77b5d0c3 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -109,7 +109,6 @@
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include <limits.h>
 #include <ctype.h>
 
 int insert_extra_deps;
@@ -304,7 +303,6 @@ static void *read_file(const char *filename)
 static void parse_dep_file(char *m)
 {
 	char *p;
-	char s[PATH_MAX];
 	int is_last, is_target;
 	int saw_any_target = 0;
 	int is_first_dep = 0;
@@ -330,16 +328,14 @@ static void parse_dep_file(char *m)
 			/* The /next/ file is the first dependency */
 			is_first_dep = 1;
 		} else {
-			/* Save this token/filename */
-			memcpy(s, m, p-m);
-			s[p - m] = 0;
+			*p = '\0';
 
 			/* Ignore certain dependencies */
-			if (strrcmp(s, "include/generated/autoconf.h") &&
-			    strrcmp(s, "include/generated/autoksyms.h") &&
-			    strrcmp(s, "arch/um/include/uml-config.h") &&
-			    strrcmp(s, "include/linux/kconfig.h") &&
-			    strrcmp(s, ".ver")) {
+			if (strrcmp(m, "include/generated/autoconf.h") &&
+			    strrcmp(m, "include/generated/autoksyms.h") &&
+			    strrcmp(m, "arch/um/include/uml-config.h") &&
+			    strrcmp(m, "include/linux/kconfig.h") &&
+			    strrcmp(m, ".ver")) {
 				/*
 				 * Do not list the source file as dependency,
 				 * so that kbuild is not confused if a .c file
@@ -360,15 +356,15 @@ static void parse_dep_file(char *m)
 					if (!saw_any_target) {
 						saw_any_target = 1;
 						printf("source_%s := %s\n\n",
-							target, s);
+							target, m);
 						printf("deps_%s := \\\n",
 							target);
 					}
 					is_first_dep = 0;
 				} else
-					printf("  %s \\\n", s);
+					printf("  %s \\\n", m);
 
-				buf = read_file(s);
+				buf = read_file(m);
 				parse_config_file(buf);
 				free(buf);
 			}

commit 4003fd80cba967e4044ebac96f13746153e87c4d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:42 2018 +0900

    fixdep: factor out common code for reading files
    
    Now, do_config_files() and print_deps() are almost the same.  Only
    the difference is the parser function called (parse_config_file vs
    parse_dep_file).
    
    We can reduce the code duplication by factoring out the common code
    into read_file() - this function allocates a buffer and loads a file
    to it.  It returns the pointer to the allocated buffer.  (As before,
    it bails out by exit(2) for any error.)  The caller must free the
    buffer when done.
    
    Having empty source files is possible; fixdep should simply skip them.
    I deleted the "st.st_size == 0" check, so read_file() allocates 1-byte
    buffer for an empty file.  strstr() will immediately return NULL, and
    this is what we expect.
    
    On the other hand, an empty dep_file should be treated as an error.
    In this case, parse_dep_file() will error out with "no targets found"
    and it is a correct error message.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 91bb4c13f121..9f9238eaec19 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -264,42 +264,36 @@ static int strrcmp(const char *s, const char *sub)
 	return memcmp(s + slen - sublen, sub, sublen);
 }
 
-static void do_config_file(const char *filename)
+static void *read_file(const char *filename)
 {
 	struct stat st;
 	int fd;
-	char *map;
+	char *buf;
 
 	fd = open(filename, O_RDONLY);
 	if (fd < 0) {
-		fprintf(stderr, "fixdep: error opening config file: ");
+		fprintf(stderr, "fixdep: error opening file: ");
 		perror(filename);
 		exit(2);
 	}
 	if (fstat(fd, &st) < 0) {
-		fprintf(stderr, "fixdep: error fstat'ing config file: ");
+		fprintf(stderr, "fixdep: error fstat'ing file: ");
 		perror(filename);
 		exit(2);
 	}
-	if (st.st_size == 0) {
-		close(fd);
-		return;
-	}
-	map = malloc(st.st_size + 1);
-	if (!map) {
+	buf = malloc(st.st_size + 1);
+	if (!buf) {
 		perror("fixdep: malloc");
 		exit(2);
 	}
-	if (read(fd, map, st.st_size) != st.st_size) {
+	if (read(fd, buf, st.st_size) != st.st_size) {
 		perror("fixdep: read");
 		exit(2);
 	}
-	map[st.st_size] = '\0';
+	buf[st.st_size] = '\0';
 	close(fd);
 
-	parse_config_file(map);
-
-	free(map);
+	return buf;
 }
 
 /*
@@ -314,6 +308,7 @@ static void parse_dep_file(char *m)
 	int is_last, is_target;
 	int saw_any_target = 0;
 	int is_first_dep = 0;
+	void *buf;
 
 	while (1) {
 		/* Skip any "white space" */
@@ -372,7 +367,10 @@ static void parse_dep_file(char *m)
 					is_first_dep = 0;
 				} else
 					printf("  %s \\\n", s);
-				do_config_file(s);
+
+				buf = read_file(s);
+				parse_config_file(buf);
+				free(buf);
 			}
 		}
 
@@ -397,46 +395,10 @@ static void parse_dep_file(char *m)
 	printf("$(deps_%s):\n", target);
 }
 
-static void print_deps(const char *filename)
-{
-	struct stat st;
-	int fd;
-	char *buf;
-
-	fd = open(filename, O_RDONLY);
-	if (fd < 0) {
-		fprintf(stderr, "fixdep: error opening depfile: ");
-		perror(filename);
-		exit(2);
-	}
-	if (fstat(fd, &st) < 0) {
-		fprintf(stderr, "fixdep: error fstat'ing depfile: ");
-		perror(filename);
-		exit(2);
-	}
-	if (st.st_size == 0) {
-		close(fd);
-		return;
-	}
-	buf = malloc(st.st_size + 1);
-	if (!buf) {
-		perror("fixdep: malloc");
-		exit(2);
-	}
-	if (read(fd, buf, st.st_size) != st.st_size) {
-		perror("fixdep: read");
-		exit(2);
-	}
-	buf[st.st_size] = '\0';
-	close(fd);
-
-	parse_dep_file(buf);
-
-	free(buf);
-}
-
 int main(int argc, char *argv[])
 {
+	void *buf;
+
 	if (argc == 5 && !strcmp(argv[1], "-e")) {
 		insert_extra_deps = 1;
 		argv++;
@@ -448,7 +410,10 @@ int main(int argc, char *argv[])
 	cmdline = argv[3];
 
 	print_cmdline();
-	print_deps(depfile);
+
+	buf = read_file(depfile);
+	parse_dep_file(buf);
+	free(buf);
 
 	return 0;
 }

commit 01b5cbe7012fb1eeffc5c143865569835bcd405e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:41 2018 +0900

    fixdep: use malloc() and read() to load dep_file to buffer
    
    Commit dee81e988674 ("fixdep: faster CONFIG_ search") changed how to
    read files in which CONFIG options are searched.  It used malloc()
    and read() instead of mmap() because it needed to zero-terminate the
    buffer in order to use strstr().  print_deps() was left untouched
    since there was no reason to change it.
    
    Now, I have two motivations to change it in the same way.
    
     - do_config_file() and print_deps() do quite similar things; they
       open a file, load it onto memory, and pass it to a parser function.
       If we use malloc() and read() for print_deps() too, we can factor
       out the common code.  (I will do this in the next commit.)
    
     - parse_dep_file() copies each token to a temporary buffer because
       it needs to zero-terminate it to be passed to printf().  It is not
       possible to modify the buffer directly because it is mmap'ed with
       O_RDONLY.  If we load the file content into a malloc'ed buffer, we
       can insert '\0' after each token, and save memcpy().  (I will do
       this in the commit after next.)
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index b9b4bbf4e8dd..91bb4c13f121 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -104,7 +104,6 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/mman.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <string.h>
@@ -308,24 +307,27 @@ static void do_config_file(const char *filename)
  * assignments are parsed not only by make, but also by the rather simple
  * parser in scripts/mod/sumversion.c.
  */
-static void parse_dep_file(void *map, size_t len)
+static void parse_dep_file(char *m)
 {
-	char *m = map;
-	char *end = m + len;
 	char *p;
 	char s[PATH_MAX];
-	int is_target;
+	int is_last, is_target;
 	int saw_any_target = 0;
 	int is_first_dep = 0;
 
-	while (m < end) {
+	while (1) {
 		/* Skip any "white space" */
-		while (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))
+		while (*m == ' ' || *m == '\\' || *m == '\n')
 			m++;
+
+		if (!*m)
+			break;
+
 		/* Find next "white space" */
 		p = m;
-		while (p < end && *p != ' ' && *p != '\\' && *p != '\n')
+		while (*p && *p != ' ' && *p != '\\' && *p != '\n')
 			p++;
+		is_last = (*p == '\0');
 		/* Is the token we found a target name? */
 		is_target = (*(p-1) == ':');
 		/* Don't write any target names into the dependency file */
@@ -373,6 +375,10 @@ static void parse_dep_file(void *map, size_t len)
 				do_config_file(s);
 			}
 		}
+
+		if (is_last)
+			break;
+
 		/*
 		 * Start searching for next token immediately after the first
 		 * "whitespace" character that follows this token.
@@ -391,40 +397,42 @@ static void parse_dep_file(void *map, size_t len)
 	printf("$(deps_%s):\n", target);
 }
 
-static void print_deps(void)
+static void print_deps(const char *filename)
 {
 	struct stat st;
 	int fd;
-	void *map;
+	char *buf;
 
-	fd = open(depfile, O_RDONLY);
+	fd = open(filename, O_RDONLY);
 	if (fd < 0) {
 		fprintf(stderr, "fixdep: error opening depfile: ");
-		perror(depfile);
+		perror(filename);
 		exit(2);
 	}
 	if (fstat(fd, &st) < 0) {
 		fprintf(stderr, "fixdep: error fstat'ing depfile: ");
-		perror(depfile);
+		perror(filename);
 		exit(2);
 	}
 	if (st.st_size == 0) {
-		fprintf(stderr,"fixdep: %s is empty\n",depfile);
 		close(fd);
 		return;
 	}
-	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
-	if ((long) map == -1) {
-		perror("fixdep: mmap");
-		close(fd);
-		return;
+	buf = malloc(st.st_size + 1);
+	if (!buf) {
+		perror("fixdep: malloc");
+		exit(2);
 	}
+	if (read(fd, buf, st.st_size) != st.st_size) {
+		perror("fixdep: read");
+		exit(2);
+	}
+	buf[st.st_size] = '\0';
+	close(fd);
 
-	parse_dep_file(map, st.st_size);
-
-	munmap(map, st.st_size);
+	parse_dep_file(buf);
 
-	close(fd);
+	free(buf);
 }
 
 int main(int argc, char *argv[])
@@ -440,7 +448,7 @@ int main(int argc, char *argv[])
 	cmdline = argv[3];
 
 	print_cmdline();
-	print_deps();
+	print_deps(depfile);
 
 	return 0;
 }

commit 41f92cffba1908bc7acc847e498e34368be29dc7
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:05:40 2018 +0900

    fixdep: remove unnecessary <arpa/inet.h> inclusion
    
    <arpa/inet.h> was included for ntohl(), but it was removed by
    commit dee81e988674 ("fixdep: faster CONFIG_ search").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 86a61d642220..b9b4bbf4e8dd 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -112,7 +112,6 @@
 #include <stdio.h>
 #include <limits.h>
 #include <ctype.h>
-#include <arpa/inet.h>
 
 int insert_extra_deps;
 char *target;

commit 7c2ec43a2154c9cd6477f85de8d247ad491cf2d1
Author: Lukas Bulwahn <lukas.bulwahn@gmail.com>
Date:   Mon Jan 8 11:04:01 2018 +0100

    fixdep: exit with error code in error branches of do_config_file()
    
    do_config_file() should exit with an error code on internal run-time
    errors, and not return if it fails as then the error in do_config_file()
    would go unnoticed in the current code and allow the build to continue.
    The exit with error code will make the build fail in those very
    exceptional cases. If this occurs, this actually indicates a deeper
    problem in the execution of the kernel build process.
    
    Now, in these error cases, we do not explicitly free memory and close
    the file handlers in do_config_file(), as this is covered by exit().
    
    This issue in the fixdep script was introduced with its initial
    implementation back in 2002 by the original author Kai Germaschewski with
    this commit 04bd72170653 ("kbuild: Make dependencies at compile time")
    in the linux history git tree, i.e.,
    git://git.kernel.org/pub/scm/linux/kernel/git/history/history.git.
    
    This issue was identified during the review of a previous patch that
    intended to address a memory leak detected by a static analysis tool.
    
    Link: https://lkml.org/lkml/2017/12/14/736
    
    Suggested-by: Nicholas Mc Guire <der.herr@hofr.at>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Lukas Bulwahn <lukas.bulwahn@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index bbf62cb1f819..86a61d642220 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -290,13 +290,11 @@ static void do_config_file(const char *filename)
 	map = malloc(st.st_size + 1);
 	if (!map) {
 		perror("fixdep: malloc");
-		close(fd);
-		return;
+		exit(2);
 	}
 	if (read(fd, map, st.st_size) != st.st_size) {
 		perror("fixdep: read");
-		close(fd);
-		return;
+		exit(2);
 	}
 	map[st.st_size] = '\0';
 	close(fd);

commit 4e433fc4d1a93310d31e7671faca8660a2890908
Author: Cao jin <caoj.fnst@cn.fujitsu.com>
Date:   Tue Aug 8 21:20:50 2017 +0800

    fixdep: trivial: typo fix and correction
    
    Signed-off-by: Cao jin <caoj.fnst@cn.fujitsu.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index fff818b92acb..bbf62cb1f819 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -25,7 +25,7 @@
  *
  * So we play the same trick that "mkdep" played before. We replace
  * the dependency on autoconf.h by a dependency on every config
- * option which is mentioned in any of the listed prequisites.
+ * option which is mentioned in any of the listed prerequisites.
  *
  * kconfig populates a tree in include/config/ with an empty file
  * for each config symbol and when the configuration is updated
@@ -34,7 +34,7 @@
  * the config symbols are rebuilt.
  *
  * So if the user changes his CONFIG_HIS_DRIVER option, only the objects
- * which depend on "include/linux/config/his/driver.h" will be rebuilt,
+ * which depend on "include/config/his/driver.h" will be rebuilt,
  * so most likely only his driver ;-)
  *
  * The idea above dates, by the way, back to Michael E Chastain, AFAIK.
@@ -75,7 +75,7 @@
  * and then basically copies the .<target>.d file to stdout, in the
  * process filtering out the dependency on autoconf.h and adding
  * dependencies on include/config/my/option.h for every
- * CONFIG_MY_OPTION encountered in any of the prequisites.
+ * CONFIG_MY_OPTION encountered in any of the prerequisites.
  *
  * It will also filter out all the dependencies on *.ver. We need
  * to make sure that the generated version checksum are globally up

commit dee81e9886748594babac67c14b0f720148e255d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Aug 24 21:03:05 2016 +0300

    fixdep: faster CONFIG_ search
    
    Do you think kernel build is 100% dominated by gcc? You are wrong!
    One small utility called "fixdep" consistently manages to sneak into
    profile's first page (unless you have small monitor of course).
    
    The choke point is this clever code:
    
            for (; m < end; m++) {
                    if (*m == INT_CONF) { p = (char *) m  ; goto conf; }
                    if (*m == INT_ONFI) { p = (char *) m-1; goto conf; }
                    if (*m == INT_NFIG) { p = (char *) m-2; goto conf; }
                    if (*m == INT_FIG_) { p = (char *) m-3; goto conf; }
    
    4 branches per 4 characters is not fast.
    
    Use strstr(3), so that SSE2 etc can be used.
    
    With this patch, fixdep is so deep at the bottom, it is hard to find it.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 746ec1ece614..fff818b92acb 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -82,8 +82,7 @@
  * to date before even starting the recursive build, so it's too late
  * at this point anyway.
  *
- * The algorithm to grep for "CONFIG_..." is bit unusual, but should
- * be fast ;-) We don't even try to really parse the header files, but
+ * We don't even try to really parse the header files, but
  * merely grep, i.e. if CONFIG_FOO is mentioned in a comment, it will
  * be picked up as well. It's not a problem with respect to
  * correctness, since that can only give too many dependencies, thus
@@ -115,11 +114,6 @@
 #include <ctype.h>
 #include <arpa/inet.h>
 
-#define INT_CONF ntohl(0x434f4e46)
-#define INT_ONFI ntohl(0x4f4e4649)
-#define INT_NFIG ntohl(0x4e464947)
-#define INT_FIG_ ntohl(0x4649475f)
-
 int insert_extra_deps;
 char *target;
 char *depfile;
@@ -241,37 +235,22 @@ static void use_config(const char *m, int slen)
 	print_config(m, slen);
 }
 
-static void parse_config_file(const char *map, size_t len)
+static void parse_config_file(const char *p)
 {
-	const int *end = (const int *) (map + len);
-	/* start at +1, so that p can never be < map */
-	const int *m   = (const int *) map + 1;
-	const char *p, *q;
-
-	for (; m < end; m++) {
-		if (*m == INT_CONF) { p = (char *) m  ; goto conf; }
-		if (*m == INT_ONFI) { p = (char *) m-1; goto conf; }
-		if (*m == INT_NFIG) { p = (char *) m-2; goto conf; }
-		if (*m == INT_FIG_) { p = (char *) m-3; goto conf; }
-		continue;
-	conf:
-		if (p > map + len - 7)
-			continue;
-		if (memcmp(p, "CONFIG_", 7))
-			continue;
+	const char *q, *r;
+
+	while ((p = strstr(p, "CONFIG_"))) {
 		p += 7;
-		for (q = p; q < map + len; q++) {
-			if (!(isalnum(*q) || *q == '_'))
-				goto found;
-		}
-		continue;
-
-	found:
-		if (!memcmp(q - 7, "_MODULE", 7))
-			q -= 7;
-		if (q - p < 0)
-			continue;
-		use_config(p, q - p);
+		q = p;
+		while (*q && (isalnum(*q) || *q == '_'))
+			q++;
+		if (memcmp(q - 7, "_MODULE", 7) == 0)
+			r = q - 7;
+		else
+			r = q;
+		if (r > p)
+			use_config(p, r - p);
+		p = q;
 	}
 }
 
@@ -291,7 +270,7 @@ static void do_config_file(const char *filename)
 {
 	struct stat st;
 	int fd;
-	void *map;
+	char *map;
 
 	fd = open(filename, O_RDONLY);
 	if (fd < 0) {
@@ -308,18 +287,23 @@ static void do_config_file(const char *filename)
 		close(fd);
 		return;
 	}
-	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
-	if ((long) map == -1) {
-		perror("fixdep: mmap");
+	map = malloc(st.st_size + 1);
+	if (!map) {
+		perror("fixdep: malloc");
 		close(fd);
 		return;
 	}
+	if (read(fd, map, st.st_size) != st.st_size) {
+		perror("fixdep: read");
+		close(fd);
+		return;
+	}
+	map[st.st_size] = '\0';
+	close(fd);
 
-	parse_config_file(map, st.st_size);
-
-	munmap(map, st.st_size);
+	parse_config_file(map);
 
-	close(fd);
+	free(map);
 }
 
 /*
@@ -446,22 +430,8 @@ static void print_deps(void)
 	close(fd);
 }
 
-static void traps(void)
-{
-	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
-	int *p = (int *)test;
-
-	if (*p != INT_CONF) {
-		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianness? %#x\n",
-			*p);
-		exit(2);
-	}
-}
-
 int main(int argc, char *argv[])
 {
-	traps();
-
 	if (argc == 5 && !strcmp(argv[1], "-e")) {
 		insert_extra_deps = 1;
 		argv++;

commit c1a95fda2a40ae8c7aad3fa44fa7718a3710eb2d
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Jan 22 13:41:57 2016 -0500

    kbuild: add fine grained build dependencies for exported symbols
    
    Like with kconfig options, we now have the ability to compile in and
    out individual EXPORT_SYMBOL() declarations based on the content of
    include/generated/autoksyms.h.  However we don't want the entire
    world to be rebuilt whenever that file is touched.
    
    Let's apply the same build dependency trick used for CONFIG_* symbols
    where the time stamp of empty files whose paths matching those symbols
    is used to trigger fine grained rebuilds. In our case the key is the
    symbol name passed to EXPORT_SYMBOL().
    
    However, unlike config options, we cannot just use fixdep to parse
    the source code for EXPORT_SYMBOL(ksym) because several variants exist
    and parsing them all in a separate tool, and keeping it in synch, is
    not trivially maintainable.  Furthermore, there are variants such as
    
            EXPORT_SYMBOL_GPL(pci_user_read_config_##size);
    
    that are instanciated via a macro for which we can't easily determine
    the actual exported symbol name(s) short of actually running the
    preprocessor on them.
    
    Storing the symbol name string in a special ELF section doesn't work
    for targets that output assembly or preprocessed source.
    
    So the best way is really to leverage the preprocessor by having it
    output actual symbol names anchored by a special sequence that can be
    easily filtered out. Then the list of symbols is simply fed to fixdep
    to be merged with the other dependencies.
    
    That implies the preprocessor is executed twice for each source file.
    A previous attempt relied on a warning pragma for each EXPORT_SYMBOL()
    instance that was filtered apart from stderr by the build system with
    a sed script during the actual compilation pass. Unfortunately the
    preprocessor/compiler diagnostic output isn't stable between versions
    and this solution, although more efficient, was deemed too fragile.
    
    Because of the lowercasing performed by fixdep, there might be name
    collisions triggering spurious rebuilds for similar symbols. But this
    shouldn't be a big issue in practice. (This is the case for CONFIG_*
    symbols and I didn't want to be different here, whatever the original
    reason for doing so.)
    
    To avoid needless build overhead, the exported symbol name gathering is
    performed only when CONFIG_TRIM_UNUSED_KSYMS is selected.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 7e90a1f7de0f..746ec1ece614 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -358,6 +358,7 @@ static void parse_dep_file(void *map, size_t len)
 
 			/* Ignore certain dependencies */
 			if (strrcmp(s, "include/generated/autoconf.h") &&
+			    strrcmp(s, "include/generated/autoksyms.h") &&
 			    strrcmp(s, "arch/um/include/uml-config.h") &&
 			    strrcmp(s, "include/linux/kconfig.h") &&
 			    strrcmp(s, ".ver")) {

commit d8329e35cc08e07a3250b3873325d300c1e91c81
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Feb 12 15:00:50 2016 -0500

    fixdep: accept extra dependencies on stdin
    
    ... and merge them in the list of parsed dependencies.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index caef815d1743..7e90a1f7de0f 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -120,13 +120,15 @@
 #define INT_NFIG ntohl(0x4e464947)
 #define INT_FIG_ ntohl(0x4649475f)
 
+int insert_extra_deps;
 char *target;
 char *depfile;
 char *cmdline;
 
 static void usage(void)
 {
-	fprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");
+	fprintf(stderr, "Usage: fixdep [-e] <depfile> <target> <cmdline>\n");
+	fprintf(stderr, " -e  insert extra dependencies given on stdin\n");
 	exit(1);
 }
 
@@ -138,6 +140,40 @@ static void print_cmdline(void)
 	printf("cmd_%s := %s\n\n", target, cmdline);
 }
 
+/*
+ * Print out a dependency path from a symbol name
+ */
+static void print_config(const char *m, int slen)
+{
+	int c, i;
+
+	printf("    $(wildcard include/config/");
+	for (i = 0; i < slen; i++) {
+		c = m[i];
+		if (c == '_')
+			c = '/';
+		else
+			c = tolower(c);
+		putchar(c);
+	}
+	printf(".h) \\\n");
+}
+
+static void do_extra_deps(void)
+{
+	if (insert_extra_deps) {
+		char buf[80];
+		while(fgets(buf, sizeof(buf), stdin)) {
+			int len = strlen(buf);
+			if (len < 2 || buf[len-1] != '\n') {
+				fprintf(stderr, "fixdep: bad data on stdin\n");
+				exit(1);
+			}
+			print_config(buf, len-1);
+		}
+	}
+}
+
 struct item {
 	struct item	*next;
 	unsigned int	len;
@@ -197,23 +233,12 @@ static void define_config(const char *name, int len, unsigned int hash)
 static void use_config(const char *m, int slen)
 {
 	unsigned int hash = strhash(m, slen);
-	int c, i;
 
 	if (is_defined_config(m, slen, hash))
 	    return;
 
 	define_config(m, slen, hash);
-
-	printf("    $(wildcard include/config/");
-	for (i = 0; i < slen; i++) {
-		c = m[i];
-		if (c == '_')
-			c = '/';
-		else
-			c = tolower(c);
-		putchar(c);
-	}
-	printf(".h) \\\n");
+	print_config(m, slen);
 }
 
 static void parse_config_file(const char *map, size_t len)
@@ -250,7 +275,7 @@ static void parse_config_file(const char *map, size_t len)
 	}
 }
 
-/* test is s ends in sub */
+/* test if s ends in sub */
 static int strrcmp(const char *s, const char *sub)
 {
 	int slen = strlen(s);
@@ -378,6 +403,8 @@ static void parse_dep_file(void *map, size_t len)
 		exit(1);
 	}
 
+	do_extra_deps();
+
 	printf("\n%s: $(deps_%s)\n\n", target, target);
 	printf("$(deps_%s):\n", target);
 }
@@ -434,7 +461,10 @@ int main(int argc, char *argv[])
 {
 	traps();
 
-	if (argc != 4)
+	if (argc == 5 && !strcmp(argv[1], "-e")) {
+		insert_extra_deps = 1;
+		argv++;
+	} else if (argc != 4)
 		usage();
 
 	depfile = argv[1];

commit 46fe94ad18aa7ce6b3dad8c035fb538942020f2b
Author: Tom Rini <trini@konsulko.com>
Date:   Mon Dec 7 16:26:08 2015 -0500

    kbuild: fixdep: Check fstat(2) return value
    
    Coverity has recently added a check that will find when we don't check
    the return code from fstat(2).  Copy/paste the checking logic that
    print_deps() has with an appropriate re-wording of the perror() message.
    
    Signed-off-by: Tom Rini <trini@konsulko.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 5b327c67a828..caef815d1743 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -274,7 +274,11 @@ static void do_config_file(const char *filename)
 		perror(filename);
 		exit(2);
 	}
-	fstat(fd, &st);
+	if (fstat(fd, &st) < 0) {
+		fprintf(stderr, "fixdep: error fstat'ing config file: ");
+		perror(filename);
+		exit(2);
+	}
 	if (st.st_size == 0) {
 		close(fd);
 		return;

commit 4c835b57b8de88aef8446867701034128a8a3522
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Wed Nov 18 19:07:15 2015 +0100

    fixdep: constify strrcmp arguments
    
    strrcmp only performs read access to the memory addressed by its
    arguments so make them const pointers.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index c68fd61fdc42..5b327c67a828 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -251,7 +251,7 @@ static void parse_config_file(const char *map, size_t len)
 }
 
 /* test is s ends in sub */
-static int strrcmp(char *s, char *sub)
+static int strrcmp(const char *s, const char *sub)
 {
 	int slen = strlen(s);
 	int sublen = strlen(sub);

commit d179e22762fd38414c4108acedd5feca4cf7e0d8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 24 14:18:46 2015 +0900

    kbuild: fixdep: drop meaningless hash table initialization
    
    The clear_config() is called just once at the beginning of this
    program, but the global variable hashtab[] is already zero-filled
    at the start-up.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 46cc1b3e5de2..c68fd61fdc42 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -191,23 +191,6 @@ static void define_config(const char *name, int len, unsigned int hash)
 	hashtab[hash % HASHSZ] = aux;
 }
 
-/*
- * Clear the set of configuration strings.
- */
-static void clear_config(void)
-{
-	struct item *aux, *next;
-	unsigned int i;
-
-	for (i = 0; i < HASHSZ; i++) {
-		for (aux = hashtab[i]; aux; aux = next) {
-			next = aux->next;
-			free(aux);
-		}
-		hashtab[i] = NULL;
-	}
-}
-
 /*
  * Record the use of a CONFIG_* word.
  */
@@ -325,8 +308,6 @@ static void parse_dep_file(void *map, size_t len)
 	int saw_any_target = 0;
 	int is_first_dep = 0;
 
-	clear_config();
-
 	while (m < end) {
 		/* Skip any "white space" */
 		while (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))

commit d721109611fb94aff53c2397859046e5f92f55ae
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 24 14:18:45 2015 +0900

    kbuild: fixdep: optimize code slightly
    
    If the target string matches "CONFIG_", move the pointer p
    forward.  This saves several 7-chars adjustments.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index b30406860b73..46cc1b3e5de2 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -251,7 +251,8 @@ static void parse_config_file(const char *map, size_t len)
 			continue;
 		if (memcmp(p, "CONFIG_", 7))
 			continue;
-		for (q = p + 7; q < map + len; q++) {
+		p += 7;
+		for (q = p; q < map + len; q++) {
 			if (!(isalnum(*q) || *q == '_'))
 				goto found;
 		}
@@ -260,9 +261,9 @@ static void parse_config_file(const char *map, size_t len)
 	found:
 		if (!memcmp(q - 7, "_MODULE", 7))
 			q -= 7;
-		if( (q-p-7) < 0 )
+		if (q - p < 0)
 			continue;
-		use_config(p+7, q-p-7);
+		use_config(p, q - p);
 	}
 }
 

commit bb66fc67192bbd406fe9c22033f1bbbf3e7ec621
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jun 10 19:08:13 2014 +0900

    kbuild: trivial - use tabs for code indent where possible
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 078fe1d64e7d..b30406860b73 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -409,10 +409,10 @@ static void print_deps(void)
 		exit(2);
 	}
 	if (fstat(fd, &st) < 0) {
-                fprintf(stderr, "fixdep: error fstat'ing depfile: ");
-                perror(depfile);
-                exit(2);
-        }
+		fprintf(stderr, "fixdep: error fstat'ing depfile: ");
+		perror(depfile);
+		exit(2);
+	}
 	if (st.st_size == 0) {
 		fprintf(stderr,"fixdep: %s is empty\n",depfile);
 		close(fd);

commit 2ab8a99661f4ce052bbad064237c441371df8751
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Mar 6 10:27:45 2013 -0700

    kbuild: fixdep: support concatenated dep files
    
    The current use-case for fixdep is: a source file is run through a single
    processing step, which creates a single dependency file as a side-effect,
    which fixdep transforms into the file used by the kernel build process.
    
    In order to transparently run the C pre-processor on device-tree files,
    we wish to run both gcc -E and dtc on a source file in a single rule.
    This generates two dependency files, which must be transformed together
    into the file used by the kernel build process. This change modifies
    fixdep so it can process the concatenation of multiple separate input
    dependency files, and produce a correct unified output.
    
    The code changes have the slight benefit of transforming the loop in
    parse_dep_file() into more of a lexer/tokenizer, with the loop body being
    more of a parser. Previously, some of this logic was mixed together
    before the loop. I also added some comments, which I hope are useful.
    
    Benchmarking shows that on a cross-compiled ARM tegra_defconfig build,
    there is less than 0.5 seconds speed decrease with this change, on top
    of a build time of ~2m24s. This is probably within the noise.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 7f6425e24ce3..078fe1d64e7d 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -320,49 +320,78 @@ static void parse_dep_file(void *map, size_t len)
 	char *end = m + len;
 	char *p;
 	char s[PATH_MAX];
-	int first;
-
-	p = strchr(m, ':');
-	if (!p) {
-		fprintf(stderr, "fixdep: parse error\n");
-		exit(1);
-	}
-	memcpy(s, m, p-m); s[p-m] = 0;
-	m = p+1;
+	int is_target;
+	int saw_any_target = 0;
+	int is_first_dep = 0;
 
 	clear_config();
 
-	first = 1;
 	while (m < end) {
+		/* Skip any "white space" */
 		while (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))
 			m++;
+		/* Find next "white space" */
 		p = m;
-		while (p < end && *p != ' ') p++;
-		if (p == end) {
-			do p--; while (!isalnum(*p));
+		while (p < end && *p != ' ' && *p != '\\' && *p != '\n')
 			p++;
+		/* Is the token we found a target name? */
+		is_target = (*(p-1) == ':');
+		/* Don't write any target names into the dependency file */
+		if (is_target) {
+			/* The /next/ file is the first dependency */
+			is_first_dep = 1;
+		} else {
+			/* Save this token/filename */
+			memcpy(s, m, p-m);
+			s[p - m] = 0;
+
+			/* Ignore certain dependencies */
+			if (strrcmp(s, "include/generated/autoconf.h") &&
+			    strrcmp(s, "arch/um/include/uml-config.h") &&
+			    strrcmp(s, "include/linux/kconfig.h") &&
+			    strrcmp(s, ".ver")) {
+				/*
+				 * Do not list the source file as dependency,
+				 * so that kbuild is not confused if a .c file
+				 * is rewritten into .S or vice versa. Storing
+				 * it in source_* is needed for modpost to
+				 * compute srcversions.
+				 */
+				if (is_first_dep) {
+					/*
+					 * If processing the concatenation of
+					 * multiple dependency files, only
+					 * process the first target name, which
+					 * will be the original source name,
+					 * and ignore any other target names,
+					 * which will be intermediate temporary
+					 * files.
+					 */
+					if (!saw_any_target) {
+						saw_any_target = 1;
+						printf("source_%s := %s\n\n",
+							target, s);
+						printf("deps_%s := \\\n",
+							target);
+					}
+					is_first_dep = 0;
+				} else
+					printf("  %s \\\n", s);
+				do_config_file(s);
+			}
 		}
-		memcpy(s, m, p-m); s[p-m] = 0;
-		if (strrcmp(s, "include/generated/autoconf.h") &&
-		    strrcmp(s, "arch/um/include/uml-config.h") &&
-		    strrcmp(s, "include/linux/kconfig.h") &&
-		    strrcmp(s, ".ver")) {
-			/*
-			 * Do not list the source file as dependency, so that
-			 * kbuild is not confused if a .c file is rewritten
-			 * into .S or vice versa. Storing it in source_* is
-			 * needed for modpost to compute srcversions.
-			 */
-			if (first) {
-				printf("source_%s := %s\n\n", target, s);
-				printf("deps_%s := \\\n", target);
-			} else
-				printf("  %s \\\n", s);
-			do_config_file(s);
-		}
-		first = 0;
+		/*
+		 * Start searching for next token immediately after the first
+		 * "whitespace" character that follows this token.
+		 */
 		m = p + 1;
 	}
+
+	if (!saw_any_target) {
+		fprintf(stderr, "fixdep: parse error; no targets found\n");
+		exit(1);
+	}
+
 	printf("\n%s: $(deps_%s)\n\n", target, target);
 	printf("$(deps_%s):\n", target);
 }

commit 8a168ca7074b463d0e19a9e9c15946db1afbddc4
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sat Dec 29 02:00:09 2012 +0900

    treewide: Fix typo in various drivers
    
    Correct spelling typo in printk within various drivers.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index cb1f50cf12e3..7f6425e24ce3 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -409,7 +409,7 @@ static void traps(void)
 	int *p = (int *)test;
 
 	if (*p != INT_CONF) {
-		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",
+		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianness? %#x\n",
 			*p);
 		exit(2);
 	}

commit 6a5be57f0f00bf5f39b983ec98d58058bc696543
Author: Peter Foley <pefoley2@verizon.net>
Date:   Mon Aug 1 09:51:24 2011 -0400

    fixdep: fix extraneous dependencies
    
    The introduction of include/linux/kconfig.h created 3 extraneous
    dependencies:
    include/config/.h
    include/config/h.h
    include/config/foo.h
    
    Fix this by excluding kconfig.h from fixdep calculations.
    
    Signed-off-by: Peter Foley <pefoley2@verizon.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 291228e25984..cb1f50cf12e3 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -345,6 +345,7 @@ static void parse_dep_file(void *map, size_t len)
 		memcpy(s, m, p-m); s[p-m] = 0;
 		if (strrcmp(s, "include/generated/autoconf.h") &&
 		    strrcmp(s, "arch/um/include/uml-config.h") &&
+		    strrcmp(s, "include/linux/kconfig.h") &&
 		    strrcmp(s, ".ver")) {
 			/*
 			 * Do not list the source file as dependency, so that

commit 7840fea200cd1ad93ed19853a83752a21f691326
Author: Michal Marek <mmarek@suse.cz>
Date:   Fri Mar 11 22:34:47 2011 +0100

    kbuild: Fix computing srcversion for modules
    
    Recent change to fixdep:
    
        commit b7bd182176960fdd139486cadb9962b39f8a2b50
        Author: Michal Marek <mmarek@suse.cz>
        Date:   Thu Feb 17 15:13:54 2011 +0100
    
        fixdep: Do not record dependency on the source file itself
    
    changed the format of the *.cmd files without realizing that it is also
    used by modpost. Put the path to the source file to the file back, in a
    special variable, so that modpost sees all source files when calculating
    srcversion for modules.
    
    Reported-and-tested-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 6c94c6ce2925..291228e25984 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -309,6 +309,11 @@ static void do_config_file(const char *filename)
 	close(fd);
 }
 
+/*
+ * Important: The below generated source_foo.o and deps_foo.o variable
+ * assignments are parsed not only by make, but also by the rather simple
+ * parser in scripts/mod/sumversion.c.
+ */
 static void parse_dep_file(void *map, size_t len)
 {
 	char *m = map;
@@ -323,7 +328,6 @@ static void parse_dep_file(void *map, size_t len)
 		exit(1);
 	}
 	memcpy(s, m, p-m); s[p-m] = 0;
-	printf("deps_%s := \\\n", target);
 	m = p+1;
 
 	clear_config();
@@ -343,12 +347,15 @@ static void parse_dep_file(void *map, size_t len)
 		    strrcmp(s, "arch/um/include/uml-config.h") &&
 		    strrcmp(s, ".ver")) {
 			/*
-			 * Do not output the first dependency (the
-			 * source file), so that kbuild is not confused
-			 * if a .c file is rewritten into .S or vice
-			 * versa.
+			 * Do not list the source file as dependency, so that
+			 * kbuild is not confused if a .c file is rewritten
+			 * into .S or vice versa. Storing it in source_* is
+			 * needed for modpost to compute srcversions.
 			 */
-			if (!first)
+			if (first) {
+				printf("source_%s := %s\n\n", target, s);
+				printf("deps_%s := \\\n", target);
+			} else
 				printf("  %s \\\n", s);
 			do_config_file(s);
 		}

commit b7bd182176960fdd139486cadb9962b39f8a2b50
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Feb 17 15:13:54 2011 +0100

    fixdep: Do not record dependency on the source file itself
    
    The dependency is already expressed by the Makefiles, storing it in the
    .cmd file breaks build if a .c file is replaced by .S or vice versa,
    because the .cmd file contains
    
    foo/bar.o: foo/bar.c ...
    
    foo/bar.c ... :
    
    so the foo/bar.c -> foo/bar.o rule triggers even if there is no
    foo/bar.c anymore.
    
    Acked-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index c9a16abacab4..6c94c6ce2925 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -315,6 +315,7 @@ static void parse_dep_file(void *map, size_t len)
 	char *end = m + len;
 	char *p;
 	char s[PATH_MAX];
+	int first;
 
 	p = strchr(m, ':');
 	if (!p) {
@@ -327,6 +328,7 @@ static void parse_dep_file(void *map, size_t len)
 
 	clear_config();
 
+	first = 1;
 	while (m < end) {
 		while (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))
 			m++;
@@ -340,9 +342,17 @@ static void parse_dep_file(void *map, size_t len)
 		if (strrcmp(s, "include/generated/autoconf.h") &&
 		    strrcmp(s, "arch/um/include/uml-config.h") &&
 		    strrcmp(s, ".ver")) {
-			printf("  %s \\\n", s);
+			/*
+			 * Do not output the first dependency (the
+			 * source file), so that kbuild is not confused
+			 * if a .c file is rewritten into .S or vice
+			 * versa.
+			 */
+			if (!first)
+				printf("  %s \\\n", s);
 			do_config_file(s);
 		}
+		first = 0;
 		m = p + 1;
 	}
 	printf("\n%s: $(deps_%s)\n\n", target, target);

commit a3ba81131aca243bfecfa78c42edec0cd69f72d6
Author: Ben Gamari <bgamari.foss@gmail.com>
Date:   Wed Dec 22 13:30:14 2010 -0500

    Make fixdep error handling more explicit
    
    Also add missing error handling to fstat call
    
    Signed-off-by: Ben Gamari <bgamari.foss@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index ed0584623690..c9a16abacab4 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -286,7 +286,7 @@ static void do_config_file(const char *filename)
 
 	fd = open(filename, O_RDONLY);
 	if (fd < 0) {
-		fprintf(stderr, "fixdep: ");
+		fprintf(stderr, "fixdep: error opening config file: ");
 		perror(filename);
 		exit(2);
 	}
@@ -357,11 +357,15 @@ static void print_deps(void)
 
 	fd = open(depfile, O_RDONLY);
 	if (fd < 0) {
-		fprintf(stderr, "fixdep: ");
+		fprintf(stderr, "fixdep: error opening depfile: ");
 		perror(depfile);
 		exit(2);
 	}
-	fstat(fd, &st);
+	if (fstat(fd, &st) < 0) {
+                fprintf(stderr, "fixdep: error fstat'ing depfile: ");
+                perror(depfile);
+                exit(2);
+        }
 	if (st.st_size == 0) {
 		fprintf(stderr,"fixdep: %s is empty\n",depfile);
 		close(fd);

commit 8af27e1dc4e4dd7a7b04c2cd0fc3d419d91d45b0
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Nov 9 16:29:27 2010 +0100

    fixdep: use hash table instead of a single array
    
    I noticed fixdep uses ~2% of cpu time in kernel build, in function
    use_config()
    
    fixdep spends a lot of cpu cycles in linear searches in its internal
    string array. With about 400 stored strings per dep file, this begins to
    be noticeable.
    
    Convert fixdep to use a hash table.
    
    kbuild results on my x86_64 allmodconfig
    
    Before patch :
    
    real    10m30.414s
    user    61m51.456s
    sys     8m28.200s
    
    real    10m12.334s
    user    61m50.236s
    sys     8m30.448s
    
    real    10m42.947s
    user    61m50.028s
    sys     8m32.380s
    
    After:
    
    real    10m8.180s
    user    61m22.506s
    sys     8m32.384s
    
    real    10m35.039s
    user    61m21.654s
    sys     8m32.212s
    
    real    10m14.487s
    user    61m23.498s
    sys     8m32.312s
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index ea26b23de082..ed0584623690 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -138,38 +138,36 @@ static void print_cmdline(void)
 	printf("cmd_%s := %s\n\n", target, cmdline);
 }
 
-char * str_config  = NULL;
-int    size_config = 0;
-int    len_config  = 0;
+struct item {
+	struct item	*next;
+	unsigned int	len;
+	unsigned int	hash;
+	char		name[0];
+};
 
-/*
- * Grow the configuration string to a desired length.
- * Usually the first growth is plenty.
- */
-static void grow_config(int len)
-{
-	while (len_config + len > size_config) {
-		if (size_config == 0)
-			size_config = 2048;
-		str_config = realloc(str_config, size_config *= 2);
-		if (str_config == NULL)
-			{ perror("fixdep:malloc"); exit(1); }
-	}
-}
+#define HASHSZ 256
+static struct item *hashtab[HASHSZ];
 
+static unsigned int strhash(const char *str, unsigned int sz)
+{
+	/* fnv32 hash */
+	unsigned int i, hash = 2166136261U;
 
+	for (i = 0; i < sz; i++)
+		hash = (hash ^ str[i]) * 0x01000193;
+	return hash;
+}
 
 /*
  * Lookup a value in the configuration string.
  */
-static int is_defined_config(const char * name, int len)
+static int is_defined_config(const char *name, int len, unsigned int hash)
 {
-	const char * pconfig;
-	const char * plast = str_config + len_config - len;
-	for ( pconfig = str_config + 1; pconfig < plast; pconfig++ ) {
-		if (pconfig[ -1] == '\n'
-		&&  pconfig[len] == '\n'
-		&&  !memcmp(pconfig, name, len))
+	struct item *aux;
+
+	for (aux = hashtab[hash % HASHSZ]; aux; aux = aux->next) {
+		if (aux->hash == hash && aux->len == len &&
+		    memcmp(aux->name, name, len) == 0)
 			return 1;
 	}
 	return 0;
@@ -178,13 +176,19 @@ static int is_defined_config(const char * name, int len)
 /*
  * Add a new value to the configuration string.
  */
-static void define_config(const char * name, int len)
+static void define_config(const char *name, int len, unsigned int hash)
 {
-	grow_config(len + 1);
+	struct item *aux = malloc(sizeof(*aux) + len);
 
-	memcpy(str_config+len_config, name, len);
-	len_config += len;
-	str_config[len_config++] = '\n';
+	if (!aux) {
+		perror("fixdep:malloc");
+		exit(1);
+	}
+	memcpy(aux->name, name, len);
+	aux->len = len;
+	aux->hash = hash;
+	aux->next = hashtab[hash % HASHSZ];
+	hashtab[hash % HASHSZ] = aux;
 }
 
 /*
@@ -192,40 +196,49 @@ static void define_config(const char * name, int len)
  */
 static void clear_config(void)
 {
-	len_config = 0;
-	define_config("", 0);
+	struct item *aux, *next;
+	unsigned int i;
+
+	for (i = 0; i < HASHSZ; i++) {
+		for (aux = hashtab[i]; aux; aux = next) {
+			next = aux->next;
+			free(aux);
+		}
+		hashtab[i] = NULL;
+	}
 }
 
 /*
  * Record the use of a CONFIG_* word.
  */
-static void use_config(char *m, int slen)
+static void use_config(const char *m, int slen)
 {
-	char s[PATH_MAX];
-	char *p;
+	unsigned int hash = strhash(m, slen);
+	int c, i;
 
-	if (is_defined_config(m, slen))
+	if (is_defined_config(m, slen, hash))
 	    return;
 
-	define_config(m, slen);
-
-	memcpy(s, m, slen); s[slen] = 0;
+	define_config(m, slen, hash);
 
-	for (p = s; p < s + slen; p++) {
-		if (*p == '_')
-			*p = '/';
+	printf("    $(wildcard include/config/");
+	for (i = 0; i < slen; i++) {
+		c = m[i];
+		if (c == '_')
+			c = '/';
 		else
-			*p = tolower((int)*p);
+			c = tolower(c);
+		putchar(c);
 	}
-	printf("    $(wildcard include/config/%s.h) \\\n", s);
+	printf(".h) \\\n");
 }
 
-static void parse_config_file(char *map, size_t len)
+static void parse_config_file(const char *map, size_t len)
 {
-	int *end = (int *) (map + len);
+	const int *end = (const int *) (map + len);
 	/* start at +1, so that p can never be < map */
-	int *m   = (int *) map + 1;
-	char *p, *q;
+	const int *m   = (const int *) map + 1;
+	const char *p, *q;
 
 	for (; m < end; m++) {
 		if (*m == INT_CONF) { p = (char *) m  ; goto conf; }
@@ -265,7 +278,7 @@ static int strrcmp(char *s, char *sub)
 	return memcmp(s + slen - sublen, sub, sublen);
 }
 
-static void do_config_file(char *filename)
+static void do_config_file(const char *filename)
 {
 	struct stat st;
 	int fd;

commit 264a26838056fc2d759f58bec2e720e01fcb1bdb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Oct 18 00:49:24 2009 +0200

    kbuild: move autoconf.h to include/generated
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 6bf21f83837d..ea26b23de082 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -16,15 +16,15 @@
  * tells make when to remake a file.
  *
  * To use this list as-is however has the drawback that virtually
- * every file in the kernel includes <linux/autoconf.h>.
+ * every file in the kernel includes autoconf.h.
  *
- * If the user re-runs make *config, linux/autoconf.h will be
+ * If the user re-runs make *config, autoconf.h will be
  * regenerated.  make notices that and will rebuild every file which
  * includes autoconf.h, i.e. basically all files. This is extremely
  * annoying if the user just changed CONFIG_HIS_DRIVER from n to m.
  *
  * So we play the same trick that "mkdep" played before. We replace
- * the dependency on linux/autoconf.h by a dependency on every config
+ * the dependency on autoconf.h by a dependency on every config
  * option which is mentioned in any of the listed prequisites.
  *
  * kconfig populates a tree in include/config/ with an empty file
@@ -73,7 +73,7 @@
  *   cmd_<target> = <cmdline>
  *
  * and then basically copies the .<target>.d file to stdout, in the
- * process filtering out the dependency on linux/autoconf.h and adding
+ * process filtering out the dependency on autoconf.h and adding
  * dependencies on include/config/my/option.h for every
  * CONFIG_MY_OPTION encountered in any of the prequisites.
  *
@@ -324,7 +324,7 @@ static void parse_dep_file(void *map, size_t len)
 			p++;
 		}
 		memcpy(s, m, p-m); s[p-m] = 0;
-		if (strrcmp(s, "include/linux/autoconf.h") &&
+		if (strrcmp(s, "include/generated/autoconf.h") &&
 		    strrcmp(s, "arch/um/include/uml-config.h") &&
 		    strrcmp(s, ".ver")) {
 			printf("  %s \\\n", s);

commit c37efa932598de5e30330a1414e34d9e082e0d9e
Merge: 9e12a7e7d89a abe1ee3a221d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 23 15:37:02 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild-next
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild-next: (30 commits)
      Use macros for .data.page_aligned section.
      Use macros for .bss.page_aligned section.
      Use new __init_task_data macro in arch init_task.c files.
      kbuild: Don't define ALIGN and ENTRY when preprocessing linker scripts.
      arm, cris, mips, sparc, powerpc, um, xtensa: fix build with bash 4.0
      kbuild: add static to prototypes
      kbuild: fail build if recordmcount.pl fails
      kbuild: set -fconserve-stack option for gcc 4.5
      kbuild: echo the record_mcount command
      gconfig: disable "typeahead find" search in treeviews
      kbuild: fix cc1 options check to ensure we do not use -fPIC when compiling
      checkincludes.pl: add option to remove duplicates in place
      markup_oops: use modinfo to avoid confusion with underscored module names
      checkincludes.pl: provide usage helper
      checkincludes.pl: close file as soon as we're done with it
      ctags: usability fix
      kernel hacking: move STRIP_ASM_SYMS from General
      gitignore usr/initramfs_data.cpio.bz2 and usr/initramfs_data.cpio.lzma
      kbuild: Check if linker supports the -X option
      kbuild: introduce ld-option
      ...
    
    Fix trivial conflict in scripts/basic/fixdep.c

commit f0a75770bde5cb5f9596bd0256d8ec3649720525
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Fri Jul 24 11:29:29 2009 -0700

    trivial: kbuild: remove extraneous blank line after declaration of usage()
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index f9c1e5408318..8ab448611680 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -125,7 +125,6 @@ char *depfile;
 char *cmdline;
 
 void usage(void)
-
 {
 	fprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");
 	exit(1);

commit 7d3392e54653171bd13467bf37f1182e83fadd08
Author: Markus Heidelberg <markus.heidelberg@web.de>
Date:   Fri Jun 12 01:02:35 2009 +0200

    trivial: remove references to non-existent include/linux/config.h
    
    Ignore drivers/staging/ since it is very likely that new drivers
    introduce it again.
    
    Signed-off-by: Markus Heidelberg <markus.heidelberg@web.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 72c15205bb2b..f9c1e5408318 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -16,8 +16,7 @@
  * tells make when to remake a file.
  *
  * To use this list as-is however has the drawback that virtually
- * every file in the kernel includes <linux/config.h> which then again
- * includes <linux/autoconf.h>
+ * every file in the kernel includes <linux/autoconf.h>.
  *
  * If the user re-runs make *config, linux/autoconf.h will be
  * regenerated.  make notices that and will rebuild every file which

commit 4356f4890792a678936c93c9196e8f7742e04535
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Fri Sep 18 12:49:23 2009 -0700

    kbuild: add static to prototypes
    
    Warnings found via gcc -Wmissing-prototypes.
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 72c15205bb2b..d7c1b04791f7 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -125,7 +125,7 @@ char *target;
 char *depfile;
 char *cmdline;
 
-void usage(void)
+static void usage(void)
 
 {
 	fprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");
@@ -135,7 +135,7 @@ void usage(void)
 /*
  * Print out the commandline prefixed with cmd_<target filename> :=
  */
-void print_cmdline(void)
+static void print_cmdline(void)
 {
 	printf("cmd_%s := %s\n\n", target, cmdline);
 }
@@ -148,7 +148,7 @@ int    len_config  = 0;
  * Grow the configuration string to a desired length.
  * Usually the first growth is plenty.
  */
-void grow_config(int len)
+static void grow_config(int len)
 {
 	while (len_config + len > size_config) {
 		if (size_config == 0)
@@ -164,7 +164,7 @@ void grow_config(int len)
 /*
  * Lookup a value in the configuration string.
  */
-int is_defined_config(const char * name, int len)
+static int is_defined_config(const char * name, int len)
 {
 	const char * pconfig;
 	const char * plast = str_config + len_config - len;
@@ -180,7 +180,7 @@ int is_defined_config(const char * name, int len)
 /*
  * Add a new value to the configuration string.
  */
-void define_config(const char * name, int len)
+static void define_config(const char * name, int len)
 {
 	grow_config(len + 1);
 
@@ -192,7 +192,7 @@ void define_config(const char * name, int len)
 /*
  * Clear the set of configuration strings.
  */
-void clear_config(void)
+static void clear_config(void)
 {
 	len_config = 0;
 	define_config("", 0);
@@ -201,7 +201,7 @@ void clear_config(void)
 /*
  * Record the use of a CONFIG_* word.
  */
-void use_config(char *m, int slen)
+static void use_config(char *m, int slen)
 {
 	char s[PATH_MAX];
 	char *p;
@@ -222,7 +222,7 @@ void use_config(char *m, int slen)
 	printf("    $(wildcard include/config/%s.h) \\\n", s);
 }
 
-void parse_config_file(char *map, size_t len)
+static void parse_config_file(char *map, size_t len)
 {
 	int *end = (int *) (map + len);
 	/* start at +1, so that p can never be < map */
@@ -256,7 +256,7 @@ void parse_config_file(char *map, size_t len)
 }
 
 /* test is s ends in sub */
-int strrcmp(char *s, char *sub)
+static int strrcmp(char *s, char *sub)
 {
 	int slen = strlen(s);
 	int sublen = strlen(sub);
@@ -267,7 +267,7 @@ int strrcmp(char *s, char *sub)
 	return memcmp(s + slen - sublen, sub, sublen);
 }
 
-void do_config_file(char *filename)
+static void do_config_file(char *filename)
 {
 	struct stat st;
 	int fd;
@@ -298,7 +298,7 @@ void do_config_file(char *filename)
 	close(fd);
 }
 
-void parse_dep_file(void *map, size_t len)
+static void parse_dep_file(void *map, size_t len)
 {
 	char *m = map;
 	char *end = m + len;
@@ -338,7 +338,7 @@ void parse_dep_file(void *map, size_t len)
 	printf("$(deps_%s):\n", target);
 }
 
-void print_deps(void)
+static void print_deps(void)
 {
 	struct stat st;
 	int fd;
@@ -370,7 +370,7 @@ void print_deps(void)
 	close(fd);
 }
 
-void traps(void)
+static void traps(void)
 {
 	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
 	int *p = (int *)test;

commit d067aa741589a9783cc43315119e0f431b4e382c
Author: Amerigo Wang <amwang@redhat.com>
Date:   Wed Jun 10 12:48:23 2009 -0700

    kbuild: fix a compile warning
    
    gcc-4.4.1:
    
     HOSTCC  scripts/basic/fixdep
    scripts/basic/fixdep.c: In function 'traps':
    scripts/basic/fixdep.c:377: warning: dereferencing type-punned pointer will break strict-aliasing rules
    scripts/basic/fixdep.c:379: warning: dereferencing type-punned pointer will break strict-aliasing rules
    
    (Apparently -fno-strict-aliasing will fix this too)
    
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 8912c0f5460b..72c15205bb2b 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -373,10 +373,11 @@ void print_deps(void)
 void traps(void)
 {
 	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
+	int *p = (int *)test;
 
-	if (*(int *)test != INT_CONF) {
+	if (*p != INT_CONF) {
 		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",
-			*(int *)test);
+			*p);
 		exit(2);
 	}
 }

commit 04c58f8196b386948abf68128605de3d2db3c6ba
Author: Andy Green <andy@warmcat.com>
Date:   Wed May 2 12:49:06 2007 +0100

    kbuild: scripts/basic/fixdep segfault on pathological string-o-death
    
    build scripts: fixdep blows segfault on string CONFIG_MODULE seen
    
    The string "CONFIG_MODULE" appearing anywhere in a source file causes
    fixdep to segfault.  This string appeared in the wild in the current
    mISDN sources (I think they meant CONFIG_MODULES).  But it shouldn't
    segfault (esp as CONFIG_MODULE appeared in a quoted string).
    
    Signed-off-by: Andy Green <andy@warmcat.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 6bc7e7cfccf6..8912c0f5460b 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -249,6 +249,8 @@ void parse_config_file(char *map, size_t len)
 	found:
 		if (!memcmp(q - 7, "_MODULE", 7))
 			q -= 7;
+		if( (q-p-7) < 0 )
+			continue;
 		use_config(p+7, q-p-7);
 	}
 }

commit c21b1e4d9b0c263a35f67eed2b025d053566c557
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Mar 29 10:27:14 2007 +0100

    [PATCH] kbuild: fix dependency generation
    
    Commit 2e3646e51b2d6415549b310655df63e7e0d7a080 changed the way the
    split config tree is built, but failed to also adjust fixdep accordingly
    - if changing a config option from or to m, files referencing the
    respective CONFIG_..._MODULE (but not the corresponding CONFIG_...)
    didn't get rebuilt.
    
    The problem is that trisate symbol are represent with three different
    symbols:
        SYMBOL=n => no symbol defined
        SYMBOL=y => CONFIG_SYMBOL defined to '1'
        SYMBOL=m => CONFIG_SYMBOL_MODULE defined to '1'
    
    But conf_split_config do not distingush between the =y and =m case, so
    only the =y case is honoured.
    
    This is fixed in fixdep so when a CONFIG symbol with _MODULE is found we
    skip that part and only look for the CONFIG_SYMBOL version.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 668a11a8b383..6bc7e7cfccf6 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -28,9 +28,11 @@
  * the dependency on linux/autoconf.h by a dependency on every config
  * option which is mentioned in any of the listed prequisites.
  *
- * To be exact, split-include populates a tree in include/config/,
- * e.g. include/config/his/driver.h, which contains the #define/#undef
- * for the CONFIG_HIS_DRIVER option.
+ * kconfig populates a tree in include/config/ with an empty file
+ * for each config symbol and when the configuration is updated
+ * the files representing changed config options are touched
+ * which then let make pick up the changes and the files that use
+ * the config symbols are rebuilt.
  *
  * So if the user changes his CONFIG_HIS_DRIVER option, only the objects
  * which depend on "include/linux/config/his/driver.h" will be rebuilt,
@@ -245,6 +247,8 @@ void parse_config_file(char *map, size_t len)
 		continue;
 
 	found:
+		if (!memcmp(q - 7, "_MODULE", 7))
+			q -= 7;
 		use_config(p+7, q-p-7);
 	}
 }

commit 6176aa9ae4b83e1957d3031774f8a8e59ff97420
Author: Jan Beulich <jbeulich@novell.com>
Date:   Mon Jan 30 10:04:27 2006 +0100

    kbuild: consolidate command line escaping
    
    While the recent change to also escape # symbols when storing C-file
    compilation command lines was helpful, it should be in effect for all
    command lines, as much as the dollar escaping should be in effect for
    C-source compilation commands. Additionally, for better readability and
    maintenance, consolidating all the escaping (single quotes, dollars,
    and now sharps) was also desirable.
    
    Signed-Off-By: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 679124b11e12..668a11a8b383 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -132,20 +132,10 @@ void usage(void)
 
 /*
  * Print out the commandline prefixed with cmd_<target filename> :=
- * If commandline contains '#' escape with '\' so make to not see
- * the '#' as a start-of-comment symbol
- **/
+ */
 void print_cmdline(void)
 {
-	char *p = cmdline;
-
-	printf("cmd_%s := ", target);
-	for (; *p; p++) {
-		if (*p == '#')
-			printf("\\");
-		printf("%c", *p);
-	}
-	printf("\n\n");
+	printf("cmd_%s := %s\n\n", target, cmdline);
 }
 
 char * str_config  = NULL;

commit 4d99f93bdaa1ab49188cac67b4aae9180f8e3960
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Dec 25 23:21:14 2005 +0100

    kbuild: escape '#' in .target.cmd files
    
    Commandlines are contained in the .<target>.cmd files and in case they
    contain a '#' char make see this as start of comment.
    Teach fixdep to escape the '#' char so make will assing the full commandline.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 0b61bea869f7..679124b11e12 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -130,9 +130,22 @@ void usage(void)
 	exit(1);
 }
 
+/*
+ * Print out the commandline prefixed with cmd_<target filename> :=
+ * If commandline contains '#' escape with '\' so make to not see
+ * the '#' as a start-of-comment symbol
+ **/
 void print_cmdline(void)
 {
-	printf("cmd_%s := %s\n\n", target, cmdline);
+	char *p = cmdline;
+
+	printf("cmd_%s := ", target);
+	for (; *p; p++) {
+		if (*p == '#')
+			printf("\\");
+		printf("%c", *p);
+	}
+	printf("\n\n");
 }
 
 char * str_config  = NULL;

commit 48b9d03c5f20a0585bb6f7d8c4abad3661df5d75
Author: J.A. Magallon <jamagallon@able.es>
Date:   Sat Jun 25 14:59:22 2005 -0700

    [PATCH] Kill signed chars
    
    scripts/ is full of mismatches between char* params an signed char* arguments,
    and viceversa.  gcc4 now complaints loud about this.  Patch below deletes all
    those 'signed'.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 7f42c5d8a5a2..0b61bea869f7 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -212,23 +212,23 @@ void use_config(char *m, int slen)
 		if (*p == '_')
 			*p = '/';
 		else
-			*p = tolower((unsigned char)*p);
+			*p = tolower((int)*p);
 	}
 	printf("    $(wildcard include/config/%s.h) \\\n", s);
 }
 
-void parse_config_file(signed char *map, size_t len)
+void parse_config_file(char *map, size_t len)
 {
 	int *end = (int *) (map + len);
 	/* start at +1, so that p can never be < map */
 	int *m   = (int *) map + 1;
-	signed char *p, *q;
+	char *p, *q;
 
 	for (; m < end; m++) {
-		if (*m == INT_CONF) { p = (signed char *) m  ; goto conf; }
-		if (*m == INT_ONFI) { p = (signed char *) m-1; goto conf; }
-		if (*m == INT_NFIG) { p = (signed char *) m-2; goto conf; }
-		if (*m == INT_FIG_) { p = (signed char *) m-3; goto conf; }
+		if (*m == INT_CONF) { p = (char *) m  ; goto conf; }
+		if (*m == INT_ONFI) { p = (char *) m-1; goto conf; }
+		if (*m == INT_NFIG) { p = (char *) m-2; goto conf; }
+		if (*m == INT_FIG_) { p = (char *) m-3; goto conf; }
 		continue;
 	conf:
 		if (p > map + len - 7)
@@ -291,9 +291,9 @@ void do_config_file(char *filename)
 
 void parse_dep_file(void *map, size_t len)
 {
-	signed char *m = map;
-	signed char *end = m + len;
-	signed char *p;
+	char *m = map;
+	char *end = m + len;
+	char *p;
 	char s[PATH_MAX];
 
 	p = strchr(m, ':');

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
new file mode 100644
index 000000000000..7f42c5d8a5a2
--- /dev/null
+++ b/scripts/basic/fixdep.c
@@ -0,0 +1,390 @@
+/*
+ * "Optimize" a list of dependencies as spit out by gcc -MD
+ * for the kernel build
+ * ===========================================================================
+ *
+ * Author       Kai Germaschewski
+ * Copyright    2002 by Kai Germaschewski  <kai.germaschewski@gmx.de>
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ *
+ * Introduction:
+ *
+ * gcc produces a very nice and correct list of dependencies which
+ * tells make when to remake a file.
+ *
+ * To use this list as-is however has the drawback that virtually
+ * every file in the kernel includes <linux/config.h> which then again
+ * includes <linux/autoconf.h>
+ *
+ * If the user re-runs make *config, linux/autoconf.h will be
+ * regenerated.  make notices that and will rebuild every file which
+ * includes autoconf.h, i.e. basically all files. This is extremely
+ * annoying if the user just changed CONFIG_HIS_DRIVER from n to m.
+ *
+ * So we play the same trick that "mkdep" played before. We replace
+ * the dependency on linux/autoconf.h by a dependency on every config
+ * option which is mentioned in any of the listed prequisites.
+ *
+ * To be exact, split-include populates a tree in include/config/,
+ * e.g. include/config/his/driver.h, which contains the #define/#undef
+ * for the CONFIG_HIS_DRIVER option.
+ *
+ * So if the user changes his CONFIG_HIS_DRIVER option, only the objects
+ * which depend on "include/linux/config/his/driver.h" will be rebuilt,
+ * so most likely only his driver ;-)
+ *
+ * The idea above dates, by the way, back to Michael E Chastain, AFAIK.
+ *
+ * So to get dependencies right, there are two issues:
+ * o if any of the files the compiler read changed, we need to rebuild
+ * o if the command line given to the compile the file changed, we
+ *   better rebuild as well.
+ *
+ * The former is handled by using the -MD output, the later by saving
+ * the command line used to compile the old object and comparing it
+ * to the one we would now use.
+ *
+ * Again, also this idea is pretty old and has been discussed on
+ * kbuild-devel a long time ago. I don't have a sensibly working
+ * internet connection right now, so I rather don't mention names
+ * without double checking.
+ *
+ * This code here has been based partially based on mkdep.c, which
+ * says the following about its history:
+ *
+ *   Copyright abandoned, Michael Chastain, <mailto:mec@shout.net>.
+ *   This is a C version of syncdep.pl by Werner Almesberger.
+ *
+ *
+ * It is invoked as
+ *
+ *   fixdep <depfile> <target> <cmdline>
+ *
+ * and will read the dependency file <depfile>
+ *
+ * The transformed dependency snipped is written to stdout.
+ *
+ * It first generates a line
+ *
+ *   cmd_<target> = <cmdline>
+ *
+ * and then basically copies the .<target>.d file to stdout, in the
+ * process filtering out the dependency on linux/autoconf.h and adding
+ * dependencies on include/config/my/option.h for every
+ * CONFIG_MY_OPTION encountered in any of the prequisites.
+ *
+ * It will also filter out all the dependencies on *.ver. We need
+ * to make sure that the generated version checksum are globally up
+ * to date before even starting the recursive build, so it's too late
+ * at this point anyway.
+ *
+ * The algorithm to grep for "CONFIG_..." is bit unusual, but should
+ * be fast ;-) We don't even try to really parse the header files, but
+ * merely grep, i.e. if CONFIG_FOO is mentioned in a comment, it will
+ * be picked up as well. It's not a problem with respect to
+ * correctness, since that can only give too many dependencies, thus
+ * we cannot miss a rebuild. Since people tend to not mention totally
+ * unrelated CONFIG_ options all over the place, it's not an
+ * efficiency problem either.
+ *
+ * (Note: it'd be easy to port over the complete mkdep state machine,
+ *  but I don't think the added complexity is worth it)
+ */
+/*
+ * Note 2: if somebody writes HELLO_CONFIG_BOOM in a file, it will depend onto
+ * CONFIG_BOOM. This could seem a bug (not too hard to fix), but please do not
+ * fix it! Some UserModeLinux files (look at arch/um/) call CONFIG_BOOM as
+ * UML_CONFIG_BOOM, to avoid conflicts with /usr/include/linux/autoconf.h,
+ * through arch/um/include/uml-config.h; this fixdep "bug" makes sure that
+ * those files will have correct dependencies.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+#include <ctype.h>
+#include <arpa/inet.h>
+
+#define INT_CONF ntohl(0x434f4e46)
+#define INT_ONFI ntohl(0x4f4e4649)
+#define INT_NFIG ntohl(0x4e464947)
+#define INT_FIG_ ntohl(0x4649475f)
+
+char *target;
+char *depfile;
+char *cmdline;
+
+void usage(void)
+
+{
+	fprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");
+	exit(1);
+}
+
+void print_cmdline(void)
+{
+	printf("cmd_%s := %s\n\n", target, cmdline);
+}
+
+char * str_config  = NULL;
+int    size_config = 0;
+int    len_config  = 0;
+
+/*
+ * Grow the configuration string to a desired length.
+ * Usually the first growth is plenty.
+ */
+void grow_config(int len)
+{
+	while (len_config + len > size_config) {
+		if (size_config == 0)
+			size_config = 2048;
+		str_config = realloc(str_config, size_config *= 2);
+		if (str_config == NULL)
+			{ perror("fixdep:malloc"); exit(1); }
+	}
+}
+
+
+
+/*
+ * Lookup a value in the configuration string.
+ */
+int is_defined_config(const char * name, int len)
+{
+	const char * pconfig;
+	const char * plast = str_config + len_config - len;
+	for ( pconfig = str_config + 1; pconfig < plast; pconfig++ ) {
+		if (pconfig[ -1] == '\n'
+		&&  pconfig[len] == '\n'
+		&&  !memcmp(pconfig, name, len))
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Add a new value to the configuration string.
+ */
+void define_config(const char * name, int len)
+{
+	grow_config(len + 1);
+
+	memcpy(str_config+len_config, name, len);
+	len_config += len;
+	str_config[len_config++] = '\n';
+}
+
+/*
+ * Clear the set of configuration strings.
+ */
+void clear_config(void)
+{
+	len_config = 0;
+	define_config("", 0);
+}
+
+/*
+ * Record the use of a CONFIG_* word.
+ */
+void use_config(char *m, int slen)
+{
+	char s[PATH_MAX];
+	char *p;
+
+	if (is_defined_config(m, slen))
+	    return;
+
+	define_config(m, slen);
+
+	memcpy(s, m, slen); s[slen] = 0;
+
+	for (p = s; p < s + slen; p++) {
+		if (*p == '_')
+			*p = '/';
+		else
+			*p = tolower((unsigned char)*p);
+	}
+	printf("    $(wildcard include/config/%s.h) \\\n", s);
+}
+
+void parse_config_file(signed char *map, size_t len)
+{
+	int *end = (int *) (map + len);
+	/* start at +1, so that p can never be < map */
+	int *m   = (int *) map + 1;
+	signed char *p, *q;
+
+	for (; m < end; m++) {
+		if (*m == INT_CONF) { p = (signed char *) m  ; goto conf; }
+		if (*m == INT_ONFI) { p = (signed char *) m-1; goto conf; }
+		if (*m == INT_NFIG) { p = (signed char *) m-2; goto conf; }
+		if (*m == INT_FIG_) { p = (signed char *) m-3; goto conf; }
+		continue;
+	conf:
+		if (p > map + len - 7)
+			continue;
+		if (memcmp(p, "CONFIG_", 7))
+			continue;
+		for (q = p + 7; q < map + len; q++) {
+			if (!(isalnum(*q) || *q == '_'))
+				goto found;
+		}
+		continue;
+
+	found:
+		use_config(p+7, q-p-7);
+	}
+}
+
+/* test is s ends in sub */
+int strrcmp(char *s, char *sub)
+{
+	int slen = strlen(s);
+	int sublen = strlen(sub);
+
+	if (sublen > slen)
+		return 1;
+
+	return memcmp(s + slen - sublen, sub, sublen);
+}
+
+void do_config_file(char *filename)
+{
+	struct stat st;
+	int fd;
+	void *map;
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		fprintf(stderr, "fixdep: ");
+		perror(filename);
+		exit(2);
+	}
+	fstat(fd, &st);
+	if (st.st_size == 0) {
+		close(fd);
+		return;
+	}
+	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if ((long) map == -1) {
+		perror("fixdep: mmap");
+		close(fd);
+		return;
+	}
+
+	parse_config_file(map, st.st_size);
+
+	munmap(map, st.st_size);
+
+	close(fd);
+}
+
+void parse_dep_file(void *map, size_t len)
+{
+	signed char *m = map;
+	signed char *end = m + len;
+	signed char *p;
+	char s[PATH_MAX];
+
+	p = strchr(m, ':');
+	if (!p) {
+		fprintf(stderr, "fixdep: parse error\n");
+		exit(1);
+	}
+	memcpy(s, m, p-m); s[p-m] = 0;
+	printf("deps_%s := \\\n", target);
+	m = p+1;
+
+	clear_config();
+
+	while (m < end) {
+		while (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))
+			m++;
+		p = m;
+		while (p < end && *p != ' ') p++;
+		if (p == end) {
+			do p--; while (!isalnum(*p));
+			p++;
+		}
+		memcpy(s, m, p-m); s[p-m] = 0;
+		if (strrcmp(s, "include/linux/autoconf.h") &&
+		    strrcmp(s, "arch/um/include/uml-config.h") &&
+		    strrcmp(s, ".ver")) {
+			printf("  %s \\\n", s);
+			do_config_file(s);
+		}
+		m = p + 1;
+	}
+	printf("\n%s: $(deps_%s)\n\n", target, target);
+	printf("$(deps_%s):\n", target);
+}
+
+void print_deps(void)
+{
+	struct stat st;
+	int fd;
+	void *map;
+
+	fd = open(depfile, O_RDONLY);
+	if (fd < 0) {
+		fprintf(stderr, "fixdep: ");
+		perror(depfile);
+		exit(2);
+	}
+	fstat(fd, &st);
+	if (st.st_size == 0) {
+		fprintf(stderr,"fixdep: %s is empty\n",depfile);
+		close(fd);
+		return;
+	}
+	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if ((long) map == -1) {
+		perror("fixdep: mmap");
+		close(fd);
+		return;
+	}
+
+	parse_dep_file(map, st.st_size);
+
+	munmap(map, st.st_size);
+
+	close(fd);
+}
+
+void traps(void)
+{
+	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
+
+	if (*(int *)test != INT_CONF) {
+		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",
+			*(int *)test);
+		exit(2);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	traps();
+
+	if (argc != 4)
+		usage();
+
+	depfile = argv[1];
+	target = argv[2];
+	cmdline = argv[3];
+
+	print_cmdline();
+	print_deps();
+
+	return 0;
+}
