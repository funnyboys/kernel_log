commit 927d780ee371d7e121cea4fc7812f6ef2cea461c
Author: Alex Sverdlin <alexander.sverdlin@nokia.com>
Date:   Wed Jan 8 15:57:47 2020 +0100

    ARM: 8950/1: ftrace/recordmcount: filter relocation types
    
    Scenario 1, ARMv7
    =================
    
    If code in arch/arm/kernel/ftrace.c would operate on mcount() pointer
    the following may be generated:
    
    00000230 <prealloc_fixed_plts>:
     230:   b5f8            push    {r3, r4, r5, r6, r7, lr}
     232:   b500            push    {lr}
     234:   f7ff fffe       bl      0 <__gnu_mcount_nc>
                            234: R_ARM_THM_CALL     __gnu_mcount_nc
     238:   f240 0600       movw    r6, #0
                            238: R_ARM_THM_MOVW_ABS_NC      __gnu_mcount_nc
     23c:   f8d0 1180       ldr.w   r1, [r0, #384]  ; 0x180
    
    FTRACE currently is not able to deal with it:
    
    WARNING: CPU: 0 PID: 0 at .../kernel/trace/ftrace.c:1979 ftrace_bug+0x1ad/0x230()
    ...
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.4.116-... #1
    ...
    [<c0314e3d>] (unwind_backtrace) from [<c03115e9>] (show_stack+0x11/0x14)
    [<c03115e9>] (show_stack) from [<c051a7f1>] (dump_stack+0x81/0xa8)
    [<c051a7f1>] (dump_stack) from [<c0321c5d>] (warn_slowpath_common+0x69/0x90)
    [<c0321c5d>] (warn_slowpath_common) from [<c0321cf3>] (warn_slowpath_null+0x17/0x1c)
    [<c0321cf3>] (warn_slowpath_null) from [<c038ee9d>] (ftrace_bug+0x1ad/0x230)
    [<c038ee9d>] (ftrace_bug) from [<c038f1f9>] (ftrace_process_locs+0x27d/0x444)
    [<c038f1f9>] (ftrace_process_locs) from [<c08915bd>] (ftrace_init+0x91/0xe8)
    [<c08915bd>] (ftrace_init) from [<c0885a67>] (start_kernel+0x34b/0x358)
    [<c0885a67>] (start_kernel) from [<00308095>] (0x308095)
    ---[ end trace cb88537fdc8fa200 ]---
    ftrace failed to modify [<c031266c>] prealloc_fixed_plts+0x8/0x60
     actual: 44:f2:e1:36
    ftrace record flags: 0
     (0)   expected tramp: c03143e9
    
    Scenario 2, ARMv4T
    ==================
    
    ftrace: allocating 14435 entries in 43 pages
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/trace/ftrace.c:2029 ftrace_bug+0x204/0x310
    CPU: 0 PID: 0 Comm: swapper Not tainted 4.19.5 #1
    Hardware name: Cirrus Logic EDB9302 Evaluation Board
    [<c0010a24>] (unwind_backtrace) from [<c000ecb0>] (show_stack+0x20/0x2c)
    [<c000ecb0>] (show_stack) from [<c03c72e8>] (dump_stack+0x20/0x30)
    [<c03c72e8>] (dump_stack) from [<c0021c18>] (__warn+0xdc/0x104)
    [<c0021c18>] (__warn) from [<c0021d7c>] (warn_slowpath_null+0x4c/0x5c)
    [<c0021d7c>] (warn_slowpath_null) from [<c0095360>] (ftrace_bug+0x204/0x310)
    [<c0095360>] (ftrace_bug) from [<c04dabac>] (ftrace_init+0x3b4/0x4d4)
    [<c04dabac>] (ftrace_init) from [<c04cef4c>] (start_kernel+0x20c/0x410)
    [<c04cef4c>] (start_kernel) from [<00000000>] (  (null))
    ---[ end trace 0506a2f5dae6b341 ]---
    ftrace failed to modify
    [<c000c350>] perf_trace_sys_exit+0x5c/0xe8
     actual:   1e:ff:2f:e1
    Initializing ftrace call sites
    ftrace record flags: 0
     (0)
     expected tramp: c000fb24
    
    The analysis for this problem has been already performed previously,
    refer to the link below.
    
    Fix the above problems by allowing only selected reloc types in
    __mcount_loc. The list itself comes from the legacy recordmcount.pl
    script.
    
    Link: https://lore.kernel.org/lkml/56961010.6000806@pengutronix.de/
    Cc: stable@vger.kernel.org
    Fixes: ed60453fa8f8 ("ARM: 6511/1: ftrace: add ARM support for C version of recordmcount")
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 612268eabef4..7225107a9aaf 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -38,6 +38,10 @@
 #define R_AARCH64_ABS64	257
 #endif
 
+#define R_ARM_PC24		1
+#define R_ARM_THM_CALL		10
+#define R_ARM_CALL		28
+
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
 static char gpfx;	/* prefix for global symbol name (sometimes '_') */
@@ -418,6 +422,18 @@ static char const *already_has_rel_mcount = "success"; /* our work here is done!
 #define RECORD_MCOUNT_64
 #include "recordmcount.h"
 
+static int arm_is_fake_mcount(Elf32_Rel const *rp)
+{
+	switch (ELF32_R_TYPE(w(rp->r_info))) {
+	case R_ARM_THM_CALL:
+	case R_ARM_CALL:
+	case R_ARM_PC24:
+		return 0;
+	}
+
+	return 1;
+}
+
 /* 64-bit EM_MIPS has weird ELF64_Rela.r_info.
  * http://techpubs.sgi.com/library/manuals/4000/007-4658-001/pdf/007-4658-001.pdf
  * We interpret Table 29 Relocation Operation (Elf64_Rel, Elf64_Rela) [p.40]
@@ -523,6 +539,7 @@ static int do_file(char const *const fname)
 		altmcount = "__gnu_mcount_nc";
 		make_nop = make_nop_arm;
 		rel_type_nop = R_ARM_NONE;
+		is_fake_mcount32 = arm_is_fake_mcount;
 		gpfx = 0;
 		break;
 	case EM_AARCH64:

commit 4fbcf0741697a75eb766835cb34836cf4f3803da
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 31 11:24:16 2019 -0700

    recordmcount: Clarify what cleanup() does
    
    cleanup() mostly frees/unmaps the malloc'd/privately-mapped
    copy of the ELF file recordmcount is working on, which is
    set up in mmap_file(). It also deals with positioning within
    the pseduo prive-mapping of the file and appending to the ELF
    file.
    
    Split into two steps:
            mmap_cleanup() for the mapping itself
            file_append_cleanup() for allocations storing the
                    appended ELF data.
    
    Also, move the global variable initializations out of the main,
    per-object-file loop and nearer to the alloc/init (mmap_file())
    and two cleanup functions so we can more clearly see how they're
    related.
    
    Link: http://lkml.kernel.org/r/2a387ac86d133d22c68f57b9933c32bab1d09a2d.1564596289.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 5677fcc88a72..612268eabef4 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -48,21 +48,26 @@ static void *file_map;	/* pointer of the mapped file */
 static void *file_end;	/* pointer to the end of the mapped file */
 static int file_updated; /* flag to state file was changed */
 static void *file_ptr;	/* current file pointer location */
+
 static void *file_append; /* added to the end of the file */
 static size_t file_append_size; /* how much is added to end of file */
 
 /* Per-file resource cleanup when multiple files. */
-static void cleanup(void)
+static void file_append_cleanup(void)
+{
+	free(file_append);
+	file_append = NULL;
+	file_append_size = 0;
+	file_updated = 0;
+}
+
+static void mmap_cleanup(void)
 {
 	if (!mmap_failed)
 		munmap(file_map, sb.st_size);
 	else
 		free(file_map);
 	file_map = NULL;
-	free(file_append);
-	file_append = NULL;
-	file_append_size = 0;
-	file_updated = 0;
 }
 
 /* ulseek, uwrite, ...:  Check return value for errors. */
@@ -103,7 +108,8 @@ static ssize_t uwrite(void const *const buf, size_t const count)
 		}
 		if (!file_append) {
 			perror("write");
-			cleanup();
+			file_append_cleanup();
+			mmap_cleanup();
 			return -1;
 		}
 		if (file_ptr < file_end) {
@@ -129,12 +135,76 @@ static void * umalloc(size_t size)
 	void *const addr = malloc(size);
 	if (addr == 0) {
 		fprintf(stderr, "malloc failed: %zu bytes\n", size);
-		cleanup();
+		file_append_cleanup();
+		mmap_cleanup();
 		return NULL;
 	}
 	return addr;
 }
 
+/*
+ * Get the whole file as a programming convenience in order to avoid
+ * malloc+lseek+read+free of many pieces.  If successful, then mmap
+ * avoids copying unused pieces; else just read the whole file.
+ * Open for both read and write; new info will be appended to the file.
+ * Use MAP_PRIVATE so that a few changes to the in-memory ElfXX_Ehdr
+ * do not propagate to the file until an explicit overwrite at the last.
+ * This preserves most aspects of consistency (all except .st_size)
+ * for simultaneous readers of the file while we are appending to it.
+ * However, multiple writers still are bad.  We choose not to use
+ * locking because it is expensive and the use case of kernel build
+ * makes multiple writers unlikely.
+ */
+static void *mmap_file(char const *fname)
+{
+	/* Avoid problems if early cleanup() */
+	fd_map = -1;
+	mmap_failed = 1;
+	file_map = NULL;
+	file_ptr = NULL;
+	file_updated = 0;
+	sb.st_size = 0;
+
+	fd_map = open(fname, O_RDONLY);
+	if (fd_map < 0) {
+		perror(fname);
+		return NULL;
+	}
+	if (fstat(fd_map, &sb) < 0) {
+		perror(fname);
+		goto out;
+	}
+	if (!S_ISREG(sb.st_mode)) {
+		fprintf(stderr, "not a regular file: %s\n", fname);
+		goto out;
+	}
+	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
+			fd_map, 0);
+	if (file_map == MAP_FAILED) {
+		mmap_failed = 1;
+		file_map = umalloc(sb.st_size);
+		if (!file_map) {
+			perror(fname);
+			goto out;
+		}
+		if (read(fd_map, file_map, sb.st_size) != sb.st_size) {
+			perror(fname);
+			free(file_map);
+			file_map = NULL;
+			goto out;
+		}
+	} else
+		mmap_failed = 0;
+out:
+	close(fd_map);
+	fd_map = -1;
+
+	file_end = file_map + sb.st_size;
+
+	return file_map;
+}
+
+
 static unsigned char ideal_nop5_x86_64[5] = { 0x0f, 0x1f, 0x44, 0x00, 0x00 };
 static unsigned char ideal_nop5_x86_32[5] = { 0x3e, 0x8d, 0x74, 0x26, 0x00 };
 static unsigned char *ideal_nop;
@@ -238,61 +308,6 @@ static int make_nop_arm64(void *map, size_t const offset)
 	return 0;
 }
 
-/*
- * Get the whole file as a programming convenience in order to avoid
- * malloc+lseek+read+free of many pieces.  If successful, then mmap
- * avoids copying unused pieces; else just read the whole file.
- * Open for both read and write; new info will be appended to the file.
- * Use MAP_PRIVATE so that a few changes to the in-memory ElfXX_Ehdr
- * do not propagate to the file until an explicit overwrite at the last.
- * This preserves most aspects of consistency (all except .st_size)
- * for simultaneous readers of the file while we are appending to it.
- * However, multiple writers still are bad.  We choose not to use
- * locking because it is expensive and the use case of kernel build
- * makes multiple writers unlikely.
- */
-static void *mmap_file(char const *fname)
-{
-	file_map = NULL;
-	sb.st_size = 0;
-	fd_map = open(fname, O_RDONLY);
-	if (fd_map < 0) {
-		perror(fname);
-		return NULL;
-	}
-	if (fstat(fd_map, &sb) < 0) {
-		perror(fname);
-		goto out;
-	}
-	if (!S_ISREG(sb.st_mode)) {
-		fprintf(stderr, "not a regular file: %s\n", fname);
-		goto out;
-	}
-	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
-			fd_map, 0);
-	mmap_failed = 0;
-	if (file_map == MAP_FAILED) {
-		mmap_failed = 1;
-		file_map = umalloc(sb.st_size);
-		if (!file_map) {
-			perror(fname);
-			goto out;
-		}
-		if (read(fd_map, file_map, sb.st_size) != sb.st_size) {
-			perror(fname);
-			free(file_map);
-			file_map = NULL;
-			goto out;
-		}
-	}
-out:
-	close(fd_map);
-
-	file_end = file_map + sb.st_size;
-
-	return file_map;
-}
-
 static int write_file(const char *fname)
 {
 	char tmp_file[strlen(fname) + 4];
@@ -438,10 +453,11 @@ static void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)
 
 static int do_file(char const *const fname)
 {
-	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
+	Elf32_Ehdr *ehdr;
 	int rc = -1;
 
+	ehdr = mmap_file(fname);
 	if (!ehdr)
 		goto out;
 
@@ -577,7 +593,8 @@ static int do_file(char const *const fname)
 
 	rc = write_file(fname);
 out:
-	cleanup();
+	file_append_cleanup();
+	mmap_cleanup();
 	return rc;
 }
 
@@ -620,12 +637,6 @@ int main(int argc, char *argv[])
 		    strcmp(file + (len - ftrace_size), ftrace) == 0)
 			continue;
 
-		/* Avoid problems if early cleanup() */
-		fd_map = -1;
-		mmap_failed = 1;
-		file_map = NULL;
-		file_ptr = NULL;
-		file_updated = 0;
 		if (do_file(file)) {
 			fprintf(stderr, "%s: failed\n", file);
 			++n_error;

commit c97fea26254b284c93a67b788968622f9cc03b30
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 31 11:24:15 2019 -0700

    recordmcount: Remove redundant cleanup() calls
    
    Redundant cleanup calls were introduced when transitioning from
    the old error/success handling via setjmp/longjmp -- the longjmp
    ensured the cleanup() call only happened once but replacing
    the success_file()/fail_file() calls with cleanup() meant that
    multiple cleanup() calls can happen as we return from function
    calls.
    
    In do_file(), looking just before and after the "goto out" jumps we
    can see that multiple cleanups() are being performed. We remove
    cleanup() calls from the nested functions because it makes the code
    easier to review -- the resources being cleaned up are generally
    allocated and initialized in the callers so freeing them there
    makes more sense.
    
    Other redundant cleanup() calls:
    
    mmap_file() is only called from do_file() and, if mmap_file() fails,
    then we goto out and do cleanup() there too.
    
    write_file() is only called from do_file() and do_file()
    calls cleanup() unconditionally after returning from write_file()
    therefore the cleanup() calls in write_file() are not necessary.
    
    find_secsym_ndx(), called from do_func()'s for-loop, when we are
    cleaning up here it's obvious that we break out of the loop and
    do another cleanup().
    
    __has_rel_mcount() is called from two parts of do_func()
    and calls cleanup(). In theory we move them into do_func(), however
    these in turn prove redundant so another simplification step
    removes them as well.
    
    Link: http://lkml.kernel.org/r/de197e17fc5426623a847ea7cf3a1560a7402a4b.1564596289.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 273ca8b42b20..5677fcc88a72 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -258,17 +258,14 @@ static void *mmap_file(char const *fname)
 	fd_map = open(fname, O_RDONLY);
 	if (fd_map < 0) {
 		perror(fname);
-		cleanup();
 		return NULL;
 	}
 	if (fstat(fd_map, &sb) < 0) {
 		perror(fname);
-		cleanup();
 		goto out;
 	}
 	if (!S_ISREG(sb.st_mode)) {
 		fprintf(stderr, "not a regular file: %s\n", fname);
-		cleanup();
 		goto out;
 	}
 	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
@@ -314,13 +311,11 @@ static int write_file(const char *fname)
 	fd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);
 	if (fd_map < 0) {
 		perror(fname);
-		cleanup();
 		return -1;
 	}
 	n = write(fd_map, file_map, sb.st_size);
 	if (n != sb.st_size) {
 		perror("write");
-		cleanup();
 		close(fd_map);
 		return -1;
 	}
@@ -328,7 +323,6 @@ static int write_file(const char *fname)
 		n = write(fd_map, file_append, file_append_size);
 		if (n != file_append_size) {
 			perror("write");
-			cleanup();
 			close(fd_map);
 			return -1;
 		}
@@ -336,7 +330,6 @@ static int write_file(const char *fname)
 	close(fd_map);
 	if (rename(tmp_file, fname) < 0) {
 		perror(fname);
-		cleanup();
 		return -1;
 	}
 	return 0;
@@ -460,7 +453,6 @@ static int do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
 			ehdr->e_ident[EI_DATA], fname);
-		cleanup();
 		goto out;
 	case ELFDATA2LSB:
 		if (*(unsigned char const *)&endian != 1) {
@@ -493,7 +485,6 @@ static int do_file(char const *const fname)
 	    w2(ehdr->e_type) != ET_REL ||
 	    ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
 		fprintf(stderr, "unrecognized ET_REL file %s\n", fname);
-		cleanup();
 		goto out;
 	}
 
@@ -502,7 +493,6 @@ static int do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized e_machine %u %s\n",
 			w2(ehdr->e_machine), fname);
-		cleanup();
 		goto out;
 	case EM_386:
 		reltype = R_386_32;
@@ -546,14 +536,12 @@ static int do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized ELF class %d %s\n",
 			ehdr->e_ident[EI_CLASS], fname);
-		cleanup();
 		goto out;
 	case ELFCLASS32:
 		if (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)
 		||  w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
-			cleanup();
 			goto out;
 		}
 		if (w2(ehdr->e_machine) == EM_MIPS) {
@@ -569,7 +557,6 @@ static int do_file(char const *const fname)
 		||  w2(ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
-			cleanup();
 			goto out;
 		}
 		if (w2(ghdr->e_machine) == EM_S390) {

commit 2e63152bc1909e10b7bc844bbbef5a815f585b45
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 31 11:24:14 2019 -0700

    recordmcount: Kernel style formatting
    
    Fix up the whitespace irregularity in the ELF switch
    blocks.
    
    Swapping the initial value of gpfx allows us to
    simplify all but one of the one-line switch cases even
    further.
    
    Link: http://lkml.kernel.org/r/647f21f43723d3e831cedd3238c893db03eea6f0.1564596289.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 67f9c45b824f..273ca8b42b20 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -489,15 +489,15 @@ static int do_file(char const *const fname)
 		push_bl_mcount_thumb = push_bl_mcount_thumb_be;
 		break;
 	}  /* end switch */
-	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
-	||  w2(ehdr->e_type) != ET_REL
-	||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
+	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0 ||
+	    w2(ehdr->e_type) != ET_REL ||
+	    ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
 		fprintf(stderr, "unrecognized ET_REL file %s\n", fname);
 		cleanup();
 		goto out;
 	}
 
-	gpfx = 0;
+	gpfx = '_';
 	switch (w2(ehdr->e_machine)) {
 	default:
 		fprintf(stderr, "unrecognized e_machine %u %s\n",
@@ -510,32 +510,35 @@ static int do_file(char const *const fname)
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_32;
 		mcount_adjust_32 = -1;
+		gpfx = 0;
+		break;
+	case EM_ARM:
+		reltype = R_ARM_ABS32;
+		altmcount = "__gnu_mcount_nc";
+		make_nop = make_nop_arm;
+		rel_type_nop = R_ARM_NONE;
+		gpfx = 0;
 		break;
-	case EM_ARM:	 reltype = R_ARM_ABS32;
-			 altmcount = "__gnu_mcount_nc";
-			 make_nop = make_nop_arm;
-			 rel_type_nop = R_ARM_NONE;
-			 break;
 	case EM_AARCH64:
-			reltype = R_AARCH64_ABS64;
-			make_nop = make_nop_arm64;
-			rel_type_nop = R_AARCH64_NONE;
-			ideal_nop = ideal_nop4_arm64;
-			gpfx = '_';
-			break;
-	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
-	case EM_MIPS:	 /* reltype: e_class    */ gpfx = '_'; break;
-	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;
-	case EM_PPC64:	 reltype = R_PPC64_ADDR64; gpfx = '_'; break;
-	case EM_S390:    /* reltype: e_class    */ gpfx = '_'; break;
-	case EM_SH:	 reltype = R_SH_DIR32;                 break;
-	case EM_SPARCV9: reltype = R_SPARC_64;     gpfx = '_'; break;
+		reltype = R_AARCH64_ABS64;
+		make_nop = make_nop_arm64;
+		rel_type_nop = R_AARCH64_NONE;
+		ideal_nop = ideal_nop4_arm64;
+		break;
+	case EM_IA_64:	reltype = R_IA64_IMM64; break;
+	case EM_MIPS:	/* reltype: e_class    */ break;
+	case EM_PPC:	reltype = R_PPC_ADDR32; break;
+	case EM_PPC64:	reltype = R_PPC64_ADDR64; break;
+	case EM_S390:	/* reltype: e_class    */ break;
+	case EM_SH:	reltype = R_SH_DIR32; gpfx = 0; break;
+	case EM_SPARCV9: reltype = R_SPARC_64; break;
 	case EM_X86_64:
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_64;
 		reltype = R_X86_64_64;
 		rel_type_nop = R_X86_64_NONE;
 		mcount_adjust_64 = -1;
+		gpfx = 0;
 		break;
 	}  /* end switch */
 

commit 3aec8638246ff284e4075aac4f72ab160ebccaf2
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 31 11:24:13 2019 -0700

    recordmcount: Kernel style function signature formatting
    
    The uwrite() and ulseek() functions are formatted inconsistently
    with the rest of the file and the kernel overall. While we're
    making other changes here let's fix this.
    
    Link: http://lkml.kernel.org/r/4c67698f734be9867a2aba7035fe0ce59e1e4423.1564596289.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index c6d395b8ff29..67f9c45b824f 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -52,8 +52,7 @@ static void *file_append; /* added to the end of the file */
 static size_t file_append_size; /* how much is added to end of file */
 
 /* Per-file resource cleanup when multiple files. */
-static void
-cleanup(void)
+static void cleanup(void)
 {
 	if (!mmap_failed)
 		munmap(file_map, sb.st_size);
@@ -68,8 +67,7 @@ cleanup(void)
 
 /* ulseek, uwrite, ...:  Check return value for errors. */
 
-static off_t
-ulseek(off_t const offset, int const whence)
+static off_t ulseek(off_t const offset, int const whence)
 {
 	switch (whence) {
 	case SEEK_SET:
@@ -89,8 +87,7 @@ ulseek(off_t const offset, int const whence)
 	return file_ptr - file_map;
 }
 
-static ssize_t
-uwrite(void const *const buf, size_t const count)
+static ssize_t uwrite(void const *const buf, size_t const count)
 {
 	size_t cnt = count;
 	off_t idx = 0;
@@ -127,8 +124,7 @@ uwrite(void const *const buf, size_t const count)
 	return count;
 }
 
-static void *
-umalloc(size_t size)
+static void * umalloc(size_t size)
 {
 	void *const addr = malloc(size);
 	if (addr == 0) {
@@ -394,8 +390,7 @@ static uint32_t (*w)(uint32_t);
 static uint32_t (*w2)(uint16_t);
 
 /* Names of the sections that could contain calls to mcount. */
-static int
-is_mcounted_section_name(char const *const txtname)
+static int is_mcounted_section_name(char const *const txtname)
 {
 	return strncmp(".text",          txtname, 5) == 0 ||
 		strcmp(".init.text",     txtname) == 0 ||
@@ -448,8 +443,7 @@ static void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)
 	}).r_info;
 }
 
-static int
-do_file(char const *const fname)
+static int do_file(char const *const fname)
 {
 	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
@@ -597,8 +591,7 @@ do_file(char const *const fname)
 	return rc;
 }
 
-int
-main(int argc, char *argv[])
+int main(int argc, char *argv[])
 {
 	const char ftrace[] = "/ftrace.o";
 	int ftrace_size = sizeof(ftrace) - 1;

commit 3f1df12019f333442b12c3b5d110b8fc43eb0b36
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 31 11:24:12 2019 -0700

    recordmcount: Rewrite error/success handling
    
    Recordmcount uses setjmp/longjmp to manage control flow as
    it reads and then writes the ELF file. This unusual control
    flow is hard to follow and check in addition to being unlike
    kernel coding style.
    
    So we rewrite these paths to use regular return values to
    indicate error/success. When an error or previously-completed object
    file is found we return an error code following kernel
    coding conventions -- negative error values and 0 for success when
    we're not returning a pointer. We return NULL for those that fail
    and return non-NULL pointers otherwise.
    
    One oddity is already_has_rel_mcount -- there we use pointer comparison
    rather than string comparison to differentiate between
    previously-processed object files and returning the name of a text
    section.
    
    Link: http://lkml.kernel.org/r/8ba8633d4afe444931f363c8d924bf9565b89a86.1564596289.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 1fe5fba99959..c6d395b8ff29 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -27,7 +27,6 @@
 #include <getopt.h>
 #include <elf.h>
 #include <fcntl.h>
-#include <setjmp.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -43,7 +42,6 @@ static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
 static char gpfx;	/* prefix for global symbol name (sometimes '_') */
 static struct stat sb;	/* Remember .st_size, etc. */
-static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
 static const char *altmcount;	/* alternate mcount symbol name */
 static int warn_on_notrace_sect; /* warn when section has mcount not being recorded */
 static void *file_map;	/* pointer of the mapped file */
@@ -53,13 +51,6 @@ static void *file_ptr;	/* current file pointer location */
 static void *file_append; /* added to the end of the file */
 static size_t file_append_size; /* how much is added to end of file */
 
-/* setjmp() return values */
-enum {
-	SJ_SETJMP = 0,  /* hardwired first return */
-	SJ_FAIL,
-	SJ_SUCCEED
-};
-
 /* Per-file resource cleanup when multiple files. */
 static void
 cleanup(void)
@@ -75,20 +66,6 @@ cleanup(void)
 	file_updated = 0;
 }
 
-static void __attribute__((noreturn))
-fail_file(void)
-{
-	cleanup();
-	longjmp(jmpenv, SJ_FAIL);
-}
-
-static void __attribute__((noreturn))
-succeed_file(void)
-{
-	cleanup();
-	longjmp(jmpenv, SJ_SUCCEED);
-}
-
 /* ulseek, uwrite, ...:  Check return value for errors. */
 
 static off_t
@@ -107,12 +84,12 @@ ulseek(off_t const offset, int const whence)
 	}
 	if (file_ptr < file_map) {
 		fprintf(stderr, "lseek: seek before file\n");
-		fail_file();
+		return -1;
 	}
 	return file_ptr - file_map;
 }
 
-static size_t
+static ssize_t
 uwrite(void const *const buf, size_t const count)
 {
 	size_t cnt = count;
@@ -129,7 +106,8 @@ uwrite(void const *const buf, size_t const count)
 		}
 		if (!file_append) {
 			perror("write");
-			fail_file();
+			cleanup();
+			return -1;
 		}
 		if (file_ptr < file_end) {
 			cnt = file_end - file_ptr;
@@ -155,7 +133,8 @@ umalloc(size_t size)
 	void *const addr = malloc(size);
 	if (addr == 0) {
 		fprintf(stderr, "malloc failed: %zu bytes\n", size);
-		fail_file();
+		cleanup();
+		return NULL;
 	}
 	return addr;
 }
@@ -183,8 +162,10 @@ static int make_nop_x86(void *map, size_t const offset)
 		return -1;
 
 	/* convert to nop */
-	ulseek(offset - 1, SEEK_SET);
-	uwrite(ideal_nop, 5);
+	if (ulseek(offset - 1, SEEK_SET) < 0)
+		return -1;
+	if (uwrite(ideal_nop, 5) < 0)
+		return -1;
 	return 0;
 }
 
@@ -232,10 +213,12 @@ static int make_nop_arm(void *map, size_t const offset)
 		return -1;
 
 	/* Convert to nop */
-	ulseek(off, SEEK_SET);
+	if (ulseek(off, SEEK_SET) < 0)
+		return -1;
 
 	do {
-		uwrite(ideal_nop, nop_size);
+		if (uwrite(ideal_nop, nop_size) < 0)
+			return -1;
 	} while (--cnt > 0);
 
 	return 0;
@@ -252,8 +235,10 @@ static int make_nop_arm64(void *map, size_t const offset)
 		return -1;
 
 	/* Convert to nop */
-	ulseek(offset, SEEK_SET);
-	uwrite(ideal_nop, 4);
+	if (ulseek(offset, SEEK_SET) < 0)
+		return -1;
+	if (uwrite(ideal_nop, 4) < 0)
+		return -1;
 	return 0;
 }
 
@@ -272,14 +257,23 @@ static int make_nop_arm64(void *map, size_t const offset)
  */
 static void *mmap_file(char const *fname)
 {
+	file_map = NULL;
+	sb.st_size = 0;
 	fd_map = open(fname, O_RDONLY);
-	if (fd_map < 0 || fstat(fd_map, &sb) < 0) {
+	if (fd_map < 0) {
+		perror(fname);
+		cleanup();
+		return NULL;
+	}
+	if (fstat(fd_map, &sb) < 0) {
 		perror(fname);
-		fail_file();
+		cleanup();
+		goto out;
 	}
 	if (!S_ISREG(sb.st_mode)) {
 		fprintf(stderr, "not a regular file: %s\n", fname);
-		fail_file();
+		cleanup();
+		goto out;
 	}
 	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
 			fd_map, 0);
@@ -287,11 +281,18 @@ static void *mmap_file(char const *fname)
 	if (file_map == MAP_FAILED) {
 		mmap_failed = 1;
 		file_map = umalloc(sb.st_size);
+		if (!file_map) {
+			perror(fname);
+			goto out;
+		}
 		if (read(fd_map, file_map, sb.st_size) != sb.st_size) {
 			perror(fname);
-			fail_file();
+			free(file_map);
+			file_map = NULL;
+			goto out;
 		}
 	}
+out:
 	close(fd_map);
 
 	file_end = file_map + sb.st_size;
@@ -299,13 +300,13 @@ static void *mmap_file(char const *fname)
 	return file_map;
 }
 
-static void write_file(const char *fname)
+static int write_file(const char *fname)
 {
 	char tmp_file[strlen(fname) + 4];
 	size_t n;
 
 	if (!file_updated)
-		return;
+		return 0;
 
 	sprintf(tmp_file, "%s.rc", fname);
 
@@ -317,25 +318,32 @@ static void write_file(const char *fname)
 	fd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);
 	if (fd_map < 0) {
 		perror(fname);
-		fail_file();
+		cleanup();
+		return -1;
 	}
 	n = write(fd_map, file_map, sb.st_size);
 	if (n != sb.st_size) {
 		perror("write");
-		fail_file();
+		cleanup();
+		close(fd_map);
+		return -1;
 	}
 	if (file_append_size) {
 		n = write(fd_map, file_append, file_append_size);
 		if (n != file_append_size) {
 			perror("write");
-			fail_file();
+			cleanup();
+			close(fd_map);
+			return -1;
 		}
 	}
 	close(fd_map);
 	if (rename(tmp_file, fname) < 0) {
 		perror(fname);
-		fail_file();
+		cleanup();
+		return -1;
 	}
+	return 0;
 }
 
 /* w8rev, w8nat, ...: Handle endianness. */
@@ -400,6 +408,8 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".cpuidle.text", txtname) == 0;
 }
 
+static char const *already_has_rel_mcount = "success"; /* our work here is done! */
+
 /* 32 bit and 64 bit are very similar */
 #include "recordmcount.h"
 #define RECORD_MCOUNT_64
@@ -438,11 +448,15 @@ static void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)
 	}).r_info;
 }
 
-static void
+static int
 do_file(char const *const fname)
 {
 	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
+	int rc = -1;
+
+	if (!ehdr)
+		goto out;
 
 	w = w4nat;
 	w2 = w2nat;
@@ -452,8 +466,8 @@ do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
 			ehdr->e_ident[EI_DATA], fname);
-		fail_file();
-		break;
+		cleanup();
+		goto out;
 	case ELFDATA2LSB:
 		if (*(unsigned char const *)&endian != 1) {
 			/* main() is big endian, file.o is little endian. */
@@ -485,7 +499,8 @@ do_file(char const *const fname)
 	||  w2(ehdr->e_type) != ET_REL
 	||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
 		fprintf(stderr, "unrecognized ET_REL file %s\n", fname);
-		fail_file();
+		cleanup();
+		goto out;
 	}
 
 	gpfx = 0;
@@ -493,8 +508,8 @@ do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized e_machine %u %s\n",
 			w2(ehdr->e_machine), fname);
-		fail_file();
-		break;
+		cleanup();
+		goto out;
 	case EM_386:
 		reltype = R_386_32;
 		rel_type_nop = R_386_NONE;
@@ -534,20 +549,22 @@ do_file(char const *const fname)
 	default:
 		fprintf(stderr, "unrecognized ELF class %d %s\n",
 			ehdr->e_ident[EI_CLASS], fname);
-		fail_file();
-		break;
+		cleanup();
+		goto out;
 	case ELFCLASS32:
 		if (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)
 		||  w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
-			fail_file();
+			cleanup();
+			goto out;
 		}
 		if (w2(ehdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_32;
 			is_fake_mcount32 = MIPS32_is_fake_mcount;
 		}
-		do32(ehdr, fname, reltype);
+		if (do32(ehdr, fname, reltype) < 0)
+			goto out;
 		break;
 	case ELFCLASS64: {
 		Elf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;
@@ -555,7 +572,8 @@ do_file(char const *const fname)
 		||  w2(ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
-			fail_file();
+			cleanup();
+			goto out;
 		}
 		if (w2(ghdr->e_machine) == EM_S390) {
 			reltype = R_390_64;
@@ -567,13 +585,16 @@ do_file(char const *const fname)
 			Elf64_r_info = MIPS64_r_info;
 			is_fake_mcount64 = MIPS64_is_fake_mcount;
 		}
-		do64(ghdr, fname, reltype);
+		if (do64(ghdr, fname, reltype) < 0)
+			goto out;
 		break;
 	}
 	}  /* end switch */
 
-	write_file(fname);
+	rc = write_file(fname);
+out:
 	cleanup();
+	return rc;
 }
 
 int
@@ -604,7 +625,6 @@ main(int argc, char *argv[])
 	/* Process each file in turn, allowing deep failure. */
 	for (i = optind; i < argc; i++) {
 		char *file = argv[i];
-		int const sjval = setjmp(jmpenv);
 		int len;
 
 		/*
@@ -617,28 +637,16 @@ main(int argc, char *argv[])
 		    strcmp(file + (len - ftrace_size), ftrace) == 0)
 			continue;
 
-		switch (sjval) {
-		default:
-			fprintf(stderr, "internal error: %s\n", file);
-			exit(1);
-			break;
-		case SJ_SETJMP:    /* normal sequence */
-			/* Avoid problems if early cleanup() */
-			fd_map = -1;
-			mmap_failed = 1;
-			file_map = NULL;
-			file_ptr = NULL;
-			file_updated = 0;
-			do_file(file);
-			break;
-		case SJ_FAIL:    /* error in do_file or below */
+		/* Avoid problems if early cleanup() */
+		fd_map = -1;
+		mmap_failed = 1;
+		file_map = NULL;
+		file_ptr = NULL;
+		file_updated = 0;
+		if (do_file(file)) {
 			fprintf(stderr, "%s: failed\n", file);
 			++n_error;
-			break;
-		case SJ_SUCCEED:    /* premature success */
-			/* do nothing */
-			break;
-		}  /* end switch */
+		}
 	}
 	return !!n_error;
 }

commit 17e262e9954bc3b6c857670f60b5b015f53509a7
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 24 14:04:57 2019 -0700

    recordmcount: Remove unused fd from uwrite() and ulseek()
    
    uwrite() works within the pseudo-mapping and extends it as necessary
    without needing the file descriptor (fd) parameter passed to it.
    Similarly, ulseek() doesn't need its fd parameter. These parameters
    were only added because the functions bear a conceptual resemblance
    to write() and lseek(). Worse, they obscure the fact that at the time
    uwrite() and ulseek() are called fd_map is not a valid file descriptor.
    
    Remove the unused file descriptor parameters that make it look like
    fd_map is still valid.
    
    Link: http://lkml.kernel.org/r/2a136e820ee208469d375265c7b8eb28570749a0.1563992889.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index c0dd46344063..1fe5fba99959 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -92,7 +92,7 @@ succeed_file(void)
 /* ulseek, uwrite, ...:  Check return value for errors. */
 
 static off_t
-ulseek(int const fd, off_t const offset, int const whence)
+ulseek(off_t const offset, int const whence)
 {
 	switch (whence) {
 	case SEEK_SET:
@@ -113,7 +113,7 @@ ulseek(int const fd, off_t const offset, int const whence)
 }
 
 static size_t
-uwrite(int const fd, void const *const buf, size_t const count)
+uwrite(void const *const buf, size_t const count)
 {
 	size_t cnt = count;
 	off_t idx = 0;
@@ -183,8 +183,8 @@ static int make_nop_x86(void *map, size_t const offset)
 		return -1;
 
 	/* convert to nop */
-	ulseek(fd_map, offset - 1, SEEK_SET);
-	uwrite(fd_map, ideal_nop, 5);
+	ulseek(offset - 1, SEEK_SET);
+	uwrite(ideal_nop, 5);
 	return 0;
 }
 
@@ -232,10 +232,10 @@ static int make_nop_arm(void *map, size_t const offset)
 		return -1;
 
 	/* Convert to nop */
-	ulseek(fd_map, off, SEEK_SET);
+	ulseek(off, SEEK_SET);
 
 	do {
-		uwrite(fd_map, ideal_nop, nop_size);
+		uwrite(ideal_nop, nop_size);
 	} while (--cnt > 0);
 
 	return 0;
@@ -252,8 +252,8 @@ static int make_nop_arm64(void *map, size_t const offset)
 		return -1;
 
 	/* Convert to nop */
-	ulseek(fd_map, offset, SEEK_SET);
-	uwrite(fd_map, ideal_nop, 4);
+	ulseek(offset, SEEK_SET);
+	uwrite(ideal_nop, 4);
 	return 0;
 }
 

commit a146207916092a49bd01ef861ac9582fd318c21a
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 24 14:04:56 2019 -0700

    recordmcount: Remove uread()
    
    uread() is only used to initialize the ELF file's pseudo
    private-memory mapping while uwrite() and ulseek() work within
    the pseudo-mapping and extend it as necessary.  Thus it is not
    a complementary function to uwrite() and ulseek(). It also makes
    no sense to do cleanups inside uread() when its only caller,
    mmap_file(), is doing the relevant allocations and associated
    initializations.
    
    Therefore it's clearer to use a plain read() call to initialize the
    data in mmap_file() and remove uread().
    
    Link: http://lkml.kernel.org/r/31a87c22b19150cec1c8dc800c8b0873a2741703.1563992889.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index ebe98c39f3cd..c0dd46344063 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -89,7 +89,7 @@ succeed_file(void)
 	longjmp(jmpenv, SJ_SUCCEED);
 }
 
-/* ulseek, uread, ...:  Check return value for errors. */
+/* ulseek, uwrite, ...:  Check return value for errors. */
 
 static off_t
 ulseek(int const fd, off_t const offset, int const whence)
@@ -112,17 +112,6 @@ ulseek(int const fd, off_t const offset, int const whence)
 	return file_ptr - file_map;
 }
 
-static size_t
-uread(int const fd, void *const buf, size_t const count)
-{
-	size_t const n = read(fd, buf, count);
-	if (n != count) {
-		perror("read");
-		fail_file();
-	}
-	return n;
-}
-
 static size_t
 uwrite(int const fd, void const *const buf, size_t const count)
 {
@@ -298,7 +287,10 @@ static void *mmap_file(char const *fname)
 	if (file_map == MAP_FAILED) {
 		mmap_failed = 1;
 		file_map = umalloc(sb.st_size);
-		uread(fd_map, file_map, sb.st_size);
+		if (read(fd_map, file_map, sb.st_size) != sb.st_size) {
+			perror(fname);
+			fail_file();
+		}
 	}
 	close(fd_map);
 

commit 1bd95be204aa3c9456e950d5ab36588dbdbb05f1
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Wed Jul 24 14:04:55 2019 -0700

    recordmcount: Remove redundant strcmp
    
    The strcmp is unnecessary since .text is already accepted as a
    prefix in the strncmp().
    
    Link: http://lkml.kernel.org/r/358e590b49adbe4185e161a8b364e323f3d52857.1563992889.git.mhelsley@vmware.com
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 8387a9bc064a..ebe98c39f3cd 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -405,8 +405,7 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".irqentry.text", txtname) == 0 ||
 		strcmp(".softirqentry.text", txtname) == 0 ||
 		strcmp(".kprobes.text", txtname) == 0 ||
-		strcmp(".cpuidle.text", txtname) == 0 ||
-		strcmp(".text.unlikely", txtname) == 0;
+		strcmp(".cpuidle.text", txtname) == 0;
 }
 
 /* 32 bit and 64 bit are very similar */

commit 4317cf95ca02411cf788d10c1972a38582e8c34d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:38 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 378
    
    Based on 1 normalized pattern(s):
    
      licensed under the gnu general public license version 2 gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 5 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.993848054@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index a50a2aa963ad..8387a9bc064a 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * recordmcount.c: construct a table of the locations of calls to 'mcount'
  * so that ftrace can find them quickly.
  * Copyright 2009 John F. Reiser <jreiser@BitWagon.com>.  All rights reserved.
- * Licensed under the GNU General Public License, version 2 (GPLv2).
  *
  * Restructured to fit Linux format, as well as other updates:
  *  Copyright 2010 Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.

commit 9c8e2f6d3d361439cc6744a094f1c15681b55269
Author: Joe Lawrence <joe.lawrence@redhat.com>
Date:   Tue Nov 20 15:19:18 2018 -0500

    scripts/recordmcount.{c,pl}: support -ffunction-sections .text.* section names
    
    When building with -ffunction-sections, the compiler will place each
    function into its own ELF section, prefixed with ".text".  For example,
    a simple test module with functions test_module_do_work() and
    test_module_wq_func():
    
      % objdump --section-headers test_module.o | awk '/\.text/{print $2}'
      .text
      .text.test_module_do_work
      .text.test_module_wq_func
      .init.text
      .exit.text
    
    Adjust the recordmcount scripts to look for ".text" as a section name
    prefix.  This will ensure that those functions will be included in the
    __mcount_loc relocations:
    
      % objdump --reloc --section __mcount_loc test_module.o
      OFFSET           TYPE              VALUE
      0000000000000000 R_X86_64_64       .text.test_module_do_work
      0000000000000008 R_X86_64_64       .text.test_module_wq_func
      0000000000000010 R_X86_64_64       .init.text
    
    Link: http://lkml.kernel.org/r/1542745158-25392-2-git-send-email-joe.lawrence@redhat.com
    
    Signed-off-by: Joe Lawrence <joe.lawrence@redhat.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 895c40e8679f..a50a2aa963ad 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -397,7 +397,7 @@ static uint32_t (*w2)(uint16_t);
 static int
 is_mcounted_section_name(char const *const txtname)
 {
-	return strcmp(".text",           txtname) == 0 ||
+	return strncmp(".text",          txtname, 5) == 0 ||
 		strcmp(".init.text",     txtname) == 0 ||
 		strcmp(".ref.text",      txtname) == 0 ||
 		strcmp(".sched.text",    txtname) == 0 ||

commit ac5db1fc89bf84d7479761e0de855e6376fdab1e
Author: nixiaoming <nixiaoming@huawei.com>
Date:   Thu May 24 11:16:12 2018 +0800

    scripts: Fixed printf format mismatch
    
    scripts/kallsyms.c: function write_src:
    "printf", the #1 format specifier "d" need arg type "int",
    but the according arg "table_cnt" has type "unsigned int"
    
    scripts/recordmcount.c: function do_file:
    "fprintf", the #1 format specifier "d" need arg type "int",
    but the according arg "(*w2)(ehdr->e_machine)" has type "unsigned int"
    
    scripts/recordmcount.h: function find_secsym_ndx:
    "fprintf", the #1 format specifier "d" need arg type "int",
    but the according arg "txtndx" has type "unsigned int"
    
    Signed-off-by: nixiaoming <nixiaoming@huawei.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 8c9691c3329e..895c40e8679f 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -500,7 +500,7 @@ do_file(char const *const fname)
 	gpfx = 0;
 	switch (w2(ehdr->e_machine)) {
 	default:
-		fprintf(stderr, "unrecognized e_machine %d %s\n",
+		fprintf(stderr, "unrecognized e_machine %u %s\n",
 			w2(ehdr->e_machine), fname);
 		fail_file();
 		break;

commit 5f171577b4f35b44795a73bde8cf2c49b4073925
Author: James Hogan <jhogan@kernel.org>
Date:   Tue Oct 24 16:52:32 2017 +0100

    Drop a bunch of metag references
    
    Now that arch/metag/ has been removed, drop a bunch of metag references
    in various codes across the whole tree:
     - VM_GROWSUP and __VM_ARCH_SPECIFIC_1.
     - MT_METAG_* ELF note types.
     - METAG Kconfig dependencies (FRAME_POINTER) and ranges
       (MAX_STACK_SIZE_MB).
     - metag cases in tools (checkstack.pl, recordmcount.c, perf).
    
    Signed-off-by: James Hogan <jhogan@kernel.org>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: linux-mm@kvack.org
    Cc: linux-metag@vger.kernel.org

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 16e086dcc567..8c9691c3329e 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -33,20 +33,6 @@
 #include <string.h>
 #include <unistd.h>
 
-/*
- * glibc synced up and added the metag number but didn't add the relocations.
- * Work around this in a crude manner for now.
- */
-#ifndef EM_METAG
-#define EM_METAG      174
-#endif
-#ifndef R_METAG_ADDR32
-#define R_METAG_ADDR32                   2
-#endif
-#ifndef R_METAG_NONE
-#define R_METAG_NONE                     3
-#endif
-
 #ifndef EM_AARCH64
 #define EM_AARCH64	183
 #define R_AARCH64_NONE		0
@@ -538,12 +524,6 @@ do_file(char const *const fname)
 			gpfx = '_';
 			break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
-	case EM_METAG:	 reltype = R_METAG_ADDR32;
-			 altmcount = "_mcount_wrapper";
-			 rel_type_nop = R_METAG_NONE;
-			 /* We happen to have the same requirement as MIPS */
-			 is_fake_mcount32 = MIPS32_is_fake_mcount;
-			 break;
 	case EM_MIPS:	 /* reltype: e_class    */ gpfx = '_'; break;
 	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;
 	case EM_PPC64:	 reltype = R_PPC64_ADDR64; gpfx = '_'; break;

commit 42c269c88dc146982a54a8267f71abc99f12852a
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Fri Mar 3 16:15:39 2017 -0500

    ftrace: Allow for function tracing to record init functions on boot up
    
    Adding a hook into free_reserve_area() that informs ftrace that boot up init
    text is being free, lets ftrace safely remove those init functions from its
    records, which keeps ftrace from trying to modify text that no longer
    exists.
    
    Note, this still does not allow for tracing .init text of modules, as
    modules require different work for freeing its init code.
    
    Link: http://lkml.kernel.org/r/1488502497.7212.24.camel@linux.intel.com
    
    Cc: linux-mm@kvack.org
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Requested-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index aeb34223167c..16e086dcc567 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -412,6 +412,7 @@ static int
 is_mcounted_section_name(char const *const txtname)
 {
 	return strcmp(".text",           txtname) == 0 ||
+		strcmp(".init.text",     txtname) == 0 ||
 		strcmp(".ref.text",      txtname) == 0 ||
 		strcmp(".sched.text",    txtname) == 0 ||
 		strcmp(".spinlock.text", txtname) == 0 ||

commit 9648dc15772d77b5431cd5c11675d90eee1a4c2f
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Oct 18 16:42:00 2016 -0700

    recordmcount: arm: Implement make_nop
    
    In similar spirit to x86 and arm64 support, add a make_nop_arm()
    to replace calls to mcount with a nop in sections that aren't
    traced.
    
    Link: http://lkml.kernel.org/r/20161018234200.5804-1-sboyd@codeaurora.org
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 5423a58d1b06..aeb34223167c 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -213,6 +213,59 @@ static int make_nop_x86(void *map, size_t const offset)
 	return 0;
 }
 
+static unsigned char ideal_nop4_arm_le[4] = { 0x00, 0x00, 0xa0, 0xe1 }; /* mov r0, r0 */
+static unsigned char ideal_nop4_arm_be[4] = { 0xe1, 0xa0, 0x00, 0x00 }; /* mov r0, r0 */
+static unsigned char *ideal_nop4_arm;
+
+static unsigned char bl_mcount_arm_le[4] = { 0xfe, 0xff, 0xff, 0xeb }; /* bl */
+static unsigned char bl_mcount_arm_be[4] = { 0xeb, 0xff, 0xff, 0xfe }; /* bl */
+static unsigned char *bl_mcount_arm;
+
+static unsigned char push_arm_le[4] = { 0x04, 0xe0, 0x2d, 0xe5 }; /* push {lr} */
+static unsigned char push_arm_be[4] = { 0xe5, 0x2d, 0xe0, 0x04 }; /* push {lr} */
+static unsigned char *push_arm;
+
+static unsigned char ideal_nop2_thumb_le[2] = { 0x00, 0xbf }; /* nop */
+static unsigned char ideal_nop2_thumb_be[2] = { 0xbf, 0x00 }; /* nop */
+static unsigned char *ideal_nop2_thumb;
+
+static unsigned char push_bl_mcount_thumb_le[6] = { 0x00, 0xb5, 0xff, 0xf7, 0xfe, 0xff }; /* push {lr}, bl */
+static unsigned char push_bl_mcount_thumb_be[6] = { 0xb5, 0x00, 0xf7, 0xff, 0xff, 0xfe }; /* push {lr}, bl */
+static unsigned char *push_bl_mcount_thumb;
+
+static int make_nop_arm(void *map, size_t const offset)
+{
+	char *ptr;
+	int cnt = 1;
+	int nop_size;
+	size_t off = offset;
+
+	ptr = map + offset;
+	if (memcmp(ptr, bl_mcount_arm, 4) == 0) {
+		if (memcmp(ptr - 4, push_arm, 4) == 0) {
+			off -= 4;
+			cnt = 2;
+		}
+		ideal_nop = ideal_nop4_arm;
+		nop_size = 4;
+	} else if (memcmp(ptr - 2, push_bl_mcount_thumb, 6) == 0) {
+		cnt = 3;
+		nop_size = 2;
+		off -= 2;
+		ideal_nop = ideal_nop2_thumb;
+	} else
+		return -1;
+
+	/* Convert to nop */
+	ulseek(fd_map, off, SEEK_SET);
+
+	do {
+		uwrite(fd_map, ideal_nop, nop_size);
+	} while (--cnt > 0);
+
+	return 0;
+}
+
 static unsigned char ideal_nop4_arm64[4] = {0x1f, 0x20, 0x03, 0xd5};
 static int make_nop_arm64(void *map, size_t const offset)
 {
@@ -430,6 +483,11 @@ do_file(char const *const fname)
 			w2 = w2rev;
 			w8 = w8rev;
 		}
+		ideal_nop4_arm = ideal_nop4_arm_le;
+		bl_mcount_arm = bl_mcount_arm_le;
+		push_arm = push_arm_le;
+		ideal_nop2_thumb = ideal_nop2_thumb_le;
+		push_bl_mcount_thumb = push_bl_mcount_thumb_le;
 		break;
 	case ELFDATA2MSB:
 		if (*(unsigned char const *)&endian != 0) {
@@ -438,6 +496,11 @@ do_file(char const *const fname)
 			w2 = w2rev;
 			w8 = w8rev;
 		}
+		ideal_nop4_arm = ideal_nop4_arm_be;
+		bl_mcount_arm = bl_mcount_arm_be;
+		push_arm = push_arm_be;
+		ideal_nop2_thumb = ideal_nop2_thumb_be;
+		push_bl_mcount_thumb = push_bl_mcount_thumb_be;
 		break;
 	}  /* end switch */
 	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
@@ -463,6 +526,8 @@ do_file(char const *const fname)
 		break;
 	case EM_ARM:	 reltype = R_ARM_ABS32;
 			 altmcount = "__gnu_mcount_nc";
+			 make_nop = make_nop_arm;
+			 rel_type_nop = R_ARM_NONE;
 			 break;
 	case EM_AARCH64:
 			reltype = R_AARCH64_ABS64;

commit 6727ad9e206cc08b80d8000a4d67f8417e53539d
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Fri Oct 7 17:02:55 2016 -0700

    nmi_backtrace: generate one-line reports for idle cpus
    
    When doing an nmi backtrace of many cores, most of which are idle, the
    output is a little overwhelming and very uninformative.  Suppress
    messages for cpus that are idling when they are interrupted and just
    emit one line, "NMI backtrace for N skipped: idling at pc 0xNNN".
    
    We do this by grouping all the cpuidle code together into a new
    .cpuidle.text section, and then checking the address of the interrupted
    PC to see if it lies within that section.
    
    This commit suitably tags x86 and tile idle routines, and only adds in
    the minimal framework for other architectures.
    
    Link: http://lkml.kernel.org/r/1472487169-14923-5-git-send-email-cmetcalf@mellanox.com
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Tested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org> [arm]
    Tested-by: Petr Mladek <pmladek@suse.com>
    Cc: Aaron Tomlin <atomlin@redhat.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index a68f03133df9..5423a58d1b06 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -365,6 +365,7 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".irqentry.text", txtname) == 0 ||
 		strcmp(".softirqentry.text", txtname) == 0 ||
 		strcmp(".kprobes.text", txtname) == 0 ||
+		strcmp(".cpuidle.text", txtname) == 0 ||
 		strcmp(".text.unlikely", txtname) == 0;
 }
 

commit e436fd61a8f62cb7a16310a42b95ab076ff72eff
Author: Dmitry Vyukov <dvyukov@google.com>
Date:   Wed Sep 28 15:22:36 2016 -0700

    scripts/recordmcount.c: account for .softirqentry.text
    
    be7635e7287e ("arch, ftrace: for KASAN put hard/soft IRQ entries into
    separate sections") added .softirqentry.text section, but it was not added
    to recordmcount.  So functions in the section are untracable.  Add the
    section to scripts/recordmcount.c and scripts/recordmcount.pl.
    
    Fixes: be7635e7287e ("arch, ftrace: for KASAN put hard/soft IRQ entries into separate sections")
    Link: http://lkml.kernel.org/r/1474902626-73468-1-git-send-email-dvyukov@google.com
    Signed-off-by: Dmitry Vyukov <dvyukov@google.com>
    Acked-by: Steve Rostedt <rostedt@goodmis.org>
    Cc: <stable@vger.kernel.org>    [4.6+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 42396a74405d..a68f03133df9 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -363,6 +363,7 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".sched.text",    txtname) == 0 ||
 		strcmp(".spinlock.text", txtname) == 0 ||
 		strcmp(".irqentry.text", txtname) == 0 ||
+		strcmp(".softirqentry.text", txtname) == 0 ||
 		strcmp(".kprobes.text", txtname) == 0 ||
 		strcmp(".text.unlikely", txtname) == 0;
 }

commit b2e1c26f0b62531636509fbcb6dab65617ed8331
Author: Laura Abbott <labbott@redhat.com>
Date:   Fri Jul 8 12:18:50 2016 -0700

    ftrace/recordmcount: Work around for addition of metag magic but not relocations
    
    glibc recently did a sync up (94e73c95d9b5 "elf.h: Sync with the gabi
    webpage") that added a #define for EM_METAG but did not add relocations
    
    This triggers build errors:
    
    scripts/recordmcount.c: In function 'do_file':
    scripts/recordmcount.c:466:28: error: 'R_METAG_ADDR32' undeclared (first use in this function)
      case EM_METAG:  reltype = R_METAG_ADDR32;
                                ^~~~~~~~~~~~~~
    scripts/recordmcount.c:466:28: note: each undeclared identifier is reported only once for each function it appears in
    scripts/recordmcount.c:468:20: error: 'R_METAG_NONE' undeclared (first use in this function)
         rel_type_nop = R_METAG_NONE;
                        ^~~~~~~~~~~~
    
    Work around this change with some more #ifdefery for the relocations.
    
    Fedora Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1354034
    
    Link: http://lkml.kernel.org/r/1468005530-14757-1-git-send-email-labbott@redhat.com
    
    Cc: stable@vger.kernel.org # v3.9+
    Cc: James Hogan <james.hogan@imgtec.com>
    Fixes: 00512bdd4573 ("metag: ftrace support")
    Reported-by: Ross Burton <ross.burton@intel.com>
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index e167592793a7..42396a74405d 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -33,10 +33,17 @@
 #include <string.h>
 #include <unistd.h>
 
+/*
+ * glibc synced up and added the metag number but didn't add the relocations.
+ * Work around this in a crude manner for now.
+ */
 #ifndef EM_METAG
-/* Remove this when these make it to the standard system elf.h. */
 #define EM_METAG      174
+#endif
+#ifndef R_METAG_ADDR32
 #define R_METAG_ADDR32                   2
+#endif
+#ifndef R_METAG_NONE
 #define R_METAG_NONE                     3
 #endif
 

commit 713a3e4de707fab49d5aa4bceb77db1058572a7b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Dec 30 23:06:41 2015 +0000

    ftrace/scripts: Fix incorrect use of sprintf in recordmcount
    
    Fix build warning:
    
    scripts/recordmcount.c:589:4: warning: format not a string
    literal and no format arguments [-Wformat-security]
        sprintf("%s: failed\n", file);
    
    Fixes: a50bd43935586 ("ftrace/scripts: Have recordmcount copy the object file")
    Link: http://lkml.kernel.org/r/1451516801-16951-1-git-send-email-colin.king@canonical.com
    
    Cc: Li Bin <huawei.libin@huawei.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: stable@vger.kernel.org # 2.6.37+
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 301d70b0174f..e167592793a7 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -586,7 +586,7 @@ main(int argc, char *argv[])
 			do_file(file);
 			break;
 		case SJ_FAIL:    /* error in do_file or below */
-			sprintf("%s: failed\n", file);
+			fprintf(stderr, "%s: failed\n", file);
 			++n_error;
 			break;
 		case SJ_SUCCEED:    /* premature success */

commit a50bd43935586420fb75f4558369eb08566fac5e
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Tue Dec 15 16:06:10 2015 -0500

    ftrace/scripts: Have recordmcount copy the object file
    
    Russell King found that he had weird side effects when compiling the kernel
    with hard linked ccache. The reason was that recordmcount modified the
    kernel in place via mmap, and when a file gets modified twice by
    recordmcount, it will complain about it. To fix this issue, Russell wrote a
    patch that checked if the file was hard linked more than once and would
    unlink it if it was.
    
    Linus Torvalds was not happy with the fact that recordmcount does this in
    place modification. Instead of doing the unlink only if the file has two or
    more hard links, it does the unlink all the time. In otherwords, it always
    does a copy if it changed something. That is, it does the write out if a
    change was made.
    
    Cc: stable@vger.kernel.org # 2.6.37+
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 91705ef30402..301d70b0174f 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -48,12 +48,17 @@
 
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
-static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
 static char gpfx;	/* prefix for global symbol name (sometimes '_') */
 static struct stat sb;	/* Remember .st_size, etc. */
 static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
 static const char *altmcount;	/* alternate mcount symbol name */
 static int warn_on_notrace_sect; /* warn when section has mcount not being recorded */
+static void *file_map;	/* pointer of the mapped file */
+static void *file_end;	/* pointer to the end of the mapped file */
+static int file_updated; /* flag to state file was changed */
+static void *file_ptr;	/* current file pointer location */
+static void *file_append; /* added to the end of the file */
+static size_t file_append_size; /* how much is added to end of file */
 
 /* setjmp() return values */
 enum {
@@ -67,10 +72,14 @@ static void
 cleanup(void)
 {
 	if (!mmap_failed)
-		munmap(ehdr_curr, sb.st_size);
+		munmap(file_map, sb.st_size);
 	else
-		free(ehdr_curr);
-	close(fd_map);
+		free(file_map);
+	file_map = NULL;
+	free(file_append);
+	file_append = NULL;
+	file_append_size = 0;
+	file_updated = 0;
 }
 
 static void __attribute__((noreturn))
@@ -92,12 +101,22 @@ succeed_file(void)
 static off_t
 ulseek(int const fd, off_t const offset, int const whence)
 {
-	off_t const w = lseek(fd, offset, whence);
-	if (w == (off_t)-1) {
-		perror("lseek");
+	switch (whence) {
+	case SEEK_SET:
+		file_ptr = file_map + offset;
+		break;
+	case SEEK_CUR:
+		file_ptr += offset;
+		break;
+	case SEEK_END:
+		file_ptr = file_map + (sb.st_size - offset);
+		break;
+	}
+	if (file_ptr < file_map) {
+		fprintf(stderr, "lseek: seek before file\n");
 		fail_file();
 	}
-	return w;
+	return file_ptr - file_map;
 }
 
 static size_t
@@ -114,12 +133,38 @@ uread(int const fd, void *const buf, size_t const count)
 static size_t
 uwrite(int const fd, void const *const buf, size_t const count)
 {
-	size_t const n = write(fd, buf, count);
-	if (n != count) {
-		perror("write");
-		fail_file();
+	size_t cnt = count;
+	off_t idx = 0;
+
+	file_updated = 1;
+
+	if (file_ptr + count >= file_end) {
+		off_t aoffset = (file_ptr + count) - file_end;
+
+		if (aoffset > file_append_size) {
+			file_append = realloc(file_append, aoffset);
+			file_append_size = aoffset;
+		}
+		if (!file_append) {
+			perror("write");
+			fail_file();
+		}
+		if (file_ptr < file_end) {
+			cnt = file_end - file_ptr;
+		} else {
+			cnt = 0;
+			idx = aoffset - count;
+		}
 	}
-	return n;
+
+	if (cnt)
+		memcpy(file_ptr, buf, cnt);
+
+	if (cnt < count)
+		memcpy(file_append + idx, buf + cnt, count - cnt);
+
+	file_ptr += count;
+	return count;
 }
 
 static void *
@@ -192,9 +237,7 @@ static int make_nop_arm64(void *map, size_t const offset)
  */
 static void *mmap_file(char const *fname)
 {
-	void *addr;
-
-	fd_map = open(fname, O_RDWR);
+	fd_map = open(fname, O_RDONLY);
 	if (fd_map < 0 || fstat(fd_map, &sb) < 0) {
 		perror(fname);
 		fail_file();
@@ -203,29 +246,58 @@ static void *mmap_file(char const *fname)
 		fprintf(stderr, "not a regular file: %s\n", fname);
 		fail_file();
 	}
-	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
-		    fd_map, 0);
+	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
+			fd_map, 0);
 	mmap_failed = 0;
-	if (addr == MAP_FAILED) {
+	if (file_map == MAP_FAILED) {
 		mmap_failed = 1;
-		addr = umalloc(sb.st_size);
-		uread(fd_map, addr, sb.st_size);
+		file_map = umalloc(sb.st_size);
+		uread(fd_map, file_map, sb.st_size);
 	}
-	if (sb.st_nlink != 1) {
-		/* file is hard-linked, break the hard link */
-		close(fd_map);
-		if (unlink(fname) < 0) {
-			perror(fname);
-			fail_file();
-		}
-		fd_map = open(fname, O_RDWR | O_CREAT, sb.st_mode);
-		if (fd_map < 0) {
-			perror(fname);
+	close(fd_map);
+
+	file_end = file_map + sb.st_size;
+
+	return file_map;
+}
+
+static void write_file(const char *fname)
+{
+	char tmp_file[strlen(fname) + 4];
+	size_t n;
+
+	if (!file_updated)
+		return;
+
+	sprintf(tmp_file, "%s.rc", fname);
+
+	/*
+	 * After reading the entire file into memory, delete it
+	 * and write it back, to prevent weird side effects of modifying
+	 * an object file in place.
+	 */
+	fd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);
+	if (fd_map < 0) {
+		perror(fname);
+		fail_file();
+	}
+	n = write(fd_map, file_map, sb.st_size);
+	if (n != sb.st_size) {
+		perror("write");
+		fail_file();
+	}
+	if (file_append_size) {
+		n = write(fd_map, file_append, file_append_size);
+		if (n != file_append_size) {
+			perror("write");
 			fail_file();
 		}
-		uwrite(fd_map, addr, sb.st_size);
 	}
-	return addr;
+	close(fd_map);
+	if (rename(tmp_file, fname) < 0) {
+		perror(fname);
+		fail_file();
+	}
 }
 
 /* w8rev, w8nat, ...: Handle endianness. */
@@ -332,7 +404,6 @@ do_file(char const *const fname)
 	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
 
-	ehdr_curr = ehdr;
 	w = w4nat;
 	w2 = w2nat;
 	w8 = w8nat;
@@ -455,6 +526,7 @@ do_file(char const *const fname)
 	}
 	}  /* end switch */
 
+	write_file(fname);
 	cleanup();
 }
 
@@ -507,11 +579,14 @@ main(int argc, char *argv[])
 		case SJ_SETJMP:    /* normal sequence */
 			/* Avoid problems if early cleanup() */
 			fd_map = -1;
-			ehdr_curr = NULL;
 			mmap_failed = 1;
+			file_map = NULL;
+			file_ptr = NULL;
+			file_updated = 0;
 			do_file(file);
 			break;
 		case SJ_FAIL:    /* error in do_file or below */
+			sprintf("%s: failed\n", file);
 			++n_error;
 			break;
 		case SJ_SUCCEED:    /* premature success */

commit dd39a26538e37f6c6131e829a4a510787e43c783
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 11 12:09:03 2015 +0000

    scripts: recordmcount: break hardlinks
    
    recordmcount edits the file in-place, which can cause problems when
    using ccache in hardlink mode.  Arrange for recordmcount to break a
    hardlinked object.
    
    Link: http://lkml.kernel.org/r/E1a7MVT-0000et-62@rmk-PC.arm.linux.org.uk
    
    Cc: stable@vger.kernel.org # 2.6.37+
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 698768bdc581..91705ef30402 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -211,6 +211,20 @@ static void *mmap_file(char const *fname)
 		addr = umalloc(sb.st_size);
 		uread(fd_map, addr, sb.st_size);
 	}
+	if (sb.st_nlink != 1) {
+		/* file is hard-linked, break the hard link */
+		close(fd_map);
+		if (unlink(fname) < 0) {
+			perror(fname);
+			fail_file();
+		}
+		fd_map = open(fname, O_RDWR | O_CREAT, sb.st_mode);
+		if (fd_map < 0) {
+			perror(fname);
+			fail_file();
+		}
+		uwrite(fd_map, addr, sb.st_size);
+	}
 	return addr;
 }
 

commit 2ee8a74f2a5da913637f75a19a0da0e7a08c0f86
Author: Li Bin <huawei.libin@huawei.com>
Date:   Fri Oct 30 16:31:04 2015 +0800

    recordmcount: arm64: Replace the ignored mcount call into nop
    
    By now, the recordmcount only records the function that in
    following sections:
    .text/.ref.text/.sched.text/.spinlock.text/.irqentry.text/
    .kprobes.text/.text.unlikely
    
    For the function that not in these sections, the call mcount
    will be in place and not be replaced when kernel boot up. And
    it will bring performance overhead, such as do_mem_abort (in
    .exception.text section). This patch make the call mcount to
    nop for this case in recordmcount.
    
    Link: http://lkml.kernel.org/r/1446019445-14421-1-git-send-email-huawei.libin@huawei.com
    Link: http://lkml.kernel.org/r/1446193864-24593-4-git-send-email-huawei.libin@huawei.com
    
    Cc: <lkp@intel.com>
    Cc: <catalin.marinas@arm.com>
    Cc: <takahiro.akashi@linaro.org>
    Cc: <stable@vger.kernel.org> # 3.18+
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Li Bin <huawei.libin@huawei.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 8cc020bbe859..698768bdc581 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -42,6 +42,7 @@
 
 #ifndef EM_AARCH64
 #define EM_AARCH64	183
+#define R_AARCH64_NONE		0
 #define R_AARCH64_ABS64	257
 #endif
 
@@ -160,6 +161,22 @@ static int make_nop_x86(void *map, size_t const offset)
 	return 0;
 }
 
+static unsigned char ideal_nop4_arm64[4] = {0x1f, 0x20, 0x03, 0xd5};
+static int make_nop_arm64(void *map, size_t const offset)
+{
+	uint32_t *ptr;
+
+	ptr = map + offset;
+	/* bl <_mcount> is 0x94000000 before relocation */
+	if (*ptr != 0x94000000)
+		return -1;
+
+	/* Convert to nop */
+	ulseek(fd_map, offset, SEEK_SET);
+	uwrite(fd_map, ideal_nop, 4);
+	return 0;
+}
+
 /*
  * Get the whole file as a programming convenience in order to avoid
  * malloc+lseek+read+free of many pieces.  If successful, then mmap
@@ -354,7 +371,12 @@ do_file(char const *const fname)
 			 altmcount = "__gnu_mcount_nc";
 			 break;
 	case EM_AARCH64:
-			 reltype = R_AARCH64_ABS64; gpfx = '_'; break;
+			reltype = R_AARCH64_ABS64;
+			make_nop = make_nop_arm64;
+			rel_type_nop = R_AARCH64_NONE;
+			ideal_nop = ideal_nop4_arm64;
+			gpfx = '_';
+			break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
 	case EM_METAG:	 reltype = R_METAG_ADDR32;
 			 altmcount = "_mcount_wrapper";

commit 46a2b61ecb286dddb4efa73b119fec54e1576efe
Author: Li Bin <huawei.libin@huawei.com>
Date:   Wed Oct 28 16:23:26 2015 +0800

    recordmcount: x86: Assign a meaningful value to rel_type_nop
    
    Although, the default value of rel_type_nop is zero, and the value
    of R_386_NONE/R_X86_64_NONE is zero too, but it should be assigned
    a meaningful value explicitly, otherwise it looks confused.
    
    Assign R_386_NONE to rel_type_nop for 386, assign R_X86_64_NONE
    to rel_type_nop for x86_64.
    
    Link: http://lkml.kernel.org/r/1446020606-16352-1-git-send-email-huawei.libin@huawei.com
    
    Signed-off-by: Li Bin <huawei.libin@huawei.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 3d1984e59a30..8cc020bbe859 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -345,6 +345,7 @@ do_file(char const *const fname)
 		break;
 	case EM_386:
 		reltype = R_386_32;
+		rel_type_nop = R_386_NONE;
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_32;
 		mcount_adjust_32 = -1;
@@ -371,6 +372,7 @@ do_file(char const *const fname)
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_64;
 		reltype = R_X86_64_64;
+		rel_type_nop = R_X86_64_NONE;
 		mcount_adjust_64 = -1;
 		break;
 	}  /* end switch */

commit c933146a5e41e42ea3eb4f34fa02e201da3f068e
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Oct 15 12:17:38 2014 +0200

    s390/ftrace,kprobes: allow to patch first instruction
    
    If the function tracer is enabled, allow to set kprobes on the first
    instruction of a function (which is the function trace caller):
    
    If no kprobe is set handling of enabling and disabling function tracing
    of a function simply patches the first instruction. Either it is a nop
    (right now it's an unconditional branch, which skips the mcount block),
    or it's a branch to the ftrace_caller() function.
    
    If a kprobe is being placed on a function tracer calling instruction
    we encode if we actually have a nop or branch in the remaining bytes
    after the breakpoint instruction (illegal opcode).
    This is possible, since the size of the instruction used for the nop
    and branch is six bytes, while the size of the breakpoint is only
    two bytes.
    Therefore the first two bytes contain the illegal opcode and the last
    four bytes contain either "0" for nop or "1" for branch. The kprobes
    code will then execute/simulate the correct instruction.
    
    Instruction patching for kprobes and function tracer is always done
    with stop_machine(). Therefore we don't have any races where an
    instruction is patched concurrently on a different cpu.
    Besides that also the program check handler which executes the function
    trace caller instruction won't be executed concurrently to any
    stop_machine() execution.
    
    This allows to keep full fault based kprobes handling which generates
    correct pt_regs contents automatically.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 001facfa5b74..3d1984e59a30 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -404,7 +404,7 @@ do_file(char const *const fname)
 		}
 		if (w2(ghdr->e_machine) == EM_S390) {
 			reltype = R_390_64;
-			mcount_adjust_64 = -8;
+			mcount_adjust_64 = -14;
 		}
 		if (w2(ghdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_64;

commit 53255c9a4dade6ff2162121430d13aaadb38a69c
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Tue Oct 7 15:45:10 2014 +0200

    s390/ftrace: remove 31 bit ftrace support
    
    31 bit and 64 bit diverge more and more and it is rather painful
    to keep both parts running.
    To make things simpler just remove the 31 bit support which nobody
    uses anyway.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 650ecc83d7d7..001facfa5b74 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -388,10 +388,6 @@ do_file(char const *const fname)
 				"unrecognized ET_REL file: %s\n", fname);
 			fail_file();
 		}
-		if (w2(ehdr->e_machine) == EM_S390) {
-			reltype = R_390_32;
-			mcount_adjust_32 = -4;
-		}
 		if (w2(ehdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_32;
 			is_fake_mcount32 = MIPS32_is_fake_mcount;

commit c1fdb2d3389c5a1e7c559a37a4967c1d2580e75c
Merge: 1700ff823b27 7fa0e6db3ced
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 21:29:20 2014 -0700

    Merge branch 'misc' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild misc updates from Michal Marek:
     "This is the non-critical part of kbuild for v3.16-rc1:
       - make deb-pkg can do s390x and arm64
       - new patterns in scripts/tags.sh
       - scripts/tags.sh skips userspace tools' sources (which sometimes
         have copies of kernel structures) and symlinks
       - improvements to the objdiff tool
       - two new coccinelle patches
       - other minor fixes"
    
    * 'misc' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      scripts: objdiff: support directories for the augument of record command
      scripts: objdiff: fix a comment
      scripts: objdiff: change the extension of disassembly from .o to .dis
      scripts: objdiff: improve path flexibility for record command
      scripts: objdiff: remove unnecessary code
      scripts: objdiff: direct error messages to stderr
      scripts: objdiff: get the path to .tmp_objdiff more simply
      deb-pkg: Add automatic support for s390x architecture
      coccicheck: Add unneeded return variable test
      kbuild: Fix a typo in documentation
      kbuild: trivial - use tabs for code indent where possible
      kbuild: trivial - remove trailing empty lines
      coccinelle: Check for missing NULL terminators in of_device_id tables
      scripts/tags.sh: ignore symlink'ed source files
      scripts/tags.sh: add regular expression replacement pattern for memcg
      builddeb: add arm64 in the supported architectures
      builddeb: use $OBJCOPY variable instead of objcopy
      scripts/tags.sh: ignore code of user space tools
      scripts/tags.sh: add pattern for DEFINE_HASHTABLE
      .gitignore: ignore Module.symvers in all directories

commit 7eb6e340526adf14ed7cf7dfde8b9c6fc0741cfc
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Thu May 29 14:12:29 2014 +0900

    kbuild: trivial - remove trailing empty lines
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 9c22317778eb..c0853063fcbc 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -480,5 +480,3 @@ main(int argc, char *argv[])
 	}
 	return !!n_error;
 }
-
-

commit af64d2aa872a174772ffc00e2558083f70193acb
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Wed Apr 30 10:54:32 2014 +0100

    ftrace: Add arm64 support to recordmcount
    
    Recordmcount utility under scripts is run, after compiling each object,
    to find out all the locations of calling _mcount() and put them into
    specific seciton named __mcount_loc.
    Then linker collects all such information into a table in the kernel image
    (between __start_mcount_loc and __stop_mcount_loc) for later use by ftrace.
    
    This patch adds arm64 specific definitions to identify such locations.
    There are two types of implementation, C and Perl. On arm64, only C version
    is used to build the kernel now that CONFIG_HAVE_C_RECORDMCOUNT is on.
    But Perl version is also maintained.
    
    This patch also contains a workaround just in case where a header file,
    elf.h, on host machine doesn't have definitions of EM_AARCH64 nor
    R_AARCH64_ABS64. Without them, compiling C version of recordmcount will
    fail.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 9c22317778eb..e11aa4a156d2 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -40,6 +40,11 @@
 #define R_METAG_NONE                     3
 #endif
 
+#ifndef EM_AARCH64
+#define EM_AARCH64	183
+#define R_AARCH64_ABS64	257
+#endif
+
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
 static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
@@ -347,6 +352,8 @@ do_file(char const *const fname)
 	case EM_ARM:	 reltype = R_ARM_ABS32;
 			 altmcount = "__gnu_mcount_nc";
 			 break;
+	case EM_AARCH64:
+			 reltype = R_AARCH64_ABS64; gpfx = '_'; break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
 	case EM_METAG:	 reltype = R_METAG_ADDR32;
 			 altmcount = "_mcount_wrapper";

commit 00512bdd4573674d10af1c1d60328b4b0f9dcafd
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Oct 5 16:27:31 2012 +0100

    metag: ftrace support
    
    Add ftrace support for metag.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index ee52cb8e17ad..9c22317778eb 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -33,6 +33,13 @@
 #include <string.h>
 #include <unistd.h>
 
+#ifndef EM_METAG
+/* Remove this when these make it to the standard system elf.h. */
+#define EM_METAG      174
+#define R_METAG_ADDR32                   2
+#define R_METAG_NONE                     3
+#endif
+
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
 static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
@@ -341,6 +348,12 @@ do_file(char const *const fname)
 			 altmcount = "__gnu_mcount_nc";
 			 break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
+	case EM_METAG:	 reltype = R_METAG_ADDR32;
+			 altmcount = "_mcount_wrapper";
+			 rel_type_nop = R_METAG_NONE;
+			 /* We happen to have the same requirement as MIPS */
+			 is_fake_mcount32 = MIPS32_is_fake_mcount;
+			 break;
 	case EM_MIPS:	 /* reltype: e_class    */ gpfx = '_'; break;
 	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;
 	case EM_PPC64:	 reltype = R_PPC64_ADDR64; gpfx = '_'; break;

commit f29638868280534ed7e2fdd93b31557232597940
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue May 10 10:10:43 2011 +0200

    ftrace/s390: mcount offset calculation
    
    Do the mcount offset adjustment in the recordmcount.pl/recordmcount.[ch]
    at compile time and not in ftrace_call_adjust at run time.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 7648a5d11154..ee52cb8e17ad 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -368,8 +368,10 @@ do_file(char const *const fname)
 				"unrecognized ET_REL file: %s\n", fname);
 			fail_file();
 		}
-		if (w2(ehdr->e_machine) == EM_S390)
+		if (w2(ehdr->e_machine) == EM_S390) {
 			reltype = R_390_32;
+			mcount_adjust_32 = -4;
+		}
 		if (w2(ehdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_32;
 			is_fake_mcount32 = MIPS32_is_fake_mcount;
@@ -384,8 +386,10 @@ do_file(char const *const fname)
 				"unrecognized ET_REL file: %s\n", fname);
 			fail_file();
 		}
-		if (w2(ghdr->e_machine) == EM_S390)
+		if (w2(ghdr->e_machine) == EM_S390) {
 			reltype = R_390_64;
+			mcount_adjust_64 = -8;
+		}
 		if (w2(ghdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_64;
 			Elf64_r_sym = MIPS64_r_sym;

commit 521ccb5c4aece609311bfa7157910a8f0c942af5
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue May 10 10:10:41 2011 +0200

    ftrace/x86: mcount offset calculation
    
    Do the mcount offset adjustment in the recordmcount.pl/recordmcount.[ch]
    at compile time and not in ftrace_call_adjust at run time.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 0e18975824f7..7648a5d11154 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -335,6 +335,7 @@ do_file(char const *const fname)
 		reltype = R_386_32;
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_32;
+		mcount_adjust_32 = -1;
 		break;
 	case EM_ARM:	 reltype = R_ARM_ABS32;
 			 altmcount = "__gnu_mcount_nc";
@@ -350,6 +351,7 @@ do_file(char const *const fname)
 		make_nop = make_nop_x86;
 		ideal_nop = ideal_nop5_x86_64;
 		reltype = R_X86_64_64;
+		mcount_adjust_64 = -1;
 		break;
 	}  /* end switch */
 

commit dfad3d598c4bbbaf137588e22bac1ce624529f7e
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Apr 12 18:53:25 2011 -0400

    ftrace/recordmcount: Add warning logic to warn on mcount not recorded
    
    There's some sections that should not have mcount recorded and should not have
    modifications to the that code. But currently they waste some time by calling
    mcount anyway (which simply returns). As the real answer should be to
    either whitelist the section or have gcc ignore it fully.
    
    This change adds a option to recordmcount to warn when it finds a section
    that is ignored by ftrace but still contains mcount callers. This is not on
    by default as developers may not know if the section should be completely
    ignored or added to the whitelist.
    
    Cc: John Reiser <jreiser@bitwagon.com>
    Link: http://lkml.kernel.org/r/20110421023738.476989377@goodmis.org
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 78054a41d134..0e18975824f7 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -24,6 +24,7 @@
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <getopt.h>
 #include <elf.h>
 #include <fcntl.h>
 #include <setjmp.h>
@@ -39,6 +40,7 @@ static char gpfx;	/* prefix for global symbol name (sometimes '_') */
 static struct stat sb;	/* Remember .st_size, etc. */
 static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
 static const char *altmcount;	/* alternate mcount symbol name */
+static int warn_on_notrace_sect; /* warn when section has mcount not being recorded */
 
 /* setjmp() return values */
 enum {
@@ -397,19 +399,33 @@ do_file(char const *const fname)
 }
 
 int
-main(int argc, char const *argv[])
+main(int argc, char *argv[])
 {
 	const char ftrace[] = "/ftrace.o";
 	int ftrace_size = sizeof(ftrace) - 1;
 	int n_error = 0;  /* gcc-4.3.0 false positive complaint */
+	int c;
+	int i;
 
-	if (argc <= 1) {
-		fprintf(stderr, "usage: recordmcount file.o...\n");
+	while ((c = getopt(argc, argv, "w")) >= 0) {
+		switch (c) {
+		case 'w':
+			warn_on_notrace_sect = 1;
+			break;
+		default:
+			fprintf(stderr, "usage: recordmcount [-w] file.o...\n");
+			return 0;
+		}
+	}
+
+	if ((argc - optind) < 1) {
+		fprintf(stderr, "usage: recordmcount [-w] file.o...\n");
 		return 0;
 	}
 
 	/* Process each file in turn, allowing deep failure. */
-	for (--argc, ++argv; argc > 0; --argc, ++argv) {
+	for (i = optind; i < argc; i++) {
+		char *file = argv[i];
 		int const sjval = setjmp(jmpenv);
 		int len;
 
@@ -418,14 +434,14 @@ main(int argc, char const *argv[])
 		 * function but does not call it. Since ftrace.o should
 		 * not be traced anyway, we just skip it.
 		 */
-		len = strlen(argv[0]);
+		len = strlen(file);
 		if (len >= ftrace_size &&
-		    strcmp(argv[0] + (len - ftrace_size), ftrace) == 0)
+		    strcmp(file + (len - ftrace_size), ftrace) == 0)
 			continue;
 
 		switch (sjval) {
 		default:
-			fprintf(stderr, "internal error: %s\n", argv[0]);
+			fprintf(stderr, "internal error: %s\n", file);
 			exit(1);
 			break;
 		case SJ_SETJMP:    /* normal sequence */
@@ -433,7 +449,7 @@ main(int argc, char const *argv[])
 			fd_map = -1;
 			ehdr_curr = NULL;
 			mmap_failed = 1;
-			do_file(argv[0]);
+			do_file(file);
 			break;
 		case SJ_FAIL:    /* error in do_file or below */
 			++n_error;

commit ffd618fa39284f8cc343894b566dd42ec6e74e77
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Fri Apr 8 03:58:48 2011 -0400

    ftrace/recordmcount: Make ignored mcount calls into nops at compile time
    
    There are sections that are ignored by ftrace for the function tracing because
    the text is in a section that can be removed without notice. The mcount calls
    in these sections are ignored and ftrace never sees them. The downside of this
    is that the functions in these sections still call mcount. Although the mcount
    function is defined in assembly simply as a return, this added overhead is
    unnecessary.
    
    The solution is to convert these callers into nops at compile time.
    A better solution is to add 'notrace' to the section markers, but as new sections
    come up all the time, it would be nice that they are delt with when they
    are created.
    
    Later patches will deal with finding these sections and doing the proper solution.
    
    Thanks to H. Peter Anvin for giving me the right nops to use for x86.
    
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: John Reiser <jreiser@bitwagon.com>
    Link: http://lkml.kernel.org/r/20110421023738.237101176@goodmis.org
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 37c59654c133..78054a41d134 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -118,6 +118,34 @@ umalloc(size_t size)
 	return addr;
 }
 
+static unsigned char ideal_nop5_x86_64[5] = { 0x0f, 0x1f, 0x44, 0x00, 0x00 };
+static unsigned char ideal_nop5_x86_32[5] = { 0x3e, 0x8d, 0x74, 0x26, 0x00 };
+static unsigned char *ideal_nop;
+
+static char rel_type_nop;
+
+static int (*make_nop)(void *map, size_t const offset);
+
+static int make_nop_x86(void *map, size_t const offset)
+{
+	uint32_t *ptr;
+	unsigned char *op;
+
+	/* Confirm we have 0xe8 0x0 0x0 0x0 0x0 */
+	ptr = map + offset;
+	if (*ptr != 0)
+		return -1;
+
+	op = map + offset - 1;
+	if (*op != 0xe8)
+		return -1;
+
+	/* convert to nop */
+	ulseek(fd_map, offset - 1, SEEK_SET);
+	uwrite(fd_map, ideal_nop, 5);
+	return 0;
+}
+
 /*
  * Get the whole file as a programming convenience in order to avoid
  * malloc+lseek+read+free of many pieces.  If successful, then mmap
@@ -301,7 +329,11 @@ do_file(char const *const fname)
 			w2(ehdr->e_machine), fname);
 		fail_file();
 		break;
-	case EM_386:	 reltype = R_386_32;                   break;
+	case EM_386:
+		reltype = R_386_32;
+		make_nop = make_nop_x86;
+		ideal_nop = ideal_nop5_x86_32;
+		break;
 	case EM_ARM:	 reltype = R_ARM_ABS32;
 			 altmcount = "__gnu_mcount_nc";
 			 break;
@@ -312,7 +344,11 @@ do_file(char const *const fname)
 	case EM_S390:    /* reltype: e_class    */ gpfx = '_'; break;
 	case EM_SH:	 reltype = R_SH_DIR32;                 break;
 	case EM_SPARCV9: reltype = R_SPARC_64;     gpfx = '_'; break;
-	case EM_X86_64:	 reltype = R_X86_64_64;                break;
+	case EM_X86_64:
+		make_nop = make_nop_x86;
+		ideal_nop = ideal_nop5_x86_64;
+		reltype = R_X86_64_64;
+		break;
 	}  /* end switch */
 
 	switch (ehdr->e_ident[EI_CLASS]) {

commit 9f087e7612115b7a201d4f3392a95ac7408948ab
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Apr 6 14:10:22 2011 -0400

    ftrace: Add .kprobe.text section to whitelist for recordmcount.c
    
    The .kprobe.text section is safe to modify mcount to nop and tracing.
    Add it to the whitelist in recordmcount.c and recordmcount.pl.
    
    Cc: John Reiser <jreiser@bitwagon.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Link: http://lkml.kernel.org/r/20110421023737.743350547@goodmis.org
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 4ebd8399cb33..37c59654c133 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -211,6 +211,7 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".sched.text",    txtname) == 0 ||
 		strcmp(".spinlock.text", txtname) == 0 ||
 		strcmp(".irqentry.text", txtname) == 0 ||
+		strcmp(".kprobes.text", txtname) == 0 ||
 		strcmp(".text.unlikely", txtname) == 0;
 }
 

commit e90b0c8bf211958a296d60369fecd51b35864407
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Apr 6 13:32:24 2011 -0400

    ftrace/trivial: Clean up record mcount to use Linux switch style
    
    The Linux style for switch statements is:
    
            switch (var) {
            case x:
                    [...]
                    break;
            }
    
    Not:
            switch (var) {
            case x: {
                    [...]
            } break;
    
    Cc: John Reiser <jreiser@bitwagon.com>
    Link: http://lkml.kernel.org/r/20110421023737.523968644@goodmis.org
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 37afe0ecacb2..4ebd8399cb33 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -264,27 +264,27 @@ do_file(char const *const fname)
 	w8 = w8nat;
 	switch (ehdr->e_ident[EI_DATA]) {
 		static unsigned int const endian = 1;
-	default: {
+	default:
 		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
 			ehdr->e_ident[EI_DATA], fname);
 		fail_file();
-	} break;
-	case ELFDATA2LSB: {
+		break;
+	case ELFDATA2LSB:
 		if (*(unsigned char const *)&endian != 1) {
 			/* main() is big endian, file.o is little endian. */
 			w = w4rev;
 			w2 = w2rev;
 			w8 = w8rev;
 		}
-	} break;
-	case ELFDATA2MSB: {
+		break;
+	case ELFDATA2MSB:
 		if (*(unsigned char const *)&endian != 0) {
 			/* main() is little endian, file.o is big endian. */
 			w = w4rev;
 			w2 = w2rev;
 			w8 = w8rev;
 		}
-	} break;
+		break;
 	}  /* end switch */
 	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
 	||  w2(ehdr->e_type) != ET_REL
@@ -295,11 +295,11 @@ do_file(char const *const fname)
 
 	gpfx = 0;
 	switch (w2(ehdr->e_machine)) {
-	default: {
+	default:
 		fprintf(stderr, "unrecognized e_machine %d %s\n",
 			w2(ehdr->e_machine), fname);
 		fail_file();
-	} break;
+		break;
 	case EM_386:	 reltype = R_386_32;                   break;
 	case EM_ARM:	 reltype = R_ARM_ABS32;
 			 altmcount = "__gnu_mcount_nc";
@@ -315,12 +315,12 @@ do_file(char const *const fname)
 	}  /* end switch */
 
 	switch (ehdr->e_ident[EI_CLASS]) {
-	default: {
+	default:
 		fprintf(stderr, "unrecognized ELF class %d %s\n",
 			ehdr->e_ident[EI_CLASS], fname);
 		fail_file();
-	} break;
-	case ELFCLASS32: {
+		break;
+	case ELFCLASS32:
 		if (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)
 		||  w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {
 			fprintf(stderr,
@@ -334,7 +334,7 @@ do_file(char const *const fname)
 			is_fake_mcount32 = MIPS32_is_fake_mcount;
 		}
 		do32(ehdr, fname, reltype);
-	} break;
+		break;
 	case ELFCLASS64: {
 		Elf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;
 		if (w2(ghdr->e_ehsize) != sizeof(Elf64_Ehdr)
@@ -352,7 +352,8 @@ do_file(char const *const fname)
 			is_fake_mcount64 = MIPS64_is_fake_mcount;
 		}
 		do64(ghdr, fname, reltype);
-	} break;
+		break;
+	}
 	}  /* end switch */
 
 	cleanup();
@@ -386,23 +387,23 @@ main(int argc, char const *argv[])
 			continue;
 
 		switch (sjval) {
-		default: {
+		default:
 			fprintf(stderr, "internal error: %s\n", argv[0]);
 			exit(1);
-		} break;
-		case SJ_SETJMP: {  /* normal sequence */
+			break;
+		case SJ_SETJMP:    /* normal sequence */
 			/* Avoid problems if early cleanup() */
 			fd_map = -1;
 			ehdr_curr = NULL;
 			mmap_failed = 1;
 			do_file(argv[0]);
-		} break;
-		case SJ_FAIL: {  /* error in do_file or below */
+			break;
+		case SJ_FAIL:    /* error in do_file or below */
 			++n_error;
-		} break;
-		case SJ_SUCCEED: {  /* premature success */
+			break;
+		case SJ_SUCCEED:    /* premature success */
 			/* do nothing */
-		} break;
+			break;
 		}  /* end switch */
 	}
 	return !!n_error;

commit dd5477ff3ba978892014ea5f988cb1bf04aa505e
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Apr 6 13:21:17 2011 -0400

    ftrace/trivial: Clean up recordmcount.c to use Linux style comparisons
    
    The Linux ftrace subsystem style for comparing is:
    
      var == 1
      var > 0
    
    and not:
    
      1 == var
      0 < var
    
    It is considered that Linux developers are smart enough not to do the
    
      if (var = 1)
    
    mistake.
    
    Cc: John Reiser <jreiser@bitwagon.com>
    Link: http://lkml.kernel.org/r/20110421023737.290712238@goodmis.org
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index f9f6f52db772..37afe0ecacb2 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -78,7 +78,7 @@ static off_t
 ulseek(int const fd, off_t const offset, int const whence)
 {
 	off_t const w = lseek(fd, offset, whence);
-	if ((off_t)-1 == w) {
+	if (w == (off_t)-1) {
 		perror("lseek");
 		fail_file();
 	}
@@ -111,7 +111,7 @@ static void *
 umalloc(size_t size)
 {
 	void *const addr = malloc(size);
-	if (0 == addr) {
+	if (addr == 0) {
 		fprintf(stderr, "malloc failed: %zu bytes\n", size);
 		fail_file();
 	}
@@ -136,7 +136,7 @@ static void *mmap_file(char const *fname)
 	void *addr;
 
 	fd_map = open(fname, O_RDWR);
-	if (0 > fd_map || 0 > fstat(fd_map, &sb)) {
+	if (fd_map < 0 || fstat(fd_map, &sb) < 0) {
 		perror(fname);
 		fail_file();
 	}
@@ -147,7 +147,7 @@ static void *mmap_file(char const *fname)
 	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
 		    fd_map, 0);
 	mmap_failed = 0;
-	if (MAP_FAILED == addr) {
+	if (addr == MAP_FAILED) {
 		mmap_failed = 1;
 		addr = umalloc(sb.st_size);
 		uread(fd_map, addr, sb.st_size);
@@ -206,12 +206,12 @@ static uint32_t (*w2)(uint16_t);
 static int
 is_mcounted_section_name(char const *const txtname)
 {
-	return 0 == strcmp(".text",           txtname) ||
-		0 == strcmp(".ref.text",      txtname) ||
-		0 == strcmp(".sched.text",    txtname) ||
-		0 == strcmp(".spinlock.text", txtname) ||
-		0 == strcmp(".irqentry.text", txtname) ||
-		0 == strcmp(".text.unlikely", txtname);
+	return strcmp(".text",           txtname) == 0 ||
+		strcmp(".ref.text",      txtname) == 0 ||
+		strcmp(".sched.text",    txtname) == 0 ||
+		strcmp(".spinlock.text", txtname) == 0 ||
+		strcmp(".irqentry.text", txtname) == 0 ||
+		strcmp(".text.unlikely", txtname) == 0;
 }
 
 /* 32 bit and 64 bit are very similar */
@@ -270,7 +270,7 @@ do_file(char const *const fname)
 		fail_file();
 	} break;
 	case ELFDATA2LSB: {
-		if (1 != *(unsigned char const *)&endian) {
+		if (*(unsigned char const *)&endian != 1) {
 			/* main() is big endian, file.o is little endian. */
 			w = w4rev;
 			w2 = w2rev;
@@ -278,7 +278,7 @@ do_file(char const *const fname)
 		}
 	} break;
 	case ELFDATA2MSB: {
-		if (0 != *(unsigned char const *)&endian) {
+		if (*(unsigned char const *)&endian != 0) {
 			/* main() is little endian, file.o is big endian. */
 			w = w4rev;
 			w2 = w2rev;
@@ -286,9 +286,9 @@ do_file(char const *const fname)
 		}
 	} break;
 	}  /* end switch */
-	if (0 != memcmp(ELFMAG, ehdr->e_ident, SELFMAG)
-	||  ET_REL != w2(ehdr->e_type)
-	||  EV_CURRENT != ehdr->e_ident[EI_VERSION]) {
+	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
+	||  w2(ehdr->e_type) != ET_REL
+	||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
 		fprintf(stderr, "unrecognized ET_REL file %s\n", fname);
 		fail_file();
 	}
@@ -321,15 +321,15 @@ do_file(char const *const fname)
 		fail_file();
 	} break;
 	case ELFCLASS32: {
-		if (sizeof(Elf32_Ehdr) != w2(ehdr->e_ehsize)
-		||  sizeof(Elf32_Shdr) != w2(ehdr->e_shentsize)) {
+		if (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)
+		||  w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
 			fail_file();
 		}
-		if (EM_S390 == w2(ehdr->e_machine))
+		if (w2(ehdr->e_machine) == EM_S390)
 			reltype = R_390_32;
-		if (EM_MIPS == w2(ehdr->e_machine)) {
+		if (w2(ehdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_32;
 			is_fake_mcount32 = MIPS32_is_fake_mcount;
 		}
@@ -337,15 +337,15 @@ do_file(char const *const fname)
 	} break;
 	case ELFCLASS64: {
 		Elf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;
-		if (sizeof(Elf64_Ehdr) != w2(ghdr->e_ehsize)
-		||  sizeof(Elf64_Shdr) != w2(ghdr->e_shentsize)) {
+		if (w2(ghdr->e_ehsize) != sizeof(Elf64_Ehdr)
+		||  w2(ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {
 			fprintf(stderr,
 				"unrecognized ET_REL file: %s\n", fname);
 			fail_file();
 		}
-		if (EM_S390 == w2(ghdr->e_machine))
+		if (w2(ghdr->e_machine) == EM_S390)
 			reltype = R_390_64;
-		if (EM_MIPS == w2(ghdr->e_machine)) {
+		if (w2(ghdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_64;
 			Elf64_r_sym = MIPS64_r_sym;
 			Elf64_r_info = MIPS64_r_info;
@@ -371,7 +371,7 @@ main(int argc, char const *argv[])
 	}
 
 	/* Process each file in turn, allowing deep failure. */
-	for (--argc, ++argv; 0 < argc; --argc, ++argv) {
+	for (--argc, ++argv; argc > 0; --argc, ++argv) {
 		int const sjval = setjmp(jmpenv);
 		int len;
 

commit 1274a9c2e91652e28efa45c3e5886ec82f08bfbe
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Fri Feb 11 16:43:33 2011 -0500

    ftrace: Add .ref.text as one of the safe areas to trace
    
    The section .ref.text will not go away unexpectedly and is
    safe to trace. Add it to the safe list of sections to allow
    tracing.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 038b3d1e2981..f9f6f52db772 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -206,7 +206,8 @@ static uint32_t (*w2)(uint16_t);
 static int
 is_mcounted_section_name(char const *const txtname)
 {
-	return 0 == strcmp(".text",          txtname) ||
+	return 0 == strcmp(".text",           txtname) ||
+		0 == strcmp(".ref.text",      txtname) ||
 		0 == strcmp(".sched.text",    txtname) ||
 		0 == strcmp(".spinlock.text", txtname) ||
 		0 == strcmp(".irqentry.text", txtname) ||

commit ed60453fa8f8fc3d034dfdf10371a99cc6905626
Author: Rabin Vincent <rabin@rab.in>
Date:   Tue Nov 30 17:36:48 2010 +0100

    ARM: 6511/1: ftrace: add ARM support for C version of recordmcount
    
    Depending on the compiler version, ARM GCC calls the mcount function
    either __gnu_mcount_nc or mcount.
    
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index ac6e51ceed50..038b3d1e2981 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -38,6 +38,7 @@ static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
 static char gpfx;	/* prefix for global symbol name (sometimes '_') */
 static struct stat sb;	/* Remember .st_size, etc. */
 static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
+static const char *altmcount;	/* alternate mcount symbol name */
 
 /* setjmp() return values */
 enum {
@@ -299,7 +300,9 @@ do_file(char const *const fname)
 		fail_file();
 	} break;
 	case EM_386:	 reltype = R_386_32;                   break;
-	case EM_ARM:	 reltype = R_ARM_ABS32;                break;
+	case EM_ARM:	 reltype = R_ARM_ABS32;
+			 altmcount = "__gnu_mcount_nc";
+			 break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
 	case EM_MIPS:	 /* reltype: e_class    */ gpfx = '_'; break;
 	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;

commit cd3478f2bd8f2cec19f9247a8a9cd711cbe37683
Author: Rabin Vincent <rabin@rab.in>
Date:   Tue Nov 30 17:33:53 2010 +0100

    ARM: 6509/1: ftrace: ignore any ftrace.o in C version of recordmcount
    
    arch/arm/kernel/ftrace.c references mcount like kernel/tracing/ftrace.c,
    so change the exclusion filter to match any ftrace.o.
    
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index f2f32eee2c5b..ac6e51ceed50 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -357,7 +357,7 @@ do_file(char const *const fname)
 int
 main(int argc, char const *argv[])
 {
-	const char ftrace[] = "kernel/trace/ftrace.o";
+	const char ftrace[] = "/ftrace.o";
 	int ftrace_size = sizeof(ftrace) - 1;
 	int n_error = 0;  /* gcc-4.3.0 false positive complaint */
 

commit 412910cd046c1f14f0fba9c0aec401d47e57dcd1
Author: Wu Zhangjin <wuzhangjin@gmail.com>
Date:   Wed Oct 27 18:59:08 2010 +0800

    ftrace/MIPS: Add module support for C version of recordmcount
    
    Since MIPS modules' address space differs from the core kernel space, to access
    the _mcount in the core kernel, the kernel functions in modules must use long
    call (-mlong-calls): load the _mcount address into one register and jump to the
    address stored by the register:
    
     c:  3c030000        lui     v1,0x0  <-------->  b label
               c: R_MIPS_HI16  _mcount
               c: R_MIPS_NONE  *ABS*
               c: R_MIPS_NONE  *ABS*
    10:  64630000        daddiu  v1,v1,0
              10: R_MIPS_LO16 _mcount
              10: R_MIPS_NONE *ABS*
              10: R_MIPS_NONE *ABS*
    14:     03e0082d        move    at,ra
    18:     0060f809        jalr    v1
    label:
    
    In the old Perl version of recordmcount, we only need to record the position of
    the 1st R_MIPS_HI16 type of _mcount, and later, in ftrace_make_nop(), replace
    the instruction in this position by a "b label" and in ftrace_make_call(),
    replace it back.
    
    But, the default C version of recordmcount records all of the _mcount symbols,
    so, we must filter the 2nd _mcount like the Perl version of recordmcount does.
    
    The C version of recordmcount copes with the symbols before they are linked, So
    It doesn't know the type of the symbols and therefore can not filter the
    symbols as the Perl version of recordmcount does. But as we can see above, the
    2nd _mcount symbols of the long call alawys follows the 1st _mcount symbol of
    the same long call, which means the offset from the 1st to the 2nd is fixed, it
    is 0x10-0xc = 4 here, 4 is the length of the 1st load instruciton, for MIPS has
    fixed length of instructions, this offset is always 4.
    
    And as we know, the _mcount is inserted into the entry of every kernel
    function, the offset between the other _mcount's is expected to be always
    bigger than 4. So, to filter the 2ns _mcount symbol of the long call, we can
    simply check the offset between two _mcount symbols, If it is 4, then, filter
    the 2nd _mcount symbol.
    
    To avoid touching too much code, an 'empty' function fn_is_fake_mcount() is
    added for all of the archs, and the specific archs can override it via chaning
    the function pointer: is_fake_mcount in do_file() with the e_machine. e.g. This
    patch adds MIPS_is_fake_mcount() to override the default fn_is_fake_mcount()
    pointed by is_fake_mcount.
    
    This fn_is_fake_mcount() checks if the _mcount symbol is fake, e.g. the 2nd
    _mcount symbol of the long call is fake, for there are 2 _mcount symbols mapped
    to one real mcount call, so, one of them is fake and must be filtered.
    
    This fn_is_fake_mcount() is called in sift_rel_mcount() after finding the
    _mcount symbols and before adding the _mcount symbol into mrelp, so, it can
    prevent the fake mcount symbol going into the last __mcount_loc table.
    
    Signed-off-by: Wu Zhangjin <wuzhangjin@gmail.com>
    LKML-Reference: <b866f0138224340a132d31861fa3f9300dee30ac.1288176026.git.wuzhangjin@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 2d32b9ced20a..f2f32eee2c5b 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -325,8 +325,10 @@ do_file(char const *const fname)
 		}
 		if (EM_S390 == w2(ehdr->e_machine))
 			reltype = R_390_32;
-		if (EM_MIPS == w2(ehdr->e_machine))
+		if (EM_MIPS == w2(ehdr->e_machine)) {
 			reltype = R_MIPS_32;
+			is_fake_mcount32 = MIPS32_is_fake_mcount;
+		}
 		do32(ehdr, fname, reltype);
 	} break;
 	case ELFCLASS64: {
@@ -343,6 +345,7 @@ do_file(char const *const fname)
 			reltype = R_MIPS_64;
 			Elf64_r_sym = MIPS64_r_sym;
 			Elf64_r_info = MIPS64_r_info;
+			is_fake_mcount64 = MIPS64_is_fake_mcount;
 		}
 		do64(ghdr, fname, reltype);
 	} break;

commit a2d49358ba9bc93204dc001d5568c5bdb299b77d
Author: John Reiser <jreiser@BitWagon.com>
Date:   Wed Oct 27 18:59:07 2010 +0800

    ftrace/MIPS: Add MIPS64 support for C version of recordmcount
    
    MIPS64 has 'weird' Elf64_Rel.r_info[1,2], which must be used instead of
    the generic Elf64_Rel.r_info, otherwise, the C version of recordmcount
    will not work for "segmentation fault".
    
    Usage of "union mips_r_info" and the functions MIPS64_r_sym() and
    MIPS64_r_info() written by Maciej W. Rozycki <macro@linux-mips.org>
    
    ----
    [1] http://techpubs.sgi.com/library/manuals/4000/007-4658-001/pdf/007-4658-001.pdf
    [2] arch/mips/include/asm/module.h
    
    Tested-by: Wu Zhangjin <wuzhangjin@gmail.com>
    Signed-off-by: John Reiser <jreiser@BitWagon.com>
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    LKML-Reference: <AANLkTinwXjLAYACUfhLYaocHD_vBbiErLN3NjwN8JqSy@mail.gmail.com>
    LKML-Reference: <910dc2d5ae1ed042df4f96815fe4a433078d1c2a.1288176026.git.wuzhangjin@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 26e1271259ba..2d32b9ced20a 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -217,6 +217,39 @@ is_mcounted_section_name(char const *const txtname)
 #define RECORD_MCOUNT_64
 #include "recordmcount.h"
 
+/* 64-bit EM_MIPS has weird ELF64_Rela.r_info.
+ * http://techpubs.sgi.com/library/manuals/4000/007-4658-001/pdf/007-4658-001.pdf
+ * We interpret Table 29 Relocation Operation (Elf64_Rel, Elf64_Rela) [p.40]
+ * to imply the order of the members; the spec does not say so.
+ *	typedef unsigned char Elf64_Byte;
+ * fails on MIPS64 because their <elf.h> already has it!
+ */
+
+typedef uint8_t myElf64_Byte;		/* Type for a 8-bit quantity.  */
+
+union mips_r_info {
+	Elf64_Xword r_info;
+	struct {
+		Elf64_Word r_sym;		/* Symbol index.  */
+		myElf64_Byte r_ssym;		/* Special symbol.  */
+		myElf64_Byte r_type3;		/* Third relocation.  */
+		myElf64_Byte r_type2;		/* Second relocation.  */
+		myElf64_Byte r_type;		/* First relocation.  */
+	} r_mips;
+};
+
+static uint64_t MIPS64_r_sym(Elf64_Rel const *rp)
+{
+	return w(((union mips_r_info){ .r_info = rp->r_info }).r_mips.r_sym);
+}
+
+static void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)
+{
+	rp->r_info = ((union mips_r_info){
+		.r_mips = { .r_sym = w(sym), .r_type = type }
+	}).r_info;
+}
+
 static void
 do_file(char const *const fname)
 {
@@ -268,6 +301,7 @@ do_file(char const *const fname)
 	case EM_386:	 reltype = R_386_32;                   break;
 	case EM_ARM:	 reltype = R_ARM_ABS32;                break;
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
+	case EM_MIPS:	 /* reltype: e_class    */ gpfx = '_'; break;
 	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;
 	case EM_PPC64:	 reltype = R_PPC64_ADDR64; gpfx = '_'; break;
 	case EM_S390:    /* reltype: e_class    */ gpfx = '_'; break;
@@ -291,6 +325,8 @@ do_file(char const *const fname)
 		}
 		if (EM_S390 == w2(ehdr->e_machine))
 			reltype = R_390_32;
+		if (EM_MIPS == w2(ehdr->e_machine))
+			reltype = R_MIPS_32;
 		do32(ehdr, fname, reltype);
 	} break;
 	case ELFCLASS64: {
@@ -303,6 +339,11 @@ do_file(char const *const fname)
 		}
 		if (EM_S390 == w2(ghdr->e_machine))
 			reltype = R_390_64;
+		if (EM_MIPS == w2(ghdr->e_machine)) {
+			reltype = R_MIPS_64;
+			Elf64_r_sym = MIPS64_r_sym;
+			Elf64_r_info = MIPS64_r_info;
+		}
 		do64(ghdr, fname, reltype);
 	} break;
 	}  /* end switch */

commit 444758636439810f110f86a3042c2dfd3626a9e2
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Fri Oct 15 11:49:47 2010 -0400

    ftrace: Do not process kernel/trace/ftrace.o with C recordmcount program
    
    The file kernel/trace/ftrace.c references the mcount() call to
    convert the mcount() callers to nops. But because it references
    mcount(), the mcount() address is placed in the relocation table.
    
    The C version of recordmcount reads the relocation table of all
    object files, and it will add all references to mcount to the
    __mcount_loc table that is used to find the places that call mcount()
    and change the call to a nop. When recordmcount finds the mcount reference
    in kernel/trace/ftrace.o, it saves that location even though the code
    is not a call, but references mcount as data.
    
    On boot up, when all calls are converted to nops, the code has a safety
    check to determine what op code it is actually replacing before it
    replaces it. If that op code at the address does not match, then
    a warning is printed and the function tracer is disabled.
    
    The reference to mcount in ftrace.c, causes this warning to trigger,
    since the reference is not a call to mcount(). The ftrace.c file is
    not compiled with the -pg flag, so no calls to mcount() should be
    expected.
    
    This patch simply makes recordmcount.c skip the kernel/trace/ftrace.c
    file. This was the same solution used by the perl version of
    recordmcount.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Cc: John Reiser <jreiser@bitwagon.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 7f7f7180fe24..26e1271259ba 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -313,12 +313,30 @@ do_file(char const *const fname)
 int
 main(int argc, char const *argv[])
 {
+	const char ftrace[] = "kernel/trace/ftrace.o";
+	int ftrace_size = sizeof(ftrace) - 1;
 	int n_error = 0;  /* gcc-4.3.0 false positive complaint */
-	if (argc <= 1)
+
+	if (argc <= 1) {
 		fprintf(stderr, "usage: recordmcount file.o...\n");
-	else  /* Process each file in turn, allowing deep failure. */
+		return 0;
+	}
+
+	/* Process each file in turn, allowing deep failure. */
 	for (--argc, ++argv; 0 < argc; --argc, ++argv) {
 		int const sjval = setjmp(jmpenv);
+		int len;
+
+		/*
+		 * The file kernel/trace/ftrace.o references the mcount
+		 * function but does not call it. Since ftrace.o should
+		 * not be traced anyway, we just skip it.
+		 */
+		len = strlen(argv[0]);
+		if (len >= ftrace_size &&
+		    strcmp(argv[0] + (len - ftrace_size), ftrace) == 0)
+			continue;
+
 		switch (sjval) {
 		default: {
 			fprintf(stderr, "internal error: %s\n", argv[0]);

commit c28d5077f8d79bfce1e3f88db2e261cf2b6473dc
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Oct 13 19:06:14 2010 -0400

    ftrace: Remove duplicate code for 64 and 32 bit in recordmcount.c
    
    The elf reader for recordmcount.c had duplicate functions for both
    32 bit and 64 bit elf handling. This was due to the need of using
    the 32 and 64 bit elf structures.
    
    This patch consolidates the two by using macros to define the 32
    and 64 bit names in a recordmcount.h file, and then by just defining
    a RECORD_MCOUNT_64 macro and including recordmcount.h twice we
    create the funtions for both the 32 bit version as well as the
    64 bit version using one code source.
    
    Cc: John Reiser <jreiser@bitwagon.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 34f32be17090..7f7f7180fe24 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -212,550 +212,10 @@ is_mcounted_section_name(char const *const txtname)
 		0 == strcmp(".text.unlikely", txtname);
 }
 
-/* Append the new shstrtab, Elf32_Shdr[], __mcount_loc and its relocations. */
-static void append32(Elf32_Ehdr *const ehdr,
-		     Elf32_Shdr *const shstr,
-		     uint32_t const *const mloc0,
-		     uint32_t const *const mlocp,
-		     Elf32_Rel const *const mrel0,
-		     Elf32_Rel const *const mrelp,
-		     unsigned int const rel_entsize,
-		     unsigned int const symsec_sh_link)
-{
-	/* Begin constructing output file */
-	Elf32_Shdr mcsec;
-	char const *mc_name = (sizeof(Elf32_Rela) == rel_entsize)
-		? ".rela__mcount_loc"
-		:  ".rel__mcount_loc";
-	unsigned const old_shnum = w2(ehdr->e_shnum);
-	uint32_t const old_shoff = w(ehdr->e_shoff);
-	uint32_t const old_shstr_sh_size   = w(shstr->sh_size);
-	uint32_t const old_shstr_sh_offset = w(shstr->sh_offset);
-	uint32_t t = 1 + strlen(mc_name) + w(shstr->sh_size);
-	uint32_t new_e_shoff;
-
-	shstr->sh_size = w(t);
-	shstr->sh_offset = w(sb.st_size);
-	t += sb.st_size;
-	t += (3u & -t);  /* 4-byte align */
-	new_e_shoff = t;
-
-	/* body for new shstrtab */
-	ulseek(fd_map, sb.st_size, SEEK_SET);
-	uwrite(fd_map, old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size);
-	uwrite(fd_map, mc_name, 1 + strlen(mc_name));
-
-	/* old(modified) Elf32_Shdr table, 4-byte aligned */
-	ulseek(fd_map, t, SEEK_SET);
-	t += sizeof(Elf32_Shdr) * old_shnum;
-	uwrite(fd_map, old_shoff + (void *)ehdr,
-	       sizeof(Elf32_Shdr) * old_shnum);
-
-	/* new sections __mcount_loc and .rel__mcount_loc */
-	t += 2*sizeof(mcsec);
-	mcsec.sh_name = w((sizeof(Elf32_Rela) == rel_entsize) + strlen(".rel")
-		+ old_shstr_sh_size);
-	mcsec.sh_type = w(SHT_PROGBITS);
-	mcsec.sh_flags = w(SHF_ALLOC);
-	mcsec.sh_addr = 0;
-	mcsec.sh_offset = w(t);
-	mcsec.sh_size = w((void *)mlocp - (void *)mloc0);
-	mcsec.sh_link = 0;
-	mcsec.sh_info = 0;
-	mcsec.sh_addralign = w(4);
-	mcsec.sh_entsize = w(4);
-	uwrite(fd_map, &mcsec, sizeof(mcsec));
-
-	mcsec.sh_name = w(old_shstr_sh_size);
-	mcsec.sh_type = (sizeof(Elf32_Rela) == rel_entsize)
-		? w(SHT_RELA)
-		: w(SHT_REL);
-	mcsec.sh_flags = 0;
-	mcsec.sh_addr = 0;
-	mcsec.sh_offset = w((void *)mlocp - (void *)mloc0 + t);
-	mcsec.sh_size   = w((void *)mrelp - (void *)mrel0);
-	mcsec.sh_link = w(symsec_sh_link);
-	mcsec.sh_info = w(old_shnum);
-	mcsec.sh_addralign = w(4);
-	mcsec.sh_entsize = w(rel_entsize);
-	uwrite(fd_map, &mcsec, sizeof(mcsec));
-
-	uwrite(fd_map, mloc0, (void *)mlocp - (void *)mloc0);
-	uwrite(fd_map, mrel0, (void *)mrelp - (void *)mrel0);
-
-	ehdr->e_shoff = w(new_e_shoff);
-	ehdr->e_shnum = w2(2 + w2(ehdr->e_shnum));  /* {.rel,}__mcount_loc */
-	ulseek(fd_map, 0, SEEK_SET);
-	uwrite(fd_map, ehdr, sizeof(*ehdr));
-}
-
-/*
- * append64 and append32 (and other analogous pairs) could be templated
- * using C++, but the complexity is high.  (For an example, look at p_elf.h
- * in the source for UPX, http://upx.sourceforge.net)  So: remember to make
- * the corresponding change in the routine for the other size.
- */
-static void append64(Elf64_Ehdr *const ehdr,
-		     Elf64_Shdr *const shstr,
-		     uint64_t const *const mloc0,
-		     uint64_t const *const mlocp,
-		     Elf64_Rel const *const mrel0,
-		     Elf64_Rel const *const mrelp,
-		     unsigned int const rel_entsize,
-		     unsigned int const symsec_sh_link)
-{
-	/* Begin constructing output file */
-	Elf64_Shdr mcsec;
-	char const *mc_name = (sizeof(Elf64_Rela) == rel_entsize)
-		? ".rela__mcount_loc"
-		:  ".rel__mcount_loc";
-	unsigned const old_shnum = w2(ehdr->e_shnum);
-	uint64_t const old_shoff = w8(ehdr->e_shoff);
-	uint64_t const old_shstr_sh_size   = w8(shstr->sh_size);
-	uint64_t const old_shstr_sh_offset = w8(shstr->sh_offset);
-	uint64_t t = 1 + strlen(mc_name) + w8(shstr->sh_size);
-	uint64_t new_e_shoff;
-
-	shstr->sh_size = w8(t);
-	shstr->sh_offset = w8(sb.st_size);
-	t += sb.st_size;
-	t += (7u & -t);  /* 8-byte align */
-	new_e_shoff = t;
-
-	/* body for new shstrtab */
-	ulseek(fd_map, sb.st_size, SEEK_SET);
-	uwrite(fd_map, old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size);
-	uwrite(fd_map, mc_name, 1 + strlen(mc_name));
-
-	/* old(modified) Elf64_Shdr table, 8-byte aligned */
-	ulseek(fd_map, t, SEEK_SET);
-	t += sizeof(Elf64_Shdr) * old_shnum;
-	uwrite(fd_map, old_shoff + (void *)ehdr,
-		sizeof(Elf64_Shdr) * old_shnum);
-
-	/* new sections __mcount_loc and .rel__mcount_loc */
-	t += 2*sizeof(mcsec);
-	mcsec.sh_name = w((sizeof(Elf64_Rela) == rel_entsize) + strlen(".rel")
-		+ old_shstr_sh_size);
-	mcsec.sh_type = w(SHT_PROGBITS);
-	mcsec.sh_flags = w8(SHF_ALLOC);
-	mcsec.sh_addr = 0;
-	mcsec.sh_offset = w8(t);
-	mcsec.sh_size = w8((void *)mlocp - (void *)mloc0);
-	mcsec.sh_link = 0;
-	mcsec.sh_info = 0;
-	mcsec.sh_addralign = w8(8);
-	mcsec.sh_entsize = w8(8);
-	uwrite(fd_map, &mcsec, sizeof(mcsec));
-
-	mcsec.sh_name = w(old_shstr_sh_size);
-	mcsec.sh_type = (sizeof(Elf64_Rela) == rel_entsize)
-		? w(SHT_RELA)
-		: w(SHT_REL);
-	mcsec.sh_flags = 0;
-	mcsec.sh_addr = 0;
-	mcsec.sh_offset = w8((void *)mlocp - (void *)mloc0 + t);
-	mcsec.sh_size   = w8((void *)mrelp - (void *)mrel0);
-	mcsec.sh_link = w(symsec_sh_link);
-	mcsec.sh_info = w(old_shnum);
-	mcsec.sh_addralign = w8(8);
-	mcsec.sh_entsize = w8(rel_entsize);
-	uwrite(fd_map, &mcsec, sizeof(mcsec));
-
-	uwrite(fd_map, mloc0, (void *)mlocp - (void *)mloc0);
-	uwrite(fd_map, mrel0, (void *)mrelp - (void *)mrel0);
-
-	ehdr->e_shoff = w8(new_e_shoff);
-	ehdr->e_shnum = w2(2 + w2(ehdr->e_shnum));  /* {.rel,}__mcount_loc */
-	ulseek(fd_map, 0, SEEK_SET);
-	uwrite(fd_map, ehdr, sizeof(*ehdr));
-}
-
-/*
- * Look at the relocations in order to find the calls to mcount.
- * Accumulate the section offsets that are found, and their relocation info,
- * onto the end of the existing arrays.
- */
-static uint32_t *sift32_rel_mcount(uint32_t *mlocp,
-				   unsigned const offbase,
-				   Elf32_Rel **const mrelpp,
-				   Elf32_Shdr const *const relhdr,
-				   Elf32_Ehdr const *const ehdr,
-				   unsigned const recsym,
-				   uint32_t const recval,
-				   unsigned const reltype)
-{
-	uint32_t *const mloc0 = mlocp;
-	Elf32_Rel *mrelp = *mrelpp;
-	Elf32_Shdr *const shdr0 = (Elf32_Shdr *)(w(ehdr->e_shoff)
-		+ (void *)ehdr);
-	unsigned const symsec_sh_link = w(relhdr->sh_link);
-	Elf32_Shdr const *const symsec = &shdr0[symsec_sh_link];
-	Elf32_Sym const *const sym0 = (Elf32_Sym const *)(w(symsec->sh_offset)
-		+ (void *)ehdr);
-
-	Elf32_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];
-	char const *const str0 = (char const *)(w(strsec->sh_offset)
-		+ (void *)ehdr);
-
-	Elf32_Rel const *const rel0 = (Elf32_Rel const *)(w(relhdr->sh_offset)
-		+ (void *)ehdr);
-	unsigned rel_entsize = w(relhdr->sh_entsize);
-	unsigned const nrel = w(relhdr->sh_size) / rel_entsize;
-	Elf32_Rel const *relp = rel0;
-
-	unsigned mcountsym = 0;
-	unsigned t;
-
-	for (t = nrel; t; --t) {
-		if (!mcountsym) {
-			Elf32_Sym const *const symp =
-				&sym0[ELF32_R_SYM(w(relp->r_info))];
-
-			if (0 == strcmp((('_' == gpfx) ? "_mcount" : "mcount"),
-					&str0[w(symp->st_name)]))
-				mcountsym = ELF32_R_SYM(w(relp->r_info));
-		}
-		if (mcountsym == ELF32_R_SYM(w(relp->r_info))) {
-			uint32_t const addend = w(w(relp->r_offset) - recval);
-			mrelp->r_offset = w(offbase
-				+ ((void *)mlocp - (void *)mloc0));
-			mrelp->r_info = w(ELF32_R_INFO(recsym, reltype));
-			if (sizeof(Elf32_Rela) == rel_entsize) {
-				((Elf32_Rela *)mrelp)->r_addend = addend;
-				*mlocp++ = 0;
-			} else
-				*mlocp++ = addend;
-
-			mrelp = (Elf32_Rel *)(rel_entsize + (void *)mrelp);
-		}
-		relp = (Elf32_Rel const *)(rel_entsize + (void *)relp);
-	}
-	*mrelpp = mrelp;
-	return mlocp;
-}
-
-static uint64_t *sift64_rel_mcount(uint64_t *mlocp,
-				   unsigned const offbase,
-				   Elf64_Rel **const mrelpp,
-				   Elf64_Shdr const *const relhdr,
-				   Elf64_Ehdr const *const ehdr,
-				   unsigned const recsym,
-				   uint64_t const recval,
-				   unsigned const reltype)
-{
-	uint64_t *const mloc0 = mlocp;
-	Elf64_Rel *mrelp = *mrelpp;
-	Elf64_Shdr *const shdr0 = (Elf64_Shdr *)(w8(ehdr->e_shoff)
-		+ (void *)ehdr);
-	unsigned const symsec_sh_link = w(relhdr->sh_link);
-	Elf64_Shdr const *const symsec = &shdr0[symsec_sh_link];
-	Elf64_Sym const *const sym0 = (Elf64_Sym const *)(w8(symsec->sh_offset)
-		+ (void *)ehdr);
-
-	Elf64_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];
-	char const *const str0 = (char const *)(w8(strsec->sh_offset)
-		+ (void *)ehdr);
-
-	Elf64_Rel const *const rel0 = (Elf64_Rel const *)(w8(relhdr->sh_offset)
-		+ (void *)ehdr);
-	unsigned rel_entsize = w8(relhdr->sh_entsize);
-	unsigned const nrel = w8(relhdr->sh_size) / rel_entsize;
-	Elf64_Rel const *relp = rel0;
-
-	unsigned mcountsym = 0;
-	unsigned t;
-
-	for (t = nrel; 0 != t; --t) {
-		if (!mcountsym) {
-			Elf64_Sym const *const symp =
-				&sym0[ELF64_R_SYM(w8(relp->r_info))];
-			char const *symname = &str0[w(symp->st_name)];
-
-			if ('.' == symname[0])
-				++symname;  /* ppc64 hack */
-			if (0 == strcmp((('_' == gpfx) ? "_mcount" : "mcount"),
-					symname))
-				mcountsym = ELF64_R_SYM(w8(relp->r_info));
-		}
-
-		if (mcountsym == ELF64_R_SYM(w8(relp->r_info))) {
-			uint64_t const addend = w8(w8(relp->r_offset) - recval);
-
-			mrelp->r_offset = w8(offbase
-				+ ((void *)mlocp - (void *)mloc0));
-			mrelp->r_info = w8(ELF64_R_INFO(recsym, reltype));
-			if (sizeof(Elf64_Rela) == rel_entsize) {
-				((Elf64_Rela *)mrelp)->r_addend = addend;
-				*mlocp++ = 0;
-			} else
-				*mlocp++ = addend;
-
-			mrelp = (Elf64_Rel *)(rel_entsize + (void *)mrelp);
-		}
-		relp = (Elf64_Rel const *)(rel_entsize + (void *)relp);
-	}
-	*mrelpp = mrelp;
-
-	return mlocp;
-}
-
-/*
- * Find a symbol in the given section, to be used as the base for relocating
- * the table of offsets of calls to mcount.  A local or global symbol suffices,
- * but avoid a Weak symbol because it may be overridden; the change in value
- * would invalidate the relocations of the offsets of the calls to mcount.
- * Often the found symbol will be the unnamed local symbol generated by
- * GNU 'as' for the start of each section.  For example:
- *    Num:    Value  Size Type    Bind   Vis      Ndx Name
- *      2: 00000000     0 SECTION LOCAL  DEFAULT    1
- */
-static unsigned find32_secsym_ndx(unsigned const txtndx,
-				  char const *const txtname,
-				  uint32_t *const recvalp,
-				  Elf32_Shdr const *const symhdr,
-				  Elf32_Ehdr const *const ehdr)
-{
-	Elf32_Sym const *const sym0 = (Elf32_Sym const *)(w(symhdr->sh_offset)
-		+ (void *)ehdr);
-	unsigned const nsym = w(symhdr->sh_size) / w(symhdr->sh_entsize);
-	Elf32_Sym const *symp;
-	unsigned t;
-
-	for (symp = sym0, t = nsym; t; --t, ++symp) {
-		unsigned int const st_bind = ELF32_ST_BIND(symp->st_info);
-
-		if (txtndx == w2(symp->st_shndx)
-			/* avoid STB_WEAK */
-		    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {
-			*recvalp = w(symp->st_value);
-			return symp - sym0;
-		}
-	}
-	fprintf(stderr, "Cannot find symbol for section %d: %s.\n",
-		txtndx, txtname);
-	fail_file();
-}
-
-static unsigned find64_secsym_ndx(unsigned const txtndx,
-				  char const *const txtname,
-				  uint64_t *const recvalp,
-				  Elf64_Shdr const *const symhdr,
-				  Elf64_Ehdr const *const ehdr)
-{
-	Elf64_Sym const *const sym0 = (Elf64_Sym const *)(w8(symhdr->sh_offset)
-		+ (void *)ehdr);
-	unsigned const nsym = w8(symhdr->sh_size) / w8(symhdr->sh_entsize);
-	Elf64_Sym const *symp;
-	unsigned t;
-
-	for (symp = sym0, t = nsym; t; --t, ++symp) {
-		unsigned int const st_bind = ELF64_ST_BIND(symp->st_info);
-
-		if (txtndx == w2(symp->st_shndx)
-			/* avoid STB_WEAK */
-		    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {
-			*recvalp = w8(symp->st_value);
-			return symp - sym0;
-		}
-	}
-	fprintf(stderr, "Cannot find symbol for section %d: %s.\n",
-		txtndx, txtname);
-	fail_file();
-}
-
-/*
- * Evade ISO C restriction: no declaration after statement in
- * has32_rel_mcount.
- */
-static char const *
-__has32_rel_mcount(Elf32_Shdr const *const relhdr,  /* is SHT_REL or SHT_RELA */
-		   Elf32_Shdr const *const shdr0,
-		   char const *const shstrtab,
-		   char const *const fname)
-{
-	/* .sh_info depends on .sh_type == SHT_REL[,A] */
-	Elf32_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];
-	char const *const txtname = &shstrtab[w(txthdr->sh_name)];
-
-	if (0 == strcmp("__mcount_loc", txtname)) {
-		fprintf(stderr, "warning: __mcount_loc already exists: %s\n",
-			fname);
-		succeed_file();
-	}
-	if (SHT_PROGBITS != w(txthdr->sh_type) ||
-	    !is_mcounted_section_name(txtname))
-		return NULL;
-	return txtname;
-}
-
-static char const *has32_rel_mcount(Elf32_Shdr const *const relhdr,
-				    Elf32_Shdr const *const shdr0,
-				    char const *const shstrtab,
-				    char const *const fname)
-{
-	if (SHT_REL  != w(relhdr->sh_type) && SHT_RELA != w(relhdr->sh_type))
-		return NULL;
-	return __has32_rel_mcount(relhdr, shdr0, shstrtab, fname);
-}
-
-static char const *__has64_rel_mcount(Elf64_Shdr const *const relhdr,
-				      Elf64_Shdr const *const shdr0,
-				      char const *const shstrtab,
-				      char const *const fname)
-{
-	/* .sh_info depends on .sh_type == SHT_REL[,A] */
-	Elf64_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];
-	char const *const txtname = &shstrtab[w(txthdr->sh_name)];
-
-	if (0 == strcmp("__mcount_loc", txtname)) {
-		fprintf(stderr, "warning: __mcount_loc already exists: %s\n",
-			fname);
-		succeed_file();
-	}
-	if (SHT_PROGBITS != w(txthdr->sh_type) ||
-	    !is_mcounted_section_name(txtname))
-		return NULL;
-	return txtname;
-}
-
-static char const *has64_rel_mcount(Elf64_Shdr const *const relhdr,
-				    Elf64_Shdr const *const shdr0,
-				    char const *const shstrtab,
-				    char const *const fname)
-{
-	if (SHT_REL  != w(relhdr->sh_type) && SHT_RELA != w(relhdr->sh_type))
-		return NULL;
-	return __has64_rel_mcount(relhdr, shdr0, shstrtab, fname);
-}
-
-static unsigned tot32_relsize(Elf32_Shdr const *const shdr0,
-			      unsigned nhdr,
-			      const char *const shstrtab,
-			      const char *const fname)
-{
-	unsigned totrelsz = 0;
-	Elf32_Shdr const *shdrp = shdr0;
-	for (; 0 != nhdr; --nhdr, ++shdrp) {
-		if (has32_rel_mcount(shdrp, shdr0, shstrtab, fname))
-			totrelsz += w(shdrp->sh_size);
-	}
-	return totrelsz;
-}
-
-static unsigned tot64_relsize(Elf64_Shdr const *const shdr0,
-			      unsigned nhdr,
-			      const char *const shstrtab,
-			      const char *const fname)
-{
-	unsigned totrelsz = 0;
-	Elf64_Shdr const *shdrp = shdr0;
-
-	for (; nhdr; --nhdr, ++shdrp) {
-		if (has64_rel_mcount(shdrp, shdr0, shstrtab, fname))
-			totrelsz += w8(shdrp->sh_size);
-	}
-	return totrelsz;
-}
-
-/* Overall supervision for Elf32 ET_REL file. */
-static void
-do32(Elf32_Ehdr *const ehdr, char const *const fname, unsigned const reltype)
-{
-	Elf32_Shdr *const shdr0 = (Elf32_Shdr *)(w(ehdr->e_shoff)
-		+ (void *)ehdr);
-	unsigned const nhdr = w2(ehdr->e_shnum);
-	Elf32_Shdr *const shstr = &shdr0[w2(ehdr->e_shstrndx)];
-	char const *const shstrtab = (char const *)(w(shstr->sh_offset)
-		+ (void *)ehdr);
-
-	Elf32_Shdr const *relhdr;
-	unsigned k;
-
-	/* Upper bound on space: assume all relevant relocs are for mcount. */
-	unsigned const totrelsz = tot32_relsize(shdr0, nhdr, shstrtab, fname);
-	Elf32_Rel *const mrel0 = umalloc(totrelsz);
-	Elf32_Rel *      mrelp = mrel0;
-
-	/* 2*sizeof(address) <= sizeof(Elf32_Rel) */
-	uint32_t *const mloc0 = umalloc(totrelsz>>1);
-	uint32_t *      mlocp = mloc0;
-
-	unsigned rel_entsize = 0;
-	unsigned symsec_sh_link = 0;
-
-	for (relhdr = shdr0, k = nhdr; k; --k, ++relhdr) {
-		char const *const txtname = has32_rel_mcount(relhdr, shdr0,
-			shstrtab, fname);
-		if (txtname) {
-			uint32_t recval = 0;
-			unsigned const recsym = find32_secsym_ndx(
-				w(relhdr->sh_info), txtname, &recval,
-				&shdr0[symsec_sh_link = w(relhdr->sh_link)],
-				ehdr);
-
-			rel_entsize = w(relhdr->sh_entsize);
-			mlocp = sift32_rel_mcount(mlocp,
-				(void *)mlocp - (void *)mloc0, &mrelp,
-				relhdr, ehdr, recsym, recval, reltype);
-		}
-	}
-	if (mloc0 != mlocp) {
-		append32(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,
-			rel_entsize, symsec_sh_link);
-	}
-	free(mrel0);
-	free(mloc0);
-}
-
-static void
-do64(Elf64_Ehdr *const ehdr, char const *const fname, unsigned const reltype)
-{
-	Elf64_Shdr *const shdr0 = (Elf64_Shdr *)(w8(ehdr->e_shoff)
-		+ (void *)ehdr);
-	unsigned const nhdr = w2(ehdr->e_shnum);
-	Elf64_Shdr *const shstr = &shdr0[w2(ehdr->e_shstrndx)];
-	char const *const shstrtab = (char const *)(w8(shstr->sh_offset)
-		+ (void *)ehdr);
-
-	Elf64_Shdr const *relhdr;
-	unsigned k;
-
-	/* Upper bound on space: assume all relevant relocs are for mcount. */
-	unsigned const totrelsz = tot64_relsize(shdr0, nhdr, shstrtab, fname);
-	Elf64_Rel *const mrel0 = umalloc(totrelsz);
-	Elf64_Rel *      mrelp = mrel0;
-
-	/* 2*sizeof(address) <= sizeof(Elf64_Rel) */
-	uint64_t *const mloc0 = umalloc(totrelsz>>1);
-	uint64_t *      mlocp = mloc0;
-
-	unsigned rel_entsize = 0;
-	unsigned symsec_sh_link = 0;
-
-	for ((relhdr = shdr0), k = nhdr; k; --k, ++relhdr) {
-		char const *const txtname = has64_rel_mcount(relhdr, shdr0,
-			shstrtab, fname);
-		if (txtname) {
-			uint64_t recval = 0;
-			unsigned const recsym = find64_secsym_ndx(
-				w(relhdr->sh_info), txtname, &recval,
-				&shdr0[symsec_sh_link = w(relhdr->sh_link)],
-				ehdr);
-
-			rel_entsize = w8(relhdr->sh_entsize);
-			mlocp = sift64_rel_mcount(mlocp,
-				(void *)mlocp - (void *)mloc0, &mrelp,
-				relhdr, ehdr, recsym, recval, reltype);
-		}
-	}
-	if (mloc0 != mlocp) {
-		append64(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,
-			rel_entsize, symsec_sh_link);
-	}
-	free(mrel0);
-	free(mloc0);
-}
+/* 32 bit and 64 bit are very similar */
+#include "recordmcount.h"
+#define RECORD_MCOUNT_64
+#include "recordmcount.h"
 
 static void
 do_file(char const *const fname)

commit 81d3858d3131a589cade0d8b57f95cc1fc699b89
Author: John Reiser <jreiser@bitwagon.com>
Date:   Wed Oct 13 15:12:54 2010 -0400

    ftrace: Add C version of recordmcount compile time code
    
    Currently, the mcount callers are found with a perl script that does
    an objdump on every file in the kernel. This is a C version of that
    same code which should increase the performance time of compiling
    the kernel with dynamic ftrace enabled.
    
    Signed-off-by: John Reiser <jreiser@bitwagon.com>
    
    [ Updated the code to include .text.unlikely section as well as
      changing the format to follow Linux coding style. ]
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
new file mode 100644
index 000000000000..34f32be17090
--- /dev/null
+++ b/scripts/recordmcount.c
@@ -0,0 +1,885 @@
+/*
+ * recordmcount.c: construct a table of the locations of calls to 'mcount'
+ * so that ftrace can find them quickly.
+ * Copyright 2009 John F. Reiser <jreiser@BitWagon.com>.  All rights reserved.
+ * Licensed under the GNU General Public License, version 2 (GPLv2).
+ *
+ * Restructured to fit Linux format, as well as other updates:
+ *  Copyright 2010 Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.
+ */
+
+/*
+ * Strategy: alter the .o file in-place.
+ *
+ * Append a new STRTAB that has the new section names, followed by a new array
+ * ElfXX_Shdr[] that has the new section headers, followed by the section
+ * contents for __mcount_loc and its relocations.  The old shstrtab strings,
+ * and the old ElfXX_Shdr[] array, remain as "garbage" (commonly, a couple
+ * kilobytes.)  Subsequent processing by /bin/ld (or the kernel module loader)
+ * will ignore the garbage regions, because they are not designated by the
+ * new .e_shoff nor the new ElfXX_Shdr[].  [In order to remove the garbage,
+ * then use "ld -r" to create a new file that omits the garbage.]
+ */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <elf.h>
+#include <fcntl.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+static int fd_map;	/* File descriptor for file being modified. */
+static int mmap_failed; /* Boolean flag. */
+static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
+static char gpfx;	/* prefix for global symbol name (sometimes '_') */
+static struct stat sb;	/* Remember .st_size, etc. */
+static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
+
+/* setjmp() return values */
+enum {
+	SJ_SETJMP = 0,  /* hardwired first return */
+	SJ_FAIL,
+	SJ_SUCCEED
+};
+
+/* Per-file resource cleanup when multiple files. */
+static void
+cleanup(void)
+{
+	if (!mmap_failed)
+		munmap(ehdr_curr, sb.st_size);
+	else
+		free(ehdr_curr);
+	close(fd_map);
+}
+
+static void __attribute__((noreturn))
+fail_file(void)
+{
+	cleanup();
+	longjmp(jmpenv, SJ_FAIL);
+}
+
+static void __attribute__((noreturn))
+succeed_file(void)
+{
+	cleanup();
+	longjmp(jmpenv, SJ_SUCCEED);
+}
+
+/* ulseek, uread, ...:  Check return value for errors. */
+
+static off_t
+ulseek(int const fd, off_t const offset, int const whence)
+{
+	off_t const w = lseek(fd, offset, whence);
+	if ((off_t)-1 == w) {
+		perror("lseek");
+		fail_file();
+	}
+	return w;
+}
+
+static size_t
+uread(int const fd, void *const buf, size_t const count)
+{
+	size_t const n = read(fd, buf, count);
+	if (n != count) {
+		perror("read");
+		fail_file();
+	}
+	return n;
+}
+
+static size_t
+uwrite(int const fd, void const *const buf, size_t const count)
+{
+	size_t const n = write(fd, buf, count);
+	if (n != count) {
+		perror("write");
+		fail_file();
+	}
+	return n;
+}
+
+static void *
+umalloc(size_t size)
+{
+	void *const addr = malloc(size);
+	if (0 == addr) {
+		fprintf(stderr, "malloc failed: %zu bytes\n", size);
+		fail_file();
+	}
+	return addr;
+}
+
+/*
+ * Get the whole file as a programming convenience in order to avoid
+ * malloc+lseek+read+free of many pieces.  If successful, then mmap
+ * avoids copying unused pieces; else just read the whole file.
+ * Open for both read and write; new info will be appended to the file.
+ * Use MAP_PRIVATE so that a few changes to the in-memory ElfXX_Ehdr
+ * do not propagate to the file until an explicit overwrite at the last.
+ * This preserves most aspects of consistency (all except .st_size)
+ * for simultaneous readers of the file while we are appending to it.
+ * However, multiple writers still are bad.  We choose not to use
+ * locking because it is expensive and the use case of kernel build
+ * makes multiple writers unlikely.
+ */
+static void *mmap_file(char const *fname)
+{
+	void *addr;
+
+	fd_map = open(fname, O_RDWR);
+	if (0 > fd_map || 0 > fstat(fd_map, &sb)) {
+		perror(fname);
+		fail_file();
+	}
+	if (!S_ISREG(sb.st_mode)) {
+		fprintf(stderr, "not a regular file: %s\n", fname);
+		fail_file();
+	}
+	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,
+		    fd_map, 0);
+	mmap_failed = 0;
+	if (MAP_FAILED == addr) {
+		mmap_failed = 1;
+		addr = umalloc(sb.st_size);
+		uread(fd_map, addr, sb.st_size);
+	}
+	return addr;
+}
+
+/* w8rev, w8nat, ...: Handle endianness. */
+
+static uint64_t w8rev(uint64_t const x)
+{
+	return   ((0xff & (x >> (0 * 8))) << (7 * 8))
+	       | ((0xff & (x >> (1 * 8))) << (6 * 8))
+	       | ((0xff & (x >> (2 * 8))) << (5 * 8))
+	       | ((0xff & (x >> (3 * 8))) << (4 * 8))
+	       | ((0xff & (x >> (4 * 8))) << (3 * 8))
+	       | ((0xff & (x >> (5 * 8))) << (2 * 8))
+	       | ((0xff & (x >> (6 * 8))) << (1 * 8))
+	       | ((0xff & (x >> (7 * 8))) << (0 * 8));
+}
+
+static uint32_t w4rev(uint32_t const x)
+{
+	return   ((0xff & (x >> (0 * 8))) << (3 * 8))
+	       | ((0xff & (x >> (1 * 8))) << (2 * 8))
+	       | ((0xff & (x >> (2 * 8))) << (1 * 8))
+	       | ((0xff & (x >> (3 * 8))) << (0 * 8));
+}
+
+static uint32_t w2rev(uint16_t const x)
+{
+	return   ((0xff & (x >> (0 * 8))) << (1 * 8))
+	       | ((0xff & (x >> (1 * 8))) << (0 * 8));
+}
+
+static uint64_t w8nat(uint64_t const x)
+{
+	return x;
+}
+
+static uint32_t w4nat(uint32_t const x)
+{
+	return x;
+}
+
+static uint32_t w2nat(uint16_t const x)
+{
+	return x;
+}
+
+static uint64_t (*w8)(uint64_t);
+static uint32_t (*w)(uint32_t);
+static uint32_t (*w2)(uint16_t);
+
+/* Names of the sections that could contain calls to mcount. */
+static int
+is_mcounted_section_name(char const *const txtname)
+{
+	return 0 == strcmp(".text",          txtname) ||
+		0 == strcmp(".sched.text",    txtname) ||
+		0 == strcmp(".spinlock.text", txtname) ||
+		0 == strcmp(".irqentry.text", txtname) ||
+		0 == strcmp(".text.unlikely", txtname);
+}
+
+/* Append the new shstrtab, Elf32_Shdr[], __mcount_loc and its relocations. */
+static void append32(Elf32_Ehdr *const ehdr,
+		     Elf32_Shdr *const shstr,
+		     uint32_t const *const mloc0,
+		     uint32_t const *const mlocp,
+		     Elf32_Rel const *const mrel0,
+		     Elf32_Rel const *const mrelp,
+		     unsigned int const rel_entsize,
+		     unsigned int const symsec_sh_link)
+{
+	/* Begin constructing output file */
+	Elf32_Shdr mcsec;
+	char const *mc_name = (sizeof(Elf32_Rela) == rel_entsize)
+		? ".rela__mcount_loc"
+		:  ".rel__mcount_loc";
+	unsigned const old_shnum = w2(ehdr->e_shnum);
+	uint32_t const old_shoff = w(ehdr->e_shoff);
+	uint32_t const old_shstr_sh_size   = w(shstr->sh_size);
+	uint32_t const old_shstr_sh_offset = w(shstr->sh_offset);
+	uint32_t t = 1 + strlen(mc_name) + w(shstr->sh_size);
+	uint32_t new_e_shoff;
+
+	shstr->sh_size = w(t);
+	shstr->sh_offset = w(sb.st_size);
+	t += sb.st_size;
+	t += (3u & -t);  /* 4-byte align */
+	new_e_shoff = t;
+
+	/* body for new shstrtab */
+	ulseek(fd_map, sb.st_size, SEEK_SET);
+	uwrite(fd_map, old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size);
+	uwrite(fd_map, mc_name, 1 + strlen(mc_name));
+
+	/* old(modified) Elf32_Shdr table, 4-byte aligned */
+	ulseek(fd_map, t, SEEK_SET);
+	t += sizeof(Elf32_Shdr) * old_shnum;
+	uwrite(fd_map, old_shoff + (void *)ehdr,
+	       sizeof(Elf32_Shdr) * old_shnum);
+
+	/* new sections __mcount_loc and .rel__mcount_loc */
+	t += 2*sizeof(mcsec);
+	mcsec.sh_name = w((sizeof(Elf32_Rela) == rel_entsize) + strlen(".rel")
+		+ old_shstr_sh_size);
+	mcsec.sh_type = w(SHT_PROGBITS);
+	mcsec.sh_flags = w(SHF_ALLOC);
+	mcsec.sh_addr = 0;
+	mcsec.sh_offset = w(t);
+	mcsec.sh_size = w((void *)mlocp - (void *)mloc0);
+	mcsec.sh_link = 0;
+	mcsec.sh_info = 0;
+	mcsec.sh_addralign = w(4);
+	mcsec.sh_entsize = w(4);
+	uwrite(fd_map, &mcsec, sizeof(mcsec));
+
+	mcsec.sh_name = w(old_shstr_sh_size);
+	mcsec.sh_type = (sizeof(Elf32_Rela) == rel_entsize)
+		? w(SHT_RELA)
+		: w(SHT_REL);
+	mcsec.sh_flags = 0;
+	mcsec.sh_addr = 0;
+	mcsec.sh_offset = w((void *)mlocp - (void *)mloc0 + t);
+	mcsec.sh_size   = w((void *)mrelp - (void *)mrel0);
+	mcsec.sh_link = w(symsec_sh_link);
+	mcsec.sh_info = w(old_shnum);
+	mcsec.sh_addralign = w(4);
+	mcsec.sh_entsize = w(rel_entsize);
+	uwrite(fd_map, &mcsec, sizeof(mcsec));
+
+	uwrite(fd_map, mloc0, (void *)mlocp - (void *)mloc0);
+	uwrite(fd_map, mrel0, (void *)mrelp - (void *)mrel0);
+
+	ehdr->e_shoff = w(new_e_shoff);
+	ehdr->e_shnum = w2(2 + w2(ehdr->e_shnum));  /* {.rel,}__mcount_loc */
+	ulseek(fd_map, 0, SEEK_SET);
+	uwrite(fd_map, ehdr, sizeof(*ehdr));
+}
+
+/*
+ * append64 and append32 (and other analogous pairs) could be templated
+ * using C++, but the complexity is high.  (For an example, look at p_elf.h
+ * in the source for UPX, http://upx.sourceforge.net)  So: remember to make
+ * the corresponding change in the routine for the other size.
+ */
+static void append64(Elf64_Ehdr *const ehdr,
+		     Elf64_Shdr *const shstr,
+		     uint64_t const *const mloc0,
+		     uint64_t const *const mlocp,
+		     Elf64_Rel const *const mrel0,
+		     Elf64_Rel const *const mrelp,
+		     unsigned int const rel_entsize,
+		     unsigned int const symsec_sh_link)
+{
+	/* Begin constructing output file */
+	Elf64_Shdr mcsec;
+	char const *mc_name = (sizeof(Elf64_Rela) == rel_entsize)
+		? ".rela__mcount_loc"
+		:  ".rel__mcount_loc";
+	unsigned const old_shnum = w2(ehdr->e_shnum);
+	uint64_t const old_shoff = w8(ehdr->e_shoff);
+	uint64_t const old_shstr_sh_size   = w8(shstr->sh_size);
+	uint64_t const old_shstr_sh_offset = w8(shstr->sh_offset);
+	uint64_t t = 1 + strlen(mc_name) + w8(shstr->sh_size);
+	uint64_t new_e_shoff;
+
+	shstr->sh_size = w8(t);
+	shstr->sh_offset = w8(sb.st_size);
+	t += sb.st_size;
+	t += (7u & -t);  /* 8-byte align */
+	new_e_shoff = t;
+
+	/* body for new shstrtab */
+	ulseek(fd_map, sb.st_size, SEEK_SET);
+	uwrite(fd_map, old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size);
+	uwrite(fd_map, mc_name, 1 + strlen(mc_name));
+
+	/* old(modified) Elf64_Shdr table, 8-byte aligned */
+	ulseek(fd_map, t, SEEK_SET);
+	t += sizeof(Elf64_Shdr) * old_shnum;
+	uwrite(fd_map, old_shoff + (void *)ehdr,
+		sizeof(Elf64_Shdr) * old_shnum);
+
+	/* new sections __mcount_loc and .rel__mcount_loc */
+	t += 2*sizeof(mcsec);
+	mcsec.sh_name = w((sizeof(Elf64_Rela) == rel_entsize) + strlen(".rel")
+		+ old_shstr_sh_size);
+	mcsec.sh_type = w(SHT_PROGBITS);
+	mcsec.sh_flags = w8(SHF_ALLOC);
+	mcsec.sh_addr = 0;
+	mcsec.sh_offset = w8(t);
+	mcsec.sh_size = w8((void *)mlocp - (void *)mloc0);
+	mcsec.sh_link = 0;
+	mcsec.sh_info = 0;
+	mcsec.sh_addralign = w8(8);
+	mcsec.sh_entsize = w8(8);
+	uwrite(fd_map, &mcsec, sizeof(mcsec));
+
+	mcsec.sh_name = w(old_shstr_sh_size);
+	mcsec.sh_type = (sizeof(Elf64_Rela) == rel_entsize)
+		? w(SHT_RELA)
+		: w(SHT_REL);
+	mcsec.sh_flags = 0;
+	mcsec.sh_addr = 0;
+	mcsec.sh_offset = w8((void *)mlocp - (void *)mloc0 + t);
+	mcsec.sh_size   = w8((void *)mrelp - (void *)mrel0);
+	mcsec.sh_link = w(symsec_sh_link);
+	mcsec.sh_info = w(old_shnum);
+	mcsec.sh_addralign = w8(8);
+	mcsec.sh_entsize = w8(rel_entsize);
+	uwrite(fd_map, &mcsec, sizeof(mcsec));
+
+	uwrite(fd_map, mloc0, (void *)mlocp - (void *)mloc0);
+	uwrite(fd_map, mrel0, (void *)mrelp - (void *)mrel0);
+
+	ehdr->e_shoff = w8(new_e_shoff);
+	ehdr->e_shnum = w2(2 + w2(ehdr->e_shnum));  /* {.rel,}__mcount_loc */
+	ulseek(fd_map, 0, SEEK_SET);
+	uwrite(fd_map, ehdr, sizeof(*ehdr));
+}
+
+/*
+ * Look at the relocations in order to find the calls to mcount.
+ * Accumulate the section offsets that are found, and their relocation info,
+ * onto the end of the existing arrays.
+ */
+static uint32_t *sift32_rel_mcount(uint32_t *mlocp,
+				   unsigned const offbase,
+				   Elf32_Rel **const mrelpp,
+				   Elf32_Shdr const *const relhdr,
+				   Elf32_Ehdr const *const ehdr,
+				   unsigned const recsym,
+				   uint32_t const recval,
+				   unsigned const reltype)
+{
+	uint32_t *const mloc0 = mlocp;
+	Elf32_Rel *mrelp = *mrelpp;
+	Elf32_Shdr *const shdr0 = (Elf32_Shdr *)(w(ehdr->e_shoff)
+		+ (void *)ehdr);
+	unsigned const symsec_sh_link = w(relhdr->sh_link);
+	Elf32_Shdr const *const symsec = &shdr0[symsec_sh_link];
+	Elf32_Sym const *const sym0 = (Elf32_Sym const *)(w(symsec->sh_offset)
+		+ (void *)ehdr);
+
+	Elf32_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];
+	char const *const str0 = (char const *)(w(strsec->sh_offset)
+		+ (void *)ehdr);
+
+	Elf32_Rel const *const rel0 = (Elf32_Rel const *)(w(relhdr->sh_offset)
+		+ (void *)ehdr);
+	unsigned rel_entsize = w(relhdr->sh_entsize);
+	unsigned const nrel = w(relhdr->sh_size) / rel_entsize;
+	Elf32_Rel const *relp = rel0;
+
+	unsigned mcountsym = 0;
+	unsigned t;
+
+	for (t = nrel; t; --t) {
+		if (!mcountsym) {
+			Elf32_Sym const *const symp =
+				&sym0[ELF32_R_SYM(w(relp->r_info))];
+
+			if (0 == strcmp((('_' == gpfx) ? "_mcount" : "mcount"),
+					&str0[w(symp->st_name)]))
+				mcountsym = ELF32_R_SYM(w(relp->r_info));
+		}
+		if (mcountsym == ELF32_R_SYM(w(relp->r_info))) {
+			uint32_t const addend = w(w(relp->r_offset) - recval);
+			mrelp->r_offset = w(offbase
+				+ ((void *)mlocp - (void *)mloc0));
+			mrelp->r_info = w(ELF32_R_INFO(recsym, reltype));
+			if (sizeof(Elf32_Rela) == rel_entsize) {
+				((Elf32_Rela *)mrelp)->r_addend = addend;
+				*mlocp++ = 0;
+			} else
+				*mlocp++ = addend;
+
+			mrelp = (Elf32_Rel *)(rel_entsize + (void *)mrelp);
+		}
+		relp = (Elf32_Rel const *)(rel_entsize + (void *)relp);
+	}
+	*mrelpp = mrelp;
+	return mlocp;
+}
+
+static uint64_t *sift64_rel_mcount(uint64_t *mlocp,
+				   unsigned const offbase,
+				   Elf64_Rel **const mrelpp,
+				   Elf64_Shdr const *const relhdr,
+				   Elf64_Ehdr const *const ehdr,
+				   unsigned const recsym,
+				   uint64_t const recval,
+				   unsigned const reltype)
+{
+	uint64_t *const mloc0 = mlocp;
+	Elf64_Rel *mrelp = *mrelpp;
+	Elf64_Shdr *const shdr0 = (Elf64_Shdr *)(w8(ehdr->e_shoff)
+		+ (void *)ehdr);
+	unsigned const symsec_sh_link = w(relhdr->sh_link);
+	Elf64_Shdr const *const symsec = &shdr0[symsec_sh_link];
+	Elf64_Sym const *const sym0 = (Elf64_Sym const *)(w8(symsec->sh_offset)
+		+ (void *)ehdr);
+
+	Elf64_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];
+	char const *const str0 = (char const *)(w8(strsec->sh_offset)
+		+ (void *)ehdr);
+
+	Elf64_Rel const *const rel0 = (Elf64_Rel const *)(w8(relhdr->sh_offset)
+		+ (void *)ehdr);
+	unsigned rel_entsize = w8(relhdr->sh_entsize);
+	unsigned const nrel = w8(relhdr->sh_size) / rel_entsize;
+	Elf64_Rel const *relp = rel0;
+
+	unsigned mcountsym = 0;
+	unsigned t;
+
+	for (t = nrel; 0 != t; --t) {
+		if (!mcountsym) {
+			Elf64_Sym const *const symp =
+				&sym0[ELF64_R_SYM(w8(relp->r_info))];
+			char const *symname = &str0[w(symp->st_name)];
+
+			if ('.' == symname[0])
+				++symname;  /* ppc64 hack */
+			if (0 == strcmp((('_' == gpfx) ? "_mcount" : "mcount"),
+					symname))
+				mcountsym = ELF64_R_SYM(w8(relp->r_info));
+		}
+
+		if (mcountsym == ELF64_R_SYM(w8(relp->r_info))) {
+			uint64_t const addend = w8(w8(relp->r_offset) - recval);
+
+			mrelp->r_offset = w8(offbase
+				+ ((void *)mlocp - (void *)mloc0));
+			mrelp->r_info = w8(ELF64_R_INFO(recsym, reltype));
+			if (sizeof(Elf64_Rela) == rel_entsize) {
+				((Elf64_Rela *)mrelp)->r_addend = addend;
+				*mlocp++ = 0;
+			} else
+				*mlocp++ = addend;
+
+			mrelp = (Elf64_Rel *)(rel_entsize + (void *)mrelp);
+		}
+		relp = (Elf64_Rel const *)(rel_entsize + (void *)relp);
+	}
+	*mrelpp = mrelp;
+
+	return mlocp;
+}
+
+/*
+ * Find a symbol in the given section, to be used as the base for relocating
+ * the table of offsets of calls to mcount.  A local or global symbol suffices,
+ * but avoid a Weak symbol because it may be overridden; the change in value
+ * would invalidate the relocations of the offsets of the calls to mcount.
+ * Often the found symbol will be the unnamed local symbol generated by
+ * GNU 'as' for the start of each section.  For example:
+ *    Num:    Value  Size Type    Bind   Vis      Ndx Name
+ *      2: 00000000     0 SECTION LOCAL  DEFAULT    1
+ */
+static unsigned find32_secsym_ndx(unsigned const txtndx,
+				  char const *const txtname,
+				  uint32_t *const recvalp,
+				  Elf32_Shdr const *const symhdr,
+				  Elf32_Ehdr const *const ehdr)
+{
+	Elf32_Sym const *const sym0 = (Elf32_Sym const *)(w(symhdr->sh_offset)
+		+ (void *)ehdr);
+	unsigned const nsym = w(symhdr->sh_size) / w(symhdr->sh_entsize);
+	Elf32_Sym const *symp;
+	unsigned t;
+
+	for (symp = sym0, t = nsym; t; --t, ++symp) {
+		unsigned int const st_bind = ELF32_ST_BIND(symp->st_info);
+
+		if (txtndx == w2(symp->st_shndx)
+			/* avoid STB_WEAK */
+		    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {
+			*recvalp = w(symp->st_value);
+			return symp - sym0;
+		}
+	}
+	fprintf(stderr, "Cannot find symbol for section %d: %s.\n",
+		txtndx, txtname);
+	fail_file();
+}
+
+static unsigned find64_secsym_ndx(unsigned const txtndx,
+				  char const *const txtname,
+				  uint64_t *const recvalp,
+				  Elf64_Shdr const *const symhdr,
+				  Elf64_Ehdr const *const ehdr)
+{
+	Elf64_Sym const *const sym0 = (Elf64_Sym const *)(w8(symhdr->sh_offset)
+		+ (void *)ehdr);
+	unsigned const nsym = w8(symhdr->sh_size) / w8(symhdr->sh_entsize);
+	Elf64_Sym const *symp;
+	unsigned t;
+
+	for (symp = sym0, t = nsym; t; --t, ++symp) {
+		unsigned int const st_bind = ELF64_ST_BIND(symp->st_info);
+
+		if (txtndx == w2(symp->st_shndx)
+			/* avoid STB_WEAK */
+		    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {
+			*recvalp = w8(symp->st_value);
+			return symp - sym0;
+		}
+	}
+	fprintf(stderr, "Cannot find symbol for section %d: %s.\n",
+		txtndx, txtname);
+	fail_file();
+}
+
+/*
+ * Evade ISO C restriction: no declaration after statement in
+ * has32_rel_mcount.
+ */
+static char const *
+__has32_rel_mcount(Elf32_Shdr const *const relhdr,  /* is SHT_REL or SHT_RELA */
+		   Elf32_Shdr const *const shdr0,
+		   char const *const shstrtab,
+		   char const *const fname)
+{
+	/* .sh_info depends on .sh_type == SHT_REL[,A] */
+	Elf32_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];
+	char const *const txtname = &shstrtab[w(txthdr->sh_name)];
+
+	if (0 == strcmp("__mcount_loc", txtname)) {
+		fprintf(stderr, "warning: __mcount_loc already exists: %s\n",
+			fname);
+		succeed_file();
+	}
+	if (SHT_PROGBITS != w(txthdr->sh_type) ||
+	    !is_mcounted_section_name(txtname))
+		return NULL;
+	return txtname;
+}
+
+static char const *has32_rel_mcount(Elf32_Shdr const *const relhdr,
+				    Elf32_Shdr const *const shdr0,
+				    char const *const shstrtab,
+				    char const *const fname)
+{
+	if (SHT_REL  != w(relhdr->sh_type) && SHT_RELA != w(relhdr->sh_type))
+		return NULL;
+	return __has32_rel_mcount(relhdr, shdr0, shstrtab, fname);
+}
+
+static char const *__has64_rel_mcount(Elf64_Shdr const *const relhdr,
+				      Elf64_Shdr const *const shdr0,
+				      char const *const shstrtab,
+				      char const *const fname)
+{
+	/* .sh_info depends on .sh_type == SHT_REL[,A] */
+	Elf64_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];
+	char const *const txtname = &shstrtab[w(txthdr->sh_name)];
+
+	if (0 == strcmp("__mcount_loc", txtname)) {
+		fprintf(stderr, "warning: __mcount_loc already exists: %s\n",
+			fname);
+		succeed_file();
+	}
+	if (SHT_PROGBITS != w(txthdr->sh_type) ||
+	    !is_mcounted_section_name(txtname))
+		return NULL;
+	return txtname;
+}
+
+static char const *has64_rel_mcount(Elf64_Shdr const *const relhdr,
+				    Elf64_Shdr const *const shdr0,
+				    char const *const shstrtab,
+				    char const *const fname)
+{
+	if (SHT_REL  != w(relhdr->sh_type) && SHT_RELA != w(relhdr->sh_type))
+		return NULL;
+	return __has64_rel_mcount(relhdr, shdr0, shstrtab, fname);
+}
+
+static unsigned tot32_relsize(Elf32_Shdr const *const shdr0,
+			      unsigned nhdr,
+			      const char *const shstrtab,
+			      const char *const fname)
+{
+	unsigned totrelsz = 0;
+	Elf32_Shdr const *shdrp = shdr0;
+	for (; 0 != nhdr; --nhdr, ++shdrp) {
+		if (has32_rel_mcount(shdrp, shdr0, shstrtab, fname))
+			totrelsz += w(shdrp->sh_size);
+	}
+	return totrelsz;
+}
+
+static unsigned tot64_relsize(Elf64_Shdr const *const shdr0,
+			      unsigned nhdr,
+			      const char *const shstrtab,
+			      const char *const fname)
+{
+	unsigned totrelsz = 0;
+	Elf64_Shdr const *shdrp = shdr0;
+
+	for (; nhdr; --nhdr, ++shdrp) {
+		if (has64_rel_mcount(shdrp, shdr0, shstrtab, fname))
+			totrelsz += w8(shdrp->sh_size);
+	}
+	return totrelsz;
+}
+
+/* Overall supervision for Elf32 ET_REL file. */
+static void
+do32(Elf32_Ehdr *const ehdr, char const *const fname, unsigned const reltype)
+{
+	Elf32_Shdr *const shdr0 = (Elf32_Shdr *)(w(ehdr->e_shoff)
+		+ (void *)ehdr);
+	unsigned const nhdr = w2(ehdr->e_shnum);
+	Elf32_Shdr *const shstr = &shdr0[w2(ehdr->e_shstrndx)];
+	char const *const shstrtab = (char const *)(w(shstr->sh_offset)
+		+ (void *)ehdr);
+
+	Elf32_Shdr const *relhdr;
+	unsigned k;
+
+	/* Upper bound on space: assume all relevant relocs are for mcount. */
+	unsigned const totrelsz = tot32_relsize(shdr0, nhdr, shstrtab, fname);
+	Elf32_Rel *const mrel0 = umalloc(totrelsz);
+	Elf32_Rel *      mrelp = mrel0;
+
+	/* 2*sizeof(address) <= sizeof(Elf32_Rel) */
+	uint32_t *const mloc0 = umalloc(totrelsz>>1);
+	uint32_t *      mlocp = mloc0;
+
+	unsigned rel_entsize = 0;
+	unsigned symsec_sh_link = 0;
+
+	for (relhdr = shdr0, k = nhdr; k; --k, ++relhdr) {
+		char const *const txtname = has32_rel_mcount(relhdr, shdr0,
+			shstrtab, fname);
+		if (txtname) {
+			uint32_t recval = 0;
+			unsigned const recsym = find32_secsym_ndx(
+				w(relhdr->sh_info), txtname, &recval,
+				&shdr0[symsec_sh_link = w(relhdr->sh_link)],
+				ehdr);
+
+			rel_entsize = w(relhdr->sh_entsize);
+			mlocp = sift32_rel_mcount(mlocp,
+				(void *)mlocp - (void *)mloc0, &mrelp,
+				relhdr, ehdr, recsym, recval, reltype);
+		}
+	}
+	if (mloc0 != mlocp) {
+		append32(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,
+			rel_entsize, symsec_sh_link);
+	}
+	free(mrel0);
+	free(mloc0);
+}
+
+static void
+do64(Elf64_Ehdr *const ehdr, char const *const fname, unsigned const reltype)
+{
+	Elf64_Shdr *const shdr0 = (Elf64_Shdr *)(w8(ehdr->e_shoff)
+		+ (void *)ehdr);
+	unsigned const nhdr = w2(ehdr->e_shnum);
+	Elf64_Shdr *const shstr = &shdr0[w2(ehdr->e_shstrndx)];
+	char const *const shstrtab = (char const *)(w8(shstr->sh_offset)
+		+ (void *)ehdr);
+
+	Elf64_Shdr const *relhdr;
+	unsigned k;
+
+	/* Upper bound on space: assume all relevant relocs are for mcount. */
+	unsigned const totrelsz = tot64_relsize(shdr0, nhdr, shstrtab, fname);
+	Elf64_Rel *const mrel0 = umalloc(totrelsz);
+	Elf64_Rel *      mrelp = mrel0;
+
+	/* 2*sizeof(address) <= sizeof(Elf64_Rel) */
+	uint64_t *const mloc0 = umalloc(totrelsz>>1);
+	uint64_t *      mlocp = mloc0;
+
+	unsigned rel_entsize = 0;
+	unsigned symsec_sh_link = 0;
+
+	for ((relhdr = shdr0), k = nhdr; k; --k, ++relhdr) {
+		char const *const txtname = has64_rel_mcount(relhdr, shdr0,
+			shstrtab, fname);
+		if (txtname) {
+			uint64_t recval = 0;
+			unsigned const recsym = find64_secsym_ndx(
+				w(relhdr->sh_info), txtname, &recval,
+				&shdr0[symsec_sh_link = w(relhdr->sh_link)],
+				ehdr);
+
+			rel_entsize = w8(relhdr->sh_entsize);
+			mlocp = sift64_rel_mcount(mlocp,
+				(void *)mlocp - (void *)mloc0, &mrelp,
+				relhdr, ehdr, recsym, recval, reltype);
+		}
+	}
+	if (mloc0 != mlocp) {
+		append64(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,
+			rel_entsize, symsec_sh_link);
+	}
+	free(mrel0);
+	free(mloc0);
+}
+
+static void
+do_file(char const *const fname)
+{
+	Elf32_Ehdr *const ehdr = mmap_file(fname);
+	unsigned int reltype = 0;
+
+	ehdr_curr = ehdr;
+	w = w4nat;
+	w2 = w2nat;
+	w8 = w8nat;
+	switch (ehdr->e_ident[EI_DATA]) {
+		static unsigned int const endian = 1;
+	default: {
+		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
+			ehdr->e_ident[EI_DATA], fname);
+		fail_file();
+	} break;
+	case ELFDATA2LSB: {
+		if (1 != *(unsigned char const *)&endian) {
+			/* main() is big endian, file.o is little endian. */
+			w = w4rev;
+			w2 = w2rev;
+			w8 = w8rev;
+		}
+	} break;
+	case ELFDATA2MSB: {
+		if (0 != *(unsigned char const *)&endian) {
+			/* main() is little endian, file.o is big endian. */
+			w = w4rev;
+			w2 = w2rev;
+			w8 = w8rev;
+		}
+	} break;
+	}  /* end switch */
+	if (0 != memcmp(ELFMAG, ehdr->e_ident, SELFMAG)
+	||  ET_REL != w2(ehdr->e_type)
+	||  EV_CURRENT != ehdr->e_ident[EI_VERSION]) {
+		fprintf(stderr, "unrecognized ET_REL file %s\n", fname);
+		fail_file();
+	}
+
+	gpfx = 0;
+	switch (w2(ehdr->e_machine)) {
+	default: {
+		fprintf(stderr, "unrecognized e_machine %d %s\n",
+			w2(ehdr->e_machine), fname);
+		fail_file();
+	} break;
+	case EM_386:	 reltype = R_386_32;                   break;
+	case EM_ARM:	 reltype = R_ARM_ABS32;                break;
+	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = '_'; break;
+	case EM_PPC:	 reltype = R_PPC_ADDR32;   gpfx = '_'; break;
+	case EM_PPC64:	 reltype = R_PPC64_ADDR64; gpfx = '_'; break;
+	case EM_S390:    /* reltype: e_class    */ gpfx = '_'; break;
+	case EM_SH:	 reltype = R_SH_DIR32;                 break;
+	case EM_SPARCV9: reltype = R_SPARC_64;     gpfx = '_'; break;
+	case EM_X86_64:	 reltype = R_X86_64_64;                break;
+	}  /* end switch */
+
+	switch (ehdr->e_ident[EI_CLASS]) {
+	default: {
+		fprintf(stderr, "unrecognized ELF class %d %s\n",
+			ehdr->e_ident[EI_CLASS], fname);
+		fail_file();
+	} break;
+	case ELFCLASS32: {
+		if (sizeof(Elf32_Ehdr) != w2(ehdr->e_ehsize)
+		||  sizeof(Elf32_Shdr) != w2(ehdr->e_shentsize)) {
+			fprintf(stderr,
+				"unrecognized ET_REL file: %s\n", fname);
+			fail_file();
+		}
+		if (EM_S390 == w2(ehdr->e_machine))
+			reltype = R_390_32;
+		do32(ehdr, fname, reltype);
+	} break;
+	case ELFCLASS64: {
+		Elf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;
+		if (sizeof(Elf64_Ehdr) != w2(ghdr->e_ehsize)
+		||  sizeof(Elf64_Shdr) != w2(ghdr->e_shentsize)) {
+			fprintf(stderr,
+				"unrecognized ET_REL file: %s\n", fname);
+			fail_file();
+		}
+		if (EM_S390 == w2(ghdr->e_machine))
+			reltype = R_390_64;
+		do64(ghdr, fname, reltype);
+	} break;
+	}  /* end switch */
+
+	cleanup();
+}
+
+int
+main(int argc, char const *argv[])
+{
+	int n_error = 0;  /* gcc-4.3.0 false positive complaint */
+	if (argc <= 1)
+		fprintf(stderr, "usage: recordmcount file.o...\n");
+	else  /* Process each file in turn, allowing deep failure. */
+	for (--argc, ++argv; 0 < argc; --argc, ++argv) {
+		int const sjval = setjmp(jmpenv);
+		switch (sjval) {
+		default: {
+			fprintf(stderr, "internal error: %s\n", argv[0]);
+			exit(1);
+		} break;
+		case SJ_SETJMP: {  /* normal sequence */
+			/* Avoid problems if early cleanup() */
+			fd_map = -1;
+			ehdr_curr = NULL;
+			mmap_failed = 1;
+			do_file(argv[0]);
+		} break;
+		case SJ_FAIL: {  /* error in do_file or below */
+			++n_error;
+		} break;
+		case SJ_SUCCEED: {  /* premature success */
+			/* do nothing */
+		} break;
+		}  /* end switch */
+	}
+	return !!n_error;
+}
+
+
