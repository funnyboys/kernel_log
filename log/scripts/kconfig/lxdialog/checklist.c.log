commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 2e96323ad11b..fd161cfff121 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  checklist.c -- implements the checklist box
  *
@@ -5,20 +6,6 @@
  *     Stuart Herbert - S.Herbert@sheffield.ac.uk: radiolist extension
  *     Alessandro Rubini - rubini@ipvvis.unipv.it: merged the two
  *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "dialog.h"

commit 694c49a7c01cc87194be40cb26404b58b68c291c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue May 22 21:36:12 2018 +0200

    kconfig: drop localization support
    
    The localization support is broken and appears unused.
    There is no google hits on the update-po-config target.
    And there is no recent (5 years) activity related to the localization.
    
    So lets just drop this as it is no longer used.
    
    Suggested-by: Ulf Magnusson <ulfalizer@gmail.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 8d016faa28d7..2e96323ad11b 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -103,8 +103,8 @@ static void print_buttons(WINDOW * dialog, int height, int width, int selected)
 	int x = width / 2 - 11;
 	int y = height - 2;
 
-	print_button(dialog, gettext("Select"), y, x, selected == 0);
-	print_button(dialog, gettext(" Help "), y, x + 14, selected == 1);
+	print_button(dialog, "Select", y, x, selected == 0);
+	print_button(dialog, " Help ", y, x + 14, selected == 1);
 
 	wmove(dialog, y, x + 1 + 14 * selected);
 	wrefresh(dialog);

commit bb66fc67192bbd406fe9c22033f1bbbf3e7ec621
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jun 10 19:08:13 2014 +0900

    kbuild: trivial - use tabs for code indent where possible
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 3b15c08ec1fa..8d016faa28d7 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -168,13 +168,13 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	/* create new window for the list */
 	list = subwin(dialog, list_height, list_width, y + box_y + 1,
-	              x + box_x + 1);
+		      x + box_x + 1);
 
 	keypad(list, TRUE);
 
 	/* draw a box around the list items */
 	draw_box(dialog, box_y, box_x, list_height + 2, list_width + 2,
-	         dlg.menubox_border.atr, dlg.menubox.atr);
+		 dlg.menubox_border.atr, dlg.menubox.atr);
 
 	/* Find length of longest item in order to center checklist */
 	check_x = 0;

commit 4f2de3e19983dafca264b672152b36e4962ca1c3
Author: Dirk Gouders <dirk@gouders.net>
Date:   Sun May 12 12:30:49 2013 +0200

    mconf: use function calls instead of ncurses' variables LINES and COLS
    
    According to the documentation [1], LINES and COLS are initialized by
    initscr(); it does not say anything about the behavior when windows are
    resized.
    
    Do not rely on the current implementation of ncurses that updates
    these variables on resize, but use the propper function calls to get
    window dimensions.
    
    init_dialog() could make use of the variables, but for the sake of
    consistency we do not change it's current use of the macro getmaxyx().
    
    [1] ncurses(3X)
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Yann E. MORIN <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 30340571190e..3b15c08ec1fa 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -140,8 +140,8 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	max_choice = MIN(list_height, item_count());
 
 	/* center dialog box on screen */
-	x = (COLS - width) / 2;
-	y = (LINES - height) / 2;
+	x = (getmaxx(stdscr) - width) / 2;
+	y = (getmaxy(stdscr) - height) / 2;
 
 	draw_shadow(stdscr, y, x, height, width);
 

commit 851f665725581d02d48ffbca50240cda44d698d4
Author: Sedat Dilek <sedat.dilek@gmail.com>
Date:   Sat Jun 15 11:07:35 2013 +0200

    kconfig/lxdialog: Add definitions for mininimum (re)size values
    
    Commit c8dc68ad0fbd ("kconfig/lxdialog: support resize") added support
    for resizing, but forgot to collect all hardcoded values at one single
    place.
    
    Also add a definition for the check for a minimum screen/window size
    of 80x19.
    
    [ ChangeLog v3:
      * Rename MENU_{HEIGTH,WIDTH}_MIN -> MENUBOX_{HEIGTH,WIDTH}_MIN
      ChangeLog v2:
      * Rename WIN_{HEIGTH,WIDTH}_MIN -> WINDOW_{HEIGTH,WIDTH}_MIN
      * Mention the check for a minimum screen/window size in the changelog
      * Add a comment above the block of new definitions ]
    
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>
    Acked-by: Wang YanQing <udknight@gmail.com>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index a2eb80fbc896..30340571190e 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -132,9 +132,9 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	}
 
 do_resize:
-	if (getmaxy(stdscr) < (height + 6))
+	if (getmaxy(stdscr) < (height + CHECKLIST_HEIGTH_MIN))
 		return -ERRDISPLAYTOOSMALL;
-	if (getmaxx(stdscr) < (width + 6))
+	if (getmaxx(stdscr) < (width + CHECKLIST_WIDTH_MIN))
 		return -ERRDISPLAYTOOSMALL;
 
 	max_choice = MIN(list_height, item_count());

commit e7401d8321f89a3785a395ba307c720e2b390f96
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu Jun 3 15:24:57 2010 +0800

    menuconfig: truncate list items
    
    Truncate list items to fit in a single line, otherwise those items
    which have long prompts will cover some other items.
    
    This follows the behavior of menubox.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index c92a05a2de17..a2eb80fbc896 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -31,6 +31,10 @@ static int list_width, check_x, item_x;
 static void print_item(WINDOW * win, int choice, int selected)
 {
 	int i;
+	char *list_item = malloc(list_width + 1);
+
+	strncpy(list_item, item_str(), list_width - item_x);
+	list_item[list_width - item_x] = '\0';
 
 	/* Clear 'residue' of last item */
 	wattrset(win, dlg.menubox.atr);
@@ -45,13 +49,14 @@ static void print_item(WINDOW * win, int choice, int selected)
 		wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');
 
 	wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
-	mvwaddch(win, choice, item_x, item_str()[0]);
+	mvwaddch(win, choice, item_x, list_item[0]);
 	wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
-	waddstr(win, (char *)item_str() + 1);
+	waddstr(win, list_item + 1);
 	if (selected) {
 		wmove(win, choice, check_x + 1);
 		wrefresh(win);
 	}
+	free(list_item);
 }
 
 /*

commit 42ef223c4a0f6e34e13ccb503b423ebdc04878e1
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu Jun 3 15:24:39 2010 +0800

    menuconfig: fix to center checklist correctly in a corner case
    
    Run:
            make ARCH=arm menuconfig
    
    And then select "System Type" -> "ARM system type". The kconfig
    "choice" menu at this point looks empty.
    
    It's because config ARCH_S3C2410 has a long prompt:
    
    config ARCH_S3C2410
            bool "Samsung S3C2410, S3C2412, S3C2413, S3C2416, S3C2440, S3C2442, S3C2443, S3C2450"
            ...
    
    menuconfig centers the checklist according to this prompt without
    considering the width of the list, and then things get wrong.
    
    Reported-by: Nobin Mathew <nobin.mathew@gmail.com>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index bcc6f19c3a35..c92a05a2de17 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -175,6 +175,7 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	check_x = 0;
 	item_foreach()
 		check_x = MAX(check_x, strlen(item_str()) + 4);
+	check_x = MIN(check_x, list_width);
 
 	check_x = (list_width - check_x) / 2;
 	item_x = check_x + 4;

commit af6c159885537eb6582a61156ccfb73e83c0478d
Author: Peter Korsgaard <jacmet@sunsite.dk>
Date:   Sun Feb 15 22:15:16 2009 +0100

    kconfig: handle comment entries within choice/endchoice
    
    Implement support for comment entries within choice groups. Comment entries
    are displayed visually distinct from normal configs, and selecting them is
    a no-op.
    
    Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index b2a878c936d6..bcc6f19c3a35 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -41,7 +41,8 @@ static void print_item(WINDOW * win, int choice, int selected)
 	wmove(win, choice, check_x);
 	wattrset(win, selected ? dlg.check_selected.atr
 		 : dlg.check.atr);
-	wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');
+	if (!item_is_tag(':'))
+		wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');
 
 	wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
 	mvwaddch(win, choice, item_x, item_str()[0]);

commit 75c0a8a55c31c0a21f7e9e64bc45e87e228a98f6
Author: EGRY Gabor <gaboregry1@t-online.hu>
Date:   Fri Jan 11 23:42:54 2008 +0100

    kconfig: gettext support for lxdialog
    
    Gettext support for lxdialog.
    
    Signed-off-by: Egry Gabor <gaboregry1@t-online.hu>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index cf697080dddd..b2a878c936d6 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -97,8 +97,8 @@ static void print_buttons(WINDOW * dialog, int height, int width, int selected)
 	int x = width / 2 - 11;
 	int y = height - 2;
 
-	print_button(dialog, "Select", y, x, selected == 0);
-	print_button(dialog, " Help ", y, x + 14, selected == 1);
+	print_button(dialog, gettext("Select"), y, x, selected == 0);
+	print_button(dialog, gettext(" Help "), y, x + 14, selected == 1);
 
 	wmove(dialog, y, x + 1 + 14 * selected);
 	wrefresh(dialog);

commit c8dc68ad0fbd934e78e913b8a8d7b45945db4930
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jul 29 22:48:57 2006 +0200

    kconfig/lxdialog: support resize
    
    In all dialogs now properly catch KEY_RESIZE and take proper action.
    In mconf try to behave sensibly when a dialog routine returns
    -ERRDISPLAYTOOSMALL.
    
    The original check for a screnn size of 80x19 is kept for now.
    It may make sense to remove it later, but thats anyway what
    much text is adjusted for.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 39becb72444a..cf697080dddd 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -125,6 +125,12 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 		}
 	}
 
+do_resize:
+	if (getmaxy(stdscr) < (height + 6))
+		return -ERRDISPLAYTOOSMALL;
+	if (getmaxx(stdscr) < (width + 6))
+		return -ERRDISPLAYTOOSMALL;
+
 	max_choice = MIN(list_height, item_count());
 
 	/* center dialog box on screen */
@@ -303,6 +309,11 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 		case KEY_ESC:
 			key = on_key_esc(dialog);
 			break;
+		case KEY_RESIZE:
+			delwin(list);
+			delwin(dialog);
+			on_key_resize();
+			goto do_resize;
 		}
 
 		/* Now, update everything... */

commit f3cbcdc955d0d2c8b4c52d6b73fc536b01b68c64
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Jul 28 23:57:48 2006 +0200

    kconfig/lxdialog: let <ESC><ESC> behave as expected
    
    <ESC><ESC> is used to step one back in the dialogs.
    When lxdialog became built-in pressing <ESC> once would cause one step back
    and pressing <ESC><ESC> would cause two steps back.
    This patch - based on concept from Roman Zippel <zippel@linux-m68k.org> -
    makes one <ESC> a noop and pressing <ESC><ESC> will cause one step backward.
    
    In addition the final yes/no dialog now has the option to go back to the
    the kernel configuration. So if you get too far out you can now go back
    to configuring the kernel without saving and starting all over again.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 282511020bcb..39becb72444a 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -192,7 +192,7 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	wnoutrefresh(list);
 	doupdate();
 
-	while (key != ESC) {
+	while (key != KEY_ESC) {
 		key = wgetch(dialog);
 
 		for (i = 0; i < max_choice; i++) {
@@ -298,8 +298,10 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 			break;
 		case 'X':
 		case 'x':
-			key = ESC;
-		case ESC:
+			key = KEY_ESC;
+			break;
+		case KEY_ESC:
+			key = on_key_esc(dialog);
 			break;
 		}
 
@@ -308,5 +310,5 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	}
 	delwin(list);
 	delwin(dialog);
-	return 255;		/* ESC pressed */
+	return key;		/* ESC pressed */
 }

commit 2982de6993e6d9944f2215d7cb9b558b465a0c99
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Thu Jul 27 22:10:27 2006 +0200

    kconfig/menuconfig: lxdialog is now built-in
    
    lxdialog was previously called as an external program causing screen
    to flicker when used. With this patch lxdialog is now built-in.
    It is loosly based om previous work by:  Petr Baudis <pasky@ucw.cz>
    
    Following is a list of changes:
    o Moved build of dialog routings to kconfig Makefile
    o menubox + checklist uses a new item list to hold all menu items
    o in util.c implmented helper function to deal with item list
    o menubox now uses parameters to save scroll state (avoids temp file)
    o textbox now get text to be displayed as parameter and not a file
    o make sure to properly delete subwin's before main windows
    o killed unused files: lxdialog.c msgbox.c
    o modified return value for ESC to match direct calling
    o in a few places the code has been adjusted to 80 char wide
    o in textbox a small refactoring was made to make code remotely readable
    o in mconf removed all unused stuff (functions/variables)
    
    Following is a list of know short comings:
    a) pressing ESC twice will be interpreted as two ESC presses
    b) resize does not work. menuconfig needs to be restarted to be adjusted
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index b90e888a2bc0..282511020bcb 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -28,8 +28,7 @@ static int list_width, check_x, item_x;
 /*
  * Print list item
  */
-static void print_item(WINDOW * win, const char *item, int status, int choice,
-		       int selected)
+static void print_item(WINDOW * win, int choice, int selected)
 {
 	int i;
 
@@ -42,12 +41,12 @@ static void print_item(WINDOW * win, const char *item, int status, int choice,
 	wmove(win, choice, check_x);
 	wattrset(win, selected ? dlg.check_selected.atr
 		 : dlg.check.atr);
-	wprintw(win, "(%c)", status ? 'X' : ' ');
+	wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');
 
 	wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
-	mvwaddch(win, choice, item_x, item[0]);
+	mvwaddch(win, choice, item_x, item_str()[0]);
 	wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
-	waddstr(win, (char *)item + 1);
+	waddstr(win, (char *)item_str() + 1);
 	if (selected) {
 		wmove(win, choice, check_x + 1);
 		wrefresh(win);
@@ -110,32 +109,23 @@ static void print_buttons(WINDOW * dialog, int height, int width, int selected)
  * in the style of radiolist (only one option turned on at a time).
  */
 int dialog_checklist(const char *title, const char *prompt, int height,
-		     int width, int list_height, int item_no,
-		     const char *const *items)
+		     int width, int list_height)
 {
 	int i, x, y, box_x, box_y;
-	int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
+	int key = 0, button = 0, choice = 0, scroll = 0, max_choice;
 	WINDOW *dialog, *list;
 
-	/* Allocate space for storing item on/off status */
-	if ((status = malloc(sizeof(int) * item_no)) == NULL) {
-		endwin();
-		fprintf(stderr,
-			"\nCan't allocate memory in dialog_checklist().\n");
-		exit(-1);
-	}
-
-	/* Initializes status */
-	for (i = 0; i < item_no; i++) {
-		status[i] = !strcasecmp(items[i * 3 + 2], "on");
-		if ((!choice && status[i])
-		    || !strcasecmp(items[i * 3 + 2], "selected"))
-			choice = i + 1;
+	/* which item to highlight */
+	item_foreach() {
+		if (item_is_tag('X'))
+			choice = item_n();
+		if (item_is_selected()) {
+			choice = item_n();
+			break;
+		}
 	}
-	if (choice)
-		choice--;
 
-	max_choice = MIN(list_height, item_no);
+	max_choice = MIN(list_height, item_count());
 
 	/* center dialog box on screen */
 	x = (COLS - width) / 2;
@@ -176,8 +166,8 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	/* Find length of longest item in order to center checklist */
 	check_x = 0;
-	for (i = 0; i < item_no; i++)
-		check_x = MAX(check_x, +strlen(items[i * 3 + 1]) + 4);
+	item_foreach()
+		check_x = MAX(check_x, strlen(item_str()) + 4);
 
 	check_x = (list_width - check_x) / 2;
 	item_x = check_x + 4;
@@ -189,14 +179,11 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	/* Print the list */
 	for (i = 0; i < max_choice; i++) {
-		if (i != choice)
-			print_item(list, items[(scroll + i) * 3 + 1],
-				   status[i + scroll], i, 0);
+		item_set(scroll + i);
+		print_item(list, i, i == choice);
 	}
-	print_item(list, items[(scroll + choice) * 3 + 1],
-		   status[choice + scroll], choice, 1);
 
-	print_arrows(dialog, choice, item_no, scroll,
+	print_arrows(dialog, choice, item_count(), scroll,
 		     box_y, box_x + check_x + 5, list_height);
 
 	print_buttons(dialog, height, width, 0);
@@ -208,10 +195,11 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	while (key != ESC) {
 		key = wgetch(dialog);
 
-		for (i = 0; i < max_choice; i++)
-			if (toupper(key) ==
-			    toupper(items[(scroll + i) * 3 + 1][0]))
+		for (i = 0; i < max_choice; i++) {
+			item_set(i + scroll);
+			if (toupper(key) == toupper(item_str()[0]))
 				break;
+		}
 
 		if (i < max_choice || key == KEY_UP || key == KEY_DOWN ||
 		    key == '+' || key == '-') {
@@ -222,15 +210,16 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 					/* Scroll list down */
 					if (list_height > 1) {
 						/* De-highlight current first item */
-						print_item(list, items[scroll * 3 + 1],
-							   status[scroll], 0, FALSE);
+						item_set(scroll);
+						print_item(list, 0, FALSE);
 						scrollok(list, TRUE);
 						wscrl(list, -1);
 						scrollok(list, FALSE);
 					}
 					scroll--;
-					print_item(list, items[scroll * 3 + 1], status[scroll], 0, TRUE);
-					print_arrows(dialog, choice, item_no,
+					item_set(scroll);
+					print_item(list, 0, TRUE);
+					print_arrows(dialog, choice, item_count(),
 						     scroll, box_y, box_x + check_x + 5, list_height);
 
 					wnoutrefresh(dialog);
@@ -241,23 +230,24 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 					i = choice - 1;
 			} else if (key == KEY_DOWN || key == '+') {
 				if (choice == max_choice - 1) {
-					if (scroll + choice >= item_no - 1)
+					if (scroll + choice >= item_count() - 1)
 						continue;
 					/* Scroll list up */
 					if (list_height > 1) {
 						/* De-highlight current last item before scrolling up */
-						print_item(list, items[(scroll + max_choice - 1) * 3 + 1],
-							   status[scroll + max_choice - 1],
-							   max_choice - 1, FALSE);
+						item_set(scroll + max_choice - 1);
+						print_item(list,
+							    max_choice - 1,
+							    FALSE);
 						scrollok(list, TRUE);
 						wscrl(list, 1);
 						scrollok(list, FALSE);
 					}
 					scroll++;
-					print_item(list, items[(scroll + max_choice - 1) * 3 + 1],
-						   status[scroll + max_choice - 1], max_choice - 1, TRUE);
+					item_set(scroll + max_choice - 1);
+					print_item(list, max_choice - 1, TRUE);
 
-					print_arrows(dialog, choice, item_no,
+					print_arrows(dialog, choice, item_count(),
 						     scroll, box_y, box_x + check_x + 5, list_height);
 
 					wnoutrefresh(dialog);
@@ -269,12 +259,12 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 			}
 			if (i != choice) {
 				/* De-highlight current item */
-				print_item(list, items[(scroll + choice) * 3 + 1],
-					   status[scroll + choice], choice, FALSE);
+				item_set(scroll + choice);
+				print_item(list, choice, FALSE);
 				/* Highlight new item */
 				choice = i;
-				print_item(list, items[(scroll + choice) * 3 + 1],
-					   status[scroll + choice], choice, TRUE);
+				item_set(scroll + choice);
+				print_item(list, choice, TRUE);
 				wnoutrefresh(dialog);
 				wrefresh(list);
 			}
@@ -284,10 +274,19 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 		case 'H':
 		case 'h':
 		case '?':
-			fprintf(stderr, "%s", items[(scroll + choice) * 3]);
+			button = 1;
+			/* fall-through */
+		case 'S':
+		case 's':
+		case ' ':
+		case '\n':
+			item_foreach()
+				item_set_selected(0);
+			item_set(scroll + choice);
+			item_set_selected(1);
+			delwin(list);
 			delwin(dialog);
-			free(status);
-			return 1;
+			return button;
 		case TAB:
 		case KEY_LEFT:
 		case KEY_RIGHT:
@@ -297,30 +296,6 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 			print_buttons(dialog, height, width, button);
 			wrefresh(dialog);
 			break;
-		case 'S':
-		case 's':
-		case ' ':
-		case '\n':
-			if (!button) {
-				if (!status[scroll + choice]) {
-					for (i = 0; i < item_no; i++)
-						status[i] = 0;
-					status[scroll + choice] = 1;
-					for (i = 0; i < max_choice; i++)
-						print_item(list, items[(scroll + i) * 3 + 1],
-							   status[scroll + i], i, i == choice);
-				}
-				wnoutrefresh(dialog);
-				wrefresh(list);
-
-				for (i = 0; i < item_no; i++)
-					if (status[i])
-						fprintf(stderr, "%s", items[i * 3]);
-			} else
-				fprintf(stderr, "%s", items[(scroll + choice) * 3]);
-			delwin(dialog);
-			free(status);
-			return button;
 		case 'X':
 		case 'x':
 			key = ESC;
@@ -331,8 +306,7 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 		/* Now, update everything... */
 		doupdate();
 	}
-
+	delwin(list);
 	delwin(dialog);
-	free(status);
-	return -1;		/* ESC pressed */
+	return 255;		/* ESC pressed */
 }

commit 98e5a1579e7d34fe3803240750a1c48efcd9cb15
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Mon Jul 24 21:40:46 2006 +0200

    kconfig/lxdialog: refactor color support
    
    Clean up and refactor color support. All color support are now
    in util.c including color definitions.
    In the process introduced a global variable named 'dlg' which is
    used all over to set color - thats the reason why all files are changed.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 79886413b6d5..b90e888a2bc0 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -34,18 +34,19 @@ static void print_item(WINDOW * win, const char *item, int status, int choice,
 	int i;
 
 	/* Clear 'residue' of last item */
-	wattrset(win, menubox_attr);
+	wattrset(win, dlg.menubox.atr);
 	wmove(win, choice, 0);
 	for (i = 0; i < list_width; i++)
 		waddch(win, ' ');
 
 	wmove(win, choice, check_x);
-	wattrset(win, selected ? check_selected_attr : check_attr);
+	wattrset(win, selected ? dlg.check_selected.atr
+		 : dlg.check.atr);
 	wprintw(win, "(%c)", status ? 'X' : ' ');
 
-	wattrset(win, selected ? tag_selected_attr : tag_attr);
+	wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
 	mvwaddch(win, choice, item_x, item[0]);
-	wattrset(win, selected ? item_selected_attr : item_attr);
+	wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
 	waddstr(win, (char *)item + 1);
 	if (selected) {
 		wmove(win, choice, check_x + 1);
@@ -62,11 +63,11 @@ static void print_arrows(WINDOW * win, int choice, int item_no, int scroll,
 	wmove(win, y, x);
 
 	if (scroll > 0) {
-		wattrset(win, uarrow_attr);
+		wattrset(win, dlg.uarrow.atr);
 		waddch(win, ACS_UARROW);
 		waddstr(win, "(-)");
 	} else {
-		wattrset(win, menubox_attr);
+		wattrset(win, dlg.menubox.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -77,11 +78,11 @@ static void print_arrows(WINDOW * win, int choice, int item_no, int scroll,
 	wmove(win, y, x);
 
 	if ((height < item_no) && (scroll + choice < item_no - 1)) {
-		wattrset(win, darrow_attr);
+		wattrset(win, dlg.darrow.atr);
 		waddch(win, ACS_DARROW);
 		waddstr(win, "(+)");
 	} else {
-		wattrset(win, menubox_border_attr);
+		wattrset(win, dlg.menubox_border.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -145,17 +146,18 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 	dialog = newwin(height, width, y, x);
 	keypad(dialog, TRUE);
 
-	draw_box(dialog, 0, 0, height, width, dialog_attr, border_attr);
-	wattrset(dialog, border_attr);
+	draw_box(dialog, 0, 0, height, width,
+		 dlg.dialog.atr, dlg.border.atr);
+	wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dialog_attr);
+	wattrset(dialog, dlg.dialog.atr);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
 
-	wattrset(dialog, dialog_attr);
+	wattrset(dialog, dlg.dialog.atr);
 	print_autowrap(dialog, prompt, width - 2, 1, 3);
 
 	list_width = width - 6;
@@ -170,7 +172,7 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	/* draw a box around the list items */
 	draw_box(dialog, box_y, box_x, list_height + 2, list_width + 2,
-	         menubox_border_attr, menubox_attr);
+	         dlg.menubox_border.atr, dlg.menubox.atr);
 
 	/* Find length of longest item in order to center checklist */
 	check_x = 0;

commit 66392c4f2246641c13b5dc60d15b09a71e09276f
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Fri Jun 30 02:18:50 2006 -0700

    kconfig: enhancing accessibility of lxdialog
    
    Some fix that I forgot for good accessibility of lxdialog (the cursor
    should always be left at the focus location):
    
    Have the checklist display the currently highlighted entry last, for having
    the cursor left on it (rather than on the last line of the list).
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index be0200e9cdaf..79886413b6d5 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -187,9 +187,12 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	/* Print the list */
 	for (i = 0; i < max_choice; i++) {
-		print_item(list, items[(scroll + i) * 3 + 1],
-			   status[i + scroll], i, i == choice);
+		if (i != choice)
+			print_item(list, items[(scroll + i) * 3 + 1],
+				   status[i + scroll], i, 0);
 	}
+	print_item(list, items[(scroll + choice) * 3 + 1],
+		   status[choice + scroll], choice, 1);
 
 	print_arrows(dialog, choice, item_no, scroll,
 		     box_y, box_x + check_x + 5, list_height);

commit f043ca43c1ae354346f72dc5826d820d5619f0b2
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Apr 12 02:21:25 2006 +0200

    [PATCH] Enhancing accessibility of lxdialog
    
    For easily getting fairly good accessibility, the TTY cursor should
    always be left at the focus location.  This patch fixes the checklist by
    just having the list refreshed after the dialog box (hence the cursor
    position remains in the list).
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index db07ae73e051..be0200e9cdaf 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -196,8 +196,8 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 
 	print_buttons(dialog, height, width, 0);
 
-	wnoutrefresh(list);
 	wnoutrefresh(dialog);
+	wnoutrefresh(list);
 	doupdate();
 
 	while (key != ESC) {
@@ -225,12 +225,11 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 					}
 					scroll--;
 					print_item(list, items[scroll * 3 + 1], status[scroll], 0, TRUE);
-					wnoutrefresh(list);
-
 					print_arrows(dialog, choice, item_no,
 						     scroll, box_y, box_x + check_x + 5, list_height);
 
-					wrefresh(dialog);
+					wnoutrefresh(dialog);
+					wrefresh(list);
 
 					continue;	/* wait for another key press */
 				} else
@@ -252,12 +251,12 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 					scroll++;
 					print_item(list, items[(scroll + max_choice - 1) * 3 + 1],
 						   status[scroll + max_choice - 1], max_choice - 1, TRUE);
-					wnoutrefresh(list);
 
 					print_arrows(dialog, choice, item_no,
 						     scroll, box_y, box_x + check_x + 5, list_height);
 
-					wrefresh(dialog);
+					wnoutrefresh(dialog);
+					wrefresh(list);
 
 					continue;	/* wait for another key press */
 				} else
@@ -271,8 +270,8 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 				choice = i;
 				print_item(list, items[(scroll + choice) * 3 + 1],
 					   status[scroll + choice], choice, TRUE);
-				wnoutrefresh(list);
-				wrefresh(dialog);
+				wnoutrefresh(dialog);
+				wrefresh(list);
 			}
 			continue;	/* wait for another key press */
 		}
@@ -306,8 +305,8 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 						print_item(list, items[(scroll + i) * 3 + 1],
 							   status[scroll + i], i, i == choice);
 				}
-				wnoutrefresh(list);
-				wrefresh(dialog);
+				wnoutrefresh(dialog);
+				wrefresh(list);
 
 				for (i = 0; i < item_no; i++)
 					if (status[i])

commit 00213b17cec87d2cd4df75bcc79aea7a91d8532d
Author: Petr Baudis <pasky@ucw.cz>
Date:   Thu Dec 22 04:44:04 2005 +0100

    kconfig: Remove support for lxdialog --checklist
    
    Remove support for lxdialog --checklist
    
    The checklist lxdialog functionality is not used by menuconfig
    (only the radiolist variant is used) and supporting it would
    significantly complicate the forthcoming liblxdialog API.
    
    Signed-off-by: Petr Baudis <pasky@suse.cz>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index 3fb681fb9632..db07ae73e051 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -23,7 +23,7 @@
 
 #include "dialog.h"
 
-static int list_width, check_x, item_x, checkflag;
+static int list_width, check_x, item_x;
 
 /*
  * Print list item
@@ -41,10 +41,7 @@ static void print_item(WINDOW * win, const char *item, int status, int choice,
 
 	wmove(win, choice, check_x);
 	wattrset(win, selected ? check_selected_attr : check_attr);
-	if (checkflag == FLAG_CHECK)
-		wprintw(win, "[%c]", status ? 'X' : ' ');
-	else
-		wprintw(win, "(%c)", status ? 'X' : ' ');
+	wprintw(win, "(%c)", status ? 'X' : ' ');
 
 	wattrset(win, selected ? tag_selected_attr : tag_attr);
 	mvwaddch(win, choice, item_x, item[0]);
@@ -109,18 +106,16 @@ static void print_buttons(WINDOW * dialog, int height, int width, int selected)
 
 /*
  * Display a dialog box with a list of options that can be turned on or off
- * The `flag' parameter is used to select between radiolist and checklist.
+ * in the style of radiolist (only one option turned on at a time).
  */
 int dialog_checklist(const char *title, const char *prompt, int height,
 		     int width, int list_height, int item_no,
-		     const char *const *items, int flag)
+		     const char *const *items)
 {
 	int i, x, y, box_x, box_y;
 	int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
 	WINDOW *dialog, *list;
 
-	checkflag = flag;
-
 	/* Allocate space for storing item on/off status */
 	if ((status = malloc(sizeof(int) * item_no)) == NULL) {
 		endwin();
@@ -303,34 +298,20 @@ int dialog_checklist(const char *title, const char *prompt, int height,
 		case ' ':
 		case '\n':
 			if (!button) {
-				if (flag == FLAG_CHECK) {
-					status[scroll + choice] = !status[scroll + choice];
-					wmove(list, choice, check_x);
-					wattrset(list, check_selected_attr);
-					wprintw(list, "[%c]", status[scroll + choice] ? 'X' : ' ');
-				} else {
-					if (!status[scroll + choice]) {
-						for (i = 0; i < item_no; i++)
-							status[i] = 0;
-						status[scroll + choice] = 1;
-						for (i = 0; i < max_choice; i++)
-							print_item(list, items[(scroll + i) * 3 + 1],
-								   status[scroll + i], i, i == choice);
-					}
+				if (!status[scroll + choice]) {
+					for (i = 0; i < item_no; i++)
+						status[i] = 0;
+					status[scroll + choice] = 1;
+					for (i = 0; i < max_choice; i++)
+						print_item(list, items[(scroll + i) * 3 + 1],
+							   status[scroll + i], i, i == choice);
 				}
 				wnoutrefresh(list);
 				wrefresh(dialog);
 
-				for (i = 0; i < item_no; i++) {
-					if (status[i]) {
-						if (flag == FLAG_CHECK) {
-							fprintf(stderr, "\"%s\" ", items[i * 3]);
-						} else {
-							fprintf(stderr, "%s", items[i * 3]);
-						}
-
-					}
-				}
+				for (i = 0; i < item_no; i++)
+					if (status[i])
+						fprintf(stderr, "%s", items[i * 3]);
 			} else
 				fprintf(stderr, "%s", items[(scroll + choice) * 3]);
 			delwin(dialog);

commit 6f6046cff2e8f04d6b916b10ebaa7b40d7e7967a
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Dec 16 21:35:19 2005 +0100

    kconfig: move lxdialog to scripts/kconfig/lxdialog
    
    The only lxdialog user i kconfig - for menuconfig.
    So move it to reflect this.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
new file mode 100644
index 000000000000..3fb681fb9632
--- /dev/null
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -0,0 +1,353 @@
+/*
+ *  checklist.c -- implements the checklist box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *     Stuart Herbert - S.Herbert@sheffield.ac.uk: radiolist extension
+ *     Alessandro Rubini - rubini@ipvvis.unipv.it: merged the two
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+static int list_width, check_x, item_x, checkflag;
+
+/*
+ * Print list item
+ */
+static void print_item(WINDOW * win, const char *item, int status, int choice,
+		       int selected)
+{
+	int i;
+
+	/* Clear 'residue' of last item */
+	wattrset(win, menubox_attr);
+	wmove(win, choice, 0);
+	for (i = 0; i < list_width; i++)
+		waddch(win, ' ');
+
+	wmove(win, choice, check_x);
+	wattrset(win, selected ? check_selected_attr : check_attr);
+	if (checkflag == FLAG_CHECK)
+		wprintw(win, "[%c]", status ? 'X' : ' ');
+	else
+		wprintw(win, "(%c)", status ? 'X' : ' ');
+
+	wattrset(win, selected ? tag_selected_attr : tag_attr);
+	mvwaddch(win, choice, item_x, item[0]);
+	wattrset(win, selected ? item_selected_attr : item_attr);
+	waddstr(win, (char *)item + 1);
+	if (selected) {
+		wmove(win, choice, check_x + 1);
+		wrefresh(win);
+	}
+}
+
+/*
+ * Print the scroll indicators.
+ */
+static void print_arrows(WINDOW * win, int choice, int item_no, int scroll,
+	     int y, int x, int height)
+{
+	wmove(win, y, x);
+
+	if (scroll > 0) {
+		wattrset(win, uarrow_attr);
+		waddch(win, ACS_UARROW);
+		waddstr(win, "(-)");
+	} else {
+		wattrset(win, menubox_attr);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+	}
+
+	y = y + height + 1;
+	wmove(win, y, x);
+
+	if ((height < item_no) && (scroll + choice < item_no - 1)) {
+		wattrset(win, darrow_attr);
+		waddch(win, ACS_DARROW);
+		waddstr(win, "(+)");
+	} else {
+		wattrset(win, menubox_border_attr);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+		waddch(win, ACS_HLINE);
+	}
+}
+
+/*
+ *  Display the termination buttons
+ */
+static void print_buttons(WINDOW * dialog, int height, int width, int selected)
+{
+	int x = width / 2 - 11;
+	int y = height - 2;
+
+	print_button(dialog, "Select", y, x, selected == 0);
+	print_button(dialog, " Help ", y, x + 14, selected == 1);
+
+	wmove(dialog, y, x + 1 + 14 * selected);
+	wrefresh(dialog);
+}
+
+/*
+ * Display a dialog box with a list of options that can be turned on or off
+ * The `flag' parameter is used to select between radiolist and checklist.
+ */
+int dialog_checklist(const char *title, const char *prompt, int height,
+		     int width, int list_height, int item_no,
+		     const char *const *items, int flag)
+{
+	int i, x, y, box_x, box_y;
+	int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
+	WINDOW *dialog, *list;
+
+	checkflag = flag;
+
+	/* Allocate space for storing item on/off status */
+	if ((status = malloc(sizeof(int) * item_no)) == NULL) {
+		endwin();
+		fprintf(stderr,
+			"\nCan't allocate memory in dialog_checklist().\n");
+		exit(-1);
+	}
+
+	/* Initializes status */
+	for (i = 0; i < item_no; i++) {
+		status[i] = !strcasecmp(items[i * 3 + 2], "on");
+		if ((!choice && status[i])
+		    || !strcasecmp(items[i * 3 + 2], "selected"))
+			choice = i + 1;
+	}
+	if (choice)
+		choice--;
+
+	max_choice = MIN(list_height, item_no);
+
+	/* center dialog box on screen */
+	x = (COLS - width) / 2;
+	y = (LINES - height) / 2;
+
+	draw_shadow(stdscr, y, x, height, width);
+
+	dialog = newwin(height, width, y, x);
+	keypad(dialog, TRUE);
+
+	draw_box(dialog, 0, 0, height, width, dialog_attr, border_attr);
+	wattrset(dialog, border_attr);
+	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
+	for (i = 0; i < width - 2; i++)
+		waddch(dialog, ACS_HLINE);
+	wattrset(dialog, dialog_attr);
+	waddch(dialog, ACS_RTEE);
+
+	print_title(dialog, title, width);
+
+	wattrset(dialog, dialog_attr);
+	print_autowrap(dialog, prompt, width - 2, 1, 3);
+
+	list_width = width - 6;
+	box_y = height - list_height - 5;
+	box_x = (width - list_width) / 2 - 1;
+
+	/* create new window for the list */
+	list = subwin(dialog, list_height, list_width, y + box_y + 1,
+	              x + box_x + 1);
+
+	keypad(list, TRUE);
+
+	/* draw a box around the list items */
+	draw_box(dialog, box_y, box_x, list_height + 2, list_width + 2,
+	         menubox_border_attr, menubox_attr);
+
+	/* Find length of longest item in order to center checklist */
+	check_x = 0;
+	for (i = 0; i < item_no; i++)
+		check_x = MAX(check_x, +strlen(items[i * 3 + 1]) + 4);
+
+	check_x = (list_width - check_x) / 2;
+	item_x = check_x + 4;
+
+	if (choice >= list_height) {
+		scroll = choice - list_height + 1;
+		choice -= scroll;
+	}
+
+	/* Print the list */
+	for (i = 0; i < max_choice; i++) {
+		print_item(list, items[(scroll + i) * 3 + 1],
+			   status[i + scroll], i, i == choice);
+	}
+
+	print_arrows(dialog, choice, item_no, scroll,
+		     box_y, box_x + check_x + 5, list_height);
+
+	print_buttons(dialog, height, width, 0);
+
+	wnoutrefresh(list);
+	wnoutrefresh(dialog);
+	doupdate();
+
+	while (key != ESC) {
+		key = wgetch(dialog);
+
+		for (i = 0; i < max_choice; i++)
+			if (toupper(key) ==
+			    toupper(items[(scroll + i) * 3 + 1][0]))
+				break;
+
+		if (i < max_choice || key == KEY_UP || key == KEY_DOWN ||
+		    key == '+' || key == '-') {
+			if (key == KEY_UP || key == '-') {
+				if (!choice) {
+					if (!scroll)
+						continue;
+					/* Scroll list down */
+					if (list_height > 1) {
+						/* De-highlight current first item */
+						print_item(list, items[scroll * 3 + 1],
+							   status[scroll], 0, FALSE);
+						scrollok(list, TRUE);
+						wscrl(list, -1);
+						scrollok(list, FALSE);
+					}
+					scroll--;
+					print_item(list, items[scroll * 3 + 1], status[scroll], 0, TRUE);
+					wnoutrefresh(list);
+
+					print_arrows(dialog, choice, item_no,
+						     scroll, box_y, box_x + check_x + 5, list_height);
+
+					wrefresh(dialog);
+
+					continue;	/* wait for another key press */
+				} else
+					i = choice - 1;
+			} else if (key == KEY_DOWN || key == '+') {
+				if (choice == max_choice - 1) {
+					if (scroll + choice >= item_no - 1)
+						continue;
+					/* Scroll list up */
+					if (list_height > 1) {
+						/* De-highlight current last item before scrolling up */
+						print_item(list, items[(scroll + max_choice - 1) * 3 + 1],
+							   status[scroll + max_choice - 1],
+							   max_choice - 1, FALSE);
+						scrollok(list, TRUE);
+						wscrl(list, 1);
+						scrollok(list, FALSE);
+					}
+					scroll++;
+					print_item(list, items[(scroll + max_choice - 1) * 3 + 1],
+						   status[scroll + max_choice - 1], max_choice - 1, TRUE);
+					wnoutrefresh(list);
+
+					print_arrows(dialog, choice, item_no,
+						     scroll, box_y, box_x + check_x + 5, list_height);
+
+					wrefresh(dialog);
+
+					continue;	/* wait for another key press */
+				} else
+					i = choice + 1;
+			}
+			if (i != choice) {
+				/* De-highlight current item */
+				print_item(list, items[(scroll + choice) * 3 + 1],
+					   status[scroll + choice], choice, FALSE);
+				/* Highlight new item */
+				choice = i;
+				print_item(list, items[(scroll + choice) * 3 + 1],
+					   status[scroll + choice], choice, TRUE);
+				wnoutrefresh(list);
+				wrefresh(dialog);
+			}
+			continue;	/* wait for another key press */
+		}
+		switch (key) {
+		case 'H':
+		case 'h':
+		case '?':
+			fprintf(stderr, "%s", items[(scroll + choice) * 3]);
+			delwin(dialog);
+			free(status);
+			return 1;
+		case TAB:
+		case KEY_LEFT:
+		case KEY_RIGHT:
+			button = ((key == KEY_LEFT ? --button : ++button) < 0)
+			    ? 1 : (button > 1 ? 0 : button);
+
+			print_buttons(dialog, height, width, button);
+			wrefresh(dialog);
+			break;
+		case 'S':
+		case 's':
+		case ' ':
+		case '\n':
+			if (!button) {
+				if (flag == FLAG_CHECK) {
+					status[scroll + choice] = !status[scroll + choice];
+					wmove(list, choice, check_x);
+					wattrset(list, check_selected_attr);
+					wprintw(list, "[%c]", status[scroll + choice] ? 'X' : ' ');
+				} else {
+					if (!status[scroll + choice]) {
+						for (i = 0; i < item_no; i++)
+							status[i] = 0;
+						status[scroll + choice] = 1;
+						for (i = 0; i < max_choice; i++)
+							print_item(list, items[(scroll + i) * 3 + 1],
+								   status[scroll + i], i, i == choice);
+					}
+				}
+				wnoutrefresh(list);
+				wrefresh(dialog);
+
+				for (i = 0; i < item_no; i++) {
+					if (status[i]) {
+						if (flag == FLAG_CHECK) {
+							fprintf(stderr, "\"%s\" ", items[i * 3]);
+						} else {
+							fprintf(stderr, "%s", items[i * 3]);
+						}
+
+					}
+				}
+			} else
+				fprintf(stderr, "%s", items[(scroll + choice) * 3]);
+			delwin(dialog);
+			free(status);
+			return button;
+		case 'X':
+		case 'x':
+			key = ESC;
+		case ESC:
+			break;
+		}
+
+		/* Now, update everything... */
+		doupdate();
+	}
+
+	delwin(dialog);
+	free(status);
+	return -1;		/* ESC pressed */
+}
