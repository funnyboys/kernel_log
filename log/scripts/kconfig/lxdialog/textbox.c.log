commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 88d2818ed956..4e339b12664e 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  textbox.c -- implements the text box
  *
  *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
  *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "dialog.h"

commit 694c49a7c01cc87194be40cb26404b58b68c291c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue May 22 21:36:12 2018 +0200

    kconfig: drop localization support
    
    The localization support is broken and appears unused.
    There is no google hits on the update-po-config target.
    And there is no recent (5 years) activity related to the localization.
    
    So lets just drop this as it is no longer used.
    
    Suggested-by: Ulf Magnusson <ulfalizer@gmail.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 1773319b95e7..88d2818ed956 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -129,7 +129,7 @@ int dialog_textbox(const char *title, char *tbuf, int initial_height,
 
 	print_title(dialog, title, width);
 
-	print_button(dialog, gettext(" Exit "), height - 2, width / 2 - 4, TRUE);
+	print_button(dialog, " Exit ", height - 2, width / 2 - 4, TRUE);
 	wnoutrefresh(dialog);
 	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
 

commit 4f2de3e19983dafca264b672152b36e4962ca1c3
Author: Dirk Gouders <dirk@gouders.net>
Date:   Sun May 12 12:30:49 2013 +0200

    mconf: use function calls instead of ncurses' variables LINES and COLS
    
    According to the documentation [1], LINES and COLS are initialized by
    initscr(); it does not say anything about the behavior when windows are
    resized.
    
    Do not rely on the current implementation of ncurses that updates
    these variables on resize, but use the propper function calls to get
    window dimensions.
    
    init_dialog() could make use of the variables, but for the sake of
    consistency we do not change it's current use of the macro getmaxyx().
    
    [1] ncurses(3X)
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Yann E. MORIN <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 907cdcb397c1..1773319b95e7 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -98,8 +98,8 @@ int dialog_textbox(const char *title, char *tbuf, int initial_height,
 			width = 0;
 
 	/* center dialog box on screen */
-	x = (COLS - width) / 2;
-	y = (LINES - height) / 2;
+	x = (getmaxx(stdscr) - width) / 2;
+	y = (getmaxy(stdscr) - height) / 2;
 
 	draw_shadow(stdscr, y, x, height, width);
 

commit 851f665725581d02d48ffbca50240cda44d698d4
Author: Sedat Dilek <sedat.dilek@gmail.com>
Date:   Sat Jun 15 11:07:35 2013 +0200

    kconfig/lxdialog: Add definitions for mininimum (re)size values
    
    Commit c8dc68ad0fbd ("kconfig/lxdialog: support resize") added support
    for resizing, but forgot to collect all hardcoded values at one single
    place.
    
    Also add a definition for the check for a minimum screen/window size
    of 80x19.
    
    [ ChangeLog v3:
      * Rename MENU_{HEIGTH,WIDTH}_MIN -> MENUBOX_{HEIGTH,WIDTH}_MIN
      ChangeLog v2:
      * Rename WIN_{HEIGTH,WIDTH}_MIN -> WINDOW_{HEIGTH,WIDTH}_MIN
      * Mention the check for a minimum screen/window size in the changelog
      * Add a comment above the block of new definitions ]
    
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>
    Acked-by: Wang YanQing <udknight@gmail.com>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index a48bb93e0907..907cdcb397c1 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -80,7 +80,7 @@ int dialog_textbox(const char *title, char *tbuf, int initial_height,
 
 do_resize:
 	getmaxyx(stdscr, height, width);
-	if (height < 8 || width < 8)
+	if (height < TEXTBOX_HEIGTH_MIN || width < TEXTBOX_WIDTH_MIN)
 		return -ERRDISPLAYTOOSMALL;
 	if (initial_height != 0)
 		height = initial_height;

commit 95ac9b3b585d20df116c5bea1511d9eb5758ac81
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:08 2012 -0400

    menuconfig: Assign jump keys per-page instead of globally
    
    At the moment, keys 1-9 are assigned to the first 9 search results. This patch
    makes them assigned to the first 9 results per-page instead. We are much less
    likely to run out of keys that way.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 3b3c5c470bf8..a48bb93e0907 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -22,23 +22,25 @@
 #include "dialog.h"
 
 static void back_lines(int n);
-static void print_page(WINDOW * win, int height, int width);
-static void print_line(WINDOW * win, int row, int width);
+static void print_page(WINDOW *win, int height, int width, update_text_fn
+		       update_text, void *data);
+static void print_line(WINDOW *win, int row, int width);
 static char *get_line(void);
 static void print_position(WINDOW * win);
 
 static int hscroll;
 static int begin_reached, end_reached, page_length;
-static const char *buf;
-static const char *page;
+static char *buf;
+static char *page;
 
 /*
  * refresh window content
  */
 static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
-							  int cur_y, int cur_x)
+			     int cur_y, int cur_x, update_text_fn update_text,
+			     void *data)
 {
-	print_page(box, boxh, boxw);
+	print_page(box, boxh, boxw, update_text, data);
 	print_position(dialog);
 	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 	wrefresh(dialog);
@@ -49,9 +51,11 @@ static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
  * Display text from a file in a dialog box.
  *
  * keys is a null-terminated array
+ * update_text() may not add or remove any '\n' or '\0' in tbuf
  */
-int dialog_textbox(const char *title, const char *tbuf, int initial_height,
-		   int initial_width, int *keys, int *_vscroll, int *_hscroll)
+int dialog_textbox(const char *title, char *tbuf, int initial_height,
+		   int initial_width, int *keys, int *_vscroll, int *_hscroll,
+		   update_text_fn update_text, void *data)
 {
 	int i, x, y, cur_x, cur_y, key = 0;
 	int height, width, boxh, boxw;
@@ -131,7 +135,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 
 	/* Print first page of text */
 	attr_clear(box, boxh, boxw, dlg.dialog.atr);
-	refresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);
+	refresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x, update_text,
+			 data);
 
 	while (!done) {
 		key = wgetch(dialog);
@@ -150,7 +155,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 				begin_reached = 1;
 				page = buf;
 				refresh_text_box(dialog, box, boxh, boxw,
-						 cur_y, cur_x);
+						 cur_y, cur_x, update_text,
+						 data);
 			}
 			break;
 		case 'G':	/* Last page */
@@ -160,8 +166,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 			/* point to last char in buf */
 			page = buf + strlen(buf);
 			back_lines(boxh);
-			refresh_text_box(dialog, box, boxh, boxw,
-					 cur_y, cur_x);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x, update_text, data);
 			break;
 		case 'K':	/* Previous line */
 		case 'k':
@@ -171,7 +177,7 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 
 			back_lines(page_length + 1);
 			refresh_text_box(dialog, box, boxh, boxw, cur_y,
-					 cur_x);
+					 cur_x, update_text, data);
 			break;
 		case 'B':	/* Previous page */
 		case 'b':
@@ -180,8 +186,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 			if (begin_reached)
 				break;
 			back_lines(page_length + boxh);
-			refresh_text_box(dialog, box, boxh, boxw,
-					 cur_y, cur_x);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x, update_text, data);
 			break;
 		case 'J':	/* Next line */
 		case 'j':
@@ -191,7 +197,7 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 
 			back_lines(page_length - 1);
 			refresh_text_box(dialog, box, boxh, boxw, cur_y,
-					 cur_x);
+					 cur_x, update_text, data);
 			break;
 		case KEY_NPAGE:	/* Next page */
 		case ' ':
@@ -200,8 +206,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 				break;
 
 			begin_reached = 0;
-			refresh_text_box(dialog, box, boxh, boxw,
-					 cur_y, cur_x);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x, update_text, data);
 			break;
 		case '0':	/* Beginning of line */
 		case 'H':	/* Scroll left */
@@ -216,8 +222,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 				hscroll--;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			refresh_text_box(dialog, box, boxh, boxw,
-					 cur_y, cur_x);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x, update_text, data);
 			break;
 		case 'L':	/* Scroll right */
 		case 'l':
@@ -227,8 +233,8 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 			hscroll++;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			refresh_text_box(dialog, box, boxh, boxw,
-					 cur_y, cur_x);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x, update_text, data);
 			break;
 		case KEY_ESC:
 			if (on_key_esc(dialog) == KEY_ESC)
@@ -301,12 +307,23 @@ static void back_lines(int n)
 }
 
 /*
- * Print a new page of text. Called by dialog_textbox().
+ * Print a new page of text.
  */
-static void print_page(WINDOW * win, int height, int width)
+static void print_page(WINDOW *win, int height, int width, update_text_fn
+		       update_text, void *data)
 {
 	int i, passed_end = 0;
 
+	if (update_text) {
+		char *end;
+
+		for (i = 0; i < height; i++)
+			get_line();
+		end = page;
+		back_lines(height);
+		update_text(buf, page - buf, end - buf, data);
+	}
+
 	page_length = 0;
 	for (i = 0; i < height; i++) {
 		print_line(win, i, width);
@@ -319,7 +336,7 @@ static void print_page(WINDOW * win, int height, int width)
 }
 
 /*
- * Print a new line of text. Called by dialog_textbox() and print_page().
+ * Print a new line of text.
  */
 static void print_line(WINDOW * win, int row, int width)
 {

commit 1a374ae6191e9c440f1953a264a94d38173737be
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:07 2012 -0400

    menuconfig: Do not open code textbox scroll up/down
    
    We don't need to explicitely use ncurses' scroll(). ncurses performs
    vertical-motion optimization at wrefresh() time.
    
    Using strace I confirmed that with the following patch curses still sends only
    the new line of text to the terminal when scrolling up/down one line at a
    time.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 506a095c387c..3b3c5c470bf8 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -166,40 +166,12 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 		case 'K':	/* Previous line */
 		case 'k':
 		case KEY_UP:
-			if (!begin_reached) {
-				int passed_end = 0;
-
-				back_lines(page_length + 1);
-
-				/* We don't call print_page() here but use
-				 * scrolling to ensure faster screen update.
-				 * However, 'end_reached' and 'page_length'
-				 * should still be updated, and 'page' should
-				 * point to start of next page. This is done
-				 * by calling get_line() in the following
-				 * 'for' loop. */
-				scrollok(box, TRUE);
-				wscrl(box, -1);	/* Scroll box region down one line */
-				scrollok(box, FALSE);
-				page_length = 0;
-				for (i = 0; i < boxh; i++) {
-					if (!i) {
-						/* print first line of page */
-						print_line(box, 0, boxw);
-						wnoutrefresh(box);
-					} else
-						/* Called to update 'end_reached' and 'page' */
-						get_line();
-					if (!passed_end)
-						page_length++;
-					if (end_reached && !passed_end)
-						passed_end = 1;
-				}
+			if (begin_reached)
+				break;
 
-				print_position(dialog);
-				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
-				wrefresh(dialog);
-			}
+			back_lines(page_length + 1);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x);
 			break;
 		case 'B':	/* Previous page */
 		case 'b':
@@ -214,17 +186,12 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 		case 'J':	/* Next line */
 		case 'j':
 		case KEY_DOWN:
-			if (!end_reached) {
-				begin_reached = 0;
-				scrollok(box, TRUE);
-				scroll(box);	/* Scroll box region up one line */
-				scrollok(box, FALSE);
-				print_line(box, boxh - 1, boxw);
-				wnoutrefresh(box);
-				print_position(dialog);
-				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
-				wrefresh(dialog);
-			}
+			if (end_reached)
+				break;
+
+			back_lines(page_length - 1);
+			refresh_text_box(dialog, box, boxh, boxw, cur_y,
+					 cur_x);
 			break;
 		case KEY_NPAGE:	/* Next page */
 		case ' ':

commit 1d1e2caebbf1f4f25ad473e90650cdc9291fdd22
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:05 2012 -0400

    menuconfig: Extend dialog_textbox so that it can return to a scrolled position
    
    We can now display other UI elements (menus) "on top" of a textbox and then
    seemingly come back to it in the same state it was left.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index eb4ee92ad2b3..506a095c387c 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -51,7 +51,7 @@ static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
  * keys is a null-terminated array
  */
 int dialog_textbox(const char *title, const char *tbuf, int initial_height,
-		   int initial_width, int *keys)
+		   int initial_width, int *keys, int *_vscroll, int *_hscroll)
 {
 	int i, x, y, cur_x, cur_y, key = 0;
 	int height, width, boxh, boxw;
@@ -65,6 +65,15 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 	buf = tbuf;
 	page = buf;	/* page is pointer to start of page to be displayed */
 
+	if (_vscroll && *_vscroll) {
+		begin_reached = 0;
+
+		for (i = 0; i < *_vscroll; i++)
+			get_line();
+	}
+	if (_hscroll)
+		hscroll = *_hscroll;
+
 do_resize:
 	getmaxyx(stdscr, height, width);
 	if (height < 8 || width < 8)
@@ -275,6 +284,19 @@ int dialog_textbox(const char *title, const char *tbuf, int initial_height,
 	}
 	delwin(box);
 	delwin(dialog);
+	if (_vscroll) {
+		const char *s;
+
+		s = buf;
+		*_vscroll = 0;
+		back_lines(page_length);
+		while (s < page && (s = strchr(s, '\n'))) {
+			(*_vscroll)++;
+			s++;
+		}
+	}
+	if (_hscroll)
+		*_hscroll = hscroll;
 	return key;
 }
 

commit 537ddae75c0f41343928d39f308f3ca670f000a8
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:04 2012 -0400

    menuconfig: Extend dialog_textbox so that it can exit on arbitrary keypresses
    
    The caller will be able to perform actions based on hotkeys in the displayed
    text.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 264a2b9f320c..eb4ee92ad2b3 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -47,14 +47,16 @@ static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
 
 /*
  * Display text from a file in a dialog box.
+ *
+ * keys is a null-terminated array
  */
-int dialog_textbox(const char *title, const char *tbuf,
-		   int initial_height, int initial_width)
+int dialog_textbox(const char *title, const char *tbuf, int initial_height,
+		   int initial_width, int *keys)
 {
 	int i, x, y, cur_x, cur_y, key = 0;
 	int height, width, boxh, boxw;
-	int passed_end;
 	WINDOW *dialog, *box;
+	bool done = false;
 
 	begin_reached = 1;
 	end_reached = 0;
@@ -122,7 +124,7 @@ int dialog_textbox(const char *title, const char *tbuf,
 	attr_clear(box, boxh, boxw, dlg.dialog.atr);
 	refresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);
 
-	while ((key != KEY_ESC) && (key != '\n')) {
+	while (!done) {
 		key = wgetch(dialog);
 		switch (key) {
 		case 'E':	/* Exit */
@@ -130,9 +132,9 @@ int dialog_textbox(const char *title, const char *tbuf,
 		case 'X':
 		case 'x':
 		case 'q':
-			delwin(box);
-			delwin(dialog);
-			return 0;
+		case '\n':
+			done = true;
+			break;
 		case 'g':	/* First page */
 		case KEY_HOME:
 			if (!begin_reached) {
@@ -156,6 +158,8 @@ int dialog_textbox(const char *title, const char *tbuf,
 		case 'k':
 		case KEY_UP:
 			if (!begin_reached) {
+				int passed_end = 0;
+
 				back_lines(page_length + 1);
 
 				/* We don't call print_page() here but use
@@ -169,7 +173,6 @@ int dialog_textbox(const char *title, const char *tbuf,
 				wscrl(box, -1);	/* Scroll box region down one line */
 				scrollok(box, FALSE);
 				page_length = 0;
-				passed_end = 0;
 				for (i = 0; i < boxh; i++) {
 					if (!i) {
 						/* print first line of page */
@@ -252,7 +255,8 @@ int dialog_textbox(const char *title, const char *tbuf,
 					 cur_y, cur_x);
 			break;
 		case KEY_ESC:
-			key = on_key_esc(dialog);
+			if (on_key_esc(dialog) == KEY_ESC)
+				done = true;
 			break;
 		case KEY_RESIZE:
 			back_lines(height);
@@ -260,11 +264,18 @@ int dialog_textbox(const char *title, const char *tbuf,
 			delwin(dialog);
 			on_key_resize();
 			goto do_resize;
+		default:
+			for (i = 0; keys[i]; i++) {
+				if (key == keys[i]) {
+					done = true;
+					break;
+				}
+			}
 		}
 	}
 	delwin(box);
 	delwin(dialog);
-	return key;		/* ESC pressed */
+	return key;
 }
 
 /*

commit b9d29abd98a2bbeb3a6c49c1607348c92bc80105
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:03 2012 -0400

    menuconfig: Remove superfluous conditionnal
    
    Because end_reached is set to 0 before the loop, the test "!end_reached" is
    always true and can be removed. This structure was perhaps copied from the
    similar one in back_lines().
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 4e5de60a0c0d..264a2b9f320c 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -357,10 +357,8 @@ static char *get_line(void)
 	end_reached = 0;
 	while (*page != '\n') {
 		if (*page == '\0') {
-			if (!end_reached) {
-				end_reached = 1;
-				break;
-			}
+			end_reached = 1;
+			break;
 		} else if (i < MAX_LEN)
 			line[i++] = *(page++);
 		else {
@@ -373,7 +371,7 @@ static char *get_line(void)
 	if (i <= MAX_LEN)
 		line[i] = '\0';
 	if (!end_reached)
-		page++;		/* move pass '\n' */
+		page++;		/* move past '\n' */
 
 	return line;
 }

commit 9d4792c9b4e9cab75e657cec0c140875472d16f0
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Tue Jul 24 16:12:02 2012 -0400

    menuconfig: add u, d, q command keys in text boxes
    
    They function just like they do in less(1).
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 154c2dd245b7..4e5de60a0c0d 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -129,6 +129,7 @@ int dialog_textbox(const char *title, const char *tbuf,
 		case 'e':
 		case 'X':
 		case 'x':
+		case 'q':
 			delwin(box);
 			delwin(dialog);
 			return 0;
@@ -190,6 +191,7 @@ int dialog_textbox(const char *title, const char *tbuf,
 			break;
 		case 'B':	/* Previous page */
 		case 'b':
+		case 'u':
 		case KEY_PPAGE:
 			if (begin_reached)
 				break;
@@ -214,6 +216,7 @@ int dialog_textbox(const char *title, const char *tbuf,
 			break;
 		case KEY_NPAGE:	/* Next page */
 		case ' ':
+		case 'd':
 			if (end_reached)
 				break;
 

commit 702a945028fd7cbf7a5e55546b3c47a5c984a1ba
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Sat Aug 20 02:28:53 2011 -0300

    kconfig: fix set but not used variables
    
    Some variables were being set but never used, which was triggering
    warnings in GCC >= 4.6.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index c704712d0227..154c2dd245b7 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -320,7 +320,6 @@ static void print_page(WINDOW * win, int height, int width)
  */
 static void print_line(WINDOW * win, int row, int width)
 {
-	int y, x;
 	char *line;
 
 	line = get_line();
@@ -329,10 +328,10 @@ static void print_line(WINDOW * win, int row, int width)
 	waddch(win, ' ');
 	waddnstr(win, line, MIN(strlen(line), width - 2));
 
-	getyx(win, y, x);
 	/* Clear 'residue' of previous line */
 #if OLD_NCURSES
 	{
+		int x = getcurx(win);
 		int i;
 		for (i = 0; i < width - x; i++)
 			waddch(win, ' ');

commit 75c0a8a55c31c0a21f7e9e64bc45e87e228a98f6
Author: EGRY Gabor <gaboregry1@t-online.hu>
Date:   Fri Jan 11 23:42:54 2008 +0100

    kconfig: gettext support for lxdialog
    
    Gettext support for lxdialog.
    
    Signed-off-by: Egry Gabor <gaboregry1@t-online.hu>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index fabfc1ad789d..c704712d0227 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -114,7 +114,7 @@ int dialog_textbox(const char *title, const char *tbuf,
 
 	print_title(dialog, title, width);
 
-	print_button(dialog, " Exit ", height - 2, width / 2 - 4, TRUE);
+	print_button(dialog, gettext(" Exit "), height - 2, width / 2 - 4, TRUE);
 	wnoutrefresh(dialog);
 	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
 

commit c8dc68ad0fbd934e78e913b8a8d7b45945db4930
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jul 29 22:48:57 2006 +0200

    kconfig/lxdialog: support resize
    
    In all dialogs now properly catch KEY_RESIZE and take proper action.
    In mconf try to behave sensibly when a dialog routine returns
    -ERRDISPLAYTOOSMALL.
    
    The original check for a screnn size of 80x19 is kept for now.
    It may make sense to remove it later, but thats anyway what
    much text is adjusted for.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index a99e1f497d67..fabfc1ad789d 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -25,22 +25,36 @@ static void back_lines(int n);
 static void print_page(WINDOW * win, int height, int width);
 static void print_line(WINDOW * win, int row, int width);
 static char *get_line(void);
-static void print_position(WINDOW * win, int height, int width);
+static void print_position(WINDOW * win);
 
 static int hscroll;
 static int begin_reached, end_reached, page_length;
 static const char *buf;
 static const char *page;
 
+/*
+ * refresh window content
+ */
+static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
+							  int cur_y, int cur_x)
+{
+	print_page(box, boxh, boxw);
+	print_position(dialog);
+	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+	wrefresh(dialog);
+}
+
+
 /*
  * Display text from a file in a dialog box.
  */
-int dialog_textbox(const char *title, const char *tbuf, int height, int width)
+int dialog_textbox(const char *title, const char *tbuf,
+		   int initial_height, int initial_width)
 {
 	int i, x, y, cur_x, cur_y, key = 0;
-	int texth, textw;
+	int height, width, boxh, boxw;
 	int passed_end;
-	WINDOW *dialog, *text;
+	WINDOW *dialog, *box;
 
 	begin_reached = 1;
 	end_reached = 0;
@@ -49,6 +63,25 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 	buf = tbuf;
 	page = buf;	/* page is pointer to start of page to be displayed */
 
+do_resize:
+	getmaxyx(stdscr, height, width);
+	if (height < 8 || width < 8)
+		return -ERRDISPLAYTOOSMALL;
+	if (initial_height != 0)
+		height = initial_height;
+	else
+		if (height > 4)
+			height -= 4;
+		else
+			height = 0;
+	if (initial_width != 0)
+		width = initial_width;
+	else
+		if (width > 5)
+			width -= 5;
+		else
+			width = 0;
+
 	/* center dialog box on screen */
 	x = (COLS - width) / 2;
 	y = (LINES - height) / 2;
@@ -58,14 +91,14 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 	dialog = newwin(height, width, y, x);
 	keypad(dialog, TRUE);
 
-	/* Create window for text region, used for scrolling text */
-	texth = height - 4;
-	textw = width - 2;
-	text = subwin(dialog, texth, textw, y + 1, x + 1);
-	wattrset(text, dlg.dialog.atr);
-	wbkgdset(text, dlg.dialog.atr & A_COLOR);
+	/* Create window for box region, used for scrolling text */
+	boxh = height - 4;
+	boxw = width - 2;
+	box = subwin(dialog, boxh, boxw, y + 1, x + 1);
+	wattrset(box, dlg.dialog.atr);
+	wbkgdset(box, dlg.dialog.atr & A_COLOR);
 
-	keypad(text, TRUE);
+	keypad(box, TRUE);
 
 	/* register the new window, along with its borders */
 	draw_box(dialog, 0, 0, height, width,
@@ -86,11 +119,8 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
 
 	/* Print first page of text */
-	attr_clear(text, texth, textw, dlg.dialog.atr);
-	print_page(text, texth, textw);
-	print_position(dialog, height, width);
-	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
-	wrefresh(dialog);
+	attr_clear(box, boxh, boxw, dlg.dialog.atr);
+	refresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);
 
 	while ((key != KEY_ESC) && (key != '\n')) {
 		key = wgetch(dialog);
@@ -99,7 +129,7 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 		case 'e':
 		case 'X':
 		case 'x':
-			delwin(text);
+			delwin(box);
 			delwin(dialog);
 			return 0;
 		case 'g':	/* First page */
@@ -107,10 +137,8 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 			if (!begin_reached) {
 				begin_reached = 1;
 				page = buf;
-				print_page(text, texth, textw);
-				print_position(dialog, height, width);
-				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
-				wrefresh(dialog);
+				refresh_text_box(dialog, box, boxh, boxw,
+						 cur_y, cur_x);
 			}
 			break;
 		case 'G':	/* Last page */
@@ -119,11 +147,9 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 			end_reached = 1;
 			/* point to last char in buf */
 			page = buf + strlen(buf);
-			back_lines(texth);
-			print_page(text, texth, textw);
-			print_position(dialog, height, width);
-			wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
-			wrefresh(dialog);
+			back_lines(boxh);
+			refresh_text_box(dialog, box, boxh, boxw,
+					 cur_y, cur_x);
 			break;
 		case 'K':	/* Previous line */
 		case 'k':
@@ -138,16 +164,16 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 				 * point to start of next page. This is done
 				 * by calling get_line() in the following
 				 * 'for' loop. */
-				scrollok(text, TRUE);
-				wscrl(text, -1);	/* Scroll text region down one line */
-				scrollok(text, FALSE);
+				scrollok(box, TRUE);
+				wscrl(box, -1);	/* Scroll box region down one line */
+				scrollok(box, FALSE);
 				page_length = 0;
 				passed_end = 0;
-				for (i = 0; i < texth; i++) {
+				for (i = 0; i < boxh; i++) {
 					if (!i) {
 						/* print first line of page */
-						print_line(text, 0, textw);
-						wnoutrefresh(text);
+						print_line(box, 0, boxw);
+						wnoutrefresh(box);
 					} else
 						/* Called to update 'end_reached' and 'page' */
 						get_line();
@@ -157,7 +183,7 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 						passed_end = 1;
 				}
 
-				print_position(dialog, height, width);
+				print_position(dialog);
 				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 				wrefresh(dialog);
 			}
@@ -167,23 +193,21 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 		case KEY_PPAGE:
 			if (begin_reached)
 				break;
-			back_lines(page_length + texth);
-			print_page(text, texth, textw);
-			print_position(dialog, height, width);
-			wmove(dialog, cur_y, cur_x);
-			wrefresh(dialog);
+			back_lines(page_length + boxh);
+			refresh_text_box(dialog, box, boxh, boxw,
+					 cur_y, cur_x);
 			break;
 		case 'J':	/* Next line */
 		case 'j':
 		case KEY_DOWN:
 			if (!end_reached) {
 				begin_reached = 0;
-				scrollok(text, TRUE);
-				scroll(text);	/* Scroll text region up one line */
-				scrollok(text, FALSE);
-				print_line(text, texth - 1, textw);
-				wnoutrefresh(text);
-				print_position(dialog, height, width);
+				scrollok(box, TRUE);
+				scroll(box);	/* Scroll box region up one line */
+				scrollok(box, FALSE);
+				print_line(box, boxh - 1, boxw);
+				wnoutrefresh(box);
+				print_position(dialog);
 				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 				wrefresh(dialog);
 			}
@@ -194,10 +218,8 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 				break;
 
 			begin_reached = 0;
-			print_page(text, texth, textw);
-			print_position(dialog, height, width);
-			wmove(dialog, cur_y, cur_x);
-			wrefresh(dialog);
+			refresh_text_box(dialog, box, boxh, boxw,
+					 cur_y, cur_x);
 			break;
 		case '0':	/* Beginning of line */
 		case 'H':	/* Scroll left */
@@ -212,9 +234,8 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 				hscroll--;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			print_page(text, texth, textw);
-			wmove(dialog, cur_y, cur_x);
-			wrefresh(dialog);
+			refresh_text_box(dialog, box, boxh, boxw,
+					 cur_y, cur_x);
 			break;
 		case 'L':	/* Scroll right */
 		case 'l':
@@ -224,16 +245,21 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 			hscroll++;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			print_page(text, texth, textw);
-			wmove(dialog, cur_y, cur_x);
-			wrefresh(dialog);
+			refresh_text_box(dialog, box, boxh, boxw,
+					 cur_y, cur_x);
 			break;
 		case KEY_ESC:
 			key = on_key_esc(dialog);
 			break;
+		case KEY_RESIZE:
+			back_lines(height);
+			delwin(box);
+			delwin(dialog);
+			on_key_resize();
+			goto do_resize;
 		}
 	}
-	delwin(text);
+	delwin(box);
 	delwin(dialog);
 	return key;		/* ESC pressed */
 }
@@ -353,13 +379,13 @@ static char *get_line(void)
 /*
  * Print current position
  */
-static void print_position(WINDOW * win, int height, int width)
+static void print_position(WINDOW * win)
 {
 	int percent;
 
 	wattrset(win, dlg.position_indicator.atr);
 	wbkgdset(win, dlg.position_indicator.atr & A_COLOR);
 	percent = (page - buf) * 100 / strlen(buf);
-	wmove(win, height - 3, width - 9);
+	wmove(win, getmaxy(win) - 3, getmaxx(win) - 9);
 	wprintw(win, "(%3d%%)", percent);
 }

commit f3cbcdc955d0d2c8b4c52d6b73fc536b01b68c64
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Jul 28 23:57:48 2006 +0200

    kconfig/lxdialog: let <ESC><ESC> behave as expected
    
    <ESC><ESC> is used to step one back in the dialogs.
    When lxdialog became built-in pressing <ESC> once would cause one step back
    and pressing <ESC><ESC> would cause two steps back.
    This patch - based on concept from Roman Zippel <zippel@linux-m68k.org> -
    makes one <ESC> a noop and pressing <ESC><ESC> will cause one step backward.
    
    In addition the final yes/no dialog now has the option to go back to the
    the kernel configuration. So if you get too far out you can now go back
    to configuring the kernel without saving and starting all over again.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 86b0770b0387..a99e1f497d67 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -92,7 +92,7 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 	wrefresh(dialog);
 
-	while ((key != ESC) && (key != '\n')) {
+	while ((key != KEY_ESC) && (key != '\n')) {
 		key = wgetch(dialog);
 		switch (key) {
 		case 'E':	/* Exit */
@@ -228,13 +228,14 @@ int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 			wmove(dialog, cur_y, cur_x);
 			wrefresh(dialog);
 			break;
-		case ESC:
+		case KEY_ESC:
+			key = on_key_esc(dialog);
 			break;
 		}
 	}
 	delwin(text);
 	delwin(dialog);
-	return 255;		/* ESC pressed */
+	return key;		/* ESC pressed */
 }
 
 /*

commit 2982de6993e6d9944f2215d7cb9b558b465a0c99
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Thu Jul 27 22:10:27 2006 +0200

    kconfig/menuconfig: lxdialog is now built-in
    
    lxdialog was previously called as an external program causing screen
    to flicker when used. With this patch lxdialog is now built-in.
    It is loosly based om previous work by:  Petr Baudis <pasky@ucw.cz>
    
    Following is a list of changes:
    o Moved build of dialog routings to kconfig Makefile
    o menubox + checklist uses a new item list to hold all menu items
    o in util.c implmented helper function to deal with item list
    o menubox now uses parameters to save scroll state (avoids temp file)
    o textbox now get text to be displayed as parameter and not a file
    o make sure to properly delete subwin's before main windows
    o killed unused files: lxdialog.c msgbox.c
    o modified return value for ESC to match direct calling
    o in a few places the code has been adjusted to 80 char wide
    o in textbox a small refactoring was made to make code remotely readable
    o in mconf removed all unused stuff (functions/variables)
    
    Following is a list of know short comings:
    a) pressing ESC twice will be interpreted as two ESC presses
    b) resize does not work. menuconfig needs to be restarted to be adjusted
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 336793b03954..86b0770b0387 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -27,54 +27,27 @@ static void print_line(WINDOW * win, int row, int width);
 static char *get_line(void);
 static void print_position(WINDOW * win, int height, int width);
 
-static int hscroll, fd, file_size, bytes_read;
-static int begin_reached = 1, end_reached, page_length;
-static char *buf, *page;
+static int hscroll;
+static int begin_reached, end_reached, page_length;
+static const char *buf;
+static const char *page;
 
 /*
  * Display text from a file in a dialog box.
  */
-int dialog_textbox(const char *title, const char *file, int height, int width)
+int dialog_textbox(const char *title, const char *tbuf, int height, int width)
 {
-	int i, x, y, cur_x, cur_y, fpos, key = 0;
+	int i, x, y, cur_x, cur_y, key = 0;
+	int texth, textw;
 	int passed_end;
-	char search_term[MAX_LEN + 1];
 	WINDOW *dialog, *text;
 
-	search_term[0] = '\0';	/* no search term entered yet */
-
-	/* Open input file for reading */
-	if ((fd = open(file, O_RDONLY)) == -1) {
-		endwin();
-		fprintf(stderr, "\nCan't open input file in dialog_textbox().\n");
-		exit(-1);
-	}
-	/* Get file size. Actually, 'file_size' is the real file size - 1,
-	   since it's only the last byte offset from the beginning */
-	if ((file_size = lseek(fd, 0, SEEK_END)) == -1) {
-		endwin();
-		fprintf(stderr, "\nError getting file size in dialog_textbox().\n");
-		exit(-1);
-	}
-	/* Restore file pointer to beginning of file after getting file size */
-	if (lseek(fd, 0, SEEK_SET) == -1) {
-		endwin();
-		fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
-		exit(-1);
-	}
-	/* Allocate space for read buffer */
-	if ((buf = malloc(BUF_SIZE + 1)) == NULL) {
-		endwin();
-		fprintf(stderr, "\nCan't allocate memory in dialog_textbox().\n");
-		exit(-1);
-	}
-	if ((bytes_read = read(fd, buf, BUF_SIZE)) == -1) {
-		endwin();
-		fprintf(stderr, "\nError reading file in dialog_textbox().\n");
-		exit(-1);
-	}
-	buf[bytes_read] = '\0';	/* mark end of valid data */
-	page = buf;		/* page is pointer to start of page to be displayed */
+	begin_reached = 1;
+	end_reached = 0;
+	page_length = 0;
+	hscroll = 0;
+	buf = tbuf;
+	page = buf;	/* page is pointer to start of page to be displayed */
 
 	/* center dialog box on screen */
 	x = (COLS - width) / 2;
@@ -86,7 +59,9 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 	keypad(dialog, TRUE);
 
 	/* Create window for text region, used for scrolling text */
-	text = subwin(dialog, height - 4, width - 2, y + 1, x + 1);
+	texth = height - 4;
+	textw = width - 2;
+	text = subwin(dialog, texth, textw, y + 1, x + 1);
 	wattrset(text, dlg.dialog.atr);
 	wbkgdset(text, dlg.dialog.atr & A_COLOR);
 
@@ -111,8 +86,8 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
 
 	/* Print first page of text */
-	attr_clear(text, height - 4, width - 2, dlg.dialog.atr);
-	print_page(text, height - 4, width - 2);
+	attr_clear(text, texth, textw, dlg.dialog.atr);
+	print_page(text, texth, textw);
 	print_position(dialog, height, width);
 	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 	wrefresh(dialog);
@@ -124,37 +99,15 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 		case 'e':
 		case 'X':
 		case 'x':
+			delwin(text);
 			delwin(dialog);
-			free(buf);
-			close(fd);
 			return 0;
 		case 'g':	/* First page */
 		case KEY_HOME:
 			if (!begin_reached) {
 				begin_reached = 1;
-				/* First page not in buffer? */
-				if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-					endwin();
-					fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
-					exit(-1);
-				}
-				if (fpos > bytes_read) {	/* Yes, we have to read it in */
-					if (lseek(fd, 0, SEEK_SET) == -1) {
-						endwin();
-						fprintf(stderr, "\nError moving file pointer in "
-							        "dialog_textbox().\n");
-						exit(-1);
-					}
-					if ((bytes_read =
-					     read(fd, buf, BUF_SIZE)) == -1) {
-						endwin();
-						fprintf(stderr, "\nError reading file in dialog_textbox().\n");
-						exit(-1);
-					}
-					buf[bytes_read] = '\0';
-				}
 				page = buf;
-				print_page(text, height - 4, width - 2);
+				print_page(text, texth, textw);
 				print_position(dialog, height, width);
 				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 				wrefresh(dialog);
@@ -164,29 +117,10 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 		case KEY_END:
 
 			end_reached = 1;
-			/* Last page not in buffer? */
-			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-				endwin();
-				fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
-				exit(-1);
-			}
-			if (fpos < file_size) {	/* Yes, we have to read it in */
-				if (lseek(fd, -BUF_SIZE, SEEK_END) == -1) {
-					endwin();
-					fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
-					exit(-1);
-				}
-				if ((bytes_read =
-				     read(fd, buf, BUF_SIZE)) == -1) {
-					endwin();
-					fprintf(stderr, "\nError reading file in dialog_textbox().\n");
-					exit(-1);
-				}
-				buf[bytes_read] = '\0';
-			}
-			page = buf + bytes_read;
-			back_lines(height - 4);
-			print_page(text, height - 4, width - 2);
+			/* point to last char in buf */
+			page = buf + strlen(buf);
+			back_lines(texth);
+			print_page(text, texth, textw);
 			print_position(dialog, height, width);
 			wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
 			wrefresh(dialog);
@@ -197,20 +131,22 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 			if (!begin_reached) {
 				back_lines(page_length + 1);
 
-				/* We don't call print_page() here but use scrolling to ensure
-				   faster screen update. However, 'end_reached' and
-				   'page_length' should still be updated, and 'page' should
-				   point to start of next page. This is done by calling
-				   get_line() in the following 'for' loop. */
+				/* We don't call print_page() here but use
+				 * scrolling to ensure faster screen update.
+				 * However, 'end_reached' and 'page_length'
+				 * should still be updated, and 'page' should
+				 * point to start of next page. This is done
+				 * by calling get_line() in the following
+				 * 'for' loop. */
 				scrollok(text, TRUE);
 				wscrl(text, -1);	/* Scroll text region down one line */
 				scrollok(text, FALSE);
 				page_length = 0;
 				passed_end = 0;
-				for (i = 0; i < height - 4; i++) {
+				for (i = 0; i < texth; i++) {
 					if (!i) {
 						/* print first line of page */
-						print_line(text, 0, width - 2);
+						print_line(text, 0, textw);
 						wnoutrefresh(text);
 					} else
 						/* Called to update 'end_reached' and 'page' */
@@ -231,8 +167,8 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 		case KEY_PPAGE:
 			if (begin_reached)
 				break;
-			back_lines(page_length + height - 4);
-			print_page(text, height - 4, width - 2);
+			back_lines(page_length + texth);
+			print_page(text, texth, textw);
 			print_position(dialog, height, width);
 			wmove(dialog, cur_y, cur_x);
 			wrefresh(dialog);
@@ -245,7 +181,7 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 				scrollok(text, TRUE);
 				scroll(text);	/* Scroll text region up one line */
 				scrollok(text, FALSE);
-				print_line(text, height - 5, width - 2);
+				print_line(text, texth - 1, textw);
 				wnoutrefresh(text);
 				print_position(dialog, height, width);
 				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
@@ -258,7 +194,7 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 				break;
 
 			begin_reached = 0;
-			print_page(text, height - 4, width - 2);
+			print_page(text, texth, textw);
 			print_position(dialog, height, width);
 			wmove(dialog, cur_y, cur_x);
 			wrefresh(dialog);
@@ -276,7 +212,7 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 				hscroll--;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			print_page(text, height - 4, width - 2);
+			print_page(text, texth, textw);
 			wmove(dialog, cur_y, cur_x);
 			wrefresh(dialog);
 			break;
@@ -288,7 +224,7 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 			hscroll++;
 			/* Reprint current page to scroll horizontally */
 			back_lines(page_length);
-			print_page(text, height - 4, width - 2);
+			print_page(text, texth, textw);
 			wmove(dialog, cur_y, cur_x);
 			wrefresh(dialog);
 			break;
@@ -296,123 +232,42 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 			break;
 		}
 	}
-
+	delwin(text);
 	delwin(dialog);
-	free(buf);
-	close(fd);
-	return -1;		/* ESC pressed */
+	return 255;		/* ESC pressed */
 }
 
 /*
- * Go back 'n' lines in text file. Called by dialog_textbox().
+ * Go back 'n' lines in text. Called by dialog_textbox().
  * 'page' will be updated to point to the desired line in 'buf'.
  */
 static void back_lines(int n)
 {
-	int i, fpos;
+	int i;
 
 	begin_reached = 0;
-	/* We have to distinguish between end_reached and !end_reached
-	   since at end of file, the line is not ended by a '\n'.
-	   The code inside 'if' basically does a '--page' to move one
-	   character backward so as to skip '\n' of the previous line */
-	if (!end_reached) {
-		/* Either beginning of buffer or beginning of file reached? */
-		if (page == buf) {
-			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-				endwin();
-				fprintf(stderr, "\nError moving file pointer in "
-					        "back_lines().\n");
-				exit(-1);
-			}
-			if (fpos > bytes_read) {	/* Not beginning of file yet */
-				/* We've reached beginning of buffer, but not beginning of
-				   file yet, so read previous part of file into buffer.
-				   Note that we only move backward for BUF_SIZE/2 bytes,
-				   but not BUF_SIZE bytes to avoid re-reading again in
-				   print_page() later */
-				/* Really possible to move backward BUF_SIZE/2 bytes? */
-				if (fpos < BUF_SIZE / 2 + bytes_read) {
-					/* No, move less then */
-					if (lseek(fd, 0, SEEK_SET) == -1) {
-						endwin();
-						fprintf(stderr, "\nError moving file pointer in "
-						                "back_lines().\n");
-						exit(-1);
-					}
-					page = buf + fpos - bytes_read;
-				} else {	/* Move backward BUF_SIZE/2 bytes */
-					if (lseek (fd, -(BUF_SIZE / 2 + bytes_read), SEEK_CUR) == -1) {
-						endwin();
-						fprintf(stderr, "\nError moving file pointer "
-						                "in back_lines().\n");
-						exit(-1);
-					}
-					page = buf + BUF_SIZE / 2;
-				}
-				if ((bytes_read =
-				     read(fd, buf, BUF_SIZE)) == -1) {
-					endwin();
-					fprintf(stderr, "\nError reading file in back_lines().\n");
-					exit(-1);
-				}
-				buf[bytes_read] = '\0';
-			} else {	/* Beginning of file reached */
-				begin_reached = 1;
-				return;
+	/* Go back 'n' lines */
+	for (i = 0; i < n; i++) {
+		if (*page == '\0') {
+			if (end_reached) {
+				end_reached = 0;
+				continue;
 			}
 		}
-		if (*(--page) != '\n') {	/* '--page' here */
-			/* Something's wrong... */
-			endwin();
-			fprintf(stderr, "\nInternal error in back_lines().\n");
-			exit(-1);
+		if (page == buf) {
+			begin_reached = 1;
+			return;
 		}
-	}
-	/* Go back 'n' lines */
-	for (i = 0; i < n; i++)
+		page--;
 		do {
 			if (page == buf) {
-				if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-					endwin();
-					fprintf(stderr, "\nError moving file pointer in back_lines().\n");
-					exit(-1);
-				}
-				if (fpos > bytes_read) {
-					/* Really possible to move backward BUF_SIZE/2 bytes? */
-					if (fpos < BUF_SIZE / 2 + bytes_read) {
-						/* No, move less then */
-						if (lseek(fd, 0, SEEK_SET) == -1) {
-							endwin();
-							fprintf(stderr, "\nError moving file pointer "
-							                "in back_lines().\n");
-							exit(-1);
-						}
-						page = buf + fpos - bytes_read;
-					} else {	/* Move backward BUF_SIZE/2 bytes */
-						if (lseek (fd, -(BUF_SIZE / 2 + bytes_read), SEEK_CUR) == -1) {
-							endwin();
-							fprintf(stderr, "\nError moving file pointer"
-							                " in back_lines().\n");
-							exit(-1);
-						}
-						page = buf + BUF_SIZE / 2;
-					}
-					if ((bytes_read =
-					     read(fd, buf, BUF_SIZE)) == -1) {
-						endwin();
-						fprintf(stderr, "\nError reading file in "
-						                "back_lines().\n");
-						exit(-1);
-					}
-					buf[bytes_read] = '\0';
-				} else {	/* Beginning of file reached */
-					begin_reached = 1;
-					return;
-				}
+				begin_reached = 1;
+				return;
 			}
-		} while (*(--page) != '\n');
-	page++;
+			page--;
+		} while (*page != '\n');
+		page++;
+	}
 }
 
 /*
@@ -467,33 +322,14 @@ static void print_line(WINDOW * win, int row, int width)
  */
 static char *get_line(void)
 {
-	int i = 0, fpos;
+	int i = 0;
 	static char line[MAX_LEN + 1];
 
 	end_reached = 0;
 	while (*page != '\n') {
 		if (*page == '\0') {
-			/* Either end of file or end of buffer reached */
-			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-				endwin();
-				fprintf(stderr, "\nError moving file pointer in "
-				                "get_line().\n");
-				exit(-1);
-			}
-			if (fpos < file_size) {	/* Not end of file yet */
-				/* We've reached end of buffer, but not end of file yet,
-				   so read next part of file into buffer */
-				if ((bytes_read =
-				     read(fd, buf, BUF_SIZE)) == -1) {
-					endwin();
-					fprintf(stderr, "\nError reading file in get_line().\n");
-					exit(-1);
-				}
-				buf[bytes_read] = '\0';
-				page = buf;
-			} else {
-				if (!end_reached)
-					end_reached = 1;
+			if (!end_reached) {
+				end_reached = 1;
 				break;
 			}
 		} else if (i < MAX_LEN)
@@ -518,17 +354,11 @@ static char *get_line(void)
  */
 static void print_position(WINDOW * win, int height, int width)
 {
-	int fpos, percent;
+	int percent;
 
-	if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
-		endwin();
-		fprintf(stderr, "\nError moving file pointer in print_position().\n");
-		exit(-1);
-	}
 	wattrset(win, dlg.position_indicator.atr);
 	wbkgdset(win, dlg.position_indicator.atr & A_COLOR);
-	percent = !file_size ?
-	    100 : ((fpos - bytes_read + page - buf) * 100) / file_size;
+	percent = (page - buf) * 100 / strlen(buf);
 	wmove(win, height - 3, width - 9);
 	wprintw(win, "(%3d%%)", percent);
 }

commit 98e5a1579e7d34fe3803240750a1c48efcd9cb15
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Mon Jul 24 21:40:46 2006 +0200

    kconfig/lxdialog: refactor color support
    
    Clean up and refactor color support. All color support are now
    in util.c including color definitions.
    In the process introduced a global variable named 'dlg' which is
    used all over to set color - thats the reason why all files are changed.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index 77848bb8e07f..336793b03954 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -87,20 +87,21 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 
 	/* Create window for text region, used for scrolling text */
 	text = subwin(dialog, height - 4, width - 2, y + 1, x + 1);
-	wattrset(text, dialog_attr);
-	wbkgdset(text, dialog_attr & A_COLOR);
+	wattrset(text, dlg.dialog.atr);
+	wbkgdset(text, dlg.dialog.atr & A_COLOR);
 
 	keypad(text, TRUE);
 
 	/* register the new window, along with its borders */
-	draw_box(dialog, 0, 0, height, width, dialog_attr, border_attr);
+	draw_box(dialog, 0, 0, height, width,
+		 dlg.dialog.atr, dlg.border.atr);
 
-	wattrset(dialog, border_attr);
+	wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dialog_attr);
-	wbkgdset(dialog, dialog_attr & A_COLOR);
+	wattrset(dialog, dlg.dialog.atr);
+	wbkgdset(dialog, dlg.dialog.atr & A_COLOR);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
@@ -110,7 +111,7 @@ int dialog_textbox(const char *title, const char *file, int height, int width)
 	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
 
 	/* Print first page of text */
-	attr_clear(text, height - 4, width - 2, dialog_attr);
+	attr_clear(text, height - 4, width - 2, dlg.dialog.atr);
 	print_page(text, height - 4, width - 2);
 	print_position(dialog, height, width);
 	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
@@ -524,8 +525,8 @@ static void print_position(WINDOW * win, int height, int width)
 		fprintf(stderr, "\nError moving file pointer in print_position().\n");
 		exit(-1);
 	}
-	wattrset(win, position_indicator_attr);
-	wbkgdset(win, position_indicator_attr & A_COLOR);
+	wattrset(win, dlg.position_indicator.atr);
+	wbkgdset(win, dlg.position_indicator.atr & A_COLOR);
 	percent = !file_size ?
 	    100 : ((fpos - bytes_read + page - buf) * 100) / file_size;
 	wmove(win, height - 3, width - 9);

commit 6f6046cff2e8f04d6b916b10ebaa7b40d7e7967a
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Dec 16 21:35:19 2005 +0100

    kconfig: move lxdialog to scripts/kconfig/lxdialog
    
    The only lxdialog user i kconfig - for menuconfig.
    So move it to reflect this.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
new file mode 100644
index 000000000000..77848bb8e07f
--- /dev/null
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -0,0 +1,533 @@
+/*
+ *  textbox.c -- implements the text box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+static void back_lines(int n);
+static void print_page(WINDOW * win, int height, int width);
+static void print_line(WINDOW * win, int row, int width);
+static char *get_line(void);
+static void print_position(WINDOW * win, int height, int width);
+
+static int hscroll, fd, file_size, bytes_read;
+static int begin_reached = 1, end_reached, page_length;
+static char *buf, *page;
+
+/*
+ * Display text from a file in a dialog box.
+ */
+int dialog_textbox(const char *title, const char *file, int height, int width)
+{
+	int i, x, y, cur_x, cur_y, fpos, key = 0;
+	int passed_end;
+	char search_term[MAX_LEN + 1];
+	WINDOW *dialog, *text;
+
+	search_term[0] = '\0';	/* no search term entered yet */
+
+	/* Open input file for reading */
+	if ((fd = open(file, O_RDONLY)) == -1) {
+		endwin();
+		fprintf(stderr, "\nCan't open input file in dialog_textbox().\n");
+		exit(-1);
+	}
+	/* Get file size. Actually, 'file_size' is the real file size - 1,
+	   since it's only the last byte offset from the beginning */
+	if ((file_size = lseek(fd, 0, SEEK_END)) == -1) {
+		endwin();
+		fprintf(stderr, "\nError getting file size in dialog_textbox().\n");
+		exit(-1);
+	}
+	/* Restore file pointer to beginning of file after getting file size */
+	if (lseek(fd, 0, SEEK_SET) == -1) {
+		endwin();
+		fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
+		exit(-1);
+	}
+	/* Allocate space for read buffer */
+	if ((buf = malloc(BUF_SIZE + 1)) == NULL) {
+		endwin();
+		fprintf(stderr, "\nCan't allocate memory in dialog_textbox().\n");
+		exit(-1);
+	}
+	if ((bytes_read = read(fd, buf, BUF_SIZE)) == -1) {
+		endwin();
+		fprintf(stderr, "\nError reading file in dialog_textbox().\n");
+		exit(-1);
+	}
+	buf[bytes_read] = '\0';	/* mark end of valid data */
+	page = buf;		/* page is pointer to start of page to be displayed */
+
+	/* center dialog box on screen */
+	x = (COLS - width) / 2;
+	y = (LINES - height) / 2;
+
+	draw_shadow(stdscr, y, x, height, width);
+
+	dialog = newwin(height, width, y, x);
+	keypad(dialog, TRUE);
+
+	/* Create window for text region, used for scrolling text */
+	text = subwin(dialog, height - 4, width - 2, y + 1, x + 1);
+	wattrset(text, dialog_attr);
+	wbkgdset(text, dialog_attr & A_COLOR);
+
+	keypad(text, TRUE);
+
+	/* register the new window, along with its borders */
+	draw_box(dialog, 0, 0, height, width, dialog_attr, border_attr);
+
+	wattrset(dialog, border_attr);
+	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
+	for (i = 0; i < width - 2; i++)
+		waddch(dialog, ACS_HLINE);
+	wattrset(dialog, dialog_attr);
+	wbkgdset(dialog, dialog_attr & A_COLOR);
+	waddch(dialog, ACS_RTEE);
+
+	print_title(dialog, title, width);
+
+	print_button(dialog, " Exit ", height - 2, width / 2 - 4, TRUE);
+	wnoutrefresh(dialog);
+	getyx(dialog, cur_y, cur_x);	/* Save cursor position */
+
+	/* Print first page of text */
+	attr_clear(text, height - 4, width - 2, dialog_attr);
+	print_page(text, height - 4, width - 2);
+	print_position(dialog, height, width);
+	wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+	wrefresh(dialog);
+
+	while ((key != ESC) && (key != '\n')) {
+		key = wgetch(dialog);
+		switch (key) {
+		case 'E':	/* Exit */
+		case 'e':
+		case 'X':
+		case 'x':
+			delwin(dialog);
+			free(buf);
+			close(fd);
+			return 0;
+		case 'g':	/* First page */
+		case KEY_HOME:
+			if (!begin_reached) {
+				begin_reached = 1;
+				/* First page not in buffer? */
+				if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+					endwin();
+					fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
+					exit(-1);
+				}
+				if (fpos > bytes_read) {	/* Yes, we have to read it in */
+					if (lseek(fd, 0, SEEK_SET) == -1) {
+						endwin();
+						fprintf(stderr, "\nError moving file pointer in "
+							        "dialog_textbox().\n");
+						exit(-1);
+					}
+					if ((bytes_read =
+					     read(fd, buf, BUF_SIZE)) == -1) {
+						endwin();
+						fprintf(stderr, "\nError reading file in dialog_textbox().\n");
+						exit(-1);
+					}
+					buf[bytes_read] = '\0';
+				}
+				page = buf;
+				print_page(text, height - 4, width - 2);
+				print_position(dialog, height, width);
+				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+				wrefresh(dialog);
+			}
+			break;
+		case 'G':	/* Last page */
+		case KEY_END:
+
+			end_reached = 1;
+			/* Last page not in buffer? */
+			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+				endwin();
+				fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
+				exit(-1);
+			}
+			if (fpos < file_size) {	/* Yes, we have to read it in */
+				if (lseek(fd, -BUF_SIZE, SEEK_END) == -1) {
+					endwin();
+					fprintf(stderr, "\nError moving file pointer in dialog_textbox().\n");
+					exit(-1);
+				}
+				if ((bytes_read =
+				     read(fd, buf, BUF_SIZE)) == -1) {
+					endwin();
+					fprintf(stderr, "\nError reading file in dialog_textbox().\n");
+					exit(-1);
+				}
+				buf[bytes_read] = '\0';
+			}
+			page = buf + bytes_read;
+			back_lines(height - 4);
+			print_page(text, height - 4, width - 2);
+			print_position(dialog, height, width);
+			wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+			wrefresh(dialog);
+			break;
+		case 'K':	/* Previous line */
+		case 'k':
+		case KEY_UP:
+			if (!begin_reached) {
+				back_lines(page_length + 1);
+
+				/* We don't call print_page() here but use scrolling to ensure
+				   faster screen update. However, 'end_reached' and
+				   'page_length' should still be updated, and 'page' should
+				   point to start of next page. This is done by calling
+				   get_line() in the following 'for' loop. */
+				scrollok(text, TRUE);
+				wscrl(text, -1);	/* Scroll text region down one line */
+				scrollok(text, FALSE);
+				page_length = 0;
+				passed_end = 0;
+				for (i = 0; i < height - 4; i++) {
+					if (!i) {
+						/* print first line of page */
+						print_line(text, 0, width - 2);
+						wnoutrefresh(text);
+					} else
+						/* Called to update 'end_reached' and 'page' */
+						get_line();
+					if (!passed_end)
+						page_length++;
+					if (end_reached && !passed_end)
+						passed_end = 1;
+				}
+
+				print_position(dialog, height, width);
+				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+				wrefresh(dialog);
+			}
+			break;
+		case 'B':	/* Previous page */
+		case 'b':
+		case KEY_PPAGE:
+			if (begin_reached)
+				break;
+			back_lines(page_length + height - 4);
+			print_page(text, height - 4, width - 2);
+			print_position(dialog, height, width);
+			wmove(dialog, cur_y, cur_x);
+			wrefresh(dialog);
+			break;
+		case 'J':	/* Next line */
+		case 'j':
+		case KEY_DOWN:
+			if (!end_reached) {
+				begin_reached = 0;
+				scrollok(text, TRUE);
+				scroll(text);	/* Scroll text region up one line */
+				scrollok(text, FALSE);
+				print_line(text, height - 5, width - 2);
+				wnoutrefresh(text);
+				print_position(dialog, height, width);
+				wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
+				wrefresh(dialog);
+			}
+			break;
+		case KEY_NPAGE:	/* Next page */
+		case ' ':
+			if (end_reached)
+				break;
+
+			begin_reached = 0;
+			print_page(text, height - 4, width - 2);
+			print_position(dialog, height, width);
+			wmove(dialog, cur_y, cur_x);
+			wrefresh(dialog);
+			break;
+		case '0':	/* Beginning of line */
+		case 'H':	/* Scroll left */
+		case 'h':
+		case KEY_LEFT:
+			if (hscroll <= 0)
+				break;
+
+			if (key == '0')
+				hscroll = 0;
+			else
+				hscroll--;
+			/* Reprint current page to scroll horizontally */
+			back_lines(page_length);
+			print_page(text, height - 4, width - 2);
+			wmove(dialog, cur_y, cur_x);
+			wrefresh(dialog);
+			break;
+		case 'L':	/* Scroll right */
+		case 'l':
+		case KEY_RIGHT:
+			if (hscroll >= MAX_LEN)
+				break;
+			hscroll++;
+			/* Reprint current page to scroll horizontally */
+			back_lines(page_length);
+			print_page(text, height - 4, width - 2);
+			wmove(dialog, cur_y, cur_x);
+			wrefresh(dialog);
+			break;
+		case ESC:
+			break;
+		}
+	}
+
+	delwin(dialog);
+	free(buf);
+	close(fd);
+	return -1;		/* ESC pressed */
+}
+
+/*
+ * Go back 'n' lines in text file. Called by dialog_textbox().
+ * 'page' will be updated to point to the desired line in 'buf'.
+ */
+static void back_lines(int n)
+{
+	int i, fpos;
+
+	begin_reached = 0;
+	/* We have to distinguish between end_reached and !end_reached
+	   since at end of file, the line is not ended by a '\n'.
+	   The code inside 'if' basically does a '--page' to move one
+	   character backward so as to skip '\n' of the previous line */
+	if (!end_reached) {
+		/* Either beginning of buffer or beginning of file reached? */
+		if (page == buf) {
+			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+				endwin();
+				fprintf(stderr, "\nError moving file pointer in "
+					        "back_lines().\n");
+				exit(-1);
+			}
+			if (fpos > bytes_read) {	/* Not beginning of file yet */
+				/* We've reached beginning of buffer, but not beginning of
+				   file yet, so read previous part of file into buffer.
+				   Note that we only move backward for BUF_SIZE/2 bytes,
+				   but not BUF_SIZE bytes to avoid re-reading again in
+				   print_page() later */
+				/* Really possible to move backward BUF_SIZE/2 bytes? */
+				if (fpos < BUF_SIZE / 2 + bytes_read) {
+					/* No, move less then */
+					if (lseek(fd, 0, SEEK_SET) == -1) {
+						endwin();
+						fprintf(stderr, "\nError moving file pointer in "
+						                "back_lines().\n");
+						exit(-1);
+					}
+					page = buf + fpos - bytes_read;
+				} else {	/* Move backward BUF_SIZE/2 bytes */
+					if (lseek (fd, -(BUF_SIZE / 2 + bytes_read), SEEK_CUR) == -1) {
+						endwin();
+						fprintf(stderr, "\nError moving file pointer "
+						                "in back_lines().\n");
+						exit(-1);
+					}
+					page = buf + BUF_SIZE / 2;
+				}
+				if ((bytes_read =
+				     read(fd, buf, BUF_SIZE)) == -1) {
+					endwin();
+					fprintf(stderr, "\nError reading file in back_lines().\n");
+					exit(-1);
+				}
+				buf[bytes_read] = '\0';
+			} else {	/* Beginning of file reached */
+				begin_reached = 1;
+				return;
+			}
+		}
+		if (*(--page) != '\n') {	/* '--page' here */
+			/* Something's wrong... */
+			endwin();
+			fprintf(stderr, "\nInternal error in back_lines().\n");
+			exit(-1);
+		}
+	}
+	/* Go back 'n' lines */
+	for (i = 0; i < n; i++)
+		do {
+			if (page == buf) {
+				if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+					endwin();
+					fprintf(stderr, "\nError moving file pointer in back_lines().\n");
+					exit(-1);
+				}
+				if (fpos > bytes_read) {
+					/* Really possible to move backward BUF_SIZE/2 bytes? */
+					if (fpos < BUF_SIZE / 2 + bytes_read) {
+						/* No, move less then */
+						if (lseek(fd, 0, SEEK_SET) == -1) {
+							endwin();
+							fprintf(stderr, "\nError moving file pointer "
+							                "in back_lines().\n");
+							exit(-1);
+						}
+						page = buf + fpos - bytes_read;
+					} else {	/* Move backward BUF_SIZE/2 bytes */
+						if (lseek (fd, -(BUF_SIZE / 2 + bytes_read), SEEK_CUR) == -1) {
+							endwin();
+							fprintf(stderr, "\nError moving file pointer"
+							                " in back_lines().\n");
+							exit(-1);
+						}
+						page = buf + BUF_SIZE / 2;
+					}
+					if ((bytes_read =
+					     read(fd, buf, BUF_SIZE)) == -1) {
+						endwin();
+						fprintf(stderr, "\nError reading file in "
+						                "back_lines().\n");
+						exit(-1);
+					}
+					buf[bytes_read] = '\0';
+				} else {	/* Beginning of file reached */
+					begin_reached = 1;
+					return;
+				}
+			}
+		} while (*(--page) != '\n');
+	page++;
+}
+
+/*
+ * Print a new page of text. Called by dialog_textbox().
+ */
+static void print_page(WINDOW * win, int height, int width)
+{
+	int i, passed_end = 0;
+
+	page_length = 0;
+	for (i = 0; i < height; i++) {
+		print_line(win, i, width);
+		if (!passed_end)
+			page_length++;
+		if (end_reached && !passed_end)
+			passed_end = 1;
+	}
+	wnoutrefresh(win);
+}
+
+/*
+ * Print a new line of text. Called by dialog_textbox() and print_page().
+ */
+static void print_line(WINDOW * win, int row, int width)
+{
+	int y, x;
+	char *line;
+
+	line = get_line();
+	line += MIN(strlen(line), hscroll);	/* Scroll horizontally */
+	wmove(win, row, 0);	/* move cursor to correct line */
+	waddch(win, ' ');
+	waddnstr(win, line, MIN(strlen(line), width - 2));
+
+	getyx(win, y, x);
+	/* Clear 'residue' of previous line */
+#if OLD_NCURSES
+	{
+		int i;
+		for (i = 0; i < width - x; i++)
+			waddch(win, ' ');
+	}
+#else
+	wclrtoeol(win);
+#endif
+}
+
+/*
+ * Return current line of text. Called by dialog_textbox() and print_line().
+ * 'page' should point to start of current line before calling, and will be
+ * updated to point to start of next line.
+ */
+static char *get_line(void)
+{
+	int i = 0, fpos;
+	static char line[MAX_LEN + 1];
+
+	end_reached = 0;
+	while (*page != '\n') {
+		if (*page == '\0') {
+			/* Either end of file or end of buffer reached */
+			if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+				endwin();
+				fprintf(stderr, "\nError moving file pointer in "
+				                "get_line().\n");
+				exit(-1);
+			}
+			if (fpos < file_size) {	/* Not end of file yet */
+				/* We've reached end of buffer, but not end of file yet,
+				   so read next part of file into buffer */
+				if ((bytes_read =
+				     read(fd, buf, BUF_SIZE)) == -1) {
+					endwin();
+					fprintf(stderr, "\nError reading file in get_line().\n");
+					exit(-1);
+				}
+				buf[bytes_read] = '\0';
+				page = buf;
+			} else {
+				if (!end_reached)
+					end_reached = 1;
+				break;
+			}
+		} else if (i < MAX_LEN)
+			line[i++] = *(page++);
+		else {
+			/* Truncate lines longer than MAX_LEN characters */
+			if (i == MAX_LEN)
+				line[i++] = '\0';
+			page++;
+		}
+	}
+	if (i <= MAX_LEN)
+		line[i] = '\0';
+	if (!end_reached)
+		page++;		/* move pass '\n' */
+
+	return line;
+}
+
+/*
+ * Print current position
+ */
+static void print_position(WINDOW * win, int height, int width)
+{
+	int fpos, percent;
+
+	if ((fpos = lseek(fd, 0, SEEK_CUR)) == -1) {
+		endwin();
+		fprintf(stderr, "\nError moving file pointer in print_position().\n");
+		exit(-1);
+	}
+	wattrset(win, position_indicator_attr);
+	wbkgdset(win, position_indicator_attr & A_COLOR);
+	percent = !file_size ?
+	    100 : ((fpos - bytes_read + page - buf) * 100) / file_size;
+	wmove(win, height - 3, width - 9);
+	wprintw(win, "(%3d%%)", percent);
+}
