commit baa23ec860920ebf3e897c4bbb3420a88ea80ec1
Author: Marco Ammon <marco.ammon@fau.de>
Date:   Thu Jul 4 12:50:41 2019 +0200

    kconfig: Fix spelling of sym_is_changable
    
    There is a spelling mistake in "changable", it is corrected to
    "changeable" and all call sites are updated accordingly.
    
    Signed-off-by: Marco Ammon <marco.ammon@fau.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 38a32b1c1a28..f9ab98238aef 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -42,7 +42,7 @@ tristate sym_toggle_tristate_value(struct symbol *sym);
 bool sym_string_valid(struct symbol *sym, const char *newval);
 bool sym_string_within_range(struct symbol *sym, const char *str);
 bool sym_set_string_value(struct symbol *sym, const char *newval);
-bool sym_is_changable(struct symbol *sym);
+bool sym_is_changeable(struct symbol *sym);
 struct property * sym_get_choice_prop(struct symbol *sym);
 const char * sym_get_string_value(struct symbol *sym);
 

commit 5533397d1ec83d749067794f54283890e38ff0c1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 27 23:37:23 2019 +0900

    kconfig: add static qualifier to expand_string()
    
    Now expand_string() is only used in preprocess.c
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 86c267540ccc..38a32b1c1a28 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -58,7 +58,6 @@ void env_write_dep(FILE *f, const char *auto_conf_name);
 void variable_add(const char *name, const char *value,
 		  enum variable_flavor flavor);
 void variable_all_del(void);
-char *expand_string(const char *in);
 char *expand_dollar(const char **str);
 char *expand_one_token(const char **str);
 

commit 00c864f8903dd357471e8ee48f4d57aaa9a1a0de
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 20 16:46:31 2018 +0900

    kconfig: allow all config targets to write auto.conf if missing
    
    Currently, only syncconfig creates or updates include/config/auto.conf
    and some other files.  Other config targets create or update only the
    .config file.
    
    When you configure and build the kernel from a pristine source tree,
    any config target is followed by syncconfig in the build stage since
    include/config/auto.conf is missing.
    
    We are moving compiler tests from Makefile to Kconfig.  It means that
    parsing Kconfig files will be more costly since Kconfig invokes the
    compiler commands internally.  Thus, we want to avoid invoking Kconfig
    twice (one for *config to create the .config, and one for syncconfig
    to synchronize the auto.conf).  If auto.conf does not exist, we can
    generate all configuration files in the first configuration stage,
    which will save the syncconfig in the build stage.
    
    Please note this should be done only when auto.conf is missing.  If
    *config blindly did this, time stamp files under include/config/ would
    be unnecessarily touched, triggering unneeded rebuild of objects.
    
    I assume a scenario like this:
    
     1. You have a source tree that has already been built
        with CONFIG_FOO disabled
    
     2. Run "make menuconfig" to enable CONFIG_FOO
    
     3. CONFIG_FOO turns out to be unnecessary.
        Run "make menuconfig" again to disable CONFIG_FOO
    
     4. Run "make"
    
    In this case, include/config/foo.h should not be touched since there
    is no change in CONFIG_FOO.  The sync process should be delayed until
    the user really attempts to build the kernel.
    
    This commit has another motivation; I want to suppress the 'No such
    file or directory' warning from the 'include' directive.
    
    The top-level Makefile includes auto.conf with '-include' directive,
    like this:
    
      ifeq ($(dot-config),1)
      -include include/config/auto.conf
      endif
    
    This looks strange because auto.conf is mandatory when dot-config is 1.
    I guess only the reason of using '-include' is to suppress the warning
    'include/config/auto.conf: No such file or directory' when building
    from a clean tree.  However, this has a side-effect; Make considers
    the files included by '-include' are optional.  Hence, Make continues
    to build even if it fails to generate include/config/auto.conf.  I will
    change this in the next commit, but the warning message is annoying.
    (At least, kbuild test robot reports it as a regression.)
    
    With this commit, Kconfig will generate all configuration files together
    with the .config and I guess it is a solution good enough to suppress
    the warning.
    
    Note:
    GNU Make 4.2 or later does not display the warning from the 'include'
    directive if include files are successfully generated.  See GNU Make
    commit 87a5f98d248f ("[SV 102] Don't show unnecessary include file
    errors.")  However, older GNU Make versions are still widely used.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index cf4510a2bdc7..86c267540ccc 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -7,7 +7,7 @@ int conf_read(const char *name);
 int conf_read_simple(const char *name, int);
 int conf_write_defconfig(const char *name);
 int conf_write(const char *name);
-int conf_write_autoconf(void);
+int conf_write_autoconf(int overwrite);
 bool conf_get_changed(void);
 void conf_set_changed_callback(void (*fn)(void));
 void conf_set_message_callback(void (*fn)(const char *s));

commit 5accd7f3360e891bd552312515387dbaa2bb4bf3
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jul 5 11:46:12 2018 +0900

    kconfig: handle format string before calling conf_message_callback()
    
    As you see in mconf.c and nconf.c, conf_message_callback() hooks are
    likely to end up with the boilerplate of vsnprintf().  Process the
    string format before calling conf_message_callback() so that it
    receives a simple string.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Dirk Gouders <dirk@gouders.net>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index a8b7a330587e..cf4510a2bdc7 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -10,7 +10,7 @@ int conf_write(const char *name);
 int conf_write_autoconf(void);
 bool conf_get_changed(void);
 void conf_set_changed_callback(void (*fn)(void));
-void conf_set_message_callback(void (*fn)(const char *fmt, va_list ap));
+void conf_set_message_callback(void (*fn)(const char *s));
 
 /* menu.c */
 extern struct menu rootmenu;

commit ed2a22f277c60308481ecea1e1b846cbf249af41
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:51 2018 +0900

    kconfig: support append assignment operator
    
    Support += operator.  This appends a space and the text on the
    righthand side to a variable.
    
    The timing of the evaluation of the righthand side depends on the
    flavor of the variable.  If the lefthand side was originally defined
    as a simple variable, the righthand side is expanded immediately.
    Otherwise, the expansion is deferred.  Appending something to an
    undefined variable results in a recursive variable.
    
    To implement this, we need to remember the flavor of variables.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 6303193f43f2..a8b7a330587e 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -52,6 +52,7 @@ const char * prop_get_type_name(enum prop_type type);
 enum variable_flavor {
 	VAR_SIMPLE,
 	VAR_RECURSIVE,
+	VAR_APPEND,
 };
 void env_write_dep(FILE *f, const char *auto_conf_name);
 void variable_add(const char *name, const char *value,

commit 1175c02506ffc9cef9f3c520249d8740a3174b1f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:50 2018 +0900

    kconfig: support simply expanded variable
    
    The previous commit added variable and user-defined function.  They
    work similarly in the sense that the evaluation is deferred until
    they are used.
    
    This commit adds another type of variable, simply expanded variable,
    as we see in Make.
    
    The := operator defines a simply expanded variable, expanding the
    righthand side immediately.  This works like traditional programming
    language variables.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 2b16d6e1b2db..6303193f43f2 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -49,8 +49,13 @@ const char * sym_get_string_value(struct symbol *sym);
 const char * prop_get_type_name(enum prop_type type);
 
 /* preprocess.c */
+enum variable_flavor {
+	VAR_SIMPLE,
+	VAR_RECURSIVE,
+};
 void env_write_dep(FILE *f, const char *auto_conf_name);
-void variable_add(const char *name, const char *value);
+void variable_add(const char *name, const char *value,
+		  enum variable_flavor flavor);
 void variable_all_del(void);
 char *expand_string(const char *in);
 char *expand_dollar(const char **str);

commit 9ced3bddec080e974e910bf887715540a8d9d96b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:49 2018 +0900

    kconfig: support user-defined function and recursively expanded variable
    
    Now, we got a basic ability to test compiler capability in Kconfig.
    
    config CC_HAS_STACKPROTECTOR
            def_bool $(shell,($(CC) -Werror -fstack-protector -E -x c /dev/null -o /dev/null 2>/dev/null) && echo y || echo n)
    
    This works, but it is ugly to repeat this long boilerplate.
    
    We want to describe like this:
    
    config CC_HAS_STACKPROTECTOR
            bool
            default $(cc-option,-fstack-protector)
    
    It is straight-forward to add a new function, but I do not like to
    hard-code specialized functions like that.  Hence, here is another
    feature, user-defined function.  This works as a textual shorthand
    with parameterization.
    
    A user-defined function is defined by using the = operator, and can
    be referenced in the same way as built-in functions.  A user-defined
    function in Make is referenced like $(call my-func,arg1,arg2), but I
    omitted the 'call' to make the syntax shorter.
    
    The definition of a user-defined function contains $(1), $(2), etc.
    in its body to reference the parameters.  It is grammatically valid
    to pass more or fewer arguments when calling it.  We already exploit
    this feature in our makefiles; scripts/Kbuild.include defines cc-option
    which takes two arguments at most, but most of the callers pass only
    one argument.
    
    By the way, a variable is supported as a subset of this feature since
    a variable is "a user-defined function with zero argument".  In this
    context, I mean "variable" as recursively expanded variable.  I will
    add a different flavored variable in the next commit.
    
    The code above can be written as follows:
    
    [Example Code]
    
      success = $(shell,($(1)) >/dev/null 2>&1 && echo y || echo n)
      cc-option = $(success,$(CC) -Werror $(1) -E -x c /dev/null -o /dev/null)
    
      config CC_HAS_STACKPROTECTOR
              def_bool $(cc-option,-fstack-protector)
    
    [Result]
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_CC_HAS_STACKPROTECTOR=y
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index c46929fab7d9..2b16d6e1b2db 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -50,6 +50,8 @@ const char * prop_get_type_name(enum prop_type type);
 
 /* preprocess.c */
 void env_write_dep(FILE *f, const char *auto_conf_name);
+void variable_add(const char *name, const char *value);
+void variable_all_del(void);
 char *expand_string(const char *in);
 char *expand_dollar(const char **str);
 char *expand_one_token(const char **str);

commit 5b31a9746756ea76b08be035b49c86319973b395
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:43 2018 +0900

    kconfig: remove sym_expand_string_value()
    
    There is no more caller of sym_expand_string_value().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 9f465fe1ca85..c46929fab7d9 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -31,7 +31,6 @@ extern struct symbol * symbol_hash[SYMBOL_HASHSIZE];
 
 struct symbol * sym_lookup(const char *name, int flags);
 struct symbol * sym_find(const char *name);
-char *sym_expand_string_value(const char *in);
 const char * sym_escape_string_value(const char *in);
 struct symbol ** sym_re_search(const char *pattern);
 const char * sym_type_name(enum symbol_type type);

commit 104daea149c45cc84842ce77a9bd6436d19f3dd8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:40 2018 +0900

    kconfig: reference environment variables directly and remove 'option env='
    
    To get access to environment variables, Kconfig needs to define a
    symbol using "option env=" syntax.  It is tedious to add a symbol entry
    for each environment variable given that we need to define much more
    such as 'CC', 'AS', 'srctree' etc. to evaluate the compiler capability
    in Kconfig.
    
    Adding '$' for symbol references is grammatically inconsistent.
    Looking at the code, the symbols prefixed with 'S' are expanded by:
     - conf_expand_value()
       This is used to expand 'arch/$ARCH/defconfig' and 'defconfig_list'
     - sym_expand_string_value()
       This is used to expand strings in 'source' and 'mainmenu'
    
    All of them are fixed values independent of user configuration.  So,
    they can be changed into the direct expansion instead of symbols.
    
    This change makes the code much cleaner.  The bounce symbols 'SRCARCH',
    'ARCH', 'SUBARCH', 'KERNELVERSION' are gone.
    
    sym_init() hard-coding 'UNAME_RELEASE' is also gone.  'UNAME_RELEASE'
    should be replaced with an environment variable.
    
    ARCH_DEFCONFIG is a normal symbol, so it should be simply referenced
    without '$' prefix.
    
    The new syntax is addicted by Make.  The variable reference needs
    parentheses, like $(FOO), but you can omit them for single-letter
    variables, like $F.  Yet, in Makefiles, people tend to use the
    parenthetical form for consistency / clarification.
    
    At this moment, only the environment variable is supported, but I will
    extend the concept of 'variable' later on.
    
    The variables are expanded in the lexer so we can simplify the token
    handling on the parser side.
    
    For example, the following code works.
    
    [Example code]
    
      config MY_TOOLCHAIN_LIST
              string
              default "My tools: CC=$(CC), AS=$(AS), CPP=$(CPP)"
    
    [Result]
    
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_MY_TOOLCHAIN_LIST="My tools: CC=gcc, AS=as, CPP=gcc -E"
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 9dc8abfb1dc3..9f465fe1ca85 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -49,5 +49,11 @@ const char * sym_get_string_value(struct symbol *sym);
 
 const char * prop_get_type_name(enum prop_type type);
 
+/* preprocess.c */
+void env_write_dep(FILE *f, const char *auto_conf_name);
+char *expand_string(const char *in);
+char *expand_dollar(const char **str);
+char *expand_one_token(const char **str);
+
 /* expr.c */
 void expr_print(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken);

commit 523ca58b7db2e30e3c185a7927dd80a30c1bc743
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 9 01:19:08 2018 +0900

    kconfig: remove const qualifier from sym_expand_string_value()
    
    This function returns realloc'ed memory, so the returned pointer
    must be passed to free() when done.  So, 'const' qualifier is odd.
    It is allowed to modify the expanded string.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 5d86e2dfae59..9dc8abfb1dc3 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -31,7 +31,7 @@ extern struct symbol * symbol_hash[SYMBOL_HASHSIZE];
 
 struct symbol * sym_lookup(const char *name, int flags);
 struct symbol * sym_find(const char *name);
-const char * sym_expand_string_value(const char *in);
+char *sym_expand_string_value(const char *in);
 const char * sym_escape_string_value(const char *in);
 struct symbol ** sym_re_search(const char *pattern);
 const char * sym_type_name(enum symbol_type type);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index d5398718ec2a..5d86e2dfae59 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #include <stdarg.h>
 
 /* confdata.c */

commit ad8d40cda3ad22ad9e8863d55a5c88f85c0173f0
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Feb 24 16:37:13 2015 +0100

    kconfig: Remove unnecessary prototypes from headers
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index ceddbcf1e5ac..d5398718ec2a 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -22,7 +22,6 @@ struct menu * menu_get_root_menu(struct menu *menu);
 struct menu * menu_get_parent_menu(struct menu *menu);
 bool menu_has_help(struct menu *menu);
 const char * menu_get_help(struct menu *menu);
-void get_symbol_str(struct gstr *r, struct symbol *sym, struct list_head *head);
 struct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head);
 void menu_get_ext_help(struct menu *menu, struct gstr *help);
 
@@ -45,11 +44,9 @@ bool sym_string_within_range(struct symbol *sym, const char *str);
 bool sym_set_string_value(struct symbol *sym, const char *newval);
 bool sym_is_changable(struct symbol *sym);
 struct property * sym_get_choice_prop(struct symbol *sym);
-struct property * sym_get_default_prop(struct symbol *sym);
 const char * sym_get_string_value(struct symbol *sym);
 
 const char * prop_get_type_name(enum prop_type type);
 
 /* expr.c */
-int expr_compare_type(enum expr_type t1, enum expr_type t2);
 void expr_print(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken);

commit 70529b1a1784503169416df19ce3d68746401340
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Jan 27 17:11:42 2015 +0100

    kconfig: Get rid of the P() macro in headers
    
    This was originally meant for dlopen()ing a potential kconfig shared
    library. The unused dlopen code has already been removed in commit
    5a6f8d2b (kconfig: nuke LKC_DIRECT_LINK cruft), so let's remove the
    rest. The lkc_proto.h change was made with the following sed script:
    
      sed -r 's/^P\(([^,]*), *([^,]*), *(.*)\);/\2 \1\3;/'
    
    Plus some manual adjustments.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index ecdb9659b67d..ceddbcf1e5ac 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -1,57 +1,55 @@
 #include <stdarg.h>
 
 /* confdata.c */
-P(conf_parse,void,(const char *name));
-P(conf_read,int,(const char *name));
-P(conf_read_simple,int,(const char *name, int));
-P(conf_write_defconfig,int,(const char *name));
-P(conf_write,int,(const char *name));
-P(conf_write_autoconf,int,(void));
-P(conf_get_changed,bool,(void));
-P(conf_set_changed_callback, void,(void (*fn)(void)));
-P(conf_set_message_callback, void,(void (*fn)(const char *fmt, va_list ap)));
+void conf_parse(const char *name);
+int conf_read(const char *name);
+int conf_read_simple(const char *name, int);
+int conf_write_defconfig(const char *name);
+int conf_write(const char *name);
+int conf_write_autoconf(void);
+bool conf_get_changed(void);
+void conf_set_changed_callback(void (*fn)(void));
+void conf_set_message_callback(void (*fn)(const char *fmt, va_list ap));
 
 /* menu.c */
-P(rootmenu,struct menu,);
+extern struct menu rootmenu;
 
-P(menu_is_empty, bool, (struct menu *menu));
-P(menu_is_visible, bool, (struct menu *menu));
-P(menu_has_prompt, bool, (struct menu *menu));
-P(menu_get_prompt,const char *,(struct menu *menu));
-P(menu_get_root_menu,struct menu *,(struct menu *menu));
-P(menu_get_parent_menu,struct menu *,(struct menu *menu));
-P(menu_has_help,bool,(struct menu *menu));
-P(menu_get_help,const char *,(struct menu *menu));
-P(get_symbol_str, void, (struct gstr *r, struct symbol *sym, struct list_head
-			 *head));
-P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct list_head
-				   *head));
-P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
+bool menu_is_empty(struct menu *menu);
+bool menu_is_visible(struct menu *menu);
+bool menu_has_prompt(struct menu *menu);
+const char * menu_get_prompt(struct menu *menu);
+struct menu * menu_get_root_menu(struct menu *menu);
+struct menu * menu_get_parent_menu(struct menu *menu);
+bool menu_has_help(struct menu *menu);
+const char * menu_get_help(struct menu *menu);
+void get_symbol_str(struct gstr *r, struct symbol *sym, struct list_head *head);
+struct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head);
+void menu_get_ext_help(struct menu *menu, struct gstr *help);
 
 /* symbol.c */
-P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
+extern struct symbol * symbol_hash[SYMBOL_HASHSIZE];
 
-P(sym_lookup,struct symbol *,(const char *name, int flags));
-P(sym_find,struct symbol *,(const char *name));
-P(sym_expand_string_value,const char *,(const char *in));
-P(sym_escape_string_value, const char *,(const char *in));
-P(sym_re_search,struct symbol **,(const char *pattern));
-P(sym_type_name,const char *,(enum symbol_type type));
-P(sym_calc_value,void,(struct symbol *sym));
-P(sym_get_type,enum symbol_type,(struct symbol *sym));
-P(sym_tristate_within_range,bool,(struct symbol *sym,tristate tri));
-P(sym_set_tristate_value,bool,(struct symbol *sym,tristate tri));
-P(sym_toggle_tristate_value,tristate,(struct symbol *sym));
-P(sym_string_valid,bool,(struct symbol *sym, const char *newval));
-P(sym_string_within_range,bool,(struct symbol *sym, const char *str));
-P(sym_set_string_value,bool,(struct symbol *sym, const char *newval));
-P(sym_is_changable,bool,(struct symbol *sym));
-P(sym_get_choice_prop,struct property *,(struct symbol *sym));
-P(sym_get_default_prop,struct property *,(struct symbol *sym));
-P(sym_get_string_value,const char *,(struct symbol *sym));
+struct symbol * sym_lookup(const char *name, int flags);
+struct symbol * sym_find(const char *name);
+const char * sym_expand_string_value(const char *in);
+const char * sym_escape_string_value(const char *in);
+struct symbol ** sym_re_search(const char *pattern);
+const char * sym_type_name(enum symbol_type type);
+void sym_calc_value(struct symbol *sym);
+enum symbol_type sym_get_type(struct symbol *sym);
+bool sym_tristate_within_range(struct symbol *sym,tristate tri);
+bool sym_set_tristate_value(struct symbol *sym,tristate tri);
+tristate sym_toggle_tristate_value(struct symbol *sym);
+bool sym_string_valid(struct symbol *sym, const char *newval);
+bool sym_string_within_range(struct symbol *sym, const char *str);
+bool sym_set_string_value(struct symbol *sym, const char *newval);
+bool sym_is_changable(struct symbol *sym);
+struct property * sym_get_choice_prop(struct symbol *sym);
+struct property * sym_get_default_prop(struct symbol *sym);
+const char * sym_get_string_value(struct symbol *sym);
 
-P(prop_get_type_name,const char *,(enum prop_type type));
+const char * prop_get_type_name(enum prop_type type);
 
 /* expr.c */
-P(expr_compare_type,int,(enum expr_type t1, enum expr_type t2));
-P(expr_print,void,(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken));
+int expr_compare_type(enum expr_type t1, enum expr_type t2);
+void expr_print(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken);

commit 1278ebdbc3167883f32095491990fbdc7cdf8b5e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Sun May 19 21:49:34 2013 +0200

    mconf/nconf: mark empty menus/menuconfigs different from non-empty ones
    
    Submenus are sometimes empty and it would be nice if there is
    something that notifies us that we should not expect any content
    _before_ we enter a submenu.
    
    A new function menu_is_empty() was introduced and empty menus and
    menuconfigs are now marked by "----" as opposed to non-empty ones that
    are marked by "--->".
    
    This scheme was suggested by "Yann E. MORIN" <yann.morin.1998@free.fr>.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index ef1a7381f956..ecdb9659b67d 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -14,6 +14,7 @@ P(conf_set_message_callback, void,(void (*fn)(const char *fmt, va_list ap)));
 /* menu.c */
 P(rootmenu,struct menu,);
 
+P(menu_is_empty, bool, (struct menu *menu));
 P(menu_is_visible, bool, (struct menu *menu));
 P(menu_has_prompt, bool, (struct menu *menu));
 P(menu_get_prompt,const char *,(struct menu *menu));

commit bad9955db1b73d7286f74a8136a0628a9b1ac017
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Sun Oct 21 05:27:53 2012 -0400

    menuconfig: Replace CIRCLEQ by list_head-style lists.
    
    sys/queue.h and CIRCLEQ in particular have proven to cause portability
    problems (reported on Debian Sarge, Cygwin and FreeBSD)
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Yaakov Selkowitz <yselkowitz@users.sourceforge.net>
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 1d1c08537f1e..ef1a7381f956 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -21,9 +21,9 @@ P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 P(menu_has_help,bool,(struct menu *menu));
 P(menu_get_help,const char *,(struct menu *menu));
-P(get_symbol_str, void, (struct gstr *r, struct symbol *sym, struct jk_head
+P(get_symbol_str, void, (struct gstr *r, struct symbol *sym, struct list_head
 			 *head));
-P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct jk_head
+P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct list_head
 				   *head));
 P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
 

commit 95ac9b3b585d20df116c5bea1511d9eb5758ac81
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:08 2012 -0400

    menuconfig: Assign jump keys per-page instead of globally
    
    At the moment, keys 1-9 are assigned to the first 9 search results. This patch
    makes them assigned to the first 9 results per-page instead. We are much less
    likely to run out of keys that way.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 946c2cb367f9..1d1c08537f1e 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -21,10 +21,10 @@ P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 P(menu_has_help,bool,(struct menu *menu));
 P(menu_get_help,const char *,(struct menu *menu));
-P(get_symbol_str, int, (struct gstr *r, struct symbol *sym, struct menu
-			**jumps, int jump_nb));
-P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct menu
-				   **jumps));
+P(get_symbol_str, void, (struct gstr *r, struct symbol *sym, struct jk_head
+			 *head));
+P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct jk_head
+				   *head));
 P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
 
 /* symbol.c */

commit 5e609addb1bd963ce1a1929f2012c8dd04ca8620
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:06 2012 -0400

    menuconfig: Add jump keys to search results
    
    makes it possible to jump directly to the menu for a configuration entry after
    having searched for it with '/'. If this menu is not currently accessible we
    jump to the nearest accessible parent instead. After exiting this menu, the
    user is returned to the search results where he may jump further in or
    elsewhere.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 47fe9c340f9a..946c2cb367f9 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -21,8 +21,10 @@ P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 P(menu_has_help,bool,(struct menu *menu));
 P(menu_get_help,const char *,(struct menu *menu));
-P(get_symbol_str, void, (struct gstr *r, struct symbol *sym));
-P(get_relations_str, struct gstr, (struct symbol **sym_arr));
+P(get_symbol_str, int, (struct gstr *r, struct symbol *sym, struct menu
+			**jumps, int jump_nb));
+P(get_relations_str, struct gstr, (struct symbol **sym_arr, struct menu
+				   **jumps));
 P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
 
 /* symbol.c */

commit e54e692ba613c2170c66ce36a3791c009680af08
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun May 15 23:42:09 2011 -0400

    kconfig: introduce specialized printer
    
    Make conf_write_symbol() grammar agnostic to be able to use it from different
    code path. These path pass a printer callback which will print a symbol's name
    and its value in different format.
    
    conf_write_symbol()'s job become mostly only to prepare a string for the
    printer. This avoid to have to pass specialized flag to generic
    functions
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    [mmarek: rebased on top of de12518 (kconfig: autogenerated config_is_xxx
    macro)]
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 17342fef38b9..47fe9c340f9a 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -31,6 +31,7 @@ P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
 P(sym_lookup,struct symbol *,(const char *name, int flags));
 P(sym_find,struct symbol *,(const char *name));
 P(sym_expand_string_value,const char *,(const char *in));
+P(sym_escape_string_value, const char *,(const char *in));
 P(sym_re_search,struct symbol **,(const char *pattern));
 P(sym_type_name,const char *,(enum symbol_type type));
 P(sym_calc_value,void,(struct symbol *sym));

commit 70c74e59db7450d5c9164abeb3b6752f8045288b
Merge: b3235fe420ed 42368c37fbd5
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Oct 28 00:54:25 2010 +0200

    Merge branch 'message-callback' into kbuild/kconfig
    
    Conflicts:
            scripts/kconfig/nconf.c

commit 76a540958af5390a94b7f68c46cb7f2aed34ccf1
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Aug 18 01:23:50 2010 -0400

    kconfig: add a symbol string expansion helper
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 9a948c9ce44e..4531badb3fe1 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -28,6 +28,7 @@ P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
 
 P(sym_lookup,struct symbol *,(const char *name, int flags));
 P(sym_find,struct symbol *,(const char *name));
+P(sym_expand_string_value,const char *,(const char *in));
 P(sym_re_search,struct symbol **,(const char *pattern));
 P(sym_type_name,const char *,(enum symbol_type type));
 P(sym_calc_value,void,(struct symbol *sym));

commit 42368c37fbd51f7b478d041ae55c5df000897158
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Aug 17 10:21:19 2010 +0200

    kconfig: Allow frontends to display messages themselves
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 9a948c9ce44e..481d4849d0f0 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -1,3 +1,4 @@
+#include <stdarg.h>
 
 /* confdata.c */
 P(conf_parse,void,(const char *name));
@@ -8,6 +9,7 @@ P(conf_write,int,(const char *name));
 P(conf_write_autoconf,int,(void));
 P(conf_get_changed,bool,(void));
 P(conf_set_changed_callback, void,(void (*fn)(void)));
+P(conf_set_message_callback, void,(void (*fn)(const char *fmt, va_list ap)));
 
 /* menu.c */
 P(rootmenu,struct menu,);

commit 7cf3d73b4360e91b14326632ab1aeda4cb26308d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:34 2010 +0200

    kconfig: add savedefconfig
    
    savedefconfig will save a minimal config to a file
    named "defconfig".
    
    The config symbols are saved in the same order as
    they appear in the menu structure so it should
    be possible to map them to the relevant menus
    if desired.
    
    The implementation was tested against several minimal
    configs for arm which was created using brute-force.
    
    There was one regression related to default numbers
    which had their valid range further limited by another symbol.
    
    Sample:
    
    config FOO
            int "foo"
            default 4
    
    config BAR
            int "bar"
            range 0 FOO
    
    If FOO is set to 3 then BAR cannot take a value higher than 3.
    But the current implementation will set BAR equal to 4.
    
    This is seldomly used and the final configuration is OK,
    and the fix was non-trivial.
    So it was documented in the code and left as is.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 7cadcad8233b..9a948c9ce44e 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -3,6 +3,7 @@
 P(conf_parse,void,(const char *name));
 P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name, int));
+P(conf_write_defconfig,int,(const char *name));
 P(conf_write,int,(const char *name));
 P(conf_write_autoconf,int,(void));
 P(conf_get_changed,bool,(void));

commit 22c7eca61e51296643bb0a379fc726fda8f3b015
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 14 11:46:02 2010 +0800

    menuconfig: add support to show hidden options which have prompts
    
    Usage:
      Press <Z> to show all config symbols which have prompts.
    
    Quote Tim Bird:
    
    | I've been bitten by this numerous times.  I most often
    | use ftrace on ARM, but when I go back to x86, I almost
    | always go through a sequence of searching for the
    | function graph tracer in the menus, then realizing it's
    | completely missing until I disable CC_OPTIMIZE_FOR_SIZE.
    |
    | Is there any way to have the menu item appear, but be
    | unsettable unless the SIZE option is disabled?  I'm
    | not a Kconfig guru...
    
    I myself found this useful too. For example, I need to test
    ftrace/tracing and want to be sure all the tracing features are
    enabled, so I  enter the "Tracers" menu, and press <Z> to
    see if there is any config hidden.
    
    I also noticed gconfig and xconfig have a button "Show all options",
    but that's a bit too much, and I think normally what we are not
    interested in those configs which have no prompt thus can't be
    changed by users.
    
    Exmaple:
    
          --- Tracers
          -*-   Kernel Function Tracer
          - -     Kernel Function Graph Tracer
          [*]   Interrupts-off Latency Tracer
          - -   Preemption-off Latency Tracer
          [*]   Sysprof Tracer
    
    Here you can see 2 tracers are not selectable, and then can find
    out how to make them selectable.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 41e652a8d1f6..7cadcad8233b 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -11,7 +11,8 @@ P(conf_set_changed_callback, void,(void (*fn)(void)));
 /* menu.c */
 P(rootmenu,struct menu,);
 
-P(menu_is_visible,bool,(struct menu *menu));
+P(menu_is_visible, bool, (struct menu *menu));
+P(menu_has_prompt, bool, (struct menu *menu));
 P(menu_get_prompt,const char *,(struct menu *menu));
 P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));

commit 692d97c380c6dce2c35a04c5dcbce4e831a42fa0
Author: nir.tzachar@gmail.com <nir.tzachar@gmail.com>
Date:   Wed Nov 25 12:28:43 2009 +0200

    kconfig: new configuration interface (nconfig)
    
    This patch was inspired by the kernel projects page, where an ncurses
    replacement for menuconfig was mentioned (by Sam Ravnborg).
    
    Building on menuconfig, this patch implements a more modern look
    interface using ncurses and ncurses' satellite libraries (menu, panel,
    form). The implementation does not depend on lxdialog, which is
    currently distributed with the kernel.
    
    Signed-off-by: Nir Tzachar <nir.tzachar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index ffeb532b2cff..41e652a8d1f6 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -17,7 +17,8 @@ P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 P(menu_has_help,bool,(struct menu *menu));
 P(menu_get_help,const char *,(struct menu *menu));
-P(get_symbol_str,void,(struct gstr *r, struct symbol *sym));
+P(get_symbol_str, void, (struct gstr *r, struct symbol *sym));
+P(get_relations_str, struct gstr, (struct symbol **sym_arr));
 P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
 
 /* symbol.c */

commit 6bd5999d1a6166ad357f2ebf5e998ce49a407f62
Author: Cheng Renquan <crquan@gmail.com>
Date:   Sun Jul 12 16:11:44 2009 +0800

    kconfig: add menu_get_ext_help function to display more information
    
    The three functions are moved from mconf.c, then they can be shared in
    all menuconfig & gconfig & xconfig & config.
    
      +void menu_get_ext_help(struct menu *menu, struct gstr *help)
      +static void get_prompt_str(struct gstr *r, struct property *prop)
      +void get_symbol_str(struct gstr *r, struct symbol *sym)
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 8e69461313d1..ffeb532b2cff 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -17,6 +17,8 @@ P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 P(menu_has_help,bool,(struct menu *menu));
 P(menu_get_help,const char *,(struct menu *menu));
+P(get_symbol_str,void,(struct gstr *r, struct symbol *sym));
+P(menu_get_ext_help,void,(struct menu *menu, struct gstr *help));
 
 /* symbol.c */
 P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);

commit 5a1aa8a1aff6191ecc55f21d8b5f0e47108ed91b
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Feb 29 05:11:50 2008 +0100

    kconfig: add named choice group
    
    As choice dependency are now fully checked, it's quite easy to add support
    for named choices. This lifts the restriction that a choice value can only
    appear once, although it still has to be within the same group,
    but multiple choices can be joined by giving them a name.
    While at it I cleaned up a little the choice type logic to simplify it a
    bit.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 4d09f6ddefe3..8e69461313d1 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -21,7 +21,7 @@ P(menu_get_help,const char *,(struct menu *menu));
 /* symbol.c */
 P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
 
-P(sym_lookup,struct symbol *,(const char *name, int isconst));
+P(sym_lookup,struct symbol *,(const char *name, int flags));
 P(sym_find,struct symbol *,(const char *name));
 P(sym_re_search,struct symbol **,(const char *pattern));
 P(sym_type_name,const char *,(enum symbol_type type));

commit 6840999b192b1b57d713ddee3761c457a2779036
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 17 15:37:31 2007 +0100

    x86: simplify "make ARCH=x86" and fix kconfig all.config
    
    Simplify "make ARCH=x86" and fix kconfig so we again can set 64BIT in
    all.config.
    
    For a fix the diffstat is nice:
     6 files changed, 3 insertions(+), 36 deletions(-)
    
    The patch reverts these commits:
     - 0f855aa64b3f63d35a891510cf7db932a435c116 ("kconfig: add helper to set
       config symbol from environment variable")
     - 2a113281f5cd2febbab21a93c8943f8d3eece4d3 ("kconfig: use $K64BIT to
       set 64BIT with all*config targets")
    
    Roman Zippel pointed out that kconfig supported string compares so
    the additional complexity introduced by the above two patches were
    not needed.
    
    With this patch we have following behaviour:
    
      # make {allno,allyes,allmod,rand}config [ARCH=...]
      option \ host arch      | 32bit         | 64bit
      =====================================================
      ./.                     | 32bit         | 64bit
      ARCH=x86                | 32bit         | 32bit
      ARCH=i386               | 32bit         | 32bit
      ARCH=x86_64             | 64bit         | 64bit
    
    The general rule are that ARCH= and native architecture takes
    precedence over the configuration.
    
    So make ARCH=i386 [whatever] will always build a 32-bit kernel
    no matter what the configuration says.  The configuration will
    be updated to 32-bit if it was configured to 64-bit and the
    other way around.
    
    This behaviour is consistent with previous behaviour so no
    suprises here.
    
    make ARCH=x86 will per default result in a 32-bit kernel but as
    the only ARCH= value x86 allow the user to select between 32-bit
    and 64-bit using menuconfig.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Andreas Herrmann <aherrman@arcor.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index dca294e90cc3..4d09f6ddefe3 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -1,7 +1,6 @@
 
 /* confdata.c */
 P(conf_parse,void,(const char *name));
-P(conf_set_env_sym,int,(const char *envname, const char *symname, int def));
 P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name, int));
 P(conf_write,int,(const char *name));

commit 0f855aa64b3f63d35a891510cf7db932a435c116
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 10 20:40:05 2007 +0100

    kconfig: add helper to set config symbol from environment variable
    
    Add conf_set_env_sym() that can set an already defined symbol
    based on the value of an environment variable.
    
    Unknown symbols are silently ignored.
    A warning is printed if the value of the environment variable
    is unexpected.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 4d09f6ddefe3..dca294e90cc3 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -1,6 +1,7 @@
 
 /* confdata.c */
 P(conf_parse,void,(const char *name));
+P(conf_set_env_sym,int,(const char *envname, const char *symname, int def));
 P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name, int));
 P(conf_write,int,(const char *name));

commit 03d29122738f0bd81afd44b1f566e64ebf8d06fe
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 21 00:00:36 2007 +0200

    kconfig: attach help text to menus
    
    Roman Zippel wrote:
    > A simple example would be
    > help texts, right now they are per symbol, but they should really be per
    > menu, so archs can provide different help texts for something.
    
    This patch does this and at the same time introduce a few API
    funtions used to access the help text.
    
    The relevant api functions are introduced in the various frontends.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 15030770d1ad..4d09f6ddefe3 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -15,6 +15,8 @@ P(menu_is_visible,bool,(struct menu *menu));
 P(menu_get_prompt,const char *,(struct menu *menu));
 P(menu_get_root_menu,struct menu *,(struct menu *menu));
 P(menu_get_parent_menu,struct menu *,(struct menu *menu));
+P(menu_has_help,bool,(struct menu *menu));
+P(menu_get_help,const char *,(struct menu *menu));
 
 /* symbol.c */
 P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);

commit 3b354c557c7a6fcac099b3a20b308853fe596183
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:08 2006 -0800

    [PATCH] kconfig: add "void conf_set_changed_callback(void (*fn)(void))", use it in qconf.cc
    
    Added function sets "void (*conf_changed_callback)(void)".  Call it, if
    .config's changed state changes.  Use above in qconf.cc to set gui's
    save-widget's sensitvity.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 84bb139789a0..15030770d1ad 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -6,6 +6,7 @@ P(conf_read_simple,int,(const char *name, int));
 P(conf_write,int,(const char *name));
 P(conf_write_autoconf,int,(void));
 P(conf_get_changed,bool,(void));
+P(conf_set_changed_callback, void,(void (*fn)(void)));
 
 /* menu.c */
 P(rootmenu,struct menu,);

commit bfc10001b11e51b59ac901d17c5f05361bd2351d
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:07 2006 -0800

    [PATCH] kconfig: make sym_change_count static, let it be altered by 2 functions only
    
    Those two functions are
            void sym_set_change_count(int count)
    and
            void sym_add_change_count(int count)
    
    All write accesses to sym_change_count are replaced by calls to above
    functions.
    
    Variable and changer-functions are moved to confdata.c.  IMO thats ok, as
    sym_change_count is an attribute of the .config's change state.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 9f1823c88b73..84bb139789a0 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -17,7 +17,6 @@ P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 
 /* symbol.c */
 P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
-P(sym_change_count,int,);
 
 P(sym_lookup,struct symbol *,(const char *name, int isconst));
 P(sym_find,struct symbol *,(const char *name));

commit b321429325e4c911c379a5bf4156c9fc9713e425
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:06 2006 -0800

    [PATCH] kconfig: new function "bool conf_get_changed(void)"
    
    Run "make xconfig" on a freshly untarred kernel-tree.  Look at the floppy disk
    icon of the qt application, that has just started: Its in a normal, active
    state.
    
    Mouse click on it: .config is being saved.
    
    This patch series changes things so taht
    after the mouse click on the floppy disk icon, the icon is greyed out.
    If you mouse click on it now, nothing happens.
    
    If you change some CONFIG_*, the floppy disk icon returns to "active state",
    that is, if you mouse click it now, .config is written.
    
    This patch:
    
    Returns sym_change_count to reflect the .config's change state.
    All read only accesses of
            sym_change_count
    are replaced by calls to
            conf_get_changed()
    .
    mconfig.c is manipulated to ask for saving only when
    conf_get_changed() returned true.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index a263746cfa7d..9f1823c88b73 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -5,6 +5,7 @@ P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name, int));
 P(conf_write,int,(const char *name));
 P(conf_write_autoconf,int,(void));
+P(conf_get_changed,bool,(void));
 
 /* menu.c */
 P(rootmenu,struct menu,);

commit ab45d190fd4acf0b0e5d307294ce24a90a69cc23
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:47 2006 -0700

    kconfig: create links in info window
    
    Extend the expression print helper function to allow customization of the
    symbol output and use it to add links to the info window.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index e195c455bfef..a263746cfa7d 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -39,4 +39,4 @@ P(prop_get_type_name,const char *,(enum prop_type type));
 
 /* expr.c */
 P(expr_compare_type,int,(enum expr_type t1, enum expr_type t2));
-P(expr_print,void,(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken));
+P(expr_print,void,(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken));

commit 669bfad906522e74ee8d962801552a8c224c0d63
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:42 2006 -0700

    kconfig: allow loading multiple configurations
    
    Extend conf_read_simple() so it can load multiple configurations.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index bd0fb1dc1322..e195c455bfef 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -2,7 +2,7 @@
 /* confdata.c */
 P(conf_parse,void,(const char *name));
 P(conf_read,int,(const char *name));
-P(conf_read_simple,int,(const char *name));
+P(conf_read_simple,int,(const char *name, int));
 P(conf_write,int,(const char *name));
 P(conf_write_autoconf,int,(void));
 

commit c955ccafc38e77312b4c65e5a70960080fb8a3f2
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:39 2006 -0700

    kconfig: fix .config dependencies
    
    This fixes one of the worst kbuild warts left - the broken dependencies used
    to check and regenerate the .config file.  This was done via an indirect
    dependency and the .config itself had an empty command, which can cause make
    not to reread the changed .config file.
    
    Instead of this we generate now a new file include/config/auto.conf from
    .config, which is used for kbuild and has the proper dependencies.  It's also
    the main make target now for all files generated during this step (and thus
    replaces include/linux/autoconf.h).
    
    This also means we can now relax the syntax requirements for the .config file
    and we don't have to rewrite it all the time, i.e.  silentoldconfig only
    writes .config now when it's necessary to keep it in sync with the Kconfig
    files and even this can be suppressed by setting the environment variable
    KCONFIG_NOSILENTUPDATE, so the update can (and must) be done manually.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index b6a389c5fcbd..bd0fb1dc1322 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -4,6 +4,7 @@ P(conf_parse,void,(const char *name));
 P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name));
 P(conf_write,int,(const char *name));
+P(conf_write_autoconf,int,(void));
 
 /* menu.c */
 P(rootmenu,struct menu,);

commit 90389160efc2864501ced6e662f9419eb7a3e6c8
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:49 2005 -0800

    [PATCH] kconfig: preset config during all*config
    
    Allow to force setting of config variables during all{no,mod,yes,random}config
    to a specific value.  For that conf first checks the KCONFIG_ALLCONFIG
    environment variable for a file name, otherwise it checks for
    all{no,mod,yes,random}.config and all.config.  The file is a normal config
    file, which presets the config variables, but they are still subject to normal
    dependency checks.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
index 6dc6d0c48e7a..b6a389c5fcbd 100644
--- a/scripts/kconfig/lkc_proto.h
+++ b/scripts/kconfig/lkc_proto.h
@@ -2,6 +2,7 @@
 /* confdata.c */
 P(conf_parse,void,(const char *name));
 P(conf_read,int,(const char *name));
+P(conf_read_simple,int,(const char *name));
 P(conf_write,int,(const char *name));
 
 /* menu.c */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/kconfig/lkc_proto.h b/scripts/kconfig/lkc_proto.h
new file mode 100644
index 000000000000..6dc6d0c48e7a
--- /dev/null
+++ b/scripts/kconfig/lkc_proto.h
@@ -0,0 +1,40 @@
+
+/* confdata.c */
+P(conf_parse,void,(const char *name));
+P(conf_read,int,(const char *name));
+P(conf_write,int,(const char *name));
+
+/* menu.c */
+P(rootmenu,struct menu,);
+
+P(menu_is_visible,bool,(struct menu *menu));
+P(menu_get_prompt,const char *,(struct menu *menu));
+P(menu_get_root_menu,struct menu *,(struct menu *menu));
+P(menu_get_parent_menu,struct menu *,(struct menu *menu));
+
+/* symbol.c */
+P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
+P(sym_change_count,int,);
+
+P(sym_lookup,struct symbol *,(const char *name, int isconst));
+P(sym_find,struct symbol *,(const char *name));
+P(sym_re_search,struct symbol **,(const char *pattern));
+P(sym_type_name,const char *,(enum symbol_type type));
+P(sym_calc_value,void,(struct symbol *sym));
+P(sym_get_type,enum symbol_type,(struct symbol *sym));
+P(sym_tristate_within_range,bool,(struct symbol *sym,tristate tri));
+P(sym_set_tristate_value,bool,(struct symbol *sym,tristate tri));
+P(sym_toggle_tristate_value,tristate,(struct symbol *sym));
+P(sym_string_valid,bool,(struct symbol *sym, const char *newval));
+P(sym_string_within_range,bool,(struct symbol *sym, const char *str));
+P(sym_set_string_value,bool,(struct symbol *sym, const char *newval));
+P(sym_is_changable,bool,(struct symbol *sym));
+P(sym_get_choice_prop,struct property *,(struct symbol *sym));
+P(sym_get_default_prop,struct property *,(struct symbol *sym));
+P(sym_get_string_value,const char *,(struct symbol *sym));
+
+P(prop_get_type_name,const char *,(enum prop_type type));
+
+/* expr.c */
+P(expr_compare_type,int,(enum expr_type t1, enum expr_type t2));
+P(expr_print,void,(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken));
