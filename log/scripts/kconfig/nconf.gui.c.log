commit 9c38f1f044080392603c497ecca4d7d09876ff99
Author: Changbin Du <changbin.du@gmail.com>
Date:   Mon Mar 25 15:16:47 2019 +0000

    kconfig/[mn]conf: handle backspace (^H) key
    
    Backspace is not working on some terminal emulators which do not send the
    key code defined by terminfo. Terminals either send '^H' (8) or '^?' (127).
    But currently only '^?' is handled. Let's also handle '^H' for those
    terminals.
    
    Signed-off-by: Changbin Du <changbin.du@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 7be620a1fcdb..77f525a8617c 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -439,7 +439,8 @@ int dialog_inputbox(WINDOW *main_window,
 		case KEY_F(F_EXIT):
 		case KEY_F(F_BACK):
 			break;
-		case 127:
+		case 8:   /* ^H */
+		case 127: /* ^? */
 		case KEY_BACKSPACE:
 			if (cursor_position > 0) {
 				memmove(&result[cursor_position-1],

commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 88874acfda36..7be620a1fcdb 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2008 Nir Tzachar <nir.tzachar@gmail.com?
- * Released under the terms of the GNU GPL v2.0.
+ * Copyright (C) 2008 Nir Tzachar <nir.tzachar@gmail.com>
  *
  * Derived from menuconfig.
- *
  */
 #include "nconf.h"
 #include "lkc.h"

commit d717f24d8c68081caae2374cf5ea6c4e62c490fc
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 9 01:19:07 2018 +0900

    kconfig: add xrealloc() helper
    
    We already have xmalloc(), xcalloc().  Add xrealloc() as well
    to save tedious error handling.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index a64b1c31253e..88874acfda36 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -6,6 +6,7 @@
  *
  */
 #include "nconf.h"
+#include "lkc.h"
 
 /* a list of all the different widgets we use */
 attributes_t attributes[ATTR_MAX+1] = {0};
@@ -374,7 +375,7 @@ int dialog_inputbox(WINDOW *main_window,
 
 	if (strlen(init)+1 > *result_len) {
 		*result_len = strlen(init)+1;
-		*resultp = result = realloc(result, *result_len);
+		*resultp = result = xrealloc(result, *result_len);
 	}
 
 	/* find the widest line of msg: */

commit ad8181060788c80c0ad75b583f24c22fa962a7a6
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon May 22 18:44:57 2017 -0700

    kconfig: fix sparse warnings in nconfig
    
    Fix sparse warnings in scripts/kconfig/nconf* ('make nconfig'):
    
    ../scripts/kconfig/nconf.c:1071:32: warning: Using plain integer as NULL pointer
    ../scripts/kconfig/nconf.c:1238:30: warning: Using plain integer as NULL pointer
    ../scripts/kconfig/nconf.c:511:51: warning: Using plain integer as NULL pointer
    ../scripts/kconfig/nconf.c:1460:6: warning: symbol 'setup_windows' was not declared. Should it be static?
    ../scripts/kconfig/nconf.c:274:12: warning: symbol 'current_instructions' was not declared. Should it be static?
    ../scripts/kconfig/nconf.c:308:22: warning: symbol 'function_keys' was not declared. Should it be static?
    ../scripts/kconfig/nconf.gui.c:132:17: warning: non-ANSI function declaration of function 'set_colors'
    ../scripts/kconfig/nconf.gui.c:195:24: warning: Using plain integer as NULL pointer
    
    nconf.gui.o before/after files are the same.
    nconf.o before/after files are the same until the 'static' function
    declarations are added.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 4b2f44c20caf..a64b1c31253e 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -129,7 +129,7 @@ static void no_colors_theme(void)
 	mkattrn(FUNCTION_TEXT, A_REVERSE);
 }
 
-void set_colors()
+void set_colors(void)
 {
 	start_color();
 	use_default_colors();
@@ -192,7 +192,7 @@ const char *get_line(const char *text, int line_no)
 	int lines = 0;
 
 	if (!text)
-		return 0;
+		return NULL;
 
 	for (i = 0; text[i] != '\0' && lines < line_no; i++)
 		if (text[i] == '\n')

commit 79e51b5c2deea542b3bb8c66e0d502230b017dde
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Thu Nov 24 22:10:23 2016 +0000

    kconfig/nconf: Fix hang when editing symbol with a long prompt
    
    Currently it is impossible to edit the value of a config symbol with a
    prompt longer than (terminal width - 2) characters.  dialog_inputbox()
    calculates a negative x-offset for the input window and newwin() fails
    as this is invalid.  It also doesn't check for this failure, so it
    busy-loops calling wgetch(NULL) which immediately returns -1.
    
    The additions in the offset calculations also don't match the intended
    size of the window.
    
    Limit the window size and calculate the offset similarly to
    show_scroll_win().
    
    Cc: stable <stable@vger.kernel.org>
    Fixes: 692d97c380c6 ("kconfig: new configuration interface (nconfig)")
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 8275f0e55106..4b2f44c20caf 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -364,12 +364,14 @@ int dialog_inputbox(WINDOW *main_window,
 	WINDOW *prompt_win;
 	WINDOW *form_win;
 	PANEL *panel;
-	int i, x, y;
+	int i, x, y, lines, columns, win_lines, win_cols;
 	int res = -1;
 	int cursor_position = strlen(init);
 	int cursor_form_win;
 	char *result = *resultp;
 
+	getmaxyx(stdscr, lines, columns);
+
 	if (strlen(init)+1 > *result_len) {
 		*result_len = strlen(init)+1;
 		*resultp = result = realloc(result, *result_len);
@@ -386,14 +388,19 @@ int dialog_inputbox(WINDOW *main_window,
 	if (title)
 		prompt_width = max(prompt_width, strlen(title));
 
+	win_lines = min(prompt_lines+6, lines-2);
+	win_cols = min(prompt_width+7, columns-2);
+	prompt_lines = max(win_lines-6, 0);
+	prompt_width = max(win_cols-7, 0);
+
 	/* place dialog in middle of screen */
-	y = (getmaxy(stdscr)-(prompt_lines+4))/2;
-	x = (getmaxx(stdscr)-(prompt_width+4))/2;
+	y = (lines-win_lines)/2;
+	x = (columns-win_cols)/2;
 
 	strncpy(result, init, *result_len);
 
 	/* create the windows */
-	win = newwin(prompt_lines+6, prompt_width+7, y, x);
+	win = newwin(win_lines, win_cols, y, x);
 	prompt_win = derwin(win, prompt_lines+1, prompt_width, 2, 2);
 	form_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);
 	keypad(form_win, TRUE);

commit e0b42605e685a0833303e1d4dde277c99d9e17b5
Author: Dirk Gouders <dirk@gouders.net>
Date:   Mon May 13 11:23:58 2013 +0200

    nconf: use function calls instead of ncurses' variables LINES and COLS
    
    According to the documentation [1], LINES and COLS are initialized by
    initscr(); it does not say anything about the behavior when windows are
    resized.
    
    Do not rely on the current implementation of ncurses that updates
    these variables on resize, but use the propper function calls or macros
    to get window dimensions.
    
    The use of the variables in main() was OK, but for the sake of
    consistency it was modified to use the macro getmaxyx().
    
    [1] ncurses(3X)
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    [yann.morin.1998@free.fr: declare 'lines' and 'columns' on a single line]
    Signed-off-by: Yann E. MORIN <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 9f8c44ecc703..8275f0e55106 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -276,8 +276,8 @@ int btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)
 
 	total_width = max(msg_width, btns_width);
 	/* place dialog in middle of screen */
-	y = (LINES-(msg_lines+4))/2;
-	x = (COLS-(total_width+4))/2;
+	y = (getmaxy(stdscr)-(msg_lines+4))/2;
+	x = (getmaxx(stdscr)-(total_width+4))/2;
 
 
 	/* create the windows */
@@ -387,8 +387,8 @@ int dialog_inputbox(WINDOW *main_window,
 		prompt_width = max(prompt_width, strlen(title));
 
 	/* place dialog in middle of screen */
-	y = (LINES-(prompt_lines+4))/2;
-	x = (COLS-(prompt_width+4))/2;
+	y = (getmaxy(stdscr)-(prompt_lines+4))/2;
+	x = (getmaxx(stdscr)-(prompt_width+4))/2;
 
 	strncpy(result, init, *result_len);
 
@@ -545,7 +545,7 @@ void show_scroll_win(WINDOW *main_window,
 {
 	int res;
 	int total_lines = get_line_no(text);
-	int x, y;
+	int x, y, lines, columns;
 	int start_x = 0, start_y = 0;
 	int text_lines = 0, text_cols = 0;
 	int total_cols = 0;
@@ -556,6 +556,8 @@ void show_scroll_win(WINDOW *main_window,
 	WINDOW *pad;
 	PANEL *panel;
 
+	getmaxyx(stdscr, lines, columns);
+
 	/* find the widest line of msg: */
 	total_lines = get_line_no(text);
 	for (i = 0; i < total_lines; i++) {
@@ -569,14 +571,14 @@ void show_scroll_win(WINDOW *main_window,
 	(void) wattrset(pad, attributes[SCROLLWIN_TEXT]);
 	fill_window(pad, text);
 
-	win_lines = min(total_lines+4, LINES-2);
-	win_cols = min(total_cols+2, COLS-2);
+	win_lines = min(total_lines+4, lines-2);
+	win_cols = min(total_cols+2, columns-2);
 	text_lines = max(win_lines-4, 0);
 	text_cols = max(win_cols-2, 0);
 
 	/* place window in middle of screen */
-	y = (LINES-win_lines)/2;
-	x = (COLS-win_cols)/2;
+	y = (lines-win_lines)/2;
+	x = (columns-win_cols)/2;
 
 	win = newwin(win_lines, win_cols, y, x);
 	keypad(win, TRUE);

commit c5ffa130f3644b51e588a2a6770648b6ea936969
Author: Roland Eggner <edvx1@systemanalysen.net>
Date:   Sat Dec 29 23:33:28 2012 +0100

    nconf: function keys line, change background color for better readability
    
    •  In function keys line descriptions black on darkblue are almost
       impossible to read.  Change colors to black on brown.
    
    Signed-off-by: Roland Eggner <edvx1@systemanalysen.net>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 379003c7a2b4..9f8c44ecc703 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -48,7 +48,7 @@ static void set_normal_colors(void)
 	init_pair(INPUT_FIELD, -1, -1);
 
 	init_pair(FUNCTION_HIGHLIGHT, -1, -1);
-	init_pair(FUNCTION_TEXT, COLOR_BLUE, -1);
+	init_pair(FUNCTION_TEXT, COLOR_YELLOW, -1);
 }
 
 /* available attributes:

commit d68e818bc4d5c962093ced51c4d8341fc6aea30d
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Tue Jul 24 16:12:03 2012 -0400

    nconf: add u, d command keys in scroll windows
    
    They function just like they do in less(1).
    Also correct some discrepancy between the help text and the code wrt
    function keys.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 3b18dd839668..379003c7a2b4 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -604,9 +604,11 @@ void show_scroll_win(WINDOW *main_window,
 		switch (res) {
 		case KEY_NPAGE:
 		case ' ':
+		case 'd':
 			start_y += text_lines-2;
 			break;
 		case KEY_PPAGE:
+		case 'u':
 			start_y -= text_lines+2;
 			break;
 		case KEY_HOME:
@@ -632,10 +634,10 @@ void show_scroll_win(WINDOW *main_window,
 			start_x++;
 			break;
 		}
-		if (res == 10 || res == 27 || res == 'q'
-		    || res == KEY_F(F_BACK) || res == KEY_F(F_EXIT)) {
+		if (res == 10 || res == 27 || res == 'q' ||
+			res == KEY_F(F_HELP) || res == KEY_F(F_BACK) ||
+			res == KEY_F(F_EXIT))
 			break;
-		}
 		if (start_y < 0)
 			start_y = 0;
 		if (start_y >= total_lines-text_lines)

commit 93072c3ecafcf188390750cc755185f3150736b9
Author: Cheng Renquan <crquan@gmail.com>
Date:   Thu Sep 1 10:52:22 2011 -0700

    scripts/kconfig/nconf: add KEY_HOME / KEY_END for dialog_inputbox
    
    to make it easier to locate begin/end when editing long strings;
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Acked By: Nir Tzachar <nir.tzachar@gmail.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 4b9d8b66087d..3b18dd839668 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -465,6 +465,14 @@ int dialog_inputbox(WINDOW *main_window,
 				cursor_form_win--;
 			}
 			break;
+		case KEY_HOME:
+			cursor_position = 0;
+			cursor_form_win = 0;
+			break;
+		case KEY_END:
+			cursor_position = len;
+			cursor_form_win = min(cursor_position, prompt_width-1);
+			break;
 		default:
 			if ((isgraph(res) || isspace(res))) {
 				/* one for new char, one for '\0' */

commit e631a57a19e103c3bb59495b236634ec62e2a850
Author: Cheng Renquan <crquan@gmail.com>
Date:   Thu Sep 1 10:52:21 2011 -0700

    scripts/kconfig/nconf: fix editing long strings
    
    The original dialog_inputbox doesn't work with longer than prompt_width
    strings, here fixed it in this way:
    1) add variable cursor_form_win to record cursor of form_win,
       keep its value always between [0, prompt_width-1];
       reuse the original cursor_position as cursor of the string result,
       use (cursor_position-cursor_form_win) as begin offset to show part of
       the string in form_win;
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Cc: Arnaud Lacombe <lacombar@gmail.com>
    Cc: Nir Tzachar <nir.tzachar@gmail.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index d64bc1c24c20..4b9d8b66087d 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -367,6 +367,7 @@ int dialog_inputbox(WINDOW *main_window,
 	int i, x, y;
 	int res = -1;
 	int cursor_position = strlen(init);
+	int cursor_form_win;
 	char *result = *resultp;
 
 	if (strlen(init)+1 > *result_len) {
@@ -410,7 +411,9 @@ int dialog_inputbox(WINDOW *main_window,
 	fill_window(prompt_win, prompt);
 
 	mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
-	mvwprintw(form_win, 0, 0, "%s", result);
+	cursor_form_win = min(cursor_position, prompt_width-1);
+	mvwprintw(form_win, 0, 0, "%s",
+		  result + cursor_position-cursor_form_win);
 
 	/* create panels */
 	panel = new_panel(win);
@@ -436,6 +439,8 @@ int dialog_inputbox(WINDOW *main_window,
 						&result[cursor_position],
 						len-cursor_position+1);
 				cursor_position--;
+				cursor_form_win--;
+				len--;
 			}
 			break;
 		case KEY_DC:
@@ -443,18 +448,22 @@ int dialog_inputbox(WINDOW *main_window,
 				memmove(&result[cursor_position],
 						&result[cursor_position+1],
 						len-cursor_position+1);
+				len--;
 			}
 			break;
 		case KEY_UP:
 		case KEY_RIGHT:
-			if (cursor_position < len &&
-			    cursor_position < min(*result_len, prompt_width))
+			if (cursor_position < len) {
 				cursor_position++;
+				cursor_form_win++;
+			}
 			break;
 		case KEY_DOWN:
 		case KEY_LEFT:
-			if (cursor_position > 0)
+			if (cursor_position > 0) {
 				cursor_position--;
+				cursor_form_win--;
+			}
 			break;
 		default:
 			if ((isgraph(res) || isspace(res))) {
@@ -470,16 +479,24 @@ int dialog_inputbox(WINDOW *main_window,
 						len-cursor_position+1);
 				result[cursor_position] = res;
 				cursor_position++;
+				cursor_form_win++;
+				len++;
 			} else {
 				mvprintw(0, 0, "unknown key: %d\n", res);
 			}
 			break;
 		}
+		if (cursor_form_win < 0)
+			cursor_form_win = 0;
+		else if (cursor_form_win > prompt_width-1)
+			cursor_form_win = prompt_width-1;
+
 		wmove(form_win, 0, 0);
 		wclrtoeol(form_win);
 		mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
-		mvwprintw(form_win, 0, 0, "%s", result);
-		wmove(form_win, 0, cursor_position);
+		mvwprintw(form_win, 0, 0, "%s",
+			result + cursor_position-cursor_form_win);
+		wmove(form_win, 0, cursor_form_win);
 		touchwin(win);
 		refresh_all_windows(main_window);
 

commit 5ea9f64ffc073bf2882f6aa83b0dad3609b1e67a
Author: Cheng Renquan <crquan@gmail.com>
Date:   Thu Sep 1 10:52:20 2011 -0700

    scripts/kconfig/nconf: dynamically alloc dialog_input_result
    
    To support unlimited length string config items;
    
    No check for realloc return value keeps code simple, and to be
    consistent with other existing unchecked malloc in kconfig.
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 3ce2a7c0bda6..d64bc1c24c20 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -356,7 +356,7 @@ int btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)
 
 int dialog_inputbox(WINDOW *main_window,
 		const char *title, const char *prompt,
-		const char *init, char *result, int result_len)
+		const char *init, char **resultp, int *result_len)
 {
 	int prompt_lines = 0;
 	int prompt_width = 0;
@@ -367,7 +367,12 @@ int dialog_inputbox(WINDOW *main_window,
 	int i, x, y;
 	int res = -1;
 	int cursor_position = strlen(init);
+	char *result = *resultp;
 
+	if (strlen(init)+1 > *result_len) {
+		*result_len = strlen(init)+1;
+		*resultp = result = realloc(result, *result_len);
+	}
 
 	/* find the widest line of msg: */
 	prompt_lines = get_line_no(prompt);
@@ -384,7 +389,7 @@ int dialog_inputbox(WINDOW *main_window,
 	y = (LINES-(prompt_lines+4))/2;
 	x = (COLS-(prompt_width+4))/2;
 
-	strncpy(result, init, result_len);
+	strncpy(result, init, *result_len);
 
 	/* create the windows */
 	win = newwin(prompt_lines+6, prompt_width+7, y, x);
@@ -443,7 +448,7 @@ int dialog_inputbox(WINDOW *main_window,
 		case KEY_UP:
 		case KEY_RIGHT:
 			if (cursor_position < len &&
-			    cursor_position < min(result_len, prompt_width))
+			    cursor_position < min(*result_len, prompt_width))
 				cursor_position++;
 			break;
 		case KEY_DOWN:
@@ -452,8 +457,13 @@ int dialog_inputbox(WINDOW *main_window,
 				cursor_position--;
 			break;
 		default:
-			if ((isgraph(res) || isspace(res)) &&
-					len-2 < result_len) {
+			if ((isgraph(res) || isspace(res))) {
+				/* one for new char, one for '\0' */
+				if (len+2 > *result_len) {
+					*result_len = len+2;
+					*resultp = result = realloc(result,
+								*result_len);
+				}
 				/* insert the char at the proper position */
 				memmove(&result[cursor_position+1],
 						&result[cursor_position],

commit cd58a90fa6ff2ec86bcc9e399acfd6dcc97268b3
Author: Cheng Renquan <crquan@gmail.com>
Date:   Thu Sep 1 10:52:19 2011 -0700

    scripts/kconfig/nconf: fix memmove's length arg
    
    In case KEY_BACKSPACE / KEY_DC to delete a char, it memmove only
    (len-cursor_position+1) bytes;
    the default case is to insert a char, it should also memmove exactly
    (len-cursor_position+1) bytes;
    
    the original use of (len+1) is wrong and may access following memory
    that doesn't belong to result, may cause SegFault in theory;
    
            case KEY_BACKSPACE:
                    if (cursor_position > 0) {
                            memmove(&result[cursor_position-1],
                                            &result[cursor_position],
                                            len-cursor_position+1);
                            cursor_position--;
                    }
                    break;
            case KEY_DC:
                    if (cursor_position >= 0 && cursor_position < len) {
                            memmove(&result[cursor_position],
                                            &result[cursor_position+1],
                                            len-cursor_position+1);
                    }
                    break;
            default:
                    if ((isgraph(res) || isspace(res)) &&
                                    len-2 < result_len) {
                            /* insert the char at the proper position */
                            memmove(&result[cursor_position+1],
                                            &result[cursor_position],
                                            len-cursor_position+1);
                            result[cursor_position] = res;
                            cursor_position++;
                    }
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Acked-by: Nir Tzachar <nir.tzachar@gmail.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index d3af04e95288..3ce2a7c0bda6 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -457,7 +457,7 @@ int dialog_inputbox(WINDOW *main_window,
 				/* insert the char at the proper position */
 				memmove(&result[cursor_position+1],
 						&result[cursor_position],
-						len+1);
+						len-cursor_position+1);
 				result[cursor_position] = res;
 				cursor_position++;
 			} else {

commit 4e24dbfc26f8b8285c9ed2f92ffddf4eb8ab960a
Author: Cheng Renquan <crquan@gmail.com>
Date:   Thu Sep 1 10:52:18 2011 -0700

    scripts/kconfig/nconf: fix typo: unknow => unknown
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Acked-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index f8137b3a5382..d3af04e95288 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -461,7 +461,7 @@ int dialog_inputbox(WINDOW *main_window,
 				result[cursor_position] = res;
 				cursor_position++;
 			} else {
-				mvprintw(0, 0, "unknow key: %d\n", res);
+				mvprintw(0, 0, "unknown key: %d\n", res);
 			}
 			break;
 		}

commit c24035b9edad6164ddc12e88444acea741d5e309
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Mon Aug 16 00:19:06 2010 -0400

    kbuild: fix typo
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index d963071e48df..f8137b3a5382 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -137,7 +137,7 @@ void set_colors()
 	if (has_colors()) {
 		normal_color_theme();
 	} else {
-		/* give deafults */
+		/* give defaults */
 		no_colors_theme();
 	}
 }

commit a72f3e2b82eb26f43bed1f83beeeb47830918811
Author: Nir Tzachar <nir.tzachar@gmail.com>
Date:   Sun Aug 8 16:50:06 2010 +0300

    nconfig: add search support
    
    Remove the old hotkeys feature, and replace it by an interactive string
    search.
    From nconfig help:
    
    Searching: pressing '/' triggers interactive search mode.
               nconfig performs a case insensitive search for the string
               in the menu prompts (no regex support).
               Pressing the up/down keys highlights the previous/next
               matching item. Backspace removes one character from the
               match string. Pressing either '/' again or ESC exits
               search mode. All other keys behave normally.
    
    Miscellaneous other changes (including Rundy's and Justin's input).
    
    Signed-off-by: Nir Tzachar <nir.tzachar@gmail.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index a9d9344e1365..d963071e48df 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -167,7 +167,7 @@ void print_in_middle(WINDOW *win,
 	length = strlen(string);
 	temp = (width - length) / 2;
 	x = startx + (int)temp;
-	wattrset(win, color);
+	(void) wattrset(win, color);
 	mvwprintw(win, y, x, "%s", string);
 	refresh();
 }
@@ -297,11 +297,11 @@ int btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)
 	set_menu_fore(menu, attributes[DIALOG_MENU_FORE]);
 	set_menu_back(menu, attributes[DIALOG_MENU_BACK]);
 
-	wattrset(win, attributes[DIALOG_BOX]);
+	(void) wattrset(win, attributes[DIALOG_BOX]);
 	box(win, 0, 0);
 
 	/* print message */
-	wattrset(msg_win, attributes[DIALOG_TEXT]);
+	(void) wattrset(msg_win, attributes[DIALOG_TEXT]);
 	fill_window(msg_win, msg);
 
 	set_menu_win(menu, win);
@@ -392,16 +392,16 @@ int dialog_inputbox(WINDOW *main_window,
 	form_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);
 	keypad(form_win, TRUE);
 
-	wattrset(form_win, attributes[INPUT_FIELD]);
+	(void) wattrset(form_win, attributes[INPUT_FIELD]);
 
-	wattrset(win, attributes[INPUT_BOX]);
+	(void) wattrset(win, attributes[INPUT_BOX]);
 	box(win, 0, 0);
-	wattrset(win, attributes[INPUT_HEADING]);
+	(void) wattrset(win, attributes[INPUT_HEADING]);
 	if (title)
 		mvwprintw(win, 0, 3, "%s", title);
 
 	/* print message */
-	wattrset(prompt_win, attributes[INPUT_TEXT]);
+	(void) wattrset(prompt_win, attributes[INPUT_TEXT]);
 	fill_window(prompt_win, prompt);
 
 	mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
@@ -531,7 +531,7 @@ void show_scroll_win(WINDOW *main_window,
 
 	/* create the pad */
 	pad = newpad(total_lines+10, total_cols+10);
-	wattrset(pad, attributes[SCROLLWIN_TEXT]);
+	(void) wattrset(pad, attributes[SCROLLWIN_TEXT]);
 	fill_window(pad, text);
 
 	win_lines = min(total_lines+4, LINES-2);
@@ -546,9 +546,9 @@ void show_scroll_win(WINDOW *main_window,
 	win = newwin(win_lines, win_cols, y, x);
 	keypad(win, TRUE);
 	/* show the help in the help window, and show the help panel */
-	wattrset(win, attributes[SCROLLWIN_BOX]);
+	(void) wattrset(win, attributes[SCROLLWIN_BOX]);
 	box(win, 0, 0);
-	wattrset(win, attributes[SCROLLWIN_HEADING]);
+	(void) wattrset(win, attributes[SCROLLWIN_HEADING]);
 	mvwprintw(win, 0, 3, " %s ", title);
 	panel = new_panel(win);
 

commit 58f915a311c1eac464e0e1caca2f85a05b66c930
Author: Stephen Boyd <bebarino@gmail.com>
Date:   Fri Jul 23 00:04:14 2010 -0700

    nconfig: Fix segfault when help contains special characters
    
    nconfig segfaults when help text contains the character '%'. For a quick
    example, navigate to the kernel compression options and get the help for
    bzip2. Doing so triggers a call to mvwprintw() with a string containing
    '%' and no extra arguments to fill in the specifier's value. Fix this
    case by printing the literal string retrieved from the kconfig.
    
     #0  0x00002b52b6b11d83 in vfprintf () from /lib/libc.so.6
     #1  0x00002b52b6bad010 in __vsnprintf_chk () from /lib/libc.so.6
     #2  0x00002b52b623991b in _nc_printf_string () from
     /lib/libncursesw.so.5
     #3  0x00002b52b6234cff in vwprintw () from /lib/libncursesw.so.5
     #4  0x00002b52b6234db9 in mvwprintw () from /lib/libncursesw.so.5
     #5  0x00000000004151d8 in fill_window (win=0x21b64c0,
         text=0x21b62b0 "CONFIG_KERNEL_BZIP2:\n\nIts compression ratio and
         speed is intermediate.\nDecompression speed is slowest among the
         three.  The kernel\nsize is about 10% smaller with bzip2, in
         comparison to gzip.\nBzip2 us"...)
         at scripts/kconfig/nconf.gui.c:229
     #6  0x0000000000416335 in show_scroll_win (main_window=0x21a5630,
             title=0x157fa30 "Bzip2",
                text=0x21b62b0 "CONFIG_KERNEL_BZIP2:\n\nIts compression
                ratio and speed is intermediate.\nDecompression speed is
                slowest among the three.  The kernel\nsize is about 10%
                smaller with bzip2, in comparison to gzip.\nBzip2 us"...)
         at scripts/kconfig/nconf.gui.c:535
     #7  0x00000000004055b2 in show_help (menu=0x157f9d0)
             at scripts/kconfig/nconf.c:1257
     #8  0x0000000000405897 in conf_choice (menu=0x157f130)
                at scripts/kconfig/nconf.c:1321
     #9  0x0000000000405326 in conf (menu=0x157d130) at
                scripts/kconfig/nconf.c:1208
     #10 0x00000000004052e8 in conf (menu=0xb434a0) at
                scripts/kconfig/nconf.c:1203
     #11 0x0000000000406092 in main (ac=2, av=0x7fff96a93c38)
    
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Nir Tzachar <nir.tzachar@gmail.com>
    Signed-off-by: Stephen Boyd <bebarino@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 115edb437fb1..a9d9344e1365 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -226,7 +226,7 @@ void fill_window(WINDOW *win, const char *text)
 		int len = get_line_length(line);
 		strncpy(tmp, line, min(len, x));
 		tmp[len] = '\0';
-		mvwprintw(win, i, 0, tmp);
+		mvwprintw(win, i, 0, "%s", tmp);
 	}
 }
 

commit 851190c9304154b7d65596801415229c05994e91
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Jan 7 13:59:57 2010 +0100

    nconfig: mark local functions as such
    
    scripts/kconfig/nconf.gui.c:23: warning: no previous prototype for 'set_normal_colors'
    scripts/kconfig/nconf.gui.c:68: warning: no previous prototype for 'normal_color_theme'
    scripts/kconfig/nconf.gui.c:100: warning: no previous prototype for 'no_colors_theme'
    scripts/kconfig/nconf.c:455: warning: no previous prototype for 'process_special_keys'
    scripts/kconfig/nconf.c:487: warning: no previous prototype for 'get_next_hot'
    scripts/kconfig/nconf.c:506: warning: no previous prototype for 'canbhot'
    scripts/kconfig/nconf.c:514: warning: no previous prototype for 'is_hot'
    scripts/kconfig/nconf.c:522: warning: no previous prototype for 'make_hot'
    scripts/kconfig/nconf.c:582: warning: no previous prototype for 'item_make'
    scripts/kconfig/nconf.c:626: warning: no previous prototype for 'item_add_str'
    scripts/kconfig/nconf.c:656: warning: no previous prototype for 'item_tag'
    scripts/kconfig/nconf.c:668: warning: no previous prototype for 'curses_item_index'
    scripts/kconfig/nconf.c:673: warning: no previous prototype for 'item_data'
    scripts/kconfig/nconf.c:684: warning: no previous prototype for 'item_is_tag'
    scripts/kconfig/nconf.c:691: warning: no previous prototype for 'set_config_filename'
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
index 879ade6dd604..115edb437fb1 100644
--- a/scripts/kconfig/nconf.gui.c
+++ b/scripts/kconfig/nconf.gui.c
@@ -20,7 +20,7 @@ attributes_t attributes[ATTR_MAX+1] = {0};
    COLOR_CYAN    6
    COLOR_WHITE   7
    */
-void set_normal_colors(void)
+static void set_normal_colors(void)
 {
 	init_pair(NORMAL, -1, -1);
 	init_pair(MAIN_HEADING, COLOR_MAGENTA, -1);
@@ -65,7 +65,7 @@ void set_normal_colors(void)
    A_CHARTEXT      Bit-mask to extract a character
    COLOR_PAIR(n)   Color-pair number n
    */
-void normal_color_theme(void)
+static void normal_color_theme(void)
 {
 	/* automatically add color... */
 #define mkattr(name, attr) do { \
@@ -97,7 +97,7 @@ attributes[name] = attr | COLOR_PAIR(name); } while (0)
 	mkattr(FUNCTION_TEXT, A_REVERSE);
 }
 
-void no_colors_theme(void)
+static void no_colors_theme(void)
 {
 	/* automatically add highlight, no color */
 #define mkattrn(name, attr) { attributes[name] = attr; }

commit 692d97c380c6dce2c35a04c5dcbce4e831a42fa0
Author: nir.tzachar@gmail.com <nir.tzachar@gmail.com>
Date:   Wed Nov 25 12:28:43 2009 +0200

    kconfig: new configuration interface (nconfig)
    
    This patch was inspired by the kernel projects page, where an ncurses
    replacement for menuconfig was mentioned (by Sam Ravnborg).
    
    Building on menuconfig, this patch implements a more modern look
    interface using ncurses and ncurses' satellite libraries (menu, panel,
    form). The implementation does not depend on lxdialog, which is
    currently distributed with the kernel.
    
    Signed-off-by: Nir Tzachar <nir.tzachar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/nconf.gui.c b/scripts/kconfig/nconf.gui.c
new file mode 100644
index 000000000000..879ade6dd604
--- /dev/null
+++ b/scripts/kconfig/nconf.gui.c
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2008 Nir Tzachar <nir.tzachar@gmail.com?
+ * Released under the terms of the GNU GPL v2.0.
+ *
+ * Derived from menuconfig.
+ *
+ */
+#include "nconf.h"
+
+/* a list of all the different widgets we use */
+attributes_t attributes[ATTR_MAX+1] = {0};
+
+/* available colors:
+   COLOR_BLACK   0
+   COLOR_RED     1
+   COLOR_GREEN   2
+   COLOR_YELLOW  3
+   COLOR_BLUE    4
+   COLOR_MAGENTA 5
+   COLOR_CYAN    6
+   COLOR_WHITE   7
+   */
+void set_normal_colors(void)
+{
+	init_pair(NORMAL, -1, -1);
+	init_pair(MAIN_HEADING, COLOR_MAGENTA, -1);
+
+	/* FORE is for the selected item */
+	init_pair(MAIN_MENU_FORE, -1, -1);
+	/* BACK for all the rest */
+	init_pair(MAIN_MENU_BACK, -1, -1);
+	init_pair(MAIN_MENU_GREY, -1, -1);
+	init_pair(MAIN_MENU_HEADING, COLOR_GREEN, -1);
+	init_pair(MAIN_MENU_BOX, COLOR_YELLOW, -1);
+
+	init_pair(SCROLLWIN_TEXT, -1, -1);
+	init_pair(SCROLLWIN_HEADING, COLOR_GREEN, -1);
+	init_pair(SCROLLWIN_BOX, COLOR_YELLOW, -1);
+
+	init_pair(DIALOG_TEXT, -1, -1);
+	init_pair(DIALOG_BOX, COLOR_YELLOW, -1);
+	init_pair(DIALOG_MENU_BACK, COLOR_YELLOW, -1);
+	init_pair(DIALOG_MENU_FORE, COLOR_RED, -1);
+
+	init_pair(INPUT_BOX, COLOR_YELLOW, -1);
+	init_pair(INPUT_HEADING, COLOR_GREEN, -1);
+	init_pair(INPUT_TEXT, -1, -1);
+	init_pair(INPUT_FIELD, -1, -1);
+
+	init_pair(FUNCTION_HIGHLIGHT, -1, -1);
+	init_pair(FUNCTION_TEXT, COLOR_BLUE, -1);
+}
+
+/* available attributes:
+   A_NORMAL        Normal display (no highlight)
+   A_STANDOUT      Best highlighting mode of the terminal.
+   A_UNDERLINE     Underlining
+   A_REVERSE       Reverse video
+   A_BLINK         Blinking
+   A_DIM           Half bright
+   A_BOLD          Extra bright or bold
+   A_PROTECT       Protected mode
+   A_INVIS         Invisible or blank mode
+   A_ALTCHARSET    Alternate character set
+   A_CHARTEXT      Bit-mask to extract a character
+   COLOR_PAIR(n)   Color-pair number n
+   */
+void normal_color_theme(void)
+{
+	/* automatically add color... */
+#define mkattr(name, attr) do { \
+attributes[name] = attr | COLOR_PAIR(name); } while (0)
+	mkattr(NORMAL, NORMAL);
+	mkattr(MAIN_HEADING, A_BOLD | A_UNDERLINE);
+
+	mkattr(MAIN_MENU_FORE, A_REVERSE);
+	mkattr(MAIN_MENU_BACK, A_NORMAL);
+	mkattr(MAIN_MENU_GREY, A_NORMAL);
+	mkattr(MAIN_MENU_HEADING, A_BOLD);
+	mkattr(MAIN_MENU_BOX, A_NORMAL);
+
+	mkattr(SCROLLWIN_TEXT, A_NORMAL);
+	mkattr(SCROLLWIN_HEADING, A_BOLD);
+	mkattr(SCROLLWIN_BOX, A_BOLD);
+
+	mkattr(DIALOG_TEXT, A_BOLD);
+	mkattr(DIALOG_BOX, A_BOLD);
+	mkattr(DIALOG_MENU_FORE, A_STANDOUT);
+	mkattr(DIALOG_MENU_BACK, A_NORMAL);
+
+	mkattr(INPUT_BOX, A_NORMAL);
+	mkattr(INPUT_HEADING, A_BOLD);
+	mkattr(INPUT_TEXT, A_NORMAL);
+	mkattr(INPUT_FIELD, A_UNDERLINE);
+
+	mkattr(FUNCTION_HIGHLIGHT, A_BOLD);
+	mkattr(FUNCTION_TEXT, A_REVERSE);
+}
+
+void no_colors_theme(void)
+{
+	/* automatically add highlight, no color */
+#define mkattrn(name, attr) { attributes[name] = attr; }
+
+	mkattrn(NORMAL, NORMAL);
+	mkattrn(MAIN_HEADING, A_BOLD | A_UNDERLINE);
+
+	mkattrn(MAIN_MENU_FORE, A_STANDOUT);
+	mkattrn(MAIN_MENU_BACK, A_NORMAL);
+	mkattrn(MAIN_MENU_GREY, A_NORMAL);
+	mkattrn(MAIN_MENU_HEADING, A_BOLD);
+	mkattrn(MAIN_MENU_BOX, A_NORMAL);
+
+	mkattrn(SCROLLWIN_TEXT, A_NORMAL);
+	mkattrn(SCROLLWIN_HEADING, A_BOLD);
+	mkattrn(SCROLLWIN_BOX, A_BOLD);
+
+	mkattrn(DIALOG_TEXT, A_NORMAL);
+	mkattrn(DIALOG_BOX, A_BOLD);
+	mkattrn(DIALOG_MENU_FORE, A_STANDOUT);
+	mkattrn(DIALOG_MENU_BACK, A_NORMAL);
+
+	mkattrn(INPUT_BOX, A_BOLD);
+	mkattrn(INPUT_HEADING, A_BOLD);
+	mkattrn(INPUT_TEXT, A_NORMAL);
+	mkattrn(INPUT_FIELD, A_UNDERLINE);
+
+	mkattrn(FUNCTION_HIGHLIGHT, A_BOLD);
+	mkattrn(FUNCTION_TEXT, A_REVERSE);
+}
+
+void set_colors()
+{
+	start_color();
+	use_default_colors();
+	set_normal_colors();
+	if (has_colors()) {
+		normal_color_theme();
+	} else {
+		/* give deafults */
+		no_colors_theme();
+	}
+}
+
+
+/* this changes the windows attributes !!! */
+void print_in_middle(WINDOW *win,
+		int starty,
+		int startx,
+		int width,
+		const char *string,
+		chtype color)
+{      int length, x, y;
+	float temp;
+
+
+	if (win == NULL)
+		win = stdscr;
+	getyx(win, y, x);
+	if (startx != 0)
+		x = startx;
+	if (starty != 0)
+		y = starty;
+	if (width == 0)
+		width = 80;
+
+	length = strlen(string);
+	temp = (width - length) / 2;
+	x = startx + (int)temp;
+	wattrset(win, color);
+	mvwprintw(win, y, x, "%s", string);
+	refresh();
+}
+
+int get_line_no(const char *text)
+{
+	int i;
+	int total = 1;
+
+	if (!text)
+		return 0;
+
+	for (i = 0; text[i] != '\0'; i++)
+		if (text[i] == '\n')
+			total++;
+	return total;
+}
+
+const char *get_line(const char *text, int line_no)
+{
+	int i;
+	int lines = 0;
+
+	if (!text)
+		return 0;
+
+	for (i = 0; text[i] != '\0' && lines < line_no; i++)
+		if (text[i] == '\n')
+			lines++;
+	return text+i;
+}
+
+int get_line_length(const char *line)
+{
+	int res = 0;
+	while (*line != '\0' && *line != '\n') {
+		line++;
+		res++;
+	}
+	return res;
+}
+
+/* print all lines to the window. */
+void fill_window(WINDOW *win, const char *text)
+{
+	int x, y;
+	int total_lines = get_line_no(text);
+	int i;
+
+	getmaxyx(win, y, x);
+	/* do not go over end of line */
+	total_lines = min(total_lines, y);
+	for (i = 0; i < total_lines; i++) {
+		char tmp[x+10];
+		const char *line = get_line(text, i);
+		int len = get_line_length(line);
+		strncpy(tmp, line, min(len, x));
+		tmp[len] = '\0';
+		mvwprintw(win, i, 0, tmp);
+	}
+}
+
+/* get the message, and buttons.
+ * each button must be a char*
+ * return the selected button
+ *
+ * this dialog is used for 2 different things:
+ * 1) show a text box, no buttons.
+ * 2) show a dialog, with horizontal buttons
+ */
+int btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)
+{
+	va_list ap;
+	char *btn;
+	int btns_width = 0;
+	int msg_lines = 0;
+	int msg_width = 0;
+	int total_width;
+	int win_rows = 0;
+	WINDOW *win;
+	WINDOW *msg_win;
+	WINDOW *menu_win;
+	MENU *menu;
+	ITEM *btns[btn_num+1];
+	int i, x, y;
+	int res = -1;
+
+
+	va_start(ap, btn_num);
+	for (i = 0; i < btn_num; i++) {
+		btn = va_arg(ap, char *);
+		btns[i] = new_item(btn, "");
+		btns_width += strlen(btn)+1;
+	}
+	va_end(ap);
+	btns[btn_num] = NULL;
+
+	/* find the widest line of msg: */
+	msg_lines = get_line_no(msg);
+	for (i = 0; i < msg_lines; i++) {
+		const char *line = get_line(msg, i);
+		int len = get_line_length(line);
+		if (msg_width < len)
+			msg_width = len;
+	}
+
+	total_width = max(msg_width, btns_width);
+	/* place dialog in middle of screen */
+	y = (LINES-(msg_lines+4))/2;
+	x = (COLS-(total_width+4))/2;
+
+
+	/* create the windows */
+	if (btn_num > 0)
+		win_rows = msg_lines+4;
+	else
+		win_rows = msg_lines+2;
+
+	win = newwin(win_rows, total_width+4, y, x);
+	keypad(win, TRUE);
+	menu_win = derwin(win, 1, btns_width, win_rows-2,
+			1+(total_width+2-btns_width)/2);
+	menu = new_menu(btns);
+	msg_win = derwin(win, win_rows-2, msg_width, 1,
+			1+(total_width+2-msg_width)/2);
+
+	set_menu_fore(menu, attributes[DIALOG_MENU_FORE]);
+	set_menu_back(menu, attributes[DIALOG_MENU_BACK]);
+
+	wattrset(win, attributes[DIALOG_BOX]);
+	box(win, 0, 0);
+
+	/* print message */
+	wattrset(msg_win, attributes[DIALOG_TEXT]);
+	fill_window(msg_win, msg);
+
+	set_menu_win(menu, win);
+	set_menu_sub(menu, menu_win);
+	set_menu_format(menu, 1, btn_num);
+	menu_opts_off(menu, O_SHOWDESC);
+	menu_opts_off(menu, O_SHOWMATCH);
+	menu_opts_on(menu, O_ONEVALUE);
+	menu_opts_on(menu, O_NONCYCLIC);
+	set_menu_mark(menu, "");
+	post_menu(menu);
+
+
+	touchwin(win);
+	refresh_all_windows(main_window);
+	while ((res = wgetch(win))) {
+		switch (res) {
+		case KEY_LEFT:
+			menu_driver(menu, REQ_LEFT_ITEM);
+			break;
+		case KEY_RIGHT:
+			menu_driver(menu, REQ_RIGHT_ITEM);
+			break;
+		case 10: /* ENTER */
+		case 27: /* ESCAPE */
+		case ' ':
+		case KEY_F(F_BACK):
+		case KEY_F(F_EXIT):
+			break;
+		}
+		touchwin(win);
+		refresh_all_windows(main_window);
+
+		if (res == 10 || res == ' ') {
+			res = item_index(current_item(menu));
+			break;
+		} else if (res == 27 || res == KEY_F(F_BACK) ||
+				res == KEY_F(F_EXIT)) {
+			res = KEY_EXIT;
+			break;
+		}
+	}
+
+	unpost_menu(menu);
+	free_menu(menu);
+	for (i = 0; i < btn_num; i++)
+		free_item(btns[i]);
+
+	delwin(win);
+	return res;
+}
+
+int dialog_inputbox(WINDOW *main_window,
+		const char *title, const char *prompt,
+		const char *init, char *result, int result_len)
+{
+	int prompt_lines = 0;
+	int prompt_width = 0;
+	WINDOW *win;
+	WINDOW *prompt_win;
+	WINDOW *form_win;
+	PANEL *panel;
+	int i, x, y;
+	int res = -1;
+	int cursor_position = strlen(init);
+
+
+	/* find the widest line of msg: */
+	prompt_lines = get_line_no(prompt);
+	for (i = 0; i < prompt_lines; i++) {
+		const char *line = get_line(prompt, i);
+		int len = get_line_length(line);
+		prompt_width = max(prompt_width, len);
+	}
+
+	if (title)
+		prompt_width = max(prompt_width, strlen(title));
+
+	/* place dialog in middle of screen */
+	y = (LINES-(prompt_lines+4))/2;
+	x = (COLS-(prompt_width+4))/2;
+
+	strncpy(result, init, result_len);
+
+	/* create the windows */
+	win = newwin(prompt_lines+6, prompt_width+7, y, x);
+	prompt_win = derwin(win, prompt_lines+1, prompt_width, 2, 2);
+	form_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);
+	keypad(form_win, TRUE);
+
+	wattrset(form_win, attributes[INPUT_FIELD]);
+
+	wattrset(win, attributes[INPUT_BOX]);
+	box(win, 0, 0);
+	wattrset(win, attributes[INPUT_HEADING]);
+	if (title)
+		mvwprintw(win, 0, 3, "%s", title);
+
+	/* print message */
+	wattrset(prompt_win, attributes[INPUT_TEXT]);
+	fill_window(prompt_win, prompt);
+
+	mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
+	mvwprintw(form_win, 0, 0, "%s", result);
+
+	/* create panels */
+	panel = new_panel(win);
+
+	/* show the cursor */
+	curs_set(1);
+
+	touchwin(win);
+	refresh_all_windows(main_window);
+	while ((res = wgetch(form_win))) {
+		int len = strlen(result);
+		switch (res) {
+		case 10: /* ENTER */
+		case 27: /* ESCAPE */
+		case KEY_F(F_HELP):
+		case KEY_F(F_EXIT):
+		case KEY_F(F_BACK):
+			break;
+		case 127:
+		case KEY_BACKSPACE:
+			if (cursor_position > 0) {
+				memmove(&result[cursor_position-1],
+						&result[cursor_position],
+						len-cursor_position+1);
+				cursor_position--;
+			}
+			break;
+		case KEY_DC:
+			if (cursor_position >= 0 && cursor_position < len) {
+				memmove(&result[cursor_position],
+						&result[cursor_position+1],
+						len-cursor_position+1);
+			}
+			break;
+		case KEY_UP:
+		case KEY_RIGHT:
+			if (cursor_position < len &&
+			    cursor_position < min(result_len, prompt_width))
+				cursor_position++;
+			break;
+		case KEY_DOWN:
+		case KEY_LEFT:
+			if (cursor_position > 0)
+				cursor_position--;
+			break;
+		default:
+			if ((isgraph(res) || isspace(res)) &&
+					len-2 < result_len) {
+				/* insert the char at the proper position */
+				memmove(&result[cursor_position+1],
+						&result[cursor_position],
+						len+1);
+				result[cursor_position] = res;
+				cursor_position++;
+			} else {
+				mvprintw(0, 0, "unknow key: %d\n", res);
+			}
+			break;
+		}
+		wmove(form_win, 0, 0);
+		wclrtoeol(form_win);
+		mvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");
+		mvwprintw(form_win, 0, 0, "%s", result);
+		wmove(form_win, 0, cursor_position);
+		touchwin(win);
+		refresh_all_windows(main_window);
+
+		if (res == 10) {
+			res = 0;
+			break;
+		} else if (res == 27 || res == KEY_F(F_BACK) ||
+				res == KEY_F(F_EXIT)) {
+			res = KEY_EXIT;
+			break;
+		} else if (res == KEY_F(F_HELP)) {
+			res = 1;
+			break;
+		}
+	}
+
+	/* hide the cursor */
+	curs_set(0);
+	del_panel(panel);
+	delwin(prompt_win);
+	delwin(form_win);
+	delwin(win);
+	return res;
+}
+
+/* refresh all windows in the correct order */
+void refresh_all_windows(WINDOW *main_window)
+{
+	update_panels();
+	touchwin(main_window);
+	refresh();
+}
+
+/* layman's scrollable window... */
+void show_scroll_win(WINDOW *main_window,
+		const char *title,
+		const char *text)
+{
+	int res;
+	int total_lines = get_line_no(text);
+	int x, y;
+	int start_x = 0, start_y = 0;
+	int text_lines = 0, text_cols = 0;
+	int total_cols = 0;
+	int win_cols = 0;
+	int win_lines = 0;
+	int i = 0;
+	WINDOW *win;
+	WINDOW *pad;
+	PANEL *panel;
+
+	/* find the widest line of msg: */
+	total_lines = get_line_no(text);
+	for (i = 0; i < total_lines; i++) {
+		const char *line = get_line(text, i);
+		int len = get_line_length(line);
+		total_cols = max(total_cols, len+2);
+	}
+
+	/* create the pad */
+	pad = newpad(total_lines+10, total_cols+10);
+	wattrset(pad, attributes[SCROLLWIN_TEXT]);
+	fill_window(pad, text);
+
+	win_lines = min(total_lines+4, LINES-2);
+	win_cols = min(total_cols+2, COLS-2);
+	text_lines = max(win_lines-4, 0);
+	text_cols = max(win_cols-2, 0);
+
+	/* place window in middle of screen */
+	y = (LINES-win_lines)/2;
+	x = (COLS-win_cols)/2;
+
+	win = newwin(win_lines, win_cols, y, x);
+	keypad(win, TRUE);
+	/* show the help in the help window, and show the help panel */
+	wattrset(win, attributes[SCROLLWIN_BOX]);
+	box(win, 0, 0);
+	wattrset(win, attributes[SCROLLWIN_HEADING]);
+	mvwprintw(win, 0, 3, " %s ", title);
+	panel = new_panel(win);
+
+	/* handle scrolling */
+	do {
+
+		copywin(pad, win, start_y, start_x, 2, 2, text_lines,
+				text_cols, 0);
+		print_in_middle(win,
+				text_lines+2,
+				0,
+				text_cols,
+				"<OK>",
+				attributes[DIALOG_MENU_FORE]);
+		wrefresh(win);
+
+		res = wgetch(win);
+		switch (res) {
+		case KEY_NPAGE:
+		case ' ':
+			start_y += text_lines-2;
+			break;
+		case KEY_PPAGE:
+			start_y -= text_lines+2;
+			break;
+		case KEY_HOME:
+			start_y = 0;
+			break;
+		case KEY_END:
+			start_y = total_lines-text_lines;
+			break;
+		case KEY_DOWN:
+		case 'j':
+			start_y++;
+			break;
+		case KEY_UP:
+		case 'k':
+			start_y--;
+			break;
+		case KEY_LEFT:
+		case 'h':
+			start_x--;
+			break;
+		case KEY_RIGHT:
+		case 'l':
+			start_x++;
+			break;
+		}
+		if (res == 10 || res == 27 || res == 'q'
+		    || res == KEY_F(F_BACK) || res == KEY_F(F_EXIT)) {
+			break;
+		}
+		if (start_y < 0)
+			start_y = 0;
+		if (start_y >= total_lines-text_lines)
+			start_y = total_lines-text_lines;
+		if (start_x < 0)
+			start_x = 0;
+		if (start_x >= total_cols-text_cols)
+			start_x = total_cols-text_cols;
+	} while (res);
+
+	del_panel(panel);
+	delwin(win);
+	refresh_all_windows(main_window);
+}
