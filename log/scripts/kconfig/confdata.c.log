commit 089b7d890f972f6b649fedc9259f6b93a18fb970
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Tue Feb 4 13:08:44 2020 +0900

    kconfig: Invalidate all symbols after changing to y or m.
    
    Since commit 89b9060987d9 ("kconfig: Add yes2modconfig and
    mod2yesconfig targets.") forgot to clear SYMBOL_VALID bit after
    changing to y or m, these targets did not save the changes.
    Call sym_clear_all_valid() so that all symbols are revalidated.
    
    Fixes: 89b9060987d9 ("kconfig: Add yes2modconfig and mod2yesconfig targets.")
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 63d307b0d1ac..a39d93e3c6ae 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1331,9 +1331,8 @@ void conf_rewrite_mod_or_yes(enum conf_def_mode mode)
 
 	for_all_symbols(i, sym) {
 		if (sym_get_type(sym) == S_TRISTATE &&
-		    sym->def[S_DEF_USER].tri == old_val) {
+		    sym->def[S_DEF_USER].tri == old_val)
 			sym->def[S_DEF_USER].tri = new_val;
-			sym_add_change_count(1);
-		}
 	}
+	sym_clear_all_valid();
 }

commit c8fb7d7e48d11520ad24808cfce7afb7b9c9f798
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sat Feb 1 14:03:11 2020 +0900

    kconfig: fix broken dependency in randconfig-generated .config
    
    Running randconfig on arm64 using KCONFIG_SEED=0x40C5E904 (e.g. on v5.5)
    produces the .config with CONFIG_EFI=y and CONFIG_CPU_BIG_ENDIAN=y,
    which does not meet the !CONFIG_CPU_BIG_ENDIAN dependency.
    
    This is because the user choice for CONFIG_CPU_LITTLE_ENDIAN vs
    CONFIG_CPU_BIG_ENDIAN is set by randomize_choice_values() after the
    value of CONFIG_EFI is calculated.
    
    When this happens, the has_changed flag should be set.
    
    Currently, it takes the result from the last iteration. It should
    accumulate all the results of the loop.
    
    Fixes: 3b9a19e08960 ("kconfig: loop as long as we changed some symbols in randconfig")
    Reported-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 11f6c72c2eee..63d307b0d1ac 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1312,7 +1312,7 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 		sym_calc_value(csym);
 		if (mode == def_random)
-			has_changed = randomize_choice_values(csym);
+			has_changed |= randomize_choice_values(csym);
 		else {
 			set_all_choice_values(csym);
 			has_changed = true;

commit 14cd0bd04907df79b36a31e55f18768172230987
Merge: 368d060bb497 2b5072b9dfab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 1 10:25:55 2020 -0800

    Merge tag 'kconfig-v5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull Kconfig updates from Masahiro Yamada:
    
     - add 'yes2modconfig' and 'mod2yesconfig' targets (useful mainly for
       turning syzbot configs into more modular ones as a step to minimizing
       the result)
    
     - sanitize help text
    
     - various code cleanups
    
    * tag 'kconfig-v5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild:
      kconfig: fix documentation typos
      kconfig: fix an "implicit declaration of function" warning
      kconfig: fix nesting of symbol help text
      kconfig: distinguish between dependencies and visibility in help text
      kconfig: list all definitions of a symbol in help text
      kconfig: Add yes2modconfig and mod2yesconfig targets.
      kconfig: use $(PERL) in Makefile
      kconfig: fix too deep indentation in Makefile
      kconfig: localmodconfig: fix indentation for closing brace
      kconfig: localmodconfig: remove unused $config
      kconfig: squash prop_alloc() into menu_add_prop()
      kconfig: remove sym from struct property
      kconfig: remove 'prompt' argument from menu_add_prop()
      kconfig: move prompt handling to menu_add_prompt() from menu_add_prop()
      kconfig: remove 'prompt' symbol
      kconfig: drop T_WORD from the RHS of 'prompt' symbol
      kconfig: use parent->dep as the parentdep of 'menu'
      kconfig: remove the rootmenu check in menu_add_prop()

commit 89b9060987d988333de59dd218c9666bd7ee95a5
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Tue Dec 17 18:42:06 2019 +0900

    kconfig: Add yes2modconfig and mod2yesconfig targets.
    
    Since kernel configs provided by syzbot are close to "make allyesconfig",
    it takes long time to rebuild. This is especially waste of time when we
    need to rebuild for many times (e.g. doing manual printk() inspection,
    bisect operations).
    
    We can save time if we can exclude modules which are irrelevant to each
    problem. But "make localmodconfig" cannot exclude modules which are built
    into vmlinux because /sbin/lsmod output is used as the source of modules.
    
    Therefore, this patch adds "make yes2modconfig" which converts from =y
    to =m if possible. After confirming that the interested problem is still
    reproducible, we can try "make localmodconfig" (and/or manually tune
    based on "Modules linked in:" line) in order to exclude modules which are
    irrelevant to the interested problem. While we are at it, this patch also
    adds "make mod2yesconfig" which converts from =m to =y in case someone
    wants to convert from =m to =y after "make localmodconfig".
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 3569d2dec37c..99f2418baa6c 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1362,3 +1362,19 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	return has_changed;
 }
+
+void conf_rewrite_mod_or_yes(enum conf_def_mode mode)
+{
+	struct symbol *sym;
+	int i;
+	tristate old_val = (mode == def_y2m) ? yes : mod;
+	tristate new_val = (mode == def_y2m) ? mod : yes;
+
+	for_all_symbols(i, sym) {
+		if (sym_get_type(sym) == S_TRISTATE &&
+		    sym->def[S_DEF_USER].tri == old_val) {
+			sym->def[S_DEF_USER].tri = new_val;
+			sym_add_change_count(1);
+		}
+	}
+}

commit 8b41fc4454e36fbfdbb23f940d023d4dece2de29
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Thu Dec 19 17:33:29 2019 +0900

    kbuild: create modules.builtin without Makefile.modbuiltin or tristate.conf
    
    Commit bc081dd6e9f6 ("kbuild: generate modules.builtin") added
    infrastructure to generate modules.builtin, the list of all
    builtin modules.
    
    Basically, it works like this:
    
      - Kconfig generates include/config/tristate.conf, the list of
        tristate CONFIG options with a value in a capital letter.
    
      - scripts/Makefile.modbuiltin makes Kbuild descend into
        directories to collect the information of builtin modules.
    
    I am not a big fan of it because Kbuild ends up with traversing
    the source tree twice.
    
    I am not sure how perfectly it should work, but this approach cannot
    avoid false positives; even if the relevant CONFIG option is tristate,
    some Makefiles forces obj-m to obj-y.
    
    Some examples are:
    
      arch/powerpc/platforms/powermac/Makefile:
        obj-$(CONFIG_NVRAM:m=y)         += nvram.o
    
      net/ipv6/Makefile:
        obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
    
      net/netlabel/Makefile:
        obj-$(subst m,y,$(CONFIG_IPV6)) += netlabel_calipso.o
    
    Nobody has complained about (or noticed) it, so it is probably fine to
    have false positives in modules.builtin.
    
    This commit simplifies the implementation. Let's exploit the fact
    that every module has MODULE_LICENSE(). (modpost shows a warning if
    MODULE_LICENSE is missing. If so, 0-day bot would already have blocked
    such a module.)
    
    I added MODULE_FILE to <linux/module.h>. When the code is being compiled
    as builtin, it will be filled with the file path of the module, and
    collected into modules.builtin.info. Then, scripts/link-vmlinux.sh
    extracts the list of builtin modules out of it.
    
    This new approach fixes the false-positives above, but adds another
    type of false-positives; non-modular code may have MODULE_LICENSE()
    by mistake. This is not a big deal, it is just the code is always
    orphan. We can clean it up if we like. You can see cleanup examples by:
    
      $ git log --grep='make.* explicitly non-modular'
    
    To sum up, this commits deletes lots of code, but still produces almost
    equivalent results. Please note it does not increase the vmlinux size at
    all. As you can see in include/asm-generic/vmlinux.lds.h, the .modinfo
    section is discarded in the link stage.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 3569d2dec37c..fb675bd9a809 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -710,25 +710,6 @@ static struct conf_printer header_printer_cb =
 	.print_comment = header_print_comment,
 };
 
-/*
- * Tristate printer
- *
- * This printer is used when generating the `include/config/tristate.conf' file.
- */
-static void
-tristate_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
-{
-
-	if (sym->type == S_TRISTATE && *value != 'n')
-		fprintf(fp, "%s%s=%c\n", CONFIG_, sym->name, (char)toupper(*value));
-}
-
-static struct conf_printer tristate_printer_cb =
-{
-	.print_symbol = tristate_print_symbol,
-	.print_comment = kconfig_print_comment,
-};
-
 static void conf_write_symbol(FILE *fp, struct symbol *sym,
 			      struct conf_printer *printer, void *printer_arg)
 {
@@ -1062,7 +1043,7 @@ int conf_write_autoconf(int overwrite)
 	struct symbol *sym;
 	const char *name;
 	const char *autoconf_name = conf_get_autoconfig_name();
-	FILE *out, *tristate, *out_h;
+	FILE *out, *out_h;
 	int i;
 
 	if (!overwrite && is_present(autoconf_name))
@@ -1077,23 +1058,13 @@ int conf_write_autoconf(int overwrite)
 	if (!out)
 		return 1;
 
-	tristate = fopen(".tmpconfig_tristate", "w");
-	if (!tristate) {
-		fclose(out);
-		return 1;
-	}
-
 	out_h = fopen(".tmpconfig.h", "w");
 	if (!out_h) {
 		fclose(out);
-		fclose(tristate);
 		return 1;
 	}
 
 	conf_write_heading(out, &kconfig_printer_cb, NULL);
-
-	conf_write_heading(tristate, &tristate_printer_cb, NULL);
-
 	conf_write_heading(out_h, &header_printer_cb, NULL);
 
 	for_all_symbols(i, sym) {
@@ -1101,15 +1072,11 @@ int conf_write_autoconf(int overwrite)
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
 
-		/* write symbol to auto.conf, tristate and header files */
+		/* write symbols to auto.conf and autoconf.h */
 		conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
-
-		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);
-
 		conf_write_symbol(out_h, sym, &header_printer_cb, NULL);
 	}
 	fclose(out);
-	fclose(tristate);
 	fclose(out_h);
 
 	name = getenv("KCONFIG_AUTOHEADER");
@@ -1120,14 +1087,6 @@ int conf_write_autoconf(int overwrite)
 	if (rename(".tmpconfig.h", name))
 		return 1;
 
-	name = getenv("KCONFIG_TRISTATE");
-	if (!name)
-		name = "include/config/tristate.conf";
-	if (make_parent_dir(name))
-		return 1;
-	if (rename(".tmpconfig_tristate", name))
-		return 1;
-
 	if (make_parent_dir(autoconf_name))
 		return 1;
 	/*

commit 0c5b6c28ed68becb692b43eae5e44d5aa7e160ce
Author: M. Vefa Bicakci <m.v.b@runbox.com>
Date:   Sat Aug 3 06:02:12 2019 -0400

    kconfig: Clear "written" flag to avoid data loss
    
    Prior to this commit, starting nconfig, xconfig or gconfig, and saving
    the .config file more than once caused data loss, where a .config file
    that contained only comments would be written to disk starting from the
    second save operation.
    
    This bug manifests itself because the SYMBOL_WRITTEN flag is never
    cleared after the first call to conf_write, and subsequent calls to
    conf_write then skip all of the configuration symbols due to the
    SYMBOL_WRITTEN flag being set.
    
    This commit resolves this issue by clearing the SYMBOL_WRITTEN flag
    from all symbols before conf_write returns.
    
    Fixes: 8e2442a5f86e ("kconfig: fix missing choice values in auto.conf")
    Cc: linux-stable <stable@vger.kernel.org> # 4.19+
    Signed-off-by: M. Vefa Bicakci <m.v.b@runbox.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 1134892599da..3569d2dec37c 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -848,6 +848,7 @@ int conf_write(const char *name)
 	const char *str;
 	char tmpname[PATH_MAX + 1], oldname[PATH_MAX + 1];
 	char *env;
+	int i;
 	bool need_newline = false;
 
 	if (!name)
@@ -930,6 +931,9 @@ int conf_write(const char *name)
 	}
 	fclose(out);
 
+	for_all_symbols(i, sym)
+		sym->flags &= ~SYMBOL_WRITTEN;
+
 	if (*tmpname) {
 		if (is_same(name, tmpname)) {
 			conf_message("No change to %s", name);

commit 8e2442a5f86e1f77b86401fce274a7f622740bc4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 12 15:07:09 2019 +0900

    kconfig: fix missing choice values in auto.conf
    
    Since commit 00c864f8903d ("kconfig: allow all config targets to write
    auto.conf if missing"), Kconfig creates include/config/auto.conf in the
    defconfig stage when it is missing.
    
    Joonas Kylmälä reported incorrect auto.conf generation under some
    circumstances.
    
    To reproduce it, apply the following diff:
    
    |  --- a/arch/arm/configs/imx_v6_v7_defconfig
    |  +++ b/arch/arm/configs/imx_v6_v7_defconfig
    |  @@ -345,14 +345,7 @@ CONFIG_USB_CONFIGFS_F_MIDI=y
    |   CONFIG_USB_CONFIGFS_F_HID=y
    |   CONFIG_USB_CONFIGFS_F_UVC=y
    |   CONFIG_USB_CONFIGFS_F_PRINTER=y
    |  -CONFIG_USB_ZERO=m
    |  -CONFIG_USB_AUDIO=m
    |  -CONFIG_USB_ETH=m
    |  -CONFIG_USB_G_NCM=m
    |  -CONFIG_USB_GADGETFS=m
    |  -CONFIG_USB_FUNCTIONFS=m
    |  -CONFIG_USB_MASS_STORAGE=m
    |  -CONFIG_USB_G_SERIAL=m
    |  +CONFIG_USB_FUNCTIONFS=y
    |   CONFIG_MMC=y
    |   CONFIG_MMC_SDHCI=y
    |   CONFIG_MMC_SDHCI_PLTFM=y
    
    And then, run:
    
    $ make ARCH=arm mrproper imx_v6_v7_defconfig
    
    You will see CONFIG_USB_FUNCTIONFS=y is correctly contained in the
    .config, but not in the auto.conf.
    
    Please note drivers/usb/gadget/legacy/Kconfig is included from a choice
    block in drivers/usb/gadget/Kconfig. So USB_FUNCTIONFS is a choice value.
    
    This is probably a similar situation described in commit beaaddb62540
    ("kconfig: tests: test defconfig when two choices interact").
    
    When sym_calc_choice() is called, the choice symbol forgets the
    SYMBOL_DEF_USER unless all of its choice values are explicitly set by
    the user.
    
    The choice symbol is given just one chance to recall it because
    set_all_choice_values() is called if SYMBOL_NEED_SET_CHOICE_VALUES
    is set.
    
    When sym_calc_choice() is called again, the choice symbol forgets it
    forever, since SYMBOL_NEED_SET_CHOICE_VALUES is a one-time aid.
    Hence, we cannot call sym_clear_all_valid() again and again.
    
    It is crazy to repeat set and unset of internal flags. However, we
    cannot simply get rid of "sym->flags &= flags | ~SYMBOL_DEF_USER;"
    Doing so would re-introduce the problem solved by commit 5d09598d488f
    ("kconfig: fix new choices being skipped upon config update").
    
    To work around the issue, conf_write_autoconf() stopped calling
    sym_clear_all_valid().
    
    conf_write() must be changed accordingly. Currently, it clears
    SYMBOL_WRITE after the symbol is written into the .config file. This
    is needed to prevent it from writing the same symbol multiple times in
    case the symbol is declared in two or more locations. I added the new
    flag SYMBOL_WRITTEN, to track the symbols that have been written.
    
    Anyway, this is a cheesy workaround in order to suppress the issue
    as far as defconfig is concerned.
    
    Handling of choices is totally broken. sym_clear_all_valid() is called
    every time a user touches a symbol from the GUI interface. To reproduce
    it, just add a new symbol drivers/usb/gadget/legacy/Kconfig, then touch
    around unrelated symbols from menuconfig. USB_FUNCTIONFS will disappear
    from the .config file.
    
    I added the Fixes tag since it is more fatal than before. But, this
    has been broken since long long time before, and still it is.
    We should take a closer look to fix this correctly somehow.
    
    Fixes: 00c864f8903d ("kconfig: allow all config targets to write auto.conf if missing")
    Cc: linux-stable <stable@vger.kernel.org> # 4.19+
    Reported-by: Joonas Kylmälä <joonas.kylmala@iki.fi>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Joonas Kylmälä <joonas.kylmala@iki.fi>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 501fdcc5e999..1134892599da 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -895,7 +895,8 @@ int conf_write(const char *name)
 				     "# %s\n"
 				     "#\n", str);
 			need_newline = false;
-		} else if (!(sym->flags & SYMBOL_CHOICE)) {
+		} else if (!(sym->flags & SYMBOL_CHOICE) &&
+			   !(sym->flags & SYMBOL_WRITTEN)) {
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
@@ -903,7 +904,7 @@ int conf_write(const char *name)
 				fprintf(out, "\n");
 				need_newline = false;
 			}
-			sym->flags &= ~SYMBOL_WRITE;
+			sym->flags |= SYMBOL_WRITTEN;
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 
@@ -1063,8 +1064,6 @@ int conf_write_autoconf(int overwrite)
 	if (!overwrite && is_present(autoconf_name))
 		return 0;
 
-	sym_clear_all_valid();
-
 	conf_write_dep("include/config/auto.conf.cmd");
 
 	if (conf_touch_deps())

commit e3cd5136a4ecece6a7599a07add0dfb811a7f49d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jul 11 16:33:17 2019 +0900

    kconfig: remove meaningless if-conditional in conf_read()
    
    sym_is_choice(sym) has already been checked by previous if-block:
    
        if (sym_is_choice(sym) || (sym->flags & SYMBOL_NO_WRITE))
                continue;
    
    Hence, the following code is redundant, and the comment is misleading:
    
        if (!sym_is_choice(sym))
                continue;
        /* fall through */
    
    It always takes 'continue', never falls though.
    
    Clean up the dead code.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index caab7336abc1..501fdcc5e999 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -534,11 +534,9 @@ int conf_read(const char *name)
 			switch (sym->type) {
 			case S_BOOLEAN:
 			case S_TRISTATE:
-				if (sym->def[S_DEF_USER].tri != sym_get_tristate_value(sym))
-					break;
-				if (!sym_is_choice(sym))
+				if (sym->def[S_DEF_USER].tri == sym_get_tristate_value(sym))
 					continue;
-				/* fall through */
+				break;
 			default:
 				if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
 					continue;

commit baa23ec860920ebf3e897c4bbb3420a88ea80ec1
Author: Marco Ammon <marco.ammon@fau.de>
Date:   Thu Jul 4 12:50:41 2019 +0200

    kconfig: Fix spelling of sym_is_changable
    
    There is a spelling mistake in "changable", it is corrected to
    "changeable" and all call sites are updated accordingly.
    
    Signed-off-by: Marco Ammon <marco.ammon@fau.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 18e8051d89d7..caab7336abc1 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -796,7 +796,7 @@ int conf_write_defconfig(const char *filename)
 				goto next_menu;
 			sym->flags &= ~SYMBOL_WRITE;
 			/* If we cannot change the symbol - skip */
-			if (!sym_is_changable(sym))
+			if (!sym_is_changeable(sym))
 				goto next_menu;
 			/* If symbol equals to default value - skip */
 			if (strcmp(sym_get_string_value(sym), sym_get_string_default(sym)) == 0)

commit b6f7e9f7050b9f8e5fe60d86e05c0740295a54bf
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 27 23:37:22 2019 +0900

    kconfig: require the argument of --defconfig
    
    Currently, the argument for --defconfig is optional. If the argument
    is not passed, the hard-coded default arch/$(ARCH)/defconfig is used.
    
    It no longer happens in Linux since the last users of the default are
    gone by the following commits:
    
    - Commit f3e20ad67b4c ("s390: move arch/s390/defconfig to
      arch/s390/configs/defconfig")
    
    - Commit 986a13769c4b ("alpha: move arch/alpha/defconfig to
      arch/alpha/configs/defconfig")
    
    I want to kill the Linux-specific directory path embedded in the
    Kconfig binary.
    
    The --savedefconfig (reverse operation of --defconfig) requires an
    argument, so it should not hurt to do likewise for --defconfig.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 6006154d36bd..18e8051d89d7 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -177,8 +177,6 @@ static void conf_message(const char *fmt, ...)
 static const char *conf_filename;
 static int conf_lineno, conf_warnings;
 
-const char conf_defname[] = "arch/$(ARCH)/defconfig";
-
 static void conf_warning(const char *fmt, ...)
 {
 	va_list ap;
@@ -233,21 +231,6 @@ static const char *conf_get_autoconfig_name(void)
 	return name ? name : "include/config/auto.conf";
 }
 
-char *conf_get_default_confname(void)
-{
-	static char fullname[PATH_MAX+1];
-	char *env, *name;
-
-	name = expand_string(conf_defname);
-	env = getenv(SRCTREE);
-	if (env) {
-		snprintf(fullname, sizeof(fullname), "%s/%s", env, name);
-		if (is_present(fullname))
-			return fullname;
-	}
-	return name;
-}
-
 static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 {
 	char *p2;

commit aff11cd983ec0850651ee9b1c2a88b33358cb2f2
Author: Alexander Popov <alex.popov@linux.com>
Date:   Fri May 17 22:42:22 2019 +0300

    kconfig: Terminate menu blocks with a comment in the generated config
    
    Currently menu blocks start with a pretty header but end with nothing in
    the generated config. So next config options stick together with the
    options from the menu block.
    
    Let's terminate menu blocks in the generated config with a comment and
    a newline if needed. Example:
    
    ...
    CONFIG_BPF_STREAM_PARSER=y
    CONFIG_NET_FLOW_LIMIT=y
    
    #
    # Network testing
    #
    CONFIG_NET_PKTGEN=y
    CONFIG_NET_DROP_MONITOR=y
    # end of Network testing
    # end of Networking options
    
    CONFIG_HAMRADIO=y
    ...
    
    Signed-off-by: Alexander Popov <alex.popov@linux.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 492ac3410147..6006154d36bd 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -867,6 +867,7 @@ int conf_write(const char *name)
 	const char *str;
 	char tmpname[PATH_MAX + 1], oldname[PATH_MAX + 1];
 	char *env;
+	bool need_newline = false;
 
 	if (!name)
 		name = conf_get_configname();
@@ -912,12 +913,16 @@ int conf_write(const char *name)
 				     "#\n"
 				     "# %s\n"
 				     "#\n", str);
+			need_newline = false;
 		} else if (!(sym->flags & SYMBOL_CHOICE)) {
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
+			if (need_newline) {
+				fprintf(out, "\n");
+				need_newline = false;
+			}
 			sym->flags &= ~SYMBOL_WRITE;
-
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 
@@ -929,6 +934,12 @@ int conf_write(const char *name)
 		if (menu->next)
 			menu = menu->next;
 		else while ((menu = menu->parent)) {
+			if (!menu->sym && menu_is_visible(menu) &&
+			    menu != &rootmenu) {
+				str = menu_get_prompt(menu);
+				fprintf(out, "# end of %s\n", str);
+				need_newline = true;
+			}
 			if (menu->next) {
 				menu = menu->next;
 				break;

commit 9b9f5948afcdf583cb1b58e0c4cc327aa1820f5a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 13 01:00:53 2019 +0900

    kconfig: make conf_get_autoconfig_name() static
    
    This is only used in confdata.c
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 8bb74d468f45..492ac3410147 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -226,7 +226,7 @@ const char *conf_get_configname(void)
 	return name ? name : ".config";
 }
 
-const char *conf_get_autoconfig_name(void)
+static const char *conf_get_autoconfig_name(void)
 {
 	char *name = getenv("KCONFIG_AUTOCONFIG");
 

commit b9d1a8e9302e68ee03571a286aadeb8041e0b2ca
Author: Jacob Garber <jgarber1@ualberta.ca>
Date:   Fri May 10 13:28:52 2019 -0600

    kconfig: use snprintf for formatting pathnames
    
    Valid pathnames will never exceed PATH_MAX, but these file names
    are unsanitized and can cause buffer overflow if set incorrectly.
    Use snprintf to avoid this. This was flagged during a Coverity scan
    of the coreboot project, which also uses kconfig for its build system.
    
    Signed-off-by: Jacob Garber <jgarber1@ualberta.ca>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index b7bdd9690319..8bb74d468f45 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -241,7 +241,7 @@ char *conf_get_default_confname(void)
 	name = expand_string(conf_defname);
 	env = getenv(SRCTREE);
 	if (env) {
-		sprintf(fullname, "%s/%s", env, name);
+		snprintf(fullname, sizeof(fullname), "%s/%s", env, name);
 		if (is_present(fullname))
 			return fullname;
 	}

commit 4cb726121e2cce18d4db5e79347f3ade5fd661a2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat May 11 01:56:48 2019 +0900

    kconfig: remove useless NULL pointer check in conf_write_dep()
    
    conf_write_dep() has just one caller:
    
        conf_write_dep("include/config/auto.conf.cmd");
    
    "name" always points to a valid string.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index d7bd353a8e50..b7bdd9690319 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -964,8 +964,6 @@ static int conf_write_dep(const char *name)
 	struct file *file;
 	FILE *out;
 
-	if (!name)
-		name = ".kconfig.d";
 	out = fopen("..config.tmp", "w");
 	if (!out)
 		return 1;

commit 580c5b3e1b8bc49dd5452c8a65a72452c534b4b5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat May 11 01:56:01 2019 +0900

    kconfig: make parent directories for the saved .config as needed
    
    With menuconfig / nconfig, users can input any file path from the
    "Save" menu, but it fails if the parent directory does not exist.
    
    Why not create the parent directory automatically. I think this is
    a user-friendly behavior.
    
    I changed the error messages in menuconfig / nconfig.
    
    "Nonexistent directory" is no longer the most likely reason of the
    failure. Perhaps, the user specified the existing directory, or
    attempted to write to the location without write permission.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 399973e35533..d7bd353a8e50 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -881,6 +881,9 @@ int conf_write(const char *name)
 		return -1;
 	}
 
+	if (make_parent_dir(name))
+		return -1;
+
 	env = getenv("KCONFIG_OVERWRITECONFIG");
 	if (env && *env) {
 		*tmpname = 0;

commit 67424f61f8132215514e03ce1760d30356ac56d7
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri May 10 15:12:05 2019 +0900

    kconfig: do not write .config if the content is the same
    
    Kconfig updates the .config when it exits even if its content is
    exactly the same as before. Since its timestamp becomes newer than
    that of other build artifacts, additional processing is invoked,
    which is annoying.
    
    - syncconfig is invoked to update include/config/auto.conf, etc.
    
    - kernel/configs.o is recompiled if CONFIG_IKCONFIG is enabled,
      then vmlinux is relinked as well.
    
    If the .config is not changed at all, we do not have to even
    touch it. Just bail out showing "No change to .config".
    
      $ make allmodconfig
      scripts/kconfig/conf  --allmodconfig Kconfig
      #
      # configuration written to .config
      #
      $ make allmodconfig
      scripts/kconfig/conf  --allmodconfig Kconfig
      #
      # No change to .config
      #
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 9fd6430c93d2..399973e35533 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -3,6 +3,7 @@
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
  */
 
+#include <sys/mman.h>
 #include <sys/stat.h>
 #include <ctype.h>
 #include <errno.h>
@@ -36,6 +37,52 @@ static bool is_dir(const char *path)
 	return S_ISDIR(st.st_mode);
 }
 
+/* return true if the given two files are the same, false otherwise */
+static bool is_same(const char *file1, const char *file2)
+{
+	int fd1, fd2;
+	struct stat st1, st2;
+	void *map1, *map2;
+	bool ret = false;
+
+	fd1 = open(file1, O_RDONLY);
+	if (fd1 < 0)
+		return ret;
+
+	fd2 = open(file2, O_RDONLY);
+	if (fd2 < 0)
+		goto close1;
+
+	ret = fstat(fd1, &st1);
+	if (ret)
+		goto close2;
+	ret = fstat(fd2, &st2);
+	if (ret)
+		goto close2;
+
+	if (st1.st_size != st2.st_size)
+		goto close2;
+
+	map1 = mmap(NULL, st1.st_size, PROT_READ, MAP_PRIVATE, fd1, 0);
+	if (map1 == MAP_FAILED)
+		goto close2;
+
+	map2 = mmap(NULL, st2.st_size, PROT_READ, MAP_PRIVATE, fd2, 0);
+	if (map2 == MAP_FAILED)
+		goto close2;
+
+	if (bcmp(map1, map2, st1.st_size))
+		goto close2;
+
+	ret = true;
+close2:
+	close(fd2);
+close1:
+	close(fd1);
+
+	return ret;
+}
+
 /*
  * Create the parent directory of the given path.
  *
@@ -888,6 +935,13 @@ int conf_write(const char *name)
 	fclose(out);
 
 	if (*tmpname) {
+		if (is_same(name, tmpname)) {
+			conf_message("No change to %s", name);
+			unlink(tmpname);
+			sym_set_change_count(0);
+			return 0;
+		}
+
 		snprintf(oldname, sizeof(oldname), "%s.old", name);
 		rename(name, oldname);
 		if (rename(tmpname, name))

commit ceb7f3296ea1fa652d68e5ecb0facf5fba19a554
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri May 10 15:12:04 2019 +0900

    kconfig: do not accept a directory for configuration output
    
    Currently, conf_write() can be called with a directory name instead
    of a file name. As far as I see, this can happen for menuconfig,
    nconfig, gconfig.
    
    If it is given with a directory path, conf_write() kindly appends
    getenv("KCONFIG_CONFIG"), but this ends up with hacky dir/basename
    handling, and screwed up in corner-cases like "what if KCONFIG_CONFIG
    is an absolute path?" as discussed before:
    
      https://patchwork.kernel.org/patch/9910037/
    
    Since conf_write() is already messed up, I'd say "do not do it".
    Please pass a file path all the time. If a directory path is specified
    for the configuration output, conf_write() will simply error out.
    
    Now that the tmp file is created in the same directory as the .config,
    the previously reported "what if KCONFIG_CONFIG points to a different
    file system?" has been solved.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Nicolas Porcel <nicolasporcel06@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 08ba146a83c5..9fd6430c93d2 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -817,40 +817,31 @@ int conf_write(const char *name)
 	FILE *out;
 	struct symbol *sym;
 	struct menu *menu;
-	const char *basename;
 	const char *str;
-	char dirname[PATH_MAX+1], tmpname[PATH_MAX+22], newname[PATH_MAX+8];
+	char tmpname[PATH_MAX + 1], oldname[PATH_MAX + 1];
 	char *env;
 
-	dirname[0] = 0;
-	if (name && name[0]) {
-		char *slash;
-
-		if (is_dir(name)) {
-			strcpy(dirname, name);
-			strcat(dirname, "/");
-			basename = conf_get_configname();
-		} else if ((slash = strrchr(name, '/'))) {
-			int size = slash - name + 1;
-			memcpy(dirname, name, size);
-			dirname[size] = 0;
-			if (slash[1])
-				basename = slash + 1;
-			else
-				basename = conf_get_configname();
-		} else
-			basename = name;
-	} else
-		basename = conf_get_configname();
-
-	sprintf(newname, "%s%s", dirname, basename);
+	if (!name)
+		name = conf_get_configname();
+
+	if (!*name) {
+		fprintf(stderr, "config name is empty\n");
+		return -1;
+	}
+
+	if (is_dir(name)) {
+		fprintf(stderr, "%s: Is a directory\n", name);
+		return -1;
+	}
+
 	env = getenv("KCONFIG_OVERWRITECONFIG");
-	if (!env || !*env) {
-		sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
-		out = fopen(tmpname, "w");
-	} else {
+	if (env && *env) {
 		*tmpname = 0;
-		out = fopen(newname, "w");
+		out = fopen(name, "w");
+	} else {
+		snprintf(tmpname, sizeof(tmpname), "%s.%d.tmp",
+			 name, (int)getpid());
+		out = fopen(tmpname, "w");
 	}
 	if (!out)
 		return 1;
@@ -897,14 +888,13 @@ int conf_write(const char *name)
 	fclose(out);
 
 	if (*tmpname) {
-		strcat(dirname, basename);
-		strcat(dirname, ".old");
-		rename(newname, dirname);
-		if (rename(tmpname, newname))
+		snprintf(oldname, sizeof(oldname), "%s.old", name);
+		rename(name, oldname);
+		if (rename(tmpname, name))
 			return 1;
 	}
 
-	conf_message("configuration written to %s", newname);
+	conf_message("configuration written to %s", name);
 
 	sym_set_change_count(0);
 

commit 558e78e3ce844c61ceffe32775dbefacf167b023
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Dec 21 17:33:04 2018 +0900

    kconfig: split some C files out of zconf.y
    
    I want to compile each C file independently instead of including all
    of them from zconf.y.
    
    Split out confdata.c, expr.c, symbol.c, and preprocess.c .
    These are low-hanging fruits.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 83f78e5c137e..08ba146a83c5 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -7,6 +7,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>

commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 9ef135735cfa..83f78e5c137e 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- * Released under the terms of the GNU GPL v2.0.
  */
 
 #include <sys/stat.h>

commit 2aabbed6774f231c57f8ae6bc4f856fb2a75cd6a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 18:15:51 2018 +0900

    kconfig: remove S_OTHER symbol type and correct dependency tracking
    
    The S_OTHER type could be set only when conf_read_simple() is reading
    include/config/auto.conf file.
    
    For example, CONFIG_FOO=y exists in include/config/auto.conf but it is
    missing from the currently parsed Kconfig files, sym_lookup() allocates
    a new symbol, and sets its type to S_OTHER.
    
    Strangely, it will be set to S_STRING by conf_set_sym_val() a few lines
    below while it is obviously bool or tristate type. On the other hand,
    when CONFIG_BAR="bar" is being dropped from include/config/auto.conf,
    its type remains S_OTHER. Because for_all_symbols() omits S_OTHER
    symbols, conf_touch_deps() misses to touch include/config/bar.h
    
    This behavior has been a pretty mystery for me, and digging the git
    histroy did not help. At least, touching depfiles is broken for string
    type symbols.
    
    I removed S_OTHER entirely, and reimplemented it more simply.
    
    If CONFIG_FOO was visible in the previous syncconfig, but is missing
    now, what we want to do is quite simple; just call conf_touch_dep()
    to touch include/config/foo.h instead of allocating a new symbol data.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 39dfe463de15..9ef135735cfa 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -227,14 +227,6 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			conf_warning("symbol value '%s' invalid for %s",
 				     p, sym->name);
 		return 1;
-	case S_OTHER:
-		if (*p != '"') {
-			for (p2 = p; *p2 && !isspace(*p2); p2++)
-				;
-			sym->type = S_STRING;
-			goto done;
-		}
-		/* fall through */
 	case S_STRING:
 		if (*p++ != '"')
 			break;
@@ -253,7 +245,6 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 		/* fall through */
 	case S_INT:
 	case S_HEX:
-	done:
 		if (sym_string_valid(sym, p)) {
 			sym->def[def].val = xstrdup(p);
 			sym->flags |= def_flags;
@@ -434,17 +425,22 @@ int conf_read_simple(const char *name, int def)
 				if (*p2 == '\r')
 					*p2 = 0;
 			}
-			if (def == S_DEF_USER) {
-				sym = sym_find(line + strlen(CONFIG_));
-				if (!sym) {
+
+			sym = sym_find(line + strlen(CONFIG_));
+			if (!sym) {
+				if (def == S_DEF_AUTO)
+					/*
+					 * Reading from include/config/auto.conf
+					 * If CONFIG_FOO previously existed in
+					 * auto.conf but it is missing now,
+					 * include/config/foo.h must be touched.
+					 */
+					conf_touch_dep(line + strlen(CONFIG_));
+				else
 					sym_add_change_count(1);
-					continue;
-				}
-			} else {
-				sym = sym_lookup(line + strlen(CONFIG_), 0);
-				if (sym->type == S_UNKNOWN)
-					sym->type = S_OTHER;
+				continue;
 			}
+
 			if (sym->flags & def_flags) {
 				conf_warning("override: reassigning to symbol %s", sym->name);
 			}
@@ -710,7 +706,6 @@ static void conf_write_symbol(FILE *fp, struct symbol *sym,
 	const char *str;
 
 	switch (sym->type) {
-	case S_OTHER:
 	case S_UNKNOWN:
 		break;
 	case S_STRING:

commit 1508fec82e394149212aca836dd925d7e8fa3228
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 18:15:50 2018 +0900

    kconfig: split out code touching a file to conf_touch_dep()
    
    conf_touch_deps() iterates over symbols, touching corresponding
    include/config/*.h files as needed.
    
    Split the part that touches a single file into a new helper so it can
    be reused.
    
    The new helper, conf_touch_dep(), takes a symbol name as a parameter,
    and touches the corresponding include/config/*.h file.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 4c76d561d383..39dfe463de15 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -74,6 +74,47 @@ static int make_parent_dir(const char *path)
 	return 0;
 }
 
+static char depfile_path[PATH_MAX];
+static size_t depfile_prefix_len;
+
+/* touch depfile for symbol 'name' */
+static int conf_touch_dep(const char *name)
+{
+	int fd, ret;
+	const char *s;
+	char *d, c;
+
+	/* check overflow: prefix + name + ".h" + '\0' must fit in buffer. */
+	if (depfile_prefix_len + strlen(name) + 3 > sizeof(depfile_path))
+		return -1;
+
+	d = depfile_path + depfile_prefix_len;
+	s = name;
+
+	while ((c = *s++))
+		*d++ = (c == '_') ? '/' : tolower(c);
+	strcpy(d, ".h");
+
+	/* Assume directory path already exists. */
+	fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
+	if (fd == -1) {
+		if (errno != ENOENT)
+			return -1;
+
+		ret = make_parent_dir(depfile_path);
+		if (ret)
+			return ret;
+
+		/* Try it again. */
+		fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
+		if (fd == -1)
+			return -1;
+	}
+	close(fd);
+
+	return 0;
+}
+
 struct conf_printer {
 	void (*print_symbol)(FILE *, struct symbol *, const char *, void *);
 	void (*print_comment)(FILE *, const char *, void *);
@@ -909,21 +950,16 @@ static int conf_write_dep(const char *name)
 static int conf_touch_deps(void)
 {
 	const char *name;
-	char path[PATH_MAX+1];
-	char *s, *d, c;
 	struct symbol *sym;
-	int res, i, fd;
+	int res, i;
+
+	strcpy(depfile_path, "include/config/");
+	depfile_prefix_len = strlen(depfile_path);
 
 	name = conf_get_autoconfig_name();
 	conf_read_simple(name, S_DEF_AUTO);
 	sym_calc_value(modules_sym);
 
-	if (make_parent_dir("include/config/foo.h"))
-		return 1;
-	if (chdir("include/config"))
-		return 1;
-
-	res = 0;
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
 		if ((sym->flags & SYMBOL_NO_WRITE) || !sym->name)
@@ -975,42 +1011,12 @@ static int conf_touch_deps(void)
 		 *	different from 'no').
 		 */
 
-		/* Replace all '_' and append ".h" */
-		s = sym->name;
-		d = path;
-		while ((c = *s++)) {
-			c = tolower(c);
-			*d++ = (c == '_') ? '/' : c;
-		}
-		strcpy(d, ".h");
-
-		/* Assume directory path already exists. */
-		fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-		if (fd == -1) {
-			if (errno != ENOENT) {
-				res = 1;
-				break;
-			}
-
-			if (make_parent_dir(path)) {
-				res = 1;
-				goto out;
-			}
-
-			/* Try it again. */
-			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-			if (fd == -1) {
-				res = 1;
-				break;
-			}
-		}
-		close(fd);
+		res = conf_touch_dep(sym->name);
+		if (res)
+			return res;
 	}
-out:
-	if (chdir("../.."))
-		return 1;
 
-	return res;
+	return 0;
 }
 
 int conf_write_autoconf(int overwrite)

commit 0849d212e39523e2289c2a6d685b899f944746eb
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 18:15:49 2018 +0900

    kconfig: rename conf_split_config() to conf_touch_deps()
    
    According to commit 2e3646e51b2d ("kconfig: integrate split config
    into silentoldconfig"), this function was named after split-include
    tool, which used to exist in old versions of Linux.
    
    Setting aside the historical reason, rename it into a more intuitive
    name. This function touches timestamp files under include/config/
    in order to interact with the fixdep tool.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 1e35529d4eeb..4c76d561d383 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -906,7 +906,7 @@ static int conf_write_dep(const char *name)
 	return 0;
 }
 
-static int conf_split_config(void)
+static int conf_touch_deps(void)
 {
 	const char *name;
 	char path[PATH_MAX+1];
@@ -1028,7 +1028,7 @@ int conf_write_autoconf(int overwrite)
 
 	conf_write_dep("include/config/auto.conf.cmd");
 
-	if (conf_split_config())
+	if (conf_touch_deps())
 		return 1;
 
 	out = fopen(".tmpconfig", "w");

commit 75889e9be78febab9991f9c07fdf09d128562bf5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 18:15:48 2018 +0900

    kconfig: remove unneeded setsym label in conf_read_simple()
    
    The two 'goto setsym' statements are reachable only when sym == NULL.
    
    The code below the 'setsym:' label does nothing when sym == NULL
    since there is just one if-block guarded by 'if (sym && ...)'.
    
    Hence, 'goto setsym' can be replaced with 'continue'.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 91d0a5c014ac..1e35529d4eeb 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -363,7 +363,7 @@ int conf_read_simple(const char *name, int def)
 				sym = sym_find(line + 2 + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
-					goto setsym;
+					continue;
 				}
 			} else {
 				sym = sym_lookup(line + 2 + strlen(CONFIG_), 0);
@@ -397,7 +397,7 @@ int conf_read_simple(const char *name, int def)
 				sym = sym_find(line + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
-					goto setsym;
+					continue;
 				}
 			} else {
 				sym = sym_lookup(line + strlen(CONFIG_), 0);
@@ -416,7 +416,7 @@ int conf_read_simple(const char *name, int def)
 
 			continue;
 		}
-setsym:
+
 		if (sym && sym_is_choice_value(sym)) {
 			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
 			switch (sym->def[def].tri) {

commit 00c864f8903dd357471e8ee48f4d57aaa9a1a0de
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 20 16:46:31 2018 +0900

    kconfig: allow all config targets to write auto.conf if missing
    
    Currently, only syncconfig creates or updates include/config/auto.conf
    and some other files.  Other config targets create or update only the
    .config file.
    
    When you configure and build the kernel from a pristine source tree,
    any config target is followed by syncconfig in the build stage since
    include/config/auto.conf is missing.
    
    We are moving compiler tests from Makefile to Kconfig.  It means that
    parsing Kconfig files will be more costly since Kconfig invokes the
    compiler commands internally.  Thus, we want to avoid invoking Kconfig
    twice (one for *config to create the .config, and one for syncconfig
    to synchronize the auto.conf).  If auto.conf does not exist, we can
    generate all configuration files in the first configuration stage,
    which will save the syncconfig in the build stage.
    
    Please note this should be done only when auto.conf is missing.  If
    *config blindly did this, time stamp files under include/config/ would
    be unnecessarily touched, triggering unneeded rebuild of objects.
    
    I assume a scenario like this:
    
     1. You have a source tree that has already been built
        with CONFIG_FOO disabled
    
     2. Run "make menuconfig" to enable CONFIG_FOO
    
     3. CONFIG_FOO turns out to be unnecessary.
        Run "make menuconfig" again to disable CONFIG_FOO
    
     4. Run "make"
    
    In this case, include/config/foo.h should not be touched since there
    is no change in CONFIG_FOO.  The sync process should be delayed until
    the user really attempts to build the kernel.
    
    This commit has another motivation; I want to suppress the 'No such
    file or directory' warning from the 'include' directive.
    
    The top-level Makefile includes auto.conf with '-include' directive,
    like this:
    
      ifeq ($(dot-config),1)
      -include include/config/auto.conf
      endif
    
    This looks strange because auto.conf is mandatory when dot-config is 1.
    I guess only the reason of using '-include' is to suppress the warning
    'include/config/auto.conf: No such file or directory' when building
    from a clean tree.  However, this has a side-effect; Make considers
    the files included by '-include' are optional.  Hence, Make continues
    to build even if it fails to generate include/config/auto.conf.  I will
    change this in the next commit, but the warning message is annoying.
    (At least, kbuild test robot reports it as a regression.)
    
    With this commit, Kconfig will generate all configuration files together
    with the .config and I guess it is a solution good enough to suppress
    the warning.
    
    Note:
    GNU Make 4.2 or later does not display the warning from the 'include'
    directive if include files are successfully generated.  See GNU Make
    commit 87a5f98d248f ("[SV 102] Don't show unnecessary include file
    errors.")  However, older GNU Make versions are still widely used.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index fad403dfa508..91d0a5c014ac 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1013,13 +1013,17 @@ static int conf_split_config(void)
 	return res;
 }
 
-int conf_write_autoconf(void)
+int conf_write_autoconf(int overwrite)
 {
 	struct symbol *sym;
 	const char *name;
+	const char *autoconf_name = conf_get_autoconfig_name();
 	FILE *out, *tristate, *out_h;
 	int i;
 
+	if (!overwrite && is_present(autoconf_name))
+		return 0;
+
 	sym_clear_all_valid();
 
 	conf_write_dep("include/config/auto.conf.cmd");
@@ -1082,14 +1086,13 @@ int conf_write_autoconf(void)
 	if (rename(".tmpconfig_tristate", name))
 		return 1;
 
-	name = conf_get_autoconfig_name();
-	if (make_parent_dir(name))
+	if (make_parent_dir(autoconf_name))
 		return 1;
 	/*
 	 * This must be the last step, kbuild has a dependency on auto.conf
 	 * and this marks the successful completion of the previous steps.
 	 */
-	if (rename(".tmpconfig", name))
+	if (rename(".tmpconfig", autoconf_name))
 		return 1;
 
 	return 0;

commit 79123b1389cc775d8e60cb026256f79f0daef173
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 20 16:46:29 2018 +0900

    kconfig: create directories needed for syncconfig by itself
    
    'make syncconfig' creates some files such as include/config/auto.conf,
    include/generate/autoconf.h, etc. but the necessary directory creation
    relies on scripts/kconfig/Makefile.
    
    To make Kconfig self-contained, create directories as needed in
    conf_write_autoconf().
    
    This change allows scripts/kconfig/Makefile cleanups; syncconfig can
    be merged into simple-targets.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 88429d723c9c..fad403dfa508 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -899,6 +899,9 @@ static int conf_write_dep(const char *name)
 
 	fprintf(out, "\n$(deps_config): ;\n");
 	fclose(out);
+
+	if (make_parent_dir(name))
+		return 1;
 	rename("..config.tmp", name);
 	return 0;
 }
@@ -915,6 +918,8 @@ static int conf_split_config(void)
 	conf_read_simple(name, S_DEF_AUTO);
 	sym_calc_value(modules_sym);
 
+	if (make_parent_dir("include/config/foo.h"))
+		return 1;
 	if (chdir("include/config"))
 		return 1;
 
@@ -991,6 +996,7 @@ static int conf_split_config(void)
 				res = 1;
 				goto out;
 			}
+
 			/* Try it again. */
 			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
 			if (fd == -1) {
@@ -1063,14 +1069,22 @@ int conf_write_autoconf(void)
 	name = getenv("KCONFIG_AUTOHEADER");
 	if (!name)
 		name = "include/generated/autoconf.h";
+	if (make_parent_dir(name))
+		return 1;
 	if (rename(".tmpconfig.h", name))
 		return 1;
+
 	name = getenv("KCONFIG_TRISTATE");
 	if (!name)
 		name = "include/config/tristate.conf";
+	if (make_parent_dir(name))
+		return 1;
 	if (rename(".tmpconfig_tristate", name))
 		return 1;
+
 	name = conf_get_autoconfig_name();
+	if (make_parent_dir(name))
+		return 1;
 	/*
 	 * This must be the last step, kbuild has a dependency on auto.conf
 	 * and this marks the successful completion of the previous steps.

commit 0608182ad54293f6f617c1cc9fb34467db5515c7
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 20 16:46:27 2018 +0900

    kconfig: split out useful helpers in confdata.c
    
    Split out helpers:
     is_present() - check if the given path exists
     is_dir() - check if the given path exists and it is a directory
     make_parent_dir() - create the parent directories of the given path
    
    These helpers will be reused in later commits.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c553f1f30c36..88429d723c9c 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -16,6 +16,64 @@
 
 #include "lkc.h"
 
+/* return true if 'path' exists, false otherwise */
+static bool is_present(const char *path)
+{
+	struct stat st;
+
+	return !stat(path, &st);
+}
+
+/* return true if 'path' exists and it is a directory, false otherwise */
+static bool is_dir(const char *path)
+{
+	struct stat st;
+
+	if (stat(path, &st))
+		return 0;
+
+	return S_ISDIR(st.st_mode);
+}
+
+/*
+ * Create the parent directory of the given path.
+ *
+ * For example, if 'include/config/auto.conf' is given, create 'include/config'.
+ */
+static int make_parent_dir(const char *path)
+{
+	char tmp[PATH_MAX + 1];
+	char *p;
+
+	strncpy(tmp, path, sizeof(tmp));
+	tmp[sizeof(tmp) - 1] = 0;
+
+	/* Remove the base name. Just return if nothing is left */
+	p = strrchr(tmp, '/');
+	if (!p)
+		return 0;
+	*(p + 1) = 0;
+
+	/* Just in case it is an absolute path */
+	p = tmp;
+	while (*p == '/')
+		p++;
+
+	while ((p = strchr(p, '/'))) {
+		*p = 0;
+
+		/* skip if the directory exists */
+		if (!is_dir(tmp) && mkdir(tmp, 0755))
+			return -1;
+
+		*p = '/';
+		while (*p == '/')
+			p++;
+	}
+
+	return 0;
+}
+
 struct conf_printer {
 	void (*print_symbol)(FILE *, struct symbol *, const char *, void *);
 	void (*print_comment)(FILE *, const char *, void *);
@@ -88,7 +146,6 @@ const char *conf_get_autoconfig_name(void)
 
 char *conf_get_default_confname(void)
 {
-	struct stat buf;
 	static char fullname[PATH_MAX+1];
 	char *env, *name;
 
@@ -96,7 +153,7 @@ char *conf_get_default_confname(void)
 	env = getenv(SRCTREE);
 	if (env) {
 		sprintf(fullname, "%s/%s", env, name);
-		if (!stat(fullname, &buf))
+		if (is_present(fullname))
 			return fullname;
 	}
 	return name;
@@ -730,10 +787,9 @@ int conf_write(const char *name)
 
 	dirname[0] = 0;
 	if (name && name[0]) {
-		struct stat st;
 		char *slash;
 
-		if (!stat(name, &st) && S_ISDIR(st.st_mode)) {
+		if (is_dir(name)) {
 			strcpy(dirname, name);
 			strcat(dirname, "/");
 			basename = conf_get_configname();
@@ -853,7 +909,6 @@ static int conf_split_config(void)
 	char path[PATH_MAX+1];
 	char *s, *d, c;
 	struct symbol *sym;
-	struct stat sb;
 	int res, i, fd;
 
 	name = conf_get_autoconfig_name();
@@ -931,18 +986,10 @@ static int conf_split_config(void)
 				res = 1;
 				break;
 			}
-			/*
-			 * Create directory components,
-			 * unless they exist already.
-			 */
-			d = path;
-			while ((d = strchr(d, '/'))) {
-				*d = 0;
-				if (stat(path, &sb) && mkdir(path, 0755)) {
-					res = 1;
-					goto out;
-				}
-				*d++ = '/';
+
+			if (make_parent_dir(path)) {
+				res = 1;
+				goto out;
 			}
 			/* Try it again. */
 			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);

commit a2ff4040151ace5be20e4de34220468b9e842e4d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 20 16:46:26 2018 +0900

    kconfig: rename file_write_dep and move it to confdata.c
    
    file_write_dep() is called only from conf_write_autoconf().
    Move it from util.c to confdata.c to make it static.
    Also, rename it to conf_write_dep() since it should belong to
    the group of conf_write* functions.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 629ad32d4708..c553f1f30c36 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -818,6 +818,35 @@ int conf_write(const char *name)
 	return 0;
 }
 
+/* write a dependency file as used by kbuild to track dependencies */
+static int conf_write_dep(const char *name)
+{
+	struct file *file;
+	FILE *out;
+
+	if (!name)
+		name = ".kconfig.d";
+	out = fopen("..config.tmp", "w");
+	if (!out)
+		return 1;
+	fprintf(out, "deps_config := \\\n");
+	for (file = file_list; file; file = file->next) {
+		if (file->next)
+			fprintf(out, "\t%s \\\n", file->name);
+		else
+			fprintf(out, "\t%s\n", file->name);
+	}
+	fprintf(out, "\n%s: \\\n"
+		     "\t$(deps_config)\n\n", conf_get_autoconfig_name());
+
+	env_write_dep(out, conf_get_autoconfig_name());
+
+	fprintf(out, "\n$(deps_config): ;\n");
+	fclose(out);
+	rename("..config.tmp", name);
+	return 0;
+}
+
 static int conf_split_config(void)
 {
 	const char *name;
@@ -940,7 +969,7 @@ int conf_write_autoconf(void)
 
 	sym_clear_all_valid();
 
-	file_write_dep("include/config/auto.conf.cmd");
+	conf_write_dep("include/config/auto.conf.cmd");
 
 	if (conf_split_config())
 		return 1;

commit 5accd7f3360e891bd552312515387dbaa2bb4bf3
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jul 5 11:46:12 2018 +0900

    kconfig: handle format string before calling conf_message_callback()
    
    As you see in mconf.c and nconf.c, conf_message_callback() hooks are
    likely to end up with the boilerplate of vsnprintf().  Process the
    string format before calling conf_message_callback() so that it
    receives a simple string.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Dirk Gouders <dirk@gouders.net>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index d1216e4ade2f..629ad32d4708 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -43,16 +43,16 @@ static void conf_warning(const char *fmt, ...)
 	conf_warnings++;
 }
 
-static void conf_default_message_callback(const char *fmt, va_list ap)
+static void conf_default_message_callback(const char *s)
 {
 	printf("#\n# ");
-	vprintf(fmt, ap);
+	printf("%s", s);
 	printf("\n#\n");
 }
 
-static void (*conf_message_callback) (const char *fmt, va_list ap) =
+static void (*conf_message_callback)(const char *s) =
 	conf_default_message_callback;
-void conf_set_message_callback(void (*fn) (const char *fmt, va_list ap))
+void conf_set_message_callback(void (*fn)(const char *s))
 {
 	conf_message_callback = fn;
 }
@@ -60,10 +60,15 @@ void conf_set_message_callback(void (*fn) (const char *fmt, va_list ap))
 static void conf_message(const char *fmt, ...)
 {
 	va_list ap;
+	char buf[4096];
+
+	if (!conf_message_callback)
+		return;
 
 	va_start(ap, fmt);
-	if (conf_message_callback)
-		conf_message_callback(fmt, ap);
+
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	conf_message_callback(buf);
 	va_end(ap);
 }
 

commit 693359f7ac9012778590a370d076b13db704255e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Tue Jul 3 14:43:31 2018 +0200

    kconfig: rename SYMBOL_AUTO to SYMBOL_NO_WRITE
    
    Over time, the use of the flag SYMBOL_AUTO changed from initially
    marking three automatically generated symbols ARCH, KERNELRELEASE and
    UNAME_RELEASE to today's effect of protecting symbols from being
    written out.
    
    Currently, only symbols of type CHOICE and those with option
    defconf_list set have that flag set.
    
    Reflect that change in semantics in the flag's name.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 39e20974f4a3..d1216e4ade2f 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -397,7 +397,7 @@ int conf_read(const char *name)
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
-		if (sym_is_choice(sym) || (sym->flags & SYMBOL_AUTO))
+		if (sym_is_choice(sym) || (sym->flags & SYMBOL_NO_WRITE))
 			continue;
 		if (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {
 			/* check that calculated value agrees with saved value */
@@ -832,7 +832,7 @@ static int conf_split_config(void)
 	res = 0;
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
-		if ((sym->flags & SYMBOL_AUTO) || !sym->name)
+		if ((sym->flags & SYMBOL_NO_WRITE) || !sym->name)
 			continue;
 		if (sym->flags & SYMBOL_WRITE) {
 			if (sym->flags & SYMBOL_DEF_AUTO) {

commit 2ae89c7a82ea9d81a19b4fc2df23bef4b112f24e
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Sat Jun 2 09:02:09 2018 -0700

    kconfig: Avoid format overflow warning from GCC 8.1
    
    In file included from scripts/kconfig/zconf.tab.c:2485:
    scripts/kconfig/confdata.c: In function ‘conf_write’:
    scripts/kconfig/confdata.c:773:22: warning: ‘%s’ directive writing likely 7 or more bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
      sprintf(newname, "%s%s", dirname, basename);
                          ^~
    scripts/kconfig/confdata.c:773:19: note: assuming directive output of 7 bytes
      sprintf(newname, "%s%s", dirname, basename);
                       ^~~~~~
    scripts/kconfig/confdata.c:773:2: note: ‘sprintf’ output 1 or more bytes (assuming 4104) into a destination of size 4097
      sprintf(newname, "%s%s", dirname, basename);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    scripts/kconfig/confdata.c:776:23: warning: ‘.tmpconfig.’ directive writing 11 bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
       sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
                           ^~~~~~~~~~~
    scripts/kconfig/confdata.c:776:3: note: ‘sprintf’ output between 13 and 4119 bytes into a destination of size 4097
       sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Increase the size of tmpname and newname to make GCC happy.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 5f87ad561b08..39e20974f4a3 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -720,7 +720,7 @@ int conf_write(const char *name)
 	struct menu *menu;
 	const char *basename;
 	const char *str;
-	char dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];
+	char dirname[PATH_MAX+1], tmpname[PATH_MAX+22], newname[PATH_MAX+8];
 	char *env;
 
 	dirname[0] = 0;

commit 104daea149c45cc84842ce77a9bd6436d19f3dd8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:40 2018 +0900

    kconfig: reference environment variables directly and remove 'option env='
    
    To get access to environment variables, Kconfig needs to define a
    symbol using "option env=" syntax.  It is tedious to add a symbol entry
    for each environment variable given that we need to define much more
    such as 'CC', 'AS', 'srctree' etc. to evaluate the compiler capability
    in Kconfig.
    
    Adding '$' for symbol references is grammatically inconsistent.
    Looking at the code, the symbols prefixed with 'S' are expanded by:
     - conf_expand_value()
       This is used to expand 'arch/$ARCH/defconfig' and 'defconfig_list'
     - sym_expand_string_value()
       This is used to expand strings in 'source' and 'mainmenu'
    
    All of them are fixed values independent of user configuration.  So,
    they can be changed into the direct expansion instead of symbols.
    
    This change makes the code much cleaner.  The bounce symbols 'SRCARCH',
    'ARCH', 'SUBARCH', 'KERNELVERSION' are gone.
    
    sym_init() hard-coding 'UNAME_RELEASE' is also gone.  'UNAME_RELEASE'
    should be replaced with an environment variable.
    
    ARCH_DEFCONFIG is a normal symbol, so it should be simply referenced
    without '$' prefix.
    
    The new syntax is addicted by Make.  The variable reference needs
    parentheses, like $(FOO), but you can omit them for single-letter
    variables, like $F.  Yet, in Makefiles, people tend to use the
    parenthetical form for consistency / clarification.
    
    At this moment, only the environment variable is supported, but I will
    extend the concept of 'variable' later on.
    
    The variables are expanded in the lexer so we can simplify the token
    handling on the parser side.
    
    For example, the following code works.
    
    [Example code]
    
      config MY_TOOLCHAIN_LIST
              string
              default "My tools: CC=$(CC), AS=$(AS), CPP=$(CPP)"
    
    [Result]
    
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_MY_TOOLCHAIN_LIST="My tools: CC=gcc, AS=as, CPP=gcc -E"
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 569217168e96..5f87ad561b08 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -30,7 +30,7 @@ static void conf_message(const char *fmt, ...)
 static const char *conf_filename;
 static int conf_lineno, conf_warnings;
 
-const char conf_defname[] = "arch/$ARCH/defconfig";
+const char conf_defname[] = "arch/$(ARCH)/defconfig";
 
 static void conf_warning(const char *fmt, ...)
 {
@@ -81,39 +81,13 @@ const char *conf_get_autoconfig_name(void)
 	return name ? name : "include/config/auto.conf";
 }
 
-static char *conf_expand_value(const char *in)
-{
-	struct symbol *sym;
-	const char *src;
-	static char res_value[SYMBOL_MAXLENGTH];
-	char *dst, name[SYMBOL_MAXLENGTH];
-
-	res_value[0] = 0;
-	dst = name;
-	while ((src = strchr(in, '$'))) {
-		strncat(res_value, in, src - in);
-		src++;
-		dst = name;
-		while (isalnum(*src) || *src == '_')
-			*dst++ = *src++;
-		*dst = 0;
-		sym = sym_lookup(name, 0);
-		sym_calc_value(sym);
-		strcat(res_value, sym_get_string_value(sym));
-		in = src;
-	}
-	strcat(res_value, in);
-
-	return res_value;
-}
-
 char *conf_get_default_confname(void)
 {
 	struct stat buf;
 	static char fullname[PATH_MAX+1];
 	char *env, *name;
 
-	name = conf_expand_value(conf_defname);
+	name = expand_string(conf_defname);
 	env = getenv(SRCTREE);
 	if (env) {
 		sprintf(fullname, "%s/%s", env, name);
@@ -274,7 +248,8 @@ int conf_read_simple(const char *name, int def)
 			if (expr_calc_value(prop->visible.expr) == no ||
 			    prop->expr->type != E_SYMBOL)
 				continue;
-			name = conf_expand_value(prop->expr->left.sym->name);
+			sym_calc_value(prop->expr->left.sym);
+			name = sym_get_string_value(prop->expr->left.sym);
 			in = zconf_fopen(name);
 			if (in) {
 				conf_message("using defaults found in %s",

commit 694c49a7c01cc87194be40cb26404b58b68c291c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue May 22 21:36:12 2018 +0200

    kconfig: drop localization support
    
    The localization support is broken and appears unused.
    There is no google hits on the update-po-config target.
    And there is no recent (5 years) activity related to the localization.
    
    So lets just drop this as it is no longer used.
    
    Suggested-by: Ulf Magnusson <ulfalizer@gmail.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index df26c7b0fe13..569217168e96 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -277,7 +277,7 @@ int conf_read_simple(const char *name, int def)
 			name = conf_expand_value(prop->expr->left.sym->name);
 			in = zconf_fopen(name);
 			if (in) {
-				conf_message(_("using defaults found in %s"),
+				conf_message("using defaults found in %s",
 					 name);
 				goto load;
 			}
@@ -831,7 +831,7 @@ int conf_write(const char *name)
 			return 1;
 	}
 
-	conf_message(_("configuration written to %s"), newname);
+	conf_message("configuration written to %s", newname);
 
 	sym_set_change_count(0);
 

commit cd81fc82b93fa408c30e08f59e5ef8caaa91d1d2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Feb 17 03:38:31 2018 +0900

    kconfig: add xstrdup() helper
    
    We already have xmalloc(), xcalloc(), and xrealloc(().  Add xstrdup()
    as well to save tedious error handling.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 5c12dc91ef34..df26c7b0fe13 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -178,7 +178,7 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 	case S_HEX:
 	done:
 		if (sym_string_valid(sym, p)) {
-			sym->def[def].val = strdup(p);
+			sym->def[def].val = xstrdup(p);
 			sym->flags |= def_flags;
 		} else {
 			if (def != S_DEF_AUTO)

commit d717f24d8c68081caae2374cf5ea6c4e62c490fc
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 9 01:19:07 2018 +0900

    kconfig: add xrealloc() helper
    
    We already have xmalloc(), xcalloc().  Add xrealloc() as well
    to save tedious error handling.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index f7927391de30..5c12dc91ef34 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -201,7 +201,7 @@ static int add_byte(int c, char **lineptr, size_t slen, size_t *n)
 	if (new_size > *n) {
 		new_size += LINE_GROWTH - 1;
 		new_size *= 2;
-		nline = realloc(*lineptr, new_size);
+		nline = xrealloc(*lineptr, new_size);
 		if (!nline)
 			return -1;
 

commit 84dd95d4f87a0dd2b635df936b1fc27d7424e097
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jan 11 22:39:41 2018 +0900

    kconfig: make conf_unsaved a local variable of conf_read()
    
    conf_unsaved is initialized by conf_read_simple(), but it is possible
    to move it to conf_read() so that it can be a local variable.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 027f5b4892cf..f7927391de30 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -28,7 +28,7 @@ static void conf_message(const char *fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
 static const char *conf_filename;
-static int conf_lineno, conf_warnings, conf_unsaved;
+static int conf_lineno, conf_warnings;
 
 const char conf_defname[] = "arch/$ARCH/defconfig";
 
@@ -290,7 +290,6 @@ int conf_read_simple(const char *name, int def)
 	conf_filename = name;
 	conf_lineno = 0;
 	conf_warnings = 0;
-	conf_unsaved = 0;
 
 	def_flags = SYMBOL_DEF << def;
 	for_all_symbols(i, sym) {
@@ -409,6 +408,7 @@ int conf_read_simple(const char *name, int def)
 int conf_read(const char *name)
 {
 	struct symbol *sym;
+	int conf_unsaved = 0;
 	int i;
 
 	sym_set_change_count(0);

commit b92d804a51796b77c7b2b11881b2700eaac88114
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Dec 16 00:38:02 2017 +0900

    kconfig: drop 'boolean' keyword
    
    No more users of this keyword.  Drop it according to the notice by
    commit 6341e62b212a ("kconfig: use bool instead of boolean for type
    definition attributes").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 297b079ae4d9..027f5b4892cf 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1123,7 +1123,7 @@ void set_all_choice_values(struct symbol *csym)
 bool conf_set_all_new_symbols(enum conf_def_mode mode)
 {
 	struct symbol *sym, *csym;
-	int i, cnt, pby, pty, ptm;	/* pby: probability of boolean  = y
+	int i, cnt, pby, pty, ptm;	/* pby: probability of bool     = y
 					 * pty: probability of tristate = y
 					 * ptm: probability of tristate = m
 					 */

commit a4663911392efdc504ce97b192d46f2677a6fe35
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Mar 16 21:27:27 2016 +0100

    kconfig: add unexpected data itself to warning
    
    If the .config parser runs into unexpected data it emits warnings like:
        .config:6911:warning: unexpected data
    
    Add the unexpected data itself to this warning. That makes it easier to
    discover what is actually going wrong:
         .config:6911:warning: unexpected data: CONFOG_CHARGER_TPS65217=m
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index dd243d2abd87..297b079ae4d9 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -375,7 +375,9 @@ int conf_read_simple(const char *name, int def)
 				continue;
 		} else {
 			if (line[0] != '\r' && line[0] != '\n')
-				conf_warning("unexpected data");
+				conf_warning("unexpected data: %.*s",
+					     (int)strcspn(line, "\r\n"), line);
+
 			continue;
 		}
 setsym:

commit 6b87b70c5339f30e3c5b32085e69625906513dc2
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Thu Jan 14 18:13:49 2016 +0000

    unbreak allmodconfig KCONFIG_ALLCONFIG=...
    
            Prior to 3.13 make allmodconfig KCONFIG_ALLCONFIG=/dev/null used
    to be equivalent to make allmodconfig; these days it hardwires MODULES to n.
    In fact, any KCONFIG_ALLCONFIG that doesn't set MODULES explicitly is
    treated as if it set it to n.
    
            Regression had been introduced by commit cfa98f ("kconfig: do not
    override symbols already set"); what happens is that conf_read_simple()
    does sym_calc_value(modules_sym) on exit, which leaves SYMBOL_VALID set and
    has conf_set_all_new_symbols() skip modules_sym.
    
            It's pretty easy to fix - simply move that call of sym_calc_value()
    into the callers, except for the ones in KCONFIG_ALLCONFIG handling.
    Objections?
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Fixes: cfa98f2e0ae9 ("kconfig: do not override symbols already set")
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 0b7dc2fd7bac..dd243d2abd87 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -267,10 +267,8 @@ int conf_read_simple(const char *name, int def)
 		if (in)
 			goto load;
 		sym_add_change_count(1);
-		if (!sym_defconfig_list) {
-			sym_calc_value(modules_sym);
+		if (!sym_defconfig_list)
 			return 1;
-		}
 
 		for_all_defaults(sym_defconfig_list, prop) {
 			if (expr_calc_value(prop->visible.expr) == no ||
@@ -403,7 +401,6 @@ int conf_read_simple(const char *name, int def)
 	}
 	free(line);
 	fclose(in);
-	sym_calc_value(modules_sym);
 	return 0;
 }
 
@@ -414,8 +411,12 @@ int conf_read(const char *name)
 
 	sym_set_change_count(0);
 
-	if (conf_read_simple(name, S_DEF_USER))
+	if (conf_read_simple(name, S_DEF_USER)) {
+		sym_calc_value(modules_sym);
 		return 1;
+	}
+
+	sym_calc_value(modules_sym);
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
@@ -846,6 +847,7 @@ static int conf_split_config(void)
 
 	name = conf_get_autoconfig_name();
 	conf_read_simple(name, S_DEF_AUTO);
+	sym_calc_value(modules_sym);
 
 	if (chdir("include/config"))
 		return 1;

commit 35ffd08d9bc92b5d56f6536406c379d82a757e7a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Jul 7 21:48:23 2015 +0200

    kconfig: Delete unnecessary checks before the function call "sym_calc_value"
    
    The sym_calc_value() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c814f57672fc..0b7dc2fd7bac 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -268,8 +268,7 @@ int conf_read_simple(const char *name, int def)
 			goto load;
 		sym_add_change_count(1);
 		if (!sym_defconfig_list) {
-			if (modules_sym)
-				sym_calc_value(modules_sym);
+			sym_calc_value(modules_sym);
 			return 1;
 		}
 
@@ -404,9 +403,7 @@ int conf_read_simple(const char *name, int def)
 	}
 	free(line);
 	fclose(in);
-
-	if (modules_sym)
-		sym_calc_value(modules_sym);
+	sym_calc_value(modules_sym);
 	return 0;
 }
 

commit ad8d40cda3ad22ad9e8863d55a5c88f85c0173f0
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Feb 24 16:37:13 2015 +0100

    kconfig: Remove unnecessary prototypes from headers
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 28df18dd1147..c814f57672fc 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -16,6 +16,11 @@
 
 #include "lkc.h"
 
+struct conf_printer {
+	void (*print_symbol)(FILE *, struct symbol *, const char *, void *);
+	void (*print_comment)(FILE *, const char *, void *);
+};
+
 static void conf_warning(const char *fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 

commit b6a2ab2cd4739a9573ed41677e53171987b8da34
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jan 12 13:18:26 2015 +0000

    kconfig: use va_end to match corresponding va_start
    
    Although on some systems va_end is a no-op, it is good practice
    to use va_end, especially since the manual states:
    
    "Each invocation of va_start() must be matched by a corresponding
    invocation of va_end() in the same function."
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index f88d90f20228..28df18dd1147 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -59,6 +59,7 @@ static void conf_message(const char *fmt, ...)
 	va_start(ap, fmt);
 	if (conf_message_callback)
 		conf_message_callback(fmt, ap);
+	va_end(ap);
 }
 
 const char *conf_get_configname(void)

commit 5d2acfc7b974bbd3858b4dd3f2cdc6362dd8843a
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Mon Apr 7 15:39:09 2014 -0700

    kconfig: make allnoconfig disable options behind EMBEDDED and EXPERT
    
    "make allnoconfig" exists to ease testing of minimal configurations.
    Documentation/SubmitChecklist includes a note to test with allnoconfig.
    This helps catch missing dependencies on common-but-not-required
    functionality, which might otherwise go unnoticed.
    
    However, allnoconfig still leaves many symbols enabled, because they're
    hidden behind CONFIG_EMBEDDED or CONFIG_EXPERT.  For instance, allnoconfig
    still has CONFIG_PRINTK and CONFIG_BLOCK enabled, so drivers don't
    typically get build-tested with those disabled.
    
    To address this, introduce a new Kconfig option "allnoconfig_y", used on
    symbols which only exist to hide other symbols.  Set it on CONFIG_EMBEDDED
    (which then selects CONFIG_EXPERT).  allnoconfig will then disable all the
    symbols hidden behind those.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Tested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 87f723804079..f88d90f20228 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1178,7 +1178,10 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 				sym->def[S_DEF_USER].tri = mod;
 				break;
 			case def_no:
-				sym->def[S_DEF_USER].tri = no;
+				if (sym->flags & SYMBOL_ALLNOCONFIG_Y)
+					sym->def[S_DEF_USER].tri = yes;
+				else
+					sym->def[S_DEF_USER].tri = no;
 				break;
 			case def_random:
 				sym->def[S_DEF_USER].tri = no;

commit 04b19b773a60d201bc1b187ba7a7c86dc237a27b
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Aug 6 18:45:07 2013 +0200

    kconfig: silence warning when parsing auto.conf when a symbol has changed type
    
    When a symbol changes type from tristate to bool, and was previously set to
    'm', a subsequent silentoldconfig would warn about inconsistency, such as:
    
        include/config/auto.conf:3014:warning: symbol value 'm' invalid for
        HOTPLUG_PCI_PCIE
    
    Seen by Linus with the merge in aa8032b (sequence to reproduce by Michal):
        git checkout 1fe0135
        make mrproper
        make allmodconfig
        make silentoldconfig
        git checkout aa8032b
        make allmodconfig
        make silentoldconfig
    
    Since HOTPLUG_PCI_PCIE changed from tristate to bool in aa8032b, it was
    previously set to 'm' in auto.conf by the first allmodconfig+silentoldconfig,
    but then was set to 'y' by the second allmodconfig. Then the second
    silentoldconfig prints the warning.
    
    The warning in this case is a spurious warning, which happens at the time
    kconfig tries to detect symbols that have changed, to touch the empty
    header files in include/config used for dependency-tracking by make.
    
    Silence the warning when we read the old auto.conf file, since it is
    perfectly legit that a symbol changed type since the previous call.
    
    Thread in:
        http://marc.info/?l=linux-pci&m=137569198904000&w=2
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c55c227af463..87f723804079 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -140,7 +140,9 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			sym->flags |= def_flags;
 			break;
 		}
-		conf_warning("symbol value '%s' invalid for %s", p, sym->name);
+		if (def != S_DEF_AUTO)
+			conf_warning("symbol value '%s' invalid for %s",
+				     p, sym->name);
 		return 1;
 	case S_OTHER:
 		if (*p != '"') {
@@ -161,7 +163,8 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			memmove(p2, p2 + 1, strlen(p2));
 		}
 		if (!p2) {
-			conf_warning("invalid string found");
+			if (def != S_DEF_AUTO)
+				conf_warning("invalid string found");
 			return 1;
 		}
 		/* fall through */
@@ -172,7 +175,9 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			sym->def[def].val = strdup(p);
 			sym->flags |= def_flags;
 		} else {
-			conf_warning("symbol value '%s' invalid for %s", p, sym->name);
+			if (def != S_DEF_AUTO)
+				conf_warning("symbol value '%s' invalid for %s",
+					     p, sym->name);
 			return 1;
 		}
 		break;

commit 490f16171119a16e05d670306c105f3b45c38837
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Jun 25 23:37:44 2013 +0200

    Revert "kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG"
    
    This reverts commit 8357b48549e17b3e4e402c7f977b65708922e60f.
    
    It breaks more stuff than it fixes.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Bounine <alexandre.bounine@idt.com>
    Cc: Matt Porter <mporter@kernel.crashing.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 3e39208ad20e..c55c227af463 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -288,6 +288,8 @@ int conf_read_simple(const char *name, int def)
 	for_all_symbols(i, sym) {
 		sym->flags |= SYMBOL_CHANGED;
 		sym->flags &= ~(def_flags|SYMBOL_VALID);
+		if (sym_is_choice(sym))
+			sym->flags |= def_flags;
 		switch (sym->type) {
 		case S_INT:
 		case S_HEX:
@@ -377,13 +379,13 @@ int conf_read_simple(const char *name, int def)
 			case mod:
 				if (cs->def[def].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
+					cs->flags &= ~def_flags;
 				}
 				break;
 			case yes:
 				if (cs->def[def].tri != no)
 					conf_warning("override: %s changes choice state", sym->name);
 				cs->def[def].val = sym;
-				cs->flags |= def_flags;
 				break;
 			}
 			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
@@ -789,8 +791,6 @@ int conf_write(const char *name)
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
-			if (sym_is_choice_value(sym) && !menu_is_visible(menu->parent))
-				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
 
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);

commit 8357b48549e17b3e4e402c7f977b65708922e60f
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Jun 18 19:35:29 2013 +0200

    kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG
    
    Currently, randconfig does randomise choice entries, unless KCONFIG_ALLCONFIG
    is specified.
    
    For example, given those two files (Thomas' test-case):
    
        ---8<--- Config.test.in
        config OPTIONA
            bool "Option A"
    
        choice
            prompt "This is a choice"
    
        config CHOICE_OPTIONA
            bool "Choice Option A"
    
        config CHOICE_OPTIONB
            bool "Choice Option B"
    
        endchoice
    
        config OPTIONB
            bool "Option B"
        ---8<--- Config.test.in
    
        ---8<--- config.defaults
        CONFIG_OPTIONA=y
        ---8<--- config.defaults
    
    And running:
        ./scripts/kconfig/conf --randconfig Config.test.in
    
    does properly randomise the two choice symbols (and the two booleans).
    
    However, running:
        KCONFIG_ALLCONFIG=config.defaults \
        ./scripts/kconfig/conf --randconfig Config.test.in
    
    does *not* reandomise the two choice entries, and only CHOICE_OPTIONA
    will ever be selected. (OPTIONA will always be set (expected), and
    OPTIONB will be be properly randomised (expected).)
    
    This patch defers setting that a choice has a value until a symbol for
    that choice is indeed set, so that choices are properly randomised when
    KCONFIG_ALLCONFIG is set, but not if a symbol for that choice is set.
    
    Reported-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    
    ---
    Changes v3 -> v4
      - fix previous issue where some choices would not be set, which would
        cause silentoldconfig to ask for them and was then breaking this
        workflow (as reported by Arnd and Sedat):
            KCONFIG_ALLCONFIG=foo.defconfig make randconfig
            make silentoldconfig </dev/nullo
        which I have tested (3h28min!) with:
            touch defconfig
            for(( i=0; i<10000; i++ )); do
                KCONFIG_ALLCONFIG=$(pwd)/defconfig make randconfig >/dev/null 2>&1
                make silentoldconfig </dev/null >/dev/null 2>&1 || break
            done
        which did not break at all.
      - change done in v3 (below) is already fixed by a previous patch
    
    Changes v2 -> v3
      - ensure only one symbol is set in a choice
    
    Changes v1 -> v2:
      - further postpone setting that a choice has a value until
        one is indeed set
      - do not print symbols that are part of an invisible choice

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c55c227af463..3e39208ad20e 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -288,8 +288,6 @@ int conf_read_simple(const char *name, int def)
 	for_all_symbols(i, sym) {
 		sym->flags |= SYMBOL_CHANGED;
 		sym->flags &= ~(def_flags|SYMBOL_VALID);
-		if (sym_is_choice(sym))
-			sym->flags |= def_flags;
 		switch (sym->type) {
 		case S_INT:
 		case S_HEX:
@@ -379,13 +377,13 @@ int conf_read_simple(const char *name, int def)
 			case mod:
 				if (cs->def[def].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
-					cs->flags &= ~def_flags;
 				}
 				break;
 			case yes:
 				if (cs->def[def].tri != no)
 					conf_warning("override: %s changes choice state", sym->name);
 				cs->def[def].val = sym;
+				cs->flags |= def_flags;
 				break;
 			}
 			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
@@ -791,6 +789,8 @@ int conf_write(const char *name)
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
+			if (sym_is_choice_value(sym) && !menu_is_visible(menu->parent))
+				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
 
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);

commit 3b9a19e08960e5cdad5253998637653e592a3c29
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Sun Apr 28 22:36:38 2013 +0200

    kconfig: loop as long as we changed some symbols in randconfig
    
    Because of choice-in-a-choice constructs, it can happen that not all
    symbols are assigned a value during randconfig, leading in rare cases
    to this situation:
    
        ---8<--- choice-in-choice.in
        choice
            bool "A/B/C"
        config A
            bool "A"
    
        config B
            bool "B"
        if B
        choice
            bool "E/F"
        config E
            bool "E"
        config F
            bool "F"
        endchoice
        endif # B
    
        config C
            bool "C"
        endchoice
        ---8<---
    
        $ ./scripts/kconfig/conf --randconfig choice-in-choice.in
        [--SNIP--]
        $ ./scripts/kconfig/conf --silentoldconfig choice-in-choice.in </dev/null
        [--SNIP--]
        A/B/C
          1. A (A)
        > 2. B (B)
          3. C (C)
        choice[1-3]: 2
          E/F
          > 1. E (E) (NEW)
            2. F (F) (NEW)
          choice[1-2]: aborted!
    
        Console input/output is redirected. Run 'make oldconfig' to update
        configuration.
    
    Fix this by looping in randconfig for as long as some symbol gets assigned
    a value.
    
    Note: this was spotted with the USB EHCI Debug Device Gadget (USB_G_DBGP),
    which uses this choice-in-a-choice construct, and exhibits this problem.
    The example above is just a stripped-down minimalist test-case.
    
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index d36bc1f1d563..c55c227af463 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1040,7 +1040,7 @@ void conf_set_changed_callback(void (*fn)(void))
 	conf_changed_callback = fn;
 }
 
-static void randomize_choice_values(struct symbol *csym)
+static bool randomize_choice_values(struct symbol *csym)
 {
 	struct property *prop;
 	struct symbol *sym;
@@ -1053,7 +1053,7 @@ static void randomize_choice_values(struct symbol *csym)
 	 * In both cases stop.
 	 */
 	if (csym->curr.tri != yes)
-		return;
+		return false;
 
 	prop = sym_get_choice_prop(csym);
 
@@ -1084,6 +1084,8 @@ static void randomize_choice_values(struct symbol *csym)
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */
 	csym->flags &= ~(SYMBOL_VALID);
+
+	return true;
 }
 
 void set_all_choice_values(struct symbol *csym)
@@ -1106,7 +1108,7 @@ void set_all_choice_values(struct symbol *csym)
 	csym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);
 }
 
-void conf_set_all_new_symbols(enum conf_def_mode mode)
+bool conf_set_all_new_symbols(enum conf_def_mode mode)
 {
 	struct symbol *sym, *csym;
 	int i, cnt, pby, pty, ptm;	/* pby: probability of boolean  = y
@@ -1154,6 +1156,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 			exit( 1 );
 		}
 	}
+	bool has_changed = false;
 
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
@@ -1161,6 +1164,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 		switch (sym_get_type(sym)) {
 		case S_BOOLEAN:
 		case S_TRISTATE:
+			has_changed = true;
 			switch (mode) {
 			case def_yes:
 				sym->def[S_DEF_USER].tri = yes;
@@ -1219,6 +1223,12 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 
 		sym_calc_value(csym);
 		if (mode == def_random)
-			randomize_choice_values(csym);
+			has_changed = randomize_choice_values(csym);
+		else {
+			set_all_choice_values(csym);
+			has_changed = true;
+		}
 	}
+
+	return has_changed;
 }

commit e6abf12a77bc56dceeb4cba557b726268e71350e
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Sun Apr 28 17:33:15 2013 +0200

    kconfig/conf: fix randconfig setting multiple symbols in a choice
    
    Currently, randconfig may set more than one symbol in a given choice.
    Given this config file:
        config A
            bool "A"
        if A
        choice
            bool "B/C/D"
        config B
            bool "B"
        config C
            bool "C"
        config D
            bool "D"
        endchoice
        endif # A
    
    Then randconfig generates such .config files (case where A is not set is not
    shown below for brevity), and where only the right-most .config is valid:
      CONFIG_A=y                  CONFIG_A=y                  CONFIG_A=y
      CONFIG_B=y                  CONFIG_B=y                  CONFIG_B=y
      CONFIG_C=y                  # CONFIG_C is not set       # CONFIG_C is not set
      # CONFIG_D is not set       CONFIG_D=y                  # CONFIG_D is not set
    
    That is, in a randomised choice, the first symbol is always selected,
    and at most one other symbol may be selected.
    
    This is due to symbol randomised in a choice not being properly flagged
    as having a value.
    
    Fix that by flagging those symbols adequately: have a user-defined value,
    and be not valid (to force recalculation of the symbol).
    
    Note: if the choice is not conditional, then the randomisation is properly
    done.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Signed-off-by: Matthieu CASTET <matthieu.castet@parrot.com>
    [yann.morin.1998@free.fr: independently re-done the same patch as Matthieu,
                              as pointed out by Sedat]
    Cc: Arnaud Lacombe <lacombar@gmail.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 35e0f164ef81..d36bc1f1d563 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1077,6 +1077,9 @@ static void randomize_choice_values(struct symbol *csym)
 		else {
 			sym->def[S_DEF_USER].tri = no;
 		}
+		sym->flags |= SYMBOL_DEF_USER;
+		/* clear VALID to get value calculated */
+		sym->flags &= ~SYMBOL_VALID;
 	}
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */

commit fbe98bb9ed3dae23e320c6b113e35f129538d14a
Author: Arve Hjønnevåg <arve@android.com>
Date:   Thu Jun 6 20:37:00 2013 -0700

    kconfig: Fix defconfig when one choice menu selects options that another choice menu depends on
    
    The defconfig and Kconfig combination below, which is based on 3.10-rc4
    Kconfigs, resulted in several options getting set to "m" instead of "y".
    
    defconfig.choice:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_USB_ZERO=y
    ---8<---
    
    Kconfig.choice:
    ---8<---
    menuconfig MODULES
            bool "Enable loadable module support"
    
    config CONFIGFS_FS
            tristate "Userspace-driven configuration filesystem"
    
    config OCFS2_FS
            tristate "OCFS2 file system support"
            depends on CONFIGFS_FS
            select CRC32
    
    config USB_LIBCOMPOSITE
            tristate
            select CONFIGFS_FS
    
    choice
            tristate "USB Gadget Drivers"
            default USB_ETH
    
    config USB_ZERO
            tristate "Gadget Zero (DEVELOPMENT)"
            select USB_LIBCOMPOSITE
    
    config USB_ETH
            tristate "Ethernet Gadget (with CDC Ethernet support)"
            select USB_LIBCOMPOSITE
    
    endchoice
    
    config CRC32
            tristate "CRC32/CRC32c functions"
            default y
    
    choice
            prompt "CRC32 implementation"
            depends on CRC32
            default CRC32_SLICEBY8
    
    config CRC32_SLICEBY8
            bool "Slice by 8 bytes"
    
    endchoice
    ---8<---
    
    $ scripts/kconfig/conf --defconfig=defconfig.choice Kconfig.choice
    
    would result in:
    
    .config:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_CONFIGFS_FS=m
    CONFIG_USB_LIBCOMPOSITE=m
    CONFIG_USB_ZERO=m
    CONFIG_CRC32=y
    CONFIG_CRC32_SLICEBY8=y
    ---8<---
    
    when the expected result would be:
    
    .config:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_CONFIGFS_FS=y
    CONFIG_USB_LIBCOMPOSITE=y
    CONFIG_USB_ZERO=y
    CONFIG_CRC32=y
    CONFIG_CRC32_SLICEBY8=y
    ---8<---
    
    Signed-off-by: Arve Hjønnevåg <arve@android.com>
    [yann.morin.1998@free.fr: add the resulting .config to commit log,
                              remove unneeded USB_GADGET from the defconfig]
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Yann E. MORIN <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 43eda40c3838..35e0f164ef81 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1083,7 +1083,7 @@ static void randomize_choice_values(struct symbol *csym)
 	csym->flags &= ~(SYMBOL_VALID);
 }
 
-static void set_all_choice_values(struct symbol *csym)
+void set_all_choice_values(struct symbol *csym)
 {
 	struct property *prop;
 	struct symbol *sym;
@@ -1100,7 +1100,7 @@ static void set_all_choice_values(struct symbol *csym)
 	}
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */
-	csym->flags &= ~(SYMBOL_VALID);
+	csym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);
 }
 
 void conf_set_all_new_symbols(enum conf_def_mode mode)
@@ -1202,6 +1202,14 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 	 * selected in a choice block and we set it to yes,
 	 * and the rest to no.
 	 */
+	if (mode != def_random) {
+		for_all_symbols(i, csym) {
+			if ((sym_is_choice(csym) && !sym_has_value(csym)) ||
+			    sym_is_choice_value(csym))
+				csym->flags |= SYMBOL_NEED_SET_CHOICE_VALUES;
+		}
+	}
+
 	for_all_symbols(i, csym) {
 		if (sym_has_value(csym) || !sym_is_choice(csym))
 			continue;
@@ -1209,7 +1217,5 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 		sym_calc_value(csym);
 		if (mode == def_random)
 			randomize_choice_values(csym);
-		else
-			set_all_choice_values(csym);
 	}
 }

commit 23a5dfdad22a574d19d7cc19b391f9ce0d3c2f21
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Fri Apr 26 22:41:32 2013 +0200

    Revert "kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG"
    
    This reverts commit 422c809f03f043d0950d8362214818e956a9daee.
    It causes more harm than it solves issues.
    
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Greg KH <greg@kroah.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index fc45fc137875..43eda40c3838 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -288,6 +288,8 @@ int conf_read_simple(const char *name, int def)
 	for_all_symbols(i, sym) {
 		sym->flags |= SYMBOL_CHANGED;
 		sym->flags &= ~(def_flags|SYMBOL_VALID);
+		if (sym_is_choice(sym))
+			sym->flags |= def_flags;
 		switch (sym->type) {
 		case S_INT:
 		case S_HEX:
@@ -377,13 +379,13 @@ int conf_read_simple(const char *name, int def)
 			case mod:
 				if (cs->def[def].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
+					cs->flags &= ~def_flags;
 				}
 				break;
 			case yes:
 				if (cs->def[def].tri != no)
 					conf_warning("override: %s changes choice state", sym->name);
 				cs->def[def].val = sym;
-				cs->flags |= def_flags;
 				break;
 			}
 			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
@@ -789,8 +791,6 @@ int conf_write(const char *name)
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
-			if (sym_is_choice_value(sym) && !menu_is_visible(menu->parent))
-				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
 
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
@@ -1077,7 +1077,6 @@ static void randomize_choice_values(struct symbol *csym)
 		else {
 			sym->def[S_DEF_USER].tri = no;
 		}
-		sym->flags &= ~(SYMBOL_VALID);
 	}
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */

commit e43956e607692f9b1c710311e4a6591ffba1edf0
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Sat Apr 13 17:18:36 2013 +0200

    kconfig: implement KCONFIG_PROBABILITY for randconfig
    
    Currently the odds to set each symbol is (rounded):
        booleans:   y: 50%          n: 50%
        tristates:  y: 33%  m: 33%  n: 33%
    
    Introduce a KCONFIG_PROBABILITY environment variable to tweak the
    probabilities (in percentage), as such:
        KCONFIG_PROBABILITY     y:n split           y:m:n split
        -----------------------------------------------------------------
    [1] unset or empty          50  : 50            33  : 33  : 34
    [2] N                        N  : 100-N         N/2 : N/2 : 100-N
        N:M                     N+M : 100-(N+M)      N  :  M  : 100-(N+M)
        N:M:L                    N  : 100-N          M  :  L  : 100-(M+L)
    
    [1] The current behaviour is kept as default, for backward compatibility
    [2] The solution initially implemented by Peter for Buildroot, see:
        http://git.buildroot.org/buildroot/commit/?id=3435c1afb5
    
    Signed-off-by: Peter Korsgaard <jacmet@uclibc.org>
    [yann.morin.1998@free.fr: add to Documentation/]
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 89274809a826..fc45fc137875 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1107,7 +1107,51 @@ static void set_all_choice_values(struct symbol *csym)
 void conf_set_all_new_symbols(enum conf_def_mode mode)
 {
 	struct symbol *sym, *csym;
-	int i, cnt;
+	int i, cnt, pby, pty, ptm;	/* pby: probability of boolean  = y
+					 * pty: probability of tristate = y
+					 * ptm: probability of tristate = m
+					 */
+
+	pby = 50; pty = ptm = 33; /* can't go as the default in switch-case
+				   * below, otherwise gcc whines about
+				   * -Wmaybe-uninitialized */
+	if (mode == def_random) {
+		int n, p[3];
+		char *env = getenv("KCONFIG_PROBABILITY");
+		n = 0;
+		while( env && *env ) {
+			char *endp;
+			int tmp = strtol( env, &endp, 10 );
+			if( tmp >= 0 && tmp <= 100 ) {
+				p[n++] = tmp;
+			} else {
+				errno = ERANGE;
+				perror( "KCONFIG_PROBABILITY" );
+				exit( 1 );
+			}
+			env = (*endp == ':') ? endp+1 : endp;
+			if( n >=3 ) {
+				break;
+			}
+		}
+		switch( n ) {
+		case 1:
+			pby = p[0]; ptm = pby/2; pty = pby-ptm;
+			break;
+		case 2:
+			pty = p[0]; ptm = p[1]; pby = pty + ptm;
+			break;
+		case 3:
+			pby = p[0]; pty = p[1]; ptm = p[2];
+			break;
+		}
+
+		if( pty+ptm > 100 ) {
+			errno = ERANGE;
+			perror( "KCONFIG_PROBABILITY" );
+			exit( 1 );
+		}
+	}
 
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
@@ -1126,8 +1170,15 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 				sym->def[S_DEF_USER].tri = no;
 				break;
 			case def_random:
-				cnt = sym->type == S_TRISTATE ? 3 : 2;
-				sym->def[S_DEF_USER].tri = (tristate)(rand() % cnt);
+				sym->def[S_DEF_USER].tri = no;
+				cnt = rand() % 100;
+				if (sym->type == S_TRISTATE) {
+					if (cnt < pty)
+						sym->def[S_DEF_USER].tri = yes;
+					else if (cnt < (pty+ptm))
+						sym->def[S_DEF_USER].tri = mod;
+				} else if (cnt < pby)
+					sym->def[S_DEF_USER].tri = yes;
 				break;
 			default:
 				continue;

commit 422c809f03f043d0950d8362214818e956a9daee
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Sun Mar 10 16:34:10 2013 +0100

    kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG
    
    Currently, randconfig does randomise choice entries, unless KCONFIG_ALLCONFIG
    is specified.
    
    For example, given those two files (Thomas' test-case):
    
        ---8<--- Config.test.in
        config OPTIONA
            bool "Option A"
    
        choice
            prompt "This is a choice"
    
        config CHOICE_OPTIONA
            bool "Choice Option A"
    
        config CHOICE_OPTIONB
            bool "Choice Option B"
    
        endchoice
    
        config OPTIONB
            bool "Option B"
        ---8<--- Config.test.in
    
        ---8<--- config.defaults
        CONFIG_OPTIONA=y
        ---8<--- config.defaults
    
    And running:
        ./scripts/kconfig/conf --randconfig Config.test.in
    
    does properly randomise the two choice symbols (and the two booleans).
    
    However, running:
        KCONFIG_ALLCONFIG=config.defaults \
        ./scripts/kconfig/conf --randconfig Config.test.in
    
    does *not* reandomise the two choice entries, and only CHOICE_OPTIONA
    will ever be selected. (OPTIONA will always be set (expected), and
    OPTIONB will be be properly randomised (expected).)
    
    This patch defers setting that a choice has a value until a symbol for
    that choice is indeed set, so that choices are properly randomised when
    KCONFIG_ALLCONFIG is set, but not if a symbol for that choice is set.
    
    Also, as a side-efect, this patch fixes the following case:
    
        ---8<---
        choice
        config OPTION_A
            bool "Option A"
        config OPTION_B
            bool "Option B"
        config OPTION_C
            bool "Option C"
        endchoice
        ---8<---
    
    which could previously generate such .config files:
    
        ---8<---                            ---8<---
        CONFIG_OPTION_A=y                   CONFIG_OPTION_A=y
        CONFIG_OPTION_B=y                   # CONFIG_OPTION_B is not set
        # CONFIG_OPTION_C is not set        CONFIG_OPTION_C=y
        ---8<---                            ---8<---
    
    Ie., the first entry in a choice is always set, plus zero or one of
    the other options may be set.
    
    This patch ensures that only one option may be set for a choice.
    
    Reported-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Arnaud Lacombe <lacombar@gmail.com>
    
    ---
    Changes v2 -> v3
      - ensure only one symbol is set in a choice
    
    Changes v1 -> v2:
      - further postpone setting that a choice has a value until
        one is indeed set
      - do not print symbols that are part of an invisible choice

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2e35d4b2bbfd..89274809a826 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -288,8 +288,6 @@ int conf_read_simple(const char *name, int def)
 	for_all_symbols(i, sym) {
 		sym->flags |= SYMBOL_CHANGED;
 		sym->flags &= ~(def_flags|SYMBOL_VALID);
-		if (sym_is_choice(sym))
-			sym->flags |= def_flags;
 		switch (sym->type) {
 		case S_INT:
 		case S_HEX:
@@ -379,13 +377,13 @@ int conf_read_simple(const char *name, int def)
 			case mod:
 				if (cs->def[def].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
-					cs->flags &= ~def_flags;
 				}
 				break;
 			case yes:
 				if (cs->def[def].tri != no)
 					conf_warning("override: %s changes choice state", sym->name);
 				cs->def[def].val = sym;
+				cs->flags |= def_flags;
 				break;
 			}
 			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
@@ -791,6 +789,8 @@ int conf_write(const char *name)
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
+			if (sym_is_choice_value(sym) && !menu_is_visible(menu->parent))
+				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
 
 			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
@@ -1077,6 +1077,7 @@ static void randomize_choice_values(struct symbol *csym)
 		else {
 			sym->def[S_DEF_USER].tri = no;
 		}
+		sym->flags &= ~(SYMBOL_VALID);
 	}
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */

commit cfa98f2e0ae956feca935573e977d7661a9561b9
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Wed Apr 24 22:00:04 2013 +0200

    kconfig: do not override symbols already set
    
    For randconfig, if a list of required symbols is specified with
    KCONFIG_ALLCONFIG, such symbols do not "have a value" as per
    sym_has_value(), but have the "valid" flag set.
    
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 306cbc1bac04..2e35d4b2bbfd 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1109,7 +1109,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 	int i, cnt;
 
 	for_all_symbols(i, sym) {
-		if (sym_has_value(sym))
+		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
 			continue;
 		switch (sym_get_type(sym)) {
 		case S_BOOLEAN:

commit 61fa0e17f99b60b851d4480605b7d905d3172f0c
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Wed Apr 24 18:14:27 2013 +0200

    kconfig: fix randconfig tristate detection
    
    Because the modules' symbole (CONFIG_MODULES) may not yet be set when
    we check a symbol's tristate capabilty, we'll always find that tristate
    symbols are booleans, even if we randomly decided that to enable modules:
    sym_get_type(sym) always return boolean for tristates when modules_sym
    has not been previously set to 'y' *and* its value calculated *and* its
    visibility calculated, both of which only occur after we randomly assign
    values to symbols.
    
    Fix that by looking at the raw type of symbols. Tristate set to 'm' will
    be promoted to 'y' when their values will be later calculated.
    
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 13ddf1126c2a..306cbc1bac04 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -1125,7 +1125,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 				sym->def[S_DEF_USER].tri = no;
 				break;
 			case def_random:
-				cnt = sym_get_type(sym) == S_TRISTATE ? 3 : 2;
+				cnt = sym->type == S_TRISTATE ? 3 : 2;
 				sym->def[S_DEF_USER].tri = (tristate)(rand() % cnt);
 				break;
 			default:

commit 1a7a8c6fd8ca24d3692dacddf8d658c9bb9c14ad
Author: Cody Schafer <cody@linux.vnet.ibm.com>
Date:   Fri Jul 13 11:27:12 2012 -0700

    kconfig: allow long lines in config file
    
    For some config options (CONFIG_EXTRA_FIRMWARE, for example), the length
    of a config file line can exceed the 1024 byte buffer.
    
    Switch from fgets to compat_getline to fix. compat_getline is an
    internally implimented getline work-alike for portability purposes.
    
    Signed-off-by: Cody Schafer <cody@linux.vnet.ibm.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 52577f052bc1..13ddf1126c2a 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -182,10 +182,66 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 	return 0;
 }
 
+#define LINE_GROWTH 16
+static int add_byte(int c, char **lineptr, size_t slen, size_t *n)
+{
+	char *nline;
+	size_t new_size = slen + 1;
+	if (new_size > *n) {
+		new_size += LINE_GROWTH - 1;
+		new_size *= 2;
+		nline = realloc(*lineptr, new_size);
+		if (!nline)
+			return -1;
+
+		*lineptr = nline;
+		*n = new_size;
+	}
+
+	(*lineptr)[slen] = c;
+
+	return 0;
+}
+
+static ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)
+{
+	char *line = *lineptr;
+	size_t slen = 0;
+
+	for (;;) {
+		int c = getc(stream);
+
+		switch (c) {
+		case '\n':
+			if (add_byte(c, &line, slen, n) < 0)
+				goto e_out;
+			slen++;
+			/* fall through */
+		case EOF:
+			if (add_byte('\0', &line, slen, n) < 0)
+				goto e_out;
+			*lineptr = line;
+			if (slen == 0)
+				return -1;
+			return slen;
+		default:
+			if (add_byte(c, &line, slen, n) < 0)
+				goto e_out;
+			slen++;
+		}
+	}
+
+e_out:
+	line[slen-1] = '\0';
+	*lineptr = line;
+	return -1;
+}
+
 int conf_read_simple(const char *name, int def)
 {
 	FILE *in = NULL;
-	char line[1024];
+	char   *line = NULL;
+	size_t  line_asize = 0;
 	char *p, *p2;
 	struct symbol *sym;
 	int i, def_flags;
@@ -247,7 +303,7 @@ int conf_read_simple(const char *name, int def)
 		}
 	}
 
-	while (fgets(line, sizeof(line), in)) {
+	while (compat_getline(&line, &line_asize, in) != -1) {
 		conf_lineno++;
 		sym = NULL;
 		if (line[0] == '#') {
@@ -335,6 +391,7 @@ int conf_read_simple(const char *name, int def)
 			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
 		}
 	}
+	free(line);
 	fclose(in);
 
 	if (modules_sym)

commit e4757cab4cff01e9c47b14376be7438694032c3c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Apr 12 19:46:34 2012 -0400

    kconfig: delete last traces of __enabled_ from autoconf.h
    
    We've now fixed IS_ENABLED() and friends to not require any special
    "__enabled_" prefixed versions of the normal Kconfig options, so delete
    the last traces of them being generated.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 9d0674473564..52577f052bc1 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -489,17 +489,6 @@ header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 			fprintf(fp, "#define %s%s%s 1\n",
 			    CONFIG_, sym->name, suffix);
 		}
-		/*
-		 * Generate the __enabled_CONFIG_* and
-		 * __enabled_CONFIG_*_MODULE macros for use by the
-		 * IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
-		 * generated even for booleans so that the IS_ENABLED() macro
-		 * works.
-		 */
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
-				sym->name, (*value == 'y'));
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
-				sym->name, (*value == 'm'));
 		break;
 	}
 	case S_HEX: {

commit a959613533a176a8f5f402585827e94a5220d2db
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Apr 12 19:46:33 2012 -0400

    Revert "kconfig: fix __enabled_ macros definition for invisible and un-selected symbols"
    
    This reverts commit 953742c8fe8ac45be453fee959d7be40cd89f920.
    
    Dumping two lines into autoconf.h for all existing Kconfig options
    results in a giant file (~16k lines) we have to process each time we
    compile something.  We've weaned IS_ENABLED() and similar off of
    requiring the __enabled_ definitions so now we can revert the change
    which caused all the extra lines.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 0586085136d1..9d0674473564 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -489,6 +489,17 @@ header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 			fprintf(fp, "#define %s%s%s 1\n",
 			    CONFIG_, sym->name, suffix);
 		}
+		/*
+		 * Generate the __enabled_CONFIG_* and
+		 * __enabled_CONFIG_*_MODULE macros for use by the
+		 * IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
+		 * generated even for booleans so that the IS_ENABLED() macro
+		 * works.
+		 */
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
+				sym->name, (*value == 'y'));
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
+				sym->name, (*value == 'm'));
 		break;
 	}
 	case S_HEX: {
@@ -539,35 +550,6 @@ static struct conf_printer header_printer_cb =
 	.print_comment = header_print_comment,
 };
 
-/*
- * Generate the __enabled_CONFIG_* and __enabled_CONFIG_*_MODULE macros for
- * use by the IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
- * generated even for booleans so that the IS_ENABLED() macro works.
- */
-static void
-header_print__enabled_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
-{
-
-	switch (sym->type) {
-	case S_BOOLEAN:
-	case S_TRISTATE: {
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
-		    sym->name, (*value == 'y'));
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
-		    sym->name, (*value == 'm'));
-		break;
-	}
-	default:
-		break;
-	}
-}
-
-static struct conf_printer header__enabled_printer_cb =
-{
-	.print_symbol = header_print__enabled_symbol,
-	.print_comment = header_print_comment,
-};
-
 /*
  * Tristate printer
  *
@@ -949,16 +931,11 @@ int conf_write_autoconf(void)
 	conf_write_heading(out_h, &header_printer_cb, NULL);
 
 	for_all_symbols(i, sym) {
-		if (!sym->name)
-			continue;
-
 		sym_calc_value(sym);
-
-		conf_write_symbol(out_h, sym, &header__enabled_printer_cb, NULL);
-
-		if (!(sym->flags & SYMBOL_WRITE))
+		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
 
+		/* write symbol to auto.conf, tristate and header files */
 		conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
 
 		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);

commit 5d09598d488f081e3be23f885ed65cbbe2d073b5
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Mon Jan 23 17:29:05 2012 -0500

    kconfig: fix new choices being skipped upon config update
    
    Running `oldconfig' after any of the following configuration change:
    
    either trivial addition, such as:
    
    config A
            bool "A"
    
    choice
            prompt "Choice ?"
            depends on A
    
            config CHOICE_B
                    bool "Choice B"
    
            config CHOICE_C
                    bool "Choice C"
    endchoice
    
    or more tricky change:
    
    OLD KCONFIG                      |  NEW KCONFIG
                                     |
                                     |  config A
                                     |          bool "A"
                                     |
    choice                           |  choice
            prompt "Choice ?"        |          prompt "Choice ?"
                                     |
            config CHOICE_C          |          config CHOICE_C
                    bool "Choice C"  |                  bool "Choice C"
                                     |
            config CHOICE_D          |          config CHOICE_D
                    bool "Choice D"  |                  bool "Choice D"
    endchoice                        |
                                     |          config CHOICE_E
                                     |                  bool "Choice E"
                                     |                  depends on A
                                     |  endchoice
    
    will not cause the choice to be considered as NEW, and thus not be
    asked. The cause of this behavior is that choice's novelty are computed
    statically right after the saved configuration has been read. At this
    point, the new dependency's value is still unknown and asserted to be
    `no'. Moreover, no update to this decision is made afterward.
    
    Correct this by dynamically evaluating a choice's novelty, and removing the
    static evaluation.
    
    Reported-and-tested-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 7c7a5a6cc3f5..0586085136d1 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -344,10 +344,8 @@ int conf_read_simple(const char *name, int def)
 
 int conf_read(const char *name)
 {
-	struct symbol *sym, *choice_sym;
-	struct property *prop;
-	struct expr *e;
-	int i, flags;
+	struct symbol *sym;
+	int i;
 
 	sym_set_change_count(0);
 
@@ -357,7 +355,7 @@ int conf_read(const char *name)
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
 		if (sym_is_choice(sym) || (sym->flags & SYMBOL_AUTO))
-			goto sym_ok;
+			continue;
 		if (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {
 			/* check that calculated value agrees with saved value */
 			switch (sym->type) {
@@ -366,30 +364,18 @@ int conf_read(const char *name)
 				if (sym->def[S_DEF_USER].tri != sym_get_tristate_value(sym))
 					break;
 				if (!sym_is_choice(sym))
-					goto sym_ok;
+					continue;
 				/* fall through */
 			default:
 				if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
-					goto sym_ok;
+					continue;
 				break;
 			}
 		} else if (!sym_has_value(sym) && !(sym->flags & SYMBOL_WRITE))
 			/* no previous value and not saved */
-			goto sym_ok;
+			continue;
 		conf_unsaved++;
 		/* maybe print value in verbose mode... */
-	sym_ok:
-		if (!sym_is_choice(sym))
-			continue;
-		/* The choice symbol only has a set value (and thus is not new)
-		 * if all its visible childs have values.
-		 */
-		prop = sym_get_choice_prop(sym);
-		flags = sym->flags;
-		expr_list_for_each_sym(prop->expr, e, choice_sym)
-			if (choice_sym->visible != no)
-				flags &= choice_sym->flags;
-		sym->flags &= flags | ~SYMBOL_DEF_USER;
 	}
 
 	for_all_symbols(i, sym) {

commit 70cc01e7579cdb71f42f3f7085ab457be7808783
Author: Peter Foley <pefoley2@verizon.net>
Date:   Sat Oct 22 10:48:49 2011 -0400

    kconfig: use xfwrite wrapper function to silence warnings
    
    Use the xfwrite wrapper function defined in lkc.h to check the return value of
    fwrite and silence these warnings.
    
      HOSTCC  scripts/kconfig/zconf.tab.o
    scripts/kconfig/zconf.tab.c: In function 'header_print_comment':
    /usr/src/lto/scripts/kconfig/confdata.c:551:10: warning: ignoring return value of 'fwrite', declared with attribute warn_unused_result
    scripts/kconfig/zconf.tab.c: In function 'kconfig_print_comment':
    /usr/src/lto/scripts/kconfig/confdata.c:467:10: warning: ignoring return value of 'fwrite', declared with attribute warn_unused_result
    
    Signed-off-by: Peter Foley <pefoley2@verizon.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 5a58965d8800..7c7a5a6cc3f5 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -464,7 +464,7 @@ kconfig_print_comment(FILE *fp, const char *value, void *arg)
 		fprintf(fp, "#");
 		if (l) {
 			fprintf(fp, " ");
-			fwrite(p, l, 1, fp);
+			xfwrite(p, l, 1, fp);
 			p += l;
 		}
 		fprintf(fp, "\n");
@@ -537,7 +537,7 @@ header_print_comment(FILE *fp, const char *value, void *arg)
 		fprintf(fp, " *");
 		if (l) {
 			fprintf(fp, " ");
-			fwrite(p, l, 1, fp);
+			xfwrite(p, l, 1, fp);
 			p += l;
 		}
 		fprintf(fp, "\n");

commit 953742c8fe8ac45be453fee959d7be40cd89f920
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Tue Aug 16 01:20:20 2011 -0400

    kconfig: fix __enabled_ macros definition for invisible and un-selected symbols
    
    __enabled_<sym-name> are only generated on visible or selected entries, do not
    reflect the purpose of its introduction.
    
    Fix this by always generating these entries for named symbol.
    
    Reported-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 59b667cae5f3..5a58965d8800 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -503,17 +503,6 @@ header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 			fprintf(fp, "#define %s%s%s 1\n",
 			    CONFIG_, sym->name, suffix);
 		}
-		/*
-		 * Generate the __enabled_CONFIG_* and
-		 * __enabled_CONFIG_*_MODULE macros for use by the
-		 * IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
-		 * generated even for booleans so that the IS_ENABLED() macro
-		 * works.
-		 */
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
-				sym->name, (*value == 'y'));
-		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
-				sym->name, (*value == 'm'));
 		break;
 	}
 	case S_HEX: {
@@ -564,6 +553,35 @@ static struct conf_printer header_printer_cb =
 	.print_comment = header_print_comment,
 };
 
+/*
+ * Generate the __enabled_CONFIG_* and __enabled_CONFIG_*_MODULE macros for
+ * use by the IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
+ * generated even for booleans so that the IS_ENABLED() macro works.
+ */
+static void
+header_print__enabled_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE: {
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
+		    sym->name, (*value == 'y'));
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
+		    sym->name, (*value == 'm'));
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+static struct conf_printer header__enabled_printer_cb =
+{
+	.print_symbol = header_print__enabled_symbol,
+	.print_comment = header_print_comment,
+};
+
 /*
  * Tristate printer
  *
@@ -945,11 +963,16 @@ int conf_write_autoconf(void)
 	conf_write_heading(out_h, &header_printer_cb, NULL);
 
 	for_all_symbols(i, sym) {
+		if (!sym->name)
+			continue;
+
 		sym_calc_value(sym);
-		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
+
+		conf_write_symbol(out_h, sym, &header__enabled_printer_cb, NULL);
+
+		if (!(sym->flags & SYMBOL_WRITE))
 			continue;
 
-		/* write symbol to auto.conf, tristate and header files */
 		conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
 
 		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);

commit 2a11c8ea20bf850b3a2c60db8c2e7497d28aba99
Author: Michal Marek <mmarek@suse.cz>
Date:   Wed Jul 20 17:38:57 2011 +0200

    kconfig: Introduce IS_ENABLED(), IS_BUILTIN() and IS_MODULE()
    
    Replace the config_is_*() macros with a variant that allows for grepping
    for usage of CONFIG_* options in the code. Usage:
    
      if (IS_ENABLED(CONFIG_NUMA))
    
    or
    
      #if IS_ENABLED(CONFIG_NUMA)
    
    The IS_ENABLED() macro evaluates to 1 if the argument is set (to either 'y'
    or 'm'), IS_BUILTIN() tests if the option is 'y' and IS_MODULE() test if
    the option is 'm'. Only boolean and tristate options are supported.
    
    Reviewed-by: Arnaud Lacombe <lacombar@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index df629ecb4fdf..59b667cae5f3 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -495,15 +495,25 @@ header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 
 		switch (*value) {
 		case 'n':
-			return;
+			break;
 		case 'm':
 			suffix = "_MODULE";
 			/* fall through */
 		default:
-			value = "1";
+			fprintf(fp, "#define %s%s%s 1\n",
+			    CONFIG_, sym->name, suffix);
 		}
-		fprintf(fp, "#define %s%s%s %s\n",
-		    CONFIG_, sym->name, suffix, value);
+		/*
+		 * Generate the __enabled_CONFIG_* and
+		 * __enabled_CONFIG_*_MODULE macros for use by the
+		 * IS_{ENABLED,BUILTIN,MODULE} macros. The _MODULE variant is
+		 * generated even for booleans so that the IS_ENABLED() macro
+		 * works.
+		 */
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s %d\n",
+				sym->name, (*value == 'y'));
+		fprintf(fp, "#define __enabled_" CONFIG_ "%s_MODULE %d\n",
+				sym->name, (*value == 'm'));
 		break;
 	}
 	case S_HEX: {
@@ -554,58 +564,6 @@ static struct conf_printer header_printer_cb =
 	.print_comment = header_print_comment,
 };
 
-/*
- * Function-style header printer
- *
- * This printer is used to generate the config_is_xxx() function-style macros
- * in `include/generated/autoconf.h' 
- */
-static void
-header_function_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
-{
-	int val = 0;
-	char c;
-	char *tmp, *d;
-
-	switch (sym->type) {
-	case S_BOOLEAN:
-	case S_TRISTATE:
-		break;
-	default:
-		return;
-	}
-	if (*value == 'm')
-		val = 2;
-	else if (*value == 'y')
-		val = 1;
-
-	d = strdup(CONFIG_);
-	tmp = d;
-	while ((c = *d)) {
-		*d = tolower(c);
-		d++;
-	}
-
-	fprintf(fp, "#define %sis_", tmp);
-	free(tmp);
-
-	d = strdup(sym->name);
-	tmp = d;
-	while ((c = *d)) {
-		*d = tolower(c);
-		d++;
-	}
-	fprintf(fp, "%s%s() %d\n", tmp, (val > 1) ? "_module" : "",
-		      val ? 1 : 0);
-	free(tmp);
-}
-
-static struct conf_printer header_function_printer_cb =
-{
-	.print_symbol = header_function_print_symbol,
-};
-
-
 /*
  * Tristate printer
  *
@@ -997,7 +955,6 @@ int conf_write_autoconf(void)
 		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);
 
 		conf_write_symbol(out_h, sym, &header_printer_cb, NULL);
-		conf_write_symbol(out_h, sym, &header_function_printer_cb, NULL);
 	}
 	fclose(out);
 	fclose(tristate);

commit eb4cf5a642f6430cffff7ba5d8d9bd46ea409281
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Thu Jul 14 15:31:07 2011 -0400

    kconfig: fix missing "0x" prefix from S_HEX symbol in autoconf.h
    
    The specialized printer for headers (espectially autoconf.h) is missing
    fixup code for S_HEX symbol's "0x" prefix. As long as kconfig does not
    warn for such missing prefix, this code is needed. Fix this.
    
    In the same time, fix some nits in `header_print_symbol()'.
    
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    
    Broken-by: Arnaud Lacombe <lacombar@gmail.com>
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Reported-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index be6952c7fb29..df629ecb4fdf 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -487,27 +487,43 @@ static struct conf_printer kconfig_printer_cb =
 static void
 header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
 {
-	const char *suffix = "";
 
 	switch (sym->type) {
 	case S_BOOLEAN:
-	case S_TRISTATE:
+	case S_TRISTATE: {
+		const char *suffix = "";
+
 		switch (*value) {
 		case 'n':
 			return;
 		case 'm':
 			suffix = "_MODULE";
-			/* FALLTHROUGH */
+			/* fall through */
 		default:
 			value = "1";
 		}
+		fprintf(fp, "#define %s%s%s %s\n",
+		    CONFIG_, sym->name, suffix, value);
+		break;
+	}
+	case S_HEX: {
+		const char *prefix = "";
+
+		if (value[0] != '0' || (value[1] != 'x' && value[1] != 'X'))
+			prefix = "0x";
+		fprintf(fp, "#define %s%s %s%s\n",
+		    CONFIG_, sym->name, prefix, value);
+		break;
+	}
+	case S_STRING:
+	case S_INT:
+		fprintf(fp, "#define %s%s %s\n",
+		    CONFIG_, sym->name, value);
 		break;
 	default:
 		break;
 	}
 
-	fprintf(fp, "#define %s%s%s %s\n",
-	    CONFIG_, sym->name, suffix, value);
 }
 
 static void

commit e54e692ba613c2170c66ce36a3791c009680af08
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun May 15 23:42:09 2011 -0400

    kconfig: introduce specialized printer
    
    Make conf_write_symbol() grammar agnostic to be able to use it from different
    code path. These path pass a printer callback which will print a symbol's name
    and its value in different format.
    
    conf_write_symbol()'s job become mostly only to prepare a string for the
    printer. This avoid to have to pass specialized flag to generic
    functions
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    [mmarek: rebased on top of de12518 (kconfig: autogenerated config_is_xxx
    macro)]
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index a49cf4f7dca5..be6952c7fb29 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -422,64 +422,228 @@ int conf_read(const char *name)
 	return 0;
 }
 
-/* Write a S_STRING */
-static void conf_write_string(bool headerfile, const char *name,
-                              const char *str, FILE *out)
+/*
+ * Kconfig configuration printer
+ *
+ * This printer is used when generating the resulting configuration after
+ * kconfig invocation and `defconfig' files. Unset symbol might be omitted by
+ * passing a non-NULL argument to the printer.
+ *
+ */
+static void
+kconfig_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		if (*value == 'n') {
+			bool skip_unset = (arg != NULL);
+
+			if (!skip_unset)
+				fprintf(fp, "# %s%s is not set\n",
+				    CONFIG_, sym->name);
+			return;
+		}
+		break;
+	default:
+		break;
+	}
+
+	fprintf(fp, "%s%s=%s\n", CONFIG_, sym->name, value);
+}
+
+static void
+kconfig_print_comment(FILE *fp, const char *value, void *arg)
 {
-	int l;
-	if (headerfile)
-		fprintf(out, "#define %s%s \"", CONFIG_, name);
-	else
-		fprintf(out, "%s%s=\"", CONFIG_, name);
-
-	while (1) {
-		l = strcspn(str, "\"\\");
+	const char *p = value;
+	size_t l;
+
+	for (;;) {
+		l = strcspn(p, "\n");
+		fprintf(fp, "#");
 		if (l) {
-			xfwrite(str, l, 1, out);
-			str += l;
+			fprintf(fp, " ");
+			fwrite(p, l, 1, fp);
+			p += l;
 		}
-		if (!*str)
+		fprintf(fp, "\n");
+		if (*p++ == '\0')
 			break;
-		fprintf(out, "\\%c", *str++);
 	}
-	fputs("\"\n", out);
 }
 
-static void conf_write_symbol(struct symbol *sym, FILE *out, bool write_no)
+static struct conf_printer kconfig_printer_cb =
 {
-	const char *str;
+	.print_symbol = kconfig_print_symbol,
+	.print_comment = kconfig_print_comment,
+};
+
+/*
+ * Header printer
+ *
+ * This printer is used when generating the `include/generated/autoconf.h' file.
+ */
+static void
+header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+	const char *suffix = "";
 
 	switch (sym->type) {
 	case S_BOOLEAN:
 	case S_TRISTATE:
-		switch (sym_get_tristate_value(sym)) {
-		case no:
-			if (write_no)
-				fprintf(out, "# %s%s is not set\n",
-				    CONFIG_, sym->name);
-			break;
-		case mod:
-			fprintf(out, "%s%s=m\n", CONFIG_, sym->name);
-			break;
-		case yes:
-			fprintf(out, "%s%s=y\n", CONFIG_, sym->name);
-			break;
+		switch (*value) {
+		case 'n':
+			return;
+		case 'm':
+			suffix = "_MODULE";
+			/* FALLTHROUGH */
+		default:
+			value = "1";
 		}
 		break;
-	case S_STRING:
-		conf_write_string(false, sym->name, sym_get_string_value(sym), out);
+	default:
 		break;
-	case S_HEX:
-	case S_INT:
-		str = sym_get_string_value(sym);
-		fprintf(out, "%s%s=%s\n", CONFIG_, sym->name, str);
+	}
+
+	fprintf(fp, "#define %s%s%s %s\n",
+	    CONFIG_, sym->name, suffix, value);
+}
+
+static void
+header_print_comment(FILE *fp, const char *value, void *arg)
+{
+	const char *p = value;
+	size_t l;
+
+	fprintf(fp, "/*\n");
+	for (;;) {
+		l = strcspn(p, "\n");
+		fprintf(fp, " *");
+		if (l) {
+			fprintf(fp, " ");
+			fwrite(p, l, 1, fp);
+			p += l;
+		}
+		fprintf(fp, "\n");
+		if (*p++ == '\0')
+			break;
+	}
+	fprintf(fp, " */\n");
+}
+
+static struct conf_printer header_printer_cb =
+{
+	.print_symbol = header_print_symbol,
+	.print_comment = header_print_comment,
+};
+
+/*
+ * Function-style header printer
+ *
+ * This printer is used to generate the config_is_xxx() function-style macros
+ * in `include/generated/autoconf.h' 
+ */
+static void
+header_function_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+	int val = 0;
+	char c;
+	char *tmp, *d;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
 		break;
+	default:
+		return;
+	}
+	if (*value == 'm')
+		val = 2;
+	else if (*value == 'y')
+		val = 1;
+
+	d = strdup(CONFIG_);
+	tmp = d;
+	while ((c = *d)) {
+		*d = tolower(c);
+		d++;
+	}
+
+	fprintf(fp, "#define %sis_", tmp);
+	free(tmp);
+
+	d = strdup(sym->name);
+	tmp = d;
+	while ((c = *d)) {
+		*d = tolower(c);
+		d++;
+	}
+	fprintf(fp, "%s%s() %d\n", tmp, (val > 1) ? "_module" : "",
+		      val ? 1 : 0);
+	free(tmp);
+}
+
+static struct conf_printer header_function_printer_cb =
+{
+	.print_symbol = header_function_print_symbol,
+};
+
+
+/*
+ * Tristate printer
+ *
+ * This printer is used when generating the `include/config/tristate.conf' file.
+ */
+static void
+tristate_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
+{
+
+	if (sym->type == S_TRISTATE && *value != 'n')
+		fprintf(fp, "%s%s=%c\n", CONFIG_, sym->name, (char)toupper(*value));
+}
+
+static struct conf_printer tristate_printer_cb =
+{
+	.print_symbol = tristate_print_symbol,
+	.print_comment = kconfig_print_comment,
+};
+
+static void conf_write_symbol(FILE *fp, struct symbol *sym,
+			      struct conf_printer *printer, void *printer_arg)
+{
+	const char *str;
+
+	switch (sym->type) {
 	case S_OTHER:
 	case S_UNKNOWN:
 		break;
+	case S_STRING:
+		str = sym_get_string_value(sym);
+		str = sym_escape_string_value(str);
+		printer->print_symbol(fp, sym, str, printer_arg);
+		free((void *)str);
+		break;
+	default:
+		str = sym_get_string_value(sym);
+		printer->print_symbol(fp, sym, str, printer_arg);
 	}
 }
 
+static void
+conf_write_heading(FILE *fp, struct conf_printer *printer, void *printer_arg)
+{
+	char buf[256];
+
+	snprintf(buf, sizeof(buf),
+	    "\n"
+	    "Automatically generated file; DO NOT EDIT.\n"
+	    "%s\n",
+	    rootmenu.prompt->text);
+
+	printer->print_comment(fp, buf, printer_arg);
+}
+
 /*
  * Write out a minimal config.
  * All values that has default values are skipped as this is redundant.
@@ -536,7 +700,7 @@ int conf_write_defconfig(const char *filename)
 						goto next_menu;
 				}
 			}
-			conf_write_symbol(sym, out, true);
+			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 next_menu:
 		if (menu->list != NULL) {
@@ -601,11 +765,7 @@ int conf_write(const char *name)
 	if (!out)
 		return 1;
 
-	fprintf(out, _("#\n"
-		       "# Automatically generated make config: don't edit\n"
-		       "# %s\n"
-		       "#\n"),
-		     rootmenu.prompt->text);
+	conf_write_heading(out, &kconfig_printer_cb, NULL);
 
 	if (!conf_get_changed())
 		sym_clear_all_valid();
@@ -626,8 +786,8 @@ int conf_write(const char *name)
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
-			/* Write config symbol to file */
-			conf_write_symbol(sym, out, true);
+
+			conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
 		}
 
 next:
@@ -773,33 +933,9 @@ static int conf_split_config(void)
 	return res;
 }
 
-static void conf_write_function_autoconf(FILE *out, char* conf, char* name,
-					 int val)
-{
-	char c;
-	char *tmp, *d;
-
-	d = strdup(conf);
-	tmp = d;
-	while ((c = *conf++))
-		*d++ = tolower(c);
-
-	fprintf(out, "#define %sis_", tmp);
-	free(tmp);
-
-	d = strdup(name);
-	tmp = d;
-	while ((c = *name++))
-		*d++ = tolower(c);
-	fprintf(out, "%s%s() %d\n", tmp, (val > 1) ? "_module" : "",
-		      val ? 1 : 0);
-	free(tmp);
-}
-
 int conf_write_autoconf(void)
 {
 	struct symbol *sym;
-	const char *str;
 	const char *name;
 	FILE *out, *tristate, *out_h;
 	int i;
@@ -828,72 +964,24 @@ int conf_write_autoconf(void)
 		return 1;
 	}
 
-	fprintf(out, "#\n"
-		     "# Automatically generated make config: don't edit\n"
-		     "# %s\n"
-		     "#\n",
-		     rootmenu.prompt->text);
-	fprintf(tristate, "#\n"
-			  "# Automatically generated - do not edit\n"
-			  "\n");
-	fprintf(out_h, "/*\n"
-		       " * Automatically generated C config: don't edit\n"
-		       " * %s\n"
-		       " */\n",
-		       rootmenu.prompt->text);
+	conf_write_heading(out, &kconfig_printer_cb, NULL);
+
+	conf_write_heading(tristate, &tristate_printer_cb, NULL);
+
+	conf_write_heading(out_h, &header_printer_cb, NULL);
 
 	for_all_symbols(i, sym) {
-		int fct_val = 0;
 		sym_calc_value(sym);
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
 
-		/* write symbol to config file */
-		conf_write_symbol(sym, out, false);
+		/* write symbol to auto.conf, tristate and header files */
+		conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
 
-		/* update autoconf and tristate files */
-		switch (sym->type) {
-		case S_BOOLEAN:
-		case S_TRISTATE:
-			switch (sym_get_tristate_value(sym)) {
-			case no:
-				break;
-			case mod:
-				fprintf(tristate, "%s%s=M\n",
-				    CONFIG_, sym->name);
-				fprintf(out_h, "#define %s%s_MODULE 1\n",
-				    CONFIG_, sym->name);
-				fct_val = 2;
-				break;
-			case yes:
-				if (sym->type == S_TRISTATE)
-					fprintf(tristate,"%s%s=Y\n",
-					    CONFIG_, sym->name);
-				fprintf(out_h, "#define %s%s 1\n",
-				    CONFIG_, sym->name);
-				fct_val = 1;
-				break;
-			}
-			conf_write_function_autoconf(out_h, CONFIG_, sym->name, fct_val);
-			break;
-		case S_STRING:
-			conf_write_string(true, sym->name, sym_get_string_value(sym), out_h);
-			break;
-		case S_HEX:
-			str = sym_get_string_value(sym);
-			if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
-				fprintf(out_h, "#define %s%s 0x%s\n",
-				    CONFIG_, sym->name, str);
-				break;
-			}
-		case S_INT:
-			str = sym_get_string_value(sym);
-			fprintf(out_h, "#define %s%s %s\n",
-			    CONFIG_, sym->name, str);
-			break;
-		default:
-			break;
-		}
+		conf_write_symbol(tristate, sym, &tristate_printer_cb, (void *)1);
+
+		conf_write_symbol(out_h, sym, &header_printer_cb, NULL);
+		conf_write_symbol(out_h, sym, &header_function_printer_cb, NULL);
 	}
 	fclose(out);
 	fclose(tristate);

commit 36fee53510f91d8ac5eb5dcba0e431a21ebdd5cd
Merge: a61944c251c3 1ea3ad4e9322
Author: Michal Marek <mmarek@suse.cz>
Date:   Wed Jun 8 17:40:20 2011 +0200

    Merge branch 'kconfig-trivial' of git://github.com/lacombar/linux-2.6 into kbuild/kconfig

commit 5a6f8d2bd9e3392569ed6f29ea4d7210652f929b
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:14:47 2011 -0400

    kconfig: nuke LKC_DIRECT_LINK cruft
    
    This interface is not (and has never been ?) used by any frontend, just get rid
    of it.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ca16ab4367dd..c257bb0bf90a 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -14,7 +14,6 @@
 #include <time.h>
 #include <unistd.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 static void conf_warning(const char *fmt, ...)

commit 10a4b2772e7643247ddb5316c644f1fe7c4dccca
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:00:46 2011 -0400

    kconfig: add missing <stdarg.h> inclusion
    
    This header is needed when using va_{start,end,copy}(3) functions family.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 4e878dda1add..ca16ab4367dd 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -7,6 +7,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

commit 75f1468beaeca690e139b4e1bcd19aa20973fca9
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Tue May 31 12:31:57 2011 -0400

    kconfig: fix return code for invalid boolean symbol in conf_set_sym_val()
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 0a1ccc397b86..4e878dda1add 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -141,7 +141,7 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			break;
 		}
 		conf_warning("symbol value '%s' invalid for %s", p, sym->name);
-		break;
+		return 1;
 	case S_OTHER:
 		if (*p != '"') {
 			for (p2 = p; *p2 && !isspace(*p2); p2++)

commit d8fc320079b46cf462897148f48d4a63f37f56ce
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Tue May 31 12:30:26 2011 -0400

    kconfig: annotate non-trivial fall-trough
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2bafd9a7c8da..0a1ccc397b86 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -128,6 +128,7 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			sym->flags |= def_flags;
 			break;
 		}
+		/* fall through */
 	case S_BOOLEAN:
 		if (p[0] == 'y') {
 			sym->def[def].tri = yes;
@@ -148,6 +149,7 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			sym->type = S_STRING;
 			goto done;
 		}
+		/* fall through */
 	case S_STRING:
 		if (*p++ != '"')
 			break;
@@ -162,6 +164,7 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 			conf_warning("invalid string found");
 			return 1;
 		}
+		/* fall through */
 	case S_INT:
 	case S_HEX:
 	done:
@@ -237,6 +240,7 @@ int conf_read_simple(const char *name, int def)
 		case S_STRING:
 			if (sym->def[def].val)
 				free(sym->def[def].val);
+			/* fall through */
 		default:
 			sym->def[def].val = NULL;
 			sym->def[def].tri = no;
@@ -363,6 +367,7 @@ int conf_read(const char *name)
 					break;
 				if (!sym_is_choice(sym))
 					goto sym_ok;
+				/* fall through */
 			default:
 				if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
 					goto sym_ok;

commit 4c54f0f846102b05efcc99114ada2b913baab161
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue May 17 17:31:53 2011 +0200

    kconfig: Only generate config_is_xxx for bool and tristate options
    
    For strings and integers, the config_is_xxx macros are useless and
    sometimes misleading:
    
      #define CONFIG_INITRAMFS_SOURCE ""
      #define config_is_initramfs_source() 1
    
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index a1a9872e4a2d..d01f962e879f 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -798,7 +798,6 @@ int conf_write_autoconf(void)
 	const char *name;
 	FILE *out, *tristate, *out_h;
 	int i;
-	int fct_val;
 
 	sym_clear_all_valid();
 
@@ -839,7 +838,7 @@ int conf_write_autoconf(void)
 		       rootmenu.prompt->text);
 
 	for_all_symbols(i, sym) {
-		fct_val = 1;
+		int fct_val = 0;
 		sym_calc_value(sym);
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
@@ -853,7 +852,6 @@ int conf_write_autoconf(void)
 		case S_TRISTATE:
 			switch (sym_get_tristate_value(sym)) {
 			case no:
-				fct_val = 0;
 				break;
 			case mod:
 				fprintf(tristate, "%s%s=M\n",
@@ -868,8 +866,10 @@ int conf_write_autoconf(void)
 					    CONFIG_, sym->name);
 				fprintf(out_h, "#define %s%s 1\n",
 				    CONFIG_, sym->name);
+				fct_val = 1;
 				break;
 			}
+			conf_write_function_autoconf(out_h, CONFIG_, sym->name, fct_val);
 			break;
 		case S_STRING:
 			conf_write_string(true, sym->name, sym_get_string_value(sym), out_h);
@@ -887,10 +887,8 @@ int conf_write_autoconf(void)
 			    CONFIG_, sym->name, str);
 			break;
 		default:
-			fct_val = 0;
 			break;
 		}
-		conf_write_function_autoconf(out_h, CONFIG_, sym->name, fct_val);
 	}
 	fclose(out);
 	fclose(tristate);

commit 51f31afd12b28eddccd29a94ffbd41cb15eadd39
Merge: de125187dc17 bdebd4892e05
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue May 24 17:16:21 2011 +0200

    Merge branch 'kbuild/kconfig-for-40' into kbuild/kconfig

commit bdebd4892e05cc9068659f25af33c6b322034eb2
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun May 15 23:22:56 2011 -0400

    kconfig: do not record timestamp in .config
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 834eecb010ba..2bafd9a7c8da 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -560,8 +560,6 @@ int conf_write(const char *name)
 	const char *basename;
 	const char *str;
 	char dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];
-	time_t now;
-	int use_timestamp = 1;
 	char *env;
 
 	dirname[0] = 0;
@@ -598,19 +596,11 @@ int conf_write(const char *name)
 	if (!out)
 		return 1;
 
-	time(&now);
-	env = getenv("KCONFIG_NOTIMESTAMP");
-	if (env && *env)
-		use_timestamp = 0;
-
 	fprintf(out, _("#\n"
 		       "# Automatically generated make config: don't edit\n"
 		       "# %s\n"
-		       "%s%s"
 		       "#\n"),
-		     rootmenu.prompt->text,
-		     use_timestamp ? "# " : "",
-		     use_timestamp ? ctime(&now) : "");
+		     rootmenu.prompt->text);
 
 	if (!conf_get_changed())
 		sym_clear_all_valid();

commit de125187dc17e3715ba983adf60faecfdc3a64c4
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri May 6 07:03:49 2011 +0200

    kconfig: autogenerated config_is_xxx macro
    
    this will allow to use to use
    
            if(config_is_xxx())
            if(config_is_xxx_module())
    
    in the code instead of
    
            #ifdef CONFIG_xxx
            #ifdef CONFIG_xxx_MODULE
    
    and now let the compiler remove the non usefull code and not the
    pre-processor
    
    as done in the mach-types for arm as exmaple
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 834eecb010ba..db06af0321b3 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -778,6 +778,29 @@ static int conf_split_config(void)
 	return res;
 }
 
+static void conf_write_function_autoconf(FILE *out, char* conf, char* name,
+					 int val)
+{
+	char c;
+	char *tmp, *d;
+
+	d = strdup(conf);
+	tmp = d;
+	while ((c = *conf++))
+		*d++ = tolower(c);
+
+	fprintf(out, "#define %sis_", tmp);
+	free(tmp);
+
+	d = strdup(name);
+	tmp = d;
+	while ((c = *name++))
+		*d++ = tolower(c);
+	fprintf(out, "%s%s() %d\n", tmp, (val > 1) ? "_module" : "",
+		      val ? 1 : 0);
+	free(tmp);
+}
+
 int conf_write_autoconf(void)
 {
 	struct symbol *sym;
@@ -785,6 +808,7 @@ int conf_write_autoconf(void)
 	const char *name;
 	FILE *out, *tristate, *out_h;
 	int i;
+	int fct_val;
 
 	sym_clear_all_valid();
 
@@ -825,6 +849,7 @@ int conf_write_autoconf(void)
 		       rootmenu.prompt->text);
 
 	for_all_symbols(i, sym) {
+		fct_val = 1;
 		sym_calc_value(sym);
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
@@ -838,12 +863,14 @@ int conf_write_autoconf(void)
 		case S_TRISTATE:
 			switch (sym_get_tristate_value(sym)) {
 			case no:
+				fct_val = 0;
 				break;
 			case mod:
 				fprintf(tristate, "%s%s=M\n",
 				    CONFIG_, sym->name);
 				fprintf(out_h, "#define %s%s_MODULE 1\n",
 				    CONFIG_, sym->name);
+				fct_val = 2;
 				break;
 			case yes:
 				if (sym->type == S_TRISTATE)
@@ -870,8 +897,10 @@ int conf_write_autoconf(void)
 			    CONFIG_, sym->name, str);
 			break;
 		default:
+			fct_val = 0;
 			break;
 		}
+		conf_write_function_autoconf(out_h, CONFIG_, sym->name, fct_val);
 	}
 	fclose(out);
 	fclose(tristate);

commit c33724a43875786719f51916311308f2752d846e
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Apr 28 15:05:20 2009 +0200

    kconfig: Do not record timestamp in auto.conf and autoconf.h
    
    Timestamps in file data are useless and there is already one in .config
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 61c35bf2d9cb..834eecb010ba 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -784,7 +784,6 @@ int conf_write_autoconf(void)
 	const char *str;
 	const char *name;
 	FILE *out, *tristate, *out_h;
-	time_t now;
 	int i;
 
 	sym_clear_all_valid();
@@ -811,22 +810,19 @@ int conf_write_autoconf(void)
 		return 1;
 	}
 
-	time(&now);
 	fprintf(out, "#\n"
 		     "# Automatically generated make config: don't edit\n"
 		     "# %s\n"
-		     "# %s"
 		     "#\n",
-		     rootmenu.prompt->text, ctime(&now));
+		     rootmenu.prompt->text);
 	fprintf(tristate, "#\n"
 			  "# Automatically generated - do not edit\n"
 			  "\n");
 	fprintf(out_h, "/*\n"
 		       " * Automatically generated C config: don't edit\n"
 		       " * %s\n"
-		       " * %s"
 		       " */\n",
-		       rootmenu.prompt->text, ctime(&now));
+		       rootmenu.prompt->text);
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);

commit 579fb8e741fecef7dfd64afcc7b0b0c68ea207cc
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Dec 5 01:41:16 2010 -0500

    kconfig: fix typos
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index d1bab0f42d10..61c35bf2d9cb 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -937,7 +937,7 @@ static void randomize_choice_values(struct symbol *csym)
 	int cnt, def;
 
 	/*
-	 * If choice is mod then we may have more items slected
+	 * If choice is mod then we may have more items selected
 	 * and if no then no-one.
 	 * In both cases stop.
 	 */
@@ -1033,10 +1033,10 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	/*
 	 * We have different type of choice blocks.
-	 * If curr.tri equal to mod then we can select several
+	 * If curr.tri equals to mod then we can select several
 	 * choice symbols in one block.
 	 * In this case we do nothing.
-	 * If curr.tri equal yes then only one symbol can be
+	 * If curr.tri equals yes then only one symbol can be
 	 * selected in a choice block and we set it to yes,
 	 * and the rest to no.
 	 */

commit 0dce631092f410bb22b21b3d47ef20d69389dfd9
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Dec 5 01:33:16 2010 -0500

    kconfig: nuke second argument of conf_write_symbol()
    
    Replacing S_TRISTATE by S_BOOLEAN is a no-op for conf_write_symbol().
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    [mmarek: Fix unused variable warning in conf_write()]
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index f349bdcffa98..d1bab0f42d10 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -440,12 +440,11 @@ static void conf_write_string(bool headerfile, const char *name,
 	fputs("\"\n", out);
 }
 
-static void conf_write_symbol(struct symbol *sym, enum symbol_type type,
-                              FILE *out, bool write_no)
+static void conf_write_symbol(struct symbol *sym, FILE *out, bool write_no)
 {
 	const char *str;
 
-	switch (type) {
+	switch (sym->type) {
 	case S_BOOLEAN:
 	case S_TRISTATE:
 		switch (sym_get_tristate_value(sym)) {
@@ -532,7 +531,7 @@ int conf_write_defconfig(const char *filename)
 						goto next_menu;
 				}
 			}
-			conf_write_symbol(sym, sym->type, out, true);
+			conf_write_symbol(sym, out, true);
 		}
 next_menu:
 		if (menu->list != NULL) {
@@ -561,7 +560,6 @@ int conf_write(const char *name)
 	const char *basename;
 	const char *str;
 	char dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];
-	enum symbol_type type;
 	time_t now;
 	int use_timestamp = 1;
 	char *env;
@@ -633,14 +631,8 @@ int conf_write(const char *name)
 			if (!(sym->flags & SYMBOL_WRITE))
 				goto next;
 			sym->flags &= ~SYMBOL_WRITE;
-			type = sym->type;
-			if (type == S_TRISTATE) {
-				sym_calc_value(modules_sym);
-				if (modules_sym->curr.tri == no)
-					type = S_BOOLEAN;
-			}
 			/* Write config symbol to file */
-			conf_write_symbol(sym, type, out, true);
+			conf_write_symbol(sym, out, true);
 		}
 
 next:
@@ -842,7 +834,7 @@ int conf_write_autoconf(void)
 			continue;
 
 		/* write symbol to config file */
-		conf_write_symbol(sym, sym->type, out, false);
+		conf_write_symbol(sym, out, false);
 
 		/* update autoconf and tristate files */
 		switch (sym->type) {

commit 6e71fabe9e60b1c6db587fbeac349848647920ab
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Dec 5 01:31:57 2010 -0500

    kconfig: do not define AUTOCONF_INCLUDED
    
    AUTOCONF_INCLUDED is not checked is not used within the tree and its parent
    header, `autoconf.h', is safe to be re-included.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 9df80114b47b..f349bdcffa98 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -833,8 +833,7 @@ int conf_write_autoconf(void)
 		       " * Automatically generated C config: don't edit\n"
 		       " * %s\n"
 		       " * %s"
-		       " */\n"
-		       "#define AUTOCONF_INCLUDED\n",
+		       " */\n",
 		       rootmenu.prompt->text, ctime(&now));
 
 	for_all_symbols(i, sym) {

commit 70c74e59db7450d5c9164abeb3b6752f8045288b
Merge: b3235fe420ed 42368c37fbd5
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Oct 28 00:54:25 2010 +0200

    Merge branch 'message-callback' into kbuild/kconfig
    
    Conflicts:
            scripts/kconfig/nconf.c

commit 1408b15b98635a13bad2e2a50b3c2ae2ccdf625b
Author: Will Newton <will.newton@gmail.com>
Date:   Wed Sep 22 15:59:13 2010 +0100

    kconfig: Use PATH_MAX instead of 128 for path buffer sizes.
    
    This prevents the buffers being overflowed when using a config
    file with a long name. PATH_MAX is used elsewhere in the same
    file, so use it here as well.
    
    Signed-off-by: Will Newton <will.newton@imgtec.com>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 35c08ecaad17..96110ea41cf3 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -535,7 +535,7 @@ int conf_write(const char *name)
 	struct menu *menu;
 	const char *basename;
 	const char *str;
-	char dirname[128], tmpname[128], newname[128];
+	char dirname[PATH_MAX+1], tmpname[PATH_MAX+1], newname[PATH_MAX+1];
 	enum symbol_type type;
 	time_t now;
 	int use_timestamp = 1;
@@ -654,7 +654,7 @@ int conf_write(const char *name)
 static int conf_split_config(void)
 {
 	const char *name;
-	char path[128];
+	char path[PATH_MAX+1];
 	char *s, *d, c;
 	struct symbol *sym;
 	struct stat sb;

commit 8bea7548ee0223175bea5fddcc54af93bd252d9b
Author: Naohiro Aota <naota@elisp.net>
Date:   Fri Oct 1 04:23:17 2010 +0900

    kconfig: Don't go out from read config loop when you read new symbol
    
    commit 8baefd30b5b0101aa07aa75da44a9eee881eed28 of linux-next replaced
    a `switch()' statement with some `if()' statements, but left `break's
    in the `switch()' statement untouched. This cause read config loop to
    exit and so "make oldconfig" is not much usable (see below).
    
    > $ make oldconfig
    ><snip>
    > scripts/kconfig/conf --oldconfig Kconfig
    > #
    > # using defaults found in /boot/config-2.6.34-ccs-r1
    > #
    > *
    > * Restart config...
    > *
    > *
    > * General setup
    > *
    > Prompt for development and/or incomplete code/drivers (EXPERIMENTAL) [N/y/?] (NEW)
    
    (I've already have "CONFIG_EXPERIMENTAL=y" in the old config file. But
    that's not read here.)
    
    This patch should fix this problem.
    
    Signed-off-by: Naohiro Aota <naota@elisp.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index f7d89d7065b7..35c08ecaad17 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -234,7 +234,7 @@ int conf_read_simple(const char *name, int def)
 				sym = sym_find(line + 2 + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
-					break;
+					goto setsym;
 				}
 			} else {
 				sym = sym_lookup(line + 2 + strlen(CONFIG_), 0);
@@ -268,7 +268,7 @@ int conf_read_simple(const char *name, int def)
 				sym = sym_find(line + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
-					break;
+					goto setsym;
 				}
 			} else {
 				sym = sym_lookup(line + strlen(CONFIG_), 0);
@@ -285,6 +285,7 @@ int conf_read_simple(const char *name, int def)
 				conf_warning("unexpected data");
 			continue;
 		}
+setsym:
 		if (sym && sym_is_choice_value(sym)) {
 			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
 			switch (sym->def[def].tri) {

commit 0954828fcbf3bd13d593499b16b901a4e801b0b9
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Aug 18 01:57:13 2010 -0400

    kconfig: replace KERNELVERSION usage by the mainmenu's prompt
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 9f3c8899da5a..f7d89d7065b7 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -574,8 +574,6 @@ int conf_write(const char *name)
 	if (!out)
 		return 1;
 
-	sym = sym_lookup("KERNELVERSION", 0);
-	sym_calc_value(sym);
 	time(&now);
 	env = getenv("KCONFIG_NOTIMESTAMP");
 	if (env && *env)
@@ -583,10 +581,10 @@ int conf_write(const char *name)
 
 	fprintf(out, _("#\n"
 		       "# Automatically generated make config: don't edit\n"
-		       "# Linux kernel version: %s\n"
+		       "# %s\n"
 		       "%s%s"
 		       "#\n"),
-		     sym_get_string_value(sym),
+		     rootmenu.prompt->text,
 		     use_timestamp ? "# " : "",
 		     use_timestamp ? ctime(&now) : "");
 
@@ -797,25 +795,23 @@ int conf_write_autoconf(void)
 		return 1;
 	}
 
-	sym = sym_lookup("KERNELVERSION", 0);
-	sym_calc_value(sym);
 	time(&now);
 	fprintf(out, "#\n"
 		     "# Automatically generated make config: don't edit\n"
-		     "# Linux kernel version: %s\n"
+		     "# %s\n"
 		     "# %s"
 		     "#\n",
-		     sym_get_string_value(sym), ctime(&now));
+		     rootmenu.prompt->text, ctime(&now));
 	fprintf(tristate, "#\n"
 			  "# Automatically generated - do not edit\n"
 			  "\n");
 	fprintf(out_h, "/*\n"
 		       " * Automatically generated C config: don't edit\n"
-		       " * Linux kernel version: %s\n"
+		       " * %s\n"
 		       " * %s"
 		       " */\n"
 		       "#define AUTOCONF_INCLUDED\n",
-		       sym_get_string_value(sym), ctime(&now));
+		       rootmenu.prompt->text, ctime(&now));
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);

commit ffb5957bc48f64f0773fd3fbc43cb9bb9b38e270
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sat Aug 14 23:57:43 2010 -0400

    kconfig: allow build-time definition of the internal config prefix
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index d9181de78927..9f3c8899da5a 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -222,22 +222,22 @@ int conf_read_simple(const char *name, int def)
 		conf_lineno++;
 		sym = NULL;
 		if (line[0] == '#') {
-			if (memcmp(line + 2, "CONFIG_", 7))
+			if (memcmp(line + 2, CONFIG_, strlen(CONFIG_)))
 				continue;
-			p = strchr(line + 9, ' ');
+			p = strchr(line + 2 + strlen(CONFIG_), ' ');
 			if (!p)
 				continue;
 			*p++ = 0;
 			if (strncmp(p, "is not set", 10))
 				continue;
 			if (def == S_DEF_USER) {
-				sym = sym_find(line + 9);
+				sym = sym_find(line + 2 + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
 					break;
 				}
 			} else {
-				sym = sym_lookup(line + 9, 0);
+				sym = sym_lookup(line + 2 + strlen(CONFIG_), 0);
 				if (sym->type == S_UNKNOWN)
 					sym->type = S_BOOLEAN;
 			}
@@ -253,8 +253,8 @@ int conf_read_simple(const char *name, int def)
 			default:
 				;
 			}
-		} else if (memcmp(line, "CONFIG_", 7) == 0) {
-			p = strchr(line + 7, '=');
+		} else if (memcmp(line, CONFIG_, strlen(CONFIG_)) == 0) {
+			p = strchr(line + strlen(CONFIG_), '=');
 			if (!p)
 				continue;
 			*p++ = 0;
@@ -265,13 +265,13 @@ int conf_read_simple(const char *name, int def)
 					*p2 = 0;
 			}
 			if (def == S_DEF_USER) {
-				sym = sym_find(line + 7);
+				sym = sym_find(line + strlen(CONFIG_));
 				if (!sym) {
 					sym_add_change_count(1);
 					break;
 				}
 			} else {
-				sym = sym_lookup(line + 7, 0);
+				sym = sym_lookup(line + strlen(CONFIG_), 0);
 				if (sym->type == S_UNKNOWN)
 					sym->type = S_OTHER;
 			}
@@ -397,9 +397,9 @@ static void conf_write_string(bool headerfile, const char *name,
 {
 	int l;
 	if (headerfile)
-		fprintf(out, "#define CONFIG_%s \"", name);
+		fprintf(out, "#define %s%s \"", CONFIG_, name);
 	else
-		fprintf(out, "CONFIG_%s=\"", name);
+		fprintf(out, "%s%s=\"", CONFIG_, name);
 
 	while (1) {
 		l = strcspn(str, "\"\\");
@@ -425,13 +425,14 @@ static void conf_write_symbol(struct symbol *sym, enum symbol_type type,
 		switch (sym_get_tristate_value(sym)) {
 		case no:
 			if (write_no)
-				fprintf(out, "# CONFIG_%s is not set\n", sym->name);
+				fprintf(out, "# %s%s is not set\n",
+				    CONFIG_, sym->name);
 			break;
 		case mod:
-			fprintf(out, "CONFIG_%s=m\n", sym->name);
+			fprintf(out, "%s%s=m\n", CONFIG_, sym->name);
 			break;
 		case yes:
-			fprintf(out, "CONFIG_%s=y\n", sym->name);
+			fprintf(out, "%s%s=y\n", CONFIG_, sym->name);
 			break;
 		}
 		break;
@@ -441,7 +442,7 @@ static void conf_write_symbol(struct symbol *sym, enum symbol_type type,
 	case S_HEX:
 	case S_INT:
 		str = sym_get_string_value(sym);
-		fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+		fprintf(out, "%s%s=%s\n", CONFIG_, sym->name, str);
 		break;
 	case S_OTHER:
 	case S_UNKNOWN:
@@ -832,14 +833,17 @@ int conf_write_autoconf(void)
 			case no:
 				break;
 			case mod:
-				fprintf(tristate, "CONFIG_%s=M\n", sym->name);
-				fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
+				fprintf(tristate, "%s%s=M\n",
+				    CONFIG_, sym->name);
+				fprintf(out_h, "#define %s%s_MODULE 1\n",
+				    CONFIG_, sym->name);
 				break;
 			case yes:
 				if (sym->type == S_TRISTATE)
-					fprintf(tristate, "CONFIG_%s=Y\n",
-							sym->name);
-				fprintf(out_h, "#define CONFIG_%s 1\n", sym->name);
+					fprintf(tristate,"%s%s=Y\n",
+					    CONFIG_, sym->name);
+				fprintf(out_h, "#define %s%s 1\n",
+				    CONFIG_, sym->name);
 				break;
 			}
 			break;
@@ -849,12 +853,14 @@ int conf_write_autoconf(void)
 		case S_HEX:
 			str = sym_get_string_value(sym);
 			if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
-				fprintf(out_h, "#define CONFIG_%s 0x%s\n", sym->name, str);
+				fprintf(out_h, "#define %s%s 0x%s\n",
+				    CONFIG_, sym->name, str);
 				break;
 			}
 		case S_INT:
 			str = sym_get_string_value(sym);
-			fprintf(out_h, "#define CONFIG_%s %s\n", sym->name, str);
+			fprintf(out_h, "#define %s%s %s\n",
+			    CONFIG_, sym->name, str);
 			break;
 		default:
 			break;

commit 8baefd30b5b0101aa07aa75da44a9eee881eed28
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Tue Aug 24 00:14:47 2010 -0400

    kconfig: replace a `switch()' statement by a more flexible `if()' statement
    
    With the upcoming dynamical configuration prefix, we can no longer assume that
    the prefix will start by a 'C'. As such, we can no longer hardcode this value in
    the `case ...:', so replace the `switch() { ... }' statement by a more flexible
    'if () { ... }' statement.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index dc11d51bd8b3..d9181de78927 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -221,8 +221,7 @@ int conf_read_simple(const char *name, int def)
 	while (fgets(line, sizeof(line), in)) {
 		conf_lineno++;
 		sym = NULL;
-		switch (line[0]) {
-		case '#':
+		if (line[0] == '#') {
 			if (memcmp(line + 2, "CONFIG_", 7))
 				continue;
 			p = strchr(line + 9, ' ');
@@ -254,12 +253,7 @@ int conf_read_simple(const char *name, int def)
 			default:
 				;
 			}
-			break;
-		case 'C':
-			if (memcmp(line, "CONFIG_", 7)) {
-				conf_warning("unexpected data");
-				continue;
-			}
+		} else if (memcmp(line, "CONFIG_", 7) == 0) {
 			p = strchr(line + 7, '=');
 			if (!p)
 				continue;
@@ -286,12 +280,9 @@ int conf_read_simple(const char *name, int def)
 			}
 			if (conf_set_sym_val(sym, def, def_flags, p))
 				continue;
-			break;
-		case '\r':
-		case '\n':
-			break;
-		default:
-			conf_warning("unexpected data");
+		} else {
+			if (line[0] != '\r' && line[0] != '\n')
+				conf_warning("unexpected data");
 			continue;
 		}
 		if (sym && sym_is_choice_value(sym)) {

commit 42368c37fbd51f7b478d041ae55c5df000897158
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Aug 17 10:21:19 2010 +0200

    kconfig: Allow frontends to display messages themselves
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index dc11d51bd8b3..c07060ab7820 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -19,6 +19,9 @@
 static void conf_warning(const char *fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
+static void conf_message(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
 static const char *conf_filename;
 static int conf_lineno, conf_warnings, conf_unsaved;
 
@@ -35,6 +38,29 @@ static void conf_warning(const char *fmt, ...)
 	conf_warnings++;
 }
 
+static void conf_default_message_callback(const char *fmt, va_list ap)
+{
+	printf("#\n# ");
+	vprintf(fmt, ap);
+	printf("\n#\n");
+}
+
+static void (*conf_message_callback) (const char *fmt, va_list ap) =
+	conf_default_message_callback;
+void conf_set_message_callback(void (*fn) (const char *fmt, va_list ap))
+{
+	conf_message_callback = fn;
+}
+
+static void conf_message(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	if (conf_message_callback)
+		conf_message_callback(fmt, ap);
+}
+
 const char *conf_get_configname(void)
 {
 	char *name = getenv("KCONFIG_CONFIG");
@@ -184,9 +210,8 @@ int conf_read_simple(const char *name, int def)
 			name = conf_expand_value(prop->expr->left.sym->name);
 			in = zconf_fopen(name);
 			if (in) {
-				printf(_("#\n"
-					 "# using defaults found in %s\n"
-					 "#\n"), name);
+				conf_message(_("using defaults found in %s"),
+					 name);
 				goto load;
 			}
 		}
@@ -651,9 +676,7 @@ int conf_write(const char *name)
 			return 1;
 	}
 
-	printf(_("#\n"
-		 "# configuration written to %s\n"
-		 "#\n"), newname);
+	conf_message(_("configuration written to %s"), newname);
 
 	sym_set_change_count(0);
 

commit 94bedeca77bf79a81952ed4c3abb8c1cce4c85dd
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Tue Aug 17 01:40:20 2010 -0400

    kbuild: confdata.c explicitly reference errno, thus need <errno.h>
    
    This fixes:
    % gmake LKC_GENPARSER=1 menuconfig
    [...]
    scripts/kconfig/confdata.c:739: error: 'errno' undeclared (first use in this function)
    scripts/kconfig/confdata.c:739: error: (Each undeclared identifier is reported only once
    scripts/kconfig/confdata.c:739: error: for each function it appears in.)
    scripts/kconfig/confdata.c:739: error: 'ENOENT' undeclared (first use in this function)
    
    triggered on NetBSD.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 515253fe46cf..dc11d51bd8b3 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -5,6 +5,7 @@
 
 #include <sys/stat.h>
 #include <ctype.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>

commit 84062dd3a6a045395a43de1d9adc9b8eb2d1426e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Aug 14 23:22:16 2010 +0200

    kconfig: fix savedefconfig with choice marked optional
    
    savedefconfig failed to save the correct minimal config
    when it encountered a choice marked optional.
    
    Consider following minimal configuration:
    $cat Kconfig
    choice
            prompt "choice"
            optional
    
    config A
            bool "a"
    
    config B
            bool "b"
    
    endchoice
    
    $cat .config | grep -v ^#
    CONFIG_A=y
    
    $conf --savedefconfig=defconfig Kconfig
    
    would before this fix result in an empty file, because
    kconfig would assume that CONFIG_A=y is a default value.
    But because the choice is optional the default is that
    both A and B are =n.
    
    Fix so we handle optional choices correct.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c39327e60ea4..515253fe46cf 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -497,7 +497,9 @@ int conf_write_defconfig(const char *filename)
 			/*
 			 * If symbol is a choice value and equals to the
 			 * default for a choice - skip.
-			 * But only if value is bool and equal to "y" .
+			 * But only if value is bool and equal to "y" and
+			 * choice is not "optional".
+			 * (If choice is "optional" then all values can be "n")
 			 */
 			if (sym_is_choice_value(sym)) {
 				struct symbol *cs;
@@ -505,7 +507,7 @@ int conf_write_defconfig(const char *filename)
 
 				cs = prop_get_symbol(sym_get_choice_prop(sym));
 				ds = sym_choice_default(cs);
-				if (sym == ds) {
+				if (!sym_is_optional(cs) && sym == ds) {
 					if ((sym->type == S_BOOLEAN) &&
 					    sym_get_tristate_value(sym) == yes)
 						goto next_menu;

commit bf5e327a300a9ac959a89440e7c67dc89f3bd804
Author: Jean Sacren <sakiwit@gmail.com>
Date:   Wed Aug 4 16:01:02 2010 -0600

    kconfig: Fix warning: ignoring return value of 'fwrite'
    
    This fix facilitates fwrite() in both confdata.c and expr.c, either it
    succeeds in writing, or an error occurs, or the end of file is reached.
    
    Signed-off-by: Jean Sacren <sakiwit@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ac13f0ff8e81..c39327e60ea4 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -412,7 +412,7 @@ static void conf_write_string(bool headerfile, const char *name,
 	while (1) {
 		l = strcspn(str, "\"\\");
 		if (l) {
-			fwrite(str, l, 1, out);
+			xfwrite(str, l, 1, out);
 			str += l;
 		}
 		if (!*str)

commit a64b44ead002ba15fdf841106a6fd344b8dd46d8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Aug 12 09:11:52 2010 +0200

    kconfig: fix tristate choice with minimal config
    
    If a minimal config did not specify the value
    of all choice values, the resulting configuration
    could have wrong values.
    
    Consider following example:
    config M
            def_bool y
            option modules
    choice
            prompt "choice list"
    config A
            tristate "a"
    config B
            tristate "b"
    endchoice
    
    With a defconfig like this:
    CONFIG_M=y
    CONFIG_A=y
    
    The resulting configuration would have
    
        CONFIG_A=m
    
    which was unexpected.
    
    The problem was not not all choice values were set and thus
    kconfig calculated a wrong value.
    
    The fix is to set all choice values when we
    read a defconfig files.
    
    conf_set_all_new_symbols() is refactored such that
    random choice values are now handled by a dedicated function.
    And new choice values are set by set_all_choice_values().
    
    This was not the minimal fix, but the fix that resulted
    in the most readable code.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Arve Hjønnevåg <arve@android.com>
    Tested-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index e5d66e4f1484..ac13f0ff8e81 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -918,13 +918,73 @@ void conf_set_changed_callback(void (*fn)(void))
 	conf_changed_callback = fn;
 }
 
+static void randomize_choice_values(struct symbol *csym)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct expr *e;
+	int cnt, def;
 
-void conf_set_all_new_symbols(enum conf_def_mode mode)
+	/*
+	 * If choice is mod then we may have more items slected
+	 * and if no then no-one.
+	 * In both cases stop.
+	 */
+	if (csym->curr.tri != yes)
+		return;
+
+	prop = sym_get_choice_prop(csym);
+
+	/* count entries in choice block */
+	cnt = 0;
+	expr_list_for_each_sym(prop->expr, e, sym)
+		cnt++;
+
+	/*
+	 * find a random value and set it to yes,
+	 * set the rest to no so we have only one set
+	 */
+	def = (rand() % cnt);
+
+	cnt = 0;
+	expr_list_for_each_sym(prop->expr, e, sym) {
+		if (def == cnt++) {
+			sym->def[S_DEF_USER].tri = yes;
+			csym->def[S_DEF_USER].val = sym;
+		}
+		else {
+			sym->def[S_DEF_USER].tri = no;
+		}
+	}
+	csym->flags |= SYMBOL_DEF_USER;
+	/* clear VALID to get value calculated */
+	csym->flags &= ~(SYMBOL_VALID);
+}
+
+static void set_all_choice_values(struct symbol *csym)
 {
-	struct symbol *sym, *csym;
 	struct property *prop;
+	struct symbol *sym;
 	struct expr *e;
-	int i, cnt, def;
+
+	prop = sym_get_choice_prop(csym);
+
+	/*
+	 * Set all non-assinged choice values to no
+	 */
+	expr_list_for_each_sym(prop->expr, e, sym) {
+		if (!sym_has_value(sym))
+			sym->def[S_DEF_USER].tri = no;
+	}
+	csym->flags |= SYMBOL_DEF_USER;
+	/* clear VALID to get value calculated */
+	csym->flags &= ~(SYMBOL_VALID);
+}
+
+void conf_set_all_new_symbols(enum conf_def_mode mode)
+{
+	struct symbol *sym, *csym;
+	int i, cnt;
 
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym))
@@ -960,8 +1020,6 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	sym_clear_all_valid();
 
-	if (mode != def_random)
-		return;
 	/*
 	 * We have different type of choice blocks.
 	 * If curr.tri equal to mod then we can select several
@@ -976,35 +1034,9 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 			continue;
 
 		sym_calc_value(csym);
-
-		if (csym->curr.tri != yes)
-			continue;
-
-		prop = sym_get_choice_prop(csym);
-
-		/* count entries in choice block */
-		cnt = 0;
-		expr_list_for_each_sym(prop->expr, e, sym)
-			cnt++;
-
-		/*
-		 * find a random value and set it to yes,
-		 * set the rest to no so we have only one set
-		 */
-		def = (rand() % cnt);
-
-		cnt = 0;
-		expr_list_for_each_sym(prop->expr, e, sym) {
-			if (def == cnt++) {
-				sym->def[S_DEF_USER].tri = yes;
-				csym->def[S_DEF_USER].val = sym;
-			}
-			else {
-				sym->def[S_DEF_USER].tri = no;
-			}
-		}
-		csym->flags |= SYMBOL_DEF_USER;
-		/* clear VALID to get value calculated */
-		csym->flags &= ~(SYMBOL_VALID);
+		if (mode == def_random)
+			randomize_choice_values(csym);
+		else
+			set_all_choice_values(csym);
 	}
 }

commit 801690caf1894d4f8b1277ca9f5dcf0bcf9b3f58
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Aug 12 09:11:51 2010 +0200

    kconfig: fix savedefconfig for tristate choices
    
    savedefconfig failed to save choice symbols equal to 'y'
    for tristate choices.
    This resulted in this value being lost.
    
    In particular is fixes an issue where
    
            make ARCH=avr32 atngw100_defconfig
            make ARCH=avr32 savedefconfig
            cp defconfig arch/avr32/configs/atngw100_defconfig
            make ARCH=avr32 atngw100_defconfig
            diff -u .config .config.old
    
    failed to produce an identical .config.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index f81f263b64f2..e5d66e4f1484 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -497,7 +497,7 @@ int conf_write_defconfig(const char *filename)
 			/*
 			 * If symbol is a choice value and equals to the
 			 * default for a choice - skip.
-			 * But only if value equal to "y".
+			 * But only if value is bool and equal to "y" .
 			 */
 			if (sym_is_choice_value(sym)) {
 				struct symbol *cs;
@@ -506,9 +506,8 @@ int conf_write_defconfig(const char *filename)
 				cs = prop_get_symbol(sym_get_choice_prop(sym));
 				ds = sym_choice_default(cs);
 				if (sym == ds) {
-					if ((sym->type == S_BOOLEAN ||
-					sym->type == S_TRISTATE) &&
-					sym_get_tristate_value(sym) == yes)
+					if ((sym->type == S_BOOLEAN) &&
+					    sym_get_tristate_value(sym) == yes)
 						goto next_menu;
 				}
 			}

commit 7cf3d73b4360e91b14326632ab1aeda4cb26308d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:34 2010 +0200

    kconfig: add savedefconfig
    
    savedefconfig will save a minimal config to a file
    named "defconfig".
    
    The config symbols are saved in the same order as
    they appear in the menu structure so it should
    be possible to map them to the relevant menus
    if desired.
    
    The implementation was tested against several minimal
    configs for arm which was created using brute-force.
    
    There was one regression related to default numbers
    which had their valid range further limited by another symbol.
    
    Sample:
    
    config FOO
            int "foo"
            default 4
    
    config BAR
            int "bar"
            range 0 FOO
    
    If FOO is set to 3 then BAR cannot take a value higher than 3.
    But the current implementation will set BAR equal to 4.
    
    This is seldomly used and the final configuration is OK,
    and the fix was non-trivial.
    So it was documented in the code and left as is.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 583f6405f01d..f81f263b64f2 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -457,6 +457,82 @@ static void conf_write_symbol(struct symbol *sym, enum symbol_type type,
 	}
 }
 
+/*
+ * Write out a minimal config.
+ * All values that has default values are skipped as this is redundant.
+ */
+int conf_write_defconfig(const char *filename)
+{
+	struct symbol *sym;
+	struct menu *menu;
+	FILE *out;
+
+	out = fopen(filename, "w");
+	if (!out)
+		return 1;
+
+	sym_clear_all_valid();
+
+	/* Traverse all menus to find all relevant symbols */
+	menu = rootmenu.list;
+
+	while (menu != NULL)
+	{
+		sym = menu->sym;
+		if (sym == NULL) {
+			if (!menu_is_visible(menu))
+				goto next_menu;
+		} else if (!sym_is_choice(sym)) {
+			sym_calc_value(sym);
+			if (!(sym->flags & SYMBOL_WRITE))
+				goto next_menu;
+			sym->flags &= ~SYMBOL_WRITE;
+			/* If we cannot change the symbol - skip */
+			if (!sym_is_changable(sym))
+				goto next_menu;
+			/* If symbol equals to default value - skip */
+			if (strcmp(sym_get_string_value(sym), sym_get_string_default(sym)) == 0)
+				goto next_menu;
+
+			/*
+			 * If symbol is a choice value and equals to the
+			 * default for a choice - skip.
+			 * But only if value equal to "y".
+			 */
+			if (sym_is_choice_value(sym)) {
+				struct symbol *cs;
+				struct symbol *ds;
+
+				cs = prop_get_symbol(sym_get_choice_prop(sym));
+				ds = sym_choice_default(cs);
+				if (sym == ds) {
+					if ((sym->type == S_BOOLEAN ||
+					sym->type == S_TRISTATE) &&
+					sym_get_tristate_value(sym) == yes)
+						goto next_menu;
+				}
+			}
+			conf_write_symbol(sym, sym->type, out, true);
+		}
+next_menu:
+		if (menu->list != NULL) {
+			menu = menu->list;
+		}
+		else if (menu->next != NULL) {
+			menu = menu->next;
+		} else {
+			while ((menu = menu->parent)) {
+				if (menu->next != NULL) {
+					menu = menu->next;
+					break;
+				}
+			}
+		}
+	}
+	fclose(out);
+	return 0;
+}
+
 int conf_write(const char *name)
 {
 	FILE *out;

commit 49192f266ffa187bd7adaf5c2d881f85bd53e0ed
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:33 2010 +0200

    kconfig: code refactoring in confdata.c
    
    Add a a few local functions to avoid some code duplication
    No functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 8dce5862550d..583f6405f01d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -399,15 +399,73 @@ int conf_read(const char *name)
 	return 0;
 }
 
+/* Write a S_STRING */
+static void conf_write_string(bool headerfile, const char *name,
+                              const char *str, FILE *out)
+{
+	int l;
+	if (headerfile)
+		fprintf(out, "#define CONFIG_%s \"", name);
+	else
+		fprintf(out, "CONFIG_%s=\"", name);
+
+	while (1) {
+		l = strcspn(str, "\"\\");
+		if (l) {
+			fwrite(str, l, 1, out);
+			str += l;
+		}
+		if (!*str)
+			break;
+		fprintf(out, "\\%c", *str++);
+	}
+	fputs("\"\n", out);
+}
+
+static void conf_write_symbol(struct symbol *sym, enum symbol_type type,
+                              FILE *out, bool write_no)
+{
+	const char *str;
+
+	switch (type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (sym_get_tristate_value(sym)) {
+		case no:
+			if (write_no)
+				fprintf(out, "# CONFIG_%s is not set\n", sym->name);
+			break;
+		case mod:
+			fprintf(out, "CONFIG_%s=m\n", sym->name);
+			break;
+		case yes:
+			fprintf(out, "CONFIG_%s=y\n", sym->name);
+			break;
+		}
+		break;
+	case S_STRING:
+		conf_write_string(false, sym->name, sym_get_string_value(sym), out);
+		break;
+	case S_HEX:
+	case S_INT:
+		str = sym_get_string_value(sym);
+		fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+		break;
+	case S_OTHER:
+	case S_UNKNOWN:
+		break;
+	}
+}
+
 int conf_write(const char *name)
 {
 	FILE *out;
 	struct symbol *sym;
 	struct menu *menu;
 	const char *basename;
-	char dirname[128], tmpname[128], newname[128];
-	int type, l;
 	const char *str;
+	char dirname[128], tmpname[128], newname[128];
+	enum symbol_type type;
 	time_t now;
 	int use_timestamp = 1;
 	char *env;
@@ -487,50 +545,11 @@ int conf_write(const char *name)
 				if (modules_sym->curr.tri == no)
 					type = S_BOOLEAN;
 			}
-			switch (type) {
-			case S_BOOLEAN:
-			case S_TRISTATE:
-				switch (sym_get_tristate_value(sym)) {
-				case no:
-					fprintf(out, "# CONFIG_%s is not set\n", sym->name);
-					break;
-				case mod:
-					fprintf(out, "CONFIG_%s=m\n", sym->name);
-					break;
-				case yes:
-					fprintf(out, "CONFIG_%s=y\n", sym->name);
-					break;
-				}
-				break;
-			case S_STRING:
-				str = sym_get_string_value(sym);
-				fprintf(out, "CONFIG_%s=\"", sym->name);
-				while (1) {
-					l = strcspn(str, "\"\\");
-					if (l) {
-						fwrite(str, l, 1, out);
-						str += l;
-					}
-					if (!*str)
-						break;
-					fprintf(out, "\\%c", *str++);
-				}
-				fputs("\"\n", out);
-				break;
-			case S_HEX:
-				str = sym_get_string_value(sym);
-				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
-					fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
-					break;
-				}
-			case S_INT:
-				str = sym_get_string_value(sym);
-				fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
-				break;
-			}
+			/* Write config symbol to file */
+			conf_write_symbol(sym, type, out, true);
 		}
 
-	next:
+next:
 		if (menu->list) {
 			menu = menu->list;
 			continue;
@@ -682,7 +701,7 @@ int conf_write_autoconf(void)
 	const char *name;
 	FILE *out, *tristate, *out_h;
 	time_t now;
-	int i, l;
+	int i;
 
 	sym_clear_all_valid();
 
@@ -732,6 +751,11 @@ int conf_write_autoconf(void)
 		sym_calc_value(sym);
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
 			continue;
+
+		/* write symbol to config file */
+		conf_write_symbol(sym, sym->type, out, false);
+
+		/* update autoconf and tristate files */
 		switch (sym->type) {
 		case S_BOOLEAN:
 		case S_TRISTATE:
@@ -739,12 +763,10 @@ int conf_write_autoconf(void)
 			case no:
 				break;
 			case mod:
-				fprintf(out, "CONFIG_%s=m\n", sym->name);
 				fprintf(tristate, "CONFIG_%s=M\n", sym->name);
 				fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
 				break;
 			case yes:
-				fprintf(out, "CONFIG_%s=y\n", sym->name);
 				if (sym->type == S_TRISTATE)
 					fprintf(tristate, "CONFIG_%s=Y\n",
 							sym->name);
@@ -753,35 +775,16 @@ int conf_write_autoconf(void)
 			}
 			break;
 		case S_STRING:
-			str = sym_get_string_value(sym);
-			fprintf(out, "CONFIG_%s=\"", sym->name);
-			fprintf(out_h, "#define CONFIG_%s \"", sym->name);
-			while (1) {
-				l = strcspn(str, "\"\\");
-				if (l) {
-					fwrite(str, l, 1, out);
-					fwrite(str, l, 1, out_h);
-					str += l;
-				}
-				if (!*str)
-					break;
-				fprintf(out, "\\%c", *str);
-				fprintf(out_h, "\\%c", *str);
-				str++;
-			}
-			fputs("\"\n", out);
-			fputs("\"\n", out_h);
+			conf_write_string(true, sym->name, sym_get_string_value(sym), out_h);
 			break;
 		case S_HEX:
 			str = sym_get_string_value(sym);
 			if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
-				fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
 				fprintf(out_h, "#define CONFIG_%s 0x%s\n", sym->name, str);
 				break;
 			}
 		case S_INT:
 			str = sym_get_string_value(sym);
-			fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
 			fprintf(out_h, "#define CONFIG_%s %s\n", sym->name, str);
 			break;
 		default:

commit ac1ffde1ba053db0266f886a15ed845a6628fcb0
Author: Ulf Magnusson <ulfalizer.lkml@gmail.com>
Date:   Tue Jul 27 21:57:43 2010 +0200

    kconfig: fix MODULES-related bug in case of no .config
    
    There seems to be a kconfig bug due to MODULES not always being
    evaluated if no .config is found. Take the following Kconfig as an
    example:
    
    config MODULES
            def_bool y
    
    config FOO
            def_tristate m
    
    With no .config, the following configuration is generated:
    
    CONFIG_MODULES=y
    CONFIG_FOO=y
    
    With an empty .config, the following:
    
    CONFIG_MODULES=y
    CONFIG_FOO=m
    
    Tristate choice statements can also exhibit the problem, due to having an
    implicit rev_dep (select) containing "m".
    
    The problem is that MODULES is never evaluted in conf_read_simple() unless
    there's a .config. The following patch fixes this.
    
    Signed-off-by: Ulf Magnusson <ulfalizer.lkml@gmail.com>
    Reviewed-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 210a49e27d47..8dce5862550d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -170,8 +170,11 @@ int conf_read_simple(const char *name, int def)
 		if (in)
 			goto load;
 		sym_add_change_count(1);
-		if (!sym_defconfig_list)
+		if (!sym_defconfig_list) {
+			if (modules_sym)
+				sym_calc_value(modules_sym);
 			return 1;
+		}
 
 		for_all_defaults(sym_defconfig_list, prop) {
 			if (expr_calc_value(prop->visible.expr) == no ||

commit 1244b41d00eb60cb3d05220383bc9d15b9045fb4
Author: Peter Korsgaard <jacmet@sunsite.dk>
Date:   Thu Jul 22 14:24:57 2010 +0200

    kconfig: make randconfig fair for booleans
    
    Give boolean symbols a 50% chance of getting enabled, rather than 67%.
    
    Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index c4dec80cfd8e..210a49e27d47 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -862,7 +862,8 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 				sym->def[S_DEF_USER].tri = no;
 				break;
 			case def_random:
-				sym->def[S_DEF_USER].tri = (tristate)(rand() % 3);
+				cnt = sym_get_type(sym) == S_TRISTATE ? 3 : 2;
+				sym->def[S_DEF_USER].tri = (tristate)(rand() % cnt);
 				break;
 			default:
 				continue;

commit bc081dd6e9f622c73334dc465359168543ccaabf
Author: Michal Marek <mmarek@suse.cz>
Date:   Mon Dec 7 16:38:33 2009 +0100

    kbuild: generate modules.builtin
    
    To make it easier for module-init-tools and scripts like mkinitrd to
    distinguish builtin and missing modules, install a modules.builtin file
    listing all builtin modules. This is done by generating an additional
    config file (tristate.conf) with tristate options set to uppercase 'Y'
    or 'M'. If we source that config file, the builtin modules appear in
    obj-Y.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 797a7410f690..c4dec80cfd8e 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -677,7 +677,7 @@ int conf_write_autoconf(void)
 	struct symbol *sym;
 	const char *str;
 	const char *name;
-	FILE *out, *out_h;
+	FILE *out, *tristate, *out_h;
 	time_t now;
 	int i, l;
 
@@ -692,9 +692,16 @@ int conf_write_autoconf(void)
 	if (!out)
 		return 1;
 
+	tristate = fopen(".tmpconfig_tristate", "w");
+	if (!tristate) {
+		fclose(out);
+		return 1;
+	}
+
 	out_h = fopen(".tmpconfig.h", "w");
 	if (!out_h) {
 		fclose(out);
+		fclose(tristate);
 		return 1;
 	}
 
@@ -707,6 +714,9 @@ int conf_write_autoconf(void)
 		     "# %s"
 		     "#\n",
 		     sym_get_string_value(sym), ctime(&now));
+	fprintf(tristate, "#\n"
+			  "# Automatically generated - do not edit\n"
+			  "\n");
 	fprintf(out_h, "/*\n"
 		       " * Automatically generated C config: don't edit\n"
 		       " * Linux kernel version: %s\n"
@@ -727,10 +737,14 @@ int conf_write_autoconf(void)
 				break;
 			case mod:
 				fprintf(out, "CONFIG_%s=m\n", sym->name);
+				fprintf(tristate, "CONFIG_%s=M\n", sym->name);
 				fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
 				break;
 			case yes:
 				fprintf(out, "CONFIG_%s=y\n", sym->name);
+				if (sym->type == S_TRISTATE)
+					fprintf(tristate, "CONFIG_%s=Y\n",
+							sym->name);
 				fprintf(out_h, "#define CONFIG_%s 1\n", sym->name);
 				break;
 			}
@@ -772,6 +786,7 @@ int conf_write_autoconf(void)
 		}
 	}
 	fclose(out);
+	fclose(tristate);
 	fclose(out_h);
 
 	name = getenv("KCONFIG_AUTOHEADER");
@@ -779,6 +794,11 @@ int conf_write_autoconf(void)
 		name = "include/generated/autoconf.h";
 	if (rename(".tmpconfig.h", name))
 		return 1;
+	name = getenv("KCONFIG_TRISTATE");
+	if (!name)
+		name = "include/config/tristate.conf";
+	if (rename(".tmpconfig_tristate", name))
+		return 1;
 	name = conf_get_autoconfig_name();
 	/*
 	 * This must be the last step, kbuild has a dependency on auto.conf

commit 264a26838056fc2d759f58bec2e720e01fcb1bdb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Oct 18 00:49:24 2009 +0200

    kbuild: move autoconf.h to include/generated
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index b55e72ff2fc6..797a7410f690 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -776,7 +776,7 @@ int conf_write_autoconf(void)
 
 	name = getenv("KCONFIG_AUTOHEADER");
 	if (!name)
-		name = "include/linux/autoconf.h";
+		name = "include/generated/autoconf.h";
 	if (rename(".tmpconfig.h", name))
 		return 1;
 	name = conf_get_autoconfig_name();

commit 4356f4890792a678936c93c9196e8f7742e04535
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Fri Sep 18 12:49:23 2009 -0700

    kbuild: add static to prototypes
    
    Warnings found via gcc -Wmissing-prototypes.
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index a04da3459f0f..b55e72ff2fc6 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -560,7 +560,7 @@ int conf_write(const char *name)
 	return 0;
 }
 
-int conf_split_config(void)
+static int conf_split_config(void)
 {
 	const char *name;
 	char path[128];

commit 12122f62324e7c6837ee8b0fa8d257ce7ebcfc6f
Author: Markus Heidelberg <markus.heidelberg@web.de>
Date:   Mon May 18 01:36:54 2009 +0200

    kconfig: do not hardcode "include/config/auto.conf" filename
    
    Regardless of KCONFIG_AUTOCONFIG, the filename written as a Make target
    into "include/config/auto.conf.cmd" was always the default one.
    
    Of course this doesn't make it work for the Kernel kbuild system, since
    there the filename is hardcoded at several places in the Makefiles.
    
    Signed-off-by: Markus Heidelberg <markus.heidelberg@web.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 273d73888f9d..a04da3459f0f 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -41,6 +41,13 @@ const char *conf_get_configname(void)
 	return name ? name : ".config";
 }
 
+const char *conf_get_autoconfig_name(void)
+{
+	char *name = getenv("KCONFIG_AUTOCONFIG");
+
+	return name ? name : "include/config/auto.conf";
+}
+
 static char *conf_expand_value(const char *in)
 {
 	struct symbol *sym;
@@ -555,15 +562,14 @@ int conf_write(const char *name)
 
 int conf_split_config(void)
 {
-	char *name, path[128];
+	const char *name;
+	char path[128];
 	char *s, *d, c;
 	struct symbol *sym;
 	struct stat sb;
 	int res, i, fd;
 
-	name = getenv("KCONFIG_AUTOCONFIG");
-	if (!name)
-		name = "include/config/auto.conf";
+	name = conf_get_autoconfig_name();
 	conf_read_simple(name, S_DEF_AUTO);
 
 	if (chdir("include/config"))
@@ -670,7 +676,7 @@ int conf_write_autoconf(void)
 {
 	struct symbol *sym;
 	const char *str;
-	char *name;
+	const char *name;
 	FILE *out, *out_h;
 	time_t now;
 	int i, l;
@@ -773,9 +779,7 @@ int conf_write_autoconf(void)
 		name = "include/linux/autoconf.h";
 	if (rename(".tmpconfig.h", name))
 		return 1;
-	name = getenv("KCONFIG_AUTOCONFIG");
-	if (!name)
-		name = "include/config/auto.conf";
+	name = conf_get_autoconfig_name();
 	/*
 	 * This must be the last step, kbuild has a dependency on auto.conf
 	 * and this marks the successful completion of the previous steps.

commit 184832c981fd38b1052f2dfa0262e793fa6c67d3
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Mar 15 11:05:12 2009 +0100

    kconfig: fix randconfig for choice blocks
    
    Ingo Molnar reported that 'make randconfig' was not covering
    choice blocks properly, resulting in certain config options
    being left out of randconfig testing altogether.
    
    With the following patch we:
    - properly randomize choice value for normal choice blocks
    - properly randomize for multi choice blocks
    - added several comments to explain what is going on
    
    The root cause of the bug was that SYMBOL_VALID was set on the
    symbol representing the choice block so clearing this did
    the trick initially.
    But testign revealed a few more issues that is now fixed.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 830d9eae11f9..273d73888f9d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -843,7 +843,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 			default:
 				continue;
 			}
-			if (!sym_is_choice(sym) || mode != def_random)
+			if (!(sym_is_choice(sym) && mode == def_random))
 				sym->flags |= SYMBOL_DEF_USER;
 			break;
 		default:
@@ -856,28 +856,49 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	if (mode != def_random)
 		return;
-
+	/*
+	 * We have different type of choice blocks.
+	 * If curr.tri equal to mod then we can select several
+	 * choice symbols in one block.
+	 * In this case we do nothing.
+	 * If curr.tri equal yes then only one symbol can be
+	 * selected in a choice block and we set it to yes,
+	 * and the rest to no.
+	 */
 	for_all_symbols(i, csym) {
 		if (sym_has_value(csym) || !sym_is_choice(csym))
 			continue;
 
 		sym_calc_value(csym);
+
+		if (csym->curr.tri != yes)
+			continue;
+
 		prop = sym_get_choice_prop(csym);
-		def = -1;
-		while (1) {
-			cnt = 0;
-			expr_list_for_each_sym(prop->expr, e, sym) {
-				if (sym->visible == no)
-					continue;
-				if (def == cnt++) {
-					csym->def[S_DEF_USER].val = sym;
-					break;
-				}
+
+		/* count entries in choice block */
+		cnt = 0;
+		expr_list_for_each_sym(prop->expr, e, sym)
+			cnt++;
+
+		/*
+		 * find a random value and set it to yes,
+		 * set the rest to no so we have only one set
+		 */
+		def = (rand() % cnt);
+
+		cnt = 0;
+		expr_list_for_each_sym(prop->expr, e, sym) {
+			if (def == cnt++) {
+				sym->def[S_DEF_USER].tri = yes;
+				csym->def[S_DEF_USER].val = sym;
+			}
+			else {
+				sym->def[S_DEF_USER].tri = no;
 			}
-			if (def >= 0 || cnt < 2)
-				break;
-			def = (rand() % cnt) + 1;
 		}
 		csym->flags |= SYMBOL_DEF_USER;
+		/* clear VALID to get value calculated */
+		csym->flags &= ~(SYMBOL_VALID);
 	}
 }

commit ce97e13e52848c6388598696b7d44748598db759
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Oct 26 05:12:34 2008 +0000

    fix allmodconfig breakage
    
    If you use KCONFIG_ALLCONFIG (even with empty file) you get broken
    allmodconfig/allyesconfig; CONFIG_MODULES gets turned off, with obvious
    massive fallout.
    
    Breakage had been introduced when conf_set_all_new_symbols() got used
    for allmodconfig et.al.
    
    What happens is that sym_calc_value(modules_sym) done in
    conf_read_simple() sets SYMBOL_VALID on both modules_sym and MODULES.
    When we get to conf_set_all_new_symbols(), we set sym->def[S_DEF_USER]
    on everything, but it has no effect on sym->curr for the symbols that
    already have SYMBOL_VALID - these are stuck.
    
    Solution: use sym_clear_all_valid() in there.  Note that it makes
    reevaluation of modules_sym redundant - sym_clear_all_valid() will do
    that itself.
    
    [ Fixes http://bugzilla.kernel.org/show_bug.cgi?id=11512, says Alexey ]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index b91cf241a539..830d9eae11f9 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -852,8 +852,7 @@ void conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	}
 
-	if (modules_sym)
-		sym_calc_value(modules_sym);
+	sym_clear_all_valid();
 
 	if (mode != def_random)
 		return;

commit 661b0680f736e628a6da1cc030c201646587d658
Author: zippel@linux-m68k.org <zippel@linux-m68k.org>
Date:   Mon Sep 29 05:27:11 2008 +0200

    kconfig: readd lost change count
    
    Commit f072181e6403b0fe2e2aa800a005497b748fd284 ("kconfig: drop the
    ""trying to assign nonexistent symbol" warning") simply dropped the
    warnings, but it does a little more than that, it also marks the current
    .config as needed saving, so add this back.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index df6a188b9930..b91cf241a539 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -222,8 +222,10 @@ int conf_read_simple(const char *name, int def)
 				continue;
 			if (def == S_DEF_USER) {
 				sym = sym_find(line + 9);
-				if (!sym)
+				if (!sym) {
+					sym_add_change_count(1);
 					break;
+				}
 			} else {
 				sym = sym_lookup(line + 9, 0);
 				if (sym->type == S_UNKNOWN)
@@ -259,8 +261,10 @@ int conf_read_simple(const char *name, int def)
 			}
 			if (def == S_DEF_USER) {
 				sym = sym_find(line + 7);
-				if (!sym)
+				if (!sym) {
+					sym_add_change_count(1);
 					break;
+				}
 			} else {
 				sym = sym_lookup(line + 7, 0);
 				if (sym->type == S_UNKNOWN)

commit f072181e6403b0fe2e2aa800a005497b748fd284
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Aug 4 22:29:37 2008 +0200

    kconfig: drop the ""trying to assign nonexistent symbol" warning
    
    They really stand out now that make *config is less chatty - and
    they are generally ignored - so drop them.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Adrian Bunk <bunk@kernel.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 07597611cc50..df6a188b9930 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -222,10 +222,8 @@ int conf_read_simple(const char *name, int def)
 				continue;
 			if (def == S_DEF_USER) {
 				sym = sym_find(line + 9);
-				if (!sym) {
-					conf_warning("trying to assign nonexistent symbol %s", line + 9);
+				if (!sym)
 					break;
-				}
 			} else {
 				sym = sym_lookup(line + 9, 0);
 				if (sym->type == S_UNKNOWN)
@@ -261,10 +259,8 @@ int conf_read_simple(const char *name, int def)
 			}
 			if (def == S_DEF_USER) {
 				sym = sym_find(line + 7);
-				if (!sym) {
-					conf_warning("trying to assign nonexistent symbol %s", line + 7);
+				if (!sym)
 					break;
-				}
 			} else {
 				sym = sym_lookup(line + 7, 0);
 				if (sym->type == S_UNKNOWN)

commit dc7862e5a65b9b9e0aad448398b4f652c49c9350
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 6 04:55:55 2008 +0200

    kconfig: set all new symbols automatically
    
    Add conf_set_all_new_symbols() which set all symbols (which don't have a
    value yet) to a specifed value.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ee5fe943d58d..07597611cc50 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -812,3 +812,73 @@ void conf_set_changed_callback(void (*fn)(void))
 {
 	conf_changed_callback = fn;
 }
+
+
+void conf_set_all_new_symbols(enum conf_def_mode mode)
+{
+	struct symbol *sym, *csym;
+	struct property *prop;
+	struct expr *e;
+	int i, cnt, def;
+
+	for_all_symbols(i, sym) {
+		if (sym_has_value(sym))
+			continue;
+		switch (sym_get_type(sym)) {
+		case S_BOOLEAN:
+		case S_TRISTATE:
+			switch (mode) {
+			case def_yes:
+				sym->def[S_DEF_USER].tri = yes;
+				break;
+			case def_mod:
+				sym->def[S_DEF_USER].tri = mod;
+				break;
+			case def_no:
+				sym->def[S_DEF_USER].tri = no;
+				break;
+			case def_random:
+				sym->def[S_DEF_USER].tri = (tristate)(rand() % 3);
+				break;
+			default:
+				continue;
+			}
+			if (!sym_is_choice(sym) || mode != def_random)
+				sym->flags |= SYMBOL_DEF_USER;
+			break;
+		default:
+			break;
+		}
+
+	}
+
+	if (modules_sym)
+		sym_calc_value(modules_sym);
+
+	if (mode != def_random)
+		return;
+
+	for_all_symbols(i, csym) {
+		if (sym_has_value(csym) || !sym_is_choice(csym))
+			continue;
+
+		sym_calc_value(csym);
+		prop = sym_get_choice_prop(csym);
+		def = -1;
+		while (1) {
+			cnt = 0;
+			expr_list_for_each_sym(prop->expr, e, sym) {
+				if (sym->visible == no)
+					continue;
+				if (def == cnt++) {
+					csym->def[S_DEF_USER].val = sym;
+					break;
+				}
+			}
+			if (def >= 0 || cnt < 2)
+				break;
+			def = (rand() % cnt) + 1;
+		}
+		csym->flags |= SYMBOL_DEF_USER;
+	}
+}

commit 7a962923359768e04137125bd479fd0dfa6117d3
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:50:23 2008 +0100

    kconfig: explicitly introduce expression list
    
    Rename E_CHOICE to E_LIST to explicitly add support for expression
    lists. Add a helper macro expr_list_for_each_sym to more easily iterate
    over the list.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 497a19e85a07..ee5fe943d58d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -312,7 +312,7 @@ int conf_read_simple(const char *name, int def)
 
 int conf_read(const char *name)
 {
-	struct symbol *sym;
+	struct symbol *sym, *choice_sym;
 	struct property *prop;
 	struct expr *e;
 	int i, flags;
@@ -353,9 +353,9 @@ int conf_read(const char *name)
 		 */
 		prop = sym_get_choice_prop(sym);
 		flags = sym->flags;
-		for (e = prop->expr; e; e = e->left.expr)
-			if (e->right.sym->visible != no)
-				flags &= e->right.sym->flags;
+		expr_list_for_each_sym(prop->expr, e, choice_sym)
+			if (choice_sym->visible != no)
+				flags &= choice_sym->flags;
 		sym->flags &= flags | ~SYMBOL_DEF_USER;
 	}
 

commit d6ee35764f270c699e165b15dc59f4e55546bfda
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jan 7 21:09:55 2008 +0100

    kconfig: rename E_OR & friends to avoid name clash
    
    We had macros named the same as a set of enumeration values.
    It is legal code but very confusing to read - so rename
    the macros from E_* to EXPR_*
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2eccefb03a93..497a19e85a07 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -300,7 +300,7 @@ int conf_read_simple(const char *name, int def)
 				cs->def[def].val = sym;
 				break;
 			}
-			cs->def[def].tri = E_OR(cs->def[def].tri, sym->def[def].tri);
+			cs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);
 		}
 	}
 	fclose(in);

commit d84876f9f8042d5536050b83674c4f348ca3c4df
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Thu Jan 3 23:33:44 2008 +0100

    kconfig: allow overriding symbols
    
    Allow config variables in .config to override earlier ones in the same
    file. In other words,
    
            # CONFIG_SECURITY is not defined
            CONFIG_SECURITY=y
    
    will activate it. This makes it a bit easier to do
    
    cat original-config myconfig myconfig2 ... >.config;
    and run *config as expected.
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index e0f402f3b75d..2eccefb03a93 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -232,8 +232,7 @@ int conf_read_simple(const char *name, int def)
 					sym->type = S_BOOLEAN;
 			}
 			if (sym->flags & def_flags) {
-				conf_warning("trying to reassign symbol %s", sym->name);
-				break;
+				conf_warning("override: reassigning to symbol %s", sym->name);
 			}
 			switch (sym->type) {
 			case S_BOOLEAN:
@@ -272,8 +271,7 @@ int conf_read_simple(const char *name, int def)
 					sym->type = S_OTHER;
 			}
 			if (sym->flags & def_flags) {
-				conf_warning("trying to reassign symbol %s", sym->name);
-				break;
+				conf_warning("override: reassigning to symbol %s", sym->name);
 			}
 			if (conf_set_sym_val(sym, def, def_flags, p))
 				continue;
@@ -297,11 +295,9 @@ int conf_read_simple(const char *name, int def)
 				}
 				break;
 			case yes:
-				if (cs->def[def].tri != no) {
-					conf_warning("%s creates inconsistent choice state", sym->name);
-					cs->flags &= ~def_flags;
-				} else
-					cs->def[def].val = sym;
+				if (cs->def[def].tri != no)
+					conf_warning("override: %s changes choice state", sym->name);
+				cs->def[def].val = sym;
 				break;
 			}
 			cs->def[def].tri = E_OR(cs->def[def].tri, sym->def[def].tri);

commit 6840999b192b1b57d713ddee3761c457a2779036
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 17 15:37:31 2007 +0100

    x86: simplify "make ARCH=x86" and fix kconfig all.config
    
    Simplify "make ARCH=x86" and fix kconfig so we again can set 64BIT in
    all.config.
    
    For a fix the diffstat is nice:
     6 files changed, 3 insertions(+), 36 deletions(-)
    
    The patch reverts these commits:
     - 0f855aa64b3f63d35a891510cf7db932a435c116 ("kconfig: add helper to set
       config symbol from environment variable")
     - 2a113281f5cd2febbab21a93c8943f8d3eece4d3 ("kconfig: use $K64BIT to
       set 64BIT with all*config targets")
    
    Roman Zippel pointed out that kconfig supported string compares so
    the additional complexity introduced by the above two patches were
    not needed.
    
    With this patch we have following behaviour:
    
      # make {allno,allyes,allmod,rand}config [ARCH=...]
      option \ host arch      | 32bit         | 64bit
      =====================================================
      ./.                     | 32bit         | 64bit
      ARCH=x86                | 32bit         | 32bit
      ARCH=i386               | 32bit         | 32bit
      ARCH=x86_64             | 64bit         | 64bit
    
    The general rule are that ARCH= and native architecture takes
    precedence over the configuration.
    
    So make ARCH=i386 [whatever] will always build a 32-bit kernel
    no matter what the configuration says.  The configuration will
    be updated to 32-bit if it was configured to 64-bit and the
    other way around.
    
    This behaviour is consistent with previous behaviour so no
    suprises here.
    
    make ARCH=x86 will per default result in a 32-bit kernel but as
    the only ARCH= value x86 allow the user to select between 32-bit
    and 64-bit using menuconfig.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Andreas Herrmann <aherrman@arcor.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index e4fa3f302541..e0f402f3b75d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -145,33 +145,6 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 	return 0;
 }
 
-/* Read an environment variable and assign the value to the symbol */
-int conf_set_env_sym(const char *env, const char *symname, int def)
-{
-	struct symbol *sym;
-	char *p;
-	int def_flags;
-
-	p = getenv(env);
-	if (p) {
-		char warning[200];
-		sprintf(warning, "Environment variable (%s = \"%s\")", env, p);
-		conf_filename = warning;
-		def_flags = SYMBOL_DEF << def;
-		if (def == S_DEF_USER) {
-			sym = sym_find(symname);
-			if (!sym)
-				return 1;
-		} else {
-			sym = sym_lookup(symname, 0);
-			if (sym->type == S_UNKNOWN)
-				sym->type = S_OTHER;
-		}
-		conf_set_sym_val(sym, def, def_flags, p);
-	}
-	return 0;
-}
-
 int conf_read_simple(const char *name, int def)
 {
 	FILE *in = NULL;

commit 0f855aa64b3f63d35a891510cf7db932a435c116
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 10 20:40:05 2007 +0100

    kconfig: add helper to set config symbol from environment variable
    
    Add conf_set_env_sym() that can set an already defined symbol
    based on the value of an environment variable.
    
    Unknown symbols are silently ignored.
    A warning is printed if the value of the environment variable
    is unexpected.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index e0f402f3b75d..e4fa3f302541 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -145,6 +145,33 @@ static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
 	return 0;
 }
 
+/* Read an environment variable and assign the value to the symbol */
+int conf_set_env_sym(const char *env, const char *symname, int def)
+{
+	struct symbol *sym;
+	char *p;
+	int def_flags;
+
+	p = getenv(env);
+	if (p) {
+		char warning[200];
+		sprintf(warning, "Environment variable (%s = \"%s\")", env, p);
+		conf_filename = warning;
+		def_flags = SYMBOL_DEF << def;
+		if (def == S_DEF_USER) {
+			sym = sym_find(symname);
+			if (!sym)
+				return 1;
+		} else {
+			sym = sym_lookup(symname, 0);
+			if (sym->type == S_UNKNOWN)
+				sym->type = S_OTHER;
+		}
+		conf_set_sym_val(sym, def, def_flags, p);
+	}
+	return 0;
+}
+
 int conf_read_simple(const char *name, int def)
 {
 	FILE *in = NULL;

commit 9c900a9c9d9351e55ab6a84e12e3a52c474c7c8b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Nov 10 20:01:56 2007 +0100

    kconfig: factor out code in confdata.c
    
    This patch introduce no functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index b2913e9da495..e0f402f3b75d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -83,6 +83,68 @@ char *conf_get_default_confname(void)
 	return name;
 }
 
+static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
+{
+	char *p2;
+
+	switch (sym->type) {
+	case S_TRISTATE:
+		if (p[0] == 'm') {
+			sym->def[def].tri = mod;
+			sym->flags |= def_flags;
+			break;
+		}
+	case S_BOOLEAN:
+		if (p[0] == 'y') {
+			sym->def[def].tri = yes;
+			sym->flags |= def_flags;
+			break;
+		}
+		if (p[0] == 'n') {
+			sym->def[def].tri = no;
+			sym->flags |= def_flags;
+			break;
+		}
+		conf_warning("symbol value '%s' invalid for %s", p, sym->name);
+		break;
+	case S_OTHER:
+		if (*p != '"') {
+			for (p2 = p; *p2 && !isspace(*p2); p2++)
+				;
+			sym->type = S_STRING;
+			goto done;
+		}
+	case S_STRING:
+		if (*p++ != '"')
+			break;
+		for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
+			if (*p2 == '"') {
+				*p2 = 0;
+				break;
+			}
+			memmove(p2, p2 + 1, strlen(p2));
+		}
+		if (!p2) {
+			conf_warning("invalid string found");
+			return 1;
+		}
+	case S_INT:
+	case S_HEX:
+	done:
+		if (sym_string_valid(sym, p)) {
+			sym->def[def].val = strdup(p);
+			sym->flags |= def_flags;
+		} else {
+			conf_warning("symbol value '%s' invalid for %s", p, sym->name);
+			return 1;
+		}
+		break;
+	default:
+		;
+	}
+	return 0;
+}
+
 int conf_read_simple(const char *name, int def)
 {
 	FILE *in = NULL;
@@ -213,61 +275,8 @@ int conf_read_simple(const char *name, int def)
 				conf_warning("trying to reassign symbol %s", sym->name);
 				break;
 			}
-			switch (sym->type) {
-			case S_TRISTATE:
-				if (p[0] == 'm') {
-					sym->def[def].tri = mod;
-					sym->flags |= def_flags;
-					break;
-				}
-			case S_BOOLEAN:
-				if (p[0] == 'y') {
-					sym->def[def].tri = yes;
-					sym->flags |= def_flags;
-					break;
-				}
-				if (p[0] == 'n') {
-					sym->def[def].tri = no;
-					sym->flags |= def_flags;
-					break;
-				}
-				conf_warning("symbol value '%s' invalid for %s", p, sym->name);
-				break;
-			case S_OTHER:
-				if (*p != '"') {
-					for (p2 = p; *p2 && !isspace(*p2); p2++)
-						;
-					sym->type = S_STRING;
-					goto done;
-				}
-			case S_STRING:
-				if (*p++ != '"')
-					break;
-				for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
-					if (*p2 == '"') {
-						*p2 = 0;
-						break;
-					}
-					memmove(p2, p2 + 1, strlen(p2));
-				}
-				if (!p2) {
-					conf_warning("invalid string found");
-					continue;
-				}
-			case S_INT:
-			case S_HEX:
-			done:
-				if (sym_string_valid(sym, p)) {
-					sym->def[def].val = strdup(p);
-					sym->flags |= def_flags;
-				} else {
-					conf_warning("symbol value '%s' invalid for %s", p, sym->name);
-					continue;
-				}
-				break;
-			default:
-				;
-			}
+			if (conf_set_sym_val(sym, def, def_flags, p))
+				continue;
 			break;
 		case '\r':
 		case '\n':

commit d8982ba1f2a24f1db89d23e9f5224f932f8b04a0
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jul 9 11:43:58 2007 -0700

    kconfig: reset generated values only if Kconfig and .config agree.
    
    Normally generated values (Kconfig entries without a prompt) are cleared as
    they are regenerated anyway and so they appear as new should they become
    visible and defaults work as expected (once a value is set defaults aren't
    used anymore).
    
    The detection whether a value is generated or not is only based on its
    visibility status, which can quickly change for a lot of symbols by just
    removing a single line from .config or adding a dependency to Kconfig as you
    noticed.
    
    The patch now suppresses this logic when .config and Kconfig aren't in sync
    and .config needs to be updated, so that you can remove now a random value
    from .config and oldconfig won't reask for many other values.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 664fe29dacef..b2913e9da495 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -341,27 +341,42 @@ int conf_read(const char *name)
 		conf_unsaved++;
 		/* maybe print value in verbose mode... */
 	sym_ok:
+		if (!sym_is_choice(sym))
+			continue;
+		/* The choice symbol only has a set value (and thus is not new)
+		 * if all its visible childs have values.
+		 */
+		prop = sym_get_choice_prop(sym);
+		flags = sym->flags;
+		for (e = prop->expr; e; e = e->left.expr)
+			if (e->right.sym->visible != no)
+				flags &= e->right.sym->flags;
+		sym->flags &= flags | ~SYMBOL_DEF_USER;
+	}
+
+	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
-			if (sym->visible == no)
+			/* Reset values of generates values, so they'll appear
+			 * as new, if they should become visible, but that
+			 * doesn't quite work if the Kconfig and the saved
+			 * configuration disagree.
+			 */
+			if (sym->visible == no && !conf_unsaved)
 				sym->flags &= ~SYMBOL_DEF_USER;
 			switch (sym->type) {
 			case S_STRING:
 			case S_INT:
 			case S_HEX:
-				if (!sym_string_within_range(sym, sym->def[S_DEF_USER].val))
-					sym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);
+				/* Reset a string value if it's out of range */
+				if (sym_string_within_range(sym, sym->def[S_DEF_USER].val))
+					break;
+				sym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);
+				conf_unsaved++;
+				break;
 			default:
 				break;
 			}
 		}
-		if (!sym_is_choice(sym))
-			continue;
-		prop = sym_get_choice_prop(sym);
-		flags = sym->flags;
-		for (e = prop->expr; e; e = e->left.expr)
-			if (e->right.sym->visible != no)
-				flags &= e->right.sym->flags;
-		sym->flags &= flags | ~SYMBOL_DEF_USER;
 	}
 
 	sym_add_change_count(conf_warnings || conf_unsaved);

commit 3b354c557c7a6fcac099b3a20b308853fe596183
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:08 2006 -0800

    [PATCH] kconfig: add "void conf_set_changed_callback(void (*fn)(void))", use it in qconf.cc
    
    Added function sets "void (*conf_changed_callback)(void)".  Call it, if
    .config's changed state changes.  Use above in qconf.cc to set gui's
    save-widget's sensitvity.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 4bbbb5b09c8d..664fe29dacef 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -767,18 +767,28 @@ int conf_write_autoconf(void)
 }
 
 static int sym_change_count;
+static void (*conf_changed_callback)(void);
 
 void sym_set_change_count(int count)
 {
+	int _sym_change_count = sym_change_count;
 	sym_change_count = count;
+	if (conf_changed_callback &&
+	    (bool)_sym_change_count != (bool)count)
+		conf_changed_callback();
 }
 
 void sym_add_change_count(int count)
 {
-	sym_change_count += count;
+	sym_set_change_count(count + sym_change_count);
 }
 
 bool conf_get_changed(void)
 {
 	return sym_change_count;
 }
+
+void conf_set_changed_callback(void (*fn)(void))
+{
+	conf_changed_callback = fn;
+}

commit bfc10001b11e51b59ac901d17c5f05361bd2351d
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:07 2006 -0800

    [PATCH] kconfig: make sym_change_count static, let it be altered by 2 functions only
    
    Those two functions are
            void sym_set_change_count(int count)
    and
            void sym_add_change_count(int count)
    
    All write accesses to sym_change_count are replaced by calls to above
    functions.
    
    Variable and changer-functions are moved to confdata.c.  IMO thats ok, as
    sym_change_count is an attribute of the .config's change state.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 140742ebd73c..4bbbb5b09c8d 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -100,7 +100,7 @@ int conf_read_simple(const char *name, int def)
 		in = zconf_fopen(name);
 		if (in)
 			goto load;
-		sym_change_count++;
+		sym_add_change_count(1);
 		if (!sym_defconfig_list)
 			return 1;
 
@@ -312,7 +312,7 @@ int conf_read(const char *name)
 	struct expr *e;
 	int i, flags;
 
-	sym_change_count = 0;
+	sym_set_change_count(0);
 
 	if (conf_read_simple(name, S_DEF_USER))
 		return 1;
@@ -364,7 +364,7 @@ int conf_read(const char *name)
 		sym->flags &= flags | ~SYMBOL_DEF_USER;
 	}
 
-	sym_change_count += conf_warnings || conf_unsaved;
+	sym_add_change_count(conf_warnings || conf_unsaved);
 
 	return 0;
 }
@@ -528,7 +528,7 @@ int conf_write(const char *name)
 		 "# configuration written to %s\n"
 		 "#\n"), newname);
 
-	sym_change_count = 0;
+	sym_set_change_count(0);
 
 	return 0;
 }
@@ -766,6 +766,18 @@ int conf_write_autoconf(void)
 	return 0;
 }
 
+static int sym_change_count;
+
+void sym_set_change_count(int count)
+{
+	sym_change_count = count;
+}
+
+void sym_add_change_count(int count)
+{
+	sym_change_count += count;
+}
+
 bool conf_get_changed(void)
 {
 	return sym_change_count;

commit b321429325e4c911c379a5bf4156c9fc9713e425
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:06 2006 -0800

    [PATCH] kconfig: new function "bool conf_get_changed(void)"
    
    Run "make xconfig" on a freshly untarred kernel-tree.  Look at the floppy disk
    icon of the qt application, that has just started: Its in a normal, active
    state.
    
    Mouse click on it: .config is being saved.
    
    This patch series changes things so taht
    after the mouse click on the floppy disk icon, the icon is greyed out.
    If you mouse click on it now, nothing happens.
    
    If you change some CONFIG_*, the floppy disk icon returns to "active state",
    that is, if you mouse click it now, .config is written.
    
    This patch:
    
    Returns sym_change_count to reflect the .config's change state.
    All read only accesses of
            sym_change_count
    are replaced by calls to
            conf_get_changed()
    .
    mconfig.c is manipulated to ask for saving only when
    conf_get_changed() returned true.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 66b15ef02931..140742ebd73c 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -432,7 +432,7 @@ int conf_write(const char *name)
 		     use_timestamp ? "# " : "",
 		     use_timestamp ? ctime(&now) : "");
 
-	if (!sym_change_count)
+	if (!conf_get_changed())
 		sym_clear_all_valid();
 
 	menu = rootmenu.list;
@@ -765,3 +765,8 @@ int conf_write_autoconf(void)
 
 	return 0;
 }
+
+bool conf_get_changed(void)
+{
+	return sym_change_count;
+}

commit 9a3d0fe84f9fe296a86ea9315092d31986bc7a3a
Author: Sam Ravnborg <sam@neptun.ravnborg.org>
Date:   Sun Oct 1 11:48:53 2006 +0200

    kconfig: fix saving alternate kconfig file in parent dir
    
    This fixes bugzilla entry: 7182
    http://bugzilla.kernel.org/show_bug.cgi?id=7182
    
    With this patch we no longer append the directory part twice
    before saving the config file.
    This patch has been sent to Roman Zippel for review with no feedback.
    It is so obviously simple that this should be OK to apply it anyway.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 69f96b398c22..66b15ef02931 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -517,7 +517,7 @@ int conf_write(const char *name)
 	fclose(out);
 
 	if (*tmpname) {
-		strcat(dirname, name ? name : conf_get_configname());
+		strcat(dirname, basename);
 		strcat(dirname, ".old");
 		rename(newname, dirname);
 		if (rename(tmpname, newname))

commit d3660a8cbdfad620af88b85b7bbfff29160f14c2
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 13 12:54:07 2006 -0600

    kconfig: support DOS line endings
    
    Kconfig doesn't currently handle config files with DOS line endings.
    While these are, of course, an abomination, etc, etc, it can be handy
    to not have to convert them first.  It's also a tiny patch and even adds
    support for lines ending in just \r or even \n\r.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index a69d8acbf274..69f96b398c22 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -193,8 +193,11 @@ int conf_read_simple(const char *name, int def)
 				continue;
 			*p++ = 0;
 			p2 = strchr(p, '\n');
-			if (p2)
-				*p2 = 0;
+			if (p2) {
+				*p2-- = 0;
+				if (*p2 == '\r')
+					*p2 = 0;
+			}
 			if (def == S_DEF_USER) {
 				sym = sym_find(line + 7);
 				if (!sym) {
@@ -266,6 +269,7 @@ int conf_read_simple(const char *name, int def)
 				;
 			}
 			break;
+		case '\r':
 		case '\n':
 			break;
 		default:

commit 002d27b1b70f6d574c816ef265147704c4e951f1
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jul 13 13:22:38 2006 +0200

    kconfig: correct oldconfig for unset choice options
    
    oldconfig currently ignores unset choice options and doesn't ask for them.
    Correct the SYMBOL_DEF_USER flag of the choice symbol to be only set if
    it's set for all values.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2ee48c377b66..a69d8acbf274 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -357,7 +357,7 @@ int conf_read(const char *name)
 		for (e = prop->expr; e; e = e->left.expr)
 			if (e->right.sym->visible != no)
 				flags &= e->right.sym->flags;
-		sym->flags |= flags & SYMBOL_DEF_USER;
+		sym->flags &= flags | ~SYMBOL_DEF_USER;
 	}
 
 	sym_change_count += conf_warnings || conf_unsaved;

commit 14cdd3c402bf7c66f0bcd76e290f0770a54a4b21
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:51 2006 -0700

    kconfig: KCONFIG_OVERWRITECONFIG
    
    If you set KCONFIG_OVERWRITECONFIG in environment, Kconfig will not break
    symlinks when .config is a symlink to somewhere else.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 5bd66f451189..2ee48c377b66 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -21,8 +21,6 @@ static void conf_warning(const char *fmt, ...)
 static const char *conf_filename;
 static int conf_lineno, conf_warnings, conf_unsaved;
 
-const char conf_def_filename[] = ".config";
-
 const char conf_defname[] = "arch/$ARCH/defconfig";
 
 static void conf_warning(const char *fmt, ...)
@@ -36,6 +34,13 @@ static void conf_warning(const char *fmt, ...)
 	conf_warnings++;
 }
 
+const char *conf_get_configname(void)
+{
+	char *name = getenv("KCONFIG_CONFIG");
+
+	return name ? name : ".config";
+}
+
 static char *conf_expand_value(const char *in)
 {
 	struct symbol *sym;
@@ -91,7 +96,7 @@ int conf_read_simple(const char *name, int def)
 	} else {
 		struct property *prop;
 
-		name = conf_def_filename;
+		name = conf_get_configname();
 		in = zconf_fopen(name);
 		if (in)
 			goto load;
@@ -381,7 +386,7 @@ int conf_write(const char *name)
 		if (!stat(name, &st) && S_ISDIR(st.st_mode)) {
 			strcpy(dirname, name);
 			strcat(dirname, "/");
-			basename = conf_def_filename;
+			basename = conf_get_configname();
 		} else if ((slash = strrchr(name, '/'))) {
 			int size = slash - name + 1;
 			memcpy(dirname, name, size);
@@ -389,16 +394,24 @@ int conf_write(const char *name)
 			if (slash[1])
 				basename = slash + 1;
 			else
-				basename = conf_def_filename;
+				basename = conf_get_configname();
 		} else
 			basename = name;
 	} else
-		basename = conf_def_filename;
+		basename = conf_get_configname();
 
-	sprintf(newname, "%s.tmpconfig.%d", dirname, (int)getpid());
-	out = fopen(newname, "w");
+	sprintf(newname, "%s%s", dirname, basename);
+	env = getenv("KCONFIG_OVERWRITECONFIG");
+	if (!env || !*env) {
+		sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
+		out = fopen(tmpname, "w");
+	} else {
+		*tmpname = 0;
+		out = fopen(newname, "w");
+	}
 	if (!out)
 		return 1;
+
 	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
 	time(&now);
@@ -498,19 +511,18 @@ int conf_write(const char *name)
 		}
 	}
 	fclose(out);
-	if (!name || basename != conf_def_filename) {
-		if (!name)
-			name = conf_def_filename;
-		sprintf(tmpname, "%s.old", name);
-		rename(name, tmpname);
+
+	if (*tmpname) {
+		strcat(dirname, name ? name : conf_get_configname());
+		strcat(dirname, ".old");
+		rename(newname, dirname);
+		if (rename(tmpname, newname))
+			return 1;
 	}
-	sprintf(tmpname, "%s%s", dirname, basename);
-	if (rename(newname, tmpname))
-		return 1;
 
 	printf(_("#\n"
 		 "# configuration written to %s\n"
-		 "#\n"), tmpname);
+		 "#\n"), newname);
 
 	sym_change_count = 0;
 

commit face4374e288372fba67c865eb0c92337f50d5a4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:45 2006 -0700

    kconfig: add defconfig_list/module option
    
    This makes it possible to change two options which were hardcoded sofar.
    1. Any symbol can now take the role of CONFIG_MODULES
    2. The more useful option is to change the list of default file names,
       which kconfig uses to load the base configuration if .config isn't
       available.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index e28cd0c2ca08..5bd66f451189 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -25,15 +25,6 @@ const char conf_def_filename[] = ".config";
 
 const char conf_defname[] = "arch/$ARCH/defconfig";
 
-const char *conf_confnames[] = {
-	".config",
-	"/lib/modules/$UNAME_RELEASE/.config",
-	"/etc/kernel-config",
-	"/boot/config-$UNAME_RELEASE",
-	conf_defname,
-	NULL,
-};
-
 static void conf_warning(const char *fmt, ...)
 {
 	va_list ap;
@@ -98,16 +89,21 @@ int conf_read_simple(const char *name, int def)
 	if (name) {
 		in = zconf_fopen(name);
 	} else {
-		const char **names = conf_confnames;
-		name = *names++;
-		if (!name)
-			return 1;
+		struct property *prop;
+
+		name = conf_def_filename;
 		in = zconf_fopen(name);
 		if (in)
 			goto load;
 		sym_change_count++;
-		while ((name = *names++)) {
-			name = conf_expand_value(name);
+		if (!sym_defconfig_list)
+			return 1;
+
+		for_all_defaults(sym_defconfig_list, prop) {
+			if (expr_calc_value(prop->visible.expr) == no ||
+			    prop->expr->type != E_SYMBOL)
+				continue;
+			name = conf_expand_value(prop->expr->left.sym->name);
 			in = zconf_fopen(name);
 			if (in) {
 				printf(_("#\n"

commit 2e3646e51b2d6415549b310655df63e7e0d7a080
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:42 2006 -0700

    kconfig: integrate split config into silentoldconfig
    
    Now that kconfig can load multiple configurations, it becomes simple to
    integrate the split config step, by simply comparing the new .config file with
    the old auto.conf (and then saving the new auto.conf).  A nice side effect is
    that this saves a bit of disk space and cache, as no data needs to be read
    from or saved into the splitted config files anymore (e.g.  include/config is
    now 648KB instead of 5.2MB).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ca693fcd023f..e28cd0c2ca08 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -5,6 +5,7 @@
 
 #include <sys/stat.h>
 #include <ctype.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -520,6 +521,119 @@ int conf_write(const char *name)
 	return 0;
 }
 
+int conf_split_config(void)
+{
+	char *name, path[128];
+	char *s, *d, c;
+	struct symbol *sym;
+	struct stat sb;
+	int res, i, fd;
+
+	name = getenv("KCONFIG_AUTOCONFIG");
+	if (!name)
+		name = "include/config/auto.conf";
+	conf_read_simple(name, S_DEF_AUTO);
+
+	if (chdir("include/config"))
+		return 1;
+
+	res = 0;
+	for_all_symbols(i, sym) {
+		sym_calc_value(sym);
+		if ((sym->flags & SYMBOL_AUTO) || !sym->name)
+			continue;
+		if (sym->flags & SYMBOL_WRITE) {
+			if (sym->flags & SYMBOL_DEF_AUTO) {
+				/*
+				 * symbol has old and new value,
+				 * so compare them...
+				 */
+				switch (sym->type) {
+				case S_BOOLEAN:
+				case S_TRISTATE:
+					if (sym_get_tristate_value(sym) ==
+					    sym->def[S_DEF_AUTO].tri)
+						continue;
+					break;
+				case S_STRING:
+				case S_HEX:
+				case S_INT:
+					if (!strcmp(sym_get_string_value(sym),
+						    sym->def[S_DEF_AUTO].val))
+						continue;
+					break;
+				default:
+					break;
+				}
+			} else {
+				/*
+				 * If there is no old value, only 'no' (unset)
+				 * is allowed as new value.
+				 */
+				switch (sym->type) {
+				case S_BOOLEAN:
+				case S_TRISTATE:
+					if (sym_get_tristate_value(sym) == no)
+						continue;
+					break;
+				default:
+					break;
+				}
+			}
+		} else if (!(sym->flags & SYMBOL_DEF_AUTO))
+			/* There is neither an old nor a new value. */
+			continue;
+		/* else
+		 *	There is an old value, but no new value ('no' (unset)
+		 *	isn't saved in auto.conf, so the old value is always
+		 *	different from 'no').
+		 */
+
+		/* Replace all '_' and append ".h" */
+		s = sym->name;
+		d = path;
+		while ((c = *s++)) {
+			c = tolower(c);
+			*d++ = (c == '_') ? '/' : c;
+		}
+		strcpy(d, ".h");
+
+		/* Assume directory path already exists. */
+		fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
+		if (fd == -1) {
+			if (errno != ENOENT) {
+				res = 1;
+				break;
+			}
+			/*
+			 * Create directory components,
+			 * unless they exist already.
+			 */
+			d = path;
+			while ((d = strchr(d, '/'))) {
+				*d = 0;
+				if (stat(path, &sb) && mkdir(path, 0755)) {
+					res = 1;
+					goto out;
+				}
+				*d++ = '/';
+			}
+			/* Try it again. */
+			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
+			if (fd == -1) {
+				res = 1;
+				break;
+			}
+		}
+		close(fd);
+	}
+out:
+	if (chdir("../.."))
+		return 1;
+
+	return res;
+}
+
 int conf_write_autoconf(void)
 {
 	struct symbol *sym;
@@ -529,8 +643,13 @@ int conf_write_autoconf(void)
 	time_t now;
 	int i, l;
 
+	sym_clear_all_valid();
+
 	file_write_dep("include/config/auto.conf.cmd");
 
+	if (conf_split_config())
+		return 1;
+
 	out = fopen(".tmpconfig", "w");
 	if (!out)
 		return 1;
@@ -558,8 +677,6 @@ int conf_write_autoconf(void)
 		       "#define AUTOCONF_INCLUDED\n",
 		       sym_get_string_value(sym), ctime(&now));
 
-	sym_clear_all_valid();
-
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
 		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)

commit 669bfad906522e74ee8d962801552a8c224c0d63
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:42 2006 -0700

    kconfig: allow loading multiple configurations
    
    Extend conf_read_simple() so it can load multiple configurations.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 54ca1a786d25..ca693fcd023f 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -86,13 +86,13 @@ char *conf_get_default_confname(void)
 	return name;
 }
 
-int conf_read_simple(const char *name)
+int conf_read_simple(const char *name, int def)
 {
 	FILE *in = NULL;
 	char line[1024];
 	char *p, *p2;
 	struct symbol *sym;
-	int i;
+	int i, def_flags;
 
 	if (name) {
 		in = zconf_fopen(name);
@@ -125,20 +125,21 @@ int conf_read_simple(const char *name)
 	conf_warnings = 0;
 	conf_unsaved = 0;
 
+	def_flags = SYMBOL_DEF << def;
 	for_all_symbols(i, sym) {
-		sym->flags |= SYMBOL_NEW | SYMBOL_CHANGED;
+		sym->flags |= SYMBOL_CHANGED;
+		sym->flags &= ~(def_flags|SYMBOL_VALID);
 		if (sym_is_choice(sym))
-			sym->flags &= ~SYMBOL_NEW;
-		sym->flags &= ~SYMBOL_VALID;
+			sym->flags |= def_flags;
 		switch (sym->type) {
 		case S_INT:
 		case S_HEX:
 		case S_STRING:
-			if (sym->def[S_DEF_USER].val)
-				free(sym->def[S_DEF_USER].val);
+			if (sym->def[def].val)
+				free(sym->def[def].val);
 		default:
-			sym->def[S_DEF_USER].val = NULL;
-			sym->def[S_DEF_USER].tri = no;
+			sym->def[def].val = NULL;
+			sym->def[def].tri = no;
 		}
 	}
 
@@ -155,19 +156,26 @@ int conf_read_simple(const char *name)
 			*p++ = 0;
 			if (strncmp(p, "is not set", 10))
 				continue;
-			sym = sym_find(line + 9);
-			if (!sym) {
-				conf_warning("trying to assign nonexistent symbol %s", line + 9);
-				break;
-			} else if (!(sym->flags & SYMBOL_NEW)) {
+			if (def == S_DEF_USER) {
+				sym = sym_find(line + 9);
+				if (!sym) {
+					conf_warning("trying to assign nonexistent symbol %s", line + 9);
+					break;
+				}
+			} else {
+				sym = sym_lookup(line + 9, 0);
+				if (sym->type == S_UNKNOWN)
+					sym->type = S_BOOLEAN;
+			}
+			if (sym->flags & def_flags) {
 				conf_warning("trying to reassign symbol %s", sym->name);
 				break;
 			}
 			switch (sym->type) {
 			case S_BOOLEAN:
 			case S_TRISTATE:
-				sym->def[S_DEF_USER].tri = no;
-				sym->flags &= ~SYMBOL_NEW;
+				sym->def[def].tri = no;
+				sym->flags |= def_flags;
 				break;
 			default:
 				;
@@ -185,34 +193,48 @@ int conf_read_simple(const char *name)
 			p2 = strchr(p, '\n');
 			if (p2)
 				*p2 = 0;
-			sym = sym_find(line + 7);
-			if (!sym) {
-				conf_warning("trying to assign nonexistent symbol %s", line + 7);
-				break;
-			} else if (!(sym->flags & SYMBOL_NEW)) {
+			if (def == S_DEF_USER) {
+				sym = sym_find(line + 7);
+				if (!sym) {
+					conf_warning("trying to assign nonexistent symbol %s", line + 7);
+					break;
+				}
+			} else {
+				sym = sym_lookup(line + 7, 0);
+				if (sym->type == S_UNKNOWN)
+					sym->type = S_OTHER;
+			}
+			if (sym->flags & def_flags) {
 				conf_warning("trying to reassign symbol %s", sym->name);
 				break;
 			}
 			switch (sym->type) {
 			case S_TRISTATE:
 				if (p[0] == 'm') {
-					sym->def[S_DEF_USER].tri = mod;
-					sym->flags &= ~SYMBOL_NEW;
+					sym->def[def].tri = mod;
+					sym->flags |= def_flags;
 					break;
 				}
 			case S_BOOLEAN:
 				if (p[0] == 'y') {
-					sym->def[S_DEF_USER].tri = yes;
-					sym->flags &= ~SYMBOL_NEW;
+					sym->def[def].tri = yes;
+					sym->flags |= def_flags;
 					break;
 				}
 				if (p[0] == 'n') {
-					sym->def[S_DEF_USER].tri = no;
-					sym->flags &= ~SYMBOL_NEW;
+					sym->def[def].tri = no;
+					sym->flags |= def_flags;
 					break;
 				}
 				conf_warning("symbol value '%s' invalid for %s", p, sym->name);
 				break;
+			case S_OTHER:
+				if (*p != '"') {
+					for (p2 = p; *p2 && !isspace(*p2); p2++)
+						;
+					sym->type = S_STRING;
+					goto done;
+				}
 			case S_STRING:
 				if (*p++ != '"')
 					break;
@@ -229,9 +251,10 @@ int conf_read_simple(const char *name)
 				}
 			case S_INT:
 			case S_HEX:
+			done:
 				if (sym_string_valid(sym, p)) {
-					sym->def[S_DEF_USER].val = strdup(p);
-					sym->flags &= ~SYMBOL_NEW;
+					sym->def[def].val = strdup(p);
+					sym->flags |= def_flags;
 				} else {
 					conf_warning("symbol value '%s' invalid for %s", p, sym->name);
 					continue;
@@ -249,24 +272,24 @@ int conf_read_simple(const char *name)
 		}
 		if (sym && sym_is_choice_value(sym)) {
 			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
-			switch (sym->def[S_DEF_USER].tri) {
+			switch (sym->def[def].tri) {
 			case no:
 				break;
 			case mod:
-				if (cs->def[S_DEF_USER].tri == yes) {
+				if (cs->def[def].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
-					cs->flags |= SYMBOL_NEW;
+					cs->flags &= ~def_flags;
 				}
 				break;
 			case yes:
-				if (cs->def[S_DEF_USER].tri != no) {
+				if (cs->def[def].tri != no) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
-					cs->flags |= SYMBOL_NEW;
+					cs->flags &= ~def_flags;
 				} else
-					cs->def[S_DEF_USER].val = sym;
+					cs->def[def].val = sym;
 				break;
 			}
-			cs->def[S_DEF_USER].tri = E_OR(cs->def[S_DEF_USER].tri, sym->def[S_DEF_USER].tri);
+			cs->def[def].tri = E_OR(cs->def[def].tri, sym->def[def].tri);
 		}
 	}
 	fclose(in);
@@ -281,11 +304,11 @@ int conf_read(const char *name)
 	struct symbol *sym;
 	struct property *prop;
 	struct expr *e;
-	int i;
+	int i, flags;
 
 	sym_change_count = 0;
 
-	if (conf_read_simple(name))
+	if (conf_read_simple(name, S_DEF_USER))
 		return 1;
 
 	for_all_symbols(i, sym) {
@@ -314,15 +337,13 @@ int conf_read(const char *name)
 	sym_ok:
 		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
 			if (sym->visible == no)
-				sym->flags |= SYMBOL_NEW;
+				sym->flags &= ~SYMBOL_DEF_USER;
 			switch (sym->type) {
 			case S_STRING:
 			case S_INT:
 			case S_HEX:
-				if (!sym_string_within_range(sym, sym->def[S_DEF_USER].val)) {
-					sym->flags |= SYMBOL_NEW;
-					sym->flags &= ~SYMBOL_VALID;
-				}
+				if (!sym_string_within_range(sym, sym->def[S_DEF_USER].val))
+					sym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);
 			default:
 				break;
 			}
@@ -330,9 +351,11 @@ int conf_read(const char *name)
 		if (!sym_is_choice(sym))
 			continue;
 		prop = sym_get_choice_prop(sym);
+		flags = sym->flags;
 		for (e = prop->expr; e; e = e->left.expr)
 			if (e->right.sym->visible != no)
-				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
+				flags &= e->right.sym->flags;
+		sym->flags |= flags & SYMBOL_DEF_USER;
 	}
 
 	sym_change_count += conf_warnings || conf_unsaved;

commit 0c1822e6991a10da6dc391f0a2e2cf5fb2e31238
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:41 2006 -0700

    kconfig: allow multiple default values per symbol
    
    Extend struct symbol to allow storing multiple default values, which can be
    used to hold multiple configurations.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2da4a8d775a5..54ca1a786d25 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -134,11 +134,11 @@ int conf_read_simple(const char *name)
 		case S_INT:
 		case S_HEX:
 		case S_STRING:
-			if (sym->user.val)
-				free(sym->user.val);
+			if (sym->def[S_DEF_USER].val)
+				free(sym->def[S_DEF_USER].val);
 		default:
-			sym->user.val = NULL;
-			sym->user.tri = no;
+			sym->def[S_DEF_USER].val = NULL;
+			sym->def[S_DEF_USER].tri = no;
 		}
 	}
 
@@ -166,7 +166,7 @@ int conf_read_simple(const char *name)
 			switch (sym->type) {
 			case S_BOOLEAN:
 			case S_TRISTATE:
-				sym->user.tri = no;
+				sym->def[S_DEF_USER].tri = no;
 				sym->flags &= ~SYMBOL_NEW;
 				break;
 			default:
@@ -196,18 +196,18 @@ int conf_read_simple(const char *name)
 			switch (sym->type) {
 			case S_TRISTATE:
 				if (p[0] == 'm') {
-					sym->user.tri = mod;
+					sym->def[S_DEF_USER].tri = mod;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
 			case S_BOOLEAN:
 				if (p[0] == 'y') {
-					sym->user.tri = yes;
+					sym->def[S_DEF_USER].tri = yes;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
 				if (p[0] == 'n') {
-					sym->user.tri = no;
+					sym->def[S_DEF_USER].tri = no;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
@@ -230,7 +230,7 @@ int conf_read_simple(const char *name)
 			case S_INT:
 			case S_HEX:
 				if (sym_string_valid(sym, p)) {
-					sym->user.val = strdup(p);
+					sym->def[S_DEF_USER].val = strdup(p);
 					sym->flags &= ~SYMBOL_NEW;
 				} else {
 					conf_warning("symbol value '%s' invalid for %s", p, sym->name);
@@ -249,24 +249,24 @@ int conf_read_simple(const char *name)
 		}
 		if (sym && sym_is_choice_value(sym)) {
 			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
-			switch (sym->user.tri) {
+			switch (sym->def[S_DEF_USER].tri) {
 			case no:
 				break;
 			case mod:
-				if (cs->user.tri == yes) {
+				if (cs->def[S_DEF_USER].tri == yes) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
 					cs->flags |= SYMBOL_NEW;
 				}
 				break;
 			case yes:
-				if (cs->user.tri != no) {
+				if (cs->def[S_DEF_USER].tri != no) {
 					conf_warning("%s creates inconsistent choice state", sym->name);
 					cs->flags |= SYMBOL_NEW;
 				} else
-					cs->user.val = sym;
+					cs->def[S_DEF_USER].val = sym;
 				break;
 			}
-			cs->user.tri = E_OR(cs->user.tri, sym->user.tri);
+			cs->def[S_DEF_USER].tri = E_OR(cs->def[S_DEF_USER].tri, sym->def[S_DEF_USER].tri);
 		}
 	}
 	fclose(in);
@@ -297,12 +297,12 @@ int conf_read(const char *name)
 			switch (sym->type) {
 			case S_BOOLEAN:
 			case S_TRISTATE:
-				if (sym->user.tri != sym_get_tristate_value(sym))
+				if (sym->def[S_DEF_USER].tri != sym_get_tristate_value(sym))
 					break;
 				if (!sym_is_choice(sym))
 					goto sym_ok;
 			default:
-				if (!strcmp(sym->curr.val, sym->user.val))
+				if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
 					goto sym_ok;
 				break;
 			}
@@ -319,7 +319,7 @@ int conf_read(const char *name)
 			case S_STRING:
 			case S_INT:
 			case S_HEX:
-				if (!sym_string_within_range(sym, sym->user.val)) {
+				if (!sym_string_within_range(sym, sym->def[S_DEF_USER].val)) {
 					sym->flags |= SYMBOL_NEW;
 					sym->flags &= ~SYMBOL_VALID;
 				}

commit c955ccafc38e77312b4c65e5a70960080fb8a3f2
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:39 2006 -0700

    kconfig: fix .config dependencies
    
    This fixes one of the worst kbuild warts left - the broken dependencies used
    to check and regenerate the .config file.  This was done via an indirect
    dependency and the .config itself had an empty command, which can cause make
    not to reread the changed .config file.
    
    Instead of this we generate now a new file include/config/auto.conf from
    .config, which is used for kbuild and has the proper dependencies.  It's also
    the main make target now for all files generated during this step (and thus
    replaces include/linux/autoconf.h).
    
    This also means we can now relax the syntax requirements for the .config file
    and we don't have to rewrite it all the time, i.e.  silentoldconfig only
    writes .config now when it's necessary to keep it in sync with the Kconfig
    files and even this can be suppressed by setting the environment variable
    KCONFIG_NOSILENTUPDATE, so the update can (and must) be done manually.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index a9e3b6abf661..2da4a8d775a5 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -342,7 +342,7 @@ int conf_read(const char *name)
 
 int conf_write(const char *name)
 {
-	FILE *out, *out_h;
+	FILE *out;
 	struct symbol *sym;
 	struct menu *menu;
 	const char *basename;
@@ -379,13 +379,6 @@ int conf_write(const char *name)
 	out = fopen(newname, "w");
 	if (!out)
 		return 1;
-	out_h = NULL;
-	if (!name) {
-		out_h = fopen(".tmpconfig.h", "w");
-		if (!out_h)
-			return 1;
-		file_write_dep(NULL);
-	}
 	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
 	time(&now);
@@ -401,16 +394,6 @@ int conf_write(const char *name)
 		     sym_get_string_value(sym),
 		     use_timestamp ? "# " : "",
 		     use_timestamp ? ctime(&now) : "");
-	if (out_h)
-		fprintf(out_h, "/*\n"
-			       " * Automatically generated C config: don't edit\n"
-			       " * Linux kernel version: %s\n"
-			       "%s%s"
-			       " */\n"
-			       "#define AUTOCONF_INCLUDED\n",
-			       sym_get_string_value(sym),
-			       use_timestamp ? " * " : "",
-			       use_timestamp ? ctime(&now) : "");
 
 	if (!sym_change_count)
 		sym_clear_all_valid();
@@ -426,11 +409,6 @@ int conf_write(const char *name)
 				     "#\n"
 				     "# %s\n"
 				     "#\n", str);
-			if (out_h)
-				fprintf(out_h, "\n"
-					       "/*\n"
-					       " * %s\n"
-					       " */\n", str);
 		} else if (!(sym->flags & SYMBOL_CHOICE)) {
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
@@ -448,59 +426,39 @@ int conf_write(const char *name)
 				switch (sym_get_tristate_value(sym)) {
 				case no:
 					fprintf(out, "# CONFIG_%s is not set\n", sym->name);
-					if (out_h)
-						fprintf(out_h, "#undef CONFIG_%s\n", sym->name);
 					break;
 				case mod:
 					fprintf(out, "CONFIG_%s=m\n", sym->name);
-					if (out_h)
-						fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
 					break;
 				case yes:
 					fprintf(out, "CONFIG_%s=y\n", sym->name);
-					if (out_h)
-						fprintf(out_h, "#define CONFIG_%s 1\n", sym->name);
 					break;
 				}
 				break;
 			case S_STRING:
-				// fix me
 				str = sym_get_string_value(sym);
 				fprintf(out, "CONFIG_%s=\"", sym->name);
-				if (out_h)
-					fprintf(out_h, "#define CONFIG_%s \"", sym->name);
-				do {
+				while (1) {
 					l = strcspn(str, "\"\\");
 					if (l) {
 						fwrite(str, l, 1, out);
-						if (out_h)
-							fwrite(str, l, 1, out_h);
-					}
-					str += l;
-					while (*str == '\\' || *str == '"') {
-						fprintf(out, "\\%c", *str);
-						if (out_h)
-							fprintf(out_h, "\\%c", *str);
-						str++;
+						str += l;
 					}
-				} while (*str);
+					if (!*str)
+						break;
+					fprintf(out, "\\%c", *str++);
+				}
 				fputs("\"\n", out);
-				if (out_h)
-					fputs("\"\n", out_h);
 				break;
 			case S_HEX:
 				str = sym_get_string_value(sym);
 				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
 					fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
-					if (out_h)
-						fprintf(out_h, "#define CONFIG_%s 0x%s\n", sym->name, str);
 					break;
 				}
 			case S_INT:
 				str = sym_get_string_value(sym);
 				fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
-				if (out_h)
-					fprintf(out_h, "#define CONFIG_%s %s\n", sym->name, str);
 				break;
 			}
 		}
@@ -520,10 +478,6 @@ int conf_write(const char *name)
 		}
 	}
 	fclose(out);
-	if (out_h) {
-		fclose(out_h);
-		rename(".tmpconfig.h", "include/linux/autoconf.h");
-	}
 	if (!name || basename != conf_def_filename) {
 		if (!name)
 			name = conf_def_filename;
@@ -542,3 +496,120 @@ int conf_write(const char *name)
 
 	return 0;
 }
+
+int conf_write_autoconf(void)
+{
+	struct symbol *sym;
+	const char *str;
+	char *name;
+	FILE *out, *out_h;
+	time_t now;
+	int i, l;
+
+	file_write_dep("include/config/auto.conf.cmd");
+
+	out = fopen(".tmpconfig", "w");
+	if (!out)
+		return 1;
+
+	out_h = fopen(".tmpconfig.h", "w");
+	if (!out_h) {
+		fclose(out);
+		return 1;
+	}
+
+	sym = sym_lookup("KERNELVERSION", 0);
+	sym_calc_value(sym);
+	time(&now);
+	fprintf(out, "#\n"
+		     "# Automatically generated make config: don't edit\n"
+		     "# Linux kernel version: %s\n"
+		     "# %s"
+		     "#\n",
+		     sym_get_string_value(sym), ctime(&now));
+	fprintf(out_h, "/*\n"
+		       " * Automatically generated C config: don't edit\n"
+		       " * Linux kernel version: %s\n"
+		       " * %s"
+		       " */\n"
+		       "#define AUTOCONF_INCLUDED\n",
+		       sym_get_string_value(sym), ctime(&now));
+
+	sym_clear_all_valid();
+
+	for_all_symbols(i, sym) {
+		sym_calc_value(sym);
+		if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
+			continue;
+		switch (sym->type) {
+		case S_BOOLEAN:
+		case S_TRISTATE:
+			switch (sym_get_tristate_value(sym)) {
+			case no:
+				break;
+			case mod:
+				fprintf(out, "CONFIG_%s=m\n", sym->name);
+				fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
+				break;
+			case yes:
+				fprintf(out, "CONFIG_%s=y\n", sym->name);
+				fprintf(out_h, "#define CONFIG_%s 1\n", sym->name);
+				break;
+			}
+			break;
+		case S_STRING:
+			str = sym_get_string_value(sym);
+			fprintf(out, "CONFIG_%s=\"", sym->name);
+			fprintf(out_h, "#define CONFIG_%s \"", sym->name);
+			while (1) {
+				l = strcspn(str, "\"\\");
+				if (l) {
+					fwrite(str, l, 1, out);
+					fwrite(str, l, 1, out_h);
+					str += l;
+				}
+				if (!*str)
+					break;
+				fprintf(out, "\\%c", *str);
+				fprintf(out_h, "\\%c", *str);
+				str++;
+			}
+			fputs("\"\n", out);
+			fputs("\"\n", out_h);
+			break;
+		case S_HEX:
+			str = sym_get_string_value(sym);
+			if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
+				fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+				fprintf(out_h, "#define CONFIG_%s 0x%s\n", sym->name, str);
+				break;
+			}
+		case S_INT:
+			str = sym_get_string_value(sym);
+			fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+			fprintf(out_h, "#define CONFIG_%s %s\n", sym->name, str);
+			break;
+		default:
+			break;
+		}
+	}
+	fclose(out);
+	fclose(out_h);
+
+	name = getenv("KCONFIG_AUTOHEADER");
+	if (!name)
+		name = "include/linux/autoconf.h";
+	if (rename(".tmpconfig.h", name))
+		return 1;
+	name = getenv("KCONFIG_AUTOCONFIG");
+	if (!name)
+		name = "include/config/auto.conf";
+	/*
+	 * This must be the last step, kbuild has a dependency on auto.conf
+	 * and this marks the successful completion of the previous steps.
+	 */
+	if (rename(".tmpconfig", name))
+		return 1;
+
+	return 0;
+}

commit ddc97cacb310ad68483952e67764c4153c138ed2
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:38 2006 -0700

    kconfig: improve config load/save output
    
    During loading special case the first common case (.config), be silent about
    it and otherwise mark it as a change that requires saving.  Instead output
    that the file has been changed.  IOW if conf does nothing (special), it's
    silent.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 1b5df589f3ae..a9e3b6abf661 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -98,20 +98,28 @@ int conf_read_simple(const char *name)
 		in = zconf_fopen(name);
 	} else {
 		const char **names = conf_confnames;
+		name = *names++;
+		if (!name)
+			return 1;
+		in = zconf_fopen(name);
+		if (in)
+			goto load;
+		sym_change_count++;
 		while ((name = *names++)) {
 			name = conf_expand_value(name);
 			in = zconf_fopen(name);
 			if (in) {
 				printf(_("#\n"
-				         "# using defaults found in %s\n"
-				         "#\n"), name);
-				break;
+					 "# using defaults found in %s\n"
+					 "#\n"), name);
+				goto load;
 			}
 		}
 	}
 	if (!in)
 		return 1;
 
+load:
 	conf_filename = name;
 	conf_lineno = 0;
 	conf_warnings = 0;
@@ -275,6 +283,8 @@ int conf_read(const char *name)
 	struct expr *e;
 	int i;
 
+	sym_change_count = 0;
+
 	if (conf_read_simple(name))
 		return 1;
 
@@ -325,7 +335,7 @@ int conf_read(const char *name)
 				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
 	}
 
-	sym_change_count = conf_warnings || conf_unsaved;
+	sym_change_count += conf_warnings || conf_unsaved;
 
 	return 0;
 }
@@ -524,6 +534,10 @@ int conf_write(const char *name)
 	if (rename(newname, tmpname))
 		return 1;
 
+	printf(_("#\n"
+		 "# configuration written to %s\n"
+		 "#\n"), tmpname);
+
 	sym_change_count = 0;
 
 	return 0;

commit b5ac4817de3032796c558b0a32062e7392b5ea60
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Apr 9 17:27:28 2006 +0200

    kconfig: fix typo in change count initialization
    
    Configuration needs saving when either of these conditions is true.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 1b8882ddbc74..1b5df589f3ae 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -325,7 +325,7 @@ int conf_read(const char *name)
 				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
 	}
 
-	sym_change_count = conf_warnings && conf_unsaved;
+	sym_change_count = conf_warnings || conf_unsaved;
 
 	return 0;
 }

commit dc9a49a4af9cdbe3d79183eefb12372b4dbc09c2
Author: Jan Beulich <JBeulich@novell.com>
Date:   Thu Mar 9 14:47:46 2006 +0100

    kconfig: fix time ordering of writes to .kconfig.d and include/linux/autoconf.h
    
    Since .kconfig.d is used as a make dependency of include/linux/autoconf.h, it
    should be written earlier than the header file, to avoid a subsequent rebuild
    to consider the header outdated.
    
    Signed-Off-By: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index b0cbbe2e41bb..1b8882ddbc74 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -374,6 +374,7 @@ int conf_write(const char *name)
 		out_h = fopen(".tmpconfig.h", "w");
 		if (!out_h)
 			return 1;
+		file_write_dep(NULL);
 	}
 	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
@@ -512,7 +513,6 @@ int conf_write(const char *name)
 	if (out_h) {
 		fclose(out_h);
 		rename(".tmpconfig.h", "include/linux/autoconf.h");
-		file_write_dep(NULL);
 	}
 	if (!name || basename != conf_def_filename) {
 		if (!name)

commit 2244cbd8a9185c197ec5ba5de175aec288697223
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Mon Jan 16 12:12:12 2006 +0100

    kbuild: create .kernelrelease at *config step
    
    To enable 'make kernelrelease' earlier now create .kernelrelease when
    one of the *config targets are used.
    Also introduce KERNELVERSION - only user is kconfig.
    KERNELVERSION was needed to display kernel version in menuconfig -
    KERNELRELEASE is not valid until configuration has completed.
    kconfig files modified to use KERNELVERSION.
    Bug reported by: Rene Rebe <rene@exactcode.de>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ccd45130c482..b0cbbe2e41bb 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -375,7 +375,7 @@ int conf_write(const char *name)
 		if (!out_h)
 			return 1;
 	}
-	sym = sym_lookup("KERNELRELEASE", 0);
+	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
 	time(&now);
 	env = getenv("KCONFIG_NOTIMESTAMP");

commit c1a0f5e3c01d28b6782457bee5ae5ace3a9958ec
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:54 2005 -0800

    [PATCH] kconfig: stricter error checking for .config
    
    Add some more checks during the parsing of .config, so that after parsing
    sym_change_count reflects the correct state whether the .config is correct and
    in sync with the Kconfig or if it needs saving.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 4bba6202b79e..ccd45130c482 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -14,6 +14,12 @@
 #define LKC_DIRECT_LINK
 #include "lkc.h"
 
+static void conf_warning(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
+static const char *conf_filename;
+static int conf_lineno, conf_warnings, conf_unsaved;
+
 const char conf_def_filename[] = ".config";
 
 const char conf_defname[] = "arch/$ARCH/defconfig";
@@ -27,6 +33,17 @@ const char *conf_confnames[] = {
 	NULL,
 };
 
+static void conf_warning(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	fprintf(stderr, "%s:%d:warning: ", conf_filename, conf_lineno);
+	vfprintf(stderr, fmt, ap);
+	fprintf(stderr, "\n");
+	va_end(ap);
+	conf_warnings++;
+}
+
 static char *conf_expand_value(const char *in)
 {
 	struct symbol *sym;
@@ -74,7 +91,6 @@ int conf_read_simple(const char *name)
 	FILE *in = NULL;
 	char line[1024];
 	char *p, *p2;
-	int lineno = 0;
 	struct symbol *sym;
 	int i;
 
@@ -93,12 +109,18 @@ int conf_read_simple(const char *name)
 			}
 		}
 	}
-
 	if (!in)
 		return 1;
 
+	conf_filename = name;
+	conf_lineno = 0;
+	conf_warnings = 0;
+	conf_unsaved = 0;
+
 	for_all_symbols(i, sym) {
 		sym->flags |= SYMBOL_NEW | SYMBOL_CHANGED;
+		if (sym_is_choice(sym))
+			sym->flags &= ~SYMBOL_NEW;
 		sym->flags &= ~SYMBOL_VALID;
 		switch (sym->type) {
 		case S_INT:
@@ -113,7 +135,7 @@ int conf_read_simple(const char *name)
 	}
 
 	while (fgets(line, sizeof(line), in)) {
-		lineno++;
+		conf_lineno++;
 		sym = NULL;
 		switch (line[0]) {
 		case '#':
@@ -127,7 +149,10 @@ int conf_read_simple(const char *name)
 				continue;
 			sym = sym_find(line + 9);
 			if (!sym) {
-				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line + 9);
+				conf_warning("trying to assign nonexistent symbol %s", line + 9);
+				break;
+			} else if (!(sym->flags & SYMBOL_NEW)) {
+				conf_warning("trying to reassign symbol %s", sym->name);
 				break;
 			}
 			switch (sym->type) {
@@ -141,8 +166,10 @@ int conf_read_simple(const char *name)
 			}
 			break;
 		case 'C':
-			if (memcmp(line, "CONFIG_", 7))
+			if (memcmp(line, "CONFIG_", 7)) {
+				conf_warning("unexpected data");
 				continue;
+			}
 			p = strchr(line + 7, '=');
 			if (!p)
 				continue;
@@ -152,7 +179,10 @@ int conf_read_simple(const char *name)
 				*p2 = 0;
 			sym = sym_find(line + 7);
 			if (!sym) {
-				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line + 7);
+				conf_warning("trying to assign nonexistent symbol %s", line + 7);
+				break;
+			} else if (!(sym->flags & SYMBOL_NEW)) {
+				conf_warning("trying to reassign symbol %s", sym->name);
 				break;
 			}
 			switch (sym->type) {
@@ -173,6 +203,7 @@ int conf_read_simple(const char *name)
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
+				conf_warning("symbol value '%s' invalid for %s", p, sym->name);
 				break;
 			case S_STRING:
 				if (*p++ != '"')
@@ -185,8 +216,8 @@ int conf_read_simple(const char *name)
 					memmove(p2, p2 + 1, strlen(p2));
 				}
 				if (!p2) {
-					fprintf(stderr, "%s:%d: invalid string found\n", name, lineno);
-					exit(1);
+					conf_warning("invalid string found");
+					continue;
 				}
 			case S_INT:
 			case S_HEX:
@@ -194,8 +225,8 @@ int conf_read_simple(const char *name)
 					sym->user.val = strdup(p);
 					sym->flags &= ~SYMBOL_NEW;
 				} else {
-					fprintf(stderr, "%s:%d: symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
-					exit(1);
+					conf_warning("symbol value '%s' invalid for %s", p, sym->name);
+					continue;
 				}
 				break;
 			default:
@@ -205,6 +236,7 @@ int conf_read_simple(const char *name)
 		case '\n':
 			break;
 		default:
+			conf_warning("unexpected data");
 			continue;
 		}
 		if (sym && sym_is_choice_value(sym)) {
@@ -213,17 +245,20 @@ int conf_read_simple(const char *name)
 			case no:
 				break;
 			case mod:
-				if (cs->user.tri == yes)
-					/* warn? */;
+				if (cs->user.tri == yes) {
+					conf_warning("%s creates inconsistent choice state", sym->name);
+					cs->flags |= SYMBOL_NEW;
+				}
 				break;
 			case yes:
-				if (cs->user.tri != no)
-					/* warn? */;
-				cs->user.val = sym;
+				if (cs->user.tri != no) {
+					conf_warning("%s creates inconsistent choice state", sym->name);
+					cs->flags |= SYMBOL_NEW;
+				} else
+					cs->user.val = sym;
 				break;
 			}
 			cs->user.tri = E_OR(cs->user.tri, sym->user.tri);
-			cs->flags &= ~SYMBOL_NEW;
 		}
 	}
 	fclose(in);
@@ -245,6 +280,28 @@ int conf_read(const char *name)
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
+		if (sym_is_choice(sym) || (sym->flags & SYMBOL_AUTO))
+			goto sym_ok;
+		if (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {
+			/* check that calculated value agrees with saved value */
+			switch (sym->type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				if (sym->user.tri != sym_get_tristate_value(sym))
+					break;
+				if (!sym_is_choice(sym))
+					goto sym_ok;
+			default:
+				if (!strcmp(sym->curr.val, sym->user.val))
+					goto sym_ok;
+				break;
+			}
+		} else if (!sym_has_value(sym) && !(sym->flags & SYMBOL_WRITE))
+			/* no previous value and not saved */
+			goto sym_ok;
+		conf_unsaved++;
+		/* maybe print value in verbose mode... */
+	sym_ok:
 		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
 			if (sym->visible == no)
 				sym->flags |= SYMBOL_NEW;
@@ -252,8 +309,10 @@ int conf_read(const char *name)
 			case S_STRING:
 			case S_INT:
 			case S_HEX:
-				if (!sym_string_within_range(sym, sym->user.val))
+				if (!sym_string_within_range(sym, sym->user.val)) {
 					sym->flags |= SYMBOL_NEW;
+					sym->flags &= ~SYMBOL_VALID;
+				}
 			default:
 				break;
 			}
@@ -266,7 +325,7 @@ int conf_read(const char *name)
 				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
 	}
 
-	sym_change_count = 1;
+	sym_change_count = conf_warnings && conf_unsaved;
 
 	return 0;
 }

commit 90389160efc2864501ced6e662f9419eb7a3e6c8
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:49 2005 -0800

    [PATCH] kconfig: preset config during all*config
    
    Allow to force setting of config variables during all{no,mod,yes,random}config
    to a specific value.  For that conf first checks the KCONFIG_ALLCONFIG
    environment variable for a file name, otherwise it checks for
    all{no,mod,yes,random}.config and all.config.  The file is a normal config
    file, which presets the config variables, but they are still subject to normal
    dependency checks.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 02f670cc6bb9..4bba6202b79e 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -69,15 +69,13 @@ char *conf_get_default_confname(void)
 	return name;
 }
 
-int conf_read(const char *name)
+int conf_read_simple(const char *name)
 {
 	FILE *in = NULL;
 	char line[1024];
 	char *p, *p2;
 	int lineno = 0;
 	struct symbol *sym;
-	struct property *prop;
-	struct expr *e;
 	int i;
 
 	if (name) {
@@ -232,6 +230,19 @@ int conf_read(const char *name)
 
 	if (modules_sym)
 		sym_calc_value(modules_sym);
+	return 0;
+}
+
+int conf_read(const char *name)
+{
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *e;
+	int i;
+
+	if (conf_read_simple(name))
+		return 1;
+
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
 		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {

commit 48b9d03c5f20a0585bb6f7d8c4abad3661df5d75
Author: J.A. Magallon <jamagallon@able.es>
Date:   Sat Jun 25 14:59:22 2005 -0700

    [PATCH] Kill signed chars
    
    scripts/ is full of mismatches between char* params an signed char* arguments,
    and viceversa.  gcc4 now complaints loud about this.  Patch below deletes all
    those 'signed'.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 2755c459d780..02f670cc6bb9 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -27,10 +27,10 @@ const char *conf_confnames[] = {
 	NULL,
 };
 
-static char *conf_expand_value(const signed char *in)
+static char *conf_expand_value(const char *in)
 {
 	struct symbol *sym;
-	const signed char *src;
+	const char *src;
 	static char res_value[SYMBOL_MAXLENGTH];
 	char *dst, name[SYMBOL_MAXLENGTH];
 

commit 3b9fa0931dd86a1fe5507311ee8031650f5d0e8c
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Thu May 5 15:09:46 2005 -0700

    [PATCH] Kconfig i18n support
    
    This patch adds i18n support for make *config, allowing users to have the
    config process in their own language.
    
    No printk was harmed in the process, don't worry, so all the bug reports,
    kernel messages, etc, remain in english, just the user tools to configure
    the kernel are internationalized.
    
    Users not interested in translations can just unset the related LANG,
    LC_ALL, etc env variables and have the config process in plain english,
    something like:
    
    LANG= make menuconfig
    
    is enough for having the whole config process in english. Or just don't
    install any translation file.
    
    Translations for brazilian portuguese are being done by a team of
    volunteers at:
    
    http://www.visionflex.inf.br/kernel_ptbr/pmwiki.php/Principal/Traducoes
    
    To start the translation process:
    
      make update-po-config
    
      This will generate the pot template named scripts/kconfig/linux.pot,
      copy it to, say, ~/es.po, to start the translation for spanish.
    
    To test your translation, as root issue this command:
    
      msgfmt -o /usr/share/locale/es/LC_MESSAGES/linux.mo ~/es.po
    
      Replace "es" with your language code.
    
      Then execute, for instance:
    
      make menuconfig
    
    The current patch doesn't use any optimization to reduce the size of the
    generated .mo file, it is possible to use the config option as a key, but
    this doesn't prevent the current patch from being used or the translations
    done under the current scheme to be in any way lost if we chose to do any
    kind of keying.
    
    Thanks to Fabricio Vaccari for starting the pt_BR (brazilian portuguese)
    translation effort, Thiago Maciera for helping me with the gconf.cc (QT
    frontent) i18n coding and to all the volunteers that are already working on
    the first translation, to pt_BR.
    
    I left the question on whether to ship the translations with the stock kernel
    sources to be discussed here, please share your suggestions.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 1e82ae390a69..2755c459d780 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -88,9 +88,9 @@ int conf_read(const char *name)
 			name = conf_expand_value(name);
 			in = zconf_fopen(name);
 			if (in) {
-				printf("#\n"
-				       "# using defaults found in %s\n"
-				       "#\n", name);
+				printf(_("#\n"
+				         "# using defaults found in %s\n"
+				         "#\n"), name);
 				break;
 			}
 		}
@@ -312,11 +312,11 @@ int conf_write(const char *name)
 	if (env && *env)
 		use_timestamp = 0;
 
-	fprintf(out, "#\n"
-		     "# Automatically generated make config: don't edit\n"
-		     "# Linux kernel version: %s\n"
-		     "%s%s"
-		     "#\n",
+	fprintf(out, _("#\n"
+		       "# Automatically generated make config: don't edit\n"
+		       "# Linux kernel version: %s\n"
+		       "%s%s"
+		       "#\n"),
 		     sym_get_string_value(sym),
 		     use_timestamp ? "# " : "",
 		     use_timestamp ? ctime(&now) : "");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
new file mode 100644
index 000000000000..1e82ae390a69
--- /dev/null
+++ b/scripts/kconfig/confdata.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <sys/stat.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+const char conf_def_filename[] = ".config";
+
+const char conf_defname[] = "arch/$ARCH/defconfig";
+
+const char *conf_confnames[] = {
+	".config",
+	"/lib/modules/$UNAME_RELEASE/.config",
+	"/etc/kernel-config",
+	"/boot/config-$UNAME_RELEASE",
+	conf_defname,
+	NULL,
+};
+
+static char *conf_expand_value(const signed char *in)
+{
+	struct symbol *sym;
+	const signed char *src;
+	static char res_value[SYMBOL_MAXLENGTH];
+	char *dst, name[SYMBOL_MAXLENGTH];
+
+	res_value[0] = 0;
+	dst = name;
+	while ((src = strchr(in, '$'))) {
+		strncat(res_value, in, src - in);
+		src++;
+		dst = name;
+		while (isalnum(*src) || *src == '_')
+			*dst++ = *src++;
+		*dst = 0;
+		sym = sym_lookup(name, 0);
+		sym_calc_value(sym);
+		strcat(res_value, sym_get_string_value(sym));
+		in = src;
+	}
+	strcat(res_value, in);
+
+	return res_value;
+}
+
+char *conf_get_default_confname(void)
+{
+	struct stat buf;
+	static char fullname[PATH_MAX+1];
+	char *env, *name;
+
+	name = conf_expand_value(conf_defname);
+	env = getenv(SRCTREE);
+	if (env) {
+		sprintf(fullname, "%s/%s", env, name);
+		if (!stat(fullname, &buf))
+			return fullname;
+	}
+	return name;
+}
+
+int conf_read(const char *name)
+{
+	FILE *in = NULL;
+	char line[1024];
+	char *p, *p2;
+	int lineno = 0;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *e;
+	int i;
+
+	if (name) {
+		in = zconf_fopen(name);
+	} else {
+		const char **names = conf_confnames;
+		while ((name = *names++)) {
+			name = conf_expand_value(name);
+			in = zconf_fopen(name);
+			if (in) {
+				printf("#\n"
+				       "# using defaults found in %s\n"
+				       "#\n", name);
+				break;
+			}
+		}
+	}
+
+	if (!in)
+		return 1;
+
+	for_all_symbols(i, sym) {
+		sym->flags |= SYMBOL_NEW | SYMBOL_CHANGED;
+		sym->flags &= ~SYMBOL_VALID;
+		switch (sym->type) {
+		case S_INT:
+		case S_HEX:
+		case S_STRING:
+			if (sym->user.val)
+				free(sym->user.val);
+		default:
+			sym->user.val = NULL;
+			sym->user.tri = no;
+		}
+	}
+
+	while (fgets(line, sizeof(line), in)) {
+		lineno++;
+		sym = NULL;
+		switch (line[0]) {
+		case '#':
+			if (memcmp(line + 2, "CONFIG_", 7))
+				continue;
+			p = strchr(line + 9, ' ');
+			if (!p)
+				continue;
+			*p++ = 0;
+			if (strncmp(p, "is not set", 10))
+				continue;
+			sym = sym_find(line + 9);
+			if (!sym) {
+				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line + 9);
+				break;
+			}
+			switch (sym->type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				sym->user.tri = no;
+				sym->flags &= ~SYMBOL_NEW;
+				break;
+			default:
+				;
+			}
+			break;
+		case 'C':
+			if (memcmp(line, "CONFIG_", 7))
+				continue;
+			p = strchr(line + 7, '=');
+			if (!p)
+				continue;
+			*p++ = 0;
+			p2 = strchr(p, '\n');
+			if (p2)
+				*p2 = 0;
+			sym = sym_find(line + 7);
+			if (!sym) {
+				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line + 7);
+				break;
+			}
+			switch (sym->type) {
+			case S_TRISTATE:
+				if (p[0] == 'm') {
+					sym->user.tri = mod;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+			case S_BOOLEAN:
+				if (p[0] == 'y') {
+					sym->user.tri = yes;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+				if (p[0] == 'n') {
+					sym->user.tri = no;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+				break;
+			case S_STRING:
+				if (*p++ != '"')
+					break;
+				for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
+					if (*p2 == '"') {
+						*p2 = 0;
+						break;
+					}
+					memmove(p2, p2 + 1, strlen(p2));
+				}
+				if (!p2) {
+					fprintf(stderr, "%s:%d: invalid string found\n", name, lineno);
+					exit(1);
+				}
+			case S_INT:
+			case S_HEX:
+				if (sym_string_valid(sym, p)) {
+					sym->user.val = strdup(p);
+					sym->flags &= ~SYMBOL_NEW;
+				} else {
+					fprintf(stderr, "%s:%d: symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
+					exit(1);
+				}
+				break;
+			default:
+				;
+			}
+			break;
+		case '\n':
+			break;
+		default:
+			continue;
+		}
+		if (sym && sym_is_choice_value(sym)) {
+			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
+			switch (sym->user.tri) {
+			case no:
+				break;
+			case mod:
+				if (cs->user.tri == yes)
+					/* warn? */;
+				break;
+			case yes:
+				if (cs->user.tri != no)
+					/* warn? */;
+				cs->user.val = sym;
+				break;
+			}
+			cs->user.tri = E_OR(cs->user.tri, sym->user.tri);
+			cs->flags &= ~SYMBOL_NEW;
+		}
+	}
+	fclose(in);
+
+	if (modules_sym)
+		sym_calc_value(modules_sym);
+	for_all_symbols(i, sym) {
+		sym_calc_value(sym);
+		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
+			if (sym->visible == no)
+				sym->flags |= SYMBOL_NEW;
+			switch (sym->type) {
+			case S_STRING:
+			case S_INT:
+			case S_HEX:
+				if (!sym_string_within_range(sym, sym->user.val))
+					sym->flags |= SYMBOL_NEW;
+			default:
+				break;
+			}
+		}
+		if (!sym_is_choice(sym))
+			continue;
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->expr; e; e = e->left.expr)
+			if (e->right.sym->visible != no)
+				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
+	}
+
+	sym_change_count = 1;
+
+	return 0;
+}
+
+int conf_write(const char *name)
+{
+	FILE *out, *out_h;
+	struct symbol *sym;
+	struct menu *menu;
+	const char *basename;
+	char dirname[128], tmpname[128], newname[128];
+	int type, l;
+	const char *str;
+	time_t now;
+	int use_timestamp = 1;
+	char *env;
+
+	dirname[0] = 0;
+	if (name && name[0]) {
+		struct stat st;
+		char *slash;
+
+		if (!stat(name, &st) && S_ISDIR(st.st_mode)) {
+			strcpy(dirname, name);
+			strcat(dirname, "/");
+			basename = conf_def_filename;
+		} else if ((slash = strrchr(name, '/'))) {
+			int size = slash - name + 1;
+			memcpy(dirname, name, size);
+			dirname[size] = 0;
+			if (slash[1])
+				basename = slash + 1;
+			else
+				basename = conf_def_filename;
+		} else
+			basename = name;
+	} else
+		basename = conf_def_filename;
+
+	sprintf(newname, "%s.tmpconfig.%d", dirname, (int)getpid());
+	out = fopen(newname, "w");
+	if (!out)
+		return 1;
+	out_h = NULL;
+	if (!name) {
+		out_h = fopen(".tmpconfig.h", "w");
+		if (!out_h)
+			return 1;
+	}
+	sym = sym_lookup("KERNELRELEASE", 0);
+	sym_calc_value(sym);
+	time(&now);
+	env = getenv("KCONFIG_NOTIMESTAMP");
+	if (env && *env)
+		use_timestamp = 0;
+
+	fprintf(out, "#\n"
+		     "# Automatically generated make config: don't edit\n"
+		     "# Linux kernel version: %s\n"
+		     "%s%s"
+		     "#\n",
+		     sym_get_string_value(sym),
+		     use_timestamp ? "# " : "",
+		     use_timestamp ? ctime(&now) : "");
+	if (out_h)
+		fprintf(out_h, "/*\n"
+			       " * Automatically generated C config: don't edit\n"
+			       " * Linux kernel version: %s\n"
+			       "%s%s"
+			       " */\n"
+			       "#define AUTOCONF_INCLUDED\n",
+			       sym_get_string_value(sym),
+			       use_timestamp ? " * " : "",
+			       use_timestamp ? ctime(&now) : "");
+
+	if (!sym_change_count)
+		sym_clear_all_valid();
+
+	menu = rootmenu.list;
+	while (menu) {
+		sym = menu->sym;
+		if (!sym) {
+			if (!menu_is_visible(menu))
+				goto next;
+			str = menu_get_prompt(menu);
+			fprintf(out, "\n"
+				     "#\n"
+				     "# %s\n"
+				     "#\n", str);
+			if (out_h)
+				fprintf(out_h, "\n"
+					       "/*\n"
+					       " * %s\n"
+					       " */\n", str);
+		} else if (!(sym->flags & SYMBOL_CHOICE)) {
+			sym_calc_value(sym);
+			if (!(sym->flags & SYMBOL_WRITE))
+				goto next;
+			sym->flags &= ~SYMBOL_WRITE;
+			type = sym->type;
+			if (type == S_TRISTATE) {
+				sym_calc_value(modules_sym);
+				if (modules_sym->curr.tri == no)
+					type = S_BOOLEAN;
+			}
+			switch (type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				switch (sym_get_tristate_value(sym)) {
+				case no:
+					fprintf(out, "# CONFIG_%s is not set\n", sym->name);
+					if (out_h)
+						fprintf(out_h, "#undef CONFIG_%s\n", sym->name);
+					break;
+				case mod:
+					fprintf(out, "CONFIG_%s=m\n", sym->name);
+					if (out_h)
+						fprintf(out_h, "#define CONFIG_%s_MODULE 1\n", sym->name);
+					break;
+				case yes:
+					fprintf(out, "CONFIG_%s=y\n", sym->name);
+					if (out_h)
+						fprintf(out_h, "#define CONFIG_%s 1\n", sym->name);
+					break;
+				}
+				break;
+			case S_STRING:
+				// fix me
+				str = sym_get_string_value(sym);
+				fprintf(out, "CONFIG_%s=\"", sym->name);
+				if (out_h)
+					fprintf(out_h, "#define CONFIG_%s \"", sym->name);
+				do {
+					l = strcspn(str, "\"\\");
+					if (l) {
+						fwrite(str, l, 1, out);
+						if (out_h)
+							fwrite(str, l, 1, out_h);
+					}
+					str += l;
+					while (*str == '\\' || *str == '"') {
+						fprintf(out, "\\%c", *str);
+						if (out_h)
+							fprintf(out_h, "\\%c", *str);
+						str++;
+					}
+				} while (*str);
+				fputs("\"\n", out);
+				if (out_h)
+					fputs("\"\n", out_h);
+				break;
+			case S_HEX:
+				str = sym_get_string_value(sym);
+				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
+					fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+					if (out_h)
+						fprintf(out_h, "#define CONFIG_%s 0x%s\n", sym->name, str);
+					break;
+				}
+			case S_INT:
+				str = sym_get_string_value(sym);
+				fprintf(out, "CONFIG_%s=%s\n", sym->name, str);
+				if (out_h)
+					fprintf(out_h, "#define CONFIG_%s %s\n", sym->name, str);
+				break;
+			}
+		}
+
+	next:
+		if (menu->list) {
+			menu = menu->list;
+			continue;
+		}
+		if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+	fclose(out);
+	if (out_h) {
+		fclose(out_h);
+		rename(".tmpconfig.h", "include/linux/autoconf.h");
+		file_write_dep(NULL);
+	}
+	if (!name || basename != conf_def_filename) {
+		if (!name)
+			name = conf_def_filename;
+		sprintf(tmpname, "%s.old", name);
+		rename(name, tmpname);
+	}
+	sprintf(tmpname, "%s%s", dirname, basename);
+	if (rename(newname, tmpname))
+		return 1;
+
+	sym_change_count = 0;
+
+	return 0;
+}
