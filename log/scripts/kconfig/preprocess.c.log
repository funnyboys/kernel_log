commit 5533397d1ec83d749067794f54283890e38ff0c1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 27 23:37:23 2019 +0900

    kconfig: add static qualifier to expand_string()
    
    Now expand_string() is only used in preprocess.c
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 592dfbfa9fb3..0243086fb168 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -15,6 +15,7 @@
 #define ARRAY_SIZE(arr)		(sizeof(arr) / sizeof((arr)[0]))
 
 static char *expand_string_with_args(const char *in, int argc, char *argv[]);
+static char *expand_string(const char *in);
 
 static void __attribute__((noreturn)) pperror(const char *format, ...)
 {
@@ -550,7 +551,7 @@ static char *expand_string_with_args(const char *in, int argc, char *argv[])
 	return __expand_string(&in, is_end_of_str, argc, argv);
 }
 
-char *expand_string(const char *in)
+static char *expand_string(const char *in)
 {
 	return expand_string_with_args(in, 0, NULL);
 }

commit 558e78e3ce844c61ceffe32775dbefacf167b023
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Dec 21 17:33:04 2018 +0900

    kconfig: split some C files out of zconf.y
    
    I want to compile each C file independently instead of including all
    of them from zconf.y.
    
    Split out confdata.c, expr.c, symbol.c, and preprocess.c .
    These are low-hanging fruits.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index b028a48b0e76..592dfbfa9fb3 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -2,6 +2,7 @@
 //
 // Copyright (C) 2018 Masahiro Yamada <yamada.masahiro@socionext.com>
 
+#include <ctype.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -9,6 +10,7 @@
 #include <string.h>
 
 #include "list.h"
+#include "lkc.h"
 
 #define ARRAY_SIZE(arr)		(sizeof(arr) / sizeof((arr)[0]))
 

commit f5451582c4e22ce8912aae4950810f3598c9b516
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 11 20:01:05 2018 +0900

    kconfig: stop supporting '.' and '/' in unquoted words
    
    In my understanding, special characters such as '.' and '/' are
    supported in unquoted words to use bare file paths in the "source"
    statement.
    
    With the previous commit surrounding all file paths with double
    quotes, we can drop this.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 5ca2df790d3c..b028a48b0e76 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -555,8 +555,7 @@ char *expand_string(const char *in)
 
 static bool is_end_of_token(char c)
 {
-	/* Why are '.' and '/' valid characters for symbols? */
-	return !(isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/');
+	return !(isalnum(c) || c == '_' || c == '-');
 }
 
 /*

commit 73d1c580f92b203f4c3a189ee98c917c65712f7e
Author: Jerry James <loganjerry@gmail.com>
Date:   Sat Jun 23 22:49:04 2018 +0200

    kconfig: loop boundary condition fix
    
    If buf[-1] just happens to hold the byte 0x0A, then nread can wrap around
    to (size_t)-1, leading to invalid memory accesses.
    
    This has caused segmentation faults when trying to build the latest
    kernel snapshots for i686 in Fedora:
    https://bugzilla.redhat.com/show_bug.cgi?id=1592374
    
    Signed-off-by: Jerry James <loganjerry@gmail.com>
    [alexpl@fedoraproject.org: reformatted patch for submission]
    Signed-off-by: Alexander Ploumistos <alexpl@fedoraproject.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 65da87fce907..5ca2df790d3c 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -156,7 +156,7 @@ static char *do_shell(int argc, char *argv[])
 		nread--;
 
 	/* remove trailing new lines */
-	while (buf[nread - 1] == '\n')
+	while (nread > 0 && buf[nread - 1] == '\n')
 		nread--;
 
 	buf[nread] = 0;

commit 915f64901eb3f1e4e126f58c0d2f82f5ec1d1223
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:55 2018 +0900

    kconfig: error out if a recursive variable references itself
    
    When using a recursively expanded variable, it is a common mistake
    to make circular reference.
    
    For example, Make terminates the following code:
    
      X = $(X)
      Y := $(X)
    
    Let's detect the circular expansion in Kconfig, too.
    
    On the other hand, a function that recurses itself is a commonly-used
    programming technique.  So, Make does not check recursion in the
    reference with 'call'.  For example, the following code continues
    running eternally:
    
      X = $(call X)
      Y := $(X)
    
    Kconfig allows circular expansion if one or more arguments are given,
    but terminates when the same function is recursively invoked 1000 times,
    assuming it is a programming mistake.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 0574039238c6..65da87fce907 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -229,6 +229,7 @@ struct variable {
 	char *name;
 	char *value;
 	enum variable_flavor flavor;
+	int exp_count;
 	struct list_head node;
 };
 
@@ -253,11 +254,22 @@ static char *variable_expand(const char *name, int argc, char *argv[])
 	if (!v)
 		return NULL;
 
+	if (argc == 0 && v->exp_count)
+		pperror("Recursive variable '%s' references itself (eventually)",
+			name);
+
+	if (v->exp_count > 1000)
+		pperror("Too deep recursive expansion");
+
+	v->exp_count++;
+
 	if (v->flavor == VAR_RECURSIVE)
 		res = expand_string_with_args(v->value, argc, argv);
 	else
 		res = xstrdup(v->value);
 
+	v->exp_count--;
+
 	return res;
 }
 
@@ -284,6 +296,7 @@ void variable_add(const char *name, const char *value,
 
 		v = xmalloc(sizeof(*v));
 		v->name = xstrdup(name);
+		v->exp_count = 0;
 		list_add_tail(&v->node, &variable_list);
 	}
 

commit a702a6176e2fea9ae366a7345247eb886e4cc730
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:54 2018 +0900

    kconfig: add 'filename' and 'lineno' built-in variables
    
    The special variables, $(filename) and $(lineno), are expanded to a
    file name and its line number being parsed, respectively.
    
    Suggested-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 5ee58eeb9a7d..0574039238c6 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -114,6 +114,11 @@ static char *do_error_if(int argc, char *argv[])
 	return NULL;
 }
 
+static char *do_filename(int argc, char *argv[])
+{
+	return xstrdup(current_file->name);
+}
+
 static char *do_info(int argc, char *argv[])
 {
 	printf("%s\n", argv[0]);
@@ -121,6 +126,15 @@ static char *do_info(int argc, char *argv[])
 	return xstrdup("");
 }
 
+static char *do_lineno(int argc, char *argv[])
+{
+	char buf[16];
+
+	sprintf(buf, "%d", yylineno);
+
+	return xstrdup(buf);
+}
+
 static char *do_shell(int argc, char *argv[])
 {
 	FILE *p;
@@ -173,7 +187,9 @@ static char *do_warning_if(int argc, char *argv[])
 static const struct function function_table[] = {
 	/* Name		MIN	MAX	Function */
 	{ "error-if",	2,	2,	do_error_if },
+	{ "filename",	0,	0,	do_filename },
 	{ "info",	1,	1,	do_info },
+	{ "lineno",	0,	0,	do_lineno },
 	{ "shell",	1,	1,	do_shell },
 	{ "warning-if",	2,	2,	do_warning_if },
 };

commit 1d6272e6fe43bc45c7ee58170d91d7242a71296b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:53 2018 +0900

    kconfig: add 'info', 'warning-if', and 'error-if' built-in functions
    
    Syntax:
      $(info,<text>)
      $(warning-if,<condition>,<text>)
      $(error-if,<condition>,<text)
    
    The 'info' function prints a message to stdout as in Make.
    
    The 'warning-if' and 'error-if' are similar to 'warning' and 'error'
    in Make, but take the condition parameter.  They are effective only
    when the <condition> part is y.
    
    Kconfig does not implement the lazy expansion as used in the 'if'
    'and, 'or' functions in Make.  In other words, Kconfig does not
    support conditional expansion.  The unconditional 'error' function
    would always terminate the parsing, hence would be useless in Kconfig.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 56aa1f0bad04..5ee58eeb9a7d 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -106,6 +106,21 @@ struct function {
 	char *(*func)(int argc, char *argv[]);
 };
 
+static char *do_error_if(int argc, char *argv[])
+{
+	if (!strcmp(argv[0], "y"))
+		pperror("%s", argv[1]);
+
+	return NULL;
+}
+
+static char *do_info(int argc, char *argv[])
+{
+	printf("%s\n", argv[0]);
+
+	return xstrdup("");
+}
+
 static char *do_shell(int argc, char *argv[])
 {
 	FILE *p;
@@ -146,9 +161,21 @@ static char *do_shell(int argc, char *argv[])
 	return xstrdup(buf);
 }
 
+static char *do_warning_if(int argc, char *argv[])
+{
+	if (!strcmp(argv[0], "y"))
+		fprintf(stderr, "%s:%d: %s\n",
+			current_file->name, yylineno, argv[1]);
+
+	return xstrdup("");
+}
+
 static const struct function function_table[] = {
 	/* Name		MIN	MAX	Function */
+	{ "error-if",	2,	2,	do_error_if },
+	{ "info",	1,	1,	do_info },
 	{ "shell",	1,	1,	do_shell },
+	{ "warning-if",	2,	2,	do_warning_if },
 };
 
 #define FUNCTION_MAX_ARGS		16

commit ed2a22f277c60308481ecea1e1b846cbf249af41
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:51 2018 +0900

    kconfig: support append assignment operator
    
    Support += operator.  This appends a space and the text on the
    righthand side to a variable.
    
    The timing of the evaluation of the righthand side depends on the
    flavor of the variable.  If the lefthand side was originally defined
    as a simple variable, the righthand side is expanded immediately.
    Otherwise, the expansion is deferred.  Appending something to an
    undefined variable results in a recursive variable.
    
    To implement this, we need to remember the flavor of variables.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index d103683b386e..56aa1f0bad04 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -222,11 +222,23 @@ void variable_add(const char *name, const char *value,
 		  enum variable_flavor flavor)
 {
 	struct variable *v;
+	char *new_value;
+	bool append = false;
 
 	v = variable_lookup(name);
 	if (v) {
-		free(v->value);
+		/* For defined variables, += inherits the existing flavor */
+		if (flavor == VAR_APPEND) {
+			flavor = v->flavor;
+			append = true;
+		} else {
+			free(v->value);
+		}
 	} else {
+		/* For undefined variables, += assumes the recursive flavor */
+		if (flavor == VAR_APPEND)
+			flavor = VAR_RECURSIVE;
+
 		v = xmalloc(sizeof(*v));
 		v->name = xstrdup(name);
 		list_add_tail(&v->node, &variable_list);
@@ -235,9 +247,19 @@ void variable_add(const char *name, const char *value,
 	v->flavor = flavor;
 
 	if (flavor == VAR_SIMPLE)
-		v->value = expand_string(value);
+		new_value = expand_string(value);
 	else
-		v->value = xstrdup(value);
+		new_value = xstrdup(value);
+
+	if (append) {
+		v->value = xrealloc(v->value,
+				    strlen(v->value) + strlen(new_value) + 2);
+		strcat(v->value, " ");
+		strcat(v->value, new_value);
+		free(new_value);
+	} else {
+		v->value = new_value;
+	}
 }
 
 static void variable_del(struct variable *v)

commit 1175c02506ffc9cef9f3c520249d8740a3174b1f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:50 2018 +0900

    kconfig: support simply expanded variable
    
    The previous commit added variable and user-defined function.  They
    work similarly in the sense that the evaluation is deferred until
    they are used.
    
    This commit adds another type of variable, simply expanded variable,
    as we see in Make.
    
    The := operator defines a simply expanded variable, expanding the
    righthand side immediately.  This works like traditional programming
    language variables.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 46487fe6b36c..d103683b386e 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -185,6 +185,7 @@ static LIST_HEAD(variable_list);
 struct variable {
 	char *name;
 	char *value;
+	enum variable_flavor flavor;
 	struct list_head node;
 };
 
@@ -203,15 +204,22 @@ static struct variable *variable_lookup(const char *name)
 static char *variable_expand(const char *name, int argc, char *argv[])
 {
 	struct variable *v;
+	char *res;
 
 	v = variable_lookup(name);
 	if (!v)
 		return NULL;
 
-	return expand_string_with_args(v->value, argc, argv);
+	if (v->flavor == VAR_RECURSIVE)
+		res = expand_string_with_args(v->value, argc, argv);
+	else
+		res = xstrdup(v->value);
+
+	return res;
 }
 
-void variable_add(const char *name, const char *value)
+void variable_add(const char *name, const char *value,
+		  enum variable_flavor flavor)
 {
 	struct variable *v;
 
@@ -224,7 +232,12 @@ void variable_add(const char *name, const char *value)
 		list_add_tail(&v->node, &variable_list);
 	}
 
-	v->value = xstrdup(value);
+	v->flavor = flavor;
+
+	if (flavor == VAR_SIMPLE)
+		v->value = expand_string(value);
+	else
+		v->value = xstrdup(value);
 }
 
 static void variable_del(struct variable *v)

commit 9ced3bddec080e974e910bf887715540a8d9d96b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:49 2018 +0900

    kconfig: support user-defined function and recursively expanded variable
    
    Now, we got a basic ability to test compiler capability in Kconfig.
    
    config CC_HAS_STACKPROTECTOR
            def_bool $(shell,($(CC) -Werror -fstack-protector -E -x c /dev/null -o /dev/null 2>/dev/null) && echo y || echo n)
    
    This works, but it is ugly to repeat this long boilerplate.
    
    We want to describe like this:
    
    config CC_HAS_STACKPROTECTOR
            bool
            default $(cc-option,-fstack-protector)
    
    It is straight-forward to add a new function, but I do not like to
    hard-code specialized functions like that.  Hence, here is another
    feature, user-defined function.  This works as a textual shorthand
    with parameterization.
    
    A user-defined function is defined by using the = operator, and can
    be referenced in the same way as built-in functions.  A user-defined
    function in Make is referenced like $(call my-func,arg1,arg2), but I
    omitted the 'call' to make the syntax shorter.
    
    The definition of a user-defined function contains $(1), $(2), etc.
    in its body to reference the parameters.  It is grammatically valid
    to pass more or fewer arguments when calling it.  We already exploit
    this feature in our makefiles; scripts/Kbuild.include defines cc-option
    which takes two arguments at most, but most of the callers pass only
    one argument.
    
    By the way, a variable is supported as a subset of this feature since
    a variable is "a user-defined function with zero argument".  In this
    context, I mean "variable" as recursively expanded variable.  I will
    add a different flavored variable in the next commit.
    
    The code above can be written as follows:
    
    [Example Code]
    
      success = $(shell,($(1)) >/dev/null 2>&1 && echo y || echo n)
      cc-option = $(success,$(CC) -Werror $(1) -E -x c /dev/null -o /dev/null)
    
      config CC_HAS_STACKPROTECTOR
              def_bool $(cc-option,-fstack-protector)
    
    [Result]
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_CC_HAS_STACKPROTECTOR=y
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index 528be594e1d0..46487fe6b36c 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -177,6 +177,72 @@ static char *function_expand(const char *name, int argc, char *argv[])
 	return NULL;
 }
 
+/*
+ * Variables (and user-defined functions)
+ */
+static LIST_HEAD(variable_list);
+
+struct variable {
+	char *name;
+	char *value;
+	struct list_head node;
+};
+
+static struct variable *variable_lookup(const char *name)
+{
+	struct variable *v;
+
+	list_for_each_entry(v, &variable_list, node) {
+		if (!strcmp(name, v->name))
+			return v;
+	}
+
+	return NULL;
+}
+
+static char *variable_expand(const char *name, int argc, char *argv[])
+{
+	struct variable *v;
+
+	v = variable_lookup(name);
+	if (!v)
+		return NULL;
+
+	return expand_string_with_args(v->value, argc, argv);
+}
+
+void variable_add(const char *name, const char *value)
+{
+	struct variable *v;
+
+	v = variable_lookup(name);
+	if (v) {
+		free(v->value);
+	} else {
+		v = xmalloc(sizeof(*v));
+		v->name = xstrdup(name);
+		list_add_tail(&v->node, &variable_list);
+	}
+
+	v->value = xstrdup(value);
+}
+
+static void variable_del(struct variable *v)
+{
+	list_del(&v->node);
+	free(v->name);
+	free(v->value);
+	free(v);
+}
+
+void variable_all_del(void)
+{
+	struct variable *v, *tmp;
+
+	list_for_each_entry_safe(v, tmp, &variable_list, node)
+		variable_del(v);
+}
+
 /*
  * Evaluate a clause with arguments.  argc/argv are arguments from the upper
  * function call.
@@ -185,14 +251,26 @@ static char *function_expand(const char *name, int argc, char *argv[])
  */
 static char *eval_clause(const char *str, size_t len, int argc, char *argv[])
 {
-	char *tmp, *name, *res, *prev, *p;
+	char *tmp, *name, *res, *endptr, *prev, *p;
 	int new_argc = 0;
 	char *new_argv[FUNCTION_MAX_ARGS];
 	int nest = 0;
 	int i;
+	unsigned long n;
 
 	tmp = xstrndup(str, len);
 
+	/*
+	 * If variable name is '1', '2', etc.  It is generally an argument
+	 * from a user-function call (i.e. local-scope variable).  If not
+	 * available, then look-up global-scope variables.
+	 */
+	n = strtoul(tmp, &endptr, 10);
+	if (!*endptr && n > 0 && n <= argc) {
+		res = xstrdup(argv[n - 1]);
+		goto free_tmp;
+	}
+
 	prev = p = tmp;
 
 	/*
@@ -238,6 +316,11 @@ static char *eval_clause(const char *str, size_t len, int argc, char *argv[])
 		new_argv[i] = expand_string_with_args(new_argv[i + 1],
 						      argc, argv);
 
+	/* Search for variables */
+	res = variable_expand(name, new_argc, new_argv);
+	if (res)
+		goto free;
+
 	/* Look for built-in functions */
 	res = function_expand(name, new_argc, new_argv);
 	if (res)
@@ -255,6 +338,7 @@ static char *eval_clause(const char *str, size_t len, int argc, char *argv[])
 	for (i = 0; i < new_argc; i++)
 		free(new_argv[i]);
 	free(name);
+free_tmp:
 	free(tmp);
 
 	return res;

commit 2fd5b09c201e20ab87299efd6a25f0bfc546e7c9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:46 2018 +0900

    kconfig: add 'shell' built-in function
    
    This accepts a single command to execute.  It returns the standard
    output from it.
    
    [Example code]
    
      config HELLO
              string
              default "$(shell,echo hello world)"
    
      config Y
              def_bool $(shell,echo y)
    
    [Result]
    
      $ make -s alldefconfig && tail -n 2 .config
      CONFIG_HELLO="hello world"
      CONFIG_Y=y
    
    Caveat:
    Like environments, functions are expanded in the lexer.  You cannot
    pass symbols to function arguments.  This is a limitation to simplify
    the implementation.  I want to avoid the dynamic function evaluation,
    which would introduce much more complexity.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index f32a496626da..528be594e1d0 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -106,8 +106,49 @@ struct function {
 	char *(*func)(int argc, char *argv[]);
 };
 
+static char *do_shell(int argc, char *argv[])
+{
+	FILE *p;
+	char buf[256];
+	char *cmd;
+	size_t nread;
+	int i;
+
+	cmd = argv[0];
+
+	p = popen(cmd, "r");
+	if (!p) {
+		perror(cmd);
+		exit(1);
+	}
+
+	nread = fread(buf, 1, sizeof(buf), p);
+	if (nread == sizeof(buf))
+		nread--;
+
+	/* remove trailing new lines */
+	while (buf[nread - 1] == '\n')
+		nread--;
+
+	buf[nread] = 0;
+
+	/* replace a new line with a space */
+	for (i = 0; i < nread; i++) {
+		if (buf[i] == '\n')
+			buf[i] = ' ';
+	}
+
+	if (pclose(p) == -1) {
+		perror(cmd);
+		exit(1);
+	}
+
+	return xstrdup(buf);
+}
+
 static const struct function function_table[] = {
 	/* Name		MIN	MAX	Function */
+	{ "shell",	1,	1,	do_shell },
 };
 
 #define FUNCTION_MAX_ARGS		16

commit e298f3b49def8e67c2466bef8aed355462bfa7f1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:45 2018 +0900

    kconfig: add built-in function support
    
    This commit adds a new concept 'function' to do more text processing
    in Kconfig.
    
    A function call looks like this:
    
      $(function,arg1,arg2,arg3,...)
    
    This commit adds the basic infrastructure to expand functions.
    Change the text expansion helpers to take arguments.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
index a2eb2eb02929..f32a496626da 100644
--- a/scripts/kconfig/preprocess.c
+++ b/scripts/kconfig/preprocess.c
@@ -10,6 +10,10 @@
 
 #include "list.h"
 
+#define ARRAY_SIZE(arr)		(sizeof(arr) / sizeof((arr)[0]))
+
+static char *expand_string_with_args(const char *in, int argc, char *argv[]);
+
 static void __attribute__((noreturn)) pperror(const char *format, ...)
 {
 	va_list ap;
@@ -92,20 +96,123 @@ void env_write_dep(FILE *f, const char *autoconfig_name)
 	}
 }
 
-static char *eval_clause(const char *str, size_t len)
+/*
+ * Built-in functions
+ */
+struct function {
+	const char *name;
+	unsigned int min_args;
+	unsigned int max_args;
+	char *(*func)(int argc, char *argv[]);
+};
+
+static const struct function function_table[] = {
+	/* Name		MIN	MAX	Function */
+};
+
+#define FUNCTION_MAX_ARGS		16
+
+static char *function_expand(const char *name, int argc, char *argv[])
 {
-	char *tmp, *name, *res;
+	const struct function *f;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(function_table); i++) {
+		f = &function_table[i];
+		if (strcmp(f->name, name))
+			continue;
+
+		if (argc < f->min_args)
+			pperror("too few function arguments passed to '%s'",
+				name);
+
+		if (argc > f->max_args)
+			pperror("too many function arguments passed to '%s'",
+				name);
+
+		return f->func(argc, argv);
+	}
+
+	return NULL;
+}
+
+/*
+ * Evaluate a clause with arguments.  argc/argv are arguments from the upper
+ * function call.
+ *
+ * Returned string must be freed when done
+ */
+static char *eval_clause(const char *str, size_t len, int argc, char *argv[])
+{
+	char *tmp, *name, *res, *prev, *p;
+	int new_argc = 0;
+	char *new_argv[FUNCTION_MAX_ARGS];
+	int nest = 0;
+	int i;
 
 	tmp = xstrndup(str, len);
 
-	name = expand_string(tmp);
+	prev = p = tmp;
+
+	/*
+	 * Split into tokens
+	 * The function name and arguments are separated by a comma.
+	 * For example, if the function call is like this:
+	 *   $(foo,$(x),$(y))
+	 *
+	 * The input string for this helper should be:
+	 *   foo,$(x),$(y)
+	 *
+	 * and split into:
+	 *   new_argv[0] = 'foo'
+	 *   new_argv[1] = '$(x)'
+	 *   new_argv[2] = '$(y)'
+	 */
+	while (*p) {
+		if (nest == 0 && *p == ',') {
+			*p = 0;
+			if (new_argc >= FUNCTION_MAX_ARGS)
+				pperror("too many function arguments");
+			new_argv[new_argc++] = prev;
+			prev = p + 1;
+		} else if (*p == '(') {
+			nest++;
+		} else if (*p == ')') {
+			nest--;
+		}
 
-	res = env_expand(name);
+		p++;
+	}
+	new_argv[new_argc++] = prev;
+
+	/*
+	 * Shift arguments
+	 * new_argv[0] represents a function name or a variable name.  Put it
+	 * into 'name', then shift the rest of the arguments.  This simplifies
+	 * 'const' handling.
+	 */
+	name = expand_string_with_args(new_argv[0], argc, argv);
+	new_argc--;
+	for (i = 0; i < new_argc; i++)
+		new_argv[i] = expand_string_with_args(new_argv[i + 1],
+						      argc, argv);
+
+	/* Look for built-in functions */
+	res = function_expand(name, new_argc, new_argv);
 	if (res)
 		goto free;
 
+	/* Last, try environment variable */
+	if (new_argc == 0) {
+		res = env_expand(name);
+		if (res)
+			goto free;
+	}
+
 	res = xstrdup("");
 free:
+	for (i = 0; i < new_argc; i++)
+		free(new_argv[i]);
 	free(name);
 	free(tmp);
 
@@ -124,14 +231,14 @@ static char *eval_clause(const char *str, size_t len)
  * after the corresponding closing parenthesis, in this case, *str will be
  *     $(BAR)
  */
-char *expand_dollar(const char **str)
+static char *expand_dollar_with_args(const char **str, int argc, char *argv[])
 {
 	const char *p = *str;
 	const char *q;
 	int nest = 0;
 
 	/*
-	 * In Kconfig, variable references always start with "$(".
+	 * In Kconfig, variable/function references always start with "$(".
 	 * Neither single-letter variables as in $A nor curly braces as in ${CC}
 	 * are supported.  '$' not followed by '(' loses its special meaning.
 	 */
@@ -158,10 +265,16 @@ char *expand_dollar(const char **str)
 	/* Advance 'str' to after the expanded initial portion of the string */
 	*str = q + 1;
 
-	return eval_clause(p, q - p);
+	return eval_clause(p, q - p, argc, argv);
+}
+
+char *expand_dollar(const char **str)
+{
+	return expand_dollar_with_args(str, 0, NULL);
 }
 
-static char *__expand_string(const char **str, bool (*is_end)(char c))
+static char *__expand_string(const char **str, bool (*is_end)(char c),
+			     int argc, char *argv[])
 {
 	const char *in, *p;
 	char *expansion, *out;
@@ -177,7 +290,7 @@ static char *__expand_string(const char **str, bool (*is_end)(char c))
 		if (*p == '$') {
 			in_len = p - in;
 			p++;
-			expansion = expand_dollar(&p);
+			expansion = expand_dollar_with_args(&p, argc, argv);
 			out_len += in_len + strlen(expansion);
 			out = xrealloc(out, out_len);
 			strncat(out, in, in_len);
@@ -210,13 +323,18 @@ static bool is_end_of_str(char c)
 }
 
 /*
- * Expand variables in the given string.  Undefined variables
+ * Expand variables and functions in the given string.  Undefined variables
  * expand to an empty string.
  * The returned string must be freed when done.
  */
+static char *expand_string_with_args(const char *in, int argc, char *argv[])
+{
+	return __expand_string(&in, is_end_of_str, argc, argv);
+}
+
 char *expand_string(const char *in)
 {
-	return __expand_string(&in, is_end_of_str);
+	return expand_string_with_args(in, 0, NULL);
 }
 
 static bool is_end_of_token(char c)
@@ -234,5 +352,5 @@ static bool is_end_of_token(char c)
  */
 char *expand_one_token(const char **str)
 {
-	return __expand_string(str, is_end_of_token);
+	return __expand_string(str, is_end_of_token, 0, NULL);
 }

commit 104daea149c45cc84842ce77a9bd6436d19f3dd8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:40 2018 +0900

    kconfig: reference environment variables directly and remove 'option env='
    
    To get access to environment variables, Kconfig needs to define a
    symbol using "option env=" syntax.  It is tedious to add a symbol entry
    for each environment variable given that we need to define much more
    such as 'CC', 'AS', 'srctree' etc. to evaluate the compiler capability
    in Kconfig.
    
    Adding '$' for symbol references is grammatically inconsistent.
    Looking at the code, the symbols prefixed with 'S' are expanded by:
     - conf_expand_value()
       This is used to expand 'arch/$ARCH/defconfig' and 'defconfig_list'
     - sym_expand_string_value()
       This is used to expand strings in 'source' and 'mainmenu'
    
    All of them are fixed values independent of user configuration.  So,
    they can be changed into the direct expansion instead of symbols.
    
    This change makes the code much cleaner.  The bounce symbols 'SRCARCH',
    'ARCH', 'SUBARCH', 'KERNELVERSION' are gone.
    
    sym_init() hard-coding 'UNAME_RELEASE' is also gone.  'UNAME_RELEASE'
    should be replaced with an environment variable.
    
    ARCH_DEFCONFIG is a normal symbol, so it should be simply referenced
    without '$' prefix.
    
    The new syntax is addicted by Make.  The variable reference needs
    parentheses, like $(FOO), but you can omit them for single-letter
    variables, like $F.  Yet, in Makefiles, people tend to use the
    parenthetical form for consistency / clarification.
    
    At this moment, only the environment variable is supported, but I will
    extend the concept of 'variable' later on.
    
    The variables are expanded in the lexer so we can simplify the token
    handling on the parser side.
    
    For example, the following code works.
    
    [Example code]
    
      config MY_TOOLCHAIN_LIST
              string
              default "My tools: CC=$(CC), AS=$(AS), CPP=$(CPP)"
    
    [Result]
    
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_MY_TOOLCHAIN_LIST="My tools: CC=gcc, AS=as, CPP=gcc -E"
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/preprocess.c b/scripts/kconfig/preprocess.c
new file mode 100644
index 000000000000..a2eb2eb02929
--- /dev/null
+++ b/scripts/kconfig/preprocess.c
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (C) 2018 Masahiro Yamada <yamada.masahiro@socionext.com>
+
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "list.h"
+
+static void __attribute__((noreturn)) pperror(const char *format, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", current_file->name, yylineno);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+
+	exit(1);
+}
+
+/*
+ * Environment variables
+ */
+static LIST_HEAD(env_list);
+
+struct env {
+	char *name;
+	char *value;
+	struct list_head node;
+};
+
+static void env_add(const char *name, const char *value)
+{
+	struct env *e;
+
+	e = xmalloc(sizeof(*e));
+	e->name = xstrdup(name);
+	e->value = xstrdup(value);
+
+	list_add_tail(&e->node, &env_list);
+}
+
+static void env_del(struct env *e)
+{
+	list_del(&e->node);
+	free(e->name);
+	free(e->value);
+	free(e);
+}
+
+/* The returned pointer must be freed when done */
+static char *env_expand(const char *name)
+{
+	struct env *e;
+	const char *value;
+
+	if (!*name)
+		return NULL;
+
+	list_for_each_entry(e, &env_list, node) {
+		if (!strcmp(name, e->name))
+			return xstrdup(e->value);
+	}
+
+	value = getenv(name);
+	if (!value)
+		return NULL;
+
+	/*
+	 * We need to remember all referenced environment variables.
+	 * They will be written out to include/config/auto.conf.cmd
+	 */
+	env_add(name, value);
+
+	return xstrdup(value);
+}
+
+void env_write_dep(FILE *f, const char *autoconfig_name)
+{
+	struct env *e, *tmp;
+
+	list_for_each_entry_safe(e, tmp, &env_list, node) {
+		fprintf(f, "ifneq \"$(%s)\" \"%s\"\n", e->name, e->value);
+		fprintf(f, "%s: FORCE\n", autoconfig_name);
+		fprintf(f, "endif\n");
+		env_del(e);
+	}
+}
+
+static char *eval_clause(const char *str, size_t len)
+{
+	char *tmp, *name, *res;
+
+	tmp = xstrndup(str, len);
+
+	name = expand_string(tmp);
+
+	res = env_expand(name);
+	if (res)
+		goto free;
+
+	res = xstrdup("");
+free:
+	free(name);
+	free(tmp);
+
+	return res;
+}
+
+/*
+ * Expand a string that follows '$'
+ *
+ * For example, if the input string is
+ *     ($(FOO)$($(BAR)))$(BAZ)
+ * this helper evaluates
+ *     $($(FOO)$($(BAR)))
+ * and returns a new string containing the expansion (note that the string is
+ * recursively expanded), also advancing 'str' to point to the next character
+ * after the corresponding closing parenthesis, in this case, *str will be
+ *     $(BAR)
+ */
+char *expand_dollar(const char **str)
+{
+	const char *p = *str;
+	const char *q;
+	int nest = 0;
+
+	/*
+	 * In Kconfig, variable references always start with "$(".
+	 * Neither single-letter variables as in $A nor curly braces as in ${CC}
+	 * are supported.  '$' not followed by '(' loses its special meaning.
+	 */
+	if (*p != '(') {
+		*str = p;
+		return xstrdup("$");
+	}
+
+	p++;
+	q = p;
+	while (*q) {
+		if (*q == '(') {
+			nest++;
+		} else if (*q == ')') {
+			if (nest-- == 0)
+				break;
+		}
+		q++;
+	}
+
+	if (!*q)
+		pperror("unterminated reference to '%s': missing ')'", p);
+
+	/* Advance 'str' to after the expanded initial portion of the string */
+	*str = q + 1;
+
+	return eval_clause(p, q - p);
+}
+
+static char *__expand_string(const char **str, bool (*is_end)(char c))
+{
+	const char *in, *p;
+	char *expansion, *out;
+	size_t in_len, out_len;
+
+	out = xmalloc(1);
+	*out = 0;
+	out_len = 1;
+
+	p = in = *str;
+
+	while (1) {
+		if (*p == '$') {
+			in_len = p - in;
+			p++;
+			expansion = expand_dollar(&p);
+			out_len += in_len + strlen(expansion);
+			out = xrealloc(out, out_len);
+			strncat(out, in, in_len);
+			strcat(out, expansion);
+			free(expansion);
+			in = p;
+			continue;
+		}
+
+		if (is_end(*p))
+			break;
+
+		p++;
+	}
+
+	in_len = p - in;
+	out_len += in_len;
+	out = xrealloc(out, out_len);
+	strncat(out, in, in_len);
+
+	/* Advance 'str' to the end character */
+	*str = p;
+
+	return out;
+}
+
+static bool is_end_of_str(char c)
+{
+	return !c;
+}
+
+/*
+ * Expand variables in the given string.  Undefined variables
+ * expand to an empty string.
+ * The returned string must be freed when done.
+ */
+char *expand_string(const char *in)
+{
+	return __expand_string(&in, is_end_of_str);
+}
+
+static bool is_end_of_token(char c)
+{
+	/* Why are '.' and '/' valid characters for symbols? */
+	return !(isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/');
+}
+
+/*
+ * Expand variables in a token.  The parsing stops when a token separater
+ * (in most cases, it is a whitespace) is encountered.  'str' is updated to
+ * point to the next character.
+ *
+ * The returned string must be freed when done.
+ */
+char *expand_one_token(const char **str)
+{
+	return __expand_string(str, is_end_of_token);
+}
