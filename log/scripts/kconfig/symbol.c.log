commit cfc6eea9f6af84e838e28be57b03be5502c4a02e
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Apr 14 00:33:20 2020 +0900

    kconfig: do not use OR-assignment for zero-cleared structure
    
    The simple assignment is enough because memset() three lines above
    has zero-cleared the structure.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 3dc81397d003..9363e37b8870 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -831,7 +831,7 @@ struct symbol *sym_lookup(const char *name, int flags)
 	memset(symbol, 0, sizeof(*symbol));
 	symbol->name = new_name;
 	symbol->type = S_UNKNOWN;
-	symbol->flags |= flags;
+	symbol->flags = flags;
 
 	symbol->next = symbol_hash[hash];
 	symbol_hash[hash] = symbol;

commit 3a9dd3ecb207b2cb8a4aabd12d20e43fa360b66d
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Mar 2 15:23:40 2020 +0900

    kconfig: make 'imply' obey the direct dependency
    
    The 'imply' statement may create unmet direct dependency when the
    implied symbol depends on m.
    
    [Test Code]
    
      config FOO
              tristate "foo"
              imply BAZ
    
      config BAZ
              tristate "baz"
              depends on BAR
    
      config BAR
              def_tristate m
    
      config MODULES
              def_bool y
              option modules
    
    If you set FOO=y, BAZ is also promoted to y, which results in the
    following .config file:
    
      CONFIG_FOO=y
      CONFIG_BAZ=y
      CONFIG_BAR=m
      CONFIG_MODULES=y
    
    This does not meet the dependency 'BAZ depends on BAR'.
    
    Unlike 'select', what is worse, Kconfig never shows the
    'WARNING: unmet direct dependencies detected for ...' for this case.
    
    Because 'imply' is considered to be weaker than 'depends on', Kconfig
    should take the direct dependency into account.
    
    For clarification, describe this case in kconfig-language.rst too.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index b101ef3c377a..3dc81397d003 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -221,7 +221,7 @@ static void sym_calc_visibility(struct symbol *sym)
 		sym_set_changed(sym);
 	}
 	tri = no;
-	if (sym->implied.expr && sym->dir_dep.tri != no)
+	if (sym->implied.expr)
 		tri = expr_calc_value(sym->implied.expr);
 	if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
 		tri = yes;
@@ -394,6 +394,8 @@ void sym_calc_value(struct symbol *sym)
 				if (sym->implied.tri != no) {
 					sym->flags |= SYMBOL_WRITE;
 					newval.tri = EXPR_OR(newval.tri, sym->implied.tri);
+					newval.tri = EXPR_AND(newval.tri,
+							      sym->dir_dep.tri);
 				}
 			}
 		calc_newval:

commit def2fbffe62c00c330c7f41584a356001179c59c
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Mar 2 15:23:39 2020 +0900

    kconfig: allow symbols implied by y to become m
    
    The 'imply' keyword restricts a symbol to y or n, excluding m
    when it is implied by y. This is the original behavior since
    commit 237e3ad0f195 ("Kconfig: Introduce the "imply" keyword").
    
    However, the author of this feature, Nicolas Pitre, stated that
    the 'imply' keyword should not impose any restrictions.
    (https://lkml.org/lkml/2020/2/19/714)
    
    I agree, and want to get rid of this tricky behavior.
    
    Suggested-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 8d38b700b314..b101ef3c377a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -401,8 +401,7 @@ void sym_calc_value(struct symbol *sym)
 				sym_warn_unmet_dep(sym);
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
-		if (newval.tri == mod &&
-		    (sym_get_type(sym) == S_BOOLEAN || sym->implied.tri == yes))
+		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)
 			newval.tri = yes;
 		break;
 	case S_STRING:
@@ -484,8 +483,6 @@ bool sym_tristate_within_range(struct symbol *sym, tristate val)
 		return false;
 	if (sym->visible <= sym->rev_dep.tri)
 		return false;
-	if (sym->implied.tri == yes && val == mod)
-		return false;
 	if (sym_is_choice_value(sym) && sym->visible == yes)
 		return val == yes;
 	return val >= sym->rev_dep.tri && val <= sym->visible;

commit adf7c5bd0674b04588246e444efef9987b2f1a6b
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:23 2019 +0900

    kconfig: squash prop_alloc() into menu_add_prop()
    
    prop_alloc() is only called from menu_add_prop(). Squash it.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index dbc5365d8bbc..8d38b700b314 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1273,27 +1273,6 @@ struct symbol *sym_check_deps(struct symbol *sym)
 	return sym2;
 }
 
-struct property *prop_alloc(enum prop_type type, struct symbol *sym)
-{
-	struct property *prop;
-	struct property **propp;
-
-	prop = xmalloc(sizeof(*prop));
-	memset(prop, 0, sizeof(*prop));
-	prop->type = type;
-	prop->file = current_file;
-	prop->lineno = zconf_lineno();
-
-	/* append property to the prop list of symbol */
-	if (sym) {
-		for (propp = &sym->prop; *propp; propp = &(*propp)->next)
-			;
-		*propp = prop;
-	}
-
-	return prop;
-}
-
 struct symbol *prop_get_symbol(struct property *prop)
 {
 	if (prop->expr && (prop->expr->type == E_SYMBOL ||

commit 6397d96ba5a52c57ee1831a4ddc3aab01bb02048
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:22 2019 +0900

    kconfig: remove sym from struct property
    
    struct property can reference to the symbol that it is associated with
    by prop->menu->sym.
    
    Fix up the one usage of prop->sym, and remove sym from struct property.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index f56eec5ea4c7..dbc5365d8bbc 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1281,7 +1281,6 @@ struct property *prop_alloc(enum prop_type type, struct symbol *sym)
 	prop = xmalloc(sizeof(*prop));
 	memset(prop, 0, sizeof(*prop));
 	prop->type = type;
-	prop->sym = sym;
 	prop->file = current_file;
 	prop->lineno = zconf_lineno();
 

commit 106f1466e7e7057ec6f4dc9516c13ea8cb9dffa0
Merge: 39ceda5ce1b0 e3cd5136a4ec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 16:06:27 2019 -0700

    Merge tag 'kconfig-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull Kconfig updates from Masahiro Yamada:
    
     - always require argument for --defconfig and remove the hard-coded
       arch/$(ARCH)/defconfig path
    
     - make arch/$(SRCARCH)/configs/defconfig the new default of defconfig
    
     - some code cleanups
    
    * tag 'kconfig-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild:
      kconfig: remove meaningless if-conditional in conf_read()
      kconfig: Fix spelling of sym_is_changable
      unicore32: rename unicore32_defconfig to defconfig
      kconfig: make arch/*/configs/defconfig the default of KBUILD_DEFCONFIG
      kconfig: add static qualifier to expand_string()
      kconfig: require the argument of --defconfig
      kconfig: remove always false ifeq ($(KBUILD_DEFCONFIG,) conditional

commit baa23ec860920ebf3e897c4bbb3420a88ea80ec1
Author: Marco Ammon <marco.ammon@fau.de>
Date:   Thu Jul 4 12:50:41 2019 +0200

    kconfig: Fix spelling of sym_is_changable
    
    There is a spelling mistake in "changable", it is corrected to
    "changeable" and all call sites are updated accordingly.
    
    Signed-off-by: Marco Ammon <marco.ammon@fau.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 1f9266dadedf..b78650cf2dbe 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -785,7 +785,7 @@ const char *sym_get_string_value(struct symbol *sym)
 	return (const char *)sym->curr.val;
 }
 
-bool sym_is_changable(struct symbol *sym)
+bool sym_is_changeable(struct symbol *sym)
 {
 	return sym->visible > sym->rev_dep.tri;
 }

commit cd238effefa28fac177e51dcf5e9d1a8b59c3c6b
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Wed Jun 12 14:52:48 2019 -0300

    docs: kbuild: convert docs to ReST and rename to *.rst
    
    The kbuild documentation clearly shows that the documents
    there are written at different times: some use markdown,
    some use their own peculiar logic to split sections.
    
    Convert everything to ReST without affecting too much
    the author's style and avoiding adding uneeded markups.
    
    The conversion is actually:
      - add blank lines and identation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 1f9266dadedf..09fd6fa18e1a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1114,7 +1114,7 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 	}
 
 	fprintf(stderr,
-		"For a resolution refer to Documentation/kbuild/kconfig-language.txt\n"
+		"For a resolution refer to Documentation/kbuild/kconfig-language.rst\n"
 		"subsection \"Kconfig recursive dependency limitations\"\n"
 		"\n");
 

commit 558e78e3ce844c61ceffe32775dbefacf167b023
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Dec 21 17:33:04 2018 +0900

    kconfig: split some C files out of zconf.y
    
    I want to compile each C file independently instead of including all
    of them from zconf.y.
    
    Split out confdata.c, expr.c, symbol.c, and preprocess.c .
    These are low-hanging fruits.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index d1457836e92a..1f9266dadedf 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -86,7 +86,7 @@ static struct property *sym_get_default_prop(struct symbol *sym)
 	return NULL;
 }
 
-static struct property *sym_get_range_prop(struct symbol *sym)
+struct property *sym_get_range_prop(struct symbol *sym)
 {
 	struct property *prop;
 

commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 2e6bf362d164..d1457836e92a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- * Released under the terms of the GNU GPL v2.0.
  */
 
 #include <ctype.h>

commit 2aabbed6774f231c57f8ae6bc4f856fb2a75cd6a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 18:15:51 2018 +0900

    kconfig: remove S_OTHER symbol type and correct dependency tracking
    
    The S_OTHER type could be set only when conf_read_simple() is reading
    include/config/auto.conf file.
    
    For example, CONFIG_FOO=y exists in include/config/auto.conf but it is
    missing from the currently parsed Kconfig files, sym_lookup() allocates
    a new symbol, and sets its type to S_OTHER.
    
    Strangely, it will be set to S_STRING by conf_set_sym_val() a few lines
    below while it is obviously bool or tristate type. On the other hand,
    when CONFIG_BAR="bar" is being dropped from include/config/auto.conf,
    its type remains S_OTHER. Because for_all_symbols() omits S_OTHER
    symbols, conf_touch_deps() misses to touch include/config/bar.h
    
    This behavior has been a pretty mystery for me, and digging the git
    histroy did not help. At least, touching depfiles is broken for string
    type symbols.
    
    I removed S_OTHER entirely, and reimplemented it more simply.
    
    If CONFIG_FOO was visible in the previous syncconfig, but is missing
    now, what we want to do is quite simple; just call conf_touch_dep()
    to touch include/config/foo.h instead of allocating a new symbol data.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 703b9b899ee9..2e6bf362d164 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -61,8 +61,6 @@ const char *sym_type_name(enum symbol_type type)
 		return "string";
 	case S_UNKNOWN:
 		return "unknown";
-	case S_OTHER:
-		break;
 	}
 	return "???";
 }
@@ -757,7 +755,6 @@ const char *sym_get_string_default(struct symbol *sym)
 		return str;
 	case S_STRING:
 		return str;
-	case S_OTHER:
 	case S_UNKNOWN:
 		break;
 	}

commit f498926c47aa7d4f1b6d08af2ba16f3cf8fcb151
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 15 14:59:45 2018 +0900

    kconfig: improve the recursive dependency report
    
    This commit improves the messages of the recursive dependency.
    Currently, sym->dir_dep.expr is not checked.  Hence, any dependency
    in property visibility is regarded as the dependency of the symbol.
    
    [Test Code 1]
    
      config A
              bool "a"
              depends on B
    
      config B
              bool "b"
              depends on A
    
    [Test Code 2]
    
      config A
              bool "a" if B
    
      config B
              bool "b"
              depends on A
    
    For both cases above, the same message is displayed:
    
            symbol B depends on A
            symbol A depends on B
    
    This commit changes the message for the latter, like this:
    
            symbol B depends on A
            symbol A prompt is visible depending on B
    
    Also, 'select' and 'imply' are distinguished.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Dirk Gouders <dirk@gouders.net>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 90e706096af8..703b9b899ee9 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1011,7 +1011,7 @@ static struct dep_stack {
 	struct dep_stack *prev, *next;
 	struct symbol *sym;
 	struct property *prop;
-	struct expr *expr;
+	struct expr **expr;
 } *check_top;
 
 static void dep_stack_insert(struct dep_stack *stack, struct symbol *sym)
@@ -1076,31 +1076,42 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 			fprintf(stderr, "%s:%d:error: recursive dependency detected!\n",
 				prop->file->name, prop->lineno);
 
-		if (stack->expr) {
-			fprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",
-				prop->file->name, prop->lineno,
+		if (sym_is_choice(sym)) {
+			fprintf(stderr, "%s:%d:\tchoice %s contains symbol %s\n",
+				menu->file->name, menu->lineno,
+				sym->name ? sym->name : "<choice>",
+				next_sym->name ? next_sym->name : "<choice>");
+		} else if (sym_is_choice_value(sym)) {
+			fprintf(stderr, "%s:%d:\tsymbol %s is part of choice %s\n",
+				menu->file->name, menu->lineno,
 				sym->name ? sym->name : "<choice>",
-				prop_get_type_name(prop->type),
 				next_sym->name ? next_sym->name : "<choice>");
-		} else if (stack->prop) {
+		} else if (stack->expr == &sym->dir_dep.expr) {
 			fprintf(stderr, "%s:%d:\tsymbol %s depends on %s\n",
 				prop->file->name, prop->lineno,
 				sym->name ? sym->name : "<choice>",
 				next_sym->name ? next_sym->name : "<choice>");
-		} else if (sym_is_choice(sym)) {
-			fprintf(stderr, "%s:%d:\tchoice %s contains symbol %s\n",
-				menu->file->name, menu->lineno,
+		} else if (stack->expr == &sym->rev_dep.expr) {
+			fprintf(stderr, "%s:%d:\tsymbol %s is selected by %s\n",
+				prop->file->name, prop->lineno,
 				sym->name ? sym->name : "<choice>",
 				next_sym->name ? next_sym->name : "<choice>");
-		} else if (sym_is_choice_value(sym)) {
-			fprintf(stderr, "%s:%d:\tsymbol %s is part of choice %s\n",
-				menu->file->name, menu->lineno,
+		} else if (stack->expr == &sym->implied.expr) {
+			fprintf(stderr, "%s:%d:\tsymbol %s is implied by %s\n",
+				prop->file->name, prop->lineno,
 				sym->name ? sym->name : "<choice>",
 				next_sym->name ? next_sym->name : "<choice>");
+		} else if (stack->expr) {
+			fprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",
+				prop->file->name, prop->lineno,
+				sym->name ? sym->name : "<choice>",
+				prop_get_type_name(prop->type),
+				next_sym->name ? next_sym->name : "<choice>");
 		} else {
-			fprintf(stderr, "%s:%d:\tsymbol %s is selected or implied by %s\n",
+			fprintf(stderr, "%s:%d:\tsymbol %s %s is visible depending on %s\n",
 				prop->file->name, prop->lineno,
 				sym->name ? sym->name : "<choice>",
+				prop_get_type_name(prop->type),
 				next_sym->name ? next_sym->name : "<choice>");
 		}
 	}
@@ -1157,14 +1168,23 @@ static struct symbol *sym_check_sym_deps(struct symbol *sym)
 
 	dep_stack_insert(&stack, sym);
 
+	stack.expr = &sym->dir_dep.expr;
+	sym2 = sym_check_expr_deps(sym->dir_dep.expr);
+	if (sym2)
+		goto out;
+
+	stack.expr = &sym->rev_dep.expr;
 	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
 	if (sym2)
 		goto out;
 
+	stack.expr = &sym->implied.expr;
 	sym2 = sym_check_expr_deps(sym->implied.expr);
 	if (sym2)
 		goto out;
 
+	stack.expr = NULL;
+
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->type == P_CHOICE || prop->type == P_SELECT ||
 		    prop->type == P_IMPLY)
@@ -1175,7 +1195,7 @@ static struct symbol *sym_check_sym_deps(struct symbol *sym)
 			break;
 		if (prop->type != P_DEFAULT || sym_is_choice(sym))
 			continue;
-		stack.expr = prop->expr;
+		stack.expr = &prop->expr;
 		sym2 = sym_check_expr_deps(prop->expr);
 		if (sym2)
 			break;

commit 5e8c5299d31519e0327be1020f309fa62dc53036
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 15 14:59:44 2018 +0900

    kconfig: report recursive dependency involving 'imply'
    
    Currently, Kconfig does not complain about the recursive dependency
    where 'imply' keywords are involved.
    
    [Test Code]
    
      config A
              bool "a"
    
      config B
              bool "b"
              imply A
              depends on A
    
    In the code above, Kconfig cannot calculate the symbol values correctly
    due to the circular dependency.  For example, allyesconfig followed by
    syncconfig results in an odd behavior because CONFIG_B becomes visible
    in syncconfig.
    
      $ make allyesconfig
      scripts/kconfig/conf  --allyesconfig Kconfig
      #
      # configuration written to .config
      #
      $ cat .config
      #
      # Automatically generated file; DO NOT EDIT.
      # Main menu
      #
      CONFIG_A=y
      $ make syncconfig
      scripts/kconfig/conf  --syncconfig Kconfig
      *
      * Restart config...
      *
      *
      * Main menu
      *
      a (A) [Y/n/?] y
        b (B) [N/y/?] (NEW)
    
    To detect this correctly, sym_check_expr_deps() should recurse to
    not only sym->rev_dep.expr but also sym->implied.expr .
    
    At this moment, sym_check_print_recursive() cannot distinguish
    'select' and 'imply' since it does not know the precise context
    where the recursive dependency has been hit.  This will be solved
    by the next commit.
    
    In fact, even the document and the unit-test are confused.  Using
    'imply' does not solve recursive dependency since 'imply' addresses
    the unmet direct dependency, which 'select' could cause.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Dirk Gouders <dirk@gouders.net>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 688f487ff454..90e706096af8 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1098,7 +1098,7 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 				sym->name ? sym->name : "<choice>",
 				next_sym->name ? next_sym->name : "<choice>");
 		} else {
-			fprintf(stderr, "%s:%d:\tsymbol %s is selected by %s\n",
+			fprintf(stderr, "%s:%d:\tsymbol %s is selected or implied by %s\n",
 				prop->file->name, prop->lineno,
 				sym->name ? sym->name : "<choice>",
 				next_sym->name ? next_sym->name : "<choice>");
@@ -1161,8 +1161,13 @@ static struct symbol *sym_check_sym_deps(struct symbol *sym)
 	if (sym2)
 		goto out;
 
+	sym2 = sym_check_expr_deps(sym->implied.expr);
+	if (sym2)
+		goto out;
+
 	for (prop = sym->prop; prop; prop = prop->next) {
-		if (prop->type == P_CHOICE || prop->type == P_SELECT)
+		if (prop->type == P_CHOICE || prop->type == P_SELECT ||
+		    prop->type == P_IMPLY)
 			continue;
 		stack.prop = prop;
 		sym2 = sym_check_expr_deps(prop->visible.expr);

commit f1575595d15657bd78c139978107deabec5a3959
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 15 14:59:43 2018 +0900

    kconfig: error out when seeing recursive dependency
    
    Originally, recursive dependency was a fatal error for Kconfig
    because Kconfig cannot compute symbol values in such a situation.
    
    Commit d595cea62403 ("kconfig: print more info when we see a recursive
    dependency") changed it to a warning, which I guess was not intentional.
    
    Get it back to an error again.
    
    Also, rename the unit test directory "warn_recursive_dep" to
    "err_recursive_dep" so that it matches to the behavior.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Dirk Gouders <dirk@gouders.net>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 4ec8b1f0d42c..688f487ff454 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1248,9 +1248,6 @@ struct symbol *sym_check_deps(struct symbol *sym)
 		sym->flags &= ~SYMBOL_CHECK;
 	}
 
-	if (sym2 && sym2 == sym)
-		sym2 = NULL;
-
 	return sym2;
 }
 

commit 1880861226c13ddd42c34ddd30c3b502b650fe29
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Aug 14 01:48:39 2018 +0900

    kconfig: remove P_ENV property type
    
    This property is not set by anyone since commit 104daea149c4 ("kconfig:
    reference environment variables directly and remove 'option env='").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 073d780f7ec9..4ec8b1f0d42c 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1289,8 +1289,6 @@ const char *prop_get_type_name(enum prop_type type)
 	switch (type) {
 	case P_PROMPT:
 		return "prompt";
-	case P_ENV:
-		return "env";
 	case P_COMMENT:
 		return "comment";
 	case P_MENU:

commit c151272d1687ce2a379a93bf848080f9a42f1cef
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Aug 14 01:48:38 2018 +0900

    kconfig: remove unused sym_get_env_prop() function
    
    This function is unused since commit 104daea149c4 ("kconfig: reference
    environment variables directly and remove 'option env='").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 869a5e8e87a5..073d780f7ec9 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -76,15 +76,6 @@ struct property *sym_get_choice_prop(struct symbol *sym)
 	return NULL;
 }
 
-struct property *sym_get_env_prop(struct symbol *sym)
-{
-	struct property *prop;
-
-	for_all_properties(sym, prop, P_ENV)
-		return prop;
-	return NULL;
-}
-
 static struct property *sym_get_default_prop(struct symbol *sym)
 {
 	struct property *prop;

commit 693359f7ac9012778590a370d076b13db704255e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Tue Jul 3 14:43:31 2018 +0200

    kconfig: rename SYMBOL_AUTO to SYMBOL_NO_WRITE
    
    Over time, the use of the flag SYMBOL_AUTO changed from initially
    marking three automatically generated symbols ARCH, KERNELRELEASE and
    UNAME_RELEASE to today's effect of protecting symbols from being
    written out.
    
    Currently, only symbols of type CHOICE and those with option
    defconf_list set have that flag set.
    
    Reflect that change in semantics in the flag's name.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 7c9a88e91cfa..869a5e8e87a5 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -463,7 +463,7 @@ void sym_calc_value(struct symbol *sym)
 		}
 	}
 
-	if (sym->flags & SYMBOL_AUTO)
+	if (sym->flags & SYMBOL_NO_WRITE)
 		sym->flags &= ~SYMBOL_WRITE;
 
 	if (sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES)

commit 5b31a9746756ea76b08be035b49c86319973b395
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:43 2018 +0900

    kconfig: remove sym_expand_string_value()
    
    There is no more caller of sym_expand_string_value().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 2460648a581a..7c9a88e91cfa 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -879,59 +879,6 @@ struct symbol *sym_find(const char *name)
 	return symbol;
 }
 
-/*
- * Expand symbol's names embedded in the string given in argument. Symbols'
- * name to be expanded shall be prefixed by a '$'. Unknown symbol expands to
- * the empty string.
- */
-char *sym_expand_string_value(const char *in)
-{
-	const char *src;
-	char *res;
-	size_t reslen;
-
-	/*
-	 * Note: 'in' might come from a token that's about to be
-	 * freed, so make sure to always allocate a new string
-	 */
-	reslen = strlen(in) + 1;
-	res = xmalloc(reslen);
-	res[0] = '\0';
-
-	while ((src = strchr(in, '$'))) {
-		char *p, name[SYMBOL_MAXLENGTH];
-		const char *symval = "";
-		struct symbol *sym;
-		size_t newlen;
-
-		strncat(res, in, src - in);
-		src++;
-
-		p = name;
-		while (isalnum(*src) || *src == '_')
-			*p++ = *src++;
-		*p = '\0';
-
-		sym = sym_find(name);
-		if (sym != NULL) {
-			sym_calc_value(sym);
-			symval = sym_get_string_value(sym);
-		}
-
-		newlen = strlen(res) + strlen(symval) + strlen(src) + 1;
-		if (newlen > reslen) {
-			reslen = newlen;
-			res = xrealloc(res, reslen);
-		}
-
-		strcat(res, symval);
-		in = src;
-	}
-	strcat(res, in);
-
-	return res;
-}
-
 const char *sym_escape_string_value(const char *in)
 {
 	const char *p;

commit 104daea149c45cc84842ce77a9bd6436d19f3dd8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:40 2018 +0900

    kconfig: reference environment variables directly and remove 'option env='
    
    To get access to environment variables, Kconfig needs to define a
    symbol using "option env=" syntax.  It is tedious to add a symbol entry
    for each environment variable given that we need to define much more
    such as 'CC', 'AS', 'srctree' etc. to evaluate the compiler capability
    in Kconfig.
    
    Adding '$' for symbol references is grammatically inconsistent.
    Looking at the code, the symbols prefixed with 'S' are expanded by:
     - conf_expand_value()
       This is used to expand 'arch/$ARCH/defconfig' and 'defconfig_list'
     - sym_expand_string_value()
       This is used to expand strings in 'source' and 'mainmenu'
    
    All of them are fixed values independent of user configuration.  So,
    they can be changed into the direct expansion instead of symbols.
    
    This change makes the code much cleaner.  The bounce symbols 'SRCARCH',
    'ARCH', 'SUBARCH', 'KERNELVERSION' are gone.
    
    sym_init() hard-coding 'UNAME_RELEASE' is also gone.  'UNAME_RELEASE'
    should be replaced with an environment variable.
    
    ARCH_DEFCONFIG is a normal symbol, so it should be simply referenced
    without '$' prefix.
    
    The new syntax is addicted by Make.  The variable reference needs
    parentheses, like $(FOO), but you can omit them for single-letter
    variables, like $F.  Yet, in Makefiles, people tend to use the
    parenthetical form for consistency / clarification.
    
    At this moment, only the environment variable is supported, but I will
    extend the concept of 'variable' later on.
    
    The variables are expanded in the lexer so we can simplify the token
    handling on the parser side.
    
    For example, the following code works.
    
    [Example code]
    
      config MY_TOOLCHAIN_LIST
              string
              default "My tools: CC=$(CC), AS=$(AS), CPP=$(CPP)"
    
    [Result]
    
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_MY_TOOLCHAIN_LIST="My tools: CC=gcc, AS=as, CPP=gcc -E"
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index f0b2e3b3102d..2460648a581a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -33,33 +33,6 @@ struct symbol *sym_defconfig_list;
 struct symbol *modules_sym;
 tristate modules_val;
 
-struct expr *sym_env_list;
-
-static void sym_add_default(struct symbol *sym, const char *def)
-{
-	struct property *prop = prop_alloc(P_DEFAULT, sym);
-
-	prop->expr = expr_alloc_symbol(sym_lookup(def, SYMBOL_CONST));
-}
-
-void sym_init(void)
-{
-	struct symbol *sym;
-	struct utsname uts;
-	static bool inited = false;
-
-	if (inited)
-		return;
-	inited = true;
-
-	uname(&uts);
-
-	sym = sym_lookup("UNAME_RELEASE", 0);
-	sym->type = S_STRING;
-	sym->flags |= SYMBOL_AUTO;
-	sym_add_default(sym, uts.release);
-}
-
 enum symbol_type sym_get_type(struct symbol *sym)
 {
 	enum symbol_type type = sym->type;
@@ -1401,32 +1374,3 @@ const char *prop_get_type_name(enum prop_type type)
 	}
 	return "unknown";
 }
-
-static void prop_add_env(const char *env)
-{
-	struct symbol *sym, *sym2;
-	struct property *prop;
-	char *p;
-
-	sym = current_entry->sym;
-	sym->flags |= SYMBOL_AUTO;
-	for_all_properties(sym, prop, P_ENV) {
-		sym2 = prop_get_symbol(prop);
-		if (strcmp(sym2->name, env))
-			menu_warn(current_entry, "redefining environment symbol from %s",
-				  sym2->name);
-		return;
-	}
-
-	prop = prop_alloc(P_ENV, sym);
-	prop->expr = expr_alloc_symbol(sym_lookup(env, SYMBOL_CONST));
-
-	sym_env_list = expr_alloc_one(E_LIST, sym_env_list);
-	sym_env_list->right.sym = sym;
-
-	p = getenv(env);
-	if (p)
-		sym_add_default(sym, p);
-	else
-		menu_warn(current_entry, "environment variable %s undefined", env);
-}

commit f8f69dc0b4e070d4a4d39889a85424913cc922d5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Mar 13 18:56:08 2018 +0900

    kconfig: make unmet dependency warnings readable
    
    Currently, the unmet dependency warnings end up with endlessly long
    expressions, most of which are false positives.
    
    Here is test code to demonstrate how it currently works.
    
    [Test Case]
    
      config DEP1
              def_bool y
    
      config DEP2
              bool "DEP2"
    
      config A
              bool "A"
              select E
    
      config B
              bool "B"
              depends on DEP2
              select E
    
      config C
              bool "C"
              depends on DEP1 && DEP2
              select E
    
      config D
              def_bool n
              select E
    
      config E
              bool
              depends on DEP1 && DEP2
    
    [Result]
    
      $ make config
      scripts/kconfig/conf  --oldaskconfig Kconfig
      *
      * Linux Kernel Configuration
      *
      DEP2 (DEP2) [N/y/?] (NEW) n
      A (A) [N/y/?] (NEW) y
      warning: (A && B && D) selects E which has unmet direct
      dependencies (DEP1 && DEP2)
    
    Here, I see some points to be improved.
    
    First, '(A || B || D)' would make more sense than '(A && B && D)'.
    I am not sure if this is intentional, but expr_simplify_unmet_dep()
    turns OR expressions into AND, like follows:
    
            case E_OR:
                    return expr_alloc_and(
    
    Second, we see false positives.  'A' is a real unmet dependency.
    'B' is false positive because 'DEP1' is fixed to 'y', and 'B' depends
    on 'DEP2'.  'C' was correctly dropped by expr_simplify_unmet_dep().
    'D' is also false positive because it has no chance to be enabled.
    Current expr_simplify_unmet_dep() cannot avoid those false positives.
    
    After all, I decided to use the same helpers as used for printing
    reverse dependencies in the help.
    
    With this commit, unreadable warnings (most of the reported symbols are
    false positives) in the real world:
    
    $ make ARCH=score allyesconfig
    scripts/kconfig/conf  --allyesconfig Kconfig
    warning: (HWSPINLOCK_QCOM && AHCI_MTK && STMMAC_PLATFORM &&
     DWMAC_IPQ806X && DWMAC_LPC18XX && DWMAC_OXNAS && DWMAC_ROCKCHIP &&
     DWMAC_SOCFPGA && DWMAC_STI && TI_CPSW && PINCTRL_GEMINI &&
     PINCTRL_OXNAS && PINCTRL_ROCKCHIP && PINCTRL_DOVE &&
     PINCTRL_ARMADA_37XX && PINCTRL_STM32 && S3C2410_WATCHDOG &&
     VIDEO_OMAP3 && VIDEO_S5P_FIMC && USB_XHCI_MTK && RTC_DRV_AT91SAM9 &&
     LPC18XX_DMAMUX && VIDEO_OMAP4 && COMMON_CLK_GEMINI &&
     COMMON_CLK_ASPEED && COMMON_CLK_NXP && COMMON_CLK_OXNAS &&
     COMMON_CLK_BOSTON && QCOM_ADSP_PIL && QCOM_Q6V5_PIL && QCOM_GSBI &&
     ATMEL_EBI && ST_IRQCHIP && RESET_IMX7 && PHY_HI6220_USB &&
     PHY_RALINK_USB && PHY_ROCKCHIP_PCIE && PHY_DA8XX_USB) selects
     MFD_SYSCON which has unmet direct dependencies (HAS_IOMEM)
    warning: (PINCTRL_AT91 && PINCTRL_AT91PIO4 && PINCTRL_OXNAS &&
     PINCTRL_PISTACHIO && PINCTRL_PIC32 && PINCTRL_MESON &&
     PINCTRL_NOMADIK && PINCTRL_MTK && PINCTRL_MT7622 && GPIO_TB10X)
     selects OF_GPIO which has unmet direct dependencies (GPIOLIB && OF &&
     HAS_IOMEM)
    warning: (FAULT_INJECTION_STACKTRACE_FILTER && LATENCYTOP && LOCKDEP)
     selects FRAME_POINTER which has unmet direct dependencies
     (DEBUG_KERNEL && (CRIS || M68K || FRV || UML || SUPERH || BLACKFIN ||
     MN10300 || METAG) || ARCH_WANT_FRAME_POINTERS)
    
    will be turned into:
    
    $ make ARCH=score allyesconfig
    scripts/kconfig/conf  --allyesconfig Kconfig
    
    WARNING: unmet direct dependencies detected for MFD_SYSCON
      Depends on [n]: HAS_IOMEM [=n]
      Selected by [y]:
      - PINCTRL_STM32 [=y] && PINCTRL [=y] && (ARCH_STM32 ||
     COMPILE_TEST [=y]) && OF [=y]
      - RTC_DRV_AT91SAM9 [=y] && RTC_CLASS [=y] && (ARCH_AT91 ||
     COMPILE_TEST [=y])
      - RESET_IMX7 [=y] && RESET_CONTROLLER [=y]
      - PHY_HI6220_USB [=y] && (ARCH_HISI && ARM64 ||
     COMPILE_TEST [=y])
      - PHY_RALINK_USB [=y] && (RALINK || COMPILE_TEST [=y])
      - PHY_ROCKCHIP_PCIE [=y] && (ARCH_ROCKCHIP && OF [=y] ||
     COMPILE_TEST [=y])
    
    WARNING: unmet direct dependencies detected for OF_GPIO
      Depends on [n]: GPIOLIB [=y] && OF [=y] && HAS_IOMEM [=n]
      Selected by [y]:
      - PINCTRL_MTK [=y] && PINCTRL [=y] && (ARCH_MEDIATEK ||
     COMPILE_TEST [=y]) && OF [=y]
      - PINCTRL_MT7622 [=y] && PINCTRL [=y] && (ARCH_MEDIATEK ||
     COMPILE_TEST [=y]) && OF [=y] && (ARM64 || COMPILE_TEST [=y])
    
    WARNING: unmet direct dependencies detected for FRAME_POINTER
      Depends on [n]: DEBUG_KERNEL [=y] && (CRIS || M68K || FRV || UML ||
     SUPERH || BLACKFIN || MN10300 || METAG) || ARCH_WANT_FRAME_POINTERS [=n]
      Selected by [y]:
      - LATENCYTOP [=y] && DEBUG_KERNEL [=y] && STACKTRACE_SUPPORT [=y] &&
     PROC_FS [=y] && !MIPS && !PPC && !S390 && !MICROBLAZE && !ARM_UNWIND &&
     !ARC && !X86
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Petr Vorel <petr.vorel@gmail.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 6acf536c9726..f0b2e3b3102d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -333,6 +333,27 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 	return def_sym;
 }
 
+static void sym_warn_unmet_dep(struct symbol *sym)
+{
+	struct gstr gs = str_new();
+
+	str_printf(&gs,
+		   "\nWARNING: unmet direct dependencies detected for %s\n",
+		   sym->name);
+	str_printf(&gs,
+		   "  Depends on [%c]: ",
+		   sym->dir_dep.tri == mod ? 'm' : 'n');
+	expr_gstr_print(sym->dir_dep.expr, &gs);
+	str_printf(&gs, "\n");
+
+	expr_gstr_print_revdep(sym->rev_dep.expr, &gs, yes,
+			       "  Selected by [y]:\n");
+	expr_gstr_print_revdep(sym->rev_dep.expr, &gs, mod,
+			       "  Selected by [m]:\n");
+
+	fputs(str_get(&gs), stderr);
+}
+
 void sym_calc_value(struct symbol *sym)
 {
 	struct symbol_value newval, oldval;
@@ -414,18 +435,8 @@ void sym_calc_value(struct symbol *sym)
 				}
 			}
 		calc_newval:
-			if (sym->dir_dep.tri < sym->rev_dep.tri) {
-				struct expr *e;
-				e = expr_simplify_unmet_dep(sym->rev_dep.expr,
-				    sym->dir_dep.expr);
-				fprintf(stderr, "warning: (");
-				expr_fprint(e, stderr);
-				fprintf(stderr, ") selects %s which has unmet direct dependencies (",
-					sym->name);
-				expr_fprint(sym->dir_dep.expr, stderr);
-				fprintf(stderr, ")\n");
-				expr_free(e);
-			}
+			if (sym->dir_dep.tri < sym->rev_dep.tri)
+				sym_warn_unmet_dep(sym);
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
 		if (newval.tri == mod &&

commit f622f8279581626170154d77d67e67bcb227ca2f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Mar 13 18:56:07 2018 +0900

    kconfig: warn unmet direct dependency of tristate symbols selected by y
    
    Commit 246cf9c26bf1 ("kbuild: Warn on selecting symbols with unmet
    direct dependencies") forcibly promoted ->dir_dep.tri to yes from mod.
    So, the unmet direct dependencies of tristate symbols are not reported.
    
    [Test Case]
    
      config MODULES
              def_bool y
              option modules
    
      config A
              def_bool y
              select B
    
      config B
              tristate "B"
              depends on m
    
    This causes unmet dependency because 'B' is forced 'y' ignoring
    'depends on m'.  This should be warned.
    
    On the other hand, the following case ('B' is bool) should not be
    warned, so 'depends on m' for bool symbols should be naturally treated
    as 'depends on y'.
    
    [Test Case2 (not unmet dependency)]
    
      config MODULES
              def_bool y
              option modules
    
      config A
              def_bool y
              select B
    
      config B
              bool "B"
              depends on m
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 0f7eba7d472a..6acf536c9726 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -243,7 +243,7 @@ static void sym_calc_visibility(struct symbol *sym)
 	tri = yes;
 	if (sym->dir_dep.expr)
 		tri = expr_calc_value(sym->dir_dep.expr);
-	if (tri == mod)
+	if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
 		tri = yes;
 	if (sym->dir_dep.tri != tri) {
 		sym->dir_dep.tri = tri;
@@ -414,7 +414,7 @@ void sym_calc_value(struct symbol *sym)
 				}
 			}
 		calc_newval:
-			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
+			if (sym->dir_dep.tri < sym->rev_dep.tri) {
 				struct expr *e;
 				e = expr_simplify_unmet_dep(sym->rev_dep.expr,
 				    sym->dir_dep.expr);

commit f467c5640c29ad258c3cd8186a776c82fc3b8057
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Fri Feb 23 12:49:01 2018 +0100

    kconfig: only write '# CONFIG_FOO is not set' for visible symbols
    
    === Background ===
    
     - Visible n-valued bool/tristate symbols generate a
       '# CONFIG_FOO is not set' line in the .config file. The idea is to
       remember the user selection without having to set a Makefile
       variable. Having n correspond to the variable being undefined in the
       Makefiles makes for easy CONFIG_* tests.
    
     - Invisible n-valued bool/tristate symbols normally do not generate a
       '# CONFIG_FOO is not set' line, because user values from .config
       files have no effect on invisible symbols anyway.
    
    Currently, there is one exception to this rule: Any bool/tristate symbol
    that gets the value n through a 'default' property generates a
    '# CONFIG_FOO is not set' line, even if the symbol is invisible.
    
    Note that this only applies to explicitly given defaults, and not when
    the symbol implicitly defaults to n (like bool/tristate symbols without
    'default' properties do).
    
    This is inconsistent, and seems redundant:
    
      - As mentioned, the '# CONFIG_FOO is not set' won't affect the symbol
        once the .config is read back in.
    
      - Even if the symbol is invisible at first but becomes visible later,
        there shouldn't be any harm in recalculating the default value
        rather than viewing the '# CONFIG_FOO is not set' as a previous
        user value of n.
    
    === Changes ===
    
    Change sym_calc_value() to only set SYMBOL_WRITE (write to .config) for
    non-n-valued 'default' properties.
    
    Note that SYMBOL_WRITE is always set for visible symbols regardless of whether
    they have 'default' properties or not, so this change only affects invisible
    symbols.
    
    This reduces the size of the x86 .config on my system by about 1% (due
    to removed '# CONFIG_FOO is not set' entries).
    
    One side effect of (and the main motivation for) this change is making
    the following two definitions behave exactly the same:
    
            config FOO
                    bool
    
            config FOO
                    bool
                    default n
    
    With this change, neither of these will generate a
    '# CONFIG_FOO is not set' line (assuming FOO isn't selected/implied).
    That might make it clearer to people that a bare 'default n' is
    redundant.
    
    This change only affects generated .config files and not autoconf.h:
    autoconf.h only includes #defines for non-n bool/tristate symbols.
    
    === Testing ===
    
    The following testing was done with the x86 Kconfigs:
    
     - .config files generated before and after the change were compared to
       verify that the only difference is some '# CONFIG_FOO is not set'
       entries disappearing. A couple of these were inspected manually, and
       most turned out to be from redundant 'default n/def_bool n'
       properties.
    
     - The generated include/generated/autoconf.h was compared before and
       after the change and verified to be identical.
    
     - As a sanity check, the same modification was done to Kconfiglib.
       The Kconfiglib test suite was then run to check for any mismatches
       against the output of the C implementation.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 2220bc4b051b..0f7eba7d472a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -403,9 +403,10 @@ void sym_calc_value(struct symbol *sym)
 			if (!sym_is_choice(sym)) {
 				prop = sym_get_default_prop(sym);
 				if (prop) {
-					sym->flags |= SYMBOL_WRITE;
 					newval.tri = EXPR_AND(expr_calc_value(prop->expr),
 							      prop->visible.tri);
+					if (newval.tri != no)
+						sym->flags |= SYMBOL_WRITE;
 				}
 				if (sym->implied.tri != no) {
 					sym->flags |= SYMBOL_WRITE;

commit cd81fc82b93fa408c30e08f59e5ef8caaa91d1d2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Feb 17 03:38:31 2018 +0900

    kconfig: add xstrdup() helper
    
    We already have xmalloc(), xcalloc(), and xrealloc(().  Add xstrdup()
    as well to save tedious error handling.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index cca9663be5dd..2220bc4b051b 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -183,7 +183,7 @@ static void sym_validate_range(struct symbol *sym)
 		sprintf(str, "%lld", val2);
 	else
 		sprintf(str, "0x%llx", val2);
-	sym->curr.val = strdup(str);
+	sym->curr.val = xstrdup(str);
 }
 
 static void sym_set_changed(struct symbol *sym)
@@ -849,7 +849,7 @@ struct symbol *sym_lookup(const char *name, int flags)
 				   : !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))
 				return symbol;
 		}
-		new_name = strdup(name);
+		new_name = xstrdup(name);
 	} else {
 		new_name = NULL;
 		hash = 0;

commit 523ca58b7db2e30e3c185a7927dd80a30c1bc743
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 9 01:19:08 2018 +0900

    kconfig: remove const qualifier from sym_expand_string_value()
    
    This function returns realloc'ed memory, so the returned pointer
    must be passed to free() when done.  So, 'const' qualifier is odd.
    It is allowed to modify the expanded string.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 60a76f958f33..cca9663be5dd 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -899,7 +899,7 @@ struct symbol *sym_find(const char *name)
  * name to be expanded shall be prefixed by a '$'. Unknown symbol expands to
  * the empty string.
  */
-const char *sym_expand_string_value(const char *in)
+char *sym_expand_string_value(const char *in)
 {
 	const char *src;
 	char *res;

commit d717f24d8c68081caae2374cf5ea6c4e62c490fc
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 9 01:19:07 2018 +0900

    kconfig: add xrealloc() helper
    
    We already have xmalloc(), xcalloc().  Add xrealloc() as well
    to save tedious error handling.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c4409ee7fee2..60a76f958f33 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -936,7 +936,7 @@ const char *sym_expand_string_value(const char *in)
 		newlen = strlen(res) + strlen(symval) + strlen(src) + 1;
 		if (newlen > reslen) {
 			reslen = newlen;
-			res = realloc(res, reslen);
+			res = xrealloc(res, reslen);
 		}
 
 		strcat(res, symval);

commit 9e3e10c725360b9d07018cfcd5b7b6b7d325fae5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Feb 6 09:34:41 2018 +0900

    kconfig: send error messages to stderr
    
    These messages should be directed to stderr.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Ulf Magnusson <ulfalizer@gmail.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 13f7fdfe328d..c4409ee7fee2 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1221,7 +1221,7 @@ static struct symbol *sym_check_expr_deps(struct expr *e)
 	default:
 		break;
 	}
-	printf("Oops! How to check %d?\n", e->type);
+	fprintf(stderr, "Oops! How to check %d?\n", e->type);
 	return NULL;
 }
 

commit cb67ab2cd2b8abd9650292c986c79901e3073a59
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Feb 6 09:34:42 2018 +0900

    kconfig: do not write choice values when their dependency becomes n
    
    "# CONFIG_... is not set" for choice values are wrongly written into
    the .config file if they are once visible, then become invisible later.
    
      Test case
      ---------
    
    ---------------------------(Kconfig)----------------------------
    config A
            bool "A"
    
    choice
            prompt "Choice ?"
            depends on A
    
    config CHOICE_B
            bool "Choice B"
    
    config CHOICE_C
            bool "Choice C"
    
    endchoice
    ----------------------------------------------------------------
    
    ---------------------------(.config)----------------------------
    CONFIG_A=y
    ----------------------------------------------------------------
    
    With the Kconfig and .config above,
    
      $ make config
      scripts/kconfig/conf  --oldaskconfig Kconfig
      *
      * Linux Kernel Configuration
      *
      A (A) [Y/n] n
      #
      # configuration written to .config
      #
      $ cat .config
      #
      # Automatically generated file; DO NOT EDIT.
      # Linux Kernel Configuration
      #
      # CONFIG_A is not set
      # CONFIG_CHOICE_B is not set
      # CONFIG_CHOICE_C is not set
    
    Here,
    
      # CONFIG_CHOICE_B is not set
      # CONFIG_CHOICE_C is not set
    
    should not be written into the .config file because their dependency
    "depends on A" is unmet.
    
    Currently, there is no code that clears SYMBOL_WRITE of choice values.
    
    Clear SYMBOL_WRITE for all symbols in sym_calc_value(), then set it
    again after calculating visibility.  To simplify the logic, set the
    flag if they have non-n visibility, regardless of types, and regardless
    of whether they are choice values or not.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Ulf Magnusson <ulfalizer@gmail.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c9123ed2b791..13f7fdfe328d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -371,11 +371,13 @@ void sym_calc_value(struct symbol *sym)
 		sym->curr.tri = no;
 		return;
 	}
-	if (!sym_is_choice_value(sym))
-		sym->flags &= ~SYMBOL_WRITE;
+	sym->flags &= ~SYMBOL_WRITE;
 
 	sym_calc_visibility(sym);
 
+	if (sym->visible != no)
+		sym->flags |= SYMBOL_WRITE;
+
 	/* set default if recursively called */
 	sym->curr = newval;
 
@@ -390,7 +392,6 @@ void sym_calc_value(struct symbol *sym)
 				/* if the symbol is visible use the user value
 				 * if available, otherwise try the default value
 				 */
-				sym->flags |= SYMBOL_WRITE;
 				if (sym_has_value(sym)) {
 					newval.tri = EXPR_AND(sym->def[S_DEF_USER].tri,
 							      sym->visible);
@@ -433,12 +434,9 @@ void sym_calc_value(struct symbol *sym)
 	case S_STRING:
 	case S_HEX:
 	case S_INT:
-		if (sym->visible != no) {
-			sym->flags |= SYMBOL_WRITE;
-			if (sym_has_value(sym)) {
-				newval.val = sym->def[S_DEF_USER].val;
-				break;
-			}
+		if (sym->visible != no && sym_has_value(sym)) {
+			newval.val = sym->def[S_DEF_USER].val;
+			break;
 		}
 		prop = sym_get_default_prop(sym);
 		if (prop) {

commit b92d804a51796b77c7b2b11881b2700eaac88114
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Dec 16 00:38:02 2017 +0900

    kconfig: drop 'boolean' keyword
    
    No more users of this keyword.  Drop it according to the notice by
    commit 6341e62b212a ("kconfig: use bool instead of boolean for type
    definition attributes").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 55c95e0bb48a..c9123ed2b791 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -77,7 +77,7 @@ const char *sym_type_name(enum symbol_type type)
 {
 	switch (type) {
 	case S_BOOLEAN:
-		return "boolean";
+		return "bool";
 	case S_TRISTATE:
 		return "tristate";
 	case S_INT:

commit 24161a6711c94598fdebb0aac1301881ada47908
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Oct 8 19:11:19 2017 +0200

    kconfig: Don't leak 'source' filenames during parsing
    
    The 'source_stmt' nonterminal takes a 'prompt', which consists of either
    a T_WORD or a T_WORD_QUOTE, both of which are always allocated on the
    heap in zconf.l and need to have their associated strings freed. Free
    them.
    
    The existing code already makes sure to always copy the string, but add
    a warning to sym_expand_string_value() to make it clear that the string
    must be copied, just in case.
    
    Summary from Valgrind on 'menuconfig' (ARCH=x86) before the fix:
    
            LEAK SUMMARY:
               definitely lost: 387,504 bytes in 15,545 blocks
               ...
    
    Summary after the fix:
    
            LEAK SUMMARY:
               definitely lost: 344,616 bytes in 14,355 blocks
               ...
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 35e0937aa6a6..55c95e0bb48a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -907,6 +907,10 @@ const char *sym_expand_string_value(const char *in)
 	char *res;
 	size_t reslen;
 
+	/*
+	 * Note: 'in' might come from a token that's about to be
+	 * freed, so make sure to always allocate a new string
+	 */
 	reslen = strlen(in) + 1;
 	res = xmalloc(reslen);
 	res[0] = '\0';

commit e3b03bf29d6b99fab7001fb20c33fe54928c157a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Dec 16 00:28:42 2017 +0900

    kconfig: display recursive dependency resolution hint just once
    
    Commit 1c199f2878f6 ("kbuild: document recursive dependency limitation
    / resolution") probably intended to show a hint along with "recursive
    dependency detected!" error, but it missed to add {...} guard, and the
    hint is displayed in every loop of the dep_stack traverse, annoyingly.
    
    This error was detected by GCC's -Wmisleading-indentation when switching
    to build-time generation of lexer/parser.
    
    scripts/kconfig/symbol.c: In function ‘sym_check_print_recursive’:
    scripts/kconfig/symbol.c:1150:3: warning: this ‘if’ clause does not guard... [-Wmisleading-indentation]
       if (stack->sym == last_sym)
       ^~
    scripts/kconfig/symbol.c:1153:4: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
        fprintf(stderr, "For a resolution refer to Documentation/kbuild/kconfig-language.txt\n");
        ^~~~~~~
    
    I could simply add {...} to surround the three fprintf(), but I rather
    chose to move the hint after the loop to make the whole message readable.
    
    Fixes: 1c199f2878f6 ("kbuild: document recursive dependency limitation / resolution"
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 3c8bd9bb4267..35e0937aa6a6 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1150,8 +1150,7 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 		if (stack->sym == last_sym)
 			fprintf(stderr, "%s:%d:error: recursive dependency detected!\n",
 				prop->file->name, prop->lineno);
-			fprintf(stderr, "For a resolution refer to Documentation/kbuild/kconfig-language.txt\n");
-			fprintf(stderr, "subsection \"Kconfig recursive dependency limitations\"\n");
+
 		if (stack->expr) {
 			fprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",
 				prop->file->name, prop->lineno,
@@ -1181,6 +1180,11 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 		}
 	}
 
+	fprintf(stderr,
+		"For a resolution refer to Documentation/kbuild/kconfig-language.txt\n"
+		"subsection \"Kconfig recursive dependency limitations\"\n"
+		"\n");
+
 	if (check_top == &cv_stack)
 		dep_stack_remove();
 }

commit 88127dae6ed9d6aa938e9cf1776dc90b897fc1f7
Author: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date:   Wed Nov 8 22:09:59 2017 +0100

    kconfig/symbol.c: use correct pointer type argument for sizeof
    
    sym_arr is of type struct symbol **.
    So in malloc we need sizeof(struct symbol *).
    
    The problem was indicated by coccinelle.
    
    Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 20136ffefb23..3c8bd9bb4267 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1061,7 +1061,7 @@ struct symbol **sym_re_search(const char *pattern)
 	}
 	if (sym_match_arr) {
 		qsort(sym_match_arr, cnt, sizeof(struct sym_match), sym_rel_comp);
-		sym_arr = malloc((cnt+1) * sizeof(struct symbol));
+		sym_arr = malloc((cnt+1) * sizeof(struct symbol *));
 		if (!sym_arr)
 			goto sym_re_search_free;
 		for (i = 0; i < cnt; i++)

commit 237e3ad0f195d8fd34f1299e45f04793832a16fc
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Nov 11 00:10:05 2016 -0500

    Kconfig: Introduce the "imply" keyword
    
    The "imply" keyword is a weak version of "select" where the target
    config symbol can still be turned off, avoiding those pitfalls that come
    with the "select" keyword.
    
    This is useful e.g. with multiple drivers that want to indicate their
    ability to hook into a secondary subsystem while allowing the user to
    configure that subsystem out without also having to unset these drivers.
    
    Currently, the same effect can almost be achieved with:
    
    config DRIVER_A
            tristate
    
    config DRIVER_B
            tristate
    
    config DRIVER_C
            tristate
    
    config DRIVER_D
            tristate
    
    [...]
    
    config SUBSYSTEM_X
            tristate
            default DRIVER_A || DRIVER_B || DRIVER_C || DRIVER_D || [...]
    
    This is unwieldy to maintain especially with a large number of drivers.
    Furthermore, there is no easy way to restrict the choice for SUBSYSTEM_X
    to y or n, excluding m, when some drivers are built-in. The "select"
    keyword allows for excluding m, but it excludes n as well. Hence
    this "imply" keyword.  The above becomes:
    
    config DRIVER_A
            tristate
            imply SUBSYSTEM_X
    
    config DRIVER_B
            tristate
            imply SUBSYSTEM_X
    
    [...]
    
    config SUBSYSTEM_X
            tristate
    
    This is much cleaner, and way more flexible than "select". SUBSYSTEM_X
    can still be configured out, and it can be set as a module when none of
    the drivers are configured in or all of them are modular.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-2-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 2432298487fb..20136ffefb23 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -258,6 +258,15 @@ static void sym_calc_visibility(struct symbol *sym)
 		sym->rev_dep.tri = tri;
 		sym_set_changed(sym);
 	}
+	tri = no;
+	if (sym->implied.expr && sym->dir_dep.tri != no)
+		tri = expr_calc_value(sym->implied.expr);
+	if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
+		tri = yes;
+	if (sym->implied.tri != tri) {
+		sym->implied.tri = tri;
+		sym_set_changed(sym);
+	}
 }
 
 /*
@@ -397,6 +406,10 @@ void sym_calc_value(struct symbol *sym)
 					newval.tri = EXPR_AND(expr_calc_value(prop->expr),
 							      prop->visible.tri);
 				}
+				if (sym->implied.tri != no) {
+					sym->flags |= SYMBOL_WRITE;
+					newval.tri = EXPR_OR(newval.tri, sym->implied.tri);
+				}
 			}
 		calc_newval:
 			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
@@ -413,7 +426,8 @@ void sym_calc_value(struct symbol *sym)
 			}
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
-		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)
+		if (newval.tri == mod &&
+		    (sym_get_type(sym) == S_BOOLEAN || sym->implied.tri == yes))
 			newval.tri = yes;
 		break;
 	case S_STRING:
@@ -498,6 +512,8 @@ bool sym_tristate_within_range(struct symbol *sym, tristate val)
 		return false;
 	if (sym->visible <= sym->rev_dep.tri)
 		return false;
+	if (sym->implied.tri == yes && val == mod)
+		return false;
 	if (sym_is_choice_value(sym) && sym->visible == yes)
 		return val == yes;
 	return val >= sym->rev_dep.tri && val <= sym->visible;
@@ -750,6 +766,10 @@ const char *sym_get_string_default(struct symbol *sym)
 	if (sym->type == S_BOOLEAN && val == mod)
 		val = yes;
 
+	/* adjust the default value if this symbol is implied by another */
+	if (val < sym->implied.tri)
+		val = sym->implied.tri;
+
 	switch (sym->type) {
 	case S_BOOLEAN:
 	case S_TRISTATE:
@@ -1352,6 +1372,8 @@ const char *prop_get_type_name(enum prop_type type)
 		return "choice";
 	case P_SELECT:
 		return "select";
+	case P_IMPLY:
+		return "imply";
 	case P_RANGE:
 		return "range";
 	case P_SYMBOL:

commit fa64e5f6a35efd5e77d639125d973077ca506074
Author: Dirk Gouders <dirk@gouders.net>
Date:   Fri Apr 29 10:24:52 2016 +0200

    kconfig/symbol.c: handle choice_values that depend on 'm' symbols
    
    If choices consist of choice_values of type tristate that depend on
    symbols set to 'm', those choice_values are not set to 'n' if the
    choice is changed from 'm' to 'y' (in which case only one active
    choice_value is allowed). Those values are also written to the config
    file causing modules to be built when they should not.
    
    The following config can be used to reproduce and examine the problem;
    with the frontend of your choice set "Choice 0" and "Choice 1" to 'm',
    then set "Tristate Choice" to 'y' and save the configuration:
    
    config modules
            boolean modules
            default y
            option modules
    
    config dependency
            tristate "Dependency"
            default m
    
    choice
            prompt "Tristate Choice"
            default choice0
    
    config choice0
            tristate "Choice 0"
    
    config choice1
            tristate "Choice 1"
            depends on dependency
    
    endchoice
    
    This patch sets tristate choice_values' visibility that depend on
    symbols set to 'm' to 'n' if the corresponding choice is set to 'y'.
    
    This makes them disappear from the choice list and will also cause the
    choice_values' value set to 'n' in sym_calc_value() and as a result
    they are written as "not set" to the resulting .config file.
    
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Tested-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 25cf0c2c0c79..2432298487fb 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -209,12 +209,26 @@ static void sym_set_all_changed(void)
 static void sym_calc_visibility(struct symbol *sym)
 {
 	struct property *prop;
+	struct symbol *choice_sym = NULL;
 	tristate tri;
 
 	/* any prompt visible? */
 	tri = no;
+
+	if (sym_is_choice_value(sym))
+		choice_sym = prop_get_symbol(sym_get_choice_prop(sym));
+
 	for_all_prompts(sym, prop) {
 		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		/*
+		 * Tristate choice_values with visibility 'mod' are
+		 * not visible if the corresponding choice's value is
+		 * 'yes'.
+		 */
+		if (choice_sym && sym->type == S_TRISTATE &&
+		    prop->visible.tri == mod && choice_sym->curr.tri == yes)
+			prop->visible.tri = no;
+
 		tri = EXPR_OR(tri, prop->visible.tri);
 	}
 	if (tri == mod && (sym->type != S_TRISTATE || modules_val == no))

commit 1c199f2878f6c1b8c52125ad9805e94fe2dde472
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed Oct 7 16:16:33 2015 -0700

    kbuild: document recursive dependency limitation / resolution
    
    Recursive dependency issues with kconfig are unavoidable due to
    some limitations with kconfig, since these issues are recurring
    provide a hint to the user how they can resolve these dependency
    issues and also document why such limitation exists.
    
    While at it also document a bit of future prospects of ways to
    enhance Kconfig, including providing formal semantics and evaluation
    of use of a SAT solver. If you're interested in this work or prospects
    of it check out the kconfig-sat project wiki [0] and mailing list [1].
    
    [0] http://kernelnewbies.org/KernelProjects/kconfig-sat
    [1] https://groups.google.com/d/forum/kconfig-sat
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: James Bottomley <jbottomley@odin.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Mate Soos <soos.mate@gmail.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 50878dc025a5..25cf0c2c0c79 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1116,6 +1116,8 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 		if (stack->sym == last_sym)
 			fprintf(stderr, "%s:%d:error: recursive dependency detected!\n",
 				prop->file->name, prop->lineno);
+			fprintf(stderr, "For a resolution refer to Documentation/kbuild/kconfig-language.txt\n");
+			fprintf(stderr, "subsection \"Kconfig recursive dependency limitations\"\n");
 		if (stack->expr) {
 			fprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",
 				prop->file->name, prop->lineno,

commit 35ffd08d9bc92b5d56f6536406c379d82a757e7a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Jul 7 21:48:23 2015 +0200

    kconfig: Delete unnecessary checks before the function call "sym_calc_value"
    
    The sym_calc_value() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 70c5ee189dce..50878dc025a5 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -467,8 +467,7 @@ void sym_clear_all_valid(void)
 	for_all_symbols(i, sym)
 		sym->flags &= ~SYMBOL_VALID;
 	sym_add_change_count(1);
-	if (modules_sym)
-		sym_calc_value(modules_sym);
+	sym_calc_value(modules_sym);
 }
 
 bool sym_tristate_within_range(struct symbol *sym, tristate val)

commit 31847b67bec0e989961118520406a63fdeac7246
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Jun 15 13:00:21 2015 +0100

    kconfig: allow use of relations other than (in)equality
    
    Over the years I found it desirable to be able to use all sorts of
    relations, not just (in)equality. And apparently I'm not the only one,
    as there's at least one example in the tree where the programmer
    assumed this would work (see DEBUG_UART_8250_WORD in
    arch/arm/Kconfig.debug). Another possible use would e.g. be to fold the
    two SMP/NR_CPUS prompts into one: SMP could be promptless, simply
    depending on NR_CPUS > 1.
    
    A (desirable) side effect of this change - resulting from numeric
    values now necessarily being compared as numbers rather than as
    strings - is that comparing hex values now works as expected: Other
    than int ones (which aren't allowed to have leading zeroes), zeroes
    following the 0x prefix made them compare unequal even if their values
    were equal.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 6731377f9bb2..70c5ee189dce 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1166,6 +1166,10 @@ static struct symbol *sym_check_expr_deps(struct expr *e)
 	case E_NOT:
 		return sym_check_expr_deps(e->left.expr);
 	case E_EQUAL:
+	case E_GEQ:
+	case E_GTH:
+	case E_LEQ:
+	case E_LTH:
 	case E_UNEQUAL:
 		sym = sym_check_deps(e->left.sym);
 		if (sym)

commit ad8d40cda3ad22ad9e8863d55a5c88f85c0173f0
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Feb 24 16:37:13 2015 +0100

    kconfig: Remove unnecessary prototypes from headers
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 7caabdb51c64..6731377f9bb2 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -112,7 +112,7 @@ struct property *sym_get_env_prop(struct symbol *sym)
 	return NULL;
 }
 
-struct property *sym_get_default_prop(struct symbol *sym)
+static struct property *sym_get_default_prop(struct symbol *sym)
 {
 	struct property *prop;
 
@@ -186,6 +186,26 @@ static void sym_validate_range(struct symbol *sym)
 	sym->curr.val = strdup(str);
 }
 
+static void sym_set_changed(struct symbol *sym)
+{
+	struct property *prop;
+
+	sym->flags |= SYMBOL_CHANGED;
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu)
+			prop->menu->flags |= MENU_CHANGED;
+	}
+}
+
+static void sym_set_all_changed(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym_set_changed(sym);
+}
+
 static void sym_calc_visibility(struct symbol *sym)
 {
 	struct property *prop;
@@ -451,26 +471,6 @@ void sym_clear_all_valid(void)
 		sym_calc_value(modules_sym);
 }
 
-void sym_set_changed(struct symbol *sym)
-{
-	struct property *prop;
-
-	sym->flags |= SYMBOL_CHANGED;
-	for (prop = sym->prop; prop; prop = prop->next) {
-		if (prop->menu)
-			prop->menu->flags |= MENU_CHANGED;
-	}
-}
-
-void sym_set_all_changed(void)
-{
-	struct symbol *sym;
-	int i;
-
-	for_all_symbols(i, sym)
-		sym_set_changed(sym);
-}
-
 bool sym_tristate_within_range(struct symbol *sym, tristate val)
 {
 	int type = sym_get_type(sym);

commit 8d9dfe8276750aaf30ca1b59b4c3f9349377cb6e
Author: Martin Walch <walch.martin@web.de>
Date:   Thu Oct 3 17:28:14 2013 +0200

    kconfig: fix trivial typos and update mconf documentation
    
    This fixes lots of typos in comments and strings.
    
    It also updates the documentation strings in mconf to reflect the changes in
    the user interface from the two commits
    
    6364fd0cb1e4c7f72b974613e0cf5744ae4d2cb2
      menuconfig: Add Save/Load buttons
    1bdbac478a858d2aa73a6784c7c2e09de0f6d06b
      menuconfig: Get rid of the top-level entries for "Load an Alternate/Save an Alternate"
    
    And it updates the layout of the example search result, i. e. moves down the
    "Defined at" and "Depends on" lines and adds a symbol state ([=n]) to the
    symbol in the "Selected by" line.
    
    Furthermore, the help texts now should fit in 80 columns again when viewed
    in mconf.
    
    Signed-off-by: Martin Walch <walch.martin@web.de>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Wang YanQing <udknight@gmail.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c9a6775565bf..7caabdb51c64 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1047,7 +1047,7 @@ struct symbol **sym_re_search(const char *pattern)
  * When we check for recursive dependencies we use a stack to save
  * current state so we can print out relevant info to user.
  * The entries are located on the call stack so no need to free memory.
- * Note inser() remove() must always match to properly clear the stack.
+ * Note insert() remove() must always match to properly clear the stack.
  */
 static struct dep_stack {
 	struct dep_stack *prev, *next;

commit 129784abc982ccac43322c2f175f3ca735c2ca73
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jul 18 11:32:01 2013 -0700

    kconfig: switch to "long long" for sanity
    
    Instead of using "long" for kconfig "hex" and "range" values, which may
    change in size depending on the host architecture, use "long long". This
    will allow values greater than INT_MAX on 32-bit hosts when cross
    compiling.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index a76b8fd1db4f..c9a6775565bf 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -136,7 +136,7 @@ static struct property *sym_get_range_prop(struct symbol *sym)
 	return NULL;
 }
 
-static long sym_get_range_val(struct symbol *sym, int base)
+static long long sym_get_range_val(struct symbol *sym, int base)
 {
 	sym_calc_value(sym);
 	switch (sym->type) {
@@ -149,13 +149,14 @@ static long sym_get_range_val(struct symbol *sym, int base)
 	default:
 		break;
 	}
-	return strtol(sym->curr.val, NULL, base);
+	return strtoll(sym->curr.val, NULL, base);
 }
 
 static void sym_validate_range(struct symbol *sym)
 {
 	struct property *prop;
-	long base, val, val2;
+	int base;
+	long long val, val2;
 	char str[64];
 
 	switch (sym->type) {
@@ -171,7 +172,7 @@ static void sym_validate_range(struct symbol *sym)
 	prop = sym_get_range_prop(sym);
 	if (!prop)
 		return;
-	val = strtol(sym->curr.val, NULL, base);
+	val = strtoll(sym->curr.val, NULL, base);
 	val2 = sym_get_range_val(prop->expr->left.sym, base);
 	if (val >= val2) {
 		val2 = sym_get_range_val(prop->expr->right.sym, base);
@@ -179,9 +180,9 @@ static void sym_validate_range(struct symbol *sym)
 			return;
 	}
 	if (sym->type == S_INT)
-		sprintf(str, "%ld", val2);
+		sprintf(str, "%lld", val2);
 	else
-		sprintf(str, "0x%lx", val2);
+		sprintf(str, "0x%llx", val2);
 	sym->curr.val = strdup(str);
 }
 
@@ -594,7 +595,7 @@ bool sym_string_valid(struct symbol *sym, const char *str)
 bool sym_string_within_range(struct symbol *sym, const char *str)
 {
 	struct property *prop;
-	long val;
+	long long val;
 
 	switch (sym->type) {
 	case S_STRING:
@@ -605,7 +606,7 @@ bool sym_string_within_range(struct symbol *sym, const char *str)
 		prop = sym_get_range_prop(sym);
 		if (!prop)
 			return true;
-		val = strtol(str, NULL, 10);
+		val = strtoll(str, NULL, 10);
 		return val >= sym_get_range_val(prop->expr->left.sym, 10) &&
 		       val <= sym_get_range_val(prop->expr->right.sym, 10);
 	case S_HEX:
@@ -614,7 +615,7 @@ bool sym_string_within_range(struct symbol *sym, const char *str)
 		prop = sym_get_range_prop(sym);
 		if (!prop)
 			return true;
-		val = strtol(str, NULL, 16);
+		val = strtoll(str, NULL, 16);
 		return val >= sym_get_range_val(prop->expr->left.sym, 16) &&
 		       val <= sym_get_range_val(prop->expr->right.sym, 16);
 	case S_BOOLEAN:

commit 508382a0428f2b2f49da0e0e89c921f07c9306aa
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Jul 16 20:39:42 2013 +0200

    kconfig: simplify symbol-search code
    
    There is no need for a double indirection in the temporary array that
    stores the internediate search results.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 08d4401e646d..a76b8fd1db4f 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -965,8 +965,8 @@ struct sym_match {
  */
 static int sym_rel_comp(const void *sym1, const void *sym2)
 {
-	struct sym_match *s1 = *(struct sym_match **)sym1;
-	struct sym_match *s2 = *(struct sym_match **)sym2;
+	const struct sym_match *s1 = sym1;
+	const struct sym_match *s2 = sym2;
 	int exact1, exact2;
 
 	/* Exact match:
@@ -992,7 +992,7 @@ static int sym_rel_comp(const void *sym1, const void *sym2)
 struct symbol **sym_re_search(const char *pattern)
 {
 	struct symbol *sym, **sym_arr = NULL;
-	struct sym_match **sym_match_arr = NULL;
+	struct sym_match *sym_match_arr = NULL;
 	int i, cnt, size;
 	regex_t re;
 	regmatch_t match[1];
@@ -1005,7 +1005,6 @@ struct symbol **sym_re_search(const char *pattern)
 		return NULL;
 
 	for_all_symbols(i, sym) {
-		struct sym_match *tmp_sym_match;
 		if (sym->flags & SYMBOL_CONST || !sym->name)
 			continue;
 		if (regexec(&re, sym->name, 1, match, 0))
@@ -1013,38 +1012,31 @@ struct symbol **sym_re_search(const char *pattern)
 		if (cnt >= size) {
 			void *tmp;
 			size += 16;
-			tmp = realloc(sym_match_arr, size * sizeof(struct sym_match *));
+			tmp = realloc(sym_match_arr, size * sizeof(struct sym_match));
 			if (!tmp)
 				goto sym_re_search_free;
 			sym_match_arr = tmp;
 		}
 		sym_calc_value(sym);
-		tmp_sym_match = (struct sym_match*)malloc(sizeof(struct sym_match));
-		if (!tmp_sym_match)
-			goto sym_re_search_free;
-		tmp_sym_match->sym = sym;
 		/* As regexec returned 0, we know we have a match, so
 		 * we can use match[0].rm_[se]o without further checks
 		 */
-		tmp_sym_match->so = match[0].rm_so;
-		tmp_sym_match->eo = match[0].rm_eo;
-		sym_match_arr[cnt++] = tmp_sym_match;
+		sym_match_arr[cnt].so = match[0].rm_so;
+		sym_match_arr[cnt].eo = match[0].rm_eo;
+		sym_match_arr[cnt++].sym = sym;
 	}
 	if (sym_match_arr) {
-		qsort(sym_match_arr, cnt, sizeof(struct sym_match*), sym_rel_comp);
+		qsort(sym_match_arr, cnt, sizeof(struct sym_match), sym_rel_comp);
 		sym_arr = malloc((cnt+1) * sizeof(struct symbol));
 		if (!sym_arr)
 			goto sym_re_search_free;
 		for (i = 0; i < cnt; i++)
-			sym_arr[i] = sym_match_arr[i]->sym;
+			sym_arr[i] = sym_match_arr[i].sym;
 		sym_arr[cnt] = NULL;
 	}
 sym_re_search_free:
-	if (sym_match_arr) {
-		for (i = 0; i < cnt; i++)
-			free(sym_match_arr[i]);
-		free(sym_match_arr);
-	}
+	/* sym_match_arr can be NULL if no match, but free(NULL) is OK */
+	free(sym_match_arr);
 	regfree(&re);
 
 	return sym_arr;

commit 1407f97aeda5720d6327d69f6058537c0fd469e3
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Jul 16 20:32:33 2013 +0200

    kconfig: don't allocate n+1 elements in temporary array
    
    The temporary array that stores the search results is not NULL-terminated,
    so there is no reason to allocate n+1 elements.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index b664d6ed515f..08d4401e646d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -1010,7 +1010,7 @@ struct symbol **sym_re_search(const char *pattern)
 			continue;
 		if (regexec(&re, sym->name, 1, match, 0))
 			continue;
-		if (cnt + 1 >= size) {
+		if (cnt >= size) {
 			void *tmp;
 			size += 16;
 			tmp = realloc(sym_match_arr, size * sizeof(struct sym_match *));

commit 803b3519880f255563d8590c1f5870398b9a4ea0
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Jul 16 20:28:51 2013 +0200

    kconfig: minor style fixes in symbol-search code
    
    Two minor style fixes:
      - no space before/after parenthesis in function definition
      - no {} for single-line if()
    
    And one grammar fix in a comment.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 020a0ac147e1..b664d6ed515f 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -963,7 +963,7 @@ struct sym_match {
  * - first, symbols that match exactly
  * - then, alphabetical sort
  */
-static int sym_rel_comp( const void *sym1, const void *sym2 )
+static int sym_rel_comp(const void *sym1, const void *sym2)
 {
 	struct sym_match *s1 = *(struct sym_match **)sym1;
 	struct sym_match *s2 = *(struct sym_match **)sym2;
@@ -1014,9 +1014,8 @@ struct symbol **sym_re_search(const char *pattern)
 			void *tmp;
 			size += 16;
 			tmp = realloc(sym_match_arr, size * sizeof(struct sym_match *));
-			if (!tmp) {
+			if (!tmp)
 				goto sym_re_search_free;
-			}
 			sym_match_arr = tmp;
 		}
 		sym_calc_value(sym);
@@ -1024,7 +1023,7 @@ struct symbol **sym_re_search(const char *pattern)
 		if (!tmp_sym_match)
 			goto sym_re_search_free;
 		tmp_sym_match->sym = sym;
-		/* As regexec return 0, we know we have a match, so
+		/* As regexec returned 0, we know we have a match, so
 		 * we can use match[0].rm_[se]o without further checks
 		 */
 		tmp_sym_match->so = match[0].rm_so;

commit 26e933e3c35624d80281330c4beb17db4cd4960f
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Sat Jul 13 15:09:43 2013 +0200

    kconfig: avoid multiple calls to strlen
    
    Calls to strlen are costly, so avoid calling strln as much as we can.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index d550300ec00c..020a0ac147e1 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -967,7 +967,7 @@ static int sym_rel_comp( const void *sym1, const void *sym2 )
 {
 	struct sym_match *s1 = *(struct sym_match **)sym1;
 	struct sym_match *s2 = *(struct sym_match **)sym2;
-	int l1, l2;
+	int exact1, exact2;
 
 	/* Exact match:
 	 * - if matched length on symbol s1 is the length of that symbol,
@@ -978,11 +978,11 @@ static int sym_rel_comp( const void *sym1, const void *sym2 )
 	 * exactly; if this is the case, we can't decide which comes first,
 	 * and we fallback to sorting alphabetically.
 	 */
-	l1 = s1->eo - s1->so;
-	l2 = s2->eo - s2->so;
-	if (l1 == strlen(s1->sym->name) && l2 != strlen(s2->sym->name))
+	exact1 = (s1->eo - s1->so) == strlen(s1->sym->name);
+	exact2 = (s2->eo - s2->so) == strlen(s2->sym->name);
+	if (exact1 && !exact2)
 		return -1;
-	if (l1 != strlen(s1->sym->name) && l2 == strlen(s2->sym->name))
+	if (!exact1 && exact2)
 		return 1;
 
 	/* As a fallback, sort symbols alphabetically */

commit b57caaaed2bd127fe656e6c145970ed6a05c0125
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jun 28 12:56:51 2013 -0700

    kconfig: allow "hex" and "range" to support longs
    
    The parsing routines for Kconfig files use strtol(), but store and
    render values as int. Switch types and formating to long to support a
    wider range of values. For example, 0x80000000 wasn't representable.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 387d55483882..d550300ec00c 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -136,7 +136,7 @@ static struct property *sym_get_range_prop(struct symbol *sym)
 	return NULL;
 }
 
-static int sym_get_range_val(struct symbol *sym, int base)
+static long sym_get_range_val(struct symbol *sym, int base)
 {
 	sym_calc_value(sym);
 	switch (sym->type) {
@@ -155,7 +155,7 @@ static int sym_get_range_val(struct symbol *sym, int base)
 static void sym_validate_range(struct symbol *sym)
 {
 	struct property *prop;
-	int base, val, val2;
+	long base, val, val2;
 	char str[64];
 
 	switch (sym->type) {
@@ -179,9 +179,9 @@ static void sym_validate_range(struct symbol *sym)
 			return;
 	}
 	if (sym->type == S_INT)
-		sprintf(str, "%d", val2);
+		sprintf(str, "%ld", val2);
 	else
-		sprintf(str, "0x%x", val2);
+		sprintf(str, "0x%lx", val2);
 	sym->curr.val = strdup(str);
 }
 
@@ -594,7 +594,7 @@ bool sym_string_valid(struct symbol *sym, const char *str)
 bool sym_string_within_range(struct symbol *sym, const char *str)
 {
 	struct property *prop;
-	int val;
+	long val;
 
 	switch (sym->type) {
 	case S_STRING:

commit 193b40aeb537b59eaa36e3dfaabedc2025332ebf
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Mon May 6 14:57:47 2013 +0200

    kconfig: sort found symbols by relevance
    
    When searching for symbols, return the symbols sorted by relevance.
    
    Sorting is done as thus:
      - first, symbols that match exactly
      - then, alphabetical sort
    
    Since the search can be a regexp, it is possible that more than one symbol
    matches exactly. In this case, we can't decide which to sort first, so we
    fallback to alphabeticall sort.
    
    Explain this (new!) sorting heuristic in the documentation.
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Jean Delvare <jdelvare@suse.de>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Roland Eggner <edvx1@systemanalysen.net>
    Cc: Wang YanQing <udknight@gmail.com>
    
    --
    Changes v1->v2:
      - drop the previous, complex heuristic in favour of a simpler heuristic
        that is both easier to understand, *and* to maintain (Jean)
      - explain sorting heuristic in the doc  (Jean)

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index ab8f4c835933..387d55483882 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -954,38 +954,98 @@ const char *sym_escape_string_value(const char *in)
 	return res;
 }
 
+struct sym_match {
+	struct symbol	*sym;
+	off_t		so, eo;
+};
+
+/* Compare matched symbols as thus:
+ * - first, symbols that match exactly
+ * - then, alphabetical sort
+ */
+static int sym_rel_comp( const void *sym1, const void *sym2 )
+{
+	struct sym_match *s1 = *(struct sym_match **)sym1;
+	struct sym_match *s2 = *(struct sym_match **)sym2;
+	int l1, l2;
+
+	/* Exact match:
+	 * - if matched length on symbol s1 is the length of that symbol,
+	 *   then this symbol should come first;
+	 * - if matched length on symbol s2 is the length of that symbol,
+	 *   then this symbol should come first.
+	 * Note: since the search can be a regexp, both symbols may match
+	 * exactly; if this is the case, we can't decide which comes first,
+	 * and we fallback to sorting alphabetically.
+	 */
+	l1 = s1->eo - s1->so;
+	l2 = s2->eo - s2->so;
+	if (l1 == strlen(s1->sym->name) && l2 != strlen(s2->sym->name))
+		return -1;
+	if (l1 != strlen(s1->sym->name) && l2 == strlen(s2->sym->name))
+		return 1;
+
+	/* As a fallback, sort symbols alphabetically */
+	return strcmp(s1->sym->name, s2->sym->name);
+}
+
 struct symbol **sym_re_search(const char *pattern)
 {
 	struct symbol *sym, **sym_arr = NULL;
+	struct sym_match **sym_match_arr = NULL;
 	int i, cnt, size;
 	regex_t re;
+	regmatch_t match[1];
 
 	cnt = size = 0;
 	/* Skip if empty */
 	if (strlen(pattern) == 0)
 		return NULL;
-	if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB|REG_ICASE))
+	if (regcomp(&re, pattern, REG_EXTENDED|REG_ICASE))
 		return NULL;
 
 	for_all_symbols(i, sym) {
+		struct sym_match *tmp_sym_match;
 		if (sym->flags & SYMBOL_CONST || !sym->name)
 			continue;
-		if (regexec(&re, sym->name, 0, NULL, 0))
+		if (regexec(&re, sym->name, 1, match, 0))
 			continue;
 		if (cnt + 1 >= size) {
-			void *tmp = sym_arr;
+			void *tmp;
 			size += 16;
-			sym_arr = realloc(sym_arr, size * sizeof(struct symbol *));
-			if (!sym_arr) {
-				free(tmp);
-				return NULL;
+			tmp = realloc(sym_match_arr, size * sizeof(struct sym_match *));
+			if (!tmp) {
+				goto sym_re_search_free;
 			}
+			sym_match_arr = tmp;
 		}
 		sym_calc_value(sym);
-		sym_arr[cnt++] = sym;
+		tmp_sym_match = (struct sym_match*)malloc(sizeof(struct sym_match));
+		if (!tmp_sym_match)
+			goto sym_re_search_free;
+		tmp_sym_match->sym = sym;
+		/* As regexec return 0, we know we have a match, so
+		 * we can use match[0].rm_[se]o without further checks
+		 */
+		tmp_sym_match->so = match[0].rm_so;
+		tmp_sym_match->eo = match[0].rm_eo;
+		sym_match_arr[cnt++] = tmp_sym_match;
 	}
-	if (sym_arr)
+	if (sym_match_arr) {
+		qsort(sym_match_arr, cnt, sizeof(struct sym_match*), sym_rel_comp);
+		sym_arr = malloc((cnt+1) * sizeof(struct symbol));
+		if (!sym_arr)
+			goto sym_re_search_free;
+		for (i = 0; i < cnt; i++)
+			sym_arr[i] = sym_match_arr[i]->sym;
 		sym_arr[cnt] = NULL;
+	}
+sym_re_search_free:
+	if (sym_match_arr) {
+		for (i = 0; i < cnt; i++)
+			free(sym_match_arr[i]);
+		free(sym_match_arr);
+	}
 	regfree(&re);
 
 	return sym_arr;

commit fbe98bb9ed3dae23e320c6b113e35f129538d14a
Author: Arve Hjønnevåg <arve@android.com>
Date:   Thu Jun 6 20:37:00 2013 -0700

    kconfig: Fix defconfig when one choice menu selects options that another choice menu depends on
    
    The defconfig and Kconfig combination below, which is based on 3.10-rc4
    Kconfigs, resulted in several options getting set to "m" instead of "y".
    
    defconfig.choice:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_USB_ZERO=y
    ---8<---
    
    Kconfig.choice:
    ---8<---
    menuconfig MODULES
            bool "Enable loadable module support"
    
    config CONFIGFS_FS
            tristate "Userspace-driven configuration filesystem"
    
    config OCFS2_FS
            tristate "OCFS2 file system support"
            depends on CONFIGFS_FS
            select CRC32
    
    config USB_LIBCOMPOSITE
            tristate
            select CONFIGFS_FS
    
    choice
            tristate "USB Gadget Drivers"
            default USB_ETH
    
    config USB_ZERO
            tristate "Gadget Zero (DEVELOPMENT)"
            select USB_LIBCOMPOSITE
    
    config USB_ETH
            tristate "Ethernet Gadget (with CDC Ethernet support)"
            select USB_LIBCOMPOSITE
    
    endchoice
    
    config CRC32
            tristate "CRC32/CRC32c functions"
            default y
    
    choice
            prompt "CRC32 implementation"
            depends on CRC32
            default CRC32_SLICEBY8
    
    config CRC32_SLICEBY8
            bool "Slice by 8 bytes"
    
    endchoice
    ---8<---
    
    $ scripts/kconfig/conf --defconfig=defconfig.choice Kconfig.choice
    
    would result in:
    
    .config:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_CONFIGFS_FS=m
    CONFIG_USB_LIBCOMPOSITE=m
    CONFIG_USB_ZERO=m
    CONFIG_CRC32=y
    CONFIG_CRC32_SLICEBY8=y
    ---8<---
    
    when the expected result would be:
    
    .config:
    ---8<---
    CONFIG_MODULES=y
    CONFIG_CONFIGFS_FS=y
    CONFIG_USB_LIBCOMPOSITE=y
    CONFIG_USB_ZERO=y
    CONFIG_CRC32=y
    CONFIG_CRC32_SLICEBY8=y
    ---8<---
    
    Signed-off-by: Arve Hjønnevåg <arve@android.com>
    [yann.morin.1998@free.fr: add the resulting .config to commit log,
                              remove unneeded USB_GADGET from the defconfig]
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Yann E. MORIN <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index ecc5aa5f865d..ab8f4c835933 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -300,6 +300,14 @@ void sym_calc_value(struct symbol *sym)
 
 	if (sym->flags & SYMBOL_VALID)
 		return;
+
+	if (sym_is_choice_value(sym) &&
+	    sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES) {
+		sym->flags &= ~SYMBOL_NEED_SET_CHOICE_VALUES;
+		prop = sym_get_choice_prop(sym);
+		sym_calc_value(prop_get_symbol(prop));
+	}
+
 	sym->flags |= SYMBOL_VALID;
 
 	oldval = sym->curr;
@@ -425,6 +433,9 @@ void sym_calc_value(struct symbol *sym)
 
 	if (sym->flags & SYMBOL_AUTO)
 		sym->flags &= ~SYMBOL_WRITE;
+
+	if (sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES)
+		set_all_choice_values(sym);
 }
 
 void sym_clear_all_valid(void)

commit 177acf78468bf5c359bcb8823ee3bd48b04b8380
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Nov 6 14:32:08 2012 +0000

    kconfig: Fix malloc handling in conf tools
    
    (and get them out of the noise in the audit work)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 22a3c400fc41..ecc5aa5f865d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -656,11 +656,11 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 	size = strlen(newval) + 1;
 	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
 		size += 2;
-		sym->def[S_DEF_USER].val = val = malloc(size);
+		sym->def[S_DEF_USER].val = val = xmalloc(size);
 		*val++ = '0';
 		*val++ = 'x';
 	} else if (!oldval || strcmp(oldval, newval))
-		sym->def[S_DEF_USER].val = val = malloc(size);
+		sym->def[S_DEF_USER].val = val = xmalloc(size);
 	else
 		return true;
 
@@ -812,7 +812,7 @@ struct symbol *sym_lookup(const char *name, int flags)
 		hash = 0;
 	}
 
-	symbol = malloc(sizeof(*symbol));
+	symbol = xmalloc(sizeof(*symbol));
 	memset(symbol, 0, sizeof(*symbol));
 	symbol->name = new_name;
 	symbol->type = S_UNKNOWN;
@@ -863,7 +863,7 @@ const char *sym_expand_string_value(const char *in)
 	size_t reslen;
 
 	reslen = strlen(in) + 1;
-	res = malloc(reslen);
+	res = xmalloc(reslen);
 	res[0] = '\0';
 
 	while ((src = strchr(in, '$'))) {
@@ -921,7 +921,7 @@ const char *sym_escape_string_value(const char *in)
 		p++;
 	}
 
-	res = malloc(reslen);
+	res = xmalloc(reslen);
 	res[0] = '\0';
 
 	strcat(res, "\"");
@@ -1228,7 +1228,7 @@ struct property *prop_alloc(enum prop_type type, struct symbol *sym)
 	struct property *prop;
 	struct property **propp;
 
-	prop = malloc(sizeof(*prop));
+	prop = xmalloc(sizeof(*prop));
 	memset(prop, 0, sizeof(*prop));
 	prop->type = type;
 	prop->sym = sym;

commit 5d09598d488f081e3be23f885ed65cbbe2d073b5
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Mon Jan 23 17:29:05 2012 -0500

    kconfig: fix new choices being skipped upon config update
    
    Running `oldconfig' after any of the following configuration change:
    
    either trivial addition, such as:
    
    config A
            bool "A"
    
    choice
            prompt "Choice ?"
            depends on A
    
            config CHOICE_B
                    bool "Choice B"
    
            config CHOICE_C
                    bool "Choice C"
    endchoice
    
    or more tricky change:
    
    OLD KCONFIG                      |  NEW KCONFIG
                                     |
                                     |  config A
                                     |          bool "A"
                                     |
    choice                           |  choice
            prompt "Choice ?"        |          prompt "Choice ?"
                                     |
            config CHOICE_C          |          config CHOICE_C
                    bool "Choice C"  |                  bool "Choice C"
                                     |
            config CHOICE_D          |          config CHOICE_D
                    bool "Choice D"  |                  bool "Choice D"
    endchoice                        |
                                     |          config CHOICE_E
                                     |                  bool "Choice E"
                                     |                  depends on A
                                     |  endchoice
    
    will not cause the choice to be considered as NEW, and thus not be
    asked. The cause of this behavior is that choice's novelty are computed
    statically right after the saved configuration has been read. At this
    point, the new dependency's value is still unknown and asserted to be
    `no'. Moreover, no update to this decision is made afterward.
    
    Correct this by dynamically evaluating a choice's novelty, and removing the
    static evaluation.
    
    Reported-and-tested-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 071f00c3046e..22a3c400fc41 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -262,11 +262,18 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 	struct symbol *def_sym;
 	struct property *prop;
 	struct expr *e;
+	int flags;
 
 	/* first calculate all choice values' visibilities */
+	flags = sym->flags;
 	prop = sym_get_choice_prop(sym);
-	expr_list_for_each_sym(prop->expr, e, def_sym)
+	expr_list_for_each_sym(prop->expr, e, def_sym) {
 		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			flags &= def_sym->flags;
+	}
+
+	sym->flags &= flags | ~SYMBOL_DEF_USER;
 
 	/* is the user choice visible? */
 	def_sym = sym->def[S_DEF_USER].val;

commit e54e692ba613c2170c66ce36a3791c009680af08
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun May 15 23:42:09 2011 -0400

    kconfig: introduce specialized printer
    
    Make conf_write_symbol() grammar agnostic to be able to use it from different
    code path. These path pass a printer callback which will print a symbol's name
    and its value in different format.
    
    conf_write_symbol()'s job become mostly only to prepare a string for the
    printer. This avoid to have to pass specialized flag to generic
    functions
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    [mmarek: rebased on top of de12518 (kconfig: autogenerated config_is_xxx
    macro)]
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index cf8edf4fc429..071f00c3046e 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -750,7 +750,8 @@ const char *sym_get_string_value(struct symbol *sym)
 		case no:
 			return "n";
 		case mod:
-			return "m";
+			sym_calc_value(modules_sym);
+			return (modules_sym->curr.tri == no) ? "n" : "m";
 		case yes:
 			return "y";
 		}
@@ -892,6 +893,49 @@ const char *sym_expand_string_value(const char *in)
 	return res;
 }
 
+const char *sym_escape_string_value(const char *in)
+{
+	const char *p;
+	size_t reslen;
+	char *res;
+	size_t l;
+
+	reslen = strlen(in) + strlen("\"\"") + 1;
+
+	p = in;
+	for (;;) {
+		l = strcspn(p, "\"\\");
+		p += l;
+
+		if (p[0] == '\0')
+			break;
+
+		reslen++;
+		p++;
+	}
+
+	res = malloc(reslen);
+	res[0] = '\0';
+
+	strcat(res, "\"");
+
+	p = in;
+	for (;;) {
+		l = strcspn(p, "\"\\");
+		strncat(res, p, l);
+		p += l;
+
+		if (p[0] == '\0')
+			break;
+
+		strcat(res, "\\");
+		strncat(res, p++, 1);
+	}
+
+	strcat(res, "\"");
+	return res;
+}
+
 struct symbol **sym_re_search(const char *pattern)
 {
 	struct symbol *sym, **sym_arr = NULL;

commit 5a6f8d2bd9e3392569ed6f29ea4d7210652f929b
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:14:47 2011 -0400

    kconfig: nuke LKC_DIRECT_LINK cruft
    
    This interface is not (and has never been ?) used by any frontend, just get rid
    of it.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index a796c95fe8a0..cf8edf4fc429 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -9,7 +9,6 @@
 #include <regex.h>
 #include <sys/utsname.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 struct symbol symbol_yes = {

commit f28b1c8aaa97a68028bb894bffb1690185c62b01
Merge: 0c05384a5a1a 39177ec36236
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 10 08:28:17 2011 -0800

    Merge branch 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      nconf: handle comment entries within choice/endchoice
      kconfig: fix warning
      kconfig: Make expr_copy() take a const argument
      kconfig: simplify select-with-unmet-direct-dependency warning
      kconfig: add more S_INT and S_HEX consistency checks
      kconfig: fix `zconfdebug' extern declaration
      kconfig/conf: merge duplicate switch's case
      kconfig: fix typos
      kbuild/gconf: add dummy inline for bind_textdomain_codeset()
      kbuild/nconf: fix spaces damage
      kconfig: nuke second argument of conf_write_symbol()
      kconfig: do not define AUTOCONF_INCLUDED
      kconfig: the day kconfig warns about "select"-abuse has come

commit 1137c56b7420c801147e0863845c03b07554721a
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Sep 26 16:24:08 2010 -0400

    kconfig: simplify select-with-unmet-direct-dependency warning
    
    This is an attempt to simplify the expressing printed by kconfig when a
    symbol is selected but still has direct unmet dependency.
    
    First, the symbol reverse dependency is split in sub-expression. Then,
    each sub-expression is checked to ensure that it does not contains the
    unmet dependency. This removes the false-positive symbols and fixed symbol
    which already have the correct dependency. Finally, only the symbol
    responsible of the "select" is printed, instead of its full dependency tree.
    
    CC: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 60830ce4a0a9..fa52e6f44ac4 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -351,12 +351,16 @@ void sym_calc_value(struct symbol *sym)
 			}
 		calc_newval:
 			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
+				struct expr *e;
+				e = expr_simplify_unmet_dep(sym->rev_dep.expr,
+				    sym->dir_dep.expr);
 				fprintf(stderr, "warning: (");
-				expr_fprint(sym->rev_dep.expr, stderr);
+				expr_fprint(e, stderr);
 				fprintf(stderr, ") selects %s which has unmet direct dependencies (",
 					sym->name);
 				expr_fprint(sym->dir_dep.expr, stderr);
 				fprintf(stderr, ")\n");
+				expr_free(e);
 			}
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}

commit 579fb8e741fecef7dfd64afcc7b0b0c68ea207cc
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Dec 5 01:41:16 2010 -0500

    kconfig: fix typos
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c0efe102d655..60830ce4a0a9 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -686,7 +686,7 @@ const char *sym_get_string_default(struct symbol *sym)
 		switch (sym->type) {
 		case S_BOOLEAN:
 		case S_TRISTATE:
-			/* The visibility imay limit the value from yes => mod */
+			/* The visibility may limit the value from yes => mod */
 			val = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);
 			break;
 		default:

commit 020e773f6b2e797a13d23723773ed1b3ba2c35dc
Author: Andy Whitcroft <apw@canonical.com>
Date:   Mon Nov 1 21:01:44 2010 +0000

    kconfig: sym_expand_string_value: allow for string termination when reallocing
    
    When expanding a parameterised string we may run out of space, this
    triggers a realloc.  When computing the new allocation size we do not
    allow for the terminating '\0'.  Allow for this when calculating the new
    length.
    
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c0efe102d655..af6e9f3de950 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -875,7 +875,7 @@ const char *sym_expand_string_value(const char *in)
 			symval = sym_get_string_value(sym);
 		}
 
-		newlen = strlen(res) + strlen(symval) + strlen(src);
+		newlen = strlen(res) + strlen(symval) + strlen(src) + 1;
 		if (newlen > reslen) {
 			reslen = newlen;
 			res = realloc(res, reslen);

commit b1f7d6e1909c72338aa93a113d5844767434dacb
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Oct 12 15:12:23 2010 +0200

    Revert "kconfig: Temporarily disable dependency warnings"
    
    This reverts commit 71ebc01, which was a 2.6.36-only stopgap solution.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index cb0056841974..c0efe102d655 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -350,7 +350,6 @@ void sym_calc_value(struct symbol *sym)
 				}
 			}
 		calc_newval:
-#if 0
 			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
 				fprintf(stderr, "warning: (");
 				expr_fprint(sym->rev_dep.expr, stderr);
@@ -359,7 +358,6 @@ void sym_calc_value(struct symbol *sym)
 				expr_fprint(sym->dir_dep.expr, stderr);
 				fprintf(stderr, ")\n");
 			}
-#endif
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
 		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)

commit 239060b93bb30a4ad55f1ecaa512464a035cc5ba
Merge: 1408b15b9863 e9203c988234
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Oct 12 15:09:06 2010 +0200

    Merge branch 'kbuild/rc-fixes' into kbuild/kconfig
    
    We need to revert the temporary hack in 71ebc01, hence the merge.

commit 71ebc01d3ad4fa3f20e86603bc31ff2cbc535d95
Author: Michal Marek <mmarek@suse.cz>
Date:   Fri Oct 8 16:40:27 2010 +0200

    kconfig: Temporarily disable dependency warnings
    
    After fixing a use-after-free bug in kconfig, a 'make defconfig' or
    'make allmodconfig' fills the screen with warnings that were not
    detected before. Given that we are close to the release now, disable the
    warnings temporarily and deal with them after 2.6.36.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 943712ca6c0a..1f8b305449db 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -350,6 +350,7 @@ void sym_calc_value(struct symbol *sym)
 				}
 			}
 		calc_newval:
+#if 0
 			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
 				fprintf(stderr, "warning: (");
 				expr_fprint(sym->rev_dep.expr, stderr);
@@ -358,6 +359,7 @@ void sym_calc_value(struct symbol *sym)
 				expr_fprint(sym->dir_dep.expr, stderr);
 				fprintf(stderr, ")\n");
 			}
+#endif
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
 		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)

commit 19c29f326075e2c66e34d98f2a0cf22901b2d8e9
Author: Michal Marek <mmarek@suse.cz>
Date:   Thu Sep 30 22:21:12 2010 +0200

    kconfig: Fix realloc usage()
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index dc5dcf2189a0..c0efe102d655 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -878,7 +878,7 @@ const char *sym_expand_string_value(const char *in)
 		newlen = strlen(res) + strlen(symval) + strlen(src);
 		if (newlen > reslen) {
 			reslen = newlen;
-			realloc(res, reslen);
+			res = realloc(res, reslen);
 		}
 
 		strcat(res, symval);

commit 76a540958af5390a94b7f68c46cb7f2aed34ccf1
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Aug 18 01:23:50 2010 -0400

    kconfig: add a symbol string expansion helper
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 943712ca6c0a..dc5dcf2189a0 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -840,6 +840,55 @@ struct symbol *sym_find(const char *name)
 	return symbol;
 }
 
+/*
+ * Expand symbol's names embedded in the string given in argument. Symbols'
+ * name to be expanded shall be prefixed by a '$'. Unknown symbol expands to
+ * the empty string.
+ */
+const char *sym_expand_string_value(const char *in)
+{
+	const char *src;
+	char *res;
+	size_t reslen;
+
+	reslen = strlen(in) + 1;
+	res = malloc(reslen);
+	res[0] = '\0';
+
+	while ((src = strchr(in, '$'))) {
+		char *p, name[SYMBOL_MAXLENGTH];
+		const char *symval = "";
+		struct symbol *sym;
+		size_t newlen;
+
+		strncat(res, in, src - in);
+		src++;
+
+		p = name;
+		while (isalnum(*src) || *src == '_')
+			*p++ = *src++;
+		*p = '\0';
+
+		sym = sym_find(name);
+		if (sym != NULL) {
+			sym_calc_value(sym);
+			symval = sym_get_string_value(sym);
+		}
+
+		newlen = strlen(res) + strlen(symval) + strlen(src);
+		if (newlen > reslen) {
+			reslen = newlen;
+			realloc(res, reslen);
+		}
+
+		strcat(res, symval);
+		in = src;
+	}
+	strcat(res, in);
+
+	return res;
+}
+
 struct symbol **sym_re_search(const char *pattern)
 {
 	struct symbol *sym, **sym_arr = NULL;

commit 3643f849d7da5c12da589beb03c12303fe79b841
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Aug 14 14:40:00 2010 +0200

    kconfig: fix segfault when detecting recursive dependency
    
    Following sample Kconfig generated a segfault:
    
    config FOO
            bool
            select PERF_EVENTS if HAVE_HW_BREAKPOINT
    
    config PERF_EVENTS
            bool
    
    config HAVE_HW_BREAKPOINT
            bool
            depends on PERF_EVENTS
    
    Fix by reverting back to a valid property if there was no
    property on the stack of symbols.
    
    The above pattern were seen in sh Kconfig.
    A fix for the Kconfig file has been sent to the sh folks.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index e95718fea355..943712ca6c0a 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -937,6 +937,8 @@ static void sym_check_print_recursive(struct symbol *last_sym)
 		sym = stack->sym;
 		next_sym = stack->next ? stack->next->sym : last_sym;
 		prop = stack->prop;
+		if (prop == NULL)
+			prop = stack->sym->prop;
 
 		/* for choice values find the menu entry (used below) */
 		if (sym_is_choice(sym) || sym_is_choice_value(sym)) {

commit 7cf3d73b4360e91b14326632ab1aeda4cb26308d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:34 2010 +0200

    kconfig: add savedefconfig
    
    savedefconfig will save a minimal config to a file
    named "defconfig".
    
    The config symbols are saved in the same order as
    they appear in the menu structure so it should
    be possible to map them to the relevant menus
    if desired.
    
    The implementation was tested against several minimal
    configs for arm which was created using brute-force.
    
    There was one regression related to default numbers
    which had their valid range further limited by another symbol.
    
    Sample:
    
    config FOO
            int "foo"
            default 4
    
    config BAR
            int "bar"
            range 0 FOO
    
    If FOO is set to 3 then BAR cannot take a value higher than 3.
    But the current implementation will set BAR equal to 4.
    
    This is seldomly used and the final configuration is OK,
    and the fix was non-trivial.
    So it was documented in the code and left as is.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 0a013ab3ae27..e95718fea355 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -661,6 +661,80 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 	return true;
 }
 
+/*
+ * Find the default value associated to a symbol.
+ * For tristate symbol handle the modules=n case
+ * in which case "m" becomes "y".
+ * If the symbol does not have any default then fallback
+ * to the fixed default values.
+ */
+const char *sym_get_string_default(struct symbol *sym)
+{
+	struct property *prop;
+	struct symbol *ds;
+	const char *str;
+	tristate val;
+
+	sym_calc_visibility(sym);
+	sym_calc_value(modules_sym);
+	val = symbol_no.curr.tri;
+	str = symbol_empty.curr.val;
+
+	/* If symbol has a default value look it up */
+	prop = sym_get_default_prop(sym);
+	if (prop != NULL) {
+		switch (sym->type) {
+		case S_BOOLEAN:
+		case S_TRISTATE:
+			/* The visibility imay limit the value from yes => mod */
+			val = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);
+			break;
+		default:
+			/*
+			 * The following fails to handle the situation
+			 * where a default value is further limited by
+			 * the valid range.
+			 */
+			ds = prop_get_symbol(prop);
+			if (ds != NULL) {
+				sym_calc_value(ds);
+				str = (const char *)ds->curr.val;
+			}
+		}
+	}
+
+	/* Handle select statements */
+	val = EXPR_OR(val, sym->rev_dep.tri);
+
+	/* transpose mod to yes if modules are not enabled */
+	if (val == mod)
+		if (!sym_is_choice_value(sym) && modules_sym->curr.tri == no)
+			val = yes;
+
+	/* transpose mod to yes if type is bool */
+	if (sym->type == S_BOOLEAN && val == mod)
+		val = yes;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (val) {
+		case no: return "n";
+		case mod: return "m";
+		case yes: return "y";
+		}
+	case S_INT:
+	case S_HEX:
+		return str;
+	case S_STRING:
+		return str;
+	case S_OTHER:
+	case S_UNKNOWN:
+		break;
+	}
+	return "";
+}
+
 const char *sym_get_string_value(struct symbol *sym)
 {
 	tristate val;

commit c252147de68cf58ba601278481e473dab432cee4
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:32 2010 +0200

    kconfig: refactor code in symbol.c
    
    Move logic to determine default for a choice to
    a separate function.
    No functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index bc1e1584e2da..0a013ab3ae27 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -226,22 +226,18 @@ static void sym_calc_visibility(struct symbol *sym)
 	}
 }
 
-static struct symbol *sym_calc_choice(struct symbol *sym)
+/*
+ * Find the default symbol for a choice.
+ * First try the default values for the choice symbol
+ * Next locate the first visible choice value
+ * Return NULL if none was found
+ */
+struct symbol *sym_choice_default(struct symbol *sym)
 {
 	struct symbol *def_sym;
 	struct property *prop;
 	struct expr *e;
 
-	/* first calculate all choice values' visibilities */
-	prop = sym_get_choice_prop(sym);
-	expr_list_for_each_sym(prop->expr, e, def_sym)
-		sym_calc_visibility(def_sym);
-
-	/* is the user choice visible? */
-	def_sym = sym->def[S_DEF_USER].val;
-	if (def_sym && def_sym->visible != no)
-		return def_sym;
-
 	/* any of the defaults visible? */
 	for_all_defaults(sym, prop) {
 		prop->visible.tri = expr_calc_value(prop->visible.expr);
@@ -258,11 +254,35 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 		if (def_sym->visible != no)
 			return def_sym;
 
-	/* no choice? reset tristate value */
-	sym->curr.tri = no;
+	/* failed to locate any defaults */
 	return NULL;
 }
 
+static struct symbol *sym_calc_choice(struct symbol *sym)
+{
+	struct symbol *def_sym;
+	struct property *prop;
+	struct expr *e;
+
+	/* first calculate all choice values' visibilities */
+	prop = sym_get_choice_prop(sym);
+	expr_list_for_each_sym(prop->expr, e, def_sym)
+		sym_calc_visibility(def_sym);
+
+	/* is the user choice visible? */
+	def_sym = sym->def[S_DEF_USER].val;
+	if (def_sym && def_sym->visible != no)
+		return def_sym;
+
+	def_sym = sym_choice_default(sym);
+
+	if (def_sym == NULL)
+		/* no choice? reset tristate value */
+		sym->curr.tri = no;
+
+	return def_sym;
+}
+
 void sym_calc_value(struct symbol *sym)
 {
 	struct symbol_value newval, oldval;

commit d595cea62403db4e65b98a8bb96ff2b5205c7b82
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Jul 31 23:35:30 2010 +0200

    kconfig: print more info when we see a recursive dependency
    
    Consider following kconfig file:
    
    config TEST1
            bool "test 1"
            depends on TEST2
    
    config TEST2
            bool "test 2"
            depends on TEST1
    
    Previously kconfig would report:
    
    foo:6:error: found recursive dependency: TEST2 -> TEST1 -> TEST2
    
    With the following patch kconfig reports:
    foo:5:error: recursive dependency detected!
    foo:5:  symbol TEST2 depends on TEST1
    foo:1:  symbol TEST1 depends on TEST2
    
    Note that we now report where the offending symbols are defined.
    This can be a great help for complex situations involving
    several files.
    
    Patch is originally from Roman Zippel with a few adjustments by Sam.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 9f180ab7698d..bc1e1584e2da 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -783,6 +783,110 @@ struct symbol **sym_re_search(const char *pattern)
 	return sym_arr;
 }
 
+/*
+ * When we check for recursive dependencies we use a stack to save
+ * current state so we can print out relevant info to user.
+ * The entries are located on the call stack so no need to free memory.
+ * Note inser() remove() must always match to properly clear the stack.
+ */
+static struct dep_stack {
+	struct dep_stack *prev, *next;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *expr;
+} *check_top;
+
+static void dep_stack_insert(struct dep_stack *stack, struct symbol *sym)
+{
+	memset(stack, 0, sizeof(*stack));
+	if (check_top)
+		check_top->next = stack;
+	stack->prev = check_top;
+	stack->sym = sym;
+	check_top = stack;
+}
+
+static void dep_stack_remove(void)
+{
+	check_top = check_top->prev;
+	if (check_top)
+		check_top->next = NULL;
+}
+
+/*
+ * Called when we have detected a recursive dependency.
+ * check_top point to the top of the stact so we use
+ * the ->prev pointer to locate the bottom of the stack.
+ */
+static void sym_check_print_recursive(struct symbol *last_sym)
+{
+	struct dep_stack *stack;
+	struct symbol *sym, *next_sym;
+	struct menu *menu = NULL;
+	struct property *prop;
+	struct dep_stack cv_stack;
+
+	if (sym_is_choice_value(last_sym)) {
+		dep_stack_insert(&cv_stack, last_sym);
+		last_sym = prop_get_symbol(sym_get_choice_prop(last_sym));
+	}
+
+	for (stack = check_top; stack != NULL; stack = stack->prev)
+		if (stack->sym == last_sym)
+			break;
+	if (!stack) {
+		fprintf(stderr, "unexpected recursive dependency error\n");
+		return;
+	}
+
+	for (; stack; stack = stack->next) {
+		sym = stack->sym;
+		next_sym = stack->next ? stack->next->sym : last_sym;
+		prop = stack->prop;
+
+		/* for choice values find the menu entry (used below) */
+		if (sym_is_choice(sym) || sym_is_choice_value(sym)) {
+			for (prop = sym->prop; prop; prop = prop->next) {
+				menu = prop->menu;
+				if (prop->menu)
+					break;
+			}
+		}
+		if (stack->sym == last_sym)
+			fprintf(stderr, "%s:%d:error: recursive dependency detected!\n",
+				prop->file->name, prop->lineno);
+		if (stack->expr) {
+			fprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",
+				prop->file->name, prop->lineno,
+				sym->name ? sym->name : "<choice>",
+				prop_get_type_name(prop->type),
+				next_sym->name ? next_sym->name : "<choice>");
+		} else if (stack->prop) {
+			fprintf(stderr, "%s:%d:\tsymbol %s depends on %s\n",
+				prop->file->name, prop->lineno,
+				sym->name ? sym->name : "<choice>",
+				next_sym->name ? next_sym->name : "<choice>");
+		} else if (sym_is_choice(sym)) {
+			fprintf(stderr, "%s:%d:\tchoice %s contains symbol %s\n",
+				menu->file->name, menu->lineno,
+				sym->name ? sym->name : "<choice>",
+				next_sym->name ? next_sym->name : "<choice>");
+		} else if (sym_is_choice_value(sym)) {
+			fprintf(stderr, "%s:%d:\tsymbol %s is part of choice %s\n",
+				menu->file->name, menu->lineno,
+				sym->name ? sym->name : "<choice>",
+				next_sym->name ? next_sym->name : "<choice>");
+		} else {
+			fprintf(stderr, "%s:%d:\tsymbol %s is selected by %s\n",
+				prop->file->name, prop->lineno,
+				sym->name ? sym->name : "<choice>",
+				next_sym->name ? next_sym->name : "<choice>");
+		}
+	}
+
+	if (check_top == &cv_stack)
+		dep_stack_remove();
+}
 
 static struct symbol *sym_check_expr_deps(struct expr *e)
 {
@@ -819,24 +923,33 @@ static struct symbol *sym_check_sym_deps(struct symbol *sym)
 {
 	struct symbol *sym2;
 	struct property *prop;
+	struct dep_stack stack;
+
+	dep_stack_insert(&stack, sym);
 
 	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
 	if (sym2)
-		return sym2;
+		goto out;
 
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->type == P_CHOICE || prop->type == P_SELECT)
 			continue;
+		stack.prop = prop;
 		sym2 = sym_check_expr_deps(prop->visible.expr);
 		if (sym2)
 			break;
 		if (prop->type != P_DEFAULT || sym_is_choice(sym))
 			continue;
+		stack.expr = prop->expr;
 		sym2 = sym_check_expr_deps(prop->expr);
 		if (sym2)
 			break;
+		stack.expr = NULL;
 	}
 
+out:
+	dep_stack_remove();
+
 	return sym2;
 }
 
@@ -845,6 +958,9 @@ static struct symbol *sym_check_choice_deps(struct symbol *choice)
 	struct symbol *sym, *sym2;
 	struct property *prop;
 	struct expr *e;
+	struct dep_stack stack;
+
+	dep_stack_insert(&stack, choice);
 
 	prop = sym_get_choice_prop(choice);
 	expr_list_for_each_sym(prop->expr, e, sym)
@@ -858,10 +974,8 @@ static struct symbol *sym_check_choice_deps(struct symbol *choice)
 
 	expr_list_for_each_sym(prop->expr, e, sym) {
 		sym2 = sym_check_sym_deps(sym);
-		if (sym2) {
-			fprintf(stderr, " -> %s", sym->name);
+		if (sym2)
 			break;
-		}
 	}
 out:
 	expr_list_for_each_sym(prop->expr, e, sym)
@@ -871,6 +985,8 @@ static struct symbol *sym_check_choice_deps(struct symbol *choice)
 	    prop_get_symbol(sym_get_choice_prop(sym2)) == choice)
 		sym2 = choice;
 
+	dep_stack_remove();
+
 	return sym2;
 }
 
@@ -880,18 +996,20 @@ struct symbol *sym_check_deps(struct symbol *sym)
 	struct property *prop;
 
 	if (sym->flags & SYMBOL_CHECK) {
-		fprintf(stderr, "%s:%d:error: found recursive dependency: %s",
-		        sym->prop->file->name, sym->prop->lineno,
-			sym->name ? sym->name : "<choice>");
+		sym_check_print_recursive(sym);
 		return sym;
 	}
 	if (sym->flags & SYMBOL_CHECKED)
 		return NULL;
 
 	if (sym_is_choice_value(sym)) {
+		struct dep_stack stack;
+
 		/* for choice groups start the check with main choice symbol */
+		dep_stack_insert(&stack, sym);
 		prop = sym_get_choice_prop(sym);
 		sym2 = sym_check_deps(prop_get_symbol(prop));
+		dep_stack_remove();
 	} else if (sym_is_choice(sym)) {
 		sym2 = sym_check_choice_deps(sym);
 	} else {
@@ -900,14 +1018,8 @@ struct symbol *sym_check_deps(struct symbol *sym)
 		sym->flags &= ~SYMBOL_CHECK;
 	}
 
-	if (sym2) {
-		fprintf(stderr, " -> %s", sym->name ? sym->name : "<choice>");
-		if (sym2 == sym) {
-			fprintf(stderr, "\n");
-			zconfnerrs++;
-			sym2 = NULL;
-		}
-	}
+	if (sym2 && sym2 == sym)
+		sym2 = NULL;
 
 	return sym2;
 }

commit 59e89e3ddf8523be39a8e0a66bacbbdd6a72d069
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:29 2010 +0200

    kconfig: save location of config symbols
    
    When we add a new config symbol save the file/line
    so we later can refer to their location.
    
    The information is saved as a property to a config symbol
    because we may have multiple definitions of the same symbol.
    
    This has the side-effect that a symbol always has
    at least one property.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c127fa342f1d..9f180ab7698d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -961,6 +961,8 @@ const char *prop_get_type_name(enum prop_type type)
 		return "select";
 	case P_RANGE:
 		return "range";
+	case P_SYMBOL:
+		return "symbol";
 	case P_UNKNOWN:
 		break;
 	}

commit 0a28c47b8db8ff74d1bfbc5c5ad0100cea472351
Author: Jan Beulich <JBeulich@novell.com>
Date:   Wed Jun 30 13:11:01 2010 +0100

    kconfig: Don't write invisible choice values
    
    This makes it so "make oldconfig" really prompts for any choice where
    options that previously weren't visible just became so. Previously one
    would have to remember to go over all choice values and check whether
    some that previously couldn't be selected now can be.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 174b230a52b0..c127fa342f1d 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -232,13 +232,15 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 	struct property *prop;
 	struct expr *e;
 
+	/* first calculate all choice values' visibilities */
+	prop = sym_get_choice_prop(sym);
+	expr_list_for_each_sym(prop->expr, e, def_sym)
+		sym_calc_visibility(def_sym);
+
 	/* is the user choice visible? */
 	def_sym = sym->def[S_DEF_USER].val;
-	if (def_sym) {
-		sym_calc_visibility(def_sym);
-		if (def_sym->visible != no)
-			return def_sym;
-	}
+	if (def_sym && def_sym->visible != no)
+		return def_sym;
 
 	/* any of the defaults visible? */
 	for_all_defaults(sym, prop) {
@@ -246,18 +248,15 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 		if (prop->visible.tri == no)
 			continue;
 		def_sym = prop_get_symbol(prop);
-		sym_calc_visibility(def_sym);
 		if (def_sym->visible != no)
 			return def_sym;
 	}
 
 	/* just get the first visible value */
 	prop = sym_get_choice_prop(sym);
-	expr_list_for_each_sym(prop->expr, e, def_sym) {
-		sym_calc_visibility(def_sym);
+	expr_list_for_each_sym(prop->expr, e, def_sym)
 		if (def_sym->visible != no)
 			return def_sym;
-	}
 
 	/* no choice? reset tristate value */
 	sym->curr.tri = no;
@@ -383,12 +382,13 @@ void sym_calc_value(struct symbol *sym)
 
 	if (sym_is_choice(sym)) {
 		struct symbol *choice_sym;
-		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
 
 		prop = sym_get_choice_prop(sym);
 		expr_list_for_each_sym(prop->expr, e, choice_sym) {
-			choice_sym->flags |= flags;
-			if (flags & SYMBOL_CHANGED)
+			if ((sym->flags & SYMBOL_WRITE) &&
+			    choice_sym->visible != no)
+				choice_sym->flags |= SYMBOL_WRITE;
+			if (sym->flags & SYMBOL_CHANGED)
 				sym_set_changed(choice_sym);
 		}
 	}

commit 246cf9c26bf11f2bffbecea6e5bd222eee7b1df8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jun 8 17:25:57 2010 +0100

    kbuild: Warn on selecting symbols with unmet direct dependencies
    
    The "select" statement in Kconfig files allows the enabling of options
    even if they have unmet direct dependencies (i.e. "depends on" expands
    to "no"). Currently, the "depends on" clauses are used in calculating
    the visibility but they do not affect the reverse dependencies in any
    way.
    
    The patch introduces additional tracking of the "depends on" statements
    and prints a warning on selecting an option if its direct dependencies
    are not met.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 2e7a048e0cfc..174b230a52b0 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -205,6 +205,16 @@ static void sym_calc_visibility(struct symbol *sym)
 	}
 	if (sym_is_choice_value(sym))
 		return;
+	/* defaulting to "yes" if no explicit "depends on" are given */
+	tri = yes;
+	if (sym->dir_dep.expr)
+		tri = expr_calc_value(sym->dir_dep.expr);
+	if (tri == mod)
+		tri = yes;
+	if (sym->dir_dep.tri != tri) {
+		sym->dir_dep.tri = tri;
+		sym_set_changed(sym);
+	}
 	tri = no;
 	if (sym->rev_dep.expr)
 		tri = expr_calc_value(sym->rev_dep.expr);
@@ -321,6 +331,14 @@ void sym_calc_value(struct symbol *sym)
 				}
 			}
 		calc_newval:
+			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
+				fprintf(stderr, "warning: (");
+				expr_fprint(sym->rev_dep.expr, stderr);
+				fprintf(stderr, ") selects %s which has unmet direct dependencies (",
+					sym->name);
+				expr_fprint(sym->dir_dep.expr, stderr);
+				fprintf(stderr, ")\n");
+			}
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
 		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)

commit da6df879b9f88d2224174a9e4e76dc0e42e47ebc
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Mar 19 14:57:47 2010 +0800

    kconfig: recalc symbol value before showing search results
    
    A symbol's value won't be recalc-ed until we save config file or
    enter the menu where the symbol sits.
    
    So If I enable OPTIMIZE_FOR_SIZE, and search FUNCTION_GRAPH_TRACER:
    
      Symbol: FUNCTION_GRAPH_TRACER [=y]
      Prompt: Kernel Function Graph Tracer
        Defined at kernel/trace/Kconfig:140
        Depends on: ... [=y] && (!X86_32 [=y] || !CC_OPTIMIZE_FOR_SIZE [=y])
        ...
    
    From the dependency it should result in FUNCTION_GRAPH_TRACER=n,
    but it still shows FUNCTION_GRAPH_TRACER=y.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 9ee3923117ee..2e7a048e0cfc 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -755,6 +755,7 @@ struct symbol **sym_re_search(const char *pattern)
 				return NULL;
 			}
 		}
+		sym_calc_value(sym);
 		sym_arr[cnt++] = sym;
 	}
 	if (sym_arr)

commit e66f25d7d1be19e177cf55126a40799757efae89
Author: Andi Kleen <andi@firstfloor.org>
Date:   Wed Jan 13 17:02:44 2010 +0100

    Improve kconfig symbol hashing
    
    While looking for something else I noticed that the symbol
    hash function used by kconfig is quite poor. It doesn't
    use any of the standard hash techniques but simply
    adds up the string and then uses power of two masking,
    which is both known to perform poorly.
    
    The current x86 kconfig has over 7000 symbols.
    
    When I instrumented it showed that the minimum hash chain
    length was 16 and a significant number of them was over
    30.
    
    It didn't help that the hash table size was only 256 buckets.
    
    This patch increases the hash table size to a larger prime
    and switches to a FNV32 hash. I played around with a couple of hash
    functions, but that one seemed to perform best with reasonable
    hash table sizes.
    
    Increasing the hash table size even further didn't
    seem like a good idea, because there are a couple of global
    walks which walk the complete hash table.
    
    I also moved the unnamed bucket to 0. It's still the longest
    of all the buckets (44 entries), but hopefully it's not
    often hit except for the global walk which doesn't care.
    
    The result is a much nicer distribution:
    (first column bucket length, second number of buckets with that length)
    
    1: 3505
    2: 1236
    3: 294
    4: 52
    5: 3
    47: 1           <--- this is the unnamed symbols bucket
    
    There are still some 5+ buckets, but increasing the hash table
    even more would be likely not worth it.
    
    This also cleans up the code slightly by removing hard coded
    magic numbers.
    
    I didn't notice a big performance difference either way
    on my Nehalem system, but I presume it'll help somewhat
    on slower systems.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 6c8fbbb66ebc..9ee3923117ee 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -651,12 +651,20 @@ bool sym_is_changable(struct symbol *sym)
 	return sym->visible > sym->rev_dep.tri;
 }
 
+static unsigned strhash(const char *s)
+{
+	/* fnv32 hash */
+	unsigned hash = 2166136261U;
+	for (; *s; s++)
+		hash = (hash ^ *s) * 0x01000193;
+	return hash;
+}
+
 struct symbol *sym_lookup(const char *name, int flags)
 {
 	struct symbol *symbol;
-	const char *ptr;
 	char *new_name;
-	int hash = 0;
+	int hash;
 
 	if (name) {
 		if (name[0] && !name[1]) {
@@ -666,12 +674,11 @@ struct symbol *sym_lookup(const char *name, int flags)
 			case 'n': return &symbol_no;
 			}
 		}
-		for (ptr = name; *ptr; ptr++)
-			hash += *ptr;
-		hash &= 0xff;
+		hash = strhash(name) % SYMBOL_HASHSIZE;
 
 		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
-			if (!strcmp(symbol->name, name) &&
+			if (symbol->name &&
+			    !strcmp(symbol->name, name) &&
 			    (flags ? symbol->flags & flags
 				   : !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))
 				return symbol;
@@ -679,7 +686,7 @@ struct symbol *sym_lookup(const char *name, int flags)
 		new_name = strdup(name);
 	} else {
 		new_name = NULL;
-		hash = 256;
+		hash = 0;
 	}
 
 	symbol = malloc(sizeof(*symbol));
@@ -697,7 +704,6 @@ struct symbol *sym_lookup(const char *name, int flags)
 struct symbol *sym_find(const char *name)
 {
 	struct symbol *symbol = NULL;
-	const char *ptr;
 	int hash = 0;
 
 	if (!name)
@@ -710,12 +716,11 @@ struct symbol *sym_find(const char *name)
 		case 'n': return &symbol_no;
 		}
 	}
-	for (ptr = name; *ptr; ptr++)
-		hash += *ptr;
-	hash &= 0xff;
+	hash = strhash(name) % SYMBOL_HASHSIZE;
 
 	for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
-		if (!strcmp(symbol->name, name) &&
+		if (symbol->name &&
+		    !strcmp(symbol->name, name) &&
 		    !(symbol->flags & SYMBOL_CONST))
 				break;
 	}

commit 4356f4890792a678936c93c9196e8f7742e04535
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Fri Sep 18 12:49:23 2009 -0700

    kbuild: add static to prototypes
    
    Warnings found via gcc -Wmissing-prototypes.
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 18f3e5c33634..6c8fbbb66ebc 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -36,7 +36,7 @@ tristate modules_val;
 
 struct expr *sym_env_list;
 
-void sym_add_default(struct symbol *sym, const char *def)
+static void sym_add_default(struct symbol *sym, const char *def)
 {
 	struct property *prop = prop_alloc(P_DEFAULT, sym);
 
@@ -125,7 +125,7 @@ struct property *sym_get_default_prop(struct symbol *sym)
 	return NULL;
 }
 
-struct property *sym_get_range_prop(struct symbol *sym)
+static struct property *sym_get_range_prop(struct symbol *sym)
 {
 	struct property *prop;
 
@@ -943,7 +943,7 @@ const char *prop_get_type_name(enum prop_type type)
 	return "unknown";
 }
 
-void prop_add_env(const char *env)
+static void prop_add_env(const char *env)
 {
 	struct symbol *sym, *sym2;
 	struct property *prop;

commit 5a1aa8a1aff6191ecc55f21d8b5f0e47108ed91b
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Feb 29 05:11:50 2008 +0100

    kconfig: add named choice group
    
    As choice dependency are now fully checked, it's quite easy to add support
    for named choices. This lifts the restriction that a choice value can only
    appear once, although it still has to be within the same group,
    but multiple choices can be joined by giving them a name.
    While at it I cleaned up a little the choice type logic to simplify it a
    bit.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 45f409a8f37f..18f3e5c33634 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -40,7 +40,7 @@ void sym_add_default(struct symbol *sym, const char *def)
 {
 	struct property *prop = prop_alloc(P_DEFAULT, sym);
 
-	prop->expr = expr_alloc_symbol(sym_lookup(def, 1));
+	prop->expr = expr_alloc_symbol(sym_lookup(def, SYMBOL_CONST));
 }
 
 void sym_init(void)
@@ -350,9 +350,6 @@ void sym_calc_value(struct symbol *sym)
 		;
 	}
 
-	if (sym->flags & SYMBOL_AUTO)
-		sym->flags &= ~SYMBOL_WRITE;
-
 	sym->curr = newval;
 	if (sym_is_choice(sym) && newval.tri == yes)
 		sym->curr.val = sym_calc_choice(sym);
@@ -377,6 +374,9 @@ void sym_calc_value(struct symbol *sym)
 				sym_set_changed(choice_sym);
 		}
 	}
+
+	if (sym->flags & SYMBOL_AUTO)
+		sym->flags &= ~SYMBOL_WRITE;
 }
 
 void sym_clear_all_valid(void)
@@ -651,7 +651,7 @@ bool sym_is_changable(struct symbol *sym)
 	return sym->visible > sym->rev_dep.tri;
 }
 
-struct symbol *sym_lookup(const char *name, int isconst)
+struct symbol *sym_lookup(const char *name, int flags)
 {
 	struct symbol *symbol;
 	const char *ptr;
@@ -671,11 +671,10 @@ struct symbol *sym_lookup(const char *name, int isconst)
 		hash &= 0xff;
 
 		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
-			if (!strcmp(symbol->name, name)) {
-				if ((isconst && symbol->flags & SYMBOL_CONST) ||
-				    (!isconst && !(symbol->flags & SYMBOL_CONST)))
-					return symbol;
-			}
+			if (!strcmp(symbol->name, name) &&
+			    (flags ? symbol->flags & flags
+				   : !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))
+				return symbol;
 		}
 		new_name = strdup(name);
 	} else {
@@ -687,8 +686,7 @@ struct symbol *sym_lookup(const char *name, int isconst)
 	memset(symbol, 0, sizeof(*symbol));
 	symbol->name = new_name;
 	symbol->type = S_UNKNOWN;
-	if (isconst)
-		symbol->flags |= SYMBOL_CONST;
+	symbol->flags |= flags;
 
 	symbol->next = symbol_hash[hash];
 	symbol_hash[hash] = symbol;
@@ -962,7 +960,7 @@ void prop_add_env(const char *env)
 	}
 
 	prop = prop_alloc(P_ENV, sym);
-	prop->expr = expr_alloc_symbol(sym_lookup(env, 1));
+	prop->expr = expr_alloc_symbol(sym_lookup(env, SYMBOL_CONST));
 
 	sym_env_list = expr_alloc_one(E_LIST, sym_env_list);
 	sym_env_list->right.sym = sym;

commit 48981178869bf7d9770f11fc361996ad11217a75
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Feb 29 05:10:24 2008 +0100

    kconfig: fix choice dependency check
    
    Properly check the dependency of choices as a group.
    Also fix that sym_check_deps() correctly terminates the dependency loop
    error check (otherwise it would continue printing the dependency chain).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 4a03191ad176..45f409a8f37f 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -762,8 +762,6 @@ struct symbol **sym_re_search(const char *pattern)
 }
 
 
-struct symbol *sym_check_deps(struct symbol *sym);
-
 static struct symbol *sym_check_expr_deps(struct expr *e)
 {
 	struct symbol *sym;
@@ -795,40 +793,100 @@ static struct symbol *sym_check_expr_deps(struct expr *e)
 }
 
 /* return NULL when dependencies are OK */
-struct symbol *sym_check_deps(struct symbol *sym)
+static struct symbol *sym_check_sym_deps(struct symbol *sym)
 {
 	struct symbol *sym2;
 	struct property *prop;
 
-	if (sym->flags & SYMBOL_CHECK) {
-		fprintf(stderr, "%s:%d:error: found recursive dependency: %s",
-		        sym->prop->file->name, sym->prop->lineno, sym->name);
-		return sym;
-	}
-	if (sym->flags & SYMBOL_CHECKED)
-		return NULL;
-
-	sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
 	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
 	if (sym2)
-		goto out;
+		return sym2;
 
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->type == P_CHOICE || prop->type == P_SELECT)
 			continue;
 		sym2 = sym_check_expr_deps(prop->visible.expr);
 		if (sym2)
-			goto out;
+			break;
 		if (prop->type != P_DEFAULT || sym_is_choice(sym))
 			continue;
 		sym2 = sym_check_expr_deps(prop->expr);
 		if (sym2)
-			goto out;
+			break;
 	}
-out:
+
+	return sym2;
+}
+
+static struct symbol *sym_check_choice_deps(struct symbol *choice)
+{
+	struct symbol *sym, *sym2;
+	struct property *prop;
+	struct expr *e;
+
+	prop = sym_get_choice_prop(choice);
+	expr_list_for_each_sym(prop->expr, e, sym)
+		sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
+
+	choice->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
+	sym2 = sym_check_sym_deps(choice);
+	choice->flags &= ~SYMBOL_CHECK;
 	if (sym2)
-		fprintf(stderr, " -> %s%s", sym->name, sym2 == sym? "\n": "");
-	sym->flags &= ~SYMBOL_CHECK;
+		goto out;
+
+	expr_list_for_each_sym(prop->expr, e, sym) {
+		sym2 = sym_check_sym_deps(sym);
+		if (sym2) {
+			fprintf(stderr, " -> %s", sym->name);
+			break;
+		}
+	}
+out:
+	expr_list_for_each_sym(prop->expr, e, sym)
+		sym->flags &= ~SYMBOL_CHECK;
+
+	if (sym2 && sym_is_choice_value(sym2) &&
+	    prop_get_symbol(sym_get_choice_prop(sym2)) == choice)
+		sym2 = choice;
+
+	return sym2;
+}
+
+struct symbol *sym_check_deps(struct symbol *sym)
+{
+	struct symbol *sym2;
+	struct property *prop;
+
+	if (sym->flags & SYMBOL_CHECK) {
+		fprintf(stderr, "%s:%d:error: found recursive dependency: %s",
+		        sym->prop->file->name, sym->prop->lineno,
+			sym->name ? sym->name : "<choice>");
+		return sym;
+	}
+	if (sym->flags & SYMBOL_CHECKED)
+		return NULL;
+
+	if (sym_is_choice_value(sym)) {
+		/* for choice groups start the check with main choice symbol */
+		prop = sym_get_choice_prop(sym);
+		sym2 = sym_check_deps(prop_get_symbol(prop));
+	} else if (sym_is_choice(sym)) {
+		sym2 = sym_check_choice_deps(sym);
+	} else {
+		sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
+		sym2 = sym_check_sym_deps(sym);
+		sym->flags &= ~SYMBOL_CHECK;
+	}
+
+	if (sym2) {
+		fprintf(stderr, " -> %s", sym->name ? sym->name : "<choice>");
+		if (sym2 == sym) {
+			fprintf(stderr, "\n");
+			zconfnerrs++;
+			sym2 = NULL;
+		}
+	}
+
 	return sym2;
 }
 

commit 587c90616a5b44e6ccfac38e64d4fecee51d588c
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Feb 11 21:13:47 2008 +0100

    kconfig: fix select in combination with default
    
    > The attached .config (with current -git) results in a compile
    > error since it contains:
    >
    > CONFIG_X86=y
    > # CONFIG_EMBEDDED is not set
    > CONFIG_SERIO=m
    > CONFIG_SERIO_I8042=y
    >
    > Looking at drivers/input/serio/Kconfig I simply don't get how this
    > can happen.
    
    You've hit the rather subtle rules of select vs default. What happened is
    that SERIO is selected to m, but SERIO_I8042 isn't selected so the default
    of y is used instead.
    We already had the problem in the past that select and default don't work
    well together, so this patch cleans this up and makes the rule hopefully
    more straightforward. Basically now the value is calculated like this:
    
            (value && dependency) || select
    
    where the value is the user choice (if available and the symbol is
    visible) or default.
    
    In this case it means SERIO and SERIO_I8042 are both set to y due to their
    default and if SERIO didn't had the default, then the SERIO_I8042 value
    would be limited to m due to the dependency.
    
    I tested this patch with more 10000 random configs and above case is the
    only the difference that showed up, so I hope there is nothing that
    depended on the old more complex and subtle rules.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Tested-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 3929e5b35e79..4a03191ad176 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -298,22 +298,30 @@ void sym_calc_value(struct symbol *sym)
 		if (sym_is_choice_value(sym) && sym->visible == yes) {
 			prop = sym_get_choice_prop(sym);
 			newval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;
-		} else if (EXPR_OR(sym->visible, sym->rev_dep.tri) != no) {
-			sym->flags |= SYMBOL_WRITE;
-			if (sym_has_value(sym))
-				newval.tri = sym->def[S_DEF_USER].tri;
-			else if (!sym_is_choice(sym)) {
-				prop = sym_get_default_prop(sym);
-				if (prop)
-					newval.tri = expr_calc_value(prop->expr);
+		} else {
+			if (sym->visible != no) {
+				/* if the symbol is visible use the user value
+				 * if available, otherwise try the default value
+				 */
+				sym->flags |= SYMBOL_WRITE;
+				if (sym_has_value(sym)) {
+					newval.tri = EXPR_AND(sym->def[S_DEF_USER].tri,
+							      sym->visible);
+					goto calc_newval;
+				}
 			}
-			newval.tri = EXPR_OR(EXPR_AND(newval.tri, sym->visible), sym->rev_dep.tri);
-		} else if (!sym_is_choice(sym)) {
-			prop = sym_get_default_prop(sym);
-			if (prop) {
+			if (sym->rev_dep.tri != no)
 				sym->flags |= SYMBOL_WRITE;
-				newval.tri = expr_calc_value(prop->expr);
+			if (!sym_is_choice(sym)) {
+				prop = sym_get_default_prop(sym);
+				if (prop) {
+					sym->flags |= SYMBOL_WRITE;
+					newval.tri = EXPR_AND(expr_calc_value(prop->expr),
+							      prop->visible.tri);
+				}
 			}
+		calc_newval:
+			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
 		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)
 			newval.tri = yes;

commit 80daa56008dad44f08d0b47670cf2513aa98ab53
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:51:16 2008 +0100

    kconfig: use environment option
    
    Use the environment option to provide the ARCH symbol
    and the KERNELVERSION symbol.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 99e3d02d1cfc..3929e5b35e79 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -47,7 +47,6 @@ void sym_init(void)
 {
 	struct symbol *sym;
 	struct utsname uts;
-	char *p;
 	static bool inited = false;
 
 	if (inited)
@@ -56,20 +55,6 @@ void sym_init(void)
 
 	uname(&uts);
 
-	sym = sym_lookup("ARCH", 0);
-	sym->type = S_STRING;
-	sym->flags |= SYMBOL_AUTO;
-	p = getenv("ARCH");
-	if (p)
-		sym_add_default(sym, p);
-
-	sym = sym_lookup("KERNELVERSION", 0);
-	sym->type = S_STRING;
-	sym->flags |= SYMBOL_AUTO;
-	p = getenv("KERNELVERSION");
-	if (p)
-		sym_add_default(sym, p);
-
 	sym = sym_lookup("UNAME_RELEASE", 0);
 	sym->type = S_STRING;
 	sym->flags |= SYMBOL_AUTO;

commit 93449082e905ce73d0346d617dd67c4b668b58af
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:50:54 2008 +0100

    kconfig: environment symbol support
    
    Add the possibility to import a value from the environment into kconfig
    via the option syntax. Beside flexibility this has the advantage
    providing proper dependencies.
    Documented the options syntax.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index a7dfc82fc858..99e3d02d1cfc 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -34,6 +34,8 @@ struct symbol *sym_defconfig_list;
 struct symbol *modules_sym;
 tristate modules_val;
 
+struct expr *sym_env_list;
+
 void sym_add_default(struct symbol *sym, const char *def)
 {
 	struct property *prop = prop_alloc(P_DEFAULT, sym);
@@ -117,6 +119,15 @@ struct property *sym_get_choice_prop(struct symbol *sym)
 	return NULL;
 }
 
+struct property *sym_get_env_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_properties(sym, prop, P_ENV)
+		return prop;
+	return NULL;
+}
+
 struct property *sym_get_default_prop(struct symbol *sym)
 {
 	struct property *prop;
@@ -346,6 +357,9 @@ void sym_calc_value(struct symbol *sym)
 		;
 	}
 
+	if (sym->flags & SYMBOL_AUTO)
+		sym->flags &= ~SYMBOL_WRITE;
+
 	sym->curr = newval;
 	if (sym_is_choice(sym) && newval.tri == yes)
 		sym->curr.val = sym_calc_choice(sym);
@@ -860,6 +874,8 @@ const char *prop_get_type_name(enum prop_type type)
 	switch (type) {
 	case P_PROMPT:
 		return "prompt";
+	case P_ENV:
+		return "env";
 	case P_COMMENT:
 		return "comment";
 	case P_MENU:
@@ -877,3 +893,32 @@ const char *prop_get_type_name(enum prop_type type)
 	}
 	return "unknown";
 }
+
+void prop_add_env(const char *env)
+{
+	struct symbol *sym, *sym2;
+	struct property *prop;
+	char *p;
+
+	sym = current_entry->sym;
+	sym->flags |= SYMBOL_AUTO;
+	for_all_properties(sym, prop, P_ENV) {
+		sym2 = prop_get_symbol(prop);
+		if (strcmp(sym2->name, env))
+			menu_warn(current_entry, "redefining environment symbol from %s",
+				  sym2->name);
+		return;
+	}
+
+	prop = prop_alloc(P_ENV, sym);
+	prop->expr = expr_alloc_symbol(sym_lookup(env, 1));
+
+	sym_env_list = expr_alloc_one(E_LIST, sym_env_list);
+	sym_env_list->right.sym = sym;
+
+	p = getenv(env);
+	if (p)
+		sym_add_default(sym, p);
+	else
+		menu_warn(current_entry, "environment variable %s undefined", env);
+}

commit 7a962923359768e04137125bd479fd0dfa6117d3
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:50:23 2008 +0100

    kconfig: explicitly introduce expression list
    
    Rename E_CHOICE to E_LIST to explicitly add support for expression
    lists. Add a helper macro expr_list_for_each_sym to more easily iterate
    over the list.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index add068c8e513..a7dfc82fc858 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -247,8 +247,7 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 
 	/* just get the first visible value */
 	prop = sym_get_choice_prop(sym);
-	for (e = prop->expr; e; e = e->left.expr) {
-		def_sym = e->right.sym;
+	expr_list_for_each_sym(prop->expr, e, def_sym) {
 		sym_calc_visibility(def_sym);
 		if (def_sym->visible != no)
 			return def_sym;
@@ -361,12 +360,14 @@ void sym_calc_value(struct symbol *sym)
 	}
 
 	if (sym_is_choice(sym)) {
+		struct symbol *choice_sym;
 		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
+
 		prop = sym_get_choice_prop(sym);
-		for (e = prop->expr; e; e = e->left.expr) {
-			e->right.sym->flags |= flags;
+		expr_list_for_each_sym(prop->expr, e, choice_sym) {
+			choice_sym->flags |= flags;
 			if (flags & SYMBOL_CHANGED)
-				sym_set_changed(e->right.sym);
+				sym_set_changed(choice_sym);
 		}
 	}
 }
@@ -849,7 +850,7 @@ struct property *prop_alloc(enum prop_type type, struct symbol *sym)
 struct symbol *prop_get_symbol(struct property *prop)
 {
 	if (prop->expr && (prop->expr->type == E_SYMBOL ||
-			   prop->expr->type == E_CHOICE))
+			   prop->expr->type == E_LIST))
 		return prop->expr->left.sym;
 	return NULL;
 }

commit d6ee35764f270c699e165b15dc59f4e55546bfda
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jan 7 21:09:55 2008 +0100

    kconfig: rename E_OR & friends to avoid name clash
    
    We had macros named the same as a set of enumeration values.
    It is legal code but very confusing to read - so rename
    the macros from E_* to EXPR_*
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index c35dcc5d6189..add068c8e513 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -199,7 +199,7 @@ static void sym_calc_visibility(struct symbol *sym)
 	tri = no;
 	for_all_prompts(sym, prop) {
 		prop->visible.tri = expr_calc_value(prop->visible.expr);
-		tri = E_OR(tri, prop->visible.tri);
+		tri = EXPR_OR(tri, prop->visible.tri);
 	}
 	if (tri == mod && (sym->type != S_TRISTATE || modules_val == no))
 		tri = yes;
@@ -303,7 +303,7 @@ void sym_calc_value(struct symbol *sym)
 		if (sym_is_choice_value(sym) && sym->visible == yes) {
 			prop = sym_get_choice_prop(sym);
 			newval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;
-		} else if (E_OR(sym->visible, sym->rev_dep.tri) != no) {
+		} else if (EXPR_OR(sym->visible, sym->rev_dep.tri) != no) {
 			sym->flags |= SYMBOL_WRITE;
 			if (sym_has_value(sym))
 				newval.tri = sym->def[S_DEF_USER].tri;
@@ -312,7 +312,7 @@ void sym_calc_value(struct symbol *sym)
 				if (prop)
 					newval.tri = expr_calc_value(prop->expr);
 			}
-			newval.tri = E_OR(E_AND(newval.tri, sym->visible), sym->rev_dep.tri);
+			newval.tri = EXPR_OR(EXPR_AND(newval.tri, sym->visible), sym->rev_dep.tri);
 		} else if (!sym_is_choice(sym)) {
 			prop = sym_get_default_prop(sym);
 			if (prop) {

commit 5447d34b080a1e3e312b05a91e87eff4710a1152
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 6 09:20:10 2007 +0200

    kconfig: error out if recursive dependencies are found
    
    Sample:
    config FOO
            bool "This is foo"
            depends on BAR
    
    config BAR
            bool "This is bar"
            depends on FOO
    
    This will result in following error message:
    error: found recursive dependency: FOO -> BAR -> FOO
    
    And will then exit with exit code equal 1 so make will stop.
    Inspired by patch from: Adrian Bunk <bunk@stusta.de>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 8f06c474d800..c35dcc5d6189 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -786,13 +786,15 @@ static struct symbol *sym_check_expr_deps(struct expr *e)
 	return NULL;
 }
 
+/* return NULL when dependencies are OK */
 struct symbol *sym_check_deps(struct symbol *sym)
 {
 	struct symbol *sym2;
 	struct property *prop;
 
 	if (sym->flags & SYMBOL_CHECK) {
-		printf("Warning! Found recursive dependency: %s", sym->name);
+		fprintf(stderr, "%s:%d:error: found recursive dependency: %s",
+		        sym->prop->file->name, sym->prop->lineno, sym->name);
 		return sym;
 	}
 	if (sym->flags & SYMBOL_CHECKED)
@@ -816,13 +818,8 @@ struct symbol *sym_check_deps(struct symbol *sym)
 			goto out;
 	}
 out:
-	if (sym2) {
-		printf(" %s", sym->name);
-		if (sym2 == sym) {
-			printf("\n");
-			sym2 = NULL;
-		}
-	}
+	if (sym2)
+		fprintf(stderr, " -> %s%s", sym->name, sym2 == sym? "\n": "");
 	sym->flags &= ~SYMBOL_CHECK;
 	return sym2;
 }

commit bfc10001b11e51b59ac901d17c5f05361bd2351d
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Dec 13 00:34:07 2006 -0800

    [PATCH] kconfig: make sym_change_count static, let it be altered by 2 functions only
    
    Those two functions are
            void sym_set_change_count(int count)
    and
            void sym_add_change_count(int count)
    
    All write accesses to sym_change_count are replaced by calls to above
    functions.
    
    Variable and changer-functions are moved to confdata.c.  IMO thats ok, as
    sym_change_count is an attribute of the .config's change state.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index ee225ced2ce4..8f06c474d800 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -30,7 +30,6 @@ struct symbol symbol_yes = {
 	.flags = SYMBOL_VALID,
 };
 
-int sym_change_count;
 struct symbol *sym_defconfig_list;
 struct symbol *modules_sym;
 tristate modules_val;
@@ -379,7 +378,7 @@ void sym_clear_all_valid(void)
 
 	for_all_symbols(i, sym)
 		sym->flags &= ~SYMBOL_VALID;
-	sym_change_count++;
+	sym_add_change_count(1);
 	if (modules_sym)
 		sym_calc_value(modules_sym);
 }

commit face4374e288372fba67c865eb0c92337f50d5a4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:45 2006 -0700

    kconfig: add defconfig_list/module option
    
    This makes it possible to change two options which were hardcoded sofar.
    1. Any symbol can now take the role of CONFIG_MODULES
    2. The more useful option is to change the list of default file names,
       which kconfig uses to load the base configuration if .config isn't
       available.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 78a60ba39e54..ee225ced2ce4 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -31,6 +31,7 @@ struct symbol symbol_yes = {
 };
 
 int sym_change_count;
+struct symbol *sym_defconfig_list;
 struct symbol *modules_sym;
 tristate modules_val;
 
@@ -352,10 +353,13 @@ void sym_calc_value(struct symbol *sym)
 		sym->curr.val = sym_calc_choice(sym);
 	sym_validate_range(sym);
 
-	if (memcmp(&oldval, &sym->curr, sizeof(oldval)))
+	if (memcmp(&oldval, &sym->curr, sizeof(oldval))) {
 		sym_set_changed(sym);
-	if (modules_sym == sym)
-		modules_val = modules_sym->curr.tri;
+		if (modules_sym == sym) {
+			sym_set_all_changed();
+			modules_val = modules_sym->curr.tri;
+		}
+	}
 
 	if (sym_is_choice(sym)) {
 		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
@@ -449,11 +453,8 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 	}
 
 	sym->def[S_DEF_USER].tri = val;
-	if (oldval != val) {
+	if (oldval != val)
 		sym_clear_all_valid();
-		if (sym == modules_sym)
-			sym_set_all_changed();
-	}
 
 	return true;
 }

commit 669bfad906522e74ee8d962801552a8c224c0d63
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:42 2006 -0700

    kconfig: allow loading multiple configurations
    
    Extend conf_read_simple() so it can load multiple configurations.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 4ea0050dcb16..78a60ba39e54 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -426,8 +426,8 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 	if (oldval != val && !sym_tristate_within_range(sym, val))
 		return false;
 
-	if (sym->flags & SYMBOL_NEW) {
-		sym->flags &= ~SYMBOL_NEW;
+	if (!(sym->flags & SYMBOL_DEF_USER)) {
+		sym->flags |= SYMBOL_DEF_USER;
 		sym_set_changed(sym);
 	}
 	/*
@@ -440,11 +440,11 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 		struct expr *e;
 
 		cs->def[S_DEF_USER].val = sym;
-		cs->flags &= ~SYMBOL_NEW;
+		cs->flags |= SYMBOL_DEF_USER;
 		prop = sym_get_choice_prop(cs);
 		for (e = prop->expr; e; e = e->left.expr) {
 			if (e->right.sym->visible != no)
-				e->right.sym->flags &= ~SYMBOL_NEW;
+				e->right.sym->flags |= SYMBOL_DEF_USER;
 		}
 	}
 
@@ -591,8 +591,8 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 	if (!sym_string_within_range(sym, newval))
 		return false;
 
-	if (sym->flags & SYMBOL_NEW) {
-		sym->flags &= ~SYMBOL_NEW;
+	if (!(sym->flags & SYMBOL_DEF_USER)) {
+		sym->flags |= SYMBOL_DEF_USER;
 		sym_set_changed(sym);
 	}
 
@@ -679,7 +679,6 @@ struct symbol *sym_lookup(const char *name, int isconst)
 	memset(symbol, 0, sizeof(*symbol));
 	symbol->name = new_name;
 	symbol->type = S_UNKNOWN;
-	symbol->flags = SYMBOL_NEW;
 	if (isconst)
 		symbol->flags |= SYMBOL_CONST;
 

commit 0c1822e6991a10da6dc391f0a2e2cf5fb2e31238
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:41 2006 -0700

    kconfig: allow multiple default values per symbol
    
    Extend struct symbol to allow storing multiple default values, which can be
    used to hold multiple configurations.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index a0a467a4387b..4ea0050dcb16 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -227,7 +227,7 @@ static struct symbol *sym_calc_choice(struct symbol *sym)
 	struct expr *e;
 
 	/* is the user choice visible? */
-	def_sym = sym->user.val;
+	def_sym = sym->def[S_DEF_USER].val;
 	if (def_sym) {
 		sym_calc_visibility(def_sym);
 		if (def_sym->visible != no)
@@ -306,7 +306,7 @@ void sym_calc_value(struct symbol *sym)
 		} else if (E_OR(sym->visible, sym->rev_dep.tri) != no) {
 			sym->flags |= SYMBOL_WRITE;
 			if (sym_has_value(sym))
-				newval.tri = sym->user.tri;
+				newval.tri = sym->def[S_DEF_USER].tri;
 			else if (!sym_is_choice(sym)) {
 				prop = sym_get_default_prop(sym);
 				if (prop)
@@ -329,7 +329,7 @@ void sym_calc_value(struct symbol *sym)
 		if (sym->visible != no) {
 			sym->flags |= SYMBOL_WRITE;
 			if (sym_has_value(sym)) {
-				newval.val = sym->user.val;
+				newval.val = sym->def[S_DEF_USER].val;
 				break;
 			}
 		}
@@ -439,7 +439,7 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 		struct property *prop;
 		struct expr *e;
 
-		cs->user.val = sym;
+		cs->def[S_DEF_USER].val = sym;
 		cs->flags &= ~SYMBOL_NEW;
 		prop = sym_get_choice_prop(cs);
 		for (e = prop->expr; e; e = e->left.expr) {
@@ -448,7 +448,7 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 		}
 	}
 
-	sym->user.tri = val;
+	sym->def[S_DEF_USER].tri = val;
 	if (oldval != val) {
 		sym_clear_all_valid();
 		if (sym == modules_sym)
@@ -596,15 +596,15 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 		sym_set_changed(sym);
 	}
 
-	oldval = sym->user.val;
+	oldval = sym->def[S_DEF_USER].val;
 	size = strlen(newval) + 1;
 	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
 		size += 2;
-		sym->user.val = val = malloc(size);
+		sym->def[S_DEF_USER].val = val = malloc(size);
 		*val++ = '0';
 		*val++ = 'x';
 	} else if (!oldval || strcmp(oldval, newval))
-		sym->user.val = val = malloc(size);
+		sym->def[S_DEF_USER].val = val = malloc(size);
 	else
 		return true;
 

commit c0e150acde52e4661675539bf5323309270f2e83
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:40 2006 -0700

    kconfig: remove SYMBOL_{YES,MOD,NO}
    
    The SYMBOL_{YES,MOD,NO} are not really used anymore (they were more used be
    the cml1 converter), so just remove them.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 3d7877afccd5..a0a467a4387b 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -15,15 +15,15 @@
 struct symbol symbol_yes = {
 	.name = "y",
 	.curr = { "y", yes },
-	.flags = SYMBOL_YES|SYMBOL_VALID,
+	.flags = SYMBOL_CONST|SYMBOL_VALID,
 }, symbol_mod = {
 	.name = "m",
 	.curr = { "m", mod },
-	.flags = SYMBOL_MOD|SYMBOL_VALID,
+	.flags = SYMBOL_CONST|SYMBOL_VALID,
 }, symbol_no = {
 	.name = "n",
 	.curr = { "n", no },
-	.flags = SYMBOL_NO|SYMBOL_VALID,
+	.flags = SYMBOL_CONST|SYMBOL_VALID,
 }, symbol_empty = {
 	.name = "",
 	.curr = { "", no },

commit 2244cbd8a9185c197ec5ba5de175aec288697223
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Mon Jan 16 12:12:12 2006 +0100

    kbuild: create .kernelrelease at *config step
    
    To enable 'make kernelrelease' earlier now create .kernelrelease when
    one of the *config targets are used.
    Also introduce KERNELVERSION - only user is kconfig.
    KERNELVERSION was needed to display kernel version in menuconfig -
    KERNELRELEASE is not valid until configuration has completed.
    kconfig files modified to use KERNELVERSION.
    Bug reported by: Rene Rebe <rene@exactcode.de>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 69c2549c0baa..3d7877afccd5 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -61,10 +61,10 @@ void sym_init(void)
 	if (p)
 		sym_add_default(sym, p);
 
-	sym = sym_lookup("KERNELRELEASE", 0);
+	sym = sym_lookup("KERNELVERSION", 0);
 	sym->type = S_STRING;
 	sym->flags |= SYMBOL_AUTO;
-	p = getenv("KERNELRELEASE");
+	p = getenv("KERNELVERSION");
 	if (p)
 		sym_add_default(sym, p);
 

commit 4cf3cbe2a9682242cd38897914b1f2a95f1db7e4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:49 2005 -0800

    [PATCH] kconfig: allow variable argumnts for range
    
    This allows variable arguments in the range option for int and hex config
    symbols.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 29bff43adc5e..69c2549c0baa 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -141,6 +141,55 @@ struct property *sym_get_range_prop(struct symbol *sym)
 	return NULL;
 }
 
+static int sym_get_range_val(struct symbol *sym, int base)
+{
+	sym_calc_value(sym);
+	switch (sym->type) {
+	case S_INT:
+		base = 10;
+		break;
+	case S_HEX:
+		base = 16;
+		break;
+	default:
+		break;
+	}
+	return strtol(sym->curr.val, NULL, base);
+}
+
+static void sym_validate_range(struct symbol *sym)
+{
+	struct property *prop;
+	int base, val, val2;
+	char str[64];
+
+	switch (sym->type) {
+	case S_INT:
+		base = 10;
+		break;
+	case S_HEX:
+		base = 16;
+		break;
+	default:
+		return;
+	}
+	prop = sym_get_range_prop(sym);
+	if (!prop)
+		return;
+	val = strtol(sym->curr.val, NULL, base);
+	val2 = sym_get_range_val(prop->expr->left.sym, base);
+	if (val >= val2) {
+		val2 = sym_get_range_val(prop->expr->right.sym, base);
+		if (val <= val2)
+			return;
+	}
+	if (sym->type == S_INT)
+		sprintf(str, "%d", val2);
+	else
+		sprintf(str, "0x%x", val2);
+	sym->curr.val = strdup(str);
+}
+
 static void sym_calc_visibility(struct symbol *sym)
 {
 	struct property *prop;
@@ -301,6 +350,7 @@ void sym_calc_value(struct symbol *sym)
 	sym->curr = newval;
 	if (sym_is_choice(sym) && newval.tri == yes)
 		sym->curr.val = sym_calc_choice(sym);
+	sym_validate_range(sym);
 
 	if (memcmp(&oldval, &sym->curr, sizeof(oldval)))
 		sym_set_changed(sym);
@@ -489,8 +539,8 @@ bool sym_string_within_range(struct symbol *sym, const char *str)
 		if (!prop)
 			return true;
 		val = strtol(str, NULL, 10);
-		return val >= strtol(prop->expr->left.sym->name, NULL, 10) &&
-		       val <= strtol(prop->expr->right.sym->name, NULL, 10);
+		return val >= sym_get_range_val(prop->expr->left.sym, 10) &&
+		       val <= sym_get_range_val(prop->expr->right.sym, 10);
 	case S_HEX:
 		if (!sym_string_valid(sym, str))
 			return false;
@@ -498,8 +548,8 @@ bool sym_string_within_range(struct symbol *sym, const char *str)
 		if (!prop)
 			return true;
 		val = strtol(str, NULL, 16);
-		return val >= strtol(prop->expr->left.sym->name, NULL, 16) &&
-		       val <= strtol(prop->expr->right.sym->name, NULL, 16);
+		return val >= sym_get_range_val(prop->expr->left.sym, 16) &&
+		       val <= sym_get_range_val(prop->expr->right.sym, 16);
 	case S_BOOLEAN:
 	case S_TRISTATE:
 		switch (str[0]) {

commit 3f23ca2b37d13a89bb6cd0421821fc9c3b8ccd47
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:48 2005 -0800

    [PATCH] kconfig: fix restart for choice symbols
    
    The restart check whether new symbols became visible, didn't always work for
    choice symbols.  Even if a choice symbol itself isn't changable, the childs
    are.  This also requires to update the new status of all choice values, once
    one of them is set.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 10d96c4188dd..29bff43adc5e 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -380,11 +380,22 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 		sym->flags &= ~SYMBOL_NEW;
 		sym_set_changed(sym);
 	}
+	/*
+	 * setting a choice value also resets the new flag of the choice
+	 * symbol and all other choice values.
+	 */
 	if (sym_is_choice_value(sym) && val == yes) {
 		struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
+		struct property *prop;
+		struct expr *e;
 
 		cs->user.val = sym;
 		cs->flags &= ~SYMBOL_NEW;
+		prop = sym_get_choice_prop(cs);
+		for (e = prop->expr; e; e = e->left.expr) {
+			if (e->right.sym->visible != no)
+				e->right.sym->flags &= ~SYMBOL_NEW;
+		}
 	}
 
 	sym->user.tri = val;

commit 3f04e7ddf47a1c821dfaa886161d94774af583fa
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Tue Nov 8 21:34:46 2005 -0800

    [PATCH] kconfig: Fix Kconfig performance bug
    
    When doing its recursive dependency check, scripts/kconfig/conf uses the flag
    SYMBOL_CHECK_DONE to avoid rechecking a symbol it has already checked.
    However, that flag is only set at the top level, so if a symbol is first
    encountered as a dependency of another symbol it will be rechecked every time
    it is encountered until it's encountered at the top level.
    
    This patch adjusts the flag setting so that each symbol will only be checked
    once, regardless of whether it is first encountered at the top level, or while
    recursing down from another symbol.  On complex configurations, this vastly
    speeds up scripts/kconfig/conf.  The config in the powerpc merge tree is
    particularly bad: this patch reduces the time for 'scripts/kconfig/conf -o
    arch/powerpc/Kconfig' by a factor of 40 on a G5.  That's even including the
    time to print the config, so the speedup in the actual checking is more likely
    2 or 3 orders of magnitude.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index affa52f5c651..10d96c4188dd 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -731,12 +731,12 @@ struct symbol *sym_check_deps(struct symbol *sym)
 	struct symbol *sym2;
 	struct property *prop;
 
-	if (sym->flags & SYMBOL_CHECK_DONE)
-		return NULL;
 	if (sym->flags & SYMBOL_CHECK) {
 		printf("Warning! Found recursive dependency: %s", sym->name);
 		return sym;
 	}
+	if (sym->flags & SYMBOL_CHECKED)
+		return NULL;
 
 	sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
 	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
@@ -756,8 +756,13 @@ struct symbol *sym_check_deps(struct symbol *sym)
 			goto out;
 	}
 out:
-	if (sym2)
+	if (sym2) {
 		printf(" %s", sym->name);
+		if (sym2 == sym) {
+			printf("\n");
+			sym2 = NULL;
+		}
+	}
 	sym->flags &= ~SYMBOL_CHECK;
 	return sym2;
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
new file mode 100644
index 000000000000..affa52f5c651
--- /dev/null
+++ b/scripts/kconfig/symbol.c
@@ -0,0 +1,816 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <regex.h>
+#include <sys/utsname.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct symbol symbol_yes = {
+	.name = "y",
+	.curr = { "y", yes },
+	.flags = SYMBOL_YES|SYMBOL_VALID,
+}, symbol_mod = {
+	.name = "m",
+	.curr = { "m", mod },
+	.flags = SYMBOL_MOD|SYMBOL_VALID,
+}, symbol_no = {
+	.name = "n",
+	.curr = { "n", no },
+	.flags = SYMBOL_NO|SYMBOL_VALID,
+}, symbol_empty = {
+	.name = "",
+	.curr = { "", no },
+	.flags = SYMBOL_VALID,
+};
+
+int sym_change_count;
+struct symbol *modules_sym;
+tristate modules_val;
+
+void sym_add_default(struct symbol *sym, const char *def)
+{
+	struct property *prop = prop_alloc(P_DEFAULT, sym);
+
+	prop->expr = expr_alloc_symbol(sym_lookup(def, 1));
+}
+
+void sym_init(void)
+{
+	struct symbol *sym;
+	struct utsname uts;
+	char *p;
+	static bool inited = false;
+
+	if (inited)
+		return;
+	inited = true;
+
+	uname(&uts);
+
+	sym = sym_lookup("ARCH", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("ARCH");
+	if (p)
+		sym_add_default(sym, p);
+
+	sym = sym_lookup("KERNELRELEASE", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("KERNELRELEASE");
+	if (p)
+		sym_add_default(sym, p);
+
+	sym = sym_lookup("UNAME_RELEASE", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	sym_add_default(sym, uts.release);
+}
+
+enum symbol_type sym_get_type(struct symbol *sym)
+{
+	enum symbol_type type = sym->type;
+
+	if (type == S_TRISTATE) {
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			type = S_BOOLEAN;
+		else if (modules_val == no)
+			type = S_BOOLEAN;
+	}
+	return type;
+}
+
+const char *sym_type_name(enum symbol_type type)
+{
+	switch (type) {
+	case S_BOOLEAN:
+		return "boolean";
+	case S_TRISTATE:
+		return "tristate";
+	case S_INT:
+		return "integer";
+	case S_HEX:
+		return "hex";
+	case S_STRING:
+		return "string";
+	case S_UNKNOWN:
+		return "unknown";
+	case S_OTHER:
+		break;
+	}
+	return "???";
+}
+
+struct property *sym_get_choice_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_choices(sym, prop)
+		return prop;
+	return NULL;
+}
+
+struct property *sym_get_default_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_defaults(sym, prop) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri != no)
+			return prop;
+	}
+	return NULL;
+}
+
+struct property *sym_get_range_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_properties(sym, prop, P_RANGE) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri != no)
+			return prop;
+	}
+	return NULL;
+}
+
+static void sym_calc_visibility(struct symbol *sym)
+{
+	struct property *prop;
+	tristate tri;
+
+	/* any prompt visible? */
+	tri = no;
+	for_all_prompts(sym, prop) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		tri = E_OR(tri, prop->visible.tri);
+	}
+	if (tri == mod && (sym->type != S_TRISTATE || modules_val == no))
+		tri = yes;
+	if (sym->visible != tri) {
+		sym->visible = tri;
+		sym_set_changed(sym);
+	}
+	if (sym_is_choice_value(sym))
+		return;
+	tri = no;
+	if (sym->rev_dep.expr)
+		tri = expr_calc_value(sym->rev_dep.expr);
+	if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
+		tri = yes;
+	if (sym->rev_dep.tri != tri) {
+		sym->rev_dep.tri = tri;
+		sym_set_changed(sym);
+	}
+}
+
+static struct symbol *sym_calc_choice(struct symbol *sym)
+{
+	struct symbol *def_sym;
+	struct property *prop;
+	struct expr *e;
+
+	/* is the user choice visible? */
+	def_sym = sym->user.val;
+	if (def_sym) {
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
+	}
+
+	/* any of the defaults visible? */
+	for_all_defaults(sym, prop) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri == no)
+			continue;
+		def_sym = prop_get_symbol(prop);
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
+	}
+
+	/* just get the first visible value */
+	prop = sym_get_choice_prop(sym);
+	for (e = prop->expr; e; e = e->left.expr) {
+		def_sym = e->right.sym;
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
+	}
+
+	/* no choice? reset tristate value */
+	sym->curr.tri = no;
+	return NULL;
+}
+
+void sym_calc_value(struct symbol *sym)
+{
+	struct symbol_value newval, oldval;
+	struct property *prop;
+	struct expr *e;
+
+	if (!sym)
+		return;
+
+	if (sym->flags & SYMBOL_VALID)
+		return;
+	sym->flags |= SYMBOL_VALID;
+
+	oldval = sym->curr;
+
+	switch (sym->type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		newval = symbol_empty.curr;
+		break;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		newval = symbol_no.curr;
+		break;
+	default:
+		sym->curr.val = sym->name;
+		sym->curr.tri = no;
+		return;
+	}
+	if (!sym_is_choice_value(sym))
+		sym->flags &= ~SYMBOL_WRITE;
+
+	sym_calc_visibility(sym);
+
+	/* set default if recursively called */
+	sym->curr = newval;
+
+	switch (sym_get_type(sym)) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		if (sym_is_choice_value(sym) && sym->visible == yes) {
+			prop = sym_get_choice_prop(sym);
+			newval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;
+		} else if (E_OR(sym->visible, sym->rev_dep.tri) != no) {
+			sym->flags |= SYMBOL_WRITE;
+			if (sym_has_value(sym))
+				newval.tri = sym->user.tri;
+			else if (!sym_is_choice(sym)) {
+				prop = sym_get_default_prop(sym);
+				if (prop)
+					newval.tri = expr_calc_value(prop->expr);
+			}
+			newval.tri = E_OR(E_AND(newval.tri, sym->visible), sym->rev_dep.tri);
+		} else if (!sym_is_choice(sym)) {
+			prop = sym_get_default_prop(sym);
+			if (prop) {
+				sym->flags |= SYMBOL_WRITE;
+				newval.tri = expr_calc_value(prop->expr);
+			}
+		}
+		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)
+			newval.tri = yes;
+		break;
+	case S_STRING:
+	case S_HEX:
+	case S_INT:
+		if (sym->visible != no) {
+			sym->flags |= SYMBOL_WRITE;
+			if (sym_has_value(sym)) {
+				newval.val = sym->user.val;
+				break;
+			}
+		}
+		prop = sym_get_default_prop(sym);
+		if (prop) {
+			struct symbol *ds = prop_get_symbol(prop);
+			if (ds) {
+				sym->flags |= SYMBOL_WRITE;
+				sym_calc_value(ds);
+				newval.val = ds->curr.val;
+			}
+		}
+		break;
+	default:
+		;
+	}
+
+	sym->curr = newval;
+	if (sym_is_choice(sym) && newval.tri == yes)
+		sym->curr.val = sym_calc_choice(sym);
+
+	if (memcmp(&oldval, &sym->curr, sizeof(oldval)))
+		sym_set_changed(sym);
+	if (modules_sym == sym)
+		modules_val = modules_sym->curr.tri;
+
+	if (sym_is_choice(sym)) {
+		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->expr; e; e = e->left.expr) {
+			e->right.sym->flags |= flags;
+			if (flags & SYMBOL_CHANGED)
+				sym_set_changed(e->right.sym);
+		}
+	}
+}
+
+void sym_clear_all_valid(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym->flags &= ~SYMBOL_VALID;
+	sym_change_count++;
+	if (modules_sym)
+		sym_calc_value(modules_sym);
+}
+
+void sym_set_changed(struct symbol *sym)
+{
+	struct property *prop;
+
+	sym->flags |= SYMBOL_CHANGED;
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu)
+			prop->menu->flags |= MENU_CHANGED;
+	}
+}
+
+void sym_set_all_changed(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym_set_changed(sym);
+}
+
+bool sym_tristate_within_range(struct symbol *sym, tristate val)
+{
+	int type = sym_get_type(sym);
+
+	if (sym->visible == no)
+		return false;
+
+	if (type != S_BOOLEAN && type != S_TRISTATE)
+		return false;
+
+	if (type == S_BOOLEAN && val == mod)
+		return false;
+	if (sym->visible <= sym->rev_dep.tri)
+		return false;
+	if (sym_is_choice_value(sym) && sym->visible == yes)
+		return val == yes;
+	return val >= sym->rev_dep.tri && val <= sym->visible;
+}
+
+bool sym_set_tristate_value(struct symbol *sym, tristate val)
+{
+	tristate oldval = sym_get_tristate_value(sym);
+
+	if (oldval != val && !sym_tristate_within_range(sym, val))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym_set_changed(sym);
+	}
+	if (sym_is_choice_value(sym) && val == yes) {
+		struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
+
+		cs->user.val = sym;
+		cs->flags &= ~SYMBOL_NEW;
+	}
+
+	sym->user.tri = val;
+	if (oldval != val) {
+		sym_clear_all_valid();
+		if (sym == modules_sym)
+			sym_set_all_changed();
+	}
+
+	return true;
+}
+
+tristate sym_toggle_tristate_value(struct symbol *sym)
+{
+	tristate oldval, newval;
+
+	oldval = newval = sym_get_tristate_value(sym);
+	do {
+		switch (newval) {
+		case no:
+			newval = mod;
+			break;
+		case mod:
+			newval = yes;
+			break;
+		case yes:
+			newval = no;
+			break;
+		}
+		if (sym_set_tristate_value(sym, newval))
+			break;
+	} while (oldval != newval);
+	return newval;
+}
+
+bool sym_string_valid(struct symbol *sym, const char *str)
+{
+	signed char ch;
+
+	switch (sym->type) {
+	case S_STRING:
+		return true;
+	case S_INT:
+		ch = *str++;
+		if (ch == '-')
+			ch = *str++;
+		if (!isdigit(ch))
+			return false;
+		if (ch == '0' && *str != 0)
+			return false;
+		while ((ch = *str++)) {
+			if (!isdigit(ch))
+				return false;
+		}
+		return true;
+	case S_HEX:
+		if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
+			str += 2;
+		ch = *str++;
+		do {
+			if (!isxdigit(ch))
+				return false;
+		} while ((ch = *str++));
+		return true;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (str[0]) {
+		case 'y': case 'Y':
+		case 'm': case 'M':
+		case 'n': case 'N':
+			return true;
+		}
+		return false;
+	default:
+		return false;
+	}
+}
+
+bool sym_string_within_range(struct symbol *sym, const char *str)
+{
+	struct property *prop;
+	int val;
+
+	switch (sym->type) {
+	case S_STRING:
+		return sym_string_valid(sym, str);
+	case S_INT:
+		if (!sym_string_valid(sym, str))
+			return false;
+		prop = sym_get_range_prop(sym);
+		if (!prop)
+			return true;
+		val = strtol(str, NULL, 10);
+		return val >= strtol(prop->expr->left.sym->name, NULL, 10) &&
+		       val <= strtol(prop->expr->right.sym->name, NULL, 10);
+	case S_HEX:
+		if (!sym_string_valid(sym, str))
+			return false;
+		prop = sym_get_range_prop(sym);
+		if (!prop)
+			return true;
+		val = strtol(str, NULL, 16);
+		return val >= strtol(prop->expr->left.sym->name, NULL, 16) &&
+		       val <= strtol(prop->expr->right.sym->name, NULL, 16);
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (str[0]) {
+		case 'y': case 'Y':
+			return sym_tristate_within_range(sym, yes);
+		case 'm': case 'M':
+			return sym_tristate_within_range(sym, mod);
+		case 'n': case 'N':
+			return sym_tristate_within_range(sym, no);
+		}
+		return false;
+	default:
+		return false;
+	}
+}
+
+bool sym_set_string_value(struct symbol *sym, const char *newval)
+{
+	const char *oldval;
+	char *val;
+	int size;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (newval[0]) {
+		case 'y': case 'Y':
+			return sym_set_tristate_value(sym, yes);
+		case 'm': case 'M':
+			return sym_set_tristate_value(sym, mod);
+		case 'n': case 'N':
+			return sym_set_tristate_value(sym, no);
+		}
+		return false;
+	default:
+		;
+	}
+
+	if (!sym_string_within_range(sym, newval))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym_set_changed(sym);
+	}
+
+	oldval = sym->user.val;
+	size = strlen(newval) + 1;
+	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
+		size += 2;
+		sym->user.val = val = malloc(size);
+		*val++ = '0';
+		*val++ = 'x';
+	} else if (!oldval || strcmp(oldval, newval))
+		sym->user.val = val = malloc(size);
+	else
+		return true;
+
+	strcpy(val, newval);
+	free((void *)oldval);
+	sym_clear_all_valid();
+
+	return true;
+}
+
+const char *sym_get_string_value(struct symbol *sym)
+{
+	tristate val;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		val = sym_get_tristate_value(sym);
+		switch (val) {
+		case no:
+			return "n";
+		case mod:
+			return "m";
+		case yes:
+			return "y";
+		}
+		break;
+	default:
+		;
+	}
+	return (const char *)sym->curr.val;
+}
+
+bool sym_is_changable(struct symbol *sym)
+{
+	return sym->visible > sym->rev_dep.tri;
+}
+
+struct symbol *sym_lookup(const char *name, int isconst)
+{
+	struct symbol *symbol;
+	const char *ptr;
+	char *new_name;
+	int hash = 0;
+
+	if (name) {
+		if (name[0] && !name[1]) {
+			switch (name[0]) {
+			case 'y': return &symbol_yes;
+			case 'm': return &symbol_mod;
+			case 'n': return &symbol_no;
+			}
+		}
+		for (ptr = name; *ptr; ptr++)
+			hash += *ptr;
+		hash &= 0xff;
+
+		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+			if (!strcmp(symbol->name, name)) {
+				if ((isconst && symbol->flags & SYMBOL_CONST) ||
+				    (!isconst && !(symbol->flags & SYMBOL_CONST)))
+					return symbol;
+			}
+		}
+		new_name = strdup(name);
+	} else {
+		new_name = NULL;
+		hash = 256;
+	}
+
+	symbol = malloc(sizeof(*symbol));
+	memset(symbol, 0, sizeof(*symbol));
+	symbol->name = new_name;
+	symbol->type = S_UNKNOWN;
+	symbol->flags = SYMBOL_NEW;
+	if (isconst)
+		symbol->flags |= SYMBOL_CONST;
+
+	symbol->next = symbol_hash[hash];
+	symbol_hash[hash] = symbol;
+
+	return symbol;
+}
+
+struct symbol *sym_find(const char *name)
+{
+	struct symbol *symbol = NULL;
+	const char *ptr;
+	int hash = 0;
+
+	if (!name)
+		return NULL;
+
+	if (name[0] && !name[1]) {
+		switch (name[0]) {
+		case 'y': return &symbol_yes;
+		case 'm': return &symbol_mod;
+		case 'n': return &symbol_no;
+		}
+	}
+	for (ptr = name; *ptr; ptr++)
+		hash += *ptr;
+	hash &= 0xff;
+
+	for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+		if (!strcmp(symbol->name, name) &&
+		    !(symbol->flags & SYMBOL_CONST))
+				break;
+	}
+
+	return symbol;
+}
+
+struct symbol **sym_re_search(const char *pattern)
+{
+	struct symbol *sym, **sym_arr = NULL;
+	int i, cnt, size;
+	regex_t re;
+
+	cnt = size = 0;
+	/* Skip if empty */
+	if (strlen(pattern) == 0)
+		return NULL;
+	if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB|REG_ICASE))
+		return NULL;
+
+	for_all_symbols(i, sym) {
+		if (sym->flags & SYMBOL_CONST || !sym->name)
+			continue;
+		if (regexec(&re, sym->name, 0, NULL, 0))
+			continue;
+		if (cnt + 1 >= size) {
+			void *tmp = sym_arr;
+			size += 16;
+			sym_arr = realloc(sym_arr, size * sizeof(struct symbol *));
+			if (!sym_arr) {
+				free(tmp);
+				return NULL;
+			}
+		}
+		sym_arr[cnt++] = sym;
+	}
+	if (sym_arr)
+		sym_arr[cnt] = NULL;
+	regfree(&re);
+
+	return sym_arr;
+}
+
+
+struct symbol *sym_check_deps(struct symbol *sym);
+
+static struct symbol *sym_check_expr_deps(struct expr *e)
+{
+	struct symbol *sym;
+
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_OR:
+	case E_AND:
+		sym = sym_check_expr_deps(e->left.expr);
+		if (sym)
+			return sym;
+		return sym_check_expr_deps(e->right.expr);
+	case E_NOT:
+		return sym_check_expr_deps(e->left.expr);
+	case E_EQUAL:
+	case E_UNEQUAL:
+		sym = sym_check_deps(e->left.sym);
+		if (sym)
+			return sym;
+		return sym_check_deps(e->right.sym);
+	case E_SYMBOL:
+		return sym_check_deps(e->left.sym);
+	default:
+		break;
+	}
+	printf("Oops! How to check %d?\n", e->type);
+	return NULL;
+}
+
+struct symbol *sym_check_deps(struct symbol *sym)
+{
+	struct symbol *sym2;
+	struct property *prop;
+
+	if (sym->flags & SYMBOL_CHECK_DONE)
+		return NULL;
+	if (sym->flags & SYMBOL_CHECK) {
+		printf("Warning! Found recursive dependency: %s", sym->name);
+		return sym;
+	}
+
+	sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
+	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
+	if (sym2)
+		goto out;
+
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->type == P_CHOICE || prop->type == P_SELECT)
+			continue;
+		sym2 = sym_check_expr_deps(prop->visible.expr);
+		if (sym2)
+			goto out;
+		if (prop->type != P_DEFAULT || sym_is_choice(sym))
+			continue;
+		sym2 = sym_check_expr_deps(prop->expr);
+		if (sym2)
+			goto out;
+	}
+out:
+	if (sym2)
+		printf(" %s", sym->name);
+	sym->flags &= ~SYMBOL_CHECK;
+	return sym2;
+}
+
+struct property *prop_alloc(enum prop_type type, struct symbol *sym)
+{
+	struct property *prop;
+	struct property **propp;
+
+	prop = malloc(sizeof(*prop));
+	memset(prop, 0, sizeof(*prop));
+	prop->type = type;
+	prop->sym = sym;
+	prop->file = current_file;
+	prop->lineno = zconf_lineno();
+
+	/* append property to the prop list of symbol */
+	if (sym) {
+		for (propp = &sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+
+	return prop;
+}
+
+struct symbol *prop_get_symbol(struct property *prop)
+{
+	if (prop->expr && (prop->expr->type == E_SYMBOL ||
+			   prop->expr->type == E_CHOICE))
+		return prop->expr->left.sym;
+	return NULL;
+}
+
+const char *prop_get_type_name(enum prop_type type)
+{
+	switch (type) {
+	case P_PROMPT:
+		return "prompt";
+	case P_COMMENT:
+		return "comment";
+	case P_MENU:
+		return "menu";
+	case P_DEFAULT:
+		return "default";
+	case P_CHOICE:
+		return "choice";
+	case P_SELECT:
+		return "select";
+	case P_RANGE:
+		return "range";
+	case P_UNKNOWN:
+		break;
+	}
+	return "unknown";
+}
