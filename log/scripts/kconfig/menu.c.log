commit 644a4b6cecc2ae3a8a840bb3606edd99af94e972
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Apr 14 00:35:42 2020 +0900

    kconfig: do not assign a variable in the return statement
    
    I am not a big fan of doing assignment in a return statement.
    Split it into two lines.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index e436ba44c9c5..a5fbd6ccc006 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -65,7 +65,8 @@ void menu_add_entry(struct symbol *sym)
 struct menu *menu_add_menu(void)
 {
 	last_entry_ptr = &current_entry->list;
-	return current_menu = current_entry;
+	current_menu = current_entry;
+	return current_menu;
 }
 
 void menu_end_menu(void)

commit a9609686042b887baa636c77646b7614074c180a
Author: Thomas Hebb <tommyhebb@gmail.com>
Date:   Tue Dec 17 08:15:45 2019 -0800

    kconfig: fix nesting of symbol help text
    
    When we generate the help text of a symbol (e.g. when a user presses '?'
    in menuconfig), we do two things:
    
     1. We iterate through every prompt that belongs to that symbol,
        printing its text and its location in the menu tree.
     2. We print symbol-wide information that's not linked to a particular
        prompt, such as what it selects/is selected by and what it
        implies/is implied by.
    
    Each prompt we print for 1 starts with a line that's not indented
    indicating where the prompt is defined, then continues with indented
    lines that describe properties of that particular definition.
    
    Once we get to 2, however, we print all the global data indented as
    well! Visually, this makes it look like the symbol-wide data is
    associated with the last prompt we happened to print rather than
    the symbol as a whole.
    
    Fix this by removing the indentation for symbol-wide information.
    
    Before:
    
      Symbol: CPU_FREQ [=n]
      Type  : bool
      Defined at drivers/cpufreq/Kconfig:4
        Prompt: CPU Frequency scaling
        Location:
          -> CPU Power Management
            -> CPU Frequency scaling
        Selects: SRCU [=n]
        Selected by [n]:
        - ARCH_SA1100 [=n] && <choice>
    
    After:
    
      Symbol: CPU_FREQ [=n]
      Type  : bool
      Defined at drivers/cpufreq/Kconfig:4
        Prompt: CPU Frequency scaling
        Location:
          -> CPU Power Management
            -> CPU Frequency scaling
      Selects: SRCU [=n]
      Selected by [n]:
        - ARCH_SA1100 [=n] && <choice>
    
    Signed-off-by: Thomas Hebb <tommyhebb@gmail.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index da50f79a8e8d..e436ba44c9c5 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -851,18 +851,18 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 		}
 	}
 
-	get_symbol_props_str(r, sym, P_SELECT, "  Selects: ");
+	get_symbol_props_str(r, sym, P_SELECT, "Selects: ");
 	if (sym->rev_dep.expr) {
-		expr_gstr_print_revdep(sym->rev_dep.expr, r, yes, "  Selected by [y]:\n");
-		expr_gstr_print_revdep(sym->rev_dep.expr, r, mod, "  Selected by [m]:\n");
-		expr_gstr_print_revdep(sym->rev_dep.expr, r, no, "  Selected by [n]:\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, yes, "Selected by [y]:\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, mod, "Selected by [m]:\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, no, "Selected by [n]:\n");
 	}
 
-	get_symbol_props_str(r, sym, P_IMPLY, "  Implies: ");
+	get_symbol_props_str(r, sym, P_IMPLY, "Implies: ");
 	if (sym->implied.expr) {
-		expr_gstr_print_revdep(sym->implied.expr, r, yes, "  Implied by [y]:\n");
-		expr_gstr_print_revdep(sym->implied.expr, r, mod, "  Implied by [m]:\n");
-		expr_gstr_print_revdep(sym->implied.expr, r, no, "  Implied by [n]:\n");
+		expr_gstr_print_revdep(sym->implied.expr, r, yes, "Implied by [y]:\n");
+		expr_gstr_print_revdep(sym->implied.expr, r, mod, "Implied by [m]:\n");
+		expr_gstr_print_revdep(sym->implied.expr, r, no, "Implied by [n]:\n");
 	}
 
 	str_append(r, "\n\n");

commit 3460d0bc256a50b71dbdae8227c600761c502022
Author: Thomas Hebb <tommyhebb@gmail.com>
Date:   Tue Dec 17 08:15:44 2019 -0800

    kconfig: distinguish between dependencies and visibility in help text
    
    Kconfig makes a distinction between dependencies (defined by "depends
    on" expressions and enclosing "if" blocks) and visibility (which
    includes all dependencies, but also includes inline "if" expressions of
    individual properties as well as, for prompts, "visible if" expressions
    of enclosing menus).
    
    Before commit bcdedcc1afd6 ("menuconfig: print more info for symbol
    without prompts"), the "Depends on" lines of a symbol's help text
    indicated the visibility of the prompt property they appeared under.
    After bcdedcc1afd, there was always only a single "Depends on" line,
    which indicated the visibility of the first P_SYMBOL property of the
    symbol. Since P_SYMBOLs never have inline if expressions, this was in
    effect the same as the dependencies of the menu item that the P_SYMBOL
    was attached to.
    
    Neither of these situations accurately conveyed the dependencies of a
    symbol--the first because it was actually the visibility, and the second
    because it only showed the dependencies from a single definition.
    
    With this series, we are back to printing separate dependencies for each
    definition, but we print the actual dependencies (rather than the
    visibility) in the "Depends on" line. However, it can still be useful to
    know the visibility of a prompt, so this patch adds a "Visible if" line
    that shows the visibility only if the visibility is different from the
    dependencies (which it isn't for most prompts in Linux).
    
    Before:
    
      Symbol: THUMB2_KERNEL [=n]
      Type  : bool
      Defined at arch/arm/Kconfig:1417
        Prompt: Compile the kernel in Thumb-2 mode
        Depends on: (CPU_V7 [=y] || CPU_V7M [=n]) && !CPU_V6 [=n] && !CPU_V6K [=n]
        Location:
          -> Kernel Features
        Selects: ARM_UNWIND [=n]
    
    After:
    
       Symbol: THUMB2_KERNEL [=n]
       Type  : bool
       Defined at arch/arm/Kconfig:1417
         Prompt: Compile the kernel in Thumb-2 mode
         Depends on: (CPU_V7 [=y] || CPU_V7M [=n]) && !CPU_V6 [=n] && !CPU_V6K [=n]
         Visible if: (CPU_V7 [=y] || CPU_V7M [=n]) && !CPU_V6 [=n] && !CPU_V6K [=n] && !CPU_THUMBONLY [=n]
         Location:
           -> Kernel Features
         Selects: ARM_UNWIND [=n]
    
    Signed-off-by: Thomas Hebb <tommyhebb@gmail.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b4fb0c88b6e0..da50f79a8e8d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -736,6 +736,17 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	str_printf(r, "  Prompt: %s\n", prop->text);
 
 	get_dep_str(r, prop->menu->dep, "  Depends on: ");
+	/*
+	 * Most prompts in Linux have visibility that exactly matches their
+	 * dependencies. For these, we print only the dependencies to improve
+	 * readability. However, prompts with inline "if" expressions and
+	 * prompts with a parent that has a "visible if" expression have
+	 * differing dependencies and visibility. In these rare cases, we
+	 * print both.
+	 */
+	if (!expr_eq(prop->menu->dep, prop->visible.expr))
+		get_dep_str(r, prop->visible.expr, "  Visible if: ");
+
 	menu = prop->menu->parent;
 	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
 		bool accessible = menu_is_visible(menu);

commit edda15f2197425c1aca8d1dd24a9bb3144686c7b
Author: Thomas Hebb <tommyhebb@gmail.com>
Date:   Tue Dec 17 08:15:43 2019 -0800

    kconfig: list all definitions of a symbol in help text
    
    In Kconfig, each symbol (representing a config option) can be defined in
    multiple places. Each definition may or may not have a prompt, which
    allows the option to be set via an interface like menuconfig. Each
    definition has a set of dependencies, which determine whether its prompt
    is visible and whether other pieces of the definition, like a default
    value, take effect.
    
    Historically, a symbol's help text (i.e. what's shown when a user
    presses '?' in menuconfig) contained some symbol-wide information not
    tied to any particular definition (e.g. what other symbols it selects)
    as well as the location (file name and line number) and dependencies of
    each prompt. Notably, the help text did not show the location or
    dependencies of definitions without prompts.
    
    Because this made it hard to reason about symbols that had no prompts,
    commit bcdedcc1afd6 ("menuconfig: print more info for symbol without
    prompts") changed the help text so that, instead of containing the
    location and dependencies of each prompt, it contained the location and
    dependencies of the symbol's first definition, regardless of whether or
    not that definition had a prompt.
    
    For symbols with only one definition, that change makes sense. However,
    it breaks down for symbols with multiple definitions: each definition
    has its own set of dependencies (the `dep` field of `struct menu`), and
    those dependencies are ORed together to get the symbol's dependency list
    (the `dir_dep` field of `struct symbol`). By printing only the
    dependencies of the first definition, the help text misleads users into
    believing that an option is more narrowly-applicable than it actually
    is.
    
    For an extreme example of this, we can look at the SYS_TEXT_BASE symbol
    in the Das U-Boot project (version 2019.10), which also uses Kconfig. (I
    unfortunately could not find an illustrative example in Linux.) This
    config option specifies the load address of the built binary and, as
    such, is applicable to basically every configuration possible. And yet,
    without this patch, its help text is as follows:
    
      Symbol: SYS_TEXT_BASE [=]
      Type  : hex
      Prompt: U-Boot base address
        Location:
          -> ARM architecture
      Prompt: Text Base
        Location:
          -> Boot images
        Defined at arch/arm/mach-aspeed/Kconfig:9
        Depends on: ARM [=n] && ARCH_ASPEED [=n]
    
    The help text indicates that the option is applicable only for a
    specific unselected architecture (aspeed), because that architecture's
    promptless definition (which just sets a default value), happens to be
    the first one seen. No definition or dependency information is printed
    for either of the two prompts listed.
    
    Because source locations and dependencies are fundamentally properties
    of definitions and not of symbols, we should treat them as such. This
    patch brings back the pre-bcdedcc1afd6 behavior for definitions with
    prompts but also separately prints the location and dependencies of
    those without prompts, solving the original problem in a different way.
    With this change, our SYS_TEXT_BASE example becomes
    
       Symbol: SYS_TEXT_BASE [=]
       Type  : hex
       Defined at arch/arm/mach-stm32mp/Kconfig:83
         Prompt: U-Boot base address
         Depends on: ARM [=n] && ARCH_STM32MP [=n]
         Location:
           -> ARM architecture
       Defined at Kconfig:532
         Prompt: Text Base
         Depends on: !NIOS2 [=n] && !XTENSA [=n] && !EFI_APP [=n]
         Location:
           -> Boot images
       Defined at arch/arm/mach-aspeed/Kconfig:9
         Depends on: ARM [=n] && ARCH_ASPEED [=n]
       Defined  at arch/arm/mach-socfpga/Kconfig:25
         Depends on: ARM [=n] && ARCH_SOCFPGA [=n]
       <snip>
       Defined at board/sifive/fu540/Kconfig:15
         Depends on: RISCV [=n] && TARGET_SIFIVE_FU540 [=n]
    
    which is a much more accurate representation.
    
    Note that there is one notable difference between what gets printed for
    prompts after this change and what got printed before bcdedcc1afd6: the
    "Depends on" line now accurately represents the prompt's dependencies
    instead of conflating those with the prompt's visibility (which can
    include extra conditions). See the patch later in this series titled
    "kconfig: distinguish between dependencies and visibility in help text"
    for more details and better handling of that nuance.
    
    Signed-off-by: Thomas Hebb <tommyhebb@gmail.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 8b772ced755d..b4fb0c88b6e0 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -711,6 +711,21 @@ const char *menu_get_help(struct menu *menu)
 		return "";
 }
 
+static void get_def_str(struct gstr *r, struct menu *menu)
+{
+	str_printf(r, "Defined at %s:%d\n",
+		   menu->file->name, menu->lineno);
+}
+
+static void get_dep_str(struct gstr *r, struct expr *expr, const char *prefix)
+{
+	if (!expr_is_yes(expr)) {
+		str_append(r, prefix);
+		expr_gstr_print(expr, r);
+		str_append(r, "\n");
+	}
+}
+
 static void get_prompt_str(struct gstr *r, struct property *prop,
 			   struct list_head *head)
 {
@@ -718,7 +733,9 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	struct menu *submenu[8], *menu, *location = NULL;
 	struct jump_key *jump = NULL;
 
-	str_printf(r, "Prompt: %s\n", prop->text);
+	str_printf(r, "  Prompt: %s\n", prop->text);
+
+	get_dep_str(r, prop->menu->dep, "  Depends on: ");
 	menu = prop->menu->parent;
 	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
 		bool accessible = menu_is_visible(menu);
@@ -768,18 +785,6 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	}
 }
 
-/*
- * get property of type P_SYMBOL
- */
-static struct property *get_symbol_prop(struct symbol *sym)
-{
-	struct property *prop = NULL;
-
-	for_all_properties(sym, prop, P_SYMBOL)
-		break;
-	return prop;
-}
-
 static void get_symbol_props_str(struct gstr *r, struct symbol *sym,
 				 enum prop_type tok, const char *prefix)
 {
@@ -819,17 +824,19 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 			}
 		}
 	}
-	for_all_prompts(sym, prop)
-		get_prompt_str(r, prop, head);
-
-	prop = get_symbol_prop(sym);
-	if (prop) {
-		str_printf(r, "  Defined at %s:%d\n", prop->menu->file->name,
-			prop->menu->lineno);
-		if (!expr_is_yes(prop->visible.expr)) {
-			str_append(r, "  Depends on: ");
-			expr_gstr_print(prop->visible.expr, r);
-			str_append(r, "\n");
+
+	/* Print the definitions with prompts before the ones without */
+	for_all_properties(sym, prop, P_SYMBOL) {
+		if (prop->menu->prompt) {
+			get_def_str(r, prop->menu);
+			get_prompt_str(r, prop->menu->prompt, head);
+		}
+	}
+
+	for_all_properties(sym, prop, P_SYMBOL) {
+		if (!prop->menu->prompt) {
+			get_def_str(r, prop->menu);
+			get_dep_str(r, prop->menu->dep, "  Depends on: ");
 		}
 	}
 

commit adf7c5bd0674b04588246e444efef9987b2f1a6b
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:23 2019 +0900

    kconfig: squash prop_alloc() into menu_add_prop()
    
    prop_alloc() is only called from menu_add_prop(). Squash it.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 5a43784ded2c..8b772ced755d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -127,12 +127,28 @@ void menu_set_type(int type)
 static struct property *menu_add_prop(enum prop_type type, struct expr *expr,
 				      struct expr *dep)
 {
-	struct property *prop = prop_alloc(type, current_entry->sym);
+	struct property *prop;
 
+	prop = xmalloc(sizeof(*prop));
+	memset(prop, 0, sizeof(*prop));
+	prop->type = type;
+	prop->file = current_file;
+	prop->lineno = zconf_lineno();
 	prop->menu = current_entry;
 	prop->expr = expr;
 	prop->visible.expr = dep;
 
+	/* append property to the prop list of symbol */
+	if (current_entry->sym) {
+		struct property **propp;
+
+		for (propp = &current_entry->sym->prop;
+		     *propp;
+		     propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+
 	return prop;
 }
 

commit 2ffeef615b5e6ac452f55fd6277dc44a667c7c8c
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:21 2019 +0900

    kconfig: remove 'prompt' argument from menu_add_prop()
    
    This function no longer uses the 'prompt' argument.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 45daece8d983..5a43784ded2c 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -124,7 +124,8 @@ void menu_set_type(int type)
 		sym_type_name(sym->type), sym_type_name(type));
 }
 
-static struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)
+static struct property *menu_add_prop(enum prop_type type, struct expr *expr,
+				      struct expr *dep)
 {
 	struct property *prop = prop_alloc(type, current_entry->sym);
 
@@ -138,7 +139,7 @@ static struct property *menu_add_prop(enum prop_type type, char *prompt, struct
 struct property *menu_add_prompt(enum prop_type type, char *prompt,
 				 struct expr *dep)
 {
-	struct property *prop = menu_add_prop(type, prompt, NULL, dep);
+	struct property *prop = menu_add_prop(type, NULL, dep);
 
 	if (isspace(*prompt)) {
 		prop_warn(prop, "leading whitespace ignored");
@@ -185,12 +186,12 @@ void menu_add_visibility(struct expr *expr)
 
 void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
 {
-	menu_add_prop(type, NULL, expr, dep);
+	menu_add_prop(type, expr, dep);
 }
 
 void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 {
-	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
+	menu_add_prop(type, expr_alloc_symbol(sym), dep);
 }
 
 void menu_add_option_modules(void)

commit 024352ff8d696e95a8601970f98a66d836e30549
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:20 2019 +0900

    kconfig: move prompt handling to menu_add_prompt() from menu_add_prop()
    
    menu_add_prompt() is the only function that calls menu_add_prop() with
    non-NULL prompt.
    
    So, the code inside the if-conditional block of menu_add_prop() can be
    moved to menu_add_prompt().
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index bbabf0a59ac4..45daece8d983 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -132,53 +132,51 @@ static struct property *menu_add_prop(enum prop_type type, char *prompt, struct
 	prop->expr = expr;
 	prop->visible.expr = dep;
 
-	if (prompt) {
-		if (isspace(*prompt)) {
-			prop_warn(prop, "leading whitespace ignored");
-			while (isspace(*prompt))
-				prompt++;
-		}
-		if (current_entry->prompt)
-			prop_warn(prop, "prompt redefined");
+	return prop;
+}
 
-		/* Apply all upper menus' visibilities to actual prompts. */
-		if(type == P_PROMPT) {
-			struct menu *menu = current_entry;
+struct property *menu_add_prompt(enum prop_type type, char *prompt,
+				 struct expr *dep)
+{
+	struct property *prop = menu_add_prop(type, prompt, NULL, dep);
 
-			while ((menu = menu->parent) != NULL) {
-				struct expr *dup_expr;
+	if (isspace(*prompt)) {
+		prop_warn(prop, "leading whitespace ignored");
+		while (isspace(*prompt))
+			prompt++;
+	}
+	if (current_entry->prompt)
+		prop_warn(prop, "prompt redefined");
 
-				if (!menu->visibility)
-					continue;
-				/*
-				 * Do not add a reference to the
-				 * menu's visibility expression but
-				 * use a copy of it.  Otherwise the
-				 * expression reduction functions
-				 * will modify expressions that have
-				 * multiple references which can
-				 * cause unwanted side effects.
-				 */
-				dup_expr = expr_copy(menu->visibility);
+	/* Apply all upper menus' visibilities to actual prompts. */
+	if (type == P_PROMPT) {
+		struct menu *menu = current_entry;
 
-				prop->visible.expr
-					= expr_alloc_and(prop->visible.expr,
-							 dup_expr);
-			}
-		}
+		while ((menu = menu->parent) != NULL) {
+			struct expr *dup_expr;
 
-		current_entry->prompt = prop;
+			if (!menu->visibility)
+				continue;
+			/*
+			 * Do not add a reference to the menu's visibility
+			 * expression but use a copy of it. Otherwise the
+			 * expression reduction functions will modify
+			 * expressions that have multiple references which
+			 * can cause unwanted side effects.
+			 */
+			dup_expr = expr_copy(menu->visibility);
+
+			prop->visible.expr = expr_alloc_and(prop->visible.expr,
+							    dup_expr);
+		}
 	}
+
+	current_entry->prompt = prop;
 	prop->text = prompt;
 
 	return prop;
 }
 
-struct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
-{
-	return menu_add_prop(type, prompt, NULL, dep);
-}
-
 void menu_add_visibility(struct expr *expr)
 {
 	current_entry->visibility = expr_alloc_and(current_entry->visibility,

commit de026ca9152c3b3d8c85b8884a29040975ac1424
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:17 2019 +0900

    kconfig: use parent->dep as the parentdep of 'menu'
    
    In menu_finalize(), the dependency of a menu entry is propagated
    downwards.
    
    For the 'menu', parent->dep and parent->prompt->visible.expr have
    the same expression. Both accumulate the 'depends on' of itself and
    upper menu entries.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b1b1ee8cf987..bbabf0a59ac4 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -326,12 +326,10 @@ void menu_finalize(struct menu *parent)
 			 * choice value symbols.
 			 */
 			parentdep = expr_alloc_symbol(sym);
-		} else if (parent->prompt)
-			/* Menu node for 'menu' */
-			parentdep = parent->prompt->visible.expr;
-		else
-			/* Menu node for 'if' */
+		} else {
+			/* Menu node for 'menu', 'if' */
 			parentdep = parent->dep;
+		}
 
 		/* For each child menu node... */
 		for (menu = parent->list; menu; menu = menu->next) {

commit f64048a20b0ce1bb1fd5c3f80e82556db73fe08b
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Tue Dec 17 13:14:16 2019 +0900

    kconfig: remove the rootmenu check in menu_add_prop()
    
    This reverts commit ba6ff60d5eb4 ("kconfig: don't emit warning upon
    rootmenu's prompt redefinition").
    
    At that time, rootmenu.prompt was always set first, then it was set
    again if a "mainmenu" statement was specified in the Kconfig file.
    
    This is no longer the case since commit 0724a7c32a54 ("kconfig: Don't
    leak main menus during parsing"). Remove the unneeded check.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index d9d16469859a..b1b1ee8cf987 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -138,7 +138,7 @@ static struct property *menu_add_prop(enum prop_type type, char *prompt, struct
 			while (isspace(*prompt))
 				prompt++;
 		}
-		if (current_entry->prompt && current_entry != &rootmenu)
+		if (current_entry->prompt)
 			prop_warn(prop, "prompt redefined");
 
 		/* Apply all upper menus' visibilities to actual prompts. */

commit 0c874100108f03401cb3154801d2671bbad40ad4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 18 21:13:35 2018 +0900

    kconfig: convert to SPDX License Identifier
    
    All files in lxdialog/ are licensed under GPL-2.0+, and the rest are
    under GPL-2.0. I added GPL-2.0 tags to test scripts in tests/.
    
    Documentation/process/license-rules.rst does not suggest anything
    about the flex/bison files. Because flex does not accept the C++
    comment style at the very top of a file, I used the C style for
    zconf.l, and so for zconf.y for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7e2b2c938d7b..d9d16469859a 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- * Released under the terms of the GNU GPL v2.0.
  */
 
 #include <ctype.h>

commit ce2164ab58316e27180034112f97608a764f5b37
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Dec 11 20:01:00 2018 +0900

    kconfig: refactor scanning and parsing "option" properties
    
    For the keywords "modules", "defconfig_list", and "allnoconfig_y",
    the lexer should pass specific tokens instead of generic T_WORD.
    
    This simplifies both the lexer and the parser.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 4cf15d449c05..7e2b2c938d7b 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -195,29 +195,26 @@ void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
 }
 
-void menu_add_option(int token, char *arg)
-{
-	switch (token) {
-	case T_OPT_MODULES:
-		if (modules_sym)
-			zconf_error("symbol '%s' redefines option 'modules'"
-				    " already defined by symbol '%s'",
-				    current_entry->sym->name,
-				    modules_sym->name
-				    );
-		modules_sym = current_entry->sym;
-		break;
-	case T_OPT_DEFCONFIG_LIST:
-		if (!sym_defconfig_list)
-			sym_defconfig_list = current_entry->sym;
-		else if (sym_defconfig_list != current_entry->sym)
-			zconf_error("trying to redefine defconfig symbol");
-		sym_defconfig_list->flags |= SYMBOL_NO_WRITE;
-		break;
-	case T_OPT_ALLNOCONFIG_Y:
-		current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;
-		break;
-	}
+void menu_add_option_modules(void)
+{
+	if (modules_sym)
+		zconf_error("symbol '%s' redefines option 'modules' already defined by symbol '%s'",
+			    current_entry->sym->name, modules_sym->name);
+	modules_sym = current_entry->sym;
+}
+
+void menu_add_option_defconfig_list(void)
+{
+	if (!sym_defconfig_list)
+		sym_defconfig_list = current_entry->sym;
+	else if (sym_defconfig_list != current_entry->sym)
+		zconf_error("trying to redefine defconfig symbol");
+	sym_defconfig_list->flags |= SYMBOL_NO_WRITE;
+}
+
+void menu_add_option_allnoconfig_y(void)
+{
+	current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;
 }
 
 static int menu_validate_number(struct symbol *sym, struct symbol *sym2)

commit 693359f7ac9012778590a370d076b13db704255e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Tue Jul 3 14:43:31 2018 +0200

    kconfig: rename SYMBOL_AUTO to SYMBOL_NO_WRITE
    
    Over time, the use of the flag SYMBOL_AUTO changed from initially
    marking three automatically generated symbols ARCH, KERNELRELEASE and
    UNAME_RELEASE to today's effect of protecting symbols from being
    written out.
    
    Currently, only symbols of type CHOICE and those with option
    defconf_list set have that flag set.
    
    Reflect that change in semantics in the flag's name.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 379a119dcd1e..4cf15d449c05 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -212,7 +212,7 @@ void menu_add_option(int token, char *arg)
 			sym_defconfig_list = current_entry->sym;
 		else if (sym_defconfig_list != current_entry->sym)
 			zconf_error("trying to redefine defconfig symbol");
-		sym_defconfig_list->flags |= SYMBOL_AUTO;
+		sym_defconfig_list->flags |= SYMBOL_NO_WRITE;
 		break;
 	case T_OPT_ALLNOCONFIG_Y:
 		current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;

commit 104daea149c45cc84842ce77a9bd6436d19f3dd8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon May 28 18:21:40 2018 +0900

    kconfig: reference environment variables directly and remove 'option env='
    
    To get access to environment variables, Kconfig needs to define a
    symbol using "option env=" syntax.  It is tedious to add a symbol entry
    for each environment variable given that we need to define much more
    such as 'CC', 'AS', 'srctree' etc. to evaluate the compiler capability
    in Kconfig.
    
    Adding '$' for symbol references is grammatically inconsistent.
    Looking at the code, the symbols prefixed with 'S' are expanded by:
     - conf_expand_value()
       This is used to expand 'arch/$ARCH/defconfig' and 'defconfig_list'
     - sym_expand_string_value()
       This is used to expand strings in 'source' and 'mainmenu'
    
    All of them are fixed values independent of user configuration.  So,
    they can be changed into the direct expansion instead of symbols.
    
    This change makes the code much cleaner.  The bounce symbols 'SRCARCH',
    'ARCH', 'SUBARCH', 'KERNELVERSION' are gone.
    
    sym_init() hard-coding 'UNAME_RELEASE' is also gone.  'UNAME_RELEASE'
    should be replaced with an environment variable.
    
    ARCH_DEFCONFIG is a normal symbol, so it should be simply referenced
    without '$' prefix.
    
    The new syntax is addicted by Make.  The variable reference needs
    parentheses, like $(FOO), but you can omit them for single-letter
    variables, like $F.  Yet, in Makefiles, people tend to use the
    parenthetical form for consistency / clarification.
    
    At this moment, only the environment variable is supported, but I will
    extend the concept of 'variable' later on.
    
    The variables are expanded in the lexer so we can simplify the token
    handling on the parser side.
    
    For example, the following code works.
    
    [Example code]
    
      config MY_TOOLCHAIN_LIST
              string
              default "My tools: CC=$(CC), AS=$(AS), CPP=$(CPP)"
    
    [Result]
    
      $ make -s alldefconfig && tail -n 1 .config
      CONFIG_MY_TOOLCHAIN_LIST="My tools: CC=gcc, AS=as, CPP=gcc -E"
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 068a4e4db20a..379a119dcd1e 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -214,9 +214,6 @@ void menu_add_option(int token, char *arg)
 			zconf_error("trying to redefine defconfig symbol");
 		sym_defconfig_list->flags |= SYMBOL_AUTO;
 		break;
-	case T_OPT_ENV:
-		prop_add_env(arg);
-		break;
 	case T_OPT_ALLNOCONFIG_Y:
 		current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;
 		break;

commit 694c49a7c01cc87194be40cb26404b58b68c291c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue May 22 21:36:12 2018 +0200

    kconfig: drop localization support
    
    The localization support is broken and appears unused.
    There is no google hits on the update-po-config target.
    And there is no recent (5 years) activity related to the localization.
    
    So lets just drop this as it is no longer used.
    
    Suggested-by: Ulf Magnusson <ulfalizer@gmail.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 5c5c1374b151..068a4e4db20a 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -711,7 +711,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	struct menu *submenu[8], *menu, *location = NULL;
 	struct jump_key *jump = NULL;
 
-	str_printf(r, _("Prompt: %s\n"), _(prop->text));
+	str_printf(r, "Prompt: %s\n", prop->text);
 	menu = prop->menu->parent;
 	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
 		bool accessible = menu_is_visible(menu);
@@ -744,16 +744,16 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	}
 
 	if (i > 0) {
-		str_printf(r, _("  Location:\n"));
+		str_printf(r, "  Location:\n");
 		for (j = 4; --i >= 0; j += 2) {
 			menu = submenu[i];
 			if (jump && menu == location)
 				jump->offset = strlen(r->s);
 			str_printf(r, "%*c-> %s", j, ' ',
-				   _(menu_get_prompt(menu)));
+				   menu_get_prompt(menu));
 			if (menu->sym) {
 				str_printf(r, " (%s [=%s])", menu->sym->name ?
-					menu->sym->name : _("<choice>"),
+					menu->sym->name : "<choice>",
 					sym_get_string_value(menu->sym));
 			}
 			str_append(r, "\n");
@@ -817,23 +817,23 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 
 	prop = get_symbol_prop(sym);
 	if (prop) {
-		str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
+		str_printf(r, "  Defined at %s:%d\n", prop->menu->file->name,
 			prop->menu->lineno);
 		if (!expr_is_yes(prop->visible.expr)) {
-			str_append(r, _("  Depends on: "));
+			str_append(r, "  Depends on: ");
 			expr_gstr_print(prop->visible.expr, r);
 			str_append(r, "\n");
 		}
 	}
 
-	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
+	get_symbol_props_str(r, sym, P_SELECT, "  Selects: ");
 	if (sym->rev_dep.expr) {
 		expr_gstr_print_revdep(sym->rev_dep.expr, r, yes, "  Selected by [y]:\n");
 		expr_gstr_print_revdep(sym->rev_dep.expr, r, mod, "  Selected by [m]:\n");
 		expr_gstr_print_revdep(sym->rev_dep.expr, r, no, "  Selected by [n]:\n");
 	}
 
-	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
+	get_symbol_props_str(r, sym, P_IMPLY, "  Implies: ");
 	if (sym->implied.expr) {
 		expr_gstr_print_revdep(sym->implied.expr, r, yes, "  Implied by [y]:\n");
 		expr_gstr_print_revdep(sym->implied.expr, r, mod, "  Implied by [m]:\n");
@@ -852,7 +852,7 @@ struct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head)
 	for (i = 0; sym_arr && (sym = sym_arr[i]); i++)
 		get_symbol_str(&res, sym, head);
 	if (!i)
-		str_append(&res, _("No matches found.\n"));
+		str_append(&res, "No matches found.\n");
 	return res;
 }
 
@@ -867,7 +867,7 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 			str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
 		help_text = menu_get_help(menu);
 	}
-	str_printf(help, "%s\n", _(help_text));
+	str_printf(help, "%s\n", help_text);
 	if (sym)
 		get_symbol_str(help, sym, NULL);
 }

commit d9119b5925a03b9a3191fa3e93b4091651d8ad25
Author: Eugeniu Rosca <erosca@de.adit-jv.com>
Date:   Sat Feb 24 16:24:18 2018 +0100

    kconfig: Print reverse dependencies in groups
    
    Surprisingly or not, disabling a CONFIG option (which is assumed to
    be unneeded) may be not so trivial. Especially it is not trivial, when
    this CONFIG option is selected by a dozen of other configs. Before the
    moment commit 1ccb27143360 ("kconfig: make "Selected by:" and
    "Implied by:" readable") popped up in v4.16-rc1, it was an absolute pain
    to break down the "Selected by" reverse dependency expression in order
    to identify all those configs which select (IOW *do not allow
    disabling*) a certain feature (assumed to be not needed).
    
    This patch tries to make one step further by putting at users'
    fingertips the revdep top level OR sub-expressions grouped/clustered by
    the tristate value they evaluate to. This should allow the users to
    directly concentrate on and tackle the _active_ reverse dependencies.
    
    To give some numbers and quantify the complexity of certain reverse
    dependencies, assuming commit 617aebe6a97e ("Merge tag
    'usercopy-v4.16-rc1' of
    git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux"), ARCH=arm64
    and vanilla arm64 defconfig, here is the top 10 CONFIG options with
    the highest amount of top level "||" sub-expressions/tokens that make
    up the final "Selected by" reverse dependency expression.
    
    | Config            | All revdep | Active revdep |
    |-------------------|------------|---------------|
    | REGMAP_I2C        | 212        | 9             |
    | CRC32             | 167        | 25            |
    | FW_LOADER         | 128        | 5             |
    | MFD_CORE          | 124        | 9             |
    | FB_CFB_IMAGEBLIT  | 114        | 2             |
    | FB_CFB_COPYAREA   | 111        | 2             |
    | FB_CFB_FILLRECT   | 110        | 2             |
    | SND_PCM           | 103        | 2             |
    | CRYPTO_HASH       | 87         | 19            |
    | WATCHDOG_CORE     | 86         | 6             |
    
    The story behind the above is that users need to visually
    review/evaluate 212 expressions which *potentially* select REGMAP_I2C
    in order to identify the expressions which *actually* select REGMAP_I2C,
    for a particular ARCH and for a particular defconfig used.
    
    To make this experience smoother, change the way reverse dependencies
    are displayed to the user from [1] to [2].
    
    [1] Old representation of DMA_ENGINE_RAID:
      Selected by:
      - AMCC_PPC440SPE_ADMA [=n] && DMADEVICES [=y] && (440SPe || 440SP)
      - BCM_SBA_RAID [=m] && DMADEVICES [=y] && (ARM64 [=y] || ...
      - FSL_RAID [=n] && DMADEVICES [=y] && FSL_SOC && ...
      - INTEL_IOATDMA [=n] && DMADEVICES [=y] && PCI [=y] && X86_64
      - MV_XOR [=n] && DMADEVICES [=y] && (PLAT_ORION || ARCH_MVEBU [=y] ...
      - MV_XOR_V2 [=y] && DMADEVICES [=y] && ARM64 [=y]
      - XGENE_DMA [=n] && DMADEVICES [=y] && (ARCH_XGENE [=y] || ...
      - DMATEST [=n] && DMADEVICES [=y] && DMA_ENGINE [=y]
    
    [2] New representation of DMA_ENGINE_RAID:
      Selected by [y]:
      - MV_XOR_V2 [=y] && DMADEVICES [=y] && ARM64 [=y]
      Selected by [m]:
      - BCM_SBA_RAID [=m] && DMADEVICES [=y] && (ARM64 [=y] || ...
      Selected by [n]:
      - AMCC_PPC440SPE_ADMA [=n] && DMADEVICES [=y] && (440SPe || ...
      - FSL_RAID [=n] && DMADEVICES [=y] && FSL_SOC && ...
      - INTEL_IOATDMA [=n] && DMADEVICES [=y] && PCI [=y] && X86_64
      - MV_XOR [=n] && DMADEVICES [=y] && (PLAT_ORION || ARCH_MVEBU [=y] ...
      - XGENE_DMA [=n] && DMADEVICES [=y] && (ARCH_XGENE [=y] || ...
      - DMATEST [=n] && DMADEVICES [=y] && DMA_ENGINE [=y]
    
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Reviewed-by: Petr Vorel <pvorel@suse.cz>
    Reviewed-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 02f46813e732..5c5c1374b151 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -828,16 +828,16 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 
 	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
 	if (sym->rev_dep.expr) {
-		str_append(r, _("  Selected by: "));
-		str_append(r, "\n");
-		expr_gstr_print_revdep(sym->rev_dep.expr, r);
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, yes, "  Selected by [y]:\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, mod, "  Selected by [m]:\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r, no, "  Selected by [n]:\n");
 	}
 
 	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
 	if (sym->implied.expr) {
-		str_append(r, _("  Implied by: "));
-		str_append(r, "\n");
-		expr_gstr_print_revdep(sym->implied.expr, r);
+		expr_gstr_print_revdep(sym->implied.expr, r, yes, "  Implied by [y]:\n");
+		expr_gstr_print_revdep(sym->implied.expr, r, mod, "  Implied by [m]:\n");
+		expr_gstr_print_revdep(sym->implied.expr, r, no, "  Implied by [n]:\n");
 	}
 
 	str_append(r, "\n\n");

commit 9a47ceec543bfb703fbe2f8d584850b582caf1a6
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Feb 20 17:18:47 2018 +0900

    kconfig: clean-up reverse dependency help implementation
    
    This commit splits out the special E_OR handling ('-' instead of '||')
    into a dedicated helper expr_print_revdev().
    
    Restore the original expr_print() prior to commit 1ccb27143360
    ("kconfig: make "Selected by:" and "Implied by:" readable").
    
    This makes sense because:
    
      - We need to chop those expressions only when printing the reverse
        dependency, and only when E_OR is encountered
    
      - Otherwise, it should be printed as before, so fall back to
        expr_print()
    
    This also improves the behavior; for a single line, it was previously
    displayed in the same line as "Selected by", like this:
    
      Selected by: A [=n] && B [=n]
    
    This will be displayed in a new line, consistently:
    
      Selected by:
      - A [=n] && B [=n]
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Petr Vorel <pvorel@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 36cd3e1f1c28..02f46813e732 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -829,15 +829,15 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
 	if (sym->rev_dep.expr) {
 		str_append(r, _("  Selected by: "));
-		expr_gstr_print_revdep(sym->rev_dep.expr, r);
 		str_append(r, "\n");
+		expr_gstr_print_revdep(sym->rev_dep.expr, r);
 	}
 
 	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
 	if (sym->implied.expr) {
 		str_append(r, _("  Implied by: "));
-		expr_gstr_print_revdep(sym->implied.expr, r);
 		str_append(r, "\n");
+		expr_gstr_print_revdep(sym->implied.expr, r);
 	}
 
 	str_append(r, "\n\n");

commit f4bc1eefc1608e9a7d40f5fdfc3acd560ba6f477
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Feb 17 03:38:32 2018 +0900

    kconfig: set SYMBOL_AUTO to the symbol marked with defconfig_list
    
    The 'defconfig_list' is a weird attribute.  If the '.config' is
    missing, conf_read_simple() iterates over all visible defaults,
    then it uses the first one for which fopen() succeeds.
    
    config DEFCONFIG_LIST
            string
            depends on !UML
            option defconfig_list
            default "/lib/modules/$UNAME_RELEASE/.config"
            default "/etc/kernel-config"
            default "/boot/config-$UNAME_RELEASE"
            default "$ARCH_DEFCONFIG"
            default "arch/$ARCH/defconfig"
    
    However, like other symbols, the first visible default is always
    written out to the .config file.  This might be different from what
    has been actually used.
    
    For example, on my machine, the third one "/boot/config-$UNAME_RELEASE"
    is opened, like follows:
    
      $ rm .config
      $ make oldconfig 2>/dev/null
      scripts/kconfig/conf  --oldconfig Kconfig
      #
      # using defaults found in /boot/config-4.4.0-112-generic
      #
      *
      * Restart config...
      *
      *
      * IRQ subsystem
      *
      Expose irq internals in debugfs (GENERIC_IRQ_DEBUGFS) [N/y/?] (NEW)
    
    However, the resulted .config file contains the first one since it is
    visible:
    
      $ grep CONFIG_DEFCONFIG_LIST .config
      CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
    
    In order to stop confusing people, prevent this CONFIG option from
    being written to the .config file.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Ulf Magnusson <ulfalizer@gmail.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 99222855544c..36cd3e1f1c28 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -212,6 +212,7 @@ void menu_add_option(int token, char *arg)
 			sym_defconfig_list = current_entry->sym;
 		else if (sym_defconfig_list != current_entry->sym)
 			zconf_error("trying to redefine defconfig symbol");
+		sym_defconfig_list->flags |= SYMBOL_AUTO;
 		break;
 	case T_OPT_ENV:
 		prop_add_env(arg);

commit 1ccb27143360bd2390a9a970e50709f858b53761
Author: Petr Vorel <petr.vorel@gmail.com>
Date:   Thu Jan 25 10:46:35 2018 +0100

    kconfig: make "Selected by:" and "Implied by:" readable
    
    Reverse dependency expressions can get rather unwieldy, especially if
    a symbol is selected by more than a handful of other symbols. I.e. it's
    possible to have near endless expressions like:
       A && B && !C || D || F && (G || H) || [...]
    
    Chop these expressions into actually readable chunks:
       - A && B && !C
       - D
       - F && (G || H)
       - [...]
    
    I.e. transform the top level OR tokens into newlines and prepend each
    line with a minus. This makes the "Selected by:" and "Implied by:" blurb
    much easier to read. This is done only if there is more than one top
    level OR. "Depends on:" and "Range :" were deliberately left as they are.
    
    Based on idea from Paul Bolle.
    
    Suggested-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Petr Vorel <petr.vorel@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index d365fc9513c5..99222855544c 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -828,14 +828,14 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
 	if (sym->rev_dep.expr) {
 		str_append(r, _("  Selected by: "));
-		expr_gstr_print(sym->rev_dep.expr, r);
+		expr_gstr_print_revdep(sym->rev_dep.expr, r);
 		str_append(r, "\n");
 	}
 
 	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
 	if (sym->implied.expr) {
 		str_append(r, _("  Implied by: "));
-		expr_gstr_print(sym->implied.expr, r);
+		expr_gstr_print_revdep(sym->implied.expr, r);
 		str_append(r, "\n");
 	}
 

commit b53688014e33256d4e3c08e89e563974dca98a98
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Tue Jan 16 21:39:02 2018 +0100

    kconfig: Clarify menu and 'if' dependency propagation
    
    It is not obvious that the last two cases refer to menus and ifs,
    respectively, in the conditional that sets 'parentdep'.
    
    Automatic submenu creation is done later, so the parent can't be a
    symbol here.
    
    No functional changes. Only comments added.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index af66065733bb..d365fc9513c5 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -332,8 +332,10 @@ void menu_finalize(struct menu *parent)
 			 */
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
+			/* Menu node for 'menu' */
 			parentdep = parent->prompt->visible.expr;
 		else
+			/* Menu node for 'if' */
 			parentdep = parent->dep;
 
 		/* For each child menu node... */

commit 9d1a9e8bc18bea94adfa716073df3ed83fc4e895
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Jan 14 15:49:26 2018 +0100

    kconfig: Document 'if' flattening logic
    
    It is not obvious that this might refer to an 'if', making the code
    pretty cryptic:
    
            if (menu->list && (!menu->prompt || !menu->prompt->text)) {
    
    Kconfig keeps the 'if' menu nodes even after flattening. Reflect that in
    the example to be accurate.
    
    No functional changes. Only comments added.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index dcf22008b2d6..af66065733bb 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -532,6 +532,35 @@ void menu_finalize(struct menu *parent)
 			*ep = expr_alloc_one(E_LIST, NULL);
 			(*ep)->right.sym = menu->sym;
 		}
+
+		/*
+		 * This code serves two purposes:
+		 *
+		 * (1) Flattening 'if' blocks, which do not specify a submenu
+		 *     and only add dependencies.
+		 *
+		 *     (Automatic submenu creation might still create a submenu
+		 *     from an 'if' before this code runs.)
+		 *
+		 * (2) "Undoing" any automatic submenus created earlier below
+		 *     promptless symbols.
+		 *
+		 * Before:
+		 *
+		 *	A
+		 *	if ... (or promptless symbol)
+		 *	 +-B
+		 *	 +-C
+		 *	D
+		 *
+		 * After:
+		 *
+		 *	A
+		 *	if ... (or promptless symbol)
+		 *	B
+		 *	C
+		 *	D
+		 */
 		if (menu->list && (!menu->prompt || !menu->prompt->text)) {
 			for (last_menu = menu->list; ; last_menu = last_menu->next) {
 				last_menu->parent = parent;

commit d3465af60f4471b7b6201928e709bc137fdbee3e
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Jan 14 15:12:05 2018 +0100

    kconfig: Clarify choice dependency propagation
    
    It's easy to miss that choices are special-cased to pass on their mode
    as the parent dependency.
    
    No functional changes. Only comments added.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7634d567e779..dcf22008b2d6 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -323,6 +323,13 @@ void menu_finalize(struct menu *parent)
 				if (menu->sym && menu->sym->type == S_UNKNOWN)
 					menu_set_type(sym->type);
 			}
+
+			/*
+			 * Use the choice itself as the parent dependency of
+			 * the contained items. This turns the mode of the
+			 * choice into an upper bound on the visibility of the
+			 * choice value symbols.
+			 */
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
 			parentdep = parent->prompt->visible.expr;

commit 3e41ba05b6d60cd54e64639b308be62c12308a04
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Jan 14 10:56:20 2018 +0100

    kconfig: Document SYMBOL_OPTIONAL logic
    
    Not obvious, especially if you don't already know how choices are
    implemented.
    
    No functional changes. Only comments added.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 47bec3434fef..7634d567e779 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -549,6 +549,15 @@ void menu_finalize(struct menu *parent)
 		sym->flags |= SYMBOL_WARNED;
 	}
 
+	/*
+	 * For non-optional choices, add a reverse dependency (corresponding to
+	 * a select) of '<visibility> && m'. This prevents the user from
+	 * setting the choice mode to 'n' when the choice is visible.
+	 *
+	 * This would also work for non-choice symbols, but only non-optional
+	 * choices clear SYMBOL_OPTIONAL as of writing. Choices are implemented
+	 * as a type of symbol.
+	 */
 	if (sym && !sym_is_optional(sym) && parent->prompt) {
 		sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr,
 				expr_alloc_and(parent->prompt->visible.expr,

commit b92d804a51796b77c7b2b11881b2700eaac88114
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Dec 16 00:38:02 2017 +0900

    kconfig: drop 'boolean' keyword
    
    No more users of this keyword.  Drop it according to the notice by
    commit 6341e62b212a ("kconfig: use bool instead of boolean for type
    definition attributes").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 93fe2fb841db..47bec3434fef 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -269,13 +269,13 @@ static void sym_check_prop(struct symbol *sym)
 			if (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)
 				prop_warn(prop,
 				    "config symbol '%s' uses %s, but is "
-				    "not boolean or tristate", sym->name, use);
+				    "not bool or tristate", sym->name, use);
 			else if (sym2->type != S_UNKNOWN &&
 				 sym2->type != S_BOOLEAN &&
 				 sym2->type != S_TRISTATE)
 				prop_warn(prop,
 				    "'%s' has wrong type. '%s' only "
-				    "accept arguments of boolean and "
+				    "accept arguments of bool and "
 				    "tristate type", sym2->name, use);
 			break;
 		case P_RANGE:

commit df60f4b92d3d0b0b91267532ea2584e3b6b58b2f
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Mon Oct 9 00:14:48 2017 +0200

    kconfig: Remove menu_end_entry()
    
    menu_end_entry() is empty and completely unused as far as I can tell:
    
            $ git log -G menu_end_entry --oneline
            a02f057 [PATCH] kconfig: improve error handling in the parser
            1da177e Linux-2.6.12-rc2
    
    Last one is the initial Git commit, where menu_end_entry() is empty as
    well. I couldn't find anything that redefined it on Google either.
    
    It might be a debugging helper for setting a breakpoint after each
    config, menuconfig, and comment is parsed. IMO it hurts more than it
    helps in that case by making the parsing code look more complicated at a
    glance than it really is, and I suspect it doesn't get used much.
    
    Tested by running the Kconfiglib test suite, which indirectly verifies
    that the .config files generated by the C implementation for each
    defconfig file in the kernel stays the same.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index d061a4d4e203..93fe2fb841db 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -62,13 +62,8 @@ void menu_add_entry(struct symbol *sym)
 		menu_add_symbol(P_SYMBOL, sym, NULL);
 }
 
-void menu_end_entry(void)
-{
-}
-
 struct menu *menu_add_menu(void)
 {
-	menu_end_entry();
 	last_entry_ptr = &current_entry->list;
 	return current_menu = current_entry;
 }

commit 05cccce580456d9b1a4548d9aba758856cac6455
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Oct 8 19:42:18 2017 +0200

    kconfig: Document automatic submenu creation code
    
    It's tricky to figure out what it does (and how) without staring at the
    code for a long time. Document it to make it more transparent.
    
    No functional changes. Only comments added.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 41c79bef3d07..d061a4d4e203 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -418,25 +418,63 @@ void menu_finalize(struct menu *parent)
 		for (menu = parent->list; menu; menu = menu->next)
 			menu_finalize(menu);
 	} else if (sym) {
+		/*
+		 * Automatic submenu creation. If sym is a symbol and A, B, C,
+		 * ... are consecutive items (symbols, menus, ifs, etc.) that
+		 * all depend on sym, then the following menu structure is
+		 * created:
+		 *
+		 *	sym
+		 *	 +-A
+		 *	 +-B
+		 *	 +-C
+		 *	 ...
+		 *
+		 * This also works recursively, giving the following structure
+		 * if A is a symbol and B depends on A:
+		 *
+		 *	sym
+		 *	 +-A
+		 *	 | +-B
+		 *	 +-C
+		 *	 ...
+		 */
+
 		basedep = parent->prompt ? parent->prompt->visible.expr : NULL;
 		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
 		basedep = expr_eliminate_dups(expr_transform(basedep));
+
+		/* Examine consecutive elements after sym */
 		last_menu = NULL;
 		for (menu = parent->next; menu; menu = menu->next) {
 			dep = menu->prompt ? menu->prompt->visible.expr : menu->dep;
 			if (!expr_contains_symbol(dep, sym))
+				/* No dependency, quit */
 				break;
 			if (expr_depends_symbol(dep, sym))
+				/* Absolute dependency, put in submenu */
 				goto next;
+
+			/*
+			 * Also consider it a dependency on sym if our
+			 * dependencies contain sym and are a "superset" of
+			 * sym's dependencies, e.g. '(sym || Q) && R' when sym
+			 * depends on R.
+			 *
+			 * Note that 'R' might be from an enclosing menu or if,
+			 * making this a more common case than it might seem.
+			 */
 			dep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);
 			dep = expr_eliminate_dups(expr_transform(dep));
 			dep2 = expr_copy(basedep);
 			expr_eliminate_eq(&dep, &dep2);
 			expr_free(dep);
 			if (!expr_is_yes(dep2)) {
+				/* Not superset, quit */
 				expr_free(dep2);
 				break;
 			}
+			/* Superset, put in submenu */
 			expr_free(dep2);
 		next:
 			menu_finalize(menu);

commit 7cf33f88e2941051309e094e2fafd80f364735f2
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Oct 8 19:35:46 2017 +0200

    kconfig: Fix choice symbol expression leak
    
    When propagating dependencies from parents after parsing, an expression
    node is allocated if the parent symbol is a 'choice'. This node was
    never freed.
    
    Outline of leak:
    
            if (sym && sym_is_choice(sym)) {
                    ...
                    *Allocate (in this case only)*
                    parentdep = expr_alloc_symbol(sym);
            } else if (parent->prompt)
                    parentdep = parent->prompt->visible.expr;
            else
                    parentdep = parent->dep;
    
            for (menu = parent->list; menu; menu = menu->next) {
                    ...
                    *Copy*
                    basedep = expr_alloc_and(expr_copy(parentdep), basedep);
                    ...
            }
            *parentdep lost if the parent is a choice!*
    
    Fix by freeing 'parentdep' after the loop if the parent symbol is a
    choice. Note that this only frees the expression node and not the choice
    symbol itself.
    
    Summary from Valgrind on 'menuconfig' (ARCH=x86) before the fix:
    
            LEAK SUMMARY:
               definitely lost: 1,608 bytes in 67 blocks
               ...
    
    Summary after the fix:
    
            LEAK SUMMARY:
               definitely lost: 0 bytes in 0 blocks
               ...
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 5b2415991c3e..41c79bef3d07 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -408,6 +408,9 @@ void menu_finalize(struct menu *parent)
 			}
 		}
 
+		if (sym && sym_is_choice(sym))
+			expr_free(parentdep);
+
 		/*
 		 * Recursively process children in the same fashion before
 		 * moving on

commit ae7440ef0c8013d68c00dad6900e7cce5311bb1c
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Sun Oct 8 19:35:44 2017 +0200

    kconfig: Fix automatic menu creation mem leak
    
    expr_trans_compare() always allocates and returns a new expression,
    giving the following leak outline:
    
            ...
            *Allocate*
            basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
            ...
            for (menu = parent->next; menu; menu = menu->next) {
                    ...
                    *Copy*
                    dep2 = expr_copy(basedep);
                    ...
                    *Free copy*
                    expr_free(dep2);
            }
            *basedep lost!*
    
    Fix by freeing 'basedep' after the loop.
    
    Summary from Valgrind on 'menuconfig' (ARCH=x86) before the fix:
    
            LEAK SUMMARY:
               definitely lost: 344,376 bytes in 14,349 blocks
               ...
    
    Summary after the fix:
    
            LEAK SUMMARY:
               definitely lost: 44,448 bytes in 1,852 blocks
               ...
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 2baebe346de9..5b2415991c3e 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -440,6 +440,7 @@ void menu_finalize(struct menu *parent)
 			menu->parent = parent;
 			last_menu = menu;
 		}
+		expr_free(basedep);
 		if (last_menu) {
 			parent->list = parent->next;
 			parent->next = last_menu->next;

commit f77850d3fe0c962fa98dff5a690723c0883a530b
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Thu Oct 5 14:01:15 2017 +0200

    kconfig: Clean up modules handling and fix crash
    
    Kconfig currently doesn't handle 'm' appearing in a Kconfig file before
    the modules symbol is defined (the symbol with 'option modules'). The
    problem is the following code, which runs during parsing:
    
            /* change 'm' into 'm' && MODULES */
            if (e->left.sym == &symbol_mod)
                    return expr_alloc_and(e, expr_alloc_symbol(modules_sym));
    
    If the modules symbol has not yet been defined, modules_sym is NULL,
    giving an invalid expression.
    
    Here is a test file where both BEFORE_1 and BEFORE_2 trigger a segfault.
    If the modules symbol is removed, all symbols trigger segfaults.
    
            config BEFORE_1
                    def_tristate y if m
    
            if m
            config BEFORE_2
                    def_tristate y
            endif
    
            config MODULES
                    def_bool y
                    option modules
    
            config AFTER_1
                    def_tristate y if m
    
            if m
            config AFTER_2
                    def_tristate y
            endif
    
    Fix the issue by rewriting 'm' in menu_finalize() instead. This function
    runs after parsing and is the proper place to do it. The following
    existing code in conf_parse() in zconf.y ensures that the modules symbol
    exists at that point:
    
            if (!modules_sym)
                    modules_sym = sym_find( "n" );
    
            ...
    
            menu_finalize(&rootmenu);
    
    The following tests were done to ensure no functional changes for
    configurations that don't reference 'm' before the modules symbol:
    
            - zconfdump(stdout) was run with ARCH=x86 and ARCH=arm before
              and after the change and verified to produce identical output.
              This function prints all symbols, choices, and menus together
              with their properties and their dependency expressions. A
              rewritten 'm' appears as 'm && MODULES'.
    
              A small annoyance is that the assert(len != 0) in xfwrite()
              needs to be disabled in order to use zconfdump(), because it
              chokes on e.g. 'default ""'.
    
            - The Kconfiglib test suite was run to indirectly verify that
              alldefconfig, allyesconfig, allnoconfig, and all defconfigs in
              the kernel still generate the same final .config.
    
            - Valgrind was used to check for memory errors and (new) memory
              leaks.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index c8cec26c2535..2baebe346de9 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -110,7 +110,7 @@ static struct expr *rewrite_m(struct expr *e)
 
 void menu_add_dep(struct expr *dep)
 {
-	current_entry->dep = expr_alloc_and(current_entry->dep, rewrite_m(dep));
+	current_entry->dep = expr_alloc_and(current_entry->dep, dep);
 }
 
 void menu_set_type(int type)
@@ -135,7 +135,7 @@ static struct property *menu_add_prop(enum prop_type type, char *prompt, struct
 
 	prop->menu = current_entry;
 	prop->expr = expr;
-	prop->visible.expr = rewrite_m(dep);
+	prop->visible.expr = dep;
 
 	if (prompt) {
 		if (isspace(*prompt)) {
@@ -340,7 +340,8 @@ void menu_finalize(struct menu *parent)
 			 * Propagate parent dependencies to the child menu
 			 * node, also rewriting and simplifying expressions
 			 */
-			basedep = expr_transform(menu->dep);
+			basedep = rewrite_m(menu->dep);
+			basedep = expr_transform(basedep);
 			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
 			basedep = expr_eliminate_dups(basedep);
 			menu->dep = basedep;
@@ -383,7 +384,8 @@ void menu_finalize(struct menu *parent)
 				 * property's condition, rewriting and
 				 * simplifying expressions at the same time
 				 */
-				dep = expr_transform(prop->visible.expr);
+				dep = rewrite_m(prop->visible.expr);
+				dep = expr_transform(dep);
 				dep = expr_alloc_and(expr_copy(basedep), dep);
 				dep = expr_eliminate_dups(dep);
 				if (menu->sym && menu->sym->type != S_TRISTATE)

commit fa8cedaef814ceced8b55e0d2bbd404ccbc2b786
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Thu Oct 5 14:01:14 2017 +0200

    kconfig: Clarify expression rewriting
    
    menu_finalize() is one of the more opaque parts of Kconfig, and I need
    to make some changes to it to fix an issue related to modules. Add some
    comments related to expression rewriting and dependency propagation as a
    review aid. They will also help other people trying to understand the
    code.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 912c77645583..c8cec26c2535 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -306,6 +306,11 @@ void menu_finalize(struct menu *parent)
 
 	sym = parent->sym;
 	if (parent->list) {
+		/*
+		 * This menu node has children. We (recursively) process them
+		 * and propagate parent dependencies before moving on.
+		 */
+
 		if (sym && sym_is_choice(sym)) {
 			if (sym->type == S_UNKNOWN) {
 				/* find the first choice value to find out choice type */
@@ -329,24 +334,66 @@ void menu_finalize(struct menu *parent)
 		else
 			parentdep = parent->dep;
 
+		/* For each child menu node... */
 		for (menu = parent->list; menu; menu = menu->next) {
+			/*
+			 * Propagate parent dependencies to the child menu
+			 * node, also rewriting and simplifying expressions
+			 */
 			basedep = expr_transform(menu->dep);
 			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
 			basedep = expr_eliminate_dups(basedep);
 			menu->dep = basedep;
+
 			if (menu->sym)
+				/*
+				 * Note: For symbols, all prompts are included
+				 * too in the symbol's own property list
+				 */
 				prop = menu->sym->prop;
 			else
+				/*
+				 * For non-symbol menu nodes, we just need to
+				 * handle the prompt
+				 */
 				prop = menu->prompt;
+
+			/* For each property... */
 			for (; prop; prop = prop->next) {
 				if (prop->menu != menu)
+					/*
+					 * Two possibilities:
+					 *
+					 * 1. The property lacks dependencies
+					 *    and so isn't location-specific,
+					 *    e.g. an 'option'
+					 *
+					 * 2. The property belongs to a symbol
+					 *    defined in multiple locations and
+					 *    is from some other location. It
+					 *    will be handled there in that
+					 *    case.
+					 *
+					 * Skip the property.
+					 */
 					continue;
+
+				/*
+				 * Propagate parent dependencies to the
+				 * property's condition, rewriting and
+				 * simplifying expressions at the same time
+				 */
 				dep = expr_transform(prop->visible.expr);
 				dep = expr_alloc_and(expr_copy(basedep), dep);
 				dep = expr_eliminate_dups(dep);
 				if (menu->sym && menu->sym->type != S_TRISTATE)
 					dep = expr_trans_bool(dep);
 				prop->visible.expr = dep;
+
+				/*
+				 * Handle selects and implies, which modify the
+				 * dependencies of the selected/implied symbol
+				 */
 				if (prop->type == P_SELECT) {
 					struct symbol *es = prop_get_symbol(prop);
 					es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,
@@ -358,6 +405,11 @@ void menu_finalize(struct menu *parent)
 				}
 			}
 		}
+
+		/*
+		 * Recursively process children in the same fashion before
+		 * moving on
+		 */
 		for (menu = parent->list; menu; menu = menu->next)
 			menu_finalize(menu);
 	} else if (sym) {

commit 9a826842ff2fbd200561d3c1e81ca34eab6bfbbb
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Thu Oct 5 14:01:13 2017 +0200

    kconfig: Rename menu_check_dep() to rewrite_m()
    
    More directly describes the only thing it does.
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index ce88de89f146..912c77645583 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -79,19 +79,23 @@ void menu_end_menu(void)
 	current_menu = current_menu->parent;
 }
 
-static struct expr *menu_check_dep(struct expr *e)
+/*
+ * Rewrites 'm' to 'm' && MODULES, so that it evaluates to 'n' when running
+ * without modules
+ */
+static struct expr *rewrite_m(struct expr *e)
 {
 	if (!e)
 		return e;
 
 	switch (e->type) {
 	case E_NOT:
-		e->left.expr = menu_check_dep(e->left.expr);
+		e->left.expr = rewrite_m(e->left.expr);
 		break;
 	case E_OR:
 	case E_AND:
-		e->left.expr = menu_check_dep(e->left.expr);
-		e->right.expr = menu_check_dep(e->right.expr);
+		e->left.expr = rewrite_m(e->left.expr);
+		e->right.expr = rewrite_m(e->right.expr);
 		break;
 	case E_SYMBOL:
 		/* change 'm' into 'm' && MODULES */
@@ -106,7 +110,7 @@ static struct expr *menu_check_dep(struct expr *e)
 
 void menu_add_dep(struct expr *dep)
 {
-	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
+	current_entry->dep = expr_alloc_and(current_entry->dep, rewrite_m(dep));
 }
 
 void menu_set_type(int type)
@@ -131,7 +135,7 @@ static struct property *menu_add_prop(enum prop_type type, char *prompt, struct
 
 	prop->menu = current_entry;
 	prop->expr = expr;
-	prop->visible.expr = menu_check_dep(dep);
+	prop->visible.expr = rewrite_m(dep);
 
 	if (prompt) {
 		if (isspace(*prompt)) {

commit 2c37e08464a8500b69a6c0be18d159bd1a312620
Author: Ulf Magnusson <ulfalizer@gmail.com>
Date:   Wed Oct 4 01:25:46 2017 +0200

    kconfig: Warn if choice default is not in choice
    
    This will catch mistakes like in the following real-world example, where
    a "CONFIG_" prefix snuck in, making an undefined symbol the default:
    
            choice
                    prompt "Compiler optimization level"
                    default CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE
    
            config CC_OPTIMIZE_FOR_PERFORMANCE
                    ...
    
            config CC_OPTIMIZE_FOR_SIZE
                    ...
    
            endchoice
    
    This now prints the following warning:
    
            init/Kconfig:1036:warning: choice default symbol 'CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE' is not contained in the choice
    
    Cases where the default symbol belongs to the wrong choice are also
    detected.
    
    (The mistake is harmless here: Since the default symbol is not visible,
    the choice falls back on using the first visible symbol as the default,
    which is CC_OPTIMIZE_FOR_PERFORMANCE, as intended.)
    
    Discovered while playing around with Kconfiglib
    (https://github.com/ulfalizer/Kconfiglib).
    
    Signed-off-by: Ulf Magnusson <ulfalizer@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index e9357931b47d..ce88de89f146 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -252,6 +252,16 @@ static void sym_check_prop(struct symbol *sym)
 					    "'%s': number is invalid",
 					    sym->name);
 			}
+			if (sym_is_choice(sym)) {
+				struct property *choice_prop =
+					sym_get_choice_prop(sym2);
+
+				if (!choice_prop ||
+				    prop_get_symbol(choice_prop) != sym)
+					prop_warn(prop,
+						  "choice default symbol '%s' is not contained in the choice",
+						  sym2->name);
+			}
 			break;
 		case P_SELECT:
 		case P_IMPLY:

commit 237e3ad0f195d8fd34f1299e45f04793832a16fc
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Nov 11 00:10:05 2016 -0500

    Kconfig: Introduce the "imply" keyword
    
    The "imply" keyword is a weak version of "select" where the target
    config symbol can still be turned off, avoiding those pitfalls that come
    with the "select" keyword.
    
    This is useful e.g. with multiple drivers that want to indicate their
    ability to hook into a secondary subsystem while allowing the user to
    configure that subsystem out without also having to unset these drivers.
    
    Currently, the same effect can almost be achieved with:
    
    config DRIVER_A
            tristate
    
    config DRIVER_B
            tristate
    
    config DRIVER_C
            tristate
    
    config DRIVER_D
            tristate
    
    [...]
    
    config SUBSYSTEM_X
            tristate
            default DRIVER_A || DRIVER_B || DRIVER_C || DRIVER_D || [...]
    
    This is unwieldy to maintain especially with a large number of drivers.
    Furthermore, there is no easy way to restrict the choice for SUBSYSTEM_X
    to y or n, excluding m, when some drivers are built-in. The "select"
    keyword allows for excluding m, but it excludes n as well. Hence
    this "imply" keyword.  The above becomes:
    
    config DRIVER_A
            tristate
            imply SUBSYSTEM_X
    
    config DRIVER_B
            tristate
            imply SUBSYSTEM_X
    
    [...]
    
    config SUBSYSTEM_X
            tristate
    
    This is much cleaner, and way more flexible than "select". SUBSYSTEM_X
    can still be configured out, and it can be set as a module when none of
    the drivers are configured in or all of them are modular.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-2-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index aed678e8a777..e9357931b47d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -233,6 +233,8 @@ static void sym_check_prop(struct symbol *sym)
 {
 	struct property *prop;
 	struct symbol *sym2;
+	char *use;
+
 	for (prop = sym->prop; prop; prop = prop->next) {
 		switch (prop->type) {
 		case P_DEFAULT:
@@ -252,18 +254,20 @@ static void sym_check_prop(struct symbol *sym)
 			}
 			break;
 		case P_SELECT:
+		case P_IMPLY:
+			use = prop->type == P_SELECT ? "select" : "imply";
 			sym2 = prop_get_symbol(prop);
 			if (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)
 				prop_warn(prop,
-				    "config symbol '%s' uses select, but is "
-				    "not boolean or tristate", sym->name);
+				    "config symbol '%s' uses %s, but is "
+				    "not boolean or tristate", sym->name, use);
 			else if (sym2->type != S_UNKNOWN &&
 				 sym2->type != S_BOOLEAN &&
 				 sym2->type != S_TRISTATE)
 				prop_warn(prop,
-				    "'%s' has wrong type. 'select' only "
+				    "'%s' has wrong type. '%s' only "
 				    "accept arguments of boolean and "
-				    "tristate type", sym2->name);
+				    "tristate type", sym2->name, use);
 			break;
 		case P_RANGE:
 			if (sym->type != S_INT && sym->type != S_HEX)
@@ -333,6 +337,10 @@ void menu_finalize(struct menu *parent)
 					struct symbol *es = prop_get_symbol(prop);
 					es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,
 							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
+				} else if (prop->type == P_IMPLY) {
+					struct symbol *es = prop_get_symbol(prop);
+					es->implied.expr = expr_alloc_or(es->implied.expr,
+							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
 				}
 			}
 		}
@@ -612,13 +620,30 @@ static struct property *get_symbol_prop(struct symbol *sym)
 	return prop;
 }
 
+static void get_symbol_props_str(struct gstr *r, struct symbol *sym,
+				 enum prop_type tok, const char *prefix)
+{
+	bool hit = false;
+	struct property *prop;
+
+	for_all_properties(sym, prop, tok) {
+		if (!hit) {
+			str_append(r, prefix);
+			hit = true;
+		} else
+			str_printf(r, " && ");
+		expr_gstr_print(prop->expr, r);
+	}
+	if (hit)
+		str_append(r, "\n");
+}
+
 /*
  * head is optional and may be NULL
  */
 static void get_symbol_str(struct gstr *r, struct symbol *sym,
 		    struct list_head *head)
 {
-	bool hit;
 	struct property *prop;
 
 	if (sym && sym->name) {
@@ -648,22 +673,20 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym,
 		}
 	}
 
-	hit = false;
-	for_all_properties(sym, prop, P_SELECT) {
-		if (!hit) {
-			str_append(r, "  Selects: ");
-			hit = true;
-		} else
-			str_printf(r, " && ");
-		expr_gstr_print(prop->expr, r);
-	}
-	if (hit)
-		str_append(r, "\n");
+	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
 	if (sym->rev_dep.expr) {
 		str_append(r, _("  Selected by: "));
 		expr_gstr_print(sym->rev_dep.expr, r);
 		str_append(r, "\n");
 	}
+
+	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
+	if (sym->implied.expr) {
+		str_append(r, _("  Implied by: "));
+		expr_gstr_print(sym->implied.expr, r);
+		str_append(r, "\n");
+	}
+
 	str_append(r, "\n\n");
 }
 

commit aab24a897cfba9dd371f6aac45dbcdae0b23def6
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Fri Jan 1 17:34:05 2016 +0100

    kconfig: return 'false' instead of 'no' in bool function
    
    menu_is_visible() is a bool function and should use boolean return
    values. "no" is a tristate value which happens to also have a value
    of 0, but we should nevertheless use the right symbol for it.
    
    This is a very minor cleanup with no semantic change.
    
    Fixes: 86e187ff9 ("kconfig: add an option to determine a menu's visibility")
    Cc: Arnaud Lacombe <lacombar@gmail.com>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b05cc3d4a9be..aed678e8a777 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -477,7 +477,7 @@ bool menu_is_visible(struct menu *menu)
 
 	if (menu->visibility) {
 		if (expr_calc_value(menu->visibility) == no)
-			return no;
+			return false;
 	}
 
 	sym = menu->sym;

commit ad8d40cda3ad22ad9e8863d55a5c88f85c0173f0
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Feb 24 16:37:13 2015 +0100

    kconfig: Remove unnecessary prototypes from headers
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 72c9dba84c5d..b05cc3d4a9be 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -125,7 +125,7 @@ void menu_set_type(int type)
 		sym_type_name(sym->type), sym_type_name(type));
 }
 
-struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)
+static struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)
 {
 	struct property *prop = prop_alloc(type, current_entry->sym);
 
@@ -615,7 +615,7 @@ static struct property *get_symbol_prop(struct symbol *sym)
 /*
  * head is optional and may be NULL
  */
-void get_symbol_str(struct gstr *r, struct symbol *sym,
+static void get_symbol_str(struct gstr *r, struct symbol *sym,
 		    struct list_head *head)
 {
 	bool hit;

commit 2d560306096739e2251329ab5c16059311a151b0
Author: Peter Kmmel <syntheticpp@gmx.net>
Date:   Tue Nov 4 12:01:59 2014 +0100

    kconfig: Fix warning "jump may be used uninitialized"
    
    Warning:
    In file included from scripts/kconfig/zconf.tab.c:2537:0:
    scripts/kconfig/menu.c: In function get_symbol_str:
    scripts/kconfig/menu.c:590:18: warning: jump may be used uninitialized in this function [-Wmaybe-uninitialized]
         jump->offset = strlen(r->s);
    
    Simplifies the test logic because (head && local) means (jump != 0)
    and makes GCC happy when checking if the jump pointer was initialized.
    
    Signed-off-by: Peter Kmmel <syntheticpp@gmx.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index a26cc5d2a9b0..72c9dba84c5d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -548,7 +548,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 {
 	int i, j;
 	struct menu *submenu[8], *menu, *location = NULL;
-	struct jump_key *jump;
+	struct jump_key *jump = NULL;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
 	menu = prop->menu->parent;
@@ -586,7 +586,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 		str_printf(r, _("  Location:\n"));
 		for (j = 4; --i >= 0; j += 2) {
 			menu = submenu[i];
-			if (head && location && menu == location)
+			if (jump && menu == location)
 				jump->offset = strlen(r->s);
 			str_printf(r, "%*c-> %s", j, ' ',
 				   _(menu_get_prompt(menu)));

commit bb66fc67192bbd406fe9c22033f1bbbf3e7ec621
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jun 10 19:08:13 2014 +0900

    kbuild: trivial - use tabs for code indent where possible
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 3ac2c9c6e280..a26cc5d2a9b0 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -258,8 +258,8 @@ static void sym_check_prop(struct symbol *sym)
 				    "config symbol '%s' uses select, but is "
 				    "not boolean or tristate", sym->name);
 			else if (sym2->type != S_UNKNOWN &&
-			         sym2->type != S_BOOLEAN &&
-			         sym2->type != S_TRISTATE)
+				 sym2->type != S_BOOLEAN &&
+				 sym2->type != S_TRISTATE)
 				prop_warn(prop,
 				    "'%s' has wrong type. 'select' only "
 				    "accept arguments of boolean and "
@@ -268,7 +268,7 @@ static void sym_check_prop(struct symbol *sym)
 		case P_RANGE:
 			if (sym->type != S_INT && sym->type != S_HEX)
 				prop_warn(prop, "range is only allowed "
-				                "for int or hex symbols");
+						"for int or hex symbols");
 			if (!menu_validate_number(sym, prop->expr->left.sym) ||
 			    !menu_validate_number(sym, prop->expr->right.sym))
 				prop_warn(prop, "range is invalid");

commit 5d2acfc7b974bbd3858b4dd3f2cdc6362dd8843a
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Mon Apr 7 15:39:09 2014 -0700

    kconfig: make allnoconfig disable options behind EMBEDDED and EXPERT
    
    "make allnoconfig" exists to ease testing of minimal configurations.
    Documentation/SubmitChecklist includes a note to test with allnoconfig.
    This helps catch missing dependencies on common-but-not-required
    functionality, which might otherwise go unnoticed.
    
    However, allnoconfig still leaves many symbols enabled, because they're
    hidden behind CONFIG_EMBEDDED or CONFIG_EXPERT.  For instance, allnoconfig
    still has CONFIG_PRINTK and CONFIG_BLOCK enabled, so drivers don't
    typically get build-tested with those disabled.
    
    To address this, introduce a new Kconfig option "allnoconfig_y", used on
    symbols which only exist to hide other symbols.  Set it on CONFIG_EMBEDDED
    (which then selects CONFIG_EXPERT).  allnoconfig will then disable all the
    symbols hidden behind those.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Tested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index db1512ae30cc..3ac2c9c6e280 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -217,6 +217,9 @@ void menu_add_option(int token, char *arg)
 	case T_OPT_ENV:
 		prop_add_env(arg);
 		break;
+	case T_OPT_ALLNOCONFIG_Y:
+		current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;
+		break;
 	}
 }
 

commit 503c823048e81cc85c0e9d8c297cc70203e335e5
Author: Martin Walch <walch.martin@web.de>
Date:   Thu Oct 3 18:35:16 2013 +0200

    kconfig: fix bug in search results string: use strlen(gstr->s), not gstr->len
    
    The struct gstr has a capacity that may differ from the actual string length.
    
    However, a string manipulation in the function search_conf made the assumption
    that it is the same, which led to messing up some search results, especially
    when the content of the gstr in use had not yet reached at least 63 chars.
    
    Signed-off-by: Martin Walch <walch.martin@web.de>
    Acked-by: Wang YanQing <udknight@gmail.com>
    Acked-by: Benjamin Poirier <bpoirier@suse.de>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 9e69f1934836..db1512ae30cc 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -584,7 +584,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 		for (j = 4; --i >= 0; j += 2) {
 			menu = submenu[i];
 			if (head && location && menu == location)
-				jump->offset = r->len - 1;
+				jump->offset = strlen(r->s);
 			str_printf(r, "%*c-> %s", j, ' ',
 				   _(menu_get_prompt(menu)));
 			if (menu->sym) {

commit 57540f1dea6580fda0debaf3704d1b0e928a120e
Author: Martin Walch <walch.martin@web.de>
Date:   Thu Oct 3 18:32:02 2013 +0200

    kconfig: adjust warning message for conflicting types
    
    Each symbol must have exactly one type assigned. However, if a symbol happens
    to have two different types assigned at runtime, a warning is printed and the
    first type is preserved while the second type is being ignored.
    
    The warning message says
    
    type of <symbol name> redefined from <first type> to <second type>
    
    which may be misleading as it may create the impression that the second type
    replaces the first type.
    
    This patch clarifies this by changing the warning to
    
    ignoring type redefinition of <symbol name> from <first type> to <second type>
    
    Signed-off-by: Martin Walch <walch.martin@web.de>
    Acked-by: Wang YanQing <udknight@gmail.com>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b9701010de8c..9e69f1934836 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -119,9 +119,10 @@ void menu_set_type(int type)
 		sym->type = type;
 		return;
 	}
-	menu_warn(current_entry, "type of '%s' redefined from '%s' to '%s'",
-	    sym->name ? sym->name : "<choice>",
-	    sym_type_name(sym->type), sym_type_name(type));
+	menu_warn(current_entry,
+		"ignoring type redefinition of '%s' from '%s' to '%s'",
+		sym->name ? sym->name : "<choice>",
+		sym_type_name(sym->type), sym_type_name(type));
 }
 
 struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)

commit 8d9dfe8276750aaf30ca1b59b4c3f9349377cb6e
Author: Martin Walch <walch.martin@web.de>
Date:   Thu Oct 3 17:28:14 2013 +0200

    kconfig: fix trivial typos and update mconf documentation
    
    This fixes lots of typos in comments and strings.
    
    It also updates the documentation strings in mconf to reflect the changes in
    the user interface from the two commits
    
    6364fd0cb1e4c7f72b974613e0cf5744ae4d2cb2
      menuconfig: Add Save/Load buttons
    1bdbac478a858d2aa73a6784c7c2e09de0f6d06b
      menuconfig: Get rid of the top-level entries for "Load an Alternate/Save an Alternate"
    
    And it updates the layout of the example search result, i. e. moves down the
    "Defined at" and "Depends on" lines and adds a symbol state ([=n]) to the
    symbol in the "Selected by" line.
    
    Furthermore, the help texts now should fit in 80 columns again when viewed
    in mconf.
    
    Signed-off-by: Martin Walch <walch.martin@web.de>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Wang YanQing <udknight@gmail.com>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index c1d53200c306..b9701010de8c 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -597,7 +597,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 }
 
 /*
- * get peoperty of type P_SYMBOL
+ * get property of type P_SYMBOL
  */
 static struct property *get_symbol_prop(struct symbol *sym)
 {

commit e062781397e5bebc6c1b8dd4bf466136e13ae4c5
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Sep 3 22:22:26 2013 +0200

    kconfig: do not allow more than one symbol to have 'option modules'
    
    Previously, it was possible to have more than one symbol with the
    'option modules' attached to them, although only the last one would
    in fact control tristates.
    
    Since this does not make much sense, only allow at most one symbol to
    control tristates.
    
    Note: it is still possible to have more than one symbol that control
    tristates, but indirectly:
    
        config MOD1
            bool "mod1"
            select MODULES
        config MOD2
            bool "mod2"
            select MODULES
        config MODULES
            bool
            option modules
    
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 3a9c67493260..c1d53200c306 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -199,6 +199,12 @@ void menu_add_option(int token, char *arg)
 {
 	switch (token) {
 	case T_OPT_MODULES:
+		if (modules_sym)
+			zconf_error("symbol '%s' redefines option 'modules'"
+				    " already defined by symbol '%s'",
+				    current_entry->sym->name,
+				    modules_sym->name
+				    );
 		modules_sym = current_entry->sym;
 		break;
 	case T_OPT_DEFCONFIG_LIST:

commit 6902dccfda005fa4c42410fa064fdd331ab42479
Author: Yann E. MORIN <yann.morin.1998@free.fr>
Date:   Tue Sep 3 17:07:18 2013 +0200

    kconfig: do not special-case 'MODULES' symbol
    
    Currently, the 'MODULES' symbol is hard-coded to be the default symbol
    that enables/disables tristates, if no other symbol was declared with
    'option modules'.
    
    While this used to be needed for the Linux kernel, we now have an
    explicit 'option modules' attached to the 'MODULES' symbol (since
    cset 11097a036), so we no longer need to special-case it in the
    kconfig code.
    
    Furthermore, kconfig is extensively used out of the Linux kernel, and
    other projects may have another meaning for a symbol named 'MODULES'.
    
    This patch changes the way we enable/disable tristates: if a symbol was
    found with 'option modules' attached to it, then that symbol controls
    enabling tristates. Otherwise, tristates are disabled, even if a symbol
    named 'MODULES' exists.
    
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7e233a6ca64e..3a9c67493260 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -197,12 +197,9 @@ void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 
 void menu_add_option(int token, char *arg)
 {
-	struct property *prop;
-
 	switch (token) {
 	case T_OPT_MODULES:
-		prop = prop_alloc(P_DEFAULT, modules_sym);
-		prop->expr = expr_alloc_symbol(current_entry->sym);
+		modules_sym = current_entry->sym;
 		break;
 	case T_OPT_DEFCONFIG_LIST:
 		if (!sym_defconfig_list)

commit b202c0d5205662fd96f7151afa83f891f2f4d542
Merge: cb63fc26623e b57caaaed2bd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 16:06:46 2013 -0700

    Merge branch 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kconfig updates from Michal Marek:
     - dependency solver fix for make defconfig
     - randconfig fixes, one of which had to be reverted again
     - more user-friendly sorting of search results
     - hex and range keywords support longs
     - fix for [mn]conf not to rely on particular behavior of the LINES and
       COLS variables
     - cleanup of magic constants in kconfig/lxdialog
     - [mn]conf formatting fixes
     - fix for scripts/config's help text in out-of-tree usage (under a
       different name)
    
    * 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      kconfig: allow "hex" and "range" to support longs
      Revert "kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG"
      kconfig: fix randomising choice entries in presence of KCONFIG_ALLCONFIG
      kconfig: loop as long as we changed some symbols in randconfig
      kconfig/[mn]conf: make it explicit in the search box that a regexp is possible
      kconfig: sort found symbols by relevance
      kconfig/conf: print the seed used to initialise the RNG for randconfig
      kconfig/conf: accept a base-16 seed for randconfig
      kconfig/conf: fix randconfig setting multiple symbols in a choice
      scripts/config: replace hard-coded script name by a dynamic value
      mconf/nconf: mark empty menus/menuconfigs different from non-empty ones
      nconf: use function calls instead of ncurses' variables LINES and COLS
      mconf: use function calls instead of ncurses' variables LINES and COLS
      kconfig/lxdialog: handle newline characters in print_autowrap()
      kconfig/lxdialog: Use new mininimum resize definitions in conf_choice()
      kconfig/lxdialog: Add definitions for mininimum (re)size values
      kconfig: Fix defconfig when one choice menu selects options that another choice menu depends on

commit 1278ebdbc3167883f32095491990fbdc7cdf8b5e
Author: Dirk Gouders <dirk@gouders.net>
Date:   Sun May 19 21:49:34 2013 +0200

    mconf/nconf: mark empty menus/menuconfigs different from non-empty ones
    
    Submenus are sometimes empty and it would be nice if there is
    something that notifies us that we should not expect any content
    _before_ we enter a submenu.
    
    A new function menu_is_empty() was introduced and empty menus and
    menuconfigs are now marked by "----" as opposed to non-empty ones that
    are marked by "--->".
    
    This scheme was suggested by "Yann E. MORIN" <yann.morin.1998@free.fr>.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b5c7d90df9df..6d11c8f63eb0 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -430,6 +430,22 @@ bool menu_has_prompt(struct menu *menu)
 	return true;
 }
 
+/*
+ * Determine if a menu is empty.
+ * A menu is considered empty if it contains no or only
+ * invisible entries.
+ */
+bool menu_is_empty(struct menu *menu)
+{
+	struct menu *child;
+
+	for (child = menu->list; child; child = child->next) {
+		if (menu_is_visible(child))
+			return(false);
+	}
+	return(true);
+}
+
 bool menu_is_visible(struct menu *menu)
 {
 	struct menu *child;

commit e983b7b17ad1a978e954e6aaa62cf12bfc747883
Author: Dirk Gouders <dirk@gouders.net>
Date:   Tue May 21 10:54:11 2013 +0200

    kconfig/menu.c: fix multiple references to expressions in menu_add_prop()
    
    menu_add_prop() applies upper menus' visibilities to actual prompts
    by AND-ing the prompts visibilities with the upper menus ones.
    
    This creates a further reference to the menu's visibilities and when
    the expression reduction functions do their work, they may remove or
    modify expressions that have multiple references, thus causing
    unpredictable side-effects.
    
    The following example Kconfig constructs a case where this causes
    problems: a menu and a prompt which's visibilities depend on the same
    symbol.  When invoking mconf with this Kconfig and pressing "Z" we
    see a problem caused by a free'd expression still referenced by the
    menu's visibility:
    
    ------------------------------------------------------------------------
    mainmenu "Kconfig Testing Configuration"
    
    config VISIBLE
            def_bool n
    
    config Placeholder
            bool "Place holder"
    
    menu "Invisible"
            visible if VISIBLE
    
    config TEST_VAR
            bool "Test option" if VISIBLE
    
    endmenu
    ------------------------------------------------------------------------
    
    This patch fixes this problem by creating copies of the menu's
    visibility expressions before AND-ing them with the prompt's one.
    
    Signed-off-by: Dirk Gouders <dirk@gouders.net>
    [yann.morin.1998@free.fr: move variable into its block-scope,
                              keep lines <80 chars, typo]
    Tested-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b5c7d90df9df..fd3f0180e08f 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -146,11 +146,24 @@ struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *e
 			struct menu *menu = current_entry;
 
 			while ((menu = menu->parent) != NULL) {
+				struct expr *dup_expr;
+
 				if (!menu->visibility)
 					continue;
+				/*
+				 * Do not add a reference to the
+				 * menu's visibility expression but
+				 * use a copy of it.  Otherwise the
+				 * expression reduction functions
+				 * will modify expressions that have
+				 * multiple references which can
+				 * cause unwanted side effects.
+				 */
+				dup_expr = expr_copy(menu->visibility);
+
 				prop->visible.expr
 					= expr_alloc_and(prop->visible.expr,
-							 menu->visibility);
+							 dup_expr);
 			}
 		}
 

commit 383da76f5261637b8beacb99a83f5834b14fc432
Author: Li Zefan <lizefan@huawei.com>
Date:   Tue May 7 15:56:54 2013 +0200

    menuconfig: fix NULL pointer dereference when searching a symbol
    
    Searching for PPC_EFIKA results in a segmentation fault, and it's
    because get_symbol_prop() returns NULL.
    
    In this case CONFIG_PPC_EFIKA is defined in arch/powerpc/platforms/
    52xx/Kconfig, so it won't be parsed if ARCH!=PPC, but menuconfig knows
    this symbol when it parses sound/soc/fsl/Kconfig:
    
        config SND_MPC52xx_SOC_EFIKA
            tristate "SoC AC97 Audio support for bbplan Efika and STAC9766"
            depends on PPC_EFIKA
    
    This bug was introduced by commit bcdedcc1afd6 ("menuconfig: print more
    info for symbol without prompts").
    
    Reported-and-tested-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Tested-by: Libo Chen <libo.chen@huawei.com>
    Reviewed-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 826da662886d..b5c7d90df9df 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -600,14 +600,18 @@ void get_symbol_str(struct gstr *r, struct symbol *sym,
 	}
 	for_all_prompts(sym, prop)
 		get_prompt_str(r, prop, head);
+
 	prop = get_symbol_prop(sym);
-	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
-		prop->menu->lineno);
-	if (!expr_is_yes(prop->visible.expr)) {
-		str_append(r, _("  Depends on: "));
-		expr_gstr_print(prop->visible.expr, r);
-		str_append(r, "\n");
+	if (prop) {
+		str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
+			prop->menu->lineno);
+		if (!expr_is_yes(prop->visible.expr)) {
+			str_append(r, _("  Depends on: "));
+			expr_gstr_print(prop->visible.expr, r);
+			str_append(r, "\n");
+		}
 	}
+
 	hit = false;
 	for_all_properties(sym, prop, P_SELECT) {
 		if (!hit) {

commit bcdedcc1afd6ac91e15cb90aedaf8432f62fed13
Author: Wengmeiling <wengmeiling.weng@huawei.com>
Date:   Tue Apr 30 15:28:46 2013 -0700

    menuconfig: print more info for symbol without prompts
    
    When we search a config symbol, if it has no prompt the position of this
    symbol in the Kconfig file and it's dependencies are not printed.  This
    can be inconvenient, especially when it's set to n and we want to find out
    why.
    
    the following is an example:
    
    before:
    
    Symbol: GENERIC_SMP_IDLE_THREAD [=y]
    Type  : boolean
      Selected by: X86 [=y]
    
    after:
    
    Symbol: GENERIC_SMP_IDLE_THREAD [=y]
    Type  : boolean
      Defined at arch/Kconfig:213
      Selected by: X86 [=y]
    
    Signed-off-by: Weng Meiling <wengmeiling.weng@huawei.com>
    Signed-off-by: Libo Chen <libo.chen@huawei.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index f3bffa309333..826da662886d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -515,13 +515,6 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	struct jump_key *jump;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
-	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
-		prop->menu->lineno);
-	if (!expr_is_yes(prop->visible.expr)) {
-		str_append(r, _("  Depends on: "));
-		expr_gstr_print(prop->visible.expr, r);
-		str_append(r, "\n");
-	}
 	menu = prop->menu->parent;
 	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
 		bool accessible = menu_is_visible(menu);
@@ -571,6 +564,18 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 	}
 }
 
+/*
+ * get peoperty of type P_SYMBOL
+ */
+static struct property *get_symbol_prop(struct symbol *sym)
+{
+	struct property *prop = NULL;
+
+	for_all_properties(sym, prop, P_SYMBOL)
+		break;
+	return prop;
+}
+
 /*
  * head is optional and may be NULL
  */
@@ -595,6 +600,14 @@ void get_symbol_str(struct gstr *r, struct symbol *sym,
 	}
 	for_all_prompts(sym, prop)
 		get_prompt_str(r, prop, head);
+	prop = get_symbol_prop(sym);
+	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
+		prop->menu->lineno);
+	if (!expr_is_yes(prop->visible.expr)) {
+		str_append(r, _("  Depends on: "));
+		expr_gstr_print(prop->visible.expr, r);
+		str_append(r, "\n");
+	}
 	hit = false;
 	for_all_properties(sym, prop, P_SELECT) {
 		if (!hit) {

commit e3900e74f26fc924c8e9e2a922bd40369b0bb517
Merge: 62dc989921df 02f3e53a131c
Author: Michal Marek <mmarek@suse.cz>
Date:   Mon Feb 25 21:50:05 2013 +0100

    Merge branch 'kbuild/rc-fixes' into kbuild/kconfig
    
    There is one kconfig fix in the rc-fixes branch that I forgot to submit
    for 3.8, so let's add it to the kconfig branch for 3.9-rc1.

commit 177acf78468bf5c359bcb8823ee3bd48b04b8380
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Nov 6 14:32:08 2012 +0000

    kconfig: Fix malloc handling in conf tools
    
    (and get them out of the noise in the audit work)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index a3cade659f89..84a2ba2077aa 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -48,7 +48,7 @@ void menu_add_entry(struct symbol *sym)
 {
 	struct menu *menu;
 
-	menu = malloc(sizeof(*menu));
+	menu = xmalloc(sizeof(*menu));
 	memset(menu, 0, sizeof(*menu));
 	menu->sym = sym;
 	menu->parent = current_menu;
@@ -531,7 +531,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 			location = menu;
 	}
 	if (head && location) {
-		jump = malloc(sizeof(struct jump_key));
+		jump = xmalloc(sizeof(struct jump_key));
 
 		if (menu_is_visible(prop->menu)) {
 			/*

commit bad9955db1b73d7286f74a8136a0628a9b1ac017
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Sun Oct 21 05:27:53 2012 -0400

    menuconfig: Replace CIRCLEQ by list_head-style lists.
    
    sys/queue.h and CIRCLEQ in particular have proven to cause portability
    problems (reported on Debian Sarge, Cygwin and FreeBSD)
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Yaakov Selkowitz <yselkowitz@users.sourceforge.net>
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index a3cade659f89..e98a05c8e508 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -508,7 +508,7 @@ const char *menu_get_help(struct menu *menu)
 }
 
 static void get_prompt_str(struct gstr *r, struct property *prop,
-			   struct jk_head *head)
+			   struct list_head *head)
 {
 	int i, j;
 	struct menu *submenu[8], *menu, *location = NULL;
@@ -544,12 +544,13 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 		} else
 			jump->target = location;
 
-		if (CIRCLEQ_EMPTY(head))
+		if (list_empty(head))
 			jump->index = 0;
 		else
-			jump->index = CIRCLEQ_LAST(head)->index + 1;
+			jump->index = list_entry(head->prev, struct jump_key,
+						 entries)->index + 1;
 
-		CIRCLEQ_INSERT_TAIL(head, jump, entries);
+		list_add_tail(&jump->entries, head);
 	}
 
 	if (i > 0) {
@@ -573,7 +574,8 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 /*
  * head is optional and may be NULL
  */
-void get_symbol_str(struct gstr *r, struct symbol *sym, struct jk_head *head)
+void get_symbol_str(struct gstr *r, struct symbol *sym,
+		    struct list_head *head)
 {
 	bool hit;
 	struct property *prop;
@@ -612,7 +614,7 @@ void get_symbol_str(struct gstr *r, struct symbol *sym, struct jk_head *head)
 	str_append(r, "\n\n");
 }
 
-struct gstr get_relations_str(struct symbol **sym_arr, struct jk_head *head)
+struct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head)
 {
 	struct symbol *sym;
 	struct gstr res = str_new();

commit 95ac9b3b585d20df116c5bea1511d9eb5758ac81
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:08 2012 -0400

    menuconfig: Assign jump keys per-page instead of globally
    
    At the moment, keys 1-9 are assigned to the first 9 search results. This patch
    makes them assigned to the first 9 results per-page instead. We are much less
    likely to run out of keys that way.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index a5241859326a..a3cade659f89 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -507,12 +507,12 @@ const char *menu_get_help(struct menu *menu)
 		return "";
 }
 
-static int get_prompt_str(struct gstr *r, struct property *prop, struct menu
-			  **jumps, int jump_nb)
+static void get_prompt_str(struct gstr *r, struct property *prop,
+			   struct jk_head *head)
 {
 	int i, j;
-	char header[4];
 	struct menu *submenu[8], *menu, *location = NULL;
+	struct jump_key *jump;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
 	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
@@ -530,7 +530,9 @@ static int get_prompt_str(struct gstr *r, struct property *prop, struct menu
 		if (location == NULL && accessible)
 			location = menu;
 	}
-	if (jumps && jump_nb < JUMP_NB && location) {
+	if (head && location) {
+		jump = malloc(sizeof(struct jump_key));
+
 		if (menu_is_visible(prop->menu)) {
 			/*
 			 * There is not enough room to put the hint at the
@@ -538,19 +540,26 @@ static int get_prompt_str(struct gstr *r, struct property *prop, struct menu
 			 * last "Location" line even when it would belong on
 			 * the former.
 			 */
-			jumps[jump_nb] = prop->menu;
+			jump->target = prop->menu;
 		} else
-			jumps[jump_nb] = location;
-		snprintf(header, 4, "(%d)", jump_nb + 1);
-	} else
-		location = NULL;
+			jump->target = location;
+
+		if (CIRCLEQ_EMPTY(head))
+			jump->index = 0;
+		else
+			jump->index = CIRCLEQ_LAST(head)->index + 1;
+
+		CIRCLEQ_INSERT_TAIL(head, jump, entries);
+	}
 
 	if (i > 0) {
 		str_printf(r, _("  Location:\n"));
-		for (j = 1; --i >= 0; j += 2) {
+		for (j = 4; --i >= 0; j += 2) {
 			menu = submenu[i];
-			str_printf(r, "%s%*c-> %s", menu == location ? header
-				   : "   ", j, ' ', _(menu_get_prompt(menu)));
+			if (head && location && menu == location)
+				jump->offset = r->len - 1;
+			str_printf(r, "%*c-> %s", j, ' ',
+				   _(menu_get_prompt(menu)));
 			if (menu->sym) {
 				str_printf(r, " (%s [=%s])", menu->sym->name ?
 					menu->sym->name : _("<choice>"),
@@ -559,20 +568,15 @@ static int get_prompt_str(struct gstr *r, struct property *prop, struct menu
 			str_append(r, "\n");
 		}
 	}
-
-	return location ? 1 : 0;
 }
 
 /*
- * jumps is optional and may be NULL
- * returns the number of jumps inserted
+ * head is optional and may be NULL
  */
-int get_symbol_str(struct gstr *r, struct symbol *sym, struct menu **jumps,
-		   int jump_nb)
+void get_symbol_str(struct gstr *r, struct symbol *sym, struct jk_head *head)
 {
 	bool hit;
 	struct property *prop;
-	int i = 0;
 
 	if (sym && sym->name) {
 		str_printf(r, "Symbol: %s [=%s]\n", sym->name,
@@ -588,7 +592,7 @@ int get_symbol_str(struct gstr *r, struct symbol *sym, struct menu **jumps,
 		}
 	}
 	for_all_prompts(sym, prop)
-		i += get_prompt_str(r, prop, jumps, jump_nb + i);
+		get_prompt_str(r, prop, head);
 	hit = false;
 	for_all_properties(sym, prop, P_SELECT) {
 		if (!hit) {
@@ -606,18 +610,16 @@ int get_symbol_str(struct gstr *r, struct symbol *sym, struct menu **jumps,
 		str_append(r, "\n");
 	}
 	str_append(r, "\n\n");
-
-	return i;
 }
 
-struct gstr get_relations_str(struct symbol **sym_arr, struct menu **jumps)
+struct gstr get_relations_str(struct symbol **sym_arr, struct jk_head *head)
 {
 	struct symbol *sym;
 	struct gstr res = str_new();
-	int i, jump_nb = 0;
+	int i;
 
 	for (i = 0; sym_arr && (sym = sym_arr[i]); i++)
-		jump_nb += get_symbol_str(&res, sym, jumps, jump_nb);
+		get_symbol_str(&res, sym, head);
 	if (!i)
 		str_append(&res, _("No matches found.\n"));
 	return res;
@@ -636,5 +638,5 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 	}
 	str_printf(help, "%s\n", _(help_text));
 	if (sym)
-		get_symbol_str(help, sym, NULL, 0);
+		get_symbol_str(help, sym, NULL);
 }

commit 5e609addb1bd963ce1a1929f2012c8dd04ca8620
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Aug 23 14:55:06 2012 -0400

    menuconfig: Add jump keys to search results
    
    makes it possible to jump directly to the menu for a configuration entry after
    having searched for it with '/'. If this menu is not currently accessible we
    jump to the nearest accessible parent instead. After exiting this menu, the
    user is returned to the search results where he may jump further in or
    elsewhere.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 8c2a97e60faf..a5241859326a 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -507,10 +507,12 @@ const char *menu_get_help(struct menu *menu)
 		return "";
 }
 
-static void get_prompt_str(struct gstr *r, struct property *prop)
+static int get_prompt_str(struct gstr *r, struct property *prop, struct menu
+			  **jumps, int jump_nb)
 {
 	int i, j;
-	struct menu *submenu[8], *menu;
+	char header[4];
+	struct menu *submenu[8], *menu, *location = NULL;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
 	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
@@ -521,13 +523,34 @@ static void get_prompt_str(struct gstr *r, struct property *prop)
 		str_append(r, "\n");
 	}
 	menu = prop->menu->parent;
-	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent)
+	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
+		bool accessible = menu_is_visible(menu);
+
 		submenu[i++] = menu;
+		if (location == NULL && accessible)
+			location = menu;
+	}
+	if (jumps && jump_nb < JUMP_NB && location) {
+		if (menu_is_visible(prop->menu)) {
+			/*
+			 * There is not enough room to put the hint at the
+			 * beginning of the "Prompt" line. Put the hint on the
+			 * last "Location" line even when it would belong on
+			 * the former.
+			 */
+			jumps[jump_nb] = prop->menu;
+		} else
+			jumps[jump_nb] = location;
+		snprintf(header, 4, "(%d)", jump_nb + 1);
+	} else
+		location = NULL;
+
 	if (i > 0) {
 		str_printf(r, _("  Location:\n"));
-		for (j = 4; --i >= 0; j += 2) {
+		for (j = 1; --i >= 0; j += 2) {
 			menu = submenu[i];
-			str_printf(r, "%*c-> %s", j, ' ', _(menu_get_prompt(menu)));
+			str_printf(r, "%s%*c-> %s", menu == location ? header
+				   : "   ", j, ' ', _(menu_get_prompt(menu)));
 			if (menu->sym) {
 				str_printf(r, " (%s [=%s])", menu->sym->name ?
 					menu->sym->name : _("<choice>"),
@@ -536,12 +559,20 @@ static void get_prompt_str(struct gstr *r, struct property *prop)
 			str_append(r, "\n");
 		}
 	}
+
+	return location ? 1 : 0;
 }
 
-void get_symbol_str(struct gstr *r, struct symbol *sym)
+/*
+ * jumps is optional and may be NULL
+ * returns the number of jumps inserted
+ */
+int get_symbol_str(struct gstr *r, struct symbol *sym, struct menu **jumps,
+		   int jump_nb)
 {
 	bool hit;
 	struct property *prop;
+	int i = 0;
 
 	if (sym && sym->name) {
 		str_printf(r, "Symbol: %s [=%s]\n", sym->name,
@@ -557,7 +588,7 @@ void get_symbol_str(struct gstr *r, struct symbol *sym)
 		}
 	}
 	for_all_prompts(sym, prop)
-		get_prompt_str(r, prop);
+		i += get_prompt_str(r, prop, jumps, jump_nb + i);
 	hit = false;
 	for_all_properties(sym, prop, P_SELECT) {
 		if (!hit) {
@@ -575,16 +606,18 @@ void get_symbol_str(struct gstr *r, struct symbol *sym)
 		str_append(r, "\n");
 	}
 	str_append(r, "\n\n");
+
+	return i;
 }
 
-struct gstr get_relations_str(struct symbol **sym_arr)
+struct gstr get_relations_str(struct symbol **sym_arr, struct menu **jumps)
 {
 	struct symbol *sym;
 	struct gstr res = str_new();
-	int i;
+	int i, jump_nb = 0;
 
 	for (i = 0; sym_arr && (sym = sym_arr[i]); i++)
-		get_symbol_str(&res, sym);
+		jump_nb += get_symbol_str(&res, sym, jumps, jump_nb);
 	if (!i)
 		str_append(&res, _("No matches found.\n"));
 	return res;
@@ -603,5 +636,5 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 	}
 	str_printf(help, "%s\n", _(help_text));
 	if (sym)
-		get_symbol_str(help, sym);
+		get_symbol_str(help, sym, NULL, 0);
 }

commit 57e6292da67c30acf92f08604f918192a886838a
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Aug 3 21:52:07 2011 -0400

    kconfig: factor code in menu_get_ext_help()
    
    Cc: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index beeb92e75f8f..8c2a97e60faf 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -10,8 +10,7 @@
 
 #include "lkc.h"
 
-static const char nohelp_text[] = N_(
-	"There is no help available for this option.\n");
+static const char nohelp_text[] = "There is no help available for this option.";
 
 struct menu rootmenu;
 static struct menu **last_entry_ptr;
@@ -595,15 +594,14 @@ struct gstr get_relations_str(struct symbol **sym_arr)
 void menu_get_ext_help(struct menu *menu, struct gstr *help)
 {
 	struct symbol *sym = menu->sym;
+	const char *help_text = nohelp_text;
 
 	if (menu_has_help(menu)) {
 		if (sym->name)
 			str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
-		str_append(help, _(menu_get_help(menu)));
-		str_append(help, "\n");
-	} else {
-		str_append(help, nohelp_text);
+		help_text = menu_get_help(menu);
 	}
+	str_printf(help, "%s\n", _(help_text));
 	if (sym)
 		get_symbol_str(help, sym);
 }

commit 3f198dfee49d2e9c30583c62b0c79286c78c7b44
Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
Date:   Tue Aug 2 18:49:52 2011 +0100

    kbuild: Fix help text not displayed in choice option.
    
    Help text under choice menu is never displayed because it does not have
    symbol name associated with it, however many kconfigs have help text
    under choice, assuming that it will be displayed when user selects help.
    for example in Kconfig if we have:
    choice
            prompt "Choice"
            ---help---
               HELP TEXT ...
    
    config A
            bool "A"
    
    config B
            bool "B"
    
    endchoice
    
    Without this patch "HELP TEXT" is not displayed when user selects help
    option when "Choice" is highlighted from menuconfig or xconfig or
    gconfig.
    
    This patch changes the logic in menu_get_ext_help to display help for
    cases which dont have symbol names like choice.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Reviewed-by: Stuart Menefy <stuart.menefy@st.com>
    Reviewed-by: Arnaud Lacombe <lacombar@gmail.com>
    Cc: stable@kernel.org
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index d66008639a43..beeb92e75f8f 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -597,11 +597,10 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 	struct symbol *sym = menu->sym;
 
 	if (menu_has_help(menu)) {
-		if (sym->name) {
+		if (sym->name)
 			str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
-			str_append(help, _(menu_get_help(menu)));
-			str_append(help, "\n");
-		}
+		str_append(help, _(menu_get_help(menu)));
+		str_append(help, "\n");
 	} else {
 		str_append(help, nohelp_text);
 	}

commit ec6452a5ec68498221a0ced3443cefd65b08be36
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 8 01:42:11 2011 -0400

    kconfig: do not overwrite symbol direct dependency in assignment
    
    Considering the following configuration:
    
    config F
        bool "F"
    
    choice AB
        bool "AB"
    config A
        bool "A"
    config B
        bool "B"
    endchoice
    
    if A
    config D
        bool
        default y if F
        select E
    config E
        bool "E"
    endif
    
    if B
    config D
        bool
        default y if F
        select E
    config E
        bool "E"
    endif
    
    The following configuration:
    
     CONFIG_F=y
     CONFIG_A=y
     # CONFIG_B is not set
     CONFIG_D=y
     CONFIG_E=y
    
    emits a spurious warning:
    
    (D) selects E which has unmet direct dependencies (B)
    
    If a symbol appears in two different branch of the tree, it should inherit the
    dependency of both parent, not just the last one.
    
    Reported-by: Yann E. Morin <yann.morin.1998@anciens.enib.fr>
    Tested-by: Yann E. Morin <yann.morin.1998@anciens.enib.fr>
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index aab5a1fee5a8..d66008639a43 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -351,7 +351,7 @@ void menu_finalize(struct menu *parent)
 			last_menu->next = NULL;
 		}
 
-		sym->dir_dep.expr = parent->dep;
+		sym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);
 	}
 	for (menu = parent->list; menu; menu = menu->next) {
 		if (sym && sym_is_choice(sym) &&

commit 5a6f8d2bd9e3392569ed6f29ea4d7210652f929b
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:14:47 2011 -0400

    kconfig: nuke LKC_DIRECT_LINK cruft
    
    This interface is not (and has never been ?) used by any frontend, just get rid
    of it.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 24547fe0fe9e..aab5a1fee5a8 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -8,7 +8,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define LKC_DIRECT_LINK
 #include "lkc.h"
 
 static const char nohelp_text[] = N_(

commit dd003306a4fae241e1f9cac5bef2c8f2afeb0446
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:06:22 2011 -0400

    kconfig: add missing <ctype.h> inclusion
    
    This header is needed when using isspace(3) function family.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index d64108bc0cf9..24547fe0fe9e 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -3,6 +3,7 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <ctype.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>

commit 10a4b2772e7643247ddb5316c644f1fe7c4dccca
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Wed Jun 1 16:00:46 2011 -0400

    kconfig: add missing <stdarg.h> inclusion
    
    This header is needed when using va_{start,end,copy}(3) functions family.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 5fdf10dc1d8a..d64108bc0cf9 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -3,6 +3,7 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 

commit f28b1c8aaa97a68028bb894bffb1690185c62b01
Merge: 0c05384a5a1a 39177ec36236
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 10 08:28:17 2011 -0800

    Merge branch 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'kconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      nconf: handle comment entries within choice/endchoice
      kconfig: fix warning
      kconfig: Make expr_copy() take a const argument
      kconfig: simplify select-with-unmet-direct-dependency warning
      kconfig: add more S_INT and S_HEX consistency checks
      kconfig: fix `zconfdebug' extern declaration
      kconfig/conf: merge duplicate switch's case
      kconfig: fix typos
      kbuild/gconf: add dummy inline for bind_textdomain_codeset()
      kbuild/nconf: fix spaces damage
      kconfig: nuke second argument of conf_write_symbol()
      kconfig: do not define AUTOCONF_INCLUDED
      kconfig: the day kconfig warns about "select"-abuse has come

commit 7ad1227818f09242cfe9bf1845fd24211f5f99bd
Author: Jan Beulich <JBeulich@novell.com>
Date:   Thu Dec 9 08:11:38 2010 +0000

    kconfig: fix undesirable side effect of adding "visible" menu attribute
    
    This lead to non-selected, non-user-selectable options to be written
    out to .config. This is not only pointless, but also preventing the
    user to be prompted should any of those options eventually become
    visible (e.g. by de-selecting the *_AUTO options the "visible"
    attribute was added for.
    
    Furthermore it is quite logical for the "visible" attribute of a menu
    to control the visibility of all contained prompts, which is what the
    patch does.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b9d9aa18e6d6..5f77dcb8977e 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -140,6 +140,20 @@ struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *e
 		}
 		if (current_entry->prompt && current_entry != &rootmenu)
 			prop_warn(prop, "prompt redefined");
+
+		/* Apply all upper menus' visibilities to actual prompts. */
+		if(type == P_PROMPT) {
+			struct menu *menu = current_entry;
+
+			while ((menu = menu->parent) != NULL) {
+				if (!menu->visibility)
+					continue;
+				prop->visible.expr
+					= expr_alloc_and(prop->visible.expr,
+							 menu->visibility);
+			}
+		}
+
 		current_entry->prompt = prop;
 	}
 	prop->text = prompt;

commit ab60bd0b92ec57c98df08616b7d0664be5551eae
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Dec 5 01:29:25 2010 -0500

    kconfig: add more S_INT and S_HEX consistency checks
    
    This patch add more number consistency checkg, trying to catch the following
    situation:
    
    config FOO0
            hex
            default 42
    
    config FOO1
            string
    
    config BAR0
            int
            default FOO1
    
    config BAR1
            hex
            default FOO1
    
    config FOO2
            hex
            default 42h
    
    config FOO3
            int
            default "1bar"
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7e83aef42c6d..8a8bc9be7831 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -183,7 +183,7 @@ void menu_add_option(int token, char *arg)
 	}
 }
 
-static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)
+static int menu_validate_number(struct symbol *sym, struct symbol *sym2)
 {
 	return sym2->type == S_INT || sym2->type == S_HEX ||
 	       (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));
@@ -201,6 +201,15 @@ static void sym_check_prop(struct symbol *sym)
 				prop_warn(prop,
 				    "default for config symbol '%s'"
 				    " must be a single symbol", sym->name);
+			if (prop->expr->type != E_SYMBOL)
+				break;
+			sym2 = prop_get_symbol(prop);
+			if (sym->type == S_HEX || sym->type == S_INT) {
+				if (!menu_validate_number(sym, sym2))
+					prop_warn(prop,
+					    "'%s': number is invalid",
+					    sym->name);
+			}
 			break;
 		case P_SELECT:
 			sym2 = prop_get_symbol(prop);
@@ -220,8 +229,8 @@ static void sym_check_prop(struct symbol *sym)
 			if (sym->type != S_INT && sym->type != S_HEX)
 				prop_warn(prop, "range is only allowed "
 				                "for int or hex symbols");
-			if (!menu_range_valid_sym(sym, prop->expr->left.sym) ||
-			    !menu_range_valid_sym(sym, prop->expr->right.sym))
+			if (!menu_validate_number(sym, prop->expr->left.sym) ||
+			    !menu_validate_number(sym, prop->expr->right.sym))
 				prop_warn(prop, "range is invalid");
 			break;
 		default:

commit 86e187ff9bce9fbed7bfed92ae34f491cf1af50f
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sat Nov 6 18:30:23 2010 -0300

    kconfig: add an option to determine a menu's visibility
    
    This option is aimed to add the possibility to control a menu's visibility
    without adding dependency to the expression to all the submenu.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Tested-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7e83aef42c6d..b9d9aa18e6d6 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -152,6 +152,12 @@ struct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr
 	return menu_add_prop(type, prompt, NULL, dep);
 }
 
+void menu_add_visibility(struct expr *expr)
+{
+	current_entry->visibility = expr_alloc_and(current_entry->visibility,
+	    expr);
+}
+
 void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
 {
 	menu_add_prop(type, NULL, expr, dep);
@@ -410,6 +416,11 @@ bool menu_is_visible(struct menu *menu)
 	if (!menu->prompt)
 		return false;
 
+	if (menu->visibility) {
+		if (expr_calc_value(menu->visibility) == no)
+			return no;
+	}
+
 	sym = menu->sym;
 	if (sym) {
 		sym_calc_value(sym);

commit 239060b93bb30a4ad55f1ecaa512464a035cc5ba
Merge: 1408b15b9863 e9203c988234
Author: Michal Marek <mmarek@suse.cz>
Date:   Tue Oct 12 15:09:06 2010 +0200

    Merge branch 'kbuild/rc-fixes' into kbuild/kconfig
    
    We need to revert the temporary hack in 71ebc01, hence the merge.

commit ff5ff6060bf880aac233e68dd666cbe9e39ec620
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sun Sep 26 16:22:03 2010 -0400

    kconfig: delay symbol direct dependency initialization
    
    This fixes the use-after-free and associated crash in kconfig introduced
    in commit 246cf9c26bf11f2bffbecea6e5bd222eee7b1df8.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 4fb590247f33..edda8b49619d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -107,7 +107,6 @@ static struct expr *menu_check_dep(struct expr *e)
 void menu_add_dep(struct expr *dep)
 {
 	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
-	current_entry->dir_dep = current_entry->dep;
 }
 
 void menu_set_type(int type)
@@ -291,10 +290,6 @@ void menu_finalize(struct menu *parent)
 		for (menu = parent->list; menu; menu = menu->next)
 			menu_finalize(menu);
 	} else if (sym) {
-		/* ignore inherited dependencies for dir_dep */
-		sym->dir_dep.expr = expr_transform(expr_copy(parent->dir_dep));
-		sym->dir_dep.expr = expr_eliminate_dups(sym->dir_dep.expr);
-
 		basedep = parent->prompt ? parent->prompt->visible.expr : NULL;
 		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
 		basedep = expr_eliminate_dups(expr_transform(basedep));
@@ -325,6 +320,8 @@ void menu_finalize(struct menu *parent)
 			parent->next = last_menu->next;
 			last_menu->next = NULL;
 		}
+
+		sym->dir_dep.expr = parent->dep;
 	}
 	for (menu = parent->list; menu; menu = menu->next) {
 		if (sym && sym_is_choice(sym) &&

commit ba6ff60d5eb47d52f1a5eb0bb6ffa751be838c46
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sat Sep 4 16:05:15 2010 -0400

    kconfig: don't emit warning upon rootmenu's prompt redefinition
    
    This silences the warning printed upon prompt redefinition for the rootmenu.
    We will encounter this redefinition when a "mainmenu" statement is specified and
    override the default prompt.
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 682045a7aae4..23acbdb2fd50 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -139,7 +139,7 @@ struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *e
 			while (isspace(*prompt))
 				prompt++;
 		}
-		if (current_entry->prompt)
+		if (current_entry->prompt && current_entry != &rootmenu)
 			prop_warn(prop, "prompt redefined");
 		current_entry->prompt = prop;
 	}

commit 652cf9821d2a5b22a1725ce8dc235ea5de0e1c6f
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sat Aug 14 23:51:40 2010 -0400

    kconfig: rephrase help texts/comments not to include the package name
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Randy Dunlap <rdunlap@xenotime.net>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 64da30c76894..682045a7aae4 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -10,7 +10,7 @@
 #include "lkc.h"
 
 static const char nohelp_text[] = N_(
-	"There is no help available for this kernel option.\n");
+	"There is no help available for this option.\n");
 
 struct menu rootmenu;
 static struct menu **last_entry_ptr;

commit ffb5957bc48f64f0773fd3fbc43cb9bb9b38e270
Author: Arnaud Lacombe <lacombar@gmail.com>
Date:   Sat Aug 14 23:57:43 2010 -0400

    kconfig: allow build-time definition of the internal config prefix
    
    Signed-off-by: Arnaud Lacombe <lacombar@gmail.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 4fb590247f33..64da30c76894 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -566,7 +566,7 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 
 	if (menu_has_help(menu)) {
 		if (sym->name) {
-			str_printf(help, "CONFIG_%s:\n\n", sym->name);
+			str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
 			str_append(help, _(menu_get_help(menu)));
 			str_append(help, "\n");
 		}

commit 59e89e3ddf8523be39a8e0a66bacbbdd6a72d069
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 31 23:35:29 2010 +0200

    kconfig: save location of config symbols
    
    When we add a new config symbol save the file/line
    so we later can refer to their location.
    
    The information is saved as a property to a config symbol
    because we may have multiple definitions of the same symbol.
    
    This has the side-effect that a symbol always has
    at least one property.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 11799894f3bd..4fb590247f33 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -58,6 +58,8 @@ void menu_add_entry(struct symbol *sym)
 	*last_entry_ptr = menu;
 	last_entry_ptr = &menu->next;
 	current_entry = menu;
+	if (sym)
+		menu_add_symbol(P_SYMBOL, sym, NULL);
 }
 
 void menu_end_entry(void)

commit 246cf9c26bf11f2bffbecea6e5bd222eee7b1df8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jun 8 17:25:57 2010 +0100

    kbuild: Warn on selecting symbols with unmet direct dependencies
    
    The "select" statement in Kconfig files allows the enabling of options
    even if they have unmet direct dependencies (i.e. "depends on" expands
    to "no"). Currently, the "depends on" clauses are used in calculating
    the visibility but they do not affect the reverse dependencies in any
    way.
    
    The patch introduces additional tracking of the "depends on" statements
    and prints a warning on selecting an option if its direct dependencies
    are not met.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index eef17bacb6bc..11799894f3bd 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -105,6 +105,7 @@ static struct expr *menu_check_dep(struct expr *e)
 void menu_add_dep(struct expr *dep)
 {
 	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
+	current_entry->dir_dep = current_entry->dep;
 }
 
 void menu_set_type(int type)
@@ -288,6 +289,10 @@ void menu_finalize(struct menu *parent)
 		for (menu = parent->list; menu; menu = menu->next)
 			menu_finalize(menu);
 	} else if (sym) {
+		/* ignore inherited dependencies for dir_dep */
+		sym->dir_dep.expr = expr_transform(expr_copy(parent->dir_dep));
+		sym->dir_dep.expr = expr_eliminate_dups(sym->dir_dep.expr);
+
 		basedep = parent->prompt ? parent->prompt->visible.expr : NULL;
 		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
 		basedep = expr_eliminate_dups(expr_transform(basedep));

commit 3fb9acb3297f5e1170f3e45a18cc3f8b1fd1901a
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri May 7 13:57:07 2010 +0800

    kconfig: fix to tag NEW symbols correctly
    
    Those configs are not new:
    
      $ cat .config
      ...
      CONFIG_NAMESPACES=y
      ...
      CONFIG_BLOCK=y
      ...
    
    But are tagged as NEW:
    
      $ yes "" | make config > myconf
      $ cat myconf | grep '(NEW)'
      Namespaces support (NAMESPACES) [Y/?] (NEW) y
      ...
      Enable the block layer (BLOCK) [Y/?] (NEW) y
      ...
    
    You can also notice this bug when using gconfig/xconfig.
    
    It's because the SYMBOL_DEF_USER bit of an invisible symbol is cleared
    when the config file is read:
    
    int conf_read(const char *name)
    {
            ...
            for_all_symbols(i, sym) {
                    if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
                            /* Reset values of generates values, so they'll appear
                             * as new, if they should become visible, but that
                             * doesn't quite work if the Kconfig and the saved
                             * configuration disagree.
                             */
                            if (sym->visible == no && !conf_unsaved)
                                    sym->flags &= ~SYMBOL_DEF_USER;
            ...
    }
    
    But a menu item which represents an invisible symbol is still
    visible, if it's sub-menu is visible, so its SYMBOL_DEF_USER
    bit should be set to indicate it's not NEW.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 9d1f2adf2289..eef17bacb6bc 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -419,9 +419,13 @@ bool menu_is_visible(struct menu *menu)
 	if (!sym || sym_get_tristate_value(menu->sym) == no)
 		return false;
 
-	for (child = menu->list; child; child = child->next)
-		if (menu_is_visible(child))
+	for (child = menu->list; child; child = child->next) {
+		if (menu_is_visible(child)) {
+			if (sym)
+				sym->flags |= SYMBOL_DEF_USER;
 			return true;
+		}
+	}
 
 	return false;
 }

commit 70ed074718a6704ac2f82d014f372ba25c42ba12
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri May 7 13:56:50 2010 +0800

    kconfig: print the range of integer/hex symbol in help text
    
    Without this patch, one has to refer to the Kconfig file to find
    out the range of an integer/hex symbol.
    
       Symbol: NR_CPUS [=4]
       Type  : integer
       Range : [2 8]
       Prompt: Maximum number of CPUs
         Defined at arch/x86/Kconfig:761
         Depends on: SMP [=y] && !MAXSMP [=n]
         Location:
           -> Processor type and features
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 187caa9142fd..9d1f2adf2289 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -505,6 +505,14 @@ void get_symbol_str(struct gstr *r, struct symbol *sym)
 		str_printf(r, "Symbol: %s [=%s]\n", sym->name,
 			   sym_get_string_value(sym));
 		str_printf(r, "Type  : %s\n", sym_type_name(sym->type));
+		if (sym->type == S_INT || sym->type == S_HEX) {
+			prop = sym_get_range_prop(sym);
+			if (prop) {
+				str_printf(r, "Range : ");
+				expr_gstr_print(prop->expr, r);
+				str_append(r, "\n");
+			}
+		}
 	}
 	for_all_prompts(sym, prop)
 		get_prompt_str(r, prop);

commit b040b44c35c251882da8488a5f038435a531312c
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri May 7 13:56:33 2010 +0800

    kconfig: print symbol type in help text
    
    Randy suggested to print out the symbol type in gconfig.
    
    Note this change does more than Randy's suggestion, that it also
    affects menuconfig and "make config".
    
       Symbol: BLOCK [=y]
       Type  : boolean
       Prompt: Enable the block layer
         Defined at block/Kconfig:4
         Depends on: EMBEDDED [=n]
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 203632cc30bd..187caa9142fd 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -501,9 +501,11 @@ void get_symbol_str(struct gstr *r, struct symbol *sym)
 	bool hit;
 	struct property *prop;
 
-	if (sym && sym->name)
+	if (sym && sym->name) {
 		str_printf(r, "Symbol: %s [=%s]\n", sym->name,
 			   sym_get_string_value(sym));
+		str_printf(r, "Type  : %s\n", sym_type_name(sym->type));
+	}
 	for_all_prompts(sym, prop)
 		get_prompt_str(r, prop);
 	hit = false;

commit 22c7eca61e51296643bb0a379fc726fda8f3b015
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 14 11:46:02 2010 +0800

    menuconfig: add support to show hidden options which have prompts
    
    Usage:
      Press <Z> to show all config symbols which have prompts.
    
    Quote Tim Bird:
    
    | I've been bitten by this numerous times.  I most often
    | use ftrace on ARM, but when I go back to x86, I almost
    | always go through a sequence of searching for the
    | function graph tracer in the menus, then realizing it's
    | completely missing until I disable CC_OPTIMIZE_FOR_SIZE.
    |
    | Is there any way to have the menu item appear, but be
    | unsettable unless the SIZE option is disabled?  I'm
    | not a Kconfig guru...
    
    I myself found this useful too. For example, I need to test
    ftrace/tracing and want to be sure all the tracing features are
    enabled, so I  enter the "Tracers" menu, and press <Z> to
    see if there is any config hidden.
    
    I also noticed gconfig and xconfig have a button "Show all options",
    but that's a bit too much, and I think normally what we are not
    interested in those configs which have no prompt thus can't be
    changed by users.
    
    Exmaple:
    
          --- Tracers
          -*-   Kernel Function Tracer
          - -     Kernel Function Graph Tracer
          [*]   Interrupts-off Latency Tracer
          - -   Preemption-off Latency Tracer
          [*]   Sysprof Tracer
    
    Here you can see 2 tracers are not selectable, and then can find
    out how to make them selectable.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 62e3f15ede0f..203632cc30bd 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -390,6 +390,13 @@ void menu_finalize(struct menu *parent)
 	}
 }
 
+bool menu_has_prompt(struct menu *menu)
+{
+	if (!menu->prompt)
+		return false;
+	return true;
+}
+
 bool menu_is_visible(struct menu *menu)
 {
 	struct menu *child;
@@ -398,6 +405,7 @@ bool menu_is_visible(struct menu *menu)
 
 	if (!menu->prompt)
 		return false;
+
 	sym = menu->sym;
 	if (sym) {
 		sym_calc_value(sym);
@@ -407,12 +415,14 @@ bool menu_is_visible(struct menu *menu)
 
 	if (visible != no)
 		return true;
+
 	if (!sym || sym_get_tristate_value(menu->sym) == no)
 		return false;
 
 	for (child = menu->list; child; child = child->next)
 		if (menu_is_visible(child))
 			return true;
+
 	return false;
 }
 

commit 4280eae0990190d190dfa7dab9bca480215d5b19
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 14 11:44:05 2010 +0800

    kconfig: some small fixes
    
    - fix a typo in documentation
    - fix a typo in a printk on error
    - fix comments in dialog_inputbox()
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 21bfb3dbc87a..62e3f15ede0f 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -197,7 +197,7 @@ static void sym_check_prop(struct symbol *sym)
 			if ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&
 			    prop->expr->type != E_SYMBOL)
 				prop_warn(prop,
-				    "default for config symbol '%'"
+				    "default for config symbol '%s'"
 				    " must be a single symbol", sym->name);
 			break;
 		case P_SELECT:

commit 692d97c380c6dce2c35a04c5dcbce4e831a42fa0
Author: nir.tzachar@gmail.com <nir.tzachar@gmail.com>
Date:   Wed Nov 25 12:28:43 2009 +0200

    kconfig: new configuration interface (nconfig)
    
    This patch was inspired by the kernel projects page, where an ncurses
    replacement for menuconfig was mentioned (by Sam Ravnborg).
    
    Building on menuconfig, this patch implements a more modern look
    interface using ncurses and ncurses' satellite libraries (menu, panel,
    form). The implementation does not depend on lxdialog, which is
    currently distributed with the kernel.
    
    Signed-off-by: Nir Tzachar <nir.tzachar@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 059a2465c574..21bfb3dbc87a 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -38,7 +38,7 @@ static void prop_warn(struct property *prop, const char *fmt, ...)
 	va_end(ap);
 }
 
-void menu_init(void)
+void _menu_init(void)
 {
 	current_entry = current_menu = &rootmenu;
 	last_entry_ptr = &rootmenu.list;
@@ -515,6 +515,20 @@ void get_symbol_str(struct gstr *r, struct symbol *sym)
 	str_append(r, "\n\n");
 }
 
+struct gstr get_relations_str(struct symbol **sym_arr)
+{
+	struct symbol *sym;
+	struct gstr res = str_new();
+	int i;
+
+	for (i = 0; sym_arr && (sym = sym_arr[i]); i++)
+		get_symbol_str(&res, sym);
+	if (!i)
+		str_append(&res, _("No matches found.\n"));
+	return res;
+}
+
+
 void menu_get_ext_help(struct menu *menu, struct gstr *help)
 {
 	struct symbol *sym = menu->sym;

commit 4356f4890792a678936c93c9196e8f7742e04535
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Fri Sep 18 12:49:23 2009 -0700

    kbuild: add static to prototypes
    
    Warnings found via gcc -Wmissing-prototypes.
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index b74f74687005..059a2465c574 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -77,7 +77,7 @@ void menu_end_menu(void)
 	current_menu = current_menu->parent;
 }
 
-struct expr *menu_check_dep(struct expr *e)
+static struct expr *menu_check_dep(struct expr *e)
 {
 	if (!e)
 		return e;
@@ -187,7 +187,7 @@ static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)
 	       (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));
 }
 
-void sym_check_prop(struct symbol *sym)
+static void sym_check_prop(struct symbol *sym)
 {
 	struct property *prop;
 	struct symbol *sym2;

commit 4779105e03cdb6639706991081839451d709230b
Author: Cheng Renquan <crquan@gmail.com>
Date:   Sun Jul 12 16:11:46 2009 +0800

    kconfig: make use of menu_get_ext_help in gconfig
    
    Futhermore, gconfig interface lack the "search a symbol" function, do later.
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    [sam: fix SEGV in gconfig]
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 931d782a2392..b74f74687005 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -528,5 +528,6 @@ void menu_get_ext_help(struct menu *menu, struct gstr *help)
 	} else {
 		str_append(help, nohelp_text);
 	}
-	get_symbol_str(help, sym);
+	if (sym)
+		get_symbol_str(help, sym);
 }

commit 6bd5999d1a6166ad357f2ebf5e998ce49a407f62
Author: Cheng Renquan <crquan@gmail.com>
Date:   Sun Jul 12 16:11:44 2009 +0800

    kconfig: add menu_get_ext_help function to display more information
    
    The three functions are moved from mconf.c, then they can be shared in
    all menuconfig & gconfig & xconfig & config.
    
      +void menu_get_ext_help(struct menu *menu, struct gstr *help)
      +static void get_prompt_str(struct gstr *r, struct property *prop)
      +void get_symbol_str(struct gstr *r, struct symbol *sym)
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 07ff8d105c9d..931d782a2392 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -9,6 +9,9 @@
 #define LKC_DIRECT_LINK
 #include "lkc.h"
 
+static const char nohelp_text[] = N_(
+	"There is no help available for this kernel option.\n");
+
 struct menu rootmenu;
 static struct menu **last_entry_ptr;
 
@@ -451,3 +454,79 @@ const char *menu_get_help(struct menu *menu)
 	else
 		return "";
 }
+
+static void get_prompt_str(struct gstr *r, struct property *prop)
+{
+	int i, j;
+	struct menu *submenu[8], *menu;
+
+	str_printf(r, _("Prompt: %s\n"), _(prop->text));
+	str_printf(r, _("  Defined at %s:%d\n"), prop->menu->file->name,
+		prop->menu->lineno);
+	if (!expr_is_yes(prop->visible.expr)) {
+		str_append(r, _("  Depends on: "));
+		expr_gstr_print(prop->visible.expr, r);
+		str_append(r, "\n");
+	}
+	menu = prop->menu->parent;
+	for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent)
+		submenu[i++] = menu;
+	if (i > 0) {
+		str_printf(r, _("  Location:\n"));
+		for (j = 4; --i >= 0; j += 2) {
+			menu = submenu[i];
+			str_printf(r, "%*c-> %s", j, ' ', _(menu_get_prompt(menu)));
+			if (menu->sym) {
+				str_printf(r, " (%s [=%s])", menu->sym->name ?
+					menu->sym->name : _("<choice>"),
+					sym_get_string_value(menu->sym));
+			}
+			str_append(r, "\n");
+		}
+	}
+}
+
+void get_symbol_str(struct gstr *r, struct symbol *sym)
+{
+	bool hit;
+	struct property *prop;
+
+	if (sym && sym->name)
+		str_printf(r, "Symbol: %s [=%s]\n", sym->name,
+			   sym_get_string_value(sym));
+	for_all_prompts(sym, prop)
+		get_prompt_str(r, prop);
+	hit = false;
+	for_all_properties(sym, prop, P_SELECT) {
+		if (!hit) {
+			str_append(r, "  Selects: ");
+			hit = true;
+		} else
+			str_printf(r, " && ");
+		expr_gstr_print(prop->expr, r);
+	}
+	if (hit)
+		str_append(r, "\n");
+	if (sym->rev_dep.expr) {
+		str_append(r, _("  Selected by: "));
+		expr_gstr_print(sym->rev_dep.expr, r);
+		str_append(r, "\n");
+	}
+	str_append(r, "\n\n");
+}
+
+void menu_get_ext_help(struct menu *menu, struct gstr *help)
+{
+	struct symbol *sym = menu->sym;
+
+	if (menu_has_help(menu)) {
+		if (sym->name) {
+			str_printf(help, "CONFIG_%s:\n\n", sym->name);
+			str_append(help, _(menu_get_help(menu)));
+			str_append(help, "\n");
+		}
+	} else {
+		str_append(help, nohelp_text);
+	}
+	get_symbol_str(help, sym);
+}

commit 5a1aa8a1aff6191ecc55f21d8b5f0e47108ed91b
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Feb 29 05:11:50 2008 +0100

    kconfig: add named choice group
    
    As choice dependency are now fully checked, it's quite easy to add support
    for named choices. This lifts the restriction that a choice value can only
    appear once, although it still has to be within the same group,
    but multiple choices can be joined by giving them a name.
    While at it I cleaned up a little the choice type logic to simplify it a
    bit.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 606ceb9e746e..07ff8d105c9d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -235,18 +235,22 @@ void menu_finalize(struct menu *parent)
 	sym = parent->sym;
 	if (parent->list) {
 		if (sym && sym_is_choice(sym)) {
-			/* find the first choice value and find out choice type */
-			for (menu = parent->list; menu; menu = menu->next) {
-				if (menu->sym) {
-					current_entry = parent;
-					if (sym->type == S_UNKNOWN)
+			if (sym->type == S_UNKNOWN) {
+				/* find the first choice value to find out choice type */
+				current_entry = parent;
+				for (menu = parent->list; menu; menu = menu->next) {
+					if (menu->sym && menu->sym->type != S_UNKNOWN) {
 						menu_set_type(menu->sym->type);
-					current_entry = menu;
-					if (menu->sym->type == S_UNKNOWN)
-						menu_set_type(sym->type);
-					break;
+						break;
+					}
 				}
 			}
+			/* set the type of the remaining choice values */
+			for (menu = parent->list; menu; menu = menu->next) {
+				current_entry = menu;
+				if (menu->sym && menu->sym->type == S_UNKNOWN)
+					menu_set_type(sym->type);
+			}
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
 			parentdep = parent->prompt->visible.expr;
@@ -313,50 +317,36 @@ void menu_finalize(struct menu *parent)
 		}
 	}
 	for (menu = parent->list; menu; menu = menu->next) {
-		if (sym && sym_is_choice(sym) && menu->sym) {
+		if (sym && sym_is_choice(sym) &&
+		    menu->sym && !sym_is_choice_value(menu->sym)) {
+			current_entry = menu;
 			menu->sym->flags |= SYMBOL_CHOICEVAL;
 			if (!menu->prompt)
 				menu_warn(menu, "choice value must have a prompt");
 			for (prop = menu->sym->prop; prop; prop = prop->next) {
-				if (prop->type == P_PROMPT && prop->menu != menu) {
-					prop_warn(prop, "choice values "
-					    "currently only support a "
-					    "single prompt");
-				}
 				if (prop->type == P_DEFAULT)
 					prop_warn(prop, "defaults for choice "
-					    "values not supported");
+						  "values not supported");
+				if (prop->menu == menu)
+					continue;
+				if (prop->type == P_PROMPT &&
+				    prop->menu->parent->sym != sym)
+					prop_warn(prop, "choice value used outside its choice group");
 			}
-			current_entry = menu;
-			if (menu->sym->type == S_UNKNOWN)
-				menu_set_type(sym->type);
 			/* Non-tristate choice values of tristate choices must
 			 * depend on the choice being set to Y. The choice
 			 * values' dependencies were propagated to their
 			 * properties above, so the change here must be re-
-			 * propagated. */
+			 * propagated.
+			 */
 			if (sym->type == S_TRISTATE && menu->sym->type != S_TRISTATE) {
 				basedep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);
-				basedep = expr_alloc_and(basedep, menu->dep);
-				basedep = expr_eliminate_dups(basedep);
-				menu->dep = basedep;
+				menu->dep = expr_alloc_and(basedep, menu->dep);
 				for (prop = menu->sym->prop; prop; prop = prop->next) {
 					if (prop->menu != menu)
 						continue;
-					dep = expr_alloc_and(expr_copy(basedep),
-							     prop->visible.expr);
-					dep = expr_eliminate_dups(dep);
-					dep = expr_trans_bool(dep);
-					prop->visible.expr = dep;
-					if (prop->type == P_SELECT) {
-						struct symbol *es = prop_get_symbol(prop);
-						dep2 = expr_alloc_symbol(menu->sym);
-						dep = expr_alloc_and(dep2,
-								     expr_copy(dep));
-						dep = expr_alloc_or(es->rev_dep.expr, dep);
-						dep = expr_eliminate_dups(dep);
-						es->rev_dep.expr = dep;
-					}
+					prop->visible.expr = expr_alloc_and(expr_copy(basedep),
+									    prop->visible.expr);
 				}
 			}
 			menu_add_symbol(P_CHOICE, sym, NULL);

commit 603d49885e023d1f68c627c2a2db599fb40eefec
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 2 21:09:57 2008 +0100

    kconfig: ignore select of unknown symbol
    
    We have had warnings for a long time about select of unknow symbol
    but the warnings does not really makes sense since we may
    select a symbol that is relevant and defined in one
    arch but not in another arch.
    And as long as we do not use a common set of Kconfig files
    for all archs lets just ignore this case.
    
    Previously we have used this to find bad uses of
    select but we need a more relaible method to do so.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index fdad17367f61..606ceb9e746e 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -203,12 +203,9 @@ void sym_check_prop(struct symbol *sym)
 				prop_warn(prop,
 				    "config symbol '%s' uses select, but is "
 				    "not boolean or tristate", sym->name);
-			else if (sym2->type == S_UNKNOWN)
-				prop_warn(prop,
-				    "'select' used by config symbol '%s' "
-				    "refers to undefined symbol '%s'",
-				    sym->name, sym2->name);
-			else if (sym2->type != S_BOOLEAN && sym2->type != S_TRISTATE)
+			else if (sym2->type != S_UNKNOWN &&
+			         sym2->type != S_BOOLEAN &&
+			         sym2->type != S_TRISTATE)
 				prop_warn(prop,
 				    "'%s' has wrong type. 'select' only "
 				    "accept arguments of boolean and "

commit f5eaa323eb6819d2f737ead42464efccaf2b98b9
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Jan 24 11:54:23 2008 +0000

    kconfig: tristate choices with mixed tristate and boolean values
    
    Change kconfig behavior so that mixing bool and tristate config
    settings in a choice is possible and has the desired effect of offering
    just the tristate options individually if the choice gets set to M, and
    a normal boolean selection if the choice gets set to Y.
    
    Also fix scripts/kconfig/conf's handling of children of choice values -
    there may be more than one immediate child, and all of them need to be
    processed.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Cc: "Roman Zippel" <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index e6ef171e5b14..fdad17367f61 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -242,9 +242,11 @@ void menu_finalize(struct menu *parent)
 			for (menu = parent->list; menu; menu = menu->next) {
 				if (menu->sym) {
 					current_entry = parent;
-					menu_set_type(menu->sym->type);
+					if (sym->type == S_UNKNOWN)
+						menu_set_type(menu->sym->type);
 					current_entry = menu;
-					menu_set_type(sym->type);
+					if (menu->sym->type == S_UNKNOWN)
+						menu_set_type(sym->type);
 					break;
 				}
 			}
@@ -329,7 +331,37 @@ void menu_finalize(struct menu *parent)
 					    "values not supported");
 			}
 			current_entry = menu;
-			menu_set_type(sym->type);
+			if (menu->sym->type == S_UNKNOWN)
+				menu_set_type(sym->type);
+			/* Non-tristate choice values of tristate choices must
+			 * depend on the choice being set to Y. The choice
+			 * values' dependencies were propagated to their
+			 * properties above, so the change here must be re-
+			 * propagated. */
+			if (sym->type == S_TRISTATE && menu->sym->type != S_TRISTATE) {
+				basedep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);
+				basedep = expr_alloc_and(basedep, menu->dep);
+				basedep = expr_eliminate_dups(basedep);
+				menu->dep = basedep;
+				for (prop = menu->sym->prop; prop; prop = prop->next) {
+					if (prop->menu != menu)
+						continue;
+					dep = expr_alloc_and(expr_copy(basedep),
+							     prop->visible.expr);
+					dep = expr_eliminate_dups(dep);
+					dep = expr_trans_bool(dep);
+					prop->visible.expr = dep;
+					if (prop->type == P_SELECT) {
+						struct symbol *es = prop_get_symbol(prop);
+						dep2 = expr_alloc_symbol(menu->sym);
+						dep = expr_alloc_and(dep2,
+								     expr_copy(dep));
+						dep = expr_alloc_or(es->rev_dep.expr, dep);
+						dep = expr_eliminate_dups(dep);
+						es->rev_dep.expr = dep;
+					}
+				}
+			}
 			menu_add_symbol(P_CHOICE, sym, NULL);
 			prop = sym_get_choice_prop(sym);
 			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)

commit 93449082e905ce73d0346d617dd67c4b668b58af
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:50:54 2008 +0100

    kconfig: environment symbol support
    
    Add the possibility to import a value from the environment into kconfig
    via the option syntax. Beside flexibility this has the advantage
    providing proper dependencies.
    Documented the options syntax.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 3637d1057e13..e6ef171e5b14 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -15,7 +15,7 @@ static struct menu **last_entry_ptr;
 struct file *file_list;
 struct file *current_file;
 
-static void menu_warn(struct menu *menu, const char *fmt, ...)
+void menu_warn(struct menu *menu, const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
@@ -172,6 +172,9 @@ void menu_add_option(int token, char *arg)
 		else if (sym_defconfig_list != current_entry->sym)
 			zconf_error("trying to redefine defconfig symbol");
 		break;
+	case T_OPT_ENV:
+		prop_add_env(arg);
+		break;
 	}
 }
 

commit 7a962923359768e04137125bd479fd0dfa6117d3
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jan 14 04:50:23 2008 +0100

    kconfig: explicitly introduce expression list
    
    Rename E_CHOICE to E_LIST to explicitly add support for expression
    lists. Add a helper macro expr_list_for_each_sym to more easily iterate
    over the list.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index e9deebe22eed..3637d1057e13 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -331,7 +331,7 @@ void menu_finalize(struct menu *parent)
 			prop = sym_get_choice_prop(sym);
 			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)
 				;
-			*ep = expr_alloc_one(E_CHOICE, NULL);
+			*ep = expr_alloc_one(E_LIST, NULL);
 			(*ep)->right.sym = menu->sym;
 		}
 		if (menu->list && (!menu->prompt || !menu->prompt->text)) {

commit 01771b0fef0f2cbff80e19295394ece2be1ab661
Author: EGRY Gabor <gaboregry1@t-online.hu>
Date:   Fri Jan 11 23:53:43 2008 +0100

    kconfig: macro fix in menu.c
    
    This patch removes the indirect I18N support for config file.
    
    Signed-off-by: Egry Gabor <gaboregry1@t-online.hu>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index f9d0d91a3fe4..e9deebe22eed 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -394,9 +394,9 @@ bool menu_is_visible(struct menu *menu)
 const char *menu_get_prompt(struct menu *menu)
 {
 	if (menu->prompt)
-		return _(menu->prompt->text);
+		return menu->prompt->text;
 	else if (menu->sym)
-		return _(menu->sym->name);
+		return menu->sym->name;
 	return NULL;
 }
 

commit e8b8c977734193adedf2b0f607d6252c78e86394
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 19 21:25:45 2007 -0700

    Revert "kconfig: tristate choices with mixed tristate and boolean values"
    
    This reverts commit a5bf3d891a6a0fb5aa122792d965e3774108b923.
    
    David Brownell notes that this causes a regression visible in the
    drivers/usb/gadget Kconfig file:
    
      "That Kconfig hasn't changed (other than adding new drivers), and it's
       worked that way for several years now ...  so the issue seems to be
       changes in menuconfig/kconfig/etc semantics.
    
       The issue is that when USB_GADGET=m, it's no longer possible to
       configure peripheral controller drivers as modules ...  the
       controller drivers can now only be configured for static linkage.
    
       It should be making a choice of one of the controller drivers which
       could work on the target system, and allow that driver to be linked
       either as a module (ok iff USB_GADGET=m) or statically."
    
    Reverting this commit resolves the problem, and also fixes a second
    problem that David noticed: various dependent options couldn't be enabled.
    
    Tested-and-reported-by: David Brownell <david-b@pacbell.net>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Jan Beulich <jbeulich@novell.com>,
    Cc: Andrew Morton <akpm@linux-foundation.org>,
    Cc: Sam Ravnborg <sam@ravnborg.org>,
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 7bfa181d6ed6..f9d0d91a3fe4 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -235,23 +235,16 @@ void menu_finalize(struct menu *parent)
 	sym = parent->sym;
 	if (parent->list) {
 		if (sym && sym_is_choice(sym)) {
-			/* find out choice type */
-			enum symbol_type type = S_UNKNOWN;
-
+			/* find the first choice value and find out choice type */
 			for (menu = parent->list; menu; menu = menu->next) {
-				if (menu->sym && menu->sym->type != S_UNKNOWN) {
-					if (type == S_UNKNOWN)
-						type = menu->sym->type;
-					if (type != S_BOOLEAN)
-						break;
-					if (menu->sym->type == S_TRISTATE) {
-						type = S_TRISTATE;
-						break;
-					}
+				if (menu->sym) {
+					current_entry = parent;
+					menu_set_type(menu->sym->type);
+					current_entry = menu;
+					menu_set_type(sym->type);
+					break;
 				}
 			}
-			current_entry = parent;
-			menu_set_type(type);
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
 			parentdep = parent->prompt->visible.expr;
@@ -260,16 +253,7 @@ void menu_finalize(struct menu *parent)
 
 		for (menu = parent->list; menu; menu = menu->next) {
 			basedep = expr_transform(menu->dep);
-			dep = parentdep;
-			if (sym && sym_is_choice(sym) && menu->sym) {
-				enum symbol_type type = menu->sym->type;
-
-				if (type == S_UNKNOWN)
-					type = sym->type;
-			     if (type != S_TRISTATE)
-					dep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);
-			}
-			basedep = expr_alloc_and(expr_copy(dep), basedep);
+			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
 			basedep = expr_eliminate_dups(basedep);
 			menu->dep = basedep;
 			if (menu->sym)
@@ -342,8 +326,7 @@ void menu_finalize(struct menu *parent)
 					    "values not supported");
 			}
 			current_entry = menu;
-			if (menu->sym->type == S_UNKNOWN)
-				menu_set_type(sym->type);
+			menu_set_type(sym->type);
 			menu_add_symbol(P_CHOICE, sym, NULL);
 			prop = sym_get_choice_prop(sym);
 			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)

commit a5bf3d891a6a0fb5aa122792d965e3774108b923
Author: Jan Beulich <jbeulich@novell.com>
Date:   Tue Oct 2 13:46:49 2007 -0700

    kconfig: tristate choices with mixed tristate and boolean values
    
    Change kconfig behavior so that mixing bool and tristate config settings in
    a choice is possible and has the desired effect of offering just the
    tristate options individually if the choice gets set to M, and a normal
    boolean selection if the choice gets set to Y.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index f9d0d91a3fe4..7bfa181d6ed6 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -235,16 +235,23 @@ void menu_finalize(struct menu *parent)
 	sym = parent->sym;
 	if (parent->list) {
 		if (sym && sym_is_choice(sym)) {
-			/* find the first choice value and find out choice type */
+			/* find out choice type */
+			enum symbol_type type = S_UNKNOWN;
+
 			for (menu = parent->list; menu; menu = menu->next) {
-				if (menu->sym) {
-					current_entry = parent;
-					menu_set_type(menu->sym->type);
-					current_entry = menu;
-					menu_set_type(sym->type);
-					break;
+				if (menu->sym && menu->sym->type != S_UNKNOWN) {
+					if (type == S_UNKNOWN)
+						type = menu->sym->type;
+					if (type != S_BOOLEAN)
+						break;
+					if (menu->sym->type == S_TRISTATE) {
+						type = S_TRISTATE;
+						break;
+					}
 				}
 			}
+			current_entry = parent;
+			menu_set_type(type);
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
 			parentdep = parent->prompt->visible.expr;
@@ -253,7 +260,16 @@ void menu_finalize(struct menu *parent)
 
 		for (menu = parent->list; menu; menu = menu->next) {
 			basedep = expr_transform(menu->dep);
-			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
+			dep = parentdep;
+			if (sym && sym_is_choice(sym) && menu->sym) {
+				enum symbol_type type = menu->sym->type;
+
+				if (type == S_UNKNOWN)
+					type = sym->type;
+			     if (type != S_TRISTATE)
+					dep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);
+			}
+			basedep = expr_alloc_and(expr_copy(dep), basedep);
 			basedep = expr_eliminate_dups(basedep);
 			menu->dep = basedep;
 			if (menu->sym)
@@ -326,7 +342,8 @@ void menu_finalize(struct menu *parent)
 					    "values not supported");
 			}
 			current_entry = menu;
-			menu_set_type(sym->type);
+			if (menu->sym->type == S_UNKNOWN)
+				menu_set_type(sym->type);
 			menu_add_symbol(P_CHOICE, sym, NULL);
 			prop = sym_get_choice_prop(sym);
 			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)

commit 03d29122738f0bd81afd44b1f566e64ebf8d06fe
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 21 00:00:36 2007 +0200

    kconfig: attach help text to menus
    
    Roman Zippel wrote:
    > A simple example would be
    > help texts, right now they are per symbol, but they should really be per
    > menu, so archs can provide different help texts for something.
    
    This patch does this and at the same time introduce a few API
    funtions used to access the help text.
    
    The relevant api functions are introduced in the various frontends.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index f14aeac67d4f..f9d0d91a3fe4 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -417,3 +417,15 @@ struct menu *menu_get_parent_menu(struct menu *menu)
 	return menu;
 }
 
+bool menu_has_help(struct menu *menu)
+{
+	return menu->help != NULL;
+}
+
+const char *menu_get_help(struct menu *menu)
+{
+	if (menu->help)
+		return menu->help;
+	else
+		return "";
+}

commit 1e093ecd4a850ad61b93d84c221e342a67ea9d56
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Mon Apr 30 15:44:27 2007 -0400

    kconfig: correct minor typo in Kconfig warning message.
    
    Correct a minor spelling mistake in a Kconfig warning message.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index c86c27f2c761..f14aeac67d4f 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -203,7 +203,7 @@ void sym_check_prop(struct symbol *sym)
 			else if (sym2->type == S_UNKNOWN)
 				prop_warn(prop,
 				    "'select' used by config symbol '%s' "
-				    "refer to undefined symbol '%s'",
+				    "refers to undefined symbol '%s'",
 				    sym->name, sym2->name);
 			else if (sym2->type != S_BOOLEAN && sym2->type != S_TRISTATE)
 				prop_warn(prop,

commit f001f7f89689d3226678ab3986f3a486f54aa069
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:48 2006 -0700

    kconfig: warn about leading whitespace for menu prompts
    
    Kconfig does its own indentation of menu prompts, so warn about and ignore
    leading whitespace.  Remove also a few unnecessary newlines after other
    warning prints.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index a8afce24fb1b..c86c27f2c761 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -114,7 +114,7 @@ void menu_set_type(int type)
 		sym->type = type;
 		return;
 	}
-	menu_warn(current_entry, "type of '%s' redefined from '%s' to '%s'\n",
+	menu_warn(current_entry, "type of '%s' redefined from '%s' to '%s'",
 	    sym->name ? sym->name : "<choice>",
 	    sym_type_name(sym->type), sym_type_name(type));
 }
@@ -124,15 +124,20 @@ struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *e
 	struct property *prop = prop_alloc(type, current_entry->sym);
 
 	prop->menu = current_entry;
-	prop->text = prompt;
 	prop->expr = expr;
 	prop->visible.expr = menu_check_dep(dep);
 
 	if (prompt) {
+		if (isspace(*prompt)) {
+			prop_warn(prop, "leading whitespace ignored");
+			while (isspace(*prompt))
+				prompt++;
+		}
 		if (current_entry->prompt)
-			menu_warn(current_entry, "prompt redefined\n");
+			prop_warn(prop, "prompt redefined");
 		current_entry->prompt = prop;
 	}
+	prop->text = prompt;
 
 	return prop;
 }
@@ -343,11 +348,10 @@ void menu_finalize(struct menu *parent)
 
 	if (sym && !(sym->flags & SYMBOL_WARNED)) {
 		if (sym->type == S_UNKNOWN)
-			menu_warn(parent, "config symbol defined "
-			    "without type\n");
+			menu_warn(parent, "config symbol defined without type");
 
 		if (sym_is_choice(sym) && !parent->prompt)
-			menu_warn(parent, "choice must have a prompt\n");
+			menu_warn(parent, "choice must have a prompt");
 
 		/* Check properties connected to this symbol */
 		sym_check_prop(sym);

commit face4374e288372fba67c865eb0c92337f50d5a4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:45 2006 -0700

    kconfig: add defconfig_list/module option
    
    This makes it possible to change two options which were hardcoded sofar.
    1. Any symbol can now take the role of CONFIG_MODULES
    2. The more useful option is to change the list of default file names,
       which kconfig uses to load the base configuration if .config isn't
       available.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 151ef2168a2c..a8afce24fb1b 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -154,6 +154,20 @@ void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 
 void menu_add_option(int token, char *arg)
 {
+	struct property *prop;
+
+	switch (token) {
+	case T_OPT_MODULES:
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(current_entry->sym);
+		break;
+	case T_OPT_DEFCONFIG_LIST:
+		if (!sym_defconfig_list)
+			sym_defconfig_list = current_entry->sym;
+		else if (sym_defconfig_list != current_entry->sym)
+			zconf_error("trying to redefine defconfig symbol");
+		break;
+	}
 }
 
 static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)

commit f6a88aa86027bdecfc74ef7c6bf6c68233e86bb3
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu Jun 8 22:12:44 2006 -0700

    kconfig: add symbol option config syntax
    
    This adds the general framework to the parser to define options for config
    symbols with a syntax like:
    
    config FOO
            option bar[="arg"]
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 0fce20cb7f3c..151ef2168a2c 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -152,6 +152,10 @@ void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
 }
 
+void menu_add_option(int token, char *arg)
+{
+}
+
 static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)
 {
 	return sym2->type == S_INT || sym2->type == S_HEX ||

commit a02f0570ae201c495ee991b959bb974af18f35cc
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:53 2005 -0800

    [PATCH] kconfig: improve error handling in the parser
    
    Add a few error tokens to the parser to catch common errors and print more
    descriptive error messages.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index c2a423a1c341..0fce20cb7f3c 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -61,10 +61,11 @@ void menu_end_entry(void)
 {
 }
 
-void menu_add_menu(void)
+struct menu *menu_add_menu(void)
 {
-	current_menu = current_entry;
+	menu_end_entry();
 	last_entry_ptr = &current_entry->list;
+	return current_menu = current_entry;
 }
 
 void menu_end_menu(void)

commit 4cf3cbe2a9682242cd38897914b1f2a95f1db7e4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Nov 8 21:34:49 2005 -0800

    [PATCH] kconfig: allow variable argumnts for range
    
    This allows variable arguments in the range option for int and hex config
    symbols.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 5cfa6c405cf0..c2a423a1c341 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -151,6 +151,12 @@ void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
 	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
 }
 
+static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)
+{
+	return sym2->type == S_INT || sym2->type == S_HEX ||
+	       (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));
+}
+
 void sym_check_prop(struct symbol *sym)
 {
 	struct property *prop;
@@ -185,8 +191,8 @@ void sym_check_prop(struct symbol *sym)
 			if (sym->type != S_INT && sym->type != S_HEX)
 				prop_warn(prop, "range is only allowed "
 				                "for int or hex symbols");
-			if (!sym_string_valid(sym, prop->expr->left.sym->name) ||
-			    !sym_string_valid(sym, prop->expr->right.sym->name))
+			if (!menu_range_valid_sym(sym, prop->expr->left.sym) ||
+			    !menu_range_valid_sym(sym, prop->expr->right.sym))
 				prop_warn(prop, "range is invalid");
 			break;
 		default:

commit fb7f6ff614f3ead2ca41bb4a348b9ea431d95176
Author: blaisorblade@yahoo.it <blaisorblade@yahoo.it>
Date:   Thu Jul 28 17:56:25 2005 +0200

    [PATCH] kconfig: trivial cleanup
    
    Replace all menu_add_prop mimicking menu_add_prompt with the latter func. I've
    had to add a return value to menu_add_prompt for one usage.
    
    I've rebuilt scripts/kconfig/zconf.tab.c_shipped by hand to reflect changes
    in the source (I've not the same Bison version so regenerating it wouldn't
    have been not a good idea), and compared it with what Roman itself did some
    time ago, and it's the same.
    
    So I guess this can be finally merged.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 8c59b212722d..5cfa6c405cf0 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -136,9 +136,9 @@ struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *e
 	return prop;
 }
 
-void menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
+struct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
 {
-	menu_add_prop(type, prompt, NULL, dep);
+	return menu_add_prop(type, prompt, NULL, dep);
 }
 
 void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)

commit 3b9fa0931dd86a1fe5507311ee8031650f5d0e8c
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Thu May 5 15:09:46 2005 -0700

    [PATCH] Kconfig i18n support
    
    This patch adds i18n support for make *config, allowing users to have the
    config process in their own language.
    
    No printk was harmed in the process, don't worry, so all the bug reports,
    kernel messages, etc, remain in english, just the user tools to configure
    the kernel are internationalized.
    
    Users not interested in translations can just unset the related LANG,
    LC_ALL, etc env variables and have the config process in plain english,
    something like:
    
    LANG= make menuconfig
    
    is enough for having the whole config process in english. Or just don't
    install any translation file.
    
    Translations for brazilian portuguese are being done by a team of
    volunteers at:
    
    http://www.visionflex.inf.br/kernel_ptbr/pmwiki.php/Principal/Traducoes
    
    To start the translation process:
    
      make update-po-config
    
      This will generate the pot template named scripts/kconfig/linux.pot,
      copy it to, say, ~/es.po, to start the translation for spanish.
    
    To test your translation, as root issue this command:
    
      msgfmt -o /usr/share/locale/es/LC_MESSAGES/linux.mo ~/es.po
    
      Replace "es" with your language code.
    
      Then execute, for instance:
    
      make menuconfig
    
    The current patch doesn't use any optimization to reduce the size of the
    generated .mo file, it is possible to use the config option as a key, but
    this doesn't prevent the current patch from being used or the translations
    done under the current scheme to be in any way lost if we chose to do any
    kind of keying.
    
    Thanks to Fabricio Vaccari for starting the pt_BR (brazilian portuguese)
    translation effort, Thiago Maciera for helping me with the gconf.cc (QT
    frontent) i18n coding and to all the volunteers that are already working on
    the first translation, to pt_BR.
    
    I left the question on whether to ship the translations with the stock kernel
    sources to be discussed here, please share your suggestions.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 0c13156f3344..8c59b212722d 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -365,9 +365,9 @@ bool menu_is_visible(struct menu *menu)
 const char *menu_get_prompt(struct menu *menu)
 {
 	if (menu->prompt)
-		return menu->prompt->text;
+		return _(menu->prompt->text);
 	else if (menu->sym)
-		return menu->sym->name;
+		return _(menu->sym->name);
 	return NULL;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
new file mode 100644
index 000000000000..0c13156f3344
--- /dev/null
+++ b/scripts/kconfig/menu.c
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct menu rootmenu;
+static struct menu **last_entry_ptr;
+
+struct file *file_list;
+struct file *current_file;
+
+static void menu_warn(struct menu *menu, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	fprintf(stderr, "%s:%d:warning: ", menu->file->name, menu->lineno);
+	vfprintf(stderr, fmt, ap);
+	fprintf(stderr, "\n");
+	va_end(ap);
+}
+
+static void prop_warn(struct property *prop, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	fprintf(stderr, "%s:%d:warning: ", prop->file->name, prop->lineno);
+	vfprintf(stderr, fmt, ap);
+	fprintf(stderr, "\n");
+	va_end(ap);
+}
+
+void menu_init(void)
+{
+	current_entry = current_menu = &rootmenu;
+	last_entry_ptr = &rootmenu.list;
+}
+
+void menu_add_entry(struct symbol *sym)
+{
+	struct menu *menu;
+
+	menu = malloc(sizeof(*menu));
+	memset(menu, 0, sizeof(*menu));
+	menu->sym = sym;
+	menu->parent = current_menu;
+	menu->file = current_file;
+	menu->lineno = zconf_lineno();
+
+	*last_entry_ptr = menu;
+	last_entry_ptr = &menu->next;
+	current_entry = menu;
+}
+
+void menu_end_entry(void)
+{
+}
+
+void menu_add_menu(void)
+{
+	current_menu = current_entry;
+	last_entry_ptr = &current_entry->list;
+}
+
+void menu_end_menu(void)
+{
+	last_entry_ptr = &current_menu->next;
+	current_menu = current_menu->parent;
+}
+
+struct expr *menu_check_dep(struct expr *e)
+{
+	if (!e)
+		return e;
+
+	switch (e->type) {
+	case E_NOT:
+		e->left.expr = menu_check_dep(e->left.expr);
+		break;
+	case E_OR:
+	case E_AND:
+		e->left.expr = menu_check_dep(e->left.expr);
+		e->right.expr = menu_check_dep(e->right.expr);
+		break;
+	case E_SYMBOL:
+		/* change 'm' into 'm' && MODULES */
+		if (e->left.sym == &symbol_mod)
+			return expr_alloc_and(e, expr_alloc_symbol(modules_sym));
+		break;
+	default:
+		break;
+	}
+	return e;
+}
+
+void menu_add_dep(struct expr *dep)
+{
+	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
+}
+
+void menu_set_type(int type)
+{
+	struct symbol *sym = current_entry->sym;
+
+	if (sym->type == type)
+		return;
+	if (sym->type == S_UNKNOWN) {
+		sym->type = type;
+		return;
+	}
+	menu_warn(current_entry, "type of '%s' redefined from '%s' to '%s'\n",
+	    sym->name ? sym->name : "<choice>",
+	    sym_type_name(sym->type), sym_type_name(type));
+}
+
+struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)
+{
+	struct property *prop = prop_alloc(type, current_entry->sym);
+
+	prop->menu = current_entry;
+	prop->text = prompt;
+	prop->expr = expr;
+	prop->visible.expr = menu_check_dep(dep);
+
+	if (prompt) {
+		if (current_entry->prompt)
+			menu_warn(current_entry, "prompt redefined\n");
+		current_entry->prompt = prop;
+	}
+
+	return prop;
+}
+
+void menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
+{
+	menu_add_prop(type, prompt, NULL, dep);
+}
+
+void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
+{
+	menu_add_prop(type, NULL, expr, dep);
+}
+
+void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
+{
+	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
+}
+
+void sym_check_prop(struct symbol *sym)
+{
+	struct property *prop;
+	struct symbol *sym2;
+	for (prop = sym->prop; prop; prop = prop->next) {
+		switch (prop->type) {
+		case P_DEFAULT:
+			if ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&
+			    prop->expr->type != E_SYMBOL)
+				prop_warn(prop,
+				    "default for config symbol '%'"
+				    " must be a single symbol", sym->name);
+			break;
+		case P_SELECT:
+			sym2 = prop_get_symbol(prop);
+			if (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)
+				prop_warn(prop,
+				    "config symbol '%s' uses select, but is "
+				    "not boolean or tristate", sym->name);
+			else if (sym2->type == S_UNKNOWN)
+				prop_warn(prop,
+				    "'select' used by config symbol '%s' "
+				    "refer to undefined symbol '%s'",
+				    sym->name, sym2->name);
+			else if (sym2->type != S_BOOLEAN && sym2->type != S_TRISTATE)
+				prop_warn(prop,
+				    "'%s' has wrong type. 'select' only "
+				    "accept arguments of boolean and "
+				    "tristate type", sym2->name);
+			break;
+		case P_RANGE:
+			if (sym->type != S_INT && sym->type != S_HEX)
+				prop_warn(prop, "range is only allowed "
+				                "for int or hex symbols");
+			if (!sym_string_valid(sym, prop->expr->left.sym->name) ||
+			    !sym_string_valid(sym, prop->expr->right.sym->name))
+				prop_warn(prop, "range is invalid");
+			break;
+		default:
+			;
+		}
+	}
+}
+
+void menu_finalize(struct menu *parent)
+{
+	struct menu *menu, *last_menu;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *parentdep, *basedep, *dep, *dep2, **ep;
+
+	sym = parent->sym;
+	if (parent->list) {
+		if (sym && sym_is_choice(sym)) {
+			/* find the first choice value and find out choice type */
+			for (menu = parent->list; menu; menu = menu->next) {
+				if (menu->sym) {
+					current_entry = parent;
+					menu_set_type(menu->sym->type);
+					current_entry = menu;
+					menu_set_type(sym->type);
+					break;
+				}
+			}
+			parentdep = expr_alloc_symbol(sym);
+		} else if (parent->prompt)
+			parentdep = parent->prompt->visible.expr;
+		else
+			parentdep = parent->dep;
+
+		for (menu = parent->list; menu; menu = menu->next) {
+			basedep = expr_transform(menu->dep);
+			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
+			basedep = expr_eliminate_dups(basedep);
+			menu->dep = basedep;
+			if (menu->sym)
+				prop = menu->sym->prop;
+			else
+				prop = menu->prompt;
+			for (; prop; prop = prop->next) {
+				if (prop->menu != menu)
+					continue;
+				dep = expr_transform(prop->visible.expr);
+				dep = expr_alloc_and(expr_copy(basedep), dep);
+				dep = expr_eliminate_dups(dep);
+				if (menu->sym && menu->sym->type != S_TRISTATE)
+					dep = expr_trans_bool(dep);
+				prop->visible.expr = dep;
+				if (prop->type == P_SELECT) {
+					struct symbol *es = prop_get_symbol(prop);
+					es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,
+							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
+				}
+			}
+		}
+		for (menu = parent->list; menu; menu = menu->next)
+			menu_finalize(menu);
+	} else if (sym) {
+		basedep = parent->prompt ? parent->prompt->visible.expr : NULL;
+		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
+		basedep = expr_eliminate_dups(expr_transform(basedep));
+		last_menu = NULL;
+		for (menu = parent->next; menu; menu = menu->next) {
+			dep = menu->prompt ? menu->prompt->visible.expr : menu->dep;
+			if (!expr_contains_symbol(dep, sym))
+				break;
+			if (expr_depends_symbol(dep, sym))
+				goto next;
+			dep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);
+			dep = expr_eliminate_dups(expr_transform(dep));
+			dep2 = expr_copy(basedep);
+			expr_eliminate_eq(&dep, &dep2);
+			expr_free(dep);
+			if (!expr_is_yes(dep2)) {
+				expr_free(dep2);
+				break;
+			}
+			expr_free(dep2);
+		next:
+			menu_finalize(menu);
+			menu->parent = parent;
+			last_menu = menu;
+		}
+		if (last_menu) {
+			parent->list = parent->next;
+			parent->next = last_menu->next;
+			last_menu->next = NULL;
+		}
+	}
+	for (menu = parent->list; menu; menu = menu->next) {
+		if (sym && sym_is_choice(sym) && menu->sym) {
+			menu->sym->flags |= SYMBOL_CHOICEVAL;
+			if (!menu->prompt)
+				menu_warn(menu, "choice value must have a prompt");
+			for (prop = menu->sym->prop; prop; prop = prop->next) {
+				if (prop->type == P_PROMPT && prop->menu != menu) {
+					prop_warn(prop, "choice values "
+					    "currently only support a "
+					    "single prompt");
+				}
+				if (prop->type == P_DEFAULT)
+					prop_warn(prop, "defaults for choice "
+					    "values not supported");
+			}
+			current_entry = menu;
+			menu_set_type(sym->type);
+			menu_add_symbol(P_CHOICE, sym, NULL);
+			prop = sym_get_choice_prop(sym);
+			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)
+				;
+			*ep = expr_alloc_one(E_CHOICE, NULL);
+			(*ep)->right.sym = menu->sym;
+		}
+		if (menu->list && (!menu->prompt || !menu->prompt->text)) {
+			for (last_menu = menu->list; ; last_menu = last_menu->next) {
+				last_menu->parent = parent;
+				if (!last_menu->next)
+					break;
+			}
+			last_menu->next = menu->next;
+			menu->next = menu->list;
+			menu->list = NULL;
+		}
+	}
+
+	if (sym && !(sym->flags & SYMBOL_WARNED)) {
+		if (sym->type == S_UNKNOWN)
+			menu_warn(parent, "config symbol defined "
+			    "without type\n");
+
+		if (sym_is_choice(sym) && !parent->prompt)
+			menu_warn(parent, "choice must have a prompt\n");
+
+		/* Check properties connected to this symbol */
+		sym_check_prop(sym);
+		sym->flags |= SYMBOL_WARNED;
+	}
+
+	if (sym && !sym_is_optional(sym) && parent->prompt) {
+		sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr,
+				expr_alloc_and(parent->prompt->visible.expr,
+					expr_alloc_symbol(&symbol_mod)));
+	}
+}
+
+bool menu_is_visible(struct menu *menu)
+{
+	struct menu *child;
+	struct symbol *sym;
+	tristate visible;
+
+	if (!menu->prompt)
+		return false;
+	sym = menu->sym;
+	if (sym) {
+		sym_calc_value(sym);
+		visible = menu->prompt->visible.tri;
+	} else
+		visible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr);
+
+	if (visible != no)
+		return true;
+	if (!sym || sym_get_tristate_value(menu->sym) == no)
+		return false;
+
+	for (child = menu->list; child; child = child->next)
+		if (menu_is_visible(child))
+			return true;
+	return false;
+}
+
+const char *menu_get_prompt(struct menu *menu)
+{
+	if (menu->prompt)
+		return menu->prompt->text;
+	else if (menu->sym)
+		return menu->sym->name;
+	return NULL;
+}
+
+struct menu *menu_get_root_menu(struct menu *menu)
+{
+	return &rootmenu;
+}
+
+struct menu *menu_get_parent_menu(struct menu *menu)
+{
+	enum prop_type type;
+
+	for (; menu != &rootmenu; menu = menu->parent) {
+		type = menu->prompt ? menu->prompt->type : 0;
+		if (type == P_MENU)
+			break;
+	}
+	return menu;
+}
+
